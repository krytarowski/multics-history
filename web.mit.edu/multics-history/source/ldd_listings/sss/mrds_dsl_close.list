	COMPILATION LISTING OF SEGMENT mrds_dsl_close
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1338.9 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       16*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       17*     This entry is being made to cover the change made on 85-04-19 by Thanh
       18*     Nguyen. (see mrds #136)
       19*  2) change(86-08-13,Hergert), approve(88-07-11,MCR7903),
       20*     audit(88-07-06,Dupuis), install(88-08-01,MR12.2-1073):
       21*     Removed changes installed on 84-11-02 to terminate domain procs. This
       22*     slows things down and really doesnt need to be done.
       23*                                                   END HISTORY COMMENTS */
       24 
       25 
       26 
       27 mrds_dsl_close:
       28 close:
       29      procedure ();
       30 
       31 /* 
       32*                   BEGIN_DESCRIPTION
       33*   This  routine  is  to  be  called  with  "entry options (variable)", with a
       34*   minimum  of  2 arguments, 1) a database index specifying the database to be
       35*   closed,  and 2) an error code to be returned.  More than one database index
       36*   may  be given.  the function performed is to "close" the database specified
       37*   by   the  database  index  that  was  returned  from  a  previous  call  to
       38*   mrds_dsl_open,  making  the  database  unusable  for  an  data manipulation
       39*   operations  such  as  retrieve  or  modify.  if an error occurs, either all
       40*   databases  in  the  list  of indexes, or none will be closed, the list will
       41*   never be partially done.  Note that once the process of actually closing  a
       42*   starts, any errors encountered are reported, but the database is not opened
       43*   again.
       44*                   END_DESCRIPTION
       45*      
       46*   PARAMETERS:
       47*
       48*   database_index  - - (input) fixed bin(35), the integer returned from a call
       49*   to  mrds_dsl_open,  specifying the database which is to be closed.  several
       50*   database indexes may be given.
       51*
       52*   error_code  -  -  (output)  fixed bin(35), error type encoding, 0 unless an
       53*   error occurred.
       54*
       55*   sub_error_  -  - (output) condition, signaled upon occurence of an error to
       56*   provide more info
       57*
       58*
       59*
       60*   HISTORY:
       61*
       62*   76-02-01 R. G. Luebke: Initially written.
       63*
       64*   77-07-01 O. Friesen: Modified to accomodate queued scope requests.
       65*
       66*   77-11-01  R.   D.   Lackey:  Modified  to  add temporary fixed for handling
       67*   dbcb.ret_fd_ptrs
       68*
       69*   77-11-02 R. D. Lackey: Modified to make perm fixed to dbcb ret_fd_ptr
       70*
       71*   79-05-31  Al  Kepner:  Modified to delete the segment for current selection
       72*   expression allocations.
       73*
       74*   79-07-01 Jim Gray : Rewritten to
       75*   1) correct argument processing to leave user in known state upon error
       76*   2) add sub_err_ reporting of errors, and structured error handling
       77*   3) add control file closing logic for transaction mode created databases
       78*   4) avoid calls to finish_file for non-ready files
       79*   5) document the modules logic
       80*   6) allow  handling  of  recursive  invocations,  so can use close as finish
       81*   handler
       82*
       83*   80-02-01   R.   Lackey:  Modified  to  change  call  to  mus_valid_iocb  to
       84*   mcbm_util_$valid_iocb_detach
       85*
       86*   80-03-01  Jim  Gray  :  Modified  to  clear  db indexes used by old version
       87*   close/open.
       88*
       89*   80-09-24 Jim Gray : Modified to correct control string for sub err mesg.
       90*
       91*   80-09-30  Jim  Gray  :  Modified  to correctly get resultant model temp dir
       92*   based on the opening index.
       93*
       94*   80-10-20  Jim Gray : Modified to clean up temp segs now generated by search
       95*   for tid arrays.
       96*
       97*   80-11-03  Jim  Gray  :  Modified to change delete_$ptr to hcs_$delentry_seg
       98*   calls for performance.
       99*
      100*   80-11-10  Jim  Gray  : Modified to change delete_$path to hcs_$del_dir_tree
      101*   and hcs_$delentry_file calls for performance.
      102*
      103*   81-01-29 Jim Gray : removed references to mdbm_data_$current_version, using
      104*   constants instead, to allow for future upgrades to db version.
      105*
      106*   81-04-25  Jim  Gray  :  changed  declaration of mrds_data_$temp_seg_name to
      107*   agree  with  change in mrds_data_, and increased the dbi_pic declaration to
      108*   three digits, as part of increasing the opening capability from 64 to 128.
      109*
      110*   81-05-29  Jim  Gray : modified to use the new resultant structure, also did
      111*   away  with  call  to  mus_valid_iocb,  as  control  file  never used.  Also
      112*   combined   mu_sec_close  into  this  module.   Also  changed  interface  to
      113*   mrds_dsl_finish_file for efficiency.
      114*
      115*   81-07-07  Rickie  E.  Brinegar : Changed calls to release_area_ to calls to
      116*   release_temp_segments  so  that  the temporary segments are returned to the
      117*   temporary segement free pool, and marked as free.
      118*
      119*   82-10-06 Mike Kubicar : converted to use relation manager.  Specifically,
      120*   the call to mrds_dsl_finish_file has been removed as this module has been
      121*   deleted.  All scope deletion, cursor deletion, and relation closing is now
      122*   done by this module.
      123*
      124*   82-10-14 Davids: changed to call mu_cursor_manager_$destroy_all_no_free
      125*   with the dbcb.cursor_ptrs_storage_ptr instead of the cursor_storage_area_ptr.
      126*   Also to not call mu_cursor_manager_ at all if the cursor_ptrs_storage_ptr
      127*   is null.
      128*
      129*   82-10-15 Davids: changed so that the call to mu_cursor_manager_$destroy_all_no_free
      130*   includes as a paramter dbcb.cursor_storage_area_ptr to conform to the new
      131*   calling sequence of the entry.
      132*
      133*   83-01-03 Roger Lackey : Changed in the close_database procedure ,
      134*   call to mu_cursor_manager_$destroy_storage to 
      135*   mu_cursor_manager_$cleanup_storage  the closing of the relation will
      136*   be done in another place in this program.
      137*
      138*   83-01-10  Roger Lackey : Changed to not call dbcb.relmgr_entries.close
      139*   if oid was zero
      140*
      141*   83-01-31  R. Harvey : Removed code to call release_temp_segment_ for the
      142*   dbcb.*_area_ptr used by the 5 main dsl_ entries.
      143*
      144*   83-02-01  Mike Kubicar : Added code to handle transaction processing.
      145*   This is needed only in the delete_temp_rels procedure.  One transaction
      146*   is started for each dm file database to be closed.
      147*
      148*   83-02-02 Davids: Added a call to hcs_$get_uid_seg to compare the uid of the
      149*   segment the dbc_ptr currently points to with what it was originally pointing to.
      150*   If the uids don't match or the uid cannot be obtained it is assumed that the
      151*   original segment has been deleted. Since the segment has been deleted there
      152*   is no need to set the scope_lock or remove the open user so the code is skiped.
      153*   The call to remove_resultant was taken out of the critical region protected
      154*   by the scope lock since there was no need to have it protected. 
      155*
      156*   83-03-11 Davids: Added calls to mu_temp_segments$delete_temp_segment to delete
      157*   the MRDS.store, modify, delete, def_tr, and retrv temp segments.
      158*
      159*   83-05-02 Davids: Modified to call mu_temp_segments$free_all_temp_segments or
      160*   delete_all_temp_segments for the curdat, stadat, and selete_area segments
      161*   (created in mrds_dsl_init_res). free is called if the segments were created
      162*   in the pdir (determined by checking dbcb.resultant_in_pdir). delete is
      163*   called for any other dir.
      164*
      165*   83-05-04 Davids: Modified to remove the calls to delete the 5 dsl temp
      166*   segments, the modules that get those temp segments now use the name
      167*   MRDS || dbi so that they be deleted in 1 fell swoop. Same for deleting
      168*   the rdbi segment, it was made a temp segmenbt with the same name as the
      169*   others. Entries mu_temp_segment$delete_temp_segment and com_err_ were
      170*   deleted.
      171* 
      172*   83-05-05 Davids: Changed calls to free_all_temp_segments to calls to
      173*   release_all_temp_segments. The difference is that a release does a
      174*   truncate to 0 length so that when a temp segment is reused it does
      175*   not see stuff left over from a previous use which becuase mrds expects
      176*   that a temp segment just obtained will be nothing but 0's caused a
      177*   problem.
      178*
      179*   83-05-24 Davids: Renamed the variable info_ptr to unused_ptr because
      180*   the name info_ptr now has a ambiguous reference with a structure
      181*   in the mrds_start_transaction include file and a name change is needed
      182*   in order to compile and second the pointer is never used for anything.
      183*
      184*   83-06-20 Davids: Removed check for old version database and the call
      185*   to v1 code if it was an old version db (old version dbs can no longer
      186*   be opened). Also removed overhead of checking to be sure that old version
      187*   db indicies and new version db indices were not given in the same call -
      188*   minor performance improvement.
      189*
      190*   84-11-02 Thanh Nguyen: Added code to check and terminate all of the
      191*   reference names of the check, encode, or decode procedure.
      192*
      193**/
      194 
      195 /* check for valid argument list */
      196 
      197 	num_ptrs = 0;
      198 	call cu_$arg_list_ptr (al_ptr);		/* get number of arguments */
      199 	nargs = arg_list.desc_count / 2;		/* = arg_count, if called with entry options(variable) */
      200 
      201 	if nargs < 2 then do;
      202 		call
      203 		     sub_err_ (error_table_$wrong_no_of_args, caller_name, continue, unused_ptr, return_value, "^/^a ^d ^a ^a",
      204 		     "The number of arguments =", arg_list.arg_count / 2, "was less than the minimum of 2,",
      205 		     "or the entry was not declared ""options (variable)"".");
      206 	     end;
      207 	else do;
      208 
      209 /* initialize the error code argument */
      210 
      211 		if arg_list.code = SPECIAL then
      212 		     desc_index = nargs + 1;
      213 		else desc_index = nargs;
      214 		num_ptrs = desc_index + nargs;	/* arg_list ptr array size */
      215 		desc_ptr = arg_list.arg_des_ptr (desc_index + nargs);
      216 						/* last arg descriptor */
      217 
      218 		if desc_ptr -> descriptor_ovrly ^= fixed_bin_35_descr then
      219 		     call
      220 			sub_err_ (error_table_$bad_arg, caller_name, continue, unused_ptr, return_value, "^/^a",
      221 			"The error code(last) argument is not declared ""fixed binary (35) aligned"".");
      222 		else do;
      223 
      224 			error_code_ptr = arg_list.arg_des_ptr (nargs);
      225 			error_code, code = 0;	/* initialize */
      226 
      227 /* initialize the "databases to be closed" list */
      228 
      229 			work_area_ptr, db_close_list_ptr = null ();
      230 			call get_temp_segment_ (caller_name, work_area_ptr, error_code);
      231 			if error_code ^= 0 then
      232 			     call
      233 				sub_err_ (error_code, caller_name, continue, unused_ptr, return_value, "^/^a",
      234 				"Unable to obtain a temporary segment for work space.");
      235 			else do;
      236 
      237 				work_area_ptr -> work_area = empty ();
      238 				clean_up_condition = OFF;
      239 
      240 				on cleanup
      241 				     begin;	/* in case user does quit/release */
      242 					clean_up_condition = ON;
      243 					if ^substr (db_mrds_dsl_close, 1, 1) then
      244 					     ;
      245 					else on sub_error_ ; /* ignore sub_err_ calls during cleanup */
      246 					call clean_up ();
      247 				     end;
      248 
      249 				on seg_fault_error goto exit; /* in case segment deleted via previous invocation */
      250 
      251 /* process the list of database indexes for databases to be closed,
      252*   making a list to be closed, if the database indexes are valid,
      253*   and are not duplicated, by saving the resultant model pointers */
      254 
      255 				arg_count = 1;
      256 				do while (arg_count < nargs & error_code = 0);
      257 
      258 				     call
      259 					mu_convert_parameter$convert_input_parameter (arg_list.arg_des_ptr (arg_count),
      260 					arg_list.arg_des_ptr (desc_index + arg_count), dbi_ptr, addr (fixed_bin_35_descr), work_area_ptr, error_code);
      261 				     if error_code ^= 0 then do;
      262 					     call
      263 						sub_err_ (error_code, caller_name, continue, unused_ptr, return_value, "^/^a ^d ^a",
      264 						"Database index argument in position", arg_count,
      265 						"could not be converted to ""fixed binary (35) aligned"".");
      266 					end;
      267 
      268 /* make sure that this database index refers to a currently open database */
      269 
      270 				     else if ^valid_index () then
      271 					;
      272 
      273 /* check for list duplicates */
      274 
      275 				     else if ^unique_index () then
      276 					;
      277 
      278 /* add the index, and it's resultant model pointer to the close list */
      279 
      280 				     else call add_index ();
      281 
      282 /* advance to the next database index argument */
      283 
      284 				     arg_count = arg_count + 1;
      285 
      286 				end;
      287 
      288 				if error_code ^= 0 then
      289 				     ;
      290 				else do;
      291 
      292 /* process the list of valid/unique databases to be closed */
      293 
      294 					proc_id = get_process_id_ ();
      295 
      296 					do db_close_ptr = db_close_list_ptr repeat db_close.next while (db_close_ptr ^= null ());
      297 
      298 /* when this point is successfully reached, all databases in the "close list"
      299*   will be forcefully closed, that is closing will go to completion, ignoring
      300*   errors encountered, with only the first error encountered being returned
      301*   in the error code(others reported via sub_err_), and an error upon closing
      302*   the first database in the list will not affect later closings
      303*   this allows close to be used as a finish/cleanup handler & leaves user in known state */
      304 
      305 					     call close_database ();
      306 
      307 					end;
      308 				     end;
      309 
      310 /* get rid of the "close list" now that processing is complete */
      311 
      312 exit:
      313 				call clean_up ();
      314 
      315 			     end;
      316 		     end;
      317 	     end;
      318 
      319 valid_index:
      320      procedure () returns (bit (1));
      321 
      322 /* check that the current database index refers to a database open by this process
      323*   and set a pointer to the resultant model if the index is good */
      324 
      325 	call mu_database_index$get_resultant_model_pointer (db_index, dbcb_ptr);
      326 						/* look up db in table */
      327 
      328 	if dbcb_ptr ^= null () then
      329 	     valid = ON;
      330 
      331 	else do;
      332 		valid = OFF;
      333 		error_code = mrds_error_$invalid_db_index;
      334 		call
      335 		     sub_err_ (error_code, caller_name, continue, unused_ptr, return_value, "^/^a ^d ^a", "The database index =", db_index,
      336 		     "does not refer to a database open by this process.");
      337 	     end;
      338 
      339 
      340 	return (valid);
      341 
      342 
      343 	dcl     valid		 bit (1);		/* on => good index */
      344 
      345      end;
      346 
      347 unique_index:
      348      procedure () returns (bit (1));
      349 
      350 /* check that this index has not apeared before in the close list */
      351 
      352 	unique = ON;
      353 
      354 	do db_close_ptr = db_close_list_ptr repeat db_close.next while (db_close_ptr ^= null () & error_code = 0);
      355 
      356 	     if db_close.index ^= db_index then
      357 		;
      358 	     else do;
      359 
      360 		     unique = OFF;
      361 		     error_code = mrds_error_$list_duplicate;
      362 		     call
      363 			sub_err_ (error_code, caller_name, continue, unused_ptr, return_value, "^/^a ^d ^a", "The database index =", db_index,
      364 			"appears more than once in the argument list.");
      365 
      366 		end;
      367 
      368 	end;
      369 
      370 
      371 	return (unique);
      372 
      373 
      374 	dcl     unique		 bit (1);		/* on => good index */
      375 
      376      end;
      377 
      378 add_index:
      379      procedure ();
      380 
      381 /* add this index to the list of databases to be closed */
      382 
      383 	allocate db_close set (db_close_ptr) in (work_area);
      384 
      385 	db_close.index = db_index;
      386 	db_close.dbcb_ptr = dbcb_ptr;
      387 	db_close.next = null ();
      388 
      389 /* link into the current list in user order */
      390 
      391 	if db_close_list_ptr = null () then do;		/* first time */
      392 		last_db_close_ptr = db_close_ptr;
      393 		db_close_list_ptr = db_close_ptr;
      394 	     end;
      395 	else do;
      396 		last_db_close_ptr -> db_close.next = db_close_ptr;
      397 		last_db_close_ptr = db_close_ptr;
      398 	     end;
      399 
      400      end;
      401 
      402 close_database:
      403      procedure ();
      404 
      405 /* This routine closes one database per call, using the database index,
      406*   and resultant model pointer passed to it
      407**/
      408 
      409 	dbcb_ptr = db_close.dbcb_ptr;
      410 	close_index = db_close.index;
      411 	rdbi_ptr = dbcb_ptr -> dbcb.rdbi_ptr;
      412 	if rdbi_ptr = null () then
      413 	     ;					/* no secure portion */
      414 	else do;
      415 		rmra_ptr = rm_db_info.ra_ptr;
      416 		secured = "0"b;
      417 		dbc_ptr = dbcb.dbc_ptr;
      418 
      419 /* Files still in the ready state must be cleaned up.  That is, all scopes must
      420*   be deleted in them. */
      421 
      422 		call finish_files ();
      423 
      424 /* temporary relations must be cleaned up */
      425 
      426 		call delete_temp_rels ();
      427 
      428 /* Close all non-temporary relations   */
      429 
      430 		do x = 1 to rm_db_info.ra_ptr -> rm_rel_array.num_rels;
      431 
      432 		     if rm_db_info.ra_ptr -> rm_rel_array.rel_data (x).ri_ptr ^= null then do;
      433 
      434 			     oid = rm_db_info.ra_ptr -> rm_rel_array.rel_data (x).ri_ptr -> rm_rel_info.opening_id;
      435 			     if oid ^= "0"b then do;
      436 				     call dbcb.relmgr_entries.close (oid, code);
      437 				     if code ^= 0 then call sub_err_ (code, caller_name,
      438 					     continue, unused_ptr, return_value, "^/^a  ^a",
      439 					     "Unable to close relation",
      440 					     rm_db_info.ra_ptr -> rm_rel_array.rel_data (x).ri_ptr -> rm_rel_info.name);
      441 				end;
      442 			end;
      443 		end;
      444 
      445 /* Now delete all cursors and close the database */
      446 
      447 		if dbcb.cursor_ptrs_storage_ptr ^= null ()
      448 		then do;
      449 			call mu_cursor_manager_$cleanup_storage (
      450 			     dbcb.cursor_ptrs_storage_ptr, dbcb.cursor_storage_area_ptr, code);
      451 			if code ^= 0
      452 			then call sub_err_ (code, caller_name, continue,
      453 				unused_ptr, return_value,
      454 				"^/Cursor storage could not be deleted.");
      455 		     end;
      456 
      457 /* set scope lock around critical section of database closing */
      458 
      459 		temp_uid = "0"b;
      460 		call hcs_$get_uid_seg (dbc_ptr, temp_uid, code);
      461 		if code = 0 & dbcb.dbc_uid = temp_uid
      462 		then do;
      463 			call set_lock_$lock (dbc.scope_lock, mrds_data_$lock_wait_time, code);
      464 			if code ^= 0 & /* allow recursion into this critical region */
      465 			     ^(code = error_table_$invalid_lock_reset | code = error_table_$locked_by_this_process) then do;
      466 				dbc.trouble_switch = "1"b;
      467 				error_code = mrds_error_$inconsistent_close;
      468 				call
      469 				     sub_err_ (code, caller_name, continue, unused_ptr, continue, "^/^a ^d",
      470 				     "Unable to set scope lock for this database index =", close_index);
      471 			     end;
      472 			else call remove_open_user ();
      473 			call set_lock_$unlock (dbc.scope_lock, code);
      474 			if code = 0 | code = error_table_$lock_not_locked then
      475 			     ;			/* in case of recursion or locking error */
      476 			else do;
      477 				call
      478 				     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^d",
      479 				     "Unable to unlock scope for database index =", close_index);
      480 				if error_code ^= 0 then
      481 				     ;
      482 				else error_code = code;
      483 			     end;
      484 		     end;
      485 		call remove_resultant ();
      486 
      487 	     end;
      488      end;
      489 
      490 delete_file_scope: procedure ();
      491 
      492 /* remove this files scope prevent and permit operations from the active scopes */
      493 
      494 	scope_ptr = dbcb.scope_ptr;
      495 	dbc_ptr = dbcb.dbc_ptr;
      496 
      497 	if dbc_ptr = null () | scope_ptr = null () then ; /* never set */
      498 	else do;
      499 
      500 		if scope_info.active_scopes = 0 then ;	/* nothing to do */
      501 		else do;
      502 
      503 /* find the file name in the scope array */
      504 
      505 			found = "0"b;
      506 			do i = 1 to scope_info.active_scopes while (^found);
      507 
      508 			     if rm_rel_info.model_name ^= scope_info.scope.name (i) then ;
      509 			     else do;
      510 				     found = "1"b;
      511 
      512 /* set the prevent/permit op codes from the scope for this file */
      513 
      514 				     perm = NO_OP;
      515 				     prev = NO_OP;
      516 
      517 				     if scope_info.scope (i).flags.permits.read_attr then
      518 					perm = perm + READ_ATTR;
      519 				     if scope_info.scope (i).flags.permits.append_tuple then
      520 					perm = perm + APPEND_TUPLE;
      521 				     if scope_info.scope (i).flags.permits.delete_tuple then
      522 					perm = perm + DELETE_TUPLE;
      523 				     if scope_info.scope (i).flags.permits.modify_attr then
      524 					perm = perm + MODIFY_ATTR;
      525 
      526 				     if scope_info.scope (i).flags.prevents.read_attr then
      527 					prev = prev + READ_ATTR;
      528 				     if scope_info.scope (i).flags.prevents.append_tuple then
      529 					prev = prev + APPEND_TUPLE;
      530 				     if scope_info.scope (i).flags.prevents.delete_tuple then
      531 					prev = prev + DELETE_TUPLE;
      532 				     if scope_info.scope (i).flags.prevents.modify_attr then
      533 					prev = prev + MODIFY_ATTR;
      534 
      535 /* go delete the scope for this file */
      536 
      537 				     call mrds_dsl_dl_fscope (dbcb.dbi, scope_info.scope.sm_name (i), perm, prev, code);
      538 				     if code = 0 then ;
      539 				     else if code = mrds_error_$unknown_proc_id then code = 0; /* amdb done on dbc */
      540 				     else do;
      541 					     call sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a^a^a",
      542 						"Unable to delete scope for file """, scope_info.scope.sm_name (i), """ during finish of file.");
      543 					     if error_code ^= 0 then ;
      544 					     else error_code = code;
      545 					end;
      546 
      547 				end;
      548 
      549 			end;
      550 
      551 		     end;
      552 
      553 	     end;
      554 
      555 	declare found		 bit (1);		/* on => file found in scope array, quit search */
      556 	declare (perm, prev)	 fixed bin (35);	/* permit and prevent bits */
      557      end;
      558 
      559 delete_temp_rels:
      560      procedure ();
      561 
      562 
      563 /*  First of all, start a transaction if necessary */
      564 
      565 	mstxn_transactions_needed = dbcb.transactions_needed;
      566 	mstxn_txn_id = "0"b;
      567 	on cleanup call mstxn_cleanup;
      568 	on any_other call mstxn_any_other;
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      569 
      570 	if mstxn_code ^= 0
      571 	then call sub_err_ (mstxn_code, caller_name, continue, unused_ptr,
      572 		return_value, "^/A transaction could not be started for database index ^d.  ^/Error occurred while releasing tempory relation storage.", close_index);
      573 
      574 	dbcb.user_started_transaction = user_started_transaction;
      575 
      576 /* delete any temporary relation definitions remaining */
      577 
      578 	if rm_db_info.tra_ptr -> rm_rel_array.num_rels > 0 then do;
      579 
      580 /* Close all the open temporary relations */
      581 
      582 		call mrds_dsl_define_temp_rel$del_trels (dbcb_ptr); /* delete any temp rels */
      583 
      584 /* now remove the storage areas for temporary relations, now that they are no longer needed */
      585 
      586 		if dbcb.retr_info_ptr = null () & dbcb.trel_info_ptr = null () then
      587 		     ;
      588 		else do;
      589 
      590 			resultant_dir = mrds_dsl_resultant_storage$get_opening_temp_dir (close_index, code);
      591 			if code ^= 0 then do;
      592 				if error_code ^= 0 then
      593 				     ;
      594 				else error_code = code;
      595 				call
      596 				     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^d",
      597 				     "Unable to get the resultant model temporary directory for database index =",
      598 				     close_index);
      599 			     end;
      600 			else do;
      601 
      602 				do x = 1 by 1 to mrds_data_$max_sets;
      603 
      604 				     if dbcb.retr_info_ptr = null () then
      605 					;
      606 				     else do;
      607 
      608 					     fd_ptr = retrieve_info.ret_fd_ptr (x);
      609 					     if fd_ptr = null () then
      610 						;
      611 					     else do;
      612 						     vfile_type = "retrieve info";
      613 						     call delete_vfile_seg ();
      614 						     retrieve_info.ret_fd_ptr (x) = null ();
      615 						end;
      616 
      617 					end;
      618 
      619 				     if dbcb.trel_info_ptr = null () then
      620 					;
      621 				     else do;
      622 
      623 					     fd_ptr = trel_info.fd_ptr (x);
      624 					     if fd_ptr = null () then
      625 						;
      626 					     else do;
      627 						     vfile_type = "temp rel info";
      628 						     call delete_vfile_seg ();
      629 						     trel_info.fd_ptr (x) = null ();
      630 						end;
      631 					end;
      632 				end;
      633 			     end;
      634 		     end;
      635 
      636 	     end;
      637 
      638 /* Finish the transaction.  If an error occurred, ignore it */
      639 
      640 	mftxn_code = 0;
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      641 
      642 	if mftxn_code ^= 0
      643 	then call sub_err_ (mftxn_code, caller_name, continue, unused_ptr,
      644 		return_value, "^/A transaction could not be finished for database index ^d.  ^/Error occurred while releasing tempory relation storage.", close_index);
      645 
      646 
      647 /***********
      648**
      649**   These routines are used by the transaction processing include files.
      650**   Restore_significant_data is called to reinitialize variables in case
      651**   of a rollback.  Should_rollback determines whether a transaction should
      652**   be rolled back or aborted on error.  Currently, it is always aborted.
      653**
      654***********/
      655 
      656 
      657 restore_significant_data:
      658      proc;
      659      end restore_significant_data;
      660 
      661 
      662 
      663 should_rollback:
      664      proc returns (bit (1));
      665 	return ("0"b);
      666 						/* There are no known cirumstances where a rollback is meaningful */
      667      end should_rollback;
      668 
      669 
      670      end delete_temp_rels;
      671 
      672 finish_files:
      673      procedure ();
      674 
      675 /* delete scopes on all files that the user has left still readied */
      676 
      677 	do j = 1 to rm_rel_array.num_rels;
      678 
      679 	     rmri_ptr = rm_rel_array.rel_data (j).ri_ptr;
      680 	     call delete_file_scope ();
      681 
      682 /* any errors were reported in the lower routine */
      683 
      684 	     if code = 0 | error_code ^= 0 then
      685 		;
      686 	     else error_code = code;
      687 
      688 	end;
      689 
      690 
      691      end;
      692 
      693 remove_open_user:
      694      procedure ();
      695 
      696 /* take this user out of the list of database openers */
      697 
      698 	ul_ptr = pointer (dbc_ptr, dbc.open_users_ofs);
      699 
      700 /* find the user in the list of database openers */
      701 
      702 	do while (rel (ul_ptr) ^= NULL_OFFSET);
      703 
      704 	     next_ul_ptr = pointer (dbc_ptr, user_list.next_open_ofs);
      705 
      706 /* is this the right user in the list */
      707 
      708 	     if user_list.process_id ^= proc_id then
      709 		;
      710 	     else do;
      711 
      712 /* check that this is the right opening instance for this user in the user list */
      713 
      714 		     if user_list.rdbi_bits ^= addr (rdbi_ptr) -> ptr_bit_string then
      715 			;
      716 		     else do;
      717 
      718 /* correct opening instance, remove the user from the list of openers */
      719 
      720 			     call mu_de_queue_user (DQ_OPEN, FREE_FIL_LIST, dbc_ptr, ul_ptr, code);
      721 			     if code = 0 | code = error_table_$locked_by_this_process then
      722 				;		/* allow recursion */
      723 			     else do;
      724 				     if error_code ^= 0 then
      725 					;
      726 				     else error_code = code;
      727 				     call
      728 					sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^d",
      729 					"Unable to remove this user from the list of database openers for database index =", close_index);
      730 				end;
      731 
      732 			     next_ul_ptr = pointer (null, NULL_OFFSET); /* set to exit loop */
      733 
      734 			end;
      735 
      736 		end;
      737 
      738 /* go to next user in open list */
      739 
      740 	     ul_ptr = next_ul_ptr;
      741 	end;
      742 
      743 
      744      end;
      745 
      746 remove_resultant:
      747      procedure ();
      748 
      749 /* the secure and non-secure portions of the resultant model
      750*   must be removed, since they are no longer needed */
      751 
      752 
      753 /* close the secure portion of the resultant */
      754 
      755 	if rdbi_ptr ^= null ()			/* clean up the extensible area */
      756 	then call release_area_ (addr (rdbi_ptr -> rm_db_info.static_area));
      757 
      758 	dbi_pic = dbcb.dbi;				/* format db opening index */
      759 
      760 /* cleanup most of the temp segements created */
      761 
      762 	if dbcb.resultant_in_pdir			/* segments in pdir may be resused */
      763 	then call mu_temp_segments$release_all_temp_segments ("MRDS" || dbi_pic, code);
      764 	else call mu_temp_segments$delete_all_temp_segments ("MRDS" || dbi_pic, code);
      765 	if code ^= 0 & code ^= error_table_$argerr
      766 	then call sub_err_ (code, caller_name, continue, unused_ptr, return_value,
      767 		"Could not clean up the temp segments created.");
      768 
      769 /* cleanup the rest */
      770 
      771 	temp_seg_name = mrds_data_$temp_seg_name || dbi_pic; /* name for temp segs */
      772 	if dbcb.resultant_in_pdir
      773 	then call mu_temp_segments$release_all_temp_segments (temp_seg_name, code);
      774 	else call mu_temp_segments$delete_all_temp_segments (temp_seg_name, code);
      775 	if code ^= 0 & code ^= error_table_$argerr
      776 	then call sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^a",
      777 		"Unable to release tid array search temp segs using the name:", temp_seg_name);
      778 
      779 
      780 	call mu_database_index$reset_resultant_model_pointer (close_index, (dbcb_ptr));
      781 						/* clear table entry */
      782 	call hcs_$delentry_seg (dbcb_ptr, code);	/* delete dbcb */
      783 	if code = 0 | code = error_table_$invalidsegno then
      784 	     ;					/* previous invocation could have deleted */
      785 	else do;
      786 		if error_code ^= 0 then
      787 		     ;
      788 		else error_code = code;
      789 		call
      790 		     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^d ",
      791 		     "Unable to delete the resultant model non-secure segment for database index =", close_index);
      792 	     end;
      793 	dbcb_ptr = null ();
      794      end;
      795 
      796 delete_vfile_seg:
      797      procedure ();
      798 
      799 /* routine to close, detach, and delete a vfile */
      800 
      801 	if fd.iocb_ptr = null () then
      802 	     ;
      803 	else do;
      804 
      805 		call iox_$close (fd.iocb_ptr, code);
      806 		if code = 0 then
      807 		     ;
      808 		else do;
      809 			if error_code ^= 0 then
      810 			     ;
      811 			else error_code = code;
      812 			call
      813 			     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^a ^a ^d", "Unable to close a", vfile_type,
      814 			     "vfile for database index =", close_index);
      815 		     end;
      816 
      817 		call iox_$detach_iocb (fd.iocb_ptr, code);
      818 		if code = 0 then
      819 		     ;
      820 		else do;
      821 			if error_code ^= 0 then
      822 			     ;
      823 			else error_code = code;
      824 			call
      825 			     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^a ^a ^d", "Unable to detach a", vfile_type,
      826 			     "vfile for database index =", close_index);
      827 		     end;
      828 
      829 		call iox_$destroy_iocb (fd.iocb_ptr, code);
      830 		if code = 0 then
      831 		     ;
      832 		else do;
      833 			if error_code ^= 0 then
      834 			     ;
      835 			else error_code = code;
      836 			call
      837 			     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^a ^a ^d", "Unable to destroy a", vfile_type,
      838 			     "vfile iocb for database index =", close_index);
      839 		     end;
      840 
      841 		fd.iocb_ptr = null ();
      842 
      843 		if fd.name = BLANK then
      844 		     ;
      845 		else do;
      846 
      847 			begin;
      848 
      849 			     call hcs_$del_dir_tree (resultant_dir, (fd.name), code);
      850 			     if code = error_table_$notadir | code = 0 then
      851 				call hcs_$delentry_file (resultant_dir, (fd.name), code);
      852 
      853 			     dcl	   hcs_$del_dir_tree      entry (char (*), char (*), fixed bin (35));
      854 						/* deletes sub directory contents */
      855 			     dcl	   hcs_$delentry_file     entry (char (*), char (*), fixed bin (35));
      856 						/* deletes segs and empty dirs */
      857 			     dcl	   error_table_$notadir   fixed bin (35) ext; /* entry was not a directory */
      858 
      859 			end;
      860 
      861 			if code = 0 then
      862 			     ;
      863 			else do;
      864 				if error_code ^= 0 then
      865 				     ;
      866 				else error_code = code;
      867 				call
      868 				     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a^a^a ^a ^a ^d",
      869 				     "Unable to delete the segment """, fd.name, """ for a", vfile_type, "vfile for database index =", close_index);
      870 			     end;
      871 
      872 			fd.name = BLANK;
      873 
      874 		     end;
      875 
      876 	     end;
      877 
      878 
      879      end;
      880 
      881 clean_up:
      882      procedure ();
      883 
      884 /* remove the "close list" working area */
      885 
      886 	if work_area_ptr = null () then
      887 	     ;
      888 	else do;
      889 
      890 		call release_temp_segment_ (caller_name, work_area_ptr, code);
      891 		if code = 0 then
      892 		     ;
      893 		else do;
      894 			if error_code ^= 0 then
      895 			     ;
      896 			else error_code = code;
      897 			call
      898 			     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a",
      899 			     "Unable to release the working space temporary segment.");
      900 		     end;
      901 
      902 		work_area_ptr = null ();
      903 
      904 	     end;
      905 
      906 
      907 
      908 
      909      end;
      910 
      911 	dcl     db_index		 fixed bin (35) based (dbi_ptr), /* data base index of db to close (input) */
      912 	        error_code		 fixed bin (35) based (error_code_ptr); /* status return error_code */
      913 
      914 	dcl     (
      915 	        nargs,				/* number of args */
      916 	        i,
      917 	        x,
      918 	        j
      919 	        )			 fixed bin;	/* length of argument */
      920 
      921 	dcl     resultant_dir	 char (168);	/* resultant model directory pathname */
      922 	dcl     secured		 bit (1) unal;	/* on if db is secured */
      923 
      924 	dcl     proc_id		 bit (36) aligned;	/* process id for this user */
      925 
      926 	dcl     (dbi_ptr, error_code_ptr) ptr;
      927 
      928 	dcl     next_ul_ptr		 ptr;		/* ptr to next user_list entry */
      929 	dcl     ptr_bit_string	 bit (72) unal based; /* bit string format of pointer */
      930 	dcl     code		 fixed bin (35);	/* internal status code */
      931 
      932 	dcl     never_readied	 bit (36) init ((36)"0"b); /* if file_array.id = this, then never readied */
      933 	dcl     temp_uid		 bit (36) aligned;	/* uid of segment that dbc_ptr currently points to */
      934 
      935 /*		Multics subroutines 		*/
      936 
      937 	dcl     cu_$arg_list_ptr	 entry (ptr),
      938 	        hcs_$delentry_seg	 entry (ptr, fixed bin (35)), /* deletes segs without ref names */
      939 	        hcs_$get_uid_seg	 entry (ptr, bit (36) aligned, fixed bin (35)),
      940 	        get_process_id_	 entry returns (bit (36)),
      941 	        iox_$close		 entry (ptr, fixed bin (35)),
      942 	        iox_$detach_iocb	 entry (ptr, fixed bin (35)),
      943 	        iox_$destroy_iocb	 entry (ptr, fixed bin (35)),
      944 	        set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35)),
      945 	        set_lock_$unlock	 entry (bit (36) aligned, fixed bin (35));
      946 	dcl     mu_temp_segments$delete_all_temp_segments entry (char (*), fixed bin (35));
      947 						/* cleans up search temp segs */
      948 	dcl     mu_temp_segments$release_all_temp_segments entry (char (*), fixed bin (35));
      949 	dcl     dbi_pic		 pic "999";	/* format for database index in temp seg name */
      950 	dcl     temp_seg_name	 char (26);	/* name used for search temp segs */
      951 
      952 /*		other subroutines		*/
      953 
      954 	dcl     mu_database_index$reset_resultant_model_pointer entry (fixed bin (35), ptr),
      955 	        mu_database_index$get_resultant_model_pointer entry (fixed bin (35), ptr),
      956 	        mrds_dsl_define_temp_rel$del_trels entry (ptr),
      957 	        mu_de_queue_user	 entry (bit (1), bit (1), ptr, ptr, fixed bin (35));
      958 
      959 /*		external data		*/
      960 
      961 	dcl     sub_err_		 entry options (variable); /* error reporting routine */
      962 	dcl     caller_name		 char (15) init ("mrds_dsl_close"); /* name of calling routine */
      963 	dcl     continue		 char (1) init ("c"); /* continue after printing err mesg */
      964 	dcl     unused_ptr		 ptr init (null ());/* unused */
      965 	dcl     return_value	 fixed bin (35) init (0); /* unused */
      966 	dcl     OFF		 bit (1) init ("0"b); /* false */
      967 	dcl     ON		 bit (1) init ("1"b); /* true */
      968 	dcl     1 db_close		 aligned based (db_close_ptr), /* list element for database to close */
      969 		2 next		 ptr,		/* to next database on list */
      970 		2 index		 fixed bin (35),	/* database index */
      971 		2 dbcb_ptr	 ptr;		/* pointer to resultant */
      972 	dcl     db_close_ptr	 ptr;		/* points to close list element */
      973 	dcl     db_close_list_ptr	 ptr;		/* points to head of list */
      974 	dcl     last_db_close_ptr	 ptr;		/* points to last on list */
      975 	dcl     arg_count		 fixed bin;	/* current argument number */
      976 	dcl     mrds_error_$invalid_db_index fixed bin (35) ext,
      977 	        error_table_$wrong_no_of_args fixed bin (35) ext, /* <2 arguments */
      978 	        mrds_error_$list_duplicate fixed bin (35) ext, /* index >1 times in list */
      979 	        mrds_data_$lock_wait_time fixed bin ext,
      980 	        mrds_data_$max_sets	 fixed bin ext,
      981 	        mrds_data_$max_data_length fixed bin ext,
      982 	        mrds_error_$inconsistent_close fixed bin (35) ext,
      983 	        error_table_$locked_by_this_process fixed bin (35) ext,
      984 	        error_table_$invalid_lock_reset fixed bin (35) ext,
      985 	        sys_info$max_seg_size	 fixed bin (35) ext;
      986 	dcl     work_area		 area (1024) based (work_area_ptr); /* space for close list */
      987 	dcl     work_area_ptr	 ptr;		/* points to close list area */
      988 	dcl     get_temp_segment_	 entry (char (*), ptr, fixed bin (35));
      989 						/* gets working space */
      990 	dcl     NOT_READY		 bit (1) init ("0"b); /* file not currently readied */
      991 	dcl     NULL_OFFSET		 bit (18) init ((18)"1"b); /* mrds version of null offset */
      992 	dcl     vfile_type		 char (20) varying; /* retrieve info, or temp rel info */
      993 	dcl     any_other		 condition;
      994 	dcl     cleanup		 condition;	/* signaled during release */
      995 	dcl     clean_up_condition	 bit (1);		/* on => cleanup signaled */
      996 	dcl     BLANK		 char (1) init (" "); /* space character */
      997 	dcl     close_index		 fixed bin (35);	/* local version of db_index */
      998 	dcl     sub_error_		 condition;	/* signaled by sub_err_ call */
      999 	dcl     mrds_error_$unknown_proc_id fixed bin (35) ext; /* Process not known to mrds database */
     1000 	dcl     mrds_data_$temp_seg_name char (23) ext;	/* common name for temp segments */
     1001 	dcl     error_table_$bad_arg	 fixed bin (35) ext;/* bad subroutine argument */
     1002 	dcl     error_table_$argerr	 fixed bin (35) ext;/* given if no temp segs of given name found */
     1003 	dcl     descriptor_ovrly	 bit (36) unal based; /* overlay for descriptor word */
     1004 	dcl     desc_index		 fixed bin;	/* offset to start of descriptor ptrs in arg list */
     1005 	dcl     SPECIAL		 fixed bin init (8);/* => extra ptr in arg_list */
     1006 	dcl     fixed_bin_35_descr	 bit (36) init ("100000100000000000000000000000100011"b);
     1007 						/* descriptor for fixed bin(35) */
     1008 	dcl     seg_fault_error	 condition;	/* signaled when invalid segment number used */
     1009 	dcl     error_table_$lock_not_locked fixed bin (35) ext; /* lock not set */
     1010 	dcl     error_table_$invalidsegno fixed bin (35) ext; /* bad segment number */
     1011 	dcl     mu_convert_parameter$convert_input_parameter entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
     1012 						/* gets db_index  */
     1013 	dcl     mrds_dsl_dl_fscope	 entry options (variable); /* Delete db scopes */
     1014 	dcl     mu_cursor_manager_$cleanup_storage entry (ptr, ptr, fixed bin (35));
     1015 	dcl     release_area_	 entry (ptr);	/* cleans up define_area_ areas */
     1016 	dcl     release_temp_segment_	 entry (char (*), ptr, fixed bin (35));
     1017 						/* removes temp work space */
     1018 	dcl     oid		 bit (36) aligned;
     1019 	dcl     mrds_dsl_resultant_storage$get_opening_temp_dir entry (fixed bin (35), fixed bin (35)) returns (char (168));
     1020 						/* gets temp dir for db_index */
     1021 	dcl     (addr, empty, fixed, null, pointer, rel, substr) builtin;
     1022 
  5     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  5     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  5     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 
  5    12 /* WARNING
  5    13*          If the rm_db_info structure is changed then the mrds_data_
  5    14*          item saved_res_version MUST be incremented to invalidate all
  5    15*          existing saved resultants
  5    16**/
  5    17 
  5    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  5    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  5    20*   resultant model that is created partially at database open  time,
  5    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  5    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  5    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  5    24*   to  provide  an  efficient  means  of  accessing  database  model
  5    25*   information, as seen from the possibly submodel view of the user,
  5    26*   and his current state of "files readied". it is the  secure  part
  5    27*   because  it  contains  the  model  information  which needs to be
  5    28*   protected  from  general  knowledge,  and   this   segment   will
  5    29*   eventually  be  capable  of  being in a lower ring. the structure
  5    30*   itself points to four arrays that are  allocated  in  it's  area,
  5    31*   that  in  turn point to the other structures mentions above, also
  5    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  5    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  5    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  5    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  5    36*   list of all known file names, the rm_rel_array only gets relation
  5    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  5    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  5    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  5    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  5    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  5    42*   file infos point to contained rel infos, the rel infos  point  to
  5    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  5    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  5    45*   foreign     keys    are    represented    by    the    structures
  5    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  5    47*   pathnames  of the model and submodel, if any, are also maintained
  5    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  5    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  5    50*   individual include files for  further  organization  information,
  5    51*   and particular data structures.
  5    52*
  5    53*   HISTORY:
  5    54*
  5    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  5    56*   so that define_area_ could be used to make it an extensible area
  5    57*
  5    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  5    59*   resultant in mu_database_index easier to keep, since no reference
  5    60*   to the area is needed.
  5    61*
  5    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  5    63*   resultant.
  5    64*
  5    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  5    66*   structure.
  5    67*
  5    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  5    69*   are  now  combined  into  the rel_array. Removed the control file
  5    70*   info which was unused. Added pointer  to  head  of  domain  list,
  5    71*   which is to be used to insure only one copy of each domain info.
  5    72*
  5    73*   83-05-19 Davids: Added the  saved_res_version element.
  5    74*
  5    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  5    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  5    77*   check, encode, or decode proc.
  5    78*
  5    79*   CAUTION: The structure entries from db_version to sm_path  should
  5    80*   not  be moved or have their declarations changed because they are
  5    81*   used in the handling of old version database openings.
  5    82*
  5    83*
  5    84**/
  5    85 
  5    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  5    87 	     2 data	      like rm_db_info_data,
  5    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  5    89 
  5    90      dcl	   rdbi_ptr	      ptr;
  5    91 
  5    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  5    93*						   like reference to it without getting the area as well */
  5    94 	     2 db_version	      fixed bin,		/* version no. of db */
  5    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  5    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  5    97 	     2 db_path	      char (168),		/* abs. path of db. */
  5    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  5    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  5   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  5   101 	     2 pad	      bit (34) unal,	/* for future use */
  5   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  5   103*                                                               dbcb and rdbi segments in the db dir */
  5   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  5   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  5   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  5   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  5   108 
  5   109 /* END mdbm_rm_db_info.incl.pl1 */
  5   110 
  5   111 
     1023 
     1024 
  6     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  6     2 
  6     3 /* WARNING
  6     4*          If the rm_rel_info structure is changed then the mrds_data_
  6     5*          item saved_res_version MUST be incremented to invalidate all
  6     6*          existing saved resultants
  6     7**/
  6     8 
  6     9 /* HISTORY:
  6    10*
  6    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  6    12*   attributes,   and   varying  attributes,  so  that  partial  view
  6    13*   submodels will have the  info  needed  to  properly  set  up  the
  6    14*   varying length array headers in the tuple structure.
  6    15*
  6    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  6    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  6    18*   delete_tuple_perm, and make m_perm = unused_perm.
  6    19*
  6    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  6    21*   view attribute was varying character or bit, since a partial view
  6    22*   submodel will not have this information in the resultant, and  it
  6    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  6    24*   since with exact length storage  of  varying  length  attributes,
  6    25*   each  tuple  can  be  a  different  length,  which is can only be
  6    26*   determined by examining the tuple itself.
  6    27*
  6    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  6    29*   interface  to  allow  temp  rel  population  to  be known, and to
  6    30*   provide a more efficient means of finding an approx. current perm
  6    31*   relation population.
  6    32*
  6    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  6    34*   blocked  files, foreign keys, and ids procedures. Also set number
  6    35*   of files per rel to a constant of 1.
  6    36*
  6    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  6    38*   structure so that only one structure per relation is needed.
  6    39*
  6    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  6    41*   counts.   Also  added  number  of  operations  count  since  last
  6    42*   statistics update, and a time  since  the  statistics  were  last
  6    43*   updated.
  6    44*
  6    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  6    46*   identifier so that small relations could be updated on a per S.E.
  6    47*   basis
  6    48*
  6    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  6    50*   to end of structure   TR 12205 (Suggestion).
  6    51*   
  6    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  6    53*   the DMS conversion. 
  6    54*
  6    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  6    56*   array and the niocb element for DMS conversion. Also removed the
  6    57*   number_selected array (and ri_niocbs_init) since subsets are not
  6    58*   going to be used.
  6    59*
  6    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  6    61*   so that it can be used with relation manager.  Also added
  6    62*   rm_rel_info.primary_key_index_id for relation manager.
  6    63*
  6    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  6    65*   nvar_atts, model_nvar_atts.
  6    66*
  6    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  6    68*   since the duplicate key count for each secondary index is now being
  6    69*   kept in the attr_info structure and key_count was only needed to
  6    70*   help in calculating the average selectivity of each index which
  6    71*   can now be gotten directly from each index's dup key count. Also
  6    72*   removed the file_id element since it is no longer needed for
  6    73*   anything.
  6    74*
  6    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  6    76*   was removed.
  6    77*
  6    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  6    79*   used when retrieving tuples from this relation.
  6    80*
  6    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  6    82*   for the relation. Note that this structure is part of the resultant NOT
  6    83*   part of the db.control structure. The scopes are duplicated in the resultant
  6    84*   to reduce contention for the db.control structure. Note also that the pointer
  6    85*   will always point to a scope_flags structure even if no scopes have been
  6    86*   set on the relation, the structure is allocated when the db is opened.
  6    87**/
  6    88 
  6    89 
  6    90 /* DESCRIPTION:
  6    91*
  6    92*   This structure is allocated in the area part of the structure  in
  6    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  6    94*   at open  time  for  a  database.  There  will  be  one  of  these
  6    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  6    96*   database view (there may be less than the total in  the  database
  6    97*   for  a  submodel  openings).  There  will  also  be  one for each
  6    98*   temporary relation currently defined for that opening.
  6    99*
  6   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  6   101*   all  rm_rel_info  structures  allocated. It is used for searching
  6   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  6   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  6   104*   rels.
  6   105*
  6   106*   The      rm_rel_info      structure      points      to       the
  6   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  6   108*   appearing in this view of the relation. Each  of  these  in  turn
  6   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  6   110*   info for each attr.
  6   111*
  6   112*   Most of the other information here deals with  specifics  of  the
  6   113*   relation's  logical  definition,  such as key and secondary index
  6   114*   attribute inidicators, security permissions, and  tuple  physical
  6   115*   construction details.
  6   116*
  6   117**/
  6   118 
  6   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  6   120 	     2 name	      char (32),		/* from submodel */
  6   121 	     2 model_name	      char (30),		/* from model */
  6   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  6   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  6   124 	     2 modify	      bit (1) unal,
  6   125 	     2 delete	      bit (1) unal,
  6   126 	     2 store	      bit (1) unal,
  6   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  6   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  6   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  6   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  6   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  6   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  6   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  6   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  6   135 	     2 reserved	      bit (24) unal,	/* for future use */
  6   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  6   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  6   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  6   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  6   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  6   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  6   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  6   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  6   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  6   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  6   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  6   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  6   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  6   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  6   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  6   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  6   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  6   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  6   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  6   155 
  6   156      dcl	   rmri_ptr	      ptr;
  6   157      dcl	   (nkey_attr_init,
  6   158 	   natts_init,
  6   159 	   nvar_atts_init)	      fixed bin;
  6   160 
  6   161 /* END mdbm_rm_rel_info.incl.pl1 */
  6   162 
  6   163 
     1025 
     1026 
  7     1 /* BEGIN mdbm_rm_rel_array.incl.pl1 -- jaw, 8/9/78 */
  7     2 
  7     3 /* WARNING
  7     4*          If the rm_rel_array structure is changed then the mrds_data_
  7     5*          item saved_res_version MUST be incremented to invalidate all
  7     6*          existing saved resultants
  7     7**/
  7     8 
  7     9 /* HISTORY:
  7    10*
  7    11*   81-05-28 Jim Gray : added  model_name  and  file_id  as  part  of
  7    12*   combining   funtions   of   file_array  and  rel_array  into  one
  7    13*   structure. This will only allow 1 relation per file model now.
  7    14*   Also changed structure to allow more efficient searching
  7    15*   via and index builtin, rather than a programmed loop.
  7    16*   Search is now I = index(string(rm_rel_array.name), "!" || in_name)
  7    17*   with I = ((I - 1) / 33) + 1 to convert from a char to array index.
  7    18*
  7    19**/
  7    20 
  7    21 
  7    22 /* this structure is allocated in the static are of the structure
  7    23*   in  mdbm_rm_db_info.incl.pl1,  the secure portion of the database
  7    24*   resultant  model  upon  opening  the  database.  two  copies  are
  7    25*   allocated,  one for temporary relations, initially empty, and one
  7    26*   for relations known to the opener, which has a length  sufficient
  7    27*   for  all  relations known to the user, but whose names, etc. will
  7    28*   not be filled  in  until  the  file  containing  that  particular
  7    29*   relation  is readied. the rm_db_info structure contains a pointer
  7    30*   to the rel_arrays, and the array entries, when  "readied",  point
  7    31*   to  the  mdbm_rm_rel_info.incl.pl1  structures  containing  model
  7    32*   information about the relation, it's attributes, etc. */
  7    33 
  7    34 dcl 1 rm_rel_array aligned based (rmra_ptr),		/* array of open relations */
  7    35     2 num_rels fixed bin,				/* no. rels in db. */
  7    36     2 name (1:rm_num_rels_init refer (rm_rel_array.num_rels)) unal,
  7    37       3 mark char (1) unal,				/* separator character = "!" */
  7    38       3 submodel char (32) unal,			/* name of relation is submodel view, model opening => model name */
  7    39     2 rel_data (rm_num_rels_init refer (rm_rel_array.num_rels)),
  7    40       3 model_name char (30),				/* name of relation in model */
  7    41       3 ri_ptr ptr unal ;				/* pointer to rm_rel_info */
  7    42 
  7    43 dcl  rmra_ptr ptr;
  7    44 dcl  rm_num_rels_init fixed bin;
  7    45 
  7    46 /* END mdbm_rm_rel_array.incl.pl1 */
  7    47 
  7    48 
     1027 
     1028 
  8     1 /* BEGIN mdbm_scope_info.incl.pl1 -- odf 8/8/78 */
  8     2 
  8     3 /* WARNING
  8     4*          If the scope_info or scope_flags structure is changed then the
  8     5*          mrds_data_ item saved_res_version MUST be incremented to invalidate
  8     6*          all existing saved resultants
  8     7**/
  8     8 
  8     9 /* Modified by Jim Gray - - 80-11-17, to add back store/delete/modify permissions */
  8    10 
  8    11 /* 80-12-10 Jim Gray : change name of store to append_tuple, delete to delete_tuple,
  8    12*   modify to modify_attr, retrieve to read_attr, remvoe update, put level 4
  8    13*   qualifiers for permit/prevent modes and to put pads in standard format */
  8    14 
  8    15 /* 80-12-11 Jim Gray : added submodel version of file/rel name for convenience */
  8    16 
  8    17 /* 80-12-22 Jim Gray : added like referenced structure so linus_scope_data.incl
  8    18*   could make use of it for compatibility. */
  8    19 
  8    20 /* 81-1-11 Jim Gray : added touched bit to scope_flags, so that
  8    21*   the fact that null scope has been set can be displayed */
  8    22 
  8    23 /* 85-04-14 Thanh Nguyen: Made scope_flags to be aligned so we could access the
  8    24*   prevent flags from any pointer which directly pointed to scope_flags itself
  8    25*   (i.e rm_rel_info.scope_flags_ptr). */
  8    26 
  8    27 /* this structure is to be allocated in the mrds_dbcb.incl.pl1 static area,
  8    28*   and is used to maintain the scope mechanism for file access.
  8    29*   It contains the scope permit/prevent operations that this user
  8    30*   has set in his view for this opening instance. */
  8    31 
  8    32 dcl 1 scope_info aligned based (scope_ptr),		/* array of scope tuples for this user */
  8    33     2 mbz1 bit (144),				/* Reserved for future use */
  8    34     2 nfiles fixed bin,				/* Number of scope tuples in user's scope */
  8    35     2 active_scopes fixed bin,			/* number of scopes currently active for a given user */
  8    36     2 scope (max_file_init refer (scope_info.nfiles)),	/* defines user's scope of access to files */
  8    37       3 name char (30) aligned,			/* filename */
  8    38       3 sm_name char (32),				/* name of file(rel) in submodel */
  8    39       3 flags like scope_flags ;
  8    40 
  8    41 
  8    42 declare 1 scope_flags aligned based,			/* common layout of scope flag bits */
  8    43         2 permits,					/* modes to permit this user */
  8    44 	3 read_attr bit (1) unal,			/* read_attr access to this file in scope */
  8    45 	3 append_tuple bit (1) unal,			/* append_tuple concnrrency permission */
  8    46 	3 delete_tuple bit (1) unal,			/* delete_tuple concurrency permission on rel */
  8    47 	3 modify_attr bit (1) unal,			/* modify_attr concurrency permission */
  8    48 	3 mbz2 bit (10) unal,			/* for expansion of permit ops */
  8    49         2 prevents,					/* modes to be denyed to other users */
  8    50 	3 read_attr bit (1) unal,			/* on if user has prevent on read_attr for this file */
  8    51 	3 append_tuple bit (1) unal,			/* prevent of append_tuple concurrency */
  8    52 	3 delete_tuple bit (1) unal,			/* prevent of delete_tuple concurrency */
  8    53 	3 modify_attr bit (1) unal,			/* prevent of modify_attr concurrency */
  8    54 	3 mbz3 bit (10) unal,			/* for future prevent concurrency modes */
  8    55         2 touched bit (1) unal,			/* on => scope set for this relation */
  8    56         2 mbz4 bit (7) unal ;				/* for future flags */
  8    57 
  8    58 dcl  max_file_init fixed bin;				/* nbr. of files in data base */
  8    59 dcl  scope_ptr ptr init (null ());			/* points to scope_info array */
  8    60 dcl  scope_rdy bit (6) unal init ("000011"b) int static options (constant); /* scope file ready modes (5 or 6) */
  8    61 dcl  scope_rdy_array (6) bit (1) unal based;		/* array format of scope_rdy string */
  8    62 
  8    63 /* END mdbm_scope_info.incl.pl1 */
     1029 
     1030 
  9     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  9     2 
  9     3 
  9     4 
  9     5 /****^  HISTORY COMMENTS:
  9     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  9     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  9     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  9     9*     Nguyen. The scopes_changed flag was added to make checking for this
  9    10*     more efficient (mrds error list #137).
  9    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  9    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  9    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  9    14*     care if multiple txns use the same selection_expression. (mrds #156)
  9    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  9    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  9    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  9    18*                                                   END HISTORY COMMENTS */
  9    19 
  9    20 
  9    21 /* WARNING
  9    22*          If the dbcb structure is changed then the mrds_data_
  9    23*          item saved_res_version MUST be incremented to invalidate all
  9    24*          existing saved resultants
  9    25**/
  9    26 
  9    27 /* HISTORY :
  9    28*
  9    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  9    30*   tid_list management
  9    31*
  9    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  9    33*   phony resultant in mu_database_index, without having the area dcl
  9    34*   included.
  9    35*
  9    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  9    37*   mrds_dsl_store
  9    38*
  9    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  9    40*   switches
  9    41*
  9    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  9    43*   expression,  so  that relation statistics can be updated relative
  9    44*   to number of selection expressions seem. Also  removed  init  for
  9    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  9    46*   mrds_dsl_init_res.
  9    47*
  9    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  9    49*
  9    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  9    51*   for the conversion to the relation manager.
  9    52*
  9    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  9    54*   substructures so that the entries and costs can change
  9    55*   depending on the type of database that is opened.
  9    56*
  9    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  9    58*   since modify uses a different vector type (general) than does store.
  9    59*
  9    60*   82-09-20 Davids: changed names of (store modify)_vector to
  9    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  9    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  9    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  9    64*   during the first call.
  9    65*
  9    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  9    67*   since it deals with the pointers to the cursors and not the cursors
  9    68*   themelves and added the element cursor_storage_area_ptr which points
  9    69*   to the area where the cursors are kept.
  9    70*
  9    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  9    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  9    73*   anything.
  9    74*
  9    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  9    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  9    77*   by mrds_dsl_define_temp_rel.
  9    78*
  9    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  9    80*   is needed by mu_store.
  9    81*
  9    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  9    83*   bin to float bin since the values are not integers.
  9    84*
  9    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  9    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  9    87*   added to the end of the structure to allow modules that don't use
  9    88*   the element to continue to reference the dbcb structure without recompiling.
  9    89*
  9    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  9    91*   are needed so that temp rels can be created with the same file attributes
  9    92*   as the permanent relations.
  9    93*
  9    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  9    95*   added the resultant_in_pdir bit.
  9    96*
  9    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  9    98*   added the res_already_made element.
  9    99*
  9   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  9   101*
  9   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  9   103*   one of the unused pointers.
  9   104*
  9   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  9   106*
  9   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  9   108*   leaving unused_ptrs(1).
  9   109*
  9   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  9   111*   unused_ptrs (1).
  9   112*
  9   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  9   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  9   115*   spare ptrs, entries and reserved storages for future enhancement, since
  9   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  9   117*
  9   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  9   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  9   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  9   121**/
  9   122 
  9   123 
  9   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  9   125*   that constitutes the non-secure portion of the resultant model that is
  9   126*   created during the opening of a database. it contains variables that
  9   127*   are used during the runtime access of the database, and an area
  9   128*   for evaluation of requests. it points to four other
  9   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  9   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  9   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  9   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  9   133*   used in the elimination of duplicate tuples during a retrieve.
  9   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  9   135*   that is used when the database is using the file scope mechanism
  9   136*   for concurrency control over file readying. the segment overlayed via
  9   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  9   138*   across database openings. the pointer to this dbcb structure is kept in a table
  9   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  9   140*   opening instances of resultant models. (see mu_database_index routine) */
  9   141 
  9   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  9   143 	     2 data	      like dbcb_data,
  9   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  9   145 
  9   146      dcl	   dbcb_ptr	      ptr;
  9   147 
  9   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  9   149*						   like references can avoid getting the area declaration */
  9   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  9   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  9   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  9   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  9   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  9   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  9   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  9   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  9   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  9   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  9   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  9   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  9   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  9   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  9   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  9   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  9   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  9   167*						   for eliminating duplicate tuples. */
  9   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  9   169*						   for eliminating duplicate tuples. */
  9   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  9   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  9   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  9   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  9   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  9   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  9   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  9   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  9   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  9   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  9   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  9   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  9   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  9   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  9   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  9   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  9   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  9   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  9   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  9   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  9   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  9   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  9   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  9   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  9   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  9   195 	     2 val_del	      bit (1) unal,		/* for delete */
  9   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  9   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  9   198*                                                                     not imply that the database is of type page_file */
  9   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  9   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  9   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  9   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  9   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  9   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  9   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  9   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  9   207*						   inside a sequence of -another selection expression. */
  9   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  9   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  9   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  9   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  9   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  9   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  9   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  9   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  9   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  9   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  9   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  9   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  9   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  9   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  9   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  9   223 	     2 relmgr_entries,			/* relation manager entries */
  9   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  9   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  9   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  9   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  9   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  9   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  9   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  9   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  9   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  9   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  9   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  9   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  9   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  9   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  9   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  9   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  9   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  9   241 	       3 reserved_entries (5) entry (),
  9   242 	     2 access_costs,			/* access costs for permute */
  9   243 	       3 total_primary_key_cost float bin,
  9   244 	       3 access_cost      float bin,
  9   245 	       3 access_overhead  float bin,
  9   246 	       3 us_access_cost   float bin,
  9   247 	       3 os_access_cost   float bin,
  9   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  9   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  9   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  9   251 
  9   252 /* END mrds_dbcb.incl.pl1 */
  9   253 
  9   254 
     1031 
     1032 
 10     1 /*	BEGIN INCLUDE FILE		mdbm_dbc.incl.pl1	08/23/78   odf			*/
 10     2 
 10     3 /* HISTORY:
 10     4*
 10     5*   Modified by odf for new version data bases in August 1978
 10     6*   Modified by Al Kepner, March 8, 1979 to add new flags for quiescing
 10     7*   Modified by M. Pierret, 8 April 1980 to look prettier, add pads
 10     8*   Modified by M. Pierret, 22 August 1980, grouping like fields (flags, offsets..)
 10     9*
 10    10*   80-11-19 Jim Gray : modified to change version number from 4  to 5 to allow
 10    11*   automatic update of dbc structures to new r-s-m-d-u scope codes from r-u.
 10    12**/
 10    13 
 10    14 dcl 1 dbc based (dbc_ptr),				/* data base control segment description */
 10    15     2 proper,
 10    16       3 version fixed bin,				/* version number of this structure */
 10    17       3 dtd_mrds fixed bin (71),			/* date time dumped by mrds utility */
 10    18       3 flags,
 10    19         4 trouble_switch bit (1) unal,			/* ON => ungraceful termination of a user process */
 10    20         4 dead_proc_flag bit (1) unal,			/* ON => dead process has access to part of data base */
 10    21         4 quiesce_sw bit (1) unal,			/* ON => db is quiesced for a administrative user */
 10    22         4 quiesce_db bit (1) unal,			/* ON => The entire data base is being quiesced. */
 10    23         4 quiesce_files bit (1) unal,			/* ON => A selected set of files is being quiesced. */
 10    24         4 pad bit (31) unal,				/* reserved for future use */
 10    25       3 quiesce_lock bit (36) aligned,			/* lock word for quiescing data base */
 10    26       3 wakeup_waiters fixed bin,			/* nbr users who have been sent a wakeup signal but have not yet
 10    27*						   received it */
 10    28       3 user_counts,
 10    29         4 open_users fixed bin,			/* nbr of users with data base open in any mode */
 10    30         4 active_users fixed bin,			/* nbr of users currently having a scope set */
 10    31         4 waiting_users fixed bin,			/* nbr of users waiting to set scope */
 10    32       3 open_lock bit (36) aligned,			/* lock word for opening data base */
 10    33       3 scope_lock bit (36) aligned,			/* lock word for setting and deleting scope */
 10    34       3 sa_size fixed bin (35),			/* size in words of static area  */
 10    35       3 pad2 bit (144),
 10    36       3 offsets,
 10    37         4 open_users_ofs bit (18) unal,			/* bit offset to list of users with data base currently open */
 10    38         4 active_users_ofs bit (18) unal,		/* bit offset to list of active users in shared mode */
 10    39         4 waiting_users_ofs bit (18) unal,		/* bit offset to list of waiting users in shared mode */
 10    40         4 obsolete bit (36) unal,			/* obsolete */
 10    41       3 pad3 bit (144),
 10    42     2 static_area area (sys_info$max_seg_size - fixed (rel (addr (dbc.static_area))) + 1);
 10    43 
 10    44 dcl  dbc_ptr ptr init (null ());
 10    45 
 10    46 dcl  VERSION_NBR fixed bin init (5) static internal options (constant);
 10    47 
 10    48 
 10    49 /* END mdbm_dcb.incl.pl1  */
 10    50 
 10    51 
     1033 
     1034 
 11     1 /* BEGIN mdbm_users.incl.pl1   -- odf, 08/10/78  */
 11     2 
 11     3 
 11     4 
 11     5 /****^  HISTORY COMMENTS:
 11     6*  1) change(86-10-03,Dupuis), approve(86-10-21,MCR7562), audit(86-10-22,Blair),
 11     7*     install(86-10-23,MR12.0-1199):
 11     8*     Deleted the DEFAULT_WAIT variable.
 11     9*                                                   END HISTORY COMMENTS */
 11    10 
 11    11 
 11    12 /* HISTORY:
 11    13*   Written by Oris Friesen August 10, 1978.
 11    14*   Modified by M. Pierret 13 December 1979, changing wakeup messages.
 11    15*   Modified by M. Pierret 13 April 1980 (Jason's birthday) to remove priority and wakeup structures
 11    16*   Modified by M. Pierret 13 August 1980 to group like fields (ids, offsets...)
 11    17*   Modified by Jim Gray - - 80-11-19, to add fields to fil_list to allow for complete
 11    18*   r-u-s-m-d scope codes, instead of just r-u.
 11    19*
 11    20*   80-12-10 Jim Gray : change names of fil_list prevent/permit modes
 11    21*   store to append_tuple, retreive to read_attr, delete to delete_tuple, modify to modify_attr,
 11    22*   and pad to mbz for consistency with MRDS access acl modes.
 11    23*
 11    24*   80-12-12 Jim Gray : Changed DEFAULT_WAIT declaration to fixed bin 35 from 71,
 11    25*   so that the wait_seconds fb35 overlay would not get 0 and thus never wait.
 11    26*   This is currently only used in mrds_dsl_set_fscope.
 11    27*
 11    28*   82-09-22 Davids: addede the opening_id element to the fil_list structure.
 11    29*   Put it at the end to make the new structure compatable with the old so
 11    30*   that testing could take place without having to recompile all the modules
 11    31*   that use the structure.
 11    32*
 11    33*   82-10-14 Davids: removed the opening_id element and added the rmri_ptr
 11    34*   element. This was done because set_fscope must be able to open the
 11    35*   relation if its not yet opened.
 11    36*   ---------------------------------------------------------------------------
 11    37*   DESCRIPTION:
 11    38*
 11    39*   The dbc contains the following information in its static area.
 11    40*   One group of information is composed of structures (user_list)
 11    41*   threaded 3 ways to form 3 lists. They are the list of active
 11    42*   scope users, of open users, and of users waiting to set scope.
 11    43*   The beginning of each of these lists is pointed to by fields
 11    44*   in the dbc proper.  All of these lists share the user_list structures,
 11    45*   and are completely contained within these structures, i.e., there
 11    46*   is no extraneous information in some knook in Scottsdale.
 11    47*
 11    48*   Associated with each user_list structure is a linked list of
 11    49*   fil_list structures.  The list is of all of the files (relations)
 11    50*   included in the user's scope request.  Unlike the user_list
 11    51*   structures which were shared by several different lists, the structures
 11    52*   in a user's file list are exclusively hers.  The entries contain
 11    53*   information about the scope request and the file name, and have
 11    54*   no real connection with the actual files in the resultant model.
 11    55*   --------------------------------------------------------------------------- */
 11    56 
 11    57 dcl 1 user_list based (ul_ptr),
 11    58     2 ids,
 11    59       3 group_id char (32),				/* group identifier of this user */
 11    60       3 process_id bit (36),				/* process identifier of this user */
 11    61       3 db_lock_id bit (36) aligned,			/* the unique lock id for this process --
 11    62*						   used to identify dead processes */
 11    63       3 ev_chn_id fixed bin (71),			/* event channel id for this process */
 11    64       3 rdbi_bits bit (72),				/* bit string of rdbi_ptr
 11    65*						   to allow concurrent openings by same process */
 11    66     2 flags,
 11    67       3 open_mode fixed bin unal,			/* the mode of the db. opening -- NORMAL or QUIESCE */
 11    68       3 passive_sw bit (1) unal,			/* OFF => -permit update on some file */
 11    69       3 active_sw bit (1) unal,			/* ON => user has a scope set */
 11    70       3 waiting_sw bit (1) unal,			/* ON => user is waiting for scope to be set */
 11    71       3 priority_high bit (1) unal,			/* obsolete */
 11    72       3 event_signal_sw bit (1) unal,			/* ON => user has been signalled thru event wait channel */
 11    73       3 dead_proc bit (1) unal,			/* ON => this user's process has died  and is inactive */
 11    74       3 dead_proc_conflict
 11    75      bit (1) unal,					/* this user's scope request conflicts with a dead process */
 11    76       3 queue_activ bit (1) unal,			/* activated from the waiting queue */
 11    77       3 pad bit (28),				/* reserved for future use */
 11    78     2 allowance_count fixed bin,			/* obsolete */
 11    79     2 bypass_count fixed bin,				/* obsolete */
 11    80     2 offsets,
 11    81       3 fil_list_ofs bit (18) unal,			/* bit offset to list of files in this user's scope request */
 11    82       3 next_active_ofs bit (18) unal,			/* bit offset to next user in this list of active scope users */
 11    83       3 next_waiting_ofs bit (18) unal,			/* bit offset to next user in user list waiting to set scope */
 11    84       3 next_open_ofs bit (18) unal,			/* bit offset to next user who has data base open in any mode */
 11    85     2 num_filns fixed bin,				/* number of files potentially accessible by this user */
 11    86     2 file (num_filns refer (user_list.num_filns)) char (30);
 11    87 						/* names of files accessible by this user */
 11    88 
 11    89 dcl 1 fil_list based (fl_ptr),			/* of files which a given user has specified for a scope  */
 11    90     2 name char (30),				/* data model name of the file specified in scope request */
 11    91     2 permits,					/* permit codes for scope setting or deleting */
 11    92       3 mbz1 bit (15) unal,
 11    93       3 modify_attr bit (1) unal,
 11    94       3 delete_tuple bit (1) unal,
 11    95       3 append_tuple bit (1) unal,
 11    96       3 update bit (1) unal,
 11    97       3 read_attr bit (1) unal,
 11    98     2 prevents,					/* prevent codes for scope setting or deleting */
 11    99       3 update bit (1) unal,
 11   100       3 read_attr bit (1) unal,
 11   101       3 append_tuple bit (1) unal,
 11   102       3 delete_tuple bit (1) unal,
 11   103       3 modify_attr bit (1) unal,
 11   104       3 mbz2 bit (29) unal,
 11   105     2 next_ofs bit (18) unal,				/* bit offset to next file entry for this user's scope request */
 11   106     2 rmri_ptr ptr;                                         /* pointer to the relation's rm_rel_info str */
 11   107                                                             /* needed so that the relation can be opened if need be */
 11   108 
 11   109 dcl  ul_ptr ptr init (null ());
 11   110 dcl  fl_ptr ptr init (null ());
 11   111 
 11   112 dcl  num_filns fixed bin;				/* number of files accessible by a given user */
 11   113 
 11   114 
 11   115 dcl  WAIT init (0) fixed bin int static options (constant);
 11   116 						/* the number of later user requests for which a user
 11   117*						   request will wait before it must be honored */
 11   118 dcl  NULL_OFS bit (18) init ("111111111111111111"b) unal int static options (constant);
 11   119 dcl  DQ_OPEN bit (1) unal init ("1"b) int static options (constant);
 11   120 						/* dequeue from open list */
 11   121 dcl  NO_DQ_OPEN bit (1) init ("0"b) int static options (constant);
 11   122 						/*  do not dequeue from open list */
 11   123 dcl  CHAR_Q_F char (8) init ("que_free") int static options (constant);
 11   124 dcl  QUE_FREE fixed bin (71);
 11   125 dcl  CHAR_ALARM char (8) init ("alarm___") int static options (constant);
 11   126 						/* wakeup up signal for time-out */
 11   127 dcl  ALARM fixed bin (71);
 11   128 dcl  FIRST_QUEUE bit (1) init ("1"b) int static options (constant);
 11   129 						/* this is the 1st time process will asleep */
 11   130 dcl  QUEUE_AGAIN bit (1) init ("0"b) int static options (constant);
 11   131 						/* being queued for the 2nd, 3rd ... time */
 11   132 dcl  SET bit (1) unal init ("1"b) int static options (constant);
 11   133 						/* check to see which scopes can be set */
 11   134 dcl  DEL bit (1) unal init ("0"b) int static options (constant);
 11   135 						/* check to see which scopes can be deleted */
 11   136 dcl  ALIVE init ("1"b) bit (1) unal int static options (constant);
 11   137 						/* process is alive */
 11   138 dcl  DEAD init ("0"b) bit (1) unal int static options (constant);
 11   139 						/* process is dead */
 11   140 dcl  Q_PRM init (3) fixed bin (35) int static options (constant);
 11   141 						/* permit retrieve, update */
 11   142 dcl  Q_PRV init (3) fixed bin (35) int static options (constant);
 11   143 						/* prevent retrieve, update */
 11   144 dcl  Q_PRM_BITS bit (2) unal init ("11"b) int static options (constant);
 11   145 						/* permit retrieve, update */
 11   146 dcl  Q_PRV_BITS bit (2) unal init ("11"b) int static options (constant);
 11   147 						/* prevent retrieve, update */
 11   148 dcl  REL_SEC bit (2) init ("11"b) int static options (constant);
 11   149 						/* measure wait time in relative seconds */
 11   150 dcl  FREE_FIL_LIST bit (1) unal init ("1"b) int static options (constant);
 11   151 						/* free this user's file lists */
 11   152 dcl  SAVE_FIL_LIST bit (1) unal init ("0"b) int static options (constant);
 11   153 						/* do not free this user's file lists */
 11   154 
 11   155 /* END mdbm_users.incl.pl1 */
 11   156 
     1035 
     1036 
 12     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
 12     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
 12     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
 12     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
 12     5 
 12     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
 12     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
 12     8     2 type unsigned fixed bin (6) unal,			/* data type */
 12     9     2 packed bit (1) unal,				/* on if data item is packed */
 12    10     2 number_dims bit (4) unal,			/* dimensions */
 12    11     2 size,					/* size for string data */
 12    12       3 scale bit (12) unal,				/* scale for num. data */
 12    13       3 precision bit (12) unal,			/* prec. for num. data */
 12    14     2 array_info (num_dims),
 12    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
 12    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
 12    17       3 multiplier fixed bin (35);			/*  element separation */
 12    18 
 12    19 dcl  desc_ptr ptr;
 12    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
 12    21 
 12    22 /* END mdbm_descriptor.incl.pl1 */
 12    23 
 12    24 
     1037 
     1038 
 13     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
 13     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
 13     3 
 13     4 /* layout of argument list for IDS and DBM entries with options (variable) */
 13     5 
 13     6 dcl 1 arg_list based (al_ptr),
 13     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
 13     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
 13     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
 13    10     2 pad fixed bin (17) unal,			/* must be 0 */
 13    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
 13    12 
 13    13 dcl  al_ptr ptr;
 13    14 dcl  num_ptrs fixed bin;
 13    15 
 13    16 /* END mdbm_arg_list.incl.pl1  */
 13    17 
     1039 
     1040 
 14     1 /*	BEGIN INCLUDE FILE		mrds_fd.incl.pl1	10/20/78	RDL			*/
 14     2 
 14     3 /*  HISTORY:
 14     4*
 14     5*83-09-07 Mike Kubicar : removed bits dealing with duplicate keys.  They are
 14     6*no longer handled at the file level.
 14     7**/
 14     8 
 14     9 dcl 1 fd aligned based (fd_ptr),
 14    10     2 name char (32),				/* File name */
 14    11     2 iocb_ptr ptr,
 14    12     2 cur_key char (256) varying,
 14    13     2 desc fixed bin (35),
 14    14     2 rec_count fixed bin (24),
 14    15     2 rec_len fixed bin (21),
 14    16     2 rec_buf char (mrds_data_$max_data_length);
 14    17 
 14    18 dcl  fd_ptr ptr;
 14    19 
 14    20 /* 	END INCLUDE FILE		mrds_fd.incl.pl1				*/
 14    21 
     1041 
     1042 
 15     1 /* START OF:	mrds_new_scope_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 15     2 
 15     3 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 15     4 /* 									*/
 15     5 /* Name:  mrds_new_scope_modes.incl.pl1						*/
 15     6 /* 									*/
 15     7 /*      This include file defines named constants which can be used to specify the MRDS	*/
 15     8 /* operations to be permitted and prevented in a call to dsl_$set_scope.		*/
 15     9 /* 									*/
 15    10 /* Status									*/
 15    11 /* 									*/
 15    12 /* 0)   Created on January 25, 1980 by Jim Gray          				*/
 15    13 /* 1)   80-12-10 Jim Gray : r-u scope modes changed to r-s-m-d type scope modes,          */
 15    14 /*    also, names were changed to agree with security acl modes in MRDS.	          */
 15    15 /*									*/
 15    16 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 15    17 
 15    18 dcl (NO_OP init (0),
 15    19      READ_ATTR init (1),
 15    20      APPEND_TUPLE init (2),
 15    21      DELETE_TUPLE init (4),
 15    22      MODIFY_ATTR init (8),
 15    23      UPDATE_OPS init (14),
 15    24      ALL_OPS init (15)) fixed bin int static options (constant);
 15    25 
 15    26 /* END OF:	mrds_new_scope_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1043 
     1044 
 16     1 /* BEGIN mrds_retrieve_info.incl.pl1   -- RDL,  11/10/77   */
 16     2 
 16     3 /* HISTORY:
 16     4*   Originator unknown:
 16     5*   81-07-16 Roger Lackey : to add auto_dup_determined and make  other switches unal
 16     6**/
 16     7 dcl 1 retrieve_info aligned based (dbcb.retr_info_ptr),	/* Retrieve static data */
 16     8     2 version fixed bin (35),				/* Version number */
 16     9     2 retain_dup bit (1) unal,			/* On = duplicates must be preserved */
 16    10     2 first_sw bit (1) unal,				/* On = new set selection expression */
 16    11     2 auto_dup_determined bit (1) unal,			/* ON = that auto dup has been determined for the current sel exp */
 16    12     2 reserved bit (33) unal,				/* Reserved for furture use */
 16    13     2 unique_count fixed bin (17),			/* Unique records retrieve */
 16    14     2 ret_fd_ptr (mrds_data_$max_sets) ptr;		/* Array of pointers to sec_retrieve temp file desc */
 16    15 
 16    16 
 16    17 dcl  retrieve_info_version fixed bin (35) int static options (constant) init (1);
 16    18 
 16    19 /* END mrds_retrieve_info.incl.pl1  */
 16    20 
     1045 
     1046 
 17     1 /* BEGIN mrds_trel_info.incl.pl1   --  RDL,  11/10/77 */
 17     2 
 17     3 dcl 1 trel_info aligned based (dbcb.trel_info_ptr),	/* temp rel static data */
 17     4     2 version fixed bin (35),
 17     5     2 fd_ptr (mrds_data_$max_sets) ptr;			/* Temp file file desc pointers */
 17     6 
 17     7 dcl  trel_version int static options (constant) init (1);
 17     8 
 17     9 /* END mrds_trel_info.incl.pl1   */
 17    10 
     1047 
     1048 
 18     1 /* BEGIN INCLUDE FILE mrds_debug_names.incl.pl1     Jim Gray 8/7/79 */
 18     2 
 18     3 /* this include file associates module names with debug switches
 18     4*   that are stored in the data segment mrds_debug_
 18     5*   each module has it's own bit(9) debug switch, to define for various
 18     6*   debug actions, with new module names to be added to the end
 18     7*   of this list using the next in order array index in mrds_debug_
 18     8*   the convention for naming is db_{module's full name}
 18     9*   for the defined declaration over mrds_debug_$switch.
 18    10*   module.name array is then changed to reflect the new
 18    11*   number of modules, with the full module name added to the bottom
 18    12*   of the initialize list for the name array.
 18    13*   the module name array is used by the command level interface that sets/resets
 18    14*   the current status of the debug switches for each module.
 18    15*   the modules themselves use the db_{module name} declared variable for
 18    16*   that module to interagate the bits for proper debug action to take.
 18    17*   the definition of the meaning of the 9-bits is up to each individual module's
 18    18*   designer. */
 18    19 
 18    20 
 18    21 /*
 18    22*   HISTORY
 18    23*
 18    24*   80-11-12 Davids: added db_mus_mod_ubtup
 18    25*
 18    26*   80-11-13 Davids: added db_mu_sec_get_tuple and db_mu_sec_get_tid
 18    27*
 18    28*   80-12-15 Jim Gray :  added  mrds_dsl_set_fscope  to  display  non
 18    29*   error  info  about  being queued, and request being granted after
 18    30*   being queued.
 18    31*
 18    32*   81-01-15 Jim Gray : added  mu_concurrency_control  bit  to  allow
 18    33*   running  MR8  and  MR9 mrds against the same database at the same
 18    34*   time.
 18    35*
 18    36*   81-02-02  Jim  Gray  :  added  bit  for  mrds_rst_dmdm  to  allow
 18    37*   displaying internal tuple format bit offset, rather than the user
 18    38*   view.
 18    39*
 18    40*   81-02-06 Jim Gray : added bit for  new  mu_open_name_manager,  to
 18    41*   dump  an  element  from  the  list, when display_open_names entry
 18    42*   called with switch set.
 18    43*
 18    44*   81-05-20 Jim Gray : added bit for  mrds_dsl_where_clause  display
 18    45*   of sub_err_ messages, when cross domain compare occurs.
 18    46*
 18    47*   81-06-17 Jim Gray : added bit for mu_open_iocb_manager to display
 18    48*   iocb slot and rel name.
 18    49*
 18    50*   81-07-08 Jim Gray : added comment for bit 4 in mrds_dsl_permute
 18    51*
 18    52*   81-07-17 Jim Gray : added comment for bit 5 in mrds_dsl_permute
 18    53*
 18    54*   81-07-18 Jim Gray : added bit 1 for  mrds_dsl_gen_srch_prog  that
 18    55*   allows  key  searches, other than than specified by permute to be
 18    56*   done as comparisons instead.
 18    57*
 18    58*   81-07-22  Jim   Gray   :   added   comment   about   bit   2   in
 18    59*   mrds_dsl_gen_srch_prog
 18    60**/
 18    61 
 18    62 declare (
 18    63          db_mrds_dsl_eval_expr bit (9) unal defined (mrds_debug_$switch (1)),
 18    64          db_mrds_dsl_get_token bit (9) unal defined (mrds_debug_$switch (2)),
 18    65          db_mrds_dsl_permute bit (9) unal defined (mrds_debug_$switch (3)),
 18    66          db_mrds_dsl_optimize bit (9) unal defined (mrds_debug_$switch (4)),
 18    67          db_mrds_dsl_search bit (9) unal defined (mrds_debug_$switch (5)),
 18    68          db_mrds_dsl_translate bit (9) unal defined (mrds_debug_$switch (6)),
 18    69          db_mu_retrieve bit (9) unal defined (mrds_debug_$switch (7)),
 18    70          db_mrds_dsl_open bit (9) unal defined (mrds_debug_$switch (8)),
 18    71          db_mrds_dsl_close bit (9) unal defined (mrds_debug_$switch (9)),
 18    72          db_mrds_dsl_init_res bit (9) unal defined (mrds_debug_$switch (10)),
 18    73          db_mu_sec_init_res bit (9) unal defined (mrds_debug_$switch (11)),
 18    74          db_mus_mod_ubtup bit (9) unal defined (mrds_debug_$switch (12)),
 18    75          db_mu_sec_get_tuple bit (9) unal defined (mrds_debug_$switch (13)),
 18    76          db_mu_sec_get_tid bit (9) unal defined (mrds_debug_$switch (14)),
 18    77          db_mrds_dsl_set_fscope bit (9) unal defined (mrds_debug_$switch (15)),
 18    78          db_mu_concurrency_control bit (9) unal defined (mrds_debug_$switch (16)),
 18    79          db_mrds_rst_dmdm bit (9) unal defined (mrds_debug_$switch (17)),
 18    80          db_mu_open_name_manager bit (9) unal defined (mrds_debug_$switch (18)),
 18    81          db_mrds_dsl_where_clause bit (9) unal defined (mrds_debug_$switch (19)),
 18    82          db_mu_open_iocb_manager bit (9) unal defined (mrds_debug_$switch (20)),
 18    83          db_mrds_dsl_gen_srch_prog bit (9) unal defined (mrds_debug_$switch (21))
 18    84          ) ;
 18    85 
 18    86 /* list of known module names, with index into name array
 18    87*   the same as that into mrds_debug_$switch,
 18    88*   number is the current count of defined module names,
 18    89*   name is the modules full name. */
 18    90 
 18    91 declare 1 module options (constant) internal static,
 18    92         2 number fixed bin init (21),
 18    93         2 name char (32) dimension (21) init (
 18    94          "mrds_dsl_eval_expr",			/* 1 => display value of each expression */
 18    95          "mrds_dsl_get_token",			/* 1 => display the current token */
 18    96          "mrds_dsl_permute",				/* each 1 => lost cost path found,
 18    97*						   2 => reverse partial path
 18    98*						   3 => use range order for path
 18    99*						   4 => display access method costs
 18   100*						   5 => display details of final low cost path */
 18   101          "mrds_dsl_optimize",				/* 1 => pred tree,
 18   102*						   2 => paths to consider, 3 => calc_cost on */
 18   103          "mrds_dsl_search",				/* 1 => display each tuple located */
 18   104          "mrds_dsl_translate",			/* 1 => display the search program */
 18   105          "mu_retrieve",				/* 1 => display values compared, 2 => display tuple data */
 18   106          "mrds_dsl_open",				/* 1 => allow cleanup sub_error_ */
 18   107          "mrds_dsl_close",				/* 1 => allow cleanup sub_error_ */
 18   108          "mrds_dsl_init_res",				/* 1 => allow cleanup sub_error_ */
 18   109          "mu_sec_init_res",				/* 1 => allow cleanup sub_error_ */
 18   110          "mus_mod_ubtup",				/* 1 => consistency checking between the old
 18   111*						   and new tuple during modifies will be done */
 18   112          "mu_sec_get_tuple",				/* 1 => attribute values
 18   113*						   will be zeroed in the tuple structure
 18   114*						   is don't have read permission. */
 18   115          "mu_sec_get_tid",				/* 1 => read permission to the key
 18   116*						   is checked (if db is secured) */
 18   117          "mrds_dsl_set_fscope",			/* 1 => display being queued,
 18   118*						   and request granted from queue messages */
 18   119          "mu_concurrency_control",			/* 1 => allow both dbc and db.control segs under db
 18   120*						   so can test both MR8 and MR9 mrds
 18   121*						   against the same database at the same time */
 18   122          "mrds_rst_dmdm",				/* 1 => allow internal form of bit offset value
 18   123*						   for attributes to be displayed, rather than user view */
 18   124          "mu_open_name_manager",			/* 1 => dump mrds_open_name tree node structure,
 18   125*						   when display_open_names entry called */
 18   126          "mrds_dsl_where_clause",			/* 1 => display details of cross domain compares */
 18   127          "mu_open_iocb_manager",			/* 1 => display relation and slot getting iocb for */
 18   128          "mrds_dsl_gen_srch_prog"			/* 1 => do additional conditions as sequential, not key searches
 18   129*						   when the original access was a key,
 18   130*						   and the additional conditions can be done as key also
 18   131*						   2 => force key searches, regardless of strategy
 18   132*						   used to decide between compare or key search */
 18   133          ) ;
 18   134 
 18   135 declare  mrds_debug_$switch (1:400) bit (9) unal ext ;	/* data segment debug array */
 18   136 
 18   137 /* END INCLUDE FILE mrds_debug_names.incl.pl1 */
 18   138 
     1049 
     1050      end;
     1051 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1300.0  mrds_dsl_close.pl1                >special_ldd>install>MR12.2-1073>mrds_dsl_close.pl1
569          1    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
641          4    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
1023         5    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
1025         6    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
1027         7    10/14/83  1609.1  mdbm_rm_rel_array.incl.pl1        >ldd>include>mdbm_rm_rel_array.incl.pl1
1029         8    04/18/85  1628.1  mdbm_scope_info.incl.pl1          >ldd>include>mdbm_scope_info.incl.pl1
1031         9    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
1033        10    10/14/83  1609.0  mdbm_dbc.incl.pl1                 >ldd>include>mdbm_dbc.incl.pl1
1035        11    10/23/86  1033.9  mdbm_users.incl.pl1               >ldd>include>mdbm_users.incl.pl1
1037        12    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
1039        13    10/14/83  1609.0  mdbm_arg_list.incl.pl1            >ldd>include>mdbm_arg_list.incl.pl1
1041        14    10/14/83  1609.1  mrds_fd.incl.pl1                  >ldd>include>mrds_fd.incl.pl1
1043        15    10/14/83  1608.7  mrds_new_scope_modes.incl.pl1     >ldd>include>mrds_new_scope_modes.incl.pl1
1045        16    10/14/83  1609.0  mrds_retrieve_info.incl.pl1       >ldd>include>mrds_retrieve_info.incl.pl1
1047        17    10/14/83  1608.5  mrds_trel_info.incl.pl1           >ldd>include>mrds_trel_info.incl.pl1
1049        18    10/14/83  1609.0  mrds_debug_names.incl.pl1         >ldd>include>mrds_debug_names.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
APPEND_TUPLE                           constant        fixed bin(17,0)          initial dcl 15-18 ref 519 528
BLANK                           000245 automatic       char(1)                  initial packed unaligned dcl 996 set ref 843 872
                                                                                  996*
DELETE_TUPLE                           constant        fixed bin(17,0)          initial dcl 15-18 ref 521 530
DQ_OPEN                         000030 constant        bit(1)                   initial packed unaligned dcl 11-119 set ref 720*
FREE_FIL_LIST                   000030 constant        bit(1)                   initial packed unaligned dcl 11-150 set ref 720*
MODIFY_ATTR                            constant        fixed bin(17,0)          initial dcl 15-18 ref 523 532
NOT_READY                       000226 automatic       bit(1)                   initial packed unaligned dcl 990 set ref 990*
NO_OP                                  constant        fixed bin(17,0)          initial dcl 15-18 ref 514 515
NULL_OFFSET                     000227 automatic       bit(18)                  initial packed unaligned dcl 991 set ref 702 732
                                                                                  991*
OFF                             000211 automatic       bit(1)                   initial packed unaligned dcl 966 set ref 238 332 360
                                                                                  966*
ON                              000212 automatic       bit(1)                   initial packed unaligned dcl 967 set ref 242 328 352
                                                                                  967*
READ_ATTR                              constant        fixed bin(17,0)          initial dcl 15-18 ref 517 526
SPECIAL                         000250 automatic       fixed bin(17,0)          initial dcl 1005 set ref 211 1005*
TM_NORMAL_MODE                  000053 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
active_scopes             5            based           fixed bin(17,0)          level 2 dcl 8-32 ref 500 506
addr                                                   builtin function         dcl 1021 ref 258 258 1-123 1-123 714 755 755
al_ptr                          000306 automatic       pointer                  dcl 13-13 set ref 198* 199 202 211 215 224 258 258
any_other                       000000 stack reference condition                dcl 993 ref 568
append_tuple             26(01)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 8-32 in procedure "close" ref
                                                                                  519
append_tuple             27(01)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 8-32 in procedure "close" ref
                                                                                  528
arg_count                              based           fixed bin(17,0)          level 2 in structure "arg_list" packed packed
                                                                                  unaligned dcl 13-6 in procedure "close" ref 202
arg_count                       000222 automatic       fixed bin(17,0)          dcl 975 in procedure "close" set ref 255* 256 258
                                                                                  258 262* 284* 284
arg_des_ptr               2            based           pointer                  array level 2 dcl 13-6 set ref 215 224 258* 258*
arg_list                               based           structure                level 1 unaligned dcl 13-6
caller_name                     000201 automatic       char(15)                 initial packed unaligned dcl 962 set ref 202* 218*
                                                                                  230* 231* 262* 334* 362* 437* 451* 468* 477* 541*
                                                                                  962* 1-140* 595* 4-115* 727* 765* 775* 789* 812*
                                                                                  824* 836* 867* 890* 897*
clean_up_condition              000244 automatic       bit(1)                   packed unaligned dcl 995 set ref 238* 242*
cleanup                         000236 stack reference condition                dcl 994 ref 240 567
close                   152            based           entry variable           level 4 dcl 9-142 ref 436
close_index                     000246 automatic       fixed bin(35,0)          dcl 997 set ref 410* 468* 477* 1-140* 590* 595*
                                                                                  4-115* 727* 780* 789* 812* 824* 836* 867*
code                      0(18)        based           fixed bin(17,0)          level 2 in structure "arg_list" packed packed
                                                                                  unaligned dcl 13-6 in procedure "close" ref 211
code                            000166 automatic       fixed bin(35,0)          dcl 930 in procedure "close" set ref 225* 436* 437
                                                                                  437* 449* 451 451* 460* 461 463* 464 464 464 468*
                                                                                  473* 474 474 477* 482 537* 538 539 539* 541* 544
                                                                                  590* 591 594 595* 684 686 720* 721 721 726 727*
                                                                                  762* 764* 765 765 765* 772* 774* 775 775 775* 782*
                                                                                  783 783 788 789* 805* 806 811 812* 817* 818 823
                                                                                  824* 829* 830 835 836* 849* 850 850 850* 861 866
                                                                                  867* 890* 891 896 897*
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue                        000205 automatic       char(1)                  initial packed unaligned dcl 963 set ref 202* 218*
                                                                                  231* 262* 334* 362* 437* 451* 468* 468* 477* 541*
                                                                                  963* 1-140* 595* 4-115* 727* 765* 775* 789* 812*
                                                                                  824* 836* 867* 897*
continue_to_signal_             000124 constant        entry                    external dcl 1-61 ref 1-137
cu_$arg_list_ptr                000010 constant        entry                    external dcl 937 ref 198
cursor_ptrs_storage_ptr
                        130            based           pointer                  level 3 dcl 9-142 set ref 447 449*
cursor_storage_area_ptr
                        132            based           pointer                  level 3 dcl 9-142 set ref 449*
data                                   based           structure                level 2 in structure "rm_db_info" dcl 5-86
                                                                                  in procedure "close"
data                                   based           structure                level 2 in structure "dbcb" dcl 9-142 in procedure
                                                                                  "close"
db_close                               based           structure                level 1 dcl 968 set ref 383
db_close_list_ptr               000216 automatic       pointer                  dcl 973 set ref 229* 296 354 391 393*
db_close_ptr                    000214 automatic       pointer                  dcl 972 set ref 296* 296* 307 354* 354* 356* 368
                                                                                  383* 385 386 387 392 393 396 397 409 410
db_index                               based           fixed bin(35,0)          dcl 911 set ref 325* 334* 356 362* 385
db_mrds_dsl_close                      defined         bit(9)                   packed unaligned dcl 18-62 ref 243
dbc                                    based           structure                level 1 unaligned dcl 10-14
dbc_ptr                         000274 automatic       pointer                  initial dcl 10-44 in procedure "close" set ref
                                                                                  10-44* 417* 460* 463 466 473 495* 497 698 698 704
                                                                                  720*
dbc_ptr                  30            based           pointer                  level 3 in structure "dbcb" dcl 9-142 in procedure
                                                                                  "close" ref 417 495
dbc_uid                 303            based           bit(36)                  level 3 dcl 9-142 ref 461
dbcb                                   based           structure                level 1 dcl 9-142
dbcb_data                              based           structure                level 1 unaligned dcl 9-148
dbcb_ptr                        000272 automatic       pointer                  dcl 9-146 in procedure "close" set ref 325* 328 386
                                                                                  409* 411 417 436 447 449 449 461 494 495 537 565
                                                                                  574 582* 586 586 604 608 614 619 623 629 758 762
                                                                                  772 780 782* 793*
dbcb_ptr                  4            based           pointer                  level 2 in structure "db_close" dcl 968 in procedure
                                                                                  "close" set ref 386* 409
dbi                     114            based           fixed bin(35,0)          level 3 dcl 9-142 set ref 537* 758
dbi_pic                         000171 automatic       picture(3)               packed unaligned dcl 949 set ref 758* 762 764 771
dbi_ptr                         000160 automatic       pointer                  dcl 926 set ref 258* 325 334 356 362 385
delete_tuple             27(02)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 8-32 in procedure "close" ref
                                                                                  530
delete_tuple             26(02)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 8-32 in procedure "close" ref
                                                                                  521
desc_count                1            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 13-6 ref 199
desc_index                      000247 automatic       fixed bin(17,0)          dcl 1004 set ref 211* 213* 214 215 258
desc_ptr                        000302 automatic       pointer                  dcl 12-19 set ref 215* 218
descriptor_ovrly                       based           bit(36)                  packed unaligned dcl 1003 ref 218
dm_error_$bj_journal_full       000144 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$lock_deadlock         000146 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000126 external static fixed bin(35,0)          dcl 1-62 ref 1-90
empty                                                  builtin function         dcl 1021 ref 237
error_code                             based           fixed bin(35,0)          dcl 911 set ref 225* 230* 231 231* 256 258* 261 262*
                                                                                  288 333* 334* 354 361* 362* 467* 480 482* 543 544*
                                                                                  592 594* 684 686* 724 726* 786 788* 809 811* 821
                                                                                  823* 833 835* 864 866* 894 896*
error_code_ptr                  000162 automatic       pointer                  dcl 926 set ref 224* 225 230 231 231 256 258 261 262
                                                                                  288 333 334 354 361 362 467 480 482 543 544 592
                                                                                  594 684 686 724 726 786 788 809 811 821 823 833
                                                                                  835 864 866 894 896
error_table_$argerr             000100 external static fixed bin(35,0)          dcl 1002 ref 765 775
error_table_$bad_arg            000076 external static fixed bin(35,0)          dcl 1001 set ref 218*
error_table_$invalid_lock_reset 000066 external static fixed bin(35,0)          dcl 976 ref 464
error_table_$invalidsegno       000104 external static fixed bin(35,0)          dcl 1010 ref 783
error_table_$lock_not_locked    000102 external static fixed bin(35,0)          dcl 1009 ref 474
error_table_$locked_by_this_process
                                000064 external static fixed bin(35,0)          dcl 976 ref 464 721
error_table_$notadir            000160 external static fixed bin(35,0)          dcl 857 ref 850
error_table_$wrong_no_of_args   000052 external static fixed bin(35,0)          dcl 976 set ref 202*
fd                                     based           structure                level 1 dcl 14-9
fd_ptr                          000312 automatic       pointer                  dcl 14-18 in procedure "close" set ref 608* 609 623*
                                                                                  624 801 805 817 829 841 843 849 850 867 872
fd_ptr                    2            based           pointer                  array level 2 in structure "trel_info" dcl 17-3
                                                                                  in procedure "close" set ref 623 629*
find_condition_info_            000130 constant        entry                    external dcl 1-64 ref 1-123
fixed_bin_35_descr              000251 automatic       bit(36)                  initial packed unaligned dcl 1006 set ref 218 258
                                                                                  258 1006*
fl_ptr                          000300 automatic       pointer                  initial dcl 11-110 set ref 11-110*
flags                    26            based           structure                array level 3 in structure "scope_info" dcl 8-32
                                                                                  in procedure "close"
flags                     4            based           structure                level 3 in structure "dbc" packed packed unaligned
                                                                                  dcl 10-14 in procedure "close"
found                           000360 automatic       bit(1)                   packed unaligned dcl 555 set ref 505* 506 510*
get_process_id_                 000016 constant        entry                    external dcl 937 ref 294
get_temp_segment_               000070 constant        entry                    external dcl 988 ref 230
hcs_$del_dir_tree               000154 constant        entry                    external dcl 853 ref 849
hcs_$delentry_file              000156 constant        entry                    external dcl 855 ref 850
hcs_$delentry_seg               000012 constant        entry                    external dcl 937 ref 782
hcs_$get_uid_seg                000014 constant        entry                    external dcl 937 ref 460
i                               000101 automatic       fixed bin(17,0)          dcl 914 set ref 506* 508 517 519 521 523 526 528 530
                                                                                  532 537 541*
ids                                    based           structure                level 2 unaligned dcl 11-57
index                     2            based           fixed bin(35,0)          level 2 dcl 968 set ref 356 385* 410
iocb_ptr                 10            based           pointer                  level 2 dcl 14-9 set ref 801 805* 817* 829* 841*
iox_$close                      000020 constant        entry                    external dcl 937 ref 805
iox_$destroy_iocb               000024 constant        entry                    external dcl 937 ref 829
iox_$detach_iocb                000022 constant        entry                    external dcl 937 ref 817
j                               000103 automatic       fixed bin(17,0)          dcl 914 set ref 677* 679*
last_db_close_ptr               000220 automatic       pointer                  dcl 974 set ref 392* 396 397*
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 640* 4-62* 4-65 4-68* 4-69 4-78
                                                                                  4-115 4-115* 1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
model_name               10            based           char(30)                 level 2 dcl 6-119 ref 508
modify_attr              26(03)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 8-32 in procedure "close" ref
                                                                                  523
modify_attr              27(03)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 8-32 in procedure "close" ref
                                                                                  532
mrds_data_$lock_wait_time       000056 external static fixed bin(17,0)          dcl 976 set ref 463*
mrds_data_$max_sets             000060 external static fixed bin(17,0)          dcl 976 ref 602
mrds_data_$temp_seg_name        000074 external static char(23)                 packed unaligned dcl 1000 ref 771
mrds_debug_$switch              000122 external static bit(9)                   array packed unaligned dcl 18-135 ref 243 243
mrds_dsl_define_temp_rel$del_trels
                                000042 constant        entry                    external dcl 954 ref 582
mrds_dsl_dl_fscope              000110 constant        entry                    external dcl 1013 ref 537
mrds_dsl_resultant_storage$get_opening_temp_dir
                                000120 constant        entry                    external dcl 1019 ref 590
mrds_error_$inconsistent_close  000062 external static fixed bin(35,0)          dcl 976 ref 467
mrds_error_$invalid_db_index    000050 external static fixed bin(35,0)          dcl 976 ref 333
mrds_error_$list_duplicate      000054 external static fixed bin(35,0)          dcl 976 ref 361
mrds_error_$unknown_proc_id     000072 external static fixed bin(35,0)          dcl 999 ref 539
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 565* 1-86
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 566* 1-84* 1-89* 1-93 1-94* 1-99*
                                                                                  1-100 4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86*
                                                                                  4-96* 4-99* 4-100* 4-109* 4-110* 4-114* 1-107
                                                                                  1-109* 1-110* 1-121
mu_convert_parameter$convert_input_parameter
                                000106 constant        entry                    external dcl 1011 ref 258
mu_cursor_manager_$cleanup_storage
                                000112 constant        entry                    external dcl 1014 ref 449
mu_database_index$get_resultant_model_pointer
                                000040 constant        entry                    external dcl 954 ref 325
mu_database_index$reset_resultant_model_pointer
                                000036 constant        entry                    external dcl 954 ref 780
mu_de_queue_user                000044 constant        entry                    external dcl 954 ref 720
mu_temp_segments$delete_all_temp_segments
                                000032 constant        entry                    external dcl 946 ref 764 774
mu_temp_segments$release_all_temp_segments
                                000034 constant        entry                    external dcl 948 ref 762 772
name                                   based           char(32)                 level 2 in structure "fd" dcl 14-9 in procedure
                                                                                  "close" set ref 843 849 850 867* 872*
name                      6            based           char(30)                 array level 3 in structure "scope_info" dcl 8-32
                                                                                  in procedure "close" ref 508
name                                   based           char(32)                 level 2 in structure "rm_rel_info" dcl 6-119
                                                                                  in procedure "close" set ref 437*
nargs                           000100 automatic       fixed bin(17,0)          dcl 914 set ref 199* 201 211 213 214 215 224 256
never_readied                   000167 automatic       bit(36)                  initial packed unaligned dcl 932 set ref 932*
next                                   based           pointer                  level 2 dcl 968 set ref 307 368 387* 396*
next_open_ofs            23(18)        based           bit(18)                  level 3 packed packed unaligned dcl 11-57 ref 704
next_ul_ptr                     000164 automatic       pointer                  dcl 928 set ref 704* 732* 740
null                                                   builtin function         dcl 1021 ref 229 296 964 8-59 10-44 11-109 11-110
                                                                                  328 354 387 391 412 432 447 497 497 586 586 604
                                                                                  609 614 619 624 629 1-123 1-123 732 755 793 801
                                                                                  841 886 902
num_dims                        000304 automatic       fixed bin(17,0)          initial dcl 12-20 set ref 12-20*
num_ptrs                        000310 automatic       fixed bin(17,0)          dcl 13-14 set ref 197* 214*
num_rels                               based           fixed bin(17,0)          level 2 dcl 7-34 ref 430 432 434 437 578 677 679
offsets                  22            based           structure                level 2 in structure "user_list" packed packed
                                                                                  unaligned dcl 11-57 in procedure "close"
offsets                  21            based           structure                level 3 in structure "dbc" packed packed unaligned
                                                                                  dcl 10-14 in procedure "close"
oid                             000260 automatic       bit(36)                  dcl 1018 set ref 434* 435 436*
open_users_ofs           21            based           bit(18)                  level 4 packed packed unaligned dcl 10-14 ref 698
opening_id               42            based           bit(36)                  level 2 dcl 6-119 ref 434
perm                            000361 automatic       fixed bin(35,0)          dcl 556 set ref 514* 517* 517 519* 519 521* 521 523*
                                                                                  523 537*
permits                  26            based           structure                array level 4 dcl 8-32
pointer                                                builtin function         dcl 1021 ref 698 704 732
prev                            000362 automatic       fixed bin(35,0)          dcl 556 set ref 515* 526* 526 528* 528 530* 530 532*
                                                                                  532 537*
prevents                 27            based           structure                array level 4 dcl 8-32
proc_id                         000157 automatic       bit(36)                  dcl 924 set ref 294* 708
process_id               10            based           bit(36)                  level 3 packed packed unaligned dcl 11-57 ref 708
proper                                 based           structure                level 2 unaligned dcl 10-14
ptr_bit_string                         based           bit(72)                  packed unaligned dcl 929 ref 714
ra_ptr                  134            based           pointer                  level 3 dcl 5-86 ref 415 430 432 434 437
rdbi_bits                14            based           bit(72)                  level 3 packed packed unaligned dcl 11-57 ref 714
rdbi_ptr                        000262 automatic       pointer                  dcl 5-90 in procedure "close" set ref 411* 412 415
                                                                                  430 432 434 437 578 714 755 755 755
rdbi_ptr                               based           pointer                  level 3 in structure "dbcb" dcl 9-142 in procedure
                                                                                  "close" ref 411
read_attr                27            based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 8-32 in procedure "close" ref
                                                                                  526
read_attr                26            based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 8-32 in procedure "close" ref
                                                                                  517
rel                                                    builtin function         dcl 1021 ref 702
rel_data                               based           structure                array level 2 dcl 7-34
release_area_                   000114 constant        entry                    external dcl 1015 ref 755
release_temp_segment_           000116 constant        entry                    external dcl 1016 ref 890
relmgr_entries          146            based           structure                level 3 dcl 9-142
resultant_dir                   000104 automatic       char(168)                packed unaligned dcl 921 set ref 590* 849* 850*
resultant_in_pdir       106(20)        based           bit(1)                   level 3 packed packed unaligned dcl 9-142 ref 762
                                                                                  772
ret_fd_ptr                4            based           pointer                  array level 2 dcl 16-7 set ref 608 614*
retr_info_ptr            22            based           pointer                  level 3 dcl 9-142 ref 586 604 608 614
retrieve_info                          based           structure                level 1 dcl 16-7
return_value                    000210 automatic       fixed bin(35,0)          initial dcl 965 set ref 202* 218* 231* 262* 334*
                                                                                  362* 437* 451* 477* 541* 965* 1-140* 595* 4-115*
                                                                                  727* 765* 775* 789* 812* 824* 836* 867* 897*
ri_ptr                                 based           pointer                  array level 3 packed packed unaligned dcl 7-34 ref
                                                                                  432 434 437 679
rm_db_info                             based           structure                level 1 dcl 5-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 5-92
rm_rel_array                           based           structure                level 1 dcl 7-34
rm_rel_info                            based           structure                level 1 dcl 6-119
rmra_ptr                        000266 automatic       pointer                  dcl 7-43 set ref 415* 677 679
rmri_ptr                        000264 automatic       pointer                  dcl 6-156 set ref 508 679*
scope                     6            based           structure                array level 2 dcl 8-32
scope_flags                            based           structure                level 1 dcl 8-42
scope_info                             based           structure                level 1 dcl 8-32
scope_lock               13            based           bit(36)                  level 3 dcl 10-14 set ref 463* 473*
scope_ptr                       000270 automatic       pointer                  initial dcl 8-59 in procedure "close" set ref 8-59*
                                                                                  494* 497 500 506 508 517 519 521 523 526 528 530
                                                                                  532 537 541
scope_ptr                34            based           pointer                  level 3 in structure "dbcb" dcl 9-142 in procedure
                                                                                  "close" ref 494
secured                         000156 automatic       bit(1)                   packed unaligned dcl 922 set ref 416*
seg_fault_error                 000252 stack reference condition                dcl 1008 ref 249
set_lock_$lock                  000026 constant        entry                    external dcl 937 ref 463
set_lock_$unlock                000030 constant        entry                    external dcl 937 ref 473
sm_name                  16            based           char(32)                 array level 3 dcl 8-32 set ref 537* 541*
static_area             142            based           area                     level 2 dcl 5-86 set ref 755 755
sub_err_                        000046 constant        entry                    external dcl 961 ref 202 218 231 262 334 362 437 451
                                                                                  468 477 541 1-140 595 4-115 727 765 775 789 812
                                                                                  824 836 867 897
sub_error_                      000000 stack reference condition                dcl 998 ref 245
substr                                                 builtin function         dcl 1021 ref 243
temp_seg_name                   000172 automatic       char(26)                 packed unaligned dcl 950 set ref 771* 772* 774* 775*
temp_uid                        000170 automatic       bit(36)                  dcl 933 set ref 459* 460* 461
tra_ptr                 136            based           pointer                  level 3 dcl 5-86 ref 578
transaction_manager_$abandon_txn
                                000132 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
transaction_manager_$abort_txn  000134 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109
transaction_manager_$begin_txn  000136 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000150 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000140 constant        entry                    external dcl 1-75 ref 1-89
transaction_manager_$handle_conditions
                                000142 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000152 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed     106(13)        based           bit(1)                   level 3 packed packed unaligned dcl 9-142 ref 565
trel_info                              based           structure                level 1 dcl 17-3
trel_info_ptr            24            based           pointer                  level 3 dcl 9-142 ref 586 619 623 629
trouble_switch            4            based           bit(1)                   level 4 packed packed unaligned dcl 10-14 set ref
                                                                                  466*
ul_ptr                          000276 automatic       pointer                  initial dcl 11-109 set ref 11-109* 698* 702 704 708
                                                                                  714 720* 740*
unique                          000332 automatic       bit(1)                   packed unaligned dcl 374 set ref 352* 360* 371
unused_ptr                      000206 automatic       pointer                  initial dcl 964 set ref 202* 218* 231* 262* 334*
                                                                                  362* 437* 451* 468* 477* 541* 964* 1-140* 595*
                                                                                  4-115* 727* 765* 775* 789* 812* 824* 836* 867*
                                                                                  897*
user_list                              based           structure                level 1 unaligned dcl 11-57
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 in procedure "delete_temp_rels" set ref
                                                                                  1-92* 1-98* 574 4-60
user_started_transaction
                        106(22)        based           bit(1)                   level 3 in structure "dbcb" packed packed unaligned
                                                                                  dcl 9-142 in procedure "close" set ref 574*
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*
valid                           000322 automatic       bit(1)                   packed unaligned dcl 343 set ref 328* 332* 340
vfile_type                      000230 automatic       varying char(20)         dcl 992 set ref 612* 627* 812* 824* 836* 867*
work_area                              based           area(1024)               dcl 986 set ref 237* 383
work_area_ptr                   000224 automatic       pointer                  dcl 987 set ref 229* 230* 237 258* 383 886 890* 902*
x                               000102 automatic       fixed bin(17,0)          dcl 914 set ref 430* 432 434 437* 602* 608 614 623
                                                                                  629*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALARM                                  automatic       fixed bin(71,0)          dcl 11-127
ALIVE                                  internal static bit(1)                   initial packed unaligned dcl 11-136
ALL_OPS                                internal static fixed bin(17,0)          initial dcl 15-18
CHAR_ALARM                             internal static char(8)                  initial packed unaligned dcl 11-125
CHAR_Q_F                               internal static char(8)                  initial packed unaligned dcl 11-123
DEAD                                   internal static bit(1)                   initial packed unaligned dcl 11-138
DEL                                    internal static bit(1)                   initial packed unaligned dcl 11-134
FIRST_QUEUE                            internal static bit(1)                   initial packed unaligned dcl 11-128
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
NO_DQ_OPEN                             internal static bit(1)                   initial packed unaligned dcl 11-121
NULL_OFS                               internal static bit(18)                  initial packed unaligned dcl 11-118
QUEUE_AGAIN                            internal static bit(1)                   initial packed unaligned dcl 11-130
QUE_FREE                               automatic       fixed bin(71,0)          dcl 11-124
Q_PRM                                  internal static fixed bin(35,0)          initial dcl 11-140
Q_PRM_BITS                             internal static bit(2)                   initial packed unaligned dcl 11-144
Q_PRV                                  internal static fixed bin(35,0)          initial dcl 11-142
Q_PRV_BITS                             internal static bit(2)                   initial packed unaligned dcl 11-146
REL_SEC                                internal static bit(2)                   initial packed unaligned dcl 11-148
SAVE_FIL_LIST                          internal static bit(1)                   initial packed unaligned dcl 11-152
SET                                    internal static bit(1)                   initial packed unaligned dcl 11-132
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
UPDATE_OPS                             internal static fixed bin(17,0)          initial dcl 15-18
VERSION_NBR                            internal static fixed bin(17,0)          initial dcl 10-46
WAIT                                   internal static fixed bin(17,0)          initial dcl 11-115
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
db_mrds_dsl_eval_expr                  defined         bit(9)                   packed unaligned dcl 18-62
db_mrds_dsl_gen_srch_prog              defined         bit(9)                   packed unaligned dcl 18-62
db_mrds_dsl_get_token                  defined         bit(9)                   packed unaligned dcl 18-62
db_mrds_dsl_init_res                   defined         bit(9)                   packed unaligned dcl 18-62
db_mrds_dsl_open                       defined         bit(9)                   packed unaligned dcl 18-62
db_mrds_dsl_optimize                   defined         bit(9)                   packed unaligned dcl 18-62
db_mrds_dsl_permute                    defined         bit(9)                   packed unaligned dcl 18-62
db_mrds_dsl_search                     defined         bit(9)                   packed unaligned dcl 18-62
db_mrds_dsl_set_fscope                 defined         bit(9)                   packed unaligned dcl 18-62
db_mrds_dsl_translate                  defined         bit(9)                   packed unaligned dcl 18-62
db_mrds_dsl_where_clause               defined         bit(9)                   packed unaligned dcl 18-62
db_mrds_rst_dmdm                       defined         bit(9)                   packed unaligned dcl 18-62
db_mu_concurrency_control              defined         bit(9)                   packed unaligned dcl 18-62
db_mu_open_iocb_manager                defined         bit(9)                   packed unaligned dcl 18-62
db_mu_open_name_manager                defined         bit(9)                   packed unaligned dcl 18-62
db_mu_retrieve                         defined         bit(9)                   packed unaligned dcl 18-62
db_mu_sec_get_tid                      defined         bit(9)                   packed unaligned dcl 18-62
db_mu_sec_get_tuple                    defined         bit(9)                   packed unaligned dcl 18-62
db_mu_sec_init_res                     defined         bit(9)                   packed unaligned dcl 18-62
db_mus_mod_ubtup                       defined         bit(9)                   packed unaligned dcl 18-62
descriptor                             based           structure                level 1 unaligned dcl 12-6
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
fil_list                               based           structure                level 1 unaligned dcl 11-89
fixed                                                  builtin function         dcl 1021
max_file_init                          automatic       fixed bin(17,0)          dcl 8-58
module                                 internal static structure                level 1 unaligned dcl 18-91
mrds_data_$max_data_length             external static fixed bin(17,0)          dcl 976
natts_init                             automatic       fixed bin(17,0)          dcl 6-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 6-157
num_filns                              automatic       fixed bin(17,0)          dcl 11-112
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 6-157
retrieve_info_version                  internal static fixed bin(35,0)          initial dcl 16-17
rm_num_rels_init                       automatic       fixed bin(17,0)          dcl 7-44
scope_rdy                              internal static bit(6)                   initial packed unaligned dcl 8-60
scope_rdy_array                        based           bit(1)                   array packed unaligned dcl 8-61
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 976
trel_version                           internal static fixed bin(17,0)          initial dcl 17-7

NAMES DECLARED BY EXPLICIT CONTEXT.
add_index                       002077 constant        entry                    internal dcl 378 ref 280
clean_up                        005573 constant        entry                    internal dcl 881 ref 246 312
close                           001000 constant        entry                    external dcl 27
close_database                  002124 constant        entry                    internal dcl 402 ref 305
delete_file_scope               002616 constant        entry                    internal dcl 490 ref 680
delete_temp_rels                003123 constant        entry                    internal dcl 559 ref 426
delete_vfile_seg                005006 constant        entry                    internal dcl 796 ref 613 628
exit                            001627 constant        label                    dcl 312 ref 249
finish_files                    004203 constant        entry                    internal dcl 672 ref 422
mftxn_check_code                003555 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      003775 constant        label                    dcl 4-115 ref 4-63
mrds_dsl_close                  001010 constant        entry                    external dcl 27
mstxn_any_other                 004075 constant        entry                    internal dcl 1-116 ref 568
mstxn_cleanup                   004043 constant        entry                    internal dcl 1-102 ref 567
mstxn_exit                      003242 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
remove_open_user                004242 constant        entry                    internal dcl 693 ref 472
remove_resultant                004406 constant        entry                    internal dcl 746 ref 485
restore_significant_data        004172 constant        entry                    internal dcl 657 ref 4-77
should_rollback                 004174 constant        entry                    internal dcl 663 ref 4-94
unique_index                    001754 constant        entry                    internal dcl 347 ref 275
valid_index                     001634 constant        entry                    internal dcl 319 ref 270

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6734        7116    5725        6744
Length     10046    5725       162         713    1007           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
close                               802 external procedure  is an external procedure.  
on unit on line 240                  70 on unit             enables or reverts conditions.  
on unit on line 245                  64 on unit               
on unit on line 249                  64 on unit               
valid_index                             internal procedure  shares stack frame of external procedure close.  
unique_index                            internal procedure  shares stack frame of external procedure close.  
add_index                               internal procedure  shares stack frame of external procedure close.  
close_database                          internal procedure  shares stack frame of external procedure close.  
delete_file_scope                       internal procedure  shares stack frame of external procedure close.  
delete_temp_rels                    402 internal procedure  enables or reverts conditions.  
on unit on line 567                  76 on unit               
on unit on line 568                  82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 567.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 568.  
restore_significant_data                internal procedure  shares stack frame of internal procedure delete_temp_rels.  
should_rollback                         internal procedure  shares stack frame of internal procedure delete_temp_rels.  
finish_files                            internal procedure  shares stack frame of external procedure close.  
remove_open_user                        internal procedure  shares stack frame of external procedure close.  
remove_resultant                        internal procedure  shares stack frame of external procedure close.  
delete_vfile_seg                        internal procedure  shares stack frame of internal procedure delete_temp_rels.  
begin block on line 847                 begin block         shares stack frame of internal procedure delete_temp_rels.  
clean_up                            110 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
close                    000100 nargs                       close
                         000101 i                           close
                         000102 x                           close
                         000103 j                           close
                         000104 resultant_dir               close
                         000156 secured                     close
                         000157 proc_id                     close
                         000160 dbi_ptr                     close
                         000162 error_code_ptr              close
                         000164 next_ul_ptr                 close
                         000166 code                        close
                         000167 never_readied               close
                         000170 temp_uid                    close
                         000171 dbi_pic                     close
                         000172 temp_seg_name               close
                         000201 caller_name                 close
                         000205 continue                    close
                         000206 unused_ptr                  close
                         000210 return_value                close
                         000211 OFF                         close
                         000212 ON                          close
                         000214 db_close_ptr                close
                         000216 db_close_list_ptr           close
                         000220 last_db_close_ptr           close
                         000222 arg_count                   close
                         000224 work_area_ptr               close
                         000226 NOT_READY                   close
                         000227 NULL_OFFSET                 close
                         000230 vfile_type                  close
                         000244 clean_up_condition          close
                         000245 BLANK                       close
                         000246 close_index                 close
                         000247 desc_index                  close
                         000250 SPECIAL                     close
                         000251 fixed_bin_35_descr          close
                         000260 oid                         close
                         000262 rdbi_ptr                    close
                         000264 rmri_ptr                    close
                         000266 rmra_ptr                    close
                         000270 scope_ptr                   close
                         000272 dbcb_ptr                    close
                         000274 dbc_ptr                     close
                         000276 ul_ptr                      close
                         000300 fl_ptr                      close
                         000302 desc_ptr                    close
                         000304 num_dims                    close
                         000306 al_ptr                      close
                         000310 num_ptrs                    close
                         000312 fd_ptr                      close
                         000322 valid                       valid_index
                         000332 unique                      unique_index
                         000360 found                       delete_file_scope
                         000361 perm                        delete_file_scope
                         000362 prev                        delete_file_scope
delete_temp_rels         000100 mstxn_code                  delete_temp_rels
                         000101 mstxn_retries               delete_temp_rels
                         000102 mstxn_temp_code             delete_temp_rels
                         000103 mstxn_transactions_needed   delete_temp_rels
                         000104 user_started_transaction    delete_temp_rels
                         000105 mstxn_txn_id                delete_temp_rels
                         000106 user_transaction_id         delete_temp_rels
                         000110 mstxn_condition_info        delete_temp_rels
                         000142 mftxn_code                  delete_temp_rels
                         000143 mftxn_temp_code             delete_temp_rels

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ent_var        call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry           int_entry
trunc_fx2           divide_fx1          op_alloc_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           cu_$arg_list_ptr              find_condition_info_          get_process_id_
get_temp_segment_             hcs_$del_dir_tree             hcs_$delentry_file            hcs_$delentry_seg
hcs_$get_uid_seg              iox_$close                    iox_$destroy_iocb             iox_$detach_iocb
mrds_dsl_define_temp_rel$del_trels                          mrds_dsl_dl_fscope
mrds_dsl_resultant_storage$get_opening_temp_dir             mu_convert_parameter$convert_input_parameter
mu_cursor_manager_$cleanup_storage                          mu_database_index$get_resultant_model_pointer
mu_database_index$reset_resultant_model_pointer             mu_de_queue_user
mu_temp_segments$delete_all_temp_segments                   mu_temp_segments$release_all_temp_segments
release_area_                 release_temp_segment_         set_lock_$lock                set_lock_$unlock
sub_err_                      transaction_manager_$abandon_txn
transaction_manager_$abort_txn                              transaction_manager_$begin_txn
transaction_manager_$commit_txn                             transaction_manager_$get_current_txn_id
transaction_manager_$handle_conditions                      transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
error_table_$argerr           error_table_$bad_arg          error_table_$invalid_lock_reset
error_table_$invalidsegno     error_table_$lock_not_locked  error_table_$locked_by_this_process
error_table_$notadir          error_table_$wrong_no_of_args mrds_data_$lock_wait_time     mrds_data_$max_sets
mrds_data_$temp_seg_name      mrds_debug_$switch            mrds_error_$inconsistent_close
mrds_error_$invalid_db_index  mrds_error_$list_duplicate    mrds_error_$unknown_proc_id




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    932 000742       962 000743       963 000746       964 000750       965 000752       966 000753       967 000754
    990 000756       991 000757       996 000761      1005 000763      1006 000765    8   59 000767   10   44 000771
11  109 000772   11  110 000773   12   20 000774        27 000777       197 001016       198 001017       199 001026
    201 001037       202 001041       206 001141       211 001142       213 001153       214 001155       215 001157
    218 001164       224 001236       225 001242       229 001244       230 001247       231 001270       237 001340
    238 001343       240 001345       242 001361       243 001364       245 001371       246 001406       247 001413
    249 001414       255 001433       256 001435       258 001443       261 001474       262 001476       266 001560
    270 001561       275 001567       280 001575       284 001576       286 001577       288 001600       294 001603
    296 001614       305 001622       307 001623       312 001627      1050 001633       319 001634       325 001636
    328 001647       332 001656       333 001660       334 001663       340 001746       347 001754       352 001756
    354 001760       356 001770       360 001775       361 001777       362 002002       368 002065       371 002071
    378 002077       383 002100       385 002105       386 002107       387 002111       391 002113       392 002116
    393 002117       394 002120       396 002121       397 002122       400 002123       402 002124       409 002125
    410 002130       411 002133       412 002135       415 002142       416 002144       417 002145       422 002150
    426 002151       430 002155       432 002165       434 002204       435 002210       436 002211       437 002222
    443 002312       447 002314       449 002321       451 002334       459 002375       460 002376       461 002411
    463 002417       464 002433       466 002442       467 002445       468 002447       471 002516       472 002517
    473 002520       474 002532       477 002540       480 002607       482 002612       485 002614       488 002615
    490 002616       494 002617       495 002622       497 002625       500 002636       505 002641       506 002642
    508 002653       510 002665       514 002667       515 002671       517 002672       519 002703       521 002712
    523 002721       526 002730       528 002737       530 002746       532 002755       537 002764       538 003015
    539 003020       541 003025       543 003112       544 003115       549 003117       557 003121       559 003122
    565 003130       566 003136       567 003137       568 003155    1   83 003173    1   86 003174    1   88 003176
 1   89 003177    1   90 003210    1   92 003214    1   93 003216    1   94 003220    1   95 003221    1   98 003222
 1   99 003223    1  100 003240    1  140 003242       574 003307       578 003316       582 003321       586 003330
    590 003343       591 003356       592 003361       594 003364       595 003366       599 003436       602 003437
    604 003450       608 003456       609 003463       612 003470       613 003475       614 003476       619 003506
    623 003514       624 003521       627 003526       628 003533       629 003534       632 003543       640 003545
 4   60 003546    4   62 003553    4   63 003554    4   65 003555    4   68 003557    4   69 003570    4   71 003572
 4   72 003603    4   75 003616    4   77 003617    4   78 003620    4   81 003627    4   82 003630    4   83 003643
 4   85 003645    4   86 003656    4   88 003671    4   90 003672    4   91 003673    4   93 003674    4   94 003675
 4   96 003702    4   97 003716    4   99 003720    4  100 003731    4  102 003744    4  104 003745    4  105 003746
 4  107 003747    4  109 003750    4  110 003761    4  114 003774    4  115 003775       670 004042    1  102 004043
 1  107 004044    1  109 004047    1  110 004060    1  114 004074    1  116 004075    1  121 004076    1  123 004101
 1  124 004120    1  126 004126    1  127 004131    1  129 004134    1  132 004146    1  133 004151    1  135 004154
 1  136 004161    1  137 004162    1  138 004171       657 004172       659 004173       663 004174       665 004176
    672 004203       677 004204       679 004213       680 004227       684 004230       686 004235       688 004237
    691 004241       693 004242       698 004243       702 004251       704 004255       708 004263       714 004267
    720 004274       721 004313       724 004321       726 004324       727 004326       732 004375       734 004402
    740 004403       741 004404       744 004405       746 004406       755 004407       758 004425       762 004436
    764 004462       765 004502       771 004545       772 004562       774 004604       775 004620       780 004675
    782 004710       783 004721       786 004727       788 004732       789 004734       793 005003       794 005005
    796 005006       801 005007       805 005016       806 005027       809 005033       811 005036       812 005040
    817 005132       818 005145       821 005151       823 005154       824 005156       829 005245       830 005260
    833 005264       835 005267       836 005271       841 005363       843 005367       849 005374       850 005422
    861 005455       864 005461       866 005464       867 005466       872 005564       879 005571       881 005572
    886 005600       890 005606       891 005626       894 005632       896 005635       897 005637       902 005704
    909 005707


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
