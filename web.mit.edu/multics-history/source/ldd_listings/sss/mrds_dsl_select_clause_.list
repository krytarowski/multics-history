	COMPILATION LISTING OF SEGMENT mrds_dsl_select_clause_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1335.4 mst Mon
	    Options: optimize map

        1 /****^  ********************************************
        2*        *                                          *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988 *
        4*        *                                          *
        5*        ******************************************** */
        6 
        7 
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
       11*     audit(88-07-07,Dupuis), install(88-08-01,MR12.2-1073):
       12*     Written.
       13*                                                   END HISTORY COMMENTS */
       14 
       15 
       16 mrds_dsl_select_clause_:
       17     proc ();
       18 
       19 /* DESCRIPTION:
       20*
       21*   BEGIN_DESCRIPTION
       22*   This  procedure  translates  the  -select  clause  within  a  DSL selection
       23*   expression  into a tabular form which can be efficiently processed when the
       24*   data is being accessed. The various entrypoints are called by
       25*   mrds_dsl_semantics during the parse.
       26*
       27*
       28*   INPUT CONDITIONS:
       29*
       30*   compiled_clause entry:
       31*   This handles a selection expression that consists of a -compiled only.
       32*
       33*   all_attributes entry:
       34*   This handles the portion of a select clause that is meant to return
       35*   a dump of the relation. It is of the type "-select a".
       36*
       37*   one_attribute entry:
       38*   This handles the portion of a select clause that is meant to return
       39*   a single attribute. It is of the type "-select a.car".
       40*
       41*   finish entry:
       42*   This is called after all of the individual select items have been
       43*   dealt with. It wraps up the processing of the select clause.
       44*
       45*
       46*   END_DESCRIPTION
       47*
       48*   HISTORY:
       49*
       50*   76-01-01 J. A. Weeldreyer: Initially written.
       51*
       52*   76-09-01 J. A. Weeldreyer: Modified to correct assign_ length problem.
       53*
       54*   76-09-02 J. A. Weeldreyer: Modified to correct area ptr init problem.
       55*
       56*   76-10-01  J.   A.   Weeldreyer:  Modified  to  return error if key attr not
       57*   defined for temp rel.
       58*
       59*   76-11-01 J . A. Weeldreyer: Modified  to fix temp rel key problem.
       60*
       61*   76-11-02 J. A. Weeldreyer: Modified to incorporate inverted attributes.
       62*
       63*   77-04-01  J.   A.   Weeldreyer:  Modified  to  implement -dup and to remove
       64*   complex range code.
       65*
       66*   77-12-01 Oris D.  Friesen: Modified to allocate 'store -another' version of
       67*   select_list.
       68*
       69*   78-09-01 J. A. Weeldreyer: Modified for MR7.0.
       70*
       71*   79-03-22 Al Kepner: Modified to add scope checking.
       72*
       73*   79-03-25  Al  Kepner:  Modified  by  to  include all range variables in the
       74*   tuple_info  structure  and  to flag those range variables which are used in
       75*   the -select clause.
       76*
       77*   79-06-01 Al Kepner: Modified to use select_area.
       78*
       79*   79-11-01 Jim Gray: Modified to make hanlding of deletes with se_values work
       80*   correctly,  by considering the caller, and not gobbling up the se_values as
       81*   arg values.
       82*
       83*   80-01-01     Jim     Gray     :     Modified     to     add     call     to
       84*   mu_valid_data_type$valid_scalar_data_type, so that packed decimal could be properly
       85*   handled.
       86*
       87*   80-01-15  Jim  Paradise:  Updated  to update the move lists on handling the
       88*   -another entry: set_user_vals.
       89*
       90*   80-02-01 Jim Gray : Modified to add area_ptr parameter in all entries.
       91*
       92*   80-05-07 Davids: modified assignments of tuple_num_atts and tuple_nvar_atts
       93*   to  take  values from rm_rel_info.model_num_attr and model_nvar_atts rather
       94*   than  rm_rel_info.num_attr  and  nvar_atts.  This was to fix a problem with
       95*   submodels were the submodel view did not contain a varying string attribute
       96*   and the model did.
       97*
       98*   80-09-25   Davids:  the  internal  procedure  check_access  was  added  and
       99*   appropriate  calls  placed  in  the  code.   this module will now check the
      100*   access  on  all  attributes specified in the select clause for the retrieve
      101*   and  modify  operations.   if  the  user  does  not  have  access the error
      102*   incorrect  attribute access is returned.  access at the relation level i.e.
      103*   append  and  delete  are  done  elsewhere.  the information needed to check
      104*   these  access  are  not  easily  gotten  at  this level in all cases.  also
      105*   removed  the declared but never referenced variables.
      106*
      107*   80-11-05  Jim Gray : Modified to "and" the mdbm_secured bit with the r_perm
      108*   bits in rm_attr_info so that secure_mrds_db turns this check on.
      109*
      110*   80-12-10 Jim Gray : changed scope mode checks to agree with change from r-u
      111*   to  r-s-m-d  type  modes, also changed names to read_attr, modify_attr, and
      112*   delete_tuple  to  agree  with  security  compatiple  names.  Documented and
      113*   cleaned  up  the  scope  checking  code.   Added  sub_err_  messages on the
      114*   particulars  of  the  scope  violation.  This was done with the new routine
      115*   scope_error.   The  mrds_data_$caller_xxx  parameters were changed to fixed
      116*   bin(35) to agree with the mrds_data_ declarations.
      117*
      118*   81-06-01 Jim Gray : changed to use new resultant structure.
      119*
      120*   81-06-23 Jim Gray : added fix to re-use space for select_list structure
      121*   when many -current operations are done, ala TR 10193.
      122*
      123*   81-09-09 Davids: modified so that the internal routine set_u_val is not
      124*   called for the case of a define_temp_rel. TR 11447
      125*
      126*   81-12-18 Davids: Modified so that the val_del and  val_mod  flags
      127*   are  no  longer set to "0"b if an attribute comes from a temp_rel
      128*   or if the range variable (if no attributes are specified)  refers
      129*   to  a  temp_rel.  This  is so that temp_rels can be updated. Also
      130*   deleted declared but unreferenced variables.
      131*
      132*   82-06-16 Mike Kubicar : Added the fix for TR phx12345.  This module
      133*   would take an area condition if many retrieves with a selection expression
      134*   of "-current ..." were done in a row.
      135*
      136*   82-08-27 Mike Kubicar : Removed tuple structure and allocation of tuples.
      137*
      138*   82-09-22 Davids: removed references to dbcb.transact_ctl_seg, since this
      139*   bit was always "0"b and the if statements testing it always used ^dbcb...
      140*   not much really changed.
      141*
      142*   82-11-02 Mike Kubicar : Changed make_tuple_info (and added a bit of code)
      143*   to pre-allocate enough space of any simple vectors needed for a search.
      144*
      145*   83-04-06 Davids: Modified the scope checking code to use the new
      146*   scope_flags_ptr in the rm_rel_info structure instead of sequentially
      147*   looking through th escope_info array for the correct relation.
      148*   The declaration to the variable j was deleted since it is no longer used.
      149*   Also explicitly declared the mod builtin function.
      150*
      151*   83-04-11 Davids: Replaced reference to add_bit_offset_ with a reference to
      152*   addnitno.
      153*
      154*   83-04-22 R. Harvey: added code to set bits in the attr_needed_list structure
      155*   so that less data may be copied from the relation manager.
      156*
      157*   84-07-19 Hergert: Moved set_user_vals out of here and made it external.
      158*   Also took set_u_vals and update_movelists with it. Changed calls to
      159*   set_u_vals to mrds_dsl_set_user_vals. This was all done as
      160*   a performancce improvement in the processing of -another's
      161*
      162*   84-09-05 Hergert: Added check for call from dsl_$compile so we dont
      163*   bother checking scope or setting user vals since we dont know them anyway.
      164*   Also added entry point compiled_clause for handling compiled se.
      165*
      166*   84-11-01 Hergert: Added call to mu_print_error for reporting errors.
      167*
      168*   84-11-25 Hergert: created procedure check_scope so that we will check scope
      169*   on compiled selection expressions. This was an oversight during the original
      170*   implemantation. Also made struct free_relations to handle this problem.
      171*
      172*   84-12-12 Hergert: Added code to initialize the select_list structure. There
      173*   were certain situations where the random data in the pointers caused
      174*   fault_tags.
      175*
      176*   85-11-22 Hergert: Removed all references to var_exists_ptr. Moved
      177*   variable var_exists into select_list structure. It needs to be kept
      178*   around for compiling select expresssions, and it doesnt need to be
      179*   kept for normal processing. This seemed to be the best compromise.
      180*
      181*   86-05-05 Hergert: Reorganized and modified for new parser.
      182**/
      183 
      184 compiled_clause:
      185     entry (dbcb_ptr, area_ptr, caller, argp_ptr, descp_ptr, num_args, trl_ptr,
      186         cur_sw, code);
      187 
      188 /* this entry processes a selection expression consisting of only a -compiled
      189*   clause. It sets up the user values and the move lists for the actual use
      190*   of a compiled select expression.
      191**/
      192 
      193         compiled_sw = "1"b;
      194         select_area_ptr = dbcb.select_area_ptr;
      195 
      196         if dbcb.ss_ptr = null then do;
      197 	  range_ptr = dbcb.range_ptr;			/* pick up correct ptr to range list */
      198 	  select_list_ptr = dbcb.select_ptr;		/* and select list */
      199         end;
      200         else do;					/* if complex select. expr. */
      201 	  ss_ptr = dbcb.ss_ptr;
      202 	  range_ptr = select_sets.items.range_ptr (1);
      203 	  select_list_ptr = select_sets.items.select_ptr (1);
      204         end;
      205 
      206 /* make sure no one has changed a temp rel on us since we first compiled this se */
      207         if trl_ptr ^= null
      208         then
      209 	  do i = 1 to temp_rel_list.number_of_temp_rels;
      210 	      if dbcb.rdbi_ptr -> rm_db_info.tra_ptr
      211 		-> rm_rel_array.name.submodel (temp_rel_list.index (i)) ^=
      212 		temp_rel_list.name (i)
      213 	      then call error (mrds_error_$undef_temp_rel, ^LOUD, 0, "", "");
      214 	  end;
      215 
      216         call mrds_dsl_set_user_vals
      217 	  (dbcb_ptr, area_ptr, argp_ptr, descp_ptr, num_args,
      218 	  select_list_ptr, code);
      219         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      220 
      221         call check_scope;				/* make sure proper scope has been set */
      222 
      223         if dbcb.ss_ptr ^= null then do;			/* must copy user data */
      224 	  s_ptr = select_sets.items.select_ptr (1);	/* data from 1st block */
      225 	  do k = 2 to select_sets.nitems;
      226 	      if ^select_sets.oper_flag (k) then do;
      227 		select_list_ptr = select_sets.items.select_ptr (k);
      228 		do i = 1 to select_list.num_items;	/* can copy because from same domains */
      229 		    select_list.item.user_ptr (i) =
      230 		        s_ptr -> select_list.item.user_ptr (i);
      231 		    select_list.item.must_convert (i) =
      232 		        s_ptr -> select_list.item.must_convert (i);
      233 		    select_list.item.user_desc_ptr (i) =
      234 		        s_ptr -> select_list.item.user_desc_ptr (i);
      235 		    call make_move_lists;
      236 		end;
      237 	      end;
      238 	  end;
      239         end;
      240         else call make_move_lists;
      241 
      242         return;
      243 
      244 all_attributes:
      245     entry (dbcb_ptr, a_range_ptr, a_select_list_ptr, a_rmri_ptr,
      246         relation_index, cur_sw, caller, code);
      247 
      248 /* this entry process a single token appearing in a select clause.
      249*   This is assumed to be either a reference to dump a whole relation
      250*   or a single attribute in a relation that need no other qualification.
      251**/
      252         range_ptr = a_range_ptr;
      253         select_list_ptr = a_select_list_ptr;
      254         rmri_ptr = a_rmri_ptr;
      255         dbcb.val_mod = "0"b;				/* whole tuple includes key attr. */
      256         var_exists (relation_index) = "1"b;		/* remember this var selected */
      257         range.tup_var.used (relation_index) = "1"b;	/* remember this var used */
      258         ss_ptr = dbcb.ss_ptr;
      259 
      260         if ss_ptr = null then check_sw = "0"b;
      261         else check_sw = "1"b;
      262 
      263         compiled_sw = "0"b;
      264 
      265         if caller ^= mrds_data_$caller_delete
      266         then do;
      267 	  if ^cur_sw
      268 	  then range.tup_var.whole_tuple_selected (relation_index) = "1"b;
      269 						/* remember whole tuple selected */
      270 	  else if ^range.tup_var.whole_tuple_selected (relation_index) &
      271 		 ^range.tup_var.copied_for_current (relation_index)
      272 	       then range.tup_var.copy_for_current (relation_index) = "1"b;
      273         end;
      274 
      275 /* Keep a list of relations associated with free tuple
      276*   variables (scope must be set before use.) */
      277 
      278         if ^range.tup_var.temp_rel (relation_index)
      279         then call add_free_rel (relation_index);		/* add_assoc. rels. to free list */
      280 
      281         do i = 1 to rm_rel_info.num_attr;		/* for each attribute */
      282 
      283 	  if ^rm_rel_info.mdbm_secured
      284 	  then call check_access (caller,
      285 		 rm_rel_info.attr_ptrs (i) -> rm_attr_info.read_perm,
      286 		 rm_rel_info.attr_ptrs (i) -> rm_attr_info.modify_perm);
      287 
      288 	  if select_list.num_items >= mrds_data_$max_select_items
      289 	  then do;				/* if no more room */
      290 	      call ioa_$rsnnl ("Only ^d items are allowed.", err_msg,
      291 		err_msg_len, mrds_data_$max_select_items);
      292 	      call error (mrds_error_$max_select_items, LOUD, 0, SC_TYPE,
      293 		err_msg);
      294 	  end;
      295 
      296 	  select_list.num_items = select_list.num_items + 1;
      297 						/* we have room, increment count */
      298 	  unspec (select_list.item (select_list.num_items)) = "0"b;
      299 
      300 	  if check_sw
      301 	  then					/* if checking union compat */
      302 	       if dbcb.prev_select then do;		/* if have prev block */
      303 		  if rm_rel_info.attr_ptrs (i)
      304 		      -> rm_attr_info.domain_ptr -> rm_domain_info.name ^=
      305 		      select_sets.domains (select_list.num_items)
      306 		  then				/* if not compat */
      307 		       call error (mrds_error_$block_dom_incons, LOUD, 0,
      308 			 SC_TYPE,
      309 			 "");
      310 	       end;
      311 
      312 	  select_list.item.key (select_list.num_items) = "0"b;
      313 						/* temp rel keys must
      314*						   be spec. explic. */
      315 	  select_list.item.index (select_list.num_items) = "0"b;
      316 	  select_list.item.var_index (select_list.num_items) =
      317 	      relation_index;
      318 	  select_list.item.ai_ptr (select_list.num_items) =
      319 	      rm_rel_info.attr_ptrs (i);
      320 
      321         end;					/* looping through attrib. */
      322 
      323         return;
      324 
      325 one_attribute:
      326     entry (dbcb_ptr, a_range_ptr, a_select_list_ptr, a_rmri_ptr, attr_index,
      327         relation_index, temp_rel_key, cur_sw, caller, code);
      328 
      329 /* this entry process a uniquely qualified attribute in a select clause.
      330*   This is the case when the realtion and an attribute are specified
      331*   as in -select a.foo
      332**/
      333 
      334         range_ptr = a_range_ptr;
      335         select_list_ptr = a_select_list_ptr;
      336         rmri_ptr = a_rmri_ptr;
      337         ai_ptr = rm_rel_info.attr_ptrs (attr_index);
      338         ss_ptr = dbcb.ss_ptr;
      339 
      340         if ss_ptr = null then check_sw = "0"b;
      341         else check_sw = "1"b;
      342 
      343         compiled_sw = "0"b;
      344 
      345         if select_list.num_items >= mrds_data_$max_select_items
      346         then do;					/* If we already have max items */
      347 	  call ioa_$rsnnl ("Only ^d items are allowed.", err_msg,
      348 	      err_msg_len, mrds_data_$max_select_items);
      349 	  call error (mrds_error_$max_select_items, LOUD, 0, SC_TYPE,
      350 	      err_msg);
      351         end;
      352 
      353         if select_list.num_items > 0
      354 	  & select_list.item.var_index (select_list.num_items)
      355 	  ^= relation_index
      356         then dbcb.val_mod, dbcb.val_del = "0"b;		/* cant update mult. tuples */
      357 
      358         select_list.num_items = select_list.num_items + 1;	/* have more room, so bump up count */
      359         unspec (select_list.item (select_list.num_items)) = "0"b;
      360 
      361         if check_sw
      362         then					/* if checking union compat */
      363 	   if dbcb.prev_select then do;		/* if have prev block */
      364 	       if ai_ptr -> rm_attr_info.domain_ptr -> rm_domain_info.name ^=
      365 		 select_sets.domains (select_list.num_items)
      366 	       then
      367 		  call error (mrds_error_$block_dom_incons, LOUD, 0,
      368 		      SC_TYPE,
      369 		      "");
      370 						/* if not compat */
      371 	   end;
      372 
      373         if ai_ptr -> rm_attr_info.mdbm_secured
      374         then call check_access (caller, ai_ptr -> rm_attr_info.read_perm,
      375 	       ai_ptr -> rm_attr_info.modify_perm);
      376 
      377         if ai_ptr -> rm_attr_info.key_attr
      378         then					/* cant modify key attr. */
      379 	   dbcb.val_mod = "0"b;
      380 
      381         if dbcb.prev_select
      382         then
      383 	   select_list.item.key (select_list.num_items) =
      384 	       select_sets.items.select_ptr (1)
      385 	       -> select_list.item.key (select_list.num_items);
      386         else
      387 	   select_list.item.key (select_list.num_items) = temp_rel_key;
      388 
      389         select_list.item.var_index (select_list.num_items) = relation_index;
      390         select_list.item.ai_ptr (select_list.num_items) = ai_ptr;
      391         var_exists (relation_index) = "1"b;		/* remember this var. selected */
      392         range.tup_var.used (relation_index) = "1"b;
      393 						/* remember this var used */
      394 
      395         if caller ^= mrds_data_$caller_modify
      396         then
      397 	   if ^cur_sw
      398 	   then range.tup_var (relation_index).needed_bits
      399 		  .attr (ai_ptr -> rm_attr_info.defn_order) = "1"b;
      400 						/* Mark this attribute as selected */
      401 	   else if ^range.tup_var (relation_index).needed_bits
      402 		  .attr (ai_ptr -> rm_attr_info.defn_order)
      403 		  & ^range.tup_var.whole_tuple_selected (relation_index)
      404 		  & ^range.tup_var.copied_for_current (relation_index)
      405 	        then range.tup_var.copy_for_current (relation_index) = "1"b;
      406 
      407 
      408 /* Keep a list of relations associated with free tuple
      409*   variables if the db does not have a transaction control file (implies
      410*   scope must be set before use.) */
      411 
      412         if ^range.tup_var.temp_rel (relation_index)
      413         then call add_free_rel (relation_index);		/* add_assoc. rels. to free list */
      414 
      415         return;
      416 
      417 finish:
      418     entry (dbcb_ptr, a_range_ptr, a_select_list_ptr, ti_ptr, caller, area_ptr,
      419         argp_ptr, descp_ptr, num_args, cur_sw, code);
      420 						/* this entry finishes up a select clause */
      421 
      422         range_ptr = a_range_ptr;
      423         select_list_ptr = a_select_list_ptr;
      424         select_area_ptr = dbcb.select_area_ptr;
      425         compiled_sw = "0"b;
      426 
      427         if ^cur_sw & dbcb.prev_select then do;		/* must copy user data */
      428 	  s_ptr = dbcb.ss_ptr -> select_sets.items.select_ptr (1);
      429 						/* dtat from 1st block */
      430 
      431 	  if s_ptr -> select_list.num_items ^= select_list.num_items
      432 	  then do;				/* must match */
      433 	      call ioa_$rsnnl (
      434 		"^d items were selected in the previous select clause and ^d items were selected in the current one."
      435 		, err_msg, err_msg_len, s_ptr -> select_list.num_items,
      436 		select_list.num_items);
      437 	      call error (mrds_error_$block_sel_incons, LOUD, 1, SC_TYPE,
      438 		err_msg);
      439 	  end;
      440 
      441 	  do i = 1 to select_list.num_items;		/* can copy because from same domains */
      442 	      select_list.item.user_ptr (i) =
      443 		s_ptr -> select_list.item.user_ptr (i);
      444 	      select_list.item.must_convert (i) =
      445 		s_ptr -> select_list.item.must_convert (i);
      446 	      select_list.item.user_desc_ptr (i) =
      447 		s_ptr -> select_list.item.user_desc_ptr (i);
      448 	      call make_move_lists;
      449 	  end;					/* user data copy */
      450         end;					/* if previous select block */
      451 
      452 /* there are four cases of existance of selection_expression values, and argument values:
      453*   1) neither are present
      454*   2) both are present
      455*   3) only argument values are present
      456*   4) only selection expression values are present
      457*
      458*   1 and 4 are legal for delete, compile and define_temp_rel, 2 and 3 are
      459*   legal for retrieve/modify/store
      460*   if the user leaves out any values for retrieve/modify/store, he gets
      461*   an insufficient_args error
      462*   case 4 with delete must not gobble up se_values mistaken for arg values
      463*   NOTE: se_values are legal in two cases
      464*   a) for temp rels in the range clause
      465*   b) for all selection expressions, for substitutions in the where clause
      466**/
      467         else if caller = mrds_data_$caller_compile
      468 	   then call make_tuple_info;
      469 	   else if num_args <= 0 | caller = mrds_data_$caller_delete
      470 		  | caller = mrds_data_$caller_define_temp_rel
      471 	        then do;				/* if no user args, can only delete or dtrel */
      472 		  dbcb.val_mod, dbcb.val_rtrv = "0"b;
      473 		  call make_tuple_info;
      474 	        end;
      475 	        else do;
      476 		  call mrds_dsl_set_user_vals
      477 		      (dbcb_ptr, area_ptr, argp_ptr, descp_ptr, num_args,
      478 		      select_list_ptr, code);
      479 		  call make_move_lists;
      480 	        end;
      481 
      482         if caller ^= mrds_data_$caller_compile then call check_scope;
      483 						/* we dont care about scope if compiling */
      484 
      485         if cur_sw
      486         then dbcb.current_ptr = select_list_ptr;		/* put select list pointer in correct slot */
      487         else dbcb.prev_select = "1"b;			/* remember we have procesed a select list */
      488 
      489         return;
      490 
      491 check_scope:
      492     proc;
      493 						/* We must check for proper scope setting on each relation referenced.
      494*						   If a relation appears in the where clause but not in the select clause,
      495*						   then it must have at least read_attr scope permission.
      496*						   A relation appearing in the select clause will require
      497*						   read_attr permission for a retrieve or define_temp_rel oepration
      498*						   modify_attr permission for a modify operation
      499*						   delete_tuple permission for a delete oepration.
      500*						   NOTE: store requires append_tuple, but is handled in mrds_dsl_store
      501*						*/
      502 
      503         do i = 1 to range.num_vars;			/* verify scope for each variable */
      504 	  if ^range.tup_var.temp_rel (i) then do;	/*  for data base rels. only */
      505 	      rmri_ptr = range.tup_var.ri_ptr (i);
      506 	      free_rel = "0"b;			/* assume is bound */
      507 	      do k = 1 to num_free_rels while (^free_rel);/* search free relation list */
      508 		if range.tup_var.rel_index (i) = free_rels (k)
      509 		then free_rel = "1"b;		/* found it */
      510 	      end;
      511 
      512 	      if free_rel then do;			/* tuple variable appears in select clause */
      513 		go to free_scope_check (caller);	/* if free, check scope for function */
      514 free_scope_check (1):				/* delete */
      515 		if rm_rel_info.scope_flags_ptr
      516 		    -> scope_flags.permits.delete_tuple /* if scope not set for delete_tuple */
      517 		then goto end_free_scope_check;
      518 		else call scope_error (caller, mrds_error_$scope_viol);
      519 
      520 free_scope_check (2):				/* modify */
      521 		if rm_rel_info.scope_flags_ptr
      522 		    -> scope_flags.permits.modify_attr	/* if scope not set for modify_attr */
      523 		then goto end_free_scope_check;
      524 		else call scope_error (caller, mrds_error_$scope_viol);
      525 
      526 free_scope_check (3):				/* retrieve */
      527 free_scope_check (4):				/* define_temp_rel */
      528 		if rm_rel_info.scope_flags_ptr
      529 		    -> scope_flags.permits.read_attr	/* if scope not set for retrieve */
      530 		then goto end_free_scope_check;
      531 		else call scope_error (caller, mrds_error_$scope_viol);
      532 end_free_scope_check:
      533 	      end;
      534 	      else				/* tuple variable does not appear in select clause,
      535*						   just where clause */
      536 		 if ^rm_rel_info.scope_flags_ptr
      537 		     -> scope_flags.permits.read_attr	/* if scope not set for retrieve */
      538 		 then call scope_error (mrds_data_$caller_retrieve,
      539 			mrds_error_$scope_viol);	/* insist on retrieve for bound rels. */
      540 	  end;					/* checking this relation */
      541         end;
      542 
      543     end check_scope;
      544 
      545 scope_error:
      546     procedure (calling_routine, code);
      547 
      548 /* routine to issue error message with specifics of scope violation */
      549 
      550         if calling_routine = mrds_data_$caller_delete
      551         then
      552 	   scope_type = "delete_tuple";
      553         else if calling_routine = mrds_data_$caller_modify
      554 	   then
      555 	        scope_type = "modify_attr";
      556 	   else scope_type = "read_attr";		/* retrieve, define_temp_rel operations,
      557*						   or tuple variable not in select clause */
      558 
      559         call sub_err_ (code, caller_name, continue, info_ptr, return_value,
      560 	  "^/^a^a^a^a^a",
      561 	  "The relation """, rm_rel_info.name,
      562 	  """ needs a scope permission of """,
      563 	  scope_type, """ in order to perform this operation.");
      564 
      565         call error (code, ^LOUD, 0, "", "");		/* now we can do the normal error exit */
      566 
      567 declare code		 fixed bin (35);		/* local copy */
      568 declare calling_routine	 fixed bin (35);		/* type of calling routine, or application of tuple variable */
      569 declare scope_type		 char (20) varying;		/* type of requried scope permission */
      570 
      571     end;
      572 
      573 check_access:
      574     proc (calling_module, r_bit, m_bit);
      575 
      576 /* this module is chechs the access of the attribute via the r_bit
      577*   and m_bit and depending on the operation to be performed either returns or
      578*   calls error with the incorrect attribute access code */
      579 
      580 dcl     calling_module	 fixed bin (35);		/* special code indicating the calling module */
      581 dcl     r_bit		 bit (1) unal;		/* "1" => user has read permission on attribute */
      582 dcl     m_bit		 bit (1) unal;		/* "1" => user has modify permission on attribute */
      583 
      584 
      585 dcl     mdbm_error_$inc_attr_acc
      586 			 fixed bin (35) external static;
      587 
      588 
      589 
      590         if caller = mrds_data_$caller_retrieve then do;
      591 	  if ^(r_bit)
      592 	  then call error (mdbm_error_$inc_attr_acc, LOUD, 0, AV_TYPE,
      593 		 "You must have read permission on this attribute to retrieve from it."
      594 		 );
      595         end;
      596         else
      597 	   if caller = mrds_data_$caller_modify
      598 	   then do;
      599 	       if ^(m_bit)
      600 	       then call error (mdbm_error_$inc_attr_acc, LOUD, 0, AV_TYPE,
      601 		      "You must have modify permission on this attribute to modify it."
      602 		      );
      603 	   end;
      604 
      605         return;
      606 
      607     end;
      608 
      609 add_free_rel:
      610     proc (var_index);
      611 
      612 /* Procedure to add all those relation indices assoc. with a free tup. var. to the free list */
      613 
      614 dcl     (var_index,
      615         rel_index,
      616         j)		 fixed bin;
      617 
      618         rel_index = range.tup_var.rel_index (var_index);	/* pick up relation index */
      619 
      620         free_rel = "0"b;				/* assume not on free list */
      621         do j = 1 to num_free_rels while (^free_rel);	/* search for it on free list */
      622 	  if free_rels (j) = rel_index then free_rel = "1"b;
      623 						/* if found */
      624         end;
      625         if ^free_rel then do;				/* if not there, must add it */
      626 	  num_free_rels = num_free_rels + 1;
      627 	  free_rels (num_free_rels) = rel_index;
      628         end;
      629     end add_free_rel;
      630 
      631 make_move_lists:
      632     proc;
      633 
      634 /* Procedure to make a move list for every selected vauiable */
      635 
      636 dcl     (i,
      637         k,
      638         var_init,
      639         mli)		 fixed bin;
      640 
      641         if select_list.mla_ptr = null () then do;
      642 	  select_list.num_vars = range.num_vars;	/* Max size */
      643 	  allocate move_list_array in (select_area);
      644 	  do i = 1 to select_list.num_vars;
      645 	      move_list_array.ml_ptr (i) = null ();
      646 	  end;
      647         end;
      648         select_list.num_vars = 0;
      649 
      650         do i = 1 to range.num_vars;			/* count the number of selected vars */
      651 	  if var_exists (i)
      652 	  then select_list.num_vars = select_list.num_vars + 1;
      653         end;
      654 
      655         var_init = 1;				/* initiallize */
      656         do k = 1 to select_list.num_vars;		/* make move list for each var. */
      657 	  do move_list_array.var_index (k) = var_init to range.num_vars
      658 	      while (^var_exists (move_list_array.var_index (k)));
      659 	  end;					/* pick a var index */
      660 	  var_init = move_list_array.var_index (k) + 1;
      661 
      662 	  if move_list_array.ml_ptr (k) = null () then do;
      663 	      ml_nitems_init = mrds_data_$max_select_items;
      664 	      allocate move_list in (select_area);
      665 	      move_list_array.ml_ptr (k) = ml_ptr;
      666 	  end;
      667 	  else do;
      668 	      ml_ptr = move_list_array.ml_ptr (k);
      669 	      move_list.nitems = mrds_data_$max_select_items;
      670 	  end;
      671 	  mli = 0;
      672 	  do i = 1 to select_list.num_items;		/* find and add all selected items of this var. */
      673 	      if select_list.item.var_index (i)
      674 		= move_list_array.var_index (k) then do;/* if attr of this var. */
      675 		mli = mli + 1;
      676 		move_list.item.attr_index (mli) =
      677 		    select_list.item.ai_ptr (i) -> rm_attr_info.defn_order;
      678 		move_list.item.user_ptr (mli) =
      679 		    select_list.item.user_ptr (i);
      680 		move_list.item.user_desc_ptr (mli) =
      681 		    select_list.item.user_desc_ptr (i);
      682 	      end;
      683 	  end;					/* adding selected items */
      684 
      685 	  move_list.nitems = mli;
      686         end;					/* making move lists */
      687 
      688         call make_tuple_info;
      689 
      690     end make_move_lists;
      691 
      692 make_tuple_info:
      693     proc;
      694 
      695 /* Procedure to make the tuple info structure and allocate each tuple */
      696 
      697 dcl     (i, tii)		 fixed bin;
      698 
      699         if cur_sw | compiled_sw			/* If -current or -compiled, don't bother */
      700         then return;
      701         ti_ntuples_init = range.num_vars;
      702         allocate tuple_info in (select_area);		/* Allocations in select_area are never freed.  This area
      703*						   is reinitialized at the beginning
      704*						   of each new selection expression */
      705 
      706         tii = 0;					/* init */
      707         do i = 1 to range.num_vars;			/* set up for each variable */
      708 	  rmri_ptr = range.tup_var.ri_ptr (i);
      709 	  tii = tii + 1;
      710 	  tuple_info.tuple.var_index (tii) = i;
      711 	  tuple_info.tuple.tuple_ptr (tii) =
      712 	      create_simple_vector (rmri_ptr, select_area_ptr);
      713 	  tuple_info.tuple.tuple_id (tii) = "0"b;
      714         end;					/* loop through range vars */
      715 
      716     end make_tuple_info;
      717 
      718 error:
      719     proc (cd, loud, stack_offset, error_type, message);
      720 
      721 dcl     cd		 fixed bin (35);		/* standard error code */
      722 dcl     loud		 bit (1) aligned;		/* OFF => dont print or signal error */
      723 dcl     stack_offset	 fixed bin;		/* offset from ls_top of where token is in lex stack */
      724 dcl     error_type		 char (*);
      725 dcl     message		 char (*);
      726 
      727         se_info_ptr = dbcb.se_info_ptr;
      728 
      729         code = cd;
      730 
      731         se_info.loud = loud;
      732         se_info.error_type = error_type;
      733         se_info.token_start = 0;
      734         se_info.stack_offset = stack_offset;		/* save this for semantics */
      735         se_info.error_msg = message;
      736         se_info.error_info_supplied = "1"b;		/* so no one else handles it */
      737 
      738         goto exit;
      739 
      740     end error;
      741 
      742 create_simple_vector:
      743     proc (rmri_ptr, area_ptr) returns (ptr);
      744 
      745 
      746 /*
      747*
      748*   BEGIN_DESCRIPTION
      749*
      750*   This routine will allocate a simple vector for a given relation.  It
      751*   takes a pointer to an rm_rel_info structure as input.  It will examine
      752*   that structure and allocate enough storage to completely contain all
      753*   attributes in it.  Then it will set up pointers to appropriate places in
      754*   that storage for the attributes.
      755*
      756*   END_DESCRIPTION
      757*
      758*   Parameters:
      759*
      760*   rm_ri_ptr (input)  -  A pointer to the rm_rel_info structure for the relation
      761*   of interest.
      762*   area_ptr  (input)  -  The area to allocate the vector in.
      763*
      764*   Output:
      765*
      766*   A Pointer to a simple vector structure that can be used to do gets from the
      767*   relation.
      768*
      769**/
      770 
      771 
      772 /* Parameters */
      773 
      774 dcl     rmri_ptr		 ptr;
      775 dcl     area_ptr		 ptr;
      776 
      777 
      778 /* Local */
      779 
      780 dcl     attr_offset		 (256) fixed bin (24);
      781 						/* Offsets of attributes from start of allocated block */
      782 dcl     block_size		 fixed bin (24);		/* Size of the block to alloate */
      783 dcl     data_string		 bit (block_size) based (data_string_ptr);
      784 						/* The block */
      785 dcl     data_string_ptr	 ptr;			/* Pointer to above */
      786 dcl     i			 fixed bin;		/* Loop index */
      787 dcl     total_attr		 fixed bin;		/* Total number of attributes */
      788 dcl     vector_area		 area based (area_ptr);	/* Where to allocate vectors */
      789 dcl     vector_ptr		 ptr;			/* Newly created vector */
      790 
      791 
      792 
      793         total_attr = rm_rel_info.num_attr;
      794         stv_number_of_dimensions = total_attr;
      795         allocate simple_typed_vector in (vector_area) set (vector_ptr);
      796         vector_ptr -> simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
      797         vector_ptr -> simple_typed_vector.number_of_dimensions = total_attr;
      798         block_size = 0;
      799         do i = 1 to total_attr;
      800 	  attr_offset (i) = block_size +
      801 	      align_data_item (
      802 	      addr (rm_rel_info.attr_ptrs (i) -> rm_attr_info.domain_ptr
      803 	      -> rm_domain_info.db_desc),
      804 	      (block_size));
      805 	  block_size =
      806 	      attr_offset (i)
      807 	      + rm_rel_info.attr_ptrs (i) -> rm_attr_info.bit_length;
      808         end;
      809         allocate data_string in (vector_area) set (data_string_ptr);
      810         do i = 1 to total_attr;
      811 	  vector_ptr -> simple_typed_vector.dimension (i).value_ptr =
      812 	      addbitno (data_string_ptr, attr_offset (i));
      813         end;
      814 
      815         return (vector_ptr);
      816 
      817     end create_simple_vector;
      818 
      819 align_data_item:
      820     procedure (d_ptr, base_to_pad) returns (fixed bin);
      821 
      822 /* HISTORY:
      823*
      824*   Originally written by Jim Gray - - December 1979
      825*
      826**/
      827 
      828 
      829 
      830 /* DESCRIPTION:
      831*
      832*   given a pointer to a standard multics pl1 data argument descriptor,
      833*   and a current storage offset at which data is to be placed,
      834*   this routine calculates from the data type, and the given address
      835*   the number of padding bits needed to properly align the data
      836*   on either a byte, word, or double word boundary, as required
      837*   by the data type definition, and routines such as assign_.
      838*   currently the data types that assign_ can handle are supported
      839*   by this routine(i.e. 1-12, 19-22, 33-34, 43-46)
      840*
      841**/
      842 
      843 /* PARAMETERS:
      844*
      845*   d_ptr - - (input) pointer, points to the standard multics pl1 argument
      846*   descriptor for the data to be byte/word/even_word aligned using the given address
      847*
      848*   base_to_pad - - (input) fixed bin(35), the current address(offset), of the last
      849*   data item, after which the data item described by the input descriptor
      850*   is to be placed, for the first data item, base_to_pad = 0.
      851*
      852*   needed_bits - - (output) fixed bin, the number of bits to add to base_to_pad,
      853*   in order to obtain the correct byte/word/even_word alignment for the
      854*   data type as described by the input descriptor.
      855*
      856**/
      857 
      858 /* using the declared alignment and data type for this attribute,
      859*   return the number of bits necessary to put the data on a boundary
      860*   as defined by pl1, such as byte, word or double word aligned, for using that type.
      861*   directly in such operations as the any_to_any convert via assign_
      862*   without having to do a bit move to get the proper alignment.
      863*   this makes data storage in the tuple a true representation of the pl1
      864*   attributes of unaligned and aligned for complete user choice
      865*   in the trade off between speed and space. */
      866 
      867 
      868 dcl     d_ptr		 ptr;			/* Pointer to a standard Multics descriptor */
      869 dcl     needed_bits		 fixed bin;		/* number of bits needed to get the alignment */
      870 dcl     base_to_pad		 fixed bin (24) parameter;	/* original value to be padded out */
      871 
      872         needed_bits = 0;				/* initialize */
      873 
      874         if d_ptr = null ()
      875         then ;
      876         else if d_ptr -> descriptor.packed
      877 	   then do;				/* unaligned */
      878 
      879 	       if ^(d_ptr -> descriptor.type = 21
      880 		 | (d_ptr -> descriptor.type >= 9
      881 		 & d_ptr -> descriptor.type <= 12)	/* char or decimal */
      882 		 | (d_ptr -> descriptor.type >= 43
      883 		 & d_ptr -> descriptor.type <= 46))
      884 	       then ;				/* packed decimal */
      885 	       else needed_bits = pad (BYTE, base_to_pad);
      886 
      887 	   end;
      888 	   else do;				/* aligned */
      889 
      890 	       if (d_ptr -> descriptor.type >= 9
      891 		 & d_ptr -> descriptor.type <= 12)
      892 		 |
      893 		 /* decimal */ (d_ptr -> descriptor.type >= 43
      894 		 & d_ptr -> descriptor.type <= 46)
      895 		 |
      896 		 /* packed decimal */ (d_ptr -> descriptor.type >= 19
      897 		 & d_ptr -> descriptor.type <= 22)
      898 		 | /* bit or char */ d_ptr -> descriptor.type = 1
      899 		 | d_ptr -> descriptor.type = 3
      900 		 | d_ptr -> descriptor.type = 33
      901 	       then				/* binary short */
      902 		  needed_bits = pad (WORD, base_to_pad);
      903 
      904 	       else if d_ptr -> descriptor.type = 2
      905 		      | d_ptr -> descriptor.type = 34
      906 		      |
      907 		      /* binary long */ (d_ptr -> descriptor.type >= 4
      908 		      & d_ptr -> descriptor.type <= 8)
      909 		  then				/* binary complex */
      910 		       needed_bits = pad (DOUBLE_WORD, base_to_pad);
      911 		  else ;				/* none needed otherwise */
      912 
      913 	   end;
      914 
      915         return (needed_bits);
      916 
      917 pad:
      918     procedure (pad_size, pad_base) returns (fixed bin);
      919 
      920 /* routine to return the number of bits necessary to pad a bit count
      921*   out to an alignment boundary of 9(byte), 36(word), or 72(double word) bits
      922*   as determined by the pad size input */
      923 
      924         if mod (pad_base, pad_size) = 0
      925         then number_of_bits = 0;
      926         else do;
      927 
      928 	  number_of_bits = pad_size - mod (pad_base, pad_size);
      929 
      930         end;
      931 
      932         return (number_of_bits);
      933 
      934 
      935 dcl     pad_size		 fixed bin;		/* either 9 or 36 or 72 */
      936 dcl     pad_base		 fixed bin (24);		/* current bit length to be padded */
      937 dcl     number_of_bits	 fixed bin;		/* what has to be added to get to the desired boundary */
      938 
      939     end pad;
      940 
      941 dcl     BYTE		 fixed bin init (9) internal static
      942 			 options (constant);
      943 						/* byte boundary = 9 bits */
      944 dcl     WORD		 fixed bin init (36) int static
      945 			 options (constant);
      946 						/* word boundary = 36 bits */
      947 dcl     DOUBLE_WORD		 fixed bin init (72) int static
      948 			 options (constant);
      949 						/* double word boundary = 72 bits */
      950 
      951     end align_data_item;
      952 
  1     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  1     9*     Nguyen. The scopes_changed flag was added to make checking for this
  1    10*     more efficient (mrds error list #137).
  1    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  1    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  1    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  1    14*     care if multiple txns use the same selection_expression. (mrds #156)
  1    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  1    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  1    18*                                                   END HISTORY COMMENTS */
  1    19 
  1    20 
  1    21 /* WARNING
  1    22*          If the dbcb structure is changed then the mrds_data_
  1    23*          item saved_res_version MUST be incremented to invalidate all
  1    24*          existing saved resultants
  1    25**/
  1    26 
  1    27 /* HISTORY :
  1    28*
  1    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  1    30*   tid_list management
  1    31*
  1    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  1    33*   phony resultant in mu_database_index, without having the area dcl
  1    34*   included.
  1    35*
  1    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  1    37*   mrds_dsl_store
  1    38*
  1    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  1    40*   switches
  1    41*
  1    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  1    43*   expression,  so  that relation statistics can be updated relative
  1    44*   to number of selection expressions seem. Also  removed  init  for
  1    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  1    46*   mrds_dsl_init_res.
  1    47*
  1    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  1    49*
  1    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  1    51*   for the conversion to the relation manager.
  1    52*
  1    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  1    54*   substructures so that the entries and costs can change
  1    55*   depending on the type of database that is opened.
  1    56*
  1    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  1    58*   since modify uses a different vector type (general) than does store.
  1    59*
  1    60*   82-09-20 Davids: changed names of (store modify)_vector to
  1    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  1    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  1    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  1    64*   during the first call.
  1    65*
  1    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  1    67*   since it deals with the pointers to the cursors and not the cursors
  1    68*   themelves and added the element cursor_storage_area_ptr which points
  1    69*   to the area where the cursors are kept.
  1    70*
  1    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  1    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  1    73*   anything.
  1    74*
  1    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  1    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  1    77*   by mrds_dsl_define_temp_rel.
  1    78*
  1    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  1    80*   is needed by mu_store.
  1    81*
  1    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  1    83*   bin to float bin since the values are not integers.
  1    84*
  1    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  1    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  1    87*   added to the end of the structure to allow modules that don't use
  1    88*   the element to continue to reference the dbcb structure without recompiling.
  1    89*
  1    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  1    91*   are needed so that temp rels can be created with the same file attributes
  1    92*   as the permanent relations.
  1    93*
  1    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  1    95*   added the resultant_in_pdir bit.
  1    96*
  1    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  1    98*   added the res_already_made element.
  1    99*
  1   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  1   101*
  1   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  1   103*   one of the unused pointers.
  1   104*
  1   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  1   106*
  1   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  1   108*   leaving unused_ptrs(1).
  1   109*
  1   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  1   111*   unused_ptrs (1).
  1   112*
  1   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  1   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  1   115*   spare ptrs, entries and reserved storages for future enhancement, since
  1   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  1   117*
  1   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  1   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  1   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  1   121**/
  1   122 
  1   123 
  1   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  1   125*   that constitutes the non-secure portion of the resultant model that is
  1   126*   created during the opening of a database. it contains variables that
  1   127*   are used during the runtime access of the database, and an area
  1   128*   for evaluation of requests. it points to four other
  1   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  1   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  1   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  1   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  1   133*   used in the elimination of duplicate tuples during a retrieve.
  1   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  1   135*   that is used when the database is using the file scope mechanism
  1   136*   for concurrency control over file readying. the segment overlayed via
  1   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  1   138*   across database openings. the pointer to this dbcb structure is kept in a table
  1   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  1   140*   opening instances of resultant models. (see mu_database_index routine) */
  1   141 
  1   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  1   143 	     2 data	      like dbcb_data,
  1   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  1   145 
  1   146      dcl	   dbcb_ptr	      ptr;
  1   147 
  1   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  1   149*						   like references can avoid getting the area declaration */
  1   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  1   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  1   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  1   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  1   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  1   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  1   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  1   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  1   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  1   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  1   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  1   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  1   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  1   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  1   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  1   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  1   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   167*						   for eliminating duplicate tuples. */
  1   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   169*						   for eliminating duplicate tuples. */
  1   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  1   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  1   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  1   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  1   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  1   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  1   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  1   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  1   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  1   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  1   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  1   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  1   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  1   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  1   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  1   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  1   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  1   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  1   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  1   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  1   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  1   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  1   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  1   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  1   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  1   195 	     2 val_del	      bit (1) unal,		/* for delete */
  1   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  1   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  1   198*                                                                     not imply that the database is of type page_file */
  1   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  1   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  1   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  1   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  1   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  1   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  1   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  1   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  1   207*						   inside a sequence of -another selection expression. */
  1   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  1   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  1   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  1   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  1   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  1   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  1   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  1   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  1   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  1   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  1   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  1   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  1   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  1   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  1   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  1   223 	     2 relmgr_entries,			/* relation manager entries */
  1   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  1   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  1   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  1   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  1   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  1   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  1   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  1   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  1   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  1   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  1   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  1   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  1   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  1   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  1   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  1   241 	       3 reserved_entries (5) entry (),
  1   242 	     2 access_costs,			/* access costs for permute */
  1   243 	       3 total_primary_key_cost float bin,
  1   244 	       3 access_cost      float bin,
  1   245 	       3 access_overhead  float bin,
  1   246 	       3 us_access_cost   float bin,
  1   247 	       3 os_access_cost   float bin,
  1   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  1   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  1   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  1   251 
  1   252 /* END mrds_dbcb.incl.pl1 */
  1   253 
  1   254 
      953 
      954 
  2     1 /* BEGIN mrds_select_list.incl.pl1 -- jaw 10/20/78 */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*   81-06-01 Jim Gray : removed user len and type elements,
  2     6*   since mu_convert rather than assign_ is now used.
  2     7*
  2     8*   84-11-22 John Hergert: added fr_ptr
  2     9*
  2    10*/****^  HISTORY COMMENTS:
  2    11*  1) change(86-07-17,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
  2    12*     install(86-08-15,MR12.0-1127):
  2    13*     85-11-22 Hergert: Added variable var_exists so that it may be kept
  2    14*     around per select expression (in sets) and when compiling. (mrds #158)
  2    15*  2) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  2    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  2    17*     For new parser, (and general readability) renamed sel_ptr to
  2    18*     select_list_ptr.
  2    19*                                                   END HISTORY COMMENTS */
  2    20 
  2    21 
  2    22 dcl 1 select_list based (select_list_ptr),			/* tabular representation of -select clause */
  2    23     2 num_vars fixed bin,				/* number of free variables */
  2    24     2 mla_ptr ptr,					/* pointer to array of move list pointers */
  2    25     2 fr_ptr ptr,                                           /* pointer to free_raltions struct in mrds_dsl_select_clause */
  2    26     2 num_items fixed bin,				/* number of attributes specified in select list */
  2    27     2 var_exists (36) bit(1),
  2    28     2 item (mrds_data_$max_select_items refer (select_list.num_items)),
  2    29       3 must_convert bit (1) unal,			/* on if conversion required */
  2    30       3 key bit (1) unal,				/* on if to be key attr. in temp. rel. */
  2    31       3 index bit (1) unal,				/* on if index attribute in temp rel */
  2    32       3 reserved bit (33) unal,			/* reserved for future use */
  2    33       3 var_index fixed bin,				/*  index of assoc. tuple variable */
  2    34       3 ai_ptr ptr,					/* ptr to attr_info */
  2    35       3 user_desc_ptr ptr,				/* to descriptor for user value */
  2    36       3 user_ptr ptr ;				/* pointer to user's area */
  2    37 
  2    38 dcl  select_list_ptr ptr int automatic init (null ());
  2    39 
  2    40 dcl 1 move_list_array (select_list.num_vars) based (select_list.mla_ptr),
  2    41     2 var_index fixed bin,
  2    42     2 ml_ptr ptr;
  2    43 
  2    44 /* END mrds_select_list.incl.pl1 */
  2    45 
      955 
      956 
  3     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  3     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  3     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 
  3    12 /* WARNING
  3    13*          If the rm_db_info structure is changed then the mrds_data_
  3    14*          item saved_res_version MUST be incremented to invalidate all
  3    15*          existing saved resultants
  3    16**/
  3    17 
  3    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  3    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  3    20*   resultant model that is created partially at database open  time,
  3    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  3    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  3    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  3    24*   to  provide  an  efficient  means  of  accessing  database  model
  3    25*   information, as seen from the possibly submodel view of the user,
  3    26*   and his current state of "files readied". it is the  secure  part
  3    27*   because  it  contains  the  model  information  which needs to be
  3    28*   protected  from  general  knowledge,  and   this   segment   will
  3    29*   eventually  be  capable  of  being in a lower ring. the structure
  3    30*   itself points to four arrays that are  allocated  in  it's  area,
  3    31*   that  in  turn point to the other structures mentions above, also
  3    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  3    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  3    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  3    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  3    36*   list of all known file names, the rm_rel_array only gets relation
  3    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  3    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  3    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  3    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  3    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  3    42*   file infos point to contained rel infos, the rel infos  point  to
  3    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  3    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  3    45*   foreign     keys    are    represented    by    the    structures
  3    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  3    47*   pathnames  of the model and submodel, if any, are also maintained
  3    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  3    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  3    50*   individual include files for  further  organization  information,
  3    51*   and particular data structures.
  3    52*
  3    53*   HISTORY:
  3    54*
  3    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  3    56*   so that define_area_ could be used to make it an extensible area
  3    57*
  3    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  3    59*   resultant in mu_database_index easier to keep, since no reference
  3    60*   to the area is needed.
  3    61*
  3    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  3    63*   resultant.
  3    64*
  3    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  3    66*   structure.
  3    67*
  3    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  3    69*   are  now  combined  into  the rel_array. Removed the control file
  3    70*   info which was unused. Added pointer  to  head  of  domain  list,
  3    71*   which is to be used to insure only one copy of each domain info.
  3    72*
  3    73*   83-05-19 Davids: Added the  saved_res_version element.
  3    74*
  3    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  3    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  3    77*   check, encode, or decode proc.
  3    78*
  3    79*   CAUTION: The structure entries from db_version to sm_path  should
  3    80*   not  be moved or have their declarations changed because they are
  3    81*   used in the handling of old version database openings.
  3    82*
  3    83*
  3    84**/
  3    85 
  3    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  3    87 	     2 data	      like rm_db_info_data,
  3    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  3    89 
  3    90      dcl	   rdbi_ptr	      ptr;
  3    91 
  3    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  3    93*						   like reference to it without getting the area as well */
  3    94 	     2 db_version	      fixed bin,		/* version no. of db */
  3    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  3    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  3    97 	     2 db_path	      char (168),		/* abs. path of db. */
  3    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  3    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  3   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  3   101 	     2 pad	      bit (34) unal,	/* for future use */
  3   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  3   103*                                                               dbcb and rdbi segments in the db dir */
  3   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  3   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  3   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  3   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  3   108 
  3   109 /* END mdbm_rm_db_info.incl.pl1 */
  3   110 
  3   111 
      957 
      958 
  4     1 /* BEGIN mdbm_rm_rel_array.incl.pl1 -- jaw, 8/9/78 */
  4     2 
  4     3 /* WARNING
  4     4*          If the rm_rel_array structure is changed then the mrds_data_
  4     5*          item saved_res_version MUST be incremented to invalidate all
  4     6*          existing saved resultants
  4     7**/
  4     8 
  4     9 /* HISTORY:
  4    10*
  4    11*   81-05-28 Jim Gray : added  model_name  and  file_id  as  part  of
  4    12*   combining   funtions   of   file_array  and  rel_array  into  one
  4    13*   structure. This will only allow 1 relation per file model now.
  4    14*   Also changed structure to allow more efficient searching
  4    15*   via and index builtin, rather than a programmed loop.
  4    16*   Search is now I = index(string(rm_rel_array.name), "!" || in_name)
  4    17*   with I = ((I - 1) / 33) + 1 to convert from a char to array index.
  4    18*
  4    19**/
  4    20 
  4    21 
  4    22 /* this structure is allocated in the static are of the structure
  4    23*   in  mdbm_rm_db_info.incl.pl1,  the secure portion of the database
  4    24*   resultant  model  upon  opening  the  database.  two  copies  are
  4    25*   allocated,  one for temporary relations, initially empty, and one
  4    26*   for relations known to the opener, which has a length  sufficient
  4    27*   for  all  relations known to the user, but whose names, etc. will
  4    28*   not be filled  in  until  the  file  containing  that  particular
  4    29*   relation  is readied. the rm_db_info structure contains a pointer
  4    30*   to the rel_arrays, and the array entries, when  "readied",  point
  4    31*   to  the  mdbm_rm_rel_info.incl.pl1  structures  containing  model
  4    32*   information about the relation, it's attributes, etc. */
  4    33 
  4    34 dcl 1 rm_rel_array aligned based (rmra_ptr),		/* array of open relations */
  4    35     2 num_rels fixed bin,				/* no. rels in db. */
  4    36     2 name (1:rm_num_rels_init refer (rm_rel_array.num_rels)) unal,
  4    37       3 mark char (1) unal,				/* separator character = "!" */
  4    38       3 submodel char (32) unal,			/* name of relation is submodel view, model opening => model name */
  4    39     2 rel_data (rm_num_rels_init refer (rm_rel_array.num_rels)),
  4    40       3 model_name char (30),				/* name of relation in model */
  4    41       3 ri_ptr ptr unal ;				/* pointer to rm_rel_info */
  4    42 
  4    43 dcl  rmra_ptr ptr;
  4    44 dcl  rm_num_rels_init fixed bin;
  4    45 
  4    46 /* END mdbm_rm_rel_array.incl.pl1 */
  4    47 
  4    48 
      959 
      960 
  5     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  5     2 
  5     3 /* WARNING
  5     4*          If the rm_rel_info structure is changed then the mrds_data_
  5     5*          item saved_res_version MUST be incremented to invalidate all
  5     6*          existing saved resultants
  5     7**/
  5     8 
  5     9 /* HISTORY:
  5    10*
  5    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  5    12*   attributes,   and   varying  attributes,  so  that  partial  view
  5    13*   submodels will have the  info  needed  to  properly  set  up  the
  5    14*   varying length array headers in the tuple structure.
  5    15*
  5    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  5    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  5    18*   delete_tuple_perm, and make m_perm = unused_perm.
  5    19*
  5    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  5    21*   view attribute was varying character or bit, since a partial view
  5    22*   submodel will not have this information in the resultant, and  it
  5    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  5    24*   since with exact length storage  of  varying  length  attributes,
  5    25*   each  tuple  can  be  a  different  length,  which is can only be
  5    26*   determined by examining the tuple itself.
  5    27*
  5    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  5    29*   interface  to  allow  temp  rel  population  to  be known, and to
  5    30*   provide a more efficient means of finding an approx. current perm
  5    31*   relation population.
  5    32*
  5    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  5    34*   blocked  files, foreign keys, and ids procedures. Also set number
  5    35*   of files per rel to a constant of 1.
  5    36*
  5    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  5    38*   structure so that only one structure per relation is needed.
  5    39*
  5    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  5    41*   counts.   Also  added  number  of  operations  count  since  last
  5    42*   statistics update, and a time  since  the  statistics  were  last
  5    43*   updated.
  5    44*
  5    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  5    46*   identifier so that small relations could be updated on a per S.E.
  5    47*   basis
  5    48*
  5    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  5    50*   to end of structure   TR 12205 (Suggestion).
  5    51*   
  5    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  5    53*   the DMS conversion. 
  5    54*
  5    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  5    56*   array and the niocb element for DMS conversion. Also removed the
  5    57*   number_selected array (and ri_niocbs_init) since subsets are not
  5    58*   going to be used.
  5    59*
  5    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  5    61*   so that it can be used with relation manager.  Also added
  5    62*   rm_rel_info.primary_key_index_id for relation manager.
  5    63*
  5    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  5    65*   nvar_atts, model_nvar_atts.
  5    66*
  5    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  5    68*   since the duplicate key count for each secondary index is now being
  5    69*   kept in the attr_info structure and key_count was only needed to
  5    70*   help in calculating the average selectivity of each index which
  5    71*   can now be gotten directly from each index's dup key count. Also
  5    72*   removed the file_id element since it is no longer needed for
  5    73*   anything.
  5    74*
  5    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  5    76*   was removed.
  5    77*
  5    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  5    79*   used when retrieving tuples from this relation.
  5    80*
  5    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  5    82*   for the relation. Note that this structure is part of the resultant NOT
  5    83*   part of the db.control structure. The scopes are duplicated in the resultant
  5    84*   to reduce contention for the db.control structure. Note also that the pointer
  5    85*   will always point to a scope_flags structure even if no scopes have been
  5    86*   set on the relation, the structure is allocated when the db is opened.
  5    87**/
  5    88 
  5    89 
  5    90 /* DESCRIPTION:
  5    91*
  5    92*   This structure is allocated in the area part of the structure  in
  5    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  5    94*   at open  time  for  a  database.  There  will  be  one  of  these
  5    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  5    96*   database view (there may be less than the total in  the  database
  5    97*   for  a  submodel  openings).  There  will  also  be  one for each
  5    98*   temporary relation currently defined for that opening.
  5    99*
  5   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  5   101*   all  rm_rel_info  structures  allocated. It is used for searching
  5   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  5   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  5   104*   rels.
  5   105*
  5   106*   The      rm_rel_info      structure      points      to       the
  5   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  5   108*   appearing in this view of the relation. Each  of  these  in  turn
  5   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  5   110*   info for each attr.
  5   111*
  5   112*   Most of the other information here deals with  specifics  of  the
  5   113*   relation's  logical  definition,  such as key and secondary index
  5   114*   attribute inidicators, security permissions, and  tuple  physical
  5   115*   construction details.
  5   116*
  5   117**/
  5   118 
  5   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  5   120 	     2 name	      char (32),		/* from submodel */
  5   121 	     2 model_name	      char (30),		/* from model */
  5   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  5   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  5   124 	     2 modify	      bit (1) unal,
  5   125 	     2 delete	      bit (1) unal,
  5   126 	     2 store	      bit (1) unal,
  5   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  5   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  5   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  5   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  5   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  5   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  5   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  5   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  5   135 	     2 reserved	      bit (24) unal,	/* for future use */
  5   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  5   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  5   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  5   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  5   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  5   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  5   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  5   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  5   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  5   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  5   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  5   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  5   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  5   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  5   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  5   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  5   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  5   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  5   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  5   155 
  5   156      dcl	   rmri_ptr	      ptr;
  5   157      dcl	   (nkey_attr_init,
  5   158 	   natts_init,
  5   159 	   nvar_atts_init)	      fixed bin;
  5   160 
  5   161 /* END mdbm_rm_rel_info.incl.pl1 */
  5   162 
  5   163 
      961 
      962 
  6     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
  6     2 
  6     3 /* WARNING
  6     4*          If the rm_attr_info structure is changed then the mrds_data_
  6     5*          item saved_res_version MUST be incremented to invalidate all
  6     6*          existing saved resultants
  6     7**/
  6     8 
  6     9 /*
  6    10*
  6    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
  6    12*   that rm_rel_info does not have to be checked
  6    13*
  6    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  6    15*   foreign keys.
  6    16*
  6    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
  6    18*   conversion.
  6    19*
  6    20*   82-09-15 Davids: added the number_of_dups field.
  6    21*
  6    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
  6    23*   aligned.  This is to conform with the new definition in the database
  6    24*   model.  Also removed the now useless field varying.
  6    25*
  6    26*   82-11-05 Davids: added the field model_defn_order and clarified the
  6    27*   comment for the field defn_order.
  6    28*
  6    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
  6    30*   that's what relation manager returns.
  6    31*
  6    32**/
  6    33 
  6    34 
  6    35 /*
  6    36*   this   structure   is   allocated   in   the   static   area   of
  6    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
  6    38*   a     readied     file.      it     in     turn     points     to
  6    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
  6    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
  6    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
  6    42*   position  within  a  tuple as stored in the data file are kept in
  6    43*   this resultant model of the attribute.
  6    44* */
  6    45 
  6    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
  6    47     2 name char (32),				/* from submodel */
  6    48     2 model_name char (32),				/* from model */
  6    49     2 key_attr bit (1) unal,				/* if key attribute */
  6    50     2 index_attr bit (1) unal,			/* if secondary index */
  6    51     2 read_perm bit (1) unal,				/* user has retr. permission */
  6    52     2 modify_perm bit (1) unal,			/* user has modify permission */
  6    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
  6    54     2 reserved bit (30) unal,				/* for future use */
  6    55     2 index_id bit (36) aligned,			/* index id if index_attr */
  6    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
  6    57     2 key_order fixed bin,				/* relative order defined in prim. key */
  6    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
  6    59     2 domain_ptr ptr,				/* to domain info */
  6    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
  6    61*                                                               be the number of duplicate values, exact
  6    62*                                                               for a page_file database, an estimate for a vfile type */
  6    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
  6    64 
  6    65 dcl  rai_ptr ptr int automatic init (null ());
  6    66 
  6    67 /* END mdbm_rm_attr_info.incl.pl1 */
  6    68 
  6    69 
      963 
      964 
  7     1 /* BEGIN mrds_tuple_info.incl.pl1 -- jaw 11/2/78 */
  7     2 
  7     3 /* HISTORY:
  7     4*
  7     5*   Modified in March 1977 by O Friesen to hold allocated ptr and length
  7     6*   82-10-29 Mike Kubicar : Made tuple_id aligned
  7     7*
  7     8**/
  7     9  
  7    10 dcl 1 tuple_info aligned based (ti_ptr),
  7    11     2 num_tuples fixed bin,				/* no. of tuples for which info given */
  7    12     2 tuple (ti_ntuples_init refer (tuple_info.num_tuples)),
  7    13       3 tuple_ptr ptr,				/* pointer to found tuple */
  7    14       3 tuple_id bit (36) aligned,			/* tuple id for  found tuple */
  7    15       3 var_index fixed bin;				/* index to tuple variable  */
  7    16 
  7    17 dcl  ti_ptr ptr;
  7    18 dcl  ti_ntuples_init fixed bin;
  7    19 
  7    20 /* END mrds_tuple_info.incl.pl1 */
  7    21 
      965 
      966 
  8     1 /* BEGIN mdbm_move_list.incl.pl1 -- jaw, 7/13/78 */
  8     2 
  8     3 /* HISTORY:
  8     4*
  8     5*   81-06-01 Jim Gray : removed assn type and len elements,
  8     6*   now that mu_convert is used.
  8     7*
  8     8**/
  8     9 
  8    10 
  8    11 dcl 1 move_list aligned based (ml_ptr),			/* info for moving data in and out of tuple */
  8    12     2 nitems fixed bin,				/* number of items */
  8    13     2 item (ml_nitems_init refer (move_list.nitems)),
  8    14       3 attr_index fixed bin,				/* index to attr info in rel_info */
  8    15       3 user_ptr ptr,				/* pointer to user data value */
  8    16       3 user_desc_ptr ptr;				/* pointer to descriptor for user */
  8    17 
  8    18 dcl  ml_ptr ptr;
  8    19 dcl  ml_nitems_init fixed bin;
  8    20 
  8    21 /* END mdbm_move_list.incl.pl1 */
  8    22 
      967 
      968 
  9     1 /* BEGIN mdbm_rm_domain_info.incl.pl1 -- jaw, 9/26/78 */
  9     2 
  9     3 /* WARNING
  9     4*          If the rm_domain_info structure is changed then the mrds_data_
  9     5*          item saved_res_version MUST be incremented to invalidate all
  9     6*          existing saved resultants
  9     7**/
  9     8 
  9     9 /* DESCRIPTION:
  9    10*
  9    11*   This  structure  is  allocated  in  the  mdbm_rm_db_info.incl.pl1
  9    12*   static  area,  once per attribute used in a relation in a readied
  9    13*   file. it is pointed to by the mdbm_rm_attr_info.incl.pl1, and may
  9    14*   point  to  mdbm_rm_ck_and_group.incl.pl1  if  a  "-check"  option
  9    15*   boolean expression was declared for this domain. it contains  the
  9    16*   descriptor  for  this domain data type, and other resultant model
  9    17*   information.
  9    18*
  9    19*
  9    20*   HISTORY:
  9    21*
  9    22*   81-05-06  Rickie  E.  Brinegar:  Modified  ck_proc,  encode_proc,
  9    23*   decode_proc to be entry variables instead of entry pointers. This
  9    24*   allows these programs to be written in languages other than pl1.
  9    25*
  9    26*   81-05-28 Jim Gray : removed unused procedure points,  and  unused
  9    27*   check  stack  structure  elements.  Also made the descriptors bit
  9    28*   (36) in this structure, rather than pointers to  the  descriptors
  9    29*   elsewhere.  Also  removed un-needed redundant assign_ parameters,
  9    30*   that are actually available in the descriptors.
  9    31*
  9    32*
  9    33**/
  9    34 
  9    35 dcl 1 rm_domain_info aligned based (rdi_ptr),		/* domain information */
  9    36     2 name char (32),				/* domain name */
  9    37     2 db_desc bit (36),				/*  to desc. for db. */
  9    38     2 user_desc bit (36),				/* desc for user visible data */
  9    39     2 user_bit_len fixed bin,				/* storage length of users data */
  9    40     2 ck_proc_entry entry variable,			/* to check proc. entry */
  9    41     2 encd_proc_entry entry variable,			/* to encode proc entry */
  9    42     2 decd_proc_entry entry variable,			/* to decode proc entry */
  9    43     2 ck_proc bit (1) unal,				/* Is there a check proc */
  9    44     2 encd_proc bit (1) unal,				/* Is there an encode proc */
  9    45     2 decd_proc bit (1) unal,				/* Is there a decode proc */
  9    46     2 pad bit (33) unal,
  9    47     2 next_domain_ptr ptr ;				/* to next domain, in list of all domains */
  9    48 						/* to check stack and groups */
  9    49 
  9    50 
  9    51 dcl  rdi_ptr ptr int automatic init (null ());
  9    52 
  9    53 /* END mdbm_rm_domain_info.incl.pl1 */
  9    54 
  9    55 
      969 
      970 
 10     1 /* BEGIN INCLUDE FILE  mrds_se_info.incl.pl1 
 10     2*
 10     3*   These contains information relating to the selection expression.
 10     4*
 10     5**/
 10     6 
 10     7 /****^  HISTORY COMMENTS:
 10     8*  1) change(85-08-05,Hergert), approve(88-06-28,MCR7903),
 10     9*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
 10    10*     Created for for new parser.
 10    11*                                                   END HISTORY COMMENTS */
 10    12 
 10    13 dcl     1 se_info		 aligned based (se_info_ptr),
 10    14 	2 se_ptr		 ptr,			/* points to the beginning of the selection expression */
 10    15 	2 se_length	 fixed bin,		/* length of the selection expression */
 10    16 	2 se_cursor	 fixed bin,		/* current place in se */
 10    17 	2 flags,
 10    18 	  3 pso_seen	 bit,			/* -pso supplied in se */
 10    19 	  3 no_ot_seen	 bit,			/* -no_ot supplied in se */
 10    20           2 error_report,
 10    21 	  3 error_info_supplied bit aligned,              /* ON -> structure already filled in */
 10    22 	  3 loud             bit aligned,                	/* ON -> call mu_print_error */
 10    23             3 token_start      fixed bin,                   /* position in se where token starts */
 10    24             3 token_length     fixed bin,                   /* length of token in se */
 10    25 	  3 error_code       fixed bin(35),               /* system error code */
 10    26             3 stack_offset     fixed bin,                   /* how far down the token is in the lex stack */
 10    27             3 error_type       char(24),                    /* type of error. ie range, select where... */
 10    28 	  3 error_msg        char(256);         	/* message to explain problem */
 10    29 
 10    30 
 10    31 /* various types of errors. actually the string that is reported in the
 10    32*   error message. */
 10    33 dcl     RC_TYPE		 char (12) internal static
 10    34 			 options (constant) init ("Range Clause");
 10    35 dcl     SE_TYPE		 char (20) internal static
 10    36 			 options (constant)
 10    37 			 init ("Selection Expression");
 10    38 dcl     SC_TYPE		 char (13) internal static
 10    39 			 options (constant)
 10    40 			 init ("Select Clause");
 10    41 dcl     WC_TYPE		 char (12) internal static
 10    42 			 options (constant)
 10    43 			 init ("Where Clause");
 10    44 dcl     WCE_TYPE		 char (23) internal static
 10    45 			 options (constant)
 10    46 			 init ("Where Clause Expression");
 10    47 dcl     WCF_TYPE		 char (21) internal static
 10    48 			 options (constant)
 10    49 			 init ("Where Clause Function");
 10    50 dcl     AV_TYPE		 char (16) internal static
 10    51 			 options (constant)
 10    52 			 init ("Access Violation");
 10    53 dcl     IL_TYPE		 char (14) internal static
 10    54 			 options (constant)
 10    55 			 init ("Internal Logic");
 10    56 
 10    57 /* parser_work_area is used to hold all static data for an invocation
 10    58*   of the parser. parser_static_info holds ptrs to all of these relevant
 10    59*   data and also a ptr back to the area it is allocated in. 
 10    60*   parser_work_area.
 10    61**/
 10    62 
 10    63 dcl parser_work_area aligned area (sys_info$max_seg_size) based (parser_static_info.pwa_ptr);
 10    64 
 10    65 dcl psi_ptr ptr;
 10    66 dcl 1 parser_static_info aligned based (psi_ptr),
 10    67       2 pwa_ptr ptr,
 10    68       2 semantics, /* for mrds_dsl_semantics */
 10    69         3 static_data_ptr ptr,
 10    70       2 expr, /* for mrds_dsl_expr_ */
 10    71         3 data_stacks_ptr ptr,
 10    72       2 func, /* for mrds_dsl_func_ */
 10    73         3 sfptrs_ptr ptr,
 10    74       2 where_clause, /* for mrds_dsl_where_clause_ */
 10    75         3 ns_ptr ptr;
 10    76 
 10    77 
 10    78 /* END INCLUDE FILE  mrds_se_info.incl.pl1 */
      971 
      972 
 11     1 /* BEGIN mrds_range.incl.pl1 -- jaw, 10/20/78 */
 11     2 
 11     3 /* Modified 83-04-22 by R. Harvey to add needed_bits */
 11     4 
 11     5 dcl 1 range aligned based (range_ptr),
 11     6     2 num_vars fixed bin,				/* number of tuple variables */
 11     7     2 tup_var (mrds_data_$max_tup_var refer (range.num_vars)), /* info for each tuple variable */
 11     8       3 name char (mrds_data_$max_id_len),		/* name of tuple variable */
 11     9       3 temp_rel bit (1) unal,			/* on if temporary relation */
 11    10       3 used bit (1) unal,				/* 1 => this tuple variable is referenced by
 11    11*						   a -select clause. */
 11    12       3 whole_tuple_selected bit (1) unal,		/* the whole tuple variable is referenced in the select clause */
 11    13       3 copy_for_current bit (1) unal,			/* -current requests attributes not previously retrieved */
 11    14       3 copied_for_current bit (1) unal,		/* tuple copied during previous -current */
 11    15       3 reserved bit (31) unal,			/* reserved for future use */
 11    16       3 rel_index fixed bin,				/* index to assoc. relation */
 11    17       3 stv_ptr ptr,				/* simple typed vector */
 11    18       3 idl_ptr ptr,				/* id_list ptr */
 11    19       3 needed_bits aligned,
 11    20         4 attr (mrds_data_$max_attributes) bit (1) unal,
 11    21       3 ri_ptr ptr;					/* pointer to rel info for assoc. relation */
 11    22 
 11    23 dcl  range_ptr ptr;
 11    24 
 11    25 /* END mrds_range.incl.pl1 */
 11    26 
      973 
      974 
 12     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
 12     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
 12     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
 12     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
 12     5 
 12     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
 12     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
 12     8     2 type unsigned fixed bin (6) unal,			/* data type */
 12     9     2 packed bit (1) unal,				/* on if data item is packed */
 12    10     2 number_dims bit (4) unal,			/* dimensions */
 12    11     2 size,					/* size for string data */
 12    12       3 scale bit (12) unal,				/* scale for num. data */
 12    13       3 precision bit (12) unal,			/* prec. for num. data */
 12    14     2 array_info (num_dims),
 12    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
 12    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
 12    17       3 multiplier fixed bin (35);			/*  element separation */
 12    18 
 12    19 dcl  desc_ptr ptr;
 12    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
 12    21 
 12    22 /* END mdbm_descriptor.incl.pl1 */
 12    23 
 12    24 
      975 
      976 
 13     1 /* BEGIN mrds_select_sets.incl.pl1		rdl,	2/27/79			*/
 13     2 
 13     3 dcl 1 select_sets aligned based (ss_ptr),
 13     4     2 dup_retain bit (1) unal,			/* ON => duplicate selected tuples must be preserved */
 13     5     2 pad bit (35) unal,				/* Resevered for furture use */
 13     6     2 domains (mrds_data_$max_select_items) char (32),	/* domain name of each select item */
 13     7     2 nitems fixed bin,				/* Number of items in this structure */
 13     8     2 items (nitems_init refer (select_sets.nitems)),
 13     9       3 oper_flag bit (1) unal,			/* On => this item is an operator */
 13    10       3 pad bit (35) unal,				/* Reserved for future use */
 13    11       3 op_code fixed bin,				/* Valid only if oper_flag id on
 13    12*						   1 -> union
 13    13*						   2 => intersection
 13    14*						   3 => Difference 			*/
 13    15       3 range_ptr ptr,				/* Valid only if oper_flag  is OFF, these pointers are */
 13    16       3 select_ptr ptr,				/* used by  mrds_dsl_search */
 13    17       3 so_ptr ptr,
 13    18       3 ti_ptr ptr;					/* to tuple info structure for this block */
 13    19 
 13    20 
 13    21 dcl  ss_ptr ptr;					/* Pointer to the selected sets */
 13    22 dcl  nitems_init fixed bin;
 13    23 
 13    24 dcl  UNION fixed bin internal static options (constant) init (1);
 13    25 dcl  INTERSECTION fixed bin internal static options (constant) init (2);
 13    26 dcl  DIFFERENCE fixed bin internal static options (constant) init (3);
 13    27 
 13    28 /* END mrds_dsl_select_sets.incl.pl1					*/
 13    29 
      977 
      978 
 14     1 /* Begin mrds_compiled_se_info.incl.pl1 -- John Hergert 09/01/84
 14     2*   Data structure to hold all pertinent information regarding compiled
 14     3*   selection expressions. Most of this information is put into the dbcb
 14     4*   variables having the same names when the compiled selection is referenced.
 14     5**/
 14     6 
 14     7 
 14     8 /****^  HISTORY COMMENTS:
 14     9*  1) change(87-01-22,Hergert), approve(88-05-19,MCR7903),
 14    10*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
 14    11*     Removed all references to var_exists_ptr.
 14    12*                                                   END HISTORY COMMENTS */
 14    13 
 14    14 
 14    15 dcl     1 compiled_se_info	 aligned based (compiled_se_info_ptr),
 14    16           2 real_select_area_ptr ptr,                       /* the real one assigned at open time */
 14    17 	2 compile_area_ptr	 ptr,			/* run time work area */
 14    18           2 temp_x_leaf_ptr    ptr,                         /* temp place to hold ptr to pred_leaf_list of .x.'s */
 14    19           2 temp_temp_rel_list_ptr ptr,                     /* temporary holding spot for list of temp rels */
 14    20 	2 number_of_compiled_se                           /* count of number of cse's weve had in this opening */
 14    21 			 fixed bin (35),
 14    22 
 14    23 
 14    24 	2 se_info		 (1                           /* various peices of information needed to describe the se */
 14    25 			 refer (compiled_se_info.number_of_compiled_se)),
 14    26             3 free             bit(1) unal,                 /* indicates whether this se is being used or not */
 14    27             3 dup_retain       bit(1) unal,                 /* se had a -dup in it */
 14    28             3 reserved         bit(34) unal,                /* a few spares */
 14    29             3 se_id_num        fixed bin(35),               /* the unique id num for the se */
 14    30 	  3 seg_ptr	 ptr,			/* points to seg that has compiled se */
 14    31 	  3 saved_ptrs,				/* these point to the various tables in the seg */
 14    32 	    5 select_area_ptr
 14    33 			 ptr,
 14    34 	    5 range_ptr	 ptr,
 14    35 	    5 select_ptr	 ptr,
 14    36 	    5 ti_ptr	 ptr,
 14    37 	    5 ss_ptr	 ptr,
 14    38               5 so_ptr         ptr,
 14    39               5 temp_rel_list_ptr ptr,
 14    40               5 x_leaf_ptr     ptr,                         /* ptr to list of ptrs to pred leaves for .x.'s */
 14    41               5 lit_ptr        ptr,
 14    42               5 reserved       (5) ptr;
 14    43 
 14    44 dcl     compiled_se_info_ptr	 ptr;
 14    45 
 14    46 
 14    47 
 14    48 /* info relating to the attributes and the literal for filling .X.'s */
 14    49 
 14    50 dcl  1 x_pred_leaf  based (x_pred_leaf_ptr) aligned,
 14    51        2 number_of_x fixed bin (35),                       /* number of .x. specified in this selection expr */
 14    52        2 lit_arg_ptr ptr,                                  /* temp pointer to literal arg */
 14    53        2 lit_desc_ptr ptr,                                  /* temp pointer to literal desc */
 14    54        2 info (mrds_data_$max_pred_nodes refer (x_pred_leaf.number_of_x)), /* this should be big enough */
 14    55          3 encode_proc bit unal,                            /* does this .x. have to be encoded */
 14    56          3 pad bit(35) unal,
 14    57          3 encode_entry entry,                              /* encode proc */
 14    58          3 encode_in_desc_ptr ptr,                          /* ptr to input to encode descrptior */
 14    59          3 encode_out_desc_ptr ptr,                         /* ptr to encoded descrptior */
 14    60          3 encode_bit_len fixed bin(35),                    /* length in bits of encoded value */
 14    61          3 lit_val_len fixed bin(35),                       /* length of value in bits to go in lit pool */
 14    62          3 lit_val_ptr ptr;                                 /* ptr to value in lit pool */
 14    63  
 14    64 
 14    65 dcl     x_pred_leaf_ptr     ptr;
 14    66 
 14    67 
 14    68 /* array of names for the temp rels used in a cse */
 14    69 /* these are used to make sure the temp isnt redefined on us after the se is compiled */
 14    70 dcl  1 temp_rel_list based (trl_ptr) aligned,   
 14    71        2 number_of_temp_rels fixed bin(35),  /* total number of temp rels in se including sets */
 14    72        2 temp_rel_info (mrds_data_$max_temp_rels) ,
 14    73          3 name char(32),                    /* model name */
 14    74          3 index fixed bin(35);              /* temp rel index */
 14    75 
 14    76 
 14    77 dcl trl_ptr ptr;
      979 
      980 
 15     1 /* BEGIN mdbm_scope_info.incl.pl1 -- odf 8/8/78 */
 15     2 
 15     3 /* WARNING
 15     4*          If the scope_info or scope_flags structure is changed then the
 15     5*          mrds_data_ item saved_res_version MUST be incremented to invalidate
 15     6*          all existing saved resultants
 15     7**/
 15     8 
 15     9 /* Modified by Jim Gray - - 80-11-17, to add back store/delete/modify permissions */
 15    10 
 15    11 /* 80-12-10 Jim Gray : change name of store to append_tuple, delete to delete_tuple,
 15    12*   modify to modify_attr, retrieve to read_attr, remvoe update, put level 4
 15    13*   qualifiers for permit/prevent modes and to put pads in standard format */
 15    14 
 15    15 /* 80-12-11 Jim Gray : added submodel version of file/rel name for convenience */
 15    16 
 15    17 /* 80-12-22 Jim Gray : added like referenced structure so linus_scope_data.incl
 15    18*   could make use of it for compatibility. */
 15    19 
 15    20 /* 81-1-11 Jim Gray : added touched bit to scope_flags, so that
 15    21*   the fact that null scope has been set can be displayed */
 15    22 
 15    23 /* 85-04-14 Thanh Nguyen: Made scope_flags to be aligned so we could access the
 15    24*   prevent flags from any pointer which directly pointed to scope_flags itself
 15    25*   (i.e rm_rel_info.scope_flags_ptr). */
 15    26 
 15    27 /* this structure is to be allocated in the mrds_dbcb.incl.pl1 static area,
 15    28*   and is used to maintain the scope mechanism for file access.
 15    29*   It contains the scope permit/prevent operations that this user
 15    30*   has set in his view for this opening instance. */
 15    31 
 15    32 dcl 1 scope_info aligned based (scope_ptr),		/* array of scope tuples for this user */
 15    33     2 mbz1 bit (144),				/* Reserved for future use */
 15    34     2 nfiles fixed bin,				/* Number of scope tuples in user's scope */
 15    35     2 active_scopes fixed bin,			/* number of scopes currently active for a given user */
 15    36     2 scope (max_file_init refer (scope_info.nfiles)),	/* defines user's scope of access to files */
 15    37       3 name char (30) aligned,			/* filename */
 15    38       3 sm_name char (32),				/* name of file(rel) in submodel */
 15    39       3 flags like scope_flags ;
 15    40 
 15    41 
 15    42 declare 1 scope_flags aligned based,			/* common layout of scope flag bits */
 15    43         2 permits,					/* modes to permit this user */
 15    44 	3 read_attr bit (1) unal,			/* read_attr access to this file in scope */
 15    45 	3 append_tuple bit (1) unal,			/* append_tuple concnrrency permission */
 15    46 	3 delete_tuple bit (1) unal,			/* delete_tuple concurrency permission on rel */
 15    47 	3 modify_attr bit (1) unal,			/* modify_attr concurrency permission */
 15    48 	3 mbz2 bit (10) unal,			/* for expansion of permit ops */
 15    49         2 prevents,					/* modes to be denyed to other users */
 15    50 	3 read_attr bit (1) unal,			/* on if user has prevent on read_attr for this file */
 15    51 	3 append_tuple bit (1) unal,			/* prevent of append_tuple concurrency */
 15    52 	3 delete_tuple bit (1) unal,			/* prevent of delete_tuple concurrency */
 15    53 	3 modify_attr bit (1) unal,			/* prevent of modify_attr concurrency */
 15    54 	3 mbz3 bit (10) unal,			/* for future prevent concurrency modes */
 15    55         2 touched bit (1) unal,			/* on => scope set for this relation */
 15    56         2 mbz4 bit (7) unal ;				/* for future flags */
 15    57 
 15    58 dcl  max_file_init fixed bin;				/* nbr. of files in data base */
 15    59 dcl  scope_ptr ptr init (null ());			/* points to scope_info array */
 15    60 dcl  scope_rdy bit (6) unal init ("000011"b) int static options (constant); /* scope file ready modes (5 or 6) */
 15    61 dcl  scope_rdy_array (6) bit (1) unal based;		/* array format of scope_rdy string */
 15    62 
 15    63 /* END mdbm_scope_info.incl.pl1 */
      981 
      982 
 16     1 /* BEGIN INCLUDE FILE mdbm_seg_area.incl.pl1 - - Jim Gray 2/19/79 */
 16     2 
 16     3 /* these structures provide a standard for
 16     4*   1) using an entire segment as an area, managed by the area manager
 16     5*   2) a constant header, that has an offset to the major common structure in the area
 16     6*   the pointer to that structure is obtained via pointer(model_seg_ptr, model_seg.offset)
 16     7*   the model_area_ptr is obtained via pointer(model_seg_ptr, size(model_seg)) */
 16     8 
 16     9 declare 1 model_seg aligned based (model_seg_ptr),	/* segment header, not to be changed */
 16    10         2 struct_offset bit (18),			/* offset to major structure allocated in area */
 16    11         2 padding (3) fixed bin ;			/* to set up four word boundary */
 16    12 
 16    13 declare  model_seg_ptr ptr int automatic init (null ());
 16    14 
 16    15 
 16    16 declare  model_area area (sys_info$max_seg_size - size (model_seg)) based (model_area_ptr) ; /* segment area */
 16    17 
 16    18 declare  model_area_ptr ptr int automatic init (null ());
 16    19 
 16    20 dcl size builtin;
 16    21 
 16    22 /* END INCLUDE FILE mdbm_seg_area.incl.pl1 */
 16    23 
      983 
      984 
 17     1 /* BEGIN INCLUDE FILE mrds_select_area.incl.pl1   (Kepner Multics)  05/29/79 1736.1 mst Tue */
 17     2 dcl 1 select_area_struct aligned based (select_area_struct_ptr), /* major structure in segment for current selection expression allocations */
 17     3     2 version fixed bin,
 17     4     2 dbcb_ptr ptr;					/* ptr ptr to dbcb */
 17     5 
 17     6 dcl  select_area_struct_ptr ptr int automatic init (null ());
 17     7 
 17     8 dcl  select_area area (sys_info$max_seg_size - size(model_seg)) based (select_area_ptr);
 17     9 
 17    10 dcl  select_area_ptr ptr int automatic init (null ());
 17    11 						/*   END INCLUDE FILE mrds_select_area.incl.pl1 */
 17    12 
      985 
      986 
 18     1 /* ***********************************************************
 18     2*   *                                                         *
 18     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 18     4*   *                                                         *
 18     5*   *********************************************************** */
 18     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
 18     7 
 18     8 /* Written by Lindsey Spratt, 04/02/82.
 18     9*Modified:
 18    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
 18    11*	  unaligned.  Changed the type number of the simple_typed_vector to
 18    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
 18    13*	  type.
 18    14**/
 18    15 
 18    16 /* format: style2,ind3 */
 18    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
 18    18 	     2 type	      fixed bin (17) unal,
 18    19 	     2 number_of_dimensions
 18    20 			      fixed bin (17) unal,
 18    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
 18    22 	       3 value_ptr	      ptr unaligned;
 18    23 
 18    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
 18    25 	     2 type	      fixed bin (17) unal,
 18    26 	     2 number_of_dimensions
 18    27 			      fixed bin (17) unal,
 18    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
 18    29 	       3 identifier	      fixed bin (17) unal,
 18    30 	       3 pad	      bit (18) unal,
 18    31 	       3 value_ptr	      ptr unal;
 18    32 
 18    33      dcl	   simple_typed_vector_ptr
 18    34 			      ptr;
 18    35      dcl	   stv_number_of_dimensions
 18    36 			      fixed bin (17);
 18    37 
 18    38      dcl	   general_typed_vector_ptr
 18    39 			      ptr;
 18    40      dcl	   gtv_number_of_dimensions
 18    41 			      fixed bin (17);
 18    42 
 18    43      dcl	   (
 18    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
 18    45 			      init (1),		/* value_ptr was aligned. */
 18    46 	   GENERAL_TYPED_VECTOR_TYPE
 18    47 			      init (2),
 18    48 	   SIMPLE_TYPED_VECTOR_TYPE
 18    49 			      init (3)
 18    50 	   )		      fixed bin (17) internal static options (constant);
 18    51 
 18    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      987 
      988 
      989 
      990 dcl     1 free_relations	 based (select_list.fr_ptr) aligned,
      991 						/* list of relation used in the select clause */
      992 	2 num_free_rels	 fixed bin,
      993 	2 free_rels	 (mrds_data_$max_relations) fixed bin;
      994 						/* array to hold all indicies of free vars */
      995 
      996 dcl     LOUD		 bit init ("1"b) aligned internal static
      997 			 options (constant);
      998 dcl     a_range_ptr		 ptr;
      999 dcl     a_rmri_ptr  	 ptr;
     1000 dcl     a_select_list_ptr	 ptr;
     1001 dcl     addbitno		 builtin;
     1002 dcl     addr		 builtin;
     1003 dcl     ai_ptr		 ptr;
     1004 dcl     area_ptr		 ptr;
     1005 dcl     argp_ptr		 ptr;
     1006 dcl     attr_index		 fixed bin;
     1007 dcl     caller		 fixed bin (35) parm;
     1008 dcl     caller_name		 char (32) init ("mrds_dsl_select_clause");
     1009 dcl     check_sw		 bit (1) aligned;		/* on if checking union comp. */
     1010 dcl     code		 fixed bin (35);
     1011 dcl     compiled_sw		 bit (1) aligned;		/* switch indicating if -compiled entry */
     1012 dcl     continue		 char (1) init ("c");	/* dont stop after printing error mesg */
     1013 dcl     cur_sw		 bit (1) aligned;		/* switch indicating if -current or -select entry */
     1014 dcl     descp_ptr		 ptr;
     1015 dcl     err_msg		 char (256);
     1016 dcl     err_msg_len		 fixed bin;
     1017 dcl     fixed		 builtin;
     1018 dcl     free_rel		 bit (1) unal;		/* on if relat.is assoc. with free var. */
     1019 dcl     i			 fixed bin;
     1020 dcl     icode		 fixed bin (35);
     1021 dcl     info_ptr		 ptr init (null ());	/* unused */
     1022 dcl     ioa_$rsnnl		 entry () options (variable);
     1023 dcl     k			 fixed bin;
     1024 dcl     mod		 builtin;
     1025 dcl     mrds_data_$caller_compile
     1026 			 fixed bin (35) ext;	/* dsl_$compile called */
     1027 dcl     mrds_data_$caller_define_temp_rel
     1028 			 fixed bin (35) external static;
     1029 dcl     mrds_data_$caller_delete
     1030 			 fixed bin (35) ext;	/* dsl_$delete called */
     1031 dcl     mrds_data_$caller_modify
     1032 			 fixed bin (35) external static;
     1033 dcl     mrds_data_$caller_retrieve
     1034 			 fixed bin (35) external static;
     1035 dcl     mrds_data_$max_attributes
     1036 			 fixed bin (35) ext static;
     1037 dcl     mrds_data_$max_id_len	 fixed bin (35) external;
     1038 dcl     mrds_data_$max_relations
     1039 			 fixed bin (35) external;
     1040 dcl     mrds_data_$max_select_items
     1041 			 fixed bin (35) external;
     1042 dcl     mrds_data_$max_temp_rels
     1043 			 fixed bin (35) external;
     1044 dcl     mrds_dsl_set_user_vals entry (ptr, ptr, ptr, ptr, fixed bin, ptr,
     1045 			 fixed bin (35));
     1046 dcl     mrds_error_$block_dom_incons
     1047 			 fixed bin (35) external;
     1048 dcl     mrds_error_$block_sel_incons
     1049 			 fixed bin (35) external;
     1050 dcl     mrds_error_$max_select_items
     1051 			 fixed bin (35) external;
     1052 dcl     mrds_error_$scope_viol fixed bin (35) external;
     1053 dcl     mrds_error_$undef_temp_rel
     1054 			 fixed bin (35) external;
     1055 dcl     null		 builtin;
     1056 dcl     num_args		 fixed bin;
     1057 dcl     rel		 builtin;
     1058 dcl     relation_index	 fixed bin;
     1059 dcl     return_value	 fixed bin (35) init (0);	/* unused */
     1060 dcl     s_ptr		 ptr;
     1061 dcl     se_info_ptr		 ptr;
     1062 dcl     sub_err_		 entry options (variable);	/* reports error details */
     1063 dcl     sys_info$max_seg_size	 fixed bin (35) external;
     1064 dcl     temp_rel_key           bit (1) aligned parameter;
     1065 
     1066 exit:
     1067     end mrds_dsl_select_clause_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1300.0  mrds_dsl_select_clause_.pl1       >special_ldd>install>MR12.2-1073>mrds_dsl_select_clause_.pl1
953          1    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
955          2    08/01/88  1300.0  mrds_select_list.incl.pl1         >special_ldd>install>MR12.2-1073>mrds_select_list.incl.pl1
957          3    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
959          4    10/14/83  1609.1  mdbm_rm_rel_array.incl.pl1        >ldd>include>mdbm_rm_rel_array.incl.pl1
961          5    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
963          6    10/14/83  1609.1  mdbm_rm_attr_info.incl.pl1        >ldd>include>mdbm_rm_attr_info.incl.pl1
965          7    10/14/83  1609.0  mrds_tuple_info.incl.pl1          >ldd>include>mrds_tuple_info.incl.pl1
967          8    10/14/83  1608.9  mdbm_move_list.incl.pl1           >ldd>include>mdbm_move_list.incl.pl1
969          9    10/14/83  1609.1  mdbm_rm_domain_info.incl.pl1      >ldd>include>mdbm_rm_domain_info.incl.pl1
971         10    08/01/88  1300.0  mrds_se_info.incl.pl1             >special_ldd>install>MR12.2-1073>mrds_se_info.incl.pl1
973         11    10/14/83  1609.1  mrds_range.incl.pl1               >ldd>include>mrds_range.incl.pl1
975         12    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
977         13    10/14/83  1608.4  mrds_select_sets.incl.pl1         >ldd>include>mrds_select_sets.incl.pl1
979         14    08/01/88  1300.0  mrds_compiled_se_info.incl.pl1    >special_ldd>install>MR12.2-1073>mrds_compiled_se_info.incl.pl1
981         15    04/18/85  1628.1  mdbm_scope_info.incl.pl1          >ldd>include>mdbm_scope_info.incl.pl1
983         16    10/14/83  1608.6  mdbm_seg_area.incl.pl1            >ldd>include>mdbm_seg_area.incl.pl1
985         17    10/14/83  1608.6  mrds_select_area.incl.pl1         >ldd>include>mrds_select_area.incl.pl1
987         18    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AV_TYPE                         000004 constant        char(16)                 initial packed unaligned dcl 10-50 set ref 591* 599*
BYTE                            000046 constant        fixed bin(17,0)          initial dcl 941 set ref 885*
DOUBLE_WORD                     000042 constant        fixed bin(17,0)          initial dcl 947 set ref 904*
LOUD                            000037 constant        bit(1)                   initial dcl 996 set ref 210 219 292* 303* 349* 364*
                                                                                  437* 565 591* 599*
SC_TYPE                         000010 constant        char(13)                 initial packed unaligned dcl 10-38 set ref 292* 303*
                                                                                  349* 364* 437*
SIMPLE_TYPED_VECTOR_TYPE               constant        fixed bin(17,0)          initial dcl 18-43 ref 796
WORD                            000043 constant        fixed bin(17,0)          initial dcl 944 set ref 890*
a_range_ptr                            parameter       pointer                  dcl 998 ref 244 252 325 334 417 422
a_rmri_ptr                             parameter       pointer                  dcl 999 ref 244 254 325 336
a_select_list_ptr                      parameter       pointer                  dcl 1000 ref 244 253 325 335 417 423
addbitno                                               builtin function         dcl 1001 ref 811
addr                                                   builtin function         dcl 1002 ref 800 800
ai_ptr                   12            based           pointer                  array level 3 in structure "select_list" dcl 2-22
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  318* 390* 676
ai_ptr                          000140 automatic       pointer                  dcl 1003 in procedure "mrds_dsl_select_clause_" set
                                                                                  ref 337* 364 373 373 373 377 390 395 401
area_ptr                               parameter       pointer                  dcl 775 in procedure "create_simple_vector" ref 742
                                                                                  795 809
area_ptr                               parameter       pointer                  dcl 1004 in procedure "mrds_dsl_select_clause_" set
                                                                                  ref 184 216* 417 476*
argp_ptr                               parameter       pointer                  dcl 1005 set ref 184 216* 417 476*
attr                                   based           bit(1)                   array level 4 packed packed unaligned dcl 11-5 set
                                                                                  ref 395* 401
attr_index                2            based           fixed bin(17,0)          array level 3 in structure "move_list" dcl 8-11
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  676*
attr_index                             parameter       fixed bin(17,0)          dcl 1006 in procedure "mrds_dsl_select_clause_" ref
                                                                                  325 337
attr_offset                     000434 automatic       fixed bin(24,0)          array dcl 780 set ref 800* 805 811
attr_ptrs                              based           pointer                  array level 2 dcl 5-119 ref 283 283 303 318 337 800
                                                                                  800 805
base_to_pad                            parameter       fixed bin(24,0)          dcl 870 set ref 819 885* 890* 904*
bit_length               24            based           fixed bin(35,0)          level 2 dcl 6-46 ref 805
block_size                      001034 automatic       fixed bin(24,0)          dcl 782 set ref 798* 800 800 805* 809 809
caller                                 parameter       fixed bin(35,0)          dcl 1007 set ref 184 244 265 283* 325 373* 395 417
                                                                                  467 469 469 482 513 518* 524* 531* 590 596
caller_name                     000142 automatic       char(32)                 initial packed unaligned dcl 1008 set ref 559* 1008*
calling_module                         parameter       fixed bin(35,0)          dcl 580 ref 573
calling_routine                        parameter       fixed bin(35,0)          dcl 568 ref 545 550 553
cd                                     parameter       fixed bin(35,0)          dcl 721 ref 718 729
check_sw                        000152 automatic       bit(1)                   dcl 1009 set ref 260* 261* 300 340* 341* 361
code                                   parameter       fixed bin(35,0)          dcl 1010 in procedure "mrds_dsl_select_clause_" set
                                                                                  ref 184 216* 219 219* 244 325 417 476* 729*
code                                   parameter       fixed bin(35,0)          dcl 567 in procedure "scope_error" set ref 545 559*
                                                                                  565*
compiled_sw                     000153 automatic       bit(1)                   dcl 1011 set ref 193* 263* 343* 425* 699
continue                        000154 automatic       char(1)                  initial packed unaligned dcl 1012 set ref 559* 1012*
copied_for_current                     based           bit(1)                   array level 3 packed packed unaligned dcl 11-5 ref
                                                                                  270 401
copy_for_current                       based           bit(1)                   array level 3 packed packed unaligned dcl 11-5 set
                                                                                  ref 270* 401*
cur_sw                                 parameter       bit(1)                   dcl 1013 ref 184 244 267 325 395 417 427 485 699
current_ptr              16            based           pointer                  level 3 dcl 1-142 set ref 485*
d_ptr                                  parameter       pointer                  dcl 868 ref 819 874 876 879 879 879 879 879 890 890
                                                                                  890 890 890 890 890 890 890 904 904 904 904
data                                   based           structure                level 2 in structure "rm_db_info" dcl 3-86
                                                                                  in procedure "mrds_dsl_select_clause_"
data                                   based           structure                level 2 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_select_clause_"
data_string                            based           bit                      packed unaligned dcl 783 ref 809
data_string_ptr                 001036 automatic       pointer                  dcl 785 set ref 809* 811
db_desc                  10            based           bit(36)                  level 2 dcl 9-35 set ref 800 800
dbcb                                   based           structure                level 1 dcl 1-142
dbcb_data                              based           structure                level 1 unaligned dcl 1-148
dbcb_ptr                               parameter       pointer                  dcl 1-146 set ref 184 194 196 197 198 201 210 216*
                                                                                  223 244 255 258 300 325 338 353 353 361 377 381
                                                                                  417 424 427 428 472 472 476* 485 487 727
defn_order               22            based           fixed bin(17,0)          level 2 dcl 6-46 ref 395 401 676
delete_tuple              0(02)        based           bit(1)                   level 3 packed packed unaligned dcl 15-42 ref 514
descp_ptr                              parameter       pointer                  dcl 1014 set ref 184 216* 417 476*
descriptor                             based           structure                level 1 unaligned dcl 12-6
dimension                 1            based           structure                array level 2 packed packed unaligned dcl 18-17
domain_ptr               26            based           pointer                  level 2 dcl 6-46 ref 303 364 800 800
domains                   1            based           char(32)                 array level 2 dcl 13-3 ref 303 364
err_msg                         000155 automatic       char(256)                packed unaligned dcl 1015 set ref 290* 292* 347*
                                                                                  349* 433* 437*
err_msg_len                     000255 automatic       fixed bin(17,0)          dcl 1016 set ref 290* 347* 433*
error_info_supplied       6            based           bit(1)                   level 3 dcl 10-13 set ref 736*
error_msg                22            based           char(256)                level 3 dcl 10-13 set ref 735*
error_report              6            based           structure                level 2 dcl 10-13
error_type               14            based           char(24)                 level 3 in structure "se_info" dcl 10-13
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  732*
error_type                             parameter       char                     packed unaligned dcl 724 in procedure "error" ref
                                                                                  718 732
fr_ptr                    4            based           pointer                  level 2 dcl 2-22 ref 507 508 621 622 626 626 627 627
free_rel                        000256 automatic       bit(1)                   packed unaligned dcl 1018 set ref 506* 507 508* 512
                                                                                  620* 621 622* 625
free_relations                         based           structure                level 1 dcl 990
free_rels                 1            based           fixed bin(17,0)          array level 2 dcl 990 set ref 508 622 627*
i                               000414 automatic       fixed bin(17,0)          dcl 697 in procedure "make_tuple_info" set ref 707*
                                                                                  708 710*
i                               000370 automatic       fixed bin(17,0)          dcl 636 in procedure "make_move_lists" set ref 644*
                                                                                  645* 650* 651* 672* 673 676 678 680*
i                               001040 automatic       fixed bin(17,0)          dcl 786 in procedure "create_simple_vector" set ref
                                                                                  799* 800 800 800 805 805* 810* 811 811*
i                               000257 automatic       fixed bin(17,0)          dcl 1019 in procedure "mrds_dsl_select_clause_" set
                                                                                  ref 207* 210 210* 228* 229 229 231 231 233 233*
                                                                                  281* 283 283 303 318* 441* 442 442 444 444 446
                                                                                  446* 503* 504 505 508*
index                    10(02)        based           bit(1)                   array level 3 in structure "select_list" packed
                                                                                  packed unaligned dcl 2-22 in procedure
                                                                                  "mrds_dsl_select_clause_" set ref 315*
index                    11            based           fixed bin(35,0)          array level 3 in structure "temp_rel_list" dcl 14-70
                                                                                  in procedure "mrds_dsl_select_clause_" ref 210
info_ptr                        000260 automatic       pointer                  initial dcl 1021 set ref 559* 1021*
ioa_$rsnnl                      000010 constant        entry                    external dcl 1022 ref 290 347 433
item                     10            based           structure                array level 2 in structure "select_list" unaligned
                                                                                  dcl 2-22 in procedure "mrds_dsl_select_clause_"
                                                                                  set ref 298* 359*
item                      2            based           structure                array level 2 in structure "move_list" dcl 8-11
                                                                                  in procedure "mrds_dsl_select_clause_"
items                                  based           structure                array level 2 dcl 13-3
j                               000357 automatic       fixed bin(17,0)          dcl 614 set ref 621* 622*
k                               000371 automatic       fixed bin(17,0)          dcl 636 in procedure "make_move_lists" set ref 656*
                                                                                  657 657 660 662 665 668 673*
k                               000262 automatic       fixed bin(17,0)          dcl 1023 in procedure "mrds_dsl_select_clause_" set
                                                                                  ref 225* 226 227* 507* 508*
key                      10(01)        based           bit(1)                   array level 3 packed packed unaligned dcl 2-22 set
                                                                                  ref 312* 381* 381 386*
key_attr                 20            based           bit(1)                   level 2 packed packed unaligned dcl 6-46 ref 377
loud                                   parameter       bit(1)                   dcl 722 in procedure "error" ref 718 731
loud                      7            based           bit(1)                   level 3 in structure "se_info" dcl 10-13
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  731*
m_bit                                  parameter       bit(1)                   packed unaligned dcl 582 ref 573 599
mdbm_error_$inc_attr_acc        000050 external static fixed bin(35,0)          dcl 585 set ref 591* 599*
mdbm_secured             21(06)        based           bit(1)                   level 2 in structure "rm_rel_info" packed packed
                                                                                  unaligned dcl 5-119 in procedure
                                                                                  "mrds_dsl_select_clause_" ref 283
mdbm_secured             20(04)        based           bit(1)                   level 2 in structure "rm_attr_info" packed packed
                                                                                  unaligned dcl 6-46 in procedure
                                                                                  "mrds_dsl_select_clause_" ref 373
message                                parameter       char                     packed unaligned dcl 725 ref 718 735
ml_nitems_init                  000112 automatic       fixed bin(17,0)          dcl 8-19 set ref 663* 664 664
ml_ptr                          000110 automatic       pointer                  dcl 8-18 in procedure "mrds_dsl_select_clause_" set
                                                                                  ref 664* 665 668* 669 676 678 680 685
ml_ptr                    2            based           pointer                  array level 2 in structure "move_list_array"
                                                                                  dcl 2-40 in procedure "mrds_dsl_select_clause_"
                                                                                  set ref 645* 662 665* 668
mla_ptr                   2            based           pointer                  level 2 dcl 2-22 set ref 641 643* 645 657 657 660
                                                                                  662 665 668 673
mli                             000373 automatic       fixed bin(17,0)          dcl 636 set ref 671* 675* 675 676 678 680 685
mod                                                    builtin function         dcl 1024 ref 924 928
model_area_ptr                  000130 automatic       pointer                  initial dcl 16-18 set ref 16-18*
model_seg_ptr                   000126 automatic       pointer                  initial dcl 16-13 set ref 16-13*
modify_attr               0(03)        based           bit(1)                   level 3 packed packed unaligned dcl 15-42 ref 520
modify_perm              20(03)        based           bit(1)                   level 2 packed packed unaligned dcl 6-46 set ref
                                                                                  283* 373*
move_list                              based           structure                level 1 dcl 8-11 set ref 664
move_list_array                        based           structure                array level 1 unaligned dcl 2-40 set ref 643
mrds_data_$caller_compile       000012 external static fixed bin(35,0)          dcl 1025 ref 467 482
mrds_data_$caller_define_temp_rel
                                000014 external static fixed bin(35,0)          dcl 1027 ref 469
mrds_data_$caller_delete        000016 external static fixed bin(35,0)          dcl 1029 ref 265 469 550
mrds_data_$caller_modify        000020 external static fixed bin(35,0)          dcl 1031 ref 395 553 596
mrds_data_$caller_retrieve      000022 external static fixed bin(35,0)          dcl 1033 set ref 534* 590
mrds_data_$max_attributes       000024 external static fixed bin(35,0)          dcl 1035 ref 257 257 267 267 270 270 270 270 270 270
                                                                                  278 278 392 392 395 395 401 401 401 401 401 401
                                                                                  401 401 412 412 504 504 505 505 505 508 508 618
                                                                                  618 708 708 708
mrds_data_$max_id_len           000026 external static fixed bin(35,0)          dcl 1037 ref 257 257 257 267 267 267 270 270 270 270
                                                                                  270 270 270 270 270 278 278 278 392 392 392 395
                                                                                  395 395 401 401 401 401 401 401 401 401 401 401
                                                                                  401 401 412 412 412 504 504 504 505 505 505 508
                                                                                  508 508 618 618 618 708 708 708
mrds_data_$max_select_items     000030 external static fixed bin(35,0)          dcl 1040 set ref 202 203 224 225 226 227 288 290*
                                                                                  345 347* 381 428 663 669
mrds_dsl_set_user_vals          000032 constant        entry                    external dcl 1044 ref 216 476
mrds_error_$block_dom_incons    000034 external static fixed bin(35,0)          dcl 1046 set ref 303* 364*
mrds_error_$block_sel_incons    000036 external static fixed bin(35,0)          dcl 1048 set ref 437*
mrds_error_$max_select_items    000040 external static fixed bin(35,0)          dcl 1050 set ref 292* 349*
mrds_error_$scope_viol          000042 external static fixed bin(35,0)          dcl 1052 set ref 518* 524* 531* 534*
mrds_error_$undef_temp_rel      000044 external static fixed bin(35,0)          dcl 1053 set ref 210*
must_convert             10            based           bit(1)                   array level 3 packed packed unaligned dcl 2-22 set
                                                                                  ref 231* 231 444* 444
name                      1            based           structure                array level 2 in structure "rm_rel_array" packed
                                                                                  packed unaligned dcl 4-34 in procedure
                                                                                  "mrds_dsl_select_clause_"
name                      1            based           char(32)                 array level 3 in structure "temp_rel_list" dcl 14-70
                                                                                  in procedure "mrds_dsl_select_clause_" ref 210
name                                   based           char(32)                 level 2 in structure "rm_domain_info" dcl 9-35
                                                                                  in procedure "mrds_dsl_select_clause_" ref 303 364
name                                   based           char(32)                 level 2 in structure "rm_rel_info" dcl 5-119
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  559*
needed_bits                            based           structure                array level 3 in structure "range" dcl 11-5
                                                                                  in procedure "mrds_dsl_select_clause_"
needed_bits                     001054 automatic       fixed bin(17,0)          dcl 869 in procedure "align_data_item" set ref 872*
                                                                                  885* 890* 904* 915
nitems                                 based           fixed bin(17,0)          level 2 in structure "select_sets" dcl 13-3
                                                                                  in procedure "mrds_dsl_select_clause_" ref 225
nitems                                 based           fixed bin(17,0)          level 2 in structure "move_list" dcl 8-11
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  664* 669* 685*
nkey_attr                24            based           fixed bin(17,0)          level 2 dcl 5-119 ref 283 283 303 318 337 514 520
                                                                                  526 534 800 800 805
null                                                   builtin function         dcl 1055 ref 196 207 223 260 340 2-38 6-65 9-51
                                                                                  15-59 16-13 16-18 17-6 17-10 641 645 662 874 1021
num_args                               parameter       fixed bin(17,0)          dcl 1056 set ref 184 216* 417 469 476*
num_attr                 22            based           fixed bin(17,0)          level 2 dcl 5-119 ref 281 514 520 526 534 793
num_dims                        000120 automatic       fixed bin(17,0)          initial dcl 12-20 set ref 12-20*
num_free_rels                          based           fixed bin(17,0)          level 2 dcl 990 set ref 507 621 626* 626 627
num_items                 6            based           fixed bin(17,0)          level 2 dcl 2-22 set ref 228 288 296* 296 298 303
                                                                                  312 315 316 318 345 353 353 358* 358 359 364 381
                                                                                  381 386 389 390 431 431 433* 433* 441 672
num_tuples                             based           fixed bin(17,0)          level 2 dcl 7-10 set ref 702*
num_vars                               based           fixed bin(17,0)          level 2 in structure "range" dcl 11-5 in procedure
                                                                                  "mrds_dsl_select_clause_" ref 503 642 650 657 701
                                                                                  707
num_vars                               based           fixed bin(17,0)          level 2 in structure "select_list" dcl 2-22
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  642* 643 644 648* 651* 651 656
number_of_bits                  001064 automatic       fixed bin(17,0)          dcl 937 set ref 924* 928* 932
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 18-17 set ref
                                                                                  795* 797*
number_of_temp_rels                    based           fixed bin(35,0)          level 2 dcl 14-70 ref 207
oper_flag                              based           bit(1)                   array level 3 packed packed unaligned dcl 13-3 ref
                                                                                  226
packed                    0(07)        based           bit(1)                   level 2 packed packed unaligned dcl 12-6 ref 876
pad_base                               parameter       fixed bin(24,0)          dcl 936 ref 917 924 928
pad_size                               parameter       fixed bin(17,0)          dcl 935 ref 917 924 928 928
permits                                based           structure                level 2 dcl 15-42
prev_select             106(05)        based           bit(1)                   level 3 packed packed unaligned dcl 1-142 set ref
                                                                                  300 361 381 427 487*
r_bit                                  parameter       bit(1)                   packed unaligned dcl 581 ref 573 591
rai_ptr                         000104 automatic       pointer                  initial dcl 6-65 set ref 6-65*
range                                  based           structure                level 1 dcl 11-5
range_ptr                              based           pointer                  array level 3 in structure "select_sets" dcl 13-3
                                                                                  in procedure "mrds_dsl_select_clause_" ref 202
range_ptr                       000116 automatic       pointer                  dcl 11-23 in procedure "mrds_dsl_select_clause_" set
                                                                                  ref 197* 202* 252* 257 267 270 270 270 278 334*
                                                                                  392 395 401 401 401 401 412 422* 503 504 505 508
                                                                                  618 642 650 657 701 707 708
range_ptr                 2            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_select_clause_" ref 197
rdbi_ptr                               based           pointer                  level 3 dcl 1-142 ref 210
rdi_ptr                         000114 automatic       pointer                  initial dcl 9-51 set ref 9-51*
read_attr                              based           bit(1)                   level 3 packed packed unaligned dcl 15-42 ref 526
                                                                                  534
read_perm                20(02)        based           bit(1)                   level 2 packed packed unaligned dcl 6-46 set ref
                                                                                  283* 373*
rel_index                       000356 automatic       fixed bin(17,0)          dcl 614 in procedure "add_free_rel" set ref 618* 622
                                                                                  627
rel_index                              based           fixed bin(17,0)          array level 3 in structure "range" dcl 11-5
                                                                                  in procedure "mrds_dsl_select_clause_" ref 508 618
relation_index                         parameter       fixed bin(17,0)          dcl 1058 set ref 244 256 257 267 270 270 270 278
                                                                                  278* 316 325 353 389 391 392 395 401 401 401 401
                                                                                  412 412*
return_value                    000263 automatic       fixed bin(35,0)          initial dcl 1059 set ref 559* 1059*
ri_ptr                                 based           pointer                  array level 3 dcl 11-5 ref 505 708
rm_attr_info                           based           structure                level 1 dcl 6-46
rm_db_info                             based           structure                level 1 dcl 3-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 3-92
rm_domain_info                         based           structure                level 1 dcl 9-35
rm_rel_array                           based           structure                level 1 dcl 4-34
rm_rel_info                            based           structure                level 1 dcl 5-119
rmri_ptr                        000102 automatic       pointer                  dcl 5-156 in procedure "mrds_dsl_select_clause_" set
                                                                                  ref 254* 281 283 283 283 303 318 336* 337 505* 514
                                                                                  520 526 534 559 708* 711* 793 800 800 805
rmri_ptr                               parameter       pointer                  dcl 774 in procedure "create_simple_vector" ref 742
s_ptr                           000264 automatic       pointer                  dcl 1060 set ref 224* 229 231 233 428* 431 433 442
                                                                                  444 446
scope_flags                            based           structure                level 1 dcl 15-42
scope_flags_ptr                        based           pointer                  level 2 dcl 5-119 ref 514 520 526 534
scope_ptr                       000124 automatic       pointer                  initial dcl 15-59 set ref 15-59*
scope_type                      000334 automatic       varying char(20)         dcl 569 set ref 550* 553* 556* 559*
se_info                                based           structure                level 1 dcl 10-13
se_info_ptr              72            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_select_clause_" ref 727
se_info_ptr                     000266 automatic       pointer                  dcl 1061 in procedure "mrds_dsl_select_clause_" set
                                                                                  ref 727* 731 732 733 734 735 736
select_area                            based           area                     dcl 17-8 ref 643 664 702
select_area_ptr                 000134 automatic       pointer                  initial dcl 17-10 in procedure
                                                                                  "mrds_dsl_select_clause_" set ref 194* 424* 17-10*
                                                                                  643 664 702 711*
select_area_ptr          36            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_select_clause_" ref 194 424
select_area_struct_ptr          000132 automatic       pointer                  initial dcl 17-6 set ref 17-6*
select_list                            based           structure                level 1 unaligned dcl 2-22
select_list_ptr                 000100 automatic       pointer                  initial dcl 2-38 set ref 198* 203* 216* 227* 228 229
                                                                                  231 233 253* 256 288 296 296 298 298 303 312 312
                                                                                  315 315 316 316 318 318 335* 345 353 353 353 358
                                                                                  358 359 359 364 381 381 381 386 386 389 389 390
                                                                                  390 391 423* 431 433 441 442 444 446 476* 485
                                                                                  2-38* 507 508 621 622 626 626 627 627 641 642 643
                                                                                  643 644 645 648 651 651 651 656 657 657 657 660
                                                                                  662 665 668 672 673 673 676 678 680
select_ptr                4            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_select_clause_" ref 198
select_ptr                             based           pointer                  array level 3 in structure "select_sets" dcl 13-3
                                                                                  in procedure "mrds_dsl_select_clause_" ref 203 224
                                                                                  227 381 428
select_sets                            based           structure                level 1 dcl 13-3
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 18-17 set ref
                                                                                  795
ss_ptr                          000122 automatic       pointer                  dcl 13-21 in procedure "mrds_dsl_select_clause_" set
                                                                                  ref 201* 202 203 224 225 226 227 258* 260 303 338*
                                                                                  340 364 381
ss_ptr                   20            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_select_clause_" ref 196 201 223 258 338
                                                                                  428
stack_offset                           parameter       fixed bin(17,0)          dcl 723 in procedure "error" ref 718 734
stack_offset             13            based           fixed bin(17,0)          level 3 in structure "se_info" dcl 10-13
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  734*
stv_number_of_dimensions        000136 automatic       fixed bin(17,0)          dcl 18-35 set ref 794* 795 795
sub_err_                        000046 constant        entry                    external dcl 1062 ref 559
submodel                  1(09)        based           char(32)                 array level 3 packed packed unaligned dcl 4-34 ref
                                                                                  210
temp_rel                               based           bit(1)                   array level 3 packed packed unaligned dcl 11-5 ref
                                                                                  278 412 504
temp_rel_info             1            based           structure                array level 2 dcl 14-70
temp_rel_key                           parameter       bit(1)                   dcl 1064 ref 325 386
temp_rel_list                          based           structure                level 1 dcl 14-70
ti_ntuples_init                 000106 automatic       fixed bin(17,0)          dcl 7-18 set ref 701* 702 702
ti_ptr                                 parameter       pointer                  dcl 7-17 set ref 417 702* 710 711 713
tii                             000415 automatic       fixed bin(17,0)          dcl 697 set ref 706* 709* 709 710 711 713
token_start              10            based           fixed bin(17,0)          level 3 dcl 10-13 set ref 733*
total_attr                      001041 automatic       fixed bin(17,0)          dcl 787 set ref 793* 794 797 799 810
tra_ptr                 136            based           pointer                  level 3 dcl 3-86 ref 210
trl_ptr                                parameter       pointer                  dcl 14-77 ref 184 207 207 210 210
tup_var                   2            based           structure                array level 2 dcl 11-5
tuple                     2            based           structure                array level 2 dcl 7-10
tuple_id                  4            based           bit(36)                  array level 3 dcl 7-10 set ref 713*
tuple_info                             based           structure                level 1 dcl 7-10 set ref 702
tuple_ptr                 2            based           pointer                  array level 3 dcl 7-10 set ref 711*
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 18-17 in procedure
                                                                                  "mrds_dsl_select_clause_" set ref 796*
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "descriptor" packed packed
                                                                                  unsigned unaligned dcl 12-6 in procedure
                                                                                  "mrds_dsl_select_clause_" ref 879 879 879 879 879
                                                                                  890 890 890 890 890 890 890 890 890 904 904 904
                                                                                  904
used                                   based           bit(1)                   array level 3 packed packed unaligned dcl 11-5 set
                                                                                  ref 257* 392*
user_desc_ptr             6            based           pointer                  array level 3 in structure "move_list" dcl 8-11
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  680*
user_desc_ptr            14            based           pointer                  array level 3 in structure "select_list" dcl 2-22
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  233* 233 446* 446 680
user_ptr                 16            based           pointer                  array level 3 in structure "select_list" dcl 2-22
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  229* 229 442* 442 678
user_ptr                  4            based           pointer                  array level 3 in structure "move_list" dcl 8-11
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  678*
val_del                 106(11)        based           bit(1)                   level 3 packed packed unaligned dcl 1-142 set ref
                                                                                  353*
val_mod                 106(10)        based           bit(1)                   level 3 packed packed unaligned dcl 1-142 set ref
                                                                                  255* 353* 377* 472*
val_rtrv                106(09)        based           bit(1)                   level 3 packed packed unaligned dcl 1-142 set ref
                                                                                  472*
value_ptr                 1            based           pointer                  array level 3 packed packed unaligned dcl 18-17 set
                                                                                  ref 811*
var_exists                7            based           bit(1)                   array level 2 packed packed unaligned dcl 2-22 set
                                                                                  ref 256* 391* 651 657
var_index                              based           fixed bin(17,0)          array level 2 in structure "move_list_array"
                                                                                  dcl 2-40 in procedure "mrds_dsl_select_clause_"
                                                                                  set ref 657* 657* 660 673
var_index                 5            based           fixed bin(17,0)          array level 3 in structure "tuple_info" dcl 7-10
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  710*
var_index                              parameter       fixed bin(17,0)          dcl 614 in procedure "add_free_rel" ref 609 618
var_index                11            based           fixed bin(17,0)          array level 3 in structure "select_list" dcl 2-22
                                                                                  in procedure "mrds_dsl_select_clause_" set ref
                                                                                  316* 353 389* 673
var_init                        000372 automatic       fixed bin(17,0)          dcl 636 set ref 655* 657 660*
vector_area                            based           area(1024)               dcl 788 ref 795 809
vector_ptr                      001042 automatic       pointer                  dcl 789 set ref 795* 796 797 811 815
whole_tuple_selected                   based           bit(1)                   array level 3 packed packed unaligned dcl 11-5 set
                                                                                  ref 267* 270 401

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DIFFERENCE                             internal static fixed bin(17,0)          initial dcl 13-26
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 18-43
IL_TYPE                                internal static char(14)                 initial packed unaligned dcl 10-53
INTERSECTION                           internal static fixed bin(1Multics                                                                                                                                   Mt                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Hopkins                                V*4$                                                        Hopkins                                 SiteSA                                                                                                                                   R,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     es                                    <>0.                                                        EJSharpe                        es      Multics                                                                                                                                                                                                              marty                                                                                                  Strakhovsky                     marty   Multics                                                                                                                                   LLbY:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 F    sv                                                                                                     Vasudevan                       sv      Multics                                                                                                                                                     internal dcl 819 ref 800
all_attributes                  000650 constant        entry                    external dcl 244
check_access                    003071 constant        entry                    internal dcl 573 ref 283 373
check_scope                     002412 constant        entry                    internal dcl 491 ref 221 482
compiled_clause                 000267 constant        entry                    external dcl 184
create_simple_vector            003744 constant        entry                    internal dcl 742 ref 711
end_free_scope_check            002656 constant        label                    dcl 532 ref 514 520 526
error                           003673 constant        entry                    internal dcl 718 ref 210 219 292 303 349 364 437 565
                                                                                  591 599
exit                            002411 constant        label                    dcl 1066 ref 738
finish                          002116 constant        entry                    external dcl 417
free_scope_check                000000 constant        label                    array(4) dcl 514 ref 513
make_move_lists                 003303 constant        entry                    internal dcl 631 ref 235 240 448 479
make_tuple_info                 003543 constant        entry                    internal dcl 692 ref 467 473 688
mrds_dsl_select_clause_         000251 constant        entry                    external dcl 16
one_attribute                   001345 constant        entry                    external dcl 325
pad                             004254 constant        entry                    internal dcl 917 ref 885 890 904
scope_error                     002706 constant        entry                    internal dcl 545 ref 518 524 531 534

NAME DECLARED BY CONTEXT OR IMPLICATION.
unspec                                                 builtin function         set ref 298 359*

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4574        4646    4312        4604
Length      5530    4312        52         646     261           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsl_select_clause_             805 external procedure  is an external procedure.  
check_scope                             internal procedure  shares stack frame of external procedure mrds_dsl_select_clause_.  
scope_error                             internal procedure  shares stack frame of external procedure mrds_dsl_select_clause_.  
check_access                            internal procedure  shares stack frame of external procedure mrds_dsl_select_clause_.  
add_free_rel                            internal procedure  shares stack frame of external procedure mrds_dsl_select_clause_.  
make_move_lists                         internal procedure  shares stack frame of external procedure mrds_dsl_select_clause_.  
make_tuple_info                         internal procedure  shares stack frame of external procedure mrds_dsl_select_clause_.  
error                                   internal procedure  shares stack frame of external procedure mrds_dsl_select_clause_.  
create_simple_vector                    internal procedure  shares stack frame of external procedure mrds_dsl_select_clause_.  
align_data_item                         internal procedure  shares stack frame of external procedure mrds_dsl_select_clause_.  
pad                                     internal procedure  shares stack frame of external procedure mrds_dsl_select_clause_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dsl_select_clause_  000100 select_list_ptr             mrds_dsl_select_clause_
                         000102 rmri_ptr                    mrds_dsl_select_clause_
                         000104 rai_ptr                     mrds_dsl_select_clause_
                         000106 ti_ntuples_init             mrds_dsl_select_clause_
                         000110 ml_ptr                      mrds_dsl_select_clause_
                         000112 ml_nitems_init              mrds_dsl_select_clause_
                         000114 rdi_ptr                     mrds_dsl_select_clause_
                         000116 range_ptr                   mrds_dsl_select_clause_
                         000120 num_dims                    mrds_dsl_select_clause_
                         000122 ss_ptr                      mrds_dsl_select_clause_
                         000124 scope_ptr                   mrds_dsl_select_clause_
                         000126 model_seg_ptr               mrds_dsl_select_clause_
                         000130 model_area_ptr              mrds_dsl_select_clause_
                         000132 select_area_struct_ptr      mrds_dsl_select_clause_
                         000134 select_area_ptr             mrds_dsl_select_clause_
                         000136 stv_number_of_dimensions    mrds_dsl_select_clause_
                         000140 ai_ptr                      mrds_dsl_select_clause_
                         000142 caller_name                 mrds_dsl_select_clause_
                         000152 check_sw                    mrds_dsl_select_clause_
                         000153 compiled_sw                 mrds_dsl_select_clause_
                         000154 continue                    mrds_dsl_select_clause_
                         000155 err_msg                     mrds_dsl_select_clause_
                         000255 err_msg_len                 mrds_dsl_select_clause_
                         000256 free_rel                    mrds_dsl_select_clause_
                         000257 i                           mrds_dsl_select_clause_
                         000260 info_ptr                    mrds_dsl_select_clause_
                         000262 k                           mrds_dsl_select_clause_
                         000263 return_value                mrds_dsl_select_clause_
                         000264 s_ptr                       mrds_dsl_select_clause_
                         000266 se_info_ptr                 mrds_dsl_select_clause_
                         000334 scope_type                  scope_error
                         000356 rel_index                   add_free_rel
                         000357 j                           add_free_rel
                         000370 i                           make_move_lists
                         000371 k                           make_move_lists
                         000372 var_init                    make_move_lists
                         000373 mli                         make_move_lists
                         000414 i                           make_tuple_info
                         000415 tii                         make_tuple_info
                         000434 attr_offset                 create_simple_vector
                         001034 block_size                  create_simple_vector
                         001036 data_string_ptr             create_simple_vector
                         001040 i                           create_simple_vector
                         001041 total_attr                  create_simple_vector
                         001042 vector_ptr                  create_simple_vector
                         001054 needed_bits                 align_data_item
                         001064 number_of_bits              pad

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mdfx1               ext_entry           op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$rsnnl                    mrds_dsl_set_user_vals        sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mdbm_error_$inc_attr_acc      mrds_data_$caller_compile     mrds_data_$caller_define_temp_rel
mrds_data_$caller_delete      mrds_data_$caller_modify      mrds_data_$caller_retrieve    mrds_data_$max_attributes
mrds_data_$max_id_len         mrds_data_$max_select_items   mrds_error_$block_dom_incons  mrds_error_$block_sel_incons
mrds_error_$max_select_items  mrds_error_$scope_viol        mrds_error_$undef_temp_rel




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 2   38 000224    6   65 000226    9   51 000227   12   20 000230   15   59 000231   16   13 000232   16   18 000233
17    6 000234   17   10 000235      1008 000236      1012 000241      1021 000243      1059 000245        16 000250
    184 000257       193 000314       194 000316       196 000323       197 000327       198 000331       199 000333
    201 000334       202 000336       203 000347       207 000351       210 000365       214 000441       216 000443
    219 000467       221 000524       223 000525       224 000534       225 000546       226 000561       227 000600
    228 000605       229 000615       231 000622       233 000626       235 000631       236 000632       238 000634
    239 000636       240 000637       242 000640       244 000641       252 000667       253 000673       254 000676
    255 000701       256 000705       257 000711       258 000757       260 000761       261 000767       263 000771
    265 000772       267 000775       270 001007       278 001040       281 001060       283 001071       288 001122
    290 001127       292 001156       296 001210       298 001212       300 001220       303 001230       312 001303
    315 001310       316 001312       318 001315       321 001332       323 001334       325 001335       334 001364
    335 001370       336 001373       337 001376       338 001407       340 001413       341 001421       343 001423
    345 001424       347 001431       349 001460       353 001512       358 001530       359 001531       361 001537
    364 001547       373 001611       377 001633       381 001644       386 001674       389 001704       390 001711
    391 001715       392 001721       395 001770       401 002015       412 002065       415 002105       417 002106
    422 002143       423 002147       424 002152       425 002156       427 002157       428 002165       431 002177
    433 002203       437 002234       441 002267       442 002277       444 002304       446 002310       448 002313
    449 002314       450 002316       467 002317       469 002325       472 002334       473 002340       474 002341
    476 002342       479 002364       482 002365       485 002372       487 002403       489 002410      1066 002411
    491 002412       503 002413       504 002423       505 002465       506 002473       507 002474       508 002507
    510 002554       512 002556       513 002560       514 002562       518 002575       520 002606       524 002621
    526 002632       531 002645       532 002656       534 002657       541 002703       543 002705       545 002706
    550 002710       553 002722       556 002732       559 002737       565 003034       571 003070       573 003071
    590 003073       591 003077       595 003140       596 003141       599 003143       605 003204       609 003205
    618 003207       620 003247       621 003250       622 003263       624 003271       625 003273       626 003275
    627 003277       629 003302       631 003303       641 003304       642 003311       643 003313       644 003322
    645 003331       646 003337       648 003341       650 003342       651 003351       653 003357       655 003361
    656 003363       657 003373       659 003424       660 003426       662 003436       663 003443       664 003446
    665 003457       666 003463       668 003464       669 003466       671 003471       672 003472       673 003503
    675 003516       676 003517       678 003526       680 003530       683 003533       685 003535       686 003537
    688 003541       690 003542       692 003543       699 003544       701 003552       702 003554       706 003566
    707 003567       708 003577       709 003640       710 003641       711 003651       713 003664       714 003670
    716 003672       718 003673       727 003711       729 003716       731 003721       732 003724       733 003731
    734 003732       735 003734       736 003741       738 003743       742 003744       793 003746       794 003751
    795 003752       796 003770       797 003773       798 004001       799 004002       800 004011       805 004034
    808 004052       809 004054       810 004065       811 004075       813 004106       815 004110       819 004114
    872 004116       874 004117       876 004124       879 004130       885 004147       887 004162       890 004163
    904 004225       915 004250       917 004254       924 004256       928 004265       932 004270


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
