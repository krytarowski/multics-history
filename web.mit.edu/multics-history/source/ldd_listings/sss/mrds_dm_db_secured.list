	COMPILATION LISTING OF SEGMENT mrds_dm_db_secured
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 03/08/88  1534.2 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-01-18,Blair), approve(88-02-26,MCR7840), audit(88-03-03,Dupuis),
       16*     install(88-03-08,MR12.2-1034):
       17*     Add code to use the mrds search list.  SCP 6366.
       18*  2) change(88-02-25,Blair), approve(88-02-25,MCR7840), audit(88-03-03,Dupuis),
       19*     install(88-03-08,MR12.2-1034):
       20*     Create a local area for use by search_paths_$get.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 mrds_dm_db_secured: procedure (); return;		/* not a legal entry */
       25 
       26 /*
       27*                   BEGIN_DESCRIPTION
       28*   This routine has three entries that will either return the  state
       29*   of  or  turn  the  secured  bit in the database model on/off. The
       30*   entries   are   names   set_db_secured,   reset_db_secured,   and
       31*   get_secured_status.  Changing the state requires that the user be
       32*   a DBA. This secured bit interface will only work  for  version  4
       33*   databases.  The  data  model  must  have been opened by a call to
       34*   dmd_$open_dm.
       35*                   END_DESCRIPTION
       36**/
       37 
       38 /* PARAMETERS:
       39*   data_model_ptr - - (input) pointer, the  pointer  the  data  base
       40*   model  returned  from  a  call  to  dmd_$open_dm  for  the  given
       41*   database. (all entries but get_secured_state)
       42*
       43*   rel_db_path - - (input) char(*), the  relative  pathname  of  the
       44*   database whose secured state is to be determined, with or without
       45*   the suffix. This is for the get_secure_state entry only.
       46*
       47*   area_ptr - - (input) pointer,  for  the  get  entry  only,  to  a
       48*   freeing  area  of  at least 20 words, in which the database_state
       49*   structure is to be allocated.
       50*
       51*   structure_version - - (input) fixed bin, for the get entry  only,
       52*   the desired version of the structure. Normaly, the version number
       53*   given in the include file.
       54*
       55*   database_state_ptr - - (output) pointer, for the get entry  only,
       56*   a  pointer  to the mrds_database_state.incl.pl1 defined structure
       57*   that has been allocated in the area supplied  by  the  user,  and
       58*   with  the  requested  version.  this  routine  will  fill  in the
       59*   database state parameters in the structure.
       60*
       61*   error_code - - (output) fixed bin(35), the error status encoding,
       62*   0 unless an error occurred.  */
       63 
       64 /* HISTORY:
       65*
       66*   Originally written by Jim Gray - - November 1980
       67*
       68*   81-01-20 Jim Gray : changed from mrds_dm_set_db_secured, with two
       69*   set/reset  entries,  into  mrds_dm_db_secured,  with  a third get
       70*   entry, replacing mrds_dm_get_secured_status.  The  get  interface
       71*   was  extended  from 1 bit, to an extensible structure. Calls were
       72*   added to the new authorization (DBA) handling  routines,  instead
       73*   of handling this logic internally.
       74*
       75*   81-04-20 Jim Gray : added entry for  mmi_$get_secured_state  that
       76*   uses  a db_path rether than a db_model pointer. Also added use of
       77*   mrds_dm_check_path,  and  use   of   hcs_$status_   rather   than
       78*   hcs_$get_user_effmode.
       79*
       80*   83-02-24 Davids: explicitly declared variables that were declared by
       81*   context or implication. Deleted declarations to variables that were
       82*   never referenced.
       83**/
       84 
       85 /* entry to set secured bit on */
       86 
       87 set_db_secured: entry (data_model_ptr, error_code);
       88 
       89 	dbm_ptr = data_model_ptr;
       90 	secure_bit = "1"b;
       91 	set_operation = "1"b;
       92 
       93 	call common ();
       94 
       95 	return;
       96 
       97 
       98 /* entry to turn the secured bit off */
       99 
      100 reset_db_secured: entry (data_model_ptr, error_code);
      101 
      102 	dbm_ptr = data_model_ptr;
      103 	secure_bit = "0"b;
      104 	set_operation = "1"b;
      105 
      106 	call common ();
      107 
      108 	return;
      109 
      110 /* entry to get database secured state info */
      111 
      112 get_secured_status: entry (data_model_ptr, area_ptr, structure_version, database_state_ptr, error_code);
      113 
      114 	dbm_ptr = data_model_ptr;
      115 	set_operation = "0"b;
      116 	database_state_ptr = null ();
      117 
      118 	call common ();
      119 
      120 	return;
      121 
      122 
      123 /* entry to get secured db state, using path rather than model ptr */
      124 
      125 get_secured_state: entry (rel_db_path, area_ptr, structure_version, database_state_ptr, error_code);
      126 
      127 dcl gs_local_area area (2048);
      128 
      129 	database_state_ptr = null ();			/* init */
      130 	use_search_paths = "0"b;
      131 	if search (rel_db_path, "<>") = 0 then do;
      132 	     call search_paths_$get (MRDS_SEARCHLIST, sl_control_default, "", null (), addr(gs_local_area), sl_info_version_1, mrds_search_list_ptr, error_code);
      133 	     if error_code ^= 0 then return;
      134 	     loop_idx = mrds_search_list_ptr -> sl_info.num_paths;
      135 	     use_search_paths = "1"b;
      136 	     end;
      137 	else do;
      138 	     call absolute_pathname_ (rel_db_path, abs_path, error_code);
      139 	     if error_code ^= 0 then return;
      140 	     loop_idx = 1;
      141 	     end;
      142 	error_code = 1;
      143 	do idx = 1 to loop_idx while (error_code ^= 0);
      144 	     if use_search_paths then abs_path = pathname_ (mrds_search_list_ptr -> sl_info.paths(idx).pathname, rel_db_path);
      145 	     call mrds_dm_check_path (abs_path, containing_dir, db_dir, new_found, error_code);
      146 	     if error_code = error_table_$incorrect_access then
      147 		error_code = 0;			/* ignore access problems for right now,
      148*		     may need to set acl's for a DBA */
      149 	     end;                                              /* end do */
      150 	if error_code = 0 then do;
      151 		if ^new_found then
      152 		     error_code = mrds_error_$version_not_supported;
      153 		else do;
      154 
      155 			db_path = rtrim (containing_dir) || ">" || db_dir;
      156 			dbm_ptr = null ();
      157 
      158 			set_operation = "0"b;
      159 
      160 			call common ();
      161 
      162 		     end;
      163 	     end;
      164 
      165 	return;
      166 
      167 common: procedure ();
      168 
      169 /* initialize */
      170 
      171 	error_code = 0;
      172 
      173 /* check for a valid pointer to a version 4 database model */
      174 
      175 	if dbm_ptr = null () & ^set_operation then
      176 	     model_name = "db_model";			/* get_secured_state entry */
      177 	else call hcs_$fs_get_path_name (dbm_ptr, db_path, ldn, model_name, error_code);
      178 	if error_code ^= 0 then ;
      179 	else if model_name ^= "db_model" then
      180 	     error_code = mrds_error_$version_not_supported;
      181 	else do;
      182 
      183 /* determine action based on entry called */
      184 
      185 		if set_operation then
      186 		     call change_secured_state ();
      187 		else call get_secured_info ();
      188 
      189 	     end;
      190 
      191      end;
      192 
      193 change_secured_state: procedure ();
      194 
      195 /* check for correct access by DBA type, to set secured bit */
      196 
      197 	call check_access ();			/* this will fail if user not dba */
      198 	if error_code ^= 0 then ;
      199 	else do;
      200 
      201 
      202 /* change the secured bit in an indivisible operation */
      203 
      204 		secure_word_ptr = addr (dbm_ptr -> db_model.consistant);
      205 		old_secure_word = secure_word;
      206 		unspec (new_secure_word) = secure_word;
      207 		new_secure_word.mdbm_secured = secure_bit;
      208 
      209 		changed = "0"b;
      210 		do while (^changed);
      211 
      212 		     changed = stacq (unspec (secure_word),
      213 			unspec (new_secure_word), unspec (old_secure_word));
      214 
      215 		end;
      216 
      217 	     end;
      218 
      219      end;
      220 
      221 check_access: procedure ();
      222 
      223 /* check for correct access by DBA type, to set secured bit */
      224 
      225 	DBA, set_ok, read_ok, unspec (my_status_branch) = "0"b; /* init */
      226 
      227 /* check for access on the db_model segment */
      228 
      229 	call hcs_$status_ (rtrim (db_path), rtrim (model_name), dont_chase_links,
      230 	     addr (my_status_branch), addr (local_area), error_code);
      231 
      232 	if error_code = 0 | error_code = error_table_$incorrect_access |
      233 	     error_code = error_table_$no_s_permission then do;
      234 
      235 		error_code = 0;
      236 
      237 		access_mode_overlay_ptr = addr (my_status_branch.mode);
      238 
      239 		if access_mode_overlay.read & access_mode_overlay.write then
      240 		     set_ok = "1"b;
      241 		if access_mode_overlay.read then
      242 		     read_ok = "1"b;
      243 
      244 /* find out if the user is a DBA */
      245 
      246 		call mrds_dm_authorization$get_user_class (rtrim (db_path), addr (local_area),
      247 		     mrds_authorization_structure_version, mrds_authorization_ptr, error_code);
      248 		if error_code = 0 then
      249 		     DBA = mrds_authorization.administrator;
      250 
      251 	     end;
      252 
      253 /* if an access violation occured, try to set access for the user.
      254*   This will fail if the user is not a DBA. */
      255 
      256 	if error_code = 0 then do;
      257 		if DBA then do;
      258 			if ((set_operation & ^set_ok) | (^set_operation & ^read_ok)) then
      259 			     call mrds_dm_authorization$set_needed_access (rtrim (db_path), error_code);
      260 		     end;
      261 		else do;				/* non-DBA */
      262 			if set_operation then
      263 			     error_code = error_table_$insufficient_access;
      264 			else if ^read_ok then /* no set operation */
      265 			     error_code = mrds_error_$no_model_access;
      266 		     end;
      267 
      268 	     end;
      269 
      270      end;
      271 
      272 get_secured_info: procedure ();
      273 
      274 /* set access for a DBA if needed */
      275 
      276 	call check_access ();
      277 	if error_code = 0 then do;
      278 
      279 /* we may need to get the model pointer for the get_secured_state entry */
      280 
      281 		if dbm_ptr = null () then
      282 		     call hcs_$initiate (rtrim (db_path), "db_model", "",
      283 			0, 1, dbm_ptr, error_code);
      284 		if dbm_ptr ^= null () then do;
      285 
      286 			error_code = 0;
      287 
      288 /* check on input parameters for correctness */
      289 
      290 			if area_ptr = null () then
      291 			     error_code = error_table_$badcall;
      292 			else do;
      293 
      294 				unspec (my_area_info) = "0"b;
      295 				my_area_info.version = 1;
      296 				my_area_info.areap = area_ptr;
      297 
      298 				call area_info_ (addr (my_area_info), error_code);
      299 				if error_code ^= 0 then ; /* couldn't get area info */
      300 				else if my_area_info.no_freeing then
      301 				     error_code = mrds_error_$not_freeing_area;
      302 				else do;
      303 
      304 					if structure_version ^= mrds_authorization_structure_version then
      305 					     error_code = error_table_$unimplemented_version;
      306 					else do;
      307 
      308 /* set up for too small an area given */
      309 
      310 						on area begin;
      311 							error_code = error_table_$area_too_small;
      312 							goto skip_allocate;
      313 						     end;
      314 
      315 						allocate database_state set (database_state_ptr) in (work_area);
      316 						revert area;
      317 						unspec (database_state) = "0"b; /* init */
      318 
      319 /* fill in the structure info details */
      320 
      321 						database_state.version = database_state_structure_version;
      322 						database_state.secured = db_model.mdbm_secured;
      323 						database_state.unsecured = ^(database_state.secured);
      324 						database_state.mbz = "0"b;
      325 
      326 skip_allocate:
      327 					     end;
      328 				     end;
      329 			     end;
      330 		     end;
      331 	     end;
      332      end;
      333 
      334 	declare DBA		 bit (1);		/* on => user is a DBA */
      335           declare MRDS_SEARCHLIST        char (4) int static options (constant) init ("mrds");
      336           declare abs_path               char (168);
      337           declare absolute_pathname_     entry (char(*), char(*), fixed bin(35));
      338 	declare access_mode_overlay_ptr ptr;		/* points to mode bits */
      339 	declare area		 condition;	/* not enough space left */
      340 	declare area_info_		 entry (ptr, fixed bin (35)); /* gets area specs */
      341 	declare area_ptr		 ptr;		/* pointer to area for allocation of structure */
      342 	declare changed		 bit (1);		/* on => change successfull */
      343 	declare containing_dir	 char (168);	/* containing directory of database */
      344 	declare data_model_ptr	 ptr;		/* pointer to database model */
      345 	declare db_dir		 char (32);	/* directory name of database */
      346 	declare db_path		 char (168);	/* pathname of database */
      347 	declare dont_chase_links	 fixed bin (1) init (0); /* dont follow links */
      348 	declare error_code		 fixed bin (35);	/* error status encoding */
      349 	declare error_table_$area_too_small fixed bin (35) ext; /* can't allocate structure */
      350 	declare error_table_$badcall	 fixed bin (35) ext;/* null area ptr */
      351 	declare error_table_$incorrect_access fixed bin (35) ext; /* no acl on dir or object */
      352 	declare error_table_$insufficient_access fixed bin (35) ext; /* not sma on db_dir or rw on db_model */
      353 	declare error_table_$no_s_permission fixed bin (35) ext; /* no "s" on containing dir */
      354 	declare error_table_$unimplemented_version fixed bin (35) ext; /* bad structure version */
      355 	declare hcs_$fs_get_path_name	 entry (ptr, char (*), fixed bin, char (*), fixed bin (35)); /* gets path from pointer */
      356 	declare hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2),
      357 				 ptr, fixed bin (35)); /* gets ptr to seg */
      358 	declare hcs_$status_	 entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35)); /* gets access modes */
      359           declare idx                    fixed bin;         /* index to search path loop */
      360           declare loop_idx               fixed bin;         /* number of entries in search list */
      361 	declare ldn		 fixed bin;	/* length of db dir name */
      362 	declare local_area		 area (2048);	/* temp space for authorization structure */
      363 	declare model_name		 char (32);	/* name of database model */
      364 	declare mrds_dm_authorization$get_user_class entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* detects DBA's */
      365 	declare mrds_dm_authorization$set_needed_access entry (char (*), fixed bin (35)); /* sets all access DBA needs */
      366 	declare mrds_dm_check_path	 entry (char (*), char (168), char (32), bit (1), fixed bin (35)); /* check for path to db */
      367 	declare mrds_error_$no_model_access fixed bin (35) ext; /* no "r" to db_model */
      368 	declare mrds_error_$not_freeing_area fixed bin (35) ext; /* no freeing attr for area */
      369 	declare mrds_error_$version_not_supported fixed bin (35) ext; /* not version 4 database */
      370           declare mrds_search_list_ptr   pointer;
      371 	declare new_found		 bit (1);		/* on => new version db arch */
      372 	declare old_secure_word	 bit (36);	/* value before change is made */
      373           declare pathname_              entry (char(*), char(*)) returns(char(168));
      374 	declare read_ok		 bit (1);		/* on => user has access to read state */
      375 	declare rel_db_path		 char (*);	/* relative database path */
      376           declare search                 builtin;
      377           declare search_paths_$get      entry (char(*), bit(36), char(*), ptr, ptr, fixed bin, ptr, fixed bin(35));
      378 	declare secure_bit		 bit (1);		/* on => secured */
      379 	declare secure_word		 bit (36) aligned based (secure_word_ptr); /* bits to be change in model */
      380 	declare secure_word_ptr	 ptr;		/* points to proper spot in model */
      381 	declare set_ok		 bit (1);		/* on => user has access to write state */
      382 	declare set_operation	 bit (1);		/* on => set or reset to be done */
      383 	declare structure_version	 fixed bin;	/* desired version of output structure */
      384 	declare sys_info$max_seg_size	 fixed bin (35) ext;/* largest segment */
      385           declare use_search_paths        bit (1);
      386 	declare work_area		 area (sys_info$max_seg_size) based (area_ptr); /* overlay for users area */
      387 	declare (addr, empty, fixed, null, rel, rtrim, stacq, unspec) builtin;
      388 	declare 1 access_mode_overlay	 unal based (access_mode_overlay_ptr), /* overlay for mode bits */
      389 		2 pad1		 bit (1) unal,
      390 		2 read		 bit (1) unal,
      391 		2 exec		 bit (1) unal,
      392 		2 write		 bit (1) unal,
      393 		2 pad2		 bit (1) unal;
      394 	declare 1 my_area_info	 like area_info;	/* local copy */
      395 	declare 1 my_status_branch	 like status_branch;/* local copy */
      396 	declare 1 new_secure_word	 aligned,		/* overlay for portion of db_model with secured bit */
      397 		2 consistent	 bit (1) unal,
      398 		2 mdbm_secured	 bit (1) unal,
      399 		2 reserved	 bit (34) unal;
      400 
  1     1 /* BEGIN INCLUDE FILE mrds_database_state.incl.pl1 - - 81-01-20 Jim Gray */
  1     2 
  1     3 /* HISTORY:
  1     4*
  1     5*   81-01-20 Jim Gray : original created for the mmi_$get_secured_status interface
  1     6*
  1     7**/
  1     8 
  1     9 /* DESCRIPTION:
  1    10*
  1    11*   This structure returns the database state (secured or unsecured)
  1    12*   for determining how commands and subroutines will behave for each case.
  1    13*   The secured bit was kept separate from the unsecured,
  1    14*   rather than it's logical "not", to allow for future extensibility
  1    15*   of database secured states.
  1    16*
  1    17**/
  1    18 
  1    19 
  1    20 declare 1 database_state aligned based (database_state_ptr),
  1    21         2 version fixed bin,				/* version number of this structure */
  1    22         2 unsecured bit (1) unal,			/* database not secured */
  1    23         2 secured bit (1) unal,			/* database has been secured */
  1    24         2 mbz bit (34) unal ;
  1    25 
  1    26 
  1    27 declare  database_state_ptr ptr ;			/* pointer for referring to the structure */
  1    28 
  1    29 declare  database_state_structure_version fixed bin init (1) int static options (constant) ;
  1    30 
  1    31 /* END INCLUDE FILE mrds_database_state.incl.pl1 */
      401 
      402 
  2     1 /* BEGIN INCLUDE FILE . . . sl_control_s.incl.pl1 */
  2     2 
  2     3      declare 1 sl_control_s	      unaligned based (addr (sl_control)),
  2     4 	     2 af_pathname	      bit (1),		/* "1"b => expand active functions */
  2     5 	     2 pad1	      bit (1),		/* Must be zero */
  2     6 	     2 key_ref_dir	      bit (1),		/* "1"b => expand -referencing_dir keyword */
  2     7 	     2 key_work_dir	      bit (1),		/* "1"b => expand -working_dir keyword */
  2     8 	     2 key_proc_dir	      bit (1),		/* "1"b => expand -process_dir keyword */
  2     9 	     2 key_home_dir	      bit (1),		/* "1"b => expand -home_dir keyword */
  2    10 	     2 pad2	      bit (30);		/* Must be zero */
  2    11 
  2    12      declare sl_control	      bit (36);
  2    13      declare sl_control_default     bit (36) internal static options (constant) initial ("101111"b);
  2    14 
  2    15 /* END INCLUDE FILE . . . sl_control_s.incl.pl1 */
      403 
      404 
  3     1 /* BEGIN INCLUDE FILE . . . sl_info.incl.pl1 */
  3     2 
  3     3      
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(87-11-16,Lippard), approve(87-12-21,MCR7822),
  3     7*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
  3     8*     Modified to add INITIATED_SEGS type.
  3     9*  2) change(87-11-19,Lippard), approve(87-12-21,MCR7822),
  3    10*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
  3    11*     Added uid to sl_info structure.
  3    12*                                                   END HISTORY COMMENTS */
  3    13 
  3    14 
  3    15 declare 1 sl_info	      aligned based (sl_info_p),
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 num_paths	      fixed binary,		/* Number of search paths */
  3    18 	     2 change_index_p     pointer,		/* Pointer to search list's update count */
  3    19 	     2 change_index	      fixed binary (71),	/* This search list's update count */
  3    20 	     2 pad1	      (6) bit (36),		/* Must be zero */
  3    21 	     2 paths	      (sl_info_num_paths refer (sl_info.num_paths)),
  3    22 	       3 type	      fixed binary,		/* Type of search path */
  3    23 	       3 code	      fixed binary (35),	/* Standard status code of search path */
  3    24 	       3 uid	      bit (36),		/* Unique ID */
  3    25 	       3 pathname	      char (168) unaligned;	/* Search pathname */
  3    26 
  3    27      declare sl_info_num_paths      fixed binary;
  3    28      declare sl_info_p	      pointer;
  3    29      declare sl_info_version_1      fixed binary internal static options (constant) initial (1);
  3    30 
  3    31 /* Keyword Types */
  3    32 
  3    33      declare ABSOLUTE_PATH	      fixed binary internal static options (constant) initial (0);
  3    34      declare UNEXPANDED_PATH	      fixed binary internal static options (constant) initial (1);
  3    35      declare REFERENCING_DIR	      fixed binary internal static options (constant) initial (3);
  3    36      declare WORKING_DIR	      fixed binary internal static options (constant) initial (4);
  3    37      declare PROCESS_DIR	      fixed binary internal static options (constant) initial (5);
  3    38      declare HOME_DIR	      fixed binary internal static options (constant) initial (6);
  3    39      declare INITIATED_SEGS	      fixed binary internal static options (constant) initial (7);
  3    40 
  3    41 /* END INCLUDE FILE . . . sl_info.incl.pl1 */
      405 
  4     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  4     2 
  4     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  4     4 
  4     5 /* This include file contains branch and link structures returned by
  4     6*   hcs_$status_ and hcs_$status_long. */
  4     7 
  4     8 dcl 1 status_branch aligned based (status_ptr),
  4     9     2 short aligned,
  4    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  4    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  4    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  4    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  4    14       3 dtu bit (36) unaligned,			/* date/time last used */
  4    15       3 mode bit (5) unaligned,			/* caller's effective access */
  4    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  4    17       3 pad1 bit (8) unaligned,
  4    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  4    19 
  4    20 /* Limit of information returned by hcs_$status_ */
  4    21 
  4    22     2 long aligned,
  4    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  4    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  4    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  4    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  4    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  4    28       3 pad2 bit (8) unaligned,
  4    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  4    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  4    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  4    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  4    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  4    34       3 pad3 bit (5) unaligned,
  4    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  4    36       3 uid bit (36) unaligned;			/* unique ID */
  4    37 
  4    38 dcl 1 status_link aligned based (status_ptr),
  4    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  4    40     2 nnames fixed bin (16) unaligned unsigned,
  4    41     2 names_relp bit (18) unaligned,
  4    42     2 dtem bit (36) unaligned,
  4    43     2 dtd bit (36) unaligned,
  4    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  4    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  4    46 
  4    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  4    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  4    49 						/* array of names returned */
  4    50      status_pathname character (status_link.pathname_length) aligned
  4    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  4    52 						/* link target path */
  4    53      status_area_ptr pointer,
  4    54      status_ptr pointer;
  4    55 
  4    56 dcl (Link initial (0),
  4    57      Segment initial (1),
  4    58      Directory initial (2)) fixed bin internal static options (constant);
  4    59 						/* values for type fields declared above */
  4    60 
  4    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      406 
      407 
  5     1 /* BEGIN INCLUDE FILE mrds_authorization.incl.pl1 - - 81-01-20 Jim Gray */
  5     2 
  5     3 /* HISTORY:
  5     4*
  5     5*   81-01-20 Jim Gray : original created for the mmi_$get_authorization interface
  5     6*
  5     7**/
  5     8 
  5     9 /* DESCRIPTION:
  5    10*
  5    11*   this structure returns the callers user_class
  5    12*   either database administrator or normal user.
  5    13*   Note that these separate classes were used to allow
  5    14*   future expansion to the user classes, rather than
  5    15*   make them logical "not"'s of one another.
  5    16*   NOTE: a DBA is always also a normal user, thus if the caller
  5    17*   is a DBA, his normal_user bit will be on also.
  5    18*
  5    19**/
  5    20 
  5    21 
  5    22 declare 1 mrds_authorization aligned based (mrds_authorization_ptr),
  5    23         2 version fixed bin,				/* version number of this structure */
  5    24         2 administrator bit (1) unal,			/* caller is a DBA */
  5    25         2 normal_user bit (1) unal,			/* caller has no special priviledges */
  5    26         2 mbz bit (34) unal ;
  5    27 
  5    28 
  5    29 declare  mrds_authorization_ptr ptr ;			/* pointer for referring to the structure */
  5    30 
  5    31 declare  mrds_authorization_structure_version fixed bin init (1) int static options (constant) ;
  5    32 
  5    33 /* END INCLUDE FILE mrds_authorization.incl.pl1 */
      408 
      409 
  6     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  6     2 
  6     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  6     4 
  6     5 dcl  area_infop ptr;
  6     6 
  6     7 dcl 1 area_info aligned based (area_infop),
  6     8     2 version fixed bin,				/* version number for this structure is 1 */
  6     9     2 control aligned like area_control,		/* control bits for the area */
  6    10     2 owner char (32) unal,				/* creator of the area */
  6    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  6    12     2 size fixed bin (18),				/* size of the area in words */
  6    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  6    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  6    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  6    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  6    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  6    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  6    19 
  6    20 dcl 1 area_control aligned based,
  6    21     2 extend bit (1) unal,				/* says area is extensible */
  6    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  6    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  6    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  6    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  6    26     2 system bit (1) unal,				/* says area is managed by system */
  6    27     2 pad bit (30) unal;
  6    28 
  6    29 /* END INCLUDE FILE area_info.incl.pl1 */
      410 
      411 
  7     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  7     6*     modified to save space occupied by model
  7     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  7     8*     to add mdbm_secured bit in db_model
  7     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  7    10*     collapsed the following into an unused_offset array:
  7    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  7    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  7    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  7    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  7    15*       unused_1
  7    16*     Also changed the name of unused_2 to restructuring_history_offset
  7    17*     and changed the comment on the changer structure to indicate
  7    18*     that it will contain on database creation information.
  7    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  7    20*     used one of the unused_offsets to point to a message which indicates
  7    21*     why the db is inconsistent. The offset will be null when the db is created
  7    22*     and set the first time the message is used. this is so it will be
  7    23*     consistent with existing data bases. Also added the message structure.
  7    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  7    25*     added the undo_request element to the message structure
  7    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  7    27*     changed unused_offset (12) to last_restructruring_history_offset and
  7    28*     changed restructuring_history_offset to first_restructuring_history_offset
  7    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  7    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  7    31*     1 => vfile database and 2 => page_file database. Up to this point all
  7    32*     database types were equal to 1.
  7    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  7    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  7    35*     flags. This will allow information about transactions and dm_file
  7    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  7    37*     change is compatable with all datamodels created by the released version
  7    38*     of mrds.
  7    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  7    40*     added the rollback_on flag to the db_type_flags since it appears that you
  7    41*     can have a dmfile database that requires transactions but does not have any
  7    42*     journalizing. Also switched the order of the transactions_needed and
  7    43*     concurrency_on flags - this makes the change compatable with existing
  7    44*     dmfile databases except when displaying the model since concurrency_on and
  7    45*     rollback_on will be off in the model even though the dmfile relations had
  7    46*     them on during creation.
  7    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  7    48*      Removed ctl_file_path_ptr.
  7    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  7    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  7    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  7    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  7    53*      in the flag word for rmdb copying.
  7    54*                                                   END HISTORY COMMENTS */
  7    55 
  7    56 
  7    57 /* this include file contains the structures that go into the make up
  7    58*   of the "db_model" segment in the model for the database.
  7    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  7    60*
  7    61*   the db_model structure goes at the base of the segment, and contains items unique to
  7    62*   the whole databse. in addition, it has an area of size to fill the
  7    63*   rest of a segment, that holds the lists of files and domains in the database.
  7    64*   these lists are singly forward linked lists. all "pointers" in the database model
  7    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  7    66*   since actual pointers are process dependent on segment number.
  7    67*   the remaining structures are first a path_entry one to save pathnames in,
  7    68*   and the stack_item and constent structures, used to save a boolean
  7    69*   expression in polish form, with the stack represented by a linked list.
  7    70*   the final structure is one for identifying the status of version information */
  7    71 
  7    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  7    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  7    74 	     2 db_type_flags      unal,
  7    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  7    76 	       3 unused	      (13) bit (1) unal,
  7    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  7    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  7    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  7    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  7    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  7    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  7    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  7    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  7    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  7    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  7    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  7    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  7    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  7    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  7    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  7    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  7    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  7    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  7    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  7    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  7    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  7    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  7    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  7   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  7   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  7   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  7   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  7   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  7   105 
  7   106      dcl	   dbm_ptr	      ptr;
  7   107 
  7   108 /* the files in the database each have a file_info containing
  7   109*   their name, the file_model for each file is found by initiating the
  7   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  7   111*   the file_info list is a singly linked list in definition order */
  7   112 
  7   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  7   114 	     2 file_name	      char (30),		/* name of file */
  7   115 	     2 file_id	      bit (36),		/* id number of file */
  7   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  7   117 	     2 unused	      unal bit (18);	/* for future expansion */
  7   118 
  7   119      dcl	   fi_ptr		      ptr;
  7   120 
  7   121 /* each domain used in the database will have a domain info saved in the db_model
  7   122*   segment. it describes the domain of the given name, and it's options.
  7   123*   the domain_info's form a singly linked list in definition order */
  7   124 
  7   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  7   126 	     2 name	      char (32),		/* name of domain */
  7   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  7   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  7   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  7   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  7   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  7   132 	     2 reserved	      bit (31) unal,
  7   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  7   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  7   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  7   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  7   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  7   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  7   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  7   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  7   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  7   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  7   143 	     2 str_err_path_ptr   unal bit (18),
  7   144 	     2 str_after_path_ptr unal bit (18),
  7   145 	     2 get_before_path_ptr unal bit (18),
  7   146 	     2 get_err_path_ptr   unal bit (18),
  7   147 	     2 get_after_path_ptr unal bit (18),
  7   148 	     2 mod_before_path_ptr unal bit (18),
  7   149 	     2 mod_err_path_ptr   unal bit (18),
  7   150 	     2 mod_after_path_ptr unal bit (18),
  7   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  7   152 	     2 unused_2	      unal bit (18),
  7   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  7   154 
  7   155      dcl	   di_ptr		      ptr;
  7   156 
  7   157 /* information necessary for attributes that are not used in any relation */
  7   158 
  7   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  7   160 	     2 name char (32),			/* name of attribute */
  7   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  7   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  7   163 	     2 unused (2) bit (18) unal;
  7   164 
  7   165      dcl     ua_ptr ptr;
  7   166 
  7   167 
  7   168 /* space saving pathname$entryname structure, to be allocated
  7   169*   only when a path$entry has to be saved, else only a bit(18)
  7   170*   offset takes up space in the main model structure */
  7   171 
  7   172      declare 1 path_entry	      based (path_entry_ptr),
  7   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  7   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  7   175 	     2 reserved	      unal bit (36);	/* for future use */
  7   176 
  7   177      declare path_entry_ptr	      ptr;
  7   178 
  7   179 
  7   180 
  7   181 
  7   182 
  7   183 /* declarations for model of postfix stack holding the check option boolean expression
  7   184*   the following encoding values indicate the corresponding type of stack element
  7   185*
  7   186*   1  =
  7   187*   2  ^=
  7   188*   3  >
  7   189*   4  <
  7   190*   5  >=
  7   191*   6  <=
  7   192*
  7   193*   10  and
  7   194*   20  or
  7   195*   30  not
  7   196*
  7   197*   40  - (minus)
  7   198*
  7   199*   50  domain variable(same name as domain)
  7   200*
  7   201*   60  constant(number, bit string, or character string)
  7   202*
  7   203**/
  7   204 
  7   205 
  7   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  7   207 	     2 next	      bit (18),		/* link to next in list */
  7   208 	     2 type	      fixed binary,		/* code for this element type */
  7   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  7   210*						   if this is a constant element type */
  7   211 
  7   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  7   213 
  7   214 
  7   215 
  7   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  7   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  7   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  7   219 
  7   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  7   221 
  7   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  7   223 
  7   224 /* version structure, giving status of source for CMDB/RMDB,
  7   225*   status of model, and status of resultant */
  7   226 
  7   227 /* version number is in form MM.N.Y
  7   228*   where MM is the major version number, N is the minor version alteration,
  7   229*   and Y is the lastest modification to that alteration,
  7   230*   where M and N represent numbers 0-9, and Y is a letter */
  7   231 
  7   232      declare 1 version_status	      unal based (version_status_ptr),
  7   233 	     2 cmdb_rmdb,
  7   234 	       3 major	      fixed bin,
  7   235 	       3 minor	      fixed bin,
  7   236 	       3 modification     char (4),
  7   237 	     2 model,
  7   238 	       3 major	      fixed bin,
  7   239 	       3 minor	      fixed bin,
  7   240 	       3 modification     char (4),
  7   241 	     2 resultant,
  7   242 	       3 major	      fixed bin,
  7   243 	       3 minor	      fixed bin,
  7   244 	       3 modification     char (4);
  7   245 
  7   246      declare version_status_ptr     ptr;
  7   247 
  7   248 
  7   249 /* maintains information only about the db creation */
  7   250 
  7   251      declare 1 changer	      unal based (changer_ptr),
  7   252 	     2 id		      char (32),
  7   253 	     2 time	      fixed bin (71),
  7   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  7   255 
  7   256      declare changer_ptr	      ptr;
  7   257 
  7   258 
  7   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  7   260 	     02 len	      fixed bin,		/* length of the message */
  7   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  7   262 	     02 name	      char (32),		/* name of thing that set the message */
  7   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  7   264*                                                               that caused the database to become inconsistent */
  7   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  7   266 
  7   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  7   268 
  7   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  7   270 
  7   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  7   272 
  7   273 
      412 
      413 
      414 
      415      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/08/88  1531.6  mrds_dm_db_secured.pl1            >spec>install>1034>mrds_dm_db_secured.pl1
401          1    10/14/83  1608.8  mrds_database_state.incl.pl1      >ldd>include>mrds_database_state.incl.pl1
403          2    01/09/79  1617.9  sl_control_s.incl.pl1             >ldd>include>sl_control_s.incl.pl1
405          3    02/18/88  2023.8  sl_info.incl.pl1                  >ldd>include>sl_info.incl.pl1
406          4    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
408          5    10/14/83  1608.8  mrds_authorization.incl.pl1       >ldd>include>mrds_authorization.incl.pl1
410          6    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
412          7    10/17/86  1404.3  mdbm_db_model.incl.pl1            >ldd>include>mdbm_db_model.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DBA                             004100 automatic       bit(1)                   packed unaligned dcl 334 set ref 225* 248* 257
MRDS_SEARCHLIST                 000001 constant        char(4)                  initial packed unaligned dcl 335 set ref 132*
abs_path                        004101 automatic       char(168)                packed unaligned dcl 336 set ref 138* 144* 145*
absolute_pathname_              000010 constant        entry                    external dcl 337 ref 138
access_mode_overlay                    based           structure                level 1 packed packed unaligned dcl 388
access_mode_overlay_ptr         004154 automatic       pointer                  dcl 338 set ref 237* 239 239 241
addr                                                   builtin function         dcl 387 ref 132 132 204 229 229 229 229 237 246 246
                                                                                  298 298
administrator             1            based           bit(1)                   level 2 packed packed unaligned dcl 5-22 ref 248
area                            000000 stack reference condition                dcl 339 ref 310 316
area_control                           based           structure                level 1 dcl 6-20
area_info                              based           structure                level 1 dcl 6-7
area_info_                      000012 constant        entry                    external dcl 340 ref 298
area_ptr                               parameter       pointer                  dcl 341 ref 112 125 290 296 315
areap                    16     010344 automatic       pointer                  level 2 dcl 394 set ref 296*
changed                         004156 automatic       bit(1)                   packed unaligned dcl 342 set ref 209* 210 212*
consistant               11            based           bit(1)                   level 2 packed packed unaligned dcl 7-72 set ref 204
containing_dir                  004157 automatic       char(168)                packed unaligned dcl 343 set ref 145* 155
control                   1     010344 automatic       structure                level 2 dcl 394
data_model_ptr                         parameter       pointer                  dcl 344 ref 87 89 100 102 112 114
database_state                         based           structure                level 1 dcl 1-20 set ref 315 317*
database_state_ptr                     parameter       pointer                  dcl 1-27 set ref 112 116* 125 129* 315* 317 321 322
                                                                                  323 323 324
database_state_structure_version       constant        fixed bin(17,0)          initial dcl 1-29 ref 321
db_dir                          004231 automatic       char(32)                 packed unaligned dcl 345 set ref 145* 155
db_model                               based           structure                level 1 dcl 7-72
db_path                         004241 automatic       char(168)                packed unaligned dcl 346 set ref 155* 177* 229 229
                                                                                  246 246 258 258 281 281
dbm_ptr                         010406 automatic       pointer                  dcl 7-106 set ref 89* 102* 114* 156* 175 177* 204
                                                                                  281 281* 284 322
dont_chase_links                004313 automatic       fixed bin(1,0)           initial dcl 347 set ref 229* 347*
empty                                                  builtin function         dcl 387 ref 127 362
error_code                             parameter       fixed bin(35,0)          dcl 348 set ref 87 100 112 125 132* 133 138* 139
                                                                                  142* 143 145* 146 146* 150 151* 171* 177* 178 179*
                                                                                  198 229* 232 232 232 235* 246* 248 256 258* 262*
                                                                                  264* 277 281* 286* 290* 298* 299 300* 304* 311*
error_table_$area_too_small     000014 external static fixed bin(35,0)          dcl 349 ref 311
error_table_$badcall            000016 external static fixed bin(35,0)          dcl 350 ref 290
error_table_$incorrect_access   000020 external static fixed bin(35,0)          dcl 351 ref 146 232
error_table_$insufficient_access
                                000022 external static fixed bin(35,0)          dcl 352 ref 262
error_table_$no_s_permission    000024 external static fixed bin(35,0)          dcl 353 ref 232
error_table_$unimplemented_version
                                000026 external static fixed bin(35,0)          dcl 354 ref 304
gs_local_area                   000100 automatic       area(2048)               dcl 127 set ref 127* 132 132
hcs_$fs_get_path_name           000030 constant        entry                    external dcl 355 ref 177
hcs_$initiate                   000032 constant        entry                    external dcl 356 ref 281
hcs_$status_                    000034 constant        entry                    external dcl 358 ref 229
idx                             004314 automatic       fixed bin(17,0)          dcl 359 set ref 143* 144*
ldn                             004316 automatic       fixed bin(17,0)          dcl 361 set ref 177*
local_area                      004320 automatic       area(2048)               dcl 362 set ref 229 229 246 246 362*
loop_idx                        004315 automatic       fixed bin(17,0)          dcl 360 set ref 134* 140* 143
mbz                       1(02)        based           bit(34)                  level 2 packed packed unaligned dcl 1-20 set ref
                                                                                  324*
mdbm_secured              0(01) 010402 automatic       bit(1)                   level 2 in structure "new_secure_word" packed packed
                                                                                  unaligned dcl 396 in procedure
                                                                                  "mrds_dm_db_secured" set ref 207*
mdbm_secured             11(01)        based           bit(1)                   level 2 in structure "db_model" packed packed
                                                                                  unaligned dcl 7-72 in procedure
                                                                                  "mrds_dm_db_secured" ref 322
mode                      3     010370 automatic       bit(5)                   level 3 packed packed unaligned dcl 395 set ref 237
model_name                      010320 automatic       char(32)                 packed unaligned dcl 363 set ref 175* 177* 179 229
                                                                                  229
mrds_authorization                     based           structure                level 1 dcl 5-22
mrds_authorization_ptr          010404 automatic       pointer                  dcl 5-29 set ref 246* 248
mrds_authorization_structure_version
                                000020 constant        fixed bin(17,0)          initial dcl 5-31 set ref 246* 304
mrds_dm_authorization$get_user_class
                                000036 constant        entry                    external dcl 364 ref 246
mrds_dm_authorization$set_needed_access
                                000040 constant        entry                    external dcl 365 ref 258
mrds_dm_check_path              000042 constant        entry                    external dcl 366 ref 145
mrds_error_$no_model_access     000044 external static fixed bin(35,0)          dcl 367 ref 264
mrds_error_$not_freeing_area    000046 external static fixed bin(35,0)          dcl 368 ref 300
mrds_error_$version_not_supported
                                000050 external static fixed bin(35,0)          dcl 369 ref 151 179
mrds_search_list_ptr            010330 automatic       pointer                  dcl 370 set ref 132* 134 144
my_area_info                    010344 automatic       structure                level 1 unaligned dcl 394 set ref 294* 298 298
my_status_branch                010370 automatic       structure                level 1 unaligned dcl 395 set ref 225* 229 229
new_found                       010332 automatic       bit(1)                   packed unaligned dcl 371 set ref 145* 151
new_secure_word                 010402 automatic       structure                level 1 dcl 396 set ref 206* 212
no_freeing                1(04) 010344 automatic       bit(1)                   level 3 packed packed unaligned dcl 394 set ref 300
null                                                   builtin function         dcl 387 ref 116 129 132 132 156 175 281 284 290
num_paths                 1            based           fixed bin(17,0)          level 2 dcl 3-15 ref 134
old_secure_word                 010333 automatic       bit(36)                  packed unaligned dcl 372 set ref 205* 212
pathname                 17            based           char(168)                array level 3 packed packed unaligned dcl 3-15 set
                                                                                  ref 144*
pathname_                       000052 constant        entry                    external dcl 373 ref 144
paths                    14            based           structure                array level 2 dcl 3-15
read                      0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 388 ref 239 241
read_ok                         010334 automatic       bit(1)                   packed unaligned dcl 374 set ref 225* 241* 258 264
rel_db_path                            parameter       char                     packed unaligned dcl 375 set ref 125 131 138* 144*
rtrim                                                  builtin function         dcl 387 ref 155 229 229 229 229 246 246 258 258 281
                                                                                  281
search                                                 builtin function         dcl 376 ref 131
search_paths_$get               000054 constant        entry                    external dcl 377 ref 132
secure_bit                      010335 automatic       bit(1)                   packed unaligned dcl 378 set ref 90* 103* 207
secure_word                            based           bit(36)                  dcl 379 ref 205 206 212
secure_word_ptr                 010336 automatic       pointer                  dcl 380 set ref 204* 205 206 212
secured                   1(01)        based           bit(1)                   level 2 packed packed unaligned dcl 1-20 set ref
                                                                                  322* 323
set_ok                          010340 automatic       bit(1)                   packed unaligned dcl 381 set ref 225* 239* 258
set_operation                   010341 automatic       bit(1)                   packed unaligned dcl 382 set ref 91* 104* 115* 158*
                                                                                  175 185 258 258 262
short                           010370 automatic       structure                level 2 dcl 395
sl_control_default              000000 constant        bit(36)                  initial packed unaligned dcl 2-13 set ref 132*
sl_info                                based           structure                level 1 dcl 3-15
sl_info_version_1               000020 constant        fixed bin(17,0)          initial dcl 3-29 set ref 132*
stacq                                                  builtin function         dcl 387 ref 212
status_branch                          based           structure                level 1 dcl 4-8
structure_version                      parameter       fixed bin(17,0)          dcl 383 ref 112 125 304
unsecured                 1            based           bit(1)                   level 2 packed packed unaligned dcl 1-20 set ref
                                                                                  323*
unspec                                                 builtin function         dcl 387 set ref 206* 212 212 212 225* 294* 317*
use_search_paths                010342 automatic       bit(1)                   packed unaligned dcl 385 set ref 130* 135* 144
version                                based           fixed bin(17,0)          level 2 in structure "database_state" dcl 1-20
                                                                                  in procedure "mrds_dm_db_secured" set ref 321*
version                         010344 automatic       fixed bin(17,0)          level 2 in structure "my_area_info" dcl 394
                                                                                  in procedure "mrds_dm_db_secured" set ref 295*
work_area                              based           area                     dcl 386 ref 315
write                     0(03)        based           bit(1)                   level 2 packed packed unaligned dcl 388 ref 239

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_PATH                          internal static fixed bin(17,0)          initial dcl 3-33
Directory                              internal static fixed bin(17,0)          initial dcl 4-56
HOME_DIR                               internal static fixed bin(17,0)          initial dcl 3-38
INITIATED_SEGS                         internal static fixed bin(17,0)          initial dcl 3-39
Link                                   internal static fixed bin(17,0)          initial dcl 4-56
PROCESS_DIR                            internal static fixed bin(17,0)          initial dcl 3-37
REFERENCING_DIR                        internal static fixed bin(17,0)          initial dcl 3-35
Segment                                internal static fixed bin(17,0)          initial dcl 4-56
UNEXPANDED_PATH                        internal static fixed bin(17,0)          initial dcl 3-34
WORKING_DIR                            internal static fixed bin(17,0)          initial dcl 3-36
alloc_length                           internal static fixed bin(35,0)          dcl 7-222
area_info_version_1                    internal static fixed bin(17,0)          initial dcl 6-3
area_infop                             automatic       pointer                  dcl 6-5
changer                                based           structure                level 1 packed packed unaligned dcl 7-251
changer_ptr                            automatic       pointer                  dcl 7-256
constant                               based           structure                level 1 unaligned dcl 7-216
constant_ptr                           automatic       pointer                  dcl 7-220
di_ptr                                 automatic       pointer                  dcl 7-155
domain_info                            based           structure                level 1 dcl 7-125
fi_ptr                                 automatic       pointer                  dcl 7-119
file_info                              based           structure                level 1 dcl 7-113
fixed                                                  builtin function         dcl 387
message_str                            based           structure                level 1 packed packed unaligned dcl 7-259
message_str_len                        automatic       fixed bin(17,0)          dcl 7-269
message_str_ptr                        automatic       pointer                  dcl 7-267
path_entry                             based           structure                level 1 packed packed unaligned dcl 7-172
path_entry_ptr                         automatic       pointer                  dcl 7-177
rel                                                    builtin function         dcl 387
sl_control                             automatic       bit(36)                  packed unaligned dcl 2-12
sl_control_s                           based           structure                level 1 packed packed unaligned dcl 2-3
sl_info_num_paths                      automatic       fixed bin(17,0)          dcl 3-27
sl_info_p                              automatic       pointer                  dcl 3-28
stack_item                             based           structure                level 1 unaligned dcl 7-206
stack_item_ptr                         automatic       pointer                  dcl 7-212
status_area_ptr                        automatic       pointer                  dcl 4-47
status_entry_names                     based           char(32)                 array dcl 4-47
status_link                            based           structure                level 1 dcl 4-38
status_pathname                        based           char                     dcl 4-47
status_ptr                             automatic       pointer                  dcl 4-47
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 384
ua_ptr                                 automatic       pointer                  dcl 7-165
unreferenced_attribute                 based           structure                level 1 dcl 7-159
version_status                         based           structure                level 1 packed packed unaligned dcl 7-232
version_status_ptr                     automatic       pointer                  dcl 7-246

NAMES DECLARED BY EXPLICIT CONTEXT.
change_secured_state            000577 constant        entry                    internal dcl 193 ref 185
check_access                    000636 constant        entry                    internal dcl 221 ref 197 276
common                          000506 constant        entry                    internal dcl 167 ref 93 106 118 160
get_secured_info                001156 constant        entry                    internal dcl 272 ref 187
get_secured_state               000160 constant        entry                    external dcl 125
get_secured_status              000131 constant        entry                    external dcl 112
mrds_dm_db_secured              000043 constant        entry                    external dcl 24
reset_db_secured                000102 constant        entry                    external dcl 100
set_db_secured                  000056 constant        entry                    external dcl 87
skip_allocate                   001434 constant        label                    dcl 326 ref 312

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2200        2256    1636        2210
Length      2632    1636        56         340     342           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dm_db_secured                 4440 external procedure  is an external procedure.  
common                                  internal procedure  shares stack frame of external procedure mrds_dm_db_secured.  
change_secured_state                    internal procedure  shares stack frame of external procedure mrds_dm_db_secured.  
check_access                        102 internal procedure  is called by several nonquick procedures.  
get_secured_info                    110 internal procedure  enables or reverts conditions.  
on unit on line 310                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dm_db_secured       000100 gs_local_area               mrds_dm_db_secured
                         004100 DBA                         mrds_dm_db_secured
                         004101 abs_path                    mrds_dm_db_secured
                         004154 access_mode_overlay_ptr     mrds_dm_db_secured
                         004156 changed                     mrds_dm_db_secured
                         004157 containing_dir              mrds_dm_db_secured
                         004231 db_dir                      mrds_dm_db_secured
                         004241 db_path                     mrds_dm_db_secured
                         004313 dont_chase_links            mrds_dm_db_secured
                         004314 idx                         mrds_dm_db_secured
                         004315 loop_idx                    mrds_dm_db_secured
                         004316 ldn                         mrds_dm_db_secured
                         004320 local_area                  mrds_dm_db_secured
                         010320 model_name                  mrds_dm_db_secured
                         010330 mrds_search_list_ptr        mrds_dm_db_secured
                         010332 new_found                   mrds_dm_db_secured
                         010333 old_secure_word             mrds_dm_db_secured
                         010334 read_ok                     mrds_dm_db_secured
                         010335 secure_bit                  mrds_dm_db_secured
                         010336 secure_word_ptr             mrds_dm_db_secured
                         010340 set_ok                      mrds_dm_db_secured
                         010341 set_operation               mrds_dm_db_secured
                         010342 use_search_paths            mrds_dm_db_secured
                         010344 my_area_info                mrds_dm_db_secured
                         010370 my_status_branch            mrds_dm_db_secured
                         010402 new_secure_word             mrds_dm_db_secured
                         010404 mrds_authorization_ptr      mrds_dm_db_secured
                         010406 dbm_ptr                     mrds_dm_db_secured

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry           ext_entry_desc
int_entry           op_alloc_           op_empty_           stacq_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            area_info_                    hcs_$fs_get_path_name         hcs_$initiate
hcs_$status_                  mrds_dm_authorization$get_user_class
mrds_dm_authorization$set_needed_access                     mrds_dm_check_path            pathname_
search_paths_$get

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$area_too_small   error_table_$badcall          error_table_$incorrect_access
error_table_$insufficient_access                            error_table_$no_s_permission
error_table_$unimplemented_version                          mrds_error_$no_model_access   mrds_error_$not_freeing_area
mrds_error_$version_not_supported




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    127 000031       347 000034       362 000035        24 000042        24 000051        87 000052        89 000067
     90 000073        91 000075        93 000076        95 000077       100 000100       102 000113       103 000117
    104 000120       106 000122       108 000123       112 000124       114 000142       115 000146       116 000147
    118 000151       120 000152       125 000153       129 000177       130 000202       131 000203       132 000217
    133 000266       134 000270       135 000273       136 000275       138 000276       139 000320       140 000322
    142 000324       143 000326       144 000337       145 000371       146 000421       149 000426       150 000430
    151 000432       155 000441       156 000500       158 000503       160 000504       165 000505       167 000506
    171 000507       175 000510       177 000522       178 000553       179 000556       185 000566       187 000572
    191 000576       193 000577       197 000600       198 000604       204 000607       205 000612       206 000614
    207 000615       209 000622       210 000623       212 000626       215 000633       219 000634       221 000635
    225 000643       229 000652       232 000751       235 000762       237 000763       239 000765       241 001000
    246 001004       248 001056       256 001066       257 001070       258 001072       260 001137       262 001141
    264 001147       270 001154       272 001155       276 001163       277 001170       281 001173       284 001265
    286 001273       290 001274       294 001305       295 001310       296 001312       298 001315       299 001330
    300 001334       304 001343       310 001353       311 001367       312 001373       315 001376       316 001410
    317 001411       321 001414       322 001416       323 001423       324 001432       332 001434


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
