	COMPILATION LISTING OF SEGMENT open_indx_file
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1147.66_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 
       16 
       17 /****^  HISTORY COMMENTS:
       18*  1) change(90-10-12,Zimmerman), approve(90-10-12,MCR8216),
       19*     audit(90-10-15,Zwick), install(90-10-16,MR12.4-1043):
       20*     Data_Mgt 63 (phx21194): Raise the max number of components in an MSF to
       21*     1250.
       22*                                                   END HISTORY COMMENTS */
       23 
       24 
       25 
       26 
       27 /* The initial design and implementation of this program was by M. D. MacLaren (1974) */
       28 /* All extensions, optimizations, and bug fixes since 1975 designed and implemented by M. Asherman */
       29 /* The above was true up through 1978.  Major modifications have been made by Jim Paradise prior to the first listed modification.
       30*   Modified:
       31*   05/31/79  by  Lindsey L. Spratt; fix "delete" bug by correcting a check seeing if the key
       32*   associated with branch_num is the same as the key in automatic storage.( a tip of the hat to
       33*   Chris D. Tavares for figuring out this fix)
       34*   Also, added code to check for improperly converted files, since check_file_version
       35*   was not doing the comp_table reformatting it should have been doing.
       36*   Modified by Jim Paradise on January 16, 1980 to correctly handle
       37*   modifiers of stationary records; problems due to interaction
       38*   of tp code and redefinition meaning of stationary header variable: modifier
       39*   04/29/80 by Jim Paradise to add fix to select/exclude logic to not try to
       40*   free at times there is not anything to free in returned descrip list,
       41*   Found and fix provided by Jim Gray.
       42*   Modified by Jim Paradise on June 27, 1980 to fix a performance bug, when inserting
       43*   duplicate keys search for them on the right.  Based on
       44*   the fix provided by Ed Brunnell.
       45*   12/18/80  by  Lindsey L. Spratt: add the ability to delete old subsets from
       46*   the "subset" vfile built for holding the results of selection and exclusion.
       47*   This also involved adding a new bit to the common_sl_info structure,
       48*   common_sl_info.delete_old_subsets.
       49*06/29/81 by Lindsey Spratt: Changed to use the iocb.incl.pl1 include file
       50*	  instead of the (now obsolete) iocbv.incl.pl1 include file.  This
       51*	  required explicitly qualifying with a locator value (iocb_ptr) all
       52*	  references to elements of the iocb structure.  Also, moved
       53*	  (nearly) all include files to the end of the source.
       54*01/20/82 by Lindsey Spratt:  Changed rewrite_indx_file entry point to only
       55*            reference the "current" node when indx_cb.outside_index is off.
       56*            This was causing a null pointer fault when no valid position had
       57*            established (e.g., the only kind of positioning done since the 
       58*            opening of the file was via the record_status control order.)
       59*01/21/82 by Lindsey Spratt:  Changed the declaration of the error_info structure
       60*            from fixed to fixed bin (35).  There was a size mis-match between
       61*            indx_cb.requested (fixed bin(34)) and error_info.requested (fixed 
       62*            bin(17)).
       63*03/31/82 by Lindsey Spratt: Changed close_indx_file to re-initialize the
       64*	  file_state pointers (fs_ptr, o_s_ptr, os_ptr, and
       65*	  indx_cb.file_state_ptr) when entered. (vfile bug 23.)
       66*04/05/82 by Lindsey Spratt: Changed the select control order to not allocate a
       67*	  descriptor array when the caller's selection gets an
       68*	  error_table_$no_record (i.e., when flag = select_flag, and
       69*	  indx_cb.subset_selected = "00"b, indicating that no selection has
       70*	  taken place).  This is checked in get_subset_status.
       71**/
       72 /* format: style2,ind3 */
       73 open_indx_file:
       74    proc (iocb_ptr, fcb_ptr_arg, first_seg_ptr, is_new_file, mode_arg, close_x, first_seg_bitcount, component_size_arg,
       75       code);
       76 
       77       go to open_file;
       78 
       79 init_down_up:					/* prologue for ops which must first lock file */
       80       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
       81       passive = "0"b;
       82       go to init_body;
       83 init_up_down:					/* prologue for semi-passive operations */
       84       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
       85       passive = indx_cb.stat;				/* lock file first if non-stationary */
       86       go to init_body;
       87 initialize:					/* prologue for all passive index operations */
       88       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
       89       passive = "1"b;				/* will never lock on this operation */
       90 init_body:
       91       code = 0;
       92       cleanup_flags = "000000"b;			/* nothing locked */
       93       if ^indx_cb.shared				/* unshared opening */
       94       then
       95          do;
       96 	  saved_state.shared = "0"b;
       97 	  timeout = 0;
       98 	  go to retry_loc (current_retry_loc);		/* back to mainline with handler established */
       99          end;
      100       saved_state_block = current_state_block;		/* for cleanup */
      101 						/* continue initialization for a shared operation */
      102       pos_ptr = file_position_ptr;
      103       f_b_ptr = file_base_ptr;
      104       fs_ptr = indx_cb.file_state_ptr;
      105       if indx_cb.wait_time < 0			/* will wait indefinitely */
      106       then timeout = eternity;			/* may wait forever */
      107       else timeout = clock () + indx_cb.wait_time;	/* microseconds */
      108       on cleanup call restore_abort;
      109       if current_retry_loc = rs_retry_2
      110       then go to retry_loc (rs_retry_2);
      111       if leave_locked				/* file left locked by me */
      112       then go to retry_loc (current_retry_loc);
      113       if ^passive
      114       then
      115          do;					/* insist on first locking the file */
      116 	  call lock_file_check;
      117 	  go to retry_loc (current_retry_loc);
      118          end;
      119       fault_ok = "0"b;				/* set when possible asynch file change errors should be handled */
      120 
      121       on any_other
      122          begin;					/* asynch change handler */
      123 	  if fault_ok				/* fault may be due to asynch change to the file */
      124 	  then
      125 	     do;					/* see if this is the case */
      126 	        fault_ok = "0"b;			/* suppress recursive any_other handling */
      127 	        call find_condition_info_ (null, addr (cond_info), er_code);
      128 						/* gets condition name */
      129 	        if asynch_change_condition (cond_name)	/* OK to handle */
      130 	        then if iocb_ptr -> iocb.open_data_ptr -> indx_cb.file_base_ptr -> file_base.change_count
      131 		      ^= iocb_ptr -> iocb.open_data_ptr -> indx_cb.last_change_count
      132 						/* file has changed--note indx_cb_ptr may not be valid now */
      133 		   then go to try_again;		/* reattempt operation or abort */
      134 	        fault_ok = "1"b;			/* pass on this fault, but resume handling others */
      135 	     end;
      136 	  call continue_to_signal_ (er_code);		/* quit or file not changed--must be an error */
      137 
      138 asynch_change_condition:
      139    proc (cond_name) returns (bit (1) aligned);		/*
      140*						   returns "1"b if condition may have arisen from asynch file change */
      141       if length (cond_name) > length ("simfault_")
      142       then if substr (cond_name, 1, length ("simfault_")) = "simfault_"
      143 	 then return ("1"b);
      144       if cond_name = "sub_err_"
      145       then if sub_err_info.name = "vfile_"
      146 	 then return ("1"b);			/* OK to handle vfile_'s own sub_err_ only */
      147 	 else return ("0"b);
      148 
      149       do i = 1 to num_conds;				/* check each possible condition known */
      150          if cond_name = as_cond_names (i)		/* match */
      151          then return ("1"b);
      152       end;					/* try each name in loop */
      153 
      154       return ("0"b);				/* not a condition which should be handled */
      155 
      156       dcl	    1 sub_err_info	       based (cond_info.infop),
      157 	      2 pad	       (70),
      158 	      2 name	       char (32);
      159       dcl	    cond_name	       char (32) var;
      160       dcl	    i		       fixed;
      161       dcl	    num_conds	       static internal fixed options (constant) init (21);
      162       dcl	    as_cond_names	       (1:21) static options (constant) char (32) var internal
      163 			       init ("fault_tag_1", "fault_tag_3", "fixedoverflow", "illegal_modifier",
      164 			       "linkage_error", "lockup", "no_execute_permission", "no_read_permission",
      165 			       "no_write_permission", "not_in_read_bracket", "not_in_write_bracket",
      166 			       "out_of_bounds", "overflow", "seg_fault_error", "size", "storage", "stringrange",
      167 			       "stringsize", "subscriptrange", "truncation", "underflow");
      168    end asynch_change_condition;
      169 
      170 	  dcl	find_condition_info_   entry (ptr, ptr, fixed (35));
      171 	  dcl	1 cond_info	   aligned,
      172 		  2 words1	   (3) fixed,
      173 		  2 cond_name	   char (32) var,	/* all that interests us */
      174 		  2 infop		   ptr,
      175 		  2 words2	   (12) fixed init ((12) 0);
      176 	  dcl	er_code		   fixed (35);
      177          end;					/* end of any_other handler */
      178 
      179       call prepare_process;
      180       go to retry_loc (current_retry_loc);		/* end of initialization pseudo-proc */
      181 
      182 try_again:					/* reattempt a passive operation if time enough */
      183       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      184       call restore_state;
      185       call prepare_process;				/* may wait on file lock */
      186       go to retry_loc (current_retry_loc);		/* back to mainline */
      187 
      188 verify_done:
      189       if indx_cb.shared
      190       then if cleanup_flags ^= "000000"b		/* not passive */
      191 	 then go to unlock_exit;			/* don't leave things locked */
      192 	 else
      193 	    do;
      194 	       call save_correct_pos;
      195 	       if ^indx_cb.leave_locked
      196 	       then
      197 		do;				/* verify a passive operation */
      198 		   if indx_cb.last_change_count = file_base.change_count
      199 						/* file unchanged during operation */
      200 		   then return;			/* result is therefore verified--done */
      201 		   call restore_state;		/* resets process vars to their former values */
      202 		   if clock () > timeout		/* time limit exhausted */
      203 		   then
      204 		      do;				/* abort */
      205 		         code = error_table_$file_busy;
      206 		         return;
      207 		      end;
      208 		   call prepare_process;
      209 		   go to retry_loc (current_retry_loc);
      210 		end;
      211 	    end;
      212       return;					/* external exit */
      213 
      214 passive_abort:
      215       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      216       if saved_state.shared				/* state has been saved */
      217       then call restore_state;
      218       return;
      219 
      220 /* seek_key routine for openings with mode keyed_sequential_output */
      221 seek_key_ks_out:
      222    entry (iocb_ptr, key, rec_len, code);
      223       current_retry_loc = seek_kso_retry;
      224       go to initialize;
      225 retry_loc (1):
      226       if indx_cb.pos_incorrect
      227       then
      228          do;					/* position correctly to end of file */
      229 	  call position_eof;
      230 	  indx_cb.pos_incorrect = "0"b;
      231          end;
      232       else
      233          do;
      234 	  pos_ptr = file_position_ptr;
      235 	  indx_cb.outside_index = "0"b;		/* current pos moves into index */
      236 	  branch_num = last_branch_num;
      237 	  call set_at_eof;				/* sets indx_cb vars */
      238          end;
      239       indx_cb.new_key = key;				/* save key for insertion */
      240       call compare_last_key (indx_cb.new_key);		/* sets code and key_is_dup */
      241       if code = 0					/* indx_cb.new_key larger than last key in file */
      242       then
      243          do;
      244 	  code = error_table_$no_record;
      245 	  indx_cb.ready_to_write = "1"b;
      246          end;
      247       else indx_cb.ready_to_write = (key_is_dup & dup_ok);	/* write will succeed if
      248*						   key exists and duplications are allowed */
      249       go to verify_done;				/* end seek_key for keyed sequential output */
      250 
      251 seek_key_indx_file:
      252    entry (iocb_ptr, key, rec_len, code);
      253       current_retry_loc = seek_retry;
      254       go to initialize;
      255 retry_loc (2):
      256       indx_cb.at_bof, indx_cb.at_eof = "0"b;
      257       file_position_ptr = root_position_ptr;
      258       indx_cb.outside_index = "0"b;
      259       indx_cb.skip_state = 0;				/* revert to forward scanning over deletions */
      260       call find_key (indx_cb_ptr, (addr (key)), search_code);
      261 						/* 2nd arg is destroyed */
      262       pos_ptr = file_position_ptr;
      263       indx_cb.pos_incorrect = "0"b;			/* Now set file position and code */
      264       if search_code = 0				/* means not found */
      265       then code = error_table_$no_record;
      266       else
      267          do;					/* try to get ptr and len */
      268 	  call find_from_leaf;			/* in case match was in upper node */
      269 	  indx_cb.current_descrip = record_designator (branch_num);
      270 	  call set_next_reclp_seek (block_ptr, lock_ptr); /* sets ptr and length */
      271 						/* limits scanning to entries for this key */
      272 						/* also sets the code to indicate failure */
      273          end;					/* either len is known or error code set */
      274       if (code = 0) | (code ^= error_table_$no_record)
      275       then
      276          do;					/* set position indicators and recl arg */
      277 	  rec_len = record_len;
      278 	  indx_cb.current_record_is_valid = "1"b;
      279 	  indx_cb.next_record_position = 1;
      280 	  indx_cb.ready_to_write = dup_ok;
      281          end;
      282       else
      283          do;					/* set indicators for unsuccessful seek */
      284 	  rec_len = 0;
      285 	  indx_cb.current_record_is_valid = "0"b;
      286 	  indx_cb.next_record_position = 0;
      287 	  if ^is_read_only
      288 	  then
      289 	     do;
      290 	        indx_cb.ready_to_write = "1"b;
      291 	        indx_cb.new_key = key;
      292 	     end;
      293          end;
      294       go to verify_done;				/* end of seek_key routine */
      295 
      296       dcl	    search_code	       fixed (35);
      297 
      298 read_length_indx_file:
      299    entry (iocb_ptr, rec_len, code);
      300       current_retry_loc = read_len_retry;
      301       go to initialize;
      302 retry_loc (3):
      303       call find_next_record;
      304       if code = 0					/* next record exists */
      305       then
      306          do;					/* get its length */
      307 	  call set_next_reclp (block_ptr, lock_ptr);
      308 	  rec_len = record_len;
      309          end;
      310       go to verify_done;				/* end of read_length routine */
      311 
      312 read_key_indx_file:
      313    entry (iocb_ptr, key, rec_len, code);
      314       current_retry_loc = read_key_retry;
      315       go to initialize;
      316 retry_loc (4):
      317       call find_next_record;
      318       if code = 0					/* next position exists */
      319       then
      320          do;
      321 	  call set_next_reclp (block_ptr, lock_ptr);
      322 	  rec_len = record_len;
      323 	  len = get_key_length ();
      324 	  if len > 0
      325 	  then key = substr (keys, key_pos (branch_num), len);
      326 	  else key = "";
      327          end;
      328       go to verify_done;				/* end of read_key routine */
      329 
      330 read_indx_file:
      331    entry (iocb_ptr, buff_ptr, buff_len, rec_len, code);
      332       current_retry_loc = read_retry;
      333       go to initialize;
      334 retry_loc (5):
      335       call find_next_record;
      336       if code = 0					/* next position exists */
      337       then
      338          do;
      339 	  call set_next_reclp_and_contents (block_ptr, lock_ptr);
      340 	  rec_len = record_len;
      341 	  if is_sequential_open & ((code = 0) | ((code ^= error_table_$end_of_info) & (code ^= error_table_$no_record)))
      342 	  then indx_cb.next_record_position = 2;	/* next record follows that just read */
      343 	  else indx_cb.next_record_position = 0;
      344          end;
      345       go to verify_done;				/* end of read routine */
      346 
      347 position_indx_file:
      348    entry (iocb_ptr, pos_type, skip, code);
      349       if pos_type = 0
      350       then
      351          do;
      352 	  current_retry_loc = skip_retry;
      353 	  saved_error_info = iocb_ptr -> iocb.open_data_ptr -> indx_cb.error;
      354 	  go to initialize;
      355 retry_loc (6):
      356 	  if indx_cb.next_record_position = 0		/* position may be undefined */
      357 	  then
      358 	     do;
      359 	        call find_next_record;		/* sets position indicators */
      360 	        if code ^= 0			/* really is an error */
      361 	        then return;
      362 	     end;
      363 	  indx_cb.outside_index = "0"b;		/* current pos moves back into index */
      364 	  if pos_incorrect
      365 	  then
      366 	     do;
      367 	        call restore_position;
      368 	        if code ^= 0
      369 	        then go to verify_done;
      370 	     end;
      371 	  else pos_ptr = file_position_ptr;
      372 	  indx_cb.at_bof, indx_cb.at_eof = "0"b;
      373 	  indx_cb.skip_state = 0;
      374 	  if skip >= 0				/* forward skip */
      375 	  then
      376 	     do;
      377 	        count = skip + indx_cb.next_record_position - 1;
      378 	        indx_cb.current_record_is_valid, indx_cb.ready_to_write = "0"b;
      379 
      380 	        do while (count > 0);			/* advance until count zero or eof reached */
      381 		 branches_left = last_branch_num - branch_num;
      382 						/* branches in current node */
      383 		 if branches_left > 0
      384 		 then if (indx_cb.subset_selected = "00"b) & (branch (branch_num) = 0)
      385 						/* leaf node */
      386 		      then
      387 		         do;			/* skip over a chunk of branches in one node */
      388 			  chunk_size = min (count, branches_left);
      389 						/* as many as possible */
      390 			  branch_num = branch_num + chunk_size;
      391 						/* will be last if more to skip */
      392 			  count = count - chunk_size; /* remainder to be skipped */
      393 		         end;
      394 		      else
      395 		         do;			/*  skip one from upper to leaf */
      396 			  if indx_cb.subset_selected ^= "00"b
      397 			  then
      398 			     do;			/* see if this entry is being masked */
      399 			        call check_subset (record_designator (branch_num));
      400 			        if ^rec_deleted	/* this one counts */
      401 			        then count = count - 1;
      402 			     end;
      403 			  else count = count - 1;	/* none are being masked */
      404 			  branch_num = branch_num + 1;/* next non-leaf branch */
      405 			  call find_leftmost_descendent;
      406 		         end;
      407 		 else
      408 		    do;				/* move to entry from last branch in a node */
      409 		       call find_this_entry;
      410 		       if pos_ptr = root_position_ptr	/* at end of file */
      411 		       then
      412 			do;
      413 			   count = -count;		/* causes exit from loop */
      414 			   code = error_table_$end_of_info;
      415 			end;
      416 		    end;
      417 	        end;
      418 
      419 	        if code ^= 0			/* attempted to pass eof */
      420 	        then
      421 		 do;
      422 		    call position_eof;		/* set position properly */
      423 		    indx_cb.error.type = skip_error;	/* error -- attempt to pass end of file on position skip */
      424 		    indx_cb.error.requested = skip;	/* number of skips specified in call */
      425 		    indx_cb.error.received = skip + count;
      426 						/* number of records actually skipped */
      427 		 end;
      428 	        else indx_cb.next_record_position = 1;
      429 	     end;					/* end of forward skip case */
      430 	  else
      431 	     do;					/* backward skip */
      432 	        count = 1 - skip - indx_cb.next_record_position;
      433 
      434 	        do while (count > 0);
      435 		 if count = 1
      436 		 then
      437 		    do;				/* backspace by a single branch */
      438 back_1:
      439 		       call find_prev_entry;		/* handles exceptions */
      440 		       if branch_num = 1		/* beginning of file */
      441 		       then
      442 			do;
      443 			   code = error_table_$end_of_info;
      444 			   count = -count;		/* causes exit from loop */
      445 			end;
      446 		       else
      447 			do;
      448 			   branch_num = branch_num - 1;
      449 			   if indx_cb.subset_selected ^= "00"b
      450 			   then
      451 			      do;
      452 			         call check_subset (record_designator (branch_num));
      453 			         if ^rec_deleted
      454 			         then count = count - 1;
      455 			      end;
      456 			   else count = count - 1;
      457 			end;
      458 		    end;
      459 		 else if branch_num > 1		/* not at first branch in node */
      460 		 then if (indx_cb.subset_selected = "00"b) & (branch (branch_num) = 0)
      461 		      then
      462 		         do;			/* skip over a bunch of leaf branches */
      463 			  chunk_size = min (count, branch_num - 1);
      464 			  count = count - chunk_size;
      465 			  branch_num = branch_num - chunk_size;
      466 						/* does the backspacing */
      467 		         end;
      468 		      else go to back_1;
      469 		 else go to back_1;
      470 	        end;
      471 
      472 	        if code ^= 0
      473 	        then
      474 		 do;				/* set position properly and save error info */
      475 		    call position_bof;
      476 		    indx_cb.error.type = skip_error;
      477 		    indx_cb.error.requested = skip;
      478 		    indx_cb.error.received = skip - count;
      479 						/* actual number successfully skipped */
      480 		 end;
      481 	        else
      482 		 do;
      483 		    indx_cb.next_record_position = 1;
      484 		    indx_cb.current_record_is_valid = "1"b;
      485 		    indx_cb.ready_to_write = dup_ok;
      486 		    indx_cb.skip_state = -1;		/* causes reverse scanning over deleted records */
      487 		 end;
      488 	     end;					/* end of backward skip case */
      489          end;					/* end of position skip case */
      490       else if abs (pos_type) = 1			/* valid type */
      491       then
      492          do;
      493 	  current_retry_loc = pos_bof_or_eof_retry;
      494 	  go to initialize;
      495 retry_loc (7):
      496 	  if pos_type = 1
      497 	  then call position_eof;
      498 	  else call position_bof;
      499 	  indx_cb.outside_index = "0"b;
      500 	  pos_incorrect = "0"b;
      501          end;
      502       else
      503          do;
      504 	  code = error_table_$bad_arg;
      505 	  return;
      506          end;
      507       go to verify_done;				/* end of position routine */
      508 
      509 control_indx_file:
      510    entry (iocb_ptr, order, info_ptr_arg, code);
      511       info_ptr = info_ptr_arg;
      512       code = 0;
      513 
      514       if order = "get_key"
      515       then
      516          do;
      517 	  current_retry_loc = gk_retry;
      518 	  go to initialize;
      519 retry_loc (8):					/* first validate arguments in info structure */
      520 	  if ^gk_inf.input_key & (gk_inf.current = "1"b) & (gk_inf.input_desc)
      521 	  then
      522 	     do;
      523 	        code = error_table_$bad_arg;
      524 	        go to exit;				/* abort */
      525 	     end;
      526 	  if (gk_inf.current & ^gk_inf.input_key) | (^gk_inf.input_desc & (gk_inf.desc_code = 1))
      527 						/* current position required */
      528 	  then
      529 	     do;
      530 	        call check_current;
      531 	        if code ^= 0
      532 	        then go to verify_done;		/* abort--no current position */
      533 	        if ^gk_inf.input_key & gk_inf.current	/* current key required */
      534 	        then if indx_cb.outside_index		/* no current key is defined */
      535 		   then
      536 		      do;
      537 		         code = error_table_$no_key;
      538 		         gk_inf.descrip = indx_cb.current_descrip;
      539 		         gk_inf.key_len = 0;
      540 		         go to verify_done;		/* abort this operation */
      541 		      end;
      542 	        if gk_inf.reset_pos & (^indx_cb.shared | ^saved_state.current_record_is_valid)
      543 	        then
      544 		 do;
      545 		    saved_state.skip_state = indx_cb.skip_state;
      546 		    call save_correct_pos;
      547 		 end;
      548 	     end;
      549 	  else if gk_inf.reset_pos & ^indx_cb.shared
      550 	  then
      551 	     do;
      552 	        saved_state.skip_state = indx_cb.skip_state;
      553 	        call save_correct_pos;
      554 	     end;
      555 	  if ^gk_inf.input_key			/* current or next position */
      556 	  then if gk_inf.current			/* current position */
      557 	       then if indx_cb.subset_selected ^= "00"b	/* must see if this record is being masked */
      558 		  then
      559 		     do;
      560 		        call check_subset (indx_cb.current_descrip);
      561 		        if rec_deleted
      562 		        then code = error_table_$no_record;
      563 		     end;
      564 		  else ;				/* just set gk_info and return now */
      565 	       else
      566 		do;				/* find next entry, possibly scanning over unwanted descriptors */
      567 		   if pos_incorrect
      568 		   then
      569 		      do;
      570 		         call restore_position;
      571 		         if code ^= 0
      572 		         then go to verify_done;
      573 		      end;
      574 		   else pos_ptr = indx_cb.file_position_ptr;
      575 		   if indx_cb.next_record_position = 1
      576 		   then if branch_num < last_branch_num
      577 		        then go to next_found;
      578 		        else ;			/* will have to handle special case */
      579 		   else if indx_cb.next_record_position = 2
      580 		   then branch_num = branch_num + 1;
      581 		   else
      582 		      do;
      583 		         code = error_table_$no_record;
      584 		         go to next_found;		/* abort */
      585 		      end;
      586 		   call find_this_entry;
      587 		   if pos_ptr = root_position_ptr	/* eof */
      588 		   then
      589 		      do;
      590 		         code = error_table_$end_of_info;
      591 		         if ^gk_inf.reset_pos
      592 		         then call position_eof;
      593 		      end;
      594 next_found:
      595 		   if code = 0
      596 		   then
      597 		      do;
      598 		         pad_key_ptr = addr (indx_cb.new_key);
      599 						/* in case previous seek_head applies */
      600 		         call gk_scan;		/* find valid entry by scanning if necessary */
      601 		      end;
      602 		end;
      603 	  else
      604 	     do;					/* seek to proper location in index */
      605 	        pad_key_ptr = addr (gk_pad_key);
      606 	        pad_key_len = 256;			/* must pad with 0's for proper seek */
      607 	        len = min (fixed (gk_inf.head_size), gk_inf.key_len);
      608 	        unspec (substr (pad_key, len + 1, 256 - len)) = "0"b;
      609 						/* pad with 0's */
      610 	        substr (pad_key, 1, len) = substr (gk_inf.key, 1, len);
      611 	        indx_cb.pos_incorrect = "0"b;
      612 	        call seek_head ((gk_inf.rel_type), addr (pad_key_info), (fixed (gk_inf.head_size)));
      613 	        if pos_ptr = root_position_ptr		/* no luck */
      614 	        then
      615 		 do;
      616 		    if ^gk_inf.reset_pos
      617 		    then indx_cb.at_bof, indx_cb.at_eof = "0"b;
      618 		    code = error_table_$no_key;
      619 		 end;
      620 	        else
      621 		 do;
      622 		    if gk_inf.rel_type = 0
      623 		    then indx_cb.skip_state = fixed (gk_inf.head_size);
      624 						/* indicates scanning after head match */
      625 		    else indx_cb.skip_state = 0;	/* just scan forward */
      626 		    call gk_scan;			/* finds satisfactory descriptor */
      627 		    if ^indx_cb.shared & ^gk_inf.reset_pos
      628 		    then call save_correct_pos;	/* in case of scan */
      629 		 end;
      630 	     end;
      631 	  if code = 0
      632 	  then
      633 	     do;
      634 	        gk_inf.key_len = get_key_length ();
      635 	        gk_inf.key = substr (keys, key_pos (branch_num), key_length (branch_num));
      636 	        gk_inf.descrip = record_designator (branch_num);
      637 	        if ^gk_inf.reset_pos			/* leave position here */
      638 	        then
      639 		 do;
      640 		    indx_cb.ready_to_write = indx_cb.dup_ok;
      641 		    indx_cb.outside_index, indx_cb.at_eof, indx_cb.at_bof = "0"b;
      642 		    indx_cb.current_record_is_valid = "1"b;
      643 		    indx_cb.next_record_position = 1;
      644 		 end;
      645 	        else
      646 		 do;
      647 		    indx_cb.skip_state = saved_state.skip_state;
      648 		    indx_cb.pos_incorrect = "1"b;
      649 		 end;
      650 	     end;
      651 	  else if ^gk_inf.reset_pos			/* leave next position undefined */
      652 	  then
      653 	     do;
      654 	        indx_cb.ready_to_write, indx_cb.current_record_is_valid, indx_cb.outside_index = "0"b;
      655 	        if ^(indx_cb.at_bof | indx_cb.at_eof)
      656 	        then indx_cb.next_record_position = 0;
      657 	     end;
      658 	  else
      659 	     do;
      660 	        indx_cb.skip_state = saved_state.skip_state;
      661 	        indx_cb.pos_incorrect = "1"b;
      662 	     end;
      663 	  go to verify_done;
      664          end;
      665 
      666       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      667       code = 0;
      668 
      669       if order = "record_status"
      670       then
      671          do;
      672 	  call check_rs_args;			/* aborts on error */
      673 	  if code ^= 0				/* fatal error detected by arg checking */
      674 	  then return;				/* abort--don't bother looking at file */
      675 	  current_retry_loc = rs_retry_1;
      676 	  if indx_cb.shared
      677 	  then if ^passive_op & (^indx_cb.stat | rs_info.create_sw)
      678 						/* first must lock file */
      679 	       then go to init_down_up;
      680 	       else if ^(indx_cb.outside_index | rs_info.locate_sw)
      681 	       then go to initialize;
      682 	       else
      683 		do;				/* get file's change count, but synch at record level */
      684 		   current_retry_loc = rs_retry_2;
      685 		   go to initialize;
      686 retry_loc (9):
      687 		   new_change_count = file_base.change_count;
      688 		   if new_change_count ^= indx_cb.last_change_count
      689 						/* asynch change */
      690 		   then
      691 		      do;				/* bring process vars up to date */
      692 		         call initialize_ptrs;
      693 		         indx_cb.pos_incorrect = "1"b;
      694 		         indx_cb.last_change_count = new_change_count;
      695 		      end;			/* open data consistent with last change count now */
      696 		end;				/* file level verification will occur if non-stationary */
      697 	  else go to init_up_down;
      698 retry_loc (10):
      699 	  call record_status;			/* may create rec or alter lock, as well as returning info
      700*						   and setting current current record pos outside index */
      701 	  if rs_info.unlock_sw & ^rs_info.lock_sw	/* explicit unlocking without locking */
      702 	  then if code = 0
      703 	       then code = error_table_$lock_not_locked;	/* complain if not already locked by me */
      704 	       else if code = error_table_$locked_by_this_process
      705 						/* expected */
      706 	       then
      707 		do;
      708 		   i_locked_rec = "1"b;		/* cause unlocking to be done */
      709 		   code = 0;
      710 		end;
      711 	  if ^passive_op				/* file modification */
      712 	  then go to unlock_exit;			/* unlock after shared file alteration */
      713 	  else if rs_info.unlock_sw
      714 	  then go to unlock_exit;			/* unlock the record only */
      715 	  else if ^indx_cb.outside_index		/* file level synchronization */
      716 	  then go to verify_done;			/* will re-attempt operation if asynch changes detected */
      717 	  else if block_ptr ^= null
      718 	  then if ^block_ptr -> record_block.stationary	/* non-stationary */
      719 	       then go to verify_done;		/* may have to retry to get snapshot */
      720 	  return;					/* may have already made external exit */
      721          end;					/* record_status proc does external exit */
      722 
      723       if order = "seek_head"
      724       then if is_sequential_open & ^is_ks_out & (mode > 7 /* keyed */)
      725 	 then
      726 	    do;					/* won't be no_operation */
      727 	       if (info.rel_type < 0) | (info.rel_type > 2) | (n < 0)
      728 	       then
      729 		do;				/* bag arg--abort */
      730 		   code = error_table_$bad_arg;
      731 		   return;
      732 		end;
      733 	       else
      734 		do;
      735 		   current_retry_loc = sh_retry;
      736 		   go to initialize;
      737 retry_loc (11):
      738 		   indx_cb.at_bof, indx_cb.at_eof = "0"b;
      739 		   indx_cb.outside_index = "0"b;
      740 		   pad_key_ptr = addr (indx_cb.new_key);
      741 		   pad_key_len = 256;
      742 		   unspec (substr (pad_key, n + 1, 256 - n)) = "0"b;
      743 						/* pad with zeroes, not blanks */
      744 		   substr (pad_key, 1, n) = search_key;
      745 		   call seek_head (info.rel_type, addr (pad_key_info), info.n);
      746 		   if pos_ptr = indx_cb.root_position_ptr
      747 						/* not found */
      748 		   then code = error_table_$no_record;
      749 		   if code = 0
      750 		   then
      751 		      do;
      752 		         if indx_cb.dup_ok
      753 		         then indx_cb.ready_to_write = "1"b;
      754 		         else indx_cb.ready_to_write = "0"b;
      755 		         indx_cb.current_record_is_valid = "1"b;
      756 		         indx_cb.next_record_position = 1;
      757 		         if info.rel_type = 0		/* exact match was required */
      758 		         then indx_cb.skip_state = n;	/* will only scan while head condition is met */
      759 		         else indx_cb.skip_state = 0;	/* any subsequent entry will do on detection of deletion */
      760 		         if indx_cb.subset_selected ^= "00"b
      761 						/* select or exclude in effect */
      762 		         then call sh_scan;		/* scan for entry in the current subset */
      763 		      end;
      764 		   else
      765 		      do;
      766 		         indx_cb.ready_to_write = "0"b;
      767 		         indx_cb.current_record_is_valid = "0"b;
      768 		         indx_cb.next_record_position = 0;
      769 		      end;
      770 		   pos_incorrect = "0"b;
      771 		   go to verify_done;		/* will save key if shared */
      772 		end;
      773 	    end;
      774 
      775       if ^is_read_only				/* must have modify access */
      776       then
      777          do;
      778 	  if (order = "add_key")
      779 	  then go to add_key;
      780 
      781 	  else if (order = "delete_key")
      782 	  then go to delete_key;			/* does the work */
      783 
      784 	  else if (order = "reassign_key")
      785 	  then go to reassign_key;
      786          end;
      787 
      788       if order = "select"
      789       then go to select;
      790 
      791       if order = "exclude"
      792       then go to exclude;
      793 
      794       if order = "error_status"
      795       then
      796          do;
      797 	  if error_info.version ^= 1
      798 	  then code = error_table_$bad_arg;
      799 	  else
      800 	     do;
      801 	        error_info.type = indx_cb.error.type;
      802 	        error_info.requested = indx_cb.error.requested;
      803 	        error_info.received = indx_cb.error.received;
      804 	     end;
      805 	  return;
      806          end;
      807 
      808       if order = "min_block_size"
      809       then
      810          do;
      811 	  indx_cb.min_res = max (0, mbs_info.min_residue);
      812 	  indx_cb.min_cap = max (0, mbs_info.min_capacity);
      813 	  return;
      814          end;
      815 
      816       if indx_cb.shared
      817       then
      818          do;
      819 	  if (order = "set_wait_time")
      820 	  then
      821 	     do;					/* change setting of max wait time */
      822 	        if new_wait_time = -2			/* collection delay version */
      823 	        then if wt_info.collection_delay_time < 0
      824 		   then code = error_table_$bad_arg;
      825 		   else indx_cb.collection_delay_time = 1000000 * wt_info.collection_delay_time;
      826 	        else if new_wait_time < -1
      827 	        then code = error_table_$bad_arg;
      828 	        else indx_cb.wait_time = 1000000 * new_wait_time;
      829 	        return;				/* that's all there is to it */
      830 	     end;
      831 
      832 	  if (order = "set_file_lock") & ^indx_cb.is_read_only
      833 	  then
      834 	     do;					/* attempt to lock or unlock the file */
      835 	        if info_ptr -> set_lock_flag		/* wants to set the lock */
      836 	        then if indx_cb.leave_locked
      837 		   then code = error_table_$locked_by_this_process;
      838 		   else
      839 		      do;				/* lock and restore process vars */
      840 		         current_retry_loc = lock_file_retry;
      841 		         go to init_down_up;		/* setup handler */
      842 retry_loc (24):
      843 		         if set_lock_info.exclusive
      844 		         then file_action = read_exclude;
      845 						/* stops readers */
      846 		         indx_cb.read_exclu = info_ptr -> exclusive;
      847 		         indx_cb.leave_locked = "1"b;	/* remember locked */
      848 		      end;
      849 	        else if ^indx_cb.leave_locked
      850 	        then
      851 		 do;
      852 		    code = error_table_$lock_not_locked;
      853 		    if indx_cb.file_base_ptr -> file_base.lock_word = indx_cb.saved_lock_copy
      854 						/* my lock */
      855 		    then call check_code (code, "File lock set by another opening in this
      856 process.  This opening can't clear the lock.  Either
      857 unlock from the opening that locked, of force unlocking
      858 with the vfile_adjust command.");
      859 		 end;
      860 	        else
      861 		 do;				/* OK to unlock */
      862 		    saved_state_block = current_state_block;
      863 		    cleanup_flags = "100000"b;	/* OK to unlock file */
      864 		    on cleanup call restore_abort;
      865 		    leave_locked = "0"b;		/* remember I unlocked */
      866 		    f_b_ptr = file_base_ptr;
      867 		    pos_ptr = file_position_ptr;
      868 		    fs_ptr = indx_cb.file_state_ptr;
      869 		    if file_action = read_exclude
      870 		    then file_action = 0;		/* clear read lock */
      871 		    indx_cb.read_exclu = "0"b;
      872 		    go to unlock_exit;		/* sets last_change_count */
      873 		 end;
      874 	        return;				/* finished with operation */
      875 	     end;
      876          end;
      877 
      878       if order = "file_status"
      879       then
      880          do;
      881 	  call vfile_status_$seg (iocb_ptr, file_base_ptr, info_ptr, code);
      882 	  return;
      883          end;
      884 
      885       if order = "io_call"
      886       then
      887          do;
      888 	  call vfile_io_control (iocb_ptr, file_base_ptr, info_ptr, code);
      889 	  return;					/* work done on recursive call */
      890          end;
      891 
      892       if order = "io_call_af"
      893       then
      894          do;
      895 	  call vfile_io_control$af (iocb_ptr, file_base_ptr, info_ptr, code);
      896 	  return;					/* return from call for active function */
      897          end;
      898 
      899       code = error_table_$no_operation;
      900       return;					/* end of control routine */
      901 
      902 get_ptr:
      903    proc (designator_arg) returns (ptr);
      904       return (addr (seg_ptr_array (des_arg.comp_num) -> seg_array (fixed (des_arg.offset))));
      905       dcl	    designator_arg	       fixed (35);
      906       dcl	    1 des_arg	       like designator_struct aligned based (addr (designator_arg));
      907    end;
      908 
      909 lock_current_record:
      910    proc (block_ptr, lock_ptr, i_locked_mask, ref_count_change);
      911 						/* non-passive, non-scanning */
      912 						/* delete_record suppresses cleanup by setting input_only flag */
      913       if indx_cb.repeating				/* recovery in progress */
      914       then
      915          do;					/* reconstruct pointers */
      916 	  f_b_ptr = indx_cb.file_base_ptr;
      917 	  fs_ptr = indx_cb.file_state_ptr;
      918 	  block_ptr = get_pointer (indx_cb.current_descrip);
      919 	  lock_ptr = null;
      920 	  cleanup_flags = cleanup_flags | (i_locked_mask & rec_lock_mask);
      921 	  if file_base.was_stat			/* record may have been stationary type */
      922 	  then
      923 	     do;					/* get correct lock_ptr */
      924 	        if (file_action = reassigning_key)	/* maybe non-stat */
      925 	        then if ^block_ptr -> record_block.stationary
      926 		   then return;			/* suppress unlocking */
      927 	        lock_ptr = addr (block_ptr -> stat_struct.record_lock);
      928 	     end;
      929 	  return;
      930          end;
      931       passive = "0"b;
      932       scan = "0"b;					/* treats logical deletion as error without scanning */
      933       go to get_reclp;				/* main body of record access synch routine */
      934 set_next_reclp_and_contents:				/* for read_record op */
      935 set_next_reclp_seek:				/* passive with restricted
      936*						   scanning, i.e. scanning of duplicate keys matching seek arg */
      937 set_next_reclp:
      938    entry (block_ptr, lock_ptr);			/* passive with scanning */
      939       passive = "1"b;				/* never modify via this entry */
      940       scan = "1"b;					/* means scan over absent entries, if found */
      941       go to get_reclp;
      942 set_current_reclp:
      943    entry (block_ptr, lock_ptr);			/* passive, non-scanning */
      944       passive = "1"b;
      945       scan = "0"b;					/* will not scan if record is logically absent */
      946 get_reclp:
      947       code = 0;
      948       block_ptr = null;				/* loop condition */
      949       lock_ptr = null;
      950       record_ptr = null;
      951       record_len = 0;
      952       max_rec_wds = 0;				/* allocated block size minus header size */
      953       ref_cnt = 0;					/* reference count--stationary records only */
      954 
      955       do while (block_ptr = null);			/* may loop over logically absent records */
      956          if indx_cb.subset_selected ^= "00"b		/* may be masked */
      957          then call check_subset (indx_cb.current_descrip);	/* sets rec_deleted flag */
      958 						/* will know whether or not to clean up by nullness of block_ptr */
      959          else rec_deleted = "0"b;			/* entry not masked so far */
      960          if ^rec_deleted				/* OK to look for allocation */
      961          then
      962 	  do;					/* look at the record block allocation */
      963 	     if indx_cb.current_descrip <= 0		/* no allocation possible for this descriptor */
      964 	     then
      965 	        do;				/* check for error and return */
      966 		 if ^passive			/* only attempt to lock may regard as an error */
      967 		 then if indx_cb.trans
      968 		      then code = error_table_$no_room_for_lock;
      969 						/* must support null descriptor special case */
      970 		 return;				/* nothing more to do in this routine */
      971 	        end;				/* will exit loop with non-null block_ptr */
      972 	     if indx_cb.shared & ^indx_cb.leave_locked & ^i_locked_file & ^indx_cb.outside_index
      973 						/* possible asynch file change errors */
      974 	     then if indx_cb.last_change_count ^= file_base.change_count
      975 						/* asynch change
      976*						   has occurred--descriptor may not be valid--reobtain */
      977 		then go to verify_done;		/* will abort if no time left */
      978 	     block_ptr = get_pointer (indx_cb.current_descrip);
      979 						/* ptr to block header */
      980 	     if block_ptr = null			/* should never happer */
      981 	     then call check_code (error_table_$no_record, "Can't obtain record pointer--reason unknown.");
      982 	     if ^block_ptr -> record_block.stationary	/* non-stationary record */
      983 	     then call inspect_non_stat_rec;		/* gets lock ptr if room */
      984 	     else call inspect_stat_record;		/* sees if logically deleted */
      985 	  end;					/* rec_deleted flag set if logically absent */
      986          if rec_deleted				/* user can't see this entry */
      987          then
      988 	  do;					/* see if OK to scan and/or garbage-collect */
      989 	     call mask_entry;			/* OK to scan if returned code = 0 */
      990 						/* no refl entry required, since deletion is irreversible */
      991 						/* until index changes supported under TP, however, there is still
      992*						   the reversible deletion of pre-created records to be considered */
      993 	     if code ^= 0				/* can't scan--just return with error */
      994 	     then return;				/* abort */
      995 						/* otherwise block_ptr will necessarily be null */
      996 	  end;					/* fall through case scans next entry */
      997       end;					/* scan over logically masked or deleted entries */
      998 
      999       return;					/* end of main get_reclp routine */
     1000 
     1001 mask_entry:
     1002    proc;						/* takes care of scanning and cleanup */
     1003 						/* returns either with a non-zero code or null block_ptr */
     1004       if ^scan					/* don't scan--return no_record error */
     1005       then
     1006          do;					/* still may clean up one entry, though */
     1007 	  if ^indx_cb.is_read_only & indx_cb.stat & (block_ptr ^= null)
     1008 						/* OK to collect */
     1009 	  then
     1010 	     do;
     1011 	        if indx_cb.outside_index
     1012 	        then if (ref_cnt > 0) | passive		/* nothing can be collected now */
     1013 		   then
     1014 		      do;				/* return immediately */
     1015 		         code = error_table_$no_record;
     1016 		         return;
     1017 		      end;
     1018 		   else threshold = 0;		/* garbage collection threshold */
     1019 	        else threshold = 1;			/* can delete one key along with the record */
     1020 	        call collect_item;			/* may delete key and/or record */
     1021 	     end;
     1022 	  code = error_table_$no_record;		/* warn user record is absent */
     1023 	  return;					/* done with non-scanning case */
     1024          end;
     1025       if block_ptr ^= null				/* may have to clean up */
     1026       then
     1027          do;					/* end up with null block_ptr */
     1028 	  if ^indx_cb.is_read_only & indx_cb.stat	/* may collect item */
     1029 	  then
     1030 	     do;
     1031 	        threshold = 1;			/* only delete key for larger ref counts */
     1032 	        call collect_item;
     1033 	        indx_cb.outside_index = "0"b;		/* in case only the key was deleted */
     1034 	     end;
     1035 	  else if indx_cb.skip_state >= 0
     1036 	  then indx_cb.next_record_position = 2;
     1037 	  block_ptr = null;				/* allow scanning to continue if final code is zero */
     1038 	  lock_ptr = null;
     1039          end;
     1040       else if indx_cb.skip_state >= 0
     1041       then indx_cb.next_record_position = 2;		/* advance */
     1042       if (indx_cb.skip_state < 0)			/* scan backwards */
     1043       then if indx_cb.next_record_position = 2		/* staggerred next and current */
     1044 	 then
     1045 	    do;					/* reset next to current--must exist */
     1046 	       indx_cb.next_record_position = 1;
     1047 	       indx_cb.current_descrip = record_designator (branch_num);
     1048 	       code = 0;				/* clear any old code */
     1049 	       return;				/* backward scan continues successfully */
     1050 	    end;
     1051 	 else call backspace;			/* also sets code */
     1052       else call find_next_record;			/* scan forward--also sets code */
     1053       if code = 0					/* did not run into either end of file */
     1054       then
     1055          do;					/* see if code must be set */
     1056 	  if current_retry_loc = seek_retry
     1057 	  then if key = substr (keys, key_pos (branch_num), get_key_length ())
     1058 	       then return;				/* OK to check this entry--key matches */
     1059 	       else ;				/* fall through complains about no_record error */
     1060 	  else if indx_cb.skip_state > 0		/* follows seek_head */
     1061 	  then if substr (indx_cb.new_key, 1, indx_cb.skip_state)
     1062 		= substr (keys, key_pos (branch_num), min (get_key_length (), indx_cb.skip_state))
     1063 						/* head still matches that of prior seek_head */
     1064 	       then return;				/* OK to continue search for record with this descrip */
     1065 	       else ;				/* fall through and complain */
     1066 	  else return;				/* previous entry obtained without eof error */
     1067 	  code = error_table_$no_record;		/* complain */
     1068          end;					/* fall through resets skip state */
     1069       else if (current_retry_loc = seek_retry) /* called by seek_key */ & (code = error_table_$end_of_info)
     1070       then code = error_table_$no_record;		/* suitable code */
     1071 						/* unable to continue scanning, although permitted */
     1072       indx_cb.skip_state = 0;				/* resume normal scanning forward */
     1073       return;					/* done masking one entry */
     1074 
     1075 collect_item:
     1076    proc;						/* garbage collection routine */
     1077       if indx_cb.trans
     1078       then if (mod > 0) & (mod = current_t_code)		/* locked by this transaction */
     1079 	 then go to handle_pos;			/* don't garbage collect yet */
     1080       if cur_mod = -3				/* special case--means creation in progress */
     1081       then
     1082          do;
     1083 	  call get_lock_status (lock_ptr, er_code);
     1084 	  if er_code ^= error_table_$lock_is_invalid
     1085 	  then go to handle_pos;			/* maybe skip over this entry */
     1086          end;
     1087       if ref_cnt <= threshold				/* record can be removed */
     1088 						/* ref count obtained in set_current_image_info logic */
     1089       then if indx_cb.shared
     1090 	 then if time_stamp + indx_cb.collection_delay_time > clock ()
     1091 	      then go to handle_pos;			/* just skip over entry if scanning */
     1092       if indx_cb.shared
     1093       then indx_cb.shared = ^indx_cb.leave_locked & ^i_locked_file;
     1094       else saved_state.skip_state = indx_cb.skip_state;
     1095       indx_cb.is_sequential_open = "1"b;
     1096       if ref_cnt <= threshold				/* OK to dispose of stationary header */
     1097       then call delete_indx_file (iocb_ptr, er_code);
     1098       else call control_indx_file (iocb_ptr, "delete_key", null, er_code);
     1099       if indx_cb.mode < 11
     1100       then indx_cb.is_sequential_open = "1"b;
     1101       else indx_cb.is_sequential_open = "0"b;
     1102       indx_cb.skip_state = saved_state.skip_state;
     1103       indx_cb.shared = saved_state.shared;
     1104       pos_ptr = indx_cb.file_position_ptr;		/* because of intervening external vfile_ calls */
     1105       return;					/* item collected */
     1106 handle_pos:
     1107       if scan & (indx_cb.skip_state >= 0)
     1108       then indx_cb.next_record_position = 2;		/* skip over entry */
     1109       dcl	    er_code	       fixed (35);
     1110    end collect_item;
     1111 
     1112       dcl	    threshold	       fixed (34);
     1113    end mask_entry;
     1114 
     1115 inspect_non_stat_rec:
     1116    proc;						/* examines a non-stationary record */
     1117       blksz = block_ptr -> record_block.block_size;
     1118       max_rec_wds = blksz - 2;
     1119       if (blksz > divide (length (block_ptr -> record_block.record) + 11, 4, 19, 0))
     1120       then lock_ptr = addr (block_ptr -> non_stat_struct.record_lock);
     1121 						/* room for lock at tail of block */
     1122       else lock_ptr = null;				/* no room for separate record lock */
     1123       if indx_cb.trans				/* transaction mode--error--record must be stationary */
     1124       then code = error_table_$no_room_for_lock;		/* rec header too small */
     1125       else if lock_ptr = null				/* can't touch lock */
     1126       then if passive
     1127 	 then if block_ptr -> record_block.lock_flag
     1128 	      then call get_lock_status (addr (file_base_ptr -> file_base.lock_word), code);
     1129 	      else code = 0;
     1130 	 else code = 0;				/* no lock to set--treat as successful */
     1131       else if ^passive				/* wants to lock--file must first be locked */
     1132       then if indx_cb.shared & ^indx_cb.leave_locked & ^i_locked_file
     1133 						/* I haven't locked */
     1134 	 then
     1135 	    do;					/* file must first be locked to lock non-stat record */
     1136 	       call lock_file_check;			/* may adjust the file */
     1137 						/* aborts if file busy or unrecoverable */
     1138 	       go to retry_loc (current_retry_loc);	/* try again with file locked */
     1139 	    end;					/* never lock non-stationary record without first locking file */
     1140 	 else
     1141 	    do;					/* try to lock the record */
     1142 	       call compute_time_left;
     1143 	       if ^(lock_ptr -> based_lock = indx_cb.saved_lock_copy)
     1144 	       then cleanup_flags = cleanup_flags | (i_locked_mask & rec_lock_mask);
     1145 	       call set_lock (lock_ptr, time_left, code); /* really shouldn't
     1146*						   wait with file locked in all cases */
     1147 	       if code ^= 0				/* lock was set */
     1148 	       then if (code = error_table_$locked_by_this_process) | (code = error_table_$invalid_lock_reset)
     1149 						/* not fatal */
     1150 		  then if ^block_ptr -> record_block.lock_flag
     1151 						/* record is valid */
     1152 		       then
     1153 			do;
     1154 			   code = 0;
     1155 			   cleanup_flags = cleanup_flags | (i_locked_mask & rec_lock_mask);
     1156 			end;
     1157 		       else ;			/* locking was complete */
     1158 		  else if code = error_table_$lock_wait_time_exceeded
     1159 		  then code = error_table_$record_busy; /* appropriate code */
     1160 	    end;					/* done with locking attempt */
     1161       else if block_ptr -> record_block.lock_flag		/* may be busy */
     1162       then call get_lock_status (lock_ptr, code);		/* sets code without locking */
     1163       else code = 0;				/* contents must be valid */
     1164       record_ptr = addr (block_ptr -> record_block.record);
     1165       record_len = length (record_ptr -> based_vstring);
     1166       if current_retry_loc = read_retry			/* contents also wanted */
     1167       then call return_contents;
     1168       dcl	    blksz		       fixed (19);
     1169    end inspect_non_stat_rec;
     1170 
     1171 inspect_stat_record:
     1172    proc;						/* looks at a stationary record */
     1173       lock_ptr = addr (block_ptr -> stat_struct.record_lock);
     1174       if passive					/* just obtaining status--not locking */
     1175       then
     1176          do while ("1"b);				/* loop for asynch changes */
     1177 keep_loopin:
     1178 	  call get_current_image_info;
     1179 	  if code ^= 0				/* fatal error at this point */
     1180 	  then if code ^= error_table_$higher_inconsistency
     1181 	       then return;				/* abort immediately */
     1182 	       else
     1183 		do;				/* maybe waiting will help */
     1184 		   call get_lock_status (lock_ptr, code);
     1185 		   if code ^= error_table_$record_busy	/* not other
     1186*						   live process--no point waiting */
     1187 		   then
     1188 		      do;
     1189 		         code = error_table_$higher_inconsistency;
     1190 		         return;			/* warn user that he can't get valid image */
     1191 		      end;
     1192 		   mics_left = timeout - clock ();
     1193 		   if mics_left <= 0		/* no time to wait */
     1194 		   then return;
     1195 		   call timer_manager_$sleep (min (50000, mics_left), "10"b);
     1196 		   code = 0;			/* set up for another try */
     1197 		   go to keep_loopin;
     1198 		end;
     1199 	  if ind_desc = -1				/* logically deleted */
     1200 	  then
     1201 	     do;					/* return immediately */
     1202 	        rec_deleted = "1"b;
     1203 	        if cur_mod ^= -3			/* still must take care or ref list */
     1204 	        then return;			/* may continue scanning */
     1205 	     end;
     1206 	  else if ind_desc = -2			/* means that before image applies */
     1207 	  then if block_ptr -> record_block.indirect
     1208 	       then ind_desc = block_ptr -> ind_struct.prev_desc;
     1209 	       else ind_desc = indx_cb.current_descrip;	/* compact case */
     1210 	  if mod = 0				/* may need lock status to warn user */
     1211 	  then if block_ptr -> record_block.lock_flag
     1212 	       then call get_lock_status (lock_ptr, code);
     1213 	  if indx_cb.shared & indx_cb.trans /* reference within a transaction */
     1214 	     & ((code = 0) | (code = error_table_$locked_by_this_process) | (code = error_table_$lock_is_invalid))
     1215 	  then
     1216 	     do;					/* take care of reference list */
     1217 	        if current_t_code = 0			/* no transaction number assigned yet */
     1218 	        then call get_t_code;			/* assigns a code or aborts if unable */
     1219 	        if (mod ^= current_t_code)		/* not already locked by this transaction */
     1220 	        then call set_ref_list_entry (block_ptr); /* detects invalid prior ref */
     1221 	     end;
     1222 	  call set_stat_reclp;			/* ptr to stationary rec contents */
     1223 	  if current_retry_loc = read_retry
     1224 	  then call return_contents;
     1225 	  if fixed (time_stamp_struct.time_last_modified) = time_stamp
     1226 	  then return;
     1227 	  if clock () > timeout
     1228 	  then
     1229 	     do;
     1230 	        code = error_table_$record_busy;
     1231 	        return;
     1232 	     end;
     1233          end;					/* loop until record snapshot passively obtained */
     1234       else
     1235          do;					/* lock the record and look at its header */
     1236 reattempt:					/* retry point for post-adjustment case */
     1237 	  call compute_time_left;
     1238 	  if ^(lock_ptr -> based_lock = indx_cb.saved_lock_copy)
     1239 	  then cleanup_flags = cleanup_flags | (i_locked_mask & rec_lock_mask);
     1240 	  call set_lock (lock_ptr, time_left, code);
     1241 	  er_code = code;				/* save returned code giving lock status */
     1242 	  call get_current_image_info;
     1243 	  if code ^= 0				/* lock was non-zero */
     1244 	  then if code = error_table_$higher_inconsistency
     1245 	       then
     1246 		do;
     1247 		   if er_code = error_table_$locked_by_this_process
     1248 		   then code = error_table_$record_busy;/* suppress attempt to unlock record */
     1249 		   else if stacq (lock_ptr -> based_lock, (36)"1"b, indx_cb.saved_lock_copy)
     1250 		   then ;				/* invalidate the lock again */
     1251 		   return;			/* abort--fatal error */
     1252 		end;
     1253 	       else if code = error_table_$lock_wait_time_exceeded
     1254 	       then
     1255 		do;				/* abort with suitable code */
     1256 		   code = error_table_$record_busy;
     1257 		   return;
     1258 		end;
     1259 	       else if mod = 0			/* see if warning required */
     1260 	       then if block_ptr -> record_block.lock_flag
     1261 		  then ;				/* leave code non-zero as a warning */
     1262 		  else
     1263 		     do;
     1264 		        code = 0;
     1265 		        cleanup_flags = cleanup_flags | (i_locked_mask & rec_lock_mask);
     1266 						/* permit unlocking */
     1267 		     end;
     1268 	       else if code = error_table_$locked_by_this_process
     1269 	       then if ^(indx_cb.trans)
     1270 		  then
     1271 		     do;				/* abort with suitable code */
     1272 		        code = error_table_$record_busy;/* fatal error */
     1273 		        return;			/* not locked by own transaction */
     1274 		     end;
     1275 		  else if (mod = current_t_code)
     1276 		  then code = 0;			/* suppress warning--already locked by this trans */
     1277 		  else
     1278 		     do;				/* abort with suitable code */
     1279 		        code = error_table_$record_busy;/* fatal error */
     1280 		        return;			/* not locked by own transaction */
     1281 		     end;
     1282 	       else
     1283 		do;				/* adjust record left locked by dead process */
     1284 		   call adjust_record (iocb_ptr, indx_cb.current_descrip, cur_mod, code);
     1285 		   call check_code (code, "Can't adjust a record locked by dead process.");
     1286 		   go to reattempt;			/* adjustment ends by unlocking--do again */
     1287 		end;
     1288 	  if ind_desc = -1				/* logically deleted record */
     1289 	  then if cur_mod = -3			/* new record this transaction */
     1290 	       then if mod = 0			/* this operation is creating */
     1291 		  then ind_desc = indx_cb.current_descrip;
     1292 		  else rec_deleted = "1"b;
     1293 	       else
     1294 		do;				/* not a pre-creation case */
     1295 		   rec_deleted = "1"b;
     1296 		   if block_ptr -> stat_struct.modifier = 0
     1297 		   then
     1298 		      do;				/* mark vfile_ operation in progress */
     1299 		         cleanup_flags = cleanup_flags | (i_locked_mask & negmod_mask);
     1300 						/* set bit indicating modifier set */
     1301 		         block_ptr -> stat_struct.modifier = -1;
     1302 		      end;
     1303 		   go to adjust_ref_count;		/* suppress ref list manipulation */
     1304 		end;
     1305 	  if indx_cb.trans				/* modification inside a transaction */
     1306 	  then
     1307 	     do;
     1308 	        if current_t_code = 0
     1309 	        then call get_t_code;
     1310 	        if mod ^= current_t_code		/* not already locked by this transaction */
     1311 	        then
     1312 		 do;				/* take care of ref list */
     1313 		    if block_ptr -> stat_struct.prev_mod = -3
     1314 						/* new record */
     1315 		    then call add_lock_list_entry (block_ptr, cleanup_flags & passive_ref_bit_mask);
     1316 						/* no need to verify this reference */
     1317 		    else
     1318 		       do;
     1319 			call set_lock_list_entry (block_ptr, cleanup_flags & passive_ref_bit_mask);
     1320 						/* check for prior passive ref */
     1321 			if (code ^= 0) & (code ^= error_table_$locked_by_this_process)
     1322 			   & (code ^= error_table_$invalid_lock_reset)
     1323 						/* fatal error */
     1324 			then return;		/* abort */
     1325 			block_ptr -> stat_struct.ind_comp = -1;
     1326 			time_stamp_struct.ind_offset = (17)"1"b;
     1327 						/* after descrip= -2 */
     1328 			block_ptr -> stat_struct.ref_count_after = ref_cnt;
     1329 						/* indicates after image initially same as before--special case */
     1330 		       end;
     1331 		    block_ptr -> stat_struct.modifier = current_t_code;
     1332 		    call set_stat_reclp;
     1333 		    ind_desc = -2;
     1334 		 end;
     1335 	        else if ind_desc = -2			/* before image applies */
     1336 	        then
     1337 		 do;
     1338 		    if block_ptr -> record_block.indirect
     1339 		    then ind_desc = block_ptr -> ind_struct.prev_desc;
     1340 		    else ind_desc = indx_cb.current_descrip;
     1341 		    call set_stat_reclp;
     1342 		    ind_desc = -2;
     1343 		 end;
     1344 	        else call set_stat_reclp;
     1345 	     end;
     1346 	  else
     1347 	     do;					/* initialize header for non-TP modification */
     1348 	        cleanup_flags = cleanup_flags | (i_locked_mask & negmod_mask);
     1349 						/* leave record locked but still need to zero modifier */
     1350 	        block_ptr -> stat_struct.modifier = -1;	/* non-TP operation in progress */
     1351 	        call set_stat_reclp;
     1352 	     end;
     1353 adjust_ref_count:
     1354 	  if ref_count_change < 0			/* decrementing */
     1355 	  then
     1356 	     do;					/* check lower limit constraint */
     1357 	        if rec_deleted			/* logically absent */
     1358 	        then min_ref_count = 0;		/* zero references permitted--can clean up */
     1359 	        else min_ref_count = 1;		/* not deleted--at least one ref must remain */
     1360 	        if ref_cnt + ref_count_change < min_ref_count
     1361 	        then
     1362 		 do;				/* abort */
     1363 		    code = error_table_$last_reference;
     1364 		    return;			/* suppress changing ref count below minimum */
     1365 		 end;
     1366 	     end;
     1367 	  else if ref_cnt + ref_count_change > max_ref_count
     1368 	  then
     1369 	     do;
     1370 	        code = error_table_$too_many_refs;
     1371 	        return;
     1372 	     end;
     1373 	  ref_cnt = ref_cnt + ref_count_change;
     1374 	  if rec_deleted & ^is_read_only & (ref_count_change ^= 0) & (block_ptr -> stat_struct.modifier = -1)
     1375 						/* record_status ref_count
     1376*						   change on a deleted record */
     1377 	  then
     1378 	     do;
     1379 	        block_ptr -> stat_struct.ref_count_after = ref_cnt;
     1380 	        block_ptr -> stat_struct.ref_count = ref_cnt;
     1381 	     end;					/* permits garbage collection of unkeyed records */
     1382          end;					/* lock is now set */
     1383       return;					/* end of main stat rec inspection routine */
     1384 
     1385 get_current_image_info:
     1386    proc;						/* same as set_current_image_info, except
     1387*						   that it checks for the case of an item that may have already been modified by this transaction */
     1388       mod = block_ptr -> stat_struct.modifier;
     1389       if (mod <= 0) | ^indx_cb.trans
     1390       then call set_current_image_info;
     1391       else if (mod = current_t_code)			/* own transaction */
     1392       then
     1393          do;					/* get after image info */
     1394 	  time_stamp = fixed (time_stamp_struct.time_last_modified);
     1395 	  cur_mod = mod;
     1396 	  ind_des.comp = stat_struct.ind_comp;
     1397 	  ind_des.offset = time_stamp_struct.ind_offset;
     1398 	  ref_cnt = stat_struct.ref_count_after;
     1399          end;
     1400       else call set_current_image_info;			/* handle any other case but own transaction */
     1401    end get_current_image_info;
     1402 
     1403 set_stat_reclp:
     1404    proc;
     1405       if ind_desc > 0				/* record allocation exists */
     1406       then
     1407          do;
     1408 	  if ind_desc = indx_cb.current_descrip		/* compact case */
     1409 	  then
     1410 	     do;
     1411 	        max_rec_wds = block_ptr -> record_block.block_size - stat_header_size;
     1412 	        record_ptr = addr (block_ptr -> stat_struct.record);
     1413 	     end;
     1414 	  else
     1415 	     do;
     1416 	        p = get_pointer (ind_desc);
     1417 	        max_rec_wds = p -> record_block.block_size - 2;
     1418 	        record_ptr = addr (p -> record_block.record);
     1419 	     end;
     1420 	  record_len = length (record_ptr -> based_vstring);
     1421          end;
     1422       dcl	    p		       ptr;
     1423    end set_stat_reclp;
     1424 
     1425       dcl	    er_code	       fixed (35);
     1426       dcl	    min_ref_count	       fixed;
     1427       dcl	    mics_left	       fixed (71);
     1428    end inspect_stat_record;
     1429 
     1430 return_contents:
     1431    proc;						/* gets record contents for read_record */
     1432       if record_len > 0
     1433       then if record_len <= buff_len
     1434 	 then buffer = substr (record_ptr -> based_vstring, 1, record_len);
     1435 	 else
     1436 	    do;
     1437 	       if buff_len > 0
     1438 	       then substr (buffer, 1, buff_len) = substr (record_ptr -> based_vstring, 1, buff_len);
     1439 	       code = error_table_$long_record;
     1440 	    end;
     1441    end return_contents;
     1442 
     1443 get_t_code:
     1444    proc;						/* initializes the current transaction */
     1445       call transaction_call_$assign (indx_cb.tcfp, 0, er_code);
     1446 						/* creates
     1447*						   a unique tcf entry for this transaction */
     1448       call check_code (er_code, "Unable to assign a transaction number to the current transaction.");
     1449       dcl	    er_code	       fixed (35);
     1450    end get_t_code;
     1451 
     1452 get_lock_status:
     1453    proc (lockp, er_code);
     1454       lock_copy = lockp -> based_lock;
     1455       call set_lock (addr (lock_copy), 0, er_code);
     1456       if er_code = 0
     1457       then return;
     1458       if er_code = error_table_$lock_wait_time_exceeded
     1459       then er_code = error_table_$record_busy;
     1460       else if er_code = error_table_$invalid_lock_reset
     1461       then er_code = error_table_$lock_is_invalid;
     1462       dcl	    lockp		       ptr;
     1463       dcl	    er_code	       fixed (35);
     1464       dcl	    lock_copy	       bit (36) aligned;
     1465    end get_lock_status;
     1466 
  1     1 set_current_image_info:
  1     2      proc;					/* passively determines the transaction code
  1     3*						   and indirect descriptor which currently apply to this record */
  1     4 						/* The validity of this algorithm while records are subject to asynch
  1     5*						   changes is guaranteed by the strict observance of a standard modification
  1     6*						   protocol */
  1     7 
  1     8 	do while ("1"b);				/* loops on detecting asynch changes */
  1     9 	     time_stamp = fixed (time_stamp_struct.time_last_modified);
  1    10 						/* to detect asynch change */
  1    11 	     cur_mod = stat_struct.prev_mod;
  1    12 	     ref_cnt = block_ptr -> stat_struct.ref_count;
  1    13 	     if cur_mod = -3			/* creation in progress */
  1    14 	     then ind_desc = -1;
  1    15 	     else if block_ptr -> record_block.indirect
  1    16 	     then ind_desc = ind_struct.prev_desc;
  1    17 	     else if block_ptr -> record_block.after_applies
  1    18 	     then do;
  1    19 		     ind_des.comp = stat_struct.ind_comp;
  1    20 		     ind_des.offset = time_stamp_struct.ind_offset;
  1    21 		     mod = stat_struct.modifier;
  1    22 		     cur_mod = mod;
  1    23 		     ref_cnt = stat_struct.ref_count_after;
  1    24 		     go to check_time;		/* validate snapshot */
  1    25 		end;
  1    26 	     else ind_desc = current_descrip;		/* compact case */
  1    27 	     mod = stat_struct.modifier;
  1    28 	     if block_ptr -> record_block.lock_flag	/* before image may not be valid */
  1    29 	     then if mod > 0			/* transaction may be in progress on this record */
  1    30 		then if mod ^= cur_mod		/* before and after are different */
  1    31 		     then do;
  1    32 			     new_ind_des.comp = stat_struct.ind_comp;
  1    33 			     new_ind_des.offset = time_stamp_struct.ind_offset;
  1    34 			     if cur_mod = stat_struct.prev_mod
  1    35 						/* in case of asynch change */
  1    36 			     then do;		/* must look in tcf to see which applies */
  1    37 				     if ^transaction/* no tcf available */
  1    38 				     then do;	/* abort with non-zero code */
  1    39 					     code = error_table_$higher_inconsistency;
  1    40 						/* can't tell which image
  1    41*						   is the one to use */
  1    42 					     return;
  1    43 						/* abort */
  1    44 					end;
  1    45 				     unspec (gk_inf.flags) = "0"b;
  1    46 				     gk_inf.input_key = "1"b;
  1    47 				     gk_inf.key_len = 4;
  1    48 				     gk_inf.head_size = 4;
  1    49 				     gk_key = mod;	/* current transaction using this record */
  1    50 				     call iox_$control (tcfp, "get_key", addr (gk_inf), er_code);
  1    51 				     if er_code = 0
  1    52 				     then if gk_inf.descrip = -1
  1    53 						/* past checkpoint */
  1    54 					then do;	/* use after image info */
  1    55 						cur_mod = mod;
  1    56 						ind_desc = new_ind_desc;
  1    57 						ref_cnt = stat_struct.ref_count_after;
  1    58 						return;
  1    59 						/* done */
  1    60 					     end;
  1    61 					else ;
  1    62 				     else if er_code = error_table_$no_key
  1    63 				     then code = error_table_$higher_inconsistency;
  1    64 				end;
  1    65 			end;
  1    66 	     if cur_mod = stat_struct.prev_mod		/* same as at previous reference */
  1    67 	     then if cur_mod > 0			/* modifier is unique for this record image */
  1    68 		then return;
  1    69 		else do;
  1    70 check_time:
  1    71 			if fixed (time_stamp_struct.time_last_modified) = time_stamp
  1    72 			then return;		/* will use time_stamp for verification */
  1    73 		     end;
  1    74 	     if clock () > timeout			/* time limit is exhausted */
  1    75 	     then do;
  1    76 		     code = error_table_$record_busy;
  1    77 		     return;
  1    78 		end;
  1    79 	end;					/* keep trying until reference succeeds */
  1    80 
  1    81 	dcl     er_code		 fixed (35);
  1    82 	dcl     1 new_ind_des	 based (addr (new_ind_desc)),
  1    83 		2 comp		 fixed (17) unal,
  1    84 		2 offset		 bit (18) unal;
  1    85 	dcl     new_ind_desc	 fixed (35);
  1    86 	dcl     gk_key		 fixed (35) based (addr (gk_inf.key));
  1    87 	dcl     1 gk_inf,
  1    88 		2 header		 like gk_header,
  1    89 		2 key		 char (4);
  1    90      end set_current_image_info;
  1    91 
  1    92      dcl	   1 ind_des	      like ind_des_structure based (addr (ind_desc));
  1    93      dcl	   1 stat_struct	      like stat_structure based (block_ptr);
  1    94      dcl	   1 ind_struct	      like ind_structure based (block_ptr);
  1    95      dcl	   1 time_stamp_struct    like time_stamp_structure based (addr (stat_struct.time_stamp_words));
  1    96      dcl	   1 record_block	      like record_block_structure based (block_ptr);
     1467 
     1468       dcl	    1 non_stat_struct      based (block_ptr),
     1469 	      2 words	       (record_block.block_size - 1),
     1470 	      2 record_lock	       bit (36) aligned;
     1471       dcl	    scan		       bit (1) aligned;
     1472       dcl	    passive	       bit (1) aligned;
     1473       dcl	    ref_count_change       fixed;
     1474       dcl	    (lock_ptr, block_ptr)  ptr;
     1475       dcl	    i_locked_mask	       bit (36) aligned;
     1476    end lock_current_record;
     1477 
     1478 check_subset:
     1479    proc (descrip);					/* sees if descriptor has been excluded */
     1480       temp_cbp = indx_cb.temp_iocbp -> iocb.open_data_ptr;
     1481       temp_cbp -> indx_cb.file_position_ptr = temp_cbp -> indx_cb.root_position_ptr;
     1482       subset_key = current_subset_bytes || descrip_bytes;
     1483       call find_key (temp_cbp, (addr (subset_key)), search_code);
     1484       if indx_cb.subset_selected = "10"b
     1485       then if search_code = 0
     1486 	 then rec_deleted = "1"b;
     1487 	 else rec_deleted = "0"b;
     1488       else if search_code ^= 0
     1489       then rec_deleted = "1"b;
     1490       else rec_deleted = "0"b;			/* verbose form to avoid operator call */
     1491       dcl	    descrip	       fixed (35);
     1492       dcl	    descrip_bytes	       char (4) based (addr (descrip));
     1493       dcl	    temp_cbp	       ptr;
     1494       dcl	    current_subset_bytes   char (4) based (addr (indx_cb.current_subset));
     1495       dcl	    search_code	       fixed (35);
     1496       dcl	    subset_key	       char (8) var;
     1497    end check_subset;
     1498 
     1499 gk_scan:
     1500    proc;						/* called by get_key to find satisfactory descriptor */
     1501       if ^gk_inf.input_desc
     1502       then if gk_inf.desc_code = 0
     1503 	 then desc_known = "0"b;
     1504 	 else desc_known = "1"b;
     1505       else desc_known = "1"b;
     1506       if desc_known
     1507       then
     1508          do;
     1509 	  if gk_inf.input_desc
     1510 	  then wanted_desc = gk_inf.descrip;
     1511 	  else wanted_desc = indx_cb.current_descrip;
     1512 	  if indx_cb.subset_selected ^= "00"b
     1513 	  then
     1514 	     do;
     1515 	        call check_subset (wanted_desc);
     1516 	        if rec_deleted
     1517 	        then
     1518 		 do;
     1519 		    if ^gk_inf.reset_pos
     1520 		    then indx_cb.at_bof, indx_cb.at_eof = "0"b;
     1521 		    go to norec;			/* logically absent record */
     1522 		 end;
     1523 	     end;
     1524          end;
     1525       else if indx_cb.subset_selected = "00"b		/* any entry will do */
     1526       then return;					/* current position is satisfactory */
     1527       reset_position = gk_inf.reset_pos;
     1528       go to scan_loop;				/* skip setup code for seek_head scan */
     1529 
     1530 sh_scan:
     1531    entry;						/* handles scanning for seek_head */
     1532       desc_known = "0"b;
     1533       reset_position = "0"b;
     1534 
     1535 scan_loop:
     1536       do while ("1"b);
     1537          descrip = record_designator (branch_num);
     1538          if desc_known
     1539          then if descrip = wanted_desc
     1540 	    then return;				/* desired descriptor found */
     1541 	    else ;				/* must keep looking--scan */
     1542          else
     1543 	  do;
     1544 	     call check_subset (descrip);
     1545 	     if ^rec_deleted			/* not logically masked by current subset */
     1546 	     then
     1547 	        do;
     1548 		 if ^reset_position
     1549 		 then indx_cb.current_descrip = descrip;/* must be valid for check_current */
     1550 		 return;				/* done with scanning */
     1551 	        end;
     1552 	  end;
     1553          if indx_cb.skip_state < 0			/* scanning backward */
     1554          then
     1555 	  do;
     1556 	     call find_prev_entry;
     1557 	     if branch_num = 1			/* bof */
     1558 	     then
     1559 	        do;
     1560 		 if ^reset_position
     1561 		 then call position_bof;
     1562 norec:
     1563 		 code = error_table_$no_record;	/* abort */
     1564 		 indx_cb.skip_state = 0;		/* resume default forward scanning */
     1565 		 return;				/* stop scanning */
     1566 	        end;
     1567 	     branch_num = branch_num - 1;
     1568 	  end;
     1569          else
     1570 	  do;
     1571 	     branch_num = branch_num + 1;		/* advance one index entry */
     1572 	     call find_this_entry;
     1573 	     if pos_ptr = indx_cb.root_position_ptr	/* eof */
     1574 	     then
     1575 	        do;
     1576 		 if ^reset_position
     1577 		 then call position_eof;
     1578 		 go to norec;
     1579 	        end;
     1580 	     if indx_cb.skip_state > 0
     1581 	     then if substr (keys, key_pos (branch_num), min (key_length (branch_num), indx_cb.skip_state))
     1582 		   > substr (pad_key, 1, indx_cb.skip_state)
     1583 						/* key out of range */
     1584 		then
     1585 		   do;
     1586 		      if ^reset_position
     1587 		      then
     1588 		         do;
     1589 			  indx_cb.next_record_position = 0;
     1590 			  indx_cb.current_record_is_valid = "0"b;
     1591 		         end;
     1592 		      go to norec;
     1593 		   end;
     1594 	  end;
     1595       end;
     1596 
     1597       dcl	    desc_known	       bit (1) aligned;
     1598       dcl	    (wanted_desc, descrip) fixed (35);
     1599       dcl	    reset_position	       bit (1) aligned;
     1600    end gk_scan;
     1601 
     1602 find_next_record:
     1603    proc;
     1604       code = 0;
     1605       if pos_incorrect				/* must restore index pos */
     1606       then
     1607          do;
     1608 	  call restore_position;
     1609 	  if code ^= 0
     1610 	  then return;				/* asynch deletion */
     1611          end;
     1612       else pos_ptr = file_position_ptr;
     1613       indx_cb.ready_to_write = indx_cb.dup_ok;
     1614       indx_cb.outside_index, indx_cb.at_eof, indx_cb.at_bof = "0"b;
     1615 						/* reset if outside */
     1616       indx_cb.current_record_is_valid = "1"b;
     1617       if indx_cb.next_record_position = 1
     1618       then
     1619          do;
     1620 	  if branch_num < last_branch_num
     1621 	  then go to set_current;
     1622          end;
     1623       else if indx_cb.next_record_position = 2
     1624       then
     1625          do;					/* next record follows current position */
     1626 	  branch_num = branch_num + 1;
     1627 	  indx_cb.next_record_position = 1;
     1628          end;
     1629       else
     1630          do;					/* next record is undefined */
     1631 	  code = error_table_$no_record;
     1632 	  indx_cb.current_record_is_valid = "0"b;
     1633 	  indx_cb.ready_to_write = "0"b;
     1634 	  return;
     1635          end;
     1636       call find_this_entry;
     1637       if pos_ptr = root_position_ptr			/* end of file */
     1638       then
     1639          do;
     1640 	  call position_eof;			/* set process info and position */
     1641 	  code = error_table_$end_of_info;
     1642          end;
     1643       else
     1644          do;
     1645 set_current:
     1646 	  indx_cb.current_descrip = record_designator (branch_num);
     1647          end;
     1648    end find_next_record;
     1649 
     1650 find_this_entry:
     1651    proc;						/* routine gets position of following index proc */
     1652       call find_leftmost_descendent;			/* in case we are not at a leaf */
     1653 find_from_leaf:
     1654    entry;
     1655 
     1656 loop:
     1657       if branch_num = last_branch_num
     1658       then if last_branch_num > 1
     1659 	 then
     1660 	    do;
     1661 	       pos_ptr = parent_position_ptr;
     1662 	       go to loop;
     1663 	    end;
     1664 
     1665       file_position_ptr = pos_ptr;
     1666    end find_this_entry;
     1667 
     1668 find_prev_entry:
     1669    proc;						/* routine finds position of preceding index entry */
     1670       call find_rightmost_descendent;			/* in case non-leaf */
     1671 
     1672 loop:
     1673       if branch_num = 1
     1674       then if last_branch_num > 1
     1675 	 then
     1676 	    do;
     1677 	       pos_ptr = parent_position_ptr;		/* position moves to parent node */
     1678 	       go to loop;
     1679 	    end;
     1680 
     1681       file_position_ptr = pos_ptr;
     1682    end find_prev_entry;
     1683 
     1684 backspace:
     1685    proc;						/* moves index position back one, setting code if end of info */
     1686       code = 0;
     1687       if indx_cb.pos_incorrect
     1688       then
     1689          do;
     1690 	  call restore_position;
     1691 	  if code ^= 0
     1692 	  then return;				/* asynch deletion */
     1693          end;
     1694       else pos_ptr = indx_cb.file_position_ptr;
     1695       indx_cb.outside_index = "0"b;
     1696       call find_prev_entry;
     1697       if branch_num = 1				/* beginning of file */
     1698       then
     1699          do;
     1700 	  code = error_table_$end_of_info;
     1701 	  call position_bof;
     1702 	  return;
     1703          end;
     1704       branch_num = branch_num - 1;
     1705       indx_cb.current_descrip = record_designator (branch_num);
     1706    end backspace;
     1707 
     1708 seek_head:
     1709    proc (rel_type, key_ptr, head_len);
     1710       indx_cb.file_position_ptr = indx_cb.root_position_ptr;/* prepare for descent */
     1711       call find_key (indx_cb_ptr, (key_ptr), foo);
     1712       pos_ptr = indx_cb.file_position_ptr;
     1713       call find_from_leaf;				/* in case of match in upper node */
     1714 
     1715       do while (pos_ptr ^= root_position_ptr);
     1716          if substr (key_ptr -> based_vstring, 1, head_len)
     1717 	  = substr (keys, key_pos (branch_num), min (key_length (branch_num), head_len))
     1718 						/* heads match */
     1719          then if rel_type ^= 2			/* that's fine */
     1720 	    then return;				/* satisfactory entry found */
     1721 	    else
     1722 	       do;				/* keep searching forward */
     1723 		branch_num = branch_num + 1;
     1724 		call find_this_entry;		/* handles exceptional cases */
     1725 	       end;
     1726          else if rel_type > 0				/* looking for larger head--fine */
     1727          then return;				/* search done */
     1728          else pos_ptr = root_position_ptr;		/* causes exit from loop */
     1729       end;
     1730 
     1731       dcl	    rel_type	       fixed;
     1732       dcl	    key_ptr	       ptr;
     1733       dcl	    head_len	       fixed;
     1734    end seek_head;
     1735 
     1736 get_pointer:
     1737    proc (descrip) returns (ptr);
     1738       if descrip < 4096
     1739       then return (null);
     1740       if (desc.comp_num >= 0) & (desc.comp_num <= indx_cb.old_last_comp_num)
     1741 						/* in case shared and unlocked */
     1742       then if seg_ptr_array (desc.comp_num) = null
     1743 	 then p = get_seg_ptr (iocb_ptr, (desc.comp_num));
     1744 	 else ;					/* fall through */
     1745       else call check_code (error_table_$bad_arg, "Invalid msf component.");
     1746       return (get_ptr (descrip));
     1747       dcl	    p		       ptr;
     1748       dcl	    descrip	       fixed (35);
     1749       dcl	    1 desc	       aligned based (addr (descrip)),
     1750 	      2 comp_num	       fixed (17) unal,
     1751 	      2 offset	       bit (18) unal;
     1752    end get_pointer;
     1753 
     1754 get_key_length:
     1755    proc returns (fixed);
     1756       len = key_length (branch_num);
     1757       if indx_cb.min_key_len <= 0			/* keys never padded with blanks */
     1758       then return (len);
     1759       if len = indx_cb.min_key_len
     1760       then
     1761          do;
     1762 	  tail_len = verify (reverse (substr (keys, key_pos (branch_num), len)), " ") - 1;
     1763 	  if tail_len < 0
     1764 	  then tail_len = len;
     1765 	  len = len - tail_len;
     1766          end;
     1767       return (len);
     1768 
     1769       dcl	    len		       fixed;
     1770       dcl	    tail_len	       fixed;
     1771    end;						/* end get_key_length */
     1772 
     1773 compare_last_key:
     1774    proc (key);					/* used to verify key order in kso openings */
     1775       key_is_dup = "0"b;				/* will be set if user seeks last key in file */
     1776       if last_branch_num > 1				/* file not empty */
     1777       then if key <= substr (keys, key_pos (last_branch_num - 1), key_length (last_branch_num - 1))
     1778 	 then
     1779 	    do;					/* key not larger--maybe dup */
     1780 	       code = error_table_$key_order;
     1781 	       if key = substr (keys, key_pos (last_branch_num - 1), key_length (last_branch_num - 1))
     1782 	       then key_is_dup = "1"b;
     1783 	    end;
     1784       dcl	    key		       char (256) var;
     1785    end compare_last_key;
     1786 
     1787 check_rs_args:
     1788    proc;						/* routine validates args to the "record_status" order */
     1789       rs_info_ptr = info_ptr;
     1790       if (rs_info.version < rs_info_version_1) | (rs_info.version > rs_info_version_2)
     1791 						/* only versions currently supported */
     1792       then code = error_table_$unimplemented_version;
     1793       else if indx_cb.trans & rs_info.unlock_sw & ^rs_info.unlock_sw
     1794 						/* no unlocking under -trans */
     1795       then code = error_table_$no_operation;
     1796       else
     1797          do;					/* keep checking */
     1798 						/* unlocking is treated passively, as far as synchronization is concerned */
     1799 	  passive_op = ^(rs_info.create_sw | rs_info.lock_sw | rs_info.inc_ref_count | rs_info.dec_ref_count);
     1800 	  if (^passive_op | rs_info.unlock_sw) & is_read_only
     1801 						/* need write access */
     1802 	  then code = error_table_$no_operation;
     1803 	  else
     1804 	     do;
     1805 	        if rs_info.create_sw
     1806 	        then if max (rs_info.max_rec_len, rs_info.record_length) > max_record_size
     1807 		   then code = error_table_$long_record;
     1808 		   else if indx_cb.subset_selected = "10"b
     1809 						/* pure selection in effect */
     1810 		   then code = error_table_$no_record;
     1811 		   else if rs_info.dec_ref_count & ^rs_info.inc_ref_count
     1812 		   then code = error_table_$last_reference;
     1813 						/* error--ref count too small */
     1814 		   else if ^rs_info.lock_sw
     1815 		   then if rs_info.unlock_sw
     1816 		        then code = error_table_$lock_not_locked;
     1817 		        else ;
     1818 		   else if ^indx_cb.shared
     1819 		   then if ^indx_cb.stat & ^rs_info.inc_ref_count & ^rs_info.dec_ref_count
     1820 		        then
     1821 			 do;
     1822 			    recl = max (0, rs_info.record_length);
     1823 			    capacity = max (min_max_rec_len, recl, rs_info.max_rec_len);
     1824 			    if rs_info.max_rec_len <= 0
     1825 			    then capacity = max (capacity, indx_cb.min_cap, recl + indx_cb.min_res);
     1826 			    if capacity - recl < 4
     1827 			    then code = error_table_$no_room_for_lock;
     1828 			 end;
     1829 		        else ;
     1830 		   else ;
     1831 	        else
     1832 		 do;				/* non-creation case */
     1833 		    if rs_info.locate_sw		/* descriptor is input arg */
     1834 		    then if (addr (rs_info.descriptor) -> rs_desc.comp_num <= 0)
     1835 						/* invalid component number */
     1836 		         then code = error_table_$no_record;
     1837 		         else /* use input descrip to set current record position */
     1838 			    call make_current (rs_info.descriptor);
     1839 		    if rs_info.inc_ref_count
     1840 		    then if rs_info.dec_ref_count
     1841 		         then delta_ref_count = 0;
     1842 		         else delta_ref_count = 1;
     1843 		    else if rs_info.dec_ref_count
     1844 		    then delta_ref_count = -1;
     1845 		    else delta_ref_count = 0;
     1846 		 end;
     1847 	     end;
     1848          end;
     1849       dcl	    (recl, capacity)       fixed (21);
     1850    end check_rs_args;
     1851 
     1852 record_status:
     1853    proc;						/* routine supports record_status order except for arg checking */
     1854       if rs_info.create_sw				/* create a new record */
     1855       then
     1856          do;
     1857 	  call initialize_substate;			/* prepare file state block */
     1858 	  file_base.new_record_length = max (rs_info.record_length, 0);
     1859 						/* save args for crash recovery */
     1860 	  if rs_info.max_rec_len > 0			/* override default min_block_size settings */
     1861 	  then
     1862 	     do;
     1863 	        file_base.saved_min_cap = max (rs_info.max_rec_len, min_max_rec_len);
     1864 	        file_base.saved_min_res = 0;
     1865 	     end;
     1866 	  else call save_min_blksz_inf;		/* in case of crash */
     1867 	  file_base.out_of_index = rs_info.locate_sw;
     1868 	  if rs_info.locate_sw & ^indx_cb.repeating	/* new rec won't be entered into index with key */
     1869 	  then call set_add_rec_stats;
     1870 	  else call set_add_ent_info ("1"b);		/* prepare to add index entry and new record */
     1871 	  file_base.old_ref_count =
     1872 	     fixed (rs_info.inc_ref_count) - fixed (rs_info.dec_ref_count) + fixed (^rs_info.locate_sw);
     1873 						/* initial ref count desired */
     1874 	  file_base.was_stat = indx_cb.stat | rs_info.inc_ref_count | rs_info.dec_ref_count;
     1875 	  file_action = adding_record;		/* necessary info saved, now alter file */
     1876 	  call change_record_list (iocb_ptr, insert_action, (null), abort_exit);
     1877 						/* create empty record */
     1878 	  file_base.change_count = file_base.old_file_ch_count + 1;
     1879 	  if rs_info.locate_sw			/* don't add index entry */
     1880 	  then call make_current (new_descriptor);	/* set current position to new record */
     1881 	  else
     1882 	     do;					/* place entry into the index */
     1883 	        indx_cb.current_descrip = new_descriptor;
     1884 	        call set_new_record_designator;
     1885 	        call change_index (iocb_ptr, abort_exit); /* does the work */
     1886 	        pos_ptr = file_position_ptr;
     1887 	        call set_post_write_pos;
     1888 	     end;
     1889 	  call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, 0);
     1890 						/* no ref count change */
     1891 	  call set_rs_return_info;			/* fills in info structure */
     1892 	  if (code = 0) | (code = error_table_$locked_by_this_process) /* in case of recovery--can't hurt */
     1893 	     | (code = error_table_$invalid_lock_reset)
     1894 	  then if ^rs_info.lock_sw			/* nothing more to do */
     1895 	       then go to switch_file_state;
     1896 	       else if lock_ptr = null		/* small non-stationary allocation */
     1897 	       then code = error_table_$no_room_for_lock;
     1898 	       else if rs_info.unlock_sw		/* also immediately unlock--silly request when creating */
     1899 	       then go to switch_file_state;
     1900 	       else if indx_cb.trans			/* TP case--leave locked, but no need to set flag */
     1901 	       then go to switch_file_state;
     1902 	       else
     1903 		do;
     1904 		   block_ptr -> record_block.lock_flag = "1"b;
     1905 						/* warn others about image change */
     1906 		   i_locked_rec = "0"b;		/* suppress unlocking this record in unlock_exit */
     1907 		   go to switch_file_state;
     1908 		end;
     1909 	  aborting = "1"b;				/* unexpected error -- file will be adjusted later */
     1910          end;					/* new record created and made current */
     1911       else
     1912          do;					/* non-creation case */
     1913 	  if ^rs_info.locate_sw
     1914 	  then
     1915 	     do;					/* make sure current record is defined */
     1916 	        call check_current;			/* may find next rec if not at current */
     1917 	        if code ^= 0			/* error--current record must be defined */
     1918 	        then return;
     1919 	     end;
     1920 	  if passive_op
     1921 	  then call set_current_reclp (block_ptr, lock_ptr);
     1922 	  else
     1923 	     do;					/* obtain record_ptr non-passively */
     1924 	        call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, delta_ref_count);
     1925 						/* may wait up to wait time limit */
     1926 	        if (code = 0) | (code = error_table_$locked_by_this_process) | (code = error_table_$invalid_lock_reset)
     1927 						/* no fatal errors occurred */
     1928 	        then
     1929 		 do;
     1930 		    if rs_info.lock_sw & ^rs_info.unlock_sw
     1931 		    then if indx_cb.trans		/* transaction case */
     1932 		         then if ind_desc = -2	/* means first modification--after=before */
     1933 			    then
     1934 			       do;		/* initialize after image as copy of before */
     1935 				if indx_cb.shared
     1936 				then indx_cb.shared = ^indx_cb.leave_locked & ^i_locked_file;
     1937 				else saved_state.outside_index = indx_cb.outside_index;
     1938 				indx_cb.outside_index = "1"b;
     1939 						/* prevent rewrite from changing position */
     1940 				call rewrite_indx_file (iocb_ptr, addrel (record_ptr, 1), record_len, er_code);
     1941 						/* should have internal procedure for efficiency */
     1942 				indx_cb.outside_index = saved_state.outside_index;
     1943 						/* restore to prior state */
     1944 				indx_cb.shared = saved_state.shared;
     1945 				if er_code ^= 0
     1946 				then
     1947 				   do;
     1948 				      code = er_code;
     1949 				      call set_rs_return_info;
     1950 				      return;
     1951 				   end;
     1952 				ind_des.comp = stat_struct.ind_comp;
     1953 				ind_des.offset = time_stamp_struct.ind_offset;
     1954 				record_ptr = addrel (get_ptr (ind_desc), 1);
     1955 						/* comp must be known */
     1956 			       end;
     1957 			    else ;		/* already have initialized after image */
     1958 		         else if lock_ptr = null	/* allocation too small for lock in tail */
     1959 		         then code = error_table_$no_room_for_lock;
     1960 		         else
     1961 			  do;			/* just locking, non-TP case */
     1962 			     block_ptr -> record_block.lock_flag = "1"b;
     1963 						/* warn others */
     1964 			     if block_ptr -> record_block.stationary
     1965 						/* record has time_stamp */
     1966 			     then time_stamp_struct.time_last_modified = clock ();
     1967 			     else file_base_ptr -> file_base.change_count =
     1968 				   file_base_ptr -> file_base.change_count + 1;
     1969 			     i_locked_rec = "0"b;	/* suppress unlocking */
     1970 			  end;
     1971 		    if rs_info.inc_ref_count | rs_info.dec_ref_count
     1972 		    then if ^block_ptr -> record_block.stationary
     1973 		         then code = error_table_$no_room_for_lock;
     1974 						/* error really is that rec is non-stationary */
     1975 		         else if indx_cb.trans
     1976 		         then block_ptr -> stat_struct.ref_count_after = ref_cnt;
     1977 		         else block_ptr -> stat_struct.ref_count = ref_cnt;
     1978 		 end;
     1979 	     end;					/* pointer obtained non-passively */
     1980 	  call set_rs_return_info;
     1981          end;					/* end of non-creation case logic */
     1982 
     1983 set_rs_return_info:
     1984    proc;						/* fills in user-supplied info structure */
     1985       rs_info.record_length = record_len;
     1986       rs_info.descriptor = indx_cb.current_descrip;
     1987       if record_ptr = null				/* no record allocation */
     1988       then
     1989          do;
     1990 	  rs_info.record_ptr = null;
     1991 	  rs_info.max_rec_len = 0;
     1992          end;
     1993       else rs_info.record_ptr = addrel (record_ptr, 1);	/* point to contents,
     1994*						   not length word */
     1995       if block_ptr ^= null				/* allocation exists */
     1996       then
     1997          do;					/* get info about block */
     1998 	  if block_ptr -> record_block.stationary
     1999 	  then
     2000 	     do;					/* give stationary record info */
     2001 	        rs_info.ref_count = ref_cnt;
     2002 	        if rs_info.version = rs_info_version_2	/* larger info structure than old one */
     2003 	        then
     2004 		 do;
     2005 		    rs_info.modifier = mod;
     2006 		    rs_info.time_last_modified = time_stamp;
     2007 		    rs_info.last_image_modifier = cur_mod;
     2008 		 end;
     2009 	     end;
     2010 	  if rs_info.version = rs_info_version_2	/* see comment above */
     2011 	  then rs_info.block_ptr = block_ptr;
     2012 	  rs_info.max_rec_len = 4 * max_rec_wds;
     2013          end;
     2014    end set_rs_return_info;
     2015 
     2016       dcl	    er_code	       fixed (35);
     2017    end record_status;
     2018 
     2019 save_correct_pos:
     2020    proc;						/* routine remembers current info so positions can be restored */
     2021       if ^indx_cb.pos_incorrect & (string (indx_cb.at_eof_or_bof) = "00"b) & ^(indx_cb.next_record_position = 0)
     2022       then
     2023          do;
     2024 	  pos_ptr = indx_cb.file_position_ptr;
     2025 	  if branch_num = last_branch_num		/* key may not exist */
     2026 	  then
     2027 	     do;
     2028 	        call find_this_entry;
     2029 	        if pos_ptr = root_position_ptr		/* at end of file */
     2030 	        then
     2031 		 do;				/* set position vars */
     2032 		    call set_at_eof;		/* no need to actually descend now */
     2033 		    indx_cb.current_record_is_valid = indx_cb.outside_index;
     2034 		    pos_incorrect = "1"b;
     2035 		    return;
     2036 		 end;
     2037 	     end;
     2038 	  indx_cb.new_key = substr (keys, key_pos (branch_num), key_length (branch_num));
     2039 	  indx_cb.saved_descrip = record_designator (branch_num);
     2040          end;
     2041    end save_correct_pos;
     2042 
     2043 make_current:
     2044    proc (descrip);					/* routine sets current pos outside index */
     2045       indx_cb.ready_to_write = "0"b;
     2046       indx_cb.current_descrip = descrip;
     2047       indx_cb.outside_index = "1"b;			/* current record moves outside index */
     2048       indx_cb.current_record_is_valid = "1"b;
     2049       dcl	    descrip	       fixed (35);
     2050    end make_current;
     2051 
     2052 set_add_rec_stats:
     2053    proc;						/* prepares statistics indicating successful creation of new record */
     2054       if indx_cb.trans				/* transaction case */
     2055       then return;					/* stats not changed until checkpoint */
     2056       os_ptr -> number_of_records = number_of_records + 1;
     2057       os_ptr -> total_record_length = total_record_length + new_record_length;
     2058    end set_add_rec_stats;
     2059 
     2060 prepare_process:
     2061    proc;						/* used by passive shared operations to set up process vars
     2062*						   and wait for opportunity to look at file */
     2063       if ^i_locked_file & ^leave_locked			/* unlocked between operations */
     2064       then
     2065          do;					/* check for asynch activity */
     2066 	  call check_file_lock;			/* waits till unlocked or time exhausted */
     2067 	  fault_ok = "1"b;				/* fault may reasonably occur because of asynch changes */
     2068 	  if last_change_count ^= new_change_count	/* asynch changes--restore process info */
     2069 	  then
     2070 	     do;
     2071 	        call initialize_ptrs;
     2072 	        pos_incorrect = "1"b;			/* will reseek before attempting index ref */
     2073 	        last_change_count = new_change_count;
     2074 	     end;
     2075          end;
     2076       else code = 0;
     2077    end prepare_process;
     2078 
     2079 check_file_lock:
     2080    proc;						/* waits for lock to be clear until time left is exhausted */
     2081       code = 0;
     2082       if indx_cb.wait_time < 0			/* will wait indefinitely */
     2083       then timeout = eternity;			/* may wait forever */
     2084       else timeout = clock () + indx_cb.wait_time;	/* microseconds */
     2085 
     2086       do while (code = 0);				/* wait loop */
     2087          new_change_count = change_count;		/* must save this before checking lock */
     2088          fs_ptr = addr (file_state_blocks (file_state));
     2089          if file_action = 0				/* not busy with alteration */
     2090          then if new_change_count = change_count		/* in case state has flipped */
     2091 	    then return;
     2092          lock_copy = file_base.lock_word;		/* copy the lock--can't alter file itself */
     2093          call set_lock (addr (lock_copy), 0, code);
     2094          if code = 0
     2095          then return;				/* lock was clear */
     2096          mics_left = timeout - clock ();
     2097          if (code = error_table_$lock_wait_time_exceeded) /* really busy */ & (mics_left > 0)
     2098 						/* OK to wait longer */
     2099          then
     2100 	  do;
     2101 	     call timer_manager_$sleep (min (50000, mics_left), "10"b);
     2102 						/* wait .05 seconds */
     2103 	     code = 0;
     2104 	  end;
     2105          else if (code = error_table_$invalid_lock_reset) & ^indx_cb.is_read_only
     2106          then call adjust_file (iocb_ptr, code);
     2107          else code = error_table_$file_busy;
     2108       end;					/* end of wait loop */
     2109 
     2110       go to exit;					/* abort */
     2111       dcl	    mics_left	       fixed (71);
     2112    end check_file_lock;
     2113 
     2114 position_eof:
     2115    proc;
     2116       pos_ptr = root_position_ptr;
     2117       call find_rightmost_descendent;
     2118 set_at_eof:
     2119    entry;						/* avoids cost of descent when not needed */
     2120       indx_cb.next_record_position = 1;
     2121       indx_cb.ready_to_write = "0"b;
     2122       indx_cb.current_record_is_valid = "0"b;
     2123       indx_cb.at_eof = "1"b;				/* causes re-seek to eof if shared and asynch changes */
     2124    end;
     2125 
     2126 position_bof:
     2127    proc;
     2128       pos_ptr = root_position_ptr;
     2129       call find_leftmost_descendent;
     2130       indx_cb.next_record_position = 1;
     2131       if last_branch_num > 1
     2132       then indx_cb.current_record_is_valid = "1"b;
     2133       else indx_cb.current_record_is_valid = "0"b;
     2134       indx_cb.ready_to_write = indx_cb.current_record_is_valid & dup_ok;
     2135       indx_cb.at_bof = "1"b;				/* shared re-seek will be to bof */
     2136    end;
     2137 
     2138 find_rightmost_descendent:
     2139    proc;
     2140       do while (branch (branch_num) ^= 0);
     2141          son_position_ptr -> node = branch (branch_num);
     2142          son_position_ptr -> node_ptr = get_ptr (branch (branch_num));
     2143          pos_ptr = son_position_ptr;
     2144          branch_num = last_branch_num;
     2145       end;
     2146       file_position_ptr = pos_ptr;
     2147    end;						/* end find_rightmost_descendent */
     2148 
     2149 find_leftmost_descendent:
     2150    proc;
     2151       do while (branch (branch_num) ^= 0);
     2152          son_position_ptr -> node = branch (branch_num);
     2153          son_position_ptr -> node_ptr = get_ptr (branch (branch_num));
     2154          pos_ptr = son_position_ptr;
     2155          branch_num = 1;
     2156       end;
     2157       file_position_ptr = pos_ptr;
     2158    end;						/* end find_leftmost_descendent */
     2159 
     2160 set_lock:
     2161    proc (lockp, wtime, er_code);			/* internal equivalent of system set_lock_$lock */
     2162       if stac (lockp, indx_cb.saved_lock_copy)		/* sets if zero */
     2163       then er_code = 0;				/* done */
     2164       else if lockp -> based_lock = indx_cb.saved_lock_copy
     2165       then er_code = error_table_$locked_by_this_process;
     2166       else call set_lock_$lock (lockp -> based_lock, wtime, er_code);
     2167 						/* must resort
     2168*						   to expensive call */
     2169       dcl	    lockp		       ptr;
     2170       dcl	    wtime		       fixed;
     2171       dcl	    er_code	       fixed (35);
     2172    end set_lock;
     2173 
     2174 compute_time_left:
     2175    proc;
     2176 (nosize):
     2177       time_left = divide (fixed (timeout - clock () + 999999, 35, 0), 1000000, 17, 0);
     2178    end compute_time_left;
     2179 
     2180 lock_file_check:
     2181    proc;						/* locks & re-seeks previously located position if file has changed */
     2182       pos_ptr = file_position_ptr;
     2183       f_b_ptr = file_base_ptr;
     2184       fs_ptr = indx_cb.file_state_ptr;
     2185       if indx_cb.leave_locked | i_locked_file		/* already locked */
     2186       then return;					/* no need to lock again */
     2187       fault_ok = "0"b;				/* no more asynch change errors allowed */
     2188       call compute_time_left;
     2189       if (file_base.lock_word = indx_cb.saved_lock_copy)
     2190       then i_locked_file = "0"b;			/* this op is not first to lock */
     2191       else i_locked_file = "1"b;			/* if lock becomes set, this op did it */
     2192       call set_lock (addr (file_base.lock_word), time_left, er_code);
     2193       if er_code ^= 0				/* lock was non-zero */
     2194       then if er_code = error_table_$invalid_lock_reset
     2195 	 then er_code = 0;
     2196 	 else
     2197 	    do;					/* abort */
     2198 	       code = error_table_$file_busy;
     2199 	       indx_cb.state_vars = saved_state;	/* quick state restore */
     2200 	       go to unlock_exit;
     2201 	    end;
     2202       if change_count ^= last_change_count
     2203       then call initialize_ptrs;
     2204       if (file_action ^= 0) & (file_action ^= read_exclude)
     2205       then
     2206          do;
     2207 	  call restart (iocb_ptr, er_code);		/* try to complete interrupted operation */
     2208 	  fs_ptr = indx_cb.file_state_ptr;
     2209 	  call check_code (er_code, "Unable to adjust a vfile_ operation in progress.");
     2210          end;
     2211       if change_count ^= last_change_count
     2212       then pos_incorrect = "1"b;			/* will force re-seek if index is referenced */
     2213       dcl	    er_code	       fixed (35);
     2214    end lock_file_check;
     2215 
     2216 initialize_substate:
     2217    proc;						/* prepares recovery vars */
     2218       f_b_ptr = file_base_ptr;
     2219       if indx_cb.shared
     2220       then call lock_file_check;
     2221       fs_ptr = indx_cb.file_state_ptr;
     2222       os_ptr = indx_cb.o_s_ptr;
     2223       if repeating					/* recovery is in progress */
     2224       then if file_substate = 0			/* died before finishing first block */
     2225 	 then repeating = "0"b;			/* switch to normal execution */
     2226 	 else next_substate = 0;			/* this count will keep track of recovery execution */
     2227       else
     2228          do;					/* normal execution */
     2229 	  file_substate = 0;			/* first block not yet completed */
     2230 	  file_base.old_file_ch_count = file_base.change_count;
     2231 	  file_base.was_transaction = indx_cb.trans;
     2232 	  os_ptr -> file_state_words = fs_ptr -> file_state_words;
     2233 	  if indx_cb.read_exclu			/* leave read lock set */
     2234 	  then os_ptr -> file_action = read_exclude;	/* locks out readers */
     2235 	  else os_ptr -> file_action = 0;
     2236          end;
     2237       dcl	    1 fsb		       based,		/* file state block */
     2238 	      2 word	       fixed,		/* file action slot */
     2239 	      2 file_state_words   (9) fixed;		/* avoids unused portion of fsb */
     2240    end initialize_substate;
     2241 
     2242 check_current:
     2243    proc;						/* routine aborts if current record is undefined */
     2244       pos_ptr = file_position_ptr;
     2245       code = 0;
     2246       if ^indx_cb.outside_index			/* current record located via index */
     2247       then
     2248          do;
     2249 	  if pos_incorrect
     2250 	  then
     2251 	     do;
     2252 	        call restore_position;
     2253 	        if code ^= 0
     2254 	        then return;
     2255 	     end;
     2256 	  if indx_cb.current_record_is_valid
     2257 	  then
     2258 	     do;
     2259 	        indx_cb.at_bof = "0"b;		/* reposition to record now that reference has occurred */
     2260 	        indx_cb.current_descrip = record_designator (branch_num);
     2261 	        return;
     2262 	     end;
     2263 	  else if indx_cb.next_record_position ^= 0
     2264 	  then
     2265 	     do;					/* current is next--find it */
     2266 	        call find_next_record;		/* detects eof */
     2267 	        if indx_cb.subset_selected ^= "00"b	/* may have to scan */
     2268 	        then if code = 0			/* index entry exists, but may be masked */
     2269 		   then call sh_scan;		/* does subset checking and scanning */
     2270 	     end;
     2271          end;
     2272       if ^indx_cb.current_record_is_valid
     2273       then code = error_table_$no_record;
     2274    end check_current;
     2275 
     2276 save_min_blksz_inf:
     2277    proc;						/* save info set by "min_block_size" order, in case
     2278*						   of crash while rewriting or inserting */
     2279       file_base.saved_min_res = indx_cb.min_res;
     2280       file_base.saved_min_cap = indx_cb.min_cap;
     2281    end save_min_blksz_inf;
     2282 
     2283 initialize_ptrs:
     2284    proc;						/* resets process vars invalidated by asynch changes */
     2285       if old_last_comp_num ^= last_comp_num
     2286       then
     2287          do;					/* recreate seg_ptr_array */
     2288 	  call free_seg_ptrs (iocb_ptr);
     2289 	  call create_seg_ptrs (iocb_ptr);
     2290          end;
     2291       else
     2292          do;					/* these initialized by createseg_ptrs */
     2293 	  if old_rover_comp_num ^= rover_comp_num
     2294 	  then
     2295 	     do;					/* initialize rover */
     2296 	        rover_seg_ptr = get_seg_ptr (iocb_ptr, rover_comp_num);
     2297 	        old_rover_comp_num = rover_comp_num;
     2298 	     end;
     2299 	  index_state_ptr = addr (index_state_blocks (index_state));
     2300          end;
     2301       if old_index_height < index_state_ptr -> index_height /* no sweat if height decreases */
     2302       then
     2303          do;					/* recreate position stack */
     2304 	  call free_position_stack (indx_cb_ptr);
     2305 	  call create_position_stack (indx_cb_ptr);
     2306 	  pos_ptr = file_position_ptr;
     2307          end;
     2308       file_state_ptr = addr (file_state_blocks (file_state));
     2309       fs_ptr = indx_cb.file_state_ptr;
     2310       o_s_ptr = addr (file_state_blocks (1 - file_state));
     2311       if ^indx_cb.dup_ok
     2312       then if duplicate_keys ^= 0
     2313 	 then indx_cb.dup_ok = "1"b;
     2314    end initialize_ptrs;
     2315 
     2316 restore_position:
     2317    proc;						/* re-establishes index position which may have become
     2318*						   invalid because of asynch changes */
     2319       code = 0;
     2320       if indx_cb.is_ks_out & indx_cb.ready_to_write	/* must keep track of key order constraint */
     2321       then
     2322          do;					/* position to end of file and test order */
     2323 	  file_position_ptr = root_position_ptr;	/* prepare for descent */
     2324 	  call find_rightmost_descendent;		/* end of file */
     2325 	  call compare_last_key (indx_cb.new_key);	/* sets code and key_is_dup */
     2326 	  if code ^= 0				/* not larger than last key in file */
     2327 	  then
     2328 	     do;
     2329 	        code = 0;				/* don't flag key_order error now */
     2330 	        if ^key_is_dup			/* no longer at last key */
     2331 	        then indx_cb.ready_to_write = "0"b;	/* asynch insertions leave indx_cb.new_key out of order */
     2332 	        else if ^dup_ok			/* key exists but no duplications allowed */
     2333 	        then
     2334 		 do;
     2335 		    indx_cb.ready_to_write = "0"b;	/* stop illegal duplications */
     2336 		    if indx_cb.at_eof		/* must have just done unsuccessful seek */
     2337 		    then code = error_table_$asynch_insertion;
     2338 						/* signal this error */
     2339 		 end;
     2340 	     end;
     2341 	  if indx_cb.at_eof				/* position fully restored and checked */
     2342 	  then return;				/* no more work necessary */
     2343          end;					/* now indx_cb.ready_to_write reflects asynch changes if mode is kso */
     2344       if indx_cb.at_bof
     2345       then call position_bof;
     2346       else if indx_cb.at_eof
     2347       then call position_eof;
     2348       else if ^dup_ok				/* no duplications allowed */
     2349       then
     2350          do;
     2351 	  file_position_ptr = root_position_ptr;
     2352 	  call find_key (indx_cb_ptr, (addr (indx_cb.new_key)), search_code);
     2353 	  pos_ptr = file_position_ptr;
     2354 	  if search_code ^= 0			/* key found */
     2355 	  then
     2356 	     do;
     2357 	        call find_from_leaf;
     2358 	        if indx_cb.ready_to_write		/* key should be absent */
     2359 	        then
     2360 		 do;
     2361 		    code = error_table_$asynch_insertion;
     2362 		    indx_cb.ready_to_write = "0"b;
     2363 		    indx_cb.current_record_is_valid = "1"b;
     2364 		    indx_cb.next_record_position = 1;
     2365 		 end;
     2366 	     end;
     2367 	  else
     2368 	     do;
     2369 as_del:
     2370 	        if (indx_cb.next_record_position ^= 0) | (indx_cb.current_record_is_valid & ^indx_cb.outside_index)
     2371 	        then
     2372 		 do;				/* previously located record has been deleted by another process */
     2373 		    code = error_table_$asynch_deletion;
     2374 		    indx_cb.ready_to_write = (^is_read_only & ^is_ks_out);
     2375 		    indx_cb.current_record_is_valid = "0"b;
     2376 		    indx_cb.next_record_position = 0;
     2377 		 end;
     2378 	     end;
     2379          end;
     2380       else
     2381          do;
     2382 	  call find_entry (indx_cb.new_key, indx_cb.saved_descrip);
     2383 	  if search_code = 0			/* no asynch insertions when dup keys allowed */
     2384 	  then if first_code = 0			/* key not found */
     2385 	       then go to as_del;			/* check for possible asynch deletion */
     2386 	       else if indx_cb.stat			/* insist on same descriptor */
     2387 	       then go to as_del;
     2388 	       else
     2389 		do;				/* key was found, but not current descrip */
     2390 		   call find_prev_entry;		/* set pos to last matching key */
     2391 		   branch_num = branch_num - 1;	/* does the backspace */
     2392 		end;
     2393          end;
     2394       pos_incorrect = "0"b;				/* index position correctly restored */
     2395    end restore_position;
     2396 
     2397 find_entry:
     2398    proc (key, descrip);				/* routine finds pos for given key and record descriptor */
     2399       file_position_ptr = root_position_ptr;		/* search starts at base of index */
     2400       call find_key (indx_cb_ptr, (addr (key)), search_code);
     2401       pos_ptr = file_position_ptr;
     2402       if search_code ^= 0				/* key found */
     2403       then call find_from_leaf;			/* in case match is non-leaf */
     2404       first_code = search_code;			/* will be non-zero if key was found */
     2405       key_is_dup = "0"b;				/* will be set in loop if key is not unique */
     2406 
     2407       do while (search_code ^= 0);			/* advance until descrip is found or key changes */
     2408          if record_designator (branch_num) = descrip	/* descrip found */
     2409          then return;				/* done--position set properly */
     2410          branch_num = branch_num + 1;			/* advance position */
     2411          call find_this_entry;			/* takes care of exceptional cases */
     2412          if pos_ptr = root_position_ptr			/* end of file */
     2413          then search_code = 0;			/* stop searching */
     2414          else if substr (keys, key_pos (branch_num), key_length (branch_num)) = key
     2415          then key_is_dup = "1"b;
     2416          else search_code = 0;			/* key has changed--stop searching */
     2417       end;
     2418 
     2419       dcl	    key		       char (256) var;
     2420       dcl	    descrip	       fixed (35);
     2421    end find_entry;
     2422 
     2423 abort_exit:
     2424       code = error_table_$file_is_full;
     2425       aborting = "1"b;
     2426       file_base_ptr -> file_base.max_comp_num = true_max_comp_num + 2;
     2427       go to unlock_exit;
     2428 
     2429 switch_file_state:
     2430       file_state = 1 - file_state;
     2431       file_state_ptr = os_ptr;
     2432       o_s_ptr = fs_ptr;
     2433 unlock_exit:
     2434       if indx_cb.shared
     2435       then if ^indx_cb.leave_locked & i_locked_file
     2436 	 then if ^aborting
     2437 	      then
     2438 	         do;				/* OK to clear the file lock */
     2439 		  call save_correct_pos;
     2440 		  last_change_count = change_count;
     2441 		  if stacq (lock_word, "0"b, indx_cb.saved_lock_copy)
     2442 						/* unlock */
     2443 		  then ;
     2444 	         end;
     2445 	      else
     2446 	         do;
     2447 		  call restore_state;
     2448 		  if stacq (lock_word, (36)"1"b, indx_cb.saved_lock_copy)
     2449 		  then ;				/* invalidate the lock */
     2450 	         end;
     2451 	 else if aborting
     2452 	 then call restore_state;
     2453 	 else call save_correct_pos;
     2454       if i_locked_rec
     2455       then call unlock_record (block_ptr, lock_ptr, old_passive_ref_mask);
     2456       else if i_set_negmod & ^aborting & (block_ptr ^= null)/* modifier set to -1 */
     2457       then block_ptr -> stat_struct.modifier = 0;		/* clear it */
     2458       if i_locked_new
     2459       then call unlock_record (new_block_ptr, new_lock_ptr, new_passive_ref_mask);
     2460 						/*
     2461*						   in case of reassign_key operation */
     2462       else if i_set_new_negmod & ^aborting & (new_block_ptr ^= null)
     2463       then new_block_ptr -> stat_struct.modifier = 0;
     2464 exit:
     2465       return;					/* external exit point */
     2466 
     2467 rewrite_indx_file:
     2468    entry (iocb_ptr, buff_ptr, buff_len, code);
     2469       current_retry_loc = rew_retry;
     2470       go to init_up_down;
     2471 retry_loc (12):
     2472       call check_buff_len;
     2473       call check_current;
     2474       if code ^= 0
     2475       then go to verify_done;
     2476       call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, 0);
     2477 						/* handles deleted record case */
     2478       if code ^= 0
     2479       then if (code ^= error_table_$locked_by_this_process) & (code ^= error_table_$invalid_lock_reset)
     2480 	 then go to verify_done;
     2481       if indx_cb.outside_index			/* not using index */
     2482       then if ^block_ptr -> record_block.stationary	/* see if non-stationary */
     2483 	 then if buff_len + indx_cb.min_res > 4 * (block_ptr -> record_block.block_size - 2)
     2484 	      then
     2485 	         do;				/* don't permit reallocation from outside index */
     2486 		  if code = error_table_$locked_by_this_process
     2487 		  then i_locked_rec = "0"b;		/* suppress unlocking of the record */
     2488 		  code = error_table_$long_record;
     2489 		  go to unlock_exit;		/* abort--no need to verify, since indx_cb.outside_index */
     2490 	         end;
     2491 	      else ;
     2492 	 else ;
     2493       else if is_sequential_open
     2494       then indx_cb.next_record_position = 2;
     2495       else indx_cb.next_record_position = 0;		/* OK to lock file now that record is locked */
     2496       call initialize_substate;			/* prepare for file state change after locking file, if not already locked */
     2497       file_base.old_record_designator = indx_cb.current_descrip;
     2498       if ^indx_cb.outside_index
     2499       then
     2500          do;					/*Only need to save current node when using index.*/
     2501 	  first_branch = node;			/* just a convenient place to save current node */
     2502 	  file_base.count = branch_num;		/* convenient place to save current branch_num */
     2503          end;
     2504       call save_min_blksz_inf;
     2505       file_base.out_of_index = indx_cb.outside_index;	/* remember in case of crash */
     2506       call save_old_record_length;
     2507       new_record_length = max (0, buff_len);
     2508       file_action = replace_action;
     2509       if file_base.was_stat				/* record is stationary type */
     2510       then
     2511          do;
     2512 	  if (new_record_length > 0) | (indx_cb.min_cap > 0) | (indx_cb.min_res > 0)
     2513 	  then /* always save buffer contents before rewriting */
     2514 	       call change_record_list (iocb_ptr, allocate_action, buff_ptr, abort_exit);
     2515 	  else file_base.new_descriptor = 0;		/* no allocation required */
     2516 	  stat_struct.ind_comp = new_rec_des.comp;
     2517 	  time_stamp_struct.ind_offset = new_rec_des.offset;
     2518 	  change_count = file_base.old_file_ch_count + 1; /* must be bumped before body of operation */
     2519 	  if file_base.was_transaction		/* in transaction mode */
     2520 	  then
     2521 	     do;					/* transaction case--retain before image */
     2522 	        if (file_base.old_ind_desc > 0)		/* current allocation exists--replace it */
     2523 	        then call change_record_list (iocb_ptr, replace_action, buff_ptr, abort_exit);
     2524 	        os_ptr -> number_of_allocated_records = number_of_allocated_records;
     2525 						/*
     2526*						   this statistic not changed until checkpoint occurs */
     2527 	     end;					/* done with rewrite for transaction case */
     2528 	  else
     2529 	     do;					/* non-TP case */
     2530 	        os_ptr -> total_record_length = total_record_length + buff_len - old_record_length;
     2531 	        call change_record_list (iocb_ptr, replace_action, null, abort_exit);
     2532 	     end;
     2533          end;					/* end of stationary replacement logic */
     2534       else
     2535          do;					/* non-stationary case */
     2536 	  file_base.change_count = file_base.old_file_ch_count + 1;
     2537 	  os_ptr -> total_record_length = total_record_length + buff_len - old_record_length;
     2538 	  if (new_record_length > 0) | (indx_cb.min_cap > 0) | (indx_cb.min_res > 0)
     2539 	  then
     2540 	     do;					/* insert or replace record */
     2541 	        if old_record_designator ^= 0
     2542 	        then record_action = replace_action;
     2543 	        else
     2544 		 do;
     2545 		    record_action = insert_action;
     2546 		    i_locked_rec = "1"b;		/* unlock when done */
     2547 		 end;
     2548 	        call change_record_list (iocb_ptr, record_action, buff_ptr, abort_exit);
     2549 	        if file_base.new_descriptor = file_base.old_record_designator
     2550 						/* allocation hasn't moved */
     2551 	        then if i_locked_rec			/* lock set by this operation */
     2552 		   then block_ptr -> record_block.lock_flag = "0"b;
     2553 						/*
     2554*						   not leaving locked, so clear the flag */
     2555 		   else if (code ^= 0) & (code = error_table_$locked_by_this_process)
     2556 						/* lock was already set by my process before rewriting */
     2557 		   then ;				/* will leave lock set, if room remains */
     2558 		   else
     2559 		      do;				/* won't leave lock set */
     2560 		         block_ptr -> record_block.lock_flag = "0"b;
     2561 		         go to end_ns_rew;		/* didn't set lock anyway */
     2562 		      end;
     2563 	        else if (code ^= 0) & (code = error_table_$locked_by_this_process)
     2564 	        then
     2565 		 do;				/* leave new allocation locked, if room */
     2566 		    block_ptr = get_ptr (file_base.new_descriptor);
     2567 		    block_ptr -> record_block.lock_flag = "1"b;
     2568 		 end;
     2569 	        else
     2570 		 do;
     2571 		    i_locked_rec = "0"b;		/* suppress unlocking rec */
     2572 		    go to end_ns_rew;
     2573 		 end;
     2574 	        if block_ptr -> record_block.block_size > divide (file_base.new_record_length + 11, 4, 19, 0)
     2575 	        then
     2576 		 do;				/* room for lock--be sure it is still set */
     2577 		    lock_ptr = addr (block_with_lock.record_lock);
     2578 		    lock_ptr -> based_lock = indx_cb.saved_lock_copy;
     2579 						/*
     2580*						   in case location of the lock has moved */
     2581 		 end;
     2582 	        else
     2583 		 do;				/* no more room for record lock */
     2584 		    block_ptr -> record_block.lock_flag = "0"b;
     2585 		    i_locked_rec = "0"b;		/* suppress attempt to unlock */
     2586 		 end;
     2587 	     end;					/* done with new allocation case */
     2588 	  else
     2589 	     do;					/* don't create or leave a record */
     2590 	        if old_record_designator ^= 0
     2591 	        then /* delete the old record */
     2592 		   call change_record_list (iocb_ptr, delete_action, (null), abort_exit);
     2593 	        new_descriptor = 0;
     2594 	        i_locked_rec = "0"b;
     2595 	     end;
     2596 end_ns_rew:
     2597 	  if ^indx_cb.outside_index			/* index position being used */
     2598 	  then record_descrip (branch_num) = new_descriptor;
     2599 						/* put new
     2600*						   record descriptor into current index position */
     2601 	  else indx_cb.current_descrip = new_descriptor;
     2602          end;					/* done with non-stationary logic */
     2603       go to switch_file_state;			/* unlocks file and record--end of rewrite logic */
     2604 
     2605 unlock_record:
     2606    proc (block_ptr_arg, lock_ptr_arg, passive_ref_mask);	/* by convention, the record is always unlocked last when independent synch levels are involved */
     2607       if block_ptr_arg = null				/* no record allocation to unlock */
     2608       then return;
     2609       if lock_ptr_arg = null
     2610       then return;
     2611       if aborting
     2612       then
     2613          do;					/* invalidate the record lock, if room */
     2614 	  if indx_cb.trans
     2615 	  then if block_ptr_arg -> record_block.stationary
     2616 	       then if (block_ptr_arg -> stat_struct.modifier > 0)
     2617 		     & (block_ptr_arg -> stat_struct.modifier = current_t_code)
     2618 		  then return;			/* leave locked -- refl entry must exist */
     2619 		  else if cleanup_flags & passive_ref_mask ^= "000000"b
     2620 						/* passive refl entry exists */
     2621 		  then return;			/* don't invalidate if in ref list */
     2622 	  if lock_ptr_arg ^= null
     2623 	  then if stacq (lock_ptr_arg -> based_lock, (36)"1"b, indx_cb.saved_lock_copy)
     2624 	       then ;				/* clobber record lock */
     2625 	  return;
     2626          end;
     2627       if block_ptr_arg -> record_block.stationary
     2628       then if block_ptr_arg -> stat_struct.modifier > 0
     2629 	 then return;				/* leave locked until checkpoint or rollback */
     2630       if ^(lock_ptr_arg -> based_lock = indx_cb.saved_lock_copy)
     2631       then return;
     2632       block_ptr_arg -> record_block.lock_flag = "0"b;
     2633       if block_ptr_arg -> record_block.stationary
     2634       then
     2635          do;
     2636 	  stat_struct.ind_comp = 0;
     2637 	  time_stamp_struct.ind_offset = "0"b;
     2638 	  stat_struct.modifier = 0;
     2639          end;
     2640       if stacq (lock_ptr_arg -> based_lock, "0"b, indx_cb.saved_lock_copy)
     2641       then ;
     2642       dcl	    (block_ptr_arg, lock_ptr_arg)
     2643 			       ptr;
     2644       dcl	    1 time_stamp_struct    like time_stamp_structure based (addr (stat_struct.time_stamp_words));
     2645       dcl	    passive_ref_mask       bit (36) aligned;
     2646       dcl	    1 record_block	       like record_block_structure based (block_ptr_arg);
     2647       dcl	    1 stat_struct	       like stat_structure based (block_ptr_arg);
     2648    end unlock_record;
     2649 
     2650 save_old_record_length:
     2651    proc;
     2652       if repeating
     2653       then
     2654          do;
     2655 	  call check_file_substate;
     2656 	  return;
     2657          end;
     2658       file_base.old_record_length = record_len;
     2659       call save_stat_info;
     2660       file_substate = file_substate + 1;
     2661    end save_old_record_length;
     2662 
     2663 save_stat_info:
     2664    proc;						/* saves info about current record for recovery */
     2665       if file_base.old_record_designator <= 0		/* no allocated record */
     2666       then file_base.was_stat = "0"b;			/* stationary record is always allocated */
     2667       else
     2668          do;					/* save info about record block */
     2669 	  file_base.prior_block_size = block_ptr -> record_block.block_size;
     2670 	  file_base.was_stat = block_ptr -> record_block.stationary;
     2671 	  file_base.was_ind = block_ptr -> record_block.indirect;
     2672 	  file_base.old_prev_mod = block_ptr -> stat_struct.prev_mod;
     2673 	  file_base.old_ind_desc = ind_desc;		/* indirect descriptor */
     2674 	  file_base.old_modifier = max (0, stat_struct.modifier);
     2675          end;
     2676    end save_stat_info;
     2677 
     2678 prepare_key:
     2679    proc (new_key);
     2680       new_key_length = max (length (new_key), indx_cb.min_key_len);
     2681       substr (new_key_string, 1, new_key_length) = new_key;
     2682 
     2683       dcl	    new_key	       char (256) varying;
     2684    end;						/* end prepare key */
     2685 
     2686 write_indx_file:
     2687    entry (iocb_ptr, buff_ptr, buff_len, code);		/* ref6 */
     2688       current_retry_loc = write_retry;
     2689       go to init_down_up;
     2690 retry_loc (13):
     2691       call check_buff_len;
     2692       if indx_cb.subset_selected = "10"b		/* pure selection */
     2693       then
     2694          do;
     2695 	  code = error_table_$no_record;
     2696 	  go to unlock_exit;
     2697          end;
     2698       call initialize_substate;
     2699       call save_min_blksz_inf;
     2700       new_record_length = max (buff_len, 0);
     2701       call set_add_ent_info ("1"b);			/* prepare to add key and rec */
     2702       file_base.old_ref_count = 1;			/* initial ref count will be for key entered with record, if -stat */
     2703       file_action = insert_action;
     2704       if (file_base.new_record_length > 0) | file_base.was_stat | (indx_cb.min_cap > 0) | (indx_cb.min_res > 0)
     2705       then
     2706          do;					/* allocate space for record and copy buffer */
     2707 	  call change_record_list (iocb_ptr, insert_action, buff_ptr, abort_exit);
     2708 	  if file_base.was_transaction		/* creating record in a transaction */
     2709 	  then
     2710 	     do;					/* mask presence to others until checkpoint */
     2711 	        indx_cb.current_descrip = file_base.new_descriptor;
     2712 	        call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, 0);
     2713 						/* also creates refl entry */
     2714 	     end;					/* only my transaction will see this record */
     2715          end;
     2716       else new_descriptor = 0;
     2717       file_base.change_count = file_base.old_file_ch_count + 1;
     2718       call set_new_record_designator;
     2719       call change_index (iocb_ptr, abort_exit);
     2720       pos_ptr = file_position_ptr;
     2721       call set_post_write_pos;
     2722       go to switch_file_state;			/* end of write routine */
     2723 
     2724 check_buff_len:
     2725    proc;						/* sets code non-zero if buffer is too big */
     2726       if buff_len > indx_cb.max_record_size
     2727       then
     2728          do;
     2729 	  code = error_table_$long_record;
     2730 	  go to unlock_exit;
     2731          end;
     2732    end check_buff_len;
     2733 
     2734 set_post_write_pos:
     2735    proc;						/* also used by record_status when creating with locate_sw clear */
     2736       indx_cb.current_record_is_valid = "1"b;
     2737       indx_cb.at_bof, indx_cb.at_eof = "0"b;
     2738       indx_cb.ready_to_write = dup_ok;
     2739       indx_cb.skip_state = 0;
     2740       if is_sequential_open
     2741       then indx_cb.next_record_position = 2;
     2742       else
     2743          do;
     2744 	  indx_cb.next_record_position = 0;
     2745 	  indx_cb.saved_descrip = file_base.new_descriptor;
     2746 						/* save now
     2747*						   because save correct pos logic won't handle next_rec_pos=0 case */
     2748          end;
     2749    end set_post_write_pos;
     2750 
     2751 set_add_ent_info:
     2752    proc (add_rec_sw);				/* routine prepares for adding index entry
     2753*						   and record if add_rec_sw="1"b */
     2754       is_ptr = indx_cb.index_state_ptr;
     2755       if repeating					/* recovery in progress */
     2756       then
     2757          do;
     2758 	  call check_file_substate;
     2759 	  return;
     2760          end;
     2761       file_base.new_desc_val = 0;			/* used by change_index */
     2762       file_base.saved_ks_out = indx_cb.is_ks_out;		/* in case of crash */
     2763       if ^add_rec_sw				/* add_key operation */
     2764       then
     2765          do;					/* will not create record */
     2766 	  if (block_ptr = null)
     2767 	  then file_base.was_stat = "0"b;
     2768 	  else if block_ptr -> record_block.stationary
     2769 	  then
     2770 	     do;
     2771 	        file_base.was_stat = "1"b;
     2772 	        file_base.new_ref_count = ref_cnt;
     2773 	     end;
     2774 	  else file_base.was_stat = "0"b;
     2775 	  if ak_inf.input_key			/* get new key from info structure */
     2776 	  then
     2777 	     do;
     2778 	        call prepare_key (ak_info_key);
     2779 	        new_key_len = ak_inf.key_len;
     2780 	     end;
     2781 	  else call prepare_key_for_insertion;
     2782 	  new_record_designator = indx_cb.current_descrip;
     2783 	  file_base.new_descriptor = new_record_designator;
     2784          end;
     2785       else
     2786          do;					/* prepare for write_record or record_status(**10) */
     2787 	  file_base.was_stat = indx_cb.stat;		/* -stat option used--default record
     2788*						   type is stationary */
     2789 	  call check_key_for_insertion;
     2790 	  call prepare_key_for_insertion;
     2791 	  call set_add_rec_stats;
     2792          end;
     2793       os_ptr -> number_of_keys = number_of_keys + 1;
     2794       os_ptr -> total_key_length = total_key_length + new_key_len;
     2795       if key_is_dup
     2796       then
     2797          do;					/* change duplicate key stats */
     2798 	  os_ptr -> duplicate_keys = duplicate_keys + 1;
     2799 	  os_ptr -> dup_key_bytes = dup_key_bytes + new_key_len;
     2800 	  call find_rightmost_descendent;		/* sets pos properly in case at non-leaf entry */
     2801          end;
     2802       change_position_ptr = pos_ptr;
     2803       change_node = node;
     2804       call save_position_info;
     2805       new_branch = 0;
     2806       index_action = insert_action;
     2807       file_substate = file_substate + 1;
     2808       return;					/* end of main routine for set_add_ent_info */
     2809 
     2810 prepare_key_for_insertion:
     2811    proc;
     2812       key_is_dup = indx_cb.current_record_is_valid;
     2813       if key_is_dup
     2814       then
     2815          do;
     2816 	  new_key_len = get_key_length ();		/* length of current key */
     2817 	  new_key_length = key_length (branch_num);
     2818 	  substr (new_key_string, 1, new_key_length) = substr (keys, key_pos (branch_num), key_length (branch_num));
     2819 						/* set up key for insertion */
     2820 	  if ^add_rec_sw				/* add_key operation */
     2821 	  then
     2822 	     do;
     2823 	        indx_cb.saved_descrip = record_designator (branch_num);
     2824 						/*
     2825*						   remember current descriptor */
     2826 	        pos_incorrect = "1"b;
     2827 	     end;
     2828 	  call find_next_key;			/* advance position beyond last dup key */
     2829          end;
     2830       else
     2831          do;
     2832 	  call prepare_key (indx_cb.new_key);		/* key for insertion */
     2833 	  new_key_len = length (indx_cb.new_key);
     2834          end;
     2835    end prepare_key_for_insertion;
     2836 
     2837       dcl	    new_key_len	       fixed;
     2838       dcl	    add_rec_sw	       bit (1) aligned;
     2839    end set_add_ent_info;
     2840 
     2841 check_key_for_insertion:
     2842    proc;						/* makes sure current key is defined */
     2843 
     2844       do while ("1"b);				/* may loop once */
     2845          if ^indx_cb.ready_to_write
     2846          then if dup_ok & ^is_ks_out			/* may be ready to write anyway */
     2847 	    then
     2848 	       do;
     2849 		call check_current;			/* sets code to zero if current really exists */
     2850 		if code ^= 0			/* really is no key for insertion */
     2851 		then
     2852 		   do;				/* forget the whole thing */
     2853 no_key:
     2854 		      code = error_table_$no_key;	/* set proper code */
     2855 		      go to verify_done;
     2856 		   end;
     2857 	       end;
     2858 	    else go to no_key;
     2859          if pos_incorrect
     2860          then
     2861 	  do;
     2862 	     call restore_position;
     2863 	     if code ^= 0
     2864 	     then go to verify_done;
     2865 	  end;
     2866          else
     2867 	  do;
     2868 	     pos_ptr = indx_cb.file_position_ptr;
     2869 	     return;
     2870 	  end;
     2871       end;
     2872 
     2873    end check_key_for_insertion;
     2874 
     2875 find_next_key:
     2876    proc;						/* routine used to advance pos beyond set of dup keys */
     2877       init_key_len = key_length (branch_num);
     2878       init_key_ptr = addr (node_ptr -> bytes (key_pos (branch_num)));
     2879 						/* keep track of prev key */
     2880 
     2881       do while ("1"b);
     2882          branch_num = branch_num + 1;
     2883          call find_this_entry;			/* takes care of exceptional cases */
     2884          if pos_ptr = root_position_ptr			/* at eof */
     2885          then return;
     2886          if substr (keys, key_pos (branch_num), key_length (branch_num)) ^= init_key_ptr -> initial_key
     2887 						/* key no longer matches */
     2888          then return;				/* found different key--done */
     2889       end;
     2890 
     2891       dcl	    init_key_len	       fixed;
     2892       dcl	    init_key_ptr	       ptr;
     2893       dcl	    initial_key	       char (init_key_len) based (init_key_ptr);
     2894       dcl	    bytes		       (1:4096) char (1) based;
     2895    end find_next_key;
     2896 
     2897 set_new_record_designator:
     2898    proc;
     2899       if repeating
     2900       then
     2901          do;
     2902 	  call check_file_substate;
     2903 	  return;
     2904          end;
     2905       new_record_designator = new_descriptor;
     2906       file_substate = file_substate + 1;
     2907    end set_new_record_designator;
     2908 
     2909 delete_indx_file:
     2910    entry (iocb_ptr, code);				/* ref7 */
     2911       current_retry_loc = del_retry;
     2912       go to init_up_down;
     2913 retry_loc (14):
     2914       del_cur = "1"b;
     2915       call check_current;
     2916       if code ^= 0
     2917       then go to verify_done;				/* file may not be locked yet */
     2918       indx_cb.is_read_only = "1"b;			/* to suppress recursive cleanup attempt */
     2919       call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, 0);
     2920 						/* must restore read_only status if abort is made */
     2921       indx_cb.is_read_only = "0"b;
     2922       if code ^= 0
     2923       then if code = error_table_$no_record & (block_ptr ^= null)
     2924 	 then ;					/* collect a garbage item--leave non-zero code as warning */
     2925 	 else if (code ^= error_table_$locked_by_this_process) & (code ^= error_table_$invalid_lock_reset)
     2926 	 then go to unlock_exit;			/* abort */
     2927       call delete_entry ("1"b);			/* delete index entry and current record */
     2928       return;
     2929 
     2930 adjust_record:
     2931    entry (iocb_ptr, descrip_arg, modifier_arg, code);	/*
     2932*						   used by transaction_call_ to unlock a record */
     2933       current_retry_loc = adj_retry;
     2934       go to init_down_up;
     2935 retry_loc (15):
     2936       call initialize_substate;			/* prepare for file modification */
     2937       file_base.old_record_designator = descrip_arg;
     2938       block_ptr = get_pointer (descrip_arg);
     2939       lock_ptr = addr (block_ptr -> stat_struct.record_lock);
     2940       i_locked_rec = "1"b;
     2941       if indx_cb.repeating
     2942       then
     2943          do;
     2944 	  rollback_sw = (file_action = rollback_action);
     2945 	  if file_base.was_ind & (file_base.old_ind_desc > 0)
     2946 	  then p = get_pointer (file_base.old_ind_desc);	/* be sure initiated */
     2947          end;
     2948       else
     2949          do;
     2950 	  if (block_ptr -> stat_struct.modifier <= 0)
     2951 	  then go to unlock_exit;
     2952 	  if ^(lock_ptr -> based_lock = indx_cb.saved_lock_copy)
     2953 	  then go to unlock_exit;			/* already adjusted */
     2954 	  if modifier_arg = block_ptr -> stat_struct.prev_mod
     2955 	  then rollback_sw = "1"b;			/* adjust to before image */
     2956 	  else if modifier_arg = block_ptr -> stat_struct.modifier
     2957 	  then
     2958 	     do;
     2959 	        rollback_sw = "0"b;			/* adjust to after image */
     2960 	        if block_ptr -> stat_struct.prev_mod = -3 /* pre-created record
     2961*						   which previous to this transaction did not exist */
     2962 	        then
     2963 		 do;				/* use null before image */
     2964 		    record_len = 0;			/* used only in following protected procedure */
     2965 		    ind_desc = -1;
     2966 		 end;
     2967 	        else if block_ptr -> record_block.indirect/* separate allocation of before */
     2968 	        then
     2969 		 do;
     2970 		    ind_desc = ind_struct.prev_desc;	/* before image */
     2971 		    if ind_struct.prev_desc <= 0	/* no allocation--special case */
     2972 		    then record_len = 0;
     2973 		    else record_len = length (get_pointer (ind_desc) -> record_block.record);
     2974 		 end;
     2975 	        else
     2976 		 do;
     2977 		    ind_desc = descrip_arg;
     2978 		    record_len = length (stat_struct.record);
     2979 						/* compact case */
     2980 		 end;
     2981 	     end;
     2982 	  else rollback_sw = "1"b;			/* roll back by default */
     2983 	  file_base.old_ref_count = block_ptr -> stat_struct.ref_count;
     2984          end;
     2985       if ^rollback_sw				/* checkpoint case */
     2986       then
     2987          do;					/* retain after and discard before image */
     2988 	  call save_old_record_length;		/* saves before-image info */
     2989 	  ind_des.comp = stat_struct.ind_comp;
     2990 	  ind_des.offset = time_stamp_struct.ind_offset;
     2991 	  call set_after_image_info;
     2992 	  if file_base.old_prev_mod = -3		/* new record created this trans */
     2993 	  then os_ptr -> number_of_records = number_of_records + 1;
     2994 	  else os_ptr -> number_of_records = number_of_records;
     2995 						/* note that this is only nec because of recovery */
     2996 	  if ind_desc = -1				/* deletion case */
     2997 	  then os_ptr -> number_of_records = os_ptr -> number_of_records - 1;
     2998 	  os_ptr -> total_record_length =
     2999 	     total_record_length + file_base.new_record_length - file_base.old_record_length;
     3000 	  file_action = adjust_action;
     3001 	  file_base.change_count = file_base.old_file_ch_count + 1;
     3002 	  block_ptr -> stat_struct.ref_count = block_ptr -> stat_struct.ref_count_after;
     3003 	  if ind_desc = -2				/* no change to the record image */
     3004 	  then
     3005 	     do;
     3006 	        block_ptr -> stat_struct.modifier = -1;	/* allow unlocking */
     3007 	        file_action = o_s_ptr -> file_action;	/* fast state switch */
     3008 	        go to unlock_exit;			/* don't change time stamp */
     3009 	     end;
     3010 	  if file_base.was_ind
     3011 	  then
     3012 	     do;
     3013 	        time_stamp_struct.time_last_modified = clock ();
     3014 	        ind_struct.prev_mod = file_base.old_modifier;
     3015 	        ind_struct.prev_desc = file_base.after_desc;
     3016 	        if file_base.old_ind_desc > 0
     3017 	        then
     3018 		 do;
     3019 		    file_base.new_descriptor = file_base.old_ind_desc;
     3020 						/* block to be freed */
     3021 		    call change_record_list (iocb_ptr, free_action, null, abort_exit);
     3022 		 end;
     3023 	     end;
     3024 	  else if file_base.old_prev_mod ^= -3		/* old record */
     3025 	  then
     3026 	     do;					/* overrite tail or convert into an indirect record */
     3027 	        file_base.new_descriptor = file_base.after_desc;
     3028 						/* after image descriptor */
     3029 	        file_base.was_transaction = "0"b;
     3030 	        call change_record_list (iocb_ptr, replace_action, null, abort_exit);
     3031 						/* tries to overrite in place if room */
     3032 	     end;
     3033 	  else
     3034 	     do;
     3035 	        time_stamp_struct.time_last_modified = clock ();
     3036 	        stat_struct.prev_mod = file_base.old_modifier;
     3037 	     end;
     3038          end;					/* end of forward adjustment logic */
     3039       else
     3040          do;					/* rollback case */
     3041 	  ind_des.comp = stat_struct.ind_comp;		/* after image info */
     3042 	  ind_des.offset = time_stamp_struct.ind_offset;
     3043 	  call save_old_record_length;		/* protected procedure for recovery */
     3044 	  file_base.new_descriptor = file_base.old_ind_desc;
     3045 						/* block to free */
     3046 	  file_base.was_transaction = "1"b;
     3047 	  file_action = rollback_action;		/* can't stop this operation now */
     3048 	  file_base.change_count = file_base.old_file_ch_count + 1;
     3049 						/* must bump since file's substate will be switched */
     3050 	  if file_base.old_prev_mod = -3
     3051 	  then
     3052 	     do;
     3053 	        if file_base.old_ref_count <= 0
     3054 	        then
     3055 		 do;
     3056 		    file_base.out_of_index = "1"b;	/* not deleting key */
     3057 		    call change_record_list (iocb_ptr, delete_action, null, abort_exit);
     3058 		    os_ptr -> number_of_allocated_records = number_of_allocated_records;
     3059 		    i_locked_rec = "0"b;		/* suppress unlocking */
     3060 		    go to switch_file_state;
     3061 		 end;
     3062 	        else
     3063 		 do;
     3064 		    if ^file_base.was_ind
     3065 		    then
     3066 		       do;
     3067 			file_base.new_descriptor = -1;
     3068 			call change_record_list (iocb_ptr, replace_action, null, abort_exit);
     3069 						/* leave only a logically deleted indirect header */
     3070 		       end;
     3071 		    else
     3072 		       do;
     3073 			if file_base.old_ind_desc > 0
     3074 			then call change_record_list (iocb_ptr, free_action, null, abort_exit);
     3075 			ind_struct.prev_desc = -1;
     3076 		       end;
     3077 		    stat_struct.prev_mod = 0;
     3078 		 end;
     3079 	     end;
     3080 	  else if file_base.old_ind_desc > 0		/* allocation exists */
     3081 	  then call change_record_list (iocb_ptr, free_action, null, abort_exit);
     3082          end;
     3083       os_ptr -> number_of_allocated_records = number_of_allocated_records;
     3084       block_ptr -> stat_struct.modifier = -1;		/* allow unlocking now */
     3085       go to switch_file_state;			/* end of adjust_record logic */
     3086 
     3087 adjust_file:
     3088    entry (iocb_ptr, code);				/* called if file found locked by dead
     3089*						   process in passive file lock checking */
     3090       current_retry_loc = adj_file_retry;
     3091       go to init_down_up;				/* tries to lock the file */
     3092 retry_loc (25):
     3093       go to unlock_exit;				/* that's all there is to it */
     3094 
     3095 set_after_image_info:
     3096    proc;
     3097       if indx_cb.repeating				/* recovery in progress */
     3098       then
     3099          do;
     3100 	  if file_base.after_desc > 0
     3101 	  then p = get_pointer (file_base.after_desc);
     3102 	  call check_file_substate;
     3103 	  return;					/* skip protected body of procedure */
     3104          end;
     3105       file_base.after_desc = ind_desc;
     3106       if ind_desc <= 0
     3107       then file_base.new_record_length = 0;
     3108       else if (block_ptr -> stat_struct.prev_mod = -3) & ^block_ptr -> record_block.indirect
     3109 						/* new compact */
     3110       then file_base.new_record_length = length (stat_struct.record);
     3111       else file_base.new_record_length = length (get_pointer (ind_desc) -> record_block.record);
     3112       file_substate = file_substate + 1;		/* mark completion of this step */
     3113    end set_after_image_info;
     3114 
     3115 delete_entry:
     3116    proc (del_rec_sw);				/* routine to delete index entry and rec if switch set */
     3117       call initialize_substate;
     3118       file_base.out_of_index = indx_cb.outside_index;	/* in case of crash */
     3119       call set_del_ent_info;
     3120       if del_cur
     3121       then if is_sequential_open
     3122 	 then
     3123 	    do;
     3124 	       indx_cb.skip_state = 0;		/* scanning of deletions is forward */
     3125 	       indx_cb.next_record_position = 1;
     3126 	    end;
     3127 	 else indx_cb.next_record_position = 0;
     3128       if del_rec_sw					/* delete_record operation */
     3129       then
     3130          do;
     3131 	  file_action = delete_action;
     3132 	  if del_cur				/* not delete_key case */
     3133 	  then
     3134 	     do;
     3135 	        indx_cb.current_record_is_valid = "0"b;	/* in case at eof or direct opening */
     3136 	        indx_cb.ready_to_write = "0"b;		/* may actually be ready if current exists */
     3137 	     end;
     3138 	  else if saved_state.current_record_is_valid
     3139 	  then indx_cb.current_descrip = saved_state.current_descrip;
     3140 	  else indx_cb.current_descrip = indx_cb.saved_descrip;
     3141 	  file_base.change_count = file_base.old_file_ch_count + 1;
     3142 	  if file_base.was_stat
     3143 	  then
     3144 	     do;					/* delete a stationary record */
     3145 	        if file_base.old_modifier > 0		/* TP case */
     3146 	        then
     3147 		 do;
     3148 		    file_base.new_descriptor = -1;
     3149 		    if file_base.old_ind_desc > 0	/* non-null after image */
     3150 		    then call change_record_list (iocb_ptr, replace_action, null, abort_exit);
     3151 						/* discard indirect after image allocation */
     3152 		    indx_cb.outside_index = "0"b;
     3153 		    if indx_cb.next_record_position = 1
     3154 		    then indx_cb.next_record_position = 2;
     3155 						/* skip over this key */
     3156 		    go to switch_file_state;		/* nothing more to do until checkpoint */
     3157 		 end;
     3158 	        call change_record_list (iocb_ptr, delete_action, null, abort_exit);
     3159 	        if indx_cb.outside_index
     3160 	        then
     3161 		 do;
     3162 		    indx_cb.outside_index = "0"b;
     3163 		    go to switch_file_state;
     3164 		 end;
     3165 	        if file_base.is_partial_deletion
     3166 	        then
     3167 		 do;
     3168 		    if indx_cb.next_record_position = 1
     3169 		    then indx_cb.next_record_position = 2;
     3170 		    go to switch_file_state;		/* don't delete last key */
     3171 		 end;
     3172 	        if ^del_cur				/* delete_key case */
     3173 	        then indx_cb.outside_index = saved_state.outside_index;
     3174 	     end;
     3175 	  else
     3176 	     do;
     3177 	        if old_record_designator ^= 0
     3178 	        then call change_record_list (iocb_ptr, delete_action, (null), abort_exit);
     3179 	        if indx_cb.outside_index		/* no key to delete */
     3180 	        then
     3181 		 do;
     3182 		    indx_cb.outside_index = "0"b;
     3183 		    go to switch_file_state;		/* just deleted the current record */
     3184 		 end;
     3185 	     end;
     3186          end;
     3187       else
     3188          do;					/* operation is delete_key */
     3189 	  file_action = deleting_key;			/* all info necessary for recovery is saved */
     3190 	  if del_cur /* key to delete is at the current file position */ & ^indx_cb.outside_index
     3191 						/* deleting key of current record */
     3192 	  then call make_current (old_record_designator); /* current pos moves out of index */
     3193 	  else if saved_state.current_record_is_valid
     3194 	  then indx_cb.current_descrip = saved_state.current_descrip;
     3195 	  else indx_cb.current_descrip = indx_cb.saved_descrip;
     3196 	  file_base.change_count = file_base.old_file_ch_count + 1;
     3197 	  if file_base.was_stat
     3198 	  then
     3199 	     do;
     3200 	        block_ptr -> stat_struct.ref_count_after = file_base.old_ref_count;
     3201 	        block_ptr -> stat_struct.ref_count = file_base.old_ref_count;
     3202 	     end;
     3203          end;
     3204       if new_desc_val ^= 0				/* non-leaf node */
     3205       then
     3206          do;					/* replace key with highest preceding one */
     3207 	  call replace_non_leaf_key;
     3208 	  call reset_change_position;
     3209 	  if is_sequential_open & del_cur
     3210 	  then indx_cb.next_record_position = 2;
     3211          end;
     3212       call change_index (iocb_ptr, abort_exit);		/* deletes the key */
     3213       pos_ptr = file_position_ptr;
     3214       if new_desc_val ^= 0
     3215       then if del_cur				/* pos belongs upstairs */
     3216 	 then call find_from_leaf;			/* climbs up tree */
     3217       go to switch_file_state;			/* end of delete routine */
     3218 
     3219 set_del_ent_info:
     3220    proc;						/* saves vars necessary for deletion */
     3221       is_ptr = indx_cb.index_state_ptr;
     3222       if repeating
     3223       then
     3224          do;
     3225 	  i_locked_rec =
     3226 	     (file_action ^= delete_action)
     3227 	     | ((file_action = delete_action) & file_base.was_stat
     3228 	     & (file_base.is_partial_deletion | (file_base.old_modifier > 0)
     3229 	     | (file_base.old_ref_count > fixed (^file_base.out_of_index))));
     3230 	  call check_file_substate;
     3231 	  return;
     3232          end;
     3233       file_base.old_record_designator = indx_cb.current_descrip;
     3234       if del_rec_sw					/* delete_record operation */
     3235       then
     3236          do;					/* prepare to remove old record */
     3237 	  call save_stat_info;			/* save more info if record is stationary */
     3238 	  file_base.is_partial_deletion = "0"b;
     3239 	  if file_base.was_stat			/* stationary record case */
     3240 	  then
     3241 	     do;
     3242 	        stat_struct.ind_comp = -1;
     3243 	        time_stamp_struct.ind_offset = (18)"1"b;	/* -1 */
     3244 	        file_base.old_ref_count = ref_cnt;
     3245 	        if file_base.old_modifier > 0		/* won't alter index at this time */
     3246 	        then go to bump_substate;		/* no more info to save for recoverability */
     3247 	        if indx_cb.shared
     3248 	        then if ^indx_cb.outside_index		/* key exists */
     3249 		   then if ref_cnt <= 1		/* at last reference */
     3250 		        then if time_stamp + indx_cb.collection_delay_time > clock ()
     3251 			   then file_base.is_partial_deletion = "1"b;
     3252 			   else i_locked_rec, i_set_negmod = "0"b;
     3253 						/* suppress unlocking */
     3254 		        else ;			/* will unlock record when done */
     3255 		   else if ref_cnt <= 0		/* no more refs--can collect */
     3256 		   then i_locked_rec, i_set_negmod = "0"b;
     3257 						/* block will be zeroed */
     3258 		   else ;				/* won't collect entire block--unlock */
     3259 	        else if ref_cnt <= fixed (^indx_cb.outside_index)
     3260 	        then i_locked_rec, i_set_negmod = "0"b;
     3261 	     end;
     3262 	  else i_locked_rec = "0"b;			/* always collect storage completely */
     3263 	  if ^rec_deleted				/* statistics must be adjusted */
     3264 	  then os_ptr -> number_of_records = number_of_records - 1;
     3265 	  os_ptr -> total_record_length = total_record_length - record_len;
     3266 	  if file_base.is_partial_deletion | indx_cb.outside_index
     3267 	  then go to bump_substate;
     3268          end;
     3269       else if (block_ptr = null)
     3270       then file_base.was_stat = "0"b;
     3271       else if block_ptr -> record_block.stationary
     3272       then
     3273          do;
     3274 	  file_base.was_stat = "1"b;
     3275 	  file_base.old_ref_count = ref_cnt;
     3276          end;
     3277       else file_base.was_stat = "0"b;
     3278       os_ptr -> number_of_keys = number_of_keys - 1;
     3279       os_ptr -> total_key_length = total_key_length - get_key_length ();
     3280       change_position_ptr = pos_ptr;
     3281       change_node = node;
     3282       file_base.new_desc_val = branch (branch_num + 1);
     3283       if dup_ok
     3284       then if deleting_dup ()
     3285 	 then
     3286 	    do;					/* duplicate key stats must change */
     3287 	       os_ptr -> duplicate_keys = duplicate_keys - 1;
     3288 	       os_ptr -> dup_key_bytes = dup_key_bytes - get_key_length ();
     3289 	    end;
     3290       if new_desc_val ^= 0				/* non-leaf node */
     3291       then
     3292          do;					/* prepare to delete preceding key */
     3293 	  call find_rightmost_descendent;
     3294 	  branch_num = branch_num - 1;
     3295 	  call prepare_key (substr (keys, key_pos (branch_num), key_length (branch_num)));
     3296 	  new_record_designator = record_designator (branch_num);
     3297 	  index_action = replace_action;		/* first replace key with copy of predecessor */
     3298          end;
     3299       else index_action = delete_action;
     3300       call save_position_info;			/* remember index location */
     3301 bump_substate:
     3302       file_substate = file_substate + 1;
     3303    end set_del_ent_info;
     3304 
     3305 deleting_dup:
     3306    proc returns (bit (1) aligned);			/* routine checks whether key to delete is a duplicate */
     3307       change_branch = branch_num;			/* remember current branch num */
     3308       return (next_is_dup () | prev_is_dup ());		/* compares key with neighbors */
     3309 
     3310 next_is_dup:
     3311    proc returns (bit (1) aligned);			/* sees if next key matches current */
     3312       branch_num = branch_num + 1;			/* advance position */
     3313       call find_this_entry;				/* in case non-leaf or at last branch */
     3314       new_branch_num = branch_num;
     3315 set_result:
     3316       if pos_ptr = root_position_ptr			/* end of file */
     3317       then keys_match = "0"b;				/* no prev or next key exists */
     3318       else if (
     3319 	    substr (change_position_ptr -> node_ptr -> keys, change_position_ptr -> node_ptr -> key_pos (change_branch),
     3320 	    change_position_ptr -> node_ptr -> key_length (change_branch))
     3321 	    = substr (keys, key_pos (branch_num), key_length (branch_num)))
     3322       then keys_match = "1"b;
     3323       else keys_match = "0"b;
     3324       branch_num = new_branch_num;			/* in case checking prev of first in node */
     3325       pos_ptr = change_position_ptr;			/* restore file position */
     3326       file_position_ptr = pos_ptr;
     3327       branch_num = change_branch;
     3328       return (keys_match);				/* return result */
     3329 
     3330 prev_is_dup:
     3331    entry returns (bit (1) aligned);			/* sees if preceding key matches current */
     3332       call find_prev_entry;				/* in case non-leaf or at first branch */
     3333       new_branch_num = branch_num;			/* in case this node is parent */
     3334       branch_num = branch_num - 1;			/* does the backspace */
     3335       go to set_result;				/* finish up */
     3336 
     3337    end next_is_dup;
     3338       dcl	    keys_match	       bit (1) aligned;
     3339       dcl	    new_branch_num	       fixed (35);
     3340       dcl	    change_branch	       fixed (35);
     3341    end deleting_dup;
     3342 
     3343       dcl	    del_rec_sw	       bit (1) aligned;
     3344    end delete_entry;
     3345 
     3346 replace_non_leaf_key:
     3347    proc;
     3348       if repeating
     3349       then
     3350          do;
     3351 	  next_substate = next_substate + 1;		/* file_substate is bumped by change_index */
     3352 	  call check_file_substate;
     3353 	  if file_substate >= next_substate
     3354 	  then return;
     3355          end;
     3356       call change_index (iocb_ptr, abort_exit);
     3357       pos_ptr = file_position_ptr;
     3358       file_substate = file_substate + 1;
     3359    end replace_non_leaf_key;
     3360 
     3361 reset_change_position:
     3362    proc;
     3363       is_ptr = indx_cb.index_state_ptr;
     3364       if repeating
     3365       then
     3366          do;
     3367 	  call check_file_substate;
     3368 	  return;
     3369          end;
     3370       change_position_ptr = pos_ptr;
     3371       change_node = node;
     3372       index_action = delete_action;
     3373       file_substate = file_substate + 1;
     3374    end reset_change_position;
     3375 
     3376 save_position_info:
     3377    proc;						/* saves process variables required for recovery mechanism */
     3378       current_node = node;
     3379       p = root_position_ptr;
     3380       do i = 1 to index_height;
     3381          p = p -> son_position_ptr;
     3382          saved_node (i) = p -> node;
     3383          saved_branch_num (i) = p -> branch_num;
     3384       end;
     3385       dcl	    i		       fixed;
     3386       dcl	    p		       ptr;
     3387    end save_position_info;
     3388 
     3389 add_key:						/* routine adds specified key to current record */
     3390       if indx_cb.mode = 7				/* unkeyed update opening */
     3391       then
     3392          do;					/* abort */
     3393 	  code = error_table_$no_operation;
     3394 	  go to exit;
     3395          end;
     3396       current_retry_loc = ak_retry;
     3397       go to init_up_down;
     3398 retry_loc (16):
     3399       saved_state.current_record_is_valid = indx_cb.current_record_is_valid;
     3400       saved_state.current_descrip = indx_cb.current_descrip;
     3401       if ak_inf.input_key				/* get new key from info structure */
     3402       then
     3403          do;
     3404 	  if ^ak_inf.input_desc			/* using current record's descrip */
     3405 	  then
     3406 	     do;
     3407 	        call check_current;			/* checks if current rec is not defined */
     3408 	        if code ^= 0			/* error */
     3409 	        then go to verify_done;		/* abort or retry */
     3410 	        if ^indx_cb.shared | ^saved_state.current_record_is_valid
     3411 	        then call save_correct_pos;
     3412 	     end;
     3413 	  else if ^indx_cb.shared
     3414 	  then call save_correct_pos;
     3415 	  pos_incorrect = "1"b;			/* index position will not be current pos */
     3416 	  file_position_ptr = root_position_ptr;	/* start search from root */
     3417 	  if ^is_ks_out				/* update opening */
     3418 	  then
     3419 	     do;
     3420 	        call find_key$last (indx_cb_ptr, (addr (ak_info_key)), search_code);
     3421 						/* look for key */
     3422 	        pos_ptr = file_position_ptr;
     3423 	        if search_code = 0			/* key not found */
     3424 	        then key_is_dup = "0"b;		/* not a duplication */
     3425 	        else
     3426 		 do;				/* key already exists--set position properly */
     3427 		    key_is_dup = "1"b;
     3428 		    call find_from_leaf;		/* in case match was non-leaf */
     3429 						/*				call find_next_key; /* advance to beyond last duplication, */
     3430 		 end;
     3431 	     end;
     3432 	  else
     3433 	     do;					/* verify key order */
     3434 	        pos_ptr = indx_cb.file_position_ptr;
     3435 	        call find_rightmost_descendent;		/* position to end of file */
     3436 	        call compare_last_key (ak_info_key);	/* test key order */
     3437 	        if code ^= 0			/* key not larger than last in file */
     3438 	        then if ^key_is_dup			/* error--key out of order */
     3439 		   then go to verify_done;
     3440 		   else code = 0;			/* may be permitted */
     3441 	     end;
     3442 	  if key_is_dup & ^dup_ok			/* illegal key duplication */
     3443 	  then
     3444 	     do;					/* abort */
     3445 	        code = error_table_$key_duplication;
     3446 	        go to verify_done;
     3447 	     end;
     3448          end;
     3449       else if ^indx_cb.repeating
     3450       then
     3451          do;
     3452 	  if ak_inf.input_desc
     3453 	  then
     3454 	     do;
     3455 	        call check_current;
     3456 	        if code ^= 0
     3457 	        then go to verify_done;
     3458 	     end;
     3459 	  call check_key_for_insertion;
     3460          end;
     3461       if ak_inf.input_desc				/* descriptor in info structure */
     3462       then indx_cb.current_descrip = ak_inf.descrip;
     3463       if indx_cb.stat				/* record must be adjusted in this case */
     3464       then
     3465          do;
     3466 	  call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, 1);
     3467 						/* bump the ref count */
     3468 	  if code ^= 0
     3469 	  then if (code ^= error_table_$locked_by_this_process) & (code ^= error_table_$invalid_lock_reset)
     3470 						/* fatal */
     3471 	       then
     3472 		do;
     3473 		   if saved_state.current_record_is_valid
     3474 		   then indx_cb.current_descrip = saved_state.current_descrip;
     3475 		   else indx_cb.current_descrip = indx_cb.saved_descrip;
     3476 		   go to verify_done;
     3477 		end;
     3478 	       else code = 0;
     3479          end;
     3480       else block_ptr = null;				/* won't have to unlock the record */
     3481       call initialize_substate;
     3482       call set_add_ent_info ("0"b);			/* just add key, no record */
     3483       if saved_state.current_record_is_valid
     3484       then indx_cb.current_descrip = saved_state.current_descrip;
     3485       else indx_cb.current_descrip = indx_cb.saved_descrip;
     3486       file_action = adding_key;			/* no turning back now */
     3487       file_base.change_count = file_base.old_file_ch_count + 1;
     3488       if file_base.was_stat
     3489       then
     3490          do;
     3491 	  block_ptr -> stat_struct.ref_count_after = file_base.new_ref_count;
     3492 	  block_ptr -> stat_struct.ref_count = file_base.new_ref_count;
     3493          end;
     3494       call change_index (iocb_ptr, abort_exit);		/* inserts the new key */
     3495       pos_ptr = file_position_ptr;
     3496       go to switch_file_state;			/* end of add_key routine */
     3497 
     3498 delete_key:					/* contains logic for the delete_key control order */
     3499       call verify_keyed_update;			/* check opening mode */
     3500       current_retry_loc = dk_retry;
     3501       go to init_up_down;
     3502 retry_loc (17):
     3503       saved_state.current_record_is_valid = indx_cb.current_record_is_valid;
     3504       saved_state.current_descrip = indx_cb.current_descrip;
     3505       if info_ptr = null				/* delete current entry for current rec */
     3506       then
     3507          do;
     3508 	  if indx_cb.outside_index			/* no key is associated with current record */
     3509 	  then code = error_table_$no_key;
     3510 	  else call check_current;			/* sets code */
     3511 	  if code ^= 0				/* error has occurred--abort */
     3512 	  then go to verify_done;
     3513 	  del_cur = "1"b;				/* indicates deleted entry is at current file position */
     3514          end;
     3515       else if ak_inf.input_key			/* use key in info structure */
     3516       then
     3517          do;
     3518 	  if ^ak_inf.input_desc
     3519 	  then
     3520 	     do;					/* use current record's descriptor */
     3521 	        call check_current;
     3522 	        if code ^= 0
     3523 	        then go to verify_done;		/* error */
     3524 	        if ^indx_cb.shared | ^saved_state.current_record_is_valid
     3525 						/* may not have saved current descriptor */
     3526 	        then call save_correct_pos;		/* don't lose your place */
     3527 	     end;
     3528 	  else
     3529 	     do;
     3530 	        if ^indx_cb.shared
     3531 	        then call save_correct_pos;
     3532 	        indx_cb.current_descrip = ak_inf.descrip; /* temporarily call this the current descriptor */
     3533 	     end;
     3534 	  if ^indx_cb.at_bof & ^indx_cb.at_eof
     3535 	     & ((indx_cb.next_record_position ^= 0) | (indx_cb.current_record_is_valid & ^indx_cb.outside_index))
     3536 	     & (indx_cb.current_descrip = indx_cb.saved_descrip) & (ak_info_key = indx_cb.new_key)
     3537 	  then
     3538 	     do;
     3539 	        del_cur = "1"b;
     3540 	        if indx_cb.pos_incorrect
     3541 	        then go to find_input_key;
     3542 	        else first_code, search_code = 1;	/* fake successful finding--already there */
     3543 	     end;
     3544 	  else
     3545 	     do;
     3546 	        del_cur = "0"b;
     3547 	        indx_cb.pos_incorrect = "1"b;
     3548 find_input_key:
     3549 	        call find_entry (ak_info_key, indx_cb.current_descrip);
     3550 						/* look for old entry */
     3551 	     end;
     3552 check_codes:
     3553 	  if first_code = 0				/* key not found--error */
     3554 	  then code = error_table_$no_key;
     3555 	  else if search_code = 0			/* old descrip not found--error */
     3556 	  then code = error_table_$no_record;
     3557 	  if code ^= 0				/* error has occurred */
     3558 	  then
     3559 	     do;
     3560 	        if saved_state.current_record_is_valid
     3561 	        then indx_cb.current_descrip = saved_state.current_descrip;
     3562 	        else indx_cb.current_descrip = indx_cb.saved_descrip;
     3563 	        go to verify_done;
     3564 	     end;
     3565 	  if del_cur				/* deleting current_key */
     3566 	  then indx_cb.pos_incorrect = "0"b;		/* save new current key */
     3567          end;
     3568       else if indx_cb.outside_index			/* no key for insertion */
     3569       then
     3570          do;					/* signal error */
     3571 	  code = error_table_$no_key;
     3572 	  go to verify_done;
     3573          end;
     3574       else
     3575          do;
     3576 	  call check_current;			/* need current record's key */
     3577 	  if code ^= 0				/* error */
     3578 	  then
     3579 	     do;
     3580 	        if ak_inf.input_desc & (code = error_table_$no_record)
     3581 	        then code = error_table_$no_key;
     3582 	        go to verify_done;
     3583 	     end;
     3584 	  if ^ak_inf.input_desc			/* current key of current record */
     3585 	  then del_cur = "1"b;
     3586 	  else
     3587 	     do;
     3588 	        if ^indx_cb.shared | ^saved_state.current_record_is_valid
     3589 	        then call save_correct_pos;
     3590 	        indx_cb.current_descrip = ak_inf.descrip;
     3591 	        if indx_cb.current_descrip = indx_cb.saved_descrip
     3592 	        then
     3593 		 do;
     3594 		    del_cur = "1"b;
     3595 		    if indx_cb.pos_incorrect
     3596 		    then go to find_cur_key;
     3597 		 end;
     3598 	        else
     3599 		 do;
     3600 		    del_cur = "0"b;
     3601 		    indx_cb.pos_incorrect = "1"b;
     3602 find_cur_key:
     3603 		    call find_entry (indx_cb.new_key, indx_cb.current_descrip);
     3604 		    go to check_codes;
     3605 		 end;
     3606 	     end;
     3607          end;
     3608       if indx_cb.stat
     3609       then
     3610          do;					/* the ref count must be decremented */
     3611 	  indx_cb.is_read_only = "1"b;		/* suppress recursive garbage collection */
     3612 	  call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, -1);
     3613 						/* decrement the ref count */
     3614 	  indx_cb.is_read_only = "0"b;		/* restore opening state properly */
     3615 	  if code ^= 0
     3616 	  then if (code = error_table_$no_record) & (block_ptr ^= null)
     3617 	       then
     3618 		do;				/* handle logically deleted record */
     3619 		   if (ref_cnt <= 0) & (block_ptr -> stat_struct.modifier <= 0)
     3620 		   then
     3621 		      do;				/* setup delete_record case */
     3622 		         saved_state.outside_index = indx_cb.outside_index;
     3623 		         indx_cb.outside_index = "0"b;	/* signal remove key with record */
     3624 		         ref_cnt = ref_cnt + 1;	/* undo decrementing, not done by delete_record */
     3625 		         call delete_entry ("1"b);
     3626 		         return;			/* not supposed to get here */
     3627 		      end;
     3628 		end;
     3629 	       else if (code ^= error_table_$locked_by_this_process) & (code ^= error_table_$invalid_lock_reset)
     3630 	       then
     3631 		do;
     3632 		   if saved_state.current_record_is_valid
     3633 		   then indx_cb.current_descrip = saved_state.current_descrip;
     3634 		   else indx_cb.current_descrip = indx_cb.saved_descrip;
     3635 		   go to verify_done;
     3636 		end;
     3637 	       else code = 0;
     3638          end;
     3639       else block_ptr = null;				/* don't unlock record */
     3640       call delete_entry ("0"b);			/* don't delete the record, just the key */
     3641       return;					/* end of delete_key */
     3642 
     3643 verify_keyed_update:
     3644    proc;						/* makes sure opening is valid for delete_key
     3645*						   or reassign_key */
     3646       if (mode ^= 10) & (mode ^= 13)			/* not a valid mode */
     3647       then
     3648          do;					/* set error code and abort */
     3649 	  code = error_table_$no_operation;
     3650 	  go to exit;
     3651          end;
     3652    end verify_keyed_update;
     3653 
     3654 select:						/* selects specified subset of records in the file */
     3655       flag = select_flag;
     3656       if ^common_sl_info.status_only			/* current subset will be reset or changed */
     3657       then if common_sl_info.list_type = 0		/* no list specification--reselect given subset */
     3658 	 then
     3659 	    do;
     3660 	       if (common_sl_info.subset_no < 0) | (common_sl_info.subset_no > indx_cb.last_subset)
     3661 	       then
     3662 		do;
     3663 bad_arg:
     3664 		   code = error_table_$bad_arg;	/* invalid subset number */
     3665 		   go to exit;			/* abort */
     3666 		end;
     3667 	       indx_cb.current_subset = common_sl_info.subset_no;
     3668 	       if indx_cb.current_subset = 0		/* the identity subset */
     3669 	       then
     3670 		do;
     3671 		   indx_cb.subset_selected = "00"b;	/* convention means default subset */
     3672 		   if common_sl_info.output_descriptors /* must do more work */
     3673 		   then go to generate_subset;
     3674 		end;
     3675 	       else indx_cb.subset_selected = "10"b;
     3676 	       call count_subset;
     3677 	    end;
     3678 	 else go to generate_subset;
     3679       else if common_sl_info.output_descriptors & (indx_cb.subset_selected = "00"b)
     3680       then go to generate_subset;
     3681       call get_subset_status;
     3682       return;					/* end of select routine */
     3683 
     3684 exclude:						/* creates temporary exclude list or removes entries from current subset */
     3685       flag = exclude_flag;
     3686       if common_sl_info.list_type = 0			/* reset to previous subset */
     3687       then if (common_sl_info.subset_no <= 0) | (common_sl_info.subset_no > indx_cb.last_subset)
     3688 	 then go to bad_arg;
     3689 	 else
     3690 	    do;
     3691 	       indx_cb.current_subset = common_sl_info.subset_no;
     3692 	       indx_cb.subset_selected = "01"b;		/* pure exclusion */
     3693 	       call count_subset;			/* return subset count to user */
     3694 	    end;
     3695       else go to generate_subset;
     3696       call get_subset_status;
     3697       return;					/* end of exclude routine */
     3698 
     3699 get_subset_status:
     3700    proc;						/* returns subset info into common_sl_info structure */
     3701       if indx_cb.subset_selected = "00"b		/* nothing excluded or explicitly selected */
     3702       then
     3703          do;
     3704 	  if ^(common_sl_info.status_only & common_sl_info.output_descriptors)
     3705 	  then
     3706 	     do;					/* trust number of allocations as the count */
     3707 	        f_b_ptr = indx_cb.file_base_ptr;
     3708 	        indx_cb.subset_count = addr (file_state_blocks (file_base.file_state)) -> number_of_allocated_records;
     3709 	     end;
     3710 	  common_sl_info.subset_no = 0;
     3711          end;
     3712       else if indx_cb.subset_selected = "10"b		/* pure selection */
     3713       then common_sl_info.subset_no = indx_cb.current_subset;
     3714       else common_sl_info.subset_no = -1 * indx_cb.current_subset;
     3715 						/* pure exclusion */
     3716       common_sl_info.count = indx_cb.subset_count;	/* count of items in temporary file for this subset */
     3717 
     3718       if common_sl_info.output_descriptors & ^(indx_cb.subset_selected = "00"b & flag = select_flag)
     3719       then
     3720          do;
     3721 	  if common_sl_info.desc_arrayp = null & common_sl_info.count > 0
     3722 						/* wants me to make allocation */
     3723 	  then
     3724 	     do;
     3725 	        if system_freep = null		/* first time this process */
     3726 	        then system_freep = get_system_free_area_ ();
     3727 	        allocate desc_array in (system_freep -> based_area) set (common_sl_info.desc_arrayp);
     3728 	     end;
     3729 	  call list_subset;
     3730          end;
     3731    end get_subset_status;
     3732 
     3733 count_subset:
     3734    proc;						/* sets subset_count for current subset */
     3735       if indx_cb.subset_selected = "00"b
     3736       then
     3737          do;					/* treat identity subset as a special case */
     3738 	  f_b_ptr = indx_cb.file_base_ptr;
     3739 	  indx_cb.subset_count = addr (file_state_blocks (file_base.file_state)) -> number_of_allocated_records;
     3740 	  return;
     3741          end;
     3742       count = 0;
     3743       unspec (zero_word_bytes) = "0"b;
     3744       subset_key = current_subset_bytes || zero_word_bytes; /* head for desired portion of temp index */
     3745       indx_cb_ptr = indx_cb.temp_iocbp -> iocb.open_data_ptr;
     3746       call seek_head (1, addr (subset_key), 8);		/* position to start of range in temp file */
     3747 
     3748       do while (pos_ptr ^= root_position_ptr);		/* loop steps until beyond current subset's range */
     3749          if substr (subset_key, 1, 4) = substr (keys, key_pos (branch_num), 4)
     3750 						/* in current subset */
     3751          then
     3752 	  do;
     3753 	     count = count + 1;
     3754 	     branch_num = branch_num + 1;
     3755 	     call find_this_entry;			/* in case last branch in node or non-leaf */
     3756 	  end;
     3757          else pos_ptr = root_position_ptr;		/* force exit from loop */
     3758       end;
     3759 
     3760       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
     3761       pos_ptr = indx_cb.file_position_ptr;
     3762       indx_cb.subset_count = count;
     3763       return;					/* end of count_subset logic */
     3764 
     3765 list_subset:
     3766    entry;						/* fills descriptor array with entries for current subset */
     3767       unspec (zero_word_bytes) = "0"b;
     3768       subset_key = current_subset_bytes || zero_word_bytes;
     3769       count = indx_cb.subset_count;
     3770       i = 0;
     3771       indx_cb_ptr = indx_cb.temp_iocbp -> iocb.open_data_ptr;
     3772       call seek_head (1, addr (subset_key), 8);		/* find start of current subset in temp file */
     3773 
     3774       do while ((i < count) & (pos_ptr ^= root_position_ptr));
     3775          i = i + 1;
     3776          common_sl_info.desc_arrayp -> desc_array_bytes (i) = substr (keys, key_pos (branch_num) + 4, 4);
     3777 						/* descriptor in lower word of temp key */
     3778          branch_num = branch_num + 1;			/* advance to next */
     3779          call find_this_entry;			/* handles exceptions */
     3780       end;
     3781 
     3782       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;	/* restore stuff for current file */
     3783       pos_ptr = indx_cb.file_position_ptr;
     3784       indx_cb.subset_count = i;
     3785       common_sl_info.count = i;			/* in case count was wrong */
     3786       return;					/* end of list_subset logic */
     3787 
     3788       dcl	    subset_key	       char (8) var;
     3789       dcl	    desc_array_bytes       (1:common_sl_info.count) char (4) based (common_sl_info.desc_arrayp);
     3790       dcl	    current_subset_bytes   char (4) based (addr (indx_cb.current_subset));
     3791       dcl	    zero_word_bytes	       char (4) aligned;
     3792       dcl	    count		       fixed;
     3793       dcl	    i		       fixed;
     3794    end count_subset;
     3795 
     3796 generate_subset:					/* flag indicates whether select or exclude */
     3797       if common_sl_info.list_type > max_list_type
     3798       then go to bad_arg;
     3799       else
     3800          do;
     3801 	  if flag = select_flag
     3802 	  then next_subset = indx_cb.last_subset + 1;	/* select creates a new subset */
     3803 	  else if indx_cb.subset_selected = "00"b
     3804 	  then next_subset = indx_cb.last_subset + 1;
     3805 	  else next_subset = indx_cb.current_subset;	/* modify current subset */
     3806 	  if indx_cb.temp_iocbp = null		/* have not yet used temp switch */
     3807 	  then call get_temp_switch;
     3808 	  else if common_sl_info.delete_old_subsets
     3809 	  then if indx_cb.current_subset = 0
     3810 	       then call delete_old_subsets (indx_cb.temp_iocbp);
     3811 	       else
     3812 		do;
     3813 		   code = error_table_$bad_arg;
     3814 		   return;
     3815 		end;
     3816 
     3817 	  count = 0;				/* will accumulate total count of descriptors */
     3818 	  temp_ak_inf.flags = "11"b;
     3819 	  temp_ak_inf.descriptor = 0;
     3820 	  temp_ak_inf.key_len = 8;
     3821 	  if (common_sl_info.list_type = 1) | (common_sl_info.status_only)
     3822 						/* array of intervals */
     3823 	  then
     3824 	     do;
     3825 	        current_retry_loc = init_retry;
     3826 	        saved_subset_selected = indx_cb.subset_selected;
     3827 	        saved_current_subset = indx_cb.current_subset;
     3828 	        go to initialize;
     3829 retry_loc (18):
     3830 	        call save_correct_pos;		/* in order to restore initial position */
     3831 	        indx_cb.pos_incorrect = "1"b;
     3832 	        if common_sl_info.status_only
     3833 	        then n_int = 1;
     3834 	        else n_int = common_sl_info.array_limit;
     3835 	        pad_key_ptr = addr (gk_pad_key);
     3836 	        last_info_ptr = addr (last_info_block (0));
     3837 	        last_info.new_last_info_ptr = addr (last_info_block (1));
     3838 	        new_last_info.new_last_info_ptr = last_info_ptr;
     3839 
     3840 	        do i = 1 to n_int;			/* for each interval accumulate descriptors */
     3841 		 current_retry_loc = outer_retry;
     3842 outer_loop:
     3843 		 if common_sl_info.status_only
     3844 		 then
     3845 		    do;
     3846 		       last_head = "";
     3847 		       call position_bof;
     3848 		       if last_branch_num = 1		/* file is empty */
     3849 		       then go to next_interval;
     3850 		    end;
     3851 		 else
     3852 		    do;
     3853 		       if ((hi_sl_info.last_head.length (i) < 0)
     3854 			& (hi_sl_info.first_head.kptr (i) = hi_sl_info.last_head.kptr (i)))
     3855 						/* else exact match required */
     3856 		       then head_spec = "0"b;
     3857 		       else head_spec = "1"b;
     3858 		       if head_spec			/* interval defined in terms of first and last head */
     3859 		       then
     3860 			do;
     3861 			   pad_key_len = 256;	/* must pad with zeroes for valid seek_head */
     3862 			   unspec (
     3863 			      substr (pad_key, hi_sl_info.first_head.length (i) + 1,
     3864 			      256 - hi_sl_info.first_head.length (i))) = "0"b;
     3865 						/* pad with zeroes */
     3866 			   substr (pad_key, 1, hi_sl_info.first_head.length (i)) =
     3867 			      substr (hi_sl_info.first_head.kptr (i) -> bstring, 1,
     3868 			      hi_sl_info.first_head.length (i));
     3869 			   call seek_head (1, addr (pad_key_info), hi_sl_info.first_head.length (i));
     3870 			   if pos_ptr = indx_cb.root_position_ptr
     3871 						/* head not found */
     3872 			   then go to next_interval;
     3873 			   last_head =
     3874 			      substr (hi_sl_info.last_head.kptr (i) -> bstring, 1,
     3875 			      abs (hi_sl_info.last_head.length (i)));
     3876 			   if (hi_sl_info.last_head.length (i) < 0)
     3877 			   then open_ended = "1"b;
     3878 			   else open_ended = "0"b;
     3879 			end;
     3880 		       else
     3881 			do;			/* force exact match with given key */
     3882 			   open_ended = "0"b;
     3883 			   vpad_key =
     3884 			      substr (hi_sl_info.first_head.kptr (i) -> bstring, 1,
     3885 			      hi_sl_info.first_head.length (i));
     3886 			   file_position_ptr = root_position_ptr;
     3887 						/* prepare for descent */
     3888 			   call find_key (indx_cb_ptr, (addr (vpad_key)), search_code);
     3889 			   pos_ptr = file_position_ptr;
     3890 			   if search_code = 0	/* not found */
     3891 			   then go to next_interval;
     3892 			   call find_from_leaf;	/* in case match in upper node */
     3893 			   last_head_len = 256;
     3894 			   substr (last_head, 1, length (vpad_key)) = vpad_key;
     3895 			   substr (last_head, length (vpad_key) + 1, 256 - length (vpad_key)) =
     3896 			      substr (blanks, 1, 256 - length (vpad_key));
     3897 			end;
     3898 		    end;
     3899 		 last_key = substr (keys, key_pos (branch_num), key_length (branch_num));
     3900 		 last_descrip = record_designator (branch_num);
     3901 
     3902 inner_loop:
     3903 		 do while (substr (last_key, 1, min (length (last_head), length (last_key))) <= last_head);
     3904 						/* pick up each index entry in this interval */
     3905 		    if substr (last_key, 1, min (length (last_head), length (last_key))) = last_head
     3906 						/*
     3907*						   exact match of head */
     3908 		    then if open_ended
     3909 		         then go to next_interval;	/* done with this interval */
     3910 		    if indx_cb.shared & ^indx_cb.leave_locked
     3911 						/* may have undergone asynch changes */
     3912 		    then if file_base.change_count ^= indx_cb.last_change_count
     3913 						/* has changed */
     3914 		         then
     3915 			  do;
     3916 			     call note_last_subset;
     3917 			     call prepare_process;
     3918 			     if current_retry_loc ^= inner_retry
     3919 			     then go to retry_loc (current_retry_loc);
     3920 retry_loc (19):
     3921 			     call find_entry (last_key, last_descrip);
     3922 			     if search_code = 0	/* prev entry not found */
     3923 			     then
     3924 			        do;		/* abort--can't find previous position */
     3925 				 call note_last_subset;
     3926 				 code = error_table_$asynch_deletion;
     3927 				 go to verify_done; /* may retry again if another asynch change */
     3928 			        end;
     3929 			     go to inner_loop;	/* resume inner loop scan from last position */
     3930 			  end;
     3931 		         else current_retry_loc = inner_retry;
     3932 		    if indx_cb.subset_selected ^= "00"b
     3933 		    then
     3934 		       do;
     3935 			call check_subset (last_descrip);
     3936 			if rec_deleted		/* this descriptor has been masked */
     3937 			then go to next_entry;	/* just skip to next */
     3938 		       end;
     3939 		    temp_key_words (1) = next_subset;
     3940 		    temp_key_words (2) = last_descrip;
     3941 		    call enter_temp_key;
     3942 next_entry:
     3943 		    branch_num = branch_num + 1;
     3944 		    call find_this_entry;
     3945 		    new_last_key = substr (keys, key_pos (branch_num), key_length (branch_num));
     3946 		    new_last_descrip = record_designator (branch_num);
     3947 		    last_info_ptr = last_info.new_last_info_ptr;
     3948 		    if pos_ptr = root_position_ptr	/* at eof */
     3949 		    then go to next_interval;		/* done with this interval */
     3950 		 end;
     3951 
     3952 next_interval:
     3953 		 if indx_cb.shared & ^indx_cb.leave_locked
     3954 		 then if indx_cb.last_change_count ^= file_base.change_count
     3955 		      then
     3956 		         do;
     3957 			  if current_retry_loc ^= outer_retry
     3958 			  then go to retry_loc (current_retry_loc);
     3959 retry_loc (20):
     3960 			  call note_last_subset;
     3961 			  call prepare_process;
     3962 			  go to outer_loop;
     3963 		         end;
     3964 	        end;				/* end of outer loop */
     3965 
     3966 	     end;					/* end of interval list case */
     3967 	  else if common_sl_info.list_type = 2		/* descriptor array specification */
     3968 	  then
     3969 	     do i = 1 to common_sl_info.array_limit;	/* use descriptors from list */
     3970 	        if indx_cb.subset_selected ^= "00"b
     3971 	        then call check_subset (da_sl_info.desc_array (i));
     3972 	        else rec_deleted = "0"b;
     3973 	        if ^rec_deleted
     3974 	        then
     3975 		 do;
     3976 		    temp_key_words (1) = next_subset;
     3977 		    temp_key_words (2) = da_sl_info.desc_array (i);
     3978 		    call enter_temp_key;
     3979 		 end;
     3980 	     end;
     3981 
     3982          end;					/* count is now known */
     3983       if count = 0					/* no records found */
     3984       then code = error_table_$no_record;
     3985       else
     3986          do;
     3987 	  code = 0;
     3988 	  if (flag = select_flag) | ((flag ^= select_flag) & (indx_cb.subset_selected = "00"b))
     3989 	  then indx_cb.subset_count = count;
     3990 	  else if indx_cb.subset_selected = "10"b
     3991 	  then indx_cb.subset_count = indx_cb.subset_count - count;
     3992 						/* entries removed from subset */
     3993 	  else indx_cb.subset_count = indx_cb.subset_count + count;
     3994 						/* entries added to exclude list */
     3995 	  indx_cb.current_subset = next_subset;
     3996 	  call note_last_subset;
     3997 
     3998 	  if common_sl_info.status_only
     3999 	  then go to get_status;
     4000 	  if (flag = select_flag) | ((flag ^= select_flag) & (indx_cb.subset_selected = "10"b))
     4001 	  then indx_cb.subset_selected = "10"b;		/* pure selection */
     4002 	  else indx_cb.subset_selected = "01"b;		/* pure exclusion */
     4003          end;
     4004 get_status:
     4005       call get_subset_status;
     4006       return;					/* end of generate subset--done with select or exclude */
     4007 
     4008 get_temp_switch:
     4009    proc;						/* obtains temp file for sorting descriptors */
     4010       unique_name = unique_chars_ ("0"b) || ".temp.vfile_";
     4011       proc_dir_string = get_pdir_ ();
     4012 
     4013       pd_path_len = index (proc_dir_string, " ") - 1;
     4014       call iox_$attach_name (unique_name, iocbp, "vfile_ " || proc_dir_path || ">" || unique_name, null, code);
     4015       call iox_$open (iocbp, 10, "0"b, code);
     4016       call check_code (code, "Cannot open temporary subset file.");
     4017       indx_cb.temp_iocbp = iocbp;
     4018       dcl	    unique_chars_	       entry (bit (*)) returns (char (15));
     4019       dcl	    1 proc_dirp_overlay,
     4020 	      2 pd_path_len	       fixed,
     4021 	      2 proc_dir_string    char (168);
     4022       dcl	    proc_dir_path	       char (168) var based (addr (pd_path_len));
     4023       dcl	    iocbp		       ptr;
     4024    end get_temp_switch;
     4025 
     4026 enter_temp_key:
     4027    proc;						/* adds entry to temp file or removes entry and adjusts count */
     4028       if (flag = select_flag) | ((flag ^= select_flag) & (indx_cb.subset_selected ^= "10"b))
     4029       then
     4030          do;
     4031 	  call control_indx_file (indx_cb.temp_iocbp, "add_key", addr (temp_ak_inf), code);
     4032 	  if code = 0
     4033 	  then count = count + 1;
     4034 	  else if code ^= error_table_$key_duplication
     4035 	  then
     4036 	     do;
     4037 	        call note_last_subset;
     4038 	        call check_code (code, "Can't add descriptor into current subset.");
     4039 	     end;
     4040          end;
     4041       else
     4042          do;
     4043 	  call control_indx_file (indx_cb.temp_iocbp, "delete_key", addr (temp_ak_inf), code);
     4044 	  if code = 0
     4045 	  then count = count + 1;
     4046 	  else if code ^= error_table_$no_key
     4047 	  then
     4048 	     do;
     4049 	        call note_last_subset;
     4050 	        call check_code (code, "Can't remove descriptor from current subset.");
     4051 	     end;
     4052          end;
     4053    end enter_temp_key;
     4054 
     4055 note_last_subset:
     4056    proc;						/* keeps track of highest used subset number */
     4057       if count = 0					/* no entries in new subset */
     4058       then return;					/* no adjustment needed */
     4059       indx_cb.last_subset = max (indx_cb.last_subset, next_subset);
     4060    end note_last_subset;
     4061 
     4062 reassign_key:					/* routine swaps record descrip for spec key */
     4063       call verify_keyed_update;			/* checks opening mode */
     4064       current_retry_loc = rk_retry;
     4065       go to init_up_down;
     4066 retry_loc (21):
     4067       saved_state.current_record_is_valid = indx_cb.current_record_is_valid;
     4068       saved_state.current_descrip = indx_cb.current_descrip;
     4069       pos_unchanged = "0"b;
     4070       if ^rk_inf.input_key & indx_cb.outside_index	/* error--no key associated with current rec */
     4071       then code = error_table_$no_key;
     4072       else if ^rk_inf.input_old_desc | ^rk_inf.input_new_desc
     4073 						/* need current descrip */
     4074       then call check_current;
     4075       else if ^rk_inf.input_key			/* using current record's key */
     4076       then
     4077          do;
     4078 	  call check_current;			/* need current record to be defined */
     4079 	  if code ^= 0				/* error */
     4080 	  then code = error_table_$no_key;		/* set proper code */
     4081          end;
     4082       if code ^= 0
     4083       then go to verify_done;				/* abort on error */
     4084       if rk_inf.input_old_desc
     4085       then old_des = rk_inf.old_descrip;
     4086       else old_des = indx_cb.current_descrip;
     4087       if rk_inf.input_new_desc
     4088       then new_des = rk_inf.new_descrip;
     4089       else new_des = indx_cb.current_descrip;
     4090       if rk_inf.input_key
     4091       then
     4092          do;
     4093 	  if ^indx_cb.shared | ^saved_state.current_record_is_valid
     4094 	  then call save_correct_pos;
     4095 	  if ^indx_cb.at_bof & ^indx_cb.at_eof
     4096 	     & ((indx_cb.next_record_position ^= 0) | (indx_cb.current_record_is_valid & ^indx_cb.outside_index))
     4097 	     & (old_des = indx_cb.saved_descrip) & (indx_cb.new_key = key_to_reassign)
     4098 	  then
     4099 	     do;
     4100 	        if indx_cb.pos_incorrect
     4101 	        then
     4102 		 do;
     4103 		    call restore_position;
     4104 		    if (code = 0) & (record_designator (branch_num) ^= indx_cb.saved_descrip)
     4105 		    then code = error_table_$asynch_deletion;
     4106 						/* insist on same
     4107*						   descriptor */
     4108 		 end;
     4109 	        else pos_ptr = indx_cb.file_position_ptr;
     4110 	        pos_unchanged = "1"b;
     4111 	        first_code = 1;			/* anything non-zero indicates key was found */
     4112 	        search_code = 1;			/* indicates descriptor was found */
     4113 	     end;
     4114 	  else call find_entry (key_to_reassign, old_des);/* look for entry */
     4115          end;
     4116       else if rk_inf.input_old_desc			/* key is same, but entry may be different */
     4117       then
     4118          do;
     4119 	  if ^indx_cb.shared | ^saved_state.current_record_is_valid
     4120 	  then call save_correct_pos;
     4121 	  if old_des = indx_cb.saved_descrip
     4122 	  then
     4123 	     do;
     4124 	        pos_unchanged = "1"b;
     4125 	        first_code = 1;
     4126 	        search_code = 1;
     4127 	     end;
     4128 	  else call find_entry (indx_cb.new_key, old_des);
     4129          end;
     4130       else
     4131          do;					/* file position is already correct */
     4132 	  first_code = 1;
     4133 	  search_code = 1;
     4134 	  pos_unchanged = "1"b;
     4135          end;
     4136       if ^pos_unchanged
     4137       then indx_cb.pos_incorrect = "1"b;
     4138       if first_code = 0				/* key not found */
     4139       then code = error_table_$no_key;
     4140       else if search_code = 0				/* key found, but not specified descrip */
     4141       then code = error_table_$no_record;
     4142       if code ^= 0
     4143       then go to verify_done;
     4144       indx_cb.current_descrip = old_des;
     4145       if indx_cb.stat				/* look for ref counts */
     4146       then
     4147          do;
     4148 	  saved_state.outside_index = indx_cb.outside_index;
     4149 	  indx_cb.outside_index = "0"b;		/* in case of garbage collection */
     4150 	  call lock_current_record (block_ptr, lock_ptr, i_locked_rec_mask, -1);
     4151 						/* decrement old record ref count */
     4152 	  indx_cb.outside_index = saved_state.outside_index;
     4153 						/* restore */
     4154 	  if code ^= 0
     4155 	  then if (code ^= error_table_$locked_by_this_process) & (code ^= error_table_$invalid_lock_reset)
     4156 	       then
     4157 		do;
     4158 		   if saved_state.current_record_is_valid
     4159 		   then indx_cb.current_descrip = saved_state.current_descrip;
     4160 		   else indx_cb.current_descrip = indx_cb.saved_descrip;
     4161 		   go to verify_done;
     4162 		end;
     4163 	  old_ref_cnt = ref_cnt;
     4164 	  current_retry_loc = reass_key_retry_2;
     4165 	  indx_cb.current_descrip = new_des;
     4166 retry_loc (22):
     4167 	  indx_cb.outside_index = "0"b;
     4168 	  call lock_current_record (new_block_ptr, new_lock_ptr, i_locked_new_mask, 1);
     4169 	  indx_cb.outside_index = saved_state.outside_index;
     4170 	  if (code ^= 0)
     4171 	  then if (code ^= error_table_$locked_by_this_process) & (code ^= error_table_$invalid_lock_reset)
     4172 	       then
     4173 		do;				/* undo any change and abort */
     4174 		   if saved_state.current_record_is_valid
     4175 		   then indx_cb.current_descrip = saved_state.current_descrip;
     4176 		   else indx_cb.current_descrip = indx_cb.saved_descrip;
     4177 		   go to unlock_exit;
     4178 		end;
     4179 	       else code = 0;			/* suppress non-fatal warning */
     4180          end;
     4181       else
     4182          do;
     4183 	  block_ptr = null;
     4184 	  new_block_ptr = null;
     4185          end;
     4186       if saved_state.current_record_is_valid
     4187       then indx_cb.current_descrip = saved_state.current_descrip;
     4188       else indx_cb.current_descrip = indx_cb.saved_descrip;
     4189       call initialize_substate;
     4190       call set_rk_info;				/* saves info for recovery */
     4191       file_action = reassigning_key;
     4192       file_base.change_count = file_base.old_file_ch_count + 1;
     4193       if block_ptr ^= null
     4194       then if block_ptr -> record_block.stationary
     4195 	 then
     4196 	    do;
     4197 	       block_ptr -> stat_struct.ref_count_after = file_base.old_ref_count;
     4198 	       block_ptr -> stat_struct.ref_count = file_base.old_ref_count;
     4199 	    end;
     4200       if new_block_ptr ^= null
     4201       then if new_block_ptr -> record_block.stationary
     4202 	 then
     4203 	    do;
     4204 	       new_block_ptr -> stat_struct.ref_count_after = file_base.new_ref_count;
     4205 	       new_block_ptr -> stat_struct.ref_count = file_base.new_ref_count;
     4206 	    end;
     4207       record_descrip (branch_num) = file_base.new_descriptor;
     4208       go to switch_file_state;			/* end of reassign key routine */
     4209 
     4210 set_rk_info:
     4211    proc;						/* saves reassign key info for recovery */
     4212       if repeating
     4213       then
     4214          do;
     4215 	  pos_ptr = indx_cb.file_position_ptr;		/* reconstruct during recovery */
     4216 	  call check_file_substate;
     4217 	  return;
     4218          end;
     4219       if (block_ptr = null)
     4220       then file_base.was_stat = "0"b;
     4221       else if block_ptr -> record_block.stationary
     4222       then
     4223          do;
     4224 	  file_base.was_stat = "1"b;
     4225 	  file_base.old_ref_count = old_ref_cnt;
     4226          end;
     4227       else file_base.was_stat = "0"b;
     4228       if (new_block_ptr ^= null)
     4229       then if new_block_ptr -> record_block.stationary
     4230 	 then
     4231 	    do;
     4232 	       file_base.was_stat = "1"b;
     4233 	       file_base.new_ref_count = ref_cnt;
     4234 	    end;
     4235       file_base.new_descriptor = new_des;
     4236       file_base.old_record_designator = old_des;		/* now save index location in convenient header variables */
     4237       file_base.first_branch = node;			/* same protected variable used by rewrite */
     4238       file_base.count = branch_num;
     4239       file_substate = file_substate + 1;		/* note this block of code has been completed */
     4240    end set_rk_info;
     4241 
     4242 set_lock_list_entry:
     4243    proc (block_ptr_arg, passive_ref_mask);		/* add non-passive reference list entry after
     4244*						   verifying any prior reference */
     4245       passive = "0"b;
     4246       must_verify = indx_cb.shared;
     4247       go to main;
     4248 add_lock_list_entry:
     4249    entry (block_ptr_arg, passive_ref_mask);		/* create entry for new record */
     4250       passive = "0"b;
     4251       must_verify = "0"b;
     4252       go to main;
     4253 set_ref_list_entry:
     4254    entry (block_ptr_arg);				/* adds item to passive ref list */
     4255       passive = "1"b;				/* not locking an item */
     4256       must_verify = "1"b;
     4257 main:
     4258       if indx_cb.tcfp -> iocb.open_data_ptr -> indx_cb.reflp = null
     4259       then
     4260          do;					/* initialize ref list */
     4261 	  call transaction_call_$setup_ref_list (indx_cb.tcfp, er_code);
     4262 	  call check_code (er_code, "Unable to initialize a transaction reference list.");
     4263          end;
     4264       refp = indx_cb.tcfp -> iocb.open_data_ptr -> indx_cb.reflp;
     4265       if indx_cb.uid = "0"b				/* comp 0 uid has not yet been obtained */
     4266       then call init_uid_info;			/* gets uid--by now file will be an msf */
     4267       temp_key.transaction_number = current_t_code;
     4268       temp_key.file_id = indx_cb.uid;			/* for process independent record locator */
     4269       temp_key.rec_id = indx_cb.current_descrip;
     4270       temp_key.blockp = block_ptr_arg;			/* this shouldn't really be necessary when right */
     4271       if ^must_verify				/* just add lock list entry for new record */
     4272       then
     4273          do;					/* don't bother to verify */
     4274 	  temp_ak_inf.flags = "11"b;
     4275 	  temp_ak_inf.key_len = 16;			/* short form */
     4276 	  temp_ak_inf.descrip = -1;			/* non-passive reference */
     4277 	  call iox_$control (refp, "add_key", addr (temp_ak_inf), er_code);
     4278 	  if (er_code ^= 0) & (er_code ^= error_table_$key_duplication)
     4279 						/* avoid cost of calling check_code if not needed */
     4280 	  then call check_code (er_code, "Can't create a ref list entry for the new record.");
     4281 	  return;
     4282          end;
     4283       temp_key.time = 0;				/* pad with 0's */
     4284       temp_rk_inf.key_len = 22;
     4285       indx_cb_ptr = refp -> iocb.open_data_ptr;		/* set up for seek_head */
     4286       call seek_head (0, addr (temp_rk_inf.key_len), 12);	/* sets pos_ptr to root if fails */
     4287       if (passive & ((cur_mod = 0) | (cur_mod = -1))) /* modifier isn't enough to uniquely
     4288*						   identify this record's image */
     4289          | (^passive & (block_ptr_arg -> stat_struct.prev_mod = 0))
     4290 						/* prev image requires
     4291*						   long form verification */
     4292       then
     4293          do;
     4294 	  temp_key.time = time_stamp;
     4295 	  temp_rk_inf.old_descrip = ind_desc;
     4296 	  if passive				/* record modifier will be non-positive */
     4297 	  then temp_rk_inf.new_descrip = ind_desc;	/* also setting add_key's
     4298*						   descriptor in info structure */
     4299 	  else temp_rk_inf.new_descrip = -1;
     4300          end;
     4301       else
     4302          do;					/* short form ref list entry */
     4303 	  temp_rk_inf.key_len = 16;
     4304 	  temp_rk_inf.old_descrip = cur_mod;		/* current image id */
     4305 	  if ^passive
     4306 	  then temp_rk_inf.new_descrip = -1;		/* this value means ref is to lock */
     4307 	  else temp_rk_inf.new_descrip = cur_mod;
     4308          end;
     4309       if pos_ptr ^= indx_cb.root_position_ptr		/* not first ref */
     4310       then if (record_designator (branch_num) = temp_rk_inf.old_descrip)
     4311 	    & (substr (keys, key_pos (branch_num), key_length (branch_num)) = rk_key)
     4312 	 then
     4313 	    do;					/* prev ref is verified */
     4314 	       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
     4315 	       pos_ptr = indx_cb.file_position_ptr;	/* restore local environment */
     4316 	       if ^passive				/* verified ref was to lock */
     4317 	       then
     4318 		do;
     4319 		   cleanup_flags = cleanup_flags | passive_ref_mask;
     4320 						/* remember that refl entry exists */
     4321 		   if temp_rk_inf.key_len = 16	/* old ref in short form */
     4322 		   then
     4323 		      do;				/* just reassign--already short form */
     4324 		         temp_rk_inf.flags = "111"b;	/* input all params */
     4325 		         call iox_$control (refp, "reassign_key", addr (temp_rk_inf), er_code);
     4326 		         if er_code ^= 0		/* optimization */
     4327 		         then call
     4328 			       check_code (er_code,
     4329 			       "Can't convert a short form passive ref list entry into a non-passive one.");
     4330 		      end;			/* end of simple reassignment case */
     4331 		   else
     4332 		      do;				/* convert long form passive entry into
     4333*						   short form non-passive ref list entry */
     4334 		         temp_ak_inf.key_len = 16;
     4335 		         temp_ak_inf.flags = "11"b;	/* input key and desc */
     4336 		         call iox_$control (refp, "add_key", addr (temp_ak_inf), er_code);
     4337 						/* add new entry before removing old one */
     4338 		         if (er_code ^= 0) & (er_code ^= error_table_$key_duplication)
     4339 		         then call
     4340 			       check_code (er_code,
     4341 			       "Can't add a non-passive ref list entry for a previous long form passive reference.")
     4342 			       ;
     4343 		         temp_ak_inf.key_len = 22;	/* set up to delete
     4344*						   long form entry */
     4345 		         temp_ak_inf.descrip = ind_desc;
     4346 		         call iox_$control (refp, "delete_key", addr (temp_ak_inf), er_code);
     4347 		         if er_code ^= 0
     4348 		         then call
     4349 			       check_code (er_code,
     4350 			       "Can't delete the old long form passive ref list entry for a subsequently modified item."
     4351 			       );
     4352 		      end;
     4353 		end;
     4354 	    end;					/* end of verified ref case */
     4355 	 else
     4356 	    do;					/* error--prev reference invalid */
     4357 	       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
     4358 	       pos_ptr = indx_cb.file_position_ptr;
     4359 	       if key_length (branch_num) = 16
     4360 	       then if record_designator (branch_num) = -1/* thought I locked it--maybe interrupted */
     4361 		  then if block_ptr_arg -> stat_struct.record_lock = indx_cb.saved_lock_copy
     4362 		       then return;			/* suppress error message */
     4363 	       code = error_table_$asynch_change;
     4364 	    end;
     4365       else
     4366          do;					/* add a ref list entry for first ref this transaction */
     4367 	  indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
     4368 	  pos_ptr = indx_cb.file_position_ptr;
     4369 	  temp_ak_inf.flags = "11"b;
     4370 	  if ^passive
     4371 	  then temp_ak_inf.key_len = 16;		/* create short form entry */
     4372 	  call iox_$control (refp, "add_key", addr (temp_ak_inf), er_code);
     4373 	  if er_code ^= 0
     4374 	  then call check_code (er_code, "Can't create a new ref list entry for this item.");
     4375          end;					/* end of no previous reference case */
     4376       return;					/* done with ref list manipulation */
     4377 
     4378 init_uid_info:
     4379    proc;						/* gets uid for this file from component 0 */
     4380 						/* also may create a ref list entry to remember iocb_ptr, if no such entry
     4381*						   already exists for this file in this process */
     4382       call hcs_$get_uid_seg (indx_cb.file_base_ptr, uid_val, er_code);
     4383       call check_code (er_code, "Cannot get a uid for the file.");
     4384       unspec (gk_inf.flags) = "0"b;
     4385       gk_inf.input_key = "1"b;
     4386       gk_inf.head_size = 12;
     4387       gk_inf.key_len = 12;
     4388       gk_key.zero = 0;
     4389       gk_key.proc_id = indx_cb.saved_lock_copy;
     4390       gk_key.file_id = uid_val;
     4391       refp = indx_cb.tcfp -> iocb.open_data_ptr -> indx_cb.reflp;
     4392       call iox_$control (refp, "get_key", addr (gk_inf), er_code);
     4393       if er_code = 0				/* file is known to this ref list */
     4394       then if gk_desc = iocb_ptr			/* this I/O switch */
     4395 	 then return;				/* nothing more to do--refl entry is fine */
     4396 	 else
     4397 	    do;					/* set refl entry to use this iocb_ptr */
     4398 	       string (rk_inf.flags) = "111"b;
     4399 	       rk_inf.old_descrip = rk_inf.new_descrip;	/* set by gk */
     4400 	       gk_desc = iocb_ptr;			/* new descrip for reassign_key */
     4401 	       call iox_$control (refp, "reassign_key", addr (rk_inf), er_code);
     4402 	       call
     4403 		check_code (er_code, "Can't reset default iocb_ptr for this file in the transaction reference list.");
     4404 	    end;
     4405       else
     4406          do;					/* attempt to create new refl entry */
     4407 	  string (ak_inf.flags) = "11"b;		/* input key and desc */
     4408 	  gk_desc = iocb_ptr;
     4409 	  call iox_$control (refp, "add_key", addr (ak_inf), er_code);
     4410 	  call check_code (er_code, "Can't save the iocb_ptr for this file in the transaction reference list.");
     4411          end;
     4412       indx_cb.uid = uid_val;
     4413       dcl	    refp		       ptr;
     4414       dcl	    uid_val	       bit (36) aligned;
     4415       dcl	    er_code	       fixed (35);
     4416       dcl	    1 rk_inf,
     4417 	      2 header	       like rk_header,
     4418 	      2 key	       char (12);
     4419       dcl	    1 gk_inf	       based (addr (rk_inf.old_descrip)),
     4420 	      2 header	       like gk_header,
     4421 	      2 key	       char (12);
     4422       dcl	    1 ak_inf	       based (addr (rk_inf.old_descrip)),
     4423 	      2 header	       like ak_header,
     4424 	      2 key	       char (12);
     4425       dcl	    gk_desc	       ptr unal based (addr (gk_inf.descrip));
     4426       dcl	    1 gk_key	       based (addr (gk_inf.key)),
     4427 	      2 zero	       fixed (35),
     4428 	      2 proc_id	       bit (36) aligned,
     4429 	      2 file_id	       bit (36) aligned;
     4430    end init_uid_info;
     4431 
     4432       dcl	    passive	       bit (1) aligned;
     4433       dcl	    must_verify	       bit (1) aligned;
     4434       dcl	    er_code	       fixed (35);
     4435       dcl	    1 temp_rk_inf,
     4436 	      2 flags	       bit (36) aligned,
     4437 	      2 old_descrip	       fixed (35),
     4438 	      2 new_descrip	       fixed (35),
     4439 	      2 key_len	       fixed,
     4440 	      2 key	       char (22);
     4441       dcl	    1 temp_ak_inf	       based (addr (temp_rk_inf.old_descrip)),
     4442 	      2 flags	       bit (36) aligned,
     4443 	      2 descrip	       fixed (35),
     4444 	      2 key_len	       fixed,
     4445 	      2 key	       char (22);
     4446       dcl	    refp		       ptr;
     4447       dcl	    1 temp_key	       based (addr (temp_rk_inf.key)),
     4448 	      2 transaction_number fixed (35),
     4449 	      2 file_id	       bit (36) aligned,
     4450 	      2 rec_id	       fixed (35),
     4451 	      2 blockp	       ptr unal,		/* should not be needed when done right */
     4452 	      2 time	       fixed (53) unal;	/* long form only */
     4453       dcl	    rk_key	       char (22) var based (addr (temp_rk_inf.key_len));
     4454       dcl	    block_ptr_arg	       ptr;
     4455       dcl	    passive_ref_mask       bit (36) aligned;
     4456    end set_lock_list_entry;
     4457 
     4458 restore_abort:
     4459    proc;						/* cleans up after unusual abort */
     4460       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
     4461       indx_cb.pos_incorrect = "1"b;			/* restore indx_cb state */
     4462       call restore_state;
     4463       if cleanup_flags = "000000"b
     4464       then return;					/* nothing to unlock */
     4465       aborting = "1"b;
     4466       if i_locked_file
     4467       then if stacq (file_base.lock_word, (36)"1"b, indx_cb.saved_lock_copy)
     4468 	 then ;					/* invalidate file lock */
     4469       if i_locked_rec & (block_ptr ^= null) & (lock_ptr ^= null)
     4470       then if indx_cb.trans
     4471 	 then if block_ptr -> record_block.stationary
     4472 	      then if (block_ptr -> stat_struct.modifier > 0) & (block_ptr -> stat_struct.modifier = current_t_code)
     4473 		 then ;				/* leave old record locked--has a lock list entry */
     4474 		 else if old_passive_ref
     4475 		 then ;
     4476 		 else go to inv_old;
     4477 	      else go to inv_old;
     4478 	 else
     4479 	    do;
     4480 inv_old:
     4481 	       if stacq (lock_ptr -> based_lock, (36)"1"b, indx_cb.saved_lock_copy)
     4482 	       then ;
     4483 	    end;
     4484       if i_locked_new & (new_block_ptr ^= null) & (new_lock_ptr ^= null)
     4485       then if indx_cb.trans
     4486 	 then if new_block_ptr -> record_block.stationary
     4487 	      then if (new_block_ptr -> stat_struct.modifier > 0)
     4488 		    & (new_block_ptr -> stat_struct.modifier = current_t_code)
     4489 		 then ;
     4490 		 else if new_passive_ref
     4491 		 then ;
     4492 		 else go to inv_new;
     4493 	      else go to inv_new;
     4494 	 else
     4495 	    do;
     4496 inv_new:
     4497 	       if stacq (new_lock_ptr -> based_lock, (36)"1"b, indx_cb.saved_lock_copy)
     4498 	       then ;
     4499 	    end;
     4500    end restore_abort;
     4501 
     4502 restore_state:
     4503    proc;						/* re-establishes initial values of process vars which may have been clobbered */
     4504       indx_cb.mode = atb.opening_mode;
     4505       indx_cb.is_sequential_open = (indx_cb.mode < 11);
     4506       indx_cb.is_read_only = substr ("0001000100100"b, indx_cb.mode, 1);
     4507       indx_cb.is_ks_out = (indx_cb.mode = 9);
     4508       if current_retry_loc = skip_retry			/* position skip attempt */
     4509       then indx_cb.error = saved_error_info;
     4510       else if (current_retry_loc = init_retry) | (current_retry_loc = inner_retry) | (current_retry_loc = outer_retry)
     4511 						/* select or exclude */
     4512       then
     4513          do;					/* restore subset state */
     4514 	  indx_cb.subset_selected = saved_subset_selected;
     4515 	  indx_cb.current_subset = saved_current_subset;
     4516          end;
     4517       indx_cb.state_vars = saved_state;
     4518    end restore_state;
     4519 
     4520 open_file:
     4521       call create_indx_cb;
     4522       if is_new_file
     4523       then call initialize_new_file;
     4524       else if file_version ^= current_file_version
     4525       then
     4526          do;
     4527 	  call check_file_version (indx_cb_ptr, code);	/* checks for pre-crashproof version */
     4528 	  if code ^= 0
     4529 	  then
     4530 	     do;
     4531 	        saved_state.shared = indx_cb.shared;
     4532 	        call free_cb_file (size (indx_cb), indx_cb_ptr);
     4533 	        if ^substr ("0001000100100"b, atb.opening_mode, 1) & saved_state.shared
     4534 	        then call set_lock_$unlock (lock_word, foo);
     4535 	        return;
     4536 	     end;
     4537          end;
     4538       else call check_comp_array_table;			/* To catch bad tables produced by bug in */
     4539 						/* check_file_version . */
     4540       call create_seg_ptrs (iocb_ptr);
     4541       call create_position_stack (indx_cb_ptr);
     4542       if (file_action ^= 0) & ^is_read_only & (file_action ^= read_exclude)
     4543       then if file_base.program_version > current_program_version
     4544 	 then
     4545 	    do;
     4546 	       code = error_table_$unimplemented_version;
     4547 	       call
     4548 		sub_err_ (code, "vfile_", "c", null, code,
     4549 		"Can't adjust operation in progress with this version of vfile_.");
     4550 	    end;
     4551 	 else
     4552 	    do;
     4553 	       call restart (iocb_ptr, code);
     4554 	       fs_ptr = indx_cb.file_state_ptr;
     4555 	    end;
     4556       if (file_base.program_version < current_program_version_2) & indx_cb.stat & ^indx_cb.is_read_only & (code = 0)
     4557       then
     4558          do;
     4559 	  code = error_table_$unimplemented_version;
     4560 	  call
     4561 	     sub_err_ (code, "vfile_", "c", null, code, "Old version file does not support -stationary attach option.");
     4562          end;
     4563       foo = 0;					/* in case of cleanup */
     4564       if code = 0
     4565       then call set_entries_and_positions;
     4566       else go to cleanup_exit;
     4567       if is_read_only
     4568       then return;
     4569       if indx_cb.read_exclu
     4570       then file_action = read_exclude;
     4571       cleanup_flags = "100000"b;			/* just unlock the file */
     4572       current_retry_loc = cleanup_retry;		/* initialize this variable */
     4573       go to unlock_exit;
     4574 
     4575 close_indx_file:
     4576    entry (iocb_ptr);
     4577       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
     4578       f_b_ptr = file_base_ptr;
     4579       indx_cb.file_state_ptr = addr (file_state_blocks (file_state));
     4580       fs_ptr = indx_cb.file_state_ptr;
     4581       o_s_ptr = addr (file_state_blocks (1 - file_state));
     4582       os_ptr = o_s_ptr;
     4583 
     4584       foo = 0;
     4585       on seg_fault_error
     4586          begin;
     4587 	  foo = error_table_$lock_wait_time_exceeded;
     4588 	  go to cleanup_exit;
     4589          end;
     4590       if indx_cb.shared & ^is_read_only & ^leave_locked
     4591       then
     4592          do;					/* prepare to set bit counts */
     4593 	  call set_lock (addr (file_base.lock_word), 0, foo);
     4594 	  if foo = error_table_$lock_wait_time_exceeded
     4595 	  then go to cleanup_exit;
     4596 	  if old_last_comp_num ^= last_comp_num		/* new component */
     4597 	  then
     4598 	     do;					/* recreate the seg_ptr_array */
     4599 	        call free_seg_ptrs (iocb_ptr);
     4600 	        call create_seg_ptrs (iocb_ptr);
     4601 	     end;
     4602          end;
     4603       if ^is_read_only
     4604       then call set_bitcounts (iocb_ptr);
     4605 retry_loc (23):
     4606 cleanup_exit:
     4607       revert seg_fault_error;
     4608       call free_seg_ptrs (iocb_ptr);
     4609       call free_position_stack (indx_cb_ptr);
     4610       call discard_temp_file (indx_cb.temp_iocbp);	/* subset file
     4611*						   can be thrown away, if one exists */
     4612       call discard_temp_file (indx_cb.reflp);		/* for transaction
     4613*						   control file only--throw away temporary reference list */
     4614       lock_copy = indx_cb.saved_lock_copy;
     4615       call free_cb_file (size (indx_cb), indx_cb_ptr);
     4616       if substr ("0001000100100"b, atb.opening_mode, 1) | (foo = error_table_$locked_by_this_process)
     4617          | (foo = error_table_$lock_wait_time_exceeded)
     4618       then return;					/* don't unlock in this case */
     4619       if file_action = read_exclude
     4620       then file_action = 0;				/* clear read lock */
     4621       if file_action = 0
     4622       then
     4623          do;
     4624 	  unspec (spare_node) = "0"b;			/* free unneeded storage */
     4625 	  if stacq (file_base.lock_word, "0"b, lock_copy) /* unlock */
     4626 	  then ;
     4627          end;
     4628       else if stacq (file_base.lock_word, (36)"1"b, lock_copy)
     4629       then ;					/* make it look like I died */
     4630       return;					/* end of close routine */
     4631 
     4632 set_entries_and_positions:
     4633    proc;
     4634       close_x = close_indx_file;
     4635       iocb_ptr -> iocb.control = control_indx_file;
     4636       go to open_case (mode);
     4637 open_case (4):					/* sequential input */
     4638       indx_cb.at_bof = "1"b;
     4639       iocb_ptr -> iocb.read_record = read_indx_file;
     4640       iocb_ptr -> iocb.read_length = read_length_indx_file;
     4641       iocb_ptr -> iocb.position = position_indx_file;
     4642       return;
     4643 open_case (7):					/* sequential update */
     4644       indx_cb.at_bof = "1"b;
     4645       iocb_ptr -> iocb.read_record = read_indx_file;
     4646       iocb_ptr -> iocb.read_length = read_length_indx_file;
     4647       iocb_ptr -> iocb.position = position_indx_file;
     4648       iocb_ptr -> iocb.rewrite_record = rewrite_indx_file;
     4649       iocb_ptr -> iocb.delete_record = delete_indx_file;
     4650       return;
     4651 open_case (8):					/* keyed sequential input */
     4652       indx_cb.at_bof = "1"b;
     4653       iocb_ptr -> iocb.read_record = read_indx_file;
     4654       iocb_ptr -> iocb.read_length = read_length_indx_file;
     4655       iocb_ptr -> iocb.read_key = read_key_indx_file;
     4656       iocb_ptr -> iocb.position = position_indx_file;
     4657       iocb_ptr -> iocb.seek_key = seek_key_indx_file;
     4658       return;
     4659 open_case (9):					/* keyed sequential output */
     4660       indx_cb.at_eof = "1"b;
     4661       iocb_ptr -> iocb.seek_key = seek_key_ks_out;
     4662       iocb_ptr -> iocb.write_record = write_indx_file;
     4663       return;
     4664 open_case (10):					/* keyed sequential update */
     4665       indx_cb.at_bof = "1"b;
     4666       iocb_ptr -> iocb.read_record = read_indx_file;
     4667       iocb_ptr -> iocb.read_length = read_length_indx_file;
     4668       iocb_ptr -> iocb.read_key = read_key_indx_file;
     4669       iocb_ptr -> iocb.position = position_indx_file;
     4670       iocb_ptr -> iocb.seek_key = seek_key_indx_file;
     4671       iocb_ptr -> iocb.control = control_indx_file;
     4672       iocb_ptr -> iocb.write_record = write_indx_file;
     4673       iocb_ptr -> iocb.rewrite_record = rewrite_indx_file;
     4674       iocb_ptr -> iocb.delete_record = delete_indx_file;
     4675       return;
     4676 open_case (11):					/* direct input */
     4677       iocb_ptr -> iocb.read_record = read_indx_file;
     4678       iocb_ptr -> iocb.read_length = read_length_indx_file;
     4679       iocb_ptr -> iocb.seek_key = seek_key_indx_file;
     4680       return;
     4681 open_case (12):					/* direct output */
     4682       iocb_ptr -> iocb.seek_key = seek_key_indx_file;
     4683       iocb_ptr -> iocb.write_record = write_indx_file;
     4684       return;
     4685 open_case (13):					/* direct update */
     4686       iocb_ptr -> iocb.read_record = read_indx_file;
     4687       iocb_ptr -> iocb.read_length = read_length_indx_file;
     4688       iocb_ptr -> iocb.seek_key = seek_key_indx_file;
     4689       iocb_ptr -> iocb.write_record = write_indx_file;
     4690       iocb_ptr -> iocb.rewrite_record = rewrite_indx_file;
     4691       iocb_ptr -> iocb.delete_record = delete_indx_file;
     4692    end set_entries_and_positions;
     4693 
     4694 create_indx_cb:
     4695    proc;						/* creates open data structure */
     4696       code = 0;
     4697       call alloc_cb_file (size (indx_cb), iocb_ptr -> iocb.open_data_ptr);
     4698       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
     4699       fcb_ptr = fcb_ptr_arg;
     4700       file_base_ptr = first_seg_ptr;
     4701       f_b_ptr = file_base_ptr;
     4702       last_change_count = change_count;			/* must be saved before referencing file_state */
     4703       mode = mode_arg;
     4704       is_sequential_open = (mode < 11);
     4705       is_read_only = substr ("0001000100100"b, mode, 1);
     4706       is_ks_out = (mode = 9);
     4707       indx_cb.next_record_position = 0;
     4708       indx_cb.current_record_is_valid = "0"b;
     4709       indx_cb.ready_to_write = "0"b;
     4710       indx_cb.shared = atb.shared;
     4711       indx_cb.wait_time = atb.wait_time;
     4712       repeating = "0"b;
     4713       file_state_ptr = addr (file_state_blocks (file_state));
     4714       fs_ptr = file_state_ptr;
     4715       o_s_ptr = addr (file_state_blocks (1 - file_state));
     4716       indx_cb.error.type = 0;				/* used by "error_status" control order */
     4717       indx_cb.at_bof = "0"b;				/* used in shared openings for asynch re-seeks */
     4718       indx_cb.at_eof = "0"b;
     4719       indx_cb.min_res = 0;				/* default is no spare space allocated with records */
     4720       indx_cb.min_cap = 0;				/* default is not to allocate null recs */
     4721       leave_locked = "0"b;				/* if shared, will leave unlocked between operations */
     4722       indx_cb.outside_index = "0"b;			/* may be set by "record_status" */
     4723       dup_ok = atb.dup_ok_sw | (duplicate_keys ^= 0);
     4724       indx_cb.stat = atb.stat_sw;			/* -stat option used */
     4725       indx_cb.read_exclu = atb.exclu_sw;		/* may be set by "set_file_lock" order */
     4726       indx_cb.pos_incorrect = "1"b;			/* may be set by "add_key", etc. */
     4727       indx_cb.saved_lock_copy = "0"b;			/* in case happens to contain a valid lock */
     4728       call set_lock_$lock (indx_cb.saved_lock_copy, 0, foo);
     4729       indx_cb.new_key = "";
     4730       file_position_ptr = null;
     4731       indx_cb.min_key_len = file_base.minimum_key_length;	/* non-zero for old files */
     4732       indx_cb.skip_state = 0;				/* default is to scan forward over deletions */
     4733       indx_cb.current_subset = 0;
     4734       indx_cb.last_subset = 0;
     4735       indx_cb.subset_selected = "00"b;
     4736       indx_cb.temp_iocbp = null;
     4737       indx_cb.trans = atb.trans_sw;			/* set if -transaction attachment */
     4738       if indx_cb.trans
     4739       then indx_cb.tcfp = atb.tcf_iocbp;		/* ptr to transaction control iocb */
     4740       else indx_cb.tcfp = null;
     4741       indx_cb.transaction_code = 0;
     4742       indx_cb.reflp = null;				/* used in transaction control file only */
     4743       indx_cb.collection_delay_time = 0;
     4744    end create_indx_cb;
     4745 check_comp_array_table:
     4746    proc;
     4747 
     4748 /*  This  looks  through  the comp_table comp_links for any component which is
     4749*   greater  than  the  maximum  component in use, identified by last_comp_num.
     4750*   Should  such a bogus comp_link be found, sub_err_ is signaled and vfile_ is
     4751*   ground to an unrestartable stop.  */
     4752 
     4753       dcl	    table_idx	       fixed bin (35);
     4754       do table_idx = lbound (comp_table, 1) to hbound (comp_table, 1);
     4755          if comp_table.comp_link (table_idx) > file_base.last_comp_num
     4756          then if is_read_only
     4757 	    then call
     4758 		  sub_err_ (error_table_$bad_file, "vfile_", "c", null, code,
     4759 		  "Previous modifications to this file may have resulted 
     4760 in lost data, due to incorrect information in the file_base 
     4761 of this file.  Type ""help damaged_keyed_files"" for more information.
     4762   Processing will continue.");
     4763 	    else
     4764 	       do;
     4765 		if stacq (file_base.common_header.lock_word, "0"b, indx_cb.saved_lock_copy)
     4766 		then ;
     4767 		call
     4768 		   sub_err_ (error_table_$bad_file, "vfile_", "s", null, error_table_$bad_file,
     4769 		   "This file cannot safely be 
     4770 updated due to incorrect information in its 
     4771 file_base.  Type ""help damaged_keyed_files"" 
     4772 for more information.");
     4773 	       end;
     4774       end;
     4775    end;
     4776 
     4777 discard_temp_file:
     4778    proc (iocbp);					/* cleanup routine for subsets and ref lists */
     4779       if iocbp = null
     4780       then return;					/* nothing to discard */
     4781       call iox_$close (iocbp, foo);
     4782       unique_name =
     4783          substr (iocbp -> iocb.attach_descrip_ptr -> based_vstring,
     4784          length (iocbp -> iocb.attach_descrip_ptr -> based_vstring) + 1 - length (unique_name), length (unique_name));
     4785 						/* unique name of temp file from attach description */
     4786       call hcs_$delentry_file (get_pdir_ (), unique_name, foo);
     4787 						/* delete temporary index */
     4788       call iox_$detach_iocb (iocbp, foo);
     4789       call iox_$destroy_iocb (iocbp, foo);
     4790       iocbp = null;
     4791       dcl	    iocbp		       ptr;
     4792       dcl	    foo		       fixed (35);
     4793    end discard_temp_file;
     4794 
     4795 initialize_new_file:
     4796    proc;						/* At this point all words except the common header are zero. This routine sets the nonzero values */
     4797       program_version = current_program_version;
     4798       max_seg_limit = component_size_arg;
     4799       minimum_block_size = minimum_block_size_val;
     4800       node_size = node_size_val;
     4801       last_branch_num_root = 1;
     4802       do foo = 0, 1;
     4803          addr (index_state_blocks (foo)) -> new_key_pos = node_head_length + branch_and_descrip_length + 1;
     4804       end;
     4805       max_comp_num = true_max_comp_num;
     4806       seg_limit (0) = node_size * (1 + divide (size (file_base) + node_size - 1, node_size, 17, 0));
     4807       call hcs_$set_bc_seg (file_base_ptr, 36 * size (file_base), foo);
     4808       file_version = current_file_version;		/* creation is thus atomic */
     4809       return;
     4810       dcl	    hcs_$set_bc_seg	       entry (ptr,		/* pointer to seg, input */
     4811 			       fixed bin (24),	/* bit count to be set */
     4812 			       fixed bin (35));	/* status code */
     4813    end initialize_new_file;
     4814 
     4815 check_file_substate:
     4816    proc;						/* keeps track of logical block during recovery execution */
     4817       next_substate = next_substate + 1;
     4818       if file_substate = next_substate
     4819       then repeating = "0"b;				/* execution resumes normally */
     4820    end check_file_substate;
     4821 
     4822 check_code:
     4823    proc (er_code, message);				/* unusual abort detector */
     4824       if er_code = 0
     4825       then return;
     4826       code = er_code;				/* give code back to caller after warning */
     4827       call sub_err_ (code, "vfile_", "c", null, code, message);
     4828       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
     4829       indx_cb.pos_incorrect = "1"b;
     4830       if cleanup_flags = "000000"b
     4831       then go to passive_abort;
     4832       aborting = "1"b;
     4833       go to unlock_exit;
     4834       dcl	    er_code	       fixed (35);
     4835       dcl	    message	       char (*);
     4836    end check_code;
     4837 
     4838 /* DECLARATIONS */
     4839       dcl	    i_locked_rec_mask      static internal options (constant) bit (36) aligned
     4840 			       init ("010101000000000000000000000000000000"b);
     4841       dcl	    i_locked_new_mask      static internal options (constant) bit (36) aligned
     4842 			       init ("001010100000000000000000000000000000"b);
     4843       dcl	    rec_lock_mask	       static internal options (constant) bit (36) aligned
     4844 			       init ("011000000000000000000000000000000000"b);
     4845       dcl	    negmod_mask	       static internal options (constant) bit (36) aligned
     4846 			       init ("000001100000000000000000000000000000"b);
     4847       dcl	    passive_ref_bit_mask   static internal options (constant) bit (36) aligned
     4848 			       init ("000110000000000000000000000000000000"b);
     4849       dcl	    old_passive_ref_mask   static internal options (constant) bit (36) aligned
     4850 			       init ("000100000000000000000000000000000000"b);
     4851       dcl	    new_passive_ref_mask   static internal options (constant) bit (36) aligned
     4852 			       init ("000010000000000000000000000000000000"b);
     4853       dcl	    seek_kso_retry	       static internal options (constant) init (1);
     4854       dcl	    seek_retry	       static internal options (constant) init (2);
     4855       dcl	    read_len_retry	       static internal options (constant) init (3);
     4856       dcl	    read_key_retry	       static internal options (constant) init (4);
     4857       dcl	    read_retry	       static internal options (constant) init (5);
     4858       dcl	    skip_retry	       static internal options (constant) init (6);
     4859       dcl	    pos_bof_or_eof_retry   static internal options (constant) init (7);
     4860       dcl	    gk_retry	       static internal options (constant) init (8);
     4861       dcl	    rs_retry_2	       static internal options (constant) init (9);
     4862       dcl	    rs_retry_1	       static internal options (constant) init (10);
     4863       dcl	    sh_retry	       static internal options (constant) init (11);
     4864       dcl	    rew_retry	       static internal options (constant) init (12);
     4865       dcl	    write_retry	       static internal options (constant) init (13);
     4866       dcl	    del_retry	       static internal options (constant) init (14);
     4867       dcl	    adj_retry	       static internal options (constant) init (15);
     4868       dcl	    ak_retry	       static internal options (constant) init (16);
     4869       dcl	    dk_retry	       static internal options (constant) init (17);
     4870       dcl	    init_retry	       static internal options (constant) init (18);
     4871       dcl	    inner_retry	       static internal options (constant) init (19);
     4872       dcl	    outer_retry	       static internal options (constant) init (20);
     4873       dcl	    rk_retry	       static internal options (constant) init (21);
     4874       dcl	    reass_key_retry_2      static internal options (constant) init (22);
     4875       dcl	    cleanup_retry	       static internal options (constant) init (23);
     4876       dcl	    lock_file_retry	       static internal options (constant) init (24);
     4877       dcl	    adj_file_retry	       static internal options (constant) init (25);
     4878       dcl	    based_area	       area based;
     4879       dcl	    system_freep	       ptr static internal init (null);
     4880       dcl	    get_system_free_area_  entry returns (ptr);
     4881       dcl	    delete_old_subsets     entry (ptr);
     4882       dcl	    rec_deleted	       bit (1) aligned;
     4883       dcl	    (stacq, string, clock, addrel, hbound,index,lbound,stac)
     4884 			       builtin;
     4885       dcl	    len		       fixed;
     4886       dcl	    1 saved_state	       like indx_cb.state_vars;
     4887       dcl	    saved_state_block      char (length (current_state_block)) based (addr (saved_state));
     4888       dcl	    saved_subset_selected  bit (2) aligned;
     4889       dcl	    saved_current_subset   fixed (34);
     4890       dcl	    1 saved_error_info     like indx_cb.error;
     4891       dcl	    current_state_block    char (4 * size (fixed_state_block) + 4 + length (indx_cb.new_key))
     4892 			       based (addr (indx_cb.state_vars));
     4893       dcl	    1 fixed_state_block    like indx_cb.fixed_state_part based;
     4894       dcl	    os_ptr	       ptr;
     4895       dcl	    branches_left	       fixed;
     4896       dcl	    count		       fixed (34);
     4897       dcl	    chunk_size	       fixed (34);
     4898       dcl	    first_code	       fixed (35);
     4899       dcl	    key_is_dup	       bit (1) aligned;
     4900       dcl	    passive_op	       bit (1) aligned;
     4901       dcl	    del_cur	       bit (1) aligned;
     4902       dcl	    fault_ok	       bit (1) aligned;
     4903       dcl	    (any_other, seg_fault_error)
     4904 			       condition;
     4905       dcl	    cleanup	       condition;
     4906       dcl	    current_retry_loc      fixed;
     4907       dcl	    need_pos	       fixed static options (constant) internal init (5);
     4908       dcl	    time_left	       fixed;
     4909       dcl	    timeout	       fixed (71);
     4910       dcl	    eternity	       static internal options (constant) fixed (71) init (1f70b);
     4911       dcl	    new_change_count       fixed (35);
     4912       dcl	    continue_to_signal_    entry (fixed (35));
     4913       dcl	    branch_and_descrip_length
     4914 			       static options (constant) fixed init (12);
     4915       dcl	    node_head_length       static options (constant) fixed init (16);
     4916       dcl	    restart	       entry (ptr, fixed (35));
     4917       dcl	    check_file_version     entry (ptr, fixed (35));
     4918       dcl	    find_key	       entry (ptr, ptr, fixed (35));
     4919       dcl	    find_key$last	       entry (ptr, ptr, fixed bin (35));
     4920       dcl	    set_lock_$lock	       entry (bit (36) aligned, fixed, fixed (35));
     4921       dcl	    set_lock_$unlock       entry (bit (36) aligned, fixed (35));
     4922 						/* Arguments */
     4923 
     4924       dcl	    buff_len	       fixed (21);
     4925       dcl	    buff_ptr	       ptr;
     4926       dcl	    close_x	       entry;
     4927       dcl	    code		       fixed (35);
     4928       dcl	    component_size_arg     fixed (19);
     4929       dcl	    fcb_ptr_arg	       ptr;
     4930       dcl	    first_seg_bitcount     fixed (24);
     4931       dcl	    first_seg_ptr	       ptr;
     4932       dcl	    iocb_ptr	       ptr;
     4933       dcl	    is_new_file	       bit (1) aligned;
     4934       dcl	    key		       char (256) varying;
     4935       dcl	    mode_arg	       fixed;
     4936       dcl	    pos_type	       fixed;
     4937       dcl	    skip		       fixed;
     4938       dcl	    rec_len	       fixed (21);
     4939 
     4940 /* Local Variables */
     4941 
     4942       dcl	    1 current_des	       like designator_struct aligned based (addr (indx_cb.current_descrip));
     4943       dcl	    record_action	       fixed;
     4944       dcl	    record_len	       fixed (21);
     4945       dcl	    record_ptr	       ptr;
     4946       dcl	    foo		       fixed (35);
     4947       dcl	    pos_ptr	       ptr;
     4948       dcl	    buffer	       char (record_len) based (buff_ptr);
     4949       dcl	    block_ptr	       ptr;
     4950       dcl	    1 block_with_lock      based (block_ptr),
     4951 	      2 words	       (record_block.block_size - 1) fixed,
     4952 						/* body of block */
     4953 	      2 record_lock	       bit (36) aligned;	/* set/cleared by "record_status" order */
     4954       dcl	    1 temp_ts_words	       aligned,
     4955 	      2 ind_offset	       bit (18) unal,
     4956 	      2 time_last_modified bit (54) unal;
     4957       dcl	    1 new_rec_des	       based (addr (file_base.new_descriptor)),
     4958 	      2 comp	       fixed (17) unal,
     4959 	      2 offset	       bit (18) unal;
     4960       dcl	    lock_ptr	       ptr;
     4961       dcl	    based_vstring	       char (1000000) var based;
     4962       dcl	    bstring	       char (1000000) based;
     4963       dcl	    based_lock	       bit (36) aligned based;
     4964 
     4965       dcl	    1 ak_inf	       based (info_ptr),
     4966 	      2 header	       like ak_header,
     4967 	      2 key	       char (ak_inf.key_len);
     4968       dcl	    1 rk_inf	       based (info_ptr),
     4969 	      2 header	       like rk_header,
     4970 	      2 key	       char (rk_inf.key_len);
     4971       dcl	    1 gk_inf	       based (info_ptr),
     4972 	      2 header	       like gk_header,
     4973 	      2 key	       char (gk_inf.key_len);
     4974       dcl	    ak_info_key	       char (256) var based (addr (ak_inf.key_len));
     4975       dcl	    key_to_reassign	       char (256) var based (addr (rk_inf.key_len));
     4976 						/* File Parameter Values */
     4977       dcl	    current_file_version   static options (constant) fixed init (40);
     4978       dcl	    current_program_version
     4979 			       static options (constant) fixed init (41);
     4980       dcl	    current_program_version_1
     4981 			       static options (constant) fixed init (32);
     4982       dcl	    current_program_version_2
     4983 			       static options (constant) fixed init (33);
     4984       dcl	    node_size_val	       static options (constant) fixed init (1024);
     4985       dcl	    minimum_block_size_val static options (constant) fixed init (8);
     4986       dcl	    msf_manager_$get_ptr   entry (ptr, fixed, bit (1), ptr, fixed (24), fixed (35));
     4987       dcl	    1 record_block	       like record_block_structure based (block_ptr);
     4988       dcl	    1 stat_struct	       like stat_structure based (block_ptr);
     4989       dcl	    1 ind_struct	       like ind_structure based (block_ptr);
     4990       dcl	    1 time_stamp_struct    like time_stamp_structure based (addr (stat_struct.time_stamp_words));
     4991       dcl	    1 ind_des	       like ind_des_structure based (addr (ind_desc));
     4992 
     4993       dcl	    hcs_$delentry_file     entry (char (*), char (*), fixed (35));
     4994       dcl	    hcs_$get_uid_seg       entry (ptr, bit (36) aligned, fixed (35));
     4995       dcl	    unique_name	       char (27);
     4996       dcl	    get_pdir_	       entry returns (char (168));
     4997       dcl	    lock_copy	       bit (36) aligned;
     4998       dcl	    ind_desc	       fixed (35);
     4999       dcl	    cur_mod	       fixed (35);
     5000       dcl	    transaction_call_$assign
     5001 			       entry (ptr, fixed (35), fixed (35));
     5002       dcl	    transaction_call_$setup_ref_list
     5003 			       entry (ptr, fixed (35));
     5004       dcl	    descrip_arg	       fixed (35);
     5005       dcl	    rollback_sw	       bit (1) aligned;
     5006       dcl	    p		       ptr;
     5007       dcl	    modifier_arg	       fixed (35);
     5008       dcl	    time_stamp	       fixed (71) aligned;
     5009       dcl	    mod		       fixed (35);
     5010       dcl	    cleanup_flags	       bit (36) aligned;
     5011       dcl	    1 cleanup_flag_struct  based (addr (cleanup_flags)),
     5012 	      2 i_locked_file      bit (1) unal,
     5013 	      2 i_locked_rec       bit (1) unal,
     5014 	      2 i_locked_new       bit (1) unal,
     5015 	      2 old_passive_ref    bit (1) unal,
     5016 	      2 new_passive_ref    bit (1) unal,
     5017 	      2 i_set_negmod       bit (1) unal,
     5018 	      2 i_set_new_negmod   bit (1) unal,
     5019 	      2 aborting	       bit (1) unal,
     5020 	      2 pad	       bit (28) unal;
     5021       dcl	    order		       char (*);
     5022       dcl	    (
     5023 	    vfile_io_control,
     5024 	    vfile_io_control$af
     5025 	    )		       entry (ptr, ptr, ptr, fixed (35));
     5026       dcl	    vfile_status_$seg      entry (ptr, ptr, ptr, fixed (35));
     5027       dcl	    (info_ptr, info_ptr_arg)
     5028 			       ptr;
     5029       dcl	    blanks	       char (256) aligned static internal options (constant) init ("");
     5030       dcl	    1 gk_pad_key,
     5031 	      2 len	       fixed,
     5032 	      2 string	       char (256);
     5033       dcl	    1 pad_key_info	       based (pad_key_ptr),
     5034 	      2 pad_key_len	       fixed,
     5035 	      2 pad_key	       char (256);
     5036       dcl	    pad_key_ptr	       ptr;
     5037       dcl	    1 info	       based (info_ptr),
     5038 	      2 rel_type	       fixed,
     5039 	      2 n		       fixed,
     5040 	      2 search_key	       char (0 refer (n));
     5041 
     5042       dcl	    1 mbs_info	       based (info_ptr),
     5043 	      2 min_residue	       fixed (21),		/* min unused capacity in bytes */
     5044 	      2 min_capacity       fixed (21);		/* minimum bytes which will be allocated */
     5045 
     5046       dcl	    1 error_info	       based (info_ptr),
     5047 	      2 version	       fixed bin (35),	/* must =1 (Input) */
     5048 	      2 type	       fixed bin (35),	/* identifies type of error--only one currently exists */
     5049 	      2 requested	       fixed bin (35),	/* skip arg passed to vfile_ for positioning */
     5050 	      2 received	       fixed bin (35);	/* skips completed successfully */
     5051       dcl	    skip_error	       fixed static options (constant) internal init (1);
     5052       dcl	    1 set_lock_info	       based (info_ptr) aligned,
     5053 	      2 set_lock_flag      bit (1) unal,	/* "1"b means lock, "0"b means unlock */
     5054 	      2 exclusive	       bit (1) unal;	/* "1"b means lock out readers too */
     5055       dcl	    new_wait_time	       float based (info_ptr);
     5056       dcl	    1 wt_info	       based (info_ptr),
     5057 	      2 version	       float,		/* -2 indicates collection delay, not new_wait_time */
     5058 	      2 collection_delay_time
     5059 			       float;
     5060       dcl	    max_rec_wds	       fixed (19);
     5061       dcl	    ref_cnt	       fixed;
     5062       dcl	    delta_ref_count	       fixed;
     5063       dcl	    new_block_ptr	       ptr;
     5064       dcl	    new_lock_ptr	       ptr;
     5065       dcl	    transaction	       defined indx_cb_ptr -> indx_cb.trans bit (1) aligned;
     5066       dcl	    passive	       bit (1) aligned;
     5067       dcl	    max_ref_count	       static internal options (constant) init (65535);
     5068 						/* 2**16 -1 */
     5069       dcl	    sub_err_	       entry options (variable);
     5070       dcl	    current_descrip	       fixed (35) defined indx_cb.current_descrip;
     5071       dcl	    old_ref_cnt	       fixed;
     5072       dcl	    new_des	       fixed (35);
     5073       dcl	    old_des	       fixed (35);
     5074       dcl	    pos_unchanged	       bit (1) aligned;
     5075       dcl	    next_subset	       fixed (34);
     5076       dcl	    i		       fixed;
     5077       dcl	    last_head	       char (256) var;
     5078       dcl	    last_head_len	       fixed based (addr (last_head));
     5079       dcl	    temp_key_words	       (1:2) fixed bin (35) based (addr (temp_key));
     5080       dcl	    vpad_key	       char (256) var based (addr (pad_key_info));
     5081       dcl	    1 temp_ak_inf,
     5082 	      2 flags	       bit (36) aligned,
     5083 	      2 descriptor	       fixed (35),
     5084 	      2 key_len	       fixed,
     5085 	      2 temp_key	       char (8);
     5086       dcl	    flag		       bit (1) aligned;
     5087       dcl	    head_spec	       bit (1) aligned;
     5088       dcl	    open_ended	       bit (1) aligned;
     5089       dcl	    max_list_type	       static fixed options (constant) init (2) internal;
     5090       dcl	    n_int		       fixed;
     5091       dcl	    last_info_ptr	       ptr;
     5092       dcl	    1 last_info_block      (0:1),
     5093 	      2 new_ptr	       ptr,
     5094 	      2 des	       fixed (35),
     5095 	      2 lkey	       char (256) var;
     5096       dcl	    1 last_info	       based (last_info_ptr),
     5097 	      2 new_last_info_ptr  ptr,
     5098 	      2 last_descrip       fixed (35),
     5099 	      2 last_key	       char (256) var;
     5100       dcl	    1 new_last_info	       based (last_info.new_last_info_ptr),
     5101 	      2 new_last_info_ptr  ptr,
     5102 	      2 new_last_descrip   fixed (35),
     5103 	      2 new_last_key       char (256) var;
     5104       dcl	    select_flag	       static internal bit (1) aligned init ("0"b) options (constant);
     5105       dcl	    exclude_flag	       static internal bit (1) aligned init ("1"b) options (constant);
     5106       dcl	    timer_manager_$sleep   entry (fixed (71), bit (2));
     5107       dcl	    min_max_rec_len	       static options (constant) internal fixed (21) init (24);
     5108 
  2     1 /* include file for common portions of vfile_'s attach block used in
  2     2*   several modules--created by M. Asherman 1/9/76
  2     3*   Modified 8/28/76 to add last_comp */
  2     4 
  2     5      dcl	   1 atb		      based (iocb_ptr -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr),
  2     6 						/* attach block */
  2     7 	     2 flags	      aligned,
  2     8 	       3 (pad1, appending, no_trunc, pad2, ssf, header_present, blocked, shared, pad3, msf, inv_lock_reset,
  2     9 		  dup_ok_sw, trans_sw, noend_sw, exclu_sw, stat_sw, checkpoint_sw)
  2    10 			      bit (1) unal,
  2    11 	       3 pad5	      bit (19) unal,
  2    12 	     2 wait_time	      fixed (35),
  2    13 	     2 word	      fixed,
  2    14 	     2 max_rec_len	      fixed (35),
  2    15 	     2 header_id	      fixed (35),
  2    16 	     2 word2	      fixed,
  2    17 	     2 attach_descrip_string
  2    18 			      char (256),
  2    19 	     2 dname_len,
  2    20 	     2 ename_len	      fixed,
  2    21 	     2 words3	      (9) fixed,
  2    22 	     2 opening_mode	      fixed,
  2    23 	     2 word4	      fixed,
  2    24 	     2 fcbp	      ptr,
  2    25 	     2 fsp	      ptr,		/* first seg ptr */
  2    26 	     2 close_x	      entry,		/* set to close routine */
  2    27 	     2 last_comp	      fixed,		/* msf component number */
  2    28 	     2 tcf_iocbp	      ptr;		/* iocb ptr for transaction control switch */
     5109 
     5110 
  3     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  3     2 
  3     3 /* Written 05/04/78 by C. D. Tavares */
  3     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  3     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  3     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  3     7 
  3     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  3     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  3    10      iox_$close entry (pointer, fixed bin (35)),
  3    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  3    12      iox_$delete_record entry (pointer, fixed bin (35)),
  3    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  3    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  3    15      iox_$err_not_attached entry options (variable),
  3    16      iox_$err_not_closed entry options (variable),
  3    17      iox_$err_no_operation entry options (variable),
  3    18      iox_$err_not_open entry options (variable),
  3    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  3    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  3    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  3    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  3    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  3    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  3    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  3    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  3    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  3    28      iox_$propagate entry (pointer),
  3    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  3    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  3    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  3    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  3    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  3    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  3    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  3    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  3    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  3    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  3    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  3    40 
  3    41 dcl (iox_$user_output,
  3    42      iox_$user_input,
  3    43      iox_$user_io,
  3    44      iox_$error_output) external static pointer;
  3    45 
  3    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
     5111 
     5112 
  4     1 /* include file for info structure used with record_status control order
  4     2*   created by M. Asherman 1/6/76 */
  4     3 /* modified 6/15/77 to support stationary type records */
  4     4 
  4     5      dcl	   rs_info_ptr	      ptr;
  4     6      dcl	   1 rs_info	      based (rs_info_ptr) aligned,
  4     7 	     2 version	      fixed,		/* must be set to 1 or 2 (Input) */
  4     8 	     2 flags	      aligned,
  4     9 	       3 lock_sw	      bit (1) unal,		/* Input -- if ="1"b  try to lock record */
  4    10 	       3 unlock_sw	      bit (1) unal,		/* Input -- if ="1"b try to unlock record */
  4    11 	       3 create_sw	      bit (1) unal,		/* Input--if set creat new record */
  4    12 	       3 locate_sw	      bit (1) unal,		/* Input--if set causes current rec to be
  4    13*						   located outside the index by descrip, or created without key */
  4    14 	       3 inc_ref_count    bit (1) unal,		/* Input--bump reference count of record, if stationary */
  4    15 	       3 dec_ref_count    bit (1) unal,		/* Input--decrement ref count if this flag set and record stationary */
  4    16 	       3 locate_pos_sw    bit (1) unal,		/* Input--if set the record_length is taken
  4    17*						   as an input argument specifying the absolute logical record positioni	  to which both the current and next positions will be set */
  4    18 	       3 mbz1	      bit (29) unal,	/* must be set to "0"b, reserved for future use */
  4    19 	     2 record_length      fixed (21),		/* length in bytes, Input if create_sw set */
  4    20 	     2 max_rec_len	      fixed (21),		/* max length of contained record
  4    21*						   Input if create_sw is set--overrides min_block_size in effect */
  4    22 	     2 record_ptr	      ptr,		/* points to first byte of record--will be word aligned */
  4    23 	     2 descriptor	      fixed (35),		/* Input if locate_sw set and create_sw="0"b */
  4    24 	     2 ref_count	      fixed (34),		/* Output--should match number of keys on this record-- = -1 if non-stationary record */
  4    25 	     2 time_last_modified fixed (71),		/* Output */
  4    26 	     2 modifier	      fixed (35),		/* Output--also Input when locking */
  4    27 	     2 block_ptr	      ptr unal,		/* Output */
  4    28 	     2 last_image_modifier
  4    29 			      fixed (35),
  4    30 	     2 mbz2	      fixed;
  4    31 
  4    32      dcl	   1 rs_desc	      based (addr (rs_info.descriptor)),
  4    33 						/* record block descriptor structure */
  4    34 	     2 comp_num	      fixed (17) unal,	/* msf component number */
  4    35 	     2 offset	      bit (18) unal;	/* word offset of record block */
  4    36 
  4    37      dcl	   1 seq_desc	      based (addr (rs_info.descriptor)),
  4    38 						/* for sequential files */
  4    39 	     2 bitno	      bit (6) unal,
  4    40 	     2 comp_num	      fixed (11) unal,	/* msf component number */
  4    41 	     2 wordno	      bit (18) unal;	/* word offset */
  4    42 
  4    43      dcl	   rs_info_version_1      static internal fixed init (1);
  4    44      dcl	   rs_info_version_2      static internal fixed init (2);
  4    45 
     5113 
     5114 
  5     1 /* ak_info -- include file for info structures used by the following vfile_
  5     2*   control orders: "add_key", "delete_key", "get_key", and "reassign_key".
  5     3*   Created by M. Asherman 3/23/76
  5     4*   Modified 5/13/77 to add separate gk_info structure */
  5     5 
  5     6      dcl	   1 ak_info	      based (ak_info_ptr),
  5     7 	     2 header	      like ak_header,
  5     8 	     2 key	      char (ak_key_len refer (ak_info.header.key_len));
  5     9 
  5    10      dcl	   1 ak_header	      based (ak_info_ptr),
  5    11 	     2 flags	      aligned,
  5    12 	       3 input_key	      bit (1) unal,		/* set if key is input arg */
  5    13 	       3 input_desc	      bit (1) unal,		/* set if descriptor is an input arg */
  5    14 	       3 mbz	      bit (34) unal,	/* not used for the present */
  5    15 	     2 descrip	      fixed (35),		/* record designator */
  5    16 	     2 key_len	      fixed;
  5    17 
  5    18      dcl	   ak_info_ptr	      ptr;
  5    19      dcl	   ak_key_len	      fixed;
  5    20 
  5    21 
  5    22      dcl	   1 rk_info	      based (rk_info_ptr),
  5    23 	     2 header	      like rk_header,
  5    24 	     2 key	      char (rk_key_len refer (rk_info.header.key_len));
  5    25 
  5    26      dcl	   1 rk_header	      based (rk_info_ptr),
  5    27 	     2 flags	      aligned,
  5    28 	       3 input_key	      bit (1) unal,		/* same as above */
  5    29 	       3 input_old_desc   bit (1) unal,		/* set if specified entry has initial descrip
  5    30*						   given by old_descrip */
  5    31 	       3 input_new_desc   bit (1) unal,		/* set if new val for descrip is input in this struc */
  5    32 	       3 mbz	      bit (33) unal,
  5    33 	     2 old_descrip	      fixed (35),		/* used if first flag is set */
  5    34 	     2 new_descrip	      fixed (35),		/* used only if second flag is set */
  5    35 	     2 key_len	      fixed;
  5    36 
  5    37      dcl	   rk_info_ptr	      ptr;
  5    38      dcl	   rk_key_len	      fixed;
  5    39 
  5    40 
  5    41      dcl	   1 gk_info	      based (gk_info_ptr),	/* structure for get_key order */
  5    42 	     2 header	      like gk_header,
  5    43 	     2 key	      char (gk_key_len refer (gk_info.header.key_len));
  5    44 						/* may be Input as well as Output */
  5    45 
  5    46      dcl	   1 gk_header	      based (gk_info_ptr),
  5    47 	     2 flags	      aligned,
  5    48 	       3 input_key	      bit (1) unal,		/* if set, use key in this structure */
  5    49 	       3 input_desc	      bit (1) unal,		/* if set, descriptor given in this structure */
  5    50 	       3 desc_code	      fixed (2) unal,	/* 0=any, 1=current -- applies when input_desc="0"b */
  5    51 	       3 position_specification
  5    52 			      unal,
  5    53 	         4 current	      bit (1) unal,		/* otherwise next */
  5    54 	         4 rel_type	      fixed (2) unal,	/* as in seek_head, if input_key = "1"b */
  5    55 	         4 head_size      fixed bin (9) unsigned unaligned,
  5    56 						/* size of head for initial seek */
  5    57 	       3 reset_pos	      bit (1) unal,		/* if set, final position unchanged by this operation */
  5    58 	       3 pad	      bit (8) unal,
  5    59 	       3 version	      fixed (8) unal,
  5    60 	     2 descrip	      fixed (35),		/* Output, except when input_desc="1"b */
  5    61 	     2 key_len	      fixed;		/* Input when input_key="1"b, also Output in all cases */
  5    62 
  5    63      dcl	   gk_info_ptr	      ptr;
  5    64      dcl	   gk_key_len	      fixed;
  5    65 
  5    66      dcl	   gk_info_version_0      internal static fixed options (constant) init (0);
  5    67 
  5    68 /* end ak_info.incl.pl1 */
     5115 
     5116 
  6     1 /* Include file for vfile_ control orders dealing with key ranges in indexed files */
  6     2 /* created by M. Asherman 4/7/77
  6     3*Modified:
  6     4*12/18/80  by  Lindsey Spratt: Add the delete_old_subsets bit.
  6     5**/
  6     6 
  6     7 /* format: style2 */
  6     8      dcl	   1 common_sl_info	      based (info_ptr),	/* info structure for select and exclude orders */
  6     9 	     2 flags	      aligned,		/* Input */
  6    10 	       3 list_type	      fixed (3) unal,	/* code identifies format of tail structure */
  6    11 	       3 status_only      bit (1) unal,		/* if set, subset info is returned, but current subset stays the same */
  6    12 	       3 output_descriptors
  6    13 			      bit (1) unal,		/* if set, resulting descriptor list is returned */
  6    14 	       3 delete_old_subsets
  6    15 			      bit (1) unal,		/* if set, causes all of the existing subsets on this switch to be deleted. */
  6    16 	       3 mbz	      bit (11) unal,	/* must be zero--in case of extensions */
  6    17 	       3 version	      fixed (17) unal,	/* current info version */
  6    18 	     2 array_limit	      fixed,		/* upper bound of array in tail of info structure */
  6    19 	     2 subset_no	      fixed,		/* identifies temporary subset-- Output */
  6    20 	     2 count	      fixed (34),		/* Output--number of distinct descrips */
  6    21 	     2 desc_arrayp	      ptr;		/* pointer to resulting array of descriptors */
  6    22 
  6    23 /* descriptor array generated if requested */
  6    24      dcl	   desc_array	      (1:common_sl_info.count) based (common_sl_info.desc_arrayp);
  6    25 
  6    26 /* this format allows specification in terms of index intervals defined by two heads or one key */
  6    27      dcl	   1 hi_sl_info	      based (info_ptr),	/* structure for list_type = 1 */
  6    28 	     2 common	      like common_sl_info,
  6    29 	     2 interval	      (1:sl_array_limit refer (hi_sl_info.array_limit)),
  6    30 	       3 first_head,
  6    31 	         4 length	      fixed,
  6    32 	         4 kptr	      ptr unal,
  6    33 	       3 last_head,
  6    34 	         4 length	      fixed,		/* if negative, this interval is defined by match with key */
  6    35 	         4 kptr	      ptr unal;
  6    36 
  6    37 /* format for specification in terms of an array of descriptors */
  6    38      dcl	   1 da_sl_info	      based (info_ptr),	/* list_type=2 */
  6    39 	     2 common	      like common_sl_info,
  6    40 	     2 desc_array	      (1:sl_array_limit refer (da_sl_info.array_limit)) fixed (35);
  6    41 
  6    42      dcl	   sl_array_limit	      fixed;
  6    43      dcl	   sl_info_version_0      static options (constant) internal fixed init (0);
  6    44 
  6    45 /* list_type=0 denotes reselection of a single, previously defined subset (no tail structure) */
     5117 
     5118 
  7     1 /* Include File of error codes used by vfile_ and related programs */
  7     2 /* Created by M. Asherman 5/20/78 */
  7     3      dcl	   (error_table_$no_key, error_table_$file_busy, error_table_$segknown, error_table_$not_open, error_table_$noentry,
  7     4 	   error_table_$no_file, error_table_$no_record, error_table_$not_detached, error_table_$not_closed,
  7     5 	   error_table_$noarg, error_table_$too_many_args, error_table_$bad_file, error_table_$end_of_info,
  7     6 	   error_table_$invalid_lock_reset, error_table_$lock_wait_time_exceeded, error_table_$last_reference,
  7     7 	   error_table_$higher_inconsistency, error_table_$record_busy, error_table_$no_room_for_lock,
  7     8 	   error_table_$lock_is_invalid, error_table_$unimplemented_version, error_table_$lock_not_locked,
  7     9 	   error_table_$key_duplication, error_table_$bad_processid, error_table_$bad_arg,
  7    10 	   error_table_$locked_by_this_process, error_table_$no_operation, error_table_$asynch_insertion,
  7    11 	   error_table_$asynch_change, error_table_$too_many_refs, error_table_$asynch_deletion, error_table_$long_record,
  7    12 	   error_table_$file_is_full, error_table_$key_order)
  7    13 			      external fixed (35);
  7    14 						/* end of vfile_ error code include file */
     5119 
     5120 
  8     1 /* the control block */
  8     2      dcl	   indx_cb_ptr	      ptr;
  8     3      dcl	   1 indx_cb	      based (indx_cb_ptr),	/* except as noted, init by create cb */
  8     4 	     2 fcb_ptr	      ptr,
  8     5 	     2 file_base_ptr      ptr,
  8     6 	     2 node_length	      fixed,		/* number of bytes in node, init by create_seg_ptrs */
  8     7 	     2 half_node_length   fixed,		/* init by create_seg_ptrs */
  8     8 	     2 max_record_size    fixed (21),		/* init by create_seg_ptrs */
  8     9 	     2 seg_ptr_array_ptr  ptr,		/* init by create seg_ptrs */
  8    10 	     2 seg_ptr_array_limit
  8    11 			      fixed,		/* init by create seg_ptrs */
  8    12 	     2 mode	      fixed,
  8    13 	     2 is_sequential_open bit (1) aligned,
  8    14 	     2 is_read_only	      bit (1) aligned,
  8    15 	     2 is_ks_out	      bit (1) aligned,	/* position info */
  8    16 	     2 position_stack_ptr ptr,		/* init by create_position stack */
  8    17 	     2 position_stack_height
  8    18 			      fixed,		/* init by create position stack */
  8    19 	     2 root_position_ptr  ptr,		/* init by create_position_stack */
  8    20 	     2 file_position_ptr  ptr,		/* not init */
  8    21 	     2 change_position_ptr
  8    22 			      ptr,		/* not init */
  8    23 						/* auxiliary variables  */
  8    24 	     2 rover_seg_ptr      ptr,		/* init by create_seg_ptrs */
  8    25 	     2 index_state_ptr    ptr,		/* init by create_seg_ptrs */
  8    26 	     2 old_index_height   fixed,
  8    27 	     2 old_last_comp_num  fixed,
  8    28 	     2 last_change_count  fixed (35),
  8    29 	     2 wait_time	      fixed (35),
  8    30 	     2 old_rover_comp_num fixed,
  8    31 	     2 file_state_ptr     ptr,
  8    32 	     2 o_s_ptr	      ptr,
  8    33 	     2 repeating	      bit (1) aligned,
  8    34 	     2 next_substate      fixed,
  8    35 	     2 file_program_version
  8    36 			      fixed,		/* used for record_lock compatibility */
  8    37 	     2 leave_locked	      bit (1) aligned,	/* indicates use of set_file_lock order */
  8    38 	     2 dup_ok	      bit (1) aligned,	/* if set, duplicate keys may occur */
  8    39 	     2 read_exclu	      bit (1) aligned,	/* set when lock excludes readers */
  8    40 	     2 pos_incorrect      bit (1) aligned,	/* indicates index position is not current */
  8    41 	     2 saved_lock_copy    bit (36) aligned,	/* copy of process lock_id */
  8    42 	     2 min_key_len	      fixed,		/* non-zero only in old programs */
  8    43 	     2 stat	      bit (1) aligned,	/* causes write_record to create stationary records */
  8    44 	     2 current_subset     fixed (34),		/* used with select order */
  8    45 	     2 last_subset	      fixed (34),
  8    46 	     2 subset_count	      fixed (34),		/* count of descriptors in current subset */
  8    47 	     2 temp_iocbp	      ptr,		/* temporary file used to implement select order */
  8    48 	     2 trans	      bit (1) aligned,	/* set if -transaction attachment */
  8    49 	     2 transaction_code   fixed (35),		/* set for control switch only */
  8    50 	     2 tcfp	      ptr,		/* ptr to iocb for transaction control switch--if applicable */
  8    51 	     2 reflp	      ptr,		/* ptr to ref list file, set only in transaction control file */
  8    52 	     2 uid	      bit (36) aligned,	/* used under -transaction */
  8    53 	     2 collection_delay_time
  8    54 			      fixed (35),		/* microseconds to wait before garbage removal */
  8    55 	     2 min_res	      fixed (21),		/* for min_block_size order */
  8    56 	     2 min_cap	      fixed (21),		/* also for min_block_size order */
  8    57 	     2 subset_selected    bit (2) aligned,	/* first bit for select, second
  8    58*						   bit is for exclude */
  8    59 	     2 error,				/* for error_status order */
  8    60 	       3 type	      fixed,		/* only one error type supported now */
  8    61 	       3 requested	      fixed (34),		/* skip arg given to position entry */
  8    62 	       3 received	      fixed (34),		/* actual successful skips */
  8    63 	     2 state_vars,
  8    64 	       3 fixed_state_part,
  8    65 	         4 shared	      bit (1) aligned,
  8    66 	         4 next_record_position
  8    67 			      fixed,		/* 0, 1, or 2 */
  8    68 	         4 current_record_is_valid
  8    69 			      bit (1) aligned,
  8    70 	         4 ready_to_write bit (1) aligned,
  8    71 	         4 at_eof_or_bof,
  8    72 		 5 at_bof	      bit (1) unal,
  8    73 		 5 at_eof	      bit (1) unal,
  8    74 		 5 pad	      bit (36) unal,
  8    75 	         4 outside_index  bit (1) aligned,	/* set after deleting current key or after use of record_status with locate switch */
  8    76 	         4 current_descrip
  8    77 			      fixed (35),		/* needed when outside index */
  8    78 	         4 saved_descrip  fixed (35),		/* for restoring index position */
  8    79 	         4 skip_state     fixed,		/* controls scanning of deleted entries */
  8    80 	       3 new_key	      char (256) var;
  8    81 
  8    82      dcl	   current_t_code	      fixed (35) based (addr (indx_cb.tcfp -> iocb.open_data_ptr -> indx_cb.transaction_code));
  8    83 
  8    84 /* component locator structures */
  8    85      dcl	   seg_ptr_array	      (0:seg_ptr_array_limit) ptr based (seg_ptr_array_ptr);
  8    86      dcl	   seg_ptr	      ptr;
  8    87      dcl	   seg_array	      (0:262143) fixed (19) based (seg_ptr) aligned;
  8    88      dcl	   designator	      fixed (35);
  8    89      dcl	   1 ind_des_structure    based,
  8    90 	     2 comp	      fixed (17) unal,
  8    91 	     2 offset	      bit (18) unal;
  8    92      dcl	   1 stat_structure	      based,
  8    93 	     2 pad	      bit (26) unal,
  8    94 	     2 ref_count_after    fixed (16) unsigned unal,
  8    95 	     2 ind_comp	      fixed (13) unal,
  8    96 	     2 ref_count	      fixed (16) unsigned unal,
  8    97 	     2 record_lock	      bit (36) aligned,
  8    98 	     2 modifier	      fixed (35),
  8    99 	     2 time_stamp_words   fixed (71) aligned,
  8   100 	     2 prev_mod	      fixed (35),
  8   101 	     2 record	      char (1000000) var;
  8   102      dcl	   1 ind_structure	      based,
  8   103 	     2 pad	      bit (26) unal,
  8   104 	     2 ref_count_after    fixed (16) unsigned unal,
  8   105 	     2 ind_comp	      fixed (13) unal,
  8   106 	     2 ref_count	      fixed (16) unsigned unal,
  8   107 	     2 record_lock	      bit (36) aligned,
  8   108 	     2 modifier	      fixed (35),
  8   109 	     2 time_stamp_words   fixed (71) aligned,
  8   110 	     2 prev_mod	      fixed (35),
  8   111 	     2 prev_desc	      fixed (35);
  8   112      dcl	   1 time_stamp_structure based,
  8   113 	     2 ind_offset	      bit (18) unal,
  8   114 	     2 time_last_modified fixed (54) unsigned unal;
  8   115      dcl	   1 record_block_structure
  8   116 			      based,
  8   117 	     2 reserved	      aligned,		/* data used by change_record_list */
  8   118 	       3 pad	      bit (2) unal,
  8   119 	       3 block_size	      fixed (19) unal,
  8   120 	       3 lock_flag	      bit (1) unal,		/* record lock flag */
  8   121 	       3 stationary	      bit (1) unal,
  8   122 	       3 indirect	      bit (1) unal,
  8   123 	       3 after_applies    bit (1) unal,
  8   124 	       3 mbz	      bit (10) unal,
  8   125 	     2 block_tail,				/* structure varies with record type */
  8   126 	       3 record	      char (1000000) var;	/* non-stat record location */
  8   127      dcl	   1 designator_struct    aligned based (addr (designator)),
  8   128 	     2 comp_num	      fixed (17) unal,
  8   129 	     2 offset	      bit (18) unal;
  8   130 
  8   131 /* position and node templates */
  8   132      dcl	   1 position_frame	      based (pos_ptr),	/* ref8 */
  8   133 	     2 parent_position_ptr
  8   134 			      ptr,
  8   135 	     2 son_position_ptr   ptr,
  8   136 	     2 node_ptr	      ptr,
  8   137 	     2 node	      fixed (35),
  8   138 	     2 branch_num	      fixed;
  8   139      dcl	   1 node_block	      based (node_ptr),	/* ref9) */
  8   140 	     2 last_branch_num    fixed,
  8   141 	     2 low_key_pos	      fixed,
  8   142 	     2 scat_space	      fixed,
  8   143 	     2 branch_and_descrip (1 refer (node_block.last_branch_num)),
  8   144 						/* in last element only branch is used */
  8   145 	       3 branch	      fixed (35),
  8   146 	       3 descrip,
  8   147 	         4 key_descrip,
  8   148 		 5 key_pos      fixed (17) unal,
  8   149 		 5 key_length   fixed (17) unal,
  8   150 	         4 record_descrip,
  8   151 		 5 record_designator
  8   152 			      fixed (35);
  8   153      dcl	   keys		      char (4096 /* 4*node_size */) based (node_ptr);
  8   154 
  8   155 /* file base and states */
  8   156      dcl	   f_b_ptr	      ptr;
  8   157      dcl	   1 file_base	      based (f_b_ptr),	/* ref10 */
  8   158 	     2 common_header,
  8   159 	       3 file_code	      fixed (35),
  8   160 	       3 lock_word	      bit (36) aligned,
  8   161 	       3 words	      (2) fixed,
  8   162 	     2 file_version	      fixed,
  8   163 	     2 program_version    fixed,
  8   164 	     2 node_size	      fixed (19),
  8   165 	     2 minimum_key_length fixed,
  8   166 	     2 minimum_block_size fixed (19),
  8   167 	     2 max_seg_limit      fixed (19),
  8   168 	     2 root_node_block,
  8   169 	       3 last_branch_num_root
  8   170 			      fixed,		/* =1 */
  8   171 	       3 word	      fixed,
  8   172 	       3 reserved	      fixed,
  8   173 	       3 only_branch_in_root
  8   174 			      fixed (35),
  8   175 	     2 file_state	      fixed,
  8   176 	     2 change_count	      fixed (34),		/* record state info, ref12 */
  8   177 	     2 old_number_of_free_blocks
  8   178 			      fixed (34),
  8   179 	     2 prior_block_size   fixed (19),
  8   180 	     2 old_record_length  fixed (21),
  8   181 	     2 need_new_seg	      bit (1) aligned,
  8   182 	     2 old_residue	      fixed,
  8   183 	     2 new_last_comp_num  fixed,
  8   184 	     2 old_prev_free_block
  8   185 			      fixed (18),
  8   186 	     2 old_next_free_block
  8   187 			      fixed (18),
  8   188 	     2 new_record_length  fixed (21),
  8   189 	     2 old_record_designator
  8   190 			      fixed (35),
  8   191 	     2 prec_block_was_free
  8   192 			      bit (1) aligned,
  8   193 	     2 next_block_was_free
  8   194 			      bit (1) aligned,
  8   195 	     2 former_block_size  fixed (19),
  8   196 	     2 old_init_offset    fixed (18),
  8   197 	     2 old_block_size     fixed (19),
  8   198 	     2 prev_block_size    fixed (19),
  8   199 	     2 former_rover_comp_num
  8   200 			      fixed,
  8   201 	     2 former_rover_offset
  8   202 			      fixed (18),
  8   203 	     2 next_block_size    fixed (19),
  8   204 	     2 next_prev_free_block
  8   205 			      fixed (18),
  8   206 	     2 next_next_free_block
  8   207 			      fixed (18),
  8   208 	     2 saved_ks_out	      bit (1) aligned,
  8   209 	     2 new_descriptor     fixed (35),
  8   210 	     2 old_last_branch_num
  8   211 			      fixed,
  8   212 	     2 old_low_key_pos    fixed,
  8   213 	     2 old_scat_space     fixed,
  8   214 	     2 old_key_pos	      fixed,
  8   215 	     2 rover_comp_num     fixed,
  8   216 	     2 rover_offset	      fixed (18),
  8   217 	     2 old_key_length     fixed,
  8   218 	     2 b_space	      fixed,
  8   219 	     2 last_b_num	      fixed,
  8   220 	     2 count	      fixed,
  8   221 	     2 first_count	      fixed,
  8   222 	     2 second_count	      fixed,
  8   223 	     2 split_num	      fixed,
  8   224 	     2 must_compact_dest  bit (1) aligned,
  8   225 	     2 first_branch	      fixed (35),
  8   226 	     2 min_source_key_pos fixed,
  8   227 	     2 min_dest_key_pos   fixed,
  8   228 	     2 new_low_key_pos    fixed,
  8   229 	     2 new_scat_space     fixed,
  8   230 	     2 old_seg_lim	      fixed (19),
  8   231 	     2 old_number_of_free_nodes
  8   232 			      fixed,
  8   233 	     2 old_next_node_designator
  8   234 			      fixed (35),
  8   235 	     2 new_index_comp_num fixed,
  8   236 	     2 out_of_index	      bit (1) aligned,
  8   237 	     2 saved_min_res      fixed (21),
  8   238 	     2 saved_min_cap      fixed (21),
  8   239 	     2 was_stat	      bit (1) aligned,
  8   240 	     2 was_ind	      bit (1) aligned,
  8   241 	     2 old_ind_desc	      fixed (35),
  8   242 	     2 after_desc	      fixed (35),
  8   243 	     2 old_ref_count      fixed (34),
  8   244 	     2 new_ref_count      fixed (34),
  8   245 	     2 old_num_free	      fixed (34),
  8   246 	     2 old_file_ch_count  fixed (35),
  8   247 	     2 y_count,				/* for conversion of pre-MR6.9 files */
  8   248 	     2 old_modifier	      fixed (35),
  8   249 	     2 was_transaction    bit (1) aligned,	/* state blocks */
  8   250 	     2 index_state	      fixed,
  8   251 	     2 index_state_blocks (0:1),
  8   252 	       3 words	      (104),
  8   253 	     2 reserved	      (30),		/* this free space might come in handy */
  8   254 	     2 old_prev_mod	      fixed (35),
  8   255 	     2 needed_blksz	      fixed (35),
  8   256 	     2 new_desc_val	      fixed (35),
  8   257 	     2 is_partial_deletion
  8   258 			      bit (1) aligned,
  8   259 	     2 reserved2	      (42),
  8   260 	     2 file_state_blocks  (0:1),
  8   261 	       3 words	      (size (file_state_block)) fixed,
  8   262 						/* component info */
  8   263 	     2 max_comp_num	      fixed,
  8   264 	     2 last_comp_num      fixed,
  8   265 	     2 first_free_comp_num,			/* not yet supported */
  8   266 	     2 comp_table_start   (size (comp_table));	/* start of comp_array */
  8   267 
  8   268      dcl	   1 comp_table	      (0:true_max_comp_num) based (addr (file_base.comp_table_start)) aligned,
  8   269 	     2 seg_limit	      fixed (19),		/* abs value is offset of first free word in seg, max val=max
  8   270*						   seg_limit and this indicates full seg */
  8   271 	     2 comp_link	      fixed (17) unal,
  8   272 	     2 init_offset	      fixed (18) unsigned unal;
  8   273 
  8   274      dcl	   1 file_header	      based (f_b_ptr),
  8   275 	     2 first_three_pages  (3, 1024) fixed,
  8   276 	     2 spare_node	      char (4096) aligned;
  8   277 
  8   278 /* The File State */
  8   279      dcl	   fs_ptr		      ptr;
  8   280      dcl	   1 file_state_block     based (fs_ptr),
  8   281 	     2 file_action	      fixed,
  8   282 	     2 file_substate      fixed,
  8   283 	     2 number_of_keys     fixed (34),
  8   284 	     2 duplicate_keys     fixed (34),		/* 0 if no duplications */
  8   285 	     2 dup_key_bytes      fixed (34),
  8   286 	     2 total_key_length   fixed (34),
  8   287 	     2 number_of_records  fixed (34),
  8   288 	     2 total_record_length
  8   289 			      fixed (34),
  8   290 	     2 number_of_allocated_records
  8   291 			      fixed (34),
  8   292 	     2 number_of_free_blocks
  8   293 			      fixed (34),
  8   294 	     2 words	      (2) fixed;
  8   295 
  8   296 /* The Index State */
  8   297      dcl	   is_ptr		      ptr;
  8   298      dcl	   1 index_state_block    based (is_ptr),	/* if this declaration is changed,
  8   299*						   index_state_blocks must be adjusted */
  8   300 	     2 number_of_nodes    fixed (34),
  8   301 	     2 free_node_designator
  8   302 			      fixed (35),
  8   303 	     2 index_tail_comp_num
  8   304 			      fixed,
  8   305 	     2 index_height	      fixed,
  8   306 	     2 index_action	      fixed,
  8   307 	     2 index_substate     fixed,
  8   308 	     2 current_node	      fixed (35),
  8   309 	     2 change_node	      fixed (35),
  8   310 	     2 fake_node,				/* equivalent to a short node because of storage map. It holds
  8   311*						   the new key, new record descrip, and new branch in a fashion
  8   312*						   convenient for overflow-underflow in change_index. */
  8   313 	       3 fake_head_and_descrip,
  8   314 	         4 word1	      fixed,		/* last_branch_num in real node */
  8   315 	         4 word2	      fixed,		/* low_key_pos in real node */
  8   316 	         4 word3	      fixed,		/* normally scat_space */
  8   317 	         4 word4	      fixed,		/* first branch in real node */
  8   318 	         4 new_key_pos    fixed (17) unal,	/* set by initializefile to denote first char
  8   319*						   in new_key_string, never changed */
  8   320 	         4 new_key_length fixed (17) unal,
  8   321 	         4 new_record_descrip,
  8   322 		 5 new_record_designator
  8   323 			      fixed (35),
  8   324 	         4 new_branch     fixed (35),
  8   325 	       3 new_key_string   char (256),
  8   326 	     2 branch_num_adjust  fixed,
  8   327 	     2 pos_array	      (10),
  8   328 	       3 saved_node	      fixed (35),
  8   329 	       3 saved_branch_num fixed;
  8   330 
  8   331      dcl	   1 old_file_base	      based (f_b_ptr),
  8   332 	     2 words1	      (15) fixed,		/* same in both file versions */
  8   333 	     2 old_file_state_blocks
  8   334 			      (0:1),
  8   335 	       3 words	      (5) fixed,
  8   336 	     2 words2	      (7) fixed,
  8   337 	     2 record_state	      fixed,
  8   338 	     2 record_state_blocks
  8   339 			      (0:1),
  8   340 	       3 words	      (4) fixed,
  8   341 	     2 words3	      (14) fixed,		/* rover info same in both versions */
  8   342 	     2 old_version_index_height
  8   343 			      fixed,
  8   344 	     2 old_version_number_of_nodes
  8   345 			      fixed (34),
  8   346 	     2 words4	      (157) fixed,
  8   347 	     2 old_version_index_tail_comp_num
  8   348 			      fixed,
  8   349 	     2 old_version_free_node_designator
  8   350 			      fixed (35),
  8   351 	     2 words5	      (10) fixed,
  8   352 	     2 old_version_comp_info
  8   353 			      fixed,
  8   354 	     2 word,
  8   355 	     2 x_count	      fixed;		/* always zero in old version files */
  8   356 
  8   357 /* External Procedures */
  8   358      dcl	   clock_		      entry returns (fixed (71));
  8   359      dcl	   alloc_cb_file	      entry (fixed,		/* size of block in words */
  8   360 			      ptr);		/* ptr to block */
  8   361      dcl	   free_cb_file	      entry (fixed, ptr);
  8   362      dcl	   get_seg_ptr	      entry (ptr, fixed) returns (ptr);
  8   363      dcl	   make_designator	      entry (fixed, fixed (18), fixed (35));
  8   364      dcl	   create_seg_ptrs	      entry (ptr);
  8   365      dcl	   free_seg_ptrs	      entry (ptr);
  8   366      dcl	   get_new_seg	      entry (ptr, fixed, ptr, fixed, label);
  8   367      dcl	   free_seg	      entry (ptr, fixed, ptr);
  8   368      dcl	   set_bitcounts	      entry (ptr);
  8   369      dcl	   create_position_stack  entry (ptr);
  8   370      dcl	   extend_position_stack  entry (ptr);
  8   371      dcl	   free_position_stack    entry (ptr);
  8   372      dcl	   change_index	      entry (ptr, label);
  8   373      dcl	   change_record_list     entry (ptr, fixed, ptr, label);
  8   374 
  8   375 /* State Constants */
  9     1      dcl	   bumping_count	      static internal options (constant) init (-14);
  9     2      dcl	   rollback_action	      static options (constant) init (-13);
  9     3      dcl	   adjust_action	      static options (constant) init (-12);
  9     4      dcl	   unshared_opening	      static internal fixed options (constant) init (-11);
  9     5      dcl	   non_eof_delete	      static internal fixed options (constant) init (-10);
  9     6      dcl	   free_action	      static options (constant) init (-10);
  9     7      dcl	   write_trunc	      static internal fixed options (constant) init (-9);
  9     8      dcl	   allocate_action	      static options (constant) init (-9);
  9     9      dcl	   reassigning_key	      static options (constant) init (-8);
  9    10      dcl	   read_exclude	      static options (constant) init (-7);
  9    11      dcl	   adding_record	      static options (constant) init (-6);
  9    12      dcl	   deleting_key	      static options (constant) init (-5);
  9    13      dcl	   adding_key	      static options (constant) init (-4);
  9    14      dcl	   delete_action	      static options (constant) init (-3);
  9    15      dcl	   eof_delete	      static internal fixed options (constant) init (-3);
  9    16      dcl	   replace_action	      static options (constant) init (-2);
  9    17      dcl	   rewrite_action	      static internal fixed options (constant) init (-2);
  9    18      dcl	   insert_action	      static options (constant) init (-1);
  9    19      dcl	   append_action	      static internal fixed options (constant) init (-1);
  9    20      dcl	   truncate_action	      static internal fixed options (constant) init (1);
  9    21      dcl	   must_adjust	      static internal fixed options (constant) init (2);
  9    22      dcl	   must_rollback	      static internal fixed options (constant) init (3);
  8   376 
  8   377 
  8   378 /* Other constants */
  8   379      dcl	   true_max_comp_num      static options (constant) init (1250);
  8   380      dcl	   stat_header_size	      static internal fixed options (constant) init (8);
  8   381 
  8   382 /* builtins */
  8   383      dcl	   (verify, reverse)      builtin;
  8   384      dcl	   addr		      builtin;
  8   385      dcl	   divide		      builtin;
  8   386      dcl	   length		      builtin;
  8   387      dcl	   null		      builtin;
  8   388      dcl	   substr		      builtin;
  8   389      dcl	   size		      builtin;
  8   390      dcl	   abs		      builtin;
  8   391      dcl	   unspec		      builtin;
  8   392      dcl	   fixed		      builtin;
  8   393      dcl	   bit		      builtin;
  8   394      dcl	   max		      builtin;
  8   395      dcl	   min		      builtin;
  8   396      dcl	   rel		      builtin;
  8   397 
     5121 
     5122 
 10     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
 10     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
 10     3*      version number to IOX2. */
 10     4 /* format: style2 */
 10     5 
 10     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
 10     7 	     2 version	      character (4) aligned,	/* IOX2 */
 10     8 	     2 name	      char (32),		/* I/O name of this block. */
 10     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
 10    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
 10    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
 10    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
 10    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
 10    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
 10    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
 10    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
 10    17 						/* open(p,mode,not_used,s) */
 10    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
 10    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
 10    20 						/* get_line(p,bufptr,buflen,actlen,s) */
 10    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
 10    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
 10    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
 10    24 						/* put_chars(p,bufptr,buflen,s) */
 10    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
 10    26 						/* modes(p,newmode,oldmode,s) */
 10    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
 10    28 						/* position(p,u1,u2,s) */
 10    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
 10    30 						/* control(p,order,infptr,s) */
 10    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
 10    32 						/* read_record(p,bufptr,buflen,actlen,s) */
 10    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
 10    34 						/* write_record(p,bufptr,buflen,s) */
 10    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
 10    36 						/* rewrite_record(p,bufptr,buflen,s) */
 10    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
 10    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
 10    39 						/* seek_key(p,key,len,s) */
 10    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
 10    41 						/* read_key(p,key,len,s) */
 10    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
 10    43 						/* read_length(p,len,s) */
 10    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
 10    45 						/* open_file(p,mode,desc,not_used,s) */
 10    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
 10    47 						/* close_file(p,desc,s) */
 10    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
 10    49 						/* detach(p,desc,s) */
 10    50 
 10    51      declare iox_$iocb_version_sentinel
 10    52 			      character (4) aligned external static;
 10    53 
 10    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
     5123 
     5124    end /* end open_indx_file */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1147.6  open_indx_file.pl1                >udd>sm>ds>w>ml>open_indx_file.pl1
1467         1    07/19/79  1647.0  set_current_image_info.incl.pl1   >ldd>incl>set_current_image_info.incl.pl1
5109         2    07/19/79  1647.0  vf_attach_block.incl.pl1          >ldd>incl>vf_attach_block.incl.pl1
5111         3    05/23/83  1016.6  iox_entries.incl.pl1              >ldd>incl>iox_dcls.incl.pl1
5113         4    07/19/79  1647.0  rs_info.incl.pl1                  >ldd>incl>rs_info.incl.pl1
5115         5    07/19/79  1647.0  ak_info.incl.pl1                  >ldd>incl>ak_info.incl.pl1
5117         6    07/31/81  1918.2  select_info.incl.pl1              >ldd>incl>select_info.incl.pl1
5119         7    07/19/79  1647.0  vfile_error_codes.incl.pl1        >ldd>incl>vfile_error_codes.incl.pl1
5121         8    07/19/79  1647.0  vfile_indx.incl.pl1               >ldd>incl>vfile_indx.incl.pl1
8-376        9    07/19/79  1647.0  vfile_action_codes.incl.pl1       >ldd>incl>vfile_action_codes.incl.pl1
5123        10    05/20/83  1946.4  iocb.incl.pl1                     >ldd>incl>iocb.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
aborting                  0(07)        based           bit(1)                   level 2 packed packed unaligned dcl 5011 set ref
                                                                                  1909* 2425* 2433 2451 2456 2462 2611 4465* 4832*
abs                                                    builtin function         dcl 8-390 ref 490 3873
actual_iocb_ptr          12            based           pointer                  level 2 dcl 10-6 ref 4504 4533 4616 4710 4711 4723
                                                                                  4724 4725 4737 4738
add_rec_sw                             parameter       bit(1)                   dcl 2838 ref 2751 2763 2820
adding_key                             constant        fixed bin(17,0)          initial dcl 9-13 ref 3486
adding_record                          constant        fixed bin(17,0)          initial dcl 9-11 ref 1875
addr                                                   builtin function         dcl 8-384 ref 100 100 100 127 127 260 598 605 612
                                                                                  612 708 740 745 745 862 862 862 904 904 904 927
                                                                                  972 1077 1092 1119 1125 1125 1131 1164 1173 1217
                                                                                  1219 1225 1275 1308 1310 1326 1331 1391 1394 1396
                                                                                  1397 1397 1412 1418 1455 1455 2425 2433 2433 2451
                                                                                  2454 2456 2456 2458 2462 2462 2486 2516 2517 2517
                                                                                  2546 2549 2571 2577 2585 2594 2939 2940 2989 2990
                                                                                  2990 3013 3035 3041 3042 3042 3059 3420 3420 3436
                                                                                  3534 3548 3835 3836 3837 3869 3869 3883 3888 3888
                                                                                  3893 3894 3894 3895 3895 3895 3939 3940 3976 3977
                                                                                  4095 4114 4579 4581 4593 4593 1-9 1-19 1-20 1-20
                                                                                  1-32 1-33 1-33 1-49 1-50 1-50 1-70 1482 1482 1483
                                                                                  1740 1740 1740 1740 1833 1906 1909 1935 1952 1953
                                                                                  1953 1964 1969 2063 2088 2093 2093 2185 2189 2191
                                                                                  2192 2192 2299 2308 2310 2352 2400 2611 2614 2637
                                                                                  2778 2878 3225 3243 3252 3252 3255 3255 3259 3259
                                                                                  3262 3708 3739 3744 3746 3746 3768 3772 3772 4014
                                                                                  4031 4031 4043 4043 4267 4267 4268 4269 4270 4274
                                                                                  4275 4276 4277 4277 4277 4277 4283 4286 4286 4294
                                                                                  4309 4325 4325 4334 4335 4336 4336 4336 4336 4343
                                                                                  4345 4346 4346 4346 4346 4369 4370 4372 4372 4372
                                                                                  4372 4384 4385 4386 4387 4388 4388 4389 4389 4390
                                                                                  4390 4392 4392 4392 4392 4393 4393 4400 4400 4401
                                                                                  4401 4407 4408 4408 4409 4409 4409 4409 4465 4466
                                                                                  4469 4469 4474 4484 4484 4490 4713 4715 4754 4754
                                                                                  4755 4803 4806 4806 4807 4832
addrel                                                 builtin function         dcl 4883 ref 1940 1940 1954 1993
adj_file_retry                         constant        fixed bin(17,0)          initial dcl 4877 ref 3090
adj_retry                              constant        fixed bin(17,0)          initial dcl 4867 ref 2933
adjust_action                          constant        fixed bin(17,0)          initial dcl 9-3 ref 3000
after_applies             0(25)        based           bit(1)                   level 3 packed packed unaligned dcl 1-96 ref 1-17
after_desc              104            based           fixed bin(35,0)          level 2 dcl 8-157 set ref 3015 3027 3100 3100* 3105*
ak_header                              based           structure                level 1 unaligned dcl 5-10
ak_inf                                 based           structure                level 1 unaligned dcl 4965 in procedure
                                                                                  "open_indx_file"
ak_inf                                 based           structure                level 1 unaligned dcl 4422 in procedure
                                                                                  "init_uid_info" set ref 4409 4409
ak_info_key                            based           varying char(256)        dcl 4974 set ref 2778* 3420 3436* 3534 3548*
ak_retry                               constant        fixed bin(17,0)          initial dcl 4868 ref 3396
alloc_cb_file                   000156 constant        entry                    external dcl 8-359 ref 4697
allocate_action                 000403 constant        fixed bin(17,0)          initial dcl 9-8 set ref 2512*
any_other                       000236 stack reference condition                dcl 4903 ref 121
array_limit               1            based           fixed bin(17,0)          level 2 dcl 6-8 ref 3834 3967
as_cond_names                   000043 constant        varying char(32)         initial array dcl 162 ref 150
at_bof                  112            based           bit(1)                   level 5 packed packed unaligned dcl 8-3 set ref 255*
                                                                                  372* 616* 641* 655 737* 1519* 1614* 2135* 2259*
                                                                                  2344 2737* 3534 4095 4637* 4643* 4651* 4664* 4717*
at_eof                  112(01)        based           bit(1)                   level 5 packed packed unaligned dcl 8-3 set ref 255*
                                                                                  372* 616* 641* 655 737* 1519* 1614* 2123* 2336
                                                                                  2341 2346 2737* 3534 4095 4659* 4718*
at_eof_or_bof           112            based           structure                level 4 packed packed unaligned dcl 8-3 set ref 2021
atb                                    based           structure                level 1 unaligned dcl 2-5
attach_data_ptr          16            based           pointer                  level 2 dcl 10-6 ref 4504 4533 4616 4710 4711 4723
                                                                                  4724 4725 4737 4738
attach_descrip_ptr       14            based           pointer                  level 2 dcl 10-6 ref 4782 4782
based_area                             based           area(1024)               dcl 4878 ref 3727
based_lock                             based           bit(36)                  dcl 4963 set ref 1143 1238 1249 1454 2164 2166*
                                                                                  2578* 2622 2630 2640 2952 4480 4496
based_vstring                          based           varying char(1000000)    dcl 4961 ref 1165 1420 1432 1437 1716 4782 4782
blanks                          025601 constant        char(256)                initial dcl 5029 ref 3895
blksz                           001062 automatic       fixed bin(19,0)          dcl 1168 set ref 1117* 1118 1119
block_ptr                13            based           pointer                  level 2 in structure "rs_info" packed packed
                                                                                  unaligned dcl 4-6 in procedure "open_indx_file"
                                                                                  set ref 2010*
block_ptr                       000276 automatic       pointer                  dcl 4949 in procedure "open_indx_file" set ref 270*
                                                                                  307* 321* 339* 717 717 1889* 1904 1920* 1924* 1952
                                                                                  1953 1962 1964 1964 1971 1975 1977 1995 1998 2010
                                                                                  2454* 2456 2456 2476* 2481 2481 2516 2517 2549
                                                                                  2560 2566* 2567 2574 2577 2577 2584 2669 2670 2671
                                                                                  2672 2674 2712* 2766 2768 2919* 2922 2938* 2939
                                                                                  2950 2954 2956 2960 2967 2970 2971 2978 2983 2989
                                                                                  2990 3002 3002 3006 3013 3014 3015 3035 3036 3041
                                                                                  3042 3075 3077 3084 3108 3108 3108 3200 3201 3242
                                                                                  3243 3269 3271 3466* 3480* 3491 3492 3612* 3615
                                                                                  3619 3639* 4150* 4183* 4193 4193 4197 4198 4219
                                                                                  4221 4469 4469 4469 4469
block_ptr                              parameter       pointer                  dcl 1474 in procedure "lock_current_record" set ref
                                                                                  909 918* 924 927 934 934 934 942 948* 955 978* 980
                                                                                  982 1007 1025 1037* 1117 1119 1119 1119 1125 1147
                                                                                  1161 1164 1173 1206 1206 1210 1219* 1225 1259 1296
                                                                                  1301 1313 1313* 1319* 1325 1326 1328 1331 1338
                                                                                  1338 1350 1374 1379 1380 1388 1394 1396 1397 1398
                                                                                  1411 1412 1-9 1-11 1-12 1-15 1-15 1-17 1-19 1-20
                                                                                  1-21 1-23 1-27 1-28 1-32 1-33 1-34 1-57 1-66 1-70
block_ptr_arg                          parameter       pointer                  dcl 4454 in procedure "set_lock_list_entry" ref 4242
                                                                                  4248 4253 4270 4287 4359
block_ptr_arg                          parameter       pointer                  dcl 2642 in procedure "unlock_record" ref 2605 2607
                                                                                  2614 2614 2614 2627 2627 2632 2633 2636 2637 2638
block_size                0(02)        based           fixed bin(19,0)          level 3 in structure "record_block" packed packed
                                                                                  unaligned dcl 4987 in procedure "open_indx_file"
                                                                                  ref 2481 2574 2577 2669
block_size                0(02)        based           fixed bin(19,0)          level 3 in structure "record_block" packed packed
                                                                                  unaligned dcl 1-96 in procedure
                                                                                  "lock_current_record" ref 1117 1119 1411 1417
block_tail                1            based           structure                level 2 in structure "record_block" unaligned
                                                                                  dcl 4987 in procedure "open_indx_file"
block_tail                1            based           structure                level 2 in structure "record_block" unaligned
                                                                                  dcl 1-96 in procedure "lock_current_record"
block_with_lock                        based           structure                level 1 unaligned dcl 4950
blockp                    3            based           pointer                  level 2 packed packed unaligned dcl 4447 set ref
                                                                                  4270*
branch                    3            based           fixed bin(35,0)          array level 3 dcl 8-139 set ref 383 459 2140 2141
                                                                                  2142* 2151 2152 2153* 3282
branch_and_descrip        3            based           structure                array level 2 unaligned dcl 8-139
branch_and_descrip_length              constant        fixed bin(17,0)          initial dcl 4913 ref 4803
branch_num                7            based           fixed bin(17,0)          level 2 dcl 8-132 set ref 236* 269 324 381 383 390*
                                                                                  390 399 404* 404 440 448* 448 452 459 459 463 465*
                                                                                  465 575 579* 579 635 635 636 1047 1056 1060 1537
                                                                                  1557 1567* 1567 1571* 1571 1580 1580 1620 1626*
                                                                                  1626 1645 1656 1672 1697 1704* 1704 1705 1716 1716
                                                                                  1723* 1723 1756 1762 2025 2038 2038 2039 2140 2141
                                                                                  2142 2144* 2151 2152 2153 2155* 2260 2391* 2391
                                                                                  2408 2410* 2410 2414 2414 2502 2596 2817 2818 2818
                                                                                  2823 2877 2878 2882* 2882 2886 2886 3282 3294*
                                                                                  3294 3295 3295 3295 3295 3296 3307 3312* 3312 3314
                                                                                  3318 3318 3324* 3327* 3333 3334* 3334 3383 3749
                                                                                  3754* 3754 3776 3778* 3778 3899 3899 3900 3942*
                                                                                  3942 3945 3945 3946 4104 4207 4238 4309 4309 4309
                                                                                  4359 4359
branches_left                   000226 automatic       fixed bin(17,0)          dcl 4895 set ref 381* 383 388
bstring                                based           char(1000000)            packed unaligned dcl 4962 ref 3866 3873 3883
buff_len                               parameter       fixed bin(21,0)          dcl 4924 ref 330 1432 1437 1437 1437 2467 2481 2507
                                                                                  2530 2537 2686 2700 2726
buff_ptr                               parameter       pointer                  dcl 4925 set ref 330 1432 1437 2467 2512* 2522*
                                                                                  2548* 2686 2707*
buffer                                 based           char                     packed unaligned dcl 4948 set ref 1432* 1437*
bytes                                  based           char(1)                  array packed unaligned dcl 2894 set ref 2878
capacity                        001277 automatic       fixed bin(21,0)          dcl 1849 set ref 1823* 1824* 1824 1826
change_branch                   001640 automatic       fixed bin(35,0)          dcl 3340 set ref 3307* 3318 3318 3327
change_count             17            based           fixed bin(34,0)          level 2 dcl 8-157 set ref 129 198 686 972 1878*
                                                                                  1967* 1967 2087 2089 2202 2211 2230 2440 2518*
                                                                                  2536* 2717* 3001* 3048* 3141* 3196* 3487* 3910
                                                                                  3952 4192* 4702
change_index                    000176 constant        entry                    external dcl 8-372 ref 1885 2719 3212 3356 3494
change_node               7            based           fixed bin(35,0)          level 2 dcl 8-298 set ref 2803* 3281* 3371*
change_position_ptr      30            based           pointer                  level 2 dcl 8-3 set ref 2802* 3280* 3318 3318 3318
                                                                                  3325 3370*
change_record_list              000200 constant        entry                    external dcl 8-373 ref 1876 2512 2522 2531 2548 2590
                                                                                  2707 3021 3030 3057 3068 3073 3080 3149 3158 3177
check_file_version              000022 constant        entry                    external dcl 4917 ref 4527
chunk_size                      000230 automatic       fixed bin(34,0)          dcl 4897 set ref 388* 390 392 463* 464 465
cleanup                         000252 stack reference condition                dcl 4905 ref 108 864
cleanup_flag_struct                    based           structure                level 1 packed packed unaligned dcl 5011
cleanup_flags                   000323 automatic       bit(36)                  dcl 5010 set ref 92* 188 708 863* 920* 920 972 1092
                                                                                  1131 1143* 1143 1155* 1155 1238* 1238 1265* 1265
                                                                                  1299* 1299 1313 1319 1348* 1348 1906 1909 1935
                                                                                  1969 2063 2185 2189 2191 2425 2433 2433 2451 2454
                                                                                  2456 2456 2458 2462 2462 2486 2546 2549 2571 2585
                                                                                  2594 2611 2619 2940 3059 3225 3252 3252 3255 3255
                                                                                  3259 3259 3262 4319* 4319 4463 4465 4466 4469 4474
                                                                                  4484 4490 4571* 4830 4832
cleanup_retry                          constant        fixed bin(17,0)          initial dcl 4875 ref 4572
clock                                                  builtin function         dcl 4883 ref 107 202 1087 1192 1227 3013 3035 1-74
                                                                                  1964 2084 2096 2176 3247
close_x                                parameter       entry variable           dcl 4926 set ref 73 4634*
code                                   parameter       fixed bin(35,0)          dcl 4927 set ref 73 90* 205* 221 241 244* 251 264*
                                                                                  274 274 298 304 312 318 330 336 341 341 341 347
                                                                                  360 368 414* 419 443* 472 504* 509 512* 523* 531
                                                                                  537* 561* 571 583* 590* 594 618* 631 667* 673 701
                                                                                  701* 704 709* 730* 746* 749 797* 822* 826* 835*
                                                                                  852* 853* 881* 888* 895* 899* 946* 966* 993 1015*
                                                                                  1022* 1048* 1053 1067* 1069 1069* 1123* 1125*
                                                                                  1129* 1130* 1145* 1147 1147 1147 1154* 1158 1158*
                                                                                  1161* 1163* 1179 1179 1184* 1185 1189* 1196* 1210*
                                                                                  1213 1213 1213 1230* 1240* 1241 1243 1243 1247*
                                                                                  1253 1256* 1264* 1268 1272* 1275* 1279* 1284*
                                                                                  1285* 1321 1321 1321 1363* 1370* 1439* 2423* 2467
                                                                                  2474 2478 2478 2478 2486 2488* 2555 2555 2563 2563
                                                                                  2686 2695* 2909 2916 2922 2922 2925 2925 2930 3087
                                                                                  3393* 3408 3437 3440* 3445* 3456 3468 3468 3468
                                                                                  3478* 3508* 3511 3522 3552* 3555* 3557 3571* 3577
                                                                                  3580 3580* 3615 3615 3629 3629 3637* 3663* 3813*
                                                                                  3926* 3983* 3987* 4070* 4079 4079* 4082 4104 4104*
                                                                                  4138* 4140* 4142 4154 4154 4154 4170 4170 4170
                                                                                  4179* 4527* 4528 4546* 4547* 4547* 4553* 4556
                                                                                  4559* 4560* 4560* 4564 1-39* 1-62* 1-76* 1562*
                                                                                  1604* 1609 1631* 1641* 1686* 1691 1700* 1780*
                                                                                  1790* 1793* 1800* 1805* 1808* 1811* 1814* 1826*
                                                                                  1833* 1892 1892 1892 1896* 1917 1926 1926 1926
                                                                                  1948* 1958* 1971* 2076* 2081* 2086 2093* 2094 2097
                                                                                  2103* 2105 2105* 2107* 2198* 2245* 2253 2267 2272*
                                                                                  2319* 2326 2329* 2336* 2361* 2373* 2729* 2850
                                                                                  2853* 2863 3649* 4014* 4015* 4016* 4031* 4032 4034
                                                                                  4038* 4043* 4044 4046 4050* 4363* 4696* 4755*
                                                                                  4826* 4827* 4827*
collection_delay_time
                         77            based           fixed bin(35,0)          level 2 in structure "indx_cb" dcl 8-3 in procedure
                                                                                  "open_indx_file" set ref 825* 1087 3247 4743*
collection_delay_time
                          1            based           float bin(27)            level 2 in structure "wt_info" dcl 5056 in procedure
                                                                                  "open_indx_file" ref 822 825
common_header                          based           structure                level 2 unaligned dcl 8-157
common_sl_info                         based           structure                level 1 unaligned dcl 6-8
comp                                   based           fixed bin(17,0)          level 2 in structure "ind_des" packed packed
                                                                                  unaligned dcl 1-92 in procedure
                                                                                  "lock_current_record" set ref 1396* 1-19*
comp                                   based           fixed bin(17,0)          level 2 in structure "new_rec_des" packed packed
                                                                                  unaligned dcl 4957 in procedure "open_indx_file"
                                                                                  ref 2516
comp                                   based           fixed bin(17,0)          level 2 in structure "ind_des" packed packed
                                                                                  unaligned dcl 4991 in procedure "open_indx_file"
                                                                                  set ref 1952* 2989* 3041*
comp                                   based           fixed bin(17,0)          level 2 in structure "new_ind_des" packed packed
                                                                                  unaligned dcl 1-82 in procedure
                                                                                  "set_current_image_info" set ref 1-32*
comp_link                 1            based           fixed bin(17,0)          array level 2 packed packed unaligned dcl 8-268 ref
                                                                                  4755
comp_num                               based           fixed bin(17,0)          level 2 in structure "desc" packed packed unaligned
                                                                                  dcl 1749 in procedure "get_pointer" ref 1740 1740
                                                                                  1740 1740
comp_num                               based           fixed bin(17,0)          level 2 in structure "rs_desc" packed packed
                                                                                  unaligned dcl 4-32 in procedure "open_indx_file"
                                                                                  ref 1833
comp_num                               based           fixed bin(17,0)          level 2 in structure "des_arg" packed packed
                                                                                  unaligned dcl 906 in procedure "get_ptr" ref 904
comp_table                             based           structure                array level 1 dcl 8-268 set ref 4754 4754 4806 4807
comp_table_start                       based           fixed bin(17,0)          array level 2 dcl 8-157 set ref 4754 4754 4755 4806
                                                                                  4806 4807
component_size_arg                     parameter       fixed bin(19,0)          dcl 4928 ref 73 4798
cond_info                       000100 automatic       structure                level 1 dcl 171 set ref 127 127
cond_name                              parameter       varying char(32)         dcl 159 in procedure "asynch_change_condition" ref
                                                                                  138 141 141 144 150
cond_name                 3     000100 automatic       varying char(32)         level 2 in structure "cond_info" dcl 171
                                                                                  in on unit on line 121 set ref 129*
continue_to_signal_             000016 constant        entry                    external dcl 4912 ref 136
control                  66            based           entry variable           level 2 dcl 10-6 set ref 4635* 4671*
count                     3            based           fixed bin(34,0)          level 2 in structure "common_sl_info" dcl 6-8
                                                                                  in procedure "open_indx_file" set ref 3716* 3721
                                                                                  3727 3785*
count                           000227 automatic       fixed bin(34,0)          dcl 4896 in procedure "open_indx_file" set ref 377*
                                                                                  380 388 392* 392 400* 400 403* 403 413* 413 425
                                                                                  432* 434 435 444* 444 453* 453 456* 456 463 464*
                                                                                  464 478 3817* 3983 3988 3990 3993 4032* 4032 4044*
                                                                                  4044 4057
count                    60            based           fixed bin(17,0)          level 2 in structure "file_base" dcl 8-157
                                                                                  in procedure "open_indx_file" set ref 2502* 4238*
count                           001726 automatic       fixed bin(17,0)          dcl 3792 in procedure "count_subset" set ref 3742*
                                                                                  3753* 3753 3762 3769* 3774
create_position_stack           000172 constant        entry                    external dcl 8-369 ref 2305 4541
create_seg_ptrs                 000164 constant        entry                    external dcl 8-364 ref 2289 4540 4600
create_sw                 1(02)        based           bit(1)                   level 3 packed packed unaligned dcl 4-6 ref 676 1799
                                                                                  1805 1854
cur_mod                         000313 automatic       fixed bin(35,0)          dcl 4999 set ref 1080 1203 1284* 1288 1395* 1-11*
                                                                                  1-13 1-22* 1-28 1-34 1-55* 1-66 1-66 2007 4287
                                                                                  4287 4304 4307
current                   0(05)        based           bit(1)                   level 5 packed packed unaligned dcl 4971 ref 519 526
                                                                                  533 555
current_descrip         115            based           fixed bin(35,0)          level 4 in structure "indx_cb" dcl 8-3 in procedure
                                                                                  "open_indx_file" set ref 269* 538 560* 918* 956*
                                                                                  963 978* 1047* 1209 1284* 1288 1340 1408 2497
                                                                                  2601* 2711* 3400 3461* 3473* 3475* 3483* 3485*
                                                                                  3504 3532* 3534 3548* 3560* 3562* 3590* 3591 3602*
                                                                                  3632* 3634* 4068 4086 4089 4144* 4158* 4160* 4165*
                                                                                  4174* 4176* 4186* 4188* 1-26 1-26 1511 1548* 1645*
                                                                                  1705* 1883* 1986 2046* 2260* 2782 3138* 3140*
                                                                                  3193* 3195* 3233 4269
current_descrip           7     000103 automatic       fixed bin(35,0)          level 3 in structure "saved_state" dcl 4886
                                                                                  in procedure "open_indx_file" set ref 3138 3193
                                                                                  3400* 3473 3483 3504* 3560 3632 4068* 4158 4174
                                                                                  4186
current_descrip                        defined         fixed bin(35,0)          dcl 5070 in procedure "open_indx_file" ref 1-26
current_file_version                   constant        fixed bin(17,0)          initial dcl 4977 ref 4524 4808
current_node              6            based           fixed bin(35,0)          level 2 dcl 8-298 set ref 3378*
current_program_version                constant        fixed bin(17,0)          initial dcl 4978 ref 4542 4797
current_program_version_2              constant        fixed bin(17,0)          initial dcl 4982 ref 4556
current_record_is_valid
                        110            based           bit(1)                   level 4 in structure "indx_cb" dcl 8-3 in procedure
                                                                                  "open_indx_file" set ref 278* 285* 378* 484* 642*
                                                                                  654* 755* 767* 1590* 1616* 1632* 2033* 2048* 2122*
                                                                                  2131* 2133* 2134 2256 2272 2363* 2369 2375* 2736*
                                                                                  2812 3135* 3398 3502 3534 4066 4095 4708*
current_record_is_valid
                          2     000103 automatic       bit(1)                   level 3 in structure "saved_state" dcl 4886
                                                                                  in procedure "open_indx_file" set ref 542 3138
                                                                                  3193 3398* 3410 3473 3483 3502* 3524 3560 3588
                                                                                  3632 4066* 4093 4119 4158 4174 4186
current_retry_loc               000260 automatic       fixed bin(17,0)          dcl 4906 set ref 98 109 111 117 180 186 209 223*
                                                                                  253* 300* 314* 332* 352* 493* 517* 675* 684* 735*
                                                                                  840* 1056 1069 1138 1166 1223 2469* 2688* 2911*
                                                                                  2933* 3090* 3396* 3500* 3825* 3841* 3918 3918
                                                                                  3931* 3957 3957 4064* 4164* 4508 4510 4510 4510
                                                                                  4572*
current_state_block                    based           char                     packed unaligned dcl 4891 ref 100 100 862 862
current_subset           62            based           fixed bin(34,0)          level 2 dcl 8-3 set ref 1482 3667* 3668 3691* 3712
                                                                                  3714 3744 3768 3805 3808 3827 3995* 4515* 4733*
current_subset_bytes                   based           char(4)                  packed unaligned dcl 3790 in procedure
                                                                                  "count_subset" ref 3744 3768
current_subset_bytes                   based           char(4)                  packed unaligned dcl 1494 in procedure
                                                                                  "check_subset" ref 1482
current_t_code                         based           fixed bin(35,0)          dcl 8-82 ref 1077 1217 1219 1275 1308 1310 1331 1391
                                                                                  2614 4267 4469 4484
da_sl_info                             based           structure                level 1 unaligned dcl 6-38
dec_ref_count             1(05)        based           bit(1)                   level 3 packed packed unaligned dcl 4-6 ref 1799
                                                                                  1811 1818 1839 1843 1871 1874 1971
del_cur                         000234 automatic       bit(1)                   dcl 4901 set ref 2913* 3120 3132 3172 3190 3209 3214
                                                                                  3513* 3539* 3546* 3565 3584* 3594* 3600*
del_rec_sw                             parameter       bit(1)                   dcl 3343 ref 3115 3128 3234
del_retry                              constant        fixed bin(17,0)          initial dcl 4866 ref 2911
delete_action                   000412 constant        fixed bin(17,0)          initial dcl 9-14 set ref 2590* 3057* 3131 3158*
                                                                                  3177* 3225 3225 3299 3372
delete_old_subsets              000014 constant        entry                    external dcl 4881 in procedure "open_indx_file" ref
                                                                                  3808
delete_old_subsets        0(06)        based           bit(1)                   level 3 in structure "common_sl_info" packed packed
                                                                                  unaligned dcl 6-8 in procedure "open_indx_file"
                                                                                  ref 3808
delete_record           106            based           entry variable           level 2 dcl 10-6 set ref 4649* 4674* 4691*
deleting_key                           constant        fixed bin(17,0)          initial dcl 9-12 ref 3189
delta_ref_count                 000434 automatic       fixed bin(17,0)          dcl 5062 set ref 1839* 1842* 1843* 1845* 1924*
des_arg                                based           structure                level 1 dcl 906
desc                                   based           structure                level 1 dcl 1749
desc_array                6            based           fixed bin(35,0)          array level 2 in structure "da_sl_info" dcl 6-38
                                                                                  in procedure "open_indx_file" set ref 3970* 3977
desc_array                             based           fixed bin(17,0)          array dcl 6-24 in procedure "open_indx_file" ref
                                                                                  3727
desc_array_bytes                       based           char(4)                  array packed unaligned dcl 3789 set ref 3776*
desc_arrayp               4            based           pointer                  level 2 dcl 6-8 set ref 3721 3727* 3776
desc_code                 0(02)        based           fixed bin(2,0)           level 4 packed packed unaligned dcl 4971 ref 526
                                                                                  1501
desc_known                      001200 automatic       bit(1)                   dcl 1597 set ref 1501* 1504* 1505* 1506 1532* 1538
descrip                   1            based           fixed bin(35,0)          level 3 in structure "ak_inf" dcl 4965 in procedure
                                                                                  "open_indx_file" ref 3461 3532 3590
descrip                   4            based           structure                array level 3 in structure "node_block" unaligned
                                                                                  dcl 8-139 in procedure "open_indx_file"
descrip                                parameter       fixed bin(35,0)          dcl 1748 in procedure "get_pointer" set ref 1736
                                                                                  1738 1740 1740 1740 1740 1746*
descrip                         001202 automatic       fixed bin(35,0)          dcl 1598 in procedure "gk_scan" set ref 1537* 1538
                                                                                  1544* 1548
descrip                   1            based           fixed bin(35,0)          level 3 in structure "gk_inf" dcl 4971 in procedure
                                                                                  "open_indx_file" set ref 538* 636* 1509
descrip                                parameter       fixed bin(35,0)          dcl 2420 in procedure "find_entry" ref 2397 2408
descrip                                parameter       fixed bin(35,0)          dcl 1491 in procedure "check_subset" set ref 1478
                                                                                  1482
descrip                   1     001152 automatic       fixed bin(35,0)          level 3 in structure "gk_inf" dcl 1-87 in procedure
                                                                                  "set_current_image_info" set ref 1-51
descrip                   1            based           fixed bin(35,0)          level 3 in structure "gk_inf" dcl 4419 in procedure
                                                                                  "init_uid_info" set ref 4393 4400 4408
descrip                   1            based           fixed bin(35,0)          level 2 in structure "temp_ak_inf" dcl 4441
                                                                                  in procedure "set_lock_list_entry" set ref 4276*
                                                                                  4345*
descrip                                parameter       fixed bin(35,0)          dcl 2049 in procedure "make_current" ref 2043 2046
descrip_arg                            parameter       fixed bin(35,0)          dcl 5004 set ref 2930 2937 2938* 2977
descrip_bytes                          based           char(4)                  packed unaligned dcl 1492 ref 1482
descriptor                6            based           fixed bin(35,0)          level 2 in structure "rs_info" dcl 4-6 in procedure
                                                                                  "open_indx_file" set ref 1833 1837* 1986*
descriptor                1     000552 automatic       fixed bin(35,0)          level 2 in structure "temp_ak_inf" dcl 5081
                                                                                  in procedure "open_indx_file" set ref 3819*
designator_arg                         parameter       fixed bin(35,0)          dcl 905 set ref 902 904 904
designator_struct                      based           structure                level 1 dcl 8-127
divide                                                 builtin function         dcl 8-385 ref 1119 2176 2574 4806
dk_retry                               constant        fixed bin(17,0)          initial dcl 4869 ref 3500
dup_key_bytes             4            based           fixed bin(34,0)          level 2 dcl 8-280 set ref 2799* 2799 3288* 3288
dup_ok                   54            based           bit(1)                   level 2 dcl 8-3 set ref 247 280 485 640 752 1613
                                                                                  2134 2311 2311* 2332 2348 2738 2845 3283 3442
                                                                                  4723*
dup_ok_sw                 0(11)        based           bit(1)                   level 3 packed packed unaligned dcl 2-5 ref 4723
duplicate_keys            3            based           fixed bin(34,0)          level 2 dcl 8-280 set ref 2311 2798* 2798 3287* 3287
                                                                                  4723
er_code                                parameter       fixed bin(35,0)          dcl 2171 in procedure "set_lock" set ref 2160 2162*
                                                                                  2164* 2166*
er_code                         001130 automatic       fixed bin(35,0)          dcl 1449 in procedure "get_t_code" set ref 1445*
                                                                                  1448*
er_code                         001430 automatic       fixed bin(35,0)          dcl 2213 in procedure "lock_file_check" set ref
                                                                                  2192* 2193 2193 2193* 2207* 2209*
er_code                         001072 automatic       fixed bin(35,0)          dcl 1425 in procedure "inspect_stat_record" set ref
                                                                                  1241* 1247
er_code                         001306 automatic       fixed bin(35,0)          dcl 2016 in procedure "record_status" set ref 1940*
                                                                                  1945 1948
er_code                         001052 automatic       fixed bin(35,0)          dcl 1109 in procedure "collect_item" set ref 1083*
                                                                                  1084 1096* 1098*
er_code                         001150 automatic       fixed bin(35,0)          dcl 1-81 in procedure "set_current_image_info" set
                                                                                  ref 1-50* 1-51 1-62
er_code                         002075 automatic       fixed bin(35,0)          dcl 4415 in procedure "init_uid_info" set ref 4382*
                                                                                  4383* 4392* 4393 4401* 4402* 4409* 4410*
er_code                         002046 automatic       fixed bin(35,0)          dcl 4434 in procedure "set_lock_list_entry" set ref
                                                                                  4261* 4262* 4277* 4278 4278 4278* 4325* 4326 4326*
                                                                                  4336* 4338 4338 4338* 4346* 4347 4347* 4372* 4373
                                                                                  4373*
er_code                                parameter       fixed bin(35,0)          dcl 4834 in procedure "check_code" ref 4822 4824
                                                                                  4826
er_code                                parameter       fixed bin(35,0)          dcl 1463 in procedure "get_lock_status" set ref 1452
                                                                                  1455* 1456 1458 1458* 1460 1460*
er_code                         000132 automatic       fixed bin(35,0)          dcl 176 in on unit on line 121 set ref 127* 136*
error                   103            based           structure                level 2 unaligned dcl 8-3 set ref 353 4508*
error_info                             based           structure                level 1 unaligned dcl 5046
error_table_$asynch_change      000142 external static fixed bin(35,0)          dcl 7-3 ref 4363
error_table_$asynch_deletion    000146 external static fixed bin(35,0)          dcl 7-3 ref 2373 3926 4104
error_table_$asynch_insertion   000140 external static fixed bin(35,0)          dcl 7-3 ref 2336 2361
error_table_$bad_arg            000132 external static fixed bin(35,0)          dcl 7-3 set ref 504 523 730 797 822 826 1745* 3663
                                                                                  3813
error_table_$bad_file           000102 external static fixed bin(35,0)          dcl 7-3 set ref 4755* 4767* 4767*
error_table_$end_of_info        000104 external static fixed bin(35,0)          dcl 7-3 ref 341 414 443 590 1069 1641 1700
error_table_$file_busy          000076 external static fixed bin(35,0)          dcl 7-3 ref 205 2107 2198
error_table_$file_is_full       000152 external static fixed bin(35,0)          dcl 7-3 ref 2423
error_table_$higher_inconsistency
                                000114 external static fixed bin(35,0)          dcl 7-3 ref 1179 1189 1243 1-39 1-62
error_table_$invalid_lock_reset 000106 external static fixed bin(35,0)          dcl 7-3 ref 1147 1321 1460 1892 1926 2105 2193 2478
                                                                                  2925 3468 3629 4154 4170
error_table_$key_duplication    000130 external static fixed bin(35,0)          dcl 7-3 ref 3445 4034 4278 4338
error_table_$key_order          000154 external static fixed bin(35,0)          dcl 7-3 ref 1780
error_table_$last_reference     000112 external static fixed bin(35,0)          dcl 7-3 ref 1363 1811
error_table_$lock_is_invalid    000122 external static fixed bin(35,0)          dcl 7-3 ref 1084 1213 1460
error_table_$lock_not_locked    000126 external static fixed bin(35,0)          dcl 7-3 ref 701 852 1814
error_table_$lock_wait_time_exceeded
                                000110 external static fixed bin(35,0)          dcl 7-3 ref 1158 1253 1458 2097 4587 4594 4616
error_table_$locked_by_this_process
                                000134 external static fixed bin(35,0)          dcl 7-3 ref 704 835 1147 1213 1247 1268 1321 1892
                                                                                  1926 2164 2478 2486 2555 2563 2925 3468 3629 4154
                                                                                  4170 4616
error_table_$long_record        000150 external static fixed bin(35,0)          dcl 7-3 ref 1439 1805 2488 2729
error_table_$no_key             000074 external static fixed bin(35,0)          dcl 7-3 ref 537 618 3508 3552 3571 3580 4070 4079
                                                                                  4138 1-62 2853 4046
error_table_$no_operation       000136 external static fixed bin(35,0)          dcl 7-3 ref 899 1793 1800 3393 3649
error_table_$no_record          000100 external static fixed bin(35,0)          dcl 7-3 set ref 244 264 274 341 561 583 746 980*
                                                                                  1015 1022 1067 1069 1562 1631 1808 1833 2272 2695
                                                                                  2922 3555 3580 3615 3983 4140
error_table_$no_room_for_lock   000120 external static fixed bin(35,0)          dcl 7-3 ref 966 1123 1826 1896 1958 1971
error_table_$record_busy        000116 external static fixed bin(35,0)          dcl 7-3 ref 1158 1185 1230 1247 1256 1272 1279 1458
                                                                                  1-76
error_table_$too_many_refs      000144 external static fixed bin(35,0)          dcl 7-3 ref 1370
error_table_$unimplemented_version
                                000124 external static fixed bin(35,0)          dcl 7-3 ref 1790 4546 4559
eternity                        000342 constant        fixed bin(71,0)          initial dcl 4910 ref 105 2082
exclu_sw                  0(14)        based           bit(1)                   level 3 packed packed unaligned dcl 2-5 ref 4725
exclude_flag                           constant        bit(1)                   initial dcl 5105 ref 3684
exclusive                 0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 5052 ref 842 846
f_b_ptr                         001002 automatic       pointer                  dcl 8-156 set ref 103* 198 686 866* 916* 921 972
                                                                                  1858 1863 1864 1867 1871 1874 1878 1878 1879 1883
                                                                                  2057 2087 2088 2088 2089 2092 2183* 2189 2192 2192
                                                                                  2202 2211 2218* 2230 2230 2231 2279 2280 2285 2293
                                                                                  2296 2297 2299 2299 2308 2308 2310 2310 2429 2429
                                                                                  2440 2441 2448 2497 2501 2502 2505 2507 2509 2512
                                                                                  2515 2516 2517 2518 2518 2519 2522 2530 2536 2536
                                                                                  2537 2538 2541 2549 2549 2566 2574 2590 2593 2596
                                                                                  2601 2658 2665 2665 2669 2670 2671 2672 2673 2674
                                                                                  2700 2702 2704 2704 2708 2711 2716 2717 2717 2745
                                                                                  2761 2762 2766 2771 2772 2774 2783 2787 2905 2937
                                                                                  2945 2945 2945 2983 2992 2998 2998 3001 3001 3010
                                                                                  3014 3015 3016 3019 3019 3024 3027 3027 3029 3036
                                                                                  3044 3044 3046 3048 3048 3050 3053 3056 3064 3067
                                                                                  3073 3080 3100 3100 3105 3106 3108 3111 3118 3141
                                                                                  3141 3142 3145 3148 3149 3165 3177 3190 3196 3196
                                                                                  3197 3200 3201 3204 3214 3225 3225 3225 3225 3225
                                                                                  3233 3238 3239 3244 3245 3247 3266 3269 3274 3275
                                                                                  3277 3282 3290 3487 3487 3488 3491 3492 3707* 3708
                                                                                  3708 3738* 3739 3739 3910 3952 4192 4192 4197 4198
                                                                                  4204 4205 4207 4219 4224 4225 4227 4232 4233 4235
                                                                                  4236 4237 4238 4466 4524 4533 4542 4556 4578* 4579
                                                                                  4579 4581 4581 4593 4593 4596 4624 4625 4628 4701*
                                                                                  4702 4713 4713 4715 4715 4731 4754 4754 4755 4755
                                                                                  4765 4797 4798 4799 4800 4801 4803 4805 4806 4806
                                                                                  4806 4806 4806 4806 4807 4807 4808
fake_head_and_descrip
                         10            based           structure                level 3 unaligned dcl 8-298
fake_node                10            based           structure                level 2 unaligned dcl 8-298
fault_ok                        000235 automatic       bit(1)                   dcl 4902 set ref 119* 123 126* 134* 2067* 2187*
fcb_ptr                                based           pointer                  level 2 dcl 8-3 set ref 4699*
fcb_ptr_arg                            parameter       pointer                  dcl 4929 ref 73 4699
file_action                            based           fixed bin(17,0)          level 2 dcl 8-280 set ref 842* 869 869* 924 1875*
                                                                                  2089 2204 2204 2233* 2235* 2508* 2703* 2944 3000*
                                                                                  3007* 3007 3047* 3131* 3189* 3225 3225 3486* 4191*
                                                                                  4542 4542 4569* 4619 4619* 4621
file_base                              based           structure                level 1 unaligned dcl 8-157 set ref 4806 4807
file_base_ptr             2            based           pointer                  level 2 dcl 8-3 set ref 103 129 853 866 881* 888*
                                                                                  895* 916 1125 1125 1967 1967 2183 2218 2426 3707
                                                                                  3738 4382* 4578 4700* 4701 4807*
file_header                            based           structure                level 1 unaligned dcl 8-274
file_id                   2            based           bit(36)                  level 2 in structure "gk_key" dcl 4426 in procedure
                                                                                  "init_uid_info" set ref 4390*
file_id                   1            based           bit(36)                  level 2 in structure "temp_key" dcl 4447
                                                                                  in procedure "set_lock_list_entry" set ref 4268*
file_position_ptr        26            based           pointer                  level 2 dcl 8-3 set ref 102 234 257* 262 371 574 867
                                                                                  1104 1481* 1612 1665* 1681* 1694 1710* 1712 1886
                                                                                  2024 2146* 2157* 2182 2244 2306 2323* 2351* 2353
                                                                                  2399* 2401 2720 2868 3213 3326* 3357 3416* 3422
                                                                                  3434 3495 3761 3783 3886* 3889 4109 4215 4315 4358
                                                                                  4368 4730*
file_state               16            based           fixed bin(17,0)          level 2 dcl 8-157 set ref 2088 2308 2310 2429* 2429
                                                                                  3708 3739 4579 4581 4713 4715
file_state_block                       based           structure                level 1 unaligned dcl 8-280 set ref 2088 2285 2308
                                                                                  2310 2426 3708 3739 4579 4581 4596 4713 4715 4754
                                                                                  4754 4755 4755 4805 4806 4806 4806 4807 4807
file_state_blocks       551            based           structure                array level 2 unaligned dcl 8-157 set ref 2088 2308
                                                                                  2310 3708 3739 4579 4581 4713 4715
file_state_ptr           44            based           pointer                  level 2 dcl 8-3 set ref 104 868 917 2184 2208 2221
                                                                                  2308* 2309 2431* 4554 4579* 4580 4713* 4714
file_state_words          1            based           fixed bin(17,0)          array level 2 dcl 2237 set ref 2232* 2232
file_substate             1            based           fixed bin(17,0)          level 2 dcl 8-280 set ref 2223 2229* 2660* 2660
                                                                                  2807* 2807 2906* 2906 3112* 3112 3301* 3301 3353
                                                                                  3358* 3358 3373* 3373 4239* 4239 4818
file_version              4            based           fixed bin(17,0)          level 2 dcl 8-157 set ref 4524 4808*
find_condition_info_            000202 constant        entry                    external dcl 170 ref 127
find_key                        000024 constant        entry                    external dcl 4918 ref 260 1483 1711 2352 2400 3888
find_key$last                   000026 constant        entry                    external dcl 4919 ref 3420
first_branch             65            based           fixed bin(35,0)          level 2 dcl 8-157 set ref 2501* 4237*
first_code                      000231 automatic       fixed bin(35,0)          dcl 4898 set ref 2383 2404* 3542* 3552 4111* 4125*
                                                                                  4132* 4138
first_head                6            based           structure                array level 3 unaligned dcl 6-27
first_seg_bitcount                     parameter       fixed bin(24,0)          dcl 4930 ref 73
first_seg_ptr                          parameter       pointer                  dcl 4931 ref 73 4700
fixed                                                  builtin function         dcl 8-392 ref 607 612 622 904 1225 1394 1-9 1-70
                                                                                  1871 1871 1871 2176 3225 3259
fixed_state_block                      based           structure                level 1 unaligned dcl 4893 ref 100 100 862 862
fixed_state_part                000103 automatic       structure                level 2 in structure "saved_state" unaligned
                                                                                  dcl 4886 in procedure "open_indx_file"
fixed_state_part        106            based           structure                level 3 in structure "indx_cb" unaligned dcl 8-3
                                                                                  in procedure "open_indx_file"
flag                            000557 automatic       bit(1)                   dcl 5086 set ref 3654* 3684* 3718 3801 3988 3988
                                                                                  4000 4000 4028 4028
flags                           001152 automatic       structure                level 3 in structure "gk_inf" dcl 1-87 in procedure
                                                                                  "set_current_image_info" set ref 1-45*
flags                           002047 automatic       bit(36)                  level 2 in structure "temp_rk_inf" dcl 4435
                                                                                  in procedure "set_lock_list_entry" set ref 4324*
flags                     1            based           structure                level 2 in structure "rs_info" dcl 4-6 in procedure
                                                                                  "open_indx_file"
flags                                  based           structure                level 3 in structure "rk_inf" dcl 4968 in procedure
                                                                                  "open_indx_file"
flags                                  based           structure                level 3 in structure "ak_inf" dcl 4965 in procedure
                                                                                  "open_indx_file"
flags                                  based           bit(36)                  level 2 in structure "temp_ak_inf" dcl 4441
                                                                                  in procedure "set_lock_list_entry" set ref 4274*
                                                                                  4335* 4369*
flags                                  based           structure                level 3 in structure "gk_inf" dcl 4419 in procedure
                                                                                  "init_uid_info" set ref 4384*
flags                                  based           structure                level 3 in structure "ak_inf" dcl 4422 in procedure
                                                                                  "init_uid_info" set ref 4407*
flags                                  based           structure                level 2 in structure "common_sl_info" dcl 6-8
                                                                                  in procedure "open_indx_file"
flags                                  based           structure                level 2 in structure "atb" dcl 2-5 in procedure
                                                                                  "open_indx_file"
flags                           000552 automatic       bit(36)                  level 2 in structure "temp_ak_inf" dcl 5081
                                                                                  in procedure "open_indx_file" set ref 3818*
flags                                  based           structure                level 3 in structure "gk_inf" dcl 4971 in procedure
                                                                                  "open_indx_file"
flags                           002076 automatic       structure                level 3 in structure "rk_inf" dcl 4416 in procedure
                                                                                  "init_uid_info" set ref 4398*
foo                             000272 automatic       fixed bin(35,0)          dcl 4946 in procedure "open_indx_file" set ref 1711*
                                                                                  4533* 4563* 4584* 4587* 4593* 4594 4616 4616 4728*
                                                                                  4802* 4803* 4807*
foo                             002140 automatic       fixed bin(35,0)          dcl 4792 in procedure "discard_temp_file" set ref
                                                                                  4781* 4786* 4788* 4789*
free_action                     000340 constant        fixed bin(17,0)          initial dcl 9-6 set ref 3021* 3073* 3080*
free_cb_file                    000160 constant        entry                    external dcl 8-361 ref 4532 4615
free_position_stack             000174 constant        entry                    external dcl 8-371 ref 2304 4609
free_seg_ptrs                   000166 constant        entry                    external dcl 8-365 ref 2288 4599 4608
fs_ptr                          001004 automatic       pointer                  dcl 8-279 set ref 104* 842 868* 869 869 917* 924
                                                                                  1875 2056 2057 2088* 2088 2089 2184* 2204 2204
                                                                                  2208* 2221* 2223 2229 2232 2285 2308 2309* 2310
                                                                                  2311 2426 2432 2508 2524 2530 2537 2660 2660 2703
                                                                                  2793 2794 2798 2799 2807 2807 2906 2906 2944 2992
                                                                                  2994 2998 3000 3007 3047 3058 3083 3112 3112 3131
                                                                                  3189 3225 3225 3263 3265 3278 3279 3287 3288 3301
                                                                                  3301 3353 3358 3358 3373 3373 3486 3708 3739 4191
                                                                                  4239 4239 4542 4542 4554* 4569 4579 4580* 4581
                                                                                  4596 4619 4619 4621 4713 4714* 4715 4723 4754 4754
                                                                                  4755 4755 4805 4806 4806 4806 4807 4807 4818
fsb                                    based           structure                level 1 unaligned dcl 2237
get_pdir_                       000040 constant        entry                    external dcl 4996 ref 4011 4786 4786
get_seg_ptr                     000162 constant        entry                    external dcl 8-362 ref 1740 2296
get_system_free_area_           000012 constant        entry                    external dcl 4880 ref 3725
gk_desc                                based           pointer                  packed unaligned dcl 4425 set ref 4393 4400* 4408*
gk_header                              based           structure                level 1 unaligned dcl 5-46
gk_inf                                 based           structure                level 1 unaligned dcl 4971 in procedure
                                                                                  "open_indx_file"
gk_inf                          001152 automatic       structure                level 1 unaligned dcl 1-87 in procedure
                                                                                  "set_current_image_info" set ref 1-50 1-50
gk_inf                                 based           structure                level 1 unaligned dcl 4419 in procedure
                                                                                  "init_uid_info" set ref 4392 4392
gk_key                                 based           fixed bin(35,0)          dcl 1-86 in procedure "set_current_image_info" set
                                                                                  ref 1-49*
gk_key                                 based           structure                level 1 unaligned dcl 4426 in procedure
                                                                                  "init_uid_info"
gk_pad_key                      000326 automatic       structure                level 1 unaligned dcl 5030 set ref 605 3835
gk_retry                               constant        fixed bin(17,0)          initial dcl 4860 ref 517
hbound                                                 builtin function         dcl 4883 ref 4754
hcs_$delentry_file              000034 constant        entry                    external dcl 4993 ref 4786
hcs_$get_uid_seg                000036 constant        entry                    external dcl 4994 ref 4382
hcs_$set_bc_seg                 000206 constant        entry                    external dcl 4810 ref 4807
head_len                               parameter       fixed bin(17,0)          dcl 1733 ref 1708 1716 1716
head_size                 0(09)        based           fixed bin(9,0)           level 5 in structure "gk_inf" packed packed unsigned
                                                                                  unaligned dcl 4419 in procedure "init_uid_info"
                                                                                  set ref 4386*
head_size                 0(09) 001152 automatic       fixed bin(9,0)           level 5 in structure "gk_inf" packed packed unsigned
                                                                                  unaligned dcl 1-87 in procedure
                                                                                  "set_current_image_info" set ref 1-48*
head_size                 0(09)        based           fixed bin(9,0)           level 5 in structure "gk_inf" packed packed unsigned
                                                                                  unaligned dcl 4971 in procedure "open_indx_file"
                                                                                  ref 607 612 622
head_spec                       000560 automatic       bit(1)                   dcl 5087 set ref 3853* 3857* 3858
header                                 based           structure                level 2 in structure "gk_inf" unaligned dcl 4419
                                                                                  in procedure "init_uid_info"
header                                 based           structure                level 2 in structure "ak_inf" unaligned dcl 4422
                                                                                  in procedure "init_uid_info"
header                                 based           structure                level 2 in structure "gk_inf" unaligned dcl 4971
                                                                                  in procedure "open_indx_file"
header                                 based           structure                level 2 in structure "rk_inf" unaligned dcl 4968
                                                                                  in procedure "open_indx_file"
header                          001152 automatic       structure                level 2 in structure "gk_inf" unaligned dcl 1-87
                                                                                  in procedure "set_current_image_info"
header                          002076 automatic       structure                level 2 in structure "rk_inf" unaligned dcl 4416
                                                                                  in procedure "init_uid_info"
header                                 based           structure                level 2 in structure "ak_inf" unaligned dcl 4965
                                                                                  in procedure "open_indx_file"
hi_sl_info                             based           structure                level 1 unaligned dcl 6-27
i                               001727 automatic       fixed bin(17,0)          dcl 3793 in procedure "count_subset" set ref 3770*
                                                                                  3774 3775* 3775 3776 3784 3785
i                               000450 automatic       fixed bin(17,0)          dcl 5076 in procedure "open_indx_file" set ref 3840*
                                                                                  3853 3853 3853 3862 3862 3866 3866 3866 3869 3873
                                                                                  3873 3876 3883 3883* 3967* 3970 3977*
i                               000144 automatic       fixed bin(17,0)          dcl 160 in procedure "asynch_change_condition" set
                                                                                  ref 149* 150*
i                               001672 automatic       fixed bin(17,0)          dcl 3385 in procedure "save_position_info" set ref
                                                                                  3380* 3382 3383*
i_locked_file                          based           bit(1)                   level 2 packed packed unaligned dcl 5011 set ref 972
                                                                                  1092 1131 1935 2063 2185 2189* 2191* 2433 4466
i_locked_mask                          parameter       bit(36)                  dcl 1475 ref 909 920 1143 1155 1238 1265 1299 1348
i_locked_new              0(02)        based           bit(1)                   level 2 packed packed unaligned dcl 5011 ref 2458
                                                                                  4484
i_locked_new_mask               000345 constant        bit(36)                  initial dcl 4841 set ref 4168*
i_locked_rec              0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 5011 set ref
                                                                                  708* 1906* 1969* 2454 2486* 2546* 2549 2571* 2585*
                                                                                  2594* 2940* 3059* 3225* 3252* 3255* 3259* 3262*
                                                                                  4469
i_locked_rec_mask               000346 constant        bit(36)                  initial dcl 4839 set ref 1889* 1924* 2476* 2712*
                                                                                  2919* 3466* 3612* 4150*
i_set_negmod              0(05)        based           bit(1)                   level 2 packed packed unaligned dcl 5011 set ref
                                                                                  2456 3252* 3255* 3259*
i_set_new_negmod          0(06)        based           bit(1)                   level 2 packed packed unaligned dcl 5011 ref 2462
inc_ref_count             1(04)        based           bit(1)                   level 3 packed packed unaligned dcl 4-6 ref 1799
                                                                                  1811 1818 1839 1871 1874 1971
ind_comp                  1(06)        based           fixed bin(13,0)          level 2 in structure "stat_struct" packed packed
                                                                                  unaligned dcl 2647 in procedure "unlock_record"
                                                                                  set ref 2636*
ind_comp                  1(06)        based           fixed bin(13,0)          level 2 in structure "stat_struct" packed packed
                                                                                  unaligned dcl 1-93 in procedure
                                                                                  "lock_current_record" set ref 1325* 1396 1-19 1-32
ind_comp                  1(06)        based           fixed bin(13,0)          level 2 in structure "stat_struct" packed packed
                                                                                  unaligned dcl 4988 in procedure "open_indx_file"
                                                                                  set ref 1952 2516* 2989 3041 3242*
ind_des                                based           structure                level 1 packed packed unaligned dcl 1-92
                                                                                  in procedure "lock_current_record"
ind_des                                based           structure                level 1 packed packed unaligned dcl 4991
                                                                                  in procedure "open_indx_file"
ind_des_structure                      based           structure                level 1 packed packed unaligned dcl 8-89
ind_desc                        000312 automatic       fixed bin(35,0)          dcl 4998 set ref 1199 1206 1206* 1209* 1288 1288*
                                                                                  1333* 1335 1338* 1340* 1342* 1396 1397 1405 1408
                                                                                  1416* 2965* 2970* 2973* 2977* 2989 2990 2996 3003
                                                                                  3041 3042 1-13* 1-15* 1-19 1-20 1-26* 1-56* 1930
                                                                                  1952 1953 1954* 2673 3105 3106 3111* 4295 4296
                                                                                  4345
ind_offset                             based           bit(18)                  level 2 in structure "time_stamp_struct" packed
                                                                                  packed unaligned dcl 4990 in procedure
                                                                                  "open_indx_file" set ref 1953 2517* 2990 3042
                                                                                  3243*
ind_offset                             based           bit(18)                  level 2 in structure "time_stamp_struct" packed
                                                                                  packed unaligned dcl 1-95 in procedure
                                                                                  "lock_current_record" set ref 1326* 1397 1-20 1-33
ind_offset                             based           bit(18)                  level 2 in structure "time_stamp_struct" packed
                                                                                  packed unaligned dcl 2644 in procedure
                                                                                  "unlock_record" set ref 2637*
ind_struct                             based           structure                level 1 unaligned dcl 1-94 in procedure
                                                                                  "lock_current_record"
ind_struct                             based           structure                level 1 unaligned dcl 4989 in procedure
                                                                                  "open_indx_file"
ind_structure                          based           structure                level 1 unaligned dcl 8-102
index                                                  builtin function         dcl 4883 ref 4013
index_action              4            based           fixed bin(17,0)          level 2 dcl 8-298 set ref 2806* 3297* 3299* 3372*
index_height              3            based           fixed bin(17,0)          level 2 dcl 8-298 ref 2301 3380
index_state             114            based           fixed bin(17,0)          level 2 dcl 8-157 ref 2299
index_state_block                      based           structure                level 1 unaligned dcl 8-298
index_state_blocks      115            based           structure                array level 2 unaligned dcl 8-157 set ref 2299 4803
index_state_ptr          34            based           pointer                  level 2 dcl 8-3 set ref 2299* 2301 2754 3221 3363
indirect                  0(24)        based           bit(1)                   level 3 in structure "record_block" packed packed
                                                                                  unaligned dcl 4987 in procedure "open_indx_file"
                                                                                  ref 2671 2967 3108
indirect                  0(24)        based           bit(1)                   level 3 in structure "record_block" packed packed
                                                                                  unaligned dcl 1-96 in procedure
                                                                                  "lock_current_record" ref 1206 1338 1-15
indx_cb                                based           structure                level 1 unaligned dcl 8-3 set ref 4532 4532 4615
                                                                                  4615 4697 4697
indx_cb_ptr                     001000 automatic       pointer                  dcl 8-2 set ref 79* 83* 85 87* 93 100 100 100 100
                                                                                  102 103 104 105 107 111 182* 188 195 198 214* 225
                                                                                  230 234 235 239 240 245 247 247 255 255 257 257
                                                                                  258 259 260* 262 263 269 278 279 280 280 285 286
                                                                                  287 290 291 341 341 343 355 363 364 371 372 372
                                                                                  373 377 378 378 383 396 410 423 424 425 428 432
                                                                                  449 459 476 477 478 483 484 485 485 486 499 500
                                                                                  533 538 542 545 549 552 555 560 567 574 575 579
                                                                                  587 598 611 613 616 616 622 625 627 640 640 641
                                                                                  641 641 642 643 647 648 654 654 654 655 655 655
                                                                                  660 661 666* 676 676 680 688 693 694 715 723 723
                                                                                  723 737 737 739 740 746 752 752 754 755 756 757
                                                                                  759 760 766 767 768 770 775 801 802 803 811 812
                                                                                  816 825 828 832 835 846 847 849 853 853 862 862
                                                                                  862 862 865 866 867 868 871 881 888 895 904 913
                                                                                  916 917 918 956 956 963 966 972 972 972 972 978
                                                                                  1007 1007 1011 1028 1028 1033 1035 1035 1040 1040
                                                                                  1042 1042 1046 1047 1060 1060 1060 1060 1072 1077
                                                                                  1077 1087 1087 1092 1092 1092 1094 1095 1099 1099
                                                                                  1101 1102 1103 1104 1106 1106 1123 1125 1125 1131
                                                                                  1131 1143 1209 1213 1213 1217 1219 1238 1249 1268
                                                                                  1275 1284 1288 1305 1308 1310 1331 1340 1374 1389
                                                                                  1391 1408 1445 2426 2431 2432 2433 2433 2440 2441
                                                                                  2448 2481 2481 2493 2493 2495 2497 2498 2505 2512
                                                                                  2512 2538 2538 2578 2596 2601 2692 2704 2704 2711
                                                                                  2720 2918 2921 2941 2952 3007 3389 3398 3400 3410
                                                                                  3413 3415 3416 3416 3417 3420* 3422 3434 3442 3449
                                                                                  3461 3463 3473 3475 3475 3483 3485 3485 3495 3502
                                                                                  3504 3508 3524 3530 3532 3534 3534 3534 3534 3534
                                                                                  3534 3534 3534 3540 3547 3548 3560 3562 3562 3565
                                                                                  3568 3588 3590 3591 3591 3595 3601 3602 3602 3608
                                                                                  3611 3614 3622 3623 3632 3634 3634 3660 3667 3668
                                                                                  3671 3675 3679 3686 3691 3692 3801 3803 3803 3805
                                                                                  3806 3808 3808 3826 3827 3831 3870 3886 3886 3888*
                                                                                  3889 3910 3910 3910 3932 3948 3952 3952 3952 3970
                                                                                  3988 3988 3990 3990 3990 3993 3993 3995 4000 4000
                                                                                  4002 4066 4068 4070 4086 4089 4093 4095 4095 4095
                                                                                  4095 4095 4095 4095 4100 4104 4109 4119 4121 4128
                                                                                  4136 4144 4145 4148 4149 4152 4158 4160 4160 4165
                                                                                  4166 4169 4174 4176 4176 4186 4188 4188 4527* 4531
                                                                                  4532 4532 4532* 4541* 4542 4554 4556 4556 4567
                                                                                  4569 4577* 4578 4579 4580 4581 4582 4590 4590 4590
                                                                                  4596 4603 4609* 4610 4612 4614 4615 4615 4615*
                                                                                  1-26 1-37 1-50 1480 1482 1484 1511 1512 1519 1519
                                                                                  1525 1548 1553 1564 1573 1580 1580 1580 1589 1590
                                                                                  1605 1612 1613 1613 1614 1614 1614 1616 1617 1623
                                                                                  1627 1632 1633 1637 1645 1665 1681 1687 1694 1695
                                                                                  1705 1710 1710 1711* 1712 1715 1728 1740 1740 1757
                                                                                  1759 1793 1800 1805 1808 1818 1818 1824 1824 1868
                                                                                  1874 1883 1886 1900 1930 1935 1935 1935 1937 1938
                                                                                  1942 1944 1967 1967 1975 1986 2021 2021 2021 2024
                                                                                  2029 2033 2033 2034 2038 2039 2045 2046 2047 2048
                                                                                  2054 2063 2068 2072 2073 2082 2084 2105 2116 2120
                                                                                  2121 2122 2123 2128 2130 2131 2133 2134 2134 2134
                                                                                  2135 2146 2157 2162 2164 2182 2183 2184 2185 2189
                                                                                  2199 2202 2208 2211 2211 2218 2219 2221 2222 2223
                                                                                  2223 2226 2231 2233 2244 2246 2249 2256 2259 2260
                                                                                  2263 2267 2272 2279 2280 2285 2293 2296 2297 2299
                                                                                  2301 2301 2304* 2305* 2306 2308 2309 2310 2311
                                                                                  2311 2320 2320 2323 2323 2325 2330 2332 2335 2336
                                                                                  2341 2344 2346 2348 2351 2351 2352* 2352 2353 2358
                                                                                  2362 2363 2364 2369 2369 2369 2374 2374 2374 2375
                                                                                  2376 2382 2382 2386 2394 2399 2399 2400* 2401 2412
                                                                                  2614 2614 2622 2630 2640 2652 2680 2726 2736 2737
                                                                                  2737 2738 2738 2739 2740 2740 2744 2745 2754 2755
                                                                                  2762 2782 2787 2802 2812 2823 2826 2832 2833 2845
                                                                                  2845 2845 2859 2868 2884 2899 3097 3118 3120 3124
                                                                                  3125 3127 3135 3136 3138 3140 3140 3152 3153 3153
                                                                                  3159 3162 3168 3168 3172 3179 3182 3190 3193 3195
                                                                                  3195 3209 3209 3213 3221 3222 3233 3247 3247 3247
                                                                                  3259 3266 3280 3283 3315 3318 3318 3318 3325 3326
                                                                                  3348 3351 3351 3353 3357 3363 3364 3370 3379 3646
                                                                                  3646 3701 3707 3708 3712 3712 3714 3716 3718 3735
                                                                                  3738 3739 3744 3745* 3745 3748 3757 3760* 3761
                                                                                  3762 3768 3769 3771* 3771 3774 3782* 3783 3784
                                                                                  4017 4028 4031 4043 4059 4059 4212 4215 4246 4257
                                                                                  4261 4264 4265 4267 4268 4269 4285* 4309 4314*
                                                                                  4315 4357* 4358 4359 4367* 4368 4382 4389 4391
                                                                                  4412 4460* 4461 4466 4469 4469 4480 4484 4484 4496
                                                                                  4504 4505 4505 4506 4506 4507 4507 4508 4514 4515
                                                                                  4517 4636 4637 4643 4651 4659 4664 4697 4697 4698*
                                                                                  4699 4700 4701 4702 4703 4704 4704 4705 4705 4706
                                                                                  4706 4707 4708 4709 4710 4711 4712 4713 4714 4715
                                                                                  4716 4717 4718 4719 4720 4721 4722 4723 4724 4725
                                                                                  4726 4727 4728 4729 4730 4731 4732 4733 4734 4735
                                                                                  4736 4737 4738 4738 4740 4741 4742 4743 4755 4765
                                                                                  4807 4817 4817 4818 4818 4828* 4829
info                                   based           structure                level 1 unaligned dcl 5037
info_ptr                        000324 automatic       pointer                  dcl 5027 set ref 511* 519 519 519 526 526 526 526
                                                                                  533 533 538 539 542 549 555 555 591 607 607 610
                                                                                  610 612 612 616 622 622 627 634 635 635 636 637
                                                                                  651 727 727 727 742 742 744 744 745 745 757 757
                                                                                  797 801 802 803 811 812 822 822 825 826 828 835
                                                                                  842 846 881* 888* 895* 1501 1501 1509 1509 1519
                                                                                  1527 1789 2775 2778 2779 3401 3404 3420 3436 3452
                                                                                  3461 3461 3505 3515 3518 3532 3534 3548 3580 3584
                                                                                  3590 3656 3656 3660 3660 3667 3672 3679 3686 3686
                                                                                  3686 3691 3704 3704 3710 3712 3714 3716 3718 3721
                                                                                  3721 3727 3727 3776 3785 3796 3808 3821 3821 3832
                                                                                  3834 3842 3853 3853 3853 3862 3862 3866 3866 3866
                                                                                  3869 3873 3873 3876 3883 3883 3967 3967 3970 3977
                                                                                  3998 4070 4072 4072 4075 4084 4084 4087 4087 4090
                                                                                  4095 4114 4116
info_ptr_arg                           parameter       pointer                  dcl 5027 ref 509 511
infop                    14     000100 automatic       pointer                  level 2 dcl 171 set ref 144
init_key_len                    001574 automatic       fixed bin(17,0)          dcl 2891 set ref 2877* 2886
init_key_ptr                    001576 automatic       pointer                  dcl 2892 set ref 2878* 2886
init_retry                             constant        fixed bin(17,0)          initial dcl 4870 ref 3825 4510
initial_key                            based           char                     packed unaligned dcl 2893 ref 2886
inner_retry                            constant        fixed bin(17,0)          initial dcl 4871 ref 3918 3931 4510
input_desc                0(01)        based           bit(1)                   level 4 in structure "gk_inf" packed packed
                                                                                  unaligned dcl 4971 in procedure "open_indx_file"
                                                                                  ref 519 526 1501 1509
input_desc                0(01)        based           bit(1)                   level 4 in structure "ak_inf" packed packed
                                                                                  unaligned dcl 4965 in procedure "open_indx_file"
                                                                                  ref 3404 3452 3461 3518 3580 3584
input_key                              based           bit(1)                   level 4 in structure "rk_inf" packed packed
                                                                                  unaligned dcl 4968 in procedure "open_indx_file"
                                                                                  ref 4070 4075 4090
input_key                              based           bit(1)                   level 4 in structure "ak_inf" packed packed
                                                                                  unaligned dcl 4965 in procedure "open_indx_file"
                                                                                  ref 2775 3401 3515
input_key                              based           bit(1)                   level 4 in structure "gk_inf" packed packed
                                                                                  unaligned dcl 4971 in procedure "open_indx_file"
                                                                                  ref 519 526 533 555
input_key                       001152 automatic       bit(1)                   level 4 in structure "gk_inf" packed packed
                                                                                  unaligned dcl 1-87 in procedure
                                                                                  "set_current_image_info" set ref 1-46*
input_key                              based           bit(1)                   level 4 in structure "gk_inf" packed packed
                                                                                  unaligned dcl 4419 in procedure "init_uid_info"
                                                                                  set ref 4385*
input_new_desc            0(02)        based           bit(1)                   level 4 packed packed unaligned dcl 4968 ref 4072
                                                                                  4087
input_old_desc            0(01)        based           bit(1)                   level 4 packed packed unaligned dcl 4968 ref 4072
                                                                                  4084 4116
insert_action                   000416 constant        fixed bin(17,0)          initial dcl 9-18 set ref 1876* 2545 2703 2707* 2806
interval                  6            based           structure                array level 2 unaligned dcl 6-27
iocb                                   based           structure                level 1 dcl 10-6
iocb_ptr                               parameter       pointer                  dcl 4932 set ref 73 79 83 87 129 129 182 214 221 251
                                                                                  298 312 330 347 353 509 666 881* 888* 895* 1096*
                                                                                  1098* 1284* 1740* 1876* 1885* 1940* 2105* 2207*
                                                                                  2288* 2289* 2296* 2467 2512* 2522* 2531* 2548*
                                                                                  2590* 2686 2707* 2719* 2909 2930 3021* 3030* 3057*
                                                                                  3068* 3073* 3080* 3087 3149* 3158* 3177* 3212*
                                                                                  3356* 3494* 3760 3782 4314 4357 4367 4393 4400
                                                                                  4408 4460 4504 4533 4540* 4553* 4575 4577 4599*
                                                                                  4600* 4603* 4608* 4616 4635 4639 4640 4641 4645
                                                                                  4646 4647 4648 4649 4653 4654 4655 4656 4657 4661
                                                                                  4662 4666 4667 4668 4669 4670 4671 4672 4673 4674
                                                                                  4676 4678 4679 4681 4683 4685 4687 4688 4689 4690
                                                                                  4691 4697 4698 4710 4711 4723 4724 4725 4737 4738
                                                                                  4828
iocbp                                  parameter       pointer                  dcl 4791 in procedure "discard_temp_file" set ref
                                                                                  4777 4779 4781* 4782 4782 4788* 4789* 4790*
iocbp                           002012 automatic       pointer                  dcl 4023 in procedure "get_temp_switch" set ref
                                                                                  4014* 4015* 4017
iox_$attach_name                000060 constant        entry                    external dcl 3-8 ref 4014
iox_$close                      000062 constant        entry                    external dcl 3-8 ref 4781
iox_$control                    000064 constant        entry                    external dcl 3-8 ref 1-50 4277 4325 4336 4346 4372
                                                                                  4392 4401 4409
iox_$destroy_iocb               000066 constant        entry                    external dcl 3-8 ref 4789
iox_$detach_iocb                000070 constant        entry                    external dcl 3-8 ref 4788
iox_$open                       000072 constant        entry                    external dcl 3-8 ref 4015
is_ks_out                16            based           bit(1)                   level 2 dcl 8-3 set ref 723 2320 2374 2762 2845 3417
                                                                                  4507* 4706*
is_new_file                            parameter       bit(1)                   dcl 4933 ref 73 4522
is_partial_deletion     476            based           bit(1)                   level 2 dcl 8-157 set ref 3165 3225 3238* 3247* 3266
is_ptr                          001006 automatic       pointer                  dcl 8-297 set ref 2680 2681 2681 2754* 2782 2783
                                                                                  2803 2805 2806 2817 2818 2818 2905 3221* 3281 3296
                                                                                  3297 3299 3363* 3371 3372 3378 3380 3382 3383
is_read_only             15            based           bit(1)                   level 2 dcl 8-3 set ref 287 775 832 1007 1028 1374
                                                                                  1800 2105 2374 2918* 2921* 3611* 3614* 4506* 4542
                                                                                  4556 4567 4590 4603 4705* 4755
is_sequential_open       14            based           bit(1)                   level 2 dcl 8-3 set ref 341 723 1095* 1099* 1101*
                                                                                  2493 2740 3120 3209 4505* 4704*
key                       4     002047 automatic       char(22)                 level 2 in structure "temp_rk_inf" packed packed
                                                                                  unaligned dcl 4435 in procedure
                                                                                  "set_lock_list_entry" set ref 4267 4268 4269 4270
                                                                                  4283 4294
key                                    parameter       varying char(256)        dcl 1784 in procedure "compare_last_key" ref 1773
                                                                                  1776 1781
key                       3            based           char                     level 2 in structure "gk_inf" packed packed
                                                                                  unaligned dcl 4971 in procedure "open_indx_file"
                                                                                  set ref 610 635*
key                                    parameter       varying char(256)        dcl 4934 in procedure "open_indx_file" set ref 221
                                                                                  239 251 260 291 312 324* 326* 1056
key                                    parameter       varying char(256)        dcl 2419 in procedure "find_entry" set ref 2397 2400
                                                                                  2414
key                       3     001152 automatic       char(4)                  level 2 in structure "gk_inf" packed packed
                                                                                  unaligned dcl 1-87 in procedure
                                                                                  "set_current_image_info" set ref 1-49
key                       3            based           char(12)                 level 2 in structure "gk_inf" packed packed
                                                                                  unaligned dcl 4419 in procedure "init_uid_info"
                                                                                  set ref 4388 4389 4390
key_descrip               4            based           structure                array level 4 packed packed unaligned dcl 8-139
key_is_dup                      000232 automatic       bit(1)                   dcl 4899 set ref 247 1775* 1781* 2330 2405* 2414*
                                                                                  2795 2812* 2813 3423* 3427* 3437 3442
key_len                   2            based           fixed bin(17,0)          level 3 in structure "ak_inf" dcl 4965 in procedure
                                                                                  "open_indx_file" set ref 2778 2779 3420 3436 3534
                                                                                  3548
key_len                   2     000552 automatic       fixed bin(17,0)          level 2 in structure "temp_ak_inf" dcl 5081
                                                                                  in procedure "open_indx_file" set ref 3820*
key_len                   2            based           fixed bin(17,0)          level 3 in structure "gk_inf" dcl 4419 in procedure
                                                                                  "init_uid_info" set ref 4387*
key_len                   3            based           fixed bin(17,0)          level 3 in structure "rk_inf" dcl 4968 in procedure
                                                                                  "open_indx_file" set ref 4095 4114
key_len                   3     002047 automatic       fixed bin(17,0)          level 2 in structure "temp_rk_inf" dcl 4435
                                                                                  in procedure "set_lock_list_entry" set ref 4284*
                                                                                  4286 4286 4303* 4309 4321
key_len                   2     001152 automatic       fixed bin(17,0)          level 3 in structure "gk_inf" dcl 1-87 in procedure
                                                                                  "set_current_image_info" set ref 1-47*
key_len                   2            based           fixed bin(17,0)          level 3 in structure "gk_inf" dcl 4971 in procedure
                                                                                  "open_indx_file" set ref 539* 607 610 634* 635
key_len                   2            based           fixed bin(17,0)          level 2 in structure "temp_ak_inf" dcl 4441
                                                                                  in procedure "set_lock_list_entry" set ref 4275*
                                                                                  4334* 4343* 4370*
key_length                4(18)        based           fixed bin(17,0)          array level 5 packed packed unaligned dcl 8-139 ref
                                                                                  635 1580 1716 1756 1776 1781 2038 2414 2817 2818
                                                                                  2877 2886 3295 3295 3318 3318 3899 3945 4309 4359
key_pos                   4            based           fixed bin(17,0)          array level 5 packed packed unaligned dcl 8-139 ref
                                                                                  324 635 1056 1060 1580 1716 1762 1776 1781 2038
                                                                                  2414 2818 2878 2886 3295 3295 3318 3318 3749 3776
                                                                                  3899 3945 4309
key_ptr                                parameter       pointer                  dcl 1732 ref 1708 1711 1716
key_to_reassign                        based           varying char(256)        dcl 4975 set ref 4095 4114*
keys                                   based           char(4096)               packed unaligned dcl 8-153 ref 324 635 1056 1060
                                                                                  1580 1716 1762 1776 1781 2038 2414 2818 2886 3295
                                                                                  3295 3318 3318 3749 3776 3899 3945 4309
keys_match                      001636 automatic       bit(1)                   dcl 3338 set ref 3315* 3318* 3323* 3328
kptr                      7            based           pointer                  array level 4 in structure "hi_sl_info" packed
                                                                                  packed unaligned dcl 6-27 in procedure
                                                                                  "open_indx_file" ref 3853 3866 3883
kptr                     11            based           pointer                  array level 4 in structure "hi_sl_info" packed
                                                                                  packed unaligned dcl 6-27 in procedure
                                                                                  "open_indx_file" ref 3853 3873
last_branch_num                        based           fixed bin(17,0)          level 2 dcl 8-139 ref 236 381 575 1620 1656 1656
                                                                                  1672 1776 1776 1776 1781 1781 2025 2131 2144 3848
last_branch_num_root     12            based           fixed bin(17,0)          level 3 dcl 8-157 set ref 4801*
last_change_count        40            based           fixed bin(35,0)          level 2 dcl 8-3 set ref 129 198 688 694* 972 2068
                                                                                  2073* 2202 2211 2440* 3910 3952 4702*
last_comp_num                          based           fixed bin(17,0)          level 2 dcl 8-157 ref 2285 4596 4755
last_descrip              2            based           fixed bin(35,0)          level 2 dcl 5096 set ref 3900* 3920* 3935* 3940
last_head                10            based           structure                array level 3 in structure "hi_sl_info" unaligned
                                                                                  dcl 6-27 in procedure "open_indx_file"
last_head                       000451 automatic       varying char(256)        dcl 5077 in procedure "open_indx_file" set ref 3846*
                                                                                  3873* 3893 3894* 3895* 3902 3902 3905 3905
last_head_len                          based           fixed bin(17,0)          dcl 5078 set ref 3893*
last_image_modifier      14            based           fixed bin(35,0)          level 2 dcl 4-6 set ref 2007*
last_info                              based           structure                level 1 unaligned dcl 5096
last_info_block                 000566 automatic       structure                array level 1 unaligned dcl 5092 set ref 3836 3837
last_info_ptr                   000564 automatic       pointer                  dcl 5091 set ref 3836* 3837 3838 3838 3899 3900 3902
                                                                                  3902 3905 3905 3920 3920 3935 3940 3945 3946 3947*
                                                                                  3947
last_key                  3            based           varying char(256)        level 2 dcl 5096 set ref 3899* 3902 3902 3905 3905
                                                                                  3920*
last_subset              63            based           fixed bin(34,0)          level 2 dcl 8-3 set ref 3660 3686 3801 3803 4059*
                                                                                  4059 4734*
lbound                                                 builtin function         dcl 4883 ref 4754
leave_locked             53            based           bit(1)                   level 2 dcl 8-3 set ref 111 195 835 847* 849 865*
                                                                                  972 1092 1131 1935 2063 2185 2433 3910 3952 4590
                                                                                  4721*
len                             000102 automatic       fixed bin(17,0)          dcl 4885 in procedure "open_indx_file" set ref 323*
                                                                                  324 324 607* 608 608 610 610
len                             001260 automatic       fixed bin(17,0)          dcl 1769 in procedure "get_key_length" set ref 1756*
                                                                                  1757 1759 1762 1763 1765* 1765 1767
length                                                 builtin function         dcl 8-386 in procedure "open_indx_file" ref 100 100
                                                                                  100 141 141 141 862 862 862 1119 1165 1420 2680
                                                                                  2833 2973 2978 3108 3111 3894 3895 3895 3895 3902
                                                                                  3902 3905 3905 4782 4782 4782
length                    6            based           fixed bin(17,0)          array level 4 in structure "hi_sl_info" dcl 6-27
                                                                                  in procedure "open_indx_file" set ref 3862 3862
                                                                                  3866 3866 3869* 3883
length                   10            based           fixed bin(17,0)          array level 4 in structure "hi_sl_info" dcl 6-27
                                                                                  in procedure "open_indx_file" ref 3853 3873 3876
list_type                              based           fixed bin(3,0)           level 3 packed packed unaligned dcl 6-8 ref 3656
                                                                                  3686 3796 3821 3967
locate_sw                 1(03)        based           bit(1)                   level 3 packed packed unaligned dcl 4-6 ref 680 1833
                                                                                  1867 1868 1871 1879 1913
lock_copy                       000311 automatic       bit(36)                  dcl 4997 in procedure "open_indx_file" set ref 2092*
                                                                                  2093 2093 4614* 4625 4628
lock_copy                       001140 automatic       bit(36)                  dcl 1464 in procedure "get_lock_status" set ref
                                                                                  1454* 1455 1455
lock_file_retry                        constant        fixed bin(17,0)          initial dcl 4876 ref 840
lock_flag                 0(22)        based           bit(1)                   level 3 in structure "record_block" packed packed
                                                                                  unaligned dcl 1-96 in procedure
                                                                                  "lock_current_record" ref 1125 1147 1161 1210 1259
                                                                                  1-28
lock_flag                 0(22)        based           bit(1)                   level 3 in structure "record_block" packed packed
                                                                                  unaligned dcl 2646 in procedure "unlock_record"
                                                                                  set ref 2632*
lock_flag                 0(22)        based           bit(1)                   level 3 in structure "record_block" packed packed
                                                                                  unaligned dcl 4987 in procedure "open_indx_file"
                                                                                  set ref 1904* 1962* 2549* 2560* 2567* 2584*
lock_ptr                        000300 automatic       pointer                  dcl 4960 in procedure "open_indx_file" set ref 270*
                                                                                  307* 321* 339* 1889* 1896 1920* 1924* 1958 2454*
                                                                                  2476* 2577* 2578 2712* 2919* 2939* 2952 3466*
                                                                                  3612* 4150* 4469 4480
lock_ptr                               parameter       pointer                  dcl 1474 in procedure "lock_current_record" set ref
                                                                                  909 919* 927* 934 934 934 942 949* 1038* 1083*
                                                                                  1119* 1122* 1125 1143 1145* 1161* 1173* 1184*
                                                                                  1210* 1238 1240* 1249
lock_ptr_arg                           parameter       pointer                  dcl 2642 ref 2605 2609 2622 2622 2630 2640
lock_sw                   1            based           bit(1)                   level 3 packed packed unaligned dcl 4-6 ref 701 1799
                                                                                  1814 1892 1930
lock_word                 1            based           bit(36)                  level 3 dcl 8-157 set ref 853 1125 1125 2092 2189
                                                                                  2192 2192 2441 2448 4466 4533* 4593 4593 4625 4628
                                                                                  4765
lockp                                  parameter       pointer                  dcl 1462 in procedure "get_lock_status" ref 1452
                                                                                  1454
lockp                                  parameter       pointer                  dcl 2169 in procedure "set_lock" ref 2160 2162 2164
                                                                                  2166
max                                                    builtin function         dcl 8-394 ref 811 812 1805 1822 1823 1824 1858 1863
                                                                                  2507 2674 2680 2700 4059
max_comp_num                           based           fixed bin(17,0)          level 2 dcl 8-157 set ref 2426* 4805*
max_list_type                          constant        fixed bin(17,0)          initial dcl 5089 ref 3796
max_rec_len               3            based           fixed bin(21,0)          level 2 dcl 4-6 set ref 1805 1823 1824 1860 1863
                                                                                  1991* 2012*
max_rec_wds                     000432 automatic       fixed bin(19,0)          dcl 5060 set ref 952* 1118* 1411* 1417* 2012
max_record_size           6            based           fixed bin(21,0)          level 2 dcl 8-3 ref 1805 2726
max_ref_count                          constant        fixed bin(17,0)          initial dcl 5067 ref 1367
max_seg_limit            11            based           fixed bin(19,0)          level 2 dcl 8-157 set ref 4798*
mbs_info                               based           structure                level 1 unaligned dcl 5042
message                                parameter       char                     packed unaligned dcl 4835 set ref 4822 4827*
mics_left                       001074 automatic       fixed bin(71,0)          dcl 1427 in procedure "inspect_stat_record" set ref
                                                                                  1192* 1193 1195 1195
mics_left                       001354 automatic       fixed bin(71,0)          dcl 2111 in procedure "check_file_lock" set ref
                                                                                  2096* 2097 2101 2101
min                                                    builtin function         dcl 8-395 ref 388 463 607 1060 1195 1195 1580 1716
                                                                                  2101 2101 3902 3905
min_cap                 101            based           fixed bin(21,0)          level 2 dcl 8-3 set ref 812* 1824 2280 2512 2538
                                                                                  2704 4720*
min_capacity              1            based           fixed bin(21,0)          level 2 dcl 5042 ref 812
min_key_len              60            based           fixed bin(17,0)          level 2 dcl 8-3 set ref 1757 1759 2680 4731*
min_max_rec_len                        constant        fixed bin(21,0)          initial dcl 5107 ref 1823 1863
min_ref_count                   001073 automatic       fixed bin(17,0)          dcl 1426 set ref 1357* 1359* 1360
min_res                 100            based           fixed bin(21,0)          level 2 dcl 8-3 set ref 811* 1824 2279 2481 2512
                                                                                  2538 2704 4719*
min_residue                            based           fixed bin(21,0)          level 2 dcl 5042 ref 811
minimum_block_size       10            based           fixed bin(19,0)          level 2 dcl 8-157 set ref 4799*
minimum_block_size_val                 constant        fixed bin(17,0)          initial dcl 4985 ref 4799
minimum_key_length        7            based           fixed bin(17,0)          level 2 dcl 8-157 ref 4731
mod                             000322 automatic       fixed bin(35,0)          dcl 5009 set ref 1077 1077 1210 1219 1259 1275 1288
                                                                                  1310 1388* 1389 1391 1395 1-21* 1-22 1-27* 1-28
                                                                                  1-28 1-49 1-55 2005
mode                     13            based           fixed bin(17,0)          level 2 dcl 8-3 set ref 723 1099 3389 3646 3646
                                                                                  4504* 4505 4506 4507 4636 4703* 4704 4705 4706
mode_arg                               parameter       fixed bin(17,0)          dcl 4935 ref 73 4703
modifier                  3            based           fixed bin(35,0)          level 2 in structure "stat_struct" dcl 1-93
                                                                                  in procedure "lock_current_record" set ref 1296
                                                                                  1301* 1331* 1350* 1374 1388 1-21 1-27
modifier                  3            based           fixed bin(35,0)          level 2 in structure "stat_struct" dcl 4988
                                                                                  in procedure "open_indx_file" set ref 2456* 2462*
                                                                                  2674 2950 2956 3006* 3084* 3619 4469 4469 4484
                                                                                  4484
modifier                 12            based           fixed bin(35,0)          level 2 in structure "rs_info" dcl 4-6 in procedure
                                                                                  "open_indx_file" set ref 2005*
modifier                  3            based           fixed bin(35,0)          level 2 in structure "stat_struct" dcl 2647
                                                                                  in procedure "unlock_record" set ref 2614 2614
                                                                                  2627 2638*
modifier_arg                           parameter       fixed bin(35,0)          dcl 5007 ref 2930 2954 2956
must_verify                     002045 automatic       bit(1)                   dcl 4433 set ref 4246* 4251* 4256* 4271
n                         1            based           fixed bin(17,0)          level 2 dcl 5037 set ref 727 742 742 744 744 745*
                                                                                  757
n_int                           000562 automatic       fixed bin(17,0)          dcl 5090 set ref 3832* 3834* 3840
name                    106            based           char(32)                 level 2 packed packed unaligned dcl 156 ref 144
negmod_mask                            constant        bit(36)                  initial dcl 4845 ref 1299 1348
new_block_ptr                   000436 automatic       pointer                  dcl 5063 set ref 2458* 2462 2462 4168* 4184* 4200
                                                                                  4200 4204 4205 4228 4228 4484 4484 4484 4484
new_branch               16            based           fixed bin(35,0)          level 4 dcl 8-298 set ref 2805*
new_branch_num                  001637 automatic       fixed bin(35,0)          dcl 3339 set ref 3314* 3324 3333*
new_change_count                000264 automatic       fixed bin(35,0)          dcl 4911 set ref 686* 688 694 2068 2073 2087* 2089
new_des                         000444 automatic       fixed bin(35,0)          dcl 5072 set ref 4087* 4089* 4165 4235
new_desc_val            475            based           fixed bin(35,0)          level 2 dcl 8-157 set ref 2761* 3204 3214 3282* 3290
new_descrip               2            based           fixed bin(35,0)          level 3 in structure "rk_inf" dcl 4968 in procedure
                                                                                  "open_indx_file" ref 4087
new_descrip               2     002076 automatic       fixed bin(35,0)          level 3 in structure "rk_inf" dcl 4416 in procedure
                                                                                  "init_uid_info" set ref 4399
new_descrip               2     002047 automatic       fixed bin(35,0)          level 2 in structure "temp_rk_inf" dcl 4435
                                                                                  in procedure "set_lock_list_entry" set ref 4296*
                                                                                  4299* 4305* 4307*
new_descriptor           46            based           fixed bin(35,0)          level 2 dcl 8-157 set ref 1879* 1883 2515* 2516 2517
                                                                                  2549 2566* 2593* 2596 2601 2711 2716* 2745 2783*
                                                                                  2905 3019* 3027* 3044* 3067* 3148* 4207 4235*
new_ind_des                            based           structure                level 1 packed packed unaligned dcl 1-82
new_ind_desc                    001151 automatic       fixed bin(35,0)          dcl 1-85 set ref 1-32 1-33 1-56
new_key                 120            based           varying char(256)        level 3 in structure "indx_cb" dcl 8-3 in procedure
                                                                                  "open_indx_file" set ref 100 100 239* 240* 291*
                                                                                  598 740 862 862 1060 2038* 2325* 2352 2382* 2832*
                                                                                  2833 3534 3602* 4095 4128* 4729*
new_key                                parameter       varying char(256)        dcl 2683 in procedure "prepare_key" ref 2678 2680
                                                                                  2681
new_key_len                     001550 automatic       fixed bin(17,0)          dcl 2837 set ref 2779* 2794 2799 2816* 2833*
new_key_length           14(18)        based           fixed bin(17,0)          level 4 packed packed unaligned dcl 8-298 set ref
                                                                                  2680* 2681 2817* 2818
new_key_pos              14            based           fixed bin(17,0)          level 4 packed packed unaligned dcl 8-298 set ref
                                                                                  4803*
new_key_string           17            based           char(256)                level 3 packed packed unaligned dcl 8-298 set ref
                                                                                  2681* 2818*
new_last_descrip          2            based           fixed bin(35,0)          level 2 dcl 5100 set ref 3946*
new_last_info                          based           structure                level 1 unaligned dcl 5100
new_last_info_ptr                      based           pointer                  level 2 in structure "last_info" dcl 5096
                                                                                  in procedure "open_indx_file" set ref 3837* 3838
                                                                                  3945 3946 3947
new_last_info_ptr                      based           pointer                  level 2 in structure "new_last_info" dcl 5100
                                                                                  in procedure "open_indx_file" set ref 3838*
new_last_key              3            based           varying char(256)        level 2 dcl 5100 set ref 3945*
new_lock_ptr                    000440 automatic       pointer                  dcl 5064 set ref 2458* 4168* 4484 4496
new_passive_ref           0(04)        based           bit(1)                   level 2 packed packed unaligned dcl 5011 ref 4490
new_passive_ref_mask            000344 constant        bit(36)                  initial dcl 4851 set ref 2458*
new_rec_des                            based           structure                level 1 packed packed unaligned dcl 4957
new_record_descrip       15            based           structure                level 4 unaligned dcl 8-298
new_record_designator
                         15            based           fixed bin(35,0)          level 5 dcl 8-298 set ref 2782* 2783 2905* 3296*
new_record_length        30            based           fixed bin(21,0)          level 2 dcl 8-157 set ref 1858* 2057 2507* 2512 2538
                                                                                  2574 2700* 2704 2998 3106* 3108* 3111*
new_ref_count           106            based           fixed bin(34,0)          level 2 dcl 8-157 set ref 2772* 3491 3492 4204 4205
                                                                                  4233*
new_wait_time                          based           float bin(27)            dcl 5055 ref 822 826 828
next_record_position    107            based           fixed bin(17,0)          level 4 dcl 8-3 set ref 279* 286* 341* 343* 355 377
                                                                                  428* 432 483* 575 579 643* 655* 756* 768* 1035*
                                                                                  1040* 1042 1046* 1106* 1589* 1617 1623 1627* 2021
                                                                                  2120* 2130* 2263 2364* 2369 2376* 2493* 2495*
                                                                                  2740* 2744* 3125* 3127* 3153 3153* 3168 3168*
                                                                                  3209* 3534 4095 4707*
next_subset                     000447 automatic       fixed bin(34,0)          dcl 5075 set ref 3801* 3803* 3805* 3939 3976 3995
                                                                                  4059
next_substate            51            based           fixed bin(17,0)          level 2 dcl 8-3 set ref 2226* 3351* 3351 3353 4817*
                                                                                  4817 4818
node                      6            based           fixed bin(35,0)          level 2 dcl 8-132 set ref 2141* 2152* 2501 2803 3281
                                                                                  3371 3378 3382 4237
node_block                             based           structure                level 1 unaligned dcl 8-139
node_head_length                       constant        fixed bin(17,0)          initial dcl 4915 ref 4803
node_ptr                  4            based           pointer                  level 2 dcl 8-132 set ref 236 269 324 324 381 383
                                                                                  399 452 459 575 635 635 635 636 1047 1056 1056
                                                                                  1060 1060 1537 1580 1580 1580 1620 1645 1656 1656
                                                                                  1672 1705 1716 1716 1716 1756 1762 1762 1776 1776
                                                                                  1776 1776 1776 1776 1781 1781 1781 1781 1781 2025
                                                                                  2038 2038 2038 2039 2131 2140 2141 2142* 2142 2144
                                                                                  2151 2152 2153* 2153 2260 2408 2414 2414 2414 2596
                                                                                  2817 2818 2818 2818 2823 2877 2878 2878 2886 2886
                                                                                  2886 3282 3295 3295 3295 3295 3295 3295 3296 3318
                                                                                  3318 3318 3318 3318 3318 3749 3749 3776 3776 3848
                                                                                  3899 3899 3899 3900 3945 3945 3945 3946 4104 4207
                                                                                  4309 4309 4309 4309 4359 4359
node_size                 6            based           fixed bin(19,0)          level 2 dcl 8-157 set ref 4800* 4806 4806 4806
node_size_val                          constant        fixed bin(17,0)          initial dcl 4984 ref 4800
non_stat_struct                        based           structure                level 1 unaligned dcl 1468
null                                                   builtin function         dcl 8-387 ref 127 127 717 919 948 949 950 955 980
                                                                                  1007 1025 1037 1038 1098 1098 1122 1125 1738 1740
                                                                                  1876 1896 1958 1987 1990 1995 2456 2462 2531 2531
                                                                                  2590 2607 2609 2622 2766 2922 3021 3021 3030 3030
                                                                                  3057 3057 3068 3068 3073 3073 3080 3080 3149 3149
                                                                                  3158 3158 3177 3269 3480 3505 3615 3639 3721 3725
                                                                                  3806 4014 4014 4183 4184 4193 4200 4219 4228 4257
                                                                                  4469 4469 4484 4484 4547 4547 4560 4560 4730 4736
                                                                                  4740 4742 4755 4755 4767 4767 4779 4790 4827 4827
num_conds                              constant        fixed bin(17,0)          initial dcl 161 ref 149
number_of_allocated_records
                         10            based           fixed bin(34,0)          level 2 dcl 8-280 set ref 2524* 2524 3058* 3058
                                                                                  3083* 3083 3708 3739
number_of_keys            2            based           fixed bin(34,0)          level 2 dcl 8-280 set ref 2793* 2793 3278* 3278
number_of_records         6            based           fixed bin(34,0)          level 2 dcl 8-280 set ref 2056* 2056 2992* 2992
                                                                                  2994* 2994 2996* 2996 3263* 3263
o_s_ptr                  46            based           pointer                  level 2 dcl 8-3 set ref 2222 2310* 2432* 3007 4581*
                                                                                  4582 4715*
offset                    0(18)        based           bit(18)                  level 2 in structure "new_ind_des" packed packed
                                                                                  unaligned dcl 1-82 in procedure
                                                                                  "set_current_image_info" set ref 1-33*
offset                    0(18)        based           bit(18)                  level 2 in structure "ind_des" packed packed
                                                                                  unaligned dcl 4991 in procedure "open_indx_file"
                                                                                  set ref 1953* 2990* 3042*
offset                    0(18)        based           bit(18)                  level 2 in structure "des_arg" packed packed
                                                                                  unaligned dcl 906 in procedure "get_ptr" ref 904
offset                    0(18)        based           bit(18)                  level 2 in structure "new_rec_des" packed packed
                                                                                  unaligned dcl 4957 in procedure "open_indx_file"
                                                                                  ref 2517
offset                    0(18)        based           bit(18)                  level 2 in structure "ind_des" packed packed
                                                                                  unaligned dcl 1-92 in procedure
                                                                                  "lock_current_record" set ref 1397* 1-20*
old_des                         000445 automatic       fixed bin(35,0)          dcl 5073 set ref 4084* 4086* 4095 4114* 4121 4128*
                                                                                  4144 4236
old_descrip               1            based           fixed bin(35,0)          level 3 in structure "rk_inf" dcl 4968 in procedure
                                                                                  "open_indx_file" ref 4084
old_descrip               1     002076 automatic       fixed bin(35,0)          level 3 in structure "rk_inf" dcl 4416 in procedure
                                                                                  "init_uid_info" set ref 4384 4385 4386 4387 4388
                                                                                  4389 4390 4392 4392 4393 4399* 4400 4407 4408 4409
                                                                                  4409
old_descrip               1     002047 automatic       fixed bin(35,0)          level 2 in structure "temp_rk_inf" dcl 4435
                                                                                  in procedure "set_lock_list_entry" set ref 4274
                                                                                  4275 4276 4277 4277 4295* 4304* 4309 4334 4335
                                                                                  4336 4336 4343 4345 4346 4346 4369 4370 4372 4372
old_file_ch_count       110            based           fixed bin(35,0)          level 2 dcl 8-157 set ref 1878 2230* 2518 2536 2717
                                                                                  3001 3048 3141 3196 3487 4192
old_ind_desc            103            based           fixed bin(35,0)          level 2 dcl 8-157 set ref 2522 2673* 2945 2945* 3016
                                                                                  3019 3044 3073 3080 3149
old_index_height         36            based           fixed bin(17,0)          level 2 dcl 8-3 ref 2301
old_last_comp_num        37            based           fixed bin(17,0)          level 2 dcl 8-3 ref 1740 2285 4596
old_modifier            112            based           fixed bin(35,0)          level 2 dcl 8-157 set ref 2674* 3014 3036 3145 3225
                                                                                  3245
old_passive_ref           0(03)        based           bit(1)                   level 2 packed packed unaligned dcl 5011 ref 4474
old_passive_ref_mask                   constant        bit(36)                  initial dcl 4849 set ref 2454*
old_prev_mod            473            based           fixed bin(35,0)          level 2 dcl 8-157 set ref 2672* 2992 3024 3050
old_record_designator
                         31            based           fixed bin(35,0)          level 2 dcl 8-157 set ref 2497* 2541 2549 2590 2665
                                                                                  2937* 3177 3190* 3233* 4236*
old_record_length        22            based           fixed bin(21,0)          level 2 dcl 8-157 set ref 2530 2537 2658* 2998
old_ref_cnt                     000443 automatic       fixed bin(17,0)          dcl 5071 set ref 4163* 4225
old_ref_count           105            based           fixed bin(34,0)          level 2 dcl 8-157 set ref 1871* 2702* 2983* 3053
                                                                                  3200 3201 3225 3244* 3275* 4197 4198 4225*
old_rover_comp_num       42            based           fixed bin(17,0)          level 2 dcl 8-3 set ref 2293 2297*
open_data_ptr            22            based           pointer                  level 2 dcl 10-6 set ref 79 83 87 129 129 182 214
                                                                                  353 666 1077 1217 1219 1275 1308 1310 1331 1391
                                                                                  1480 2614 3745 3760 3771 3782 4257 4264 4267 4285
                                                                                  4314 4357 4367 4391 4460 4469 4484 4577 4697* 4698
                                                                                  4828
open_ended                      000561 automatic       bit(1)                   dcl 5088 set ref 3876* 3878* 3882* 3905
opening_mode            121            based           fixed bin(17,0)          level 2 dcl 2-5 ref 4504 4533 4616
order                                  parameter       char                     packed unaligned dcl 5021 ref 509 514 669 723 778
                                                                                  781 784 788 791 794 808 819 832 878 885 892
os_ptr                          000224 automatic       pointer                  dcl 4894 set ref 2056 2057 2222* 2232 2233 2235 2431
                                                                                  2524 2530 2537 2793 2794 2798 2799 2992 2994 2996
                                                                                  2996 2998 3058 3083 3263 3265 3278 3279 3287 3288
                                                                                  4582*
out_of_index             76            based           bit(1)                   level 2 dcl 8-157 set ref 1867* 2505* 3056* 3118*
                                                                                  3225
outer_retry                            constant        fixed bin(17,0)          initial dcl 4872 ref 3841 3957 4510
output_descriptors        0(05)        based           bit(1)                   level 3 packed packed unaligned dcl 6-8 ref 3672
                                                                                  3679 3704 3718
outside_index             6     000103 automatic       bit(1)                   level 3 in structure "saved_state" dcl 4886
                                                                                  in procedure "open_indx_file" set ref 1937* 1942
                                                                                  3172 3622* 4148* 4152 4169
outside_index           114            based           bit(1)                   level 4 in structure "indx_cb" dcl 8-3 in procedure
                                                                                  "open_indx_file" set ref 235* 258* 363* 499* 533
                                                                                  641* 654* 680 715 739* 972 1011 1033* 1614* 1695*
                                                                                  1937 1938* 1942* 2033 2047* 2246 2369 2481 2498
                                                                                  2505 2596 3118 3152* 3159 3162* 3172* 3179 3182*
                                                                                  3190 3247 3259 3266 3508 3534 3568 3622 3623* 4070
                                                                                  4095 4148 4149* 4152* 4166* 4169* 4722*
p                               000316 automatic       pointer                  dcl 5006 in procedure "open_indx_file" set ref 2945*
                                                                                  3100*
p                               001250 automatic       pointer                  dcl 1747 in procedure "get_pointer" set ref 1740*
p                               001112 automatic       pointer                  dcl 1422 in procedure "set_stat_reclp" set ref 1416*
                                                                                  1417 1418
p                               001674 automatic       pointer                  dcl 3386 in procedure "save_position_info" set ref
                                                                                  3379* 3381* 3381 3382 3383
pad_key                   1            based           char(256)                level 2 packed packed unaligned dcl 5033 set ref
                                                                                  608* 610* 742* 744* 1580 3862* 3866*
pad_key_info                           based           structure                level 1 unaligned dcl 5033 set ref 612 612 745 745
                                                                                  3869 3869 3883 3888 3894 3894 3895 3895 3895
pad_key_len                            based           fixed bin(17,0)          level 2 dcl 5033 set ref 606* 741* 3861*
pad_key_ptr                     000430 automatic       pointer                  dcl 5036 set ref 598* 605* 606 608 610 612 612 740*
                                                                                  741 742 744 745 745 1580 3835* 3861 3862 3866 3869
                                                                                  3869 3883 3888 3894 3894 3895 3895 3895
parent_position_ptr                    based           pointer                  level 2 dcl 8-132 ref 1661 1677
passive                         002044 automatic       bit(1)                   dcl 4432 in procedure "set_lock_list_entry" set ref
                                                                                  4245* 4250* 4255* 4287 4287 4296 4305 4316 4370
passive                         001033 automatic       bit(1)                   dcl 1472 in procedure "lock_current_record" set ref
                                                                                  931* 939* 944* 966 1011 1125 1131 1174
passive                         000442 automatic       bit(1)                   dcl 5066 in procedure "open_indx_file" set ref 81*
                                                                                  85* 89* 113
passive_op                      000233 automatic       bit(1)                   dcl 4900 set ref 676 711 1799* 1800 1920
passive_ref_bit_mask                   constant        bit(36)                  initial dcl 4847 ref 1313 1319
passive_ref_mask                       parameter       bit(36)                  dcl 2645 in procedure "unlock_record" ref 2605 2619
passive_ref_mask                       parameter       bit(36)                  dcl 4455 in procedure "set_lock_list_entry" ref 4242
                                                                                  4248 4319
pd_path_len                     001736 automatic       fixed bin(17,0)          level 2 dcl 4019 set ref 4013* 4014
pos_array               120            based           structure                array level 2 unaligned dcl 8-298
pos_bof_or_eof_retry                   constant        fixed bin(17,0)          initial dcl 4859 ref 493
pos_incorrect            56            based           bit(1)                   level 2 dcl 8-3 set ref 225 230* 263* 364 500* 567
                                                                                  611* 648* 661* 693* 770* 1605 1687 2021 2034*
                                                                                  2072* 2211* 2249 2394* 2826* 2859 3415* 3540 3547*
                                                                                  3565* 3595 3601* 3831* 4100 4136* 4461* 4726*
                                                                                  4829*
pos_ptr                         000274 automatic       pointer                  dcl 4947 set ref 102* 234* 236 236 262* 269 269 324
                                                                                  324 324 371* 381 381 383 383 390 390 399 399 404
                                                                                  404 410 440 448 448 452 452 459 459 459 463 465
                                                                                  465 574* 575 575 579 579 587 613 635 635 635 635
                                                                                  635 636 636 746 867* 1047 1047 1056 1056 1056 1060
                                                                                  1060 1060 1104* 1537 1537 1557 1567 1567 1571 1571
                                                                                  1573 1580 1580 1580 1580 1580 1612* 1620 1620 1626
                                                                                  1626 1637 1645 1645 1656 1656 1656 1661* 1661 1665
                                                                                  1672 1672 1677* 1677 1681 1694* 1697 1704 1704
                                                                                  1705 1705 1712* 1715 1716 1716 1716 1716 1716 1723
                                                                                  1723 1728* 1756 1756 1762 1762 1762 1776 1776 1776
                                                                                  1776 1776 1776 1781 1781 1781 1781 1781 1886*
                                                                                  2024* 2025 2025 2029 2038 2038 2038 2038 2038 2039
                                                                                  2039 2116* 2128* 2131 2140 2140 2141 2141 2141
                                                                                  2142 2142 2142 2143* 2143 2144 2144 2146 2151 2151
                                                                                  2152 2152 2152 2153 2153 2153 2154* 2154 2155 2157
                                                                                  2182* 2244* 2260 2260 2306* 2353* 2391 2391 2401*
                                                                                  2408 2408 2410 2410 2412 2414 2414 2414 2414 2414
                                                                                  2501 2502 2596 2596 2720* 2802 2803 2817 2817 2818
                                                                                  2818 2818 2818 2818 2823 2823 2868* 2877 2877 2878
                                                                                  2878 2878 2882 2882 2884 2886 2886 2886 2886 2886
                                                                                  3213* 3280 3281 3282 3282 3294 3294 3295 3295 3295
                                                                                  3295 3295 3295 3295 3295 3295 3295 3296 3296 3307
                                                                                  3312 3312 3314 3315 3318 3318 3318 3318 3318 3324
                                                                                  3325* 3326 3327 3333 3334 3334 3357* 3370 3371
                                                                                  3378 3422* 3434* 3495* 3748 3749 3749 3749 3754
                                                                                  3754 3757* 3761* 3774 3776 3776 3776 3778 3778
                                                                                  3783* 3848 3870 3889* 3899 3899 3899 3899 3899
                                                                                  3900 3900 3942 3942 3945 3945 3945 3945 3945 3946
                                                                                  3946 3948 4104 4104 4109* 4207 4207 4215* 4237
                                                                                  4238 4309 4309 4309 4309 4309 4309 4309 4309 4315*
                                                                                  4358* 4359 4359 4359 4359 4368*
pos_type                               parameter       fixed bin(17,0)          dcl 4936 ref 347 349 490 495
pos_unchanged                   000446 automatic       bit(1)                   dcl 5074 set ref 4069* 4110* 4124* 4134* 4136
position                 62            based           entry variable           level 2 dcl 10-6 set ref 4641* 4647* 4656* 4669*
position_frame                         based           structure                level 1 unaligned dcl 8-132
position_specification
                          0(05) 001152 automatic       structure                level 4 in structure "gk_inf" packed packed
                                                                                  unaligned dcl 1-87 in procedure
                                                                                  "set_current_image_info"
position_specification
                          0(05)        based           structure                level 4 in structure "gk_inf" packed packed
                                                                                  unaligned dcl 4419 in procedure "init_uid_info"
position_specification
                          0(05)        based           structure                level 4 in structure "gk_inf" packed packed
                                                                                  unaligned dcl 4971 in procedure "open_indx_file"
prev_desc                 7            based           fixed bin(35,0)          level 2 in structure "ind_struct" dcl 4989
                                                                                  in procedure "open_indx_file" set ref 2970 2971
                                                                                  3015* 3075*
prev_desc                 7            based           fixed bin(35,0)          level 2 in structure "ind_struct" dcl 1-94
                                                                                  in procedure "lock_current_record" ref 1206 1338
                                                                                  1-15
prev_mod                  6            based           fixed bin(35,0)          level 2 in structure "stat_struct" dcl 1-93
                                                                                  in procedure "lock_current_record" ref 1313 1-11
                                                                                  1-34 1-66
prev_mod                  6            based           fixed bin(35,0)          level 2 in structure "ind_struct" dcl 4989
                                                                                  in procedure "open_indx_file" set ref 3014*
prev_mod                  6            based           fixed bin(35,0)          level 2 in structure "stat_struct" dcl 4988
                                                                                  in procedure "open_indx_file" set ref 2672 2954
                                                                                  2960 3036* 3077* 3108 4287
prior_block_size         21            based           fixed bin(19,0)          level 2 dcl 8-157 set ref 2669*
proc_dir_path                          based           varying char(168)        dcl 4022 ref 4014
proc_dir_string           1     001736 automatic       char(168)                level 2 packed packed unaligned dcl 4019 set ref
                                                                                  4011* 4013
proc_dirp_overlay               001736 automatic       structure                level 1 unaligned dcl 4019
proc_id                   1            based           bit(36)                  level 2 dcl 4426 set ref 4389*
program_version           5            based           fixed bin(17,0)          level 2 dcl 8-157 set ref 4542 4556 4797*
read_exclu               55            based           bit(1)                   level 2 dcl 8-3 set ref 846* 871* 2233 4569 4725*
read_exclude                    025576 constant        fixed bin(17,0)          initial dcl 9-10 ref 842 869 2204 2233 4542 4569
                                                                                  4619
read_key                116            based           entry variable           level 2 dcl 10-6 set ref 4655* 4668*
read_key_retry                         constant        fixed bin(17,0)          initial dcl 4856 ref 314
read_len_retry                         constant        fixed bin(17,0)          initial dcl 4855 ref 300
read_length             122            based           entry variable           level 2 dcl 10-6 set ref 4640* 4646* 4654* 4667*
                                                                                  4678* 4687*
read_record              72            based           entry variable           level 2 dcl 10-6 set ref 4639* 4645* 4653* 4666*
                                                                                  4676* 4685*
read_retry                             constant        fixed bin(17,0)          initial dcl 4857 ref 332 1166 1223
ready_to_write          111            based           bit(1)                   level 4 dcl 8-3 set ref 245* 247* 280* 290* 378*
                                                                                  485* 640* 654* 752* 754* 766* 1613* 1633* 2045*
                                                                                  2121* 2134* 2320 2330* 2335* 2358 2362* 2374*
                                                                                  2738* 2845 3136* 4709*
reass_key_retry_2                      constant        fixed bin(17,0)          initial dcl 4874 ref 4164
reassigning_key                 025577 constant        fixed bin(17,0)          initial dcl 9-9 ref 924 4191
rec_deleted                     000101 automatic       bit(1)                   dcl 4882 set ref 400 453 561 959* 960 986 1202*
                                                                                  1292* 1295* 1357 1374 1484* 1487* 1488* 1490* 1516
                                                                                  1545 3263 3936 3972* 3973
rec_id                    2            based           fixed bin(35,0)          level 2 dcl 4447 set ref 4269*
rec_len                                parameter       fixed bin(21,0)          dcl 4938 set ref 221 251 277* 284* 298 308* 312 322*
                                                                                  330 340*
rec_lock_mask                          constant        bit(36)                  initial dcl 4843 ref 920 1143 1155 1238 1265
received                  3            based           fixed bin(35,0)          level 2 in structure "error_info" dcl 5046
                                                                                  in procedure "open_indx_file" set ref 803*
received                105            based           fixed bin(34,0)          level 3 in structure "indx_cb" dcl 8-3 in procedure
                                                                                  "open_indx_file" set ref 425* 478* 803
recl                            001276 automatic       fixed bin(21,0)          dcl 1849 set ref 1822* 1823 1824 1826
record                    7            based           varying char(1000000)    level 2 in structure "stat_struct" dcl 1-93
                                                                                  in procedure "lock_current_record" set ref 1412
record                    1            based           varying char(1000000)    level 3 in structure "record_block" dcl 1-96
                                                                                  in procedure "lock_current_record" set ref 1119
                                                                                  1164 1418
record                    7            based           varying char(1000000)    level 2 in structure "stat_struct" dcl 4988
                                                                                  in procedure "open_indx_file" ref 2978 3108
record                    1            based           varying char(1000000)    level 3 in structure "record_block" dcl 4987
                                                                                  in procedure "open_indx_file" ref 2973 3111
record_action                   000265 automatic       fixed bin(17,0)          dcl 4943 set ref 2541* 2545* 2548*
record_block                           based           structure                level 1 unaligned dcl 4987 in procedure
                                                                                  "open_indx_file"
record_block                           based           structure                level 1 unaligned dcl 2646 in procedure
                                                                                  "unlock_record"
record_block                           based           structure                level 1 unaligned dcl 1-96 in procedure
                                                                                  "lock_current_record"
record_block_structure                 based           structure                level 1 unaligned dcl 8-115
record_descrip            5            based           structure                array level 4 unaligned dcl 8-139 set ref 2596*
                                                                                  4207*
record_designator         5            based           fixed bin(35,0)          array level 5 dcl 8-139 set ref 269 399* 452* 636
                                                                                  1047 1537 1645 1705 2039 2260 2408 2823 3296 3900
                                                                                  3946 4104 4309 4359
record_len                      000266 automatic       fixed bin(21,0)          dcl 4944 set ref 277 308 322 340 951* 1165* 1420*
                                                                                  1432 1432 1432 1432 1437 1940* 1985 2658 2964*
                                                                                  2971* 2973* 2978* 3265
record_length             2            based           fixed bin(21,0)          level 2 dcl 4-6 set ref 1805 1822 1858 1985*
record_lock               2            based           bit(36)                  level 2 in structure "stat_struct" dcl 4988
                                                                                  in procedure "open_indx_file" set ref 2939 4359
record_lock                            based           bit(36)                  level 2 in structure "non_stat_struct" dcl 1468
                                                                                  in procedure "lock_current_record" set ref 1119
record_lock               2            based           bit(36)                  level 2 in structure "stat_struct" dcl 1-93
                                                                                  in procedure "lock_current_record" set ref 927
                                                                                  1173
record_lock                            based           bit(36)                  level 2 in structure "block_with_lock" dcl 4950
                                                                                  in procedure "open_indx_file" set ref 2577
record_ptr                4            based           pointer                  level 2 in structure "rs_info" dcl 4-6 in procedure
                                                                                  "open_indx_file" set ref 1990* 1993*
record_ptr                      000270 automatic       pointer                  dcl 4945 in procedure "open_indx_file" set ref 950*
                                                                                  1164* 1165 1412* 1418* 1420 1432 1437 1940 1940
                                                                                  1954* 1987 1993
ref_cnt                         000433 automatic       fixed bin(17,0)          dcl 5061 set ref 953* 1011 1087 1096 1328 1360 1367
                                                                                  1373* 1373 1379 1380 1398* 3619 3624* 3624 4163
                                                                                  1-12* 1-23* 1-57* 1975 1977 2001 2772 3244 3247
                                                                                  3255 3259 3275 4233
ref_count                 7            based           fixed bin(34,0)          level 2 in structure "rs_info" dcl 4-6 in procedure
                                                                                  "open_indx_file" set ref 2001*
ref_count                 1(20)        based           fixed bin(16,0)          level 2 in structure "stat_struct" packed packed
                                                                                  unsigned unaligned dcl 1-93 in procedure
                                                                                  "lock_current_record" set ref 1380* 1-12
ref_count                 1(20)        based           fixed bin(16,0)          level 2 in structure "stat_struct" packed packed
                                                                                  unsigned unaligned dcl 4988 in procedure
                                                                                  "open_indx_file" set ref 1977* 2983 3002* 3201*
                                                                                  3492* 4198* 4205*
ref_count_after           0(26)        based           fixed bin(16,0)          level 2 in structure "stat_struct" packed packed
                                                                                  unsigned unaligned dcl 4988 in procedure
                                                                                  "open_indx_file" set ref 1975* 3002 3200* 3491*
                                                                                  4197* 4204*
ref_count_after           0(26)        based           fixed bin(16,0)          level 2 in structure "stat_struct" packed packed
                                                                                  unsigned unaligned dcl 1-93 in procedure
                                                                                  "lock_current_record" set ref 1328* 1379* 1398
                                                                                  1-23 1-57
ref_count_change                       parameter       fixed bin(17,0)          dcl 1473 ref 909 1353 1360 1367 1373 1374
reflp                    74            based           pointer                  level 2 dcl 8-3 set ref 4257 4264 4391 4612* 4742*
refp                            002062 automatic       pointer                  dcl 4446 in procedure "set_lock_list_entry" set ref
                                                                                  4264* 4277* 4285 4325* 4336* 4346* 4372*
refp                            002072 automatic       pointer                  dcl 4413 in procedure "init_uid_info" set ref 4391*
                                                                                  4392* 4401* 4409*
rel_type                               parameter       fixed bin(17,0)          dcl 1731 in procedure "seek_head" ref 1708 1716 1726
rel_type                               based           fixed bin(17,0)          level 2 in structure "info" dcl 5037 in procedure
                                                                                  "open_indx_file" set ref 727 727 745* 757
rel_type                  0(06)        based           fixed bin(2,0)           level 5 in structure "gk_inf" packed packed
                                                                                  unaligned dcl 4971 in procedure "open_indx_file"
                                                                                  ref 612 622
repeating                50            based           bit(1)                   level 2 dcl 8-3 set ref 913 1868 2223 2223* 2652
                                                                                  2755 2899 2941 3097 3222 3348 3364 3449 4212 4712*
                                                                                  4818*
replace_action                  000411 constant        fixed bin(17,0)          initial dcl 9-16 set ref 2508 2522* 2531* 2541 3030*
                                                                                  3068* 3149* 3297
requested                 2            based           fixed bin(35,0)          level 2 in structure "error_info" dcl 5046
                                                                                  in procedure "open_indx_file" set ref 802*
requested               104            based           fixed bin(34,0)          level 3 in structure "indx_cb" dcl 8-3 in procedure
                                                                                  "open_indx_file" set ref 424* 477* 802
reserved                               based           structure                level 2 in structure "record_block" dcl 2646
                                                                                  in procedure "unlock_record"
reserved                               based           structure                level 2 in structure "record_block" dcl 4987
                                                                                  in procedure "open_indx_file"
reserved                               based           structure                level 2 in structure "record_block" dcl 1-96
                                                                                  in procedure "lock_current_record"
reset_pos                 0(18)        based           bit(1)                   level 4 packed packed unaligned dcl 4971 ref 542 549
                                                                                  591 616 627 637 651 1519 1527
reset_position                  001203 automatic       bit(1)                   dcl 1599 set ref 1527* 1533* 1548 1560 1576 1586
restart                         000020 constant        entry                    external dcl 4916 ref 2207 4553
reverse                                                builtin function         dcl 8-383 ref 1762
rew_retry                              constant        fixed bin(17,0)          initial dcl 4864 ref 2469
rewrite_record          102            based           entry variable           level 2 dcl 10-6 set ref 4648* 4673* 4690*
rk_header                              based           structure                level 1 unaligned dcl 5-26
rk_inf                                 based           structure                level 1 unaligned dcl 4968 in procedure
                                                                                  "open_indx_file"
rk_inf                          002076 automatic       structure                level 1 unaligned dcl 4416 in procedure
                                                                                  "init_uid_info" set ref 4401 4401
rk_key                                 based           varying char(22)         dcl 4453 ref 4309
rk_retry                               constant        fixed bin(17,0)          initial dcl 4873 ref 4064
rollback_action                 025600 constant        fixed bin(17,0)          initial dcl 9-2 ref 2944 3047
rollback_sw                     000314 automatic       bit(1)                   dcl 5005 set ref 2944* 2954* 2959* 2982* 2985
root_node_block          12            based           structure                level 2 unaligned dcl 8-157
root_position_ptr        24            based           pointer                  level 2 dcl 8-3 ref 257 410 587 613 746 1481 1573
                                                                                  1637 1710 1715 1728 2029 2116 2128 2323 2351 2399
                                                                                  2412 2884 3315 3379 3416 3748 3757 3774 3870 3886
                                                                                  3948 4309
rover_comp_num           53            based           fixed bin(17,0)          level 2 dcl 8-157 set ref 2293 2296* 2297
rover_seg_ptr            32            based           pointer                  level 2 dcl 8-3 set ref 2296*
rs_desc                                based           structure                level 1 packed packed unaligned dcl 4-32
rs_info                                based           structure                level 1 dcl 4-6
rs_info_ptr                     000776 automatic       pointer                  dcl 4-5 set ref 676 680 701 701 713 1789* 1790 1790
                                                                                  1793 1793 1799 1799 1799 1799 1800 1805 1805 1805
                                                                                  1811 1811 1814 1814 1818 1818 1822 1823 1824 1833
                                                                                  1833 1837 1839 1839 1843 1854 1858 1860 1863 1867
                                                                                  1868 1871 1871 1871 1874 1874 1879 1892 1898 1913
                                                                                  1930 1930 1971 1971 1985 1986 1990 1991 1993 2001
                                                                                  2002 2005 2006 2007 2010 2010 2012
rs_info_version_1                      constant        fixed bin(17,0)          initial dcl 4-43 ref 1790
rs_info_version_2                      constant        fixed bin(17,0)          initial dcl 4-44 ref 1790 2002 2010
rs_retry_1                             constant        fixed bin(17,0)          initial dcl 4862 ref 675
rs_retry_2                             constant        fixed bin(17,0)          initial dcl 4861 ref 109 109 684
saved_branch_num        121            based           fixed bin(17,0)          array level 3 dcl 8-298 set ref 3383*
saved_current_subset            000217 automatic       fixed bin(34,0)          dcl 4889 set ref 3827* 4515
saved_descrip           116            based           fixed bin(35,0)          level 4 dcl 8-3 set ref 2039* 2382* 2745* 2823* 3140
                                                                                  3195 3475 3485 3534 3562 3591 3634 4095 4104 4121
                                                                                  4160 4176 4188
saved_error_info                000220 automatic       structure                level 1 unaligned dcl 4890 set ref 353* 4508
saved_ks_out             45            based           bit(1)                   level 2 dcl 8-157 set ref 2762*
saved_lock_copy          57            based           bit(36)                  level 2 dcl 8-3 set ref 853 1143 1238 1249 2162 2164
                                                                                  2189 2441 2448 2578 2622 2630 2640 2952 4359 4389
                                                                                  4466 4480 4496 4614 4727* 4728* 4765
saved_min_cap           100            based           fixed bin(21,0)          level 2 dcl 8-157 set ref 1863* 2280*
saved_min_res            77            based           fixed bin(21,0)          level 2 dcl 8-157 set ref 1864* 2279*
saved_node              120            based           fixed bin(35,0)          array level 3 dcl 8-298 set ref 3382*
saved_state                     000103 automatic       structure                level 1 unaligned dcl 4886 set ref 100 862 2199 4517
saved_state_block                      based           char                     packed unaligned dcl 4887 set ref 100* 862*
saved_subset_selected           000216 automatic       bit(2)                   dcl 4888 set ref 3826* 4514
scan                            001032 automatic       bit(1)                   dcl 1471 set ref 932* 940* 945* 1004 1106
search_code                     001166 automatic       fixed bin(35,0)          dcl 1495 in procedure "check_subset" set ref 1483*
                                                                                  1484 1488
search_code                     000100 automatic       fixed bin(35,0)          dcl 296 in procedure "open_indx_file" set ref 260*
                                                                                  264 2352* 2354 2383 2400* 2402 2404 2407 2412*
                                                                                  2416* 3420* 3423 3542* 3555 3888* 3890 3922 4112*
                                                                                  4126* 4133* 4140
search_key                2            based           char                     level 2 packed packed unaligned dcl 5037 ref 744
seek_key                112            based           entry variable           level 2 dcl 10-6 set ref 4657* 4661* 4670* 4679*
                                                                                  4681* 4688*
seek_kso_retry                         constant        fixed bin(17,0)          initial dcl 4853 ref 223
seek_retry                             constant        fixed bin(17,0)          initial dcl 4854 ref 253 1056 1069
seg_array                              based           fixed bin(19,0)          array dcl 8-87 set ref 904
seg_fault_error                 000244 stack reference condition                dcl 4903 ref 4585 4605
seg_limit                              based           fixed bin(19,0)          array level 2 dcl 8-268 set ref 4806*
seg_ptr_array                          based           pointer                  array dcl 8-85 ref 904 1740
seg_ptr_array_ptr        10            based           pointer                  level 2 dcl 8-3 ref 904 1740
select_flag                            constant        bit(1)                   initial dcl 5104 ref 3654 3718 3801 3988 3988 4000
                                                                                  4000 4028 4028
set_bitcounts                   000170 constant        entry                    external dcl 8-368 ref 4603
set_lock_$lock                  000030 constant        entry                    external dcl 4920 ref 2166 4728
set_lock_$unlock                000032 constant        entry                    external dcl 4921 ref 4533
set_lock_flag                          based           bit(1)                   level 2 packed packed unaligned dcl 5052 ref 835
set_lock_info                          based           structure                level 1 dcl 5052
sh_retry                               constant        fixed bin(17,0)          initial dcl 4863 ref 735
shared                  106            based           bit(1)                   level 4 in structure "indx_cb" dcl 8-3 in procedure
                                                                                  "open_indx_file" set ref 93 188 542 549 627 676
                                                                                  816 972 1087 1092 1092* 1103* 1131 1213 1818 1935
                                                                                  1935* 1944* 2219 2433 3247 3410 3413 3524 3530
                                                                                  3588 3910 3952 4093 4119 4246 4531 4590 4710*
shared                    0(07)        based           bit(1)                   level 3 in structure "atb" packed packed unaligned
                                                                                  dcl 2-5 in procedure "open_indx_file" ref 4710
shared                          000103 automatic       bit(1)                   level 3 in structure "saved_state" dcl 4886
                                                                                  in procedure "open_indx_file" set ref 96* 216 1103
                                                                                  1944 4531* 4533
size                                                   builtin function         dcl 8-389 ref 100 100 862 862 2088 2285 2308 2310
                                                                                  2426 3708 3739 4532 4532 4579 4581 4596 4615 4615
                                                                                  4697 4697 4713 4715 4754 4754 4755 4755 4805 4806
                                                                                  4806 4806 4806 4806 4807 4807 4807 4807
skip                                   parameter       fixed bin(17,0)          dcl 4937 ref 347 374 377 424 425 432 477 478
skip_error                             constant        fixed bin(17,0)          initial dcl 5051 ref 423 476
skip_retry                             constant        fixed bin(17,0)          initial dcl 4858 ref 352 4508
skip_state              117            based           fixed bin(17,0)          level 4 in structure "indx_cb" dcl 8-3 in procedure
                                                                                  "open_indx_file" set ref 259* 373* 486* 545 552
                                                                                  622* 625* 647* 660* 757* 759* 1035 1040 1042 1060
                                                                                  1060 1060 1072* 1094 1102* 1106 1553 1564* 1580
                                                                                  1580 1580 2739* 3124* 4732*
skip_state               11     000103 automatic       fixed bin(17,0)          level 3 in structure "saved_state" dcl 4886
                                                                                  in procedure "open_indx_file" set ref 545* 552*
                                                                                  647 660 1094* 1102
son_position_ptr          2            based           pointer                  level 2 dcl 8-132 ref 2141 2142 2143 2152 2153 2154
                                                                                  3381
spare_node             6000            based           char(4096)               level 2 dcl 8-274 set ref 4624*
stac                                                   builtin function         dcl 4883 ref 2162
stacq                                                  builtin function         dcl 4883 ref 1249 2441 2448 2622 2640 4466 4480 4496
                                                                                  4625 4628 4765
stat                     61            based           bit(1)                   level 2 dcl 8-3 set ref 85 676 1007 1028 1818 1874
                                                                                  2386 2787 3463 3608 4145 4556 4724*
stat_header_size                       constant        fixed bin(17,0)          initial dcl 8-380 ref 1411
stat_struct                            based           structure                level 1 unaligned dcl 1-93 in procedure
                                                                                  "lock_current_record"
stat_struct                            based           structure                level 1 unaligned dcl 4988 in procedure
                                                                                  "open_indx_file"
stat_struct                            based           structure                level 1 unaligned dcl 2647 in procedure
                                                                                  "unlock_record"
stat_structure                         based           structure                level 1 unaligned dcl 8-92
stat_sw                   0(15)        based           bit(1)                   level 3 packed packed unaligned dcl 2-5 ref 4724
state_vars              106            based           structure                level 2 unaligned dcl 8-3 set ref 100 100 862 862
                                                                                  2199* 4517*
stationary                0(23)        based           bit(1)                   level 3 in structure "record_block" packed packed
                                                                                  unaligned dcl 1-96 in procedure
                                                                                  "lock_current_record" ref 924 982
stationary                0(23)        based           bit(1)                   level 3 in structure "record_block" packed packed
                                                                                  unaligned dcl 2646 in procedure "unlock_record"
                                                                                  ref 2614 2627 2633
stationary                0(23)        based           bit(1)                   level 3 in structure "record_block" packed packed
                                                                                  unaligned dcl 4987 in procedure "open_indx_file"
                                                                                  ref 717 1964 1971 1998 2481 2670 2768 3271 4193
                                                                                  4200 4221 4228 4469 4484
status_only               0(04)        based           bit(1)                   level 3 packed packed unaligned dcl 6-8 ref 3656
                                                                                  3704 3821 3832 3842 3998
string                                                 builtin function         dcl 4883 set ref 2021 4398* 4407*
sub_err_                        000054 constant        entry                    external dcl 5069 ref 4547 4560 4755 4767 4827
sub_err_info                           based           structure                level 1 unaligned dcl 156
subset_count             64            based           fixed bin(34,0)          level 2 dcl 8-3 set ref 3708* 3716 3739* 3762* 3769
                                                                                  3784* 3988* 3990* 3990 3993* 3993
subset_key                      001167 automatic       varying char(8)          dcl 1496 in procedure "check_subset" set ref 1482*
                                                                                  1483
subset_key                      001722 automatic       varying char(8)          dcl 3788 in procedure "count_subset" set ref 3744*
                                                                                  3746 3746 3749 3768* 3772 3772
subset_no                 2            based           fixed bin(17,0)          level 2 dcl 6-8 set ref 3660 3660 3667 3686 3686
                                                                                  3691 3710* 3712* 3714*
subset_selected         102            based           bit(2)                   level 2 dcl 8-3 set ref 383 396 449 459 555 760 956
                                                                                  1484 1512 1525 1808 2267 2692 3671* 3675* 3679
                                                                                  3692* 3701 3712 3718 3735 3803 3826 3932 3970 3988
                                                                                  3990 4000 4000* 4002* 4028 4514* 4735*
substr                                                 builtin function         dcl 8-388 set ref 141 324 608 610* 610 635 742 744*
                                                                                  1056 1060 1060 1432 1437* 1437 1580 1580 1716 1716
                                                                                  1762 1776 1781 2038 2414 2681* 2818* 2818 2886
                                                                                  3295 3295 3318 3318 3749 3749 3776 3862 3866* 3866
                                                                                  3873 3883 3894* 3895* 3895 3899 3902 3905 3945
                                                                                  4309 4506 4533 4616 4705 4782
system_freep                    000010 internal static pointer                  initial dcl 4879 set ref 3725 3725* 3727
table_idx                       002130 automatic       fixed bin(35,0)          dcl 4753 set ref 4754* 4755*
tail_len                        001261 automatic       fixed bin(17,0)          dcl 1770 set ref 1762* 1763 1763* 1765
tcf_iocbp               136            based           pointer                  level 2 dcl 2-5 ref 4738
tcfp                     72            based           pointer                  level 2 dcl 8-3 set ref 1077 1217 1219 1275 1308
                                                                                  1310 1331 1391 1445* 1-50* 2614 4257 4261* 4264
                                                                                  4267 4391 4469 4484 4738* 4740*
temp_ak_inf                            based           structure                level 1 unaligned dcl 4441 in procedure
                                                                                  "set_lock_list_entry" set ref 4277 4277 4336 4336
                                                                                  4346 4346 4372 4372
temp_ak_inf                     000552 automatic       structure                level 1 unaligned dcl 5081 in procedure
                                                                                  "open_indx_file" set ref 4031 4031 4043 4043
temp_cbp                        001164 automatic       pointer                  dcl 1493 set ref 1480* 1481 1481 1483*
temp_iocbp               66            based           pointer                  level 2 dcl 8-3 set ref 1480 3745 3771 3806 3808*
                                                                                  4017* 4031* 4043* 4610* 4736*
temp_key                  3     000552 automatic       char(8)                  level 2 in structure "temp_ak_inf" packed packed
                                                                                  unaligned dcl 5081 in procedure "open_indx_file"
                                                                                  set ref 3939 3940 3976 3977
temp_key                               based           structure                level 1 unaligned dcl 4447 in procedure
                                                                                  "set_lock_list_entry"
temp_key_words                         based           fixed bin(35,0)          array dcl 5079 set ref 3939* 3940* 3976* 3977*
temp_rk_inf                     002047 automatic       structure                level 1 unaligned dcl 4435 set ref 4325 4325
threshold                       001042 automatic       fixed bin(34,0)          dcl 1112 set ref 1018* 1019* 1031* 1087 1096
time                      4            based           fixed bin(53,0)          level 2 packed packed unaligned dcl 4447 set ref
                                                                                  4283* 4294*
time_last_modified        0(18)        based           fixed bin(54,0)          level 2 in structure "time_stamp_struct" packed
                                                                                  packed unsigned unaligned dcl 1-95 in procedure
                                                                                  "lock_current_record" ref 1225 1394 1-9 1-70
time_last_modified        0(18)        based           fixed bin(54,0)          level 2 in structure "time_stamp_struct" packed
                                                                                  packed unsigned unaligned dcl 4990 in procedure
                                                                                  "open_indx_file" set ref 1964* 3013* 3035*
time_last_modified       10            based           fixed bin(71,0)          level 2 in structure "rs_info" dcl 4-6 in procedure
                                                                                  "open_indx_file" set ref 2006*
time_left                       000261 automatic       fixed bin(17,0)          dcl 4908 set ref 1145* 1240* 2176* 2192*
time_stamp                      000320 automatic       fixed bin(71,0)          dcl 5008 set ref 1087 1225 1394* 1-9* 1-70 2006 3247
                                                                                  4294
time_stamp_struct                      based           structure                level 1 packed packed unaligned dcl 4990
                                                                                  in procedure "open_indx_file"
time_stamp_struct                      based           structure                level 1 packed packed unaligned dcl 2644
                                                                                  in procedure "unlock_record"
time_stamp_struct                      based           structure                level 1 packed packed unaligned dcl 1-95
                                                                                  in procedure "lock_current_record"
time_stamp_structure                   based           structure                level 1 packed packed unaligned dcl 8-112
time_stamp_words          4            based           fixed bin(71,0)          level 2 in structure "stat_struct" dcl 4988
                                                                                  in procedure "open_indx_file" set ref 1953 1964
                                                                                  2517 2990 3013 3035 3042 3243
time_stamp_words          4            based           fixed bin(71,0)          level 2 in structure "stat_struct" dcl 2647
                                                                                  in procedure "unlock_record" set ref 2637
time_stamp_words          4            based           fixed bin(71,0)          level 2 in structure "stat_struct" dcl 1-93
                                                                                  in procedure "lock_current_record" set ref 1225
                                                                                  1326 1394 1397 1-9 1-20 1-33 1-70
timeout                         000262 automatic       fixed bin(71,0)          dcl 4909 set ref 97* 105* 107* 202 1192 1227 1-74
                                                                                  2082* 2084* 2096 2176
timer_manager_$sleep            000056 constant        entry                    external dcl 5106 ref 1195 2101
total_key_length          5            based           fixed bin(34,0)          level 2 dcl 8-280 set ref 2794* 2794 3279* 3279
total_record_length       7            based           fixed bin(34,0)          level 2 dcl 8-280 set ref 2057* 2057 2530* 2530
                                                                                  2537* 2537 2998* 2998 3265* 3265
trans                    70            based           bit(1)                   level 2 dcl 8-3 set ref 966 1077 1123 1213 1268 1305
                                                                                  1389 1-37 1-37 1793 1900 1930 1975 2054 2231 2614
                                                                                  4469 4484 4737* 4738
trans_sw                  0(12)        based           bit(1)                   level 3 packed packed unaligned dcl 2-5 ref 4737
transaction                            defined         bit(1)                   dcl 5065 ref 1-37
transaction_call_$assign        000042 constant        entry                    external dcl 5000 ref 1445
transaction_call_$setup_ref_list
                                000044 constant        entry                    external dcl 5002 ref 4261
transaction_code         71            based           fixed bin(35,0)          level 2 dcl 8-3 set ref 1077 1217 1219 1275 1308
                                                                                  1310 1331 1391 2614 4267 4469 4484 4741*
transaction_number                     based           fixed bin(35,0)          level 2 dcl 4447 set ref 4267*
true_max_comp_num                      constant        fixed bin(17,0)          initial dcl 8-379 ref 2426 4754 4805 4806 4807
type                      1            based           fixed bin(35,0)          level 2 in structure "error_info" dcl 5046
                                                                                  in procedure "open_indx_file" set ref 801*
type                    103            based           fixed bin(17,0)          level 3 in structure "indx_cb" dcl 8-3 in procedure
                                                                                  "open_indx_file" set ref 423* 476* 801 4716*
uid                      76            based           bit(36)                  level 2 dcl 8-3 set ref 4265 4268 4412*
uid_val                         002074 automatic       bit(36)                  dcl 4414 set ref 4382* 4390 4412
unique_chars_                   000204 constant        entry                    external dcl 4018 ref 4010
unique_name                     000302 automatic       char(27)                 packed unaligned dcl 4995 set ref 4010* 4014* 4014
                                                                                  4782* 4782 4782 4786*
unlock_sw                 1(01)        based           bit(1)                   level 3 packed packed unaligned dcl 4-6 ref 701 713
                                                                                  1793 1793 1800 1814 1898 1930
unspec                                                 builtin function         dcl 8-391 set ref 608* 742* 3862* 4624* 1-45* 3743*
                                                                                  3767* 4384*
verify                                                 builtin function         dcl 8-383 ref 1762
version                                based           fixed bin(17,0)          level 2 in structure "rs_info" dcl 4-6 in procedure
                                                                                  "open_indx_file" ref 1790 1790 2002 2010
version                                based           fixed bin(35,0)          level 2 in structure "error_info" dcl 5046
                                                                                  in procedure "open_indx_file" ref 797
vfile_io_control                000046 constant        entry                    external dcl 5022 ref 888
vfile_io_control$af             000050 constant        entry                    external dcl 5022 ref 895
vfile_status_$seg               000052 constant        entry                    external dcl 5026 ref 881
vpad_key                               based           varying char(256)        dcl 5080 set ref 3883* 3888 3894 3894 3895 3895 3895
wait_time                41            based           fixed bin(35,0)          level 2 in structure "indx_cb" dcl 8-3 in procedure
                                                                                  "open_indx_file" set ref 105 107 828* 2082 2084
                                                                                  4711*
wait_time                 1            based           fixed bin(35,0)          level 2 in structure "atb" dcl 2-5 in procedure
                                                                                  "open_indx_file" ref 4711
wanted_desc                     001201 automatic       fixed bin(35,0)          dcl 1598 set ref 1509* 1511* 1515* 1538
was_ind                 102            based           bit(1)                   level 2 dcl 8-157 set ref 2671* 2945 3010 3064
was_stat                101            based           bit(1)                   level 2 dcl 8-157 set ref 921 1874* 2509 2665* 2670*
                                                                                  2704 2766* 2771* 2774* 2787* 3142 3197 3225 3239
                                                                                  3269* 3274* 3277* 3488 4219* 4224* 4227* 4232*
was_transaction         113            based           bit(1)                   level 2 dcl 8-157 set ref 2231* 2519 2708 3029*
                                                                                  3046*
words2                   16     000100 automatic       fixed bin(17,0)          initial array level 2 dcl 171 set ref 171*
write_record             76            based           entry variable           level 2 dcl 10-6 set ref 4662* 4672* 4683* 4689*
write_retry                            constant        fixed bin(17,0)          initial dcl 4865 ref 2688
wt_info                                based           structure                level 1 unaligned dcl 5056
wtime                                  parameter       fixed bin(17,0)          dcl 2170 set ref 2160 2166*
zero                                   based           fixed bin(35,0)          level 2 dcl 4426 set ref 4388*
zero_word_bytes                 001725 automatic       char(4)                  dcl 3791 set ref 3743* 3744 3767* 3768

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ak_info                                based           structure                level 1 unaligned dcl 5-6
ak_info_ptr                            automatic       pointer                  dcl 5-18
ak_key_len                             automatic       fixed bin(17,0)          dcl 5-19
append_action                          internal static fixed bin(17,0)          initial dcl 9-19
bit                                                    builtin function         dcl 8-393
bumping_count                          internal static fixed bin(17,0)          initial dcl 9-1
clock_                          000000 constant        entry                    external dcl 8-358
current_des                            based           structure                level 1 dcl 4942
current_program_version_1              internal static fixed bin(17,0)          initial dcl 4980
designator                             automatic       fixed bin(35,0)          dcl 8-88
eof_delete                             internal static fixed bin(17,0)          initial dcl 9-15
error_table_$bad_processid             external static fixed bin(35,0)          dcl 7-3
error_table_$no_file                   external static fixed bin(35,0)          dcl 7-3
error_table_$noarg                     external static fixed bin(35,0)          dcl 7-3
error_table_$noentry                   external static fixed bin(35,0)          dcl 7-3
error_table_$not_closed                external static fixed bin(35,0)          dcl 7-3
error_table_$not_detached              external static fixed bin(35,0)          dcl 7-3
error_table_$not_open                  external static fixed bin(35,0)          dcl 7-3
error_table_$segknown                  external static fixed bin(35,0)          dcl 7-3
error_table_$too_many_args             external static fixed bin(35,0)          dcl 7-3
extend_position_stack           000000 constant        entry                    external dcl 8-370
free_seg                        000000 constant        entry                    external dcl 8-367
get_new_seg                     000000 constant        entry                    external dcl 8-366
gk_info                                based           structure                level 1 unaligned dcl 5-41
gk_info_ptr                            automatic       pointer                  dcl 5-63
gk_info_version_0                      internal static fixed bin(17,0)          initial dcl 5-66
gk_key_len                             automatic       fixed bin(17,0)          dcl 5-64
iox_$attach_loud                000000 constant        entry                    external dcl 3-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 3-8
iox_$close_file                 000000 constant        entry                    external dcl 3-8
iox_$delete_record              000000 constant        entry                    external dcl 3-8
iox_$detach                     000000 constant        entry                    external dcl 3-8
iox_$err_no_operation           000000 constant        entry                    external dcl 3-8
iox_$err_not_attached           000000 constant        entry                    external dcl 3-8
iox_$err_not_closed             000000 constant        entry                    external dcl 3-8
iox_$err_not_open               000000 constant        entry                    external dcl 3-8
iox_$error_output                      external static pointer                  dcl 3-41
iox_$find_iocb                  000000 constant        entry                    external dcl 3-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 3-8
iox_$get_chars                  000000 constant        entry                    external dcl 3-8
iox_$get_line                   000000 constant        entry                    external dcl 3-8
iox_$iocb_version_sentinel             external static char(4)                  dcl 10-51
iox_$look_iocb                  000000 constant        entry                    external dcl 3-8
iox_$modes                      000000 constant        entry                    external dcl 3-8
iox_$move_attach                000000 constant        entry                    external dcl 3-8
iox_$open_file                  000000 constant        entry                    external dcl 3-8
iox_$position                   000000 constant        entry                    external dcl 3-8
iox_$propagate                  000000 constant        entry                    external dcl 3-8
iox_$put_chars                  000000 constant        entry                    external dcl 3-8
iox_$read_key                   000000 constant        entry                    external dcl 3-8
iox_$read_length                000000 constant        entry                    external dcl 3-8
iox_$read_record                000000 constant        entry                    external dcl 3-8
iox_$rewrite_record             000000 constant        entry                    external dcl 3-8
iox_$seek_key                   000000 constant        entry                    external dcl 3-8
iox_$user_input                        external static pointer                  dcl 3-41
iox_$user_io                           external static pointer                  dcl 3-41
iox_$user_output                       external static pointer                  dcl 3-41
iox_$write_record               000000 constant        entry                    external dcl 3-8
make_designator                 000000 constant        entry                    external dcl 8-363
msf_manager_$get_ptr            000000 constant        entry                    external dcl 4986
must_adjust                            internal static fixed bin(17,0)          initial dcl 9-21
must_rollback                          internal static fixed bin(17,0)          initial dcl 9-22
need_pos                               internal static fixed bin(17,0)          initial dcl 4907
non_eof_delete                         internal static fixed bin(17,0)          initial dcl 9-5
old_file_base                          based           structure                level 1 unaligned dcl 8-331
rel                                                    builtin function         dcl 8-396
rewrite_action                         internal static fixed bin(17,0)          initial dcl 9-17
rk_info                                based           structure                level 1 unaligned dcl 5-22
rk_info_ptr                            automatic       pointer                  dcl 5-37
rk_key_len                             automatic       fixed bin(17,0)          dcl 5-38
seg_ptr                                automatic       pointer                  dcl 8-86
seq_desc                               based           structure                level 1 packed packed unaligned dcl 4-37
sl_array_limit                         automatic       fixed bin(17,0)          dcl 6-42
sl_info_version_0                      internal static fixed bin(17,0)          initial dcl 6-43
temp_ts_words                          automatic       structure                level 1 dcl 4954
truncate_action                        internal static fixed bin(17,0)          initial dcl 9-20
unshared_opening                       internal static fixed bin(17,0)          initial dcl 9-4
write_trunc                            internal static fixed bin(17,0)          initial dcl 9-7

NAMES DECLARED BY EXPLICIT CONTEXT.
abort_exit                      004336 constant        label                    dcl 2423 ref 1876 1876 1885 1885 2512 2512 2522 2522
                                                                                  2531 2531 2548 2548 2590 2590 2707 2707 2719 2719
                                                                                  3021 3021 3030 3030 3057 3057 3068 3068 3073 3073
                                                                                  3080 3080 3149 3149 3158 3158 3177 3177 3212 3212
                                                                                  3356 3356 3494 3494
add_key                         006250 constant        label                    dcl 3389 ref 778
add_lock_list_entry             022447 constant        entry                    internal dcl 4248 ref 1313
adjust_file                     006234 constant        entry                    external dcl 3087 ref 2105
adjust_record                   005461 constant        entry                    external dcl 2930 ref 1284
adjust_ref_count                013251 constant        label                    dcl 1353 ref 1303
as_del                          017271 constant        label                    dcl 2369 ref 2383 2386
asynch_change_condition         001633 constant        entry                    internal dcl 138 ref 129
back_1                          002632 constant        label                    dcl 438 ref 459 459
backspace                       014445 constant        entry                    internal dcl 1684 ref 1051
bad_arg                         007121 constant        label                    dcl 3663 ref 3686 3796
bump_substate                   021217 constant        label                    dcl 3301 ref 3245 3266
check_buff_len                  017664 constant        entry                    internal dcl 2724 ref 2471 2690
check_code                      025005 constant        entry                    internal dcl 4822 ref 853 980 1285 1448 1745 2209
                                                                                  4016 4038 4050 4262 4278 4326 4338 4347 4373 4383
                                                                                  4402 4410
check_codes                     006673 constant        label                    dcl 3552 ref 3604
check_comp_array_table          024414 constant        entry                    internal dcl 4745 ref 4538
check_current                   016726 constant        entry                    internal dcl 2242 ref 530 1916 2473 2849 2915 3407
                                                                                  3455 3510 3521 3576 4072 4078
check_file_lock                 016170 constant        entry                    internal dcl 2079 ref 2066
check_file_substate             024774 constant        entry                    internal dcl 4815 ref 2655 2758 2902 3102 3230 3352
                                                                                  3367 4216
check_key_for_insertion         020130 constant        entry                    internal dcl 2841 ref 2789 3459
check_rs_args                   015021 constant        entry                    internal dcl 1787 ref 672
check_subset                    014017 constant        entry                    internal dcl 1478 ref 399 452 560 956 1515 1544 3935
                                                                                  3970
check_time                      013776 constant        label                    dcl 1-70 ref 1-24
cleanup_exit                    011216 constant        label                    dcl 4605 ref 4564 4588 4594
close_indx_file                 011063 constant        entry                    external dcl 4575 ref 4634
collect_item                    012040 constant        entry                    internal dcl 1075 ref 1020 1032
compare_last_key                014757 constant        entry                    internal dcl 1773 ref 240 2325 3436
compute_time_left               016523 constant        entry                    internal dcl 2174 ref 1142 1236 2188
control_indx_file               003003 constant        entry                    external dcl 509 ref 1098 4031 4043 4635 4671
count_subset                    021574 constant        entry                    internal dcl 3733 ref 3676 3693
create_indx_cb                  024160 constant        entry                    internal dcl 4694 ref 4520
delete_entry                    020324 constant        entry                    internal dcl 3115 ref 2927 3625 3640
delete_indx_file                005400 constant        entry                    external dcl 2909 ref 1096 4649 4674 4691
delete_key                      006542 constant        label                    dcl 3498 ref 781
deleting_dup                    021222 constant        entry                    internal dcl 3305 ref 3283
discard_temp_file               024563 constant        entry                    internal dcl 4777 ref 4610 4612
end_ns_rew                      005207 constant        label                    dcl 2596 ref 2561 2572
enter_temp_key                  022172 constant        entry                    internal dcl 4026 ref 3941 3978
exclude                         007150 constant        label                    dcl 3684 ref 791
exit                            004505 constant        label                    dcl 2464 ref 524 2110 3394 3650 3665
find_cur_key                    007003 constant        label                    dcl 3602 ref 3595
find_entry                      017343 constant        entry                    internal dcl 2397 ref 2382 3548 3602 3920 4114 4128
find_from_leaf                  014410 constant        entry                    internal dcl 1653 ref 268 1713 2357 2402 3214 3428
                                                                                  3892
find_input_key                  006663 constant        label                    dcl 3548 ref 3540
find_leftmost_descendent        016426 constant        entry                    internal dcl 2149 ref 405 1652 2129
find_next_key                   020164 constant        entry                    internal dcl 2875 ref 2828
find_next_record                014310 constant        entry                    internal dcl 1602 ref 302 316 334 359 1052 2266
find_prev_entry                 014426 constant        entry                    internal dcl 1668 ref 438 1556 1696 2390 3332
find_rightmost_descendent       016372 constant        entry                    internal dcl 2138 ref 1670 2117 2324 2800 3293 3435
find_this_entry                 014405 constant        entry                    internal dcl 1650 ref 409 586 1572 1636 1724 2028
                                                                                  2411 2883 3313 3755 3779 3944
generate_subset                 007170 constant        label                    dcl 3796 ref 3656 3672 3679 3686
get_current_image_info          013335 constant        entry                    internal dcl 1385 ref 1177 1242
get_key_length                  014710 constant        entry                    internal dcl 1754 ref 323 634 1056 1060 2816 3279
                                                                                  3288
get_lock_status                 013516 constant        entry                    internal dcl 1452 ref 1083 1125 1161 1184 1210
get_pointer                     014610 constant        entry                    internal dcl 1736 ref 918 978 1416 2938 2945 2973
                                                                                  3100 3111
get_ptr                         011343 constant        entry                    internal dcl 902 ref 1746 1954 2142 2153 2566
get_reclp                       011456 constant        label                    dcl 946 ref 933 941
get_status                      010060 constant        label                    dcl 4004 ref 3998
get_subset_status               021474 constant        entry                    internal dcl 3699 ref 3681 3696 4004
get_t_code                      013471 constant        entry                    internal dcl 1443 ref 1217 1308
get_temp_switch                 021771 constant        entry                    internal dcl 4008 ref 3806
gk_scan                         014074 constant        entry                    internal dcl 1499 ref 600 626
handle_pos                      012215 constant        label                    dcl 1106 ref 1077 1084 1087
init_body                       001424 constant        label                    dcl 90 ref 82 86
init_down_up                    001376 constant        label                    dcl 79 ref 676 841 2689 2934 3091
init_uid_info                   023255 constant        entry                    internal dcl 4378 ref 4265
init_up_down                    001405 constant        label                    dcl 83 set ref 676 2470 2912 3397 3501 4065
initialize                      001415 constant        label                    dcl 87 ref 224 254 301 315 333 354 494 518 680 685
                                                                                  736 3828
initialize_new_file             024673 constant        entry                    internal dcl 4795 ref 4522
initialize_ptrs                 017010 constant        entry                    internal dcl 2283 ref 692 2071 2202
initialize_substate             016657 constant        entry                    internal dcl 2216 ref 1857 2496 2698 2935 3117 3481
                                                                                  4189
inner_loop                      007557 constant        label                    dcl 3902 ref 3929
inspect_non_stat_rec            012225 constant        entry                    internal dcl 1115 ref 982
inspect_stat_record             012434 constant        entry                    internal dcl 1171 ref 984
inv_new                         023650 constant        label                    dcl 4496 ref 4484 4490
inv_old                         023603 constant        label                    dcl 4480 ref 4469 4474
keep_loopin                     012444 constant        label                    dcl 1177 ref 1197
list_subset                     021674 constant        entry                    internal dcl 3765 ref 3729
lock_current_record             011362 constant        entry                    internal dcl 909 ref 1889 1924 2476 2712 2919 3466
                                                                                  3612 4150 4168
lock_file_check                 016533 constant        entry                    internal dcl 2180 ref 116 1136 2219
loop                            014430 constant        label                    dcl 1672 in procedure "find_prev_entry" ref 1678
loop                            014411 constant        label                    dcl 1656 in procedure "find_this_entry" ref 1662
main                            022461 constant        label                    dcl 4257 ref 4247 4252
make_current                    016110 constant        entry                    internal dcl 2043 ref 1837 1879 3190
mask_entry                      011620 constant        entry                    internal dcl 1001 ref 989
next_entry                      007661 constant        label                    dcl 3942 ref 3936
next_found                      003246 constant        label                    dcl 594 ref 575 584
next_interval                   007717 constant        label                    dcl 3952 ref 3848 3870 3890 3905 3948
next_is_dup                     021244 constant        entry                    internal dcl 3310 ref 3308
no_key                          020144 constant        label                    dcl 2853 ref 2845
norec                           014227 constant        label                    dcl 1562 ref 1521 1578 1592
note_last_subset                022344 constant        entry                    internal dcl 4055 ref 3916 3925 3959 3996 4037 4049
open_case                       000031 constant        label                    array(4:13) dcl 4637 ref 4636
open_file                       010541 constant        label                    dcl 4520 ref 77
open_indx_file                  001365 constant        entry                    external dcl 73
outer_loop                      007323 constant        label                    dcl 3842 ref 3962
passive_abort                   001775 constant        label                    dcl 214 ref 4830
position_bof                    016344 constant        entry                    internal dcl 2126 ref 475 498 1560 1701 2344 3847
position_eof                    016325 constant        entry                    internal dcl 2114 ref 229 422 495 591 1576 1640 2346
position_indx_file              002423 constant        entry                    external dcl 347 ref 4641 4647 4656 4669
prepare_key                     017644 constant        entry                    internal dcl 2678 ref 2778 2832 3295
prepare_key_for_insertion       020056 constant        entry                    internal dcl 2810 ref 2781 2790
prepare_process                 016141 constant        entry                    internal dcl 2060 ref 179 185 208 3917 3961
prev_is_dup                     021331 constant        entry                    internal dcl 3330 ref 3308
read_indx_file                  002353 constant        entry                    external dcl 330 ref 4639 4645 4653 4666 4676 4685
read_key_indx_file              002272 constant        entry                    external dcl 312 ref 4655 4668
read_length_indx_file           002243 constant        entry                    external dcl 298 ref 4640 4646 4654 4667 4678 4687
reassign_key                    010062 constant        label                    dcl 4062 ref 784
reattempt                       012660 constant        label                    dcl 1236 ref 1286
record_status                   015276 constant        entry                    internal dcl 1852 ref 698
replace_non_leaf_key            021342 constant        entry                    internal dcl 3346 ref 3207
reset_change_position           021401 constant        entry                    internal dcl 3361 ref 3208
restore_abort                   023503 constant        entry                    internal dcl 4458 ref 108 864
restore_position                017143 constant        entry                    internal dcl 2316 ref 367 570 1608 1690 2252 2862
                                                                                  4103
restore_state                   023660 constant        entry                    internal dcl 4502 ref 184 201 216 2447 2451 4462
retry_loc                       000000 constant        label                    array(25) dcl 225 ref 98 109 111 117 180 186 209
                                                                                  1138 3918 3957
return_contents                 013440 constant        entry                    internal dcl 1430 ref 1166 1223
rewrite_indx_file               004513 constant        entry                    external dcl 2467 ref 1940 4648 4673 4690
save_correct_pos                016031 constant        entry                    internal dcl 2019 ref 194 546 553 627 2439 2453 3410
                                                                                  3413 3524 3530 3588 3829 4093 4119
save_min_blksz_inf              017000 constant        entry                    internal dcl 2276 ref 1866 2504 2699
save_old_record_length          017572 constant        entry                    internal dcl 2650 ref 2506 2988 3043
save_position_info              021423 constant        entry                    internal dcl 3376 ref 2804 3300
save_stat_info                  017607 constant        entry                    internal dcl 2663 ref 2659 3237
scan_loop                       014165 constant        label                    dcl 1535 ref 1528
seek_head                       014506 constant        entry                    internal dcl 1708 ref 612 745 3746 3772 3869 4286
seek_key_indx_file              002106 constant        entry                    external dcl 251 ref 4657 4670 4679 4681 4688
seek_key_ks_out                 002016 constant        entry                    external dcl 221 ref 4661
select                          007105 constant        label                    dcl 3654 ref 788
set_add_ent_info                017724 constant        entry                    internal dcl 2751 ref 1870 2701 3482
set_add_rec_stats               016122 constant        entry                    internal dcl 2052 ref 1868 2791
set_after_image_info            020251 constant        entry                    internal dcl 3095 ref 2991
set_at_eof                      016333 constant        entry                    internal dcl 2118 ref 237 2032
set_current                     014376 constant        label                    dcl 1645 ref 1620
set_current_image_info          013560 constant        entry                    internal dcl 1-1 ref 1389 1400
set_current_reclp               011451 constant        entry                    internal dcl 942 ref 1920
set_del_ent_info                020662 constant        entry                    internal dcl 3219 ref 3119
set_entries_and_positions       023741 constant        entry                    internal dcl 4632 ref 4564
set_lock                        016462 constant        entry                    internal dcl 2160 ref 1145 1240 1455 2093 2192 4593
set_lock_list_entry             022440 constant        entry                    internal dcl 4242 ref 1319
set_new_record_designator       020234 constant        entry                    internal dcl 2897 ref 1884 2718
set_next_reclp                  011435 constant        entry                    internal dcl 934 ref 307 321
set_next_reclp_and_contents     011443 constant        entry                    internal dcl 934 ref 339
set_next_reclp_seek             011440 constant        entry                    internal dcl 934 ref 270
set_post_write_pos              017677 constant        entry                    internal dcl 2734 ref 1887 2721
set_ref_list_entry              022454 constant        entry                    internal dcl 4253 ref 1219
set_result                      021254 constant        label                    dcl 3315 ref 3335
set_rk_info                     022357 constant        entry                    internal dcl 4210 ref 4190
set_rs_return_info              015754 constant        entry                    internal dcl 1983 ref 1891 1949 1980
set_stat_reclp                  013402 constant        entry                    internal dcl 1403 ref 1222 1332 1341 1344 1351
sh_scan                         014162 constant        entry                    internal dcl 1530 ref 760 2267
switch_file_state               004350 constant        label                    dcl 2429 ref 1892 1898 1900 1907 2603 2722 3060 3085
                                                                                  3156 3163 3170 3183 3217 3496 4208
try_again                       001725 constant        label                    dcl 182 ref 129
unlock_exit                     004360 constant        label                    dcl 2433 ref 188 711 713 872 2200 2427 2489 2696
                                                                                  2730 2925 2950 2952 3008 3092 4177 4573 4833
unlock_record                   017452 constant        entry                    internal dcl 2605 ref 2454 2458
verify_done                     001741 constant        label                    dcl 188 ref 249 294 310 328 345 368 507 531 540 571
                                                                                  663 715 717 771 972 2474 2478 2855 2863 2916 3408
                                                                                  3437 3446 3456 3476 3511 3522 3563 3572 3582 3635
                                                                                  3927 4082 4142 4161
verify_keyed_update             021460 constant        entry                    internal dcl 3643 ref 3498 4062
write_indx_file                 005231 constant        entry                    external dcl 2686 ref 4662 4672 4683 4689

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     27040       27250   25703       27050
Length     30166   25703       210         702    1134           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
open_indx_file                     2226 external procedure  is an external procedure.  
on unit on line 108                  64 on unit               
on unit on line 121                 117 on unit               
asynch_change_condition                 internal procedure  shares stack frame of on unit on line 121.  
on unit on line 864                  64 on unit               
get_ptr                                 internal procedure  shares stack frame of external procedure open_indx_file.  
lock_current_record                     internal procedure  shares stack frame of external procedure open_indx_file.  
mask_entry                              internal procedure  shares stack frame of external procedure open_indx_file.  
collect_item                            internal procedure  shares stack frame of external procedure open_indx_file.  
inspect_non_stat_rec                    internal procedure  shares stack frame of external procedure open_indx_file.  
inspect_stat_record                     internal procedure  shares stack frame of external procedure open_indx_file.  
get_current_image_info                  internal procedure  shares stack frame of external procedure open_indx_file.  
set_stat_reclp                          internal procedure  shares stack frame of external procedure open_indx_file.  
return_contents                         internal procedure  shares stack frame of external procedure open_indx_file.  
get_t_code                              internal procedure  shares stack frame of external procedure open_indx_file.  
get_lock_status                         internal procedure  shares stack frame of external procedure open_indx_file.  
set_current_image_info                  internal procedure  shares stack frame of external procedure open_indx_file.  
check_subset                            internal procedure  shares stack frame of external procedure open_indx_file.  
gk_scan                                 internal procedure  shares stack frame of external procedure open_indx_file.  
find_next_record                        internal procedure  shares stack frame of external procedure open_indx_file.  
find_this_entry                         internal procedure  shares stack frame of external procedure open_indx_file.  
find_prev_entry                         internal procedure  shares stack frame of external procedure open_indx_file.  
backspace                               internal procedure  shares stack frame of external procedure open_indx_file.  
seek_head                               internal procedure  shares stack frame of external procedure open_indx_file.  
get_pointer                             internal procedure  shares stack frame of external procedure open_indx_file.  
get_key_length                          internal procedure  shares stack frame of external procedure open_indx_file.  
compare_last_key                        internal procedure  shares stack frame of external procedure open_indx_file.  
check_rs_args                           internal procedure  shares stack frame of external procedure open_indx_file.  
record_status                           internal procedure  shares stack frame of external procedure open_indx_file.  
set_rs_return_info                      internal procedure  shares stack frame of external procedure open_indx_file.  
save_correct_pos                        internal procedure  shares stack frame of external procedure open_indx_file.  
make_current                            internal procedure  shares stack frame of external procedure open_indx_file.  
set_add_rec_stats                       internal procedure  shares stack frame of external procedure open_indx_file.  
prepare_process                         internal procedure  shares stack frame of external procedure open_indx_file.  
check_file_lock                         internal procedure  shares stack frame of external procedure open_indx_file.  
position_eof                            internal procedure  shares stack frame of external procedure open_indx_file.  
position_bof                            internal procedure  shares stack frame of external procedure open_indx_file.  
find_rightmost_descendent               internal procedure  shares stack frame of external procedure open_indx_file.  
find_leftmost_descendent                internal procedure  shares stack frame of external procedure open_indx_file.  
set_lock                                internal procedure  shares stack frame of external procedure open_indx_file.  
compute_time_left                       internal procedure  shares stack frame of external procedure open_indx_file.  
lock_file_check                         internal procedure  shares stack frame of external procedure open_indx_file.  
initialize_substate                     internal procedure  shares stack frame of external procedure open_indx_file.  
check_current                           internal procedure  shares stack frame of external procedure open_indx_file.  
save_min_blksz_inf                      internal procedure  shares stack frame of external procedure open_indx_file.  
initialize_ptrs                         internal procedure  shares stack frame of external procedure open_indx_file.  
restore_position                        internal procedure  shares stack frame of external procedure open_indx_file.  
find_entry                              internal procedure  shares stack frame of external procedure open_indx_file.  
unlock_record                           internal procedure  shares stack frame of external procedure open_indx_file.  
save_old_record_length                  internal procedure  shares stack frame of external procedure open_indx_file.  
save_stat_info                          internal procedure  shares stack frame of external procedure open_indx_file.  
prepare_key                             internal procedure  shares stack frame of external procedure open_indx_file.  
check_buff_len                          internal procedure  shares stack frame of external procedure open_indx_file.  
set_post_write_pos                      internal procedure  shares stack frame of external procedure open_indx_file.  
set_add_ent_info                        internal procedure  shares stack frame of external procedure open_indx_file.  
prepare_key_for_insertion               internal procedure  shares stack frame of external procedure open_indx_file.  
check_key_for_insertion                 internal procedure  shares stack frame of external procedure open_indx_file.  
find_next_key                           internal procedure  shares stack frame of external procedure open_indx_file.  
set_new_record_designator               internal procedure  shares stack frame of external procedure open_indx_file.  
set_after_image_info                    internal procedure  shares stack frame of external procedure open_indx_file.  
delete_entry                            internal procedure  shares stack frame of external procedure open_indx_file.  
set_del_ent_info                        internal procedure  shares stack frame of external procedure open_indx_file.  
deleting_dup                            internal procedure  shares stack frame of external procedure open_indx_file.  
next_is_dup                             internal procedure  shares stack frame of external procedure open_indx_file.  
replace_non_leaf_key                    internal procedure  shares stack frame of external procedure open_indx_file.  
reset_change_position                   internal procedure  shares stack frame of external procedure open_indx_file.  
save_position_info                      internal procedure  shares stack frame of external procedure open_indx_file.  
verify_keyed_update                     internal procedure  shares stack frame of external procedure open_indx_file.  
get_subset_status                       internal procedure  shares stack frame of external procedure open_indx_file.  
count_subset                            internal procedure  shares stack frame of external procedure open_indx_file.  
get_temp_switch                         internal procedure  shares stack frame of external procedure open_indx_file.  
enter_temp_key                          internal procedure  shares stack frame of external procedure open_indx_file.  
note_last_subset                        internal procedure  shares stack frame of external procedure open_indx_file.  
set_rk_info                             internal procedure  shares stack frame of external procedure open_indx_file.  
set_lock_list_entry                     internal procedure  shares stack frame of external procedure open_indx_file.  
init_uid_info                           internal procedure  shares stack frame of external procedure open_indx_file.  
restore_abort                        66 internal procedure  is called by several nonquick procedures.  
restore_state                        64 internal procedure  is called by several nonquick procedures.  
on unit on line 4585                 64 on unit               
set_entries_and_positions               internal procedure  shares stack frame of external procedure open_indx_file.  
create_indx_cb                          internal procedure  shares stack frame of external procedure open_indx_file.  
check_comp_array_table                  internal procedure  shares stack frame of external procedure open_indx_file.  
discard_temp_file                       internal procedure  shares stack frame of external procedure open_indx_file.  
initialize_new_file                     internal procedure  shares stack frame of external procedure open_indx_file.  
check_file_substate                     internal procedure  shares stack frame of external procedure open_indx_file.  
check_code                              internal procedure  shares stack frame of external procedure open_indx_file.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 system_freep                open_indx_file

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
on unit on line 121      000100 cond_info                   on unit on line 121
                         000132 er_code                     on unit on line 121
                         000144 i                           asynch_change_condition
open_indx_file           000100 search_code                 open_indx_file
                         000101 rec_deleted                 open_indx_file
                         000102 len                         open_indx_file
                         000103 saved_state                 open_indx_file
                         000216 saved_subset_selected       open_indx_file
                         000217 saved_current_subset        open_indx_file
                         000220 saved_error_info            open_indx_file
                         000224 os_ptr                      open_indx_file
                         000226 branches_left               open_indx_file
                         000227 count                       open_indx_file
                         000230 chunk_size                  open_indx_file
                         000231 first_code                  open_indx_file
                         000232 key_is_dup                  open_indx_file
                         000233 passive_op                  open_indx_file
                         000234 del_cur                     open_indx_file
                         000235 fault_ok                    open_indx_file
                         000260 current_retry_loc           open_indx_file
                         000261 time_left                   open_indx_file
                         000262 timeout                     open_indx_file
                         000264 new_change_count            open_indx_file
                         000265 record_action               open_indx_file
                         000266 record_len                  open_indx_file
                         000270 record_ptr                  open_indx_file
                         000272 foo                         open_indx_file
                         000274 pos_ptr                     open_indx_file
                         000276 block_ptr                   open_indx_file
                         000300 lock_ptr                    open_indx_file
                         000302 unique_name                 open_indx_file
                         000311 lock_copy                   open_indx_file
                         000312 ind_desc                    open_indx_file
                         000313 cur_mod                     open_indx_file
                         000314 rollback_sw                 open_indx_file
                         000316 p                           open_indx_file
                         000320 time_stamp                  open_indx_file
                         000322 mod                         open_indx_file
                         000323 cleanup_flags               open_indx_file
                         000324 info_ptr                    open_indx_file
                         000326 gk_pad_key                  open_indx_file
                         000430 pad_key_ptr                 open_indx_file
                         000432 max_rec_wds                 open_indx_file
                         000433 ref_cnt                     open_indx_file
                         000434 delta_ref_count             open_indx_file
                         000436 new_block_ptr               open_indx_file
                         000440 new_lock_ptr                open_indx_file
                         000442 passive                     open_indx_file
                         000443 old_ref_cnt                 open_indx_file
                         000444 new_des                     open_indx_file
                         000445 old_des                     open_indx_file
                         000446 pos_unchanged               open_indx_file
                         000447 next_subset                 open_indx_file
                         000450 i                           open_indx_file
                         000451 last_head                   open_indx_file
                         000552 temp_ak_inf                 open_indx_file
                         000557 flag                        open_indx_file
                         000560 head_spec                   open_indx_file
                         000561 open_ended                  open_indx_file
                         000562 n_int                       open_indx_file
                         000564 last_info_ptr               open_indx_file
                         000566 last_info_block             open_indx_file
                         000776 rs_info_ptr                 open_indx_file
                         001000 indx_cb_ptr                 open_indx_file
                         001002 f_b_ptr                     open_indx_file
                         001004 fs_ptr                      open_indx_file
                         001006 is_ptr                      open_indx_file
                         001032 scan                        lock_current_record
                         001033 passive                     lock_current_record
                         001042 threshold                   mask_entry
                         001052 er_code                     collect_item
                         001062 blksz                       inspect_non_stat_rec
                         001072 er_code                     inspect_stat_record
                         001073 min_ref_count               inspect_stat_record
                         001074 mics_left                   inspect_stat_record
                         001112 p                           set_stat_reclp
                         001130 er_code                     get_t_code
                         001140 lock_copy                   get_lock_status
                         001150 er_code                     set_current_image_info
                         001151 new_ind_desc                set_current_image_info
                         001152 gk_inf                      set_current_image_info
                         001164 temp_cbp                    check_subset
                         001166 search_code                 check_subset
                         001167 subset_key                  check_subset
                         001200 desc_known                  gk_scan
                         001201 wanted_desc                 gk_scan
                         001202 descrip                     gk_scan
                         001203 reset_position              gk_scan
                         001250 p                           get_pointer
                         001260 len                         get_key_length
                         001261 tail_len                    get_key_length
                         001276 recl                        check_rs_args
                         001277 capacity                    check_rs_args
                         001306 er_code                     record_status
                         001354 mics_left                   check_file_lock
                         001430 er_code                     lock_file_check
                         001550 new_key_len                 set_add_ent_info
                         001574 init_key_len                find_next_key
                         001576 init_key_ptr                find_next_key
                         001636 keys_match                  deleting_dup
                         001637 new_branch_num              deleting_dup
                         001640 change_branch               deleting_dup
                         001672 i                           save_position_info
                         001674 p                           save_position_info
                         001722 subset_key                  count_subset
                         001725 zero_word_bytes             count_subset
                         001726 count                       count_subset
                         001727 i                           count_subset
                         001736 proc_dirp_overlay           get_temp_switch
                         002012 iocbp                       get_temp_switch
                         002044 passive                     set_lock_list_entry
                         002045 must_verify                 set_lock_list_entry
                         002046 er_code                     set_lock_list_entry
                         002047 temp_rk_inf                 set_lock_list_entry
                         002062 refp                        set_lock_list_entry
                         002072 refp                        init_uid_info
                         002074 uid_val                     init_uid_info
                         002075 er_code                     init_uid_info
                         002076 rk_inf                      init_uid_info
                         002130 table_idx                   check_comp_array_table
                         002140 foo                         discard_temp_file

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_g_a               r_e_as              r_ne_as             alloc_char_temp     unpk_to_pk
cat_realloc_chars   call_ext_in_desc    call_ext_in         call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          fl2_to_fx1          tra_ext_1           stac_mac            enable_op
shorten_stack       ext_entry           ext_entry_desc      int_entry           op_alloc_           stacq_mac
clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
alloc_cb_file                 change_index                  change_record_list            check_file_version
continue_to_signal_           create_position_stack         create_seg_ptrs               delete_old_subsets
find_condition_info_          find_key                      find_key$last                 free_cb_file
free_position_stack           free_seg_ptrs                 get_pdir_                     get_seg_ptr
get_system_free_area_         hcs_$delentry_file            hcs_$get_uid_seg              hcs_$set_bc_seg
iox_$attach_name              iox_$close                    iox_$control                  iox_$destroy_iocb
iox_$detach_iocb              iox_$open                     restart                       set_bitcounts
set_lock_$lock                set_lock_$unlock              sub_err_                      timer_manager_$sleep
transaction_call_$assign      transaction_call_$setup_ref_list                            unique_chars_
vfile_io_control              vfile_io_control$af           vfile_status_$seg

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$asynch_change    error_table_$asynch_deletion  error_table_$asynch_insertion error_table_$bad_arg
error_table_$bad_file         error_table_$end_of_info      error_table_$file_busy        error_table_$file_is_full
error_table_$higher_inconsistency                           error_table_$invalid_lock_reset
error_table_$key_duplication  error_table_$key_order        error_table_$last_reference   error_table_$lock_is_invalid
error_table_$lock_not_locked  error_table_$lock_wait_time_exceeded
error_table_$locked_by_this_process                         error_table_$long_record      error_table_$no_key
error_table_$no_operation     error_table_$no_record        error_table_$no_room_for_lock error_table_$record_busy
error_table_$too_many_refs    error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     73 001356        77 001375        79 001376        81 001403        82 001404        83 001405        85 001412
     86 001414        87 001415        89 001422        90 001424        92 001425        93 001426        96 001430
     97 001431        98 001433       100 001435       102 001442       103 001444       104 001446       105 001450
    107 001455       108 001460       109 001502       111 001507       113 001513       116 001515       117 001516
    119 001520       121 001521       171 001530       121 001545       123 001554       126 001557       127 001560
    129 001577       134 001620       136 001623       177 001632       138 001633       141 001635       144 001650
    147 001665       149 001667       150 001677       152 001715       154 001717       179 001722       180 001723
    182 001725       184 001732       185 001736       186 001737       188 001741       194 001746       195 001747
    198 001752       201 001756       202 001762       205 001765       206 001770       208 001771       209 001772
    212 001774       214 001775       216 002002       218 002010       221 002011       223 002030       224 002032
    225 002033       229 002036       230 002037       231 002041       234 002042       235 002044       236 002045
    237 002047       239 002050       240 002060       241 002066       244 002070       245 002073       246 002076
    247 002077       249 002103       251 002104       253 002120       254 002122       255 002123       257 002130
    258 002132       259 002133       260 002134       262 002153       263 002156       264 002160       268 002166
    269 002167       270 002176       274 002200       277 002205       278 002207       279 002212       280 002214
    281 002216       284 002217       285 002220       286 002222       287 002223       290 002225       291 002227
    294 002236       298 002237       300 002255       301 002257       302 002260       304 002261       307 002263
    308 002265       310 002267       312 002270       314 002304       315 002306       316 002307       318 002310
    321 002312       322 002314       323 002316       324 002320       326 002342       328 002345       330 002346
    332 002365       333 002367       334 002370       336 002371       339 002373       340 002375       341 002377
    343 002414       345 002415       347 002416       349 002433       352 002436       353 002440       354 002450
    355 002451       359 002454       360 002455       363 002457       364 002461       367 002463       368 002464
    370 002466       371 002467       372 002471       373 002476       374 002477       377 002502       378 002505
    380 002507       381 002512       383 002516       388 002527       390 002534       392 002535       393 002537
    396 002540       399 002542       400 002552       402 002556       403 002557       404 002561       405 002563
    406 002564       409 002565       410 002566       413 002573       414 002575       417 002600       419 002601
    422 002603       423 002604       424 002607       425 002612       427 002614       428 002615       429 002620
    432 002621       434 002625       435 002630       438 002632       440 002633       443 002637       444 002642
    445 002644       448 002645       449 002647       452 002652       453 002663       455 002667       456 002670
    458 002672       459 002673       463 002705       464 002713       465 002715       470 002717       472 002720
    475 002722       476 002723       477 002726       478 002731       480 002733       483 002734       484 002737
    485 002741       486 002743       489 002745       490 002746       493 002753       494 002755       495 002756
    498 002764       499 002765       500 002767       501 002770       504 002771       505 002774       507 002775
    509 002776       511 003021       512 003025       514 003026       517 003034       518 003036       519 003037
    523 003061       524 003064       526 003065       530 003100       531 003101       533 003103       537 003114
    538 003117       539 003122       540 003123       542 003124       545 003134       546 003136       548 003137
    549 003140       552 003146       553 003150       555 003151       560 003162       561 003170       564 003175
    567 003176       570 003201       571 003202       573 003204       574 003205       575 003207       578 003217
    579 003220       583 003225       584 003230       586 003231       587 003232       590 003237       591 003242
    594 003246       598 003250       600 003253       602 003254       605 003255       606 003257       607 003261
    608 003272       610 003304       611 003310       612 003312       613 003324       616 003331       618 003340
    619 003343       622 003344       625 003355       626 003356       627 003357       631 003366       634 003370
    635 003377       636 003412       637 003414       640 003417       641 003422       642 003427       643 003431
    644 003433       647 003434       648 003437       650 003441       651 003442       654 003445       655 003451
    657 003455       660 003456       661 003461       663 003463       666 003464       667 003470       669 003471
    672 003475       673 003476       675 003500       676 003502       680 003515       684 003523       685 003525
    686 003526       688 003531       692 003534       693 003535       694 003540       698 003542       701 003543
    704 003560       708 003563       709 003565       711 003566       713 003570       715 003573       717 003576
    720 003605       723 003606       727 003621       730 003630       731 003633       735 003634       736 003636
    737 003637       739 003644       740 003645       741 003647       742 003651       744 003664       745 003670
    746 003704       749 003714       752 003716       754 003723       755 003724       756 003726       757 003730
    759 003736       760 003737       763 003742       766 003743       767 003744       768 003745       770 003746
    771 003750       775 003751       778 003755       781 003762       784 003766       788 003772       791 003777
    794 004003       797 004007       801 004016       802 004021       803 004023       805 004025       808 004026
    811 004032       812 004037       813 004045       816 004046       819 004050       822 004054       825 004066
    826 004072       828 004100       829 004103       832 004104       835 004112       840 004123       841 004125
    842 004126       846 004135       847 004140       848 004142       849 004143       852 004145       853 004150
    859 004173       862 004174       863 004201       864 004203       865 004225       866 004227       867 004231
    868 004233       869 004235       871 004241       872 004242       874 004243       878 004244       881 004250
    882 004265       885 004266       888 004272       889 004307       892 004310       895 004314       896 004331
    899 004332       900 004335      2423 004336      2425 004341      2426 004343      2427 004347      2429 004350
   2431 004353      2432 004356      2433 004360      2439 004375      2440 004376      2441 004402      2444 004407
   2447 004410      2448 004414      2450 004423      2451 004424      2453 004434      2454 004435      2456 004445
   2458 004461      2462 004471      2464 004505      2467 004506      2469 004523      2470 004525      2471 004526
   2473 004527      2474 004530      2476 004532      2478 004535      2481 004544      2486 004565      2488 004573
   2489 004575      2492 004576      2493 004577      2495 004604      2496 004605      2497 004606      2498 004612
   2501 004614      2502 004617      2504 004621      2505 004622      2506 004626      2507 004627      2508 004636
   2509 004640      2512 004642      2515 004672      2516 004673      2517 004702      2518 004705      2519 004711
   2522 004713      2524 004736      2527 004742      2530 004743      2531 004757      2533 005001      2536 005002
   2537 005006      2538 005021      2541 005030      2545 005035      2546 005037      2548 005041      2549 005061
   2555 005073      2560 005101      2561 005103      2562 005104      2563 005105      2566 005112      2567 005122
   2568 005124      2571 005125      2572 005127      2574 005130      2577 005142      2578 005146      2581 005151
   2584 005152      2585 005154      2587 005156      2590 005157      2593 005203      2594 005205      2596 005207
   2601 005224      2603 005226      2686 005227      2688 005241      2689 005243      2690 005244      2692 005245
   2695 005251      2696 005254      2698 005255      2699 005256      2700 005257      2701 005266      2702 005272
   2703 005275      2704 005277      2707 005310      2708 005331      2711 005334      2712 005337      2715 005342
   2716 005343      2717 005344      2718 005351      2719 005352      2720 005367      2721 005372      2722 005373
   2909 005374      2911 005410      2912 005412      2913 005413      2915 005415      2916 005416      2918 005420
   2919 005423      2921 005426      2922 005430      2925 005442      2927 005447      2928 005453      2930 005454
   2933 005471      2934 005473      2935 005474      2937 005475      2938 005501      2939 005511      2940 005514
   2941 005516      2944 005521      2945 005525      2947 005542      2950 005543      2952 005546      2954 005551
   2956 005560      2959 005562      2960 005563      2964 005566      2965 005567      2966 005571      2967 005572
   2970 005575      2971 005577      2973 005603      2974 005610      2977 005611      2978 005613      2981 005615
   2982 005616      2983 005620      2985 005625      2988 005627      2989 005630      2990 005635      2991 005640
   2992 005641      2994 005653      2996 005657      2998 005664      3000 005675      3001 005677      3002 005703
   3003 005712      3006 005715      3007 005717      3008 005722      3010 005723      3013 005725      3014 005730
   3015 005733      3016 005735      3019 005737      3021 005740      3023 005763      3024 005764      3027 005767
   3029 005771      3030 005772      3032 006015      3035 006016      3036 006021      3038 006024      3041 006025
   3042 006032      3043 006035      3044 006036      3046 006041      3047 006043      3048 006045      3050 006051
   3053 006054      3056 006056      3057 006060      3058 006103      3059 006107      3060 006111      3064 006112
   3067 006114      3068 006116      3070 006141      3073 006142      3075 006167      3077 006172      3079 006174
   3080 006175      3083 006222      3084 006226      3085 006231      3087 006232      3090 006244      3091 006246
   3092 006247      3389 006250      3393 006253      3394 006256      3396 006257      3397 006261      3398 006262
   3400 006265      3401 006267      3404 006272      3407 006275      3408 006276      3410 006300      3412 006306
   3413 006307      3415 006312      3416 006315      3417 006317      3420 006321      3422 006337      3423 006342
   3427 006346      3428 006350      3431 006351      3434 006352      3435 006353      3436 006354      3437 006363
   3440 006367      3442 006370      3445 006375      3446 006400      3448 006401      3449 006402      3452 006404
   3455 006407      3456 006410      3459 006412      3461 006413      3463 006422      3466 006425      3468 006431
   3473 006440      3475 006446      3476 006451      3478 006452      3479 006453      3480 006454      3481 006456
   3482 006457      3483 006463      3485 006471      3486 006474      3487 006476      3488 006503      3491 006505
   3492 006515      3494 006521      3495 006536      3496 006541      3498 006542      3500 006543      3501 006545
   3502 006546      3504 006551      3505 006553      3508 006557      3510 006565      3511 006566      3513 006570
   3514 006572      3515 006573      3518 006576      3521 006601      3522 006602      3524 006604      3527 006612
   3530 006613      3532 006616      3534 006622      3539 006650      3540 006652      3542 006654      3543 006657
   3546 006660      3547 006661      3548 006663      3552 006673      3555 006701      3557 006706      3560 006710
   3562 006716      3563 006721      3565 006722      3567 006726      3568 006727      3571 006731      3572 006734
   3576 006735      3577 006736      3580 006740      3582 006750      3584 006751      3588 006757      3590 006765
   3591 006771      3594 006773      3595 006775      3597 006777      3600 007000      3601 007001      3602 007003
   3604 007013      3608 007014      3611 007017      3612 007021      3614 007025      3615 007027      3619 007040
   3622 007045      3623 007047      3624 007050      3625 007051      3626 007055      3628 007056      3629 007057
   3632 007064      3634 007071      3635 007073      3637 007074      3638 007075      3639 007076      3640 007100
   3641 007104      3654 007105      3656 007106      3660 007114      3663 007121      3665 007124      3667 007125
   3668 007126      3671 007130      3672 007131      3674 007134      3675 007135      3676 007137      3677 007140
   3679 007141      3681 007146      3682 007147      3684 007150      3686 007152      3691 007162      3692 007163
   3693 007165      3696 007166      3697 007167      3796 007170      3801 007174      3803 007202      3805 007210
   3806 007212      3808 007220      3813 007235      3814 007240      3817 007241      3818 007242      3819 007244
   3820 007245      3821 007247      3825 007257      3826 007261      3827 007264      3828 007266      3829 007267
   3831 007270      3832 007273      3834 007301      3835 007304      3836 007306      3837 007310      3838 007312
   3840 007313      3841 007321      3842 007323      3846 007326      3847 007327      3848 007330      3850 007334
   3853 007335      3857 007351      3858 007353      3861 007355      3862 007357      3866 007373      3869 007400
   3870 007416      3873 007423      3876 007444      3878 007451      3879 007452      3882 007453      3883 007454
   3886 007467      3888 007473      3889 007510      3890 007513      3892 007515      3893 007516      3894 007520
   3895 007526      3899 007534      3900 007555      3902 007557      3905 007574      3910 007577      3916 007610
   3917 007611      3918 007612      3920 007616      3922 007627      3925 007631      3926 007632      3927 007635
   3929 007636      3931 007637      3932 007641      3935 007643      3936 007651      3939 007653      3940 007655
   3941 007660      3942 007661      3944 007663      3945 007664      3946 007706      3947 007710      3948 007711
   3950 007716      3952 007717      3957 007730      3959 007734      3961 007735      3962 007736      3964 007737
   3966 007741      3967 007742      3970 007755      3972 007770      3973 007771      3976 007773      3977 007775
   3978 010001      3980 010002      3983 010004      3987 010012      3988 010013      3990 010024      3993 010033
   3995 010034      3996 010036      3998 010037      4000 010042      4002 010055      4004 010060      4006 010061
   4062 010062      4064 010063      4065 010065      4066 010066      4068 010071      4069 010073      4070 010074
   4072 010107      4075 010115      4078 010117      4079 010120      4082 010125      4084 010127      4086 010140
   4087 010143      4089 010152      4090 010155      4093 010160      4095 010166      4100 010214      4103 010216
   4104 010217      4108 010234      4109 010235      4110 010237      4111 010241      4112 010243      4113 010244
   4114 010245      4115 010255      4116 010256      4119 010260      4121 010266      4124 010272      4125 010274
   4126 010276      4127 010277      4128 010300      4129 010310      4132 010311      4133 010313      4134 010314
   4136 010316      4138 010323      4140 010331      4142 010336      4144 010340      4145 010343      4148 010345
   4149 010347      4150 010350      4152 010354      4154 010357      4158 010366      4160 010373      4161 010375
   4163 010376      4164 010400      4165 010402      4166 010404      4168 010406      4169 010412      4170 010415
   4174 010424      4176 010431      4177 010433      4179 010434      4180 010435      4183 010436      4184 010440
   4186 010441      4188 010446      4189 010450      4190 010451      4191 010452      4192 010454      4193 010461
   4197 010470      4198 010500      4200 010504      4204 010513      4205 010523      4207 010527      4208 010540
   4520 010541      4522 010542      4524 010550      4527 010554      4528 010565      4531 010567      4532 010572
   4533 010605      4535 010634      4537 010635      4538 010636      4540 010637      4541 010647      4542 010656
   4546 010671      4547 010674      4550 010740      4553 010741      4554 010753      4556 010756      4559 010771
   4560 010774      4563 011040      4564 011041      4567 011044      4569 011047      4571 011053      4572 011055
   4573 011057      4575 011060      4577 011070      4578 011075      4579 011077      4580 011103      4581 011104
   4582 011112      4584 011113      4585 011114      4587 011130      4588 011133      4590 011136      4593 011145
   4594 011153      4596 011157      4599 011164      4600 011173      4603 011203      4605 011216      4608 011217
   4609 011227      4610 011236      4612 011245      4614 011254      4615 011257      4616 011272      4619 011313
   4621 011317      4624 011321      4625 011326      4627 011333      4628 011334      4630 011342       902 011343
    904 011345       909 011362       913 011364       916 011367       917 011371       918 011373       919 011404
    920 011407       921 011412       924 011415       927 011425       929 011431       931 011432       932 011433
    933 011434       934 011435       939 011445       940 011447       941 011450       942 011451       944 011453
    945 011455       946 011456       948 011457       949 011462       950 011463       951 011464       952 011465
    953 011466       955 011467       956 011475       959 011507       960 011510       963 011512       966 011515
    970 011524       972 011525       978 011542       980 011553       982 011600       984 011607       986 011610
    989 011612       993 011613       997 011616       999 011617      1001 011620      1004 011621      1007 011623
   1011 011635      1015 011643      1016 011646      1018 011647      1019 011651      1020 011653      1022 011654
   1023 011657      1025 011660      1028 011665      1031 011672      1032 011674      1033 011675      1034 011677
   1035 011700      1037 011704      1038 011707      1039 011710      1040 011711      1042 011716      1046 011724
   1047 011726      1048 011734      1049 011735      1051 011736      1052 011740      1053 011741      1056 011743
   1059 011766      1060 011767      1065 012016      1066 012017      1067 012020      1068 012023      1069 012024
   1072 012035      1073 012037      1075 012040      1077 012041      1080 012052      1083 012055      1084 012066
   1087 012072      1092 012107      1094 012123      1095 012125      1096 012127      1098 012144      1099 012176
   1101 012205      1102 012206      1103 012210      1104 012212      1105 012214      1106 012215      1110 012224
   1115 012225      1117 012226      1118 012234      1119 012237      1122 012251      1123 012253      1125 012262
   1129 012310      1130 012312      1131 012314      1136 012325      1138 012326      1142 012330      1143 012331
   1145 012342      1147 012354      1154 012370      1155 012371      1157 012374      1158 012375      1160 012401
   1161 012402      1163 012417      1164 012420      1165 012425      1166 012427      1169 012433      1171 012434
   1173 012435      1174 012442      1177 012444      1179 012445      1184 012453      1185 012464      1189 012470
   1190 012472      1192 012473      1193 012477      1195 012501      1196 012522      1197 012523      1199 012524
   1202 012527      1203 012531      1205 012535      1206 012536      1209 012551      1210 012554      1213 012573
   1217 012607      1219 012614      1222 012631      1223 012632      1225 012636      1227 012647      1230 012652
   1231 012655      1233 012656      1236 012660      1238 012661      1240 012672      1241 012704      1242 012706
   1243 012707      1247 012714      1249 012722      1251 012732      1253 012733      1256 012735      1257 012737
   1259 012740      1264 012750      1265 012751      1267 012754      1268 012755      1272 012763      1273 012765
   1275 012766      1279 012775      1280 012777      1281 013000      1284 013001      1285 013017      1286 013036
   1288 013037      1292 013053      1295 013056      1296 013060      1299 013065      1301 013070      1303 013072
   1305 013073      1308 013076      1310 013103      1313 013111      1319 013133      1321 013146      1325 013156
   1326 013166      1328 013170      1331 013177      1332 013207      1333 013210      1334 013212      1335 013213
   1338 013216      1340 013227      1341 013232      1342 013233      1343 013235      1344 013236      1345 013237
   1348 013240      1350 013244      1351 013250      1353 013251      1357 013254      1359 013260      1360 013262
   1363 013266      1364 013271      1366 013272      1367 013273      1370 013276      1371 013301      1373 013302
   1374 013305      1379 013321      1380 013330      1383 013334      1385 013335      1388 013336      1389 013343
   1391 013351      1394 013355      1395 013361      1396 013363      1397 013367      1398 013372      1399 013377
   1400 013400      1401 013401      1403 013402      1405 013403      1408 013405      1411 013410      1412 013417
   1413 013422      1416 013423      1417 013425      1418 013432      1420 013435      1423 013437      1430 013440
   1432 013441      1437 013455      1439 013465      1441 013470      1443 013471      1445 013472      1448 013507
   1450 013515      1452 013516      1454 013520      1455 013523      1456 013541      1458 013545      1460 013553
   1465 013557    1    1 013560    1    8 013561    1    9 013562    1   11 013571    1   12 013573    1   13 013576
 1   15 013606    1   17 013614    1   19 013617    1   20 013623    1   21 013626    1   22 013630    1   23 013631
 1   24 013636    1   26 013637    1   27 013642    1   28 013644    1   32 013653    1   33 013657    1   34 013662
 1   37 013665    1   39 013670    1   42 013673    1   45 013674    1   46 013675    1   47 013677    1   48 013701
 1   49 013703    1   50 013705    1   51 013735    1   55 013742    1   56 013744    1   57 013746    1   58 013756
 1   61 013757    1   62 013760    1   66 013765    1   70 013776    1   74 014006    1   76 014011    1   77 014014
 1   79 014015    1   90 014016      1478 014017      1480 014021      1481 014025      1482 014027      1483 014035
   1484 014052      1487 014063      1488 014065      1490 014072      1497 014073      1499 014074      1501 014075
   1504 014110      1505 014113      1506 014115      1509 014117      1511 014125      1512 014130      1515 014133
   1516 014135      1519 014137      1521 014147      1524 014150      1525 014151      1527 014155      1528 014161
   1530 014162      1532 014163      1533 014164      1535 014165      1537 014166      1538 014174      1541 014201
   1544 014202      1545 014204      1548 014206      1550 014213      1553 014214      1556 014217      1557 014220
   1560 014224      1562 014227      1564 014232      1565 014234      1567 014235      1568 014237      1571 014240
   1572 014242      1573 014243      1576 014250      1578 014253      1580 014254      1586 014301      1589 014303
   1590 014304      1592 014305      1595 014306      1600 014307      1602 014310      1604 014311      1605 014312
   1608 014315      1609 014316      1611 014321      1612 014322      1613 014324      1614 014327      1616 014334
   1617 014336      1620 014341      1622 014345      1623 014346      1626 014350      1627 014352      1628 014354
   1631 014355      1632 014360      1633 014361      1634 014362      1636 014363      1637 014364      1640 014371
   1641 014372      1642 014375      1645 014376      1648 014404      1650 014405      1652 014406      1653 014407
   1656 014411      1661 014420      1662 014422      1665 014423      1666 014425      1668 014426      1670 014427
   1672 014430      1677 014437      1678 014441      1681 014442      1682 014444      1684 014445      1686 014446
   1687 014447      1690 014452      1691 014453      1693 014456      1694 014457      1695 014461      1696 014463
   1697 014464      1700 014470      1701 014473      1702 014474      1704 014475      1705 014477      1706 014505
   1708 014506      1710 014510      1711 014514      1712 014532      1713 014535      1715 014536      1716 014543
   1723 014575      1724 014576      1725 014577      1726 014600      1728 014603      1729 014606      1734 014607
   1736 014610      1738 014612      1740 014620      1744 014652      1745 014653      1746 014673      1754 014710
   1756 014712      1757 014723      1759 014731      1762 014733      1763 014747      1765 014752      1767 014754
   1773 014757      1775 014761      1776 014762      1780 015006      1781 015011      1785 015020      1787 015021
   1789 015022      1790 015024      1793 015035      1799 015054      1800 015100      1805 015112      1808 015127
   1811 015136      1814 015150      1817 015157      1818 015160      1822 015170      1823 015175      1824 015205
   1826 015222      1830 015231      1833 015232      1837 015244      1839 015252      1842 015263      1843 015266
   1845 015274      1850 015275      1852 015276      1854 015277      1857 015303      1858 015304      1860 015313
   1863 015315      1864 015321      1865 015322      1866 015323      1867 015324      1868 015332      1870 015341
   1871 015345      1874 015373      1875 015400      1876 015402      1878 015425      1879 015432      1883 015445
   1884 015450      1885 015451      1886 015466      1887 015471      1889 015472      1891 015475      1892 015476
   1896 015511      1898 015521      1900 015524      1904 015527      1906 015531      1907 015533      1909 015534
   1910 015536      1913 015537      1916 015542      1917 015543      1920 015546      1924 015553      1926 015555
   1930 015564      1935 015601      1937 015614      1938 015616      1940 015620      1942 015640      1944 015643
   1945 015645      1948 015647      1949 015650      1950 015651      1952 015652      1953 015657      1954 015662
   1957 015667      1958 015670      1962 015700      1964 015702      1967 015712      1969 015714      1971 015716
   1975 015731      1977 015745      1980 015752      2017 015753      1983 015754      1985 015755      1986 015760
   1987 015763      1990 015767      1991 015771      1992 015772      1993 015773      1995 015776      1998 016002
   2001 016005      2002 016007      2005 016012      2006 016014      2007 016016      2010 016020      2012 016025
   2014 016030      2019 016031      2021 016032      2024 016043      2025 016045      2028 016050      2029 016051
   2032 016056      2033 016057      2034 016062      2035 016064      2038 016065      2039 016105      2041 016107
   2043 016110      2045 016112      2046 016114      2047 016116      2048 016120      2050 016121      2052 016122
   2054 016123      2056 016127      2057 016134      2058 016140      2060 016141      2063 016142      2066 016150
   2067 016151      2068 016153      2071 016157      2072 016160      2073 016163      2075 016165      2076 016166
   2077 016167      2079 016170      2081 016171      2082 016172      2084 016200      2086 016204      2087 016206
   2088 016211      2089 016215      2092 016223      2093 016225      2094 016242      2096 016245      2097 016251
   2101 016257      2103 016277      2104 016300      2105 016301      2107 016321      2108 016323      2110 016324
   2114 016325      2116 016326      2117 016331      2118 016332      2120 016334      2121 016337      2122 016340
   2123 016341      2124 016343      2126 016344      2128 016345      2129 016350      2130 016351      2131 016354
   2133 016363      2134 016364      2135 016367      2136 016371      2138 016372      2140 016373      2141 016402
   2142 016404      2143 016415      2144 016420      2145 016422      2146 016423      2147 016425      2149 016426
   2151 016427      2152 016436      2153 016440      2154 016451      2155 016454      2156 016456      2157 016457
   2158 016461      2160 016462      2162 016464      2164 016475      2166 016507      2172 016522      2174 016523
   2176 016524      2178 016532      2180 016533      2182 016534      2183 016537      2184 016542      2185 016545
   2187 016554      2188 016555      2189 016556      2191 016566      2192 016570      2193 016574      2198 016603
   2199 016605      2200 016611      2202 016612      2204 016620      2207 016624      2208 016636      2209 016641
   2211 016647      2214 016656      2216 016657      2218 016660      2219 016663      2221 016667      2222 016672
   2223 016675      2226 016704      2229 016706      2230 016707      2231 016712      2232 016714      2233 016717
   2235 016724      2240 016725      2242 016726      2244 016727      2245 016732      2246 016733      2249 016736
   2252 016740      2253 016741      2256 016744      2259 016747      2260 016751      2261 016757      2263 016760
   2266 016762      2267 016763      2272 016771      2274 016777      2276 017000      2279 017001      2280 017005
   2281 017007      2283 017010      2285 017011      2288 017016      2289 017026      2290 017036      2293 017037
   2296 017042      2297 017056      2299 017062      2301 017070      2304 017075      2305 017104      2306 017113
   2308 017116      2309 017124      2310 017125      2311 017133      2314 017142      2316 017143      2319 017144
   2320 017145      2323 017152      2324 017154      2325 017155      2326 017164      2329 017166      2330 017167
   2332 017174      2335 017177      2336 017200      2341 017206      2344 017213      2346 017220      2348 017225
   2351 017227      2352 017231      2353 017247      2354 017252      2357 017254      2358 017255      2361 017260
   2362 017263      2363 017264      2364 017266      2366 017270      2369 017271      2373 017300      2374 017303
   2375 017312      2376 017313      2379 017314      2382 017315      2383 017325      2386 017331      2390 017334
   2391 017335      2394 017340      2395 017342      2397 017343      2399 017345      2400 017351      2401 017367
   2402 017372      2404 017375      2405 017377      2407 017400      2408 017402      2410 017414      2411 017415
   2412 017416      2414 017425      2416 017447      2417 017450      2421 017451      2605 017452      2607 017454
   2609 017461      2611 017466      2614 017471      2619 017510      2622 017515      2625 017530      2627 017531
   2630 017541      2632 017547      2633 017551      2636 017554      2637 017561      2638 017563      2640 017564
   2648 017571      2650 017572      2652 017573      2655 017576      2656 017577      2658 017600      2659 017603
   2660 017604      2661 017606      2663 017607      2665 017610      2669 017615      2670 017621      2671 017625
   2672 017631      2673 017634      2674 017636      2676 017643      2678 017644      2680 017646      2681 017656
   2684 017663      2724 017664      2726 017665      2729 017672      2730 017675      2732 017676      2734 017677
   2736 017700      2737 017703      2738 017707      2739 017711      2740 017712      2744 017717      2745 017720
   2749 017723      2751 017724      2754 017726      2755 017731      2758 017734      2759 017735      2761 017736
   2762 017740      2763 017742      2766 017745      2768 017753      2771 017756      2772 017760      2773 017762
   2774 017763      2775 017764      2778 017767      2779 017776      2780 020001      2781 020002      2782 020003
   2783 020007      2784 020011      2787 020012      2789 020014      2790 020015      2791 020016      2793 020017
   2794 020024      2795 020027      2798 020031      2799 020034      2800 020037      2802 020040      2803 020043
   2804 020046      2805 020047      2806 020051      2807 020053      2808 020055      2810 020056      2812 020057
   2813 020062      2816 020063      2817 020065      2818 020074      2820 020102      2823 020107      2826 020112
   2828 020114      2829 020115      2832 020116      2833 020124      2835 020127      2841 020130      2844 020131
   2845 020132      2849 020141      2850 020142      2853 020144      2855 020147      2859 020150      2862 020153
   2863 020154      2865 020156      2868 020157      2869 020161      2871 020162      2873 020163      2875 020164
   2877 020165      2878 020176      2881 020203      2882 020204      2883 020206      2884 020207      2886 020215
   2889 020232      2895 020233      2897 020234      2899 020235      2902 020240      2903 020241      2905 020242
   2906 020246      2907 020250      3095 020251      3097 020252      3100 020255      3102 020270      3103 020271
   3105 020272      3106 020275      3108 020301      3111 020313      3112 020321      3113 020323      3115 020324
   3117 020326      3118 020327      3119 020333      3120 020334      3124 020341      3125 020342      3126 020344
   3127 020345      3128 020346      3131 020352      3132 020354      3135 020356      3136 020360      3137 020361
   3138 020362      3140 020370      3141 020373      3142 020400      3145 020402      3148 020404      3149 020406
   3152 020433      3153 020435      3156 020442      3158 020443      3159 020466      3162 020471      3163 020472
   3165 020473      3168 020476      3170 020503      3172 020504      3174 020510      3177 020511      3179 020536
   3182 020541      3183 020542      3186 020543      3189 020544      3190 020546      3193 020563      3195 020571
   3196 020574      3197 020601      3200 020603      3201 020613      3204 020617      3207 020622      3208 020623
   3209 020624      3212 020633      3213 020650      3214 020653      3217 020661      3219 020662      3221 020663
   3222 020666      3225 020671      3230 020725      3231 020726      3233 020727      3234 020732      3237 020736
   3238 020737      3239 020741      3242 020743      3243 020751      3244 020753      3245 020755      3247 020757
   3252 021001      3254 021005      3255 021006      3258 021014      3259 021015      3261 021031      3262 021032
   3263 021034      3265 021043      3266 021050      3268 021056      3269 021057      3271 021065      3274 021070
   3275 021072      3276 021074      3277 021075      3278 021076      3279 021103      3280 021112      3281 021115
   3282 021120      3283 021126      3287 021136      3288 021143      3290 021152      3293 021155      3294 021156
   3295 021161      3296 021201      3297 021210      3298 021212      3299 021213      3300 021216      3301 021217
   3303 021221      3305 021222      3307 021224      3308 021227      3310 021244      3312 021246      3313 021250
   3314 021251      3315 021254      3318 021263      3323 021312      3324 021313      3325 021316      3326 021321
   3327 021323      3328 021325      3330 021331      3332 021333      3333 021334      3334 021337      3335 021341
   3346 021342      3348 021343      3351 021346      3352 021347      3353 021350      3356 021356      3357 021373
   3358 021376      3359 021400      3361 021401      3363 021402      3364 021405      3367 021410      3368 021411
   3370 021412      3371 021414      3372 021416      3373 021420      3374 021422      3376 021423      3378 021424
   3379 021430      3380 021433      3381 021443      3382 021446      3383 021453      3384 021455      3387 021457
   3643 021460      3646 021461      3649 021467      3650 021472      3652 021473      3699 021474      3701 021475
   3704 021500      3707 021504      3708 021506      3710 021513      3711 021515      3712 021516      3714 021524
   3716 021530      3718 021532      3721 021541      3725 021547      3727 021562      3729 021572      3731 021573
   3733 021574      3735 021575      3738 021600      3739 021602      3740 021607      3742 021610      3743 021611
   3744 021612      3745 021620      3746 021623      3748 021633      3749 021641      3753 021653      3754 021654
   3755 021655      3756 021656      3757 021657      3758 021661      3760 021662      3761 021667      3762 021671
   3763 021673      3765 021674      3767 021675      3768 021676      3769 021705      3770 021707      3771 021710
   3772 021713      3774 021723      3775 021734      3776 021735      3778 021752      3779 021753      3780 021754
   3782 021755      3783 021762      3784 021764      3785 021766      3786 021770      4008 021771      4010 021772
   4011 022017      4013 022026      4014 022036      4015 022125      4016 022147      4017 022166      4024 022171
   4026 022172      4028 022173      4031 022202      4032 022232      4034 022236      4037 022241      4038 022242
   4040 022261      4043 022262      4044 022314      4046 022320      4049 022323      4050 022324      4053 022343
   4055 022344      4057 022345      4059 022350      4060 022356      4210 022357      4212 022360      4215 022363
   4216 022365      4217 022366      4219 022367      4221 022376      4224 022401      4225 022404      4226 022406
   4227 022407      4228 022411      4232 022420      4233 022422      4235 022424      4236 022426      4237 022430
   4238 022433      4239 022435      4240 022437      4242 022440      4245 022442      4246 022443      4247 022446
   4248 022447      4250 022451      4251 022452      4252 022453      4253 022454      4255 022456      4256 022460
   4257 022461      4261 022470      4262 022501      4264 022507      4265 022514      4267 022520      4268 022525
   4269 022527      4270 022531      4271 022535      4274 022537      4275 022541      4276 022543      4277 022545
   4278 022575      4281 022610      4283 022611      4284 022616      4285 022620      4286 022623      4287 022632
   4294 022652      4295 022656      4296 022660      4299 022665      4300 022667      4303 022670      4304 022672
   4305 022674      4307 022701      4309 022703      4314 022732      4315 022737      4316 022741      4319 022743
   4321 022746      4324 022751      4325 022753      4326 023006      4330 023016      4334 023017      4335 023021
   4336 023023      4338 023053      4343 023066      4345 023070      4346 023072      4347 023124      4354 023134
   4357 023135      4358 023142      4359 023144      4363 023171      4364 023174      4367 023175      4368 023202
   4369 023204      4370 023206      4372 023214      4373 023244      4376 023254      4378 023255      4382 023256
   4383 023272      4384 023300      4385 023301      4386 023303      4387 023305      4388 023307      4389 023310
   4390 023313      4391 023315      4392 023321      4393 023351      4398 023361      4399 023363      4400 023365
   4401 023370      4402 023423      4404 023431      4407 023432      4408 023434      4409 023440      4410 023470
   4412 023476      4430 023501      4458 023502      4460 023510      4461 023516      4462 023520      4463 023525
   4465 023530      4466 023532      4469 023544      4474 023577      4480 023603      4484 023611      4490 023644
   4496 023650      4500 023656      4502 023657      4504 023665      4505 023677      4506 023702      4507 023707
   4508 023712      4510 023723      4514 023731      4515 023733      4517 023735      4518 023740      4632 023741
   4634 023742      4635 023750      4636 023755      4637 023760      4639 023762      4640 023766      4641 023771
   4642 023774      4643 023775      4645 023777      4646 024003      4647 024006      4648 024011      4649 024014
   4650 024017      4651 024020      4653 024022      4654 024026      4655 024031      4656 024034      4657 024037
   4658 024042      4659 024043      4661 024045      4662 024051      4663 024054      4664 024055      4666 024057
   4667 024063      4668 024066      4669 024071      4670 024074      4671 024077      4672 024102      4673 024105
   4674 024110      4675 024113      4676 024114      4678 024117      4679 024122      4680 024125      4681 024126
   4683 024131      4684 024134      4685 024135      4687 024140      4688 024143      4689 024146      4690 024151
   4691 024154      4692 024157      4694 024160      4696 024161      4697 024162      4698 024200      4699 024205
   4700 024210      4701 024214      4702 024215      4703 024220      4704 024222      4705 024225      4706 024232
   4707 024235      4708 024236      4709 024237      4710 024240      4711 024247      4712 024253      4713 024254
   4714 024261      4715 024262      4716 024270      4717 024272      4718 024274      4719 024276      4720 024277
   4721 024300      4722 024301      4723 024302      4724 024317      4725 024323      4726 024327      4727 024331
   4728 024332      4729 024346      4730 024350      4731 024352      4732 024356      4733 024357      4734 024360
   4735 024361      4736 024362      4737 024364      4738 024375      4740 024403      4741 024405      4742 024407
   4743 024411      4744 024413      4745 024414      4754 024415      4755 024423      4765 024503      4767 024510
   4774 024555      4775 024562      4777 024563      4779 024565      4781 024572      4782 024603      4786 024613
   4788 024643      4789 024655      4790 024667      4793 024672      4795 024673      4797 024674      4798 024677
   4799 024702      4800 024704      4801 024706      4802 024710      4803 024713      4804 024723      4805 024732
   4806 024735      4807 024751      4808 024770      4809 024773      4815 024774      4817 024775      4818 024777
   4820 025004      4822 025005      4824 025016      4826 025022      4827 025023      4828 025066      4829 025073
   4830 025075      4832 025077      4833 025101


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
