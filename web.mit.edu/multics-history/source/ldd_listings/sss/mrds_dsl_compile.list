	COMPILATION LISTING OF SEGMENT mrds_dsl_compile
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1327.4 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
        9*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       10*     This entry is being made to cover the change made on 85-03-04 by
       11*     John Hergert (mrds #144)
       12*  2) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       13*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       14*     Added the mrds_start_transaction and mrds_finish_transaction
       15*     include files. (see mrds #142, phx19907)
       16*  3) change(86-07-16,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
       17*     install(86-08-15,MR12.0-1127):
       18*     85-11-22 Hergert: Removed all references to var_exists_ptr. Moved
       19*     variable var_exists into select_list structure. This was done to
       20*     fix the bug where compiled set expressions that referenced a different
       21*     set of relations would fail to execute properly. (mrds #158)
       22*                                                   END HISTORY COMMENTS */
       23 
       24 mrds_dsl_compile:
       25 compile:
       26      proc;
       27 
       28 /* (database_index, selection_expression, se_index, values,...., values, code)
       29*
       30*   DESCRIPTION
       31*
       32* The purpose of this procedure is to implement the dsl_$compile function. 
       33* This procedure creates an argument list for and calls translate, then 
       34* squirrels away the translated selection expression for future use by others.
       35*
       36*
       37*   HISTORY:
       38*
       39* 84-09-01 Originally written by John Hergert.
       40*
       41* 85-03-04 John Hergert Fixed bug that failed to detect the condition when
       42* se_index was equal to 1 on the first call to dsl_$compile. It failed to
       43* return mrds_error_$no_sel_exp.
       44*
       45*   INPUT CONDITIONS:
       46*
       47* database_index is the index of the database the caller wishes to compile
       48* a selection expression for.
       49*
       50* selection_expression is the expression supplied by the user to be compiled.
       51*
       52* se_index is the index of the selection expression.
       53*
       54* values are the indices (if any) of the temp rels used in the se 
       55*
       56*
       57*   OUTPUT DEFINITIONS:
       58*
       59* If no errors are encountered the selection expression was sucessfully 
       60* compiled.
       61*
       62* se_index is the index of the selection expression just compiled.
       63*
       64* code = 0; if no errors were detected.
       65*
       66* code = error_table_$bad_ptr; if the dbcbw_ptr could not be obtained.
       67*
       68* code = mrds_error_$invalid_db_index; if no dbcb_ptr was found for the 
       69* database index.
       70*
       71* If less then 4 arguments were passed to this procedure the condition 
       72* arg_error will be signaled.
       73*
       74* code = something else; if another error is detected by this module. 
       75*
       76**/
       77 
       78 	area_ptr, dbcb_ptr = null;
       79 	call cu_$arg_list_ptr (al_ptr);		/* Get pointer to this proc arg list */
       80 	if al_ptr = null then signal arg_error;		/* This returns you to command level */
       81 
       82 	nargs = arg_list.arg_count / 2;		/* Get the number of arguments to this proc */
       83 	if nargs < 4 then signal arg_error;		/* This returns to command level */
       84 
       85 	if arg_list.code = 4
       86 	then num_ptrs = arg_list.arg_count;		/* Determine number of ptrs in arg list */
       87 	else num_ptrs = arg_list.arg_count + 1;
       88 
       89 	call cu_$arg_ptr (nargs, cd_ptr, arg_len, icode); /* Get pointer to callers return code */
       90 	if icode ^= 0 then signal arg_error;		/* This returns to command level */
       91 
       92 	call cu_$arg_ptr (1, dbi_ptr, arg_len, icode);	/* Get pointer to database index */
       93 	if icode ^= 0 then call error (icode);
       94 
       95 	call cu_$arg_ptr (2, se_ptr, se_len, icode);	/* Get pointer to selection expression */
       96 	if icode ^= 0 then call error (icode);
       97 
       98 	if arg_list.code = 4			/* Get se descriptor */
       99 	then desc_ptr = arg_list.arg_des_ptr (nargs + 2);
      100 	else desc_ptr = arg_list.arg_des_ptr (nargs + 3);
      101 
      102 	if descriptor.type = 22 then do;		/* if char var */
      103 		se_len_ptr = addrel (se_ptr, -1);	/* get current length of varying string */
      104 		se_len = se_len_ptr -> fb35u;
      105 	     end;
      106 
      107 	call cu_$arg_ptr (3, se_index_ptr, arg_len, icode); /* Get pointer to selection expression index */
      108 	if icode ^= 0 then call error (icode);
      109 
      110 	if nargs > 4 then do;			/* If we have any values get pointer to them */
      111 		appl_ptr = addr (arg_list.arg_des_ptr (4));
      112 
      113 		if arg_list.code = 4		/* and their descriptors */
      114 		then adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 4));
      115 		else adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 5));
      116 	     end;
      117 	else adpl_ptr, appl_ptr = null;
      118 
      119 	num_args = nargs - 4;			/* Number of args passed to translate */
      120 
      121 	call mu_database_index$get_resultant_model_pointer (database_index,
      122 	     dbcb_ptr);				/* Get the dbcb pointer */
      123 	if dbcb_ptr = null then call error (mrds_error_$invalid_db_index);
      124 
      125 
      126 	compiled_se_info_ptr = dbcb.compiled_se_info_ptr;
      127 	if se_index >= 0 then do;			/* were compiling an se */
      128 
      129 		dbi_pic = dbcb.dbi;
      130 		if dbcb.compiled_se_info_ptr = null () then do; /* get a place to put compiled selection expressions */
      131 						/* if we dont already have one */
      132 			call mu_define_area$define_temp_dir_area (
      133 			     dbcb.compiled_se_info_ptr,
      134 			     database_index, (sys_info$max_seg_size), "MRDS" || dbi_pic,
      135 			     "0"b /* not extensible */, "1"b /* no freeing */, "0"b,
      136 			     "0"b /* no zeroing */, icode);
      137 			if icode ^= 0 then call error (icode);
      138 
      139 			compiled_se_info_ptr = dbcb.compiled_se_info_ptr;
      140 						/* initialize our new cse area */
      141 			compiled_se_info.real_select_area_ptr = dbcb.select_area_ptr;
      142 			compiled_se_info.number_of_compiled_se = 1;
      143 			compiled_se_info.compile_area_ptr = null;
      144 			compiled_se_info.se_info.seg_ptr (1) = null;
      145 			compiled_se_info.se_info.saved_ptrs (1) = null;
      146 			compiled_se_info.se_info.free (1) = "1"b;
      147 			compiled_se_info.se_info.dup_retain (1) = "0"b;
      148 
      149 			call get_cse_area (1);	/* get an area for the cse */
      150 		     end;
      151 
      152 /* get a work area */
      153 
      154 		call mu_define_area$define_temp_dir_area (
      155 		     compiled_se_info.compile_area_ptr,
      156 		     database_index, (sys_info$max_seg_size), "MRDS" || dbi_pic,
      157 		     "0"b /* not extensible */, "1"b /* no freeing */, "0"b,
      158 		     "0"b /* no zeroing */, icode);
      159 		if icode ^= 0 then call error (icode);
      160 		area_ptr = compiled_se_info.compile_area_ptr;
      161 
      162 		on cleanup call cleanup_handler;
      163 
      164 		if se_index = 0 then do;		/* If new compiled se */
      165 			sei = 0;
      166 			do i = 1 to compiled_se_info.number_of_compiled_se;
      167 			     if compiled_se_info.se_info.free (i) & sei = 0
      168 			     then do;
      169 				     sei = i;
      170 				     compiled_se_info.se_info.free (sei) = "0"b;
      171 				     dbcb.select_area_ptr, compiled_se_info.se_info.select_area_ptr (sei) =
      172 					pointer (compiled_se_info.se_info.seg_ptr (sei), rel (compiled_se_info.real_select_area_ptr));
      173 				     call mrds_dsl_delete_se (dbcb_ptr, (mrds_data_$caller_compile), icode);
      174 				     if icode ^= 0 then call error (icode);
      175 				end;
      176 			end;
      177 			if sei = 0 then do;		/* cant reuse a deleted one */
      178 				compiled_se_info.number_of_compiled_se =
      179 				     /* so make a new one */
      180 				     compiled_se_info.number_of_compiled_se + 1;
      181 				sei = compiled_se_info.number_of_compiled_se;
      182 
      183 				compiled_se_info.se_info.free (sei) = "0"b;
      184 
      185 				call get_cse_area (sei);
      186 			     end;
      187 		     end;
      188 		else do;				/* redefining an old se */
      189 			if (se_index <= compiled_se_info.number_of_compiled_se) &
      190 			^(compiled_se_info.se_info.free(se_index))
      191 			then do;
      192 				sei = se_index;
      193 				dbcb.select_area_ptr = compiled_se_info.se_info.select_area_ptr (sei);
      194 				call mrds_dsl_delete_se (dbcb_ptr, (mrds_data_$caller_compile), icode);
      195 				if icode ^= 0 then call error (icode);
      196 			     end;
      197 			else call error (mrds_error_$no_sel_exp);
      198 		     end;
      199 
      200 	     end;
      201 	else do;					/* deleteing a compiled se */
      202 		if dbcb.compiled_se_info_ptr = null then call error (mrds_error_$no_sel_exp);
      203 		sei = -se_index;
      204 		if sei <= compiled_se_info.number_of_compiled_se
      205 		     & ^compiled_se_info.se_info.free (sei)
      206 		then do;
      207 			compiled_se_info.se_info.saved_ptrs (sei) = null;
      208 						/* remove all references to the seg */
      209 			compiled_se_info.se_info.free (sei) = "1"b;
      210 			compiled_se_info.se_info.dup_retain (sei) = "0"b;
      211 						/* indicate this seg is free now */
      212 			code = 0;
      213 		     end;
      214 		else call error (mrds_error_$no_sel_exp);
      215 
      216 		return;				/* nothing else to do here */
      217 	     end;
      218 
      219 	mstxn_transactions_needed = dbcb.transactions_needed;
      220 	on cleanup begin;
      221 	     call mstxn_cleanup;
      222 	     call cleanup_handler;
      223 	end;
      224 	on any_other call mstxn_any_other;
      225 
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      226 
      227 	if mstxn_code ^= 0
      228 	then call error (mstxn_code);
      229 
      230 	call mrds_dsl_translate (dbcb_ptr, area_ptr,
      231 	     (mrds_data_$caller_compile), se_ptr, se_len, appl_ptr, adpl_ptr,
      232 	     num_args, icode);
      233 	mftxn_code = icode;
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      234 
      235 	if icode ^= 0 then call error (icode);
      236 
      237 /* save the world for others */
      238 
      239 	compiled_se_info.se_info.saved_ptrs.range_ptr (sei) = dbcb.range_ptr;
      240 	compiled_se_info.se_info.saved_ptrs.select_ptr (sei) = dbcb.select_ptr;
      241 	compiled_se_info.se_info.saved_ptrs.ti_ptr (sei) = dbcb.ti_ptr;
      242 	compiled_se_info.se_info.saved_ptrs.ss_ptr (sei) = dbcb.ss_ptr;
      243 	compiled_se_info.se_info.saved_ptrs.so_ptr (sei) = dbcb.so_ptr;
      244 	compiled_se_info.se_info.saved_ptrs.lit_ptr (sei) = dbcb.lit_ptr;
      245 	compiled_se_info.se_info.se_id_num (sei) = dbcb.last_s_e_id_num;
      246 	compiled_se_info.se_info.dup_retain (sei) = dbcb.dup_retain;
      247 	compiled_se_info.se_info.x_leaf_ptr (sei) = compiled_se_info.temp_x_leaf_ptr;
      248 	compiled_se_info.se_info.temp_rel_list_ptr (sei) = compiled_se_info.temp_temp_rel_list_ptr;
      249 
      250 	dbcb.select_area_ptr = compiled_se_info.real_select_area_ptr; /* cleanup after ourselves */
      251 	compiled_se_info.temp_temp_rel_list_ptr,
      252 	     compiled_se_info.temp_x_leaf_ptr = null;
      253 	call mrds_dsl_delete_se (dbcb_ptr, mrds_data_$caller_compile, icode);
      254 	if icode ^= 0 then call error (icode);
      255 
      256 	if compiled_se_info.compile_area_ptr ^= null
      257 	then call mu_release_area (compiled_se_info.compile_area_ptr);
      258 
      259 	se_index = sei;
      260 	code = 0;					/* evevrythings OK */
      261 compile_exit:
      262 	return;
      263 
      264 get_cse_area:
      265      proc (index);
      266 
      267 /* get an area for the new compiled selection expression
      268*   (dbcb.select_area_ptr).  We cant use the one supplied to us by
      269*   dsl_init_res because it is expecting to be reused and we want to save it.
      270**/
      271 
      272 	dcl     index		 fixed bin (35);
      273 
      274 	call mu_temp_segments$get_temp_segment (database_index, /* get a place to put thge compiled se */
      275 	     "MRDS" || dbi_pic, compiled_se_info.se_info.seg_ptr (index), icode);
      276 	if icode ^= 0 then call error (icode);
      277 
      278 	compiled_se_info.se_info.saved_ptrs.select_area_ptr (index), dbcb.select_area_ptr = /* start the new area at the same offset the old starts in */
      279 	     pointer (compiled_se_info.se_info.seg_ptr (index), rel (dbcb.select_area_ptr));
      280 
      281 	dbcb.new_select_expr = "1"b;			/* tell search to start new tid_list management period */
      282 	dbcb.last_s_e_id_num = mod (dbcb.last_s_e_id_num + 1, 999999); /* increment the select expr ID for current S.E. */
      283 
      284 	call mrds_dsl_init_select_area (dbcb_ptr, icode); /* and initialize it */
      285 	if icode ^= 0 then call error (icode);
      286 
      287      end get_cse_area;
      288 
      289 error:
      290      proc (cd);
      291 
      292 	dcl     cd		 fixed bin (35);	/* (INPUT) error code */
      293 
      294 	code = cd;				/* Return the error code to caller */
      295 	call cleanup_handler;			/* Tidy up before we leave */
      296 	goto compile_exit;				/* Exit mrds_dsl_compile */
      297 
      298      end error;
      299 
      300 cleanup_handler:
      301      proc;
      302 
      303 	if dbcb_ptr ^= null then do;
      304 		if dbcb.compiled_se_info_ptr ^= null
      305 		then if compiled_se_info.compile_area_ptr ^= null
      306 		     then call mu_release_area (compiled_se_info.compile_area_ptr);
      307 		call mrds_dsl_delete_se (dbcb_ptr, mrds_data_$caller_compile, icode);
      308 	     end;
      309 
      310 	return;
      311 
      312      end cleanup_handler;
      313 
      314 restore_significant_data: proc;
      315 
      316 	return;
      317 
      318      end restore_significant_data;
      319 
      320 should_rollback: proc () returns (bit (1));
      321 
      322 	return ("0"b);
      323 
      324      end should_rollback;
      325 
  5     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  5     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  5     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  5     9*     Nguyen. The scopes_changed flag was added to make checking for this
  5    10*     more efficient (mrds error list #137).
  5    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  5    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  5    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  5    14*     care if multiple txns use the same selection_expression. (mrds #156)
  5    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  5    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  5    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  5    18*                                                   END HISTORY COMMENTS */
  5    19 
  5    20 
  5    21 /* WARNING
  5    22*          If the dbcb structure is changed then the mrds_data_
  5    23*          item saved_res_version MUST be incremented to invalidate all
  5    24*          existing saved resultants
  5    25**/
  5    26 
  5    27 /* HISTORY :
  5    28*
  5    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  5    30*   tid_list management
  5    31*
  5    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  5    33*   phony resultant in mu_database_index, without having the area dcl
  5    34*   included.
  5    35*
  5    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  5    37*   mrds_dsl_store
  5    38*
  5    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  5    40*   switches
  5    41*
  5    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  5    43*   expression,  so  that relation statistics can be updated relative
  5    44*   to number of selection expressions seem. Also  removed  init  for
  5    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  5    46*   mrds_dsl_init_res.
  5    47*
  5    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  5    49*
  5    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  5    51*   for the conversion to the relation manager.
  5    52*
  5    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  5    54*   substructures so that the entries and costs can change
  5    55*   depending on the type of database that is opened.
  5    56*
  5    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  5    58*   since modify uses a different vector type (general) than does store.
  5    59*
  5    60*   82-09-20 Davids: changed names of (store modify)_vector to
  5    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  5    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  5    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  5    64*   during the first call.
  5    65*
  5    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  5    67*   since it deals with the pointers to the cursors and not the cursors
  5    68*   themelves and added the element cursor_storage_area_ptr which points
  5    69*   to the area where the cursors are kept.
  5    70*
  5    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  5    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  5    73*   anything.
  5    74*
  5    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  5    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  5    77*   by mrds_dsl_define_temp_rel.
  5    78*
  5    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  5    80*   is needed by mu_store.
  5    81*
  5    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  5    83*   bin to float bin since the values are not integers.
  5    84*
  5    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  5    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  5    87*   added to the end of the structure to allow modules that don't use
  5    88*   the element to continue to reference the dbcb structure without recompiling.
  5    89*
  5    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  5    91*   are needed so that temp rels can be created with the same file attributes
  5    92*   as the permanent relations.
  5    93*
  5    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  5    95*   added the resultant_in_pdir bit.
  5    96*
  5    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  5    98*   added the res_already_made element.
  5    99*
  5   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  5   101*
  5   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  5   103*   one of the unused pointers.
  5   104*
  5   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  5   106*
  5   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  5   108*   leaving unused_ptrs(1).
  5   109*
  5   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  5   111*   unused_ptrs (1).
  5   112*
  5   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  5   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  5   115*   spare ptrs, entries and reserved storages for future enhancement, since
  5   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  5   117*
  5   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  5   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  5   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  5   121**/
  5   122 
  5   123 
  5   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  5   125*   that constitutes the non-secure portion of the resultant model that is
  5   126*   created during the opening of a database. it contains variables that
  5   127*   are used during the runtime access of the database, and an area
  5   128*   for evaluation of requests. it points to four other
  5   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  5   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  5   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  5   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  5   133*   used in the elimination of duplicate tuples during a retrieve.
  5   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  5   135*   that is used when the database is using the file scope mechanism
  5   136*   for concurrency control over file readying. the segment overlayed via
  5   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  5   138*   across database openings. the pointer to this dbcb structure is kept in a table
  5   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  5   140*   opening instances of resultant models. (see mu_database_index routine) */
  5   141 
  5   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  5   143 	     2 data	      like dbcb_data,
  5   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  5   145 
  5   146      dcl	   dbcb_ptr	      ptr;
  5   147 
  5   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  5   149*						   like references can avoid getting the area declaration */
  5   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  5   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  5   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  5   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  5   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  5   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  5   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  5   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  5   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  5   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  5   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  5   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  5   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  5   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  5   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  5   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  5   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  5   167*						   for eliminating duplicate tuples. */
  5   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  5   169*						   for eliminating duplicate tuples. */
  5   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  5   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  5   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  5   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  5   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  5   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  5   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  5   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  5   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  5   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  5   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  5   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  5   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  5   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  5   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  5   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  5   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  5   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  5   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  5   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  5   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  5   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  5   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  5   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  5   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  5   195 	     2 val_del	      bit (1) unal,		/* for delete */
  5   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  5   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  5   198*                                                                     not imply that the database is of type page_file */
  5   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  5   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  5   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  5   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  5   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  5   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  5   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  5   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  5   207*						   inside a sequence of -another selection expression. */
  5   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  5   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  5   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  5   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  5   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  5   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  5   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  5   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  5   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  5   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  5   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  5   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  5   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  5   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  5   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  5   223 	     2 relmgr_entries,			/* relation manager entries */
  5   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  5   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  5   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  5   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  5   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  5   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  5   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  5   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  5   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  5   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  5   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  5   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  5   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  5   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  5   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  5   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  5   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  5   241 	       3 reserved_entries (5) entry (),
  5   242 	     2 access_costs,			/* access costs for permute */
  5   243 	       3 total_primary_key_cost float bin,
  5   244 	       3 access_cost      float bin,
  5   245 	       3 access_overhead  float bin,
  5   246 	       3 us_access_cost   float bin,
  5   247 	       3 os_access_cost   float bin,
  5   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  5   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  5   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  5   251 
  5   252 /* END mrds_dbcb.incl.pl1 */
  5   253 
  5   254 
      326 
      327 
  6     1 /* Begin mrds_compiled_se_info.incl.pl1 -- John Hergert 09/01/84
  6     2*   Data structure to hold all pertinent information regarding compiled
  6     3*   selection expressions. Most of this information is put into the dbcb
  6     4*   variables having the same names when the compiled selection is referenced.
  6     5**/
  6     6 
  6     7 
  6     8 /****^  HISTORY COMMENTS:
  6     9*  1) change(87-01-22,Hergert), approve(88-05-19,MCR7903),
  6    10*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  6    11*     Removed all references to var_exists_ptr.
  6    12*                                                   END HISTORY COMMENTS */
  6    13 
  6    14 
  6    15 dcl     1 compiled_se_info	 aligned based (compiled_se_info_ptr),
  6    16           2 real_select_area_ptr ptr,                       /* the real one assigned at open time */
  6    17 	2 compile_area_ptr	 ptr,			/* run time work area */
  6    18           2 temp_x_leaf_ptr    ptr,                         /* temp place to hold ptr to pred_leaf_list of .x.'s */
  6    19           2 temp_temp_rel_list_ptr ptr,                     /* temporary holding spot for list of temp rels */
  6    20 	2 number_of_compiled_se                           /* count of number of cse's weve had in this opening */
  6    21 			 fixed bin (35),
  6    22 
  6    23 
  6    24 	2 se_info		 (1                           /* various peices of information needed to describe the se */
  6    25 			 refer (compiled_se_info.number_of_compiled_se)),
  6    26             3 free             bit(1) unal,                 /* indicates whether this se is being used or not */
  6    27             3 dup_retain       bit(1) unal,                 /* se had a -dup in it */
  6    28             3 reserved         bit(34) unal,                /* a few spares */
  6    29             3 se_id_num        fixed bin(35),               /* the unique id num for the se */
  6    30 	  3 seg_ptr	 ptr,			/* points to seg that has compiled se */
  6    31 	  3 saved_ptrs,				/* these point to the various tables in the seg */
  6    32 	    5 select_area_ptr
  6    33 			 ptr,
  6    34 	    5 range_ptr	 ptr,
  6    35 	    5 select_ptr	 ptr,
  6    36 	    5 ti_ptr	 ptr,
  6    37 	    5 ss_ptr	 ptr,
  6    38               5 so_ptr         ptr,
  6    39               5 temp_rel_list_ptr ptr,
  6    40               5 x_leaf_ptr     ptr,                         /* ptr to list of ptrs to pred leaves for .x.'s */
  6    41               5 lit_ptr        ptr,
  6    42               5 reserved       (5) ptr;
  6    43 
  6    44 dcl     compiled_se_info_ptr	 ptr;
  6    45 
  6    46 
  6    47 
  6    48 /* info relating to the attributes and the literal for filling .X.'s */
  6    49 
  6    50 dcl  1 x_pred_leaf  based (x_pred_leaf_ptr) aligned,
  6    51        2 number_of_x fixed bin (35),                       /* number of .x. specified in this selection expr */
  6    52        2 lit_arg_ptr ptr,                                  /* temp pointer to literal arg */
  6    53        2 lit_desc_ptr ptr,                                  /* temp pointer to literal desc */
  6    54        2 info (mrds_data_$max_pred_nodes refer (x_pred_leaf.number_of_x)), /* this should be big enough */
  6    55          3 encode_proc bit unal,                            /* does this .x. have to be encoded */
  6    56          3 pad bit(35) unal,
  6    57          3 encode_entry entry,                              /* encode proc */
  6    58          3 encode_in_desc_ptr ptr,                          /* ptr to input to encode descrptior */
  6    59          3 encode_out_desc_ptr ptr,                         /* ptr to encoded descrptior */
  6    60          3 encode_bit_len fixed bin(35),                    /* length in bits of encoded value */
  6    61          3 lit_val_len fixed bin(35),                       /* length of value in bits to go in lit pool */
  6    62          3 lit_val_ptr ptr;                                 /* ptr to value in lit pool */
  6    63  
  6    64 
  6    65 dcl     x_pred_leaf_ptr     ptr;
  6    66 
  6    67 
  6    68 /* array of names for the temp rels used in a cse */
  6    69 /* these are used to make sure the temp isnt redefined on us after the se is compiled */
  6    70 dcl  1 temp_rel_list based (trl_ptr) aligned,   
  6    71        2 number_of_temp_rels fixed bin(35),  /* total number of temp rels in se including sets */
  6    72        2 temp_rel_info (mrds_data_$max_temp_rels) ,
  6    73          3 name char(32),                    /* model name */
  6    74          3 index fixed bin(35);              /* temp rel index */
  6    75 
  6    76 
  6    77 dcl trl_ptr ptr;
      328 
      329 
  7     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
  7     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
  7     3 
  7     4 /* layout of argument list for IDS and DBM entries with options (variable) */
  7     5 
  7     6 dcl 1 arg_list based (al_ptr),
  7     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
  7     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
  7     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
  7    10     2 pad fixed bin (17) unal,			/* must be 0 */
  7    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
  7    12 
  7    13 dcl  al_ptr ptr;
  7    14 dcl  num_ptrs fixed bin;
  7    15 
  7    16 /* END mdbm_arg_list.incl.pl1  */
  7    17 
      330 
      331 
  8     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  8     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  8     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  8     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  8     5 
  8     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  8     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  8     8     2 type unsigned fixed bin (6) unal,			/* data type */
  8     9     2 packed bit (1) unal,				/* on if data item is packed */
  8    10     2 number_dims bit (4) unal,			/* dimensions */
  8    11     2 size,					/* size for string data */
  8    12       3 scale bit (12) unal,				/* scale for num. data */
  8    13       3 precision bit (12) unal,			/* prec. for num. data */
  8    14     2 array_info (num_dims),
  8    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  8    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  8    17       3 multiplier fixed bin (35);			/*  element separation */
  8    18 
  8    19 dcl  desc_ptr ptr;
  8    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  8    21 
  8    22 /* END mdbm_descriptor.incl.pl1 */
  8    23 
  8    24 
      332 
      333 
  9     1 /* BEGIN INCLUDE FILE mdbm_seg_area.incl.pl1 - - Jim Gray 2/19/79 */
  9     2 
  9     3 /* these structures provide a standard for
  9     4*   1) using an entire segment as an area, managed by the area manager
  9     5*   2) a constant header, that has an offset to the major common structure in the area
  9     6*   the pointer to that structure is obtained via pointer(model_seg_ptr, model_seg.offset)
  9     7*   the model_area_ptr is obtained via pointer(model_seg_ptr, size(model_seg)) */
  9     8 
  9     9 declare 1 model_seg aligned based (model_seg_ptr),	/* segment header, not to be changed */
  9    10         2 struct_offset bit (18),			/* offset to major structure allocated in area */
  9    11         2 padding (3) fixed bin ;			/* to set up four word boundary */
  9    12 
  9    13 declare  model_seg_ptr ptr int automatic init (null ());
  9    14 
  9    15 
  9    16 declare  model_area area (sys_info$max_seg_size - size (model_seg)) based (model_area_ptr) ; /* segment area */
  9    17 
  9    18 declare  model_area_ptr ptr int automatic init (null ());
  9    19 
  9    20 dcl size builtin;
  9    21 
  9    22 /* END INCLUDE FILE mdbm_seg_area.incl.pl1 */
  9    23 
      334 
      335 
      336 /* Multics Subroutines */
      337 
      338 	dcl     cu_$arg_list_ptr	 entry (ptr);
      339 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin,
      340 				 fixed bin (35));
      341 
      342 	dcl     sys_info$max_seg_size	 ext fixed bin (35);
      343 
      344 /* DBM Routines */
      345 
      346 	dcl     mrds_data_$caller_compile
      347 				 fixed bin (35) ext;
      348 
      349 	dcl     mrds_error_$invalid_db_index
      350 				 ext fixed bin (35);
      351 	dcl     mrds_error_$no_sel_exp
      352 				 ext fixed bin (35);
      353 
      354 	dcl     mrds_dsl_delete_se	 entry (ptr, fixed bin (35), fixed bin (35));
      355 	dcl     mrds_dsl_init_select_area
      356 				 entry (ptr, fixed bin (35));
      357 	dcl     mu_temp_segments$get_temp_segment
      358 				 entry (fixed bin (35), char (*), ptr,
      359 				 fixed bin (35));
      360 	dcl     mu_database_index$get_resultant_model_pointer
      361 				 entry (fixed bin (35), ptr);
      362 	dcl     mrds_dsl_translate	 entry (ptr, ptr, fixed bin, ptr, fixed bin, ptr,
      363 				 ptr, fixed bin, fixed bin (35));
      364 
      365 /* OTHERS */
      366 
      367 	dcl     (
      368 	        se_ptr,				/* pointer to selection expr. */
      369 	        se_index_ptr,			/* pointer to selection expression index */
      370 	        cd_ptr,				/* pointer to error code */
      371 	        dbi_ptr,				/* ptr to db index */
      372 	        appl_ptr,				/* pointer to args for translate */
      373 	        adpl_ptr
      374 	        )			 ptr;		/* pointer to descs for translate */
      375 
      376 	dcl     fb35u		 fixed bin (35) unal based;
      377 
      378 	dcl     sei		 fixed bin (35);	/* selection expression indedx */
      379 	dcl     icode		 fixed bin (35);	/* Internal error code */
      380 
      381 	dcl     code		 fixed bin (35) based (cd_ptr);
      382 						/* Output: status code */
      383 	dcl     database_index	 fixed bin (35) based (dbi_ptr);
      384 						/* input: db index */
      385 	dcl     se_index		 fixed bin (35) based (se_index_ptr);
      386 						/* input: se index */
      387 
      388 	dcl     (
      389 	        nargs,				/* num args passed in */
      390 	        i,				/* index variable */
      391 	        se_len,				/* length of selection expr. */
      392 	        arg_len,				/* length of an arg */
      393 	        num_args
      394 	        )			 fixed bin;	/* num args for translate */
      395 
      396 	dcl     (null, addr, addrel, fixed, rel, mod, pointer)
      397 				 builtin;
      398 
      399 	dcl     (cleanup, arg_error, any_other)	 condition;
      400 
      401 /* STATIC VARIABLES */
      402 
      403 	declare clean_up_condition	 bit (1) init ("0"b); /* on => clean up proc called */
      404 	declare mu_release_area	 entry (ptr);
      405 	declare area_ptr		 ptr;
      406 
      407 	declare mu_define_area$define_temp_dir_area
      408 				 entry (ptr, fixed bin (35), fixed bin (18),
      409 				 char (11), bit (1) aligned, bit (1) aligned,
      410 				 bit (1) aligned, bit (1) aligned,
      411 				 fixed bin (35));
      412 	declare se_len_ptr		 ptr;		/* temp for getting varying se length */
      413 	dcl     dbi_pic		 picture "999";
      414 
      415      end mrds_dsl_compile;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1314.7  mrds_dsl_compile.pl1              >special_ldd>install>MR12.2-1073>mrds_dsl_compile.pl1
226          1    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
234          4    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
326          5    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
328          6    08/01/88  1300.0  mrds_compiled_se_info.incl.pl1    >special_ldd>install>MR12.2-1073>mrds_compiled_se_info.incl.pl1
330          7    10/14/83  1609.0  mdbm_arg_list.incl.pl1            >ldd>include>mdbm_arg_list.incl.pl1
332          8    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
334          9    10/14/83  1608.6  mdbm_seg_area.incl.pl1            >ldd>include>mdbm_seg_area.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
TM_NORMAL_MODE                  000006 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
addr                                                   builtin function         dcl 396 ref 111 113 115 1-123 1-123
addrel                                                 builtin function         dcl 396 ref 103
adpl_ptr                        000176 automatic       pointer                  dcl 367 set ref 113* 115* 117* 230*
al_ptr                          000150 automatic       pointer                  dcl 7-13 set ref 79* 80 82 85 85 87 98 98 100 111
                                                                                  113 113 115
any_other                       000224 stack reference condition                dcl 399 ref 224
appl_ptr                        000174 automatic       pointer                  dcl 367 set ref 111* 117* 230*
area_ptr                        000234 automatic       pointer                  dcl 405 set ref 78* 160* 230*
arg_count                              based           fixed bin(17,0)          level 2 packed packed unaligned dcl 7-6 ref 82 85 87
arg_des_ptr               2            based           pointer                  array level 2 dcl 7-6 set ref 98 100 111 113 115
arg_error                       000216 stack reference condition                dcl 399 ref 80 83 90
arg_len                         000205 automatic       fixed bin(17,0)          dcl 388 set ref 89* 92* 107*
arg_list                               based           structure                level 1 unaligned dcl 7-6
cd                                     parameter       fixed bin(35,0)          dcl 292 ref 289 294
cd_ptr                          000170 automatic       pointer                  dcl 367 set ref 89* 212 260 294
clean_up_condition              000232 automatic       bit(1)                   initial packed unaligned dcl 403 set ref 403*
cleanup                         000210 stack reference condition                dcl 399 ref 162 220
code                      0(18)        based           fixed bin(17,0)          level 2 in structure "arg_list" packed packed
                                                                                  unaligned dcl 7-6 in procedure "compile" ref 85 98
                                                                                  113
code                                   based           fixed bin(35,0)          dcl 381 in procedure "compile" set ref 212* 260*
                                                                                  294*
compile_area_ptr          2            based           pointer                  level 2 dcl 6-15 set ref 143* 154* 160 256 256* 304
                                                                                  304*
compiled_se_info                       based           structure                level 1 dcl 6-15
compiled_se_info_ptr            000146 automatic       pointer                  dcl 6-44 in procedure "compile" set ref 126* 139*
                                                                                  141 142 143 144 145 146 147 154 160 166 167 170
                                                                                  171 171 171 178 178 181 183 189 189 193 204 204
                                                                                  207 209 210 239 240 241 242 243 244 245 246 247
                                                                                  247 248 248 250 251 251 256 256 274 278 278 304
                                                                                  304
compiled_se_info_ptr     66            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "compile" set ref 126 130 132* 139 202 304
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 1-137
cu_$arg_list_ptr                000040 constant        entry                    external dcl 338 ref 79
cu_$arg_ptr                     000042 constant        entry                    external dcl 339 ref 89 92 95 107
data                                   based           structure                level 2 dcl 5-142
database_index                         based           fixed bin(35,0)          dcl 383 set ref 121* 132* 154* 274*
dbcb                                   based           structure                level 1 dcl 5-142
dbcb_data                              based           structure                level 1 unaligned dcl 5-148
dbcb_ptr                        000144 automatic       pointer                  dcl 5-146 set ref 78* 121* 123 126 129 130 132 139
                                                                                  141 171 173* 193 194* 202 219 230* 239 240 241 242
                                                                                  243 244 245 246 250 253* 278 278 281 282 282 284*
                                                                                  303 304 307*
dbi                     114            based           fixed bin(35,0)          level 3 dcl 5-142 ref 129
dbi_pic                         000240 automatic       picture(3)               packed unaligned dcl 413 set ref 129* 132 154 274
dbi_ptr                         000172 automatic       pointer                  dcl 367 set ref 92* 121 132 154 274
desc_ptr                        000154 automatic       pointer                  dcl 8-19 set ref 98* 100* 102
descriptor                             based           structure                level 1 unaligned dcl 8-6
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
dup_retain               12(01)        based           bit(1)                   array level 3 in structure "compiled_se_info" packed
                                                                                  packed unaligned dcl 6-15 in procedure "compile"
                                                                                  set ref 147* 210* 246*
dup_retain              106(04)        based           bit(1)                   level 3 in structure "dbcb" packed packed unaligned
                                                                                  dcl 5-142 in procedure "compile" ref 246
fb35u                                  based           fixed bin(35,0)          packed unaligned dcl 376 ref 104
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
free                     12            based           bit(1)                   array level 3 packed packed unaligned dcl 6-15 set
                                                                                  ref 146* 167 170* 183* 189 204 209*
i                               000203 automatic       fixed bin(17,0)          dcl 388 set ref 166* 167 169*
icode                           000201 automatic       fixed bin(35,0)          dcl 379 set ref 89* 90 92* 93 93* 95* 96 96* 107*
                                                                                  108 108* 132* 137 137* 154* 159 159* 173* 174 174*
                                                                                  194* 195 195* 230* 233 4-115 4-115* 253* 254 254*
                                                                                  274* 276 276* 284* 285 285* 307*
index                                  parameter       fixed bin(35,0)          dcl 272 ref 264 274 278 278
last_s_e_id_num         115            based           fixed bin(35,0)          level 3 dcl 5-142 set ref 245 282* 282
lit_ptr                  36            based           pointer                  array level 4 in structure "compiled_se_info"
                                                                                  dcl 6-15 in procedure "compile" set ref 244*
lit_ptr                  14            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "compile" ref 244
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 233* 4-62* 4-65 4-68* 4-69 4-78
                                                                                  1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
mod                                                    builtin function         dcl 396 ref 282
model_area_ptr                  000162 automatic       pointer                  initial dcl 9-18 set ref 9-18*
model_seg_ptr                   000160 automatic       pointer                  initial dcl 9-13 set ref 9-13*
mrds_data_$caller_compile       000046 external static fixed bin(35,0)          dcl 346 set ref 173 194 230 253* 307*
mrds_dsl_delete_se              000054 constant        entry                    external dcl 354 ref 173 194 253 307
mrds_dsl_init_select_area       000056 constant        entry                    external dcl 355 ref 284
mrds_dsl_translate              000064 constant        entry                    external dcl 362 ref 230
mrds_error_$invalid_db_index    000050 external static fixed bin(35,0)          dcl 349 set ref 123*
mrds_error_$no_sel_exp          000052 external static fixed bin(35,0)          dcl 351 set ref 197* 202* 214*
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 219* 1-86
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 1-84* 1-89* 1-93 1-94* 1-99* 1-100
                                                                                  4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86* 4-96*
                                                                                  4-99* 4-100* 4-109* 4-110* 4-114* 1-107 1-109*
                                                                                  1-110* 1-121
mu_database_index$get_resultant_model_pointer
                                000062 constant        entry                    external dcl 360 ref 121
mu_define_area$define_temp_dir_area
                                000070 constant        entry                    external dcl 407 ref 132 154
mu_release_area                 000066 constant        entry                    external dcl 404 ref 256 304
mu_temp_segments$get_temp_segment
                                000060 constant        entry                    external dcl 357 ref 274
nargs                           000202 automatic       fixed bin(17,0)          dcl 388 set ref 82* 83 89* 98 100 110 113 115 119
new_select_expr         106(17)        based           bit(1)                   level 3 packed packed unaligned dcl 5-142 set ref
                                                                                  281*
null                                                   builtin function         dcl 396 ref 78 80 117 123 130 143 144 145 202 207
                                                                                  251 256 9-13 9-18 1-123 1-123 303 304 304
num_args                        000206 automatic       fixed bin(17,0)          dcl 388 set ref 119* 230*
num_dims                        000156 automatic       fixed bin(17,0)          initial dcl 8-20 set ref 8-20*
num_ptrs                        000152 automatic       fixed bin(17,0)          dcl 7-14 set ref 85* 87*
number_of_compiled_se
                         10            based           fixed bin(35,0)          level 2 dcl 6-15 set ref 142* 166 178* 178 181 189
                                                                                  204
pointer                                                builtin function         dcl 396 ref 171 278
range_ptr                20            based           pointer                  array level 4 in structure "compiled_se_info"
                                                                                  dcl 6-15 in procedure "compile" set ref 239*
range_ptr                 2            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "compile" ref 239
real_select_area_ptr                   based           pointer                  level 2 dcl 6-15 set ref 141* 171 250
rel                                                    builtin function         dcl 396 ref 171 278
saved_ptrs               16            based           structure                array level 3 dcl 6-15 set ref 145* 207*
se_id_num                13            based           fixed bin(35,0)          array level 3 dcl 6-15 set ref 245*
se_index                               based           fixed bin(35,0)          dcl 385 set ref 127 164 189 189 192 203 259*
se_index_ptr                    000166 automatic       pointer                  dcl 367 set ref 107* 127 164 189 189 192 203 259
se_info                  12            based           structure                array level 2 dcl 6-15
se_len                          000204 automatic       fixed bin(17,0)          dcl 388 set ref 95* 104* 230*
se_len_ptr                      000236 automatic       pointer                  dcl 412 set ref 103* 104
se_ptr                          000164 automatic       pointer                  dcl 367 set ref 95* 103 230*
seg_ptr                  14            based           pointer                  array level 3 dcl 6-15 set ref 144* 171 274* 278
sei                             000200 automatic       fixed bin(35,0)          dcl 378 set ref 165* 167 169* 170 171 171 177 181*
                                                                                  183 185* 192* 193 203* 204 204 207 207 207 207 207
                                                                                  207 207 207 207 207 209 210 239 240 241 242 243
                                                                                  244 245 246 247 248 259
select_area_ptr          16            based           pointer                  array level 4 in structure "compiled_se_info"
                                                                                  dcl 6-15 in procedure "compile" set ref 171* 193
                                                                                  278*
select_area_ptr          36            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "compile" set ref 141 171* 193* 250* 278 278*
select_ptr                4            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "compile" ref 240
select_ptr               22            based           pointer                  array level 4 in structure "compiled_se_info"
                                                                                  dcl 6-15 in procedure "compile" set ref 240*
so_ptr                   10            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "compile" ref 243
so_ptr                   30            based           pointer                  array level 4 in structure "compiled_se_info"
                                                                                  dcl 6-15 in procedure "compile" set ref 243*
ss_ptr                   26            based           pointer                  array level 4 in structure "compiled_se_info"
                                                                                  dcl 6-15 in procedure "compile" set ref 242*
ss_ptr                   20            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "compile" ref 242
sys_info$max_seg_size           000044 external static fixed bin(35,0)          dcl 342 ref 132 154
temp_rel_list_ptr        32            based           pointer                  array level 4 dcl 6-15 set ref 248*
temp_temp_rel_list_ptr
                          6            based           pointer                  level 2 dcl 6-15 set ref 248 251*
temp_x_leaf_ptr           4            based           pointer                  level 2 dcl 6-15 set ref 247 251*
ti_ptr                   24            based           pointer                  array level 4 in structure "compiled_se_info"
                                                                                  dcl 6-15 in procedure "compile" set ref 241*
ti_ptr                   12            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "compile" ref 241
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 1-89
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed     106(13)        based           bit(1)                   level 3 packed packed unaligned dcl 5-142 ref 219
type                      0(01)        based           fixed bin(6,0)           level 2 packed packed unsigned unaligned dcl 8-6 ref
                                                                                  102
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 set ref 1-92* 1-98* 4-60
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*
x_leaf_ptr               34            based           pointer                  array level 4 dcl 6-15 set ref 247*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
fixed                                                  builtin function         dcl 396
model_area                             based           area                     dcl 9-16
model_seg                              based           structure                level 1 dcl 9-9
size                                                   builtin function         dcl 9-20
temp_rel_list                          based           structure                level 1 dcl 6-70
trl_ptr                                automatic       pointer                  dcl 6-77
x_pred_leaf                            based           structure                level 1 dcl 6-50
x_pred_leaf_ptr                        automatic       pointer                  dcl 6-65

NAMES DECLARED BY EXPLICIT CONTEXT.
cleanup_handler                 002074 constant        entry                    internal dcl 300 ref 162 222 295
compile                         000055 constant        entry                    external dcl 24
compile_exit                    001625 constant        label                    dcl 261 ref 296
error                           002062 constant        entry                    internal dcl 289 ref 93 96 108 123 137 159 174 195
                                                                                  197 202 214 1-140 4-115 254 276 285
get_cse_area                    001755 constant        entry                    internal dcl 264 ref 149 185
mftxn_check_code                001277 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      001517 constant        label                    dcl 4-115 ref 4-63
mrds_dsl_compile                000065 constant        entry                    external dcl 24
mstxn_any_other                 001660 constant        entry                    internal dcl 1-116 ref 224
mstxn_cleanup                   001626 constant        entry                    internal dcl 1-102 ref 221
mstxn_exit                      001231 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
restore_significant_data        002143 constant        entry                    internal dcl 314 ref 4-77
should_rollback                 002145 constant        entry                    internal dcl 320 ref 4-94

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2626        2720    2205        2636
Length      3370    2205        72         434     420           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
compile                             252 external procedure  is an external procedure.  
on unit on line 162                  64 on unit               
on unit on line 220                  76 on unit               
on unit on line 224                  82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 220.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 224.  
get_cse_area                            internal procedure  shares stack frame of external procedure compile.  
error                                   internal procedure  shares stack frame of external procedure compile.  
cleanup_handler                      76 internal procedure  is called by several nonquick procedures.  
restore_significant_data                internal procedure  shares stack frame of external procedure compile.  
should_rollback                         internal procedure  shares stack frame of external procedure compile.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
compile                  000100 mstxn_code                  compile
                         000101 mstxn_retries               compile
                         000102 mstxn_temp_code             compile
                         000103 mstxn_transactions_needed   compile
                         000104 user_started_transaction    compile
                         000105 mstxn_txn_id                compile
                         000106 user_transaction_id         compile
                         000110 mstxn_condition_info        compile
                         000142 mftxn_code                  compile
                         000143 mftxn_temp_code             compile
                         000144 dbcb_ptr                    compile
                         000146 compiled_se_info_ptr        compile
                         000150 al_ptr                      compile
                         000152 num_ptrs                    compile
                         000154 desc_ptr                    compile
                         000156 num_dims                    compile
                         000160 model_seg_ptr               compile
                         000162 model_area_ptr              compile
                         000164 se_ptr                      compile
                         000166 se_index_ptr                compile
                         000170 cd_ptr                      compile
                         000172 dbi_ptr                     compile
                         000174 appl_ptr                    compile
                         000176 adpl_ptr                    compile
                         000200 sei                         compile
                         000201 icode                       compile
                         000202 nargs                       compile
                         000203 i                           compile
                         000204 se_len                      compile
                         000205 arg_len                     compile
                         000206 num_args                    compile
                         000232 clean_up_condition          compile
                         000234 area_ptr                    compile
                         000236 se_len_ptr                  compile
                         000240 dbi_pic                     compile

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          tra_ext_1
mdfx3               signal_op           enable_op           ext_entry           int_entry           trunc_fx2
divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           cu_$arg_list_ptr              cu_$arg_ptr                   find_condition_info_
mrds_dsl_delete_se            mrds_dsl_init_select_area     mrds_dsl_translate
mu_database_index$get_resultant_model_pointer               mu_define_area$define_temp_dir_area
mu_release_area               mu_temp_segments$get_temp_segment
transaction_manager_$abandon_txn                            transaction_manager_$abort_txn
transaction_manager_$begin_txn                              transaction_manager_$commit_txn
transaction_manager_$get_current_txn_id                     transaction_manager_$handle_conditions
transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
mrds_data_$caller_compile     mrds_error_$invalid_db_index  mrds_error_$no_sel_exp        sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 8   20 000045    9   13 000046    9   18 000050       403 000051        24 000054        78 000073        79 000076
     80 000105        82 000114        83 000124        85 000131        87 000142        89 000146        90 000163
     92 000170        93 000207        95 000213        96 000232        98 000236       100 000251       102 000256
    103 000263       104 000266       107 000274       108 000313       110 000317       111 000322       113 000325
    115 000340       116 000345       117 000346       119 000351       121 000354       123 000365       126 000400
    127 000403       129 000405       130 000416       132 000422       137 000470       139 000474       141 000477
    142 000502       143 000504       144 000506       145 000507       146 000534       147 000536       149 000540
    154 000544       159 000613       160 000617       162 000622       164 000644       165 000646       166 000647
    167 000657       169 000666       170 000670       171 000673       173 000702       174 000717       176 000723
    177 000725       178 000727       181 000734       183 000735       185 000740       187 000742       189 000743
    192 000752       193 000754       194 000760       195 000775       196 001001       197 001002       200 001011
    202 001012       203 001026       204 001030       207 001042       209 001074       210 001077       212 001101
    213 001102       214 001103       216 001112       219 001113       220 001120       221 001134       222 001135
    223 001142       224 001143    1   83 001161    1   84 001162    1   86 001163    1   88 001165    1   89 001166
 1   90 001177    1   92 001203    1   93 001205    1   94 001207    1   95 001210    1   98 001211    1   99 001212
 1  100 001227    1  140 001231       230 001235       233 001266    4   60 001270    4   62 001275    4   63 001276
 4   65 001277    4   68 001301    4   69 001312    4   71 001314    4   72 001325    4   75 001340    4   77 001341
 4   78 001342    4   81 001351    4   82 001352    4   83 001365    4   85 001367    4   86 001400    4   88 001413
 4   90 001414    4   91 001415    4   93 001416    4   94 001417    4   96 001424    4   97 001440    4   99 001442
 4  100 001453    4  102 001466    4  104 001467    4  105 001470    4  107 001471    4  109 001472    4  110 001503
 4  114 001516    4  115 001517       239 001523       240 001531       241 001534       242 001537       243 001542
    244 001544       245 001546       246 001551       247 001556       248 001560       250 001562       251 001564
    253 001567       254 001602       256 001606       259 001622       260 001624       261 001625    1  102 001626
 1  107 001627    1  109 001632    1  110 001643    1  114 001657    1  116 001660    1  121 001661    1  123 001664
 1  124 001703    1  126 001711    1  127 001714    1  129 001717    1  132 001731    1  133 001734    1  135 001737
 1  136 001744    1  137 001745    1  138 001754       264 001755       274 001757       276 002013       278 002017
    281 002033       282 002036       284 002044       285 002055       287 002061       289 002062       294 002064
    295 002066       296 002072       300 002073       303 002101       304 002106       307 002126       310 002142
    314 002143       316 002144       320 002145       322 002147


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
