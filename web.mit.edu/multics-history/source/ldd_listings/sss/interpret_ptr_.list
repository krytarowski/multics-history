	COMPILATION LISTING OF SEGMENT interpret_ptr_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/05/86  1040.9 mst Wed
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   * Copyright (c) 1972 by Massachusetts Institute of   *
        5*   * Technology and Honeywell Information Systems, Inc. *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 interpret_ptr_:
       11      procedure (a_ptr, a_framep, strp);
       12 
       13 /* INTERPRET_PTR_ - find out as much as possible about a pointer.
       14*
       15*   This program returns printable information about an input pointer.
       16*   If a stack frame pointer or machine conditions pointer is also supplied,
       17*   the program finds out information about the owner of the given stack frame,
       18*   and remarks that the fault may not have occurred in the frame owner.
       19**/
       20 
       21 /* modified 24 July 1975 by M. Weaver for separate static */
       22 /* Modified 7/76 to prevent a fault while interpreting a bad pointer */
       23 /* Modified March 1980 by C. Hornig to find source line */
       24 /* Changed to use interpret_link_info.incl.pl1 05/12/83 S. Herbst */
       25 
       26 dcl a_ptr ptr,					/* ptr to be interpreted (input) */
       27     a_framep ptr,					/* ptr to associated stack frame, or null (input) */
       28     strp ptr;					/* ptr to return structure (input) */
       29 
       30 dcl bcs char (54) based (in_ptr);
       31 dcl bit_72 bit (72) based;				/* Used to avoid pointer check while copying the argument */
       32 
       33 dcl 1 ptrb based aligned,				/* breakdown of a pointer */
       34       2 xx1 bit (3) unal,
       35       2 sn bit (15) unal,
       36       2 rn bit (3) unal,
       37       2 xxx bit (9) unal,
       38       2 its bit (6) unal,
       39       2 yyy bit (36) unal;
       40 
       41 dcl 1 condinfo aligned like condition_info;		/* structure returned by find_condition_info_ */
       42 dcl 1 oi aligned like object_info;
       43 
       44 dcl 1 situation aligned,
       45       2 bad_frame bit (1) unal,
       46       2 exists_ppr bit (1) unal,
       47       2 ppr_is_owner bit (1) unal,
       48       2 ppr_is_ops bit (1) unal,
       49       2 caller_is_owner bit (1) unal,
       50       2 entry_ptr_invalid bit (1) unal,
       51       2 ret_ptr_is_ops bit (1) unal,
       52       2 pad bit (29) unal;
       53 
       54 dcl 1 auto_interpret_link_info aligned like interpret_link_info;
       55 
       56 dcl xp ptr,					/* ptr to segment name */
       57     frame_owner_sw bit (1) aligned init ("1"b),
       58     coptr ptr init (null),
       59     coflg bit (1) init ("0"b),
       60     in_ptr ptr,					/* copied arg */
       61     framep ptr,					/* ptr to stack frame */
       62     hcsct fixed bin,				/* highest hardcore segment */
       63     highct fixed bin,				/* highest segment number */
       64     txtp ptr,					/* ptr into text */
       65     rings (3) fixed bin (6),				/* used when checking accessibility */
       66     lev fixed bin,					/* ... validation level */
       67     mode fixed bin (5),				/* rewa mode of segment */
       68     type fixed bin (2),				/* dir, seg, link */
       69     (bc, bc1) fixed bin (24),				/* bitcount */
       70     bmp ptr,					/* bindmap ptr */
       71     sblkp ptr,
       72     namp ptr,					/* component name */
       73     naml fixed bin,
       74     based_name char (naml) based (namp),		/* component name (in defs of bound seg) */
       75     (i, j) fixed bin,				/* temps */
       76     dirn char (168) aligned,				/* dirname where segment reside */
       77     ename char (32) aligned,				/* temp entry name */
       78     pl1_op_name char (32) aligned,			/* operator name */
       79     segn char (32) aligned,				/* file-system name for seg */
       80     segno fixed bin (18),
       81     adjusted_offset fixed bin (18),
       82     section char (8) aligned,
       83     lang char (8) aligned,
       84     op_seg_name char (32) aligned,
       85     ec fixed bin (35),				/* file-system error code */
       86     ctmp char (65);
       87 
       88 dcl condition_ entry (char (*), entry),
       89     get_entry_name_ entry (ptr, char (*) aligned, fixed bin (18), char (8) aligned, fixed bin (35)),
       90     is_condition_frame_ entry (ptr) returns (bit (1)),
       91     find_condition_info_ entry (ptr, ptr, fixed bin (35)),
       92     find_nonobject_info_
       93          entry (ptr, char (*), fixed bin (18) aligned, char (8) aligned, fixed bin (18) aligned, fixed bin (35)),
       94     stack_frame_exit_ entry (ptr, ptr, ptr, bit (1), ptr, char (32) aligned, ptr),
       95     find_operator_name_ entry (char (*) aligned, ptr, char (32) aligned),
       96     cu_$level_get entry (fixed bin),
       97     hcs_$fs_get_brackets entry (ptr, fixed bin (5), (*) fixed bin (6), fixed bin (35)),
       98     hcs_$high_low_seg_count entry (fixed bin, fixed bin),
       99     ring0_get_$name entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35)),
      100     hcs_$fs_get_path_name entry (ptr, char (*) aligned, fixed bin, char (*) aligned, fixed bin (35)),
      101     hcs_$status_mins entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35)),
      102     object_info_$display entry (ptr, fixed bin (24), ptr, fixed bin (35)),
      103     get_bound_seg_info_ entry (ptr, fixed bin (24), ptr, ptr, ptr, fixed bin (35)),
      104     component_info_$offset entry (ptr, fixed bin (18), ptr, fixed bin (35)),
      105     interpret_link_ entry (ptr, ptr, fixed bin (35)),
      106     ioa_$rsnnl entry options (variable);
      107 
      108 dcl LEGAL char (96) int static init			/* Printables except PAD, but with BS */
      109          (" !""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~");
      110 
      111 dcl (addr, baseno, baseptr, ptr, fixed, null, addrel, rel, substr, binary, bit, verify) builtin;
      112 
      113 /* ------------------------------------------------------ */
      114 
      115 	frame_owner_sw = "0"b;
      116 	go to start;
      117 
      118 frame_owner:
      119      entry (a_ptr, a_framep, strp);
      120 
      121 start:
      122 	if strp = null then return;			/* initialization. check args */
      123 	addr (in_ptr) -> bit_72 = addr (a_ptr) -> bit_72; /* copy arg without pointer check */
      124 	call condition_ ("any_other", oop);
      125 	framep = a_framep;				/* .. and copy args */
      126 	mcp, scup = null;				/* assume no machine cond */
      127 	if framep ^= null
      128 	then					/* see if condition frame */
      129 	     if frame_owner_sw
      130 	     then					/* un-necessary (& may be harmful) in some cases */
      131 		if is_condition_frame_ (framep) then do;
      132 		     call find_condition_info_ (framep, addr (condinfo), ec);
      133 		     if ec = 0 then do;
      134 			mcp = condinfo.mc_ptr;
      135 			in_ptr = condinfo.user_loc_ptr;
      136 			coptr = condinfo.wc_ptr;
      137 			coflg = condinfo.flags.crawlout;
      138 			scup = addr (mc.scu);	/* Fix ptr to suit Clancy */
      139 			end;
      140 		     end;
      141 	struc.comment, struc.segment, struc.entryn, struc.offset, struc.opname, struc.modifier = "";
      142 	struc.instruction_counter = fixed (rel (in_ptr)); /* initialize return values */
      143 	struc.compiler = "";
      144 	struc.ring = "";
      145 	struc.std_flag = "0"b;
      146 	struc.xpad = "0"b;
      147 	struc.symbolp = null;
      148 	struc.text_ptr = in_ptr;
      149 	struc.stack_ptr = framep;
      150 	struc.sourcemap = 0;
      151 	call hcs_$high_low_seg_count (highct, hcsct);	/* find range of good segnos */
      152 	ename = "";
      153 	call ioa_$rsnnl ("^o", struc.offset, i, struc.instruction_counter);
      154 	j = fixed (baseno (in_ptr), 17);		/* if can't get segname. what is segno? */
      155 	call ioa_$rsnnl ("#^o", segn, i, j);		/* unknown segment. put number */
      156 	struc.segment = segn;
      157 
      158 /* Try to take care of some special cases first. */
      159 
      160 	xp = addr (in_ptr);				/* null ptr is special cased */
      161 	if xp -> ptrb.sn = (15)"1"b then do;
      162 	     struc.segment = "null pointer";
      163 	     return;
      164 	     end;
      165 
      166 	if xp -> ptrb.its = "100110"b then do;		/* unsnapped link */
      167 
      168 	     auto_interpret_link_info.version = INTERPRET_LINK_INFO_VERSION_1;
      169 
      170 	     call interpret_link_ (addr (auto_interpret_link_info), in_ptr, ec);
      171 						/* if ft2, ask spier */
      172 	     if ec = 0 then do;			/* good. we can say */
      173 		struc.entryn = auto_interpret_link_info.entry_point_name;
      174 		struc.segment = auto_interpret_link_info.segment_name;
      175 		struc.offset = auto_interpret_link_info.expression;
      176 		struc.modifier = auto_interpret_link_info.modifier;
      177 		end;
      178 	     else struc.segment = "unsnapped link";	/* happens if not in linkage section */
      179 glop:
      180 	     struc.text_ptr = null;			/* save everybody else a lot of trouble */
      181 glop1:
      182 	     return;
      183 	     end;
      184 	if xp -> ptrb.its ^= "100011"b then go to glop;	/* not fool with non-ptr */
      185 
      186 	struc.ring = substr ("01234567", fixed (xp -> ptrb.rn, 3), 1);
      187 	if binary (baseno (in_ptr)) <= hcsct then do;	/* Hardcore segment? */
      188 	     call ring0_get_$name (dirn, segn, in_ptr, ec);
      189 						/* yes. obtain name */
      190 	     if ec = 0 then do;
      191 		struc.segment = segn;		/* oho. */
      192 		struc.ring = "0";
      193 		call check_access (in_ptr, bc, ec);
      194 		if ec = 5 then go to nonobj;
      195 		if ec ^= 0 then go to glop;
      196 		end;
      197 	     end;
      198 
      199 /* Special cases are taken care of. In normal case, we examine stack frame to get procedure name. */
      200 
      201 	txtp = in_ptr;				/* Assume return ptr is good, for the moment */
      202 	call hcs_$fs_get_path_name (txtp, dirn, j, segn, ec);
      203 						/* who is he */
      204 	if ec = 0 then struc.segment = segn;
      205 	if frame_owner_sw
      206 	then if framep ^= null then do;		/* Check stack frame. */
      207 		call stack_frame_exit_ (framep, mcp, coptr, coflg, txtp, op_seg_name, addr (situation));
      208 		if situation.bad_frame then return;
      209 		end;
      210 	call check_access (txtp, bc, ec);
      211 	if ec = 1 then go to glop;
      212 	if ec ^= 0 then go to nonobj;
      213 
      214 	if mcp ^= null then do;			/* if no machine cond, stymied */
      215 	     call find_operator_name_ (op_seg_name, txtp, pl1_op_name);
      216 	     if pl1_op_name ^= ""
      217 	     then					/* If we were in an operator, */
      218 		struc.opname = "in operator " || pl1_op_name;
      219 	     end;
      220 
      221 	call hcs_$fs_get_path_name (txtp, dirn, j, segn, ec);
      222 						/* who is he */
      223 	struc.segment = segn;
      224 	call get_entry_name_ (txtp, ename, segno, lang, ec);
      225 	if ec ^= 0
      226 	then if framep ^= null then call get_entry_name_ (framep -> stack_frame.entry_ptr, ename, segno, lang, ec);
      227 	if ec = 0 then struc.entryn = "$" || ename;
      228 	struc.instruction_counter = fixed (rel (txtp));
      229 	struc.text_ptr = txtp;
      230 	call ioa_$rsnnl ("^o", struc.offset, j, struc.instruction_counter);
      231 	oi.version_number = object_info_version_2;
      232 	call object_info_$display (ptr (txtp, 0), bc, addr (oi), ec);
      233 	if ec ^= 0 then go to nonobj;			/* if not object seg, jump down */
      234 	struc.compiler = oi.compiler;			/* was object seg. get info on it */
      235 	struc.std_flag = ^oi.format.old_format;
      236 	struc.symbolp = oi.symbp;			/* save ptr to beg of symbol section */
      237 	struc.sourcemap = oi.source_map;		/* save source map if given */
      238 	if oi.format.bound then do;			/* is this a bound segment? */
      239 	     call component_info_$offset (ptr (txtp, 0), binary (rel (txtp)), addr (ci), ec);
      240 	     if ec = 0 then do;			/* bound segment. */
      241 		struc.compiler = ci.compiler;		/* we have better info now. */
      242 		struc.std_flag = ci.standard;
      243 		struc.symbolp = ci.symb_start;
      244 		struc.sourcemap = ci.source_map;
      245 		call ioa_$rsnnl ("(^a|^a)", struc.comment, ec, segn, struc.offset);
      246 		struc.segment = ci.name;
      247 		struc.instruction_counter = binary (rel (txtp)) - binary (rel (ci.text_start));
      248 		call ioa_$rsnnl ("^o", struc.offset, j, struc.instruction_counter);
      249 		end;
      250 	     end;
      251 	goto xtarget;
      252 
      253 /* If ptr is to combined linkage segment, see if we can get any info from the LOT. Or  be v1 entry */
      254 
      255 nonobj:						/* see if location is described by def */
      256 	call find_nonobject_info_ (in_ptr, ctmp, segno, section, adjusted_offset, ec);
      257 	if section = "text" then do;			/* text assumed if not in combined linkage segment */
      258 	     if ctmp = "" then go to xtarget;		/* have no further name info */
      259 	     if segn = ""
      260 	     then struc.entryn = ctmp;
      261 	     else struc.entryn = "$" || ctmp;
      262 	     struc.comment = "(external symbol in separate nonstandard text section)";
      263 	     go to done;
      264 	     end;
      265 
      266 /* in_ptr points to static or linkage */
      267 	call hcs_$fs_get_path_name (baseptr (segno), dirn, i, segn, ec);
      268 	if ec ^= 0 then go to xtarget;
      269 	call ioa_$rsnnl ("(^a|^o for ^a)", struc.comment, i, section, adjusted_offset, segn);
      270 	call hcs_$status_mins (baseptr (segno), type, bc1, ec);
      271 	if ec = 0 then do;
      272 	     call get_bound_seg_info_ (baseptr (segno), bc1, addr (oi), bmp, sblkp, ec);
      273 	     if ec = 0 then do;
      274 		do j = 1 to n_components
      275 		     while (adjusted_offset > fixed (component (j).stat_start) + fixed (component (j).stat_lng));
      276 		end;
      277 		if j <= n_components then do;
      278 		     namp = addrel (sblkp, component (j).name_ptr);
      279 		     naml = fixed (component (j).name_lng);
      280 		     call ioa_$rsnnl ("(internal static|^o for ^a)", struc.comment, i,
      281 			adjusted_offset - fixed (component (j).stat_start), based_name);
      282 		     end;
      283 		end;
      284 	     end;
      285 	if ctmp ^= "" then do;
      286 	     struc.entryn = "$" || ctmp;
      287 	     if section = "linkage" then struc.comment = "(entry sequence)";
      288 	     end;
      289 
      290 /* If we cannot say anything else, tell what the pointer points at, if it's ascii. */
      291 
      292 xtarget:
      293 	if struc.comment = "" then do;
      294 	     i = verify (bcs, LEGAL);			/* Scan to see how much is ascii. */
      295 	     if i = 0 then i = 54;			/* If all legal. */
      296 	     if i > 4 then struc.comment = "( -> """ || substr (bcs, 1, i - 1) || """)";
      297 	     end;
      298 done:
      299 	return;
      300 
      301 /* ------------------------------------------------------- */
      302 
      303 check_access:
      304      proc (txtp, bc, code);
      305 
      306 dcl txtp ptr,
      307     bc fixed bin (24),
      308     code fixed bin (35);
      309 
      310 dcl ec fixed bin (35);
      311 
      312 	code = 0;
      313 	if binary (baseno (txtp)) > hcsct + highct then do;
      314 						/* dump out if segment invalid */
      315 	     code = 1;
      316 	     return;
      317 	     end;
      318 	call hcs_$status_mins (txtp, type, bc, ec);	/* check for directory, get length in bits */
      319 	if ec ^= 0 then go to ng;			/* how can this happen? */
      320 	if type ^= 1 then do;			/* ignore directories */
      321 ng:
      322 	     code = 4;
      323 	     return;
      324 	     end;
      325 	call cu_$level_get (lev);			/* check ring brackets */
      326 	call hcs_$fs_get_brackets (txtp, mode, rings, ec);
      327 	if ec ^= 0 then go to ng;			/* if cannot status segment */
      328 	if rings (2) < lev then do;			/* outside read bracket? */
      329 	     code = 2;
      330 	     return;
      331 	     end;
      332 	if (bit (mode, 5) & "01000"b) ^= "01000"b then do;/* check for read access */
      333 	     struc.text_ptr = null;
      334 	     code = 3;
      335 	     return;
      336 	     end;
      337 	if bc = 0 then code = 5;			/* if bit count zero, is not object seg. */
      338 
      339      end check_access;
      340 
      341 /* -------------------------------------------------------- */
      342 
      343 oop:
      344      proc (mcp, cname, cop, infop, cont);
      345 
      346 dcl (mcp, cop, infop) ptr,
      347     cname char (*),
      348     cont bit (1);
      349 
      350 	if cname = "cput" then go to xx;
      351 	if cname = "alrm" then go to xx;
      352 	if cname = "quit" then go to xx;
      353 	if cname = "finish" then go to xx;
      354 	if cname = "stack" then go to xx;
      355 	if cname = "mme2" then go to xx;
      356 	if cname = "program_interrupt" then do;
      357 xx:
      358 	     cont = "1"b;
      359 	     return;
      360 	     end;
      361 
      362 	if cname ^= "cleanup" then go to glop1;
      363 
      364      end oop;
      365 
      366 /* * * * * * * * * * * * * * * * * * * */
      367 
  1     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  1     2 
  1     3 /* Structure for find_condition_info_.
  1     4*
  1     5*   Written 1-Mar-79 by M. N. Davidoff.
  1     6**/
  1     7 
  1     8 /* automatic */
  1     9 
  1    10      declare condition_info_ptr     pointer;
  1    11 
  1    12 /* based */
  1    13 
  1    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  1    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  1    16 	     2 version	      fixed binary,		/* Must be 1 */
  1    17 	     2 condition_name     char (32) varying,	/* name of condition */
  1    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  1    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  1    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  1    21 	     2 flags	      unaligned,
  1    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  1    23 	       3 pad1	      bit (35),
  1    24 	     2 pad2	      bit (36),
  1    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  1    26 	     2 pad3	      (4) bit (36);
  1    27 
  1    28 /* internal static */
  1    29 
  1    30      declare condition_info_version_1
  1    31 			      fixed binary internal static options (constant) initial (1);
  1    32 
  1    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      368 
  2     1 /*  BEGIN INCLUDE FILE interpret_link_info.incl.pl1  */
  2     2 
  2     3 /* Written 05/12/83 by S. Herbst */
  2     4 
  2     5 dcl 1 interpret_link_info aligned based (interpret_link_info_ptr),
  2     6    2 version char (8),
  2     7    2 segment_name char (32) aligned,
  2     8    2 entry_point_name char (260) aligned,
  2     9    2 expression char (8) aligned,
  2    10    2 modifier char (4) aligned,
  2    11    2 trap char (48) aligned;
  2    12 
  2    13 dcl INTERPRET_LINK_INFO_VERSION_1 char (8) int static options (constant) init ("ILI 1.0");
  2    14 
  2    15 dcl interpret_link_info_ptr ptr;
  2    16 
  2    17 /* END INCLUDE FILE interpret_link_info.incl.pl1  */
      369 
  3     1 /* BEGIN INCLUDE FILE ... interpret_ptr_struc.incl.pl1 */
  3     2 
  3     3 dcl 1 struc based (strp) aligned,			/* This useful structure is in trace_stack pgms */
  3     4     2 comment char (64),				/* name of boundseg, or thing pointed to, or .. */
  3     5     2 segment char (32),				/* name of segment, or segment number with # */
  3     6     2 entryn char (33),				/* entry name, preceded by $, or blank */
  3     7     2 offset char (6),				/* offset in segment, or blank */
  3     8     2 opname char (32),				/* may be pl1 operator name */
  3     9     2 ring char (1) unal,				/* ring number of ptr */
  3    10     2 std_flag bit (1) unal,				/* TRUE if std object. */
  3    11     2 xpad bit (26) unal,
  3    12     2 bitoff char (4),				/* bit offset */
  3    13     2 modifier char (8),				/* ptr modifier, or special code like "noaccess" */
  3    14     2 symbolp ptr,					/* ptr to symbol section */
  3    15     2 instruction_counter fixed bin,			/* binary instruction counter */
  3    16     2 sourcemap fixed bin,				/* source map offset in symbol section */
  3    17     2 compiler char (8),				/* name of compiler */
  3    18     2 text_ptr ptr,					/* ptr to segment text */
  3    19     2 stack_ptr ptr;				/* ptr to stack frame */
  3    20 
  3    21 dcl 1 strbuf aligned like struc;			/* If referenced, will make storage for struc */
  3    22 
  3    23 /* END INCLUDE FILE ... interpret_ptr_struc.incl.pl1 */
      370 
  4     1 	/* BEGIN INCLUDE SEGMENT ...  component_info.incl.pl1   M. Weaver  4/26/72  */
  4     2 
  4     3 declare	1 ci aligned,
  4     4 	2 dcl_version fixed bin,		/* version number of this structure */
  4     5 	2 name char(32) aligned,		/* objectname of component segment */
  4     6 	2 text_start pointer,		/* ptr to component's section of text */
  4     7 	2 stat_start pointer,		/* pointer to component's section of internal static */
  4     8 	2 symb_start pointer,		/* pointer to component's first symbol block */
  4     9 	2 defblock_ptr pointer,		/* ptr to component's definition block */
  4    10 	2 text_lng fixed bin,		/* length of text section */
  4    11 	2 stat_lng fixed bin,		/* length of internal static */
  4    12 	2 symb_lng fixed bin,		/* length of symbol section */
  4    13 	2 n_blocks fixed bin,		/* number of symbol blocks in component's symbol section */
  4    14 	2 standard bit(1) aligned,		/* indicates whether component is in standard (new) format */
  4    15 	2 compiler char(8) aligned,		/* name of component's compiler */
  4    16 	2 compile_time fixed bin(71),		/* time component was compiled */
  4    17 	2 userid char(32) aligned,		/* id of creator of component */
  4    18 	2 cvers aligned,			/* version of component's compiler in printable form */
  4    19 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  4    20 	  3 length bit(18) unaligned,		/* length of name in characters */
  4    21 	2 comment aligned,			/* component's comment */
  4    22 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  4    23 	  3 length bit(18) unaligned,		/* length of comment in characters */
  4    24 	2 source_map fixed bin;		/* offset, rel to beg of symbol block, of component's source map */
  4    25 
  4    26 	/* END INCLUDE SEGMENT ... component_info.incl.pl1 */
      371 
  5     1 	/* BEGIN INCLUDE SEGMENT ... bind_map.incl.pl1 Michael J. Spier, 4/29/71  */
  5     2 	/* last modified  April, 1972 by M. Weaver */
  5     3 
  5     4 declare	1 bindmap aligned based(bmp),
  5     5 
  5     6 	2 dcl_version fixed bin,		/* version number of this structure = 1 */
  5     7 	2 n_components fixed bin,		/* number of entries in this array */
  5     8 	2 component(0 refer(bindmap.n_components)) aligned,
  5     9 	  3 name,				/* objectname of component object */
  5    10 	    4 name_ptr bit(18) unaligned,	/* pointer to name string */
  5    11 	    4 name_lng bit(18) unaligned,	/* length of name string */
  5    12 	  3 comp_name char(8) aligned,	/* name of component's compiler */
  5    13 	  3 text_start bit(18) unaligned,	/* text section relocation counter */
  5    14 	  3 text_lng bit(18) unaligned,	/* length of text section */
  5    15 	  3 stat_start bit(18) unaligned,	/* internal static relocation counter */
  5    16 	  3 stat_lng bit(18) unaligned,	/* length of internal static */
  5    17 	  3 symb_start bit(18) unaligned,	/* symbol section relocation counter */
  5    18 	  3 symb_lng bit(18) unaligned,	/* length of symbol section */
  5    19 	  3 defblock_ptr bit(18) unaligned,	/* pointer to components definition block */
  5    20 	  3 n_blocks bit(18) unaligned,	/* number of symbol blocks the component has */
  5    21 	2 bf_name aligned,			/* name of bindfile */
  5    22 	  3 bf_name_ptr bit(18) unaligned,	/* pointer to name string */
  5    23 	  3 bf_name_lng bit(18) unaligned,	/* length of name string */
  5    24 	2 bf_date_up char(24),		/* date updated in archive */
  5    25 	2 bf_date_mod char(24);		/* date last modified */
  5    26 
  5    27 /* END INCLUDE SEGMENT ... bind_map.incl.pl1 */
      372 
  6     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  6     2*coded February 8, 1972 by Michael J. Spier	*/
  6     3 /* modified May 26, 1972 by M. Weaver */
  6     4 /* modified 15 April, 1975 by M. Weaver */
  6     5 
  6     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  6     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  6     8 	2 textp pointer,			/* pointer to beginning of text section */
  6     9 	2 defp pointer,			/* pointer to beginning of definition section */
  6    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  6    11 	2 statp pointer,			/* pointer to beginning of static section */
  6    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  6    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  6    14 	2 tlng fixed bin,			/* length in words of text section */
  6    15 	2 dlng fixed bin,			/* length in words of definition section */
  6    16 	2 llng fixed bin,			/* length in words of linkage section */
  6    17 	2 ilng fixed bin,			/* length in words of static section */
  6    18 	2 slng fixed bin,			/* length in words of symbol section */
  6    19 	2 blng fixed bin,			/* length in words of break map */
  6    20 	2 format,				/* word containing bit flags about object type */
  6    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  6    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  6    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  6    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  6    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  6    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  6    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  6    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  6    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  6    30 	  3 pad bit(27) unaligned,
  6    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  6    32 	2 textlinkp pointer,		/* ptr to first link in text */
  6    33 
  6    34 	/* LIMIT OF BRIEF STRUCTURE */
  6    35 
  6    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  6    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  6    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  6    39 	2 cvers aligned,			/* generator version name in printable char string form */
  6    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  6    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  6    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  6    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  6    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  6    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  6    46 
  6    47 	/* LIMIT OF DISPLAY STRUCTURE */
  6    48 
  6    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  6    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  6    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  6    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  6    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  6    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  6    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  6    56 					/* currently not used by system */
  6    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  6    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  6    59 
  6    60 declare	object_info_version_2 fixed bin int static init(2);
  6    61 
  6    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      373 
  7     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  7     2 
  7     3 /* format: off */
  7     4 
  7     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  7     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  7     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  7     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  7     9 
  7    10 
  7    11 /****^  HISTORY COMMENTS:
  7    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  7    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  7    14*     Modified to add constants for the translator_id field in the stack_frame
  7    15*     structure.
  7    16*                                                   END HISTORY COMMENTS */
  7    17 
  7    18 
  7    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  7    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  7    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  7    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  7    23 
  7    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  7    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  7    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  7    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  7    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  7    29 
  7    30 
  7    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  7    32 
  7    33 dcl  stack_frame_min_length fixed bin static init(48);
  7    34 
  7    35 
  7    36 dcl 1 stack_frame based(sp) aligned,
  7    37     2 pointer_registers(0 : 7) ptr,
  7    38     2 prev_sp pointer,
  7    39     2 next_sp pointer,
  7    40     2 return_ptr pointer,
  7    41     2 entry_ptr pointer,
  7    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  7    43     2 arg_ptr pointer,
  7    44     2 static_ptr ptr unaligned,
  7    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  7    46     2 on_unit_relp1 bit(18) unaligned,
  7    47     2 on_unit_relp2 bit(18) unaligned,
  7    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  7    49*						   0 => PL/I version II
  7    50*						   1 => ALM
  7    51*						   2 => PL/I version I   
  7    52*						   3 => signal caller frame
  7    53*						   4 => signaller frame */
  7    54     2 operator_return_offset bit(18) unaligned,
  7    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  7    56     2 a bit(36),					/* accumulator */
  7    57     2 q bit(36),					/* q-register */
  7    58     2 e bit(36),					/* exponent */
  7    59     2 timer bit(27) unaligned,				/* timer */
  7    60     2 pad bit(6) unaligned,
  7    61     2 ring_alarm_reg bit(3) unaligned;
  7    62 
  7    63 
  7    64 dcl 1 stack_frame_flags based(sp) aligned,
  7    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  7    66     2 xx0 bit(22) unal,
  7    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  7    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  7    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  7    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  7    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  7    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  7    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  7    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  7    75     2 xx0a bit(6) unal,
  7    76     2 xx1 fixed bin,
  7    77     2 xx2 fixed bin,
  7    78     2 xx3 bit(25) unal,
  7    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  7    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  7    81     2 xx3a bit(9) unaligned,
  7    82     2 xx4(9) bit(72) aligned,
  7    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  7    84*						*  operator puts a pointer to the base of
  7    85*						*  the calling procedure here. (text base ptr)  */
  7    86     2 xx5 bit(72) aligned,
  7    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  7    88 
  7    89 /* format: on */
  7    90 
  7    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      374 
  8     1 /*  */
  8     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  8     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  8     4 /* Modified 07/07/76 by Morris for fault register data */
  8     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  8     6 /* Modified '82 to make values constant */
  8     7 
  8     8 /* words 0-15 pointer registers */
  8     9 
  8    10 dcl  mcp ptr;
  8    11 
  8    12 dcl 1 mc based (mcp) aligned,
  8    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  8    14    (2 regs,					/* registers */
  8    15       3 x (0:7) bit (18),				/* index registers */
  8    16       3 a bit (36),					/* accumulator */
  8    17       3 q bit (36),					/* q-register */
  8    18       3 e bit (8),					/* exponent */
  8    19       3 pad1 bit (28),
  8    20       3 t bit (27),					/* timer register */
  8    21       3 pad2 bit (6),
  8    22       3 ralr bit (3),				/* ring alarm register */
  8    23 
  8    24     2 scu (0:7) bit (36),
  8    25 
  8    26     2 mask bit (72),				/* mem controller mask at time of fault */
  8    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  8    28     2 errcode fixed bin (35),				/* fault handler's error code */
  8    29     2 fim_temp,
  8    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  8    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  8    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  8    33     2 fault_reg bit (36),				/* fault register */
  8    34     2 pad2 bit (1),
  8    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  8    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  8    37     2 fault_time bit (54),				/* time of fault */
  8    38 
  8    39     2 eis_info (0:7) bit (36)) unaligned;
  8    40 
  8    41 
  8    42 dcl (apx fixed bin init (0),
  8    43      abx fixed bin init (1),
  8    44      bpx fixed bin init (2),
  8    45      bbx fixed bin init (3),
  8    46      lpx fixed bin init (4),
  8    47      lbx fixed bin init (5),
  8    48      spx fixed bin init (6),
  8    49      sbx fixed bin init (7)) internal static options (constant);
  8    50 
  8    51 
  8    52 
  8    53 
  8    54 dcl  scup ptr;
  8    55 
  8    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  8    57 
  8    58 
  8    59 /*	WORD (0)		*/
  8    60 
  8    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  8    62       3 prr bit (3),				/* procedure ring register */
  8    63       3 psr bit (15),				/* procedure segment register */
  8    64       3 p bit (1),					/* procedure privileged bit */
  8    65 
  8    66     2 apu,					/* APPENDING UNIT STATUS */
  8    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  8    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  8    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  8    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  8    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  8    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  8    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  8    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  8    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  8    76       3 ptw bit (1),				/* Fetch of PTW */
  8    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  8    78       3 fap bit (1),				/* Fetch of final address paged */
  8    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  8    80       3 fabs bit (1),				/* Fetch of final address absolute */
  8    81 
  8    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  8    83 
  8    84 
  8    85 /*	WORD (1)		*/
  8    86 
  8    87     2 fd,						/* FAULT  DATA */
  8    88       3 iro bit (1),				/* illegal ring order */
  8    89       3 oeb bit (1),				/* out of execute bracket */
  8    90       3 e_off bit (1),				/* no execute */
  8    91       3 orb bit (1),				/* out of read bracket */
  8    92       3 r_off bit (1),				/* no read */
  8    93       3 owb bit (1),				/* out of write bracket */
  8    94       3 w_off bit (1),				/* no write */
  8    95       3 no_ga bit (1),				/* not a gate */
  8    96       3 ocb bit (1),				/* out of call bracket */
  8    97       3 ocall bit (1),				/* outward call */
  8    98       3 boc bit (1),				/* bad outward call */
  8    99       3 inret bit (1),				/* inward return */
  8   100       3 crt bit (1),				/* cross ring transfer */
  8   101       3 ralr bit (1),				/* ring alarm register */
  8   102       3 am_er bit (1),				/* associative memory fault */
  8   103       3 oosb bit (1),				/* out of segment bounds */
  8   104       3 paru bit (1),				/* processor parity upper */
  8   105       3 parl bit (1),				/* processor parity lower */
  8   106       3 onc_1 bit (1),				/* op not complete type 1 */
  8   107       3 onc_2 bit (1),				/* op not complete type 2 */
  8   108 
  8   109     2 port_stat,					/* PORT  STATUS */
  8   110       3 ial bit (4),				/* illegal action lines */
  8   111       3 iac bit (3),				/* illegal action channel */
  8   112       3 con_chan bit (3),				/* connect channel */
  8   113 
  8   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  8   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  8   116 
  8   117 
  8   118 /*	WORD (2)		*/
  8   119 
  8   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  8   121       3 trr bit (3),				/* temporary ring register */
  8   122       3 tsr bit (15),				/* temporary segment register */
  8   123 
  8   124     2 pad2 bit (9),
  8   125 
  8   126     2 cpu_no bit (3),				/* CPU number */
  8   127 
  8   128     2 delta bit (6),				/* tally modification DELTA */
  8   129 
  8   130 
  8   131 /*	WORD (3)		*/
  8   132 
  8   133     2 word3 bit (18),
  8   134 
  8   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  8   136       3 tsna,					/* Word 1 status */
  8   137         4 prn bit (3),				/* Word 1  PR  number */
  8   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  8   139       3 tsnb,					/* Word 2  status */
  8   140         4 prn bit (3),				/* Word 2  PR  number */
  8   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  8   142       3 tsnc,					/* Word 3  status */
  8   143         4 prn bit (3),				/* Word 3  PR  number */
  8   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  8   145 
  8   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  8   147 
  8   148 
  8   149 /* 	WORD (4)		*/
  8   150 
  8   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  8   152 
  8   153     2 ir,						/* INDICATOR  REGISTERS */
  8   154       3 zero bit (1),				/* zero indicator */
  8   155       3 neg bit (1),				/* negative indicator */
  8   156       3 carry bit (1),				/* carryry indicator */
  8   157       3 ovfl bit (1),				/* overflow indicator */
  8   158       3 eovf bit (1),				/* eponent overflow */
  8   159       3 eufl bit (1),				/* exponent underflow */
  8   160       3 oflm bit (1),				/* overflow mask */
  8   161       3 tro bit (1),				/* tally runout */
  8   162       3 par bit (1),				/* parity error */
  8   163       3 parm bit (1),				/* parity mask */
  8   164       3 bm bit (1),					/* ^bar mode */
  8   165       3 tru bit (1),				/* truncation mode */
  8   166       3 mif bit (1),				/* multi-word instruction mode */
  8   167       3 abs bit (1),				/* absolute mode */
  8   168       3 hex bit (1),				/* hexadecimal exponent mode */
  8   169       3 pad bit (3),
  8   170 
  8   171 
  8   172 /*	WORD (5)		*/
  8   173 
  8   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  8   175 
  8   176     2 cu,						/* CONTROL UNIT STATUS */
  8   177       3 rf bit (1),					/* on first cycle of repeat instr */
  8   178       3 rpt bit (1),				/* repeat instruction */
  8   179       3 rd bit (1),					/* repeat double instruction */
  8   180       3 rl bit (1),					/* repeat link instruciton */
  8   181       3 pot bit (1),				/* IT  modification */
  8   182       3 pon bit (1),				/* return type instruction */
  8   183       3 xde bit (1),				/* XDE from Even location */
  8   184       3 xdo bit (1),				/* XDE from Odd  location */
  8   185       3 poa bit (1),				/* operation preparation */
  8   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  8   187       3 its bit (1),				/* ITS modification */
  8   188       3 if bit (1),					/* fault occured during instruction fetch */
  8   189 
  8   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  8   191 
  8   192 
  8   193 /*	WORDS (6,7)	*/
  8   194 
  8   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  8   196 
  8   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  8   198 
  8   199 
  8   200 
  8   201 
  8   202 
  8   203 
  8   204 /*	ALTERNATE   SCU  DECLARATION		*/
  8   205 
  8   206 
  8   207 dcl 1 scux based (scup) aligned,
  8   208 
  8   209    (2 pad0 bit (36),
  8   210 
  8   211     2 fd,						/* GROUP II  FAULT DATA */
  8   212       3 isn bit (1),				/* illegal segment number */
  8   213       3 ioc bit (1),				/* illegal op  code  */
  8   214       3 ia_am bit (1),				/* illegal address - modifier */
  8   215       3 isp bit (1),				/* illegal slave  procedure */
  8   216       3 ipr bit (1),				/* illegal procedure */
  8   217       3 nea bit (1),				/* non existent address */
  8   218       3 oobb bit (1),				/* out of bounds */
  8   219       3 pad bit (29),
  8   220 
  8   221     2 pad2 bit (36),
  8   222 
  8   223     2 pad3a bit (18),
  8   224 
  8   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  8   226       3 prn bit (3),				/* PR  number */
  8   227       3 prv bit (1),				/* PR  valid bit */
  8   228 
  8   229     2 pad3b bit (6)) unaligned,
  8   230 
  8   231     2 pad45 (0:1) bit (36),
  8   232 
  8   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  8   234 
  8   235 
  8   236 
  8   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      375 
      376 
      377      end interpret_ptr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/86  1041.7  interpret_ptr_.pl1                >special_ldd>install>MR12.0-1206>interpret_ptr_.pl1
368          1    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
369          2    06/06/83  0917.4  interpret_link_info.incl.pl1      >ldd>include>interpret_link_info.incl.pl1
370          3    06/11/74  0602.3  interpret_ptr_struc.incl.pl1      >ldd>include>interpret_ptr_struc.incl.pl1
371          4    05/06/74  1741.0  component_info.incl.pl1           >ldd>include>component_info.incl.pl1
372          5    09/18/74  1700.9  bind_map.incl.pl1                 >ldd>include>bind_map.incl.pl1
373          6    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
374          7    11/03/86  1114.7  stack_frame.incl.pl1              >special_ldd>install>MR12.0-1206>stack_frame.incl.pl1
375          8    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
INTERPRET_LINK_INFO_VERSION_1   000000 constant        char(8)                  initial unaligned dcl 2-13 ref 168
LEGAL                           000002 constant        char(96)                 initial unaligned dcl 108 ref 294
a_framep                               parameter       pointer                  dcl 26 ref 10 118 125
a_ptr                                  parameter       pointer                  dcl 26 set ref 10 118 123
addr                                                   builtin function         dcl 111 ref 123 123 132 132 138 160 170 170 207 207
                                                                                  232 232 239 239 272 272
addrel                                                 builtin function         dcl 111 ref 278
adjusted_offset                 000520 automatic       fixed bin(18,0)          dcl 56 set ref 255* 269* 274 280
auto_interpret_link_info        000221 automatic       structure                level 1 dcl 54 set ref 170 170
bad_frame                       000220 automatic       bit(1)                   level 2 packed unaligned dcl 44 set ref 208
based_name                             based           char                     unaligned dcl 56 set ref 280*
baseno                                                 builtin function         dcl 111 ref 154 187 313
baseptr                                                builtin function         dcl 111 ref 267 267 270 270 272 272
bc                              000402 automatic       fixed bin(24,0)          dcl 56 in procedure "interpret_ptr_" set ref 193*
                                                                                  210* 232*
bc                                     parameter       fixed bin(24,0)          dcl 306 in procedure "check_access" set ref 303 318*
                                                                                  337
bc1                             000403 automatic       fixed bin(24,0)          dcl 56 set ref 270* 272*
bcs                                    based           char(54)                 unaligned dcl 30 ref 294 296
binary                                                 builtin function         dcl 111 ref 187 239 239 247 247 313
bindmap                                based           structure                level 1 dcl 5-4
bit                                                    builtin function         dcl 111 ref 332
bit_72                                 based           bit(72)                  unaligned dcl 31 set ref 123* 123
bmp                             000404 automatic       pointer                  dcl 56 set ref 272* 274 274 274 277 278 279 280
bound                    24(01) 000132 automatic       bit(1)                   level 3 packed unaligned dcl 42 set ref 238
ci                              000560 automatic       structure                level 1 dcl 4-3 set ref 239 239
cname                                  parameter       char                     unaligned dcl 346 ref 343 350 351 352 353 354 355
                                                                                  356 362
code                                   parameter       fixed bin(35,0)          dcl 306 set ref 303 312* 315* 321* 329* 334* 337*
coflg                           000362 automatic       bit(1)                   initial unaligned dcl 56 set ref 56* 137* 207*
comment                                based           char(64)                 level 2 dcl 3-3 set ref 141* 245* 262* 269* 280*
                                                                                  287* 292 296*
compiler                 27     000560 automatic       char(8)                  level 2 in structure "ci" dcl 4-3 in procedure
                                                                                  "interpret_ptr_" set ref 241
compiler                 30     000132 automatic       char(8)                  level 2 in structure "oi" dcl 42 in procedure
                                                                                  "interpret_ptr_" set ref 234
compiler                 64            based           char(8)                  level 2 in structure "struc" dcl 3-3 in procedure
                                                                                  "interpret_ptr_" set ref 143* 234* 241*
component                 2            based           structure                array level 2 dcl 5-4
component_info_$offset          000046 constant        entry                    external dcl 88 ref 239
condinfo                        000100 automatic       structure                level 1 dcl 41 set ref 132 132
condition_                      000010 constant        entry                    external dcl 88 ref 124
condition_info                         based           structure                level 1 dcl 1-14
cont                                   parameter       bit(1)                   unaligned dcl 346 set ref 343 357*
cop                                    parameter       pointer                  dcl 346 ref 343
coptr                           000360 automatic       pointer                  initial dcl 56 set ref 56* 136* 207*
crawlout                 22     000100 automatic       bit(1)                   level 3 packed unaligned dcl 41 set ref 137
ctmp                            000537 automatic       char(65)                 unaligned dcl 56 set ref 255* 258 259 261 285 286
cu_$level_get                   000026 constant        entry                    external dcl 88 ref 325
dirn                            000415 automatic       char(168)                dcl 56 set ref 188* 202* 221* 267*
ec                              000536 automatic       fixed bin(35,0)          dcl 56 in procedure "interpret_ptr_" set ref 132*
                                                                                  133 170* 172 188* 190 193* 194 195 202* 204 210*
                                                                                  211 212 221* 224* 225 225* 227 232* 233 239* 240
                                                                                  245* 255* 267* 268 270* 271 272* 273
ec                              000644 automatic       fixed bin(35,0)          dcl 310 in procedure "check_access" set ref 318* 319
                                                                                  326* 327
ename                           000467 automatic       char(32)                 dcl 56 set ref 152* 224* 225* 227
entry_point_name         12     000221 automatic       char(260)                level 2 dcl 54 set ref 173
entry_ptr                26            based           pointer                  level 2 dcl 7-36 set ref 225*
entryn                   30            based           char(33)                 level 2 dcl 3-3 set ref 141* 173* 227* 259* 261*
                                                                                  286*
expression              113     000221 automatic       char(8)                  level 2 dcl 54 set ref 175
find_condition_info_            000016 constant        entry                    external dcl 88 ref 132
find_nonobject_info_            000020 constant        entry                    external dcl 88 ref 255
find_operator_name_             000024 constant        entry                    external dcl 88 ref 215
fixed                                                  builtin function         dcl 111 ref 142 154 186 228 274 274 279 280
flags                    22     000100 automatic       structure                level 2 packed unaligned dcl 41
format                   24     000132 automatic       structure                level 2 dcl 42
frame_owner_sw                  000356 automatic       bit(1)                   initial dcl 56 set ref 56* 115* 127 205
framep                          000366 automatic       pointer                  dcl 56 set ref 125* 127 127* 132* 149 205 207* 225
                                                                                  225
get_bound_seg_info_             000044 constant        entry                    external dcl 88 ref 272
get_entry_name_                 000012 constant        entry                    external dcl 88 ref 224 225
hcs_$fs_get_brackets            000030 constant        entry                    external dcl 88 ref 326
hcs_$fs_get_path_name           000036 constant        entry                    external dcl 88 ref 202 221 267
hcs_$high_low_seg_count         000032 constant        entry                    external dcl 88 ref 151
hcs_$status_mins                000040 constant        entry                    external dcl 88 ref 270 318
hcsct                           000370 automatic       fixed bin(17,0)          dcl 56 set ref 151* 187 313
highct                          000371 automatic       fixed bin(17,0)          dcl 56 set ref 151* 313
i                               000413 automatic       fixed bin(17,0)          dcl 56 set ref 153* 155* 267* 269* 280* 294* 295
                                                                                  295* 296 296
in_ptr                          000364 automatic       pointer                  dcl 56 set ref 123 135* 142 148 154 160 170* 187
                                                                                  188* 193* 201 255* 294 296
infop                                  parameter       pointer                  dcl 346 ref 343
instruction_counter      62            based           fixed bin(17,0)          level 2 dcl 3-3 set ref 142* 153* 228* 230* 247*
                                                                                  248*
interpret_link_                 000050 constant        entry                    external dcl 88 ref 170
interpret_link_info                    based           structure                level 1 dcl 2-5
ioa_$rsnnl                      000052 constant        entry                    external dcl 88 ref 153 155 230 245 248 269 280
is_condition_frame_             000014 constant        entry                    external dcl 88 ref 127
its                       0(30)        based           bit(6)                   level 2 packed unaligned dcl 33 ref 166 184
j                               000414 automatic       fixed bin(17,0)          dcl 56 set ref 154* 155* 202* 221* 230* 248* 274*
                                                                                  274 274* 277 278 279 280
lang                            000524 automatic       char(8)                  dcl 56 set ref 224* 225*
lev                             000377 automatic       fixed bin(17,0)          dcl 56 set ref 325* 328
mc                                     based           structure                level 1 dcl 8-12
mc_ptr                          000100 automatic       pointer                  level 2 dcl 41 set ref 134
mcp                                    parameter       pointer                  dcl 346 in procedure "oop" ref 343
mcp                             000630 automatic       pointer                  dcl 8-10 in procedure "interpret_ptr_" set ref 126*
                                                                                  134* 138 207* 214
mode                            000400 automatic       fixed bin(5,0)           dcl 56 set ref 326* 332
modifier                115     000221 automatic       char(4)                  level 2 in structure "auto_interpret_link_info"
                                                                                  dcl 54 in procedure "interpret_ptr_" set ref 176
modifier                 55            based           char(8)                  level 2 in structure "struc" dcl 3-3 in procedure
                                                                                  "interpret_ptr_" set ref 141* 176*
n_components              1            based           fixed bin(17,0)          level 2 dcl 5-4 ref 274 277
name                      1     000560 automatic       char(32)                 level 2 in structure "ci" dcl 4-3 in procedure
                                                                                  "interpret_ptr_" set ref 246
name                      2            based           structure                array level 3 in structure "bindmap" dcl 5-4
                                                                                  in procedure "interpret_ptr_"
name_lng                  2(18)        based           bit(18)                  array level 4 packed unaligned dcl 5-4 ref 279
name_ptr                  2            based           bit(18)                  array level 4 packed unaligned dcl 5-4 ref 278
naml                            000412 automatic       fixed bin(17,0)          dcl 56 set ref 279* 280 280
namp                            000410 automatic       pointer                  dcl 56 set ref 278* 280
null                                                   builtin function         dcl 111 ref 56 121 126 127 147 179 205 214 225 333
object_info                            based           structure                level 1 dcl 6-6
object_info_$display            000042 constant        entry                    external dcl 88 ref 232
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 6-60 ref 231
offset                   41            based           char(6)                  level 2 dcl 3-3 set ref 141* 153* 175* 230* 245*
                                                                                  248*
oi                              000132 automatic       structure                level 1 dcl 42 set ref 232 232 272 272
old_format               24     000132 automatic       bit(1)                   level 3 packed unaligned dcl 42 set ref 235
op_seg_name                     000526 automatic       char(32)                 dcl 56 set ref 207* 215*
opname                   43            based           char(32)                 level 2 dcl 3-3 set ref 141* 216*
pl1_op_name                     000477 automatic       char(32)                 dcl 56 set ref 215* 216 216
ptr                                                    builtin function         dcl 111 ref 232 232 239 239
ptrb                                   based           structure                level 1 dcl 33
rel                                                    builtin function         dcl 111 ref 142 228 239 239 247 247
ring                     53            based           char(1)                  level 2 packed unaligned dcl 3-3 set ref 144* 186*
                                                                                  192*
ring0_get_$name                 000034 constant        entry                    external dcl 88 ref 188
rings                           000374 automatic       fixed bin(6,0)           array dcl 56 set ref 326* 328
rn                        0(18)        based           bit(3)                   level 2 packed unaligned dcl 33 ref 186
sblkp                           000406 automatic       pointer                  dcl 56 set ref 272* 278
scu                      30            based           bit(36)                  array level 2 packed unaligned dcl 8-12 set ref 138
scup                            000632 automatic       pointer                  dcl 8-54 set ref 126* 138*
section                         000522 automatic       char(8)                  dcl 56 set ref 255* 257 269* 287
segment                  20            based           char(32)                 level 2 dcl 3-3 set ref 141* 156* 162* 174* 178*
                                                                                  191* 204* 223* 246*
segment_name              2     000221 automatic       char(32)                 level 2 dcl 54 set ref 174
segn                            000507 automatic       char(32)                 dcl 56 set ref 155* 156 188* 191 202* 204 221* 223
                                                                                  245* 259 267* 269*
segno                           000517 automatic       fixed bin(18,0)          dcl 56 set ref 224* 225* 255* 267 267 270 270 272
                                                                                  272
situation                       000220 automatic       structure                level 1 dcl 44 set ref 207 207
sn                        0(03)        based           bit(15)                  level 2 packed unaligned dcl 33 ref 161
source_map               46     000132 automatic       fixed bin(17,0)          level 2 in structure "oi" dcl 42 in procedure
                                                                                  "interpret_ptr_" set ref 237
source_map               46     000560 automatic       fixed bin(17,0)          level 2 in structure "ci" dcl 4-3 in procedure
                                                                                  "interpret_ptr_" set ref 244
sourcemap                63            based           fixed bin(17,0)          level 2 dcl 3-3 set ref 150* 237* 244*
stack_frame                            based           structure                level 1 dcl 7-36
stack_frame_exit_               000022 constant        entry                    external dcl 88 ref 207
stack_ptr                70            based           pointer                  level 2 dcl 3-3 set ref 149*
standard                 26     000560 automatic       bit(1)                   level 2 dcl 4-3 set ref 242
stat_lng                  6(18)        based           bit(18)                  array level 3 packed unaligned dcl 5-4 ref 274
stat_start                6            based           bit(18)                  array level 3 packed unaligned dcl 5-4 ref 274 280
std_flag                 53(09)        based           bit(1)                   level 2 packed unaligned dcl 3-3 set ref 145* 235*
                                                                                  242*
strp                                   parameter       pointer                  dcl 26 ref 10 118 121 141 141 141 141 141 141 142
                                                                                  143 144 145 146 147 148 149 150 153 153 156 162
                                                                                  173 174 175 176 178 179 186 191 192 204 216 223
                                                                                  227 228 229 230 230 234 235 236 237 241 242 243
                                                                                  244 245 245 246 247 248 248 259 261 262 269 280
                                                                                  286 287 292 296 333
struc                                  based           structure                level 1 dcl 3-3
substr                                                 builtin function         dcl 111 ref 186 296
symb_start               16     000560 automatic       pointer                  level 2 dcl 4-3 set ref 243
symbolp                  60            based           pointer                  level 2 dcl 3-3 set ref 147* 236* 243*
symbp                    12     000132 automatic       pointer                  level 2 dcl 42 set ref 236
text_ptr                 66            based           pointer                  level 2 dcl 3-3 set ref 148* 179* 229* 333*
text_start               12     000560 automatic       pointer                  level 2 dcl 4-3 set ref 247
txtp                                   parameter       pointer                  dcl 306 in procedure "check_access" set ref 303 313
                                                                                  318* 326*
txtp                            000372 automatic       pointer                  dcl 56 in procedure "interpret_ptr_" set ref 201*
                                                                                  202* 207* 210* 215* 221* 224* 228 229 232 232 239
                                                                                  239 239 239 247
type                            000401 automatic       fixed bin(2,0)           dcl 56 set ref 270* 318* 320
user_loc_ptr             24     000100 automatic       pointer                  level 2 dcl 41 set ref 135
verify                                                 builtin function         dcl 111 ref 294
version                         000221 automatic       char(8)                  level 2 dcl 54 set ref 168*
version_number                  000132 automatic       fixed bin(17,0)          level 2 dcl 42 set ref 231*
wc_ptr                   16     000100 automatic       pointer                  level 2 dcl 41 set ref 136
xp                              000354 automatic       pointer                  dcl 56 set ref 160* 161 166 184 186
xpad                     53(10)        based           bit(26)                  level 2 packed unaligned dcl 3-3 set ref 146*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
RETURN_PTR_MASK                        internal static bit(72)                  initial unaligned dcl 7-19
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial unaligned dcl 7-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial unaligned dcl 7-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial unaligned dcl 7-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial unaligned dcl 7-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial unaligned dcl 7-27
abx                                    internal static fixed bin(17,0)          initial dcl 8-42
apx                                    internal static fixed bin(17,0)          initial dcl 8-42
bbx                                    internal static fixed bin(17,0)          initial dcl 8-42
bpx                                    internal static fixed bin(17,0)          initial dcl 8-42
condition_info_ptr                     automatic       pointer                  dcl 1-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 1-30
interpret_link_info_ptr                automatic       pointer                  dcl 2-15
lbx                                    internal static fixed bin(17,0)          initial dcl 8-42
lpx                                    internal static fixed bin(17,0)          initial dcl 8-42
sbx                                    internal static fixed bin(17,0)          initial dcl 8-42
scu                                    based           structure                level 1 dcl 8-56
scux                                   based           structure                level 1 dcl 8-207
sp                                     automatic       pointer                  dcl 7-31
spx                                    internal static fixed bin(17,0)          initial dcl 8-42
stack_frame_flags                      based           structure                level 1 dcl 7-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 7-33
strbuf                                 automatic       structure                level 1 dcl 3-21

NAMES DECLARED BY EXPLICIT CONTEXT.
check_access                    002246 constant        entry                    internal dcl 303 ref 193 210
done                            002245 constant        label                    dcl 298 ref 263
frame_owner                     000225 constant        entry                    external dcl 118
glop                            000633 constant        label                    dcl 179 ref 184 195 211
glop1                           000640 constant        label                    dcl 181 ref 362
interpret_ptr_                  000213 constant        entry                    external dcl 10
ng                              002313 constant        label                    dcl 321 ref 319 327
nonobj                          001533 constant        label                    dcl 255 ref 194 212 233
oop                             002414 constant        entry                    internal dcl 343 ref 124 124
start                           000233 constant        label                    dcl 121 ref 116
xtarget                         002167 constant        label                    dcl 292 ref 251 258 268
xx                              002465 constant        label                    dcl 357 ref 350 351 352 353 354 355

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3202        3256    2725        3212
Length      3646    2725        54         354     254           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
interpret_ptr_                      542 external procedure  is an external procedure.  
check_access                            internal procedure  shares stack frame of external procedure interpret_ptr_.  
oop                                  65 internal procedure  is assigned to an entry variable.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
interpret_ptr_           000100 condinfo                    interpret_ptr_
                         000132 oi                          interpret_ptr_
                         000220 situation                   interpret_ptr_
                         000221 auto_interpret_link_info    interpret_ptr_
                         000354 xp                          interpret_ptr_
                         000356 frame_owner_sw              interpret_ptr_
                         000360 coptr                       interpret_ptr_
                         000362 coflg                       interpret_ptr_
                         000364 in_ptr                      interpret_ptr_
                         000366 framep                      interpret_ptr_
                         000370 hcsct                       interpret_ptr_
                         000371 highct                      interpret_ptr_
                         000372 txtp                        interpret_ptr_
                         000374 rings                       interpret_ptr_
                         000377 lev                         interpret_ptr_
                         000400 mode                        interpret_ptr_
                         000401 type                        interpret_ptr_
                         000402 bc                          interpret_ptr_
                         000403 bc1                         interpret_ptr_
                         000404 bmp                         interpret_ptr_
                         000406 sblkp                       interpret_ptr_
                         000410 namp                        interpret_ptr_
                         000412 naml                        interpret_ptr_
                         000413 i                           interpret_ptr_
                         000414 j                           interpret_ptr_
                         000415 dirn                        interpret_ptr_
                         000467 ename                       interpret_ptr_
                         000477 pl1_op_name                 interpret_ptr_
                         000507 segn                        interpret_ptr_
                         000517 segno                       interpret_ptr_
                         000520 adjusted_offset             interpret_ptr_
                         000522 section                     interpret_ptr_
                         000524 lang                        interpret_ptr_
                         000526 op_seg_name                 interpret_ptr_
                         000536 ec                          interpret_ptr_
                         000537 ctmp                        interpret_ptr_
                         000560 ci                          interpret_ptr_
                         000630 mcp                         interpret_ptr_
                         000632 scup                        interpret_ptr_
                         000644 ec                          check_access

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac          tra_ext_1
shorten_stack       ext_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
component_info_$offset        condition_                    cu_$level_get                 find_condition_info_
find_nonobject_info_          find_operator_name_           get_bound_seg_info_           get_entry_name_
hcs_$fs_get_brackets          hcs_$fs_get_path_name         hcs_$high_low_seg_count       hcs_$status_mins
interpret_link_               ioa_$rsnnl                    is_condition_frame_           object_info_$display
ring0_get_$name               stack_frame_exit_

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     56 000200        10 000207       115 000221       116 000222       118 000223       121 000233       123 000240
    124 000244       125 000270       126 000274       127 000277       132 000321       133 000336       134 000340
    135 000342       136 000344       137 000346       138 000352       141 000355       142 000402       143 000405
    144 000410       145 000412       146 000414       147 000416       148 000420       149 000424       150 000430
    151 000433       152 000444       153 000447       154 000500       155 000504       156 000532       160 000540
    161 000542       162 000547       163 000552       166 000553       168 000560       170 000563       172 000600
    173 000602       174 000610       175 000613       176 000617       177 000624       178 000625       179 000633
    181 000640       184 000641       186 000643       187 000651       188 000661       190 000706       191 000710
    192 000716       193 000720       194 000722       195 000725       201 000727       202 000731       204 000762
    205 000772       207 001000       208 001025       210 001030       211 001032       212 001035       214 001037
    215 001043       216 001063       219 001105       221 001106       223 001137       224 001145       225 001176
    227 001236       228 001251       229 001257       230 001261       231 001311       232 001313       233 001334
    234 001336       235 001344       236 001353       237 001355       238 001361       239 001364       240 001410
    241 001412       242 001421       243 001426       244 001430       245 001434       246 001467       247 001475
    248 001504       251 001532       255 001533       257 001567       258 001574       259 001600       261 001613
    262 001631       263 001637       267 001640       268 001675       269 001677       270 001744       271 001765
    272 001767       273 002016       274 002020       276 002050       277 002052       278 002056       279 002065
    280 002070       285 002135       286 002141       287 002157       292 002167       294 002176       295 002211
    296 002214       297 002244       298 002245       303 002246       312 002250       313 002251       315 002265
    316 002267       318 002270       319 002306       320 002310       321 002313       323 002316       325 002317
    326 002326       327 002354       328 002356       329 002361       330 002364       332 002365       333 002374
    334 002401       335 002404       337 002405       339 002412       343 002413       350 002427       351 002435
    352 002441       353 002445       354 002451       355 002455       356 002461       357 002465       359 002471
    362 002472       364 002501


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
