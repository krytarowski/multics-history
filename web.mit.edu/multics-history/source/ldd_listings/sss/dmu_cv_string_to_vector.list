	COMPILATION LISTING OF SEGMENT dmu_cv_string_to_vector
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/05/85  0845.6 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*          Converts data in the form of a non-varying bit string, formatted
        9*     according to the supplied field_table, to a simple typed vector
       10*     structure.  The new typed_vector is allocated in the caller-supplied
       11*     area.  The caller may supply a list of fields to be converted, in which
       12*     case the fields are converted to vector "values" and ordered in the
       13*     returned vector in the same order as they appear in the caller-supplied
       14*     id_list structure.  If the id_list_ptr is null, then a simple
       15*     typed_vector containing all of the fields in the field_table is returned.
       16**/
       17 
       18 /* HISTORY:
       19*Written by Lindsey Spratt, 04/20/82, from dmu_cv_vector_to_string.
       20*Modified:
       21*05/17/82 by Lindsey Spratt: Changed to use (varying_field_idx > 0) to
       22*	  determine if the field under consideration is a varying string or
       23*	  not.  Also, converted from the field_id_list structure to the
       24*	  id_list structure.
       25*10/19/82 by Lindsey Spratt:  Fixed cv_field to use a parameter to  specify
       26*	  which dimension of the simple_typed_vector is to be used as the
       27*	  target of the conversion.
       28*12/09/82 by Lindsey Spratt:  Fixed handling of varying character strings to
       29*	  interpret the length variable value correctly.
       30*02/04/83 by Lindsey Spratt:  Fixed to deal with varying strings correctly when
       31*	  given an id_list.
       32*02/08/83 by Lindsey Spratt:  Added a new entry point, called "new" which sets
       33*	  the value of simple_typed_vector_ptr to p_simple_typed_vector_ptr
       34*	  rather than always making it null.  Changed the rest of the module
       35*	  to use the passed in simple_typed_vector if there is one.  A new
       36*	  entry point was added so that modules could be converted over to
       37*	  use the new approach (which relies on the caller being very
       38*	  careful about the INPUT value of p_simple_typed_vector_ptr) in a
       39*	  gradual fashion.
       40*03/22/83 by Lindsey Spratt:  Changed to use version 2 field_table.  Changed to
       41*	  check version numbers in the field_table and id_lsit structures.
       42*04/03/83 by Lindsey L. Spratt:  Fixed vs_length to be declared fixed bin (35)
       43*            instead of fixed bin (17).
       44*04/03/83 by Lindsey L. Spratt:  Made version check of the id_list structure
       45*            conditional on whether the id_list_ptr is null or not.
       46*04/04/83 by Lindsey L. Spratt:  Fixed the re-use of the
       47*            current_varying_field_bit_index in the non-null id_list case.
       48*06/14/83 by Matthew Pierret:  Changed to leave an empty
       49*            simple_typed_vector.value_ptr entry for each non-positive id in
       50*            the given id_list.  Added a cleanup handler to free an allocated
       51*            simple_typed_vector.  This is incomplete, as the values are not
       52*            also freed.  Added copyright notice.
       53*02/22/84 by Matthew Pierret:  Changed cv_field to two separate routines,
       54*            CV_VARYING_FIELD and CV_NONVARYING_FIELD.  Changed the way fields
       55*            are converted, from using a substr approach to usign an overlay 
       56*            approach, in hopes of enhancing efficiency.  Added a check to
       57*            see if all of the given id_list actually contains all fields in
       58*            the order defined in in field_table.  If so, pretend that no
       59*            id_list was supplied as the conversion of the all fields is
       60*            faster than selected fields.
       61*02/24/84 by Matthew Pierret:  Fixed improper use of addbitno builtin. The 
       62*            number addbitno takes is an offset, but was being used as an index.
       63*05/03/84 by Matthew Pierret:  Changed to FIELD_TABLE_VERSION_3.
       64*05/03/84 by Matthew Pierret:  Changed to use dm_error_$bad_vector_type instead
       65*            of vd_error_$bad_vector_structure_type.
       66*10/13/84 by Lindsey L. Spratt:  Fixed to set p_code to 0 on entry.  Deleted
       67*            unused variables and changed to pass id_list.version by reference
       68*            in call to CHECK_VERSION, in response to audit comments.
       69*02/04/85 by Lindsey L. Spratt:  Added area condition handler and the
       70*            ERROR_RETURN proc.
       71**/
       72 
       73 /* format: style2,ind3 */
       74 
       75 dmu_cv_string_to_vector:
       76    proc;
       77       call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
       78 	 "^/An invalid entry (dmu_cv_string_to_vector$dmu_cv_string_to_vector) was
       79 invoked.");
       80 
       81 
       82 /* START OF DECLARATIONS */
       83 /* Parameter */
       84 
       85       dcl	    p_field_table_ptr      ptr;
       86       dcl	    p_work_area_ptr	       ptr;
       87       dcl	    p_id_list_ptr	       ptr;
       88       dcl	    p_typed_vector_ptr     ptr;
       89       dcl	    p_string_length	       fixed bin (35);
       90       dcl	    p_string_ptr	       ptr;
       91       dcl	    p_code	       fixed bin (35);
       92 
       93 /* Automatic */
       94 
       95       dcl	    input_string_ptr       ptr;
       96 
       97       dcl	    id_list_idx	       fixed bin;
       98 
       99       dcl	    old_varying_field_idx  fixed bin (35) init (0);
      100       dcl	    current_varying_field_idx
      101 			       fixed bin (35) init (0);
      102       dcl	    field_idx	       fixed bin (17);
      103       dcl	    current_varying_field_bit_index
      104 			       fixed bin (35);
      105       dcl	    work_area_ptr	       ptr;
      106 
      107 /* Based */
      108 
      109       dcl	    work_area	       area (sys_info$max_seg_size) based (work_area_ptr);
      110 
      111 /* Builtin */
      112 
      113       dcl	    (addbitno, bin, null)  builtin;
      114 
      115 /* Condition */
      116 
      117       dcl	    (area, cleanup)	       condition;
      118 
      119 /* Constant */
      120 
      121       dcl	    myname	       init ("dmu_cv_string_to_vector") char (32) varying internal static
      122 			       options (constant);
      123 
      124       dcl	    BITS_PER_BYTE	       init (9) fixed bin (17) int static options (constant);
      125 
      126 /* Entry */
      127 
      128       dcl	    sub_err_	       entry () options (variable);
      129 
      130 /* External */
      131 
      132       dcl	    (
      133 	    error_table_$area_too_small,
      134 	    error_table_$unimplemented_version
      135 	    )		       fixed bin (35) ext;
      136       dcl	    sys_info$max_seg_size  fixed bin (35) ext static;
      137       dcl	    (dm_error_$programming_error)
      138 			       fixed bin (35) ext;
      139       dcl	    dm_error_$bad_vector_type
      140 			       fixed bin (35) ext;
      141 
      142 /* END OF DECLARATIONS */
      143 
      144 old:
      145    entry (p_field_table_ptr, p_work_area_ptr, p_string_ptr, p_string_length, p_id_list_ptr, p_typed_vector_ptr, p_code);
      146       simple_typed_vector_ptr = null;
      147       goto JOIN;
      148 
      149 new:
      150    entry (p_field_table_ptr, p_work_area_ptr, p_string_ptr, p_string_length, p_id_list_ptr, p_typed_vector_ptr, p_code);
      151       simple_typed_vector_ptr = p_typed_vector_ptr;
      152 
      153 JOIN:
      154       p_code = 0;
      155       input_string_ptr = p_string_ptr;
      156 
      157       field_table_ptr = p_field_table_ptr;
      158       call CHECK_VERSION_CHAR (field_table.version, FIELD_TABLE_VERSION_3, "field_table");
      159 
      160       id_list_ptr = p_id_list_ptr;
      161       work_area_ptr = p_work_area_ptr;
      162 
      163       current_varying_field_bit_index = field_table.location_of_first_varying_field;
      164 
      165       on area call ERROR_RETURN (error_table_$area_too_small);
      166 
      167       if id_list_ptr ^= null
      168       then
      169          do;
      170 	  call CHECK_VERSION (id_list.version, (ID_LIST_VERSION_1), "id_list");
      171 
      172 /* See if the id_list actually contains all fields */
      173 
      174 	  if id_list.number_of_ids = field_table.number_of_fields
      175 	  then
      176 	     do;
      177 	        do id_list_idx = 1 to id_list.number_of_ids while (id_list_idx = id_list.id (id_list_idx));
      178 	        end;
      179 	        if id_list_idx > id_list.number_of_ids	/* contains all fields in order */
      180 	        then id_list_ptr = null;
      181 	     end;
      182          end;
      183 
      184       if id_list_ptr = null
      185       then
      186          do;
      187 	  if simple_typed_vector_ptr = null
      188 	  then
      189 	     do;
      190 	        on cleanup call FINISH;
      191 
      192 	        stv_number_of_dimensions = field_table.number_of_fields;
      193 	        alloc simple_typed_vector in (work_area);
      194 	        simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
      195 	        simple_typed_vector.dimension.value_ptr = null;
      196 	     end;
      197 	  else if simple_typed_vector.type ^= SIMPLE_TYPED_VECTOR_TYPE
      198 	  then call sub_err_ (dm_error_$bad_vector_type, myname, ACTION_CANT_RESTART, null, 0,
      199 		  "^/Expected a ""simple"" typed_vector (type = ^d).
      200 Received instead a typed_vector with type = ^d.", SIMPLE_TYPED_VECTOR_TYPE, simple_typed_vector.type);
      201 	  else if simple_typed_vector.number_of_dimensions < field_table.number_of_fields
      202 	  then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
      203 		  "^/The provided ""simple"" typed_vector has only ^d dimensions, while the 
      204 number of dimensions requested is ^d.", simple_typed_vector.number_of_dimensions, field_table.number_of_fields);
      205 
      206 
      207 	  do field_idx = 1 to field_table.number_of_fields;
      208 	     if field_table.varying_field_map (field_idx).varying_field_index <= 0
      209 	     then call CV_NONVARYING_FIELD (field_idx, field_idx);
      210 	     else call CV_VARYING_FIELD (field_idx, field_idx, current_varying_field_bit_index);
      211 	  end;
      212          end;
      213       else
      214          do;
      215 	  if simple_typed_vector_ptr = null
      216 	  then
      217 	     do;
      218 	        on cleanup call FINISH;
      219 
      220 	        stv_number_of_dimensions = id_list.number_of_ids;
      221 	        alloc simple_typed_vector in (work_area);
      222 	        simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
      223 	        simple_typed_vector.dimension.value_ptr = null;
      224 	     end;
      225 	  else if simple_typed_vector.type ^= SIMPLE_TYPED_VECTOR_TYPE
      226 	  then call sub_err_ (dm_error_$bad_vector_type, myname, ACTION_CANT_RESTART, null, 0,
      227 		  "^/Expected a ""simple"" typed_vector (type = ^d).
      228 Received instead a typed_vector with type = ^d.", SIMPLE_TYPED_VECTOR_TYPE, simple_typed_vector.type);
      229 	  else if simple_typed_vector.number_of_dimensions < id_list.number_of_ids
      230 	  then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
      231 		  "^/The provided ""simple"" typed_vector has only ^d dimensions, while the 
      232 number of dimensions requested is ^d.", simple_typed_vector.number_of_dimensions, id_list.number_of_ids);
      233 
      234 
      235 	  do id_list_idx = 1 to id_list.number_of_ids;
      236 
      237 	     field_idx = id_list.id (id_list_idx);
      238 
      239 	     if field_idx >= 1			/* If field_idx < 1, ignore it. */
      240 	     then
      241 	        do;
      242 		 current_varying_field_idx = field_table.varying_field_map (field_idx).varying_field_index;
      243 
      244 		 if current_varying_field_idx <= 0
      245 		 then call CV_NONVARYING_FIELD (id_list_idx, field_idx);
      246 		 else
      247 		    do;				/* Current field is varying */
      248 		       if current_varying_field_idx ^= old_varying_field_idx + 1
      249 						/* The current_varying_field_bit_index is not valid for the current field. */
      250 		       then current_varying_field_bit_index = -1;
      251 		       old_varying_field_idx = current_varying_field_idx;
      252 
      253 		       call CV_VARYING_FIELD (id_list_idx, field_idx, current_varying_field_bit_index);
      254 		    end;
      255 	        end;
      256 	  end;
      257          end;
      258 
      259 
      260       if p_typed_vector_ptr ^= simple_typed_vector_ptr
      261       then p_typed_vector_ptr = simple_typed_vector_ptr;
      262 
      263 MAIN_RETURN:
      264       return;
      265 
      266 FINISH:
      267    proc ();
      268 
      269 
      270       if simple_typed_vector_ptr ^= null & simple_typed_vector_ptr ^= p_typed_vector_ptr
      271       then free simple_typed_vector in (work_area);
      272 
      273 /**** Also need to free dimension values. */
      274 
      275    end FINISH;
      276 
      277 
      278 ERROR_RETURN:
      279    proc (er_p_code);
      280       dcl	    er_p_code	       fixed bin (35) parm;
      281       p_code = er_p_code;
      282       call FINISH ();
      283       goto MAIN_RETURN;
      284    end ERROR_RETURN;
      285 
      286 CV_VARYING_FIELD:
      287    proc (cvf_p_dimension_idx, cvf_p_field_idx, cvf_p_current_varying_field_bit_index);
      288 
      289 /* This routine copies the value of a varying field in the input string to
      290*   a stand-alone varying dimension string. The location of the varying field
      291*   in the input string is determined by adding up the lengths of all prior
      292*   varying fields in the input string and the location of the first varying
      293*   field. */
      294 
      295 /* Global variables:
      296*
      297*   input_string_ptr - points to the input string
      298*   simple_typed_vector - the simple_typed_vector which holds the dimension
      299*                         values to be returned.
      300*   field_table - the field_table describing the fields in the input string.
      301*   work_area - the area in which this program allocates things.
      302**/
      303 
      304       dcl	    cvf_p_dimension_idx    fixed bin;
      305       dcl	    cvf_p_field_idx	       fixed bin;
      306       dcl	    cvf_p_current_varying_field_bit_index
      307 			       fixed bin (35);
      308 
      309       dcl	    cvf_field_idx	       fixed bin;
      310       dcl	    cvf_current_varying_field_bit_index
      311 			       fixed bin (35);
      312 
      313       dcl	    cvf_varying_field_idx  fixed bin init (0);	/* index into field_table.varying_field_map for each prior varying field */
      314       dcl	    cvf_temp_field_idx     fixed bin init (0);	/* index into field_table.field for each prior varying field */
      315       dcl	    cvf_temp_varying_field_length
      316 			       fixed bin (35) init (0);
      317 						/* length of each prior varying field */
      318 
      319       dcl	    cvf_dimension_value_string
      320 			       bit (cvf_dimension_value_length) varying based (cvf_dimension_value_ptr);
      321 						/* Varying bit string which holds converted field value */
      322       dcl	    cvf_dimension_value_length
      323 			       fixed bin (35) init (0);
      324       dcl	    cvf_dimension_value_ptr
      325 			       ptr init (null);
      326 
      327       dcl	    cvf_dimension_value_length_overlay
      328 			       fixed bin (35) based (cvf_dimension_value_ptr);
      329 						/* Overlays the length word of the varying dimension_value_string */
      330 						/* This is used to change the length from bit- to character-length*/
      331       dcl	    cvf_dimension_value_length_in_characters
      332 			       fixed bin (35) init (0);
      333 						/* Saved length of the dimension in characters. */
      334 
      335       dcl	    cvf_field_value_string bit (cvf_dimension_value_length) based (cvf_field_value_ptr);
      336 						/* Non-varying bit string overlay of field in input string */
      337       dcl	    cvf_field_value_ptr    ptr init (null);
      338 
      339       dcl	    cvf_length_field_string
      340 			       bit (cvf_length_field_length) based (cvf_length_field_ptr);
      341 						/* Bit string overlay of varying field length in input string */
      342       dcl	    cvf_length_field_length
      343 			       fixed bin (35) init (0);
      344       dcl	    cvf_length_field_ptr   ptr init (null);
      345 
      346       dcl	    cvf_field_length_is_in_characters
      347 			       bit (1) aligned init ("0"b);
      348 
      349 
      350 
      351       cvf_field_idx = cvf_p_field_idx;			/* for efficiency */
      352       cvf_current_varying_field_bit_index = cvf_p_current_varying_field_bit_index;
      353 
      354 
      355       if cvf_current_varying_field_bit_index = -1
      356       then /* Find location of varying field */
      357          do;
      358 	  cvf_current_varying_field_bit_index = field_table.location_of_first_varying_field;
      359 
      360 CVF_LOOP_THROUGH_VARYING_FIELDS:
      361 	  do cvf_varying_field_idx = 1 to field_table.varying_field_map (cvf_field_idx).varying_field_index - 1;
      362 
      363 	     cvf_temp_field_idx = field_table.varying_field_map (cvf_varying_field_idx).field_id;
      364 	     cvf_length_field_length = field_table.field (cvf_temp_field_idx).length_in_bits;
      365 	     cvf_length_field_ptr = addbitno (input_string_ptr, field_table.field (cvf_temp_field_idx).location - 1);
      366 	     cvf_temp_varying_field_length = bin (cvf_length_field_string, 35, 0);
      367 
      368 	     if field_table.field (cvf_temp_field_idx).flags.length_is_in_characters
      369 	     then cvf_temp_varying_field_length = cvf_temp_varying_field_length * BITS_PER_BYTE;
      370 
      371 	     cvf_current_varying_field_bit_index = cvf_current_varying_field_bit_index + cvf_temp_varying_field_length;
      372 
      373 	  end CVF_LOOP_THROUGH_VARYING_FIELDS;
      374 
      375          end;
      376 
      377 
      378 /* Set the length of the dimension */
      379 
      380       cvf_length_field_length = field_table.field (cvf_field_idx).length_in_bits;
      381       cvf_length_field_ptr = addbitno (input_string_ptr, field_table.field (cvf_field_idx).location - 1);
      382       cvf_dimension_value_length = bin (cvf_length_field_string, 35, 0);
      383 
      384       cvf_field_length_is_in_characters = field_table.field (cvf_field_idx).flags.length_is_in_characters;
      385       if cvf_field_length_is_in_characters		/* Change character length to bit length */
      386       then
      387          do;
      388 	  cvf_dimension_value_length_in_characters = cvf_dimension_value_length;
      389 	  cvf_dimension_value_length = cvf_dimension_value_length * BITS_PER_BYTE;
      390          end;
      391 
      392 /* Set the pointer to the dimension to return */
      393 
      394       cvf_dimension_value_ptr = simple_typed_vector.dimension (cvf_p_dimension_idx).value_ptr;
      395       if cvf_dimension_value_ptr = null
      396       then
      397          do;
      398 	  alloc cvf_dimension_value_string in (work_area);
      399 	  simple_typed_vector.dimension (cvf_p_dimension_idx).value_ptr = cvf_dimension_value_ptr;
      400          end;
      401 
      402       cvf_field_value_ptr = addbitno (input_string_ptr, cvf_current_varying_field_bit_index - 1);
      403 
      404       cvf_dimension_value_string = cvf_field_value_string;	/* Copy the value */
      405 
      406       if cvf_field_length_is_in_characters
      407       then cvf_dimension_value_length_overlay = cvf_dimension_value_length_in_characters;
      408 
      409       cvf_p_current_varying_field_bit_index = cvf_current_varying_field_bit_index + cvf_dimension_value_length;
      410 						/* Set return value */
      411 
      412       return;
      413 
      414    end CV_VARYING_FIELD;
      415 
      416 CV_NONVARYING_FIELD:
      417    proc (cnf_p_dimension_idx, cnf_p_field_idx);
      418 
      419 /* This routine copies the value of the cnf_p_field_idx'th field in the
      420*   string into a stand-alone, nonvarying dimension value. */
      421 
      422       dcl	    cnf_p_dimension_idx    fixed bin;
      423       dcl	    cnf_p_field_idx	       fixed bin;
      424 
      425       dcl	    cnf_field_idx	       fixed bin;		/* Local copy for efficiency */
      426       dcl	    cnf_field_value_ptr    ptr;
      427       dcl	    cnf_dimension_value_ptr
      428 			       ptr;
      429       dcl	    cnf_dimension_value_length
      430 			       fixed bin;		/* Length of dimension value in bits */
      431       dcl	    cnf_dimension_value_string
      432 			       bit (cnf_dimension_value_length) based (cnf_dimension_value_ptr);
      433 
      434 /* Global variables:
      435*
      436*   input_string_ptr - points to the input string
      437*   simple_typed_vector - the simple_typed_vector which holds the dimension
      438*                         values to be returned.
      439*   field_table - the field_table describing the fields in the input string.
      440*   work_area - the area in which this program allocates things.
      441**/
      442 
      443       cnf_field_idx = cnf_p_field_idx;
      444 
      445       cnf_dimension_value_length = field_table.field (cnf_field_idx).length_in_bits;
      446       cnf_dimension_value_ptr = simple_typed_vector.dimension (cnf_p_dimension_idx).value_ptr;
      447       if cnf_dimension_value_ptr = null
      448       then
      449          do;
      450 	  alloc cnf_dimension_value_string in (work_area);
      451 	  simple_typed_vector.dimension (cnf_p_dimension_idx).value_ptr = cnf_dimension_value_ptr;
      452          end;
      453 
      454       cnf_field_value_ptr = addbitno (input_string_ptr, field_table.field (cnf_field_idx).location - 1);
      455 
      456       cnf_dimension_value_string = cnf_field_value_ptr -> cnf_dimension_value_string;
      457 
      458       return;
      459 
      460    end CV_NONVARYING_FIELD;
      461 
      462 CHECK_VERSION_CHAR:
      463    proc (p_received_version, p_expected_version, p_structure_name);
      464       dcl	    p_received_version     char (8) aligned parameter;
      465       dcl	    p_expected_version     char (8) aligned parameter;
      466       dcl	    p_structure_name       char (*) parameter;
      467 
      468       if p_received_version ^= p_expected_version
      469       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      470 	      "^/Expected version ^a of the ^a structure. Received version ^a.", p_expected_version, p_structure_name,
      471 	      p_received_version);
      472 
      473    end CHECK_VERSION_CHAR;
      474 
      475 CHECK_VERSION:
      476    proc (p_received_version, p_expected_version, p_structure_name);
      477       dcl	    p_received_version     fixed bin (35) parameter;
      478       dcl	    p_expected_version     fixed bin (35) parameter;
      479       dcl	    p_structure_name       char (*) parameter;
      480 
      481       if p_received_version ^= p_expected_version
      482       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      483 	      "^/Expected version ^d of the ^a structure. Received version ^d.", p_expected_version, p_structure_name,
      484 	      p_received_version);
      485 
      486    end CHECK_VERSION;
      487 
  1     1 /* ***********************************************************
  1     2*   *                                                         *
  1     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  1     4*   *                                                         *
  1     5*   *********************************************************** */
  1     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  1     7 
  1     8 /* Written by Lindsey Spratt, 04/02/82.
  1     9*Modified:
  1    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  1    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  1    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  1    13*	  type.
  1    14**/
  1    15 
  1    16 /* format: style2,ind3 */
  1    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  1    18 	     2 type	      fixed bin (17) unal,
  1    19 	     2 number_of_dimensions
  1    20 			      fixed bin (17) unal,
  1    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  1    22 	       3 value_ptr	      ptr unaligned;
  1    23 
  1    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  1    25 	     2 type	      fixed bin (17) unal,
  1    26 	     2 number_of_dimensions
  1    27 			      fixed bin (17) unal,
  1    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  1    29 	       3 identifier	      fixed bin (17) unal,
  1    30 	       3 pad	      bit (18) unal,
  1    31 	       3 value_ptr	      ptr unal;
  1    32 
  1    33      dcl	   simple_typed_vector_ptr
  1    34 			      ptr;
  1    35      dcl	   stv_number_of_dimensions
  1    36 			      fixed bin (17);
  1    37 
  1    38      dcl	   general_typed_vector_ptr
  1    39 			      ptr;
  1    40      dcl	   gtv_number_of_dimensions
  1    41 			      fixed bin (17);
  1    42 
  1    43      dcl	   (
  1    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  1    45 			      init (1),		/* value_ptr was aligned. */
  1    46 	   GENERAL_TYPED_VECTOR_TYPE
  1    47 			      init (2),
  1    48 	   SIMPLE_TYPED_VECTOR_TYPE
  1    49 			      init (3)
  1    50 	   )		      fixed bin (17) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      488 
      489 
  2     1 /* ********** BEGIN INCLUDE FILE dm_field_table.incl.pl1 ********** */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*          The field_table describes the layout of a set of fields in a
  2     6*     formatted data string.  Such a string is the stored representation of a
  2     7*     record or a key.  Fields are placed side-by-side in the string in the
  2     8*     order they appear in the field_table.field array.  The string is divided
  2     9*     into the fixed portion and the varying portion.  In the fixed portion
  2    10*     appear fixed-length fields and fixed-size length-fields for
  2    11*     varying-length fields.  In the varying portion appear varying length
  2    12*     fields.  The length-field for a varying-length field contains the length
  2    13*     of the field values either in bits or in characters, depending on the
  2    14*     data type of the field.
  2    15**/
  2    16 
  2    17 /* HISTORY:
  2    18*Written by Matthew Pierret, 04/01/82.
  2    19*Modified:
  2    20*04/20/82 by Matthew Pierret: Added length_is_in_characters, meaning, if on,
  2    21*	  that if the field is varying, its length is expressed in
  2    22*	  bytes/characters.
  2    23*03/22/83 by Lindsey Spratt:  Changed lofvf to have a precision of 35 instead
  2    24*	  of 17, changed version to 2, changed version field to char(8) from
  2    25*	  fixed bin (17).
  2    26*05/01/84 by Matthew Pierret:  Changed version to 3. Removed field.name and
  2    27*            put field names in one string (field_names) at the end of the 
  2    28*            structure. Added field.location_of_name and field.length_of_name
  2    29*            for locating the field name in field_names. Aligned all "fixed bin"
  2    30*            structure elements.  Changed maximum_field_name_length to 
  2    31*            length_of_field_names.
  2    32**/
  2    33 
  2    34 /* format: style2 */
  2    35 
  2    36      dcl	   1 field_table	      aligned based (field_table_ptr),
  2    37 	     2 version	      char (8) aligned init (FIELD_TABLE_VERSION_3),
  2    38 	     2 number_of_fields   fixed bin (17),
  2    39 	     2 length_of_field_names
  2    40 			      fixed bin (17),	/* length of field_names in characters */
  2    41 	     2 location_of_first_varying_field
  2    42 			      fixed bin (35),	/* location of first bit in the varying portion of the formatted string */
  2    43 	     2 field	      (ft_number_of_fields refer (field_table.number_of_fields)),
  2    44 	       3 flags	      aligned,
  2    45 	         4 descriptor_is_varying
  2    46 			      bit (1) unal,		/* if on, the descriptor is not limited to the standard 36 bits */
  2    47 						/* and is stored in a stand-alone fashion, with field.descriptor */
  2    48 						/* containing the id of the element in which the descriptor is stored. */
  2    49 	         4 length_is_in_characters
  2    50 			      bit (1) unal,		/* if field is varying, the length field describes its length */
  2    51 						/* in characters instead of in bits */
  2    52 	         4 must_be_zero   bit (34) unal,
  2    53 	       3 descriptor	      bit (36) aligned,
  2    54 	       3 location	      fixed bin (35),	/* location of first bit of field in formatted string */
  2    55 	       3 length_in_bits   fixed bin (35),	/* length of field in bits */
  2    56 	     3 location_of_name   fixed bin (17),	/* location of first character of field name in field_names */
  2    57 	     3 length_of_name     fixed bin (17),	/* length of name in characters */
  2    58 	     2 varying_field_map  (ft_number_of_fields refer (field_table.number_of_fields)),
  2    59 	       3 field_id	      fixed bin (17),	/* field_id of Nth varying field */
  2    60 	       3 varying_field_index
  2    61 			      fixed bin (17),	/* ordinality among varying fields of field N */
  2    62 	     2 field_names	      char (ft_length_of_field_names refer (field_table.length_of_field_names));
  2    63 
  2    64 
  2    65      dcl	   field_table_ptr	      ptr;
  2    66      dcl	   ft_length_of_field_names
  2    67 			      fixed bin;
  2    68      dcl	   ft_number_of_fields    fixed bin;
  2    69      dcl	   FIELD_TABLE_VERSION_3  char (8) aligned init ("FldTbl 3") internal static options (constant);
  2    70 
  2    71 dcl field_name char (field_name_length) based (field_name_ptr);
  2    72 
  2    73 dcl field_name_length fixed bin;
  2    74 dcl field_name_ptr ptr;
  2    75 
  2    76 /* END INCLUDE FILE dm_field_table.incl.pl1 */
      490 
      491 
  3     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION
  3     4*        The id_list structure is used to identify attributes, fields and
  3     5*   dimensions by various modules of the Data Management System.
  3     6**/
  3     7 
  3     8 /* HISTORY:
  3     9*Written by Matthew Pierret, '82.
  3    10*Modified:
  3    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  3    12*            (constant)' and to initialize automatic variables.
  3    13**/
  3    14 
  3    15 /* format: style2,ind3 */
  3    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  3    17 	     2 version	      fixed bin (35),
  3    18 	     2 number_of_ids      fixed bin (17),
  3    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  3    20 
  3    21      dcl	   id_list_ptr	      ptr init (null);
  3    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  3    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  3    24 
  3    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      492 
      493 
  4     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  4     2 /* format: style3 */
  4     3 
  4     4 /* These constants are to be used for the flags argument of sub_err_ */
  4     5 /* They are just "string (condition_info_header.action_flags)" */
  4     6 
  4     7 declare	(
  4     8 	ACTION_CAN_RESTART	init (""b),
  4     9 	ACTION_CANT_RESTART init ("1"b),
  4    10 	ACTION_DEFAULT_RESTART
  4    11 			init ("01"b),
  4    12 	ACTION_QUIET_RESTART
  4    13 			init ("001"b),
  4    14 	ACTION_SUPPORT_SIGNAL
  4    15 			init ("0001"b)
  4    16 	)		bit (36) aligned internal static options (constant);
  4    17 
  4    18 /* End include file */
      494 
      495    end dmu_cv_string_to_vector;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/05/85  0755.1  dmu_cv_string_to_vector.pl1       >spec>on>7138.pbf>dmu_cv_string_to_vector.pl1
488          1    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
490          2    01/07/85  0858.8  dm_field_table.incl.pl1           >ldd>include>dm_field_table.incl.pl1
492          3    10/14/83  1609.1  dm_id_list.incl.pl1               >ldd>include>dm_id_list.incl.pl1
494          4    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000000 constant        bit(36)                  initial dcl 4-7 set ref 77* 197* 201* 225* 229* 468*
                                                                                  481*
BITS_PER_BYTE                          constant        fixed bin(17,0)          initial dcl 124 ref 368 389
FIELD_TABLE_VERSION_3           000002 constant        char(8)                  initial dcl 2-69 set ref 158*
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 3-23 ref 170
SIMPLE_TYPED_VECTOR_TYPE        000033 constant        fixed bin(17,0)          initial dcl 1-43 set ref 194 197 197* 222 225 225*
addbitno                                               builtin function         dcl 113 ref 365 381 402 454
area                            000112 stack reference condition                dcl 117 ref 165
bin                                                    builtin function         dcl 113 ref 366 382
cleanup                         000120 stack reference condition                dcl 117 ref 190 218
cnf_dimension_value_length      000210 automatic       fixed bin(17,0)          dcl 429 set ref 445* 450 450 456 456
cnf_dimension_value_ptr         000206 automatic       pointer                  dcl 427 set ref 446* 447 450* 451 456
cnf_dimension_value_string             based           bit                      unaligned dcl 431 set ref 450 456* 456
cnf_field_idx                   000202 automatic       fixed bin(17,0)          dcl 425 set ref 443* 445 454
cnf_field_value_ptr             000204 automatic       pointer                  dcl 426 set ref 454* 456
cnf_p_dimension_idx                    parameter       fixed bin(17,0)          dcl 422 ref 416 446 451
cnf_p_field_idx                        parameter       fixed bin(17,0)          dcl 423 ref 416 443
current_varying_field_bit_index 000106 automatic       fixed bin(35,0)          dcl 103 set ref 163* 210* 248* 253*
current_varying_field_idx       000104 automatic       fixed bin(35,0)          initial dcl 100 set ref 100* 242* 244 248 251
cvf_current_varying_field_bit_index
                                000153 automatic       fixed bin(35,0)          dcl 310 set ref 352* 355 358* 371* 371 402 409
cvf_dimension_value_length      000157 automatic       fixed bin(35,0)          initial dcl 322 set ref 322* 382* 388 389* 389 398
                                                                                  404 404 409
cvf_dimension_value_length_in_characters
                                000162 automatic       fixed bin(35,0)          initial dcl 331 set ref 331* 388* 406
cvf_dimension_value_length_overlay     based           fixed bin(35,0)          dcl 327 set ref 406*
cvf_dimension_value_ptr         000160 automatic       pointer                  initial dcl 324 set ref 324* 394* 395 398* 399 404
                                                                                  406
cvf_dimension_value_string             based           varying bit              dcl 319 set ref 398 404*
cvf_field_idx                   000152 automatic       fixed bin(17,0)          dcl 309 set ref 351* 360 380 381 384
cvf_field_length_is_in_characters
                                000172 automatic       bit(1)                   initial dcl 346 set ref 346* 384* 385 406
cvf_field_value_ptr             000164 automatic       pointer                  initial dcl 337 set ref 337* 402* 404
cvf_field_value_string                 based           bit                      unaligned dcl 335 ref 404
cvf_length_field_length         000166 automatic       fixed bin(35,0)          initial dcl 342 set ref 342* 364* 366 380* 382
cvf_length_field_ptr            000170 automatic       pointer                  initial dcl 344 set ref 344* 365* 366 381* 382
cvf_length_field_string                based           bit                      unaligned dcl 339 ref 366 382
cvf_p_current_varying_field_bit_index  parameter       fixed bin(35,0)          dcl 306 set ref 286 352 409*
cvf_p_dimension_idx                    parameter       fixed bin(17,0)          dcl 304 ref 286 394 399
cvf_p_field_idx                        parameter       fixed bin(17,0)          dcl 305 ref 286 351
cvf_temp_field_idx              000155 automatic       fixed bin(17,0)          initial dcl 314 set ref 314* 363* 364 365 368
cvf_temp_varying_field_length   000156 automatic       fixed bin(35,0)          initial dcl 315 set ref 315* 366* 368* 368 371
cvf_varying_field_idx           000154 automatic       fixed bin(17,0)          initial dcl 313 set ref 313* 360* 363*
dimension                 1            based           structure                array level 2 packed unaligned dcl 1-17
dm_error_$bad_vector_type       000020 external static fixed bin(35,0)          dcl 139 set ref 197* 225*
dm_error_$programming_error     000016 external static fixed bin(35,0)          dcl 137 set ref 77* 201* 229*
er_p_code                              parameter       fixed bin(35,0)          dcl 280 ref 278 281
error_table_$area_too_small     000012 external static fixed bin(35,0)          dcl 132 set ref 165*
error_table_$unimplemented_version
                                000014 external static fixed bin(35,0)          dcl 132 set ref 468* 481*
field                     5            based           structure                array level 2 dcl 2-36
field_id                               based           fixed bin(17,0)          array level 3 dcl 2-36 ref 363
field_idx                       000105 automatic       fixed bin(17,0)          dcl 102 set ref 207* 208 208* 208* 210* 210* 237*
                                                                                  239 242 244* 253*
field_table                            based           structure                level 1 dcl 2-36
field_table_ptr                 000132 automatic       pointer                  dcl 2-65 set ref 157* 158 163 174 192 201 201 207
                                                                                  208 242 358 360 363 364 365 368 380 381 384 445
                                                                                  454
flags                     5            based           structure                array level 3 dcl 2-36
id                        2            based           fixed bin(17,0)          array level 2 dcl 3-16 ref 177 237
id_list                                based           structure                level 1 dcl 3-16
id_list_idx                     000102 automatic       fixed bin(17,0)          dcl 97 set ref 177* 177 177* 179 235* 237 244* 253*
id_list_ptr                     000134 automatic       pointer                  initial dcl 3-21 set ref 160* 167 170 174 177 177
                                                                                  179 179* 184 220 229 229 235 237 3-21*
il_number_of_ids                000136 automatic       fixed bin(17,0)          initial dcl 3-22 set ref 3-22*
input_string_ptr                000100 automatic       pointer                  dcl 95 set ref 155* 365 381 402 454
length_in_bits           10            based           fixed bin(35,0)          array level 3 dcl 2-36 ref 364 380 445
length_is_in_characters
                          5(01)        based           bit(1)                   array level 4 packed unaligned dcl 2-36 ref 368 384
location                  7            based           fixed bin(35,0)          array level 3 dcl 2-36 ref 365 381 454
location_of_first_varying_field
                          4            based           fixed bin(35,0)          level 2 dcl 2-36 ref 163 358
myname                          000004 constant        varying char(32)         initial dcl 121 set ref 77* 197* 201* 225* 229* 468*
                                                                                  481*
null                                                   builtin function         dcl 113 ref 77 77 146 167 179 184 187 195 197 197
                                                                                  201 201 215 223 225 225 229 229 3-21 270 324 337
                                                                                  344 395 447 468 468 481 481
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-17 set ref 193* 195
                                                                                  201 201* 221* 223 229 229* 270
number_of_fields          2            based           fixed bin(17,0)          level 2 dcl 2-36 set ref 174 192 201 201* 207 208
                                                                                  242 360 363
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 3-16 set ref 174 177 179 220 229 229*
                                                                                  235
old_varying_field_idx           000103 automatic       fixed bin(35,0)          initial dcl 99 set ref 99* 248 251*
p_code                                 parameter       fixed bin(35,0)          dcl 91 set ref 144 149 153* 281*
p_expected_version                     parameter       char(8)                  dcl 465 in procedure "CHECK_VERSION_CHAR" set ref
                                                                                  462 468 468*
p_expected_version                     parameter       fixed bin(35,0)          dcl 478 in procedure "CHECK_VERSION" set ref 475 481
                                                                                  481*
p_field_table_ptr                      parameter       pointer                  dcl 85 ref 144 149 157
p_id_list_ptr                          parameter       pointer                  dcl 87 ref 144 149 160
p_received_version                     parameter       char(8)                  dcl 464 in procedure "CHECK_VERSION_CHAR" set ref
                                                                                  462 468 468*
p_received_version                     parameter       fixed bin(35,0)          dcl 477 in procedure "CHECK_VERSION" set ref 475 481
                                                                                  481*
p_string_length                        parameter       fixed bin(35,0)          dcl 89 ref 144 149
p_string_ptr                           parameter       pointer                  dcl 90 ref 144 149 155
p_structure_name                       parameter       char                     unaligned dcl 466 in procedure "CHECK_VERSION_CHAR"
                                                                                  set ref 462 468*
p_structure_name                       parameter       char                     unaligned dcl 479 in procedure "CHECK_VERSION" set
                                                                                  ref 475 481*
p_typed_vector_ptr                     parameter       pointer                  dcl 88 set ref 144 149 151 260 260* 270
p_work_area_ptr                        parameter       pointer                  dcl 86 ref 144 149 161
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 1-17 set ref 193 221
                                                                                  270
simple_typed_vector_ptr         000126 automatic       pointer                  dcl 1-33 set ref 146* 151* 187 193* 194 195 197 197
                                                                                  201 201 215 221* 222 223 225 225 229 229 260 260
                                                                                  270 270 270 394 399 446 451
stv_number_of_dimensions        000130 automatic       fixed bin(17,0)          dcl 1-35 set ref 192* 193 193 220* 221 221
sub_err_                        000010 constant        entry                    external dcl 128 ref 77 197 201 225 229 468 481
type                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 1-17 set ref 194* 197
                                                                                  197* 222* 225 225*
value_ptr                 1            based           pointer                  array level 3 packed unaligned dcl 1-17 set ref 195*
                                                                                  223* 394 399* 446 451*
varying_field_index                    based           fixed bin(17,0)          array level 3 dcl 2-36 ref 208 242 360
varying_field_map                      based           structure                array level 2 dcl 2-36
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 3-16 in procedure
                                                                                  "dmu_cv_string_to_vector" set ref 170*
version                                based           char(8)                  initial level 2 in structure "field_table" dcl 2-36
                                                                                  in procedure "dmu_cv_string_to_vector" set ref
                                                                                  158*
work_area                              based           area                     dcl 109 ref 193 221 270 398 450
work_area_ptr                   000110 automatic       pointer                  dcl 105 set ref 161* 193 221 270 398 450

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 4-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 4-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 4-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 4-7
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 1-43
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 1-43
field_name                             based           char                     unaligned dcl 2-71
field_name_length                      automatic       fixed bin(17,0)          dcl 2-73
field_name_ptr                         automatic       pointer                  dcl 2-74
ft_length_of_field_names               automatic       fixed bin(17,0)          dcl 2-66
ft_number_of_fields                    automatic       fixed bin(17,0)          dcl 2-68
general_typed_vector                   based           structure                level 1 packed unaligned dcl 1-24
general_typed_vector_ptr               automatic       pointer                  dcl 1-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 1-40
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 136

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   002021 constant        entry                    internal dcl 475 ref 170
CHECK_VERSION_CHAR              001717 constant        entry                    internal dcl 462 ref 158
CVF_LOOP_THROUGH_VARYING_FIELDS 001433 constant        label                    dcl 360
CV_NONVARYING_FIELD             001635 constant        entry                    internal dcl 416 ref 208 244
CV_VARYING_FIELD                001405 constant        entry                    internal dcl 286 ref 210 253
ERROR_RETURN                    001367 constant        entry                    internal dcl 278 ref 165
FINISH                          001336 constant        entry                    internal dcl 266 ref 190 218 282
JOIN                            000337 constant        label                    dcl 153 ref 147
MAIN_RETURN                     001334 constant        label                    dcl 263 ref 283
dmu_cv_string_to_vector         000232 constant        entry                    external dcl 75
new                             000325 constant        entry                    external dcl 149
old                             000312 constant        entry                    external dcl 144

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2316        2340    2155        2326
Length      2620    2155        22         244     141           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dmu_cv_string_to_vector             390 external procedure  is an external procedure.  
on unit on line 165                  76 on unit               
on unit on line 190                  64 on unit               
on unit on line 218                  64 on unit               
FINISH                               64 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                            internal procedure  shares stack frame of on unit on line 165.  
CV_VARYING_FIELD                        internal procedure  shares stack frame of external procedure dmu_cv_string_to_vector.  
CV_NONVARYING_FIELD                     internal procedure  shares stack frame of external procedure dmu_cv_string_to_vector.  
CHECK_VERSION_CHAR                      internal procedure  shares stack frame of external procedure dmu_cv_string_to_vector.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure dmu_cv_string_to_vector.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dmu_cv_string_to_vector  000100 input_string_ptr            dmu_cv_string_to_vector
                         000102 id_list_idx                 dmu_cv_string_to_vector
                         000103 old_varying_field_idx       dmu_cv_string_to_vector
                         000104 current_varying_field_idx   dmu_cv_string_to_vector
                         000105 field_idx                   dmu_cv_string_to_vector
                         000106 current_varying_field_bit_index
                                                            dmu_cv_string_to_vector
                         000110 work_area_ptr               dmu_cv_string_to_vector
                         000126 simple_typed_vector_ptr     dmu_cv_string_to_vector
                         000130 stv_number_of_dimensions    dmu_cv_string_to_vector
                         000132 field_table_ptr             dmu_cv_string_to_vector
                         000134 id_list_ptr                 dmu_cv_string_to_vector
                         000136 il_number_of_ids            dmu_cv_string_to_vector
                         000152 cvf_field_idx               CV_VARYING_FIELD
                         000153 cvf_current_varying_field_bit_index
                                                            CV_VARYING_FIELD
                         000154 cvf_varying_field_idx       CV_VARYING_FIELD
                         000155 cvf_temp_field_idx          CV_VARYING_FIELD
                         000156 cvf_temp_varying_field_length
                                                            CV_VARYING_FIELD
                         000157 cvf_dimension_value_length  CV_VARYING_FIELD
                         000160 cvf_dimension_value_ptr     CV_VARYING_FIELD
                         000162 cvf_dimension_value_length_in_characters
                                                            CV_VARYING_FIELD
                         000164 cvf_field_value_ptr         CV_VARYING_FIELD
                         000166 cvf_length_field_length     CV_VARYING_FIELD
                         000170 cvf_length_field_ptr        CV_VARYING_FIELD
                         000172 cvf_field_length_is_in_characters
                                                            CV_VARYING_FIELD
                         000202 cnf_field_idx               CV_NONVARYING_FIELD
                         000204 cnf_field_value_ptr         CV_NONVARYING_FIELD
                         000206 cnf_dimension_value_ptr     CV_NONVARYING_FIELD
                         000210 cnf_dimension_value_length  CV_NONVARYING_FIELD

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_int_other      return              bs_to_fx2           tra_ext             enable
ext_entry           int_entry           set_bs_eis          alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bad_vector_type     dm_error_$programming_error   error_table_$area_too_small
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     99 000221       100 000222    3   21 000223    3   22 000225        75 000231        77 000240       144 000303
    146 000320       147 000322       149 000323       151 000333       153 000337       155 000341       157 000344
    158 000347       160 000372       161 000376       163 000401       165 000404       167 000427       170 000433
    174 000456       177 000463       178 000474       179 000476       184 000503       187 000507       190 000513
    192 000535       193 000540       194 000554       195 000557       196 000603       197 000604       201 000670
    207 000755       208 000765       210 001001       211 001003       212 001005       215 001006       218 001012
    220 001034       221 001037       222 001053       223 001056       224 001101       225 001102       229 001166
    235 001253       237 001263       239 001266       242 001270       244 001301       248 001305       251 001317
    253 001321       256 001323       260 001325       263 001334       266 001335       270 001343       275 001366
    278 001367       281 001371       282 001375       283 001402       286 001405       313 001407       314 001410
    315 001411       322 001412       324 001413       331 001415       337 001416       342 001417       344 001420
    346 001421       351 001422       352 001424       355 001426       358 001430       360 001433       363 001453
    364 001464       365 001470       366 001500       368 001504       371 001511       373 001515       380 001517
    381 001525       382 001535       384 001541       385 001545       388 001546       389 001550       394 001552
    395 001562       398 001566       399 001576       402 001605       404 001615       406 001623       409 001627
    412 001634       416 001635       443 001637       445 001641       446 001646       447 001655       450 001661
    451 001670       454 001677       456 001711       458 001716       462 001717       468 001730       473 002020
    475 002021       481 002032       486 002114


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
