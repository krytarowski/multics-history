	COMPILATION LISTING OF SEGMENT mrds_dsm_msmi
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 03/08/88  1533.6 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(88-01-18,Blair), approve(88-02-25,MCR7840), audit(88-03-03,Dupuis),
       13*     install(88-03-08,MR12.2-1034):
       14*     Use "mrds" searchlist to find submodel.  SCP 6366.
       15*                                                   END HISTORY COMMENTS */
       16 
       17 
       18 mrds_dsm_msmi: msmi_: proc;
       19 
       20 /* DESCRIPTION:
       21*
       22*   This module implements the msmi_ interface of MRDS. It  allows  a
       23*   user  to  determine the data model mapping and access permissions
       24*   that are defined in a MRDS submodel as  well  as  certain  things
       25*   about  the submodel itself. At the same time it protects a secure
       26*   database by not returning model information to anyone but DBAs.
       27*
       28*   Before a submodel can be referenced it must be "readied" via  the
       29*   open_submodel  entry.  When  the submodel is not longer needed it
       30*   should be "closed" via the close_submodel entry.
       31*
       32*   Entries:
       33*
       34*   .   mrds_dsm_msmi:
       35*   .        should never be called.
       36*
       37*   .   close_submodel:
       38*   .        closes the submodel file to further output, removes  the
       39*   .        opening_name from the open name name list, and frees the
       40*   .        open_info structure.
       41*
       42*   .   get_attribute_data:
       43*   .        loads the mrds_dsm_attribute_data  structure  with  data
       44*   .        about the attributes in the specified relation.
       45*
       46*   .   get_relation_data:
       47*   .        loads the  mrds_dsm_relation_data  structure  with  data
       48*   .        about all the relations in the submodel view.
       49*
       50*   .   get_submodel_info:
       51*   .        loads the mrds_dsm_submodel_info structure with  general
       52*   .        information about the submodel.
       53*
       54*   .   open_submodel:
       55*   .        sets up a submodel so the other entries  can  use  it  -
       56*   .        opens  the  submodel  vfile  for reading, determines the
       57*   .        security state of the database and the authorization  of
       58*   .        the  caller  and  associates  an  opening_name  with  an
       59*   .        allocated structure containing information needed by the
       60*   .        rest  of  the  entries.  Also  the  first call sets up a
       61*   .        temporary segment to  be  used  as  a  work  area.  This
       62*   .        segment  remains  associated  with mrds_dsm_msmi for the
       63*   .        life of the process.
       64*
       65*
       66*   This   module   is   not   recursive    because    the    entries
       67*   get_attribute_data  and  get_relation_data  use vfile subsets and
       68*   cannot be recursive. It was decieded to make  the  entire  module
       69*   non-recursive  instead of just parts of it to avoid complex rules
       70*   when decieding what sequences could or could  not  be  recursive,
       71*   i.e  a  call  to get_attribute_data cannot be interrupted to call
       72*   get_relation_data but can be interrupted to call open_submodel.
       73*
       74*   Known Bugs:
       75*
       76*   Other Problems:
       77*
       78*   .   The temp segment used to hold the msmi_area should go into  a
       79*   .   lower  ring  so  that  the  open_info.return_model_stuff  bit
       80*   .   cannot be twiddled.
       81*
       82*
       83*
       84*   HISTORY:
       85*
       86*   81-04-06 Davids: Coded.
       87*
       88*   81-05-21  Rickie  E.  Brinegar:  Modified  to  use  the   changed
       89*   .        mrds_dsm_relation_names.incl.pl1      which      changed
       90*   .        dsm_relation_names to mrds_dsm_relation_names.
       91*
       92*   81-06-01   Davids:   changed   mrds_dsm_header_str.incl.pl1    to
       93*   .        mrds_dsm_header.incl.pl1
       94**/
       95 
       96 /* PARAMETERS */
       97 
       98 	dcl     attribute_data_ptr	 ptr;		/* (output) pointer to the attribute_data structure */
       99 	dcl     code		 fixed bin (35);	/* (output) error code */
      100 	dcl     dsm_path		 char (*);	/* (input) path relative or absolute to the submodel */
      101 	dcl     opening_name	 char (*);	/* (input) unique identifing name for this opening */
      102 	dcl     relation_data_ptr	 ptr;		/* (output) pointer to the relation_data structure */
      103 	dcl     relation_name	 char (*);	/* (input) name of relation, used in get_attribute_data */
      104 	dcl     str_version		 fixed bin;	/* (input) version of the submodel_info str
      105*						   to be allocated and returned */
      106 	dcl     submodel_info_ptr	 ptr;		/* (output) pointer to the submodel_info structure */
      107 	dcl     users_area_ptr	 ptr;		/* (input) points to a freeing area */
      108 
      109 /* AUTOMATIC */
      110 
      111 	dcl     db_path		 char (168);	/* absolute path to the database that the submodel refers to */
      112 	dcl     dsm_dirname		 char (168);	/* absolute path of the submodel's containing directory */
      113 	dcl     dsm_entryname	 char (32);	/* entry name of the submodel */
      114 	dcl     mrds_dsm_header_ptr	 ptr;		/* points to a copy of the submodels header record */
      115 	dcl     dsm_iocb_ptr	 ptr;		/* pointer to the submodel's iocb */
      116 	dcl     dsm_path_absolute	 char (168);	/* absolute path to the entry specified
      117*						   by the parameter dsm_path */
      118 	dcl     i			 fixed bin;	/* loop index */
      119 	dcl     ignore_arg_char1	 char (1);	/* output argument returned from a call - never used */
      120 	dcl     ignore_error	 fixed bin (35);	/* an error code that will be ignored */
      121 	dcl     internal_error	 fixed bin (35) init (0); /* so as not to use the parameter code */
      122 	dcl     local_area		 area (50);	/* local area for temporary allocations */
      123 	dcl     01 local_area_info	 like area_info;	/* local copy of the area_info structure */
      124 	dcl     name_not_deleted	 bit (1) unal;	/* indicates that the opening_name has not yet been
      125*						   deleted from the open_name_manager - used in close_submodel */
      126 	dcl     open_info_ptr	 ptr;		/* points to an open_info structure */
      127 	dcl     open_info_ptr2	 ptr;		/* a copy of the open_info_ptr - used in close_submodel */
      128 
      129 /* BASED */
      130 
      131 	dcl     01 open_info	 based (open_info_ptr),
      132 		02 iocb		 ptr,		/* pointer to this openings submodels iocb */
      133 		02 return_model_stuff bit (1),	/* if true model info will be returned */
      134 		02 dsm_path	 char (168);	/* absolute path of the submodel used
      135*						   in the opening (may be a link) */
      136 	dcl     msmi_area		 area (sys_info$max_seg_size) based (msmi_area_ptr);
      137 						/* area for big allocations and
      138*						   static stuff (open_info structures) */
      139 	dcl     users_area		 area based (users_area_ptr); /* freeing area that the user has set up */
      140 
      141 /* BUILTINS */
      142 
      143 	dcl     addr		 builtin;
      144 	dcl     empty		 builtin;
      145 	dcl     null		 builtin;
      146 	dcl     rtrim		 builtin;
      147           dcl     search                 builtin;		  
      148 	dcl     unspec		 builtin;
      149 
      150 /* CONDITIONS */
      151 
      152 	dcl     area		 condition;
      153 	dcl     cleanup		 condition;
      154 
      155 /* CONSTANTS */
      156 
      157 	dcl     DSM_SUFFIX		 char (3) init ("dsm") internal static options (constant);
      158           dcl     MRDS_SEARCHLIST        char (4) init ("mrds") internal static options (constant);
      159 /* EXTERNAL STATIC */
      160 
      161 	dcl     error_table_$area_too_small fixed bin (35) external static;
      162 	dcl     error_table_$badcall	 fixed bin (35) external static;
      163 	dcl     error_table_$no_record fixed bin (35) external static;
      164 	dcl     error_table_$unimplemented_version fixed bin (35) external static;
      165 	dcl     mrds_error_$not_freeing_area fixed bin (35) external static;
      166 	dcl     mrds_error_$recursion_error fixed bin (35) external static;
      167 	dcl     mrds_error_$unknown_relation_name fixed bin (35) external static;
      168 	dcl     sys_info$max_seg_size	 fixed bin (35) external static;
      169 
      170 /* INTERNAL STATIC */
      171 
      172 	dcl     executing		 bit (1) unal init ("0"b) internal static; /* true while code is being executed - prevents recursion */
      173 	dcl     msmi_area_ptr	 ptr init (null ()) internal static; /* points to a temporary segment in the pdir, set on the process's
      174*						   first call to the open_submodel entry point.
      175*						   Remains set for the life of the process */
      176 
      177 /* ENTRIES */
      178 
      179 	dcl     area_info_		 entry (ptr, fixed bin (35));
      180 	dcl     expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));
      181 	dcl     get_temp_segment_	 entry (char (*), pointer, fixed bin (35));
      182 	dcl     mrds_dsm_close$force	 entry (ptr);
      183 	dcl     mrds_dsm_determine_auth_sec entry (char (*), char (*), char (*)) returns (bit (1));
      184 	dcl     mrds_dsm_open$read_share entry (char (*), ptr, fixed bin (35));
      185 	dcl     mrds_dsm_read_header	 entry (ptr, ptr, ptr, fixed bin (35));
      186 	dcl     mrds_dsm_read_header$db_path entry (ptr, char (168), fixed bin (35));
      187 	dcl     mrds_dsm_read_relation entry (char (*), ptr, ptr, ptr, fixed bin (35));
      188 	dcl     mrds_dsm_get_relation_names entry (ptr, ptr, ptr, fixed bin (35));
      189 	dcl     mu_open_name_manager$define_open_name entry (char (*), char (1), ptr, fixed bin (35));
      190 	dcl     mu_open_name_manager$delete_open_name entry (char (*), fixed bin (35));
      191 	dcl     mu_open_name_manager$get_model_pointer entry (char (*), char (1), ptr, fixed bin (35));
      192 
  1     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  1     2 
  1     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  1     4 
  1     5 dcl  area_infop ptr;
  1     6 
  1     7 dcl 1 area_info aligned based (area_infop),
  1     8     2 version fixed bin,				/* version number for this structure is 1 */
  1     9     2 control aligned like area_control,		/* control bits for the area */
  1    10     2 owner char (32) unal,				/* creator of the area */
  1    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  1    12     2 size fixed bin (18),				/* size of the area in words */
  1    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  1    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  1    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  1    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  1    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  1    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  1    19 
  1    20 dcl 1 area_control aligned based,
  1    21     2 extend bit (1) unal,				/* says area is extensible */
  1    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  1    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  1    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  1    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  1    26     2 system bit (1) unal,				/* says area is managed by system */
  1    27     2 pad bit (30) unal;
  1    28 
  1    29 /* END INCLUDE FILE area_info.incl.pl1 */
      193 
      194 
  2     1 /* BEGIN INCLUDE FILE mrds_dsm_attribute_data.incl.pl1 - NSDavids 81-01-29
  2     2*
  2     3*
  2     4*   This include file contains information about all the attributes in
  2     5*   a relation. It is a user's view only and is not meant to  be  used
  2     6*   by mrds code.
  2     7*
  2     8*   HISTORY
  2     9*
  2    10*   81-01-29 Davids: written
  2    11**/
  2    12 
  2    13 
  2    14 
  2    15 
  2    16 
  2    17 dcl 01 mrds_dsm_attribute_data aligned based (mrds_dsm_attribute_data_ptr),
  2    18     02 version fixed bin,
  2    19     02 number_of_attributes fixed bin,
  2    20     02 attributes (mrds_dsm_attribute_data_num_atts
  2    21      refer (mrds_dsm_attribute_data.number_of_attributes)),
  2    22       03 submodel_attribute_name char (64),
  2    23       03 model_attribute_name char (32),
  2    24       03 read_access bit (1) unal,
  2    25       03 modify_access bit (1) unal,
  2    26       03 null_access bit (1) unal,
  2    27       03 mbz1 bit (33) unal;
  2    28 
  2    29 dcl  mrds_dsm_attribute_data_ptr ptr;
  2    30 
  2    31 dcl  mrds_dsm_attribute_data_num_atts fixed bin;
  2    32 
  2    33 dcl  mrds_dsm_attribute_data_structure_version fixed bin init (1) internal static options (constant);
  2    34 
  2    35 /* END INCLUDE FILE mrds_dsm_attribute_data.incl.pl1 */
  2    36 
      195 
      196 
  3     1 /* BEGIN INCLUDE FILE mrds_dsm_header.incl.pl1
  3     2*
  3     3*This include file is for internal MRDS use only - it is not to be
  3     4*documented in any user manual.
  3     5*
  3     6*81-06-01 Davids:  This  is  a  copy  of  the  mrds_dsm_header_str
  3     7*include  file,  it  is  to  be  used  by  all  mrds routines. The
  3     8*structure  name  has  been  changed  from  dsm_header_record   to
  3     9*mrds_dsm_header  to  avoid  conflicts when both this include file
  3    10*and mrds_dsm_header_str are included (mrds_dsm_dsmd).
  3    11**/
  3    12 
  3    13 dcl 1 mrds_dsm_header based,				/* header structure for a MRDS submodel */
  3    14     2 dsm_generator_version fixed bin init (0),		/* version number of submodel created by CMDSM */
  3    15     2 date_time_generated fixed bin (71) init (0),	/* convert data to binary form of creation time */
  3    16     2 database_pn char (168) init (""),			/* pathname of database this submodel is valid for */
  3    17     2 name char (32) init (""),			/* identifying name for this header structure */
  3    18     2 num_of_relations fixed bin (35) init (0),		/* number of relations in submodel view of database */
  3    19     2 creator_id char (32) init ("") ;			/* the person.project.tag of the submodel creator */
  3    20 
  3    21 /*           END INCLUDE FILE                     mrds_dsm_header.incl.pl1 */
      197 
      198 
  4     1 /*	BEGIN INCLUDE FILE		mrds_dsm_rel_block.incl.pl1
  4     2*
  4     3*   Created October, 1975 for release in MR 4.0
  4     4*
  4     5*   The relation_block contains the relation name and  the  attribute
  4     6*   names and access information
  4     7*
  4     8*   HISTORY
  4     9*
  4    10*   80-04-10 Spratt: changed to have version  number,  be  explicitly
  4    11*   .        based, use an automatic variable in the refer for num of
  4    12*   .        attributes,  add access flags for rel and attr's, remove
  4    13*   .        attr key flags. This is for the  first  Attribute  Level
  4    14*   .        Security version of MRDS.
  4    15*
  4    16*   81-01-14 Davids: increased submodel rel  and  attr  names  to  64
  4    17*   .        characters and made dsm_rel_name char  varying.  changed
  4    18*   .        access  bits  from  a  bit  string to individually named
  4    19*   .        flags.
  4    20**/
  4    21 
  4    22 dcl  relation_block_ptr ptr;
  4    23 dcl  rb_number_of_attributes fixed bin (35);
  4    24 dcl  RELATION_BLOCK_VERSION_1 fixed bin (35) internal static options (constant) init (1);
  4    25 
  4    26 dcl 1 relation_block based (relation_block_ptr),
  4    27 						/* Relation block */
  4    28     2 version fixed bin (35),
  4    29     2 dsm_rel_name char (64) varying,			/* Data submodel relation name */
  4    30     2 dm_rel_name char (32),				/* Data model relation name */
  4    31     2 rel_access unal,
  4    32       3 append bit (1),
  4    33       3 delete bit (1),
  4    34       3 null bit (1),
  4    35       3 mbz1 bit (33),
  4    36     2 no_rb_attributes fixed bin,			/* The number of attributes in this relation */
  4    37     2 attribute_info (rb_number_of_attributes refer (relation_block.no_rb_attributes)),
  4    38       3 dsm_attr_name char (64) varying,		/* Data submodel attribute name */
  4    39       3 attr_access unal,				/* Data submodel attribute flags */
  4    40         4 read bit (1),
  4    41         4 modify bit (1),
  4    42         4 null bit (1),
  4    43         4 mbz2 bit (33),				/* For future use */
  4    44       3 dm_attr_name char (32) varying,			/* Data model attribute name */
  4    45       3 dm_attr_flags,				/* Data model attribute flags */
  4    46         4 mbz3 bit (36);				/* For future use */
  4    47 
  4    48 /* 	END INCLUDE FILE 		mrds_dsm_rel_block.incl.pl1  */
  4    49 
      199 
      200 
  5     1 /* BEGIN INCLUDE FILE mrds_dsm_relation_data.incl.pl1 - NSDavids 81-01-29
  5     2*
  5     3*
  5     4*   This include file contains information about all the relations in a
  5     5*   submodel view. It is a user's view only and is not meant to be used
  5     6*   by mrds code.
  5     7*
  5     8*   HISTORY
  5     9*
  5    10*   81-01-29 Davids: written
  5    11**/
  5    12 
  5    13 
  5    14 
  5    15 
  5    16 
  5    17 dcl 01 mrds_dsm_relation_data aligned based (mrds_dsm_relation_data_ptr),
  5    18     02 version fixed bin,
  5    19     02 number_of_relations fixed bin,
  5    20     02 relations (mrds_dsm_relation_data_num_rels
  5    21      refer (mrds_dsm_relation_data.number_of_relations)),
  5    22       03 submodel_relation_name char (64),
  5    23       03 model_relation_name char (32),
  5    24       03 append_access bit (1) unal,
  5    25       03 delete_access bit (1) unal,
  5    26       03 null_access bit (1) unal,
  5    27       03 mbz1 bit (33) unal;
  5    28 
  5    29 dcl  mrds_dsm_relation_data_ptr ptr;
  5    30 
  5    31 dcl  mrds_dsm_relation_data_num_rels fixed bin;
  5    32 
  5    33 dcl  mrds_dsm_relation_data_structure_version fixed bin init (1) internal static options (constant);
  5    34 
  5    35 /* END INCLUDE FILE mrds_dsm_relation_data.incl.pl1 */
      201 
      202 
  6     1 /* BEGIN INCLUDE FILE mrds_dsm_relation_names.incl.pl1 -- nsd 81/01/12 */
  6     2 
  6     3 /*
  6     4*This include file is for internal mrds use only. It  is  used  to
  6     5*return an array of submodel relation names.
  6     6*
  6     7*HISTORY
  6     8*
  6     9*81-01-12 Davids: written
  6    10*
  6    11*81-09-14 Davids: changed relation to char (32) from char (64). 64
  6    12*was  a  proposed  maximum  but  could not be implemented. Several
  6    13*modules would not compile when compiled with  -prefix  stringsize
  6    14*becuase they made assignments of the form char (32) = char (64).
  6    15**/
  6    16 
  6    17 dcl 1 mrds_dsm_relation_names based (mrds_dsm_relation_names_ptr),
  6    18     2 nrels fixed bin,
  6    19     2 relation (mrds_dsm_relation_names_nrels_alloc refer (mrds_dsm_relation_names.nrels)) char (32);
  6    20 
  6    21 dcl  mrds_dsm_relation_names_nrels_alloc fixed bin;
  6    22 
  6    23 dcl  mrds_dsm_relation_names_ptr ptr;
  6    24 
  6    25 /* END INCLUDE FILE mrds_dsm_relation_names.incl.pl1 */
  6    26 
      203 
      204 
  7     1 /* BEGIN INCLUDE FILE  - mrds_dsm_submodel_info.incl.pl1 */
  7     2 
  7     3 /*
  7     4*   This  include   file   contains   the   structure   returned   by
  7     5*   msmi_$get_submodel_info.  This  include  file is a user interface
  7     6*   and should not be used by any mrds routine  except  mrds_dsm_msmi
  7     7*   (msmi_).
  7     8*
  7     9*   HISTORY:
  7    10*
  7    11*   81-04-03 Davids: coded
  7    12**/
  7    13 
  7    14 
  7    15 dcl 01 mrds_dsm_submodel_info based (mrds_dsm_submodel_info_ptr),
  7    16     02 version fixed bin,				/* version of this structure */
  7    17     02 submodel_version fixed bin,			/* version of the submodel */
  7    18     02 database_path char (168),			/* absolute path of the database that the submodel refers to */
  7    19     02 submodel_path char (168),			/* absolure path of the submodel (may be a link) */
  7    20     02 date_time_created fixed bin (71),		/* date-time submodel was created in standard format */
  7    21     02 creator_id char (32);				/* Person.Project.Tag of the submodel creator */
  7    22 
  7    23 dcl  mrds_dsm_submodel_info_ptr ptr;			/* pointer to the structure */
  7    24 
  7    25 dcl  mrds_dsm_submodel_info_structure_version fixed bin init (1) internal static options (constant);
  7    26 
  7    27 /* END INCLUDE FILE -  mrds_dsm_submodel_info.incl.pl1 */
  7    28 
      205 
      206 
      207 /* MAIN ENTRY POINT */
      208 
      209 	call report_error (error_table_$badcall,
      210 	     "The entry point mrds_dsm_msmi$mrds_dsm_msmi (msmi_$msmi_) should never be called", "", "", "");
      211 
      212 	return;
      213 
      214 close_submodel: entry (opening_name, code);
      215 
      216 /*
      217*   where:
      218*   .   opening_name: (input) unique identifing name for this opening
      219*   .   code: (output) error code
      220*
      221*   This entry "closes" a submodel so that it may not  be  referenced
      222*   by  any  of  the  other  entry  points.  This entails closing the
      223*   submodel  vfile  to  further  output,  freeing   the   associated
      224*   open_info  structure  and  deleting  the  opening_name  from  the
      225*   open_name manager - this will also allow the opening_name  to  be
      226*   used again.
      227*
      228*   All   of   the   work   is   actually   done   by   the   routine
      229*   cleanup_close_submodel.
      230*
      231*   The variables open_info_ptr2 and  name_not_deleted  are  used  as
      232*   switches  to be sure that the submodel is "closed" and to prevent
      233*   errors from trying to  do  things  twice.  There  are  of  course
      234*   windows where the operation has been performed but the switch not
      235*   yet set, these windows are as small as possible.
      236**/
      237 
      238 	code = 0;					/* initialize output variables */
      239 
      240 	if executing				/* This module cannot be recursive */
      241 	then internal_error = mrds_error_$recursion_error;
      242 	else do;
      243 		open_info_ptr = null ();		/* initialize working variables */
      244 		open_info_ptr2 = null ();
      245 		name_not_deleted = "1"b;
      246 
      247 		on cleanup call cleanup_close_submodel; /* setup the cleanup condition handler */
      248 		executing = "1"b;			/* and set flag to prevent recursion */
      249 
      250 		call cleanup_close_submodel;		/* do the actual work */
      251 		code = internal_error;		/* set output parameters */
      252 	     end;					/* executing flag is reset in cleanup_close_submodel */
      253 
      254 	return;
      255 
      256 get_attribute_data: entry (opening_name, relation_name, users_area_ptr, str_version, attribute_data_ptr, code);
      257 
      258 /*
      259*   where:
      260*   .   opening_name: (input) unique indetifing name for a opening
      261*   .   relation_name: (input) name of relation whose attribute  data
      262*   .        is wanted
      263*   .   users_area_ptr: (input) pointer to a freeing area set  up  by
      264*   .        the caller
      265*   .   str_version: (input) version of  the  mrds_dsm_attribute_data
      266*   .        structure expected to be allocated.
      267*   .   attribute_data_ptr:    (output)      pointer      to      the
      268*   .        mrds_dsm_attribute_data structure which was allocated
      269*   .   code: (output) error code.
      270*
      271*   This entry point returns a pointer to the mrds_dsm_attribute_data
      272*   structure,  which  contains information about the attributes in a
      273*   specific submodel relation. If the submodel refers  to  a  secure
      274*   database  and the caller is not a DBA the names of the attributes
      275*   in the model will be returned as spaces.
      276*
      277*   The structure is allocated in  a  freeing  area  set  up  by  the
      278*   caller who is responsible for freeing it.
      279**/
      280 
      281 
      282 
      283 	code = 0;					/* initialize output variables */
      284 	attribute_data_ptr = null ();
      285 
      286 	if executing				/* This module cannot be recursive */
      287 	then internal_error = mrds_error_$recursion_error;
      288 	else do;
      289 		mrds_dsm_attribute_data_ptr = null ();	/* initialize working variables */
      290 		relation_block_ptr = null ();
      291 
      292 		on cleanup call cleanup_get_attribute_data; /* setup the cleanup condition handler */
      293 		executing = "1"b;			/* and set flag to prevent recursion */
      294 
      295 		call verify_input_parameters (opening_name, /* verify some of the input */
      296 		     users_area_ptr, str_version,	/* parameters and get the open_info pointer */
      297 		     mrds_dsm_attribute_data_structure_version,
      298 		     open_info_ptr, internal_error);
      299 		if internal_error ^= 0
      300 		then goto exit_get_attribute_data;
      301 
      302 		call mrds_dsm_read_relation (relation_name, /* get the relation and attribute */
      303 		     msmi_area_ptr, relation_block_ptr, /* data for the specified relation */
      304 		     open_info.iocb, internal_error);
      305 		if internal_error ^= 0
      306 		then do;
      307 			if internal_error = error_table_$no_record
      308 			then internal_error = mrds_error_$unknown_relation_name;
      309 			goto exit_get_attribute_data;
      310 		     end;
      311 
      312 		on area /* trap the area condition while */
      313 		     begin;			/* allocating in the user's area */
      314 			internal_error = error_table_$area_too_small;
      315 			goto exit_get_attribute_data;
      316 		     end;
      317 		mrds_dsm_attribute_data_num_atts =
      318 		     relation_block.no_rb_attributes;
      319 		allocate mrds_dsm_attribute_data
      320 		     in (users_area) set (mrds_dsm_attribute_data_ptr);
      321 		revert area;
      322 
      323 		unspec (mrds_dsm_attribute_data) = "0"b;/* initialize the allocated structure */
      324 		mrds_dsm_attribute_data.number_of_attributes =
      325 		     mrds_dsm_attribute_data_num_atts;
      326 		mrds_dsm_attribute_data.version =
      327 		     mrds_dsm_attribute_data_structure_version;
      328 
      329 		do i = 1 to mrds_dsm_attribute_data_num_atts; /* load the structure */
      330 
      331 		     mrds_dsm_attribute_data.attributes (i).submodel_attribute_name =
      332 			relation_block.attribute_info (i).dsm_attr_name;
      333 						/* supress model names if the caller is not a DBA */
      334 		     if open_info.return_model_stuff	/* and the database is secure */
      335 		     then mrds_dsm_attribute_data.attributes (i).model_attribute_name =
      336 			     relation_block.attribute_info (i).dm_attr_name;
      337 		     else mrds_dsm_attribute_data.attributes (i).model_attribute_name = " ";
      338 
      339 		     mrds_dsm_attribute_data.attributes (i).read_access =
      340 			relation_block.attribute_info (i).attr_access.read;
      341 		     mrds_dsm_attribute_data.attributes (i).modify_access =
      342 			relation_block.attribute_info (i).attr_access.modify;
      343 		     mrds_dsm_attribute_data.attributes (i).null_access =
      344 			relation_block.attribute_info (i).attr_access.null;
      345 		     mrds_dsm_attribute_data.attributes (i).mbz1 = "0"b;
      346 		end;
      347 
      348 		free relation_block_ptr -> relation_block;
      349 
      350 		attribute_data_ptr = mrds_dsm_attribute_data_ptr;
      351 
      352 exit_get_attribute_data:
      353 		code = internal_error;
      354 		executing = "0"b;			/* no longer executing */
      355 
      356 	     end;
      357 
      358 	return;
      359 
      360 get_relation_data: entry (opening_name, users_area_ptr, str_version, relation_data_ptr, code);
      361 
      362 /*
      363*   where:
      364*   .   opening_name: (input) unique indetifing name for a opening
      365*   .   users_area_ptr: (input) pointer to a freeing area set  up  by
      366*   .        the caller
      367*   .   str_version: (input) version  of  the  mrds_dsm_relation_data
      368*   .        structure expected to be allocated.
      369*   .   relation_data_ptr:     (output)      pointer      to      the
      370*   .        mrds_dsm_relation_data structure which was allocated
      371*   .   code: (output) error code.
      372*
      373*   This entry point returns a pointer to the  mrds_dsm_relation_data
      374*   structure  which  contains information about all of the relations
      375*   in a submodel view. If the submodel refers to a  secure  database
      376*   and  the  caller  is not a DBA then the names of the relations in
      377*   the model are returned as blanks.
      378*
      379*   The structure is allocated in  a  freeing  area  set  up  by  the
      380*   caller who is responsible for freeing it.
      381**/
      382 
      383 
      384 
      385 	code = 0;					/* initiate output variables */
      386 	relation_data_ptr = null ();
      387 
      388 	if executing				/* This module cannot be recursive */
      389 	then internal_error = mrds_error_$recursion_error;
      390 	else do;
      391 		mrds_dsm_relation_data_ptr = null ();	/* initialize working variables */
      392 		mrds_dsm_relation_names_ptr = null ();
      393 		relation_block_ptr = null ();
      394 
      395 		on cleanup call cleanup_get_relation_data; /* setup cleanup condition handler */
      396 		executing = "1"b;			/* and set flag to prevent recursion */
      397 
      398 		call verify_input_parameters (opening_name, /* verify the input parameters */
      399 		     users_area_ptr, str_version,	/* and get the open_info pointer */
      400 		     mrds_dsm_relation_data_structure_version,
      401 		     open_info_ptr, internal_error);
      402 		if internal_error ^= 0
      403 		then goto exit_get_relation_data;
      404 
      405 		call mrds_dsm_get_relation_names /* get a list of all the */
      406 		     (msmi_area_ptr, mrds_dsm_relation_names_ptr, /* relations in the submodel */
      407 		     open_info.iocb, internal_error);
      408 		if internal_error ^= 0
      409 		then do;
      410 			call report_error (internal_error, /* this error should never occur */
      411 			     "PROGRAM LOGIC ERROR^/Could not get the list of submodel relation names",
      412 			     "", "", "");
      413 			goto exit_get_relation_data;
      414 		     end;
      415 
      416 		on area /* trap the area condition while */
      417 		     begin;			/* allocating in the user's area */
      418 			internal_error = error_table_$area_too_small;
      419 			goto exit_get_relation_data;
      420 		     end;
      421 		mrds_dsm_relation_data_num_rels = mrds_dsm_relation_names.nrels;
      422 		allocate mrds_dsm_relation_data in (users_area) set (mrds_dsm_relation_data_ptr);
      423 		revert area;
      424 
      425 		unspec (mrds_dsm_relation_data) = "0"b; /* initialize the allocated structure */
      426 		mrds_dsm_relation_data.number_of_relations =
      427 		     mrds_dsm_relation_data_num_rels;
      428 		mrds_dsm_relation_data.version =
      429 		     mrds_dsm_relation_data_structure_version;
      430 
      431 		do i = 1 to mrds_dsm_relation_names.nrels; /* load the structure */
      432 
      433 		     call mrds_dsm_read_relation /* get relation and attribute data */
      434 			(mrds_dsm_relation_names.relation (i), /* ingore attribute data */
      435 			msmi_area_ptr, relation_block_ptr,
      436 			open_info.iocb, internal_error);
      437 		     if internal_error ^= 0
      438 		     then do;
      439 			     call report_error (internal_error, /* this error should never occur */
      440 				"PROGRAM LOGIC ERROR^/Could not read the relation record for relation ^a",
      441 				mrds_dsm_relation_names.relation (i), "", "");
      442 			     goto exit_get_relation_data;
      443 			end;
      444 
      445 		     mrds_dsm_relation_data.relations (i).submodel_relation_name = mrds_dsm_relation_names.relation (i);
      446 						/* surpress model names if the caller is not a DBA */
      447 		     if open_info.return_model_stuff	/* and the database is secure */
      448 		     then mrds_dsm_relation_data.relations (i).model_relation_name = relation_block.dm_rel_name;
      449 		     else mrds_dsm_relation_data.relations (i).model_relation_name = " ";
      450 
      451 		     mrds_dsm_relation_data.relations (i).append_access = relation_block.rel_access.append;
      452 		     mrds_dsm_relation_data.relations (i).delete_access = relation_block.rel_access.delete;
      453 		     mrds_dsm_relation_data.relations (i).null_access = relation_block.rel_access.null;
      454 		     mrds_dsm_relation_data.relations (i).mbz1 = "0"b;
      455 
      456 		     free relation_block_ptr -> relation_block;
      457 		end;
      458 
      459 		free mrds_dsm_relation_names_ptr -> mrds_dsm_relation_names;
      460 
      461 		relation_data_ptr = mrds_dsm_relation_data_ptr;
      462 
      463 exit_get_relation_data:
      464 		code = internal_error;
      465 		executing = "0"b;			/* no longer executing */
      466 
      467 	     end;
      468 
      469 	return;
      470 
      471 get_submodel_info: entry (opening_name, users_area_ptr, str_version, submodel_info_ptr, code);
      472 
      473 /*
      474*   where:
      475*   .   opening_name: (input) unique indetifing name for a opening
      476*   .   users_area_ptr: (input) pointer to a freeing area set  up  by
      477*   .        the caller
      478*   .   str_version: (input) version  of  the  mrds_dsm_relation_data
      479*   .        structure expected to be allocated.
      480*   .   relation_data_ptr:     (output)      pointer      to      the
      481*   .        mrds_dsm_relation_data structure which was allocated
      482*   .   code: (output) error code.
      483*
      484*   This entry point returns a pointer to the  mrds_dsm_submodel_info
      485*   structure  which  contains general information about the submodel
      486*   associated with the opening_name.
      487*
      488*   The structure is allocated in  a  freeing  area  set  up  by  the
      489*   caller who is resp}onsible for freeing it.
      490**/
      491 
      492 
      493 	code = 0;					/* initialize output variables */
      494 	submodel_info_ptr = null ();
      495 
      496 	if executing				/* This module cannot be recursive */
      497 	then internal_error = mrds_error_$recursion_error;
      498 	else do;
      499 		mrds_dsm_submodel_info_ptr = null ();	/* initialize working variables */
      500 		mrds_dsm_header_ptr = null ();
      501 
      502 		on cleanup call cleanup_get_submodel_info; /* setup the cleanup condition handler */
      503 		executing = "1"b;			/* and set flag to prevent recursion */
      504 
      505 		call verify_input_parameters (opening_name, /* verify the input parameters */
      506 		     users_area_ptr, str_version,	/* and get the open_info pointer */
      507 		     mrds_dsm_submodel_info_structure_version,
      508 		     open_info_ptr, internal_error);
      509 		if internal_error ^= 0
      510 		then goto exit_get_submodel_info;
      511 
      512 		call mrds_dsm_read_header (msmi_area_ptr, /* get the info in the submodel header */
      513 		     mrds_dsm_header_ptr, open_info.iocb,
      514 		     internal_error);
      515 		if internal_error ^= 0
      516 		then do;
      517 			call report_error (internal_error, /* this error should never occur */
      518 			     "PROGRAM LOGIC ERROR^/Could not read the submodel header record",
      519 			     "", "", "");
      520 			goto exit_get_submodel_info;
      521 		     end;
      522 
      523 		on area /* trap the area condition while */
      524 		     begin;			/* allocating in the user's area */
      525 			internal_error = error_table_$area_too_small;
      526 			goto exit_get_submodel_info;
      527 		     end;
      528 		allocate mrds_dsm_submodel_info in (users_area) set (mrds_dsm_submodel_info_ptr);
      529 		revert area;
      530 
      531 		unspec (mrds_dsm_submodel_info) = "0"b; /* initialize the allocated structure */
      532 		mrds_dsm_submodel_info.version =
      533 		     mrds_dsm_submodel_info_structure_version;
      534 						/* load the structure */
      535 		mrds_dsm_submodel_info.submodel_version =
      536 		     mrds_dsm_header_ptr -> mrds_dsm_header.dsm_generator_version;
      537 		mrds_dsm_submodel_info.database_path =
      538 		     mrds_dsm_header_ptr -> mrds_dsm_header.database_pn;
      539 		mrds_dsm_submodel_info.submodel_path =
      540 		     open_info.dsm_path;
      541 		mrds_dsm_submodel_info.date_time_created =
      542 		     mrds_dsm_header_ptr -> mrds_dsm_header.date_time_generated;
      543 		mrds_dsm_submodel_info.creator_id =
      544 		     mrds_dsm_header_ptr -> mrds_dsm_header.creator_id;
      545 
      546 		free mrds_dsm_header_ptr -> mrds_dsm_header;
      547 
      548 		submodel_info_ptr = mrds_dsm_submodel_info_ptr;
      549 
      550 exit_get_submodel_info:
      551 		code = internal_error;
      552 		executing = "0"b;			/* no longer executing */
      553 
      554 	     end;
      555 
      556 	return;
      557 
      558 open_submodel: entry (opening_name, dsm_path, code);
      559 
      560 /*
      561*   where:
      562*   .   opening_name: (input) unique identifing name for a opening
      563*   .   dsm_path: (input) path relative or absolute to the submodel.
      564*   .   code: (output) error code
      565*
      566*   This entry point prepares a submodel so that it may be referenced
      567*   by  the  other  entry  points  in  this module, it associates the
      568*   opened submodel with the opening_name.
      569*
      570*   It opens  the  submodel  for  shared  reading.  and  sets  up  an
      571*   association  between  the  users unique identifier (opening_name)
      572*   and the opening information (open_info). This opening information
      573*   is  a  pointer to the submodels iocb and an indication of whether
      574*   model information may be returned (only if the  database  is  not
      575*   secure  or  if the database is secure and the user is a DBA), the
      576*   submodel path is also saved.
      577*
      578*   The open_info structure is allocated in a  temporary  segment  in
      579*   the  process  directory.  This temporary segment is set up on the
      580*   process's first call to this entry point and  remains  associated
      581*   with this module for the life of the process.
      582**/
      583 dcl       suffixed_name_$make entry (char(*), char(*), char(32), fixed bin(35));
      584 dcl       search_paths_$find_dir entry (char(*), ptr, char(*), char(*), char(*), fixed bin(35));
      585 
      586 	code = 0;					/* initialize output variables */
      587 
      588 	if executing				/* this module cannot be recursive */
      589 	then internal_error = mrds_error_$recursion_error;
      590 	else do;
      591 		dsm_iocb_ptr = null ();
      592 		open_info_ptr = null ();
      593 
      594 		on cleanup call cleanup_open_submodel;	/* setup the cleanup condition handler */
      595 		executing = "1"b;			/* and set flag to prevent recursion */
      596 
      597 		if msmi_area_ptr = null ()		/* if the msmi_area has not yet been set up - set it up */
      598 		then do;
      599 			call get_temp_segment_ ("mrds_dsm_msmi", msmi_area_ptr, internal_error);
      600 			if internal_error ^= 0
      601 			then do;
      602 				call report_error (internal_error,
      603 				     "Could not get a temp segment to hold opening information", "", "", "");
      604 				goto exit_open_submodel;
      605 			     end;
      606 			else msmi_area_ptr -> msmi_area = empty (); /* define an empty area in the segment */
      607 		     end;
      608 
      609 		if search (dsm_path, "<>") = 0 then do;
      610 		     call suffixed_name_$make (dsm_path, DSM_SUFFIX, dsm_entryname, internal_error);
      611 		     if internal_error ^= 0 
      612 			then goto exit_open_submodel;
      613 		     call search_paths_$find_dir (MRDS_SEARCHLIST, null(), dsm_entryname, "", dsm_dirname, internal_error);
      614 		     if internal_error ^= 0 
      615 			then goto exit_open_submodel;
      616 		     end;
      617 		else do;
      618 		     call expand_pathname_$add_suffix (dsm_path, /* add .dsm to the input path if its not */
      619 			DSM_SUFFIX, dsm_dirname,		/* already there and expand it to get the */
      620 			dsm_entryname, internal_error);	/* absolute path of the directory and entry name */
      621 		     if internal_error ^= 0
      622 			then goto exit_open_submodel;
      623 		     end;
      624 		dsm_path_absolute = rtrim (dsm_dirname) ||
      625 		     ">" || dsm_entryname;
      626 		call mrds_dsm_open$read_share /* open the submodel, allowing multiple readers */
      627 		     (dsm_path_absolute, dsm_iocb_ptr, internal_error);
      628 		if internal_error ^= 0
      629 		then goto exit_open_submodel;
      630 
      631 		call mrds_dsm_read_header$db_path /* get the absolute path of the db */
      632 		     (dsm_iocb_ptr, db_path, internal_error); /* that the submodel is defined for */
      633 		if internal_error ^= 0
      634 		then do;
      635 			call report_error (internal_error, /* this error should never occur */
      636 			     "PROGRAM LOGIC ERROR^/Could not read submodel ^a>^a's" ||
      637 			     " header to get the database path", dsm_dirname, dsm_entryname, "");
      638 			call mrds_dsm_close$force (dsm_iocb_ptr);
      639 			goto exit_open_submodel;
      640 		     end;
      641 
      642 		allocate open_info in (msmi_area) /* allocate the open_info structure */
      643 		     set (open_info_ptr);		/* to store */
      644 		open_info.iocb = dsm_iocb_ptr;	/* submodel iocb pointer */
      645 		open_info.dsm_path = dsm_path_absolute; /* input submodel path and */
      646 		open_info.return_model_stuff = /* whether to return model info or not */
      647 		     mrds_dsm_determine_auth_sec (db_path,
      648 		     dsm_dirname, dsm_entryname);
      649 
      650 		call mu_open_name_manager$define_open_name (opening_name, /* assocate the opening_name */
      651 		     "s", open_info_ptr, internal_error); /* with the open_info structure */
      652 		if internal_error ^= 0		/* in case of error free the open_info structure */
      653 		then free open_info_ptr -> open_info;
      654 
      655 exit_open_submodel:
      656 		code = internal_error;
      657 		executing = "0"b;			/* no longer executing */
      658 	     end;
      659 
      660 	return;
      661 
      662 cleanup_close_submodel: proc;
      663 
      664 /*
      665*   This procedure  "closes"  a  submodel,  that  is  it  closes  the
      666*   submodel  vfile  to further output, frees the open_info structure
      667*   and deletes the opening_name from the  name  list.  Because  this
      668*   routine  is  also  a  cleanup  handler  and the goal is to always
      669*   "close" the submodel special switches are set and tested.
      670*
      671*   .        open_info_ptr: if not null then a call to
      672*   .        get_model_ptr has been successfully made.
      673*
      674*   .        open_info_ptr2:  if  not  null  then  the
      675*   .        open_info  structure  has  not  yet  been
      676*   .        freed.
      677*
      678*   .        name_not_deleted: if "1"b then a call  to
      679*   .        delete_name has not yet been made.
      680**/
      681 
      682 	internal_error = 0;
      683 	if open_info_ptr = null ()			/* if the open_info_ptr has not yet been obtained - get it */
      684 	then do;
      685 		call mu_open_name_manager$get_model_pointer (opening_name, ignore_arg_char1,
      686 		     open_info_ptr, internal_error);
      687 		open_info_ptr2 = open_info_ptr;
      688 	     end;
      689 
      690 	if internal_error = 0			/* if open_info_ptr was obtained without error */
      691 	then do;
      692 		if name_not_deleted			/* and the name has not yet been deleted */
      693 		then do;				/* from the open_name list - delete it */
      694 			call mu_open_name_manager$delete_open_name
      695 			     (opening_name, internal_error);
      696 			name_not_deleted = "0"b;
      697 			if internal_error ^= 0	/* You should always be able to delete a */
      698 			then do;			/* name which can get a model pointer */
      699 				call report_error (internal_error, "PROGRAM LOGIC ERROR^/Could not delete" ||
      700 				     " the opening name ^a the submodel HAS been closed but you cannot use" ||
      701 				     " the opening name over again", opening_name, "", "");
      702 				internal_error = 0;
      703 			     end;
      704 		     end;
      705 
      706 		if open_info_ptr2 ^= null ()		/* free an allocated open_info structure */
      707 		then do;
      708 			call mrds_dsm_close$force /* close the submodel - without generating errors */
      709 			     (open_info.iocb);
      710 			free open_info_ptr2 -> open_info; /* and free the structure */
      711 		     end;
      712 	     end;
      713 
      714 	executing = "0"b;
      715 
      716      end /* cleanup_close_submodel */;
      717 
      718 cleanup_get_attribute_data: proc;
      719 
      720 /*
      721*   This procedure cleansup allocated structures in the event that  a
      722*   cleanup    condition    is    signaled    while   executing   the
      723*   get_attribute_data entry. It also resets  the  executing  bit  to
      724*   allow the module to be recalled.
      725**/
      726 
      727 
      728 
      729 	if relation_block_ptr ^= null ()		/* free an allocated relation_block structure */
      730 	then free relation_block_ptr -> relation_block;
      731 
      732 	if mrds_dsm_attribute_data_ptr ^= null ()	/* free an allocated mrds_dsm_attribute_data structure */
      733 	then free mrds_dsm_attribute_data_ptr -> mrds_dsm_attribute_data;
      734 
      735 	executing = "0"b;				/* allow the module to be recalled */
      736 
      737      end /* cleanup_get_attribute_data */;
      738 
      739 cleanup_get_relation_data: proc;
      740 
      741 /*
      742*   This procedure cleansup allocated structures in the event that  a
      743*   cleanup    condition    is    signaled    while   executing   the
      744*   get_relation_data entry. It also resets the executing bit so that
      745*   the moduled can be called again.
      746**/
      747 
      748 
      749 
      750 
      751 	if mrds_dsm_relation_data_ptr ^= null ()	/* free an allocated mrds_dsm_relation_data structure */
      752 	then free mrds_dsm_relation_data_ptr -> mrds_dsm_relation_data;
      753 
      754 	if mrds_dsm_relation_names_ptr ^= null ()	/* free an allocated mrds_dsm_relation_names structure */
      755 	then free mrds_dsm_relation_names_ptr -> mrds_dsm_relation_names;
      756 
      757 	if relation_block_ptr ^= null ()		/* free an allocated relation_block structure */
      758 	then free relation_block_ptr -> relation_block;
      759 
      760 	executing = "0"b;				/* allow the module to be called again */
      761 
      762      end /* cleanup_get_relation_data */;
      763 
      764 cleanup_get_submodel_info: proc;
      765 
      766 /*
      767*   This procedure cleansup allocated structures in the event that  a
      768*   cleanup    condition    is    signaled    while   executing   the
      769*   get_submodel_info entry. It also resets the executing bit so  the
      770*   module can be recalled.
      771**/
      772 
      773 
      774 
      775 	if mrds_dsm_header_ptr ^= null ()		/* free an allocated mrds_dsm_header structure */
      776 	then free mrds_dsm_header_ptr -> mrds_dsm_header;
      777 
      778 	if mrds_dsm_submodel_info_ptr ^= null ()	/* free an allocated mrds_dsm_submodel structure */
      779 	then free mrds_dsm_submodel_info_ptr -> mrds_dsm_submodel_info;
      780 
      781 	executing = "0"b;				/* allow the module to be called again */
      782 
      783      end;						/* cleanup_get_submodel_info */
      784 
      785 cleanup_open_submodel: proc;
      786 
      787 /*
      788*   This procedure cleansup  allocated  structures  and  closes  open
      789*   files  in  the  event  that a cleanup condition is signaled while
      790*   executing the open_submodel entry. It also resets  the  executing
      791*   bit so the model can be recalled.
      792**/
      793 
      794 
      795 
      796 	if dsm_iocb_ptr ^= null ()			/* if the submodel has been opened close it */
      797 	then call mrds_dsm_close$force (dsm_iocb_ptr);
      798 
      799 	if open_info_ptr ^= null ()
      800 	then do;
      801 		call mu_open_name_manager$delete_open_name /* the name may not have been added yet */
      802 		     (opening_name, ignore_error);	/* so ignore any errors */
      803 		free open_info_ptr -> open_info;	/* free an allocated open_info structure */
      804 	     end;
      805 
      806 	executing = "0"b;				/* allow the module to be recalled */
      807 
      808      end /* cleanup_open_submodel */;
      809 
      810 verify_input_parameters: proc (opening_name, users_area_ptr, str_version, version_limit, open_info_ptr, icode);
      811 
      812 /*
      813*   This routine is used to verify the input parameters:
      814*
      815*   .   opening_name: to be sure that  the  name  is  associated
      816*   .        with a submodel opening
      817*
      818*   .   users_area_ptr: to be sure that it points to  a  freeing
      819*   .        area
      820*
      821*   .   str_version: to be sure that the  requested  version  of
      822*   .        the structure can be allocated  (assumes  that  all
      823*   .        versions  of  the structure <= version_limit can be
      824*   .        allocated
      825*
      826*   the routine also returns the pointer to a open_info  structure  -
      827*   provided that all the parameters are ok.
      828**/
      829 
      830 
      831 /* PARAMETERS */
      832 
      833 	dcl     opening_name	 char (*);	/* (input) name identifing the opening */
      834 	dcl     users_area_ptr	 ptr;		/* (input) pointer to users area */
      835 	dcl     str_version		 fixed bin;	/* (input) str version requested by user */
      836 	dcl     version_limit	 fixed bin;	/* (input) maximum str version obtainable */
      837 	dcl     open_info_ptr	 ptr;		/* (output) open_info associated with opening_name */
      838 	dcl     icode		 fixed bin (35);	/* (output) error icode */
      839 
      840 
      841 	icode = 0;
      842 
      843 	call mu_open_name_manager$get_model_pointer /* get the open_info associated with the opening_name */
      844 	     (opening_name, ignore_arg_char1, open_info_ptr, icode);
      845 	if icode = 0
      846 	then do;
      847 		if users_area_ptr = null ()		/* check to be sure that the area */
      848 		then icode = error_table_$badcall;	/* is a freeing area */
      849 		else do;
      850 			unspec (local_area_info) = "0"b;
      851 			local_area_info.version = 1;
      852 			local_area_info.areap = users_area_ptr;
      853 			call area_info_ (addr (local_area_info), icode);
      854 			if icode = 0
      855 			then do;
      856 				if local_area_info.no_freeing
      857 				then icode = mrds_error_$not_freeing_area;
      858 			     end;
      859 		     end;
      860 		if icode = 0
      861 		then do;
      862 			if (str_version > version_limit) | /* make sure that the requested */
      863 			     (str_version < 0)	/* structure can be allocated */
      864 			then icode =
      865 				error_table_$unimplemented_version;
      866 		     end;
      867 	     end;
      868 
      869 	return;
      870 
      871      end /* verify_input_parameters */;
      872 
      873 report_error: proc (icode, message, arg1, arg2, arg3);
      874 
      875 /*
      876*   This routine is used to report errors via the sub_err_ condition.
      877*   sub_err_ is called with the continue switch set so that after the
      878*   sub_err_ condition has been  acted  on  by  the  system  and  the
      879*   message  is printed control is returned to the entry which called
      880*   report_error. All this assumes that the user has not set  up  his
      881*   own  sub_err_  handler  - if he has he can return control to this
      882*   module or not as well as printing the message or not.
      883**/
      884 
      885 
      886 /* PARAMETERS */
      887 
      888 	dcl     icode		 fixed bin (35);	/* (input) error code */
      889 	dcl     message		 char (*);	/* (input) error message */
      890 	dcl     arg1		 char (*);	/* (input) first argument to error message */
      891 	dcl     arg2		 char (*);	/* (input) second argument to error message */
      892 	dcl     arg3		 char (*);	/* (input) third argument to error message */
      893 
      894 /* AUTOMATIC */
      895 
      896 	dcl     retval		 fixed bin (35);
      897 
      898 /* ENTRIES */
      899 
      900 	dcl     sub_err_		 entry options (variable);
      901 
      902 
      903 
      904 	call sub_err_ (icode, "mrds_dsm_msmi", "c", null (), retval, message, arg1, arg2, arg3);
      905 
      906 	return;
      907 
      908      end /* report_error */;
      909 
      910      end /* mrds_dsm_msmi */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/08/88  1530.1  mrds_dsm_msmi.pl1                 >spec>install>1034>mrds_dsm_msmi.pl1
193          1    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
195          2    10/14/83  1608.8  mrds_dsm_attribute_data.incl.pl1  >ldd>include>mrds_dsm_attribute_data.incl.pl1
197          3    10/14/83  1608.9  mrds_dsm_header.incl.pl1          >ldd>include>mrds_dsm_header.incl.pl1
199          4    10/14/83  1608.7  mrds_dsm_rel_block.incl.pl1       >ldd>include>mrds_dsm_rel_block.incl.pl1
201          5    10/14/83  1608.8  mrds_dsm_relation_data.incl.pl1   >ldd>include>mrds_dsm_relation_data.incl.pl1
203          6    10/14/83  1609.0  mrds_dsm_relation_names.incl.pl1  >ldd>include>mrds_dsm_relation_names.incl.pl1
205          7    10/14/83  1608.8  mrds_dsm_submodel_info.incl.pl1   >ldd>include>mrds_dsm_submodel_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DSM_SUFFIX                      000000 constant        char(3)                  initial packed unaligned dcl 157 set ref 610* 618*
MRDS_SEARCHLIST                 000034 constant        char(4)                  initial packed unaligned dcl 158 set ref 613*
addr                                                   builtin function         dcl 143 ref 853 853
append                   32            based           bit(1)                   level 3 packed packed unaligned dcl 4-26 ref 451
append_access            32            based           bit(1)                   array level 3 packed packed unaligned dcl 5-17 set
                                                                                  ref 451*
area                            000432 stack reference condition                dcl 152 ref 312 321 416 423 523 529
area_control                           based           structure                level 1 dcl 1-20
area_info                              based           structure                level 1 dcl 1-7
area_info_                      000034 constant        entry                    external dcl 179 ref 853
areap                    16     000400 automatic       pointer                  level 2 dcl 123 set ref 852*
arg1                                   parameter       char                     packed unaligned dcl 890 set ref 873 904*
arg2                                   parameter       char                     packed unaligned dcl 891 set ref 873 904*
arg3                                   parameter       char                     packed unaligned dcl 892 set ref 873 904*
attr_access              55            based           structure                array level 3 packed packed unaligned dcl 4-26
attribute_data_ptr                     parameter       pointer                  dcl 98 set ref 256 284* 350*
attribute_info           34            based           structure                array level 2 unaligned dcl 4-26
attributes                2            based           structure                array level 2 dcl 2-17
cleanup                         000440 stack reference condition                dcl 153 ref 247 292 395 502 594
code                                   parameter       fixed bin(35,0)          dcl 99 set ref 214 238* 251* 256 283* 352* 360 385*
                                                                                  463* 471 493* 550* 558 586* 655*
control                   1     000400 automatic       structure                level 2 dcl 123
creator_id              130            based           char(32)                 level 2 in structure "mrds_dsm_submodel_info" packed
                                                                                  packed unaligned dcl 7-15 in procedure "msmi_" set
                                                                                  ref 543*
creator_id               67            based           char(32)                 initial level 2 in structure "mrds_dsm_header"
                                                                                  packed packed unaligned dcl 3-13 in procedure
                                                                                  "msmi_" ref 543
database_path             2            based           char(168)                level 2 packed packed unaligned dcl 7-15 set ref
                                                                                  537*
database_pn               4            based           char(168)                initial level 2 packed packed unaligned dcl 3-13 ref
                                                                                  537
date_time_created       126            based           fixed bin(71,0)          level 2 dcl 7-15 set ref 541*
date_time_generated       2            based           fixed bin(71,0)          initial level 2 dcl 3-13 ref 541
db_path                         000100 automatic       char(168)                packed unaligned dcl 111 set ref 631* 646*
delete                   32(01)        based           bit(1)                   level 3 packed packed unaligned dcl 4-26 ref 452
delete_access            32(01)        based           bit(1)                   array level 3 packed packed unaligned dcl 5-17 set
                                                                                  ref 452*
dm_attr_name             56            based           varying char(32)         array level 3 dcl 4-26 ref 334
dm_rel_name              22            based           char(32)                 level 2 packed packed unaligned dcl 4-26 ref 447
dsm_attr_name            34            based           varying char(64)         array level 3 dcl 4-26 ref 331
dsm_dirname                     000152 automatic       char(168)                packed unaligned dcl 112 set ref 613* 618* 624 635*
                                                                                  646*
dsm_entryname                   000224 automatic       char(32)                 packed unaligned dcl 113 set ref 610* 613* 618* 624
                                                                                  635* 646*
dsm_generator_version                  based           fixed bin(17,0)          initial level 2 dcl 3-13 ref 535
dsm_iocb_ptr                    000236 automatic       pointer                  dcl 115 set ref 591* 626* 631* 638* 644 796 796*
dsm_path                               parameter       char                     packed unaligned dcl 100 in procedure "msmi_" set
                                                                                  ref 558 609 610* 618*
dsm_path                  2(09)        based           char(168)                level 2 in structure "open_info" packed packed
                                                                                  unaligned dcl 131 in procedure "msmi_" set ref 539
                                                                                  645*
dsm_path_absolute               000240 automatic       char(168)                packed unaligned dcl 116 set ref 624* 626* 645
empty                                                  builtin function         dcl 144 ref 122 606
error_table_$area_too_small     000014 external static fixed bin(35,0)          dcl 161 ref 314 418 525
error_table_$badcall            000016 external static fixed bin(35,0)          dcl 162 set ref 209* 847
error_table_$no_record          000020 external static fixed bin(35,0)          dcl 163 ref 307
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 164 ref 862
executing                       000010 internal static bit(1)                   initial packed unaligned dcl 172 set ref 240 248*
                                                                                  286 293* 354* 388 396* 465* 496 503* 552* 588 595*
                                                                                  657* 714* 735* 760* 781* 806*
expand_pathname_$add_suffix     000036 constant        entry                    external dcl 180 ref 618
get_temp_segment_               000040 constant        entry                    external dcl 181 ref 599
i                               000312 automatic       fixed bin(17,0)          dcl 118 set ref 329* 331 331 334 334 337 339 339 341
                                                                                  341 343 343 345* 431* 433 439 445 445 447 449 451
                                                                                  452 453 454*
icode                                  parameter       fixed bin(35,0)          dcl 838 in procedure "verify_input_parameters" set
                                                                                  ref 810 841* 843* 845 847* 853* 854 856* 860 862*
icode                                  parameter       fixed bin(35,0)          dcl 888 in procedure "report_error" set ref 873 904*
ignore_arg_char1                000313 automatic       char(1)                  packed unaligned dcl 119 set ref 685* 843*
ignore_error                    000314 automatic       fixed bin(35,0)          dcl 120 set ref 801*
internal_error                  000315 automatic       fixed bin(35,0)          initial dcl 121 set ref 121* 240* 251 286* 295* 299
                                                                                  302* 305 307 307* 314* 352 388* 398* 402 405* 408
                                                                                  410* 418* 433* 437 439* 463 496* 505* 509 512* 515
                                                                                  517* 525* 550 588* 599* 600 602* 610* 611 613* 614
                                                                                  618* 621 626* 628 631* 633 635* 650* 652 655 682*
                                                                                  685* 690 694* 697 699* 702*
iocb                                   based           pointer                  level 2 dcl 131 set ref 302* 405* 433* 512* 644*
                                                                                  708*
local_area                      000316 automatic       area(50)                 dcl 122 set ref 122*
local_area_info                 000400 automatic       structure                level 1 unaligned dcl 123 set ref 850* 853 853
mbz1                     32(03)        based           bit(33)                  array level 3 in structure "mrds_dsm_relation_data"
                                                                                  packed packed unaligned dcl 5-17 in procedure
                                                                                  "msmi_" set ref 454*
mbz1                     32(03)        based           bit(33)                  array level 3 in structure "mrds_dsm_attribute_data"
                                                                                  packed packed unaligned dcl 2-17 in procedure
                                                                                  "msmi_" set ref 345*
message                                parameter       char                     packed unaligned dcl 889 set ref 873 904*
model_attribute_name     22            based           char(32)                 array level 3 dcl 2-17 set ref 334* 337*
model_relation_name      22            based           char(32)                 array level 3 dcl 5-17 set ref 447* 449*
modify                   55(01)        based           bit(1)                   array level 4 packed packed unaligned dcl 4-26 ref
                                                                                  341
modify_access            32(01)        based           bit(1)                   array level 3 packed packed unaligned dcl 2-17 set
                                                                                  ref 341*
mrds_dsm_attribute_data                based           structure                level 1 dcl 2-17 set ref 319 323* 732
mrds_dsm_attribute_data_num_atts
                                000450 automatic       fixed bin(17,0)          dcl 2-31 set ref 317* 319 319 324 329
mrds_dsm_attribute_data_ptr     000446 automatic       pointer                  dcl 2-29 set ref 289* 319* 323 324 326 331 334 337
                                                                                  339 341 343 345 350 732 732
mrds_dsm_attribute_data_structure_version
                                000023 constant        fixed bin(17,0)          initial dcl 2-33 set ref 295* 326
mrds_dsm_close$force            000042 constant        entry                    external dcl 182 ref 638 708 796
mrds_dsm_determine_auth_sec     000044 constant        entry                    external dcl 183 ref 646
mrds_dsm_get_relation_names     000056 constant        entry                    external dcl 188 ref 405
mrds_dsm_header                        based           structure                level 1 unaligned dcl 3-13 ref 546 775
mrds_dsm_header_ptr             000234 automatic       pointer                  dcl 114 set ref 500* 512* 535 537 541 543 546 775
                                                                                  775
mrds_dsm_open$read_share        000046 constant        entry                    external dcl 184 ref 626
mrds_dsm_read_header            000050 constant        entry                    external dcl 185 ref 512
mrds_dsm_read_header$db_path    000052 constant        entry                    external dcl 186 ref 631
mrds_dsm_read_relation          000054 constant        entry                    external dcl 187 ref 302 433
mrds_dsm_relation_data                 based           structure                level 1 dcl 5-17 set ref 422 425* 751
mrds_dsm_relation_data_num_rels 000456 automatic       fixed bin(17,0)          dcl 5-31 set ref 421* 422 422 426
mrds_dsm_relation_data_ptr      000454 automatic       pointer                  dcl 5-29 set ref 391* 422* 425 426 428 445 447 449
                                                                                  451 452 453 454 461 751 751
mrds_dsm_relation_data_structure_version
                                000023 constant        fixed bin(17,0)          initial dcl 5-33 set ref 398* 428
mrds_dsm_relation_names                based           structure                level 1 unaligned dcl 6-17 set ref 459 754
mrds_dsm_relation_names_ptr     000460 automatic       pointer                  dcl 6-23 set ref 392* 405* 421 431 433 439 445 459
                                                                                  754 754
mrds_dsm_submodel_info                 based           structure                level 1 unaligned dcl 7-15 set ref 528 531* 778
mrds_dsm_submodel_info_ptr      000462 automatic       pointer                  dcl 7-23 set ref 499* 528* 531 532 535 537 539 541
                                                                                  543 548 778 778
mrds_dsm_submodel_info_structure_version
                                000023 constant        fixed bin(17,0)          initial dcl 7-25 set ref 505* 532
mrds_error_$not_freeing_area    000024 external static fixed bin(35,0)          dcl 165 ref 856
mrds_error_$recursion_error     000026 external static fixed bin(35,0)          dcl 166 ref 240 286 388 496 588
mrds_error_$unknown_relation_name
                                000030 external static fixed bin(35,0)          dcl 167 ref 307
msmi_area                              based           area                     dcl 136 set ref 606* 642
msmi_area_ptr                   000012 internal static pointer                  initial dcl 173 set ref 302* 405* 433* 512* 597 599*
                                                                                  606 642
mu_open_name_manager$define_open_name
                                000060 constant        entry                    external dcl 189 ref 650
mu_open_name_manager$delete_open_name
                                000062 constant        entry                    external dcl 190 ref 694 801
mu_open_name_manager$get_model_pointer
                                000064 constant        entry                    external dcl 191 ref 685 843
name_not_deleted                000424 automatic       bit(1)                   packed unaligned dcl 124 set ref 245* 692 696*
no_freeing                1(04) 000400 automatic       bit(1)                   level 3 packed packed unaligned dcl 123 set ref 856
no_rb_attributes         33            based           fixed bin(17,0)          level 2 dcl 4-26 ref 317 348 456 729 757
nrels                                  based           fixed bin(17,0)          level 2 dcl 6-17 ref 421 431 459 754
null                     32(02)        based           bit(1)                   level 3 in structure "relation_block" packed packed
                                                                                  unaligned dcl 4-26 in procedure "msmi_" ref 453
null                     55(02)        based           bit(1)                   array level 4 in structure "relation_block" packed
                                                                                  packed unaligned dcl 4-26 in procedure "msmi_" ref
                                                                                  343
null                                                   builtin function         dcl 145 in procedure "msmi_" ref 243 244 284 289 290
                                                                                  386 391 392 393 494 499 500 591 592 597 613 613
                                                                                  683 706 729 732 751 754 757 775 778 796 799 847
                                                                                  904 904
null_access              32(02)        based           bit(1)                   array level 3 in structure "mrds_dsm_relation_data"
                                                                                  packed packed unaligned dcl 5-17 in procedure
                                                                                  "msmi_" set ref 453*
null_access              32(02)        based           bit(1)                   array level 3 in structure "mrds_dsm_attribute_data"
                                                                                  packed packed unaligned dcl 2-17 in procedure
                                                                                  "msmi_" set ref 343*
number_of_attributes      1            based           fixed bin(17,0)          level 2 dcl 2-17 set ref 319* 323 324* 732
number_of_relations       1            based           fixed bin(17,0)          level 2 dcl 5-17 set ref 422* 425 426* 751
open_info                              based           structure                level 1 unaligned dcl 131 set ref 642 652 710 803
open_info_ptr                          parameter       pointer                  dcl 837 in procedure "verify_input_parameters" set
                                                                                  ref 810 843*
open_info_ptr                   000426 automatic       pointer                  dcl 126 in procedure "msmi_" set ref 243* 295* 302
                                                                                  334 398* 405 433 447 505* 512 539 592* 642* 644
                                                                                  645 646 650* 652 683 685* 687 708 799 803
open_info_ptr2                  000430 automatic       pointer                  dcl 127 set ref 244* 687* 706 710
opening_name                           parameter       char                     packed unaligned dcl 833 in procedure
                                                                                  "verify_input_parameters" set ref 810 843*
opening_name                           parameter       char                     packed unaligned dcl 101 in procedure "msmi_" set
                                                                                  ref 214 256 295* 360 398* 471 505* 558 650* 685*
                                                                                  694* 699* 801*
read                     55            based           bit(1)                   array level 4 packed packed unaligned dcl 4-26 ref
                                                                                  339
read_access              32            based           bit(1)                   array level 3 packed packed unaligned dcl 2-17 set
                                                                                  ref 339*
rel_access               32            based           structure                level 2 packed packed unaligned dcl 4-26
relation                  1            based           char(32)                 array level 2 packed packed unaligned dcl 6-17 set
                                                                                  ref 433* 439* 445
relation_block                         based           structure                level 1 unaligned dcl 4-26 ref 348 456 729 757
relation_block_ptr              000452 automatic       pointer                  dcl 4-22 set ref 290* 302* 317 331 334 339 341 343
                                                                                  348 393* 433* 447 451 452 453 456 729 729 757 757
relation_data_ptr                      parameter       pointer                  dcl 102 set ref 360 386* 461*
relation_name                          parameter       char                     packed unaligned dcl 103 set ref 256 302*
relations                 2            based           structure                array level 2 dcl 5-17
return_model_stuff        2            based           bit(1)                   level 2 packed packed unaligned dcl 131 set ref 334
                                                                                  447 646*
retval                          000100 automatic       fixed bin(35,0)          dcl 896 set ref 904*
rtrim                                                  builtin function         dcl 146 ref 624
search                                                 builtin function         dcl 147 ref 609
search_paths_$find_dir          000070 constant        entry                    external dcl 584 ref 613
str_version                            parameter       fixed bin(17,0)          dcl 104 in procedure "msmi_" set ref 256 295* 360
                                                                                  398* 471 505*
str_version                            parameter       fixed bin(17,0)          dcl 835 in procedure "verify_input_parameters" ref
                                                                                  810 862 862
sub_err_                        000072 constant        entry                    external dcl 900 ref 904
submodel_attribute_name
                          2            based           char(64)                 array level 3 dcl 2-17 set ref 331*
submodel_info_ptr                      parameter       pointer                  dcl 106 set ref 471 494* 548*
submodel_path            54            based           char(168)                level 2 packed packed unaligned dcl 7-15 set ref
                                                                                  539*
submodel_relation_name
                          2            based           char(64)                 array level 3 dcl 5-17 set ref 445*
submodel_version          1            based           fixed bin(17,0)          level 2 dcl 7-15 set ref 535*
suffixed_name_$make             000066 constant        entry                    external dcl 583 ref 610
sys_info$max_seg_size           000032 external static fixed bin(35,0)          dcl 168 ref 606
unspec                                                 builtin function         dcl 148 set ref 323* 425* 531* 850*
users_area                             based           area(1024)               dcl 139 ref 319 422 528
users_area_ptr                         parameter       pointer                  dcl 107 in procedure "msmi_" set ref 256 295* 319
                                                                                  360 398* 422 471 505* 528
users_area_ptr                         parameter       pointer                  dcl 834 in procedure "verify_input_parameters" ref
                                                                                  810 847 852
version                                based           fixed bin(17,0)          level 2 in structure "mrds_dsm_submodel_info"
                                                                                  dcl 7-15 in procedure "msmi_" set ref 532*
version                         000400 automatic       fixed bin(17,0)          level 2 in structure "local_area_info" dcl 123
                                                                                  in procedure "msmi_" set ref 851*
version                                based           fixed bin(17,0)          level 2 in structure "mrds_dsm_relation_data"
                                                                                  dcl 5-17 in procedure "msmi_" set ref 428*
version                                based           fixed bin(17,0)          level 2 in structure "mrds_dsm_attribute_data"
                                                                                  dcl 2-17 in procedure "msmi_" set ref 326*
version_limit                          parameter       fixed bin(17,0)          dcl 836 ref 810 862

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
RELATION_BLOCK_VERSION_1               internal static fixed bin(35,0)          initial dcl 4-24
area_info_version_1                    internal static fixed bin(17,0)          initial dcl 1-3
area_infop                             automatic       pointer                  dcl 1-5
mrds_dsm_relation_names_nrels_alloc    automatic       fixed bin(17,0)          dcl 6-21
rb_number_of_attributes                automatic       fixed bin(35,0)          dcl 4-23

NAMES DECLARED BY EXPLICIT CONTEXT.
cleanup_close_submodel          002533 constant        entry                    internal dcl 662 ref 247 250
cleanup_get_attribute_data      002710 constant        entry                    internal dcl 718 ref 292
cleanup_get_relation_data       002742 constant        entry                    internal dcl 739 ref 395
cleanup_get_submodel_info       003006 constant        entry                    internal dcl 764 ref 502
cleanup_open_submodel           003030 constant        entry                    internal dcl 785 ref 594
close_submodel                  000342 constant        entry                    external dcl 214
exit_get_attribute_data         001002 constant        label                    dcl 352 ref 299 309 315
exit_get_relation_data          001461 constant        label                    dcl 463 ref 402 413 419 442
exit_get_submodel_info          001742 constant        label                    dcl 550 ref 509 520 526
exit_open_submodel              002525 constant        label                    dcl 655 ref 604 611 614 621 628 639
get_attribute_data              000437 constant        entry                    external dcl 256
get_relation_data               001014 constant        entry                    external dcl 360
get_submodel_info               001470 constant        entry                    external dcl 471
mrds_dsm_msmi                   000275 constant        entry                    external dcl 18
msmi_                           000265 constant        entry                    external dcl 18
open_submodel                   001753 constant        entry                    external dcl 558
report_error                    003223 constant        entry                    internal dcl 873 ref 209 410 439 517 602 635 699
verify_input_parameters         003077 constant        entry                    internal dcl 810 ref 295 398 505

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4256        4352    3537        4266
Length      5004    3537        74         415     517           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
msmi_                               424 external procedure  is an external procedure.  
on unit on line 247                  64 on unit               
on unit on line 292                  70 on unit               
on unit on line 312                  64 on unit               
on unit on line 395                  70 on unit               
on unit on line 416                  64 on unit               
on unit on line 502                  70 on unit               
on unit on line 523                  64 on unit               
on unit on line 594                  84 on unit               
cleanup_close_submodel              142 internal procedure  is called by several nonquick procedures.  
cleanup_get_attribute_data              internal procedure  shares stack frame of on unit on line 292.  
cleanup_get_relation_data               internal procedure  shares stack frame of on unit on line 395.  
cleanup_get_submodel_info               internal procedure  shares stack frame of on unit on line 502.  
cleanup_open_submodel                   internal procedure  shares stack frame of on unit on line 594.  
verify_input_parameters                 internal procedure  shares stack frame of external procedure msmi_.  
report_error                        114 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 executing                   msmi_
000012 msmi_area_ptr               msmi_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
msmi_                    000100 db_path                     msmi_
                         000152 dsm_dirname                 msmi_
                         000224 dsm_entryname               msmi_
                         000234 mrds_dsm_header_ptr         msmi_
                         000236 dsm_iocb_ptr                msmi_
                         000240 dsm_path_absolute           msmi_
                         000312 i                           msmi_
                         000313 ignore_arg_char1            msmi_
                         000314 ignore_error                msmi_
                         000315 internal_error              msmi_
                         000316 local_area                  msmi_
                         000400 local_area_info             msmi_
                         000424 name_not_deleted            msmi_
                         000426 open_info_ptr               msmi_
                         000430 open_info_ptr2              msmi_
                         000446 mrds_dsm_attribute_data_ptr msmi_
                         000450 mrds_dsm_attribute_data_num_atts
                                                            msmi_
                         000452 relation_block_ptr          msmi_
                         000454 mrds_dsm_relation_data_ptr  msmi_
                         000456 mrds_dsm_relation_data_num_rels
                                                            msmi_
                         000460 mrds_dsm_relation_names_ptr msmi_
                         000462 mrds_dsm_submodel_info_ptr  msmi_
report_error             000100 retval                      report_error

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other_desc call_int_other      return_mac          tra_ext_1           enable_op           shorten_stack
ext_entry           ext_entry_desc      int_entry           int_entry_desc      op_alloc_           op_freen_
op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
area_info_                    expand_pathname_$add_suffix   get_temp_segment_             mrds_dsm_close$force
mrds_dsm_determine_auth_sec   mrds_dsm_get_relation_names   mrds_dsm_open$read_share      mrds_dsm_read_header
mrds_dsm_read_header$db_path  mrds_dsm_read_relation        mu_open_name_manager$define_open_name
mu_open_name_manager$delete_open_name                       mu_open_name_manager$get_model_pointer
search_paths_$find_dir        sub_err_                      suffixed_name_$make

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$area_too_small   error_table_$badcall          error_table_$no_record
error_table_$unimplemented_version                          mrds_error_$not_freeing_area  mrds_error_$recursion_error
mrds_error_$unknown_relation_name                           sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    121 000256       122 000257        18 000264       209 000303       212 000335       214 000336       238 000361
    240 000362       243 000370       244 000372       245 000373       247 000375       248 000417       250 000422
    251 000426       254 000430       256 000431       283 000467       284 000470       286 000473       289 000501
    290 000503       292 000504       293 000522       295 000525       299 000561       302 000563       305 000614
    307 000616       309 000623       312 000624       314 000640       315 000643       317 000646       319 000651
    321 000663       323 000664       324 000674       326 000676       329 000700       331 000707       334 000723
    337 000742       339 000747       341 000755       343 000761       345 000765       346 000767       348 000771
    350 000777       352 001002       354 001004       358 001006       360 001007       385 001037       386 001040
    388 001043       391 001051       392 001053       393 001054       395 001055       396 001073       398 001076
    402 001132       405 001134       408 001151       410 001153       413 001204       416 001205       418 001221
    419 001224       421 001227       422 001231       423 001243       425 001244       426 001254       428 001256
    431 001260       433 001267       437 001323       439 001325       442 001364       445 001365       447 001401
    449 001415       451 001422       452 001430       453 001434       454 001440       456 001442       457 001447
    459 001451       461 001456       463 001461       465 001463       469 001465       471 001466       493 001513
    494 001514       496 001517       499 001525       500 001527       502 001530       503 001546       505 001551
    509 001605       512 001607       515 001624       517 001626       520 001657       523 001660       525 001674
    526 001677       528 001702       529 001710       531 001711       532 001714       535 001716       537 001720
    539 001724       541 001730       543 001732       546 001735       548 001737       550 001742       552 001744
    556 001746       558 001747       586 001777       588 002000       591 002006       592 002010       594 002011
    595 002027       597 002032       599 002036       600 002062       602 002064       604 002115       606 002116
    609 002122       610 002137       611 002165       613 002167       614 002226       616 002230       618 002231
    621 002263       624 002265       626 002324       628 002346       631 002350       633 002363       635 002365
    638 002420       639 002427       642 002430       644 002436       645 002440       646 002443       650 002470
    652 002521       655 002525       657 002527       660 002531       662 002532       682 002540       683 002542
    685 002546       687 002574       690 002600       692 002603       694 002605       696 002624       697 002626
    699 002630       702 002665       706 002667       708 002673       710 002702       714 002705       716 002707
    718 002710       729 002711       732 002724       735 002737       737 002741       739 002742       751 002743
    754 002756       757 002770       760 003003       762 003005       764 003006       775 003007       778 003016
    781 003025       783 003027       785 003030       796 003031       799 003045       801 003052       803 003071
    806 003074       808 003076       810 003077       841 003110       843 003112       845 003140       847 003143
    850 003153       851 003156       852 003160       853 003163       854 003176       856 003201       860 003207
    862 003211       869 003221       873 003222       904 003255       906 003335


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
