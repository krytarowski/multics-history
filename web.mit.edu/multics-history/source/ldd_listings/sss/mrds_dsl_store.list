	COMPILATION LISTING OF SEGMENT mrds_dsl_store
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1328.8 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 
       19 /****^  HISTORY COMMENTS:
       20*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       21*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       22*     This entry is being made to cover the change made on 85-04-19 by Thanh
       23*     Nguyen. (see mrds #136)
       24*                                                   END HISTORY COMMENTS */
       25 
       26 mrds_dsl_store:
       27 store:
       28      proc;
       29 
       30 
       31 /*
       32*
       33*		      BEGIN_DESCRIPTION
       34*
       35*   The call to store looks like :
       36*
       37*   call  mrds_dsl_store (database_index, relation_name, value_1, ..., value_n,
       38*   code);
       39*
       40*   store  accepts  as  input  from  the  caller an index to the database to be
       41*   referenced  the  name  of  the  relation  to  be  affected the values to be
       42*   assigned to a tuple of the affected relation and a recturn code.
       43*
       44*   if the attempt to store is unsuccesful for some reason a nonzero code value
       45*   is returned to the caller
       46*
       47*   store  requires  that  the  database is open for update or exclusive update
       48*   activity and that append_tuple or store_tuple scope be set on the relation.
       49*		       END_DESCRIPTION
       50*
       51*   Known Bugs:
       52*      1) data types of the arguments are not checked so it is possible
       53*         to have a character string dbi which is treated as a fixed
       54*         bin (35) value (NSD 83-04-05)
       55*
       56*   Other Problems:
       57*      1) replacing the mdbm_arg_list include file with the system arg_list
       58*         include file would reduce the number of index calculations needed
       59*         and the divide operation to get the number of arguments. It would
       60*         also improve the readability since descriptor and argument pointers
       61*         would be separated.
       62*      2) investigate the need to call mu_release_area in every call (is
       63*         it really necessary to free the temp segment or can it be kept
       64*         around) also a faster way to empty the area.
       65*
       66*   HISTORY:
       67*
       68*   76-02-01 Oris Friesen : Originally written.
       69*
       70*   78-05-01 J. A. Weeldreyer: Rewritten for MR7.0.
       71*
       72*   79-22-04 Al Kepner: to add scope checking.
       73*
       74*   79-08-27  NSDavids:  Modified  to return a zero value error code if the the
       75*   store was successful rather than just not changing the value of the code.
       76*
       77*   79-12-01  Jim  Gray  : Modified to add call to mu_valid_data_type, and make
       78*   changes  to  assign_  length parameter handling to make packed decimal data
       79*   types available, also corrected signed scale problem
       80*
       81*   80-02-01  Jim  Gray  :  Modified  to  put  allocations  in  a  non-freeing,
       82*   extensible area managed by this routine.
       83*
       84*   80-05-08 Davids: modified assignments of tuple_num_atts and tuple_nvar_atts
       85*   to  take  values from rm_rel_info.model_num_attr and model_nvar_atts rather
       86*   than  rm_rel_info.num_attr  and  nvar_atts.  This was to fix a problem with
       87*   submodels were the submodel view did not contain a varying string attribute
       88*   and the model did.
       89*
       90*   80-12-10  Jim  Gray  :  modified  scope check to handle r-u to r-s-m-d type
       91*   scope  modes  change, and new name of append_tuple for store.  Details of a
       92*   store scope violation are now reported via sub_err_
       93*
       94*   81-01-29 Jim Gray : removed references to mdbm_data_$current_version, using
       95*   a constant instead, to allow future db version expansion.
       96*
       97*   81-03-27 Jim Gray : changed dbi to dbcb_ptr parameter for mu_store, as part
       98*   of getting rid of mus_ptr_man module.
       99*
      100*   81-05-06   Rickie   E.   Brinegar:  modified  to  make  use  of  a  changed
      101*   rm_domain_info structure.
      102*
      103*   81-06-01 Jim Gray : modified to use new resultant structures.
      104*
      105*   81-06-18  Roger  Lackey  : modified to use last_store_rel_name in dbdb.incl
      106*   also to remove references to store_info.n36 n27 n18 and store_info.ht_len.
      107*
      108*   81-06-19 Roger Lackey : Minor format cleanup for previous change.
      109*
      110*   81-07-02  Jim  Gray  : added code to update the relation reference count in
      111*   the new statistics section of rm_rel_info.
      112*
      113*   81-07-07  Jim  Gray : added reset of the auto -another rel name in the dbcb
      114*   to  the  clean up handler, so that errors do not cause the flag to get hung
      115*   up.
      116*
      117*   81-09-17  Rickie  E.   Brinegar: moved the seting of num_ptrs to a point in
      118*   frong  of  the  first reference of arg_list.arg_ptrs to eliminate subscript
      119*   range faults.
      120*
      121*   81-10-30 Davids: Modified so that the internal procedure error is
      122*   not  called  if the error returned by mu_store is dup_store. This
      123*   allows the -another (either explicit or automatic  (by  specifing
      124*   the  same  rel  name)) to be used after the dup_store error. this
      125*   answers tr11808
      126*
      127*   81-12-15 R. Lackey : Modify to search rm_rel_array for full name. TR11887.
      128*
      129*   81-12-18 Davids: Modified so that rel_name if not  found  in  the
      130*   list  of permanent relations will be considered a temp rel index.
      131*   Scopes are not checked for temporary relations. This so that temp
      132*   rels can be updateable.
      133*
      134*   82-01-08 R. Lackey : Added check to detect relation names longer
      135*   then 30 characters.
      136*
      137*   82-08-19 Mike Kubicar : Removed all reference to the tuple structure;
      138*   changed mrds_dsl_store to use a simple_typed_vector instead.
      139*
      140*   83-01-18 Davids: Added transaction code
      141*
      142*   83-01-24 Davids: modifed to set mstxn_txn_id = "0"b as the first thing, so that
      143*   it is set incase an error occurs in argument processing or getting the 
      144*   database index.
      145*   
      146*   83-03-35 Roger Lackey : Modified to check scope on all calls
      147*
      148*   83-03-28 Roger Lackey : Changed place where move_list was allocated to be in
      149*                           do  new store.
      150*
      151*   83-03-30 Davids: Changes to improve preformance - replaced multiple
      152*   references to "fixed (arg_list.code = SPECIAL)" with a reference to an
      153*   automatic variable and reference the above code fragment 1 to set the
      154*   variable (environment_pointer_offset). Also replaced references to the
      155*   "/" infix operator with the divide builtin.
      156*
      157*   83-03-31 Davids: More changes to improve performance - removed excess
      158*   if-then-else nesting, removed extraneous setup of a cleanup condition
      159*   handler, shortened test for a relation name over 30 characters by first
      160*   testing the actual length of the relname and only if thats greater than
      161*   30 then determining if the first space occurs within the limit, this
      162*   replaced always doing a length (rtrim (relname)), shortened all the code
      163*   that assignes the move_list.item_user_desc_ptr to just an assignment
      164*   from the desc_ptr instead of lots of hairy ifs that checked to see if
      165*   the descriptor was for a structure (at this point it never could be) or
      166*   an array (again at this point point it couldn't be). Removed include files
      167*   mdbm_rm_attr_info, mdbm_rm_domain_info and vu_typed_vector.
      168*
      169*   83-04-04 Davids: Added view, and security level checking
      170*   which used to be in mu_store. Added variables mdbm_error_$view_prevent,
      171*   and inc_rel_acc. Note that ready_mode checking was not copied from 
      172*   mu_store since ready_mode is no longer needed, if scopes are ok ready_mode
      173*   will always be ok. Also it is not necessary to check the read permission
      174*   access on the key attributes for security checking since you cannot create
      175*   a submodel with append access on a relation unless all of its key attrs
      176*   have read access so the check was redundant.
      177*
      178*   83-04-05 Davids: Replaced the call to mu_store with calls to mu_build_tuple
      179*   mu_cursor_manager_$get and dbcb.relmgr_entries.put_tuple (the calls that
      180*   mu_store used to make). The call to mu_cursor_manager_$get is done only for
      181*   a "new" store, the cursor_ptr is saved in the store_info structure. The
      182*   variable unused_tuple_id was added since the call to put_tuple returns the
      183*   tuple_id. The variable t_ptr was deleted since it was not needed and a
      184*   check to be sure that the dbi_ptr was non-null was deleted since the
      185*   argument list cannot have null argument pointers.
      186*
      187*   83-04-06 Davids: modified the scope checking code to use the new
      188*   scope_flags_ptr in the rm_rel_info structure instead of sequentially
      189*   looking through the scope_info array. Deleted declaration to variable j
      190*   which is no longer used. Moved the transaction start include file to right
      191*   before the if statement that determines if this is a "new" store. This was
      192*   needed becuase cursors for protected data files must be created in a
      193*   transaction.
      194*
      195*   83-04-07 Davids: Replaced the use of the val_args array with an array of just
      196*   the argument pointers and an array of just the argument descriptors. For the
      197*   case of a structure these new arrays are based on the val_args array. For
      198*   the non-structure case they are based on the original argument list. This
      199*   eliminated the allocation of the val_args array and the loop setting each
      200*   element of the array from the argument list for the non-structure case. It
      201*   also eliminates additions in the index calculation when the move_list is
      202*   built. The new variables arg_val_ptr_array_ptr, arg_val_ptr_array,
      203*   arg_desc_ptr_array_ptr, arg_desc_ptr_array were added. The variables doffset
      204*   work_area are no longer used and were deleted.
      205*
      206*   83-05-04 Davids: Modified so that mu_define_area is called with a name
      207*   of MRDS || dbi_pic. This will allow closes to be faster since all
      208*   temp_segments with the name MRDS || dbi_pic can be deleted/freed in 1 call.
      209*   the variable dbi_pic was created as an easy way to convert from fixed bin
      210*   to character.
      211*
      212*   83-05-23 Mike Kubicar : relation manager calling sequence change
      213*
      214*   83-06-20 Davids: Removed check for old version database and the call
      215*   to v1 code if it was an old version db (old version dbs can no longer
      216*   be opened)
      217*
      218*   84-05-21 Moberg:  Fixed check for long relation names which had an off by
      219*   one error.
      220**/
      221 
      222 	icode, num_dims = 0;
      223 	dbcb_ptr, arg_ptr = null;
      224 	mstxn_txn_id = "0"b;
      225 
      226 	call cu_$arg_list_ptr (al_ptr);
      227 	num_ptrs = arg_list.arg_count;
      228 	if arg_list.arg_count < 8
      229 	then signal arg_err;			/* must be at least four arguments */
      230 
      231 /* get ptr to return code argument */
      232 	n_args = divide (arg_list.arg_count, 2, 17, 0);
      233 	c_ptr = arg_list.arg_des_ptr (n_args);
      234 	code = 0;					/* in case things work make sure to return 0. */
      235 	dbi_ptr = arg_list.arg_des_ptr (1);		/* get the index value to the
      236*						   data base which is to be stored into */
      237 
      238 /* translate it into a ptr to th database control block */
      239 	call mu_database_index$get_resultant_model_pointer (db_index, dbcb_ptr);
      240 	if dbcb_ptr = null then
      241 	     call error (mrds_error_$invalid_db_index);
      242 
      243 	rdbi_ptr = dbcb.rdbi_ptr;
      244 
      245 	mstxn_transactions_needed = dbcb.transactions_needed;
      246 
      247 	on cleanup begin;
      248 		call mstxn_cleanup;
      249 		call clean_up;
      250 	     end;
      251 
      252 	on any_other call mstxn_any_other;
      253 
      254 	dbi_pic = dbcb.dbi;
      255 	call
      256 	     mu_define_area$define_temp_dir_area (dbcb.store_area_ptr, db_index, (sys_info$max_seg_size),
      257 	     "MRDS" || dbi_pic, "0"b /* not extensible */,
      258 	     "1"b /* no freeing */, "0"b, "0"b /* no zeroing */, icode);
      259 	if icode ^= 0 then
      260 	     call error (icode);
      261 	area_ptr = dbcb.store_area_ptr;
      262 
      263 	rn_ptr = arg_list.arg_des_ptr (2);
      264 	environment_pointer_offset = fixed (arg_list.code = SPECIAL);
      265 	desc_ptr = arg_list.arg_des_ptr (2 + n_args + environment_pointer_offset);
      266 	rn_len = fixed (string (descriptor.size));
      267 	if rn_len > 30
      268 	then do;
      269 		first_space = index (rel_name, " ");
      270 		if first_space = 0 | first_space > 31
      271 		then call error (mrds_error_$rel_name_too_long);
      272 	     end;
      273 
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      274 
      275 
      276 	if mstxn_code ^= 0
      277 	then call error (mstxn_code);
      278 
      279 	dbcb.user_started_transaction = user_started_transaction;
      280 
      281 	if rel_name = "-another" | dbcb.last_store_rel_name = rel_name then do;
      282 
      283 		if dbcb.sti_ptr = null then
      284 		     call error (mrds_error_$no_prev_store);
      285 		sti_ptr = dbcb.sti_ptr;		/* pick up info from prev. store */
      286 		rmri_ptr = store_info.ri_ptr;
      287 		ml_ptr = store_info.ml_ptr;
      288 	     end;
      289 	else do;					/* if new store */
      290 
      291 		dbcb.last_store_rel_name = "!!!!!!!... ...!!!!!"; /*  Temparory store bad rel name so it won't compare if this store fails */
      292 
      293 		call free_store_info;
      294 		allocate store_info in (dbcb.static_area); /* set up store information */
      295 		dbcb.sti_ptr = sti_ptr;
      296 		store_info.ml_ptr = null ();
      297 		store_info.temp_rel = "0"b;		/* Until we find out */
      298 		rmra_ptr = rm_db_info.ra_ptr;		/* find rel info */
      299 
      300 		rel_name_32 = rel_name;		/* Get proper length for search */
      301 		i = index (string (rm_rel_array.name), "!" || rel_name_32);
      302 
      303 		if i = 0 then do;			/* if not found - could be temp rel index */
      304 			rmra_ptr = rm_db_info.tra_ptr;
      305 			i = cv_dec_check_ (rel_name, icode); /* if number it must be a temp rel */
      306 			if icode ^= 0
      307 			then call error (mrds_error_$unknown_relation_name);
      308 			else
      309 			     if i < 1 | i > mrds_data_$max_temp_rels /* must be a number within range */
      310 			then call error (mrds_error_$undefined_temp_rel_index);
      311 			else
      312 			     if rm_rel_array.rel_data.ri_ptr (i) = null () /* must be a defined temp rel */
      313 			then call error (mrds_error_$undefined_temp_rel_index);
      314 			else do;
      315 				rmri_ptr = rm_rel_array.rel_data.ri_ptr (i);
      316 				store_info.temp_rel = "1"b;
      317 			     end;
      318 		     end;
      319 		else do;
      320 			i = divide ((i - 1), 33, 17, 0) + 1; /* convert from char to array index */
      321 			rmri_ptr = rm_rel_array.rel_data.ri_ptr (i);
      322 			store_info.temp_rel = "0"b;
      323 		     end;
      324 
      325 		call mu_cursor_manager_$get (dbcb.dbi, rmri_ptr, 0, /* tuple variable = 0 for stores */
      326 		     rm_rel_info.rel_id, dbcb.relmgr_entries.create_cursor, /* so that retrieve-store-retrieve */
      327 		     dbcb.relmgr_entries.open, dbcb.cursor_ptrs_storage_ptr, /* can be done without screwups */
      328 		     dbcb.cursor_storage_area_ptr, store_info.cursor_ptr, icode);
      329 		if icode ^= 0
      330 		then call error (icode);
      331 
      332 		if rm_rel_info.last_statistics_update_count ^= 0 & /* 0 => staticstics not ever set */
      333 		     rm_rel_info.last_statistics_update_count
      334 		     <= mrds_data_$statistics_update_count_interval then
      335 		     rm_rel_info.last_statistics_update_count =
      336 			rm_rel_info.last_statistics_update_count + 1;
      337 						/* add to reference count for this rel */
      338 
      339 		store_info.ri_ptr = rmri_ptr;
      340 		store_info.num_atts = rm_rel_info.model_num_attr;
      341 						/* allocate space for tuple */
      342 		ml_nitems_init = rm_rel_info.num_attr;	/* allocate and set up move list */
      343 		allocate move_list in (dbcb.static_area) set (store_info.ml_ptr);
      344 		ml_ptr = store_info.ml_ptr;
      345 		do i = 1 to move_list.nitems;
      346 		     move_list.item.attr_index (i) = i;
      347 		end;
      348 
      349 	     end;					/* if new store */
      350 
      351 	if ^store_info.temp_rel
      352 	then do;
      353 		if ^rm_rel_info.scope_flags_ptr -> scope_flags.permits.append_tuple
      354 		then do;				/* if scope not set for append_tuple */
      355 			call sub_err_ (mrds_error_$scope_viol, caller_name, continue, info_ptr, return_value,
      356 			     "^/The relation ""^a"" needs a scope permission of ""append tuple"" in order to perform this operation",
      357 			     rm_rel_info.name);
      358 			call error (mrds_error_$scope_viol);
      359 		     end;
      360 
      361 		if ^rm_rel_info.store		/* verify submodel view valid for store */
      362 		then call error (mrds_error_$view_prevent);
      363 
      364 		if rm_rel_info.mdbm_secured		/* verify security access if necessary */
      365 		then do;
      366 			if ^rm_rel_info.append_tuple_perm /* check access to rel. */
      367 			then call error (mrds_error_$inc_rel_acc);
      368 		     end;
      369 
      370 	     end;					/* check scope, view, security access */
      371 
      372 	desc_ptr = arg_list.arg_des_ptr (n_args + environment_pointer_offset + 3);
      373 	if descriptor.type = STRUCTURE_TYPE & n_args = 4 then do;
      374 						/* if values in structure */
      375 		data_ptr = arg_list.arg_des_ptr (3);	/* ptr to the third argument */
      376 		descr_ptr = desc_ptr;		/* ptr to
      377*						   the descriptor of the third argument */
      378 		call
      379 		     mu_break_structure (area_ptr, data_ptr, descr_ptr, arg_ptr,
      380 		     val_arg_count, icode);		/* break_structure procedure implicitly sets arg_ptr by allocating
      381*						   val_args in static_area */
      382 		if icode ^= 0 then
      383 		     call error (icode);
      384 
      385 		arg_val_ptr_array_ptr = addr (val_args (1));
      386 		arg_desc_ptr_array_ptr = addr (val_args (val_arg_count + 1));
      387 
      388 		was_structure = "1"b;
      389 	     end;
      390 
      391 	else do;					/* third arg was not a structure */
      392 		val_arg_count = n_args - 3;		/* this is the number of values passed
      393*						   by the caller */
      394 
      395 		arg_val_ptr_array_ptr = addr (arg_list.arg_des_ptr (3));
      396 		arg_desc_ptr_array_ptr = addr (arg_list.arg_des_ptr (environment_pointer_offset + 3 + n_args));
      397 
      398 		was_structure = "0"b;
      399 	     end;
      400 
      401 	if val_arg_count ^= rm_rel_info.num_attr
      402 	then call error (error_table_$wrong_no_of_args);
      403 
      404 	do i = 1 to val_arg_count;			/* build move_list */
      405 	     desc_ptr = arg_desc_ptr_array (i);
      406 	     if ^mu_valid_data_type$valid_scalar_data_type (desc_ptr -> descriptor_overlay)
      407 	     then call error (mrds_error_$invalid_dm_descriptor);
      408 
      409 	     move_list.item.user_ptr (i) = arg_val_ptr_array (i);
      410 	     if ^was_structure then
      411 		if descriptor.type = VAR_CHAR | descriptor.type = VAR_BIT then
      412 		     move_list.item.user_ptr (i) =
      413 			addrel (move_list.item.user_ptr (i), -1);
      414 	     move_list.item.user_desc_ptr (i) = desc_ptr;
      415 	end;
      416 
      417 	call mu_build_tuple (rmri_ptr, area_ptr, dbcb.store_vector_ptr, ml_ptr, "0"b, icode); /* build the tuple */
      418 	if icode ^= 0
      419 	then call error (icode);
      420 
      421 	call dbcb.relmgr_entries.put_tuple (store_info.cursor_ptr,
      422 	     dbcb.store_vector_ptr, unused_tuple_id, icode);
      423 	if icode = dm_error_$key_duplication then do;
      424 		icode = mrds_error_$dup_store;	/* The error code everyone is expecting */
      425 		mftxn_code = 0;
      426 	     end;
      427 	else mftxn_code = icode;
      428 
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      429 
      430 
      431 	if mftxn_code ^= 0
      432 	then call error (mftxn_code);
      433 
      434 	if icode ^= 0 then do;
      435 		if icode = mrds_error_$dup_store	/* do not call the clean up procedure */
      436 		then code = icode;			/* in the event of a duplicate key error */
      437 		else call error (icode);
      438 	     end;
      439 
      440 	dbcb.last_store_rel_name = rel_name;		/* Save the relation name for next call to store */
      441 
      442 exit:
      443 	if dbcb_ptr = null () then
      444 	     ;
      445 	else if dbcb.store_area_ptr ^= null () then
      446 	     call mu_release_area (dbcb.store_area_ptr);
      447 	return;
      448 
      449 
      450 should_rollback: proc () returns (bit (1));
      451 
      452 	return ("0"b);
      453 
      454 /* There are no circumstances under which a rollback is desired here */
      455 
      456      end should_rollback;
      457 
      458 
      459 
      460 restore_significant_data: proc;
      461 
      462 	return;					/* no data need be restored before a retry */
      463 
      464      end restore_significant_data;
      465 
      466 clean_up:
      467      proc;
      468 
      469 
      470 	if dbcb_ptr ^= null then do;
      471 		call free_store_info;
      472 		dbcb.last_store_rel_name = "!!!!!!!!  !!!!!!!"; /* reset so errors don't
      473*						   leave this in a state implying that
      474*						   -another can automatically be forced */
      475 	     end;
      476 
      477      end clean_up;
      478 
      479 
      480 free_store_info:
      481      proc;
      482 
      483 	if dbcb.sti_ptr ^= null then do;		/* clean out store info */
      484 		sti_ptr = dbcb.sti_ptr;
      485 		if store_info.ml_ptr ^= null then do;
      486 			free store_info.ml_ptr -> move_list in (dbcb.static_area);
      487 			store_info.ml_ptr = null ();
      488 		     end;
      489 		free store_info in (dbcb.static_area);
      490 		dbcb.sti_ptr = null ();
      491 	     end;
      492 
      493      end free_store_info;
      494 
      495 error:
      496      proc (err_code);
      497 	dcl     err_code		 fixed bin (35);
      498 	code = err_code;
      499 	call clean_up;
      500 	go to exit;
      501      end error;
      502 
      503 	dcl     mu_valid_data_type$valid_scalar_data_type entry (bit (36)) returns (bit (1) aligned);
      504 	dcl     descriptor_overlay	 bit (36) unal based; /* overlay for descriptor */
      505 	dcl     area_ptr		 ptr;
      506 	dcl     mu_release_area	 entry (ptr);
      507 	dcl     mu_define_area$define_temp_dir_area
      508 				 entry (ptr, fixed bin (35), fixed bin (18), char (11), bit (1) aligned,
      509 				 bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35));
      510 	dcl     sub_err_		 entry options (variable); /* reports errors */
      511 	dcl     continue		 char (1) init ("c"); /* dont stop after printing mesg */
      512 	dcl     caller_name		 char (32) init ("mrds_dsl_store"); /* name of calling routine */
      513 	dcl     info_ptr		 ptr init (null ());/* unused */
      514 	dcl     return_value	 fixed bin (35) init (0); /* unused */
      515 	dcl     environment_pointer_offset fixed bin;	/* 1 if the argument list contains an environment pointer */
      516 						/* 0 if the arg list doesn't contain the environment pointer */
      517 	dcl     SPECIAL		 fixed bin static internal init (8) options (constant);
      518 	dcl     STRUCTURE_TYPE	 fixed bin static internal init (17) options (constant);
      519 						/* data type for a structure */
      520 	dcl     VAR_BIT		 fixed bin (5) static internal init (20) options (constant);
      521 	dcl     VAR_CHAR		 fixed bin (5) internal static init (22) options (constant);
      522 	dcl     (
      523 	        n_args,				/* number of arguments passed to store */
      524 	        rn_len,				/* length of relation name parameter */
      525 	        val_arg_count,			/* the number of values specified for this tuple */
      526 	        i,
      527 	        first_space				/* index of first space in relation name */
      528 	        /* 0 implies no spaces */
      529 	        )			 fixed bin;	/* index used within the store procedure */
      530 
      531 	dcl     rel_name		 char (rn_len) based (rn_ptr); /* relation name passed by caller */
      532 	dcl     rel_name_32		 char (32);	/* Rel_name 32 characters long used for searching */
      533 	dcl     db_index		 fixed bin (35) based (dbi_ptr); /* database_index passed by caller */
      534 	dcl     code		 fixed bin (35) based (c_ptr); /* code returned to caller */
      535 
      536 	dcl     was_structure	 bit (1) unal;	/* on if user views as a structure */
      537 	dcl     icode		 fixed bin (35);	/* internal error return code */
      538 	dcl     val_args		 (2 * val_arg_count) ptr based (arg_ptr); /* an array of pointers to
      539*						   user supplied values followed by pointers to
      540*						   the descriptors for those values returned by mu_break_structure */
      541 	dcl     arg_val_ptr_array	 (val_arg_count) ptr based (arg_val_ptr_array_ptr);
      542 						/* array of pointers to user supplied argument values */
      543 	dcl     arg_val_ptr_array_ptr	 ptr;
      544 	dcl     arg_desc_ptr_array	 (val_arg_count) ptr based (arg_desc_ptr_array_ptr);
      545 						/* array of pointers to the descriptors of the user supplied argument values */
      546 	dcl     arg_desc_ptr_array_ptr ptr;
      547 
      548 	dcl     unused_tuple_id	 bit (36) aligned;	/* tuple id of the tuple just stored - not used */
      549 	dcl     (rn_ptr, c_ptr, dbi_ptr, data_ptr, descr_ptr, sti_ptr,
      550 	        arg_ptr)		 ptr;
      551 
      552 	dcl     (null, addr, addrel, string, divide, fixed) builtin;
      553 	dcl     (index, rel)	 builtin;
      554 
      555 	dcl     1 store_info	 aligned based (sti_ptr), /* static store information */
      556 		2 ri_ptr		 ptr,
      557 		2 ml_ptr		 ptr,
      558 		2 num_atts	 fixed bin,
      559 		2 nvar_atts	 fixed bin,
      560 		2 cursor_ptr	 ptr,
      561 		2 temp_rel	 bit (1);		/* On = storeing in to a temp rel */
      562 
      563 
  5     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  5     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  5     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  5     9*     Nguyen. The scopes_changed flag was added to make checking for this
  5    10*     more efficient (mrds error list #137).
  5    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  5    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  5    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  5    14*     care if multiple txns use the same selection_expression. (mrds #156)
  5    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  5    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  5    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  5    18*                                                   END HISTORY COMMENTS */
  5    19 
  5    20 
  5    21 /* WARNING
  5    22*          If the dbcb structure is changed then the mrds_data_
  5    23*          item saved_res_version MUST be incremented to invalidate all
  5    24*          existing saved resultants
  5    25**/
  5    26 
  5    27 /* HISTORY :
  5    28*
  5    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  5    30*   tid_list management
  5    31*
  5    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  5    33*   phony resultant in mu_database_index, without having the area dcl
  5    34*   included.
  5    35*
  5    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  5    37*   mrds_dsl_store
  5    38*
  5    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  5    40*   switches
  5    41*
  5    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  5    43*   expression,  so  that relation statistics can be updated relative
  5    44*   to number of selection expressions seem. Also  removed  init  for
  5    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  5    46*   mrds_dsl_init_res.
  5    47*
  5    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  5    49*
  5    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  5    51*   for the conversion to the relation manager.
  5    52*
  5    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  5    54*   substructures so that the entries and costs can change
  5    55*   depending on the type of database that is opened.
  5    56*
  5    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  5    58*   since modify uses a different vector type (general) than does store.
  5    59*
  5    60*   82-09-20 Davids: changed names of (store modify)_vector to
  5    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  5    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  5    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  5    64*   during the first call.
  5    65*
  5    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  5    67*   since it deals with the pointers to the cursors and not the cursors
  5    68*   themelves and added the element cursor_storage_area_ptr which points
  5    69*   to the area where the cursors are kept.
  5    70*
  5    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  5    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  5    73*   anything.
  5    74*
  5    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  5    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  5    77*   by mrds_dsl_define_temp_rel.
  5    78*
  5    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  5    80*   is needed by mu_store.
  5    81*
  5    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  5    83*   bin to float bin since the values are not integers.
  5    84*
  5    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  5    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  5    87*   added to the end of the structure to allow modules that don't use
  5    88*   the element to continue to reference the dbcb structure without recompiling.
  5    89*
  5    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  5    91*   are needed so that temp rels can be created with the same file attributes
  5    92*   as the permanent relations.
  5    93*
  5    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  5    95*   added the resultant_in_pdir bit.
  5    96*
  5    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  5    98*   added the res_already_made element.
  5    99*
  5   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  5   101*
  5   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  5   103*   one of the unused pointers.
  5   104*
  5   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  5   106*
  5   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  5   108*   leaving unused_ptrs(1).
  5   109*
  5   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  5   111*   unused_ptrs (1).
  5   112*
  5   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  5   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  5   115*   spare ptrs, entries and reserved storages for future enhancement, since
  5   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  5   117*
  5   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  5   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  5   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  5   121**/
  5   122 
  5   123 
  5   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  5   125*   that constitutes the non-secure portion of the resultant model that is
  5   126*   created during the opening of a database. it contains variables that
  5   127*   are used during the runtime access of the database, and an area
  5   128*   for evaluation of requests. it points to four other
  5   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  5   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  5   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  5   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  5   133*   used in the elimination of duplicate tuples during a retrieve.
  5   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  5   135*   that is used when the database is using the file scope mechanism
  5   136*   for concurrency control over file readying. the segment overlayed via
  5   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  5   138*   across database openings. the pointer to this dbcb structure is kept in a table
  5   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  5   140*   opening instances of resultant models. (see mu_database_index routine) */
  5   141 
  5   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  5   143 	     2 data	      like dbcb_data,
  5   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  5   145 
  5   146      dcl	   dbcb_ptr	      ptr;
  5   147 
  5   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  5   149*						   like references can avoid getting the area declaration */
  5   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  5   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  5   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  5   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  5   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  5   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  5   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  5   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  5   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  5   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  5   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  5   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  5   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  5   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  5   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  5   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  5   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  5   167*						   for eliminating duplicate tuples. */
  5   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  5   169*						   for eliminating duplicate tuples. */
  5   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  5   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  5   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  5   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  5   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  5   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  5   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  5   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  5   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  5   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  5   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  5   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  5   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  5   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  5   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  5   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  5   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  5   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  5   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  5   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  5   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  5   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  5   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  5   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  5   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  5   195 	     2 val_del	      bit (1) unal,		/* for delete */
  5   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  5   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  5   198*                                                                     not imply that the database is of type page_file */
  5   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  5   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  5   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  5   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  5   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  5   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  5   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  5   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  5   207*						   inside a sequence of -another selection expression. */
  5   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  5   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  5   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  5   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  5   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  5   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  5   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  5   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  5   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  5   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  5   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  5   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  5   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  5   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  5   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  5   223 	     2 relmgr_entries,			/* relation manager entries */
  5   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  5   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  5   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  5   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  5   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  5   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  5   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  5   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  5   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  5   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  5   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  5   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  5   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  5   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  5   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  5   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  5   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  5   241 	       3 reserved_entries (5) entry (),
  5   242 	     2 access_costs,			/* access costs for permute */
  5   243 	       3 total_primary_key_cost float bin,
  5   244 	       3 access_cost      float bin,
  5   245 	       3 access_overhead  float bin,
  5   246 	       3 us_access_cost   float bin,
  5   247 	       3 os_access_cost   float bin,
  5   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  5   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  5   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  5   251 
  5   252 /* END mrds_dbcb.incl.pl1 */
  5   253 
  5   254 
      564 
      565 
  6     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  6     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  6     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  6     9*                                                   END HISTORY COMMENTS */
  6    10 
  6    11 
  6    12 /* WARNING
  6    13*          If the rm_db_info structure is changed then the mrds_data_
  6    14*          item saved_res_version MUST be incremented to invalidate all
  6    15*          existing saved resultants
  6    16**/
  6    17 
  6    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  6    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  6    20*   resultant model that is created partially at database open  time,
  6    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  6    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  6    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  6    24*   to  provide  an  efficient  means  of  accessing  database  model
  6    25*   information, as seen from the possibly submodel view of the user,
  6    26*   and his current state of "files readied". it is the  secure  part
  6    27*   because  it  contains  the  model  information  which needs to be
  6    28*   protected  from  general  knowledge,  and   this   segment   will
  6    29*   eventually  be  capable  of  being in a lower ring. the structure
  6    30*   itself points to four arrays that are  allocated  in  it's  area,
  6    31*   that  in  turn point to the other structures mentions above, also
  6    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  6    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  6    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  6    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  6    36*   list of all known file names, the rm_rel_array only gets relation
  6    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  6    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  6    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  6    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  6    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  6    42*   file infos point to contained rel infos, the rel infos  point  to
  6    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  6    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  6    45*   foreign     keys    are    represented    by    the    structures
  6    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  6    47*   pathnames  of the model and submodel, if any, are also maintained
  6    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  6    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  6    50*   individual include files for  further  organization  information,
  6    51*   and particular data structures.
  6    52*
  6    53*   HISTORY:
  6    54*
  6    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  6    56*   so that define_area_ could be used to make it an extensible area
  6    57*
  6    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  6    59*   resultant in mu_database_index easier to keep, since no reference
  6    60*   to the area is needed.
  6    61*
  6    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  6    63*   resultant.
  6    64*
  6    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  6    66*   structure.
  6    67*
  6    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  6    69*   are  now  combined  into  the rel_array. Removed the control file
  6    70*   info which was unused. Added pointer  to  head  of  domain  list,
  6    71*   which is to be used to insure only one copy of each domain info.
  6    72*
  6    73*   83-05-19 Davids: Added the  saved_res_version element.
  6    74*
  6    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  6    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  6    77*   check, encode, or decode proc.
  6    78*
  6    79*   CAUTION: The structure entries from db_version to sm_path  should
  6    80*   not  be moved or have their declarations changed because they are
  6    81*   used in the handling of old version database openings.
  6    82*
  6    83*
  6    84**/
  6    85 
  6    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  6    87 	     2 data	      like rm_db_info_data,
  6    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  6    89 
  6    90      dcl	   rdbi_ptr	      ptr;
  6    91 
  6    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  6    93*						   like reference to it without getting the area as well */
  6    94 	     2 db_version	      fixed bin,		/* version no. of db */
  6    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  6    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  6    97 	     2 db_path	      char (168),		/* abs. path of db. */
  6    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  6    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  6   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  6   101 	     2 pad	      bit (34) unal,	/* for future use */
  6   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  6   103*                                                               dbcb and rdbi segments in the db dir */
  6   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  6   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  6   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  6   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  6   108 
  6   109 /* END mdbm_rm_db_info.incl.pl1 */
  6   110 
  6   111 
      566 
      567 
  7     1 /* BEGIN mdbm_rm_rel_array.incl.pl1 -- jaw, 8/9/78 */
  7     2 
  7     3 /* WARNING
  7     4*          If the rm_rel_array structure is changed then the mrds_data_
  7     5*          item saved_res_version MUST be incremented to invalidate all
  7     6*          existing saved resultants
  7     7**/
  7     8 
  7     9 /* HISTORY:
  7    10*
  7    11*   81-05-28 Jim Gray : added  model_name  and  file_id  as  part  of
  7    12*   combining   funtions   of   file_array  and  rel_array  into  one
  7    13*   structure. This will only allow 1 relation per file model now.
  7    14*   Also changed structure to allow more efficient searching
  7    15*   via and index builtin, rather than a programmed loop.
  7    16*   Search is now I = index(string(rm_rel_array.name), "!" || in_name)
  7    17*   with I = ((I - 1) / 33) + 1 to convert from a char to array index.
  7    18*
  7    19**/
  7    20 
  7    21 
  7    22 /* this structure is allocated in the static are of the structure
  7    23*   in  mdbm_rm_db_info.incl.pl1,  the secure portion of the database
  7    24*   resultant  model  upon  opening  the  database.  two  copies  are
  7    25*   allocated,  one for temporary relations, initially empty, and one
  7    26*   for relations known to the opener, which has a length  sufficient
  7    27*   for  all  relations known to the user, but whose names, etc. will
  7    28*   not be filled  in  until  the  file  containing  that  particular
  7    29*   relation  is readied. the rm_db_info structure contains a pointer
  7    30*   to the rel_arrays, and the array entries, when  "readied",  point
  7    31*   to  the  mdbm_rm_rel_info.incl.pl1  structures  containing  model
  7    32*   information about the relation, it's attributes, etc. */
  7    33 
  7    34 dcl 1 rm_rel_array aligned based (rmra_ptr),		/* array of open relations */
  7    35     2 num_rels fixed bin,				/* no. rels in db. */
  7    36     2 name (1:rm_num_rels_init refer (rm_rel_array.num_rels)) unal,
  7    37       3 mark char (1) unal,				/* separator character = "!" */
  7    38       3 submodel char (32) unal,			/* name of relation is submodel view, model opening => model name */
  7    39     2 rel_data (rm_num_rels_init refer (rm_rel_array.num_rels)),
  7    40       3 model_name char (30),				/* name of relation in model */
  7    41       3 ri_ptr ptr unal ;				/* pointer to rm_rel_info */
  7    42 
  7    43 dcl  rmra_ptr ptr;
  7    44 dcl  rm_num_rels_init fixed bin;
  7    45 
  7    46 /* END mdbm_rm_rel_array.incl.pl1 */
  7    47 
  7    48 
      568 
      569 
  8     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  8     2 
  8     3 /* WARNING
  8     4*          If the rm_rel_info structure is changed then the mrds_data_
  8     5*          item saved_res_version MUST be incremented to invalidate all
  8     6*          existing saved resultants
  8     7**/
  8     8 
  8     9 /* HISTORY:
  8    10*
  8    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  8    12*   attributes,   and   varying  attributes,  so  that  partial  view
  8    13*   submodels will have the  info  needed  to  properly  set  up  the
  8    14*   varying length array headers in the tuple structure.
  8    15*
  8    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  8    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  8    18*   delete_tuple_perm, and make m_perm = unused_perm.
  8    19*
  8    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  8    21*   view attribute was varying character or bit, since a partial view
  8    22*   submodel will not have this information in the resultant, and  it
  8    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  8    24*   since with exact length storage  of  varying  length  attributes,
  8    25*   each  tuple  can  be  a  different  length,  which is can only be
  8    26*   determined by examining the tuple itself.
  8    27*
  8    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  8    29*   interface  to  allow  temp  rel  population  to  be known, and to
  8    30*   provide a more efficient means of finding an approx. current perm
  8    31*   relation population.
  8    32*
  8    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  8    34*   blocked  files, foreign keys, and ids procedures. Also set number
  8    35*   of files per rel to a constant of 1.
  8    36*
  8    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  8    38*   structure so that only one structure per relation is needed.
  8    39*
  8    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  8    41*   counts.   Also  added  number  of  operations  count  since  last
  8    42*   statistics update, and a time  since  the  statistics  were  last
  8    43*   updated.
  8    44*
  8    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  8    46*   identifier so that small relations could be updated on a per S.E.
  8    47*   basis
  8    48*
  8    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  8    50*   to end of structure   TR 12205 (Suggestion).
  8    51*   
  8    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  8    53*   the DMS conversion. 
  8    54*
  8    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  8    56*   array and the niocb element for DMS conversion. Also removed the
  8    57*   number_selected array (and ri_niocbs_init) since subsets are not
  8    58*   going to be used.
  8    59*
  8    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  8    61*   so that it can be used with relation manager.  Also added
  8    62*   rm_rel_info.primary_key_index_id for relation manager.
  8    63*
  8    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  8    65*   nvar_atts, model_nvar_atts.
  8    66*
  8    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  8    68*   since the duplicate key count for each secondary index is now being
  8    69*   kept in the attr_info structure and key_count was only needed to
  8    70*   help in calculating the average selectivity of each index which
  8    71*   can now be gotten directly from each index's dup key count. Also
  8    72*   removed the file_id element since it is no longer needed for
  8    73*   anything.
  8    74*
  8    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  8    76*   was removed.
  8    77*
  8    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  8    79*   used when retrieving tuples from this relation.
  8    80*
  8    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  8    82*   for the relation. Note that this structure is part of the resultant NOT
  8    83*   part of the db.control structure. The scopes are duplicated in the resultant
  8    84*   to reduce contention for the db.control structure. Note also that the pointer
  8    85*   will always point to a scope_flags structure even if no scopes have been
  8    86*   set on the relation, the structure is allocated when the db is opened.
  8    87**/
  8    88 
  8    89 
  8    90 /* DESCRIPTION:
  8    91*
  8    92*   This structure is allocated in the area part of the structure  in
  8    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  8    94*   at open  time  for  a  database.  There  will  be  one  of  these
  8    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  8    96*   database view (there may be less than the total in  the  database
  8    97*   for  a  submodel  openings).  There  will  also  be  one for each
  8    98*   temporary relation currently defined for that opening.
  8    99*
  8   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  8   101*   all  rm_rel_info  structures  allocated. It is used for searching
  8   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  8   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  8   104*   rels.
  8   105*
  8   106*   The      rm_rel_info      structure      points      to       the
  8   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  8   108*   appearing in this view of the relation. Each  of  these  in  turn
  8   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  8   110*   info for each attr.
  8   111*
  8   112*   Most of the other information here deals with  specifics  of  the
  8   113*   relation's  logical  definition,  such as key and secondary index
  8   114*   attribute inidicators, security permissions, and  tuple  physical
  8   115*   construction details.
  8   116*
  8   117**/
  8   118 
  8   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  8   120 	     2 name	      char (32),		/* from submodel */
  8   121 	     2 model_name	      char (30),		/* from model */
  8   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  8   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  8   124 	     2 modify	      bit (1) unal,
  8   125 	     2 delete	      bit (1) unal,
  8   126 	     2 store	      bit (1) unal,
  8   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  8   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  8   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  8   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  8   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  8   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  8   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  8   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  8   135 	     2 reserved	      bit (24) unal,	/* for future use */
  8   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  8   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  8   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  8   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  8   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  8   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  8   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  8   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  8   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  8   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  8   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  8   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  8   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  8   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  8   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  8   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  8   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  8   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  8   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  8   155 
  8   156      dcl	   rmri_ptr	      ptr;
  8   157      dcl	   (nkey_attr_init,
  8   158 	   natts_init,
  8   159 	   nvar_atts_init)	      fixed bin;
  8   160 
  8   161 /* END mdbm_rm_rel_info.incl.pl1 */
  8   162 
  8   163 
      570 
      571 
  9     1 /* BEGIN mdbm_move_list.incl.pl1 -- jaw, 7/13/78 */
  9     2 
  9     3 /* HISTORY:
  9     4*
  9     5*   81-06-01 Jim Gray : removed assn type and len elements,
  9     6*   now that mu_convert is used.
  9     7*
  9     8**/
  9     9 
  9    10 
  9    11 dcl 1 move_list aligned based (ml_ptr),			/* info for moving data in and out of tuple */
  9    12     2 nitems fixed bin,				/* number of items */
  9    13     2 item (ml_nitems_init refer (move_list.nitems)),
  9    14       3 attr_index fixed bin,				/* index to attr info in rel_info */
  9    15       3 user_ptr ptr,				/* pointer to user data value */
  9    16       3 user_desc_ptr ptr;				/* pointer to descriptor for user */
  9    17 
  9    18 dcl  ml_ptr ptr;
  9    19 dcl  ml_nitems_init fixed bin;
  9    20 
  9    21 /* END mdbm_move_list.incl.pl1 */
  9    22 
      572 
      573 
 10     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
 10     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
 10     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
 10     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
 10     5 
 10     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
 10     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
 10     8     2 type unsigned fixed bin (6) unal,			/* data type */
 10     9     2 packed bit (1) unal,				/* on if data item is packed */
 10    10     2 number_dims bit (4) unal,			/* dimensions */
 10    11     2 size,					/* size for string data */
 10    12       3 scale bit (12) unal,				/* scale for num. data */
 10    13       3 precision bit (12) unal,			/* prec. for num. data */
 10    14     2 array_info (num_dims),
 10    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
 10    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
 10    17       3 multiplier fixed bin (35);			/*  element separation */
 10    18 
 10    19 dcl  desc_ptr ptr;
 10    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
 10    21 
 10    22 /* END mdbm_descriptor.incl.pl1 */
 10    23 
 10    24 
      574 
      575 
 11     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
 11     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
 11     3 
 11     4 /* layout of argument list for IDS and DBM entries with options (variable) */
 11     5 
 11     6 dcl 1 arg_list based (al_ptr),
 11     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
 11     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
 11     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
 11    10     2 pad fixed bin (17) unal,			/* must be 0 */
 11    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
 11    12 
 11    13 dcl  al_ptr ptr;
 11    14 dcl  num_ptrs fixed bin;
 11    15 
 11    16 /* END mdbm_arg_list.incl.pl1  */
 11    17 
      576 
      577 
 12     1 /* BEGIN mdbm_scope_info.incl.pl1 -- odf 8/8/78 */
 12     2 
 12     3 /* WARNING
 12     4*          If the scope_info or scope_flags structure is changed then the
 12     5*          mrds_data_ item saved_res_version MUST be incremented to invalidate
 12     6*          all existing saved resultants
 12     7**/
 12     8 
 12     9 /* Modified by Jim Gray - - 80-11-17, to add back store/delete/modify permissions */
 12    10 
 12    11 /* 80-12-10 Jim Gray : change name of store to append_tuple, delete to delete_tuple,
 12    12*   modify to modify_attr, retrieve to read_attr, remvoe update, put level 4
 12    13*   qualifiers for permit/prevent modes and to put pads in standard format */
 12    14 
 12    15 /* 80-12-11 Jim Gray : added submodel version of file/rel name for convenience */
 12    16 
 12    17 /* 80-12-22 Jim Gray : added like referenced structure so linus_scope_data.incl
 12    18*   could make use of it for compatibility. */
 12    19 
 12    20 /* 81-1-11 Jim Gray : added touched bit to scope_flags, so that
 12    21*   the fact that null scope has been set can be displayed */
 12    22 
 12    23 /* 85-04-14 Thanh Nguyen: Made scope_flags to be aligned so we could access the
 12    24*   prevent flags from any pointer which directly pointed to scope_flags itself
 12    25*   (i.e rm_rel_info.scope_flags_ptr). */
 12    26 
 12    27 /* this structure is to be allocated in the mrds_dbcb.incl.pl1 static area,
 12    28*   and is used to maintain the scope mechanism for file access.
 12    29*   It contains the scope permit/prevent operations that this user
 12    30*   has set in his view for this opening instance. */
 12    31 
 12    32 dcl 1 scope_info aligned based (scope_ptr),		/* array of scope tuples for this user */
 12    33     2 mbz1 bit (144),				/* Reserved for future use */
 12    34     2 nfiles fixed bin,				/* Number of scope tuples in user's scope */
 12    35     2 active_scopes fixed bin,			/* number of scopes currently active for a given user */
 12    36     2 scope (max_file_init refer (scope_info.nfiles)),	/* defines user's scope of access to files */
 12    37       3 name char (30) aligned,			/* filename */
 12    38       3 sm_name char (32),				/* name of file(rel) in submodel */
 12    39       3 flags like scope_flags ;
 12    40 
 12    41 
 12    42 declare 1 scope_flags aligned based,			/* common layout of scope flag bits */
 12    43         2 permits,					/* modes to permit this user */
 12    44 	3 read_attr bit (1) unal,			/* read_attr access to this file in scope */
 12    45 	3 append_tuple bit (1) unal,			/* append_tuple concnrrency permission */
 12    46 	3 delete_tuple bit (1) unal,			/* delete_tuple concurrency permission on rel */
 12    47 	3 modify_attr bit (1) unal,			/* modify_attr concurrency permission */
 12    48 	3 mbz2 bit (10) unal,			/* for expansion of permit ops */
 12    49         2 prevents,					/* modes to be denyed to other users */
 12    50 	3 read_attr bit (1) unal,			/* on if user has prevent on read_attr for this file */
 12    51 	3 append_tuple bit (1) unal,			/* prevent of append_tuple concurrency */
 12    52 	3 delete_tuple bit (1) unal,			/* prevent of delete_tuple concurrency */
 12    53 	3 modify_attr bit (1) unal,			/* prevent of modify_attr concurrency */
 12    54 	3 mbz3 bit (10) unal,			/* for future prevent concurrency modes */
 12    55         2 touched bit (1) unal,			/* on => scope set for this relation */
 12    56         2 mbz4 bit (7) unal ;				/* for future flags */
 12    57 
 12    58 dcl  max_file_init fixed bin;				/* nbr. of files in data base */
 12    59 dcl  scope_ptr ptr init (null ());			/* points to scope_info array */
 12    60 dcl  scope_rdy bit (6) unal init ("000011"b) int static options (constant); /* scope file ready modes (5 or 6) */
 12    61 dcl  scope_rdy_array (6) bit (1) unal based;		/* array format of scope_rdy string */
 12    62 
 12    63 /* END mdbm_scope_info.incl.pl1 */
      578 
      579 
      580 /* dbm subroutines */
      581 
      582 	dcl     mu_break_structure	 entry (ptr, ptr, ptr, ptr, fixed bin, fixed bin (35));
      583 	dcl     mu_database_index$get_resultant_model_pointer entry (fixed bin (35), ptr);
      584 	dcl     mu_build_tuple	 entry (ptr, ptr, ptr, ptr, bit (1) aligned, fixed bin (35));
      585 	dcl     mu_cursor_manager_$get entry (fixed bin (35), ptr, fixed bin (35), bit (36) aligned, entry, entry, ptr,
      586 				 ptr, ptr, fixed bin (35));
      587 
      588 	dcl     error_table_$wrong_no_of_args fixed bin (35) ext;
      589 
      590 	dcl     mrds_data_$max_temp_rels fixed bin (35) ext;
      591 
      592 	dcl     dm_error_$key_duplication fixed bin (35) ext static;
      593 
      594 	dcl     mrds_error_$dup_store	 fixed bin (35) external static;
      595 	dcl     mrds_error_$invalid_db_index fixed bin (35) ext;
      596 	dcl     mrds_error_$invalid_dm_descriptor fixed bin (35) ext;
      597 	dcl     mrds_error_$no_prev_store fixed bin (35) ext;
      598 	dcl     mrds_error_$rel_name_too_long fixed bin (35) ext;
      599 	dcl     mrds_error_$scope_viol fixed bin (35) ext;
      600 	dcl     mrds_error_$undefined_temp_rel_index fixed bin (35) ext;
      601 	dcl     mrds_error_$unknown_relation_name fixed bin (35) ext;
      602 
      603 	dcl     mrds_error_$view_prevent fixed bin (35) external static;
      604 	dcl     mrds_error_$inc_rel_acc fixed bin (35) external static;
      605 
      606 	dcl     sys_info$max_seg_size	 fixed bin (35) ext;
      607 
      608 /*    Multics subroutines */
      609 
      610 	dcl     cu_$arg_list_ptr	 entry (ptr);
      611 	dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
      612 
      613 	dcl     arg_err		 condition;
      614 	dcl     cleanup		 condition;
      615 	dcl     any_other		 condition;
      616 	dcl     mrds_data_$statistics_update_count_interval fixed bin (35) ext;
      617 	dcl     dbi_pic		 picture "999";
      618 
      619      end mrds_dsl_store;
      620 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1314.2  mrds_dsl_store.pl1                >special_ldd>install>MR12.2-1073>mrds_dsl_store.pl1
274          1    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
429          4    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
564          5    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
566          6    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
568          7    10/14/83  1609.1  mdbm_rm_rel_array.incl.pl1        >ldd>include>mdbm_rm_rel_array.incl.pl1
570          8    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
572          9    10/14/83  1608.9  mdbm_move_list.incl.pl1           >ldd>include>mdbm_move_list.incl.pl1
574         10    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
576         11    10/14/83  1609.0  mdbm_arg_list.incl.pl1            >ldd>include>mdbm_arg_list.incl.pl1
578         12    04/18/85  1628.1  mdbm_scope_info.incl.pl1          >ldd>include>mdbm_scope_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
SPECIAL                                constant        fixed bin(17,0)          initial dcl 517 ref 264
STRUCTURE_TYPE                         constant        fixed bin(17,0)          initial dcl 518 ref 373
TM_NORMAL_MODE                  000012 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
VAR_BIT                                constant        fixed bin(5,0)           initial dcl 520 ref 410
VAR_CHAR                               constant        fixed bin(5,0)           initial dcl 521 ref 410
addr                                                   builtin function         dcl 552 ref 385 386 395 396 1-123 1-123
addrel                                                 builtin function         dcl 552 ref 410
al_ptr                          000250 automatic       pointer                  dcl 11-13 set ref 226* 227 228 232 233 235 263 264
                                                                                  265 372 375 395 396
any_other                       000272 stack reference condition                dcl 615 ref 252
append_tuple              0(01)        based           bit(1)                   level 3 packed packed unaligned dcl 12-42 ref 353
append_tuple_perm        21(08)        based           bit(1)                   level 2 packed packed unaligned dcl 8-119 ref 366
area_ptr                        000144 automatic       pointer                  dcl 505 set ref 261* 378* 417*
arg_count                              based           fixed bin(17,0)          level 2 packed packed unaligned dcl 11-6 ref 227 228
                                                                                  232
arg_des_ptr               2            based           pointer                  array level 2 dcl 11-6 set ref 233 235 263 265 372
                                                                                  375 395 396
arg_desc_ptr_array                     based           pointer                  array dcl 544 ref 405
arg_desc_ptr_array_ptr          000206 automatic       pointer                  dcl 546 set ref 386* 396* 405
arg_err                         000256 stack reference condition                dcl 613 ref 228
arg_list                               based           structure                level 1 unaligned dcl 11-6
arg_ptr                         000226 automatic       pointer                  dcl 549 set ref 223* 378* 385 386
arg_val_ptr_array                      based           pointer                  array dcl 541 ref 409
arg_val_ptr_array_ptr           000204 automatic       pointer                  dcl 543 set ref 385* 395* 409
attr_index                2            based           fixed bin(17,0)          array level 3 dcl 9-11 set ref 346*
c_ptr                           000214 automatic       pointer                  dcl 549 set ref 233* 234 435 498
caller_name                     000147 automatic       char(32)                 initial packed unaligned dcl 512 set ref 355* 512*
cleanup                         000264 stack reference condition                dcl 614 ref 247
code                                   based           fixed bin(35,0)          dcl 534 in procedure "store" set ref 234* 435* 498*
code                      0(18)        based           fixed bin(17,0)          level 2 in structure "arg_list" packed packed
                                                                                  unaligned dcl 11-6 in procedure "store" ref 264
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue                        000146 automatic       char(1)                  initial packed unaligned dcl 511 set ref 355* 511*
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 1-137
create_cursor           156            based           entry variable           level 4 dcl 5-142 set ref 325*
cu_$arg_list_ptr                000114 constant        entry                    external dcl 610 ref 226
cursor_ptr                6            based           pointer                  level 2 dcl 555 set ref 325* 421*
cursor_ptrs_storage_ptr
                        130            based           pointer                  level 3 dcl 5-142 set ref 325*
cursor_storage_area_ptr
                        132            based           pointer                  level 3 dcl 5-142 set ref 325*
cv_dec_check_                   000116 constant        entry                    external dcl 611 ref 305
data                                   based           structure                level 2 in structure "rm_db_info" dcl 6-86
                                                                                  in procedure "store"
data                                   based           structure                level 2 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "store"
data_ptr                        000220 automatic       pointer                  dcl 549 set ref 375* 378*
db_index                               based           fixed bin(35,0)          dcl 533 set ref 239* 255*
dbcb                                   based           structure                level 1 dcl 5-142
dbcb_data                              based           structure                level 1 unaligned dcl 5-148
dbcb_ptr                        000230 automatic       pointer                  dcl 5-146 set ref 223* 239* 240 243 245 254 255 261
                                                                                  279 281 283 285 291 294 295 325 325 325 325 325
                                                                                  343 417 421 421 440 442 445 445 470 472 483 484
                                                                                  486 489 490
dbi                     114            based           fixed bin(35,0)          level 3 dcl 5-142 set ref 254 325*
dbi_pic                         000300 automatic       picture(3)               packed unaligned dcl 617 set ref 254* 255
dbi_ptr                         000216 automatic       pointer                  dcl 549 set ref 235* 239 255
desc_ptr                        000244 automatic       pointer                  dcl 10-19 set ref 265* 266 372* 373 376 405* 406 410
                                                                                  410 414
descr_ptr                       000222 automatic       pointer                  dcl 549 set ref 376* 378*
descriptor                             based           structure                level 1 unaligned dcl 10-6
descriptor_overlay                     based           bit(36)                  packed unaligned dcl 504 set ref 406*
divide                                                 builtin function         dcl 552 ref 232 320
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$key_duplication       000064 external static fixed bin(35,0)          dcl 592 ref 423
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
environment_pointer_offset      000163 automatic       fixed bin(17,0)          dcl 515 set ref 264* 265 372 396
err_code                               parameter       fixed bin(35,0)          dcl 497 ref 495 498
error_table_$wrong_no_of_args   000060 external static fixed bin(35,0)          dcl 588 set ref 401*
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
first_space                     000170 automatic       fixed bin(17,0)          dcl 522 set ref 269* 270 270
fixed                                                  builtin function         dcl 552 ref 264 266
i                               000167 automatic       fixed bin(17,0)          dcl 522 set ref 301* 303 305* 308 308 311 315 320*
                                                                                  320 321 345* 346 346* 404* 405 409 409 410 410
                                                                                  414*
icode                           000202 automatic       fixed bin(35,0)          dcl 537 set ref 222* 255* 259 259* 305* 306 325* 329
                                                                                  329* 378* 382 382* 417* 418 418* 421* 423 424* 427
                                                                                  434 435 435 437*
index                                                  builtin function         dcl 553 ref 269 301
info_ptr                        000160 automatic       pointer                  initial dcl 513 set ref 355* 513*
item                      2            based           structure                array level 2 dcl 9-11
last_statistics_update_count
                         32            based           fixed bin(17,0)          level 2 dcl 8-119 set ref 332 332 332* 332
last_store_rel_name     117            based           char(32)                 level 3 dcl 5-142 set ref 281 291* 440* 472*
mdbm_secured             21(06)        based           bit(1)                   level 2 packed packed unaligned dcl 8-119 ref 364
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 425* 427* 4-62* 4-65 4-68* 4-69
                                                                                  4-78 4-115 4-115* 1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
ml_nitems_init                  000242 automatic       fixed bin(17,0)          dcl 9-19 set ref 342* 343 343
ml_ptr                    2            based           pointer                  level 2 in structure "store_info" dcl 555
                                                                                  in procedure "store" set ref 287 296* 343* 344 485
                                                                                  486 487*
ml_ptr                          000240 automatic       pointer                  dcl 9-18 in procedure "store" set ref 287* 344* 345
                                                                                  346 409 410 410 414 417*
model_num_attr           23            based           fixed bin(17,0)          level 2 dcl 8-119 ref 340
move_list                              based           structure                level 1 dcl 9-11 set ref 343 486
mrds_data_$max_temp_rels        000062 external static fixed bin(35,0)          dcl 590 ref 308
mrds_data_$statistics_update_count_interval
                                000120 external static fixed bin(35,0)          dcl 616 ref 332
mrds_error_$dup_store           000066 external static fixed bin(35,0)          dcl 594 ref 424 435
mrds_error_$inc_rel_acc         000110 external static fixed bin(35,0)          dcl 604 set ref 366*
mrds_error_$invalid_db_index    000070 external static fixed bin(35,0)          dcl 595 set ref 240*
mrds_error_$invalid_dm_descriptor
                                000072 external static fixed bin(35,0)          dcl 596 set ref 406*
mrds_error_$no_prev_store       000074 external static fixed bin(35,0)          dcl 597 set ref 283*
mrds_error_$rel_name_too_long   000076 external static fixed bin(35,0)          dcl 598 set ref 270*
mrds_error_$scope_viol          000100 external static fixed bin(35,0)          dcl 599 set ref 355* 358*
mrds_error_$undefined_temp_rel_index
                                000102 external static fixed bin(35,0)          dcl 600 set ref 308* 311*
mrds_error_$unknown_relation_name
                                000104 external static fixed bin(35,0)          dcl 601 set ref 306*
mrds_error_$view_prevent        000106 external static fixed bin(35,0)          dcl 603 set ref 361*
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 245* 1-86
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 224* 1-84* 1-89* 1-93 1-94* 1-99*
                                                                                  1-100 4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86*
                                                                                  4-96* 4-99* 4-100* 4-109* 4-110* 4-114* 1-107
                                                                                  1-109* 1-110* 1-121
mu_break_structure              000050 constant        entry                    external dcl 582 ref 378
mu_build_tuple                  000054 constant        entry                    external dcl 584 ref 417
mu_cursor_manager_$get          000056 constant        entry                    external dcl 585 ref 325
mu_database_index$get_resultant_model_pointer
                                000052 constant        entry                    external dcl 583 ref 239
mu_define_area$define_temp_dir_area
                                000044 constant        entry                    external dcl 507 ref 255
mu_release_area                 000042 constant        entry                    external dcl 506 ref 445
mu_valid_data_type$valid_scalar_data_type
                                000040 constant        entry                    external dcl 503 ref 406
n_args                          000164 automatic       fixed bin(17,0)          dcl 522 set ref 232* 233 265 372 373 392 396
name                                   based           char(32)                 level 2 in structure "rm_rel_info" dcl 8-119
                                                                                  in procedure "store" set ref 355*
name                      1            based           structure                array level 2 in structure "rm_rel_array" packed
                                                                                  packed unaligned dcl 7-34 in procedure "store" ref
                                                                                  301
nitems                                 based           fixed bin(17,0)          level 2 dcl 9-11 set ref 343* 345 486
nkey_attr                24            based           fixed bin(17,0)          level 2 dcl 8-119 ref 353
null                                                   builtin function         dcl 552 ref 223 240 283 296 311 442 445 513 12-59
                                                                                  1-123 1-123 470 483 485 487 490
num_attr                 22            based           fixed bin(17,0)          level 2 dcl 8-119 ref 342 353 401
num_atts                  4            based           fixed bin(17,0)          level 2 dcl 555 set ref 340*
num_dims                        000246 automatic       fixed bin(17,0)          initial dcl 10-20 set ref 222* 10-20*
num_ptrs                        000252 automatic       fixed bin(17,0)          dcl 11-14 set ref 227*
num_rels                               based           fixed bin(17,0)          level 2 dcl 7-34 ref 301 311 315 321
open                    146            based           entry variable           level 4 dcl 5-142 set ref 325*
permits                                based           structure                level 2 dcl 12-42
put_tuple               216            based           entry variable           level 4 dcl 5-142 ref 421
ra_ptr                  134            based           pointer                  level 3 dcl 6-86 ref 298
rdbi_ptr                               based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "store" ref 243
rdbi_ptr                        000232 automatic       pointer                  dcl 6-90 in procedure "store" set ref 243* 298 304
rel_data                               based           structure                array level 2 dcl 7-34
rel_id                   20            based           bit(36)                  level 2 dcl 8-119 set ref 325*
rel_name                               based           char                     packed unaligned dcl 531 set ref 269 281 281 300
                                                                                  305* 440
rel_name_32                     000171 automatic       char(32)                 packed unaligned dcl 532 set ref 300* 301
relmgr_entries          146            based           structure                level 3 dcl 5-142
return_value                    000162 automatic       fixed bin(35,0)          initial dcl 514 set ref 355* 514*
ri_ptr                                 based           pointer                  array level 3 in structure "rm_rel_array" packed
                                                                                  packed unaligned dcl 7-34 in procedure "store" ref
                                                                                  311 315 321
ri_ptr                                 based           pointer                  level 2 in structure "store_info" dcl 555
                                                                                  in procedure "store" set ref 286 339*
rm_db_info                             based           structure                level 1 dcl 6-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 6-92
rm_rel_array                           based           structure                level 1 dcl 7-34
rm_rel_info                            based           structure                level 1 dcl 8-119
rmra_ptr                        000234 automatic       pointer                  dcl 7-43 set ref 298* 301 304* 311 315 321
rmri_ptr                        000236 automatic       pointer                  dcl 8-156 set ref 286* 315* 321* 325* 325 332 332
                                                                                  332 332 339 340 342 353 355 361 364 366 401 417*
rn_len                          000165 automatic       fixed bin(17,0)          dcl 522 set ref 266* 267 269 281 281 300 305 305 440
rn_ptr                          000212 automatic       pointer                  dcl 549 set ref 263* 269 281 281 300 305 440
scope_flags                            based           structure                level 1 dcl 12-42
scope_flags_ptr                        based           pointer                  level 2 dcl 8-119 ref 353
scope_ptr                       000254 automatic       pointer                  initial dcl 12-59 set ref 12-59*
size                      0(12)        based           structure                level 2 packed packed unaligned dcl 10-6 ref 266
static_area             306            based           area                     level 2 dcl 5-142 ref 294 343 486 489
sti_ptr                         000224 automatic       pointer                  dcl 549 in procedure "store" set ref 285* 286 287
                                                                                  294* 295 296 297 316 322 325 339 340 343 344 351
                                                                                  421 484* 485 486 487 489
sti_ptr                  26            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "store" set ref 283 285 295* 483 484 490*
store                    21(03)        based           bit(1)                   level 2 packed packed unaligned dcl 8-119 ref 361
store_area_ptr           44            based           pointer                  level 3 dcl 5-142 set ref 255* 261 445 445*
store_info                             based           structure                level 1 dcl 555 set ref 294 489
store_vector_ptr         60            based           pointer                  level 3 dcl 5-142 set ref 417* 421*
string                                                 builtin function         dcl 552 ref 266 301
sub_err_                        000046 constant        entry                    external dcl 510 ref 355
sys_info$max_seg_size           000112 external static fixed bin(35,0)          dcl 606 ref 255
temp_rel                 10            based           bit(1)                   level 2 dcl 555 set ref 297* 316* 322* 351
tra_ptr                 136            based           pointer                  level 3 dcl 6-86 ref 304
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 1-89
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed     106(13)        based           bit(1)                   level 3 packed packed unaligned dcl 5-142 ref 245
type                      0(01)        based           fixed bin(6,0)           level 2 packed packed unsigned unaligned dcl 10-6
                                                                                  ref 373 410 410
unused_tuple_id                 000210 automatic       bit(36)                  dcl 548 set ref 421*
user_desc_ptr             6            based           pointer                  array level 3 dcl 9-11 set ref 414*
user_ptr                  4            based           pointer                  array level 3 dcl 9-11 set ref 409* 410* 410
user_started_transaction
                        106(22)        based           bit(1)                   level 3 in structure "dbcb" packed packed unaligned
                                                                                  dcl 5-142 in procedure "store" set ref 279*
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 in procedure "store" set ref 1-92* 1-98*
                                                                                  279 4-60
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*
val_arg_count                   000166 automatic       fixed bin(17,0)          dcl 522 set ref 378* 386 392* 401 404
val_args                               based           pointer                  array dcl 538 set ref 385 386
was_structure                   000201 automatic       bit(1)                   packed unaligned dcl 536 set ref 388* 398* 410

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
max_file_init                          automatic       fixed bin(17,0)          dcl 12-58
natts_init                             automatic       fixed bin(17,0)          dcl 8-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 8-157
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 8-157
rel                                                    builtin function         dcl 553
rm_num_rels_init                       automatic       fixed bin(17,0)          dcl 7-44
scope_info                             based           structure                level 1 dcl 12-32
scope_rdy                              internal static bit(6)                   initial packed unaligned dcl 12-60
scope_rdy_array                        based           bit(1)                   array packed unaligned dcl 12-61

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        002150 constant        entry                    internal dcl 466 ref 249 499
error                           002237 constant        entry                    internal dcl 495 ref 240 259 270 1-140 283 306 308
                                                                                  311 329 358 361 366 382 401 406 418 4-115 437
exit                            001765 constant        label                    dcl 442 ref 500
free_store_info                 002176 constant        entry                    internal dcl 480 ref 293 471
mftxn_check_code                001522 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      001742 constant        label                    dcl 4-115 ref 4-63
mrds_dsl_store                  000146 constant        entry                    external dcl 26
mstxn_any_other                 002041 constant        entry                    internal dcl 1-116 ref 252
mstxn_cleanup                   002007 constant        entry                    internal dcl 1-102 ref 248
mstxn_exit                      000521 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
restore_significant_data        002145 constant        entry                    internal dcl 460 ref 4-77
should_rollback                 002136 constant        entry                    internal dcl 450 ref 4-94
store                           000136 constant        entry                    external dcl 26

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3060        3202    2274        3070
Length      3740    2274       122         521     563           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
store                               330 external procedure  is an external procedure.  
on unit on line 247                  76 on unit               
on unit on line 252                  82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 247.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 252.  
should_rollback                         internal procedure  shares stack frame of external procedure store.  
restore_significant_data                internal procedure  shares stack frame of external procedure store.  
clean_up                             64 internal procedure  is called by several nonquick procedures.  
free_store_info                      64 internal procedure  is called by several nonquick procedures.  
error                                   internal procedure  shares stack frame of external procedure store.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
store                    000100 mstxn_code                  store
                         000101 mstxn_retries               store
                         000102 mstxn_temp_code             store
                         000103 mstxn_transactions_needed   store
                         000104 user_started_transaction    store
                         000105 mstxn_txn_id                store
                         000106 user_transaction_id         store
                         000110 mstxn_condition_info        store
                         000142 mftxn_code                  store
                         000143 mftxn_temp_code             store
                         000144 area_ptr                    store
                         000146 continue                    store
                         000147 caller_name                 store
                         000160 info_ptr                    store
                         000162 return_value                store
                         000163 environment_pointer_offset  store
                         000164 n_args                      store
                         000165 rn_len                      store
                         000166 val_arg_count               store
                         000167 i                           store
                         000170 first_space                 store
                         000171 rel_name_32                 store
                         000201 was_structure               store
                         000202 icode                       store
                         000204 arg_val_ptr_array_ptr       store
                         000206 arg_desc_ptr_array_ptr      store
                         000210 unused_tuple_id             store
                         000212 rn_ptr                      store
                         000214 c_ptr                       store
                         000216 dbi_ptr                     store
                         000220 data_ptr                    store
                         000222 descr_ptr                   store
                         000224 sti_ptr                     store
                         000226 arg_ptr                     store
                         000230 dbcb_ptr                    store
                         000232 rdbi_ptr                    store
                         000234 rmra_ptr                    store
                         000236 rmri_ptr                    store
                         000240 ml_ptr                      store
                         000242 ml_nitems_init              store
                         000244 desc_ptr                    store
                         000246 num_dims                    store
                         000250 al_ptr                      store
                         000252 num_ptrs                    store
                         000254 scope_ptr                   store
                         000300 dbi_pic                     store

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ent_var        call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           signal_op           enable_op           ext_entry           int_entry
set_chars_eis       index_chars_eis     op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           cu_$arg_list_ptr              cv_dec_check_                 find_condition_info_
mu_break_structure            mu_build_tuple                mu_cursor_manager_$get
mu_database_index$get_resultant_model_pointer               mu_define_area$define_temp_dir_area
mu_release_area               mu_valid_data_type$valid_scalar_data_type                   sub_err_
transaction_manager_$abandon_txn                            transaction_manager_$abort_txn
transaction_manager_$begin_txn                              transaction_manager_$commit_txn
transaction_manager_$get_current_txn_id                     transaction_manager_$handle_conditions
transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$key_duplication     dm_error_$lock_deadlock
dm_error_$no_current_transaction                            error_table_$wrong_no_of_args mrds_data_$max_temp_rels
mrds_data_$statistics_update_count_interval                 mrds_error_$dup_store         mrds_error_$inc_rel_acc
mrds_error_$invalid_db_index  mrds_error_$invalid_dm_descriptor                           mrds_error_$no_prev_store
mrds_error_$rel_name_too_long mrds_error_$scope_viol        mrds_error_$undefined_temp_rel_index
mrds_error_$unknown_relation_name                           mrds_error_$view_prevent      sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    511 000121       512 000123       513 000126       514 000130   10   20 000131   12   59 000132        26 000135
    222 000154       223 000156       224 000161       226 000162       227 000171       228 000174       232 000201
    233 000205       234 000211       235 000212       239 000215       240 000226       243 000241       245 000244
    247 000251       248 000265       249 000266       250 000273       252 000274       254 000312       255 000323
    259 000371       261 000375       263 000400       264 000403       265 000412       266 000421       267 000424
    269 000426       270 000437    1   83 000451    1   84 000452    1   86 000453    1   88 000455    1   89 000456
 1   90 000467    1   92 000473    1   93 000475    1   94 000477    1   95 000500    1   98 000501    1   99 000502
 1  100 000517    1  140 000521       279 000525       281 000533       283 000545       285 000560       286 000563
    287 000565       288 000567       291 000570       293 000573       294 000577       295 000605       296 000607
    297 000611       298 000612       300 000615       301 000622       303 000644       304 000645       305 000650
    306 000675       308 000707       311 000725       315 000752       316 000755       318 000760       320 000761
    321 000765       322 000777       325 001001       329 001036       332 001042       339 001051       340 001052
    342 001055       343 001057       344 001072       345 001073       346 001103       347 001110       351 001112
    353 001115       355 001130       358 001173       361 001202       364 001215       366 001221       372 001233
    373 001241       375 001251       376 001254       378 001255       382 001276       385 001302       386 001304
    388 001310       389 001312       392 001313       395 001316       396 001321       398 001327       401 001330
    404 001343       405 001353       406 001357       409 001402       410 001413       414 001430       415 001432
    417 001434       418 001460       421 001464       423 001502       424 001506       425 001510       426 001511
    427 001512    4   60 001513    4   62 001520    4   63 001521    4   65 001522    4   68 001524    4   69 001535
 4   71 001537    4   72 001550    4   75 001563    4   77 001564    4   78 001565    4   81 001574    4   82 001575
 4   83 001610    4   85 001612    4   86 001623    4   88 001636    4   90 001637    4   91 001640    4   93 001641
 4   94 001642    4   96 001647    4   97 001663    4   99 001665    4  100 001676    4  102 001711    4  104 001712
 4  105 001713    4  107 001714    4  109 001715    4  110 001726    4  114 001741    4  115 001742       434 001746
    435 001750       437 001755       440 001757       442 001765       445 001772       447 002006    1  102 002007
 1  107 002010    1  109 002013    1  110 002024    1  114 002040    1  116 002041    1  121 002042    1  123 002045
 1  124 002064    1  126 002072    1  127 002075    1  129 002100    1  132 002112    1  133 002115    1  135 002120
 1  136 002125    1  137 002126    1  138 002135       450 002136       452 002140       460 002145       462 002146
    466 002147       470 002155       471 002162       472 002167       477 002174       480 002175       483 002203
    484 002211       485 002213       486 002217       487 002224       489 002230       490 002232       493 002236
    495 002237       498 002241       499 002243       500 002247


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
