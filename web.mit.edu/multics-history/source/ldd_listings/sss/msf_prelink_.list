	COMPILATION LISTING OF SEGMENT msf_prelink_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/20/86  1158.9 mst Thu
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
       11*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
       12*     First reference trap procedure for object multisegment files.  This
       13*     procedure completes snapping of all inter-component links in an object
       14*     MSF, and runs any first reference traps in the other MSF components.
       15*                                                   END HISTORY COMMENTS */
       16 
       17 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll79,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       18 
       19 msf_prelink_:
       20   proc (info_linkp);		/** ptr to info link    (in )	*/
       21 
       22   /*** ****************************************************************/
       23   /***							*/
       24   /***	Name:	msf_prelink_				*/
       25   /***	Input:	info_linkp				*/
       26   /***	Function:	given a pointer to an object MSF linkage section	*/
       27   /***		header,  (derived from the unsnapped link passed	*/
       28   /***		to it), initiate each of the MSF components,	*/
       29   /***		combine their linkage sections if necessary, scan	*/
       30   /***		their linkage sections completing the snapping of	*/
       31   /***		any partially snapped links, and running the	*/
       32   /***		first reference traps of all of the other	*/
       33   /***		components (ie. other than the component whos	*/
       34   /***		firstref trap cause the procedure to be invoked	*/
       35   /***		in the first place.)			*/
       36   /***	Output:	none					*/
       37   /***							*/
       38   /*** ****************************************************************/
       39 
       40   /* constants */
       41 
       42   /* parameters */
       43 
       44   dcl info_linkp		ptr parameter;
       45 
       46   /* based */
       47 
       48   dcl 01 comp		(0:n_comp) aligned like component based (ctp);
       49   dcl 01 dh		aligned like definition_header based (dhp);
       50   dcl 01 lh		aligned like linkage_header based (lhp);
       51   dcl 01 mm		aligned like msf_map based (mmp);
       52   dcl system_free_area	area based (system_free_areap);
       53 
       54   dcl 01 component		aligned based,
       55        02 segp		ptr,
       56        02 linkp		ptr,
       57        02 statp		ptr,
       58        02 symbp		ptr;
       59 
       60   /* automatic */
       61 
       62   dcl c			fixed bin;
       63   dcl ctp			ptr;
       64   dcl dhp			ptr;
       65   dcl dir_name		char (168);
       66   dcl ec			fixed bin (35);
       67   dcl entry_name		char (32);
       68   dcl lhp			ptr;
       69   dcl mmp			ptr;
       70   dcl n_comp		fixed bin;
       71   dcl ring		fixed bin;
       72   dcl seg_no		fixed bin;
       73   dcl system_free_areap	ptr;
       74 
       75   /* procedures */
       76 
       77   dcl cu_$make_entry_value	entry (ptr, entry);
       78   dcl get_ring_		entry () returns (fixed bin (3));
       79   dcl get_system_free_area_	entry () returns (ptr);
       80   dcl hcs_$fs_get_path_name	entry (ptr, char (*), fixed bin, char (*),
       81 			fixed bin (35));
       82   dcl hcs_$link_force	entry (ptr, fixed bin, fixed bin (35));
       83   dcl hcs_$combine_linkage	entry (ptr, fixed bin, fixed bin (35));
       84   dcl initiate_file_	entry (char (*), char (*), bit (*), ptr,
       85 			fixed bin (24), fixed bin (35));
       86 
       87   /* conditions */
       88 
       89   dcl cleanup		condition;
       90   dcl object_msf_damaged_	condition;
       91 
       92   /* builtin */
       93 
       94   dcl addwordno		builtin;
       95   dcl char		builtin;
       96   dcl codeptr		builtin;
       97   dcl hbound		builtin;
       98   dcl lbound		builtin;
       99   dcl ltrim		builtin;
      100   dcl min			builtin;
      101   dcl null		builtin;
      102   dcl segno		builtin;
      103   dcl size		builtin;
      104   dcl stackbaseptr		builtin;
      105   dcl unspec		builtin;
      106   dcl wordno		builtin;
      107   
      108   system_free_areap = get_system_free_area_ ();
      109 
      110   /* get address of start of linkage section */
      111 
      112   lhp = addwordno (info_linkp, info_linkp -> object_link.header_relp);
      113 
      114   /* get definition section header */
      115 
      116   dhp = lh.def_ptr;
      117 
      118   if dh.msf_map_relp = 0
      119     then signal object_msf_damaged_;
      120 
      121   /* get msf_map */
      122 
      123   mmp = addwordno (dhp, dh.msf_map_relp);
      124 
      125   /* set up cleanup handler for component table */
      126 
      127   ctp = null;
      128 
      129   on cleanup
      130     begin;
      131     if ctp ^= null
      132       then free comp in (system_free_area);
      133   end;
      134 
      135   n_comp = mm.component_count - 1;
      136   allocate comp in (system_free_area);
      137 
      138   /* get the containing directory name */
      139 
      140   call hcs_$fs_get_path_name (dhp, dir_name, (0), entry_name, ec);
      141 
      142   /* get pointers to the components */
      143 
      144   do c = lbound (comp, 1) to hbound (comp, 1);;
      145     entry_name = ltrim (char (c));
      146     call initiate_file_ (dir_name, entry_name, RE_ACCESS, comp (c).segp,
      147          0, ec);
      148     if ec ^= 0
      149       then signal object_msf_damaged_;
      150   end;
      151 
      152   /* get the linkage, static, and symbol pointers for the components,	*/
      153   /* combining their linkage sections as necessary		*/
      154 
      155   sb = stackbaseptr ();
      156   lotp = stack_header.lot_ptr;
      157   isotp = stack_header.isot_ptr;
      158   ring = get_ring_ ();
      159   
      160   do c = lbound (comp, 1) to hbound (comp, 1);
      161     seg_no = segno (comp (c).segp);
      162     if seg_no > stack_header.cur_lot_size
      163       then signal object_msf_damaged_;
      164     if unspec (lot.lp (seg_no)) = lot_fault
      165       then do;
      166         call hcs_$combine_linkage (comp (c).segp, ring, ec);
      167         if ec ^= 0
      168 	then signal object_msf_damaged_;
      169       end;
      170     comp (c).linkp = lot.lp (seg_no);
      171     comp (c).statp = isot.isp (seg_no);
      172     comp (c).symbp = comp (c).linkp -> linkage_header.symbol_ptr;
      173   end;
      174 
      175   /* now we complete the prelinking in all of the components */
      176 
      177   do c = lbound (comp, 1) to hbound (comp, 1);
      178     call prelink_component (ctp, n_comp, c);
      179   end;
      180 
      181   /* then run the firstref_traps in each of the components, taking	*/
      182   /* care not to invoke msf_prelink_ again.			*/
      183 
      184   do c = lbound (comp, 1) to hbound (comp, 1);
      185     if c ^= mm.my_component		/* this will occur later anyway */
      186       then call execute_firstref_traps (ctp, n_comp, c);
      187   end;
      188 
      189   free comp in (system_free_area);
      190 
      191   return;
      192 
      193 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      194 
      195 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      196 
      197 
      198 prelink_component:
      199   proc (ctp,			/** component table ptr (in )	*/
      200        n_comp,			/** component count	    (in )	*/
      201        c);			/** component index	    (in ) */
      202 
      203   /*** ****************************************************************/
      204   /***							*/
      205   /***	Name:	prelink_component				*/
      206   /***	Input:	component_table, component_index		*/
      207   /***	Function:	completes the prelinking of the links in a single	*/
      208   /***		components linkage section.			*/
      209   /***	Output:	none					*/
      210   /***							*/
      211   /*** ****************************************************************/
      212 
      213   /* parameters */
      214 
      215   dcl ctp			ptr;
      216   dcl n_comp		fixed bin;
      217   dcl c			fixed bin;
      218 
      219   /* based */
      220 
      221   dcl 01 comp		(0:n_comp) aligned like component based (ctp);
      222   dcl 01 its_ptr		aligned like its_unsigned based (linkp);
      223   dcl 01 lh		aligned like linkage_header based (lhp);
      224   dcl 01 lk		aligned like partial_link based (linkp);
      225   dcl 01 vlh		aligned like virgin_linkage_header based (vlhp);
      226 
      227   /* automatic */
      228 
      229   dcl lhp			ptr;
      230   dcl link		fixed bin(18);
      231   dcl linkp		ptr;
      232   dcl lk_end		fixed bin;
      233   dcl t			fixed bin;
      234   dcl type		fixed bin;
      235   dcl vlhp		ptr;
      236 
      237   /* builtin */
      238 
      239   dcl segno		builtin;
      240 
      241   lhp = comp (c).linkp;
      242   vlhp = lh.original_linkage_ptr;
      243 
      244   /* calculate the number of links */
      245 
      246   if vlh.defs_in_link = "20"b3
      247     then lk_end = vlh.def_offset;
      248     else lk_end = vlh.linkage_section_lng;
      249 
      250   if vlh.first_ref_relp ^= 0
      251     then lk_end = min (lk_end, vlh.first_ref_relp);
      252 
      253   /* scan the linkage section for pre-snapped links */
      254 
      255   do link = vlh.link_begin 
      256          to lk_end - size (object_link)
      257          by size (object_link);
      258 
      259     /* get a pointer to the current link */
      260 
      261     linkp = addwordno (lhp, link);
      262 
      263     /* if it has a "47"b3 fault tag 3 rather than a "46"b3 fault tag 2 */
      264 
      265     if its_ptr.its_mod = FAULT_TAG_3
      266       then do;
      267         type = lk.type;
      268         t = lk.component;
      269         its_ptr.pad1 = ""b;
      270 
      271         /* snap text links to the object segment */
      272 
      273         if type = CLASS_TEXT
      274 	then its_ptr.segno = segno (comp (t).segp);
      275 
      276         /* snap linkage links to the copied linkage section */
      277 
      278         else if type = CLASS_LINKAGE
      279 	then do;
      280 	  its_ptr.offset = lk.offset + wordno (comp (t).linkp);
      281 	  its_ptr.segno = segno (comp (t).linkp);
      282 	end;
      283 
      284         /* snap static links to the copied static section */
      285 
      286         else if type = CLASS_STATIC
      287 	then do;
      288 	  its_ptr.offset = lk.offset + wordno (comp (t).statp);
      289 	  its_ptr.segno = segno (comp (t).statp);
      290 	end;
      291 	
      292         /* snap symbol links to the object segment */
      293         
      294         else if type = CLASS_SYMBOL
      295 	then do;
      296 	  its_ptr.offset = lk.offset + wordno (comp (t).symbp);
      297 	  its_ptr.segno = segno (comp (t).symbp);
      298 	end;
      299         else signal object_msf_damaged_;
      300 	  
      301         its_ptr.its_mod = ITS_MODIFIER;
      302         its_ptr.ringno = get_ring_ ();
      303       end;
      304   end;
      305 
      306   end prelink_component;
      307 
      308 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      309 
      310 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      311 
      312 
      313 execute_firstref_traps:
      314   proc (ctp,			/** component table ptr (in ) */
      315        n_comp,			/** component count	    (in )	*/
      316        c);			/** component index	    (in ) */
      317 
      318   /*** ****************************************************************/
      319   /***							*/
      320   /***	Name:	execute_firstref_traps			*/
      321   /***	Input:	component_table, component_index		*/
      322   /***	Function:	executes the firstref traps in a given component	*/
      323   /***		if they have not already run.			*/
      324   /***	Output:	none					*/
      325   /***							*/
      326   /*** ****************************************************************/
      327 
      328   /* parameters */
      329 
      330   dcl ctp			ptr;
      331   dcl n_comp		fixed bin;
      332   dcl c			fixed bin;
      333 
      334   /* based */
      335 
      336   dcl call_ptr		ptr based (call_ptr_ptr);
      337   dcl 01 comp		(0:n_comp) aligned like component based (ctp);
      338   dcl 01 lh		aligned like linkage_header based (lhp);
      339   dcl 01 vlh		aligned like virgin_linkage_header based (vlhp);
      340   dcl 01 frt		aligned like fr_traps based (frtp);
      341 
      342   /* automatic */
      343 
      344   dcl call_ptr_ptr		ptr;
      345   dcl info_ptr_ptr		ptr;
      346   dcl lhp			ptr;
      347   dcl frtp		ptr;
      348   dcl linkp		ptr;
      349   dcl trap		fixed bin;
      350   dcl trap_proc		entry variable options (variable);
      351   dcl vlhp		ptr;
      352 
      353   /* there are no firstref traps or they have already run. */
      354 
      355   if comp (c).linkp -> its.pad4 = ""b
      356     then return;
      357 
      358   /* make sure we don't run them again */
      359 
      360   comp (c).linkp -> its.pad4 = ""b;
      361 
      362   lhp = comp (c).linkp;
      363   vlhp = lh.original_linkage_ptr;
      364 
      365   if vlh.first_ref_relp = 0
      366     then return;
      367 
      368   /* get the firstref block */
      369 
      370   frtp = addwordno (lhp, vlh.first_ref_relp);
      371 
      372   if frt.decl_vers ^= FR_TRAPS_VERSION_1
      373     then signal object_msf_damaged_;
      374 
      375   linkp = comp (c).linkp;
      376 
      377   do trap = 1 to frt.n_traps;
      378     call_ptr_ptr = addwordno (linkp, frt.trap_array (trap).call_relp);
      379     if frt.trap_array (trap).info_relp = 0
      380       then info_ptr_ptr = null;
      381       else info_ptr_ptr = addwordno (linkp, frt.trap_array (trap).info_relp);
      382     call hcs_$link_force (call_ptr_ptr, (0), ec);
      383     if ec ^= 0
      384       then signal object_msf_damaged_;
      385 
      386     /* don't re-run msf_prelink_ */
      387 
      388     if call_ptr ^= codeptr (msf_prelink_)
      389       then do;
      390         call cu_$make_entry_value (call_ptr, trap_proc);
      391         call trap_proc (info_ptr_ptr);
      392       end;
      393   end;
      394 
      395   end execute_firstref_traps;
      396 
      397 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      398 
      399 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      400 
      401 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      402 
  2     1 /* Begin include file definition_dcls.incl.pl1 BIM 1981 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  2     6*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  2     7*     Modified to add indirect bit to definition flags, add msf_map_relp to the
  2     8*     definition header, declare the msf_map, and add structures and constants
  2     9*     for deferred initialization.
  2    10*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420),
  2    11*     audit(86-08-05,Schroth), install(86-11-20,MR12.0-1222):
  2    12*     added the structures for pointer initialization. pointer_init_template.
  2    13*     changed list_template_entry
  2    14*                                                   END HISTORY COMMENTS */
  2    15 
  2    16 
  2    17 /* Modified:  */
  2    18 /*   13 Dec 1982 by Lee A. Newcomb to put definition_header.hash_table_relp */
  2    19 /*	after unused half-word instead of before it. */
  2    20 /*   1 March 1983 by M. Weaver to add list template init type */
  2    21 
  2    22 /* format: style3,idind25 */
  2    23 /* everything for the definition section */
  2    24 
  2    25 declare	(
  2    26 	CLASS_TEXT	     init (0),		/* text section definition */
  2    27 	CLASS_LINKAGE	     init (1),		/* linkage section definition */
  2    28 	CLASS_SYMBOL	     init (2),		/* symbol section definition */
  2    29 	CLASS_SEGNAME	     init (3),		/* segment name definition */
  2    30 	CLASS_STATIC	     init (4),		/* static section definition */
  2    31 	CLASS_SYSTEM	     init (5),		/* valid only in self links, not def class */
  2    32 	CLASS_HEAP	     init (6)		/* valid only in self links, not def class */
  2    33 	)		     fixed bin (3) unsigned internal static options (constant);
  2    34 
  2    35 declare	CLASS_NAMES	     (0:6) character (12) internal static options (constant)
  2    36 			     init ("text", "linkage", "symbol", "segname", "static", "system", "heap");
  2    37 
  2    38 declare	SYMBOLIC_SECTION_NAMES   (0:6) character (8)
  2    39 			     init ("*text", "*link", "*symbol", *, "*static", "*system", "*heap") internal static
  2    40 			     options (constant);
  2    41 
  2    42 declare	1 definition_flags	     unaligned based,
  2    43 	  2 new		     bit (1),		/* should be "1"b */
  2    44 	  2 ignore	     bit (1),		/* cannot snap link to this */
  2    45 	  2 entry		     bit (1),		/* can tra here */
  2    46 	  2 retain	     bit (1),		/* binder respects this */
  2    47 	  2 argcount	     bit (1),		/* OBSOLETE */
  2    48 	  2 descriptors	     bit (1),		/* OBSOLETE */
  2    49 	  2 indirect	     bit (1),		/* target is a pointer to actual target */
  2    50 	  2 unused	     bit (8);		/* Must be zero */
  2    51 
  2    52 
  2    53 
  2    54 
  2    55 /* Header of the definition section */
  2    56 
  2    57 declare	def_header_ptr	     pointer;
  2    58 declare	1 definition_header	     aligned based (def_header_ptr),
  2    59 	  2 def_list_relp	     fixed bin (18) unsigned unaligned,
  2    60 						/* first definition, reloc def18 */
  2    61 	  2 msf_map_relp	     fixed bin (18) unsigned unaligned,
  2    62 						/* msf_map if any, or 0 if none.  reloc def18 unless none */
  2    63 	  2 hash_table_relp	     fixed bin (18) unsigned unaligned,
  2    64 						/* def hash table, if any, or 0 if none. reloc def18 unless none */
  2    65 	  2 flags		     unaligned like definition_flags;
  2    66 						/* both new and ignore must be "1"b here */
  2    67 
  2    68 /* A non class=3 definition. See segname_definition below for class=3 */
  2    69 
  2    70 
  2    71 declare	def_ptr		     pointer;
  2    72 declare	1 definition	     aligned based (def_ptr),
  2    73 	  2 forward_relp	     unal fixed bin (18) unsigned,
  2    74 						/* offset of next def */
  2    75 	  2 backward_relp	     unal fixed bin (18) unsigned,
  2    76 						/* offset of previous def */
  2    77 	  2 thing_relp	     unal fixed bin (18) unsigned,
  2    78 						/* offset in section specified by class of thing this defines */
  2    79 	  2 flags		     unaligned like definition_flags,
  2    80 	  2 class		     unal fixed bin (3) unsigned,
  2    81 						/* Type of definition */
  2    82 	  2 name_relp	     unal fixed bin (18) unsigned,
  2    83 						/* offset of ACC for symbol */
  2    84 	  2 segname_relp	     unal fixed bin (18) unsigned;
  2    85 						/* offset of segname def to which this belongs */
  2    86 
  2    87 /* Class=3, segname definition */
  2    88 
  2    89 declare	segname_ptr	     pointer;
  2    90 declare	1 segname_definition     aligned based (segname_ptr),
  2    91 	  2 forward_relp	     unal fixed bin (18) unsigned,
  2    92 						/* offset of next def */
  2    93 	  2 backward_relp	     unal fixed bin (18) unsigned,
  2    94 						/* offset of previous def */
  2    95 	  2 next_segname_relp    unal fixed bin (18) unsigned,
  2    96 						/* offset of next segname def */
  2    97 	  2 flags		     unaligned like definition_flags,
  2    98 	  2 class		     unal fixed bin (3) unsigned,
  2    99 						/* 3 for segname */
  2   100 	  2 name_relp	     unal fixed bin (18) unsigned,
  2   101 						/* offset of ACC for symbol */
  2   102 	  2 first_relp	     unal fixed bin (18) unsigned;
  2   103 						/* see following : */
  2   104 
  2   105 /* Definition blocks are chained off of segname definitions.
  2   106*   segname_definition.first_relp is one of three things:
  2   107*    (1) the def section offset of the first ordinary (class^=3) definition
  2   108*      belonging to this segname block. In the case where there are more than
  2   109*      one segname's on a block, all their first_relp will point
  2   110*      to the same place.
  2   111*
  2   112*    (2) if there are no ordinary definitions associated with this segname,
  2   113*      then it is the def section offset of the next segname. 
  2   114*
  2   115*    (3) if there are no ordinary definitions in the block, and it
  2   116*      is the last block, then it points to a word containing 0.
  2   117*
  2   118* Thus the end of a list of synonym segnames can be detected by forward_relp
  2   119*   pointing to a class=3 definition whose first_relp is not the same as
  2   120*   the current definitions first_relp.
  2   121**/
  2   122 
  2   123 /* All the definitions are linked through the forward and
  2   124*   backward thread variables. The end of the chain can is indicated
  2   125*   by forward pointing to a zero word. */
  2   126 
  2   127 
  2   128 declare	exp_ptr		     pointer;
  2   129 declare	1 exp_word	     based (exp_ptr) aligned, /* expression word in link definition */
  2   130 	  2 type_relp	     fixed bin (18) unsigned unal,
  2   131 						/* pointer (rel to defs) of type pair structure */
  2   132 	  2 expression	     fixed bin (17) unal;	/* constant expression to be added in when snapping link */
  2   133 
  2   134 declare	(
  2   135 	LINK_SELF_BASE	     init (1),		/* *section|0+expression,modifier */
  2   136 						/* which section determined by segname_relp */
  2   137 	LINK_OBSOLETE_2	     init (2),		/* not used */
  2   138 	LINK_REFNAME_BASE	     init (3),		/* refname|0+expression,modifier */
  2   139 	LINK_REFNAME_OFFSETNAME  init (4),		/* refname|offsetname+expression,modifier */
  2   140 	LINK_SELF_OFFSETNAME     init (5),		/* *section|offsetname+expression,modifier */
  2   141 	LINK_CREATE_IF_NOT_FOUND init (6),		/* OBSOLETE: like LINK_REFNAME_OFFSETNAME except that it will create instead of taking linkage_error */
  2   142 	SECTION_TEXT	     init (0),		/* *text */
  2   143 	SECTION_LINK	     init (1),		/* *link */
  2   144 	SECTION_SYMBOL	     init (2),		/* *symbol */
  2   145 	SECTION_UNUSED	     init (3),		/* reserved */
  2   146 	SECTION_STATIC	     init (4),		/* *static */
  2   147 	SECTION_SYSTEM	     init (5),		/* *system */
  2   148 	SECTION_HEAP	     init (6)		/* *heap */
  2   149 	)		     fixed bin (18) unsigned unaligned internal static options (constant);
  2   150 
  2   151 /* use CLASS_NAMES for section names */
  2   152 
  2   153 declare	LINK_TYPE_NAMES	     (1:6)
  2   154 			     init ("absolute in section", "unused", "absolute off of refname",
  2   155 			     "symbolic off of refname", "symbolic in section", "symbolic off of refname; create")
  2   156 			     character (32) varying internal static options (constant);
  2   157 
  2   158 
  2   159 declare	type_ptr		     pointer;
  2   160 declare	1 type_pair	     based (type_ptr) aligned,/* type pair in link definition */
  2   161 	  2 type		     fixed bin (18) unsigned unal,
  2   162 						/* see above */
  2   163 	  2 trap_relp	     fixed bin (18) unsigned unal,
  2   164 						/* pointer (rel to defs) to the trap word */
  2   165 						/* unless LINK_SELF_OFFSETNAME off of *system or create link */
  2   166 	  2 segname_relp	     fixed bin (18) unsigned unal,
  2   167 						/* pointer (rel to defs) to ACC reference name for segment referenced, 
  2   168* /*or section code for SELF links */
  2   169 	  2 offsetname_relp	     fixed bin (18) unsigned unal;
  2   170 						/* for OFFSETNAME links, ACC string of name of location. */
  2   171 						/* for others, must be ZERO */
  2   172 
  2   173 
  2   174 /* Link Trap Pair */
  2   175 
  2   176 declare	link_trap_ptr	     pointer;
  2   177 declare	1 link_trap_pair	     aligned based (link_trap_ptr),
  2   178 	  2 call_relp	     fixed bin (18) unsigned unaligned,
  2   179 						/* LINK18, link to thing to call */
  2   180 	  2 info_relp	     fixed bin (18) unsigned unaligned;
  2   181 						/* LINK18, link to argument list */
  2   182 
  2   183 
  2   184 /* initialization info for *system or *heap link */
  2   185 
  2   186 
  2   187 /* NOTE --------------------------------------------------
  2   188*   the following structures defining initialization information are also
  2   189*   defined in fortran_storage.incl.pl1  system_link_init_info.incl.pl1
  2   190*   and should be kept equivalent
  2   191*   -------------------------------------------------------
  2   192**/
  2   193 
  2   194 declare	(
  2   195 	INIT_NO_INIT	     init (0),
  2   196 	INIT_COPY_INFO	     init (3),
  2   197 	INIT_DEFINE_AREA	     init (4),
  2   198 	INIT_LIST_TEMPLATE	     init (5),
  2   199 	INIT_DEFERRED	     init (6)
  2   200 	)		     fixed bin internal static options (constant);
  2   201 
  2   202 /* for type = 0 or 4 */
  2   203 
  2   204 declare	link_init_ptr	     pointer;
  2   205 declare	1 link_init	     aligned based (link_init_ptr),
  2   206 	  2 n_words	     fixed bin (35),	/* number to invent */
  2   207 	  2 type		     fixed bin;		/* see types above */
  2   208 
  2   209 /* for type=3, there is data to copy */
  2   210 
  2   211 declare	1 link_init_copy_info    aligned based (link_init_ptr),
  2   212 	  2 header	     aligned like link_init,
  2   213 	  2 initial_data	     (link_init_n_words refer (link_init_copy_info.header.n_words)) bit (36) aligned;
  2   214 
  2   215 declare	link_init_n_words	     fixed bin;
  2   216 
  2   217 /* for type = 5, there is a list template to copy */
  2   218 
  2   219 declare	1 link_init_list_template
  2   220 			     aligned based (link_init_ptr),
  2   221 	  2 header	     aligned like link_init,
  2   222 	  2 pad		     bit (18) unaligned,
  2   223 	  2 n_words_in_list	     fixed bin (18) unsigned unaligned,
  2   224 	  2 template	     (link_init_n_words_in_list refer (link_init_list_template.n_words_in_list));
  2   225 
  2   226 declare	link_init_n_words_in_list
  2   227 			     fixed bin;
  2   228 
  2   229 /* A list template consists of a series of entries with the following
  2   230*   description, concatenated together.  n_bits and datum are bit items,
  2   231*   to permit a wide range of inputs.
  2   232*
  2   233*   1.  A 'repeat' of '0' signifies skipping of 'n_bits' bits.
  2   234*   2.  A 'n_bits' of '0' signifies the last item of the list.
  2   235*
  2   236*   COMMON, VLA's, and LA's are presumed to start at the base pointer
  2   237*   of their particular storage section. */
  2   238 
  2   239 declare	1 list_template_entry    aligned based,
  2   240 	  2 n_bits	     fixed bin (35) aligned,	/* size of datum */
  2   241 	  2 mbz		     bit (3) unaligned,	/* future expansion */
  2   242 	  2 init_type	     fixed bin (3) unsigned unaligned, /* 0 normal init, 1 ptr init, 2 packed ptr init */
  2   243 	  2 repeat	     fixed bin (30) unsigned unaligned,
  2   244 						/* number of times to repeat datum */
  2   245 	  2 datum		     bit (link_init_n_bits_in_datum refer (list_template_entry.n_bits));
  2   246 
  2   247 
  2   248 /* the pointer_init_template represents the initialization information
  2   249*   for ITS and packed pointers.  Both pointer types require the entire
  2   250*   72 bit structure.
  2   251**/
  2   252 
  2   253 dcl       1 pointer_init_template  based,
  2   254 	  2 ptr_type	     fixed bin (18) unsigned unaligned,  /* 0 text section, 1 linkage section, 2 static section */
  2   255 	  2 section_offset	     fixed bin (18) unsigned unaligned,  /* offset to item in specified section */
  2   256 	  2 word_offset	     fixed bin (18) unsigned unaligned,  /* offset from section item to target in words */
  2   257 	  2 mbz		     bit (12) unaligned,
  2   258 	  2 bit_offset	     fixed bin (6) unsigned unaligned;   /* offset from section item|word offset to target in bits */
  2   259 
  2   260 
  2   261 declare	link_init_n_bits_in_datum
  2   262 			     fixed bin (35);
  2   263 
  2   264 /* for type = 6, the init_info resides in another MSF component */
  2   265 /* target_relp is a linkage section offset to a partial link to */
  2   266 /* the base of the linkage section of the component containing  */
  2   267 /* the actual init_info. link_relp is the offset of the actual  */
  2   268 /* link within that linkage section.			    */
  2   269 
  2   270 declare	1 link_init_deferred     aligned based (link_init_ptr),
  2   271 	  2 header	     aligned like link_init,
  2   272 	  2 target_relp	     fixed bin (18) unsigned unaligned,
  2   273 	  2 link_relp	     fixed bin (18) unsigned unaligned;
  2   274 
  2   275 /* Definition section hash table */
  2   276 
  2   277 declare	def_ht_ptr	     pointer;
  2   278 declare	1 definition_ht	     aligned based (def_ht_ptr),
  2   279 	  2 n_entries	     fixed bin,
  2   280 	  2 table		     (def_ht_n_entries refer (definition_ht.n_entries)) aligned,
  2   281 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  2   282 	    3 unused	     bit (18) unaligned;
  2   283 
  2   284 declare	def_ht_n_entries	     fixed bin;
  2   285 
  2   286 
  2   287 /* Component name ht */
  2   288 declare	comp_ht_ptr	     pointer;
  2   289 declare	1 component_ht	     aligned based (comp_ht_ptr),
  2   290 	  2 n_entries	     fixed bin,
  2   291 	  2 table		     (comp_ht_n_entries refer (component_ht.n_entries)) aligned,
  2   292 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  2   293 						/* hashed segname */
  2   294 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  2   295 						/* first segname def of block containing def_relp */
  2   296 
  2   297 declare	comp_ht_n_entries	     fixed bin;
  2   298 
  2   299 /* Duplicate name table */
  2   300 
  2   301 declare	dup_table_ptr	     pointer;
  2   302 declare	1 duplicate_table	     aligned based (dup_table_ptr),
  2   303 	  2 mbz		     bit (18) unaligned,	/* to tell it from a definition */
  2   304 	  2 n_names	     fixed bin (18) unsigned unaligned,
  2   305 						/* n in table */
  2   306 	  2 table		     (dup_table_n_names refer (duplicate_table.n_names)) aligned,
  2   307 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  2   308 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  2   309 
  2   310 declare	dup_table_n_names	     fixed bin;
  2   311 
  2   312 /* The msf_map is found in the definition section of an	*/
  2   313 /* object MSF component.  It is used by the linker to	*/
  2   314 /* determine whether a segment is a component of an object	*/
  2   315 /* MSF or a standard single-segment object.		*/
  2   316   
  2   317   dcl msf_map_ptr		ptr;
  2   318   dcl 01 msf_map		aligned based (msf_map_ptr),
  2   319        02 version		char (8),
  2   320        02 component_count	fixed bin (15) unsigned,
  2   321        02 my_component	fixed bin (15) unsigned;
  2   322   
  2   323   dcl msf_map_version_1	char (8) static options (constant)
  2   324 			     init ("msfmp1.0");
  2   325   
  2   326 declare	acc_string_ptr	     pointer;
  2   327 declare	1 acc_string	     aligned based (acc_string_ptr),
  2   328 	  2 count		     fixed bin (9) unsigned unaligned,
  2   329 	  2 string	     character (max (3, acc_string_length) refer (acc_string.count)) unaligned,
  2   330 	  2 mbz		     bit (0) aligned;	/* this causes the statement */
  2   331 						/* unspec (acc_string) = ""b to zero out */
  2   332 						/* the last word, if the string is not of length 0mod4 */
  2   333 
  2   334 declare	acc_string_length	     fixed bin (21);
  2   335 
  2   336 
  2   337 /* end include file definitions_dcls.incl.pl1 */
      403 
  3     1 /* BEGIN INCLUDE FILE its.incl.pl1
  3     2*   modified 27 July 79 by JRDavis to add its_unsigned
  3     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  3     4 
  3     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  3     6     2 pad1 bit (3) unaligned,
  3     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  3     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  3     9     2 pad2 bit (9) unaligned,
  3    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  3    11 
  3    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  3    13     2 pad3 bit (3) unaligned,
  3    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  3    15     2 pad4 bit (3) unaligned,
  3    16     2 mod bit (6) unaligned;				/* further modification */
  3    17 
  3    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  3    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  3    20     2 pad1 bit (27) unaligned,
  3    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  3    22 
  3    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  3    24     2 pad2 bit (3) unaligned,
  3    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  3    26     2 pad3 bit (3) unaligned,
  3    27     2 mod bit (6) unaligned;				/* further modification */
  3    28 
  3    29 
  3    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  3    31     2 pad1 bit (3) unaligned,
  3    32     2 segno fixed bin (15) unsigned unaligned,
  3    33     2 ringno fixed bin (3) unsigned unaligned,
  3    34     2 pad2 bit (9) unaligned,
  3    35     2 its_mod bit (6) unaligned,
  3    36 
  3    37     2 offset fixed bin (18) unsigned unaligned,
  3    38     2 pad3 bit (3) unaligned,
  3    39     2 bit_offset fixed bin (6) unsigned unaligned,
  3    40     2 pad4 bit (3) unaligned,
  3    41     2 mod bit (6) unaligned;
  3    42 
  3    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  3    44     2 pr_no fixed bin (3) unsigned unaligned,
  3    45     2 pad1 bit (27) unaligned,
  3    46     2 itp_mod bit (6) unaligned,
  3    47 
  3    48     2 offset fixed bin (18) unsigned unaligned,
  3    49     2 pad2 bit (3) unaligned,
  3    50     2 bit_offset fixed bin (6) unsigned unaligned,
  3    51     2 pad3 bit (3) unaligned,
  3    52     2 mod bit (6) unaligned;
  3    53 
  3    54 
  3    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  3    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  3    57 
  3    58 /* END INCLUDE FILE   its.incl.pl1 */
      404 
  4     1 /* BEGIN INCLUDE FILE --  lot.incl.pl1   S.Webber 9/74, Modified by R. Bratt 04/76, modified by M. Weaver 7/76 */
  4     2 /* modified by M. Weaver 3/77 */
  4     3 
  4     4 dcl  lotp ptr;
  4     5 
  4     6 dcl 1 lot based (lotp) aligned,
  4     7     2 lp (0:9999) ptr unaligned;			/* array of packed pointers to linkage sections */
  4     8 
  4     9 dcl lot_fault bit (36) aligned static options (constant) init ("111000000000000000000000000000000000"b);
  4    10 						/* lot fault has fault code = 0 and offset = 0 */
  4    11 
  4    12 dcl  isotp ptr;
  4    13 dcl 1 isot based (isotp) aligned,
  4    14     2 isp (0:9999) ptr unaligned;
  4    15 
  4    16 dcl 1 isot1 (0 :9999) aligned based,
  4    17     2 flags unaligned,
  4    18       3 fault bit (2) unaligned,
  4    19       3 system bit (1) unaligned,
  4    20       3 mbz bit (6) unaligned,
  4    21     2 fault_code fixed bin (8) unaligned,
  4    22     2 static_offset bit (18) unaligned;
  4    23 
  4    24 
  4    25 /* END INCLUDE FILE  lot.incl.pl1 */
      405 
  5     1 /* BEGIN INCLUDE FILE object_link_dcls.incl.pl1 BIM 1981 from linkdcl */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  5     6*     audit(86-11-18,Schroth), install(86-11-20,MR12.0-1222):
  5     7*     Modified to add partial_link structure for an object MSF partially snapped
  5     8*     link.
  5     9*  2) change(86-11-13,DGHowe), approve(86-11-13,MCR7391), audit(86-11-13,Zwick),
  5    10*     install(86-11-20,MR12.0-1222):
  5    11*     Added a declaration of FAULT_TAG_1, FAULT_TAG_2 and FAULT_TAG_3.
  5    12*                                                   END HISTORY COMMENTS */
  5    13 
  5    14 
  5    15 /* format: style3 */
  5    16 /* everything you ever wanted in a linkage section */
  5    17 
  5    18 /*
  5    19* Last Modified (Date and Reason):
  5    20*  15 Nov 1971 by C Garman 
  5    21*   6/75 by M.Weaver to add virgin_linkage_header declaration
  5    22*   6/75 by S.Webber to comment existing structures better
  5    23*   9/77 by M. Weaver to add run_depth to link
  5    24*   7/81 by B. Margulies for firstref structure, unsigned fixed bins.
  5    25*   3/83 by M. Weaver to add flags overlaying def_ptr
  5    26**/
  5    27 
  5    28 declare	1 object_link	based aligned,		/* link pair in linkage section */
  5    29 	  2 header_relp	fixed bin (17) unal,	/* rel pointer to beginning of linkage, always negative */
  5    30 	  2 ringno	fixed bin (3) unsigned unal,	/* MBZ */
  5    31 	  2 mbz		bit (6) unal,
  5    32 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  5    33 	  2 tag		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  5    34 	  2 expression_relp fixed bin (18) unsigned unal, /* pointer (rel to defs) of expression word */
  5    35 	  2 mbz2		bit (12) unal,
  5    36 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  5    37 
  5    38 declare	1 partial_link	based aligned,		/* partially snapped link */
  5    39 	  2 type		fixed bin (3) unsigned unal,	/* target section of link */
  5    40 	  2 component	fixed bin (15) unsigned unal,	/* target component index */
  5    41 	  2 mbz1		bit (12) unal,
  5    42 	  2 tag		bit (6) unal,		/* fault tag 3 47(8), ITS 43(8) if snapped */
  5    43 	  
  5    44 	  2 offset	fixed bin (18) unsigned unal,	/* word offset of link */
  5    45 	  2 mbz2		bit (3) unal,
  5    46 	  2 bit_offset	fixed bin (6) unsigned unal,	/* bit offset (in practice, always 0) */
  5    47 	  2 mbz3		bit (3) unal,
  5    48 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  5    49 
  5    50 declare	1 linkage_header	based aligned,		/* linkage block header */
  5    51 	  2 def_ptr	ptr,			/* pointer to definition section */
  5    52 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  5    53 	  2 original_linkage_ptr
  5    54 			ptr unal,			/* pointer to linkage section in object segment */
  5    55 	  2 unused	bit (72),
  5    56 	  2 stats,
  5    57 	    3 begin_links	fixed bin (18) unsigned unal, /* offset (rel to this section) of first link */
  5    58 	    3 block_length	fixed bin (18) unsigned unal, /* number of words in this linkage section */
  5    59 	    3 segment_number
  5    60 			fixed bin (18) unsigned unal, /* text segment number associated with this section */
  5    61 	    3 static_length fixed bin (18) unsigned unal; /* number of words of static for this segment */
  5    62 
  5    63 declare	1 linkage_header_flags
  5    64 			aligned based,		/* overlay of def_ptr for flags */
  5    65 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  5    66 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  5    67 	  2 perprocess_static
  5    68 			bit (1) unaligned,		/* 1 copy of static section is shared among all tasks/run units */
  5    69 	  2 pad2		bit (6) unaligned;
  5    70 
  5    71 declare	1 virgin_linkage_header
  5    72 			aligned based,		/* template for linkage header in object segment */
  5    73 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  5    74 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  5    75 	  2 def_offset	fixed bin (18) unsigned unaligned,
  5    76 						/* offset of definition section */
  5    77 	  2 first_ref_relp	fixed bin (18) unsigned unaligned,
  5    78 						/* offset of trap-at-first-reference offset array */
  5    79 	  2 filled_in_later bit (144),
  5    80 	  2 link_begin	fixed bin (18) unsigned unaligned,
  5    81 						/* offset of first link */
  5    82 	  2 linkage_section_lng
  5    83 			fixed bin (18) unsigned unaligned,
  5    84 						/* length of linkage section */
  5    85 	  2 segno_pad	fixed bin (18) unsigned unaligned,
  5    86 						/* will be segment number of copied linkage */
  5    87 	  2 static_length	fixed bin (18) unsigned unaligned;
  5    88 						/* length of static section */
  5    89 
  5    90 declare	1 fr_traps	based aligned,		/* First Reference Trap Procedures */
  5    91 	  2 decl_vers	fixed bin,		/* version of this struc, value=1, ABS reloc */
  5    92 	  2 n_traps	fixed bin,		/* number of traps on this segment, ABS */
  5    93 	  2 trap_array	(n_fr_traps refer (fr_traps.n_traps)) aligned,
  5    94 	    3 call_relp	fixed bin (18) unsigned unaligned,
  5    95 						/* LINK18, offset of link defining procedure to call */
  5    96 	    3 info_relp	fixed bin (18) unsigned unaligned;
  5    97 						/* LINK18, offser of link defining argument list for trap proc */
  5    98 
  5    99 declare	FR_TRAPS_VERSION_1	init (1) fixed bin internal static options (constant);
  5   100 declare   FAULT_TAG_1	bit(6) unaligned init ("40"b3) static options (constant);
  5   101 declare   FAULT_TAG_2	bit(6) unaligned init ("46"b3) static options (constant);
  5   102 declare   FAULT_TAG_3	bit(6) unaligned init ("47"b3) static options (constant);
  5   103 
  5   104 /* END INCLUDE FILE object_link_dcls.incl.pl1 */
      406 
  6     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  6     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  6     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  6     4 /*	Modified April 1983 by C. Hornig for tasking */
  6     5 
  6     6 /****^  HISTORY COMMENTS:
  6     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  6     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  6     9*     added the heap_header_ptr definition.
  6    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  6    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  6    12*     Modified to support control point management.  These changes were actually
  6    13*     made in February 1985 by G. Palter.
  6    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  6    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  6    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  6    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  6    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  6    19*     (ITS pair).
  6    20*                                                   END HISTORY COMMENTS */
  6    21 
  6    22 /* format: style2 */
  6    23 
  6    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  6    25 
  6    26      dcl	   1 stack_header	      based (sb) aligned,
  6    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  6    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  6    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  6    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  6    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  6    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  6    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  6    34 	     2 pad4	      bit (2) unal,
  6    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  6    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  6    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  6    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  6    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  6    40 	     2 null_ptr	      ptr,		/*  (16)  */
  6    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  6    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  6    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  6    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  6    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  6    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  6    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  6    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  6    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  6    50 	     2 return_no_pop_op_ptr
  6    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  6    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  6    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  6    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  6    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  6    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  6    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  6    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  6    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  6    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  6    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  6    62 	     2 trace,
  6    63 	       3 frames,
  6    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  6    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  6    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  6    67 	     2 pad2	      bit (36),		/*  (61) */
  6    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  6    69 
  6    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  6    71 
  6    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  6    73 						/* (551) octal */
  6    74 
  6    75 
  6    76 /*	The following constants are offsets within this transfer vector table.  */
  6    77 
  6    78      dcl	   (
  6    79 	   call_offset	      fixed bin init (271),
  6    80 	   push_offset	      fixed bin init (272),
  6    81 	   return_offset	      fixed bin init (273),
  6    82 	   return_no_pop_offset   fixed bin init (274),
  6    83 	   entry_offset	      fixed bin init (275)
  6    84 	   )		      internal static;
  6    85 
  6    86 
  6    87 
  6    88 
  6    89 
  6    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  6    91*	move the whole stack header should use this overlay.
  6    92**/
  6    93 
  6    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  6    95 
  6    96 
  6    97 
  6    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      407 
      408 
      409   end msf_prelink_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/20/86  1144.4  msf_prelink_.pl1                  >special_ldd>install>MR12.0-1222>msf_prelink_.pl1
402          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
403          2    11/20/86  1035.3  definition_dcls.incl.pl1          >special_ldd>install>MR12.0-1222>definition_dcls.incl.pl1
404          3    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
405          4    08/05/77  1022.4  lot.incl.pl1                      >ldd>include>lot.incl.pl1
406          5    11/20/86  1035.4  object_link_dcls.incl.pl1         >special_ldd>install>MR12.0-1222>object_link_dcls.incl.pl1
407          6    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CLASS_LINKAGE                          constant        fixed bin(3,0)           initial unsigned dcl 2-25 ref 278
CLASS_STATIC                           constant        fixed bin(3,0)           initial unsigned dcl 2-25 ref 286
CLASS_SYMBOL                           constant        fixed bin(3,0)           initial unsigned dcl 2-25 ref 294
CLASS_TEXT                             constant        fixed bin(3,0)           initial unsigned dcl 2-25 ref 273
FAULT_TAG_3                            constant        bit(6)                   initial unaligned dcl 5-102 ref 265
FR_TRAPS_VERSION_1                     constant        fixed bin(17,0)          initial dcl 5-99 ref 372
ITS_MODIFIER                           constant        bit(6)                   initial unaligned dcl 3-55 ref 301
RE_ACCESS                       000000 constant        bit(3)                   initial unaligned dcl 1-11 set ref 146*
addwordno                                              builtin function         dcl 94 ref 112 123 261 370 378 381
c                               000100 automatic       fixed bin(17,0)          dcl 62 in procedure "msf_prelink_" set ref 144* 145
                                                                                  146* 160* 161 166 170 171 172 172* 177* 178* 184*
                                                                                  185 185*
c                                      parameter       fixed bin(17,0)          dcl 217 in procedure "prelink_component" ref 198 241
c                                      parameter       fixed bin(17,0)          dcl 332 in procedure "execute_firstref_traps" ref
                                                                                  313 355 360 362 375
call_ptr                               based           pointer                  dcl 336 set ref 388 390*
call_ptr_ptr                    000272 automatic       pointer                  dcl 344 set ref 378* 382* 388 390
call_relp                 2            based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 340 ref
                                                                                  378
char                                                   builtin function         dcl 95 ref 145
cleanup                         000204 stack reference condition                dcl 89 ref 129
codeptr                                                builtin function         dcl 96 ref 388
comp                                   based           structure                array level 1 dcl 337 in procedure
                                                                                  "execute_firstref_traps"
comp                                   based           structure                array level 1 dcl 221 in procedure
                                                                                  "prelink_component"
comp                                   based           structure                array level 1 dcl 48 in procedure "msf_prelink_" set
                                                                                  ref 131 136 144 144 160 160 177 177 184 184 189
component                 0(03)        based           fixed bin(15,0)          level 2 in structure "lk" packed unsigned unaligned
                                                                                  dcl 224 in procedure "prelink_component" ref 268
component                              based           structure                level 1 dcl 54 in procedure "msf_prelink_"
component_count           2            based           fixed bin(15,0)          level 2 unsigned dcl 51 ref 135
ctp                                    parameter       pointer                  dcl 215 in procedure "prelink_component" ref 198 241
                                                                                  273 280 281 288 289 296 297
ctp                             000102 automatic       pointer                  dcl 63 in procedure "msf_prelink_" set ref 127* 131
                                                                                  131 136* 144 144 146 160 160 161 166 170 171 172
                                                                                  172 177 177 178* 184 184 185* 189
ctp                                    parameter       pointer                  dcl 330 in procedure "execute_firstref_traps" ref
                                                                                  313 355 360 362 375
cu_$make_entry_value            000010 constant        entry                    external dcl 77 ref 390
cur_lot_size             13            based           fixed bin(17,0)          level 2 packed unaligned dcl 6-26 ref 162
decl_vers                              based           fixed bin(17,0)          level 2 dcl 340 ref 372
def_offset                1            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 225 ref 246
def_ptr                                based           pointer                  level 2 dcl 50 ref 116
definition_flags                       based           structure                level 1 packed unaligned dcl 2-42
definition_header                      based           structure                level 1 dcl 2-58
defs_in_link              0(30)        based           bit(6)                   level 2 packed unaligned dcl 225 ref 246
dh                                     based           structure                level 1 dcl 49
dhp                             000104 automatic       pointer                  dcl 64 set ref 116* 118 123 123 140*
dir_name                        000106 automatic       char(168)                unaligned dcl 65 set ref 140* 146*
ec                              000160 automatic       fixed bin(35,0)          dcl 66 set ref 140* 146* 148 166* 167 382* 383
entry_name                      000161 automatic       char(32)                 unaligned dcl 67 set ref 140* 145* 146*
first_ref_relp            1(18)        based           fixed bin(18,0)          level 2 in structure "vlh" packed unsigned unaligned
                                                                                  dcl 339 in procedure "execute_firstref_traps" ref
                                                                                  365 370
first_ref_relp            1(18)        based           fixed bin(18,0)          level 2 in structure "vlh" packed unsigned unaligned
                                                                                  dcl 225 in procedure "prelink_component" ref 250
                                                                                  250
fr_traps                               based           structure                level 1 dcl 5-90
frt                                    based           structure                level 1 dcl 340
frtp                            000300 automatic       pointer                  dcl 347 set ref 370* 372 377 378 379 381
get_ring_                       000012 constant        entry                    external dcl 78 ref 158 302
get_system_free_area_           000014 constant        entry                    external dcl 79 ref 108
hbound                                                 builtin function         dcl 97 ref 144 160 177 184
hcs_$combine_linkage            000022 constant        entry                    external dcl 83 ref 166
hcs_$fs_get_path_name           000016 constant        entry                    external dcl 80 ref 140
hcs_$link_force                 000020 constant        entry                    external dcl 82 ref 382
header_relp                            based           fixed bin(17,0)          level 2 packed unaligned dcl 5-28 ref 112
info_linkp                             parameter       pointer                  dcl 44 ref 19 112 112
info_ptr_ptr                    000274 automatic       pointer                  dcl 345 set ref 379* 381* 391*
info_relp                 2(18)        based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 340 ref
                                                                                  379 381
initiate_file_                  000024 constant        entry                    external dcl 84 ref 146
isot                                   based           structure                level 1 dcl 4-13
isot_ptr                 52            based           pointer                  level 2 dcl 6-26 ref 157
isotp                           000222 automatic       pointer                  dcl 4-12 set ref 157* 171
isp                                    based           pointer                  array level 2 packed unaligned dcl 4-13 ref 171
its                                    based           structure                level 1 dcl 3-5
its_mod                   0(30)        based           bit(6)                   level 2 packed unaligned dcl 222 set ref 265 301*
its_ptr                                based           structure                level 1 dcl 222
its_unsigned                           based           structure                level 1 dcl 3-30
lbound                                                 builtin function         dcl 98 ref 144 160 177 184
lh                                     based           structure                level 1 dcl 50 in procedure "msf_prelink_"
lh                                     based           structure                level 1 dcl 338 in procedure
                                                                                  "execute_firstref_traps"
lh                                     based           structure                level 1 dcl 223 in procedure "prelink_component"
lhp                             000276 automatic       pointer                  dcl 346 in procedure "execute_firstref_traps" set
                                                                                  ref 362* 363 370
lhp                             000172 automatic       pointer                  dcl 68 in procedure "msf_prelink_" set ref 112* 116
lhp                             000240 automatic       pointer                  dcl 229 in procedure "prelink_component" set ref
                                                                                  241* 242 261
link                            000242 automatic       fixed bin(18,0)          dcl 230 set ref 255* 261*
link_begin                6            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 225 ref 255
link_init                              based           structure                level 1 dcl 2-205
linkage_header                         based           structure                level 1 dcl 5-50
linkage_section_lng       6(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 225 ref 248
linkp                     2            based           pointer                  array level 2 in structure "comp" dcl 221
                                                                                  in procedure "prelink_component" ref 241 280 281
linkp                     2            based           pointer                  array level 2 in structure "comp" dcl 48
                                                                                  in procedure "msf_prelink_" set ref 170* 172
linkp                           000302 automatic       pointer                  dcl 348 in procedure "execute_firstref_traps" set
                                                                                  ref 375* 378 381
linkp                           000244 automatic       pointer                  dcl 231 in procedure "prelink_component" set ref
                                                                                  261* 265 267 268 269 273 280 280 281 288 288 289
                                                                                  296 296 297 301 302
linkp                     2            based           pointer                  array level 2 in structure "comp" dcl 337
                                                                                  in procedure "execute_firstref_traps" ref 355 360
                                                                                  362 375
lk                                     based           structure                level 1 dcl 224
lk_end                          000246 automatic       fixed bin(17,0)          dcl 232 set ref 246* 248* 250* 250 255
lot                                    based           structure                level 1 dcl 4-6
lot_fault                              constant        bit(36)                  initial dcl 4-9 ref 164
lot_ptr                  26            based           pointer                  level 2 dcl 6-26 ref 156
lotp                            000220 automatic       pointer                  dcl 4-4 set ref 156* 164 170
lp                                     based           pointer                  array level 2 packed unaligned dcl 4-6 ref 164 170
ltrim                                                  builtin function         dcl 99 ref 145
min                                                    builtin function         dcl 100 ref 250
mm                                     based           structure                level 1 dcl 51
mmp                             000174 automatic       pointer                  dcl 69 set ref 123* 135 185
msf_map                                based           structure                level 1 dcl 2-318
msf_map_relp              0(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 49 ref 118 123
my_component              3            based           fixed bin(15,0)          level 2 unsigned dcl 51 ref 185
n_comp                                 parameter       fixed bin(17,0)          dcl 216 in procedure "prelink_component" ref 198
n_comp                                 parameter       fixed bin(17,0)          dcl 331 in procedure "execute_firstref_traps" ref
                                                                                  313
n_comp                          000176 automatic       fixed bin(17,0)          dcl 70 in procedure "msf_prelink_" set ref 131 135*
                                                                                  136 144 160 177 178* 184 185* 189
n_traps                   1            based           fixed bin(17,0)          level 2 dcl 340 ref 377
null                                                   builtin function         dcl 101 ref 127 131 379
object_link                            based           structure                level 1 dcl 5-28 ref 255 255
object_msf_damaged_             000212 stack reference condition                dcl 90 ref 118 148 162 167 299 372 383
offset                    1            based           fixed bin(18,0)          level 2 in structure "its_ptr" packed unsigned
                                                                                  unaligned dcl 222 in procedure "prelink_component"
                                                                                  set ref 280* 288* 296*
offset                    1            based           fixed bin(18,0)          level 2 in structure "lk" packed unsigned unaligned
                                                                                  dcl 224 in procedure "prelink_component" ref 280
                                                                                  288 296
original_linkage_ptr      3            based           pointer                  level 2 in structure "lh" packed unaligned dcl 223
                                                                                  in procedure "prelink_component" ref 242
original_linkage_ptr      3            based           pointer                  level 2 in structure "lh" packed unaligned dcl 338
                                                                                  in procedure "execute_firstref_traps" ref 363
pad1                                   based           bit(3)                   level 2 packed unaligned dcl 222 set ref 269*
pad4                      1(27)        based           bit(3)                   level 2 packed unaligned dcl 3-5 set ref 355 360*
partial_link                           based           structure                level 1 dcl 5-38
ring                            000177 automatic       fixed bin(17,0)          dcl 71 set ref 158* 166*
ringno                    0(18)        based           fixed bin(3,0)           level 2 packed unsigned unaligned dcl 222 set ref
                                                                                  302*
sb                              000224 automatic       pointer                  dcl 6-24 set ref 155* 156 157 162
seg_no                          000200 automatic       fixed bin(17,0)          dcl 72 set ref 161* 162 164 170 171
segno                     0(03)        based           fixed bin(15,0)          level 2 in structure "its_ptr" packed unsigned
                                                                                  unaligned dcl 222 in procedure "prelink_component"
                                                                                  set ref 273* 281* 289* 297*
segno                                                  builtin function         dcl 239 in procedure "prelink_component" ref 273 281
                                                                                  289 297
segno                                                  builtin function         dcl 102 in procedure "msf_prelink_" ref 161
segp                                   based           pointer                  array level 2 in structure "comp" dcl 221
                                                                                  in procedure "prelink_component" ref 273
segp                                   based           pointer                  array level 2 in structure "comp" dcl 48
                                                                                  in procedure "msf_prelink_" set ref 146* 161 166*
size                                                   builtin function         dcl 103 ref 255 255
stack_header                           based           structure                level 1 dcl 6-26
stackbaseptr                                           builtin function         dcl 104 ref 155
statp                     4            based           pointer                  array level 2 in structure "comp" dcl 221
                                                                                  in procedure "prelink_component" ref 288 289
statp                     4            based           pointer                  array level 2 in structure "comp" dcl 48
                                                                                  in procedure "msf_prelink_" set ref 171*
symbol_ptr                2            based           pointer                  level 2 packed unaligned dcl 5-50 ref 172
symbp                     6            based           pointer                  array level 2 in structure "comp" dcl 48
                                                                                  in procedure "msf_prelink_" set ref 172*
symbp                     6            based           pointer                  array level 2 in structure "comp" dcl 221
                                                                                  in procedure "prelink_component" ref 296 297
system_free_area                       based           area(1024)               dcl 52 ref 131 136 189
system_free_areap               000202 automatic       pointer                  dcl 73 set ref 108* 131 136 189
t                               000247 automatic       fixed bin(17,0)          dcl 233 set ref 268* 273 280 281 288 289 296 297
trap                            000304 automatic       fixed bin(17,0)          dcl 349 set ref 377* 378 379 381*
trap_array                2            based           structure                array level 2 dcl 340
trap_proc                       000306 automatic       entry variable           dcl 350 set ref 390* 391
type                                   based           fixed bin(3,0)           level 2 in structure "lk" packed unsigned unaligned
                                                                                  dcl 224 in procedure "prelink_component" ref 267
type                            000250 automatic       fixed bin(17,0)          dcl 234 in procedure "prelink_component" set ref
                                                                                  267* 273 278 286 294
unspec                                                 builtin function         dcl 105 ref 164
virgin_linkage_header                  based           structure                level 1 dcl 5-71
vlh                                    based           structure                level 1 dcl 225 in procedure "prelink_component"
vlh                                    based           structure                level 1 dcl 339 in procedure
                                                                                  "execute_firstref_traps"
vlhp                            000312 automatic       pointer                  dcl 351 in procedure "execute_firstref_traps" set
                                                                                  ref 363* 365 370
vlhp                            000252 automatic       pointer                  dcl 235 in procedure "prelink_component" set ref
                                                                                  242* 246 246 248 250 250 255
wordno                                                 builtin function         dcl 106 ref 280 288 296

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
CLASS_HEAP                             internal static fixed bin(3,0)           initial unsigned dcl 2-25
CLASS_NAMES                            internal static char(12)                 initial array unaligned dcl 2-35
CLASS_SEGNAME                          internal static fixed bin(3,0)           initial unsigned dcl 2-25
CLASS_SYSTEM                           internal static fixed bin(3,0)           initial unsigned dcl 2-25
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
FAULT_TAG_1                            internal static bit(6)                   initial unaligned dcl 5-100
FAULT_TAG_2                            internal static bit(6)                   initial unaligned dcl 5-101
INIT_COPY_INFO                         internal static fixed bin(17,0)          initial dcl 2-194
INIT_DEFERRED                          internal static fixed bin(17,0)          initial dcl 2-194
INIT_DEFINE_AREA                       internal static fixed bin(17,0)          initial dcl 2-194
INIT_LIST_TEMPLATE                     internal static fixed bin(17,0)          initial dcl 2-194
INIT_NO_INIT                           internal static fixed bin(17,0)          initial dcl 2-194
ITP_MODIFIER                           internal static bit(6)                   initial unaligned dcl 3-56
LINK_CREATE_IF_NOT_FOUND               internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_OBSOLETE_2                        internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_REFNAME_BASE                      internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_REFNAME_OFFSETNAME                internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_SELF_BASE                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_SELF_OFFSETNAME                   internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_TYPE_NAMES                        internal static varying char(32)         initial array dcl 2-153
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SECTION_HEAP                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_LINK                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_STATIC                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_SYMBOL                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_SYSTEM                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_TEXT                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_UNUSED                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SYMBOLIC_SECTION_NAMES                 internal static char(8)                  initial array unaligned dcl 2-38
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
acc_string                             based           structure                level 1 dcl 2-327
acc_string_length                      automatic       fixed bin(21,0)          dcl 2-334
acc_string_ptr                         automatic       pointer                  dcl 2-326
call_offset                            internal static fixed bin(17,0)          initial dcl 6-78
comp_ht_n_entries                      automatic       fixed bin(17,0)          dcl 2-297
comp_ht_ptr                            automatic       pointer                  dcl 2-288
component_ht                           based           structure                level 1 dcl 2-289
def_header_ptr                         automatic       pointer                  dcl 2-57
def_ht_n_entries                       automatic       fixed bin(17,0)          dcl 2-284
def_ht_ptr                             automatic       pointer                  dcl 2-277
def_ptr                                automatic       pointer                  dcl 2-71
definition                             based           structure                level 1 dcl 2-72
definition_ht                          based           structure                level 1 dcl 2-278
dup_table_n_names                      automatic       fixed bin(17,0)          dcl 2-310
dup_table_ptr                          automatic       pointer                  dcl 2-301
duplicate_table                        based           structure                level 1 dcl 2-302
entry_offset                           internal static fixed bin(17,0)          initial dcl 6-78
exp_ptr                                automatic       pointer                  dcl 2-128
exp_word                               based           structure                level 1 dcl 2-129
isot1                                  based           structure                array level 1 dcl 4-16
itp                                    based           structure                level 1 dcl 3-18
itp_unsigned                           based           structure                level 1 dcl 3-43
link_init_copy_info                    based           structure                level 1 dcl 2-211
link_init_deferred                     based           structure                level 1 dcl 2-270
link_init_list_template                based           structure                level 1 dcl 2-219
link_init_n_bits_in_datum              automatic       fixed bin(35,0)          dcl 2-261
link_init_n_words                      automatic       fixed bin(17,0)          dcl 2-215
link_init_n_words_in_list              automatic       fixed bin(17,0)          dcl 2-226
link_init_ptr                          automatic       pointer                  dcl 2-204
link_trap_pair                         based           structure                level 1 dcl 2-177
link_trap_ptr                          automatic       pointer                  dcl 2-176
linkage_header_flags                   based           structure                level 1 dcl 5-63
list_template_entry                    based           structure                level 1 dcl 2-239
msf_map_ptr                            automatic       pointer                  dcl 2-317
msf_map_version_1                      internal static char(8)                  initial unaligned dcl 2-323
pointer_init_template                  based           structure                level 1 packed unaligned dcl 2-253
push_offset                            internal static fixed bin(17,0)          initial dcl 6-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 6-78
return_offset                          internal static fixed bin(17,0)          initial dcl 6-78
segname_definition                     based           structure                level 1 dcl 2-90
segname_ptr                            automatic       pointer                  dcl 2-89
stack_header_overlay                   based           fixed bin(17,0)          array dcl 6-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 6-72
type_pair                              based           structure                level 1 dcl 2-160
type_ptr                               automatic       pointer                  dcl 2-159

NAMES DECLARED BY EXPLICIT CONTEXT.
execute_firstref_traps          000711 constant        entry                    internal dcl 313 ref 185
msf_prelink_                    000026 constant        entry                    external dcl 19 ref 388
prelink_component               000432 constant        entry                    internal dcl 198 ref 178

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1222        1250    1100        1232
Length      1560    1100        26         274     121           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
msf_prelink_                        286 external procedure  is an external procedure.  
on unit on line 129                  64 on unit               
prelink_component                       internal procedure  shares stack frame of external procedure msf_prelink_.  
execute_firstref_traps                  internal procedure  shares stack frame of external procedure msf_prelink_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
msf_prelink_             000100 c                           msf_prelink_
                         000102 ctp                         msf_prelink_
                         000104 dhp                         msf_prelink_
                         000106 dir_name                    msf_prelink_
                         000160 ec                          msf_prelink_
                         000161 entry_name                  msf_prelink_
                         000172 lhp                         msf_prelink_
                         000174 mmp                         msf_prelink_
                         000176 n_comp                      msf_prelink_
                         000177 ring                        msf_prelink_
                         000200 seg_no                      msf_prelink_
                         000202 system_free_areap           msf_prelink_
                         000220 lotp                        msf_prelink_
                         000222 isotp                       msf_prelink_
                         000224 sb                          msf_prelink_
                         000240 lhp                         prelink_component
                         000242 link                        prelink_component
                         000244 linkp                       prelink_component
                         000246 lk_end                      prelink_component
                         000247 t                           prelink_component
                         000250 type                        prelink_component
                         000252 vlhp                        prelink_component
                         000272 call_ptr_ptr                execute_firstref_traps
                         000274 info_ptr_ptr                execute_firstref_traps
                         000276 lhp                         execute_firstref_traps
                         000300 frtp                        execute_firstref_traps
                         000302 linkp                       execute_firstref_traps
                         000304 trap                        execute_firstref_traps
                         000306 trap_proc                   execute_firstref_traps
                         000312 vlhp                        execute_firstref_traps

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ent_var_desc   call_ext_out_desc   call_ext_out        return_mac          signal_op           enable_op
ext_entry           int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$make_entry_value          get_ring_                     get_system_free_area_         hcs_$combine_linkage
hcs_$fs_get_path_name         hcs_$link_force               initiate_file_

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.


CONSTANTS
001063  aa     777777777077

001064  aa     077777777777

001066  aa     000006000000
001067  aa     000000000000
001070  aa     600000000041
001071  aa     000102000000
001072  aa     600000000041
001073  aa     000176000000
001074  aa     600000000041
001075  aa     000100000000

001076  aa  403 040 022 146	 f
001077  aa  040 321 000 000	 

000000  aa     600000000000

000001  aa     404000000030

000002  aa     516000000003

000003  aa     404000000043

000004  aa     526000000040

000005  aa     404000000021

000006  aa     526000000250

000007  aa     404000000003

000010  aa     464000000000

000012  aa     077777000043
000013  aa     000001000000

000014  aa  143 154 145 141	clea
000015  aa  156 165 160 000	nup

000016  aa  157 142 152 145	obje
000017  aa  143 164 137 155	ct_m
000020  aa  163 146 137 144	sf_d
000021  aa  141 155 141 147	amag
000022  aa  145 144 137 000	ed_

BEGIN PROCEDURE msf_prelink_
ENTRY TO msf_prelink_                                       STATEMENT 1 ON LINE 19
msf_prelink_:
  proc (info_linkp);

000023  at     000001000010
000024  ta     000023000000
000025  da     000107300000
000026  aa   000440 6270 00	eax7 	288
000027  aa  7 00034 3521 20	epp2 	pr7|28,*
000030  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000031  aa     000002000000
000032  aa     000000000000
						STATEMENT 1 ON LINE 108
  system_free_areap = get_system_free_area_ ();

000033  aa  6 00202 3521 00	epp2 	pr6|130		system_free_areap
000034  aa  6 00326 2521 00	spri2	pr6|214
000035  aa  6 00324 6211 00	eax1 	pr6|212
000036  aa   004000 4310 07	fld  	2048,dl
000037  la  4 00014 3521 20	epp2 	pr4|12,*		get_system_free_area_
000040  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 112
  lhp = addwordno (info_linkp, info_linkp -> object_link.header_relp);

000041  aa  6 00032 3735 20	epp7 	pr6|26,*
000042  aa  7 00002 3715 20	epp5 	pr7|2,*		info_linkp
000043  aa  5 00000 2351 20	lda  	pr5|0,*		object_link.header_relp
000044  aa   000066 7330 00	lrs  	54
000045  aa  5 00000 3521 66	epp2 	pr5|0,*ql		info_linkp
000046  aa   000000 0520 03	adwp2	0,du
000047  aa  6 00172 2521 00	spri2	pr6|122		lhp
						STATEMENT 1 ON LINE 116
  dhp = lh.def_ptr;

000050  aa  2 00000 3535 20	epp3 	pr2|0,*		lh.def_ptr
000051  aa  6 00104 2535 00	spri3	pr6|68		dhp
						STATEMENT 1 ON LINE 118
  if dh.msf_map_relp = 0
    then signal object_msf_damaged_;

000052  aa  3 00000 2361 00	ldq  	pr3|0		dh.msf_map_relp
000053  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000054  aa   000004 6010 04	tnz  	4,ic		000060
000055  aa   000023 7260 07	lxl6 	19,dl
000056  aa   777740 3520 04	epp2 	-32,ic		000016 = 157142152145
000057  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
						STATEMENT 1 ON LINE 123
  mmp = addwordno (dhp, dh.msf_map_relp);

000060  aa  6 00104 2361 20	ldq  	pr6|68,*		dh.msf_map_relp
000061  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000062  aa  6 00104 3521 66	epp2 	pr6|68,*ql	dhp
000063  aa   000000 0520 03	adwp2	0,du
000064  aa  6 00174 2521 00	spri2	pr6|124		mmp
						STATEMENT 1 ON LINE 127
  ctp = null;

000065  aa   777725 2370 04	ldaq 	-43,ic		000012 = 077777000043 000001000000
000066  aa  6 00102 7571 00	staq 	pr6|66		ctp
						STATEMENT 1 ON LINE 129
  on cleanup
    begin;

000067  aa   000007 7260 07	lxl6 	7,dl
000070  aa   777724 3520 04	epp2 	-44,ic		000014 = 143154145141
000071  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
000072  aa   000004 7100 04	tra  	4,ic		000076
000073  aa     000204000000
000074  aa   000022 7100 04	tra  	18,ic		000116
BEGIN CONDITION cleanup.1
ENTRY TO cleanup.1                                          STATEMENT 1 ON LINE 129
  on cleanup
    begin;

000075  da     000115200000
000076  aa   000100 6270 00	eax7 	64
000077  aa  7 00034 3521 20	epp2 	pr7|28,*
000100  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000101  aa     000000000000
000102  aa     000000000000
						STATEMENT 1 ON LINE 131
    if ctp ^= null
      then free comp in (system_free_area);

000103  aa  6 00040 3735 20	epp7 	pr6|32,*
000104  aa  7 00102 2371 00	ldaq 	pr7|66		ctp
000105  aa   777705 6770 04	eraq 	-59,ic		000012 = 077777000043 000001000000
000106  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000107  aa   000006 6000 04	tze  	6,ic		000115
000110  aa  7 00176 2361 00	ldq  	pr7|126		n_comp
000111  aa   000001 0760 07	adq  	1,dl
000112  aa   000003 7360 00	qls  	3
000113  aa  7 00102 3715 00	epp5 	pr7|66		ctp
000114  aa  0 01404 7001 00	tsx0 	pr0|772		op_freen_
						STATEMENT 1 ON LINE 133
  end;

000115  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.1
						STATEMENT 1 ON LINE 135
  n_comp = mm.component_count - 1;

000116  aa  6 00174 3735 20	epp7 	pr6|124,*		mmp
000117  aa  7 00002 2361 00	ldq  	pr7|2		mm.component_count
000120  aa   000001 1760 07	sbq  	1,dl
000121  aa  6 00176 7561 00	stq  	pr6|126		n_comp
						STATEMENT 1 ON LINE 136
  allocate comp in (system_free_area);

000122  aa  6 00176 2361 00	ldq  	pr6|126		n_comp
000123  aa   000001 0760 07	adq  	1,dl
000124  aa   000003 7360 00	qls  	3
000125  aa  6 00202 3521 20	epp2 	pr6|130,*		system_free_area
000126  aa  0 01402 7001 00	tsx0 	pr0|770		op_alloc_
000127  aa   777773 7100 04	tra  	-5,ic		000122
000130  aa  6 00102 2521 00	spri2	pr6|66		ctp
						STATEMENT 1 ON LINE 140
  call hcs_$fs_get_path_name (dhp, dir_name, (0), entry_name, ec);

000131  aa  6 00323 4501 00	stz  	pr6|211
000132  aa  6 00104 3521 00	epp2 	pr6|68		dhp
000133  aa  6 00332 2521 00	spri2	pr6|218
000134  aa  6 00106 3521 00	epp2 	pr6|70		dir_name
000135  aa  6 00334 2521 00	spri2	pr6|220
000136  aa  6 00323 3521 00	epp2 	pr6|211
000137  aa  6 00336 2521 00	spri2	pr6|222
000140  aa  6 00161 3521 00	epp2 	pr6|113		entry_name
000141  aa  6 00340 2521 00	spri2	pr6|224
000142  aa  6 00160 3521 00	epp2 	pr6|112		ec
000143  aa  6 00342 2521 00	spri2	pr6|226
000144  aa   777644 3520 04	epp2 	-92,ic		000010 = 464000000000
000145  aa  6 00344 2521 00	spri2	pr6|228
000146  aa   777640 3520 04	epp2 	-96,ic		000006 = 526000000250
000147  aa  6 00346 2521 00	spri2	pr6|230
000150  aa   777635 3520 04	epp2 	-99,ic		000005 = 404000000021
000151  aa  6 00350 2521 00	spri2	pr6|232
000152  aa   777632 3520 04	epp2 	-102,ic		000004 = 526000000040
000153  aa  6 00352 2521 00	spri2	pr6|234
000154  aa   777627 3520 04	epp2 	-105,ic		000003 = 404000000043
000155  aa  6 00354 2521 00	spri2	pr6|236
000156  aa  6 00330 6211 00	eax1 	pr6|216
000157  aa   024000 4310 07	fld  	10240,dl
000160  aa  6 00044 3701 20	epp4 	pr6|36,*
000161  la  4 00016 3521 20	epp2 	pr4|14,*		hcs_$fs_get_path_name
000162  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 144
  do c = lbound (comp, 1) to hbound (comp, 1);

000163  aa  6 00176 2361 00	ldq  	pr6|126		n_comp
000164  aa  6 00226 7561 00	stq  	pr6|150
000165  aa  6 00100 4501 00	stz  	pr6|64		c
000166  aa  6 00100 2361 00	ldq  	pr6|64		c
000167  aa  6 00226 1161 00	cmpq 	pr6|150
000170  aa   000076 6054 04	tpnz 	62,ic		000266
						STATEMENT 1 ON LINE 145
    entry_name = ltrim (char (c));

000171  aa  000 100 301 500	btd  	(pr),(pr)
000172  aa  6 00100 00 0004	desc9a	pr6|64,4		c
000173  aa  6 00356 01 0010	desc9ls	pr6|238,8,0
000174  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
000175  aa  6 00356 01 0010	desc9ls	pr6|238,8,0
000176  aa   000702 00 0006	desc9a	450,6		001076 = 403040022146
000177  aa  6 00324 00 0012	desc9a	pr6|212,10
000200  aa  000 000 164 500	tct  	(pr)
000201  aa  6 00324 00 0012	desc9a	pr6|212,10
000202  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
000203  aa  6 00056 0001 00	arg  	pr6|46
000204  aa  6 00056 2361 00	ldq  	pr6|46
000205  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
000206  aa  6 00323 7561 00	stq  	pr6|211
000207  aa   000012 2360 07	ldq  	10,dl
000210  aa  6 00323 1761 00	sbq  	pr6|211
000211  aa  6 00323 2351 00	lda  	pr6|211
000212  aa  040 100 100 545	mlr  	(pr,rl,al),(pr),fill(040)
000213  aa  6 00324 00 0006	desc9a	pr6|212,ql
000214  aa  6 00161 00 0040	desc9a	pr6|113,32	entry_name
						STATEMENT 1 ON LINE 146
    call initiate_file_ (dir_name, entry_name, RE_ACCESS, comp (c).segp,
         0, ec);

000215  aa   464000 2360 03	ldq  	157696,du
000216  aa  6 00323 7561 00	stq  	pr6|211
000217  aa  6 00100 2361 00	ldq  	pr6|64		c
000220  aa   000003 7360 00	qls  	3
000221  aa  6 00360 4501 00	stz  	pr6|240
000222  aa  6 00106 3521 00	epp2 	pr6|70		dir_name
000223  aa  6 00364 2521 00	spri2	pr6|244
000224  aa  6 00161 3521 00	epp2 	pr6|113		entry_name
000225  aa  6 00366 2521 00	spri2	pr6|246
000226  aa   777552 3520 04	epp2 	-150,ic		000000 = 600000000000
000227  aa  6 00370 2521 00	spri2	pr6|248
000230  aa  6 00102 3521 66	epp2 	pr6|66,*ql	comp.segp
000231  aa  6 00372 2521 00	spri2	pr6|250
000232  aa  6 00360 3521 00	epp2 	pr6|240
000233  aa  6 00374 2521 00	spri2	pr6|252
000234  aa  6 00160 3521 00	epp2 	pr6|112		ec
000235  aa  6 00376 2521 00	spri2	pr6|254
000236  aa   777550 3520 04	epp2 	-152,ic		000006 = 526000000250
000237  aa  6 00400 2521 00	spri2	pr6|256
000240  aa   777544 3520 04	epp2 	-156,ic		000004 = 526000000040
000241  aa  6 00402 2521 00	spri2	pr6|258
000242  aa   777540 3520 04	epp2 	-160,ic		000002 = 516000000003
000243  aa  6 00404 2521 00	spri2	pr6|260
000244  aa  6 00323 3521 00	epp2 	pr6|211
000245  aa  6 00406 2521 00	spri2	pr6|262
000246  aa   777533 3520 04	epp2 	-165,ic		000001 = 404000000030
000247  aa  6 00410 2521 00	spri2	pr6|264
000250  aa   777533 3520 04	epp2 	-165,ic		000003 = 404000000043
000251  aa  6 00412 2521 00	spri2	pr6|266
000252  aa  6 00362 6211 00	eax1 	pr6|242
000253  aa   030000 4310 07	fld  	12288,dl
000254  aa  6 00044 3701 20	epp4 	pr6|36,*
000255  la  4 00024 3521 20	epp2 	pr4|20,*		initiate_file_
000256  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 148
    if ec ^= 0
      then signal object_msf_damaged_;

000257  aa  6 00160 2361 00	ldq  	pr6|112		ec
000260  aa   000004 6000 04	tze  	4,ic		000264
000261  aa   000023 7260 07	lxl6 	19,dl
000262  aa   777534 3520 04	epp2 	-164,ic		000016 = 157142152145
000263  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
						STATEMENT 1 ON LINE 150
  end;

000264  aa  6 00100 0541 00	aos  	pr6|64		c
000265  aa   777701 7100 04	tra  	-63,ic		000166
						STATEMENT 1 ON LINE 155
  sb = stackbaseptr ();

000266  aa  6 00000 3525 00	epbp2	pr6|0
000267  aa  6 00224 2521 00	spri2	pr6|148		sb
						STATEMENT 1 ON LINE 156
  lotp = stack_header.lot_ptr;

000270  aa  2 00026 3735 20	epp7 	pr2|22,*		stack_header.lot_ptr
000271  aa  6 00220 6535 00	spri7	pr6|144		lotp
						STATEMENT 1 ON LINE 157
  isotp = stack_header.isot_ptr;

000272  aa  2 00052 3715 20	epp5 	pr2|42,*		stack_header.isot_ptr
000273  aa  6 00222 6515 00	spri5	pr6|146		isotp
						STATEMENT 1 ON LINE 158
  ring = get_ring_ ();

000274  aa  6 00323 3521 00	epp2 	pr6|211
000275  aa  6 00326 2521 00	spri2	pr6|214
000276  aa  6 00324 6211 00	eax1 	pr6|212
000277  aa   004000 4310 07	fld  	2048,dl
000300  aa  6 00044 3701 20	epp4 	pr6|36,*
000301  la  4 00012 3521 20	epp2 	pr4|10,*		get_ring_
000302  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000303  aa  6 00323 2361 00	ldq  	pr6|211
000304  aa  6 00177 7561 00	stq  	pr6|127		ring
						STATEMENT 1 ON LINE 160
  do c = lbound (comp, 1) to hbound (comp, 1);

000305  aa  6 00176 2361 00	ldq  	pr6|126		n_comp
000306  aa  6 00227 7561 00	stq  	pr6|151
000307  aa  6 00100 4501 00	stz  	pr6|64		c
000310  aa  6 00100 2361 00	ldq  	pr6|64		c
000311  aa  6 00227 1161 00	cmpq 	pr6|151
000312  aa   000063 6054 04	tpnz 	51,ic		000375
						STATEMENT 1 ON LINE 161
    seg_no = segno (comp (c).segp);

000313  aa   000003 7360 00	qls  	3
000314  aa  6 00102 3735 66	epp7 	pr6|66,*ql	comp.segp
000315  aa  7 00000 3735 20	epp7 	pr7|0,*		comp.segp
000316  aa  7 00000 2131 00	epaq 	pr7|0		comp.segp
000317  aa   000022 7770 00	llr  	18
000320  aa   077777 3760 07	anq  	32767,dl
000321  aa  6 00200 7561 00	stq  	pr6|128		seg_no
						STATEMENT 1 ON LINE 162
    if seg_no > stack_header.cur_lot_size
      then signal object_msf_damaged_;

000322  aa  6 00224 3715 20	epp5 	pr6|148,*		sb
000323  aa  5 00013 2351 00	lda  	pr5|11		stack_header.cur_lot_size
000324  aa   000066 7330 00	lrs  	54
000325  aa  6 00200 1161 00	cmpq 	pr6|128		seg_no
000326  aa   000004 6050 04	tpl  	4,ic		000332
000327  aa   000023 7260 07	lxl6 	19,dl
000330  aa   777466 3520 04	epp2 	-202,ic		000016 = 157142152145
000331  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
						STATEMENT 1 ON LINE 164
    if unspec (lot.lp (seg_no)) = lot_fault
      then do;

000332  aa  6 00200 7271 00	lxl7 	pr6|128		seg_no
000333  aa  6 00220 2351 77	lda  	pr6|144,*7
000334  aa   700000 1150 03	cmpa 	229376,du
000335  aa   000023 6010 04	tnz  	19,ic		000360
						STATEMENT 1 ON LINE 166
        call hcs_$combine_linkage (comp (c).segp, ring, ec);

000336  aa  6 00100 2361 00	ldq  	pr6|64		c
000337  aa   000003 7360 00	qls  	3
000340  aa  6 00102 3521 66	epp2 	pr6|66,*ql	comp.segp
000341  aa  6 00332 2521 00	spri2	pr6|218
000342  aa  6 00177 3521 00	epp2 	pr6|127		ring
000343  aa  6 00334 2521 00	spri2	pr6|220
000344  aa  6 00160 3521 00	epp2 	pr6|112		ec
000345  aa  6 00336 2521 00	spri2	pr6|222
000346  aa  6 00330 6211 00	eax1 	pr6|216
000347  aa   014000 4310 07	fld  	6144,dl
000350  aa  6 00044 3701 20	epp4 	pr6|36,*
000351  la  4 00022 3521 20	epp2 	pr4|18,*		hcs_$combine_linkage
000352  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 167
        if ec ^= 0
	then signal object_msf_damaged_;

000353  aa  6 00160 2361 00	ldq  	pr6|112		ec
000354  aa   000004 6000 04	tze  	4,ic		000360
000355  aa   000023 7260 07	lxl6 	19,dl
000356  aa   777440 3520 04	epp2 	-224,ic		000016 = 157142152145
000357  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
						STATEMENT 1 ON LINE 169
      end;

						STATEMENT 1 ON LINE 170
    comp (c).linkp = lot.lp (seg_no);

000360  aa  6 00100 2361 00	ldq  	pr6|64		c
000361  aa   000003 7360 00	qls  	3
000362  aa  6 00200 7271 00	lxl7 	pr6|128		seg_no
000363  aa  6 00220 7671 77	lprp7	pr6|144,*7	lot.lp
000364  aa  6 00102 3715 20	epp5 	pr6|66,*		ctp
000365  aa  5 00002 6535 06	spri7	pr5|2,ql		comp.linkp
						STATEMENT 1 ON LINE 171
    comp (c).statp = isot.isp (seg_no);

000366  aa  6 00222 7631 77	lprp3	pr6|146,*7	isot.isp
000367  aa  5 00004 2535 06	spri3	pr5|4,ql		comp.statp
						STATEMENT 1 ON LINE 172
    comp (c).symbp = comp (c).linkp -> linkage_header.symbol_ptr;

000370  aa  5 00002 3515 26	epp1 	pr5|2,ql*		comp.linkp
000371  aa  1 00002 7631 00	lprp3	pr1|2		linkage_header.symbol_ptr
000372  aa  5 00006 2535 06	spri3	pr5|6,ql		comp.symbp
						STATEMENT 1 ON LINE 173
  end;

000373  aa  6 00100 0541 00	aos  	pr6|64		c
000374  aa   777714 7100 04	tra  	-52,ic		000310
						STATEMENT 1 ON LINE 177
  do c = lbound (comp, 1) to hbound (comp, 1);

000375  aa  6 00176 2361 00	ldq  	pr6|126		n_comp
000376  aa  6 00230 7561 00	stq  	pr6|152
000377  aa  6 00100 4501 00	stz  	pr6|64		c
000400  aa  6 00100 2361 00	ldq  	pr6|64		c
000401  aa  6 00230 1161 00	cmpq 	pr6|152
000402  aa   000005 6054 04	tpnz 	5,ic		000407
						STATEMENT 1 ON LINE 178
    call prelink_component (ctp, n_comp, c);

000403  aa   000463 3520 04	epp2 	307,ic		001066 = 000006000000
000404  aa   000026 6700 04	tsp4 	22,ic		000432
						STATEMENT 1 ON LINE 179
  end;

000405  aa  6 00100 0541 00	aos  	pr6|64		c
000406  aa   777772 7100 04	tra  	-6,ic		000400
						STATEMENT 1 ON LINE 184
  do c = lbound (comp, 1) to hbound (comp, 1);

000407  aa  6 00176 2361 00	ldq  	pr6|126		n_comp
000410  aa  6 00231 7561 00	stq  	pr6|153
000411  aa  6 00100 4501 00	stz  	pr6|64		c
000412  aa  6 00100 2361 00	ldq  	pr6|64		c
000413  aa  6 00231 1161 00	cmpq 	pr6|153
000414  aa   000010 6054 04	tpnz 	8,ic		000424
						STATEMENT 1 ON LINE 185
    if c ^= mm.my_component		/* this will occur later anyway */
      then call execute_firstref_traps (ctp, n_comp, c);

000415  aa  6 00174 3735 20	epp7 	pr6|124,*		mmp
000416  aa  7 00003 1161 00	cmpq 	pr7|3		mm.my_component
000417  aa   000003 6000 04	tze  	3,ic		000422
000420  aa   000446 3520 04	epp2 	294,ic		001066 = 000006000000
000421  aa   000270 6700 04	tsp4 	184,ic		000711
						STATEMENT 1 ON LINE 187
  end;

000422  aa  6 00100 0541 00	aos  	pr6|64		c
000423  aa   777767 7100 04	tra  	-9,ic		000412
						STATEMENT 1 ON LINE 189
  free comp in (system_free_area);

000424  aa  6 00176 2361 00	ldq  	pr6|126		n_comp
000425  aa   000001 0760 07	adq  	1,dl
000426  aa   000003 7360 00	qls  	3
000427  aa  6 00102 3715 00	epp5 	pr6|66		ctp
000430  aa  0 01404 7001 00	tsx0 	pr0|772		op_freen_
						STATEMENT 1 ON LINE 191
  return;

000431  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 409
  end msf_prelink_;

BEGIN PROCEDURE prelink_component
ENTRY TO prelink_component                                  STATEMENT 1 ON LINE 198
prelink_component:
  proc (ctp,			/** component table ptr (in )	*/
       n_comp,			/** component count	    (in )	*/
       c);

000432  aa  6 00232 6501 00	spri4	pr6|154
000433  aa  6 00234 2521 00	spri2	pr6|156
						STATEMENT 1 ON LINE 241
  lhp = comp (c).linkp;

000434  aa  2 00006 2361 20	ldq  	pr2|6,*		c
000435  aa   000003 7360 00	qls  	3
000436  aa  2 00002 3735 20	epp7 	pr2|2,*		ctp
000437  aa  7 00000 3735 20	epp7 	pr7|0,*		ctp
000440  aa  7 00002 3715 26	epp5 	pr7|2,ql*		comp.linkp
000441  aa  6 00240 6515 00	spri5	pr6|160		lhp
						STATEMENT 1 ON LINE 242
  vlhp = lh.original_linkage_ptr;

000442  aa  5 00003 7631 00	lprp3	pr5|3		lh.original_linkage_ptr
000443  aa  6 00252 2535 00	spri3	pr6|170		vlhp
						STATEMENT 1 ON LINE 246
  if vlh.defs_in_link = "20"b3
    then lk_end = vlh.def_offset;

000444  aa  3 00000 2351 00	lda  	pr3|0		vlh.defs_in_link
000445  aa   000036 7350 00	als  	30
000446  aa   200000 1150 03	cmpa 	65536,du
000447  aa   000005 6010 04	tnz  	5,ic		000454
000450  aa  3 00001 2351 00	lda  	pr3|1		vlh.def_offset
000451  aa   000066 7730 00	lrl  	54
000452  aa  6 00246 7561 00	stq  	pr6|166		lk_end
000453  aa   000004 7100 04	tra  	4,ic		000457
						STATEMENT 1 ON LINE 248
    else lk_end = vlh.linkage_section_lng;

000454  aa  3 00006 2361 00	ldq  	pr3|6		vlh.linkage_section_lng
000455  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000456  aa  6 00246 7561 00	stq  	pr6|166		lk_end
						STATEMENT 1 ON LINE 250
  if vlh.first_ref_relp ^= 0
    then lk_end = min (lk_end, vlh.first_ref_relp);

000457  aa  3 00001 2361 00	ldq  	pr3|1		vlh.first_ref_relp
000460  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000461  aa  6 00414 7561 00	stq  	pr6|268		vlh.first_ref_relp
000462  aa   000005 6000 04	tze  	5,ic		000467
000463  aa  6 00246 1161 00	cmpq 	pr6|166		lk_end
000464  aa   000002 6040 04	tmi  	2,ic		000466
000465  aa  6 00246 2361 00	ldq  	pr6|166		lk_end
000466  aa  6 00246 7561 00	stq  	pr6|166		lk_end
						STATEMENT 1 ON LINE 255
  do link = vlh.link_begin 
         to lk_end - size (object_link)
         by size (object_link);

000467  aa  6 00246 2361 00	ldq  	pr6|166		lk_end
000470  aa   000002 1760 07	sbq  	2,dl
000471  aa  6 00262 7561 00	stq  	pr6|178
000472  aa   000002 2360 07	ldq  	2,dl
000473  aa  6 00263 7561 00	stq  	pr6|179
000474  aa  3 00006 2351 00	lda  	pr3|6		vlh.link_begin
000475  aa   000066 7730 00	lrl  	54
000476  aa  6 00242 7561 00	stq  	pr6|162		link
000477  aa   000000 0110 03	nop  	0,du
000500  aa  6 00263 2361 00	ldq  	pr6|179
000501  aa   000004 6040 04	tmi  	4,ic		000505
000502  aa  6 00242 2361 00	ldq  	pr6|162		link
000503  aa  6 00262 1161 00	cmpq 	pr6|178
000504  aa   000204 6054 04	tpnz 	132,ic		000710
000505  aa  6 00263 2361 00	ldq  	pr6|179
000506  aa   000004 6050 04	tpl  	4,ic		000512
000507  aa  6 00242 2361 00	ldq  	pr6|162		link
000510  aa  6 00262 1161 00	cmpq 	pr6|178
000511  aa   000177 6040 04	tmi  	127,ic		000710
						STATEMENT 1 ON LINE 261
    linkp = addwordno (lhp, link);

000512  aa  6 00242 2361 00	ldq  	pr6|162		link
000513  aa  6 00240 3521 66	epp2 	pr6|160,*ql	lhp
000514  aa   000000 0520 03	adwp2	0,du
000515  aa  6 00244 2521 00	spri2	pr6|164		linkp
						STATEMENT 1 ON LINE 265
    if its_ptr.its_mod = FAULT_TAG_3
      then do;

000516  aa  2 00000 2351 00	lda  	pr2|0		its_ptr.its_mod
000517  aa   000036 7350 00	als  	30
000520  aa   470000 1150 03	cmpa 	159744,du
000521  aa   000164 6010 04	tnz  	116,ic		000705
						STATEMENT 1 ON LINE 267
        type = lk.type;

000522  aa  2 00000 2351 00	lda  	pr2|0		lk.type
000523  aa   000105 7730 00	lrl  	69
000524  aa  6 00250 7561 00	stq  	pr6|168		type
						STATEMENT 1 ON LINE 268
        t = lk.component;

000525  aa  2 00000 2351 00	lda  	pr2|0		lk.component
000526  aa   000003 7350 00	als  	3
000527  aa   000071 7730 00	lrl  	57
000530  aa  6 00247 7561 00	stq  	pr6|167		t
						STATEMENT 1 ON LINE 269
        its_ptr.pad1 = ""b;

000531  aa   000333 2350 04	lda  	219,ic		001064 = 077777777777
000532  aa  2 00000 3551 00	ansa 	pr2|0		its_ptr.pad1
						STATEMENT 1 ON LINE 273
        if type = CLASS_TEXT
	then its_ptr.segno = segno (comp (t).segp);

000533  aa  6 00250 2361 00	ldq  	pr6|168		type
000534  aa   000017 6010 04	tnz  	15,ic		000553
000535  aa  6 00247 2361 00	ldq  	pr6|167		t
000536  aa   000003 7360 00	qls  	3
000537  aa  6 00234 3735 20	epp7 	pr6|156,*
000540  aa  7 00002 3715 20	epp5 	pr7|2,*		ctp
000541  aa  5 00000 3535 66	epp3 	pr5|0,*ql		comp.segp
000542  aa  3 00000 3535 20	epp3 	pr3|0,*		comp.segp
000543  aa  3 00000 2131 00	epaq 	pr3|0		comp.segp
000544  aa   000022 7770 00	llr  	18
000545  aa   077777 3760 07	anq  	32767,dl
000546  aa   000066 7370 00	lls  	54
000547  aa  2 00000 6751 00	era  	pr2|0		its_ptr.segno
000550  aa   077777 3750 03	ana  	32767,du
000551  aa  2 00000 6551 00	ersa 	pr2|0		its_ptr.segno
000552  aa   000114 7100 04	tra  	76,ic		000666
						STATEMENT 1 ON LINE 278
        else if type = CLASS_LINKAGE
	then do;

000553  aa   000001 1160 07	cmpq 	1,dl
000554  aa   000027 6010 04	tnz  	23,ic		000603
						STATEMENT 1 ON LINE 280
	  its_ptr.offset = lk.offset + wordno (comp (t).linkp);

000555  aa  6 00247 2361 00	ldq  	pr6|167		t
000556  aa   000003 7360 00	qls  	3
000557  aa  6 00234 3735 20	epp7 	pr6|156,*
000560  aa  7 00002 3715 20	epp5 	pr7|2,*		ctp
000561  aa  5 00000 3715 20	epp5 	pr5|0,*		ctp
000562  aa   000000 6270 06	eax7 	0,ql
000563  aa  5 00002 6361 26	eaq  	pr5|2,ql*		comp.linkp
000564  aa   000022 7720 00	qrl  	18
000565  aa  6 00415 7561 00	stq  	pr6|269
000566  aa  2 00001 2351 00	lda  	pr2|1		lk.offset
000567  aa   000066 7730 00	lrl  	54
000570  aa  6 00415 0761 00	adq  	pr6|269
000571  aa   000066 7370 00	lls  	54
000572  aa  2 00001 5511 60	stba 	pr2|1,60		its_ptr.offset
						STATEMENT 1 ON LINE 281
	  its_ptr.segno = segno (comp (t).linkp);

000573  aa  5 00002 2131 37	epaq 	pr5|2,7*		comp.linkp
000574  aa   000022 7770 00	llr  	18
000575  aa   077777 3760 07	anq  	32767,dl
000576  aa   000066 7370 00	lls  	54
000577  aa  2 00000 6751 00	era  	pr2|0		its_ptr.segno
000600  aa   077777 3750 03	ana  	32767,du
000601  aa  2 00000 6551 00	ersa 	pr2|0		its_ptr.segno
						STATEMENT 1 ON LINE 282
	end;

000602  aa   000064 7100 04	tra  	52,ic		000666
						STATEMENT 1 ON LINE 286
        else if type = CLASS_STATIC
	then do;

000603  aa   000004 1160 07	cmpq 	4,dl
000604  aa   000027 6010 04	tnz  	23,ic		000633
						STATEMENT 1 ON LINE 288
	  its_ptr.offset = lk.offset + wordno (comp (t).statp);

000605  aa  6 00247 2361 00	ldq  	pr6|167		t
000606  aa   000003 7360 00	qls  	3
000607  aa  6 00234 3735 20	epp7 	pr6|156,*
000610  aa  7 00002 3715 20	epp5 	pr7|2,*		ctp
000611  aa  5 00000 3715 20	epp5 	pr5|0,*		ctp
000612  aa   000000 6270 06	eax7 	0,ql
000613  aa  5 00004 6361 26	eaq  	pr5|4,ql*		comp.statp
000614  aa   000022 7720 00	qrl  	18
000615  aa  6 00415 7561 00	stq  	pr6|269
000616  aa  2 00001 2351 00	lda  	pr2|1		lk.offset
000617  aa   000066 7730 00	lrl  	54
000620  aa  6 00415 0761 00	adq  	pr6|269
000621  aa   000066 7370 00	lls  	54
000622  aa  2 00001 5511 60	stba 	pr2|1,60		its_ptr.offset
						STATEMENT 1 ON LINE 289
	  its_ptr.segno = segno (comp (t).statp);

000623  aa  5 00004 2131 37	epaq 	pr5|4,7*		comp.statp
000624  aa   000022 7770 00	llr  	18
000625  aa   077777 3760 07	anq  	32767,dl
000626  aa   000066 7370 00	lls  	54
000627  aa  2 00000 6751 00	era  	pr2|0		its_ptr.segno
000630  aa   077777 3750 03	ana  	32767,du
000631  aa  2 00000 6551 00	ersa 	pr2|0		its_ptr.segno
						STATEMENT 1 ON LINE 290
	end;

000632  aa   000034 7100 04	tra  	28,ic		000666
						STATEMENT 1 ON LINE 294
        else if type = CLASS_SYMBOL
	then do;

000633  aa   000002 1160 07	cmpq 	2,dl
000634  aa   000027 6010 04	tnz  	23,ic		000663
						STATEMENT 1 ON LINE 296
	  its_ptr.offset = lk.offset + wordno (comp (t).symbp);

000635  aa  6 00247 2361 00	ldq  	pr6|167		t
000636  aa   000003 7360 00	qls  	3
000637  aa  6 00234 3735 20	epp7 	pr6|156,*
000640  aa  7 00002 3715 20	epp5 	pr7|2,*		ctp
000641  aa  5 00000 3715 20	epp5 	pr5|0,*		ctp
000642  aa   000000 6270 06	eax7 	0,ql
000643  aa  5 00006 6361 26	eaq  	pr5|6,ql*		comp.symbp
000644  aa   000022 7720 00	qrl  	18
000645  aa  6 00415 7561 00	stq  	pr6|269
000646  aa  2 00001 2351 00	lda  	pr2|1		lk.offset
000647  aa   000066 7730 00	lrl  	54
000650  aa  6 00415 0761 00	adq  	pr6|269
000651  aa   000066 7370 00	lls  	54
000652  aa  2 00001 5511 60	stba 	pr2|1,60		its_ptr.offset
						STATEMENT 1 ON LINE 297
	  its_ptr.segno = segno (comp (t).symbp);

000653  aa  5 00006 2131 37	epaq 	pr5|6,7*		comp.symbp
000654  aa   000022 7770 00	llr  	18
000655  aa   077777 3760 07	anq  	32767,dl
000656  aa   000066 7370 00	lls  	54
000657  aa  2 00000 6751 00	era  	pr2|0		its_ptr.segno
000660  aa   077777 3750 03	ana  	32767,du
000661  aa  2 00000 6551 00	ersa 	pr2|0		its_ptr.segno
						STATEMENT 1 ON LINE 298
	end;

000662  aa   000004 7100 04	tra  	4,ic		000666
						STATEMENT 1 ON LINE 299
        else signal object_msf_damaged_;

000663  aa   000023 7260 07	lxl6 	19,dl
000664  aa   777132 3520 04	epp2 	-422,ic		000016 = 157142152145
000665  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
						STATEMENT 1 ON LINE 301
        its_ptr.its_mod = ITS_MODIFIER;

000666  aa   000043 2350 07	lda  	35,dl
000667  aa  6 00244 3735 20	epp7 	pr6|164,*		its_ptr.its_mod
000670  aa  7 00000 7511 01	stca 	pr7|0,01		its_ptr.its_mod
						STATEMENT 1 ON LINE 302
        its_ptr.ringno = get_ring_ ();

000671  aa  6 00414 3521 00	epp2 	pr6|268
000672  aa  6 00420 2521 00	spri2	pr6|272
000673  aa  6 00416 6211 00	eax1 	pr6|270
000674  aa   004000 4310 07	fld  	2048,dl
000675  aa  6 00044 3701 20	epp4 	pr6|36,*
000676  la  4 00012 3521 20	epp2 	pr4|10,*		get_ring_
000677  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000700  aa  6 00414 2361 00	ldq  	pr6|268
000701  aa   000063 7370 00	lls  	51
000702  aa  6 00244 6751 20	era  	pr6|164,*		its_ptr.ringno
000703  aa   700000 3750 07	ana  	229376,dl
000704  aa  6 00244 6551 20	ersa 	pr6|164,*		its_ptr.ringno
						STATEMENT 1 ON LINE 303
      end;

						STATEMENT 1 ON LINE 304
  end;

000705  aa  6 00263 2361 00	ldq  	pr6|179
000706  aa  6 00242 0561 00	asq  	pr6|162		link
000707  aa   777571 7100 04	tra  	-135,ic		000500
						STATEMENT 1 ON LINE 306
  end prelink_component;

000710  aa  6 00232 6101 00	rtcd 	pr6|154
  END PROCEDURE prelink_component
BEGIN PROCEDURE execute_firstref_traps
ENTRY TO execute_firstref_traps                             STATEMENT 1 ON LINE 313
execute_firstref_traps:
  proc (ctp,			/** component table ptr (in ) */
       n_comp,			/** component count	    (in )	*/
       c);

000711  aa  6 00264 6501 00	spri4	pr6|180
000712  aa  6 00266 2521 00	spri2	pr6|182
						STATEMENT 1 ON LINE 355
  if comp (c).linkp -> its.pad4 = ""b
    then return;

000713  aa  2 00006 2361 20	ldq  	pr2|6,*		c
000714  aa   000003 7360 00	qls  	3
000715  aa  2 00002 3735 20	epp7 	pr2|2,*		ctp
000716  aa  7 00000 3735 20	epp7 	pr7|0,*		ctp
000717  aa  7 00002 3715 26	epp5 	pr7|2,ql*		comp.linkp
000720  aa  5 00001 2351 00	lda  	pr5|1		its.pad4
000721  aa   000700 3150 07	cana 	448,dl
000722  aa  6 00422 7561 00	stq  	pr6|274
000723  aa   000002 6010 04	tnz  	2,ic		000725
000724  aa  6 00264 6101 00	rtcd 	pr6|180
						STATEMENT 1 ON LINE 360
  comp (c).linkp -> its.pad4 = ""b;

000725  aa   000136 2350 04	lda  	94,ic		001063 = 777777777077
000726  aa  5 00001 3551 00	ansa 	pr5|1		its.pad4
						STATEMENT 1 ON LINE 362
  lhp = comp (c).linkp;

000727  aa  6 00276 6515 00	spri5	pr6|190		lhp
						STATEMENT 1 ON LINE 363
  vlhp = lh.original_linkage_ptr;

000730  aa  5 00003 7631 00	lprp3	pr5|3		lh.original_linkage_ptr
000731  aa  6 00312 2535 00	spri3	pr6|202		vlhp
						STATEMENT 1 ON LINE 365
  if vlh.first_ref_relp = 0
    then return;

000732  aa  3 00001 2361 00	ldq  	pr3|1		vlh.first_ref_relp
000733  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000734  aa  6 00422 7561 00	stq  	pr6|274		vlh.first_ref_relp
000735  aa   000002 6010 04	tnz  	2,ic		000737
000736  aa  6 00264 6101 00	rtcd 	pr6|180
						STATEMENT 1 ON LINE 370
  frtp = addwordno (lhp, vlh.first_ref_relp);

000737  aa  5 00000 3515 06	epp1 	pr5|0,ql
000740  aa   000000 0510 03	adwp1	0,du
000741  aa  6 00300 2515 00	spri1	pr6|192		frtp
						STATEMENT 1 ON LINE 372
  if frt.decl_vers ^= FR_TRAPS_VERSION_1
    then signal object_msf_damaged_;

000742  aa  1 00000 2361 00	ldq  	pr1|0		frt.decl_vers
000743  aa   000001 1160 07	cmpq 	1,dl
000744  aa   000004 6000 04	tze  	4,ic		000750
000745  aa   000023 7260 07	lxl6 	19,dl
000746  aa   777050 3520 04	epp2 	-472,ic		000016 = 157142152145
000747  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
						STATEMENT 1 ON LINE 375
  linkp = comp (c).linkp;

000750  aa  6 00266 3735 20	epp7 	pr6|182,*
000751  aa  7 00006 2361 20	ldq  	pr7|6,*		c
000752  aa   000003 7360 00	qls  	3
000753  aa  7 00002 3715 20	epp5 	pr7|2,*		ctp
000754  aa  5 00000 3715 20	epp5 	pr5|0,*		ctp
000755  aa  5 00002 3535 26	epp3 	pr5|2,ql*		comp.linkp
000756  aa  6 00302 2535 00	spri3	pr6|194		linkp
						STATEMENT 1 ON LINE 377
  do trap = 1 to frt.n_traps;

000757  aa  6 00300 3515 20	epp1 	pr6|192,*		frtp
000760  aa  1 00001 2361 00	ldq  	pr1|1		frt.n_traps
000761  aa  6 00322 7561 00	stq  	pr6|210
000762  aa   000001 2360 07	ldq  	1,dl
000763  aa  6 00304 7561 00	stq  	pr6|196		trap
000764  aa  6 00304 2361 00	ldq  	pr6|196		trap
000765  aa  6 00322 1161 00	cmpq 	pr6|210
000766  aa   000074 6054 04	tpnz 	60,ic		001062
						STATEMENT 1 ON LINE 378
    call_ptr_ptr = addwordno (linkp, frt.trap_array (trap).call_relp);

000767  aa  6 00300 3735 20	epp7 	pr6|192,*		frtp
000770  aa  7 00001 2351 06	lda  	pr7|1,ql		frt.call_relp
000771  aa   000066 7730 00	lrl  	54
000772  aa  6 00302 3521 66	epp2 	pr6|194,*ql	linkp
000773  aa   000000 0520 03	adwp2	0,du
000774  aa  6 00272 2521 00	spri2	pr6|186		call_ptr_ptr
						STATEMENT 1 ON LINE 379
    if frt.trap_array (trap).info_relp = 0
      then info_ptr_ptr = null;

000775  aa  6 00304 7271 00	lxl7 	pr6|196		trap
000776  aa  7 00001 2361 17	ldq  	pr7|1,7		frt.info_relp
000777  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
001000  aa  6 00422 7561 00	stq  	pr6|274		frt.info_relp
001001  aa   000004 6010 04	tnz  	4,ic		001005
001002  aa   777010 2370 04	ldaq 	-504,ic		000012 = 077777000043 000001000000
001003  aa  6 00274 7571 00	staq 	pr6|188		info_ptr_ptr
001004  aa   000004 7100 04	tra  	4,ic		001010
						STATEMENT 1 ON LINE 381
      else info_ptr_ptr = addwordno (linkp, frt.trap_array (trap).info_relp);

001005  aa  6 00302 3515 66	epp1 	pr6|194,*ql	linkp
001006  aa   000000 0510 03	adwp1	0,du
001007  aa  6 00274 2515 00	spri1	pr6|188		info_ptr_ptr
						STATEMENT 1 ON LINE 382
    call hcs_$link_force (call_ptr_ptr, (0), ec);

001010  aa  6 00422 4501 00	stz  	pr6|274
001011  aa  6 00272 3521 00	epp2 	pr6|186		call_ptr_ptr
001012  aa  6 00426 2521 00	spri2	pr6|278
001013  aa  6 00422 3521 00	epp2 	pr6|274
001014  aa  6 00430 2521 00	spri2	pr6|280
001015  aa  6 00160 3521 00	epp2 	pr6|112		ec
001016  aa  6 00432 2521 00	spri2	pr6|282
001017  aa  6 00424 6211 00	eax1 	pr6|276
001020  aa   014000 4310 07	fld  	6144,dl
001021  aa  6 00044 3701 20	epp4 	pr6|36,*
001022  la  4 00020 3521 20	epp2 	pr4|16,*		hcs_$link_force
001023  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 383
    if ec ^= 0
      then signal object_msf_damaged_;

001024  aa  6 00160 2361 00	ldq  	pr6|112		ec
001025  aa   000004 6000 04	tze  	4,ic		001031
001026  aa   000023 7260 07	lxl6 	19,dl
001027  aa   776767 3520 04	epp2 	-521,ic		000016 = 157142152145
001030  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
						STATEMENT 1 ON LINE 388
    if call_ptr ^= codeptr (msf_prelink_)
      then do;

001031  aa   776775 3520 04	epp2 	-515,ic		000026 = 000440627000
001032  aa  6 00434 2521 00	spri2	pr6|284
001033  aa  6 00434 2371 00	ldaq 	pr6|284
001034  aa  6 00272 6771 20	eraq 	pr6|186,*		call_ptr
001035  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001036  aa   000022 6000 04	tze  	18,ic		001060
						STATEMENT 1 ON LINE 390
        call cu_$make_entry_value (call_ptr, trap_proc);

001037  aa  6 00272 3521 20	epp2 	pr6|186,*		call_ptr
001040  aa  6 00426 2521 00	spri2	pr6|278
001041  aa  6 00306 3521 00	epp2 	pr6|198		trap_proc
001042  aa  6 00430 2521 00	spri2	pr6|280
001043  aa  6 00424 6211 00	eax1 	pr6|276
001044  aa   010000 4310 07	fld  	4096,dl
001045  aa  6 00044 3701 20	epp4 	pr6|36,*
001046  la  4 00010 3521 20	epp2 	pr4|8,*		cu_$make_entry_value
001047  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 391
        call trap_proc (info_ptr_ptr);

001050  aa  6 00274 3521 00	epp2 	pr6|188		info_ptr_ptr
001051  aa  6 00426 2521 00	spri2	pr6|278
001052  aa   776736 3520 04	epp2 	-546,ic		000010 = 464000000000
001053  aa  6 00432 2521 00	spri2	pr6|282
001054  aa  6 00424 6211 00	eax1 	pr6|276
001055  aa   004000 4310 07	fld  	2048,dl
001056  aa  6 00306 3521 00	epp2 	pr6|198		trap_proc
001057  aa  0 00616 7001 00	tsx0 	pr0|398		call_ent_var_desc
						STATEMENT 1 ON LINE 392
      end;

						STATEMENT 1 ON LINE 393
  end;

001060  aa  6 00304 0541 00	aos  	pr6|196		trap
001061  aa   777703 7100 04	tra  	-61,ic		000764
						STATEMENT 1 ON LINE 395
  end execute_firstref_traps;

001062  aa  6 00264 6101 00	rtcd 	pr6|180
  END PROCEDURE execute_firstref_traps
  END PROCEDURE msf_prelink_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
