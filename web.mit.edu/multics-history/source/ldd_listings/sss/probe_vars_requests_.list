	COMPILATION LISTING OF SEGMENT probe_vars_requests_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 11/11/88  1547.6 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       16*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       17*     Added format control comment to make the source more readable.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       22 
       23 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       24 
       25 probe_vars_requests_:
       26   proc;
       27 
       28   /* Here we have the probe variable requests:
       29*
       30*   the 'declare' request:         dcl {NAME} TYPE {-force}
       31*   the 'list_variables' request:  lsv {NAMES}
       32*
       33*   James R. Davis Feb 80
       34*
       35**/
       36   /* Added unaligned pointers 12/04/81 S. Herbst */
       37   /* Added "external" variables 04/26/82 S. Herbst */
       38   /* Fixed "dcl" bad-type error message 07/15/82 S. Herbst */
       39   /* Implemented "dcl NAME TYPE defined EXPRESSION" 03/12/84 S. Herbst */
       40   /* Fixed bug causing auto var to not be allocated 07/09/84 S. Herbst */
       41   /* Fixed to translate "-" to "_" in COBOL identifiers when looking up in symbol table 09/20/84 Steve Herbst */
       42 
       43   dcl P_probe_info_ptr	ptr parameter;
       44 				/* input */
       45 
       46   dcl 1 ref_1		aligned like reference_node based (ref_1_ptr);
       47   dcl ref_1_ptr		ptr;
       48 
       49   dcl variable_name		char (64) varying;
       50 				/* name of var */
       51   dcl variable_type		char (64) varying;
       52 				/* what type */
       53   dcl translated_name	char (64) varying;
       54 				/* var name with "-" translated to "_" (COBOL) */
       55   dcl unaligned_sw		bit (1) aligned;
       56   dcl external_sw		bit (1) aligned;
       57   dcl force		bit (1) aligned;
       58 				/* -force ? */
       59   dcl address_type		fixed bin;
       60   dcl address_ptr		ptr;
       61   dcl code		fixed bin (35);
       62   dcl control_arg		char (64) varying;
       63 
       64   dcl symbol_ptr		ptr;	/* to symbol node of like-named var if already is one */
       65   dcl response		char (64) varying;
       66 
       67   dcl (
       68       probe_et_$bad_dcl_type,
       69       probe_et_$noarg,
       70       probe_et_$too_many_args,
       71       probe_et_$var_exists,
       72       probe_et_$var_doesnt_exist
       73       )
       74 			fixed bin (35) external static;
       75 
       76   dcl probe_create_reference_ entry (ptr, ptr);
       77   dcl probe_get_$control_arg	entry (ptr, char (64) varying, fixed bin (35));
       78   dcl probe_get_$expression	entry (ptr, 1 aligned like reference_node,
       79 			fixed bin (35));
       80   dcl probe_variable_mgr_$create_variable
       81 			entry (ptr, char (64) varying,
       82 			char (64) varying, bit (1) aligned,
       83 			fixed bin, ptr, bit (1) aligned, ptr unal,
       84 			fixed bin (35));
       85   dcl probe_variable_mgr_$list_variable
       86 			entry (ptr, char (64) varying, fixed bin (35));
       87   dcl probe_variable_mgr_$list_all_variables
       88 			entry (ptr, fixed bin (35));
       89 
       90   dcl probe_error_$warning	entry options (variable);
       91   dcl probe_error_		entry options (variable);
       92 
       93   dcl stu_$find_runtime_symbol
       94 			entry (ptr, char (*), ptr, fixed bin)
       95 			returns (ptr);
       96   dcl command_query_	entry options (variable);
       97 
       98   dcl (addr, null, translate) builtin;
       99 MAIN_RETURN:
      100   return;
      101 
      102 declare_request:
      103   entry (P_probe_info_ptr);
      104 
      105   probe_info_ptr = P_probe_info_ptr;
      106 
      107   if current_token.type >= probe_info.end_token
      108     then
      109          goto DCL_USAGE;
      110 
      111   if current_token.type ^= NAME_TYPE
      112     then goto DCL_USAGE;
      113   variable_name = current_identifier_name;
      114   call bump_ct ();
      115 
      116   external_sw, unaligned_sw = "0"b;
      117   call accept_unal_arg ();
      118 
      119   if current_token.type ^= NAME_TYPE
      120     then goto DCL_USAGE;
      121   variable_type = current_identifier_name;
      122   call bump_ct ();
      123 
      124   call accept_unal_arg ();
      125 
      126   if external_sw
      127     then address_type = ADDRESS_EXTERNAL_TYPE;
      128     else address_type = ADDRESS_ALLOC_TYPE;
      129   address_ptr = null;
      130 
      131   if probe_info.ct -> operator.type < probe_info.end_token
      132     then
      133          if probe_info.ct -> token.type = NAME_TYPE then do;
      134 	   if current_identifier_name = "defined"
      135 	        | current_identifier_name = "def" then do;
      136 	       call bump_ct ();
      137 	       if probe_info.ct -> token.type >= probe_info.end_token
      138 	         then do;
      139 		 call probe_error_ (probe_info_ptr, probe_et_$noarg);
      140 		 goto MAIN_RETURN;
      141 	         end;
      142 	       call probe_create_reference_ (probe_info_ptr, ref_1_ptr);
      143 	       call probe_get_$expression (probe_info_ptr, ref_1, code);
      144 	       if code ^= 0 then do;
      145 		 call probe_error_ (probe_info_ptr, code);
      146 		 goto MAIN_RETURN;
      147 	         end;
      148 	       address_type = ADDRESS_GIVEN_TYPE;
      149 	       address_ptr = ref_1.address_ptr;
      150 	     end;
      151 	     else go to TOO_MANY;
      152 	 end;
      153 
      154   force = "0"b;
      155   call probe_get_$control_arg (probe_info_ptr, control_arg, code);
      156   if control_arg = "force" | control_arg = "fc"
      157     then force = "1"b;
      158   else if control_arg ^= ""		/* something else */
      159     then goto DCL_USAGE;
      160 
      161   if current_token.type < probe_info.end_token
      162     then goto TOO_MANY;
      163 
      164   if unaligned_sw & variable_type ^= "pointer" & variable_type ^= "ptr"
      165     then
      166          call probe_error_ (probe_info_ptr, 0,
      167 	    "Only pointers can be declared unaligned in probe.  ^a",
      168 	    variable_name);
      169 
      170   if ^probe_info.flags.execute
      171     then goto MAIN_RETURN;
      172 
      173   if probe_info.language_type = COBOL_lang_type
      174     then translated_name = translate (variable_name, "_", "-");
      175     else translated_name = variable_name;
      176 
      177   symbol_ptr = stu_$find_runtime_symbol (current_source.block_ptr,
      178        (translated_name), (null), (0));
      179 
      180   if symbol_ptr ^= null ()
      181     then /* tell user already exists */
      182          call probe_error_$warning (probe_info_ptr, 0,
      183 	    "Warning: a program variable also named ^a is known",
      184 	    variable_name);
      185 
      186 
      187   call probe_variable_mgr_$create_variable (probe_info_ptr, variable_name,
      188        variable_type, unaligned_sw,
      189        address_type, address_ptr, force, probe_variable_ptr, code);
      190 
      191   if code = probe_et_$var_exists then do;
      192 
      193       query_info.version = query_info_version_4;
      194       query_info.switches.yes_or_no_sw = "1"b;
      195       query_info.question_iocbp = probe_info.output_switch;
      196       query_info.answer_iocbp = probe_info.input_switch;
      197 
      198       call command_query_ (addr (query_info), response, "declare",
      199 	 "A variable named ^a is already declared as ^a. Replace it?",
      200 	 variable_name, probe_variable.declared_type);
      201       if response = "no"
      202         then goto MAIN_RETURN;
      203       call probe_variable_mgr_$create_variable (probe_info_ptr, variable_name,
      204 	 variable_type, unaligned_sw,
      205 	 address_type, address_ptr, "1"b, probe_variable_ptr, code);
      206 
      207     end;
      208   if code ^= 0
      209     then
      210          if code = probe_et_$bad_dcl_type
      211 	 then call probe_error_ (probe_info_ptr, code, variable_type);
      212 	 else call probe_error_ (probe_info_ptr, code, variable_name);
      213 
      214   goto MAIN_RETURN;
      215 
      216 DCL_USAGE:
      217   call probe_error_ (probe_info_ptr, 0,
      218        "Usage: dcl NAME TYPE {-force}");
      219   goto MAIN_RETURN;
      220 
      221 
      222 list_variables_request:
      223   entry (P_probe_info_ptr);
      224 
      225   probe_info_ptr = P_probe_info_ptr;
      226   code = 0;
      227 
      228   if current_token.type < probe_info.end_token
      229     then
      230       do while (current_token.type < probe_info.end_token & code = 0);
      231       if current_token.type ^= NAME_TYPE
      232         then goto LSV_USAGE;
      233       variable_name = current_identifier_name;
      234       if probe_info.flags.execute
      235         then
      236 	   call probe_variable_mgr_$list_variable (probe_info_ptr,
      237 	        variable_name, code);
      238       if code = probe_et_$var_doesnt_exist then do;
      239 	call probe_error_$warning (probe_info_ptr, code, variable_name);
      240 	code = 0;			/* list the others, no harm in it */
      241         end;
      242 
      243       call bump_ct ();
      244     end;				/* looping thru all NAMEs */
      245   else if probe_info.flags.execute
      246     then
      247          call probe_variable_mgr_$list_all_variables (probe_info_ptr, code);
      248 
      249   if code ^= 0
      250     then call probe_error_ (probe_info_ptr, code);
      251   goto MAIN_RETURN;
      252 
      253 LSV_USAGE:
      254   call probe_error_ (probe_info_ptr, 0, "Usage: lsv {NAMES}");
      255   goto MAIN_RETURN;
      256 
      257 
      258 
      259 bump_ct:
      260   proc ();
      261   probe_info.ct = current_token.next;
      262   end bump_ct;
      263 
      264 TOO_MANY:
      265   call probe_error_ (probe_info_ptr, probe_et_$too_many_args);
      266   goto MAIN_RETURN;
      267 
      268 accept_unal_arg:
      269   proc;
      270 
      271   /* For declare request, sees if next arg is "unaligned" or "unal" and sets flag */
      272 
      273 NEXT:
      274   if probe_info.ct -> operator.type < probe_info.end_token
      275     then
      276          if probe_info.ct -> token.type = NAME_TYPE
      277 	 then
      278 	      if current_identifier_name = "external"
      279 		 | current_identifier_name = "ext" then do;
      280 		external_sw = "1"b;
      281 		call bump_ct ();
      282 		go to NEXT;
      283 	        end;
      284 	      else if (current_identifier_name = "unaligned"
      285 		 | current_identifier_name = "unal") then do;
      286 		unaligned_sw = "1"b;
      287 		call bump_ct ();
      288 		go to NEXT;
      289 	        end;
      290   end accept_unal_arg;
      291 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      292 
      293 
  2     1 /* BEGIN INCLUDE FILE  ... probe_lang_types.incl.pl1
  2     2*
  2     3*   JRD 26 June 79
  2     4*   MBW 31 July 1981 to add algol68 */
  2     5 
  2     6 
  2     7 /****^  HISTORY COMMENTS:
  2     8*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  2     9*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  2    10*     Added C Language type.
  2    11*                                                   END HISTORY COMMENTS */
  2    12 
  2    13 
  2    14 /*   Modified June 83 JMAthane to add PASCAL language type */
  2    15 /*   Modified April 88 Hinatsu to add C language type */
  2    16 
  2    17      dcl	   (UNKNOWN_lang_type     init (1),
  2    18 	   OTHER_lang_type	      init (2),
  2    19 	   PL1_lang_type	      init (3),
  2    20 	   FORTRAN_lang_type      init (4),
  2    21 	   COBOL_lang_type	      init (5),
  2    22 	   ALM_lang_type	      init (6),
  2    23 	   ALGOL68_lang_type      init (7),
  2    24 	   PASCAL_lang_type	      init (8),
  2    25 	   C_lang_type	      init (9)) fixed bin internal static options (constant);
  2    26 
  2    27      dcl	   official_language_names (9) char (32) internal static options (constant) init
  2    28 			      ("Unknown", "other", "PL/I", "FORTRAN", "COBOL", "ALM", "Algol 68", "Pascal", "C");
  2    29 
  2    30      dcl	   palatable_language_names (9) char (32) internal static options (constant) init
  2    31 			      ("Unknown", "Other", "pl1", "fortran", "cobol", "alm", "algol68", "pascal", "c");
  2    32 
  2    33 /* END INCLUDE FILE ... probe_lang_types.incl.pl1 */
      294 
      295 
  3     1 /*	BEGIN INCLUDE FILE probe_references.incl.pl1	*/
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  3     5*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  3     6*     Added new field (c_symbol) for C-Probe support.
  3     7*  2) change(88-10-28,WAAnderson), approve(88-10-28,MCR7952),
  3     8*     audit(88-10-31,RWaters), install(88-11-11,MR12.2-1210):
  3     9*     Added new field (c_sub_c_ptr) for C-Probe_support.
  3    10*                                                   END HISTORY COMMENTS */
  3    11 
  3    12 /*	Split out of probe_tokens, 04/22/79 WOS 	*/
  3    13 /*       modified for probe variables Feb 19 80 JRD         */
  3    14 /*   Modified June 83 JMAthane to add "type_ptr" and "builtin" fields */
  3    15 
  3    16      dcl	   1 reference_node	      aligned based,	/* information about a reference */
  3    17 	     2 symbol_ptr	      pointer aligned,	/* to symbol table entry for reference */
  3    18 	     2 type_ptr	      pointer aligned,	/* to symbol table entry for type (null if none) */
  3    19 	     2 address_ptr	      pointer aligned,	/* to location of variable */
  3    20 	     2 base_addr	      pointer aligned,	/* pointer on which whole symbol is based */
  3    21 	     2 source_info_ptr    pointer aligned,	/* to symbol structure for reference */
  3    22 
  3    23 	     2 name	      char (256) unaligned varying, /* symbol name */
  3    24 
  3    25 	     2 type	      fixed bin (35),	/* data type */
  3    26 	     2 descriptor	      fixed bin (35),	/* type || packed */
  3    27 	     2 precision	      fixed bin (35),	/* scale and precision */
  3    28 	     2 flags,
  3    29 	       3 packed	      bit (1) unal,		/* data is in packed format */
  3    30 	       3 constant	      bit (1) unal,		/* data is really a constant */
  3    31 	       3 cross_section    bit (1) unal,		/* reference is an array cross-section */
  3    32 	       3 function	      bit (1) unal,		/* reference is function value */
  3    33 	       3 octal	      bit (1) unal,		/* indicates that this is the octal bif */
  3    34 	       3 star_extent      bit (1) unal,		/* reference is a star subscript for father */
  3    35 	       3 have_generation  bit (1) unal,		/* this reference has an explicitly specified generation */
  3    36 	       3 pseudo_var	      bit (1) unal,		/* it is ok to assign to it */
  3    37 	       3 probe_variable   bit (1) unal,
  3    38 	       3 path	      bit (1) unal,		/* it's a pathname/virtual entry */
  3    39 	       3 builtin	      bit (1) unal,		/* probe builtinvalue */
  3    40 	       3 c_ptr_to_char    bit (1)  unal,
  3    41                  3 c_sub_c_ptr      bit (1)  unal,
  3    42 	       3 pad2	      bit (23) unal,
  3    43 
  3    44 	     2 optional_info,			/* information which may or may not be present */
  3    45 	       3 argument_list    pointer unaligned,	/* pointer to reference_arg_list */
  3    46 	       3 subscript_ptr    pointer unaligned,	/* pointer to reference_subscripts */
  3    47 	       3 n_arguments      fixed bin,		/* number of arguments in argument list */
  3    48 	       3 n_subscripts     fixed bin,		/* number of subscripts present */
  3    49 
  3    50 	     2 constant_token_ptr pointer unaligned,	/* pointer to constant token if this is a constant */
  3    51 	     2 subscript_refs_ptr pointer unaligned,	/* pointer to array of subscript reference node pointers */
  3    52 	     2 invocation_level   fixed bin,		/* invocation level number ("[-17]") for this reference */
  3    53 	     2 probe_var_info_ptr ptr unal,		/* only if flags.probe_variable */
  3    54                2 c_symbol_ptr  ptr unal,
  3    55 	     2 pad1	      (9) pointer unaligned,
  3    56 	     2 end_of_reference_node pointer aligned;
  3    57 
  3    58 
  3    59      dcl	   1 reference_arg_list   aligned based,	/* argument list; based on reference.argument_list */
  3    60 	     2 number	      fixed bin,		/* number of arguments actually present */
  3    61 	     2 node	      (16) pointer aligned;	/* reference node pointers for each argument */
  3    62 
  3    63 
  3    64      dcl	   1 reference_subscripts aligned based,	/* subscript array; based on reference.subscript_ptr */
  3    65 	     2 number	      fixed bin,		/* number actually present */
  3    66 	     2 value	      (2, 16) fixed bin (24); /* values for lower and upper bound for each */
  3    67 
  3    68 
  3    69      dcl	   1 subscript_reference_ptrs aligned based,	/* array of pointers to subscript reference nodes */
  3    70 	     2 ptr	      (2, 16) pointer aligned;
  3    71 
  3    72 /*	END INCLUDE FILE probe_references.incl.pl1	*/
      296 
      297 
  4     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  4     2*
  4     3*  James R. Davis 2 July 79 */
  4     4 
  4     5 dcl 1 source_info based aligned,
  4     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  4     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  4     8       2 block_ptr ptr,				/* to runtime_block node */
  4     9       2 stack_ptr ptr,				/* to a stack frame */
  4    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  4    11       2 seg_info_ptr ptr;				/* to seg_info */
  4    12 
  4    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  4    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  4    15 
  4    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      298 
      299 
  5     1 /*	BEGIN INCLUDE FILE probe_tokens.incl.pl1	*/
  5     2 /*	Split up into probe_tokens and probe_references, 04/22/79 WOS */
  5     3 
  5     4 dcl 1 token_header aligned based,			/* header information common to all tokens */
  5     5     2 next pointer unaligned,				/* pointer to next token in chain */
  5     6     2 prev pointer unaligned,				/* same for previous token */
  5     7     2 type bit (18) aligned,
  5     8     2 buffer_ptr pointer unaligned,			/* pointer to beginning of input buffer */
  5     9     2 location fixed bin (17) unal,			/* offset in input buffer */
  5    10     2 length fixed bin (17) unal,
  5    11     2 flags aligned,
  5    12      (3 leading_whitespace,				/* there is whitespace before thios token */
  5    13       3 trailing_whitespace) bit (1) unaligned,		/* and same for after */
  5    14       3 pad1 bit (34) unaligned;
  5    15 
  5    16 dcl 1 token aligned based,				/* produced by scan_probe_input_ */
  5    17     2 header aligned like token_header;			/* that's all there is */
  5    18 
  5    19 dcl 1 identifier aligned based,			/* keyword or identifier token */
  5    20     2 header aligned like token_header,
  5    21     2 length fixed bin,				/* length of name */
  5    22     2 name pointer unaligned;				/* to string in buffer containing name */
  5    23 
  5    24 dcl 1 operator aligned based,				/* for punctuation */
  5    25     2 header aligned like token_header;			/* nothing but a header here */
  5    26 
  5    27 dcl 1 constant aligned based,				/* for strings pointers numbers etc */
  5    28     2 header aligned like token_header,
  5    29     2 encoded_precision aligned,			/* encoded precision kludge for assign_ */
  5    30       3 scale fixed bin (17) unaligned,			/* arithmetic scale */
  5    31       3 precision fixed bin (17) unaligned,		/* arithmetic precision or other size */
  5    32     2 scale_and_precision fixed bin (35),		/* An identical copy of the two values above */
  5    33     2 data_type fixed bin,				/* standard data type code + packed bit */
  5    34     2 data_ptr pointer unaligned;
  5    35 
  5    36 
  5    37 dcl (OPERATOR_TYPE init ("100"b),			/* types for above */
  5    38      NAME_TYPE init ("010"b),
  5    39      CONSTANT_TYPE init ("001"b)) bit (18) internal static options (constant);
  5    40 
  5    41 
  5    42 dcl  current_identifier_name				/* Overlays for looking at the current tokens */
  5    43      char (probe_info.ct -> identifier.length) based (probe_info.ct -> identifier.name);
  5    44 dcl 1 current_constant aligned like constant based (probe_info.ct);
  5    45 dcl 1 current_token aligned like token based (probe_info.ct);
  5    46 
  5    47 /*	END INCLUDE FILE probe_tokens.incl.pl1		*/
      300 
      301 
  6     1 /* BEGIN INCLUDE FILE ... probe_var_info.incl.pl 
  6     2*
  6     3*   describes a probe variable.  This str pointed to by the probe_var_info_ptr
  6     4*   of a reference node.
  6     5*   Jim Davis 19 Feb 80
  6     6**/
  6     7 
  6     8 
  6     9 /****^  HISTORY COMMENTS:
  6    10*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  6    11*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  6    12*     Added info for new types used by C.
  6    13*                                                   END HISTORY COMMENTS */
  6    14 
  6    15 
  6    16 /* Added probe_variable.unaligned_sw and pointer_unal type 12/04/81 S. Herbst */
  6    17 /* Added address-type constants (ADDRESS_ALLOC_TYPE, etc.) 03/12/84 S. Herbst */
  6    18 
  6    19 dcl (ADDRESS_ALLOC_TYPE init (1),
  6    20      ADDRESS_EXTERNAL_TYPE init (2),
  6    21      ADDRESS_GIVEN_TYPE init (3)) fixed bin int static options (constant);
  6    22 
  6    23 dcl 1 probe_variable aligned based (probe_variable_ptr),
  6    24       2 next ptr unal,			         /* threaded */
  6    25       2 name char (64) varying,
  6    26       2 declared_type char (64) varying,	         /* what user TYPE */
  6    27       2 type fixed bin,			         /* Multics type */
  6    28       2 unaligned_sw bit (1) aligned,
  6    29       2 address ptr unal,			         /* to the data */
  6    30       2 pad (5) ptr unal;
  6    31 
  6    32 dcl probe_variable_integer fixed bin (35) based (probe_variable.address);
  6    33 dcl probe_variable_pointer pointer aligned based (probe_variable.address);
  6    34 dcl probe_variable_pointer_unal pointer unaligned based (probe_variable.address);
  6    35 dcl probe_variable_float float bin (27) based (probe_variable.address);
  6    36 dcl probe_variable_char  char(1) based (probe_variable.address);
  6    37 dcl probe_variable_double float bin (63) based (probe_variable.address);
  6    38 dcl probe_variable_long fixed bin(71) based (probe_variable.address);
  6    39 
  6    40 dcl probe_variable_ptr pointer unal;
  6    41 
  6    42 /* END INCLUDE FILE ... probe_var_info.incl.pl1 */
  6    43 
      302 
      303 
  7     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  7     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  7     3 /*	version number changed to 4, 08/10/78 WOS */
  7     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  7     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  7     6 
  7     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  7     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  7     9     2 switches aligned,                                     /* various bit switch values */
  7    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  7    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  7    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  7    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  7    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  7    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  7    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  7    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  7    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  7    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  7    20 
  7    21 /*  Limit of data defined for version 2 */
  7    22 
  7    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  7    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  7    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  7    26 						/* minimum of 30 seconds required for repeat */
  7    27 						/* otherwise, no repeat will occur */
  7    28 /* Limit of data defined for version 4 */
  7    29 
  7    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  7    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  7    32 
  7    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  7    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  7    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  7    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  7    37 
  7    38 /*	END INCLUDE FILE query_info.incl.pl1 */
      304 
      305 
      306 
      307   end probe_vars_requests_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/88  1545.0  probe_vars_requests_.pl1          >spec>install>MR12.2-1210>probe_vars_requests_.pl1
292          1    10/27/88  1339.2  probe_info.incl.pl1               >ldd>include>probe_info.incl.pl1
294          2    10/26/88  1255.5  probe_lang_types.incl.pl1         >ldd>include>probe_lang_types.incl.pl1
296          3    11/11/88  1543.8  probe_references.incl.pl1         >spec>install>MR12.2-1210>probe_references.incl.pl1
298          4    11/26/79  1320.6  probe_source_info.incl.pl1        >ldd>include>probe_source_info.incl.pl1
300          5    11/26/79  1320.6  probe_tokens.incl.pl1             >ldd>include>probe_tokens.incl.pl1
302          6    10/26/88  1255.5  probe_var_info.incl.pl1           >ldd>include>probe_var_info.incl.pl1
304          7    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ADDRESS_ALLOC_TYPE                     constant        fixed bin(17,0)          initial dcl 6-19 ref 128
ADDRESS_EXTERNAL_TYPE                  constant        fixed bin(17,0)          initial dcl 6-19 ref 126
ADDRESS_GIVEN_TYPE                     constant        fixed bin(17,0)          initial dcl 6-19 ref 148
COBOL_lang_type                        constant        fixed bin(17,0)          initial dcl 2-17 ref 173
NAME_TYPE                              constant        bit(18)                  initial packed unaligned dcl 5-37 ref 111 119 131
                                                                                  231 273
P_probe_info_ptr                       parameter       pointer                  dcl 43 ref 102 105 222 225
addr                                                   builtin function         dcl 98 ref 198 198
address_ptr               4            based           pointer                  level 2 in structure "ref_1" dcl 46 in procedure
                                                                                  "probe_vars_requests_" set ref 149
address_ptr                     000172 automatic       pointer                  dcl 60 in procedure "probe_vars_requests_" set ref
                                                                                  129* 149* 187* 203*
address_type                    000170 automatic       fixed bin(17,0)          dcl 59 set ref 126* 128* 148* 187* 203*
answer_iocbp              6     000246 automatic       pointer                  initial level 2 dcl 7-7 set ref 196* 7-7*
block_ptr                 4            based           pointer                  level 2 dcl 4-13 set ref 177*
code                            000174 automatic       fixed bin(35,0)          dcl 61 set ref 143* 144 145* 155* 187* 191 203* 208
                                                                                  208 208* 212* 226* 228 234* 238 239* 240* 245* 249
                                                                                  249*
command_query_                  000044 constant        entry                    external dcl 96 ref 198
constant                               based           structure                level 1 dcl 5-27
control_arg                     000175 automatic       varying char(64)         dcl 62 set ref 155* 156 156 158
cp_escape_control         1(02) 000246 automatic       bit(2)                   initial level 3 packed packed unaligned dcl 7-7 set
                                                                                  ref 7-7*
ct                       13            based           pointer                  level 3 packed packed unaligned dcl 1-18 set ref 107
                                                                                  111 113 113 119 121 121 131 131 134 134 134 134
                                                                                  137 161 228 228 231 233 233 261* 261 273 273 273
                                                                                  273 273 273 284 284 284 284
current_identifier_name                based           char                     packed unaligned dcl 5-42 ref 113 121 134 134 233
                                                                                  273 273 284 284
current_source                         based           structure                level 1 dcl 4-13
current_token                          based           structure                level 1 dcl 5-45
declared_type            22            based           varying char(64)         level 2 dcl 6-23 set ref 198*
end_token                14            based           bit(18)                  level 3 dcl 1-18 ref 107 131 137 161 228 228 273
execute                  64            based           bit(1)                   level 3 packed packed unaligned dcl 1-18 ref 170 234
                                                                                  245
explanation_len          14     000246 automatic       fixed bin(21,0)          initial level 2 dcl 7-7 set ref 7-7*
explanation_ptr          12     000246 automatic       pointer                  initial level 2 dcl 7-7 set ref 7-7*
external_sw                     000166 automatic       bit(1)                   dcl 56 set ref 116* 126 280*
flags                    64            based           structure                level 2 dcl 1-18
force                           000167 automatic       bit(1)                   dcl 57 set ref 154* 156* 187*
header                                 based           structure                level 2 in structure "operator" dcl 5-24
                                                                                  in procedure "probe_vars_requests_"
header                                 based           structure                level 2 in structure "current_token" dcl 5-45
                                                                                  in procedure "probe_vars_requests_"
header                                 based           structure                level 2 in structure "token" dcl 5-16 in procedure
                                                                                  "probe_vars_requests_"
identifier                             based           structure                level 1 dcl 5-19
input_switch             66            based           pointer                  level 3 dcl 1-18 ref 196
io_switches              66            based           structure                level 2 dcl 1-18
language_type            21            based           fixed bin(17,0)          level 3 dcl 1-18 ref 173
length                    6            based           fixed bin(17,0)          level 2 dcl 5-19 ref 113 121 134 134 233 273 273 284
                                                                                  284
literal_sw                1(05) 000246 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 7-7 set
                                                                                  ref 7-7*
name                      7            based           pointer                  level 2 packed packed unaligned dcl 5-19 ref 113 121
                                                                                  134 134 233 273 273 284 284
next                                   based           pointer                  level 3 packed packed unaligned dcl 5-45 ref 261
null                                                   builtin function         dcl 98 ref 129 177 180 7-7 7-7 7-7
operator                               based           structure                level 1 dcl 5-24
output_switch            70            based           pointer                  level 3 dcl 1-18 ref 195
padding                   1(07) 000246 automatic       bit(29)                  initial level 3 packed packed unaligned dcl 7-7 set
                                                                                  ref 7-7*
probe_create_reference_         000022 constant        entry                    external dcl 76 ref 142
probe_error_                    000040 constant        entry                    external dcl 91 ref 139 145 164 208 212 216 249 253
                                                                                  264
probe_error_$warning            000036 constant        entry                    external dcl 90 ref 180 239
probe_et_$bad_dcl_type          000010 external static fixed bin(35,0)          dcl 67 ref 208
probe_et_$noarg                 000012 external static fixed bin(35,0)          dcl 67 set ref 139*
probe_et_$too_many_args         000014 external static fixed bin(35,0)          dcl 67 set ref 264*
probe_et_$var_doesnt_exist      000020 external static fixed bin(35,0)          dcl 67 ref 238
probe_et_$var_exists            000016 external static fixed bin(35,0)          dcl 67 ref 191
probe_get_$control_arg          000024 constant        entry                    external dcl 77 ref 155
probe_get_$expression           000026 constant        entry                    external dcl 78 ref 143
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000242 automatic       pointer                  dcl 1-86 set ref 105* 107 107 111 113 113 119 121
                                                                                  121 131 131 131 134 134 134 134 137 137 139* 142*
                                                                                  143* 145* 155* 161 161 164* 170 173 177 180* 187*
                                                                                  195 196 203* 208* 212* 216* 225* 228 228 228 228
                                                                                  231 233 233 234 234* 239* 245 245* 249* 253* 261
                                                                                  261 264* 273 273 273 273 273 273 273 284 284 284
                                                                                  284
probe_variable                         based           structure                level 1 dcl 6-23
probe_variable_mgr_$create_variable
                                000030 constant        entry                    external dcl 80 ref 187 203
probe_variable_mgr_$list_all_variables
                                000034 constant        entry                    external dcl 87 ref 245
probe_variable_mgr_$list_variable
                                000032 constant        entry                    external dcl 85 ref 234
probe_variable_ptr              000244 automatic       pointer                  packed unaligned dcl 6-40 set ref 187* 198 203*
prompt_after_explanation
                          1(06) 000246 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 7-7 set
                                                                                  ref 7-7*
ptr_to_current_source
                          4            based           pointer                  level 2 dcl 1-18 ref 177
query_code                3     000246 automatic       fixed bin(35,0)          initial level 2 dcl 7-7 set ref 7-7*
query_info                      000246 automatic       structure                level 1 dcl 7-7 set ref 198 198
query_info_version_4                   constant        fixed bin(17,0)          initial dcl 7-34 ref 193
question_iocbp            4     000246 automatic       pointer                  initial level 2 dcl 7-7 set ref 195* 7-7*
random_info              17            based           structure                level 2 dcl 1-18
ref_1                                  based           structure                level 1 dcl 46 set ref 143*
ref_1_ptr                       000100 automatic       pointer                  dcl 47 set ref 142* 143 149
reference_node                         based           structure                level 1 dcl 3-16
repeat_time              10     000246 automatic       fixed bin(71,0)          initial level 2 dcl 7-7 set ref 7-7*
response                        000220 automatic       varying char(64)         dcl 65 set ref 198* 201
source_info                            based           structure                level 1 dcl 4-5
status_code               2     000246 automatic       fixed bin(35,0)          initial level 2 dcl 7-7 set ref 7-7*
stu_$find_runtime_symbol        000042 constant        entry                    external dcl 93 ref 177
suppress_name_sw          1(01) 000246 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 7-7 set
                                                                                  ref 7-7*
suppress_spacing          1(04) 000246 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 7-7 set
                                                                                  ref 7-7*
switches                  1     000246 automatic       structure                level 2 dcl 7-7
symbol_ptr                      000216 automatic       pointer                  dcl 64 set ref 177* 180
token                                  based           structure                level 1 dcl 5-16
token_header                           based           structure                level 1 dcl 5-4
token_info               12            based           structure                level 2 dcl 1-18
translate                                              builtin function         dcl 98 ref 173
translated_name                 000144 automatic       varying char(64)         dcl 53 set ref 173* 175* 177
type                      2            based           bit(18)                  level 3 in structure "token" dcl 5-16 in procedure
                                                                                  "probe_vars_requests_" ref 131 137 273
type                      2            based           bit(18)                  level 3 in structure "current_token" dcl 5-45
                                                                                  in procedure "probe_vars_requests_" ref 107 111
                                                                                  119 161 228 228 231
type                      2            based           bit(18)                  level 3 in structure "operator" dcl 5-24
                                                                                  in procedure "probe_vars_requests_" ref 131 273
unaligned_sw                    000165 automatic       bit(1)                   dcl 55 set ref 116* 164 187* 203* 286*
variable_name                   000102 automatic       varying char(64)         dcl 49 set ref 113* 164* 173 175 180* 187* 198* 203*
                                                                                  212* 233* 234* 239*
variable_type                   000123 automatic       varying char(64)         dcl 51 set ref 121* 164 164 187* 203* 208*
version                         000246 automatic       fixed bin(17,0)          level 2 dcl 7-7 set ref 193*
yes_or_no_sw              1     000246 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 7-7 set
                                                                                  ref 194* 7-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALGOL68_lang_type                      internal static fixed bin(17,0)          initial dcl 2-17
ALM_lang_type                          internal static fixed bin(17,0)          initial dcl 2-17
CONSTANT_TYPE                          internal static bit(18)                  initial packed unaligned dcl 5-37
C_lang_type                            internal static fixed bin(17,0)          initial dcl 2-17
FORTRAN_lang_type                      internal static fixed bin(17,0)          initial dcl 2-17
OPERATOR_TYPE                          internal static bit(18)                  initial packed unaligned dcl 5-37
OTHER_lang_type                        internal static fixed bin(17,0)          initial dcl 2-17
PASCAL_lang_type                       internal static fixed bin(17,0)          initial dcl 2-17
PL1_lang_type                          internal static fixed bin(17,0)          initial dcl 2-17
UNKNOWN_lang_type                      internal static fixed bin(17,0)          initial dcl 2-17
current_constant                       based           structure                level 1 dcl 5-44
expression_area                        based           area(1024)               dcl 1-95
initial_source                         based           structure                level 1 dcl 4-14
official_language_names                internal static char(32)                 initial array packed unaligned dcl 2-27
palatable_language_names               internal static char(32)                 initial array packed unaligned dcl 2-30
probe_area                             based           area(1024)               dcl 1-93
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
probe_variable_char                    based           char(1)                  packed unaligned dcl 6-36
probe_variable_double                  based           float bin(63)            dcl 6-37
probe_variable_float                   based           float bin(27)            dcl 6-35
probe_variable_integer                 based           fixed bin(35,0)          dcl 6-32
probe_variable_long                    based           fixed bin(71,0)          dcl 6-38
probe_variable_pointer                 based           pointer                  dcl 6-33
probe_variable_pointer_unal            based           pointer                  packed unaligned dcl 6-34
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 7-33
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 7-35
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 7-36
reference_arg_list                     based           structure                level 1 dcl 3-59
reference_subscripts                   based           structure                level 1 dcl 3-64
scratch_area                           based           area(1024)               dcl 1-92
subscript_reference_ptrs               based           structure                level 1 dcl 3-69
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
DCL_USAGE                       001072 constant        label                    dcl 216 ref 107 111 119 158
LSV_USAGE                       001270 constant        label                    dcl 253 ref 231
MAIN_RETURN                     000172 constant        label                    dcl 99 ref 140 146 170 201 214 219 251 255 266
NEXT                            001344 constant        label                    dcl 273 ref 282 288
TOO_MANY                        001316 constant        label                    dcl 264 ref 134 161
accept_unal_arg                 001343 constant        entry                    internal dcl 268 ref 117 124
bump_ct                         001334 constant        entry                    internal dcl 259 ref 114 122 136 243 281 287
declare_request                 000176 constant        entry                    external dcl 102
list_variables_request          001122 constant        entry                    external dcl 222
probe_vars_requests_            000164 constant        entry                    external dcl 25

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2056        2124    1622        2066
Length      2472    1622        46         331     233           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_vars_requests_                294 external procedure  is an external procedure.  
bump_ct                                 internal procedure  shares stack frame of external procedure probe_vars_requests_.  
accept_unal_arg                         internal procedure  shares stack frame of external procedure probe_vars_requests_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_vars_requests_     000100 ref_1_ptr                   probe_vars_requests_
                         000102 variable_name               probe_vars_requests_
                         000123 variable_type               probe_vars_requests_
                         000144 translated_name             probe_vars_requests_
                         000165 unaligned_sw                probe_vars_requests_
                         000166 external_sw                 probe_vars_requests_
                         000167 force                       probe_vars_requests_
                         000170 address_type                probe_vars_requests_
                         000172 address_ptr                 probe_vars_requests_
                         000174 code                        probe_vars_requests_
                         000175 control_arg                 probe_vars_requests_
                         000216 symbol_ptr                  probe_vars_requests_
                         000220 response                    probe_vars_requests_
                         000242 probe_info_ptr              probe_vars_requests_
                         000244 probe_variable_ptr          probe_vars_requests_
                         000246 query_info                  probe_vars_requests_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
command_query_                probe_create_reference_       probe_error_                  probe_error_$warning
probe_get_$control_arg        probe_get_$expression         probe_variable_mgr_$create_variable
probe_variable_mgr_$list_all_variables                      probe_variable_mgr_$list_variable
stu_$find_runtime_symbol

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
probe_et_$bad_dcl_type        probe_et_$noarg               probe_et_$too_many_args       probe_et_$var_doesnt_exist
probe_et_$var_exists




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 7    7 000131        25 000163        99 000172       102 000173       105 000204       107 000210       111 000214
    113 000216       114 000227       116 000230       117 000232       119 000233       121 000240       122 000251
    124 000252       126 000253       128 000260       129 000262       131 000264       134 000275       136 000311
    137 000312       139 000320       140 000335       142 000336       143 000347       144 000362       145 000364
    146 000401       148 000402       149 000404       154 000407       155 000410       156 000423       158 000440
    161 000445       164 000453       170 000521       173 000525       175 000547       177 000555       180 000620
    187 000656       191 000705       193 000711       194 000713       195 000715       196 000720       198 000723
    201 000765       203 000772       208 001023       212 001051       214 001071       216 001072       219 001117
    222 001120       225 001130       226 001134       228 001135       231 001152       233 001155       234 001166
    238 001204       239 001210       240 001230       243 001231       244 001232       245 001234       249 001250
    251 001267       253 001270       255 001315       264 001316       266 001333       259 001334       261 001335
    262 001342       268 001343       273 001344       280 001371       281 001373       282 001374       284 001375
    286 001405       287 001407       288 001410       290 001411


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
