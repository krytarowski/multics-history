	COMPILATION LISTING OF SEGMENT base_man
	Compiled by: Multics PL/I Compiler, Release 28d, of September 14, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 10/03/83  1623.0 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* format: style3 */
        9 /* Procedure to manage base registers
       10*
       11*   The contents of the base registers are determined by the value
       12*   of the type field as follows (P = variable field, N = constant field)
       13*
       14*          0         EMPTY
       15*          1         value of reference specified by P
       16*          2         address of reference specified by P
       17*          3         value of ptr contained at N in current stack
       18*          4         ptr to display for block N levels back
       19*          5         ptr to linkage section
       20*          6         arg ptr for block P
       21*          7         desc ptr for block P
       22*          8         ptr thru link with offset N
       23*          9         ptr to arg N in block P
       24*         10         ptr to desc N in block P
       25*         11         ptr to data of ext ctl variable with link N
       26*         12         ptr to desc of ext ctl variable with link N
       27*         13         ptr to static section
       28*         14         ptr through ptr in static with offset N
       29*
       30*   Initial Version: 16 April 1971 by BLW
       31*          Modified:  11 May 1973 by RAB  for multiple base regs
       32*          Modified: 19 June 1973 by RAB for EIS
       33*          Modified: 19 July 1974 by RAB to load arg ptr in any reg
       34*          Modified: 4 June 1975 by RAB for separate_static
       35*          Modified: 20 August 1976 by RAB to fix 1512
       36*          Modified: 22 January 1979 by RAB to fix 1814 (ERROR 313 for multiple
       37*                    occurrences of based packed qualifier in if stmt)
       38*                    prepare_operand now sets reference.evaluated after call to
       39*                    base_man$load_packed
       40*          Modified: 23 April 1979 by PCK to implement 4-bit decimal
       41*          Modified: 2 September 1982 by BIM for load_aq_var
       42*	Modified: June 1983 BIM for ref count fixes.
       43**/
       44 
       45 base_man$load_any_var:
       46      proc (code, var, base3);
       47 
       48 dcl       code                fixed bin,                    /* how to load */
       49           var                 ptr,                          /* ptr to ref */
       50           base3               bit (3) aligned;              /* set to base loaded */
       51 
       52 dcl       (i, j, k, n, text_pos, type, ca_code)
       53                               fixed bin,
       54           (vp, p, q)          ptr,
       55           (
       56           cg_stat$cur_level,
       57           cg_stat$text_pos,
       58           cg_stat$last_base_used
       59           )                   fixed bin ext,
       60           cg_stat$separate_static
       61                               bit (1) aligned ext static,
       62           (
       63           cg_stat$text_base,
       64           cg_stat$cur_statement
       65           )                   ptr ext static,
       66           (addressable, atomic)
       67                               bit (1) aligned,
       68           eis                 bit (1) aligned,
       69           lock                bit (1) aligned init ("0"b),
       70           tag_hold            bit (6) aligned,
       71           fract_offset        fixed bin,
       72           xr                  fixed bin (3),
       73           base                bit (3) aligned,
       74           full_word           bit (36) aligned based,
       75           macro               fixed bin (15),
       76           load                entry (ptr, fixed bin),
       77           prepare_operand     entry (ptr, fixed bin, bit (1) aligned) returns (ptr),
       78           copy_temp           entry (ptr) returns (ptr),
       79           base_to_core        entry (fixed bin, ptr),
       80           base_man$load_var   entry (fixed bin, ptr, fixed bin),
       81           base_man$load_display
       82                               entry (fixed bin, bit (3) aligned),
       83           base_man$load_linkage
       84                               entry (bit (3) aligned),
       85           base_man$load_arg   entry (fixed bin, ptr, bit (3) aligned),
       86           base_man$load_any_var
       87                               entry (fixed bin, ptr, bit (3) aligned),
       88           base_man$load_link_indirect
       89                               entry (fixed bin, bit (12) aligned, bit (3) aligned),
       90           xr_man$load_any_const
       91                               entry (fixed bin, fixed bin (3)),
       92           xr_man$add_any_const
       93                               entry (fixed bin, fixed bin (3), fixed bin (3)),
       94           m_a                 entry (ptr, bit (2) aligned),
       95           c_a                 entry (fixed bin, fixed bin) returns (ptr),
       96           compile_exp$save    entry (ptr) returns (ptr),
       97           get_reference       entry () returns (ptr),
       98           adjust_ref_count    entry (ptr, fixed bin),
       99           expmac              entry (fixed bin (15), ptr),
      100           expmac$zero         entry (fixed bin (15)),
      101           error               entry (fixed bin, ptr, ptr);
      102 
      103 declare   new_base            bit (3) aligned;
      104 declare   a_q_aq              fixed bin;                    /* Zero, one, two */
      105 declare   want_a_PR           bit (1) aligned init ("1"b);
      106 
      107 dcl       (abs, addrel, bit, fixed, mod, null, string, substr)
      108                               builtin;
      109 
      110 dcl       (
      111           first_base          init (3),
      112           last_base           init (6)
      113           )                   fixed bin (3) int static options (constant);
      114 
      115 dcl       (
      116           load_base           (0:1, 6) init (60, 361, 618, 619, 620, 621,
      117                                                             /* unpacked */
      118                               636, 637, 638, 639, 640, 641),/* packed */
      119           store_base          (23:24, 6) init (61, 409, 622, 623, 624, 625,
      120                                                             /* unpacked */
      121                               630, 631, 632, 633, 634, 635) /* packed */
      122           )                   fixed bin (15) int static options (constant);
      123 
      124 
      125 declare   e_a_q_aq_mac        (0:2) init (370, 371, 376) fixed bin (15) int static options (constant);
      126 
      127 dcl       add_base            (3) init (643, 736, 644) fixed bin (15) int static options (constant);
      128 
      129 dcl       (
      130           load_bp             init (60),
      131           store_bp            init (61),
      132           load_lp             init (361),
      133           packed_into_bp      init (584),
      134           stfx1               init (15),
      135           load_link_ptr       init (283)
      136           )                   fixed bin (15) int static options (constant);
      137 
      138 dcl       stack_info          (0:1) fixed bin int static options (constant) init (26,
      139                                                             /* stack offset of arg list */
      140                               34);                          /* stack offset of desc list */
      141 
      142 dcl       link_info           (0:1) fixed bin int static options (constant) init (36,
      143                                                             /* stack offset of linkage ptr */
      144                               28);                          /* stack offset of static ptr */
      145 
      146 dcl       display_offset      fixed bin int static init (32) options (constant);
      147 
  1     1 /* BEGIN INCLUDE FILE ... op_codes.incl.pl1 */
  1     2 
  1     3 /* Modified: 25 Apr 1979 by PCK 4-bit decimal */
  1     4 /* Modified: 6 Jun 1979 by PG to add rank and byte */
  1     5 /* Modified: 26 Dec 1979 by PCK to add assign_by_name */
  1     6 /* Modified: 26 July 82 BIM wordno, segno */
  1     7 
  1     8 dcl (	add		initial("000010001"b),	/* opnd(1) <- opnd(2)+opnd(3)		*/
  1     9 	sub		initial("000010010"b),	/* opnd(1) <- opnd(2)-opnd(3)		*/
  1    10 	mult		initial("000010011"b),	/* opnd(1) <- opnd(2)*opnd(3)		*/
  1    11 	div		initial("000010100"b),	/* opnd(1) <- opnd(2)/opnd(3)		*/
  1    12 	negate		initial("000010101"b),	/* opnd(1) <- -opnd(2)  		*/
  1    13 	exp		initial("000010110"b),	/* opnd(1) <- opnd(2) ** opnd(3)	*/
  1    14 
  1    15 	and_bits		initial("000100001"b),	/* opnd(1) <- opnd(2) & opnd(3)	*/
  1    16 	or_bits		initial("000100010"b),	/* opnd(1) <- opnd(2)|opnd(3)		*/
  1    17 	xor_bits		initial("000100011"b),	/* opnd(1) <- opnd(2) xor opnd(3)	*/
  1    18 	not_bits		initial("000100100"b),	/* opnd(1) <- ^opnd(2)		*/
  1    19 	cat_string	initial("000100101"b),	/* opnd(1) <- opnd(2)||opnd(3)	*/
  1    20 	bool_fun		initial("000100110"b),	/* opnd(1) <- bool(opnd(2),opnd(3),opnd(4)) */
  1    21 
  1    22 	assign		initial("000110001"b),	/* opnd(1) <- opnd(2)		*/
  1    23 	assign_size_ck	initial("000110010"b),	/* opnd(1) <- opnd(2)		*/
  1    24 	assign_zero	initial("000110011"b),	/* opnd(1) <- 0			*/
  1    25 	copy_words	initial("000110100"b),	/* move opnd(2) to opnd(1) by opnd(3) words */
  1    26 	copy_string	initial("000110101"b),	/* move opnd(2) to opnd(1) by opnd(3) units */
  1    27 	make_desc		initial("000110110"b),	/* opnd(1) <- descriptor(opnd(2),opnd(3)) */
  1    28 	assign_round	initial("000110111"b),	/* opnd(1) <- opnd(2) rounded		*/
  1    29 	pack		initial("000111000"b),	/* opnd(1) <- encode to picture opnd(2) */
  1    30 	unpack		initial("000111001"b),	/* opnd(1) <- decode from picture opnd(2) */
  1    31 
  1    32 	less_than		initial("001000100"b),	/* opnd(1) <- opnd(2) < opnd(3)	*/
  1    33 	greater_than	initial("001000101"b),	/* opnd(1) <- opnd(2) > opnd(3)	*/
  1    34 	equal		initial("001000110"b),	/* opnd(1) <- opnd(2) = opnd(3)	*/
  1    35 	not_equal		initial("001000111"b),	/* opnd(1) <- opnd(2) ^= opnd(3)	*/
  1    36 	less_or_equal	initial("001001000"b),	/* opnd(1) <- opnd(2) <= opnd(3)	*/
  1    37 	greater_or_equal	initial("001001001"b),	/* opnd(1) <- opnd(2) >= opnd(3)	*/
  1    38 
  1    39 	jump		initial("001010001"b),	/* go to opnd(1) unconditionally	*/
  1    40 	jump_true		initial("001010010"b),	/* go to opnd(1) if opnd(2) is not 0	*/
  1    41 	jump_false	initial("001010011"b),	/* go to opnd(1) if opnd(2) is all 0	*/
  1    42 	jump_if_lt	initial("001010100"b),	/* go to opnd(1) if opnd(2) < opnd(3)	*/
  1    43 	jump_if_gt	initial("001010101"b),	/* go to opnd(1) if opnd(2) > opnd(3)	*/
  1    44 	jump_if_eq	initial("001010110"b),	/* go to opnd(1) if opnd(2) = opnd(3)	*/
  1    45 	jump_if_ne	initial("001010111"b),	/* go to opnd(1) if opnd(2) ^= opnd(3)	*/
  1    46 	jump_if_le	initial("001011000"b),	/* go to opnd(1) if opnd(2) <= opnd(3)	*/
  1    47 	jump_if_ge	initial("001011001"b),	/* go to opnd(1) if opnd(2) >= opnd(3)	*/
  1    48 
  1    49 	std_arg_list	initial("001100001"b),	/* opnd(1) <- arglist(opnd(2) desclist(opnd(3)))	*/
  1    50 	return_words	initial("001100010"b),	/* return aggregate opnd(1), opnd(2) is length in words */
  1    51 	std_call		initial("001100011"b),	/* opnd(1) <- call opnd(2) with opnd(3)		*/
  1    52 	return_bits	initial("001100100"b),	/* return aggregate opnd(1), opnd(2) is length in bits */
  1    53 	std_entry		initial("001100101"b),	/* entry(opnd(1)... opnd(n))			*/
  1    54 	return_string	initial("001100110"b),	/* return string opnd(1) */
  1    55 	ex_prologue	initial("001100111"b),	/* execute the prologue -no operands-		*/
  1    56 	allot_auto	initial("001101000"b),	/* opnd(1) <- addrel(stack,opnd(2))		*/
  1    57 	param_ptr		initial("001101001"b),	/* opnd(1) <- ptr to opnd(2) in  block opnd(3)	*/
  1    58 	param_desc_ptr	initial("001101010"b),	/* opnd(1) <- ptr to opnd(2) in block opnd(3)	*/
  1    59 	std_return	initial("001101011"b),	/* return -no arguments-			*/
  1    60 	allot_ctl		initial("001101100"b),	/* allocate opnd(1) , length in words is opnd(2) 	*/
  1    61 	free_ctl		initial("001101101"b),	/* free opnd(1)				*/
  1    62 	stop		initial("001101110"b),	/* stop - terminate run unit			*/
  1    63 
  1    64 	mod_bit		initial("001110000"b),	/* opnd(1) <- mod(opnd(3),36),
  1    65*						   opnd(2) <- opnd(3) / 36		*/
  1    66 	mod_byte		initial("001110001"b),	/* opnd(1) <- mod(opnd(3),4),
  1    67*						   opnd(2) <- opnd(3) / 4		*/
  1    68 	mod_half		initial("001110010"b),	/* opnd(1) <- mod(opnd(3),2),
  1    69*						   opnd(2) <- opnd(3) / 2		*/
  1    70 	mod_word		initial("001110011"b),	/* TO BE DEFINED BY BLW			*/
  1    71 
  1    72 	bit_to_char	initial("010000000"b),	/* opnd(1) <- (opnd(2)+8)/9		*/
  1    73 	bit_to_word	initial("010000001"b),	/* opnd(1) <- (opnd(2)+35)/36		*/
  1    74 	char_to_word	initial("010000010"b),	/* opnd(1) <- (opnd(2)+3)/4		*/
  1    75 	half_to_word	initial("010000011"b),	/* opnd(1) <- (opnd(2)+1)/2		*/
  1    76 	word_to_mod2	initial("010000100"b),	/* opnd(1) <- (opnd(2)+1)/2*2		*/
  1    77 	word_to_mod4	initial("010000101"b),	/* opnd(1) <- (opnd(2)+3)/4*4		*/
  1    78 	word_to_mod8	initial("010000110"b),	/* opnd(1) <- (opnd(2)+7)/8*8		*/
  1    79 	rel_fun		initial("010000111"b),	/* opnd(1) <- rel(opnd(2))		*/
  1    80 	baseno_fun	initial("010001000"b),	/* opnd(1) <- baseno(opnd(2))		*/
  1    81 	desc_size		initial("010001001"b),	/* opnd(1) <- substr(opnd(2),13,24)	*/
  1    82 	bit_pointer	initial("010001010"b),	/* opnd(1) <- bit offset of opnd(2)	*/
  1    83 	index_before_fun	initial("010001011"b),	/* opnd(1) <- length of before(opnd(2),opnd(3)) */
  1    84 	index_after_fun	initial("010001100"b),	/* opnd(1) <- offset of after(opnd(2),opnd(3)) in opnd(2) */
  1    85 	verify_ltrim_fun	initial("010001101"b),	/* opnd(1) <- offset of ltrim(opnd(2),opnd(3)) in opnd(2) */
  1    86 	verify_rtrim_fun	initial("010001110"b),	/* opnd(1) <- length(opnd(2))-length(rtrim(opnd(2),opnd(3))) */
  1    87 	digit_to_bit	initial("010001111"b),	/* opnd(1) <- 9*opnd(2)/2		*/
  1    88 
  1    89 	ceil_fun		initial("010010000"b),	/* opnd(1) <- ceil(opnd(2))		*/
  1    90 	floor_fun		initial("010010001"b),	/* opnd(1) <- floor(opnd(2))		*/
  1    91 	round_fun		initial("010010010"b),	/* opnd(1) <- round(opnd(2))		*/
  1    92 	sign_fun		initial("010010011"b),	/* opnd(1) <- sign(opnd(2))		*/
  1    93 	abs_fun		initial("010010100"b),	/* opnd(1) <- abs(opnd(2))		*/
  1    94 	trunc_fun		initial("010010101"b),	/* opnd(1) <- trunc(opnd(2))		*/
  1    95 	byte_fun		initial("010010110"b),	/* opnd(1) <- byte(opnd(2))		*/
  1    96 	rank_fun		initial("010010111"b),	/* opnd(1) <- rank(opnd(2))		*/
  1    97 	index_rev_fun	initial("010011000"b),	/* opnd(1) <- index(reverse(opnd(2)),reverse(opnd(3))) */
  1    98 	search_rev_fun	initial("010011001"b),	/* opnd(1) <- search(reverse(opnd(2)),opnd(3)) */
  1    99 	verify_rev_fun	initial("010011010"b),	/* opnd(1) <- verify(reverse(opnd(2)),opnd(3)) */
  1   100 	wordno_fun	initial("010011011"b),        /* opnd(1) <- wordno (opnd(2)) */
  1   101 	segno_fun		initial("010011100"b),        /* opnd(1) <- segno (opnd(2)) */
  1   102 	bitno_fun           initial("010011101"b),        /* opnd(1) <- bitno (opnd(2)) */
  1   103 	charno_fun	initial("010011110"b),        /* opnd(1) <- charno (opnd(2)) */
  1   104 
  1   105 	index_fun		initial("010100000"b),	/* opnd(1) <- index(opnd(2),opnd(3))	*/
  1   106 	off_fun		initial("010100001"b),	/* opnd(1) <- offset(opnd(2),opnd(3))	*/
  1   107 	complex_fun	initial("010100010"b),	/* opnd(1) <- complex(opnd(2),opnd(3))	*/
  1   108 	conjg_fun		initial("010100011"b),	/* opnd(1) <- conjg(opnd(2),opnd(3))	*/
  1   109 	mod_fun		initial("010100100"b),	/* opnd(1) <- mod(opnd(2),opnd(3))	*/
  1   110 	repeat_fun	initial("010100101"b),	/* opnd(1) <- repeat(opnd(2),opnd(3))	*/
  1   111 	verify_fun	initial("010100110"b),	/* opnd(1) <- verify(opnd(2),opnd(3))	*/
  1   112 	translate_fun	initial("010100111"b),	/* opnd(1) <- translate(opnd(2),opnd(3))*/
  1   113 	real_fun   	initial("010101001"b),	/* opnd(1) <- real(opnd(2))		*/
  1   114 	imag_fun   	initial("010101010"b),	/* opnd(1) <- imag(opnd(2))		*/
  1   115 	length_fun	initial("010101011"b),	/* opnd(1) <- length(opnd(2))	*/
  1   116 	pl1_mod_fun	initial("010101100"b),	/* opnd(1) <- mod(opnd(2)) */
  1   117 	search_fun	initial("010101101"b),	/* opnd(1) <- search(opnd(2),opnd(3)) */
  1   118 	allocation_fun	initial("010101110"b),	/* opnd(1) <- allocation(opnd(2)) */
  1   119 	reverse_fun	initial("010101111"b),	/* opnd(1) <- reverse(opnd(2)) */
  1   120 
  1   121 	addr_fun		initial("010110000"b),	/* opnd(1) <- addr(opnd(2))		*/
  1   122 	addr_fun_bits	initial("010110001"b),	/* opnd(1) <- addr(opnd(2))		*/
  1   123 	ptr_fun		initial("010110010"b),	/* opnd(1) <- ptr(opnd(2),opnd(3))	*/
  1   124 	baseptr_fun	initial("010110011"b),	/* opnd(1) <- baseptr(opnd(2))	*/
  1   125 	addrel_fun	initial("010110100"b),	/* opnd(1) <- addrel(opnd(2),opnd(3))	*/
  1   126 	codeptr_fun	initial("010110101"b),	/* opnd(1) <- codeptr(opnd(2))	*/
  1   127 	environmentptr_fun	initial("010110110"b),	/* opnd(1) <- environmentptr(opnd(2))	*/
  1   128 	stackbaseptr_fun	initial("010110111"b),	/* opnd(1) is ptr to base of current stack	*/
  1   129 	stackframeptr_fun	initial("010111000"b),	/* opnd(1) is ptr to current block's stack frame	*/
  1   130 	setcharno_fun	initial("010111001"b),	/* opnd(1) <- opnd(2) with charno opnd(3) */
  1   131 	addcharno_fun	initial("010111010"b),	/* opnd(1) <- opnd(2) with charno = charno + opnd(3) */
  1   132 	setbitno_fun	initial("010111011"b),	/* setcharno for bitsno */
  1   133 	addbitno_fun	initial("010111100"b),	/* addcharno for bitno */
  1   134 
  1   135 	min_fun		initial("011000000"b),	/* opnd(1) <- min(opnd(1),opnd(2),...)	*/
  1   136 	max_fun		initial("011000001"b),	/* opnd(1) <- max(opnd(1),opnd(2),...)	*/
  1   137 
  1   138 	stack_ptr		initial("011010001"b),	/* opnd(1) <- stack frame ptr		*/
  1   139 	empty_area	initial("011010010"b),	/* empty opnd(1), length in words is opnd(2) */
  1   140 	enable_on		initial("011010100"b),	/* opnd(1) is the cond name
  1   141*						   opnd(2) is the file name
  1   142*						   opnd(3) is the block	*/
  1   143 	revert_on		initial("011010101"b),	/* opnd(1) is the cond name,
  1   144*						   opnd(2) is the file name	*/
  1   145 	signal_on		initial("011010110"b),	/* opnd(1) is the cond name
  1   146*						   opnd(2) is the file name */
  1   147 
  1   148 	lock_fun		initial("011010111"b),	/* opnd(1) <- stac(opnd(2),opnd(3))	*/
  1   149 	stacq_fun		initial("011011000"b),	/* opnd(1) is result, opnd(2) is ptr to lock word,
  1   150*						   opnd(3) is old value, (4) is new value. */
  1   151 	clock_fun		initial("011011001"b),	/* opnd(1) is the clock time		*/
  1   152 	vclock_fun	initial("011011010"b),	/* opnd(1) is the virtual clock time	*/
  1   153 
  1   154 	bound_ck		initial("011100000"b),	/* opnd(1) <- opnd(2) if opnd(3) <= opnd(2) <= opnd(4) */
  1   155 	range_ck		initial("011100001"b),	/* opnd(1) <- opnd(2) if opnd(3) <= opnd(2) <= opnd(4) */
  1   156 	loop		initial("011100010"b),	/* do opnd(1) for opnd(2) from opnd(3) to opnd(4) by 1,
  1   157*						   opnd(5) is the list */
  1   158 	join		initial("011100011"b),	/* do opnd(1), opnd(2) ... opnd(n)	*/
  1   159 	allot_based	initial("011100100"b),	/* allocate opnd(2) words in opnd(3), set opnd(1) */
  1   160 	free_based	initial("011100101"b),	/* free opnd(1) in opnd(3), length is opnd(2) words */
  1   161 
  1   162 	r_parn		initial("011110001"b),	/* format op code			*/
  1   163 	l_parn		initial("011110010"b),
  1   164 	r_format		initial("011110011"b),
  1   165 	c_format		initial("011110100"b),
  1   166 	f_format		initial("011110101"b),
  1   167 	e_format		initial("011110110"b),
  1   168 	b_format		initial("011110111"b),
  1   169 	a_format		initial("011111000"b),
  1   170 	x_format		initial("011111001"b),
  1   171 	skip_format	initial("011111010"b),
  1   172 	column_format	initial("011111011"b),
  1   173 	page_format	initial("011111100"b),
  1   174 	line_format	initial("011111101"b),
  1   175 	picture_format	initial("011111110"b),
  1   176 	bn_format		initial("011111111"b),	/* bit format, length(opnd(2)), radix factor(opnd(3)) */
  1   177 
  1   178 	get_list_trans	initial("100000000"b),	/* getlist(opnd(2) with desc(opnd(1)))	*/
  1   179 	get_edit_trans	initial("100000001"b),	/* getedit(opnd(2) with desc(opnd(1)))	*/
  1   180 	get_data_trans	initial("100000010"b),	/* getdata(opnd(1) to opnd(n))	*/
  1   181 	put_list_trans	initial("100000011"b),	/* putlist(opnd(2) with desc(opnd(1)))	*/
  1   182 	put_edit_trans	initial("100000100"b),	/* putedit(opnd(2) with desc(opnd(1)))	*/
  1   183 	put_data_trans	initial("100000101"b),	/* putdata(opnd(2)) with subscript-list opnd(1) */
  1   184 	terminate_trans	initial("100000110"b),	/* terminate stream transmission	*/
  1   185 	stream_prep	initial("100000111"b),	/* initiate stream transmission	*/
  1   186 	record_io		initial("100001000"b),	/* perform record io operation	*/
  1   187 	fortran_read	initial("100001001"b),	/* A complete read statement		*/
  1   188 	fortran_write	initial("100001010"b),	/* A complete write statement		*/
  1   189 	ftn_file_manip	initial("100001011"b),	/* endfile,backspace,rewind,etc.	*/
  1   190 	ftn_trans_loop	initial("100001100"b),	/* An implied do in i/o list		*/
  1   191 	put_control	initial("100001101"b),	/* put control opnd(1) opnd(2) times	*/
  1   192 	put_field		initial("100001110"b),	/* putlist(opnd(2)) of length(opnd(1))	*/
  1   193 	put_field_chk	initial("100001111"b),	/* putlist(op(2)) of len(op(1)) check char index(op(3)) */
  1   194 
  1   195 /* These operators are produced by the parse but are not used as input to the code generator.	*/
  1   196 /* They are processed by the semantic translator.						*/
  1   197 
  1   198 	return_value	initial("100010010"b),	/* return(opnd(1))			*/
  1   199 	allot_var		initial("100010011"b),	/* allot opnd(1) in opnd(2)		*/
  1   200 	free_var		initial("100010100"b),	/* free opnd(1) out of opnd(2)	*/
  1   201 	get_file		initial("100010101"b),	/* opnd(1) is filename,opnd(2) is copy	*/
  1   202 						/* opnd(3) is skip, opnd(4) is list	*/
  1   203 	get_string	initial("100010110"b),	/* opnd(1) is string,opnd(2) is list	*/
  1   204 	put_file		initial("100010111"b),	/* opnd(1) is filename,opnd(2) is page	*/
  1   205 						/* opnd(3) is skip,opnd(4) is line	*/
  1   206 	put_string	initial("100011000"b),	/* opnd(1) is string,opnd(2) is list	*/
  1   207 	open_file		initial("100011001"b),
  1   208 	close_file	initial("100011010"b),
  1   209 	read_file		initial("100011011"b),
  1   210 	write_file	initial("100011100"b),
  1   211 	locate_file	initial("100011101"b),
  1   212 	do_fun		initial("100011110"b),	/* opnd(1) is join of a list		*/
  1   213 						/* opnd(2) is control variable ref	*/
  1   214 						/* opnd(3) is specification operator	*/
  1   215 	do_spec		initial("100011111"b),	/* opnd(1) to opnd(2) by opnd(3) 	*/
  1   216 						/* repeat opnd(4) while opnd(5)	*/
  1   217 						/* opnd(6) is next specification	*/
  1   218 
  1   219 	rewrite_file	initial("100100000"b),
  1   220 	delete_file	initial("100100001"b),
  1   221 	unlock_file	initial("100100010"b),
  1   222 	lock_file		initial("100100011"b),
  1   223 	refer		initial("100100101"b),	/* opnd(1) refer(opnd(2))		*/
  1   224 	prefix_plus	initial("100100110"b),	/* opnd(1) <- +opnd(2)		*/
  1   225 	nop		initial("100100111"b),	/* no-op */
  1   226 	assign_by_name	initial("100101000"b),	/* opnd(1) <- opnd(2),by name		*/
  1   227 
  1   228 /* These operators are produced by the semantic translator in processing the math
  1   229*   builtin functions and are used as input to the code generator			*/
  1   230 
  1   231 	sqrt_fun		initial("100110000"b),	/* opnd(1) <- sqrt(opnd(2))	*/
  1   232 	sin_fun		initial("100110001"b),	/* opnd(1) <- sin(opnd(2))	*/
  1   233 	sind_fun		initial("100110010"b),	/* opnd(1) <- sind(opnd(2))	*/
  1   234 	cos_fun		initial("100110011"b),	/* opnd(1) <- cos(opnd(2))	*/
  1   235 	cosd_fun		initial("100110100"b),	/* opnd(1) <- cosd(opnd(2))	*/
  1   236 	tan_fun		initial("100110101"b),	/* opnd(1) <- tan(opnd(2))	*/
  1   237 	tand_fun		initial("100110110"b),	/* opnd(1) <- tand(opnd(2))	*/
  1   238 	asin_fun		initial("100110111"b),	/* opnd(1) <- asin(opnd(2))	*/
  1   239 	asind_fun		initial("100111000"b),	/* opnd(1) <- asind(opnd(2))	*/
  1   240 	acos_fun		initial("100111001"b),	/* opnd(1) <- acos(opnd(2))	*/
  1   241 	acosd_fun		initial("100111010"b),	/* opnd(1) <- acosd(opnd(2))	*/
  1   242 	atan_fun		initial("100111011"b),	/* opnd(1) <- atan(opnd(2)[,opnd(3)])	*/
  1   243 	atand_fun		initial("100111100"b),	/* opnd(1) <- atand(opnd(2)[,opnd(3)])	*/
  1   244 	log2_fun		initial("100111101"b),	/* opnd(1) <- log2(opnd(2))	*/
  1   245 	log_fun		initial("100111110"b),	/* opnd(1) <- log(opnd(2))	*/
  1   246 	log10_fun		initial("100111111"b),	/* opnd(1) <- log10(opnd(2))	*/
  1   247 
  1   248 	exp_fun		initial("101000000"b))	/* opnd(1) <- exp(opnd(2))	*/
  1   249 
  1   250 			bit(9) aligned internal static options(constant);
  1   251 
  1   252 /* END INCLUDE FILE ... op_codes.incl.pl1 */
      148 
  2     1 /* BEGIN INCLUDE FILE ... operator.incl.pl1 */
  2     2 
  2     3 /*	Modified: 2 Apr 1980 by PCK to add max_number_of_operands */
  2     4 
  2     5 /* format: style3 */
  2     6 dcl	1 operator	based aligned,
  2     7 	  2 node_type	bit (9) unaligned,
  2     8 	  2 op_code	bit (9) unaligned,
  2     9 	  2 shared	bit (1) unaligned,
  2    10 	  2 processed	bit (1) unaligned,
  2    11 	  2 optimized	bit (1) unaligned,
  2    12 	  2 number	fixed (14) unaligned,
  2    13 	  2 operand	dimension (n refer (operator.number)) ptr unaligned;
  2    14 
  2    15 dcl	max_number_of_operands
  2    16 			fixed bin (15) int static options (constant) initial (32767);
  2    17 
  2    18 /* END INCLUDE FILE ... operator.incl.pl1 */
      149 
  3     1 /* BEGIN INCLUDE FILE ... block.incl.pl1 */
  3     2 /* Modified 22 Ocober 1980 by M. N. Davidoff to increase max block.number to 511 */
  3     3 /* format: style3,idind30 */
  3     4 
  3     5 declare	1 block			aligned based,
  3     6 	  2 node_type		bit (9) unaligned,
  3     7 	  2 source_id		structure unaligned,
  3     8 	    3 file_number		bit (8),
  3     9 	    3 line_number		bit (14),
  3    10 	    3 statement_number	bit (5),
  3    11 	  2 father		ptr unaligned,
  3    12 	  2 brother		ptr unaligned,
  3    13 	  2 son			ptr unaligned,
  3    14 	  2 declaration		ptr unaligned,
  3    15 	  2 end_declaration		ptr unaligned,
  3    16 	  2 default		ptr unaligned,
  3    17 	  2 end_default		ptr unaligned,
  3    18 	  2 context		ptr unaligned,
  3    19 	  2 prologue		ptr unaligned,
  3    20 	  2 end_prologue		ptr unaligned,
  3    21 	  2 main			ptr unaligned,
  3    22 	  2 end_main		ptr unaligned,
  3    23 	  2 return_values		ptr unaligned,
  3    24 	  2 return_count		ptr unaligned,
  3    25 	  2 plio_ps		ptr unaligned,
  3    26 	  2 plio_fa		ptr unaligned,
  3    27 	  2 plio_ffsb		ptr unaligned,
  3    28 	  2 plio_ssl		ptr unaligned,
  3    29 	  2 plio_fab2		ptr unaligned,
  3    30 	  2 block_type		bit (9) unaligned,
  3    31 	  2 prefix		bit (12) unaligned,
  3    32 	  2 like_attribute		bit (1) unaligned,
  3    33 	  2 no_stack		bit (1) unaligned,
  3    34 	  2 get_data		bit (1) unaligned,
  3    35 	  2 flush_at_call		bit (1) unaligned,
  3    36 	  2 processed		bit (1) unaligned,
  3    37 	  2 text_displayed		bit (1) unaligned,
  3    38 	  2 number		fixed bin (9) unsigned unaligned,
  3    39 	  2 free_temps		dimension (3) ptr,	/* these fields are used by the code generator */
  3    40 	  2 temp_list		ptr,
  3    41 	  2 entry_list		ptr,
  3    42 	  2 o_and_s		ptr,
  3    43 	  2 why_nonquick		aligned,
  3    44 	    3 auto_adjustable_storage bit (1) unaligned,
  3    45 	    3 returns_star_extents	bit (1) unaligned,
  3    46 	    3 stack_extended_by_args	bit (1) unaligned,
  3    47 	    3 invoked_by_format	bit (1) unaligned,
  3    48 	    3 format_statement	bit (1) unaligned,
  3    49 	    3 io_statements		bit (1) unaligned,
  3    50 	    3 assigned_to_entry_var	bit (1) unaligned,
  3    51 	    3 condition_statements	bit (1) unaligned,
  3    52 	    3 no_owner		bit (1) unaligned,
  3    53 	    3 recursive_call	bit (1) unaligned,
  3    54 	    3 options_non_quick	bit (1) unaligned,
  3    55 	    3 options_variable	bit (1) unaligned,
  3    56 	    3 never_referenced	bit (1) unaligned,
  3    57 	    3 pad_nonquick		bit (5) unaligned,
  3    58 	  2 prologue_flag		bit (1) unaligned,
  3    59 	  2 options_main		bit (1) unaligned,
  3    60 	  2 pad			bit (16) unaligned,
  3    61 	  2 number_of_entries	fixed bin (17),
  3    62 	  2 level			fixed bin (17),
  3    63 	  2 last_auto_loc		fixed bin (17),
  3    64 	  2 symbol_block		fixed bin (17),
  3    65 	  2 entry_info		fixed bin (18),
  3    66 	  2 enter			structure unaligned,
  3    67 	    3 start		fixed bin (17),
  3    68 	    3 end			fixed bin (17),
  3    69 	  2 leave			structure unaligned,
  3    70 	    3 start		fixed bin (17),
  3    71 	    3 end			fixed bin (17),
  3    72 	  2 owner			ptr;
  3    73 
  3    74 declare	max_block_number		fixed bin internal static options (constant) initial (511);
  3    75 
  3    76 /* END INCLUDE FILE ... block.incl.pl1 */
      150 
  4     1 /* BEGIN INCLUDE FILE ... machine_state.incl.pl1 */
  4     2 
  4     3 dcl	cg_static_$m_s_p ptr ext static,
  4     4 	m_s_p ptr init(cg_static_$m_s_p);
  4     5 
  4     6 dcl	1 machine_state	aligned based(m_s_p),
  4     7 	2 node_type	bit(9),
  4     8 	2 indicators	fixed bin,
  4     9 	2 next		ptr unal,
  4    10 	2 a_reg,
  4    11 	  3 variable(10)	ptr unal,
  4    12 	  3 number	fixed bin(17),
  4    13 	  3 size		fixed bin(8),
  4    14 	  3 length	fixed bin(8),
  4    15 	  3 offset	fixed bin(8),
  4    16 	  3 constant	fixed bin(24),
  4    17 	  3 changed	fixed bin(18),
  4    18 	  3 instruction	bit(36),
  4    19 	  3 locked	bit(1) aligned,
  4    20 	  3 number_h_o	fixed bin,
  4    21 	  3 has_offset(3)	ptr unal,
  4    22 	2 q_reg,
  4    23 	  3 variable(10)	ptr unal,
  4    24 	  3 number	fixed bin(17),
  4    25 	  3 size		fixed bin(8),
  4    26 	  3 length	fixed bin(8),
  4    27 	  3 offset	fixed bin(8),
  4    28 	  3 constant	fixed bin(24),
  4    29 	  3 changed	fixed bin(18),
  4    30 	  3 instruction	bit(36),
  4    31 	  3 locked	bit(1) aligned,
  4    32 	  3 number_h_o	fixed bin,
  4    33 	  3 has_offset(3)	ptr unal,
  4    34 	2 string_reg,
  4    35 	  3 variable	ptr unal,
  4    36 	  3 size		fixed bin(8),
  4    37 	  3 offset	fixed bin(8),
  4    38 	2 complex_reg,
  4    39 	  3 variable	ptr unal,
  4    40 	  3 size		fixed bin(8),
  4    41 	  3 scale		fixed bin(8),
  4    42 	2 decimal_reg,
  4    43 	  3 variable	ptr unal,
  4    44 	  3 size		fixed bin(8),
  4    45 	  3 scale		fixed bin(8),
  4    46 	2 index_regs(0:7),
  4    47 	  3 variable	ptr unal,
  4    48 	  3 constant	fixed bin,
  4    49 	  3 type		fixed bin(8),
  4    50 	  3 used		fixed bin(18),
  4    51 	  3 changed	fixed bin(18),
  4    52 	  3 instruction	bit(36),
  4    53 	  3 filler	fixed bin,
  4    54 	2 base_regs(0:7),
  4    55 	  3 variable	ptr unal,
  4    56 	  3 constant	fixed bin,
  4    57 	  3 type		fixed bin(8),
  4    58 	  3 pad (12)	fixed bin,	/* future...room to make 5 element array for variable, constant, type */
  4    59 	  3 number	fixed bin (17),	/* future...number of valid elements in array */
  4    60 	  3 used		fixed bin(18),
  4    61 	  3 changed	fixed bin(18),
  4    62 	  3 instruction	bit(36),
  4    63 	  3 locked	fixed bin(2),
  4    64 	2 indicators_ref(2:3) ptr unal;
  4    65 
  4    66 /* Permissible values for machine_state.indicators. */
  4    67 
  4    68 dcl (	ind_known_refs	init (-2),		/* set by comparison of known, nonzero, references */
  4    69 	ind_invalid	init (-1),
  4    70 	ind_string_aq	init (0),			/* logical value in storage */
  4    71 	ind_logical	init (1),			/* logical value in A or AQ */
  4    72 	ind_arithmetic	init (2),			/* arith value in Q, AQ, or EAQ */
  4    73 	ind_x (0:7)	init (6, 7, 8, 9, 10, 11, 12, 13),
  4    74 	ind_decimal_reg	init (14)
  4    75 	) fixed bin internal static options (constant);
  4    76 
  4    77 /* END INCLUDE FILE ... machine_state.incl.pl1 */
      151 
  5     1 /* BEGIN INCLUDE FILE ... symbol.incl.pl1 */
  5     2 
  5     3 dcl	1 symbol			based aligned,
  5     4 	2 node_type		bit(9) unal,
  5     5 	2 source_id		structure unal,
  5     6 	  3 file_number		bit(8),
  5     7 	  3 line_number		bit(14),
  5     8 	  3 statement_number	bit(5),
  5     9 	2 location		fixed(18) unal unsigned,
  5    10 	2 allocated		bit(1) unal,
  5    11 	2 dcl_type		bit(3) unal,
  5    12 	2 reserved		bit(6) unal,
  5    13 	2 pix			unal,
  5    14 	  3 pic_fixed		bit(1) unal,
  5    15 	  3 pic_float		bit(1) unal,
  5    16 	  3 pic_char		bit(1) unal,
  5    17 	  3 pic_scale		fixed(7) unal,
  5    18 	  3 pic_size		fixed(7) unal,
  5    19 	2 level			fixed(8) unal,
  5    20 	2 boundary		fixed(3) unal,
  5    21 	2 size_units		fixed(3) unal,
  5    22 	2 scale			fixed(7) unal,
  5    23 	2 runtime			bit(18) unal,
  5    24 	2 runtime_offset		bit(18) unal,
  5    25 	2 block_node		ptr unal,
  5    26 	2 token			ptr unal,
  5    27 	2 next			ptr unal,
  5    28 	2 multi_use		ptr unal,
  5    29 	2 cross_references		ptr unal,
  5    30 	2 initial			ptr unal,
  5    31 	2 array			ptr unal,
  5    32 	2 descriptor		ptr unal,
  5    33 	2 equivalence		ptr unal,
  5    34 	2 reference		ptr unal,
  5    35 	2 general			ptr unal,
  5    36 	2 father			ptr unal,
  5    37 	2 brother			ptr unal,
  5    38 	2 son			ptr unal,
  5    39 	2 word_size		ptr unal,
  5    40 	2 bit_size		ptr unal,
  5    41 	2 dcl_size		ptr unal,
  5    42 	2 symtab_size		ptr unal,
  5    43 	2 c_word_size		fixed(24),
  5    44 	2 c_bit_size		fixed(24),
  5    45 	2 c_dcl_size		fixed(24),
  5    46 
  5    47 	2 attributes		structure aligned,
  5    48 	  3 data_type		structure unal,
  5    49 	    4 structure		bit(1) ,
  5    50 	    4 fixed		bit(1),
  5    51 	    4 float		bit(1),
  5    52 	    4 bit			bit(1),
  5    53 	    4 char		bit(1),
  5    54 	    4 ptr			bit(1),
  5    55 	    4 offset		bit(1),
  5    56 	    4 area		bit(1),
  5    57 	    4 label		bit(1),
  5    58 	    4 entry		bit(1),
  5    59 	    4 file		bit(1),
  5    60 	    4 arg_descriptor	bit(1),
  5    61 	    4 storage_block		bit(1),
  5    62 	    4 explicit_packed	bit(1), /* options(packed) */
  5    63 	    4 condition		bit(1),
  5    64 	    4 format		bit(1),
  5    65 	    4 builtin		bit(1),
  5    66 	    4 generic		bit(1),
  5    67 	    4 picture		bit(1),
  5    68 
  5    69 	  3 misc_attributes		structure unal,
  5    70 	    4 dimensioned		bit(1),
  5    71 	    4 initialed		bit(1),
  5    72 	    4 aligned		bit(1),
  5    73 	    4 unaligned		bit(1),
  5    74 	    4 signed		bit(1),
  5    75 	    4 unsigned		bit(1),
  5    76 	    4 precision		bit(1),
  5    77 	    4 varying		bit(1),
  5    78 	    4 local		bit(1),
  5    79 	    4 decimal		bit(1),
  5    80 	    4 binary		bit(1),
  5    81 	    4 real		bit(1),
  5    82 	    4 complex		bit(1),
  5    83 	    4 variable		bit(1),
  5    84 	    4 reducible		bit(1),
  5    85 	    4 irreducible		bit(1),
  5    86 	    4 returns		bit(1),
  5    87 	    4 position		bit(1),
  5    88 	    4 internal		bit(1),
  5    89 	    4 external		bit(1),
  5    90 	    4 like		bit(1),
  5    91 	    4 member		bit(1),
  5    92 	    4 non_varying		bit(1),
  5    93 	    4 options		bit(1),
  5    94 	    4 variable_arg_list 	bit(1),		/* options(variable) */
  5    95 	    4 alloc_in_text		bit(1),		/* options(constant) */
  5    96 
  5    97 	  3 storage_class		structure unal,
  5    98 	    4 auto		bit(1),
  5    99 	    4 based		bit(1),
  5   100 	    4 static		bit(1),
  5   101 	    4 controlled		bit(1),
  5   102 	    4 defined		bit(1),
  5   103 	    4 parameter		bit(1),
  5   104 	    4 param_desc		bit(1),
  5   105 	    4 constant		bit(1),
  5   106 	    4 temporary		bit(1),
  5   107 	    4 return_value		bit(1),
  5   108 
  5   109 	  3 file_attributes		structure unal,
  5   110 	    4 print		bit(1),
  5   111 	    4 input		bit(1),
  5   112 	    4 output		bit(1),
  5   113 	    4 update		bit(1),
  5   114 	    4 stream		bit(1),
  5   115 	    4 reserved_1		bit(1),
  5   116 	    4 record		bit(1),
  5   117 	    4 sequential		bit(1),
  5   118 	    4 direct		bit(1),
  5   119 	    4 interactive		bit(1),		/* env(interactive) */
  5   120 	    4 reserved_2		bit(1),
  5   121 	    4 reserved_3		bit(1),
  5   122 	    4 stringvalue		bit(1),		/* env(stringvalue) */
  5   123 	    4 keyed		bit(1),
  5   124 	    4 reserved_4		bit(1),
  5   125 	    4 environment		bit(1),
  5   126 
  5   127 	  3 compiler_developed	structure unal,
  5   128 	    4 aliasable		bit(1),
  5   129 	    4 packed		bit(1),
  5   130 	    4 passed_as_arg		bit(1),
  5   131 	    4 allocate		bit(1),
  5   132 	    4 set			bit(1),
  5   133 	    4 exp_extents		bit(1),
  5   134 	    4 refer_extents		bit(1),
  5   135 	    4 star_extents		bit(1),
  5   136 	    4 isub		bit(1),
  5   137 	    4 put_in_symtab		bit(1),
  5   138 	    4 contiguous		bit(1),
  5   139 	    4 put_data		bit(1),
  5   140 	    4 overlayed		bit(1),
  5   141 	    4 error		bit(1),
  5   142 	    4 symtab_processed	bit(1),
  5   143 	    4 overlayed_by_builtin	bit(1),
  5   144 	    4 defaulted		bit(1),
  5   145 	    4 connected		bit(1);
  5   146 
  5   147 /* END INCLUDE FILE ... symbol.incl.pl1 */
      152 
  6     1 /* BEGIN INCLUDE FILE ... cg_reference.incl.pl1 */
  6     2 
  6     3 dcl	1 reference		based aligned,
  6     4 	2 node_type		bit(9) unaligned,
  6     5 	2 array_ref		bit(1) unaligned,
  6     6 	2 varying_ref		bit(1) unaligned,
  6     7 	2 shared			bit(1) unaligned,
  6     8 	2 put_data_sw		bit(1) unaligned,
  6     9 	2 processed		bit(1) unaligned,
  6    10 	2 units			fixed(3) unaligned,
  6    11 	2 ref_count		fixed(17) unaligned,
  6    12 	2 c_offset		fixed(24),
  6    13 	2 c_length		fixed(24),
  6    14 	2 symbol			ptr unaligned,
  6    15 	2 qualifier		ptr unaligned,
  6    16 	2 offset			ptr unaligned,
  6    17 	2 length			ptr unaligned,
  6    18 						/* these fields are used by the 645 code generator */
  6    19 	2 c_f_offset		fixed bin(6),
  6    20 	2 address			structure unaligned,
  6    21 	  3 base			bit(3),
  6    22 	  3 offset		bit(15),
  6    23 	  3 op			bit(9),
  6    24 	  3 no_address		bit(1),
  6    25 	  3 inhibit		bit(1),
  6    26 	  3 ext_base		bit(1),
  6    27 	  3 tag			bit(6),
  6    28 	2 info			structure unaligned,
  6    29 	  3 address_in		structure,
  6    30 	    4 b			dimension(0:7) bit(1),
  6    31 	    4 storage		bit(1),
  6    32 	  3 value_in		structure,
  6    33 	    4 a			bit(1),
  6    34 	    4 q			bit(1),
  6    35 	    4 aq			bit(1),
  6    36 	    4 string_aq		bit(1),
  6    37 	    4 complex_aq		bit(1),
  6    38 	    4 decimal_aq		bit(1),
  6    39 	    4 b			dimension(0:7) bit(1),
  6    40 	    4 storage		bit(1),
  6    41 	    4 indicators		bit(1),
  6    42 	    4 x			dimension(0:7) bit(1),
  6    43 	  3 other			structure,
  6    44 	    4 big_offset		bit(1),
  6    45 	    4 big_length		bit(1),
  6    46 	    4 modword_in_offset	bit(1),
  6    47 	2 data_type		fixed(5) unaligned,
  6    48 	2 bits			structure unaligned,
  6    49 	  3 padded_ref		bit(1),
  6    50 	  3 aligned_ref		bit(1),
  6    51 	  3 long_ref		bit(1),
  6    52 	  3 forward_ref		bit(1),
  6    53 	  3 ic_ref		bit(1),
  6    54 	  3 temp_ref		bit(1),
  6    55 	  3 defined_ref		bit(1),
  6    56 	  3 evaluated		bit(1),
  6    57 	  3 allocate		bit(1),
  6    58 	  3 allocated		bit(1),
  6    59 	  3 aliasable		bit(1),
  6    60 	  3 even			bit(1),
  6    61 	  3 perm_address		bit(1),
  6    62 	  3 aggregate		bit(1),
  6    63 	  3 hit_zero		bit(1),
  6    64 	  3 dont_save		bit(1),
  6    65 	  3 fo_in_qual		bit(1),
  6    66 	  3 hard_to_load		bit(1),
  6    67 	2 relocation		bit(12) unaligned,
  6    68 	2 more_bits		structure unaligned,
  6    69 	  3 substr		bit(1),
  6    70 	  3 padded_for_store_ref	bit(1),
  6    71 	  3 aligned_for_store_ref	bit(1),
  6    72 	  3 mbz			bit(15),
  6    73 	2 store_ins		bit(18) unaligned;
  6    74 
  6    75 /* END INCLUDE FILE ... cg_reference.incl.pl1 */
      153 
  7     1 dcl	bases(0:7) bit(3) aligned int static init("000"b, "010"b, "100"b,  "001"b, "011"b, "101"b, "111"b,"110"b)
  7     2 	options(constant);
  7     3 
  7     4 dcl (	ap	defined(bases(0)),
  7     5 	bp	defined(bases(1)),
  7     6 	lp	defined(bases(2)),
  7     7 	sp	defined(bases(7))) bit(3) aligned;
  7     8 
  7     9 dcl (	ab	defined(bases(3)),
  7    10 	bb	defined(bases(4)),
  7    11 	lb	defined(bases(5)),
  7    12 	sb	defined(bases(6))) bit(3) aligned;
  7    13 
  7    14 dcl	which_base(0:7) fixed bin int static init(0,3,1,4,2,5,7,6) options(constant);
      154 
  8     1 /* BEGIN INCLUDE FILE relocation_bits.incl.pl1 */
  8     2 
  8     3 /* This include file defines the relocation bits as bit (6) entities.  See
  8     4*   also relbts.incl.pl1 and reloc_lower.incl.pl1. */
  8     5 
  8     6 dcl (	rc_a	initial("000000"b),		/* absolute */
  8     7 	rc_t	initial("010000"b),		/* text */
  8     8 	rc_nt	initial("010001"b),		/* negative text */
  8     9 	rc_lp18	initial("010010"b),		/* linkage, 18 bit */
  8    10 	rc_nlp18	initial("010011"b),		/* negative link, 18 bit */
  8    11 	rc_lp15	initial("010100"b),		/* linkage, 15 bit */
  8    12 	rc_dp	initial("010101"b),		/* def section */
  8    13 	rc_s	initial("010110"b),		/* symbol segment */
  8    14 	rc_ns	initial("010111"b),		/* negative symbol */
  8    15 	rc_is18	initial("011000"b),		/* internal static 18 */
  8    16 	rc_is15	initial("011001"b),		/* internal static 15 */
  8    17 	rc_lb	initial("011000"b),		/* link block */
  8    18 	rc_nlb	initial("011001"b),		/* negative link block */
  8    19 	rc_sr	initial("011010"b),		/* self relative */
  8    20 	rc_e	initial("011111"b))		/* escape */
  8    21 	bit(6) int static options(constant);
  8    22 
  8    23 /* END INCLUDE FILE relocation_bits.incl.pl1 */
      155 
  9     1 /* BEGIN INCLUDE FILE ... nodes.incl.pl1 */
  9     2 
  9     3 /* Modified: 26 Dec 1979 by PCK to implement by name assignment */
  9     4 
  9     5 dcl (	block_node		initial("000000001"b),
  9     6 	statement_node		initial("000000010"b),
  9     7 	operator_node		initial("000000011"b),
  9     8 	reference_node		initial("000000100"b),
  9     9 	token_node		initial("000000101"b),
  9    10 	symbol_node		initial("000000110"b),
  9    11 	context_node		initial("000000111"b),
  9    12 	array_node		initial("000001000"b),
  9    13 	bound_node		initial("000001001"b),
  9    14 	format_value_node		initial("000001010"b),
  9    15 	list_node			initial("000001011"b),
  9    16 	default_node		initial("000001100"b),
  9    17 	machine_state_node		initial("000001101"b),
  9    18 	source_node		initial("000001110"b),
  9    19 	label_node		initial("000001111"b),
  9    20 	cross_reference_node	initial("000010000"b),
  9    21 	sf_par_node		initial("000010001"b),
  9    22 	temporary_node		initial("000010010"b),
  9    23 	label_array_element_node	initial("000010011"b),
  9    24 	by_name_agg_node		initial("000010100"b))
  9    25 				bit(9) internal static aligned options(constant);
  9    26 
  9    27 dcl	1 node			based aligned,
  9    28 	2 type			unal bit(9),
  9    29 	2 source_id		unal structure,
  9    30 	  3 file_number		bit(8),
  9    31 	  3 line_number		bit(14),
  9    32 	  3 statement_number	bit(5);
  9    33 
  9    34 /* END INCLUDE FILE ... nodes.incl.pl1 */
      156 
 10     1 /* BEGIN INCLUDE FILE ... boundary.incl.pl1 */
 10     2 
 10     3 /* Modified: 26 Apr 1979 by PCK to implement 4-bit decimal */
 10     4 
 10     5 dcl (	bit_		init(1),
 10     6 	digit_		init(2),
 10     7 	character_	init(3),
 10     8 	half_		init(4),
 10     9 	word_		init(5),
 10    10 	mod2_		init(6),
 10    11 	mod4_		init(7)) fixed bin(3) int static options(constant);
 10    12 
 10    13 /* END INCLUDE FILE ... boundary.incl.pl1 */
      157 
 11     1 /* BEGIN INCLUDE FILE ... cgsystem.incl.pl1 */
 11     2 
 11     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
 11     4 
 11     5 dcl (	bits_per_char		init(9),
 11     6 	bits_per_half		init(18),
 11     7 	bits_per_word		init(36),
 11     8 	bits_per_two_words		init(72),
 11     9 	bits_per_four_words		init(144),
 11    10 	bits_per_words(2)		init(36,72),
 11    11 	packed_digits_per_char	init(2),
 11    12 	chars_per_word		init(4),
 11    13 	packed_digits_per_word	init(8),
 11    14 
 11    15 	break_even_bits		init(216),
 11    16 	break_even_words		init(6),
 11    17 
 11    18 	label_size		init(4),
 11    19 
 11    20 	convert_size(13:14)		init(9,1),
 11    21 	max_offset(13:14)		init(27,35),
 11    22 	max_short_size(13:14)	init(8,72),
 11    23 
 11    24 	units_per_word(0:5)		init(1,36,8,4,2,1),
 11    25 
 11    26 	max_dec_scale		init(32),
 11    27 	min_dec_scale		init(-31),
 11    28 	max_p_xreg		init(18),
 11    29 	max_p_fix_bin_1		init(35),
 11    30 	max_p_flt_bin_1		init(27),
 11    31 	max_p_fix_dec		init(59),
 11    32 	max_length_p		init(24),
 11    33 	default_fix_bin_p		init(17)) fixed bin(8) int static options(constant);
 11    34 
 11    35 dcl      (convert_offset(0:5)		init(36,1,4.5,9,18,36),
 11    36 	bits_per_packed_digit	init(4.5)) fixed bin(8,1) int static options(constant);
 11    37 
 11    38 dcl	max_index_register_value	init(262143) fixed bin(31) int static options(constant);
 11    39 
 11    40 /* END INCLUDE FILE ... cgsystem.incl.pl1 */
 11    41 
      158 
      159 
      160 /* This entry handles types 1 -3 and only loads bp */
      161 
      162 begin:
      163           n = code;                                         /* see list of values above */
      164           j, k = -1;
      165           want_a_PR = "1"b;
      166           go to load_any_var_load_aq_common;
      167 
      168 load_aq_var:
      169      entry (var);
      170 
      171 /* ASSUMPTIONS: this will only be called with pointer values */
      172 
      173           n = 1;
      174           j, k = -1;
      175           want_a_PR = "0"b;
      176           a_q_aq = 2;                                       /* AQ */
      177           go to load_any_var_load_aq_common;
      178 
      179 load_a_var:
      180      entry (var);
      181 
      182           n = 1;
      183           j, k = -1;
      184           want_a_PR = "0"b;
      185           a_q_aq = 0;
      186           go to load_any_var_load_aq_common;
      187 
      188 load_q_var:
      189      entry (var);
      190 
      191           n = 1;
      192           j, k = -1;
      193           want_a_PR = "0"b;
      194           a_q_aq = 1;
      195 
      196 load_any_var_load_aq_common:
      197           vp = var;
      198 
      199 /* Search the registers to see if we already have the registers */
      200 
      201           do i = 1 to last_base;
      202                type = base_regs (i).type;
      203                if type = 0
      204                then k = i;
      205                else if type = n                             /* contains the address type */
      206                then if base_regs (i).variable = vp
      207                     then do;
      208                               if ^want_a_PR
      209                               then go to PR_to_AQ;
      210                               if ^vp -> reference.shared
      211                               then call adjust_ref_count (vp, -1);
      212                               base3 = bases (i);
      213                               go to reset_perm;
      214                          end;
      215           end;
      216 
      217 /* We must load a register */
      218 
      219           call when_to_m_a;
      220           if ^want_a_PR
      221           then go to load_AQ;
      222           i = get_free_base ();
      223           base3 = bases (i);
      224           go to l1a;
      225 
      226 PR_to_AQ:                                                   /* come here with the PR number in i */
      227           string (vp -> address) = ""b;
      228           vp -> address.base = bases (i);                   /* fix the reference */
      229           vp -> address.ext_base = "1"b;
      230           vp -> reference.perm_address = "1"b;
      231           vp -> reference.relocation = ""b;                 /* Has to be absolute, its XXXX prn|0 */
      232           call expmac (e_a_q_aq_mac (a_q_aq), vp);
      233           go to AQ_finish;
      234 
      235 load_AQ:
      236           if ^addressable
      237           then do;
      238                     call m_a (vp, "00"b);
      239                     vp -> reference.perm_address = "1"b;
      240                end;
      241 
      242           if substr (vp -> address.tag, 1, 2)               /* Is there a star ? */
      243           then do;
      244                     if ^vp -> reference.shared
      245                     then vp -> reference.ref_count = vp -> reference.ref_count + 1;
      246                     call base_man$load_any_var (n, var, new_base);
      247                     i = which_base (bin (new_base, 3));
      248                     go to PR_to_AQ;
      249                end;
      250 
      251           substr (vp -> address.tag, 1, 2) = "01"b;         /* convert to RI mod */
      252           call expmac (e_a_q_aq_mac (a_q_aq), vp);
      253 
      254 AQ_finish:
      255           vp -> reference.perm_address = "0"b;              /* force m_a to recalculate, since we may have patched the tag */
      256           return;
      257 
      258 base_man$load_any_var_and_lock:
      259      entry (code, var, base3);
      260 
      261           lock = "1"b;
      262           go to begin;
      263 
      264 
      265 base_man$load_var_and_lock:
      266      entry (code, var, which);
      267 
      268           lock = "1"b;
      269 
      270 
      271 base_man$load_var:
      272      entry (code, var, which);
      273 
      274 dcl       which               fixed bin;                    /* which base to load */
      275 
      276           i = which;
      277           j, k = -1;
      278 
      279           vp = var;
      280           n = code;
      281           call when_to_m_a;
      282 
      283 /* See if item is already in a pointer register */
      284 
      285           do k = 1 to last_base;
      286                if base_regs (k).type = n
      287                then if base_regs (k).variable = vp
      288                     then if k = i
      289                          then do;
      290                                    if ^vp -> reference.shared
      291                                    then call adjust_ref_count (vp, -1);
      292                                    go to reset_perm;
      293                               end;
      294                          else j = k;
      295           end;
      296 
      297 /* Section to load the pointer register */
      298 
      299 
      300           do;
      301                cg_stat$last_base_used = i;
      302 l1a:
      303                macro = load_base (0, i);
      304 
      305 /* If we have the item in another pointer register, move it over */
      306 
      307                if j >= 0
      308                then do;
      309                          call change_base (i);
      310                          p = c_a (0, 4);
      311                          p -> address.base = bases (j);
      312                          call expmac (macro, p);
      313                          if ^vp -> reference.shared
      314                          then call adjust_ref_count (vp, -1);
      315                          if n = 2
      316                          then do;
      317                                    vp -> reference.address_in.b (i) = "1"b;
      318                                    go to l2;
      319                               end;
      320                          else go to l1b;
      321                     end;
      322 
      323 /*  To get the item, we must make it addressable */
      324 
      325                if ^addressable
      326                then do;
      327                          call m_a (vp, "0"b || eis);
      328                          vp -> reference.perm_address = "1"b;
      329                     end;
      330 
      331                call change_base (i);
      332 
      333 
      334                if n = 2
      335                then do;
      336 
      337                          if eis
      338                          then do;                           /* mask out the tag */
      339                                    tag_hold = vp -> address.tag & "001111"b;
      340                                    vp -> address.tag = vp -> address.tag & "010000"b;
      341                               end;
      342 
      343                          call expmac (macro, vp);
      344 
      345                          if vp -> reference.units ^= word_
      346                          then do;
      347                                    macro = add_base (vp -> reference.units);
      348                                    p = get_reference ();
      349                                    string (p -> reference.address) = bases (i);
      350                                    p -> address.ext_base = "1"b;
      351                                    p -> reference.relocation = "0"b;
      352                                    p -> reference.perm_address = "1"b;
      353 
      354                                    if eis
      355                                    then do;
      356                                              if vp -> reference.c_f_offset ^= 0
      357                                              then call add_cfo;
      358                                              p -> address.tag = tag_hold;
      359                                         end;
      360                                    else do;
      361                                              fract_offset =
      362                                                   mod (vp -> reference.c_offset, units_per_word (vp -> reference.units));
      363                                              if fract_offset < 0
      364                                              then fract_offset = fract_offset + units_per_word (vp -> reference.units);
      365                                              call xr_man$load_any_const (fract_offset, xr);
      366                                              p -> address.tag = "001"b || bit (xr, 3);
      367                                         end;
      368 
      369                                    if p -> address.tag
      370                                    then call exp_addmac;
      371                               end;
      372 
      373                          if vp -> reference.symbol ^= null
      374                          then do;
      375                                    string (vp -> reference.address) = bases (i);
      376                                    vp -> address.ext_base = "1"b;
      377                                    vp -> reference.relocation = "0"b;
      378                                    vp -> reference.c_f_offset = 0;
      379                                    vp -> reference.ic_ref = "0"b;
      380                               end;
      381 
      382                          vp -> reference.address_in.b (i) = "1"b;
      383 
      384                          goto l2;
      385                     end;
      386 
      387                if substr (vp -> address.tag, 1, 2)
      388                then do;
      389                          if ^vp -> reference.shared
      390                          then vp -> reference.ref_count = vp -> reference.ref_count + 1;
      391                          call expmac (macro, vp);
      392                          string (vp -> reference.address) = bases (i);
      393                          vp -> address.ext_base = "1"b;
      394                          vp -> address.tag = "010000"b;     /* * */
      395                          vp -> reference.relocation = "0"b;
      396                     end;
      397                else substr (vp -> address.tag, 1, 2) = "01"b;
      398                                                             /* convert to RI mod */
      399 
      400                call expmac (macro, vp);
      401 
      402 l1b:
      403                vp -> reference.value_in.b (i) = "1"b;
      404 l2:
      405                base_regs (i).variable = vp;
      406 
      407                base_regs (i).type = n;
      408                if lock
      409                then base_regs (i).locked = base_regs (i).locked + 1;
      410                else base_regs (i).locked = 0;
      411 
      412           end;
      413 
      414 reset_perm:
      415           if vp -> reference.symbol ^= null
      416           then vp -> reference.perm_address = "0"b;
      417 
      418 used_i:
      419           base_regs (i).used = cg_stat$text_pos;
      420           return;
      421 
      422 base_man$load_stack_indirect:
      423      entry (code, base2);
      424 
      425           n = code;
      426 
      427           k = -1;
      428           do i = 1 to last_base;
      429                type = base_regs (i).type;
      430                if type = 0
      431                then k = i;
      432                else if type = 3
      433                then if base_regs (i).constant = n
      434                     then go to l8;
      435           end;
      436 
      437           i = get_free_base ();
      438 
      439 
      440           call change_base (i);
      441 
      442           vp = c_a (n, 14);                                 /* sp|n,* */
      443           call expmac ((load_base (0, i)), vp);
      444 
      445           base_regs (i).type = 3;
      446           base_regs (i).constant = n;
      447 
      448 l8:
      449           base2 = bases (i);
      450           goto used_i;
      451 
      452 base_man$load_display:
      453      entry (frames, base2);
      454 
      455 dcl       frames              fixed bin,                    /* number of frames */
      456           base2               bit (3) aligned;              /* set to base loaded */
      457 
      458 dcl       (fmin, nframes)     fixed bin;
      459 
      460           j, k = -1;
      461           n, fmin = frames;
      462 
      463 /* Search for a register with a display pointer already loaded */
      464 
      465           do i = 1 to last_base;
      466                type = base_regs (i).type;
      467                if type = 0
      468                then k = i;
      469                else if type = 4
      470                then do;
      471                          if base_regs (i).constant = n
      472                          then go to l6;
      473                          if base_regs (i).constant < n
      474                          then do;
      475                                    nframes = n - base_regs (i).constant;
      476                                    if nframes < fmin
      477                                    then do;
      478                                              fmin = nframes;
      479                                              j = i;
      480                                         end;
      481                               end;
      482                     end;
      483           end;
      484 
      485           i = get_free_base ();
      486 
      487 /* Get first pointer in the chain */
      488 
      489           call change_base (i);
      490 
      491           vp = c_a (display_offset, 14);                    /* sp|32,* */
      492           if j > 0
      493           then vp -> address.base = bases (j);
      494           macro = load_base (0, i);
      495 
      496           call expmac (macro, vp);
      497 
      498 /* If necessary, follow the chain */
      499 
      500           if fmin > 1
      501           then do;
      502                     vp -> address.base = bases (i);
      503                     do j = 2 to fmin;
      504                          call expmac (macro, vp);
      505                     end;
      506                end;
      507 
      508 
      509           base_regs (i).type = 4;
      510           base_regs (i).constant = frames;
      511 
      512 l6:
      513           base2 = bases (i);
      514           go to used_i;
      515 
      516 
      517 base_man$load_static:
      518      entry (base1);
      519 
      520           if cg_stat$separate_static
      521           then do;
      522                     n = 13;
      523                     j = 1;
      524                     ca_code = 4;
      525                     go to link_join;
      526                end;
      527 
      528 
      529 base_man$load_linkage:
      530      entry (base1);
      531 
      532 dcl       base1               bit (3) aligned;              /* set to base loaded */
      533 
      534           n = 5;
      535           j = 0;
      536           ca_code = 14;
      537 link_join:
      538           k = -1;
      539 
      540 /* search for a register with ptr already loaded */
      541 
      542           do i = 2 to last_base;
      543                type = base_regs (i).type;
      544                if type = 0
      545                then k = i;
      546                else if type = n
      547                then go to set_base1;
      548           end;
      549 
      550 /* we prefer to use the lp */
      551 
      552           if base_regs (2).type < 5
      553           then i = 2;
      554           else i = get_free_base ();
      555 
      556 /* flush register i */
      557 
      558           call change_base (i);
      559 
      560 /* load the register from the correct offset */
      561 
      562           vp = c_a ((link_info (j)), ca_code);
      563           call expmac ((load_base (j, i)), vp);
      564           base_regs (i).type = n;
      565 
      566 set_base1:
      567           base1 = bases (i);
      568           base_regs (i).used = cg_stat$text_pos;
      569           return;
      570 
      571 
      572 base_man$load_arg:
      573      entry (code, blk_pt, base3);
      574 
      575 dcl       blk_pt              ptr;                          /* points at a blk node */
      576 
      577           vp = blk_pt;
      578 
      579           j = code + 6;
      580 
      581           do i = 1 to last_base;
      582                if base_regs (i).type = j
      583                then if base_regs (i).variable = vp
      584                     then go to l7;
      585           end;
      586 
      587           n = cg_stat$cur_level - vp -> block.level;
      588           if n = 0
      589           then base = sp;
      590           else call base_man$load_display (n, base);
      591 
      592           call setk;
      593 
      594           i = get_free_base ();
      595 
      596           if vp -> block.no_stack
      597           then n = vp -> block.entry_info + 2 + 2 * code;
      598           else n = stack_info (code);
      599 
      600           call change_base (i);
      601 
      602           p = c_a (n, 14);
      603           p -> address.base = base;
      604           call expmac ((load_base (0, i)), p);
      605 
      606           base_regs (i).type = j;
      607           base_regs (i).variable = vp;
      608 
      609 l7:
      610           base3 = bases (i);
      611           goto used_i;
      612 
      613 base_man$load_link_indirect:
      614      entry (poff, reloc, base3);
      615 
      616 dcl       (poff, off)         fixed bin,                    /* offset in linkage or static section */
      617           reloc               bit (12) aligned;             /* relocation to use */
      618 
      619 dcl       multiple            fixed bin;
      620 
      621           off = poff;
      622 
      623           if reloc = rc_lp15
      624           then do;                                          /* link indirect */
      625                     n = 8;
      626                     j = 9;
      627                end;
      628           else do;                                          /* static indirect */
      629                     n = 14;
      630                     j = 15;
      631                end;
      632 
      633           do i = 1 to last_base;
      634                if base_regs (i).type = n
      635                then if base_regs (i).constant = off
      636                     then go to l10;
      637           end;
      638 
      639           vp = c_a (off, j);
      640 
      641           call setk;
      642 
      643           i = get_free_base ();
      644 
      645           call change_base (i);
      646 
      647 
      648           call expmac ((load_base (0, i)), vp);
      649 
      650           base_regs (i).type = n;
      651           base_regs (i).constant = off;
      652 
      653 l10:
      654           base3 = bases (i);
      655           go to used_i;
      656 
      657 base_man$load_controlled:
      658      entry (poff, desc, base3);
      659 
      660 dcl       desc                fixed bin;                    /* zero if data, otherwise desc */
      661 
      662           n = 11 + fixed (desc ^= 0, 1);
      663           off = poff;
      664 
      665           do i = 1 to last_base;
      666                if base_regs (i).type = n
      667                then if base_regs (i).constant = off
      668                     then go to l10;
      669           end;
      670 
      671           call base_man$load_link_indirect (off, (rc_lp15), base);
      672 
      673           call setk;
      674 
      675           i = get_free_base ();
      676 
      677           call change_base (i);
      678 
      679           p = c_a (desc, 14);
      680           p -> address.base = base;
      681           call expmac ((load_base (0, i)), p);
      682 
      683           base_regs (i).type = n;
      684           base_regs (i).constant = off;
      685 
      686           goto l10;
      687 
      688 base_man$load_arg_ptr:
      689      entry (code, blk_pt, argno, base4);
      690 
      691 dcl       argno               fixed bin,                    /* which arg */
      692           base4               bit (3) aligned;              /* set to base loaded */
      693 
      694           vp = blk_pt;
      695 
      696           n = code + 9;
      697 
      698           do i = 1 to last_base;
      699                type = base_regs (i).type;
      700                if type = n
      701                then if base_regs (i).variable = vp
      702                     then if base_regs (i).constant = argno
      703                          then go to l9;
      704           end;
      705 
      706           call base_man$load_arg (code, blk_pt, base);
      707 
      708           call setk;
      709 
      710           i = get_free_base ();
      711 
      712           call change_base (i);
      713 
      714           p = c_a (2 * (argno - code), 14);
      715           p -> address.base = base;
      716 
      717           call expmac ((load_base (0, i)), p);
      718 
      719           base_regs (i).type = n;
      720           base_regs (i).variable = vp;
      721           base_regs (i).constant = argno;
      722 
      723 l9:
      724           base4 = bases (i);
      725           goto used_i;
      726 
      727 base_man$store_ptr_to:
      728      entry (pa, pb);
      729 
      730 /* this entry is called to store a ptr to reference pa in
      731*             reference pb */
      732 
      733 dcl       (pa, pb)            ptr;
      734 
      735           do i = 1 to last_base;
      736                if base_regs (i).type = 2
      737                then if base_regs (i).variable = pa
      738                     then do;
      739                               if ^pa -> reference.shared
      740                               then call adjust_ref_count (pa, -1);
      741                               go to store;
      742                          end;
      743           end;
      744 
      745           i = 1;
      746 
      747           call base_man$load_var (2, pa, i);
      748 
      749 store:
      750           if pb -> reference.symbol ^= null
      751           then call base_to_core (i, pb);
      752           else do;
      753                     call expmac ((store_base (23, i)), pb);
      754                     if pb -> reference.temp_ref
      755                     then pb -> reference.value_in.storage = "1"b;
      756                end;
      757 
      758           return;
      759 
      760 base_man$update_base:
      761      entry (code, var, which);
      762 
      763 /* This entry is called to update the contents of the base register state */
      764 
      765           i = which;
      766           call change_base (i);
      767 
      768           vp = var;
      769           n = code;
      770 
      771           if n = 2
      772           then do;
      773                     vp -> reference.address_in.b (i) = "1"b;
      774                     goto l2;
      775                end;
      776 
      777           if n = 1
      778           then goto l1b;
      779 
      780           if n >= 5 & n <= 7
      781           then do;
      782                     base_regs (i).type = n;
      783                     base_regs (i).variable = vp;
      784                     go to used_i;
      785                end;
      786           else base_regs (i).type = 0;
      787           return;
      788 
      789 base_man$load_packed:
      790      entry (pa, where);
      791 
      792 /* This entry is called when an assigment from packed ptr to unpacked ptr is
      793*             found as the qualifier of a reference node, or when such an assignment is
      794*             found elsewhere.  The packed ptr is loaded into any register. */
      795 
      796 dcl       where               fixed bin;
      797 
      798           n = 1;
      799 
      800           p = pa;
      801           vp = p -> operand (1);
      802 
      803           if vp -> reference.shared & vp -> reference.symbol -> symbol.temporary
      804           then vp, p -> operand (1) = copy_temp (vp);
      805 
      806           vp = prepare_operand (vp, 1, atomic);
      807 
      808 
      809           q = prepare_operand ((p -> operand (2)), 1, atomic);
      810 
      811           if ^atomic
      812           then q = compile_exp$save ((p -> operand (2)));
      813 
      814           k = -1;
      815           do i = first_base to last_base;
      816                if base_regs (i).type = 0
      817                then k = i;
      818                else if q -> reference.temp_ref
      819                then if base_regs (i).type = 1
      820                     then if base_regs (i).variable = q
      821                          then do;
      822                                    where = i;
      823                                    call adjust_ref_count (q, -1);
      824                                    go to used_i;
      825                               end;
      826           end;
      827 
      828           if q -> reference.temp_ref
      829           then if ^q -> reference.value_in.storage
      830                then if q -> reference.value_in.q
      831                     then do;
      832                               q -> reference.ref_count = q -> reference.ref_count + 1;
      833                               q -> reference.store_ins = bit (cg_stat$text_pos, 18);
      834                               call expmac ((stfx1), q);
      835                               q -> reference.value_in.storage = "1"b;
      836                          end;
      837                     else call error (315, cg_stat$cur_statement, q);
      838 
      839           p = vp;
      840           vp = q;
      841 
      842           call when_to_m_a;
      843           i = get_free_base ();
      844 
      845           where = i;
      846 
      847           call change_base (i);
      848 
      849           call expmac ((load_base (1, i)), vp);
      850 
      851           vp = p;
      852           go to l1b;
      853 
      854 
      855 base_man$lock:
      856      entry (lbase);
      857 dcl       lbase               fixed bin;
      858           base_regs (lbase).locked = base_regs (lbase).locked + 1;
      859           return;
      860 
      861 base_man$unlock:
      862      entry (lbase);
      863           base_regs (lbase).locked = base_regs (lbase).locked - 1;
      864           return;
      865 
      866 
      867 
      868 /* */
      869 when_to_m_a:
      870      proc;
      871 dcl       p                   ptr;
      872 
      873 /* Decide whether we must make vp addressable before looking for a free base
      874*   register and loading it */
      875 
      876           eis = "0"b;
      877           addressable = ^vp -> reference.no_address & vp -> reference.perm_address;
      878           if string (vp -> reference.value_in.b)
      879           then return;
      880           if string (vp -> reference.address_in.b)
      881           then return;
      882 
      883           if n = 2
      884           then if vp -> reference.units ^= word_
      885                then if ^vp -> reference.modword_in_offset
      886                     then eis = "1"b;
      887 
      888           if addressable
      889           then return;
      890 
      891           do p = vp -> reference.qualifier repeat p -> reference.qualifier while (p ^= null);
      892                if p -> node.type = temporary_node
      893                then return;
      894                if p -> node.type = operator_node
      895                then do;
      896                          if p -> operator.op_code = param_ptr
      897                          then go to call_ma;
      898                          p = p -> operand (1);
      899                     end;
      900                if string (p -> reference.value_in.b)
      901                then go to call_ma;
      902                if string (p -> reference.address_in.b)
      903                then go to call_ma;
      904                if p -> reference.ref_count > 1
      905                then do;
      906 call_ma:
      907                          call m_a (vp, "0"b || eis);
      908                          vp -> reference.perm_address = "1"b;
      909                          addressable = "1"b;
      910                          if k >= first_base
      911                          then if base_regs (k).type ^= 0
      912                               then call setk;
      913                          return;
      914                     end;
      915           end;
      916      end;
      917 
      918 
      919 
      920 /* */
      921 get_free_base:
      922      proc () returns (fixed bin);
      923 
      924 /* If an empty register was found in the scan, use that; otherwise pick a
      925*   register containing a variable with the lowest reference count, priority, and
      926*   least recently used */
      927 
      928 dcl       (i, j, cmin, n, pr, pmin, type)
      929                               fixed bin;
      930 dcl       p                   ptr;
      931 dcl       priority            (14) fixed bin int static init (3, 3, 2, 4, 5, 4, 3, 2, 3, 1, 3, 1, 5, 2);
      932 
      933 /* Variable k lives in the outer block */
      934 
      935           if k >= first_base
      936           then if base_regs (k).locked = 0
      937                then do;
      938                          cg_stat$last_base_used = k;
      939                          return (k);
      940                     end;
      941 
      942           j = -1;
      943           cmin = 123456;
      944           do i = max (cg_stat$last_base_used + 1, first_base) to last_base, first_base to cg_stat$last_base_used;
      945                if base_regs (i).locked > 0
      946                then go to try_another;
      947 
      948                type = base_regs (i).type;
      949                if type = 0
      950                then do;
      951 hit:
      952                          cg_stat$last_base_used = i;
      953                          return (i);
      954                     end;
      955 
      956                p = base_regs (i).variable;
      957 
      958                if type < 3
      959                then do;
      960                          if p = null
      961                          then go to hit;
      962                          n = p -> reference.ref_count;
      963 
      964                          if ^p -> reference.shared
      965                          then if n <= 0
      966                               then go to hit;
      967                               else ;
      968                          else if p -> reference.temp_ref
      969                          then go to hit;
      970 
      971                          pr = 3;
      972                     end;
      973                else do;
      974                          n = 0;
      975                          pr = priority (type);
      976                     end;
      977 
      978                if n < cmin
      979                then do;
      980                          cmin = n;
      981 sj:
      982                          pmin = pr;
      983                          j = i;
      984                     end;
      985                else if n = cmin
      986                then if pr < pmin
      987                     then go to sj;
      988                     else if pr = pmin
      989                     then if base_regs (i).used < base_regs (j).used
      990                          then go to sj;
      991 try_another:
      992           end;
      993 
      994           cg_stat$last_base_used = j;
      995           return (j);
      996      end;
      997 
      998 
      999 
     1000 
     1001 /* */
     1002 
     1003 change_base:
     1004      proc (m);
     1005 
     1006 dcl       (m, n, t)           fixed bin,
     1007           p                   ptr;
     1008 
     1009           n = m;
     1010           p = base_regs (n).variable;
     1011           if p = null
     1012           then return;
     1013 
     1014           t = base_regs (n).type;
     1015 
     1016           if t = 2
     1017           then do;
     1018                     p -> reference.address_in.b (n) = "0"b;
     1019                     return;
     1020                end;
     1021 
     1022           if t ^= 1
     1023           then return;
     1024 
     1025           p -> reference.value_in.b (n) = "0"b;
     1026 
     1027           if ^p -> reference.temp_ref
     1028           then return;
     1029           if p -> reference.value_in.storage
     1030           then return;
     1031           if p -> reference.dont_save
     1032           then return;
     1033 
     1034           if p -> reference.ref_count > 0
     1035           then do;
     1036                     p -> reference.ref_count = p -> reference.ref_count + 1;
     1037                     p -> reference.store_ins = bit (cg_stat$text_pos, 18);
     1038                     call expmac ((store_base (p -> reference.data_type, n)), p);
     1039                     p -> reference.value_in.storage = "1"b;
     1040                end;
     1041 
     1042      end;                                                   /* */
     1043 setk:
     1044      proc;
     1045 
     1046           k = -1;
     1047           do i = last_base to first_base by -1;
     1048                if base_regs (i).type = 0
     1049                then do;
     1050                          k = i;
     1051                          return;
     1052                     end;
     1053           end;
     1054 
     1055      end;                                                   /**/
     1056 exp_addmac:
     1057      proc;
     1058 
     1059 /* Issues add bits or bytes to pointer macro */
     1060 
     1061           text_pos = cg_stat$text_pos;
     1062 
     1063           call expmac (macro, p);
     1064 
     1065           base_regs (i).changed = text_pos;
     1066           base_regs (i).instruction = addrel (cg_stat$text_base, text_pos) -> full_word;
     1067      end;
     1068 
     1069 
     1070 
     1071 add_cfo:
     1072      proc;
     1073 
     1074 /* routine to add in constant_fractional_offset if not already done */
     1075 
     1076           if substr (tag_hold, 3, 1)
     1077           then do;
     1078                     call xr_man$add_any_const ((vp -> reference.c_f_offset), xr, fixed (substr (tag_hold, 4, 3), 3));
     1079                     tag_hold = "001"b || bit (xr, 3);
     1080                end;
     1081           else do;
     1082                     call xr_man$load_any_const ((vp -> reference.c_f_offset), xr);
     1083                     p -> address.tag = "001"b || bit (xr, 3);
     1084                     call exp_addmac;
     1085                end;
     1086      end;
     1087 
     1088      end base_man$load_any_var;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/83  1007.9  base_man.pl1                      >spec>on>pl128d>base_man.pl1
148          1    04/07/83  1635.0  op_codes.incl.pl1                 >ldd>include>op_codes.incl.pl1
149          2    07/21/80  1546.3  operator.incl.pl1                 >ldd>include>operator.incl.pl1
150          3    08/13/81  2043.5  block.incl.pl1                    >ldd>include>block.incl.pl1
151          4    11/13/79  1015.8  machine_state.incl.pl1            >ldd>include>machine_state.incl.pl1
152          5    10/02/83  0828.4  symbol.incl.pl1                   >spec>on>pl128d>symbol.incl.pl1
153          6    07/21/80  1546.3  cg_reference.incl.pl1             >ldd>include>cg_reference.incl.pl1
154          7    05/03/76  1320.8  bases.incl.pl1                    >ldd>include>bases.incl.pl1
155          8    10/30/80  1648.7  relocation_bits.incl.pl1          >ldd>include>relocation_bits.incl.pl1
156          9    07/21/80  1546.3  nodes.incl.pl1                    >ldd>include>nodes.incl.pl1
157         10    10/25/79  1645.8  boundary.incl.pl1                 >ldd>include>boundary.incl.pl1
158         11    10/25/79  1645.8  cgsystem.incl.pl1                 >ldd>include>cgsystem.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_q_aq                          000130 automatic       fixed bin(17,0)          dcl 104 set ref 176* 185* 194* 232 252
add_base                        000052 constant        fixed bin(15,0)          initial array dcl 127 ref 347
addrel                                                 builtin function         dcl 107 ref 1066
address                  10            based           structure                level 2 packed unaligned dcl 6-3 set ref 226* 349*
                                                                                  375* 392*
address_in               11            based           structure                level 3 packed unaligned dcl 6-3
addressable                     000116 automatic       bit(1)                   dcl 52 set ref 235 325 877* 888 909*
adjust_ref_count                000060 constant        entry                    external dcl 52 ref 210 290 313 739 823
argno                                  parameter       fixed bin(17,0)          dcl 691 ref 688 700 714 721
atomic                          000117 automatic       bit(1)                   dcl 52 set ref 806* 809* 811
attributes               31            based           structure                level 2 dcl 5-3
b                        11            based           bit(1)                   array level 4 in structure "reference" packed
                                                                                  unaligned dcl 6-3 in procedure
                                                                                  "base_man$load_any_var" set ref 317* 382* 773* 880
                                                                                  902 1018*
b                        11(15)        based           bit(1)                   array level 4 in structure "reference" packed
                                                                                  unaligned dcl 6-3 in procedure
                                                                                  "base_man$load_any_var" set ref 402* 878 900 1025*
base                     10            based           bit(3)                   level 3 in structure "reference" packed unaligned
                                                                                  dcl 6-3 in procedure "base_man$load_any_var" set
                                                                                  ref 228* 311* 492* 502* 603* 680* 715*
base                            000125 automatic       bit(3)                   dcl 52 in procedure "base_man$load_any_var" set ref
                                                                                  588* 590* 603 671* 680 706* 715
base1                                  parameter       bit(3)                   dcl 532 set ref 517 529 566*
base2                                  parameter       bit(3)                   dcl 455 set ref 422 448* 452 512*
base3                                  parameter       bit(3)                   dcl 48 set ref 45 212* 223* 258 572 609* 613 653*
                                                                                  657
base4                                  parameter       bit(3)                   dcl 691 set ref 688 723*
base_man$load_any_var           000040 constant        entry                    external dcl 52 ref 246
base_man$load_arg               000036 constant        entry                    external dcl 52 ref 706
base_man$load_display           000034 constant        entry                    external dcl 52 ref 590
base_man$load_link_indirect     000042 constant        entry                    external dcl 52 ref 671
base_man$load_var               000032 constant        entry                    external dcl 52 ref 747
base_regs               160            based           structure                array level 2 dcl 4-6
base_to_core                    000030 constant        entry                    external dcl 52 ref 749
bases                           000034 constant        bit(3)                   initial array dcl 7-1 ref 212 223 228 311 349 375
                                                                                  392 448 492 502 512 566 588 588 609 653 723
bit                                                    builtin function         dcl 107 ref 366 833 1037 1079 1083
bits                     12(06)        based           structure                level 2 packed unaligned dcl 6-3
blk_pt                                 parameter       pointer                  dcl 575 set ref 572 577 688 694 706*
block                                  based           structure                level 1 dcl 3-5
c_a                             000052 constant        entry                    external dcl 52 ref 310 442 491 562 602 639 679 714
c_f_offset                7            based           fixed bin(6,0)           level 2 dcl 6-3 set ref 356 378* 1078 1082
c_offset                  1            based           fixed bin(24,0)          level 2 dcl 6-3 ref 361
ca_code                         000106 automatic       fixed bin(17,0)          dcl 52 set ref 524* 536* 562*
cg_stat$cur_level               000010 external static fixed bin(17,0)          dcl 52 ref 587
cg_stat$cur_statement           000022 external static pointer                  dcl 52 set ref 837*
cg_stat$last_base_used          000014 external static fixed bin(17,0)          dcl 52 set ref 301* 938* 944 944 951* 994*
cg_stat$separate_static         000016 external static bit(1)                   dcl 52 ref 520
cg_stat$text_base               000020 external static pointer                  dcl 52 ref 1066
cg_stat$text_pos                000012 external static fixed bin(17,0)          dcl 52 ref 418 568 833 1037 1061
cg_static_$m_s_p                000066 external static pointer                  dcl 4-3 ref 4-3
changed                 201            based           fixed bin(18,0)          array level 3 dcl 4-6 set ref 1065*
cmin                            000176 automatic       fixed bin(17,0)          dcl 928 set ref 943* 978 980* 985
code                                   parameter       fixed bin(17,0)          dcl 48 set ref 45 162 258 265 271 280 422 425 572
                                                                                  579 596 598 688 696 706* 714 760 769
compile_exp$save                000054 constant        entry                    external dcl 52 ref 811
constant                161            based           fixed bin(17,0)          array level 3 dcl 4-6 set ref 432 446* 471 473 475
                                                                                  510* 634 651* 666 684* 700 721*
copy_temp                       000026 constant        entry                    external dcl 52 ref 803
data_type                12            based           fixed bin(5,0)           level 2 packed unaligned dcl 6-3 ref 1038
desc                                   parameter       fixed bin(17,0)          dcl 660 set ref 657 662 679*
display_offset                  000044 constant        fixed bin(17,0)          initial dcl 146 set ref 491*
dont_save                12(21)        based           bit(1)                   level 3 packed unaligned dcl 6-3 ref 1031
e_a_q_aq_mac                    000055 constant        fixed bin(15,0)          initial array dcl 125 set ref 232* 252*
eis                             000120 automatic       bit(1)                   dcl 52 set ref 327 337 354 876* 883* 906
entry_info               50            based           fixed bin(18,0)          level 2 dcl 3-5 ref 596
error                           000064 constant        entry                    external dcl 52 ref 837
expmac                          000062 constant        entry                    external dcl 52 ref 232 252 312 343 391 400 443 496
                                                                                  504 563 604 648 681 717 753 834 849 1038 1063
ext_base                 10(29)        based           bit(1)                   level 3 packed unaligned dcl 6-3 set ref 229* 350*
                                                                                  376* 393*
first_base                             constant        fixed bin(3,0)           initial dcl 110 ref 815 910 935 944 944 1047
fixed                                                  builtin function         dcl 107 ref 662 1078 1078
fmin                            000134 automatic       fixed bin(17,0)          dcl 458 set ref 461* 476 478* 500 503
fract_offset                    000123 automatic       fixed bin(17,0)          dcl 52 set ref 361* 363 363* 363 365*
frames                                 parameter       fixed bin(17,0)          dcl 455 ref 452 461 510
full_word                              based           bit(36)                  dcl 52 ref 1066
get_reference                   000056 constant        entry                    external dcl 52 ref 348
i                               000174 automatic       fixed bin(17,0)          dcl 928 in procedure "get_free_base" set ref 944*
                                                                                  945 948 951 953 956 983 988*
i                               000100 automatic       fixed bin(17,0)          dcl 52 in procedure "base_man$load_any_var" set ref
                                                                                  201* 202 203 205 212* 222* 223 228 247* 276* 286
                                                                                  301 302 309* 317 331* 349 375 382 392 402 404 407
                                                                                  408 408 410 418 428* 429 430 432* 437* 440* 443
                                                                                  445 446 448 465* 466 467 471 473 475 479* 485*
                                                                                  489* 494 502 509 510 512 542* 543 544* 552* 554*
                                                                                  558* 563 564 566 568 581* 582 582* 594* 600* 604
                                                                                  606 607 609 633* 634 634* 643* 645* 648 650 651
                                                                                  653 665* 666 666* 675* 677* 681 683 684 698* 699
                                                                                  700 700* 710* 712* 717 719 720 721 723 735* 736
                                                                                  736* 745* 747* 749* 753 765* 766* 773 782 783 786
                                                                                  815* 816 816 818 818 822* 843* 845 847* 849 1047*
                                                                                  1048 1050* 1065 1066
ic_ref                   12(10)        based           bit(1)                   level 3 packed unaligned dcl 6-3 set ref 379*
info                     11            based           structure                level 2 packed unaligned dcl 6-3
instruction             202            based           bit(36)                  array level 3 dcl 4-6 set ref 1066*
j                               000175 automatic       fixed bin(17,0)          dcl 928 in procedure "get_free_base" set ref 942*
                                                                                  983* 988 994 995
j                               000101 automatic       fixed bin(17,0)          dcl 52 in procedure "base_man$load_any_var" set ref
                                                                                  164* 174* 183* 192* 277* 294* 307 311 460* 479*
                                                                                  492 492 503* 523* 535* 562 563 579* 582 606 626*
                                                                                  630* 639*
k                               000102 automatic       fixed bin(17,0)          dcl 52 set ref 164* 174* 183* 192* 203* 277* 285*
                                                                                  286 286 286 294* 427* 430* 460* 467* 537* 544*
                                                                                  814* 816* 910 910 935 935 938 939 1046* 1050*
last_base                              constant        fixed bin(3,0)           initial dcl 110 ref 201 285 428 465 542 581 633 665
                                                                                  698 735 815 944 1047
lbase                                  parameter       fixed bin(17,0)          dcl 857 ref 855 858 858 861 863 863
level                    45            based           fixed bin(17,0)          level 2 dcl 3-5 ref 587
link_info                       000046 constant        fixed bin(17,0)          initial array dcl 142 ref 562
load_base                       000074 constant        fixed bin(15,0)          initial array dcl 115 ref 302 443 494 563 604 648
                                                                                  681 717 849
lock                            000121 automatic       bit(1)                   initial dcl 52 set ref 52* 261* 268* 408
locked                  203            based           fixed bin(2,0)           array level 3 dcl 4-6 set ref 408* 408 410* 858* 858
                                                                                  863* 863 935 945
m                                      parameter       fixed bin(17,0)          dcl 1006 ref 1003 1009
m_a                             000050 constant        entry                    external dcl 52 ref 238 327 906
m_s_p                           000132 automatic       pointer                  initial dcl 4-3 set ref 202 205 286 286 404 407 408
                                                                                  408 410 418 429 432 445 446 466 471 473 475 509
                                                                                  510 543 552 564 568 582 582 606 607 634 634 650
                                                                                  651 666 666 683 684 699 700 700 719 720 721 736
                                                                                  736 782 783 786 816 818 818 858 858 863 863 4-3*
                                                                                  910 935 945 948 956 988 988 1010 1014 1048 1065
                                                                                  1066
machine_state                          based           structure                level 1 dcl 4-6
macro                           000126 automatic       fixed bin(15,0)          dcl 52 set ref 302* 312* 343* 347* 391* 400* 494*
                                                                                  496* 504* 1063*
mod                                                    builtin function         dcl 107 ref 361
modword_in_offset        11(35)        based           bit(1)                   level 4 packed unaligned dcl 6-3 ref 883
n                               000103 automatic       fixed bin(17,0)          dcl 52 in procedure "base_man$load_any_var" set ref
                                                                                  162* 173* 182* 191* 205 246* 280* 286 315 334 407
                                                                                  425* 432 442* 446 461* 471 473 475 522* 534* 546
                                                                                  564 587* 588 590* 596* 598* 602* 625* 629* 634 650
                                                                                  662* 666 683 696* 700 719 769* 771 777 780 780 782
                                                                                  798* 883
n                               000177 automatic       fixed bin(17,0)          dcl 928 in procedure "get_free_base" set ref 962*
                                                                                  964 974* 978 980 985
n                               000220 automatic       fixed bin(17,0)          dcl 1006 in procedure "change_base" set ref 1009*
                                                                                  1010 1014 1018 1025 1038
new_base                        000127 automatic       bit(3)                   dcl 103 set ref 246* 247
nframes                         000135 automatic       fixed bin(17,0)          dcl 458 set ref 475* 476 478
no_address               10(27)        based           bit(1)                   level 3 packed unaligned dcl 6-3 set ref 877
no_stack                 24(22)        based           bit(1)                   level 2 packed unaligned dcl 3-5 ref 596
node                                   based           structure                level 1 dcl 9-27
null                                                   builtin function         dcl 107 ref 373 414 749 891 960 1011
off                             000136 automatic       fixed bin(17,0)          dcl 616 set ref 621* 634 639* 651 663* 666 671* 684
op_code                   0(09)        based           bit(9)                   level 2 packed unaligned dcl 2-6 ref 896
operand                   1            based           pointer                  array level 2 packed unaligned dcl 2-6 set ref 801
                                                                                  803* 809 811 898
operator                               based           structure                level 1 dcl 2-6
operator_node                          constant        bit(9)                   initial dcl 9-5 ref 894
other                    11(33)        based           structure                level 3 packed unaligned dcl 6-3
p                               000164 automatic       pointer                  dcl 871 in procedure "when_to_m_a" set ref 891* 891*
                                                                                  892 894 896 898* 898 900 902 904* 915
p                               000204 automatic       pointer                  dcl 930 in procedure "get_free_base" set ref 956*
                                                                                  960 962 964 968
p                               000112 automatic       pointer                  dcl 52 in procedure "base_man$load_any_var" set ref
                                                                                  310* 311 312* 348* 349 350 351 352 358 366 369
                                                                                  602* 603 604* 679* 680 681* 714* 715 717* 800* 801
                                                                                  803 809 811 839* 851 1063* 1083
p                               000222 automatic       pointer                  dcl 1006 in procedure "change_base" set ref 1010*
                                                                                  1011 1018 1025 1027 1029 1031 1034 1036 1036 1037
                                                                                  1038 1038* 1039
pa                                     parameter       pointer                  dcl 733 set ref 727 736 739 739* 747* 789 800
param_ptr                              constant        bit(9)                   initial dcl 1-8 ref 896
pb                                     parameter       pointer                  dcl 733 set ref 727 749 749* 753* 754 754
perm_address             12(18)        based           bit(1)                   level 3 packed unaligned dcl 6-3 set ref 230* 239*
                                                                                  254* 328* 352* 414* 877 908*
pmin                            000201 automatic       fixed bin(17,0)          dcl 928 set ref 981* 985 988
poff                                   parameter       fixed bin(17,0)          dcl 616 ref 613 621 657 663
pr                              000200 automatic       fixed bin(17,0)          dcl 928 set ref 971* 975* 981 985 988
prepare_operand                 000024 constant        entry                    external dcl 52 ref 806 809
priority                        000000 constant        fixed bin(17,0)          initial array dcl 931 ref 975
q                        11(10)        based           bit(1)                   level 4 in structure "reference" packed unaligned
                                                                                  dcl 6-3 in procedure "base_man$load_any_var" ref
                                                                                  828
q                               000114 automatic       pointer                  dcl 52 in procedure "base_man$load_any_var" set ref
                                                                                  809* 811* 818 818 823* 828 828 828 832 832 833
                                                                                  834* 835 837* 840
qualifier                 4            based           pointer                  level 2 packed unaligned dcl 6-3 ref 891 915
rc_lp15                                constant        bit(6)                   initial unaligned dcl 8-6 ref 623 671
ref_count                 0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 6-3 set ref 244* 244
                                                                                  389* 389 832* 832 904 962 1034 1036* 1036
reference                              based           structure                level 1 dcl 6-3
reloc                                  parameter       bit(12)                  dcl 616 ref 613 623
relocation               12(24)        based           bit(12)                  level 2 packed unaligned dcl 6-3 set ref 231* 351*
                                                                                  377* 395*
shared                    0(11)        based           bit(1)                   level 2 packed unaligned dcl 6-3 ref 210 244 290 313
                                                                                  389 739 803 964
sp                                     defined         bit(3)                   dcl 7-4 ref 588
stack_info                      000050 constant        fixed bin(17,0)          initial array dcl 138 ref 598
stfx1                                  constant        fixed bin(15,0)          initial dcl 129 ref 834
storage                  11(23)        based           bit(1)                   level 4 packed unaligned dcl 6-3 set ref 754* 828
                                                                                  835* 1029 1039*
storage_class            32(09)        based           structure                level 3 packed unaligned dcl 5-3
store_base                      000060 constant        fixed bin(15,0)          initial array dcl 115 ref 753 1038
store_ins                13(18)        based           bit(18)                  level 2 packed unaligned dcl 6-3 set ref 833* 1037*
string                                                 builtin function         dcl 107 set ref 226* 349* 375* 392* 878 880 900 902
substr                                                 builtin function         dcl 107 set ref 242 251* 387 397* 1076 1078 1078
symbol                                 based           structure                level 1 dcl 5-3 in procedure "base_man$load_any_var"
symbol                    3            based           pointer                  level 2 in structure "reference" packed unaligned
                                                                                  dcl 6-3 in procedure "base_man$load_any_var" ref
                                                                                  373 414 749 803
t                               000221 automatic       fixed bin(17,0)          dcl 1006 set ref 1014* 1016 1022
tag                      10(30)        based           bit(6)                   level 3 packed unaligned dcl 6-3 set ref 242 251*
                                                                                  339 340* 340 358* 366* 369 387 394* 397* 1083*
tag_hold                        000122 automatic       bit(6)                   dcl 52 set ref 339* 358 1076 1078 1078 1079*
temp_ref                 12(11)        based           bit(1)                   level 3 packed unaligned dcl 6-3 ref 754 818 828 968
                                                                                  1027
temporary                32(17)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 803
temporary_node                         constant        bit(9)                   initial dcl 9-5 ref 892
text_pos                        000104 automatic       fixed bin(17,0)          dcl 52 set ref 1061* 1065 1066
type                            000202 automatic       fixed bin(17,0)          dcl 928 in procedure "get_free_base" set ref 948*
                                                                                  949 958 975
type                                   based           bit(9)                   level 2 in structure "node" packed unaligned
                                                                                  dcl 9-27 in procedure "base_man$load_any_var" ref
                                                                                  892 894
type                    162            based           fixed bin(8,0)           array level 3 in structure "machine_state" dcl 4-6
                                                                                  in procedure "base_man$load_any_var" set ref 202
                                                                                  286 407* 429 445* 466 509* 543 552 564* 582 606*
                                                                                  634 650* 666 683* 699 719* 736 782* 786* 816 818
                                                                                  910 948 1014 1048
type                            000105 automatic       fixed bin(17,0)          dcl 52 in procedure "base_man$load_any_var" set ref
                                                                                  202* 203 205 429* 430 432 466* 467 469 543* 544
                                                                                  546 699* 700
units                     0(14)        based           fixed bin(3,0)           level 2 packed unaligned dcl 6-3 ref 345 347 361 363
                                                                                  883
units_per_word                  000016 constant        fixed bin(8,0)           initial array dcl 11-5 ref 361 363
used                    200            based           fixed bin(18,0)          array level 3 dcl 4-6 set ref 418* 568* 988 988
value_in                 11(09)        based           structure                level 3 packed unaligned dcl 6-3
var                                    parameter       pointer                  dcl 48 set ref 45 168 179 188 196 246* 258 265 271
                                                                                  279 760 768
variable                160            based           pointer                  array level 3 packed unaligned dcl 4-6 set ref 205
                                                                                  286 404* 582 607* 700 720* 736 783* 818 956 1010
vp                              000110 automatic       pointer                  dcl 52 set ref 196* 205 210 210* 226 228 229 230 231
                                                                                  232* 238* 239 242 244 244 244 251 252* 254 279*
                                                                                  286 290 290* 313 313* 317 327* 328 339 340 340
                                                                                  343* 345 347 356 361 361 363 373 375 376 377 378
                                                                                  379 382 387 389 389 389 391* 392 393 394 395 397
                                                                                  400* 402 404 414 414 442* 443* 491* 492 496* 502
                                                                                  504* 562* 563* 577* 582 587 596 596 607 639* 648*
                                                                                  694* 700 720 768* 773 783 801* 803 803 803* 803*
                                                                                  806* 806* 839 840* 849* 851* 877 877 878 880 883
                                                                                  883 891 906* 908 1078 1082
want_a_PR                       000131 automatic       bit(1)                   initial dcl 105 set ref 105* 165* 175* 184* 193* 208
                                                                                  220
where                                  parameter       fixed bin(17,0)          dcl 796 set ref 789 822* 845*
which                                  parameter       fixed bin(17,0)          dcl 274 ref 265 271 276 760 765
which_base                      000024 constant        fixed bin(17,0)          initial array dcl 7-14 ref 247
word_                                  constant        fixed bin(3,0)           initial dcl 10-5 ref 345 883
xr                              000124 automatic       fixed bin(3,0)           dcl 52 set ref 365* 366 1078* 1079 1082* 1083
xr_man$add_any_const            000046 constant        entry                    external dcl 52 ref 1078
xr_man$load_any_const           000044 constant        entry                    external dcl 52 ref 365 1082

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
a_format                               internal static bit(9)                   initial dcl 1-8
ab                                     defined         bit(3)                   dcl 7-9
abs                                                    builtin function         dcl 107
abs_fun                                internal static bit(9)                   initial dcl 1-8
acos_fun                               internal static bit(9)                   initial dcl 1-8
acosd_fun                              internal static bit(9)                   initial dcl 1-8
add                                    internal static bit(9)                   initial dcl 1-8
addbitno_fun                           internal static bit(9)                   initial dcl 1-8
addcharno_fun                          internal static bit(9)                   initial dcl 1-8
addr_fun                               internal static bit(9)                   initial dcl 1-8
addr_fun_bits                          internal static bit(9)                   initial dcl 1-8
addrel_fun                             internal static bit(9)                   initial dcl 1-8
allocation_fun                         internal static bit(9)                   initial dcl 1-8
allot_auto                             internal static bit(9)                   initial dcl 1-8
allot_based                            internal static bit(9)                   initial dcl 1-8
allot_ctl                              internal static bit(9)                   initial dcl 1-8
allot_var                              internal static bit(9)                   initial dcl 1-8
and_bits                               internal static bit(9)                   initial dcl 1-8
ap                                     defined         bit(3)                   dcl 7-4
array_node                             internal static bit(9)                   initial dcl 9-5
asin_fun                               internal static bit(9)                   initial dcl 1-8
asind_fun                              internal static bit(9)                   initial dcl 1-8
assign                                 internal static bit(9)                   initial dcl 1-8
assign_by_name                         internal static bit(9)                   initial dcl 1-8
assign_round                           internal static bit(9)                   initial dcl 1-8
assign_size_ck                         internal static bit(9)                   initial dcl 1-8
assign_zero                            internal static bit(9)                   initial dcl 1-8
atan_fun                               internal static bit(9)                   initial dcl 1-8
atand_fun                              internal static bit(9)                   initial dcl 1-8
b_format                               internal static bit(9)                   initial dcl 1-8
base_man$load_linkage           000000 constant        entry                    external dcl 52
baseno_fun                             internal static bit(9)                   initial dcl 1-8
baseptr_fun                            internal static bit(9)                   initial dcl 1-8
bb                                     defined         bit(3)                   dcl 7-9
bit_                                   internal static fixed bin(3,0)           initial dcl 10-5
bit_pointer                            internal static bit(9)                   initial dcl 1-8
bit_to_char                            internal static bit(9)                   initial dcl 1-8
bit_to_word                            internal static bit(9)                   initial dcl 1-8
bitno_fun                              internal static bit(9)                   initial dcl 1-8
bits_per_char                          internal static fixed bin(8,0)           initial dcl 11-5
bits_per_four_words                    internal static fixed bin(8,0)           initial dcl 11-5
bits_per_half                          internal static fixed bin(8,0)           initial dcl 11-5
bits_per_packed_digit                  internal static fixed bin(8,1)           initial dcl 11-35
bits_per_two_words                     internal static fixed bin(8,0)           initial dcl 11-5
bits_per_word                          internal static fixed bin(8,0)           initial dcl 11-5
bits_per_words                         internal static fixed bin(8,0)           initial array dcl 11-5
block_node                             internal static bit(9)                   initial dcl 9-5
bn_format                              internal static bit(9)                   initial dcl 1-8
bool_fun                               internal static bit(9)                   initial dcl 1-8
bound_ck                               internal static bit(9)                   initial dcl 1-8
bound_node                             internal static bit(9)                   initial dcl 9-5
bp                                     defined         bit(3)                   dcl 7-4
break_even_bits                        internal static fixed bin(8,0)           initial dcl 11-5
break_even_words                       internal static fixed bin(8,0)           initial dcl 11-5
by_name_agg_node                       internal static bit(9)                   initial dcl 9-5
byte_fun                               internal static bit(9)                   initial dcl 1-8
c_format                               internal static bit(9)                   initial dcl 1-8
cat_string                             internal static bit(9)                   initial dcl 1-8
ceil_fun                               internal static bit(9)                   initial dcl 1-8
char_to_word                           internal static bit(9)                   initial dcl 1-8
character_                             internal static fixed bin(3,0)           initial dcl 10-5
charno_fun                             internal static bit(9)                   initial dcl 1-8
chars_per_word                         internal static fixed bin(8,0)           initial dcl 11-5
clock_fun                              internal static bit(9)                   initial dcl 1-8
close_file                             internal static bit(9)                   initial dcl 1-8
codeptr_fun                            internal static bit(9)                   initial dcl 1-8
column_format                          internal static bit(9)                   initial dcl 1-8
complex_fun                            internal static bit(9)                   initial dcl 1-8
conjg_fun                              internal static bit(9)                   initial dcl 1-8
context_node                           internal static bit(9)                   initial dcl 9-5
convert_offset                         internal static fixed bin(8,1)           initial array dcl 11-35
convert_size                           internal static fixed bin(8,0)           initial array dcl 11-5
copy_string                            internal static bit(9)                   initial dcl 1-8
copy_words                             internal static bit(9)                   initial dcl 1-8
cos_fun                                internal static bit(9)                   initial dcl 1-8
cosd_fun                               internal static bit(9)                   initial dcl 1-8
cross_reference_node                   internal static bit(9)                   initial dcl 9-5
default_fix_bin_p                      internal static fixed bin(8,0)           initial dcl 11-5
default_node                           internal static bit(9)                   initial dcl 9-5
delete_file                            internal static bit(9)                   initial dcl 1-8
desc_size                              internal static bit(9)                   initial dcl 1-8
digit_                                 internal static fixed bin(3,0)           initial dcl 10-5
digit_to_bit                           internal static bit(9)                   initial dcl 1-8
div                                    internal static bit(9)                   initial dcl 1-8
do_fun                                 internal static bit(9)                   initial dcl 1-8
do_spec                                internal static bit(9)                   initial dcl 1-8
e_format                               internal static bit(9)                   initial dcl 1-8
empty_area                             internal static bit(9)                   initial dcl 1-8
enable_on                              internal static bit(9)                   initial dcl 1-8
environmentptr_fun                     internal static bit(9)                   initial dcl 1-8
equal                                  internal static bit(9)                   initial dcl 1-8
ex_prologue                            internal static bit(9)                   initial dcl 1-8
exp                                    internal static bit(9)                   initial dcl 1-8
exp_fun                                internal static bit(9)                   initial dcl 1-8
expmac$zero                     000000 constant        entry                    external dcl 52
f_format                               internal static bit(9)                   initial dcl 1-8
floor_fun                              internal static bit(9)                   initial dcl 1-8
format_value_node                      internal static bit(9)                   initial dcl 9-5
fortran_read                           internal static bit(9)                   initial dcl 1-8
fortran_write                          internal static bit(9)                   initial dcl 1-8
free_based                             internal static bit(9)                   initial dcl 1-8
free_ctl                               internal static bit(9)                   initial dcl 1-8
free_var                               internal static bit(9)                   initial dcl 1-8
ftn_file_manip                         internal static bit(9)                   initial dcl 1-8
ftn_trans_loop                         internal static bit(9)                   initial dcl 1-8
get_data_trans                         internal static bit(9)                   initial dcl 1-8
get_edit_trans                         internal static bit(9)                   initial dcl 1-8
get_file                               internal static bit(9)                   initial dcl 1-8
get_list_trans                         internal static bit(9)                   initial dcl 1-8
get_string                             internal static bit(9)                   initial dcl 1-8
greater_or_equal                       internal static bit(9)                   initial dcl 1-8
greater_than                           internal static bit(9)                   initial dcl 1-8
half_                                  internal static fixed bin(3,0)           initial dcl 10-5
half_to_word                           internal static bit(9)                   initial dcl 1-8
imag_fun                               internal static bit(9)                   initial dcl 1-8
ind_arithmetic                         internal static fixed bin(17,0)          initial dcl 4-68
ind_decimal_reg                        internal static fixed bin(17,0)          initial dcl 4-68
ind_invalid                            internal static fixed bin(17,0)          initial dcl 4-68
ind_known_refs                         internal static fixed bin(17,0)          initial dcl 4-68
ind_logical                            internal static fixed bin(17,0)          initial dcl 4-68
ind_string_aq                          internal static fixed bin(17,0)          initial dcl 4-68
ind_x                                  internal static fixed bin(17,0)          initial array dcl 4-68
index_after_fun                        internal static bit(9)                   initial dcl 1-8
index_before_fun                       internal static bit(9)                   initial dcl 1-8
index_fun                              internal static bit(9)                   initial dcl 1-8
index_rev_fun                          internal static bit(9)                   initial dcl 1-8
join                                   internal static bit(9)                   initial dcl 1-8
jump                                   internal static bit(9)                   initial dcl 1-8
jump_false                             internal static bit(9)                   initial dcl 1-8
jump_if_eq                             internal static bit(9)                   initial dcl 1-8
jump_if_ge                             internal static bit(9)                   initial dcl 1-8
jump_if_gt                             internal static bit(9)                   initial dcl 1-8
jump_if_le                             internal static bit(9)                   initial dcl 1-8
jump_if_lt                             internal static bit(9)                   initial dcl 1-8
jump_if_ne                             internal static bit(9)                   initial dcl 1-8
jump_true                              internal static bit(9)                   initial dcl 1-8
l_parn                                 internal static bit(9)                   initial dcl 1-8
label_array_element_node               internal static bit(9)                   initial dcl 9-5
label_node                             internal static bit(9)                   initial dcl 9-5
label_size                             internal static fixed bin(8,0)           initial dcl 11-5
lb                                     defined         bit(3)                   dcl 7-9
length_fun                             internal static bit(9)                   initial dcl 1-8
less_or_equal                          internal static bit(9)                   initial dcl 1-8
less_than                              internal static bit(9)                   initial dcl 1-8
line_format                            internal static bit(9)                   initial dcl 1-8
list_node                              internal static bit(9)                   initial dcl 9-5
load                            000000 constant        entry                    external dcl 52
load_bp                                internal static fixed bin(15,0)          initial dcl 129
load_link_ptr                          internal static fixed bin(15,0)          initial dcl 129
load_lp                                internal static fixed bin(15,0)          initial dcl 129
locate_file                            internal static bit(9)                   initial dcl 1-8
lock_file                              internal static bit(9)                   initial dcl 1-8
lock_fun                               internal static bit(9)                   initial dcl 1-8
log10_fun                              internal static bit(9)                   initial dcl 1-8
log2_fun                               internal static bit(9)                   initial dcl 1-8
log_fun                                internal static bit(9)                   initial dcl 1-8
loop                                   internal static bit(9)                   initial dcl 1-8
lp                                     defined         bit(3)                   dcl 7-4
machine_state_node                     internal static bit(9)                   initial dcl 9-5
make_desc                              internal static bit(9)                   initial dcl 1-8
max_block_number                       internal static fixed bin(17,0)          initial dcl 3-74
max_dec_scale                          internal static fixed bin(8,0)           initial dcl 11-5
max_fun                                internal static bit(9)                   initial dcl 1-8
max_index_register_value               internal static fixed bin(31,0)          initial dcl 11-38
max_length_p                           internal static fixed bin(8,0)           initial dcl 11-5
max_number_of_operands                 internal static fixed bin(15,0)          initial dcl 2-15
max_offset                             internal static fixed bin(8,0)           initial array dcl 11-5
max_p_fix_bin_1                        internal static fixed bin(8,0)           initial dcl 11-5
max_p_fix_dec                          internal static fixed bin(8,0)           initial dcl 11-5
max_p_flt_bin_1                        internal static fixed bin(8,0)           initial dcl 11-5
max_p_xreg                             internal static fixed bin(8,0)           initial dcl 11-5
max_short_size                         internal static fixed bin(8,0)           initial array dcl 11-5
min_dec_scale                          internal static fixed bin(8,0)           initial dcl 11-5
min_fun                                internal static bit(9)                   initial dcl 1-8
mod2_                                  internal static fixed bin(3,0)           initial dcl 10-5
mod4_                                  internal static fixed bin(3,0)           initial dcl 10-5
mod_bit                                internal static bit(9)                   initial dcl 1-8
mod_byte                               internal static bit(9)                   initial dcl 1-8
mod_fun                                internal static bit(9)                   initial dcl 1-8
mod_half                               internal static bit(9)                   initial dcl 1-8
mod_word                               internal static bit(9)                   initial dcl 1-8
mult                                   internal static bit(9)                   initial dcl 1-8
multiple                               automatic       fixed bin(17,0)          dcl 619
negate                                 internal static bit(9)                   initial dcl 1-8
nop                                    internal static bit(9)                   initial dcl 1-8
not_bits                               internal static bit(9)                   initial dcl 1-8
not_equal                              internal static bit(9)                   initial dcl 1-8
off_fun                                internal static bit(9)                   initial dcl 1-8
open_file                              internal static bit(9)                   initial dcl 1-8
or_bits                                internal static bit(9)                   initial dcl 1-8
pack                                   internal static bit(9)                   initial dcl 1-8
packed_digits_per_char                 internal static fixed bin(8,0)           initial dcl 11-5
packed_digits_per_word                 internal static fixed bin(8,0)           initial dcl 11-5
packed_into_bp                         internal static fixed bin(15,0)          initial dcl 129
page_format                            internal static bit(9)                   initial dcl 1-8
param_desc_ptr                         internal static bit(9)                   initial dcl 1-8
picture_format                         internal static bit(9)                   initial dcl 1-8
pl1_mod_fun                            internal static bit(9)                   initial dcl 1-8
prefix_plus                            internal static bit(9)                   initial dcl 1-8
ptr_fun                                internal static bit(9)                   initial dcl 1-8
put_control                            internal static bit(9)                   initial dcl 1-8
put_data_trans                         internal static bit(9)                   initial dcl 1-8
put_edit_trans                         internal static bit(9)                   initial dcl 1-8
put_field                              internal static bit(9)                   initial dcl 1-8
put_field_chk                          internal static bit(9)                   initial dcl 1-8
put_file                               internal static bit(9)                   initial dcl 1-8
put_list_trans                         internal static bit(9)                   initial dcl 1-8
put_string                             internal static bit(9)                   initial dcl 1-8
r_format                               internal static bit(9)                   initial dcl 1-8
r_parn                                 internal static bit(9)                   initial dcl 1-8
range_ck                               internal static bit(9)                   initial dcl 1-8
rank_fun                               internal static bit(9)                   initial dcl 1-8
rc_a                                   internal static bit(6)                   initial unaligned dcl 8-6
rc_dp                                  internal static bit(6)                   initial unaligned dcl 8-6
rc_e                                   internal static bit(6)                   initial unaligned dcl 8-6
rc_is15                                internal static bit(6)                   initial unaligned dcl 8-6
rc_is18                                internal static bit(6)                   initial unaligned dcl 8-6
rc_lb                                  internal static bit(6)                   initial unaligned dcl 8-6
rc_lp18                                internal static bit(6)                   initial unaligned dcl 8-6
rc_nlb                                 internal static bit(6)                   initial unaligned dcl 8-6
rc_nlp18                               internal static bit(6)                   initial unaligned dcl 8-6
rc_ns                                  internal static bit(6)                   initial unaligned dcl 8-6
rc_nt                                  internal static bit(6)                   initial unaligned dcl 8-6
rc_s                                   internal static bit(6)                   initial unaligned dcl 8-6
rc_sr                                  internal static bit(6)                   initial unaligned dcl 8-6
rc_t                                   internal static bit(6)                   initial unaligned dcl 8-6
read_file                              internal static bit(9)                   initial dcl 1-8
real_fun                               internal static bit(9)                   initial dcl 1-8
record_io                              internal static bit(9)                   initial dcl 1-8
refer                                  internal static bit(9)                   initial dcl 1-8
reference_node                         internal static bit(9)                   initial dcl 9-5
rel_fun                                internal static bit(9)                   initial dcl 1-8
repeat_fun                             internal static bit(9)                   initial dcl 1-8
return_bits                            internal static bit(9)                   initial dcl 1-8
return_string                          internal static bit(9)                   initial dcl 1-8
return_value                           internal static bit(9)                   initial dcl 1-8
return_words                           internal static bit(9)                   initial dcl 1-8
reverse_fun                            internal static bit(9)                   initial dcl 1-8
revert_on                              internal static bit(9)                   initial dcl 1-8
rewrite_file                           internal static bit(9)                   initial dcl 1-8
round_fun                              internal static bit(9)                   initial dcl 1-8
sb                                     defined         bit(3)                   dcl 7-9
search_fun                             internal static bit(9)                   initial dcl 1-8
search_rev_fun                         internal static bit(9)                   initial dcl 1-8
segno_fun                              internal static bit(9)                   initial dcl 1-8
setbitno_fun                           internal static bit(9)                   initial dcl 1-8
setcharno_fun                          internal static bit(9)                   initial dcl 1-8
sf_par_node                            internal static bit(9)                   initial dcl 9-5
sign_fun                               internal static bit(9)                   initial dcl 1-8
signal_on                              internal static bit(9)                   initial dcl 1-8
sin_fun                                internal static bit(9)                   initial dcl 1-8
sind_fun                               internal static bit(9)                   initial dcl 1-8
skip_format                            internal static bit(9)                   initial dcl 1-8
source_node                            internal static bit(9)                   initial dcl 9-5
sqrt_fun                               internal static bit(9)                   initial dcl 1-8
stack_ptr                              internal static bit(9)                   initial dcl 1-8
stackbaseptr_fun                       internal static bit(9)                   initial dcl 1-8
stackframeptr_fun                      internal static bit(9)                   initial dcl 1-8
stacq_fun                              internal static bit(9)                   initial dcl 1-8
statement_node                         internal static bit(9)                   initial dcl 9-5
std_arg_list                           internal static bit(9)                   initial dcl 1-8
std_call                               internal static bit(9)                   initial dcl 1-8
std_entry                              internal static bit(9)                   initial dcl 1-8
std_return                             internal static bit(9)                   initial dcl 1-8
stop                                   internal static bit(9)                   initial dcl 1-8
store_bp                               internal static fixed bin(15,0)          initial dcl 129
stream_prep                            internal static bit(9)                   initial dcl 1-8
sub                                    internal static bit(9)                   initial dcl 1-8
symbol_node                            internal static bit(9)                   initial dcl 9-5
tan_fun                                internal static bit(9)                   initial dcl 1-8
tand_fun                               internal static bit(9)                   initial dcl 1-8
terminate_trans                        internal static bit(9)                   initial dcl 1-8
token_node                             internal static bit(9)                   initial dcl 9-5
translate_fun                          internal static bit(9)                   initial dcl 1-8
trunc_fun                              internal static bit(9)                   initial dcl 1-8
unlock_file                            internal static bit(9)                   initial dcl 1-8
unpack                                 internal static bit(9)                   initial dcl 1-8
vclock_fun                             internal static bit(9)                   initial dcl 1-8
verify_fun                             internal static bit(9)                   initial dcl 1-8
verify_ltrim_fun                       internal static bit(9)                   initial dcl 1-8
verify_rev_fun                         internal static bit(9)                   initial dcl 1-8
verify_rtrim_fun                       internal static bit(9)                   initial dcl 1-8
word_to_mod2                           internal static bit(9)                   initial dcl 1-8
word_to_mod4                           internal static bit(9)                   initial dcl 1-8
word_to_mod8                           internal static bit(9)                   initial dcl 1-8
wordno_fun                             internal static bit(9)                   initial dcl 1-8
write_file                             internal static bit(9)                   initial dcl 1-8
x_format                               internal static bit(9)                   initial dcl 1-8
xor_bits                               internal static bit(9)                   initial dcl 1-8

NAMES DECLARED BY EXPLICIT CONTEXT.
AQ_finish                       000466 constant        label                    dcl 254 set ref 233
PR_to_AQ                        000344 constant        label                    dcl 226 ref 208 248
add_cfo                         004131 constant        entry                    internal dcl 1071 ref 356
base_man$load_any_var           000134 constant        entry                    external dcl 45
base_man$load_any_var_and_lock  000474 constant        entry                    external dcl 258
base_man$load_arg               001751 constant        entry                    external dcl 572
base_man$load_arg_ptr           002426 constant        entry                    external dcl 688
base_man$load_controlled        002266 constant        entry                    external dcl 657
base_man$load_display           001374 constant        entry                    external dcl 452
base_man$load_link_indirect     002140 constant        entry                    external dcl 613
base_man$load_linkage           001616 constant        entry                    external dcl 529
base_man$load_packed            003032 constant        entry                    external dcl 789
base_man$load_stack_indirect    001254 constant        entry                    external dcl 422
base_man$load_static            001573 constant        entry                    external dcl 517
base_man$load_var               000532 constant        entry                    external dcl 271
base_man$load_var_and_lock      000514 constant        entry                    external dcl 265
base_man$lock                   003350 constant        entry                    external dcl 855
base_man$store_ptr_to           002605 constant        entry                    external dcl 727
base_man$unlock                 003366 constant        entry                    external dcl 861
base_man$update_base            002750 constant        entry                    external dcl 760
begin                           000145 constant        label                    dcl 162 ref 262
call_ma                         003514 constant        label                    dcl 906 ref 896 900 902
change_base                     003740 constant        entry                    internal dcl 1003 ref 309 331 440 489 558 600 645
                                                                                  677 712 766 847
exp_addmac                      004100 constant        entry                    internal dcl 1056 ref 369 1084
get_free_base                   003552 constant        entry                    internal dcl 921 ref 222 437 485 554 594 643 675 710
                                                                                  843
hit                             003625 constant        label                    dcl 951 ref 960 964 968
l10                             002255 constant        label                    dcl 653 ref 634 666 686
l1a                             000632 constant        label                    dcl 302 ref 224
l1b                             001207 constant        label                    dcl 402 ref 315 777 852
l2                              001214 constant        label                    dcl 404 ref 318 384 774
l6                              001563 constant        label                    dcl 512 ref 471
l7                              002127 constant        label                    dcl 609 ref 582
l8                              001365 constant        label                    dcl 448 ref 432
l9                              002574 constant        label                    dcl 723 ref 700
link_join                       001631 constant        label                    dcl 537 ref 525
load_AQ                         000374 constant        label                    dcl 235 ref 220
load_a_var                      000205 constant        entry                    external dcl 179
load_any_var_load_aq_common     000251 constant        label                    dcl 196 ref 166 177 186
load_aq_var                     000161 constant        entry                    external dcl 168
load_q_var                      000230 constant        entry                    external dcl 188
reset_perm                      001232 constant        label                    dcl 414 ref 213 292
set_base1                       001734 constant        label                    dcl 566 ref 546
setk                            004053 constant        entry                    internal dcl 1043 ref 592 641 673 708 910
sj                              003672 constant        label                    dcl 981 ref 985 988
store                           002701 constant        label                    dcl 749 ref 741
try_another                     003712 constant        label                    dcl 991 ref 945
used_i                          001240 constant        label                    dcl 418 set ref 450 514 611 655 725 784 824
when_to_m_a                     003404 constant        entry                    internal dcl 869 ref 219 281 842

NAMES DECLARED BY CONTEXT OR IMPLICATION.
bin                                                    builtin function         ref 247
max                                                    builtin function         ref 944

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5126        5216    4230        5136
Length      5760    4230        70         526     675           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
base_man$load_any_var               236 external procedure  is an external procedure.  
when_to_m_a                             internal procedure  shares stack frame of external procedure base_man$load_any_var.  
get_free_base                           internal procedure  shares stack frame of external procedure base_man$load_any_var.  
change_base                             internal procedure  shares stack frame of external procedure base_man$load_any_var.  
setk                                    internal procedure  shares stack frame of external procedure base_man$load_any_var.  
exp_addmac                              internal procedure  shares stack frame of external procedure base_man$load_any_var.  
add_cfo                                 internal procedure  shares stack frame of external procedure base_man$load_any_var.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
base_man$load_any_var    000100 i                           base_man$load_any_var
                         000101 j                           base_man$load_any_var
                         000102 k                           base_man$load_any_var
                         000103 n                           base_man$load_any_var
                         000104 text_pos                    base_man$load_any_var
                         000105 type                        base_man$load_any_var
                         000106 ca_code                     base_man$load_any_var
                         000110 vp                          base_man$load_any_var
                         000112 p                           base_man$load_any_var
                         000114 q                           base_man$load_any_var
                         000116 addressable                 base_man$load_any_var
                         000117 atomic                      base_man$load_any_var
                         000120 eis                         base_man$load_any_var
                         000121 lock                        base_man$load_any_var
                         000122 tag_hold                    base_man$load_any_var
                         000123 fract_offset                base_man$load_any_var
                         000124 xr                          base_man$load_any_var
                         000125 base                        base_man$load_any_var
                         000126 macro                       base_man$load_any_var
                         000127 new_base                    base_man$load_any_var
                         000130 a_q_aq                      base_man$load_any_var
                         000131 want_a_PR                   base_man$load_any_var
                         000132 m_s_p                       base_man$load_any_var
                         000134 fmin                        base_man$load_any_var
                         000135 nframes                     base_man$load_any_var
                         000136 off                         base_man$load_any_var
                         000164 p                           when_to_m_a
                         000174 i                           get_free_base
                         000175 j                           get_free_base
                         000176 cmin                        get_free_base
                         000177 n                           get_free_base
                         000200 pr                          get_free_base
                         000201 pmin                        get_free_base
                         000202 type                        get_free_base
                         000204 p                           get_free_base
                         000220 n                           change_base
                         000221 t                           change_base
                         000222 p                           change_base

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             unpk_to_pk          call_ext_out        return              mod_fx1             ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_ref_count              base_man$load_any_var         base_man$load_arg             base_man$load_display
base_man$load_link_indirect   base_man$load_var             base_to_core                  c_a
compile_exp$save              copy_temp                     error                         expmac
get_reference                 m_a                           prepare_operand               xr_man$add_any_const
xr_man$load_any_const

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cg_stat$cur_level             cg_stat$cur_statement         cg_stat$last_base_used        cg_stat$separate_static
cg_stat$text_base             cg_stat$text_pos              cg_static_$m_s_p




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     52 000117       105 000120    4    3 000122        45 000130       162 000145       164 000150       165 000153
    166 000155       168 000156       173 000172       174 000174       175 000177       176 000200       177 000202
    179 000203       182 000216       183 000220       184 000223       185 000224       186 000225       188 000226
    191 000241       192 000243       193 000246       194 000247       196 000251       201 000254       202 000263
    203 000270       205 000274       208 000303       210 000305       212 000323       213 000327       215 000330
    219 000332       220 000333       222 000335       223 000337       224 000343       226 000344       228 000346
    229 000353       230 000355       231 000357       232 000361       233 000373       235 000374       238 000376
    239 000411       242 000414       244 000420       246 000430       247 000443       248 000447       251 000450
    252 000454       254 000466       256 000471       258 000472       261 000505       262 000507       265 000510
    268 000525       271 000527       276 000543       277 000546       279 000551       280 000554       281 000556
    285 000557       286 000567       290 000605       292 000623       294 000624       295 000625       301 000627
    302 000632       307 000635       309 000637       310 000641       311 000657       312 000665       313 000676
    315 000714       317 000717       318 000724       325 000725       327 000727       328 000743       331 000746
    334 000750       337 000753       339 000755       340 000763       343 000767       345 001000       347 001005
    348 001010       349 001017       350 001023       351 001025       352 001027       354 001031       356 001033
    358 001037       359 001043       361 001044       363 001055       365 001061       366 001072       369 001103
    373 001107       375 001113       376 001116       377 001120       378 001122       379 001123       382 001125
    384 001131       387 001132       389 001136       391 001146       392 001157       393 001163       394 001165
    395 001167       396 001171       397 001172       400 001176       402 001207       404 001214       407 001221
    408 001224       410 001231       414 001232       418 001240       420 001247       422 001250       425 001262
    427 001265       428 001267       429 001277       430 001304       432 001310       435 001316       437 001320
    440 001322       442 001324       443 001341       445 001355       446 001363       448 001365       450 001371
    452 001372       460 001402       461 001405       465 001411       466 001421       467 001426       469 001432
    471 001434       473 001440       475 001441       476 001444       478 001446       479 001447       483 001451
    485 001453       489 001455       491 001457       492 001474       494 001503       496 001506       500 001517
    502 001522       503 001530       504 001537       505 001550       509 001552       510 001560       512 001563
    514 001567       517 001570       520 001601       522 001604       523 001606       524 001610       525 001612
    529 001613       534 001624       535 001626       536 001627       537 001631       542 001633       543 001643
    544 001647       546 001653       548 001655       552 001657       554 001666       558 001670       562 001672
    563 001710       564 001726       566 001734       568 001740       569 001746       572 001747       577 001757
    579 001763       581 001766       582 001775       585 002010       587 002012       588 002017       590 002023
    592 002033       594 002034       596 002036       598 002053       600 002057       602 002061       603 002076
    604 002103       606 002117       607 002125       609 002127       611 002133       613 002134       621 002146
    623 002151       625 002155       626 002157       627 002161       629 002162       630 002164       633 002166
    634 002175       637 002207       639 002211       641 002224       643 002225       645 002227       648 002231
    650 002245       651 002253       653 002255       655 002261       657 002262       662 002274       663 002302
    665 002304       666 002313       669 002325       671 002327       673 002344       675 002345       677 002347
    679 002351       680 002367       681 002374       683 002410       684 002416       686 002420       688 002421
    694 002434       696 002440       698 002443       699 002453       700 002460       704 002473       706 002475
    708 002511       710 002512       712 002514       714 002516       715 002540       717 002545       719 002561
    720 002567       721 002571       723 002574       725 002600       727 002601       735 002613       736 002623
    739 002637       741 002656       743 002657       745 002661       747 002663       749 002701       753 002721
    754 002735       758 002745       760 002746       765 002761       766 002764       768 002766       769 002771
    771 002774       773 002776       774 003002       777 003003       780 003005       782 003011       783 003017
    784 003020       786 003021       787 003025       789 003026       798 003040       800 003042       801 003046
    803 003050       806 003074       809 003113       811 003135       814 003154       815 003156       816 003165
    818 003175       822 003210       823 003213       824 003226       826 003227       828 003231       832 003243
    833 003250       834 003257       835 003271       836 003274       837 003275       839 003312       840 003314
    842 003316       843 003317       845 003321       847 003324       849 003326       851 003342       852 003344
    855 003345       858 003356       859 003363       861 003364       863 003374       864 003403       869 003404
    876 003405       877 003406       878 003421       880 003425       883 003431       888 003446       891 003451
    892 003460       894 003466       896 003470       898 003475       900 003500       902 003504       904 003507
    906 003514       908 003530       909 003533       910 003535       913 003545       915 003546       916 003551
    921 003552       935 003554       938 003563       939 003566       942 003570       943 003572       944 003574
    945 003613       948 003621       949 003624       951 003625       953 003630       956 003633       958 003635
    960 003637       962 003643       964 003647       967 003654       968 003655       971 003660       972 003662
    974 003663       975 003664       978 003666       980 003671       981 003672       983 003674       984 003676
    985 003677       988 003703       991 003712       994 003732       995 003735      1003 003740      1009 003742
   1010 003744      1011 003750      1014 003756      1016 003762      1018 003764      1019 003770      1022 003771
   1025 003774      1027 004000      1029 004004      1031 004010      1034 004014      1036 004020      1037 004022
   1038 004031      1039 004047      1042 004052      1043 004053      1046 004054      1047 004056      1048 004065
   1050 004071      1051 004073      1053 004074      1055 004077      1056 004100      1061 004101      1063 004104
   1065 004114      1066 004122      1067 004130      1071 004131      1076 004132      1078 004135      1079 004157
   1080 004166      1082 004167      1083 004203      1084 004214      1086 004215


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
