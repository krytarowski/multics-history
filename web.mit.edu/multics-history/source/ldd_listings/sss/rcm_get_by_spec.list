	COMPILATION LISTING OF SEGMENT rcm_get_by_spec
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/24/88  1535.3 mst Mon
	    Options: optimize map

        1 /* format: ^indcomtxt */
        2 /* ***********************************************************
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        5*   *                                                         *
        6*   *********************************************************** */
        7 
        8 /* DESCRIPTION:
        9*
       10*   This subroutine examines a range of records, selecting records
       11*   according to a sequential_specification.  The records selected are
       12*   processed according to the entrypoint used to enter the subroutine:
       13*   get converts selected records to simple_typed_vectors; $delete deletes
       14*   the selected records.
       15**/
       16 
       17 /* HISTORY:
       18*
       19*Written by Matthew Pierret, 08/30/84.
       20*Extracted from rcm_process_records.pl1)
       21*Modified:
       22*12/20/84 by Lindsey L. Spratt:  Fixed to reference dm_vector_util_ instead of
       23*	  vector_util_.
       24*02/05/85 by Lindsey L. Spratt:  Changed SETUP_OUTPUT_RECORDS to take a
       25*            work_area_ptr parm, fixed calls to SETUP_OUTPUT_RECORDS to provide
       26*            an id_list_ptr, changed SOR to use the sor_p_work_area_ptr and
       27*            sor_p_work_area.  Upped the VECTOR_SLOT_INCREMENT to 500 from 50.
       28*	  Fixed SETUP_ID_LIST to set record_id_field_id to the correct value
       29*	  when the last value in the id_list is = to
       30*	  DEFAULT_RECORD_ID_FIELD_ID (-1).
       31*02/12/85 by Lindsey L. Spratt:  Extended to handle area_too_small when adding
       32*            records and ids.
       33*02/16/85 by Lindsey L. Spratt:  Added initializations of all automatic
       34*            variables at declaration time.  Fixed to set the
       35*            record_buffer_length variable.
       36**/
       37 
       38 /* format: style2,ind3,ll79,^indnoniterdo,indnoniterend,^indprocbody,comcol50,^indblkcom,indcomtxt */
       39 
       40 rcm_get_by_spec:
       41    proc ();
       42 
       43    call sub_err_ (dm_error_$programming_error, MYNAME, ACTION_CANT_RESTART,
       44         null, 0, "^/^a$^a is not a valid entrypoint", MYNAME, MYNAME);
       45 
       46 /* START OF DECLARATIONS */
       47 /* Parameter */
       48 
       49    dcl	 p_record_cursor_ptr    ptr parameter;
       50    dcl	 p_work_area_ptr	    ptr parameter;
       51    dcl	 p_field_table_ptr	    ptr parameter;
       52    dcl	 p_id_list_ptr	    ptr parameter;
       53    dcl	 p_element_id_list_ptr  ptr parameter;
       54    dcl	 p_specification_ptr    ptr parameter;
       55    dcl	 p_typed_vector_array_ptr
       56 			    ptr parameter;
       57    dcl	 p_direction_to_process fixed bin parameter;
       58    dcl	 p_first_record_to_process
       59 			    bit (36) aligned parameter;
       60    dcl	 p_last_record_to_process
       61 			    bit (36) aligned parameter;
       62    dcl	 p_spec_is_always_satisfied
       63 			    bit (1) aligned parameter;
       64    dcl	 p_maximum_number_of_records
       65 			    fixed bin (35) parameter;
       66    dcl	 p_number_of_records_accepted
       67 			    fixed bin (35) parameter;
       68    dcl	 p_code		    fixed bin (35) parameter;
       69 
       70 /* Automatic */
       71 
       72    dcl	 (get, get_id, count, position)
       73 			    bit (1) aligned init ("0"b);
       74    dcl	 (get_each_record, record_satisfies_spec, spec_is_always_satisfied)
       75 			    bit (1) aligned init ("0"b);
       76 
       77    dcl	 area_status	    fixed bin init (AREA_IS_BIG_ENOUGH);
       78    dcl	 code		    fixed bin (35);
       79    dcl	 current_ci_ptr	    ptr init (null ());
       80    dcl	 direction_to_process   fixed bin (17);
       81    dcl	 field_table_ptr	    ptr init (null ());
       82    dcl	 first_record_to_process
       83 			    bit (36) aligned init (NO_RECORD);
       84    dcl	 highest_accepted_record
       85 			    bit (36) aligned init (NO_RECORD);
       86    dcl	 last_record_to_process bit (36) aligned init (NO_RECORD);
       87    dcl	 maximum_number_of_records
       88 			    fixed bin (35) init (-1);
       89    dcl	 number_of_records_accepted
       90 			    fixed bin (35) init (-1);
       91    dcl	 previous_record_id	    bit (36) aligned init (NO_RECORD);
       92    dcl	 record_count	    fixed bin (35) init (-1);
       93    dcl	 record_buffer_length   fixed bin (35) init (-1);
       94    dcl	 record_buffer_ptr	    ptr init (null ());
       95    dcl	 record_id	    bit (36) aligned init (NO_RECORD);
       96    dcl	 record_id_field_id	    fixed bin (17)
       97 			    init (DEFAULT_RECORD_ID_FIELD_ID);
       98    dcl	 record_string_length   fixed bin (35) init (-1);
       99    dcl	 record_string_ptr	    ptr init (null ());
      100    dcl	 specification_ptr	    ptr init (null ());
      101    dcl	 (old_eil_ptr, old_tva_ptr, vector_ptr, work_area_ptr,
      102 	 based_bit_36_aligned_ptr)
      103 			    ptr init (null);
      104    dcl	 local_record_buffer    (DOUBLE_WORDS_PER_PAGE) fixed bin (71);
      105    dcl	 temp_element_id_list_ptr
      106 			    ptr init (null ());
      107    dcl	 temp_typed_vector_array_ptr
      108 			    ptr init (null ());
      109 
      110 /* Based */
      111 
      112    dcl	 based_bit_36_aligned   bit (36) aligned
      113 			    based (based_bit_36_aligned_ptr);
      114 
      115    dcl	 record_string	    bit (record_string_length)
      116 			    based (record_string_ptr);
      117    dcl	 work_area	    area based (work_area_ptr);
      118    dcl	 record_buffer	    bit (record_buffer_length) aligned
      119 			    based (record_buffer_ptr);
      120 
      121 /* Builtin */
      122 
      123    dcl	 (addr, divide, hbound, min, null, unspec)
      124 			    builtin;
      125 
      126 /* Condition */
      127 
      128    dcl	 (area, cleanup)	    condition;
      129 
      130 /* Constant */
      131 
      132    dcl	 MYNAME		    init ("rcm_get_by_spec") char (32)
      133 			    varying internal static options (constant);
      134    dcl	 (
      135 	 AREA_IS_BIG_ENOUGH	    init (1) fixed bin,
      136 	 AREA_IS_TOO_SMALL	    init (2) fixed bin,
      137 	 BACKWARD_DIRECTION	    init (-1) fixed bin,
      138 	 DEFAULT_AND_GROUP_ID_LIST_PTR
      139 			    init (null ()) ptr,
      140 	 DEFAULT_NUMBER_OF_FULLY_STRUCTURAL_FIELDS
      141 			    init (0) fixed bin,
      142 	 DEFAULT_PARTIAL_STRUCTURAL_FIELD
      143 			    init (0) fixed bin,
      144 	 DEFAULT_RECORD_ID_FIELD_ID
      145 			    init (-1) fixed bin,
      146 	 DOUBLE_WORDS_PER_PAGE  init (512) fixed bin,
      147 	 ELEMENT_ID_LIST_INCREMENT
      148 			    init (100) fixed bin,
      149 	 FALSE		    init ("0"b) bit (1) aligned,
      150 	 FREE_OLD_TYPED_VECTOR_ARRAY
      151 			    init ("1"b) bit (1) aligned,
      152 	 GET_CURRENT	    init (0) fixed bin,
      153 	 IS_RELATIVE	    init ("0"b) bit (1) aligned,
      154 	 LIMIT_TO_STOP_INFINITE_LOOPING
      155 			    init (1e6) fixed bin (35),
      156 	 NO_RECORD	    init ("0"b) bit (36) aligned,
      157 	 TRUE		    init ("1"b) bit (1) aligned,
      158 	 VECTOR_SLOT_INCREMENT  init (500) fixed bin
      159 	 )		    internal static options (constant);
      160 
      161 /* Entry */
      162 
      163    dcl	 data_format_util_$compare_sequential
      164 			    entry (ptr, ptr, ptr, fixed bin, fixed bin,
      165 			    bit (*), bit (1) aligned, fixed bin (35));
      166    dcl	 data_format_util_$cv_table_to_typed_array
      167 			    entry (ptr, ptr, ptr, fixed bin (35), ptr,
      168 			    fixed bin (35));
      169    dcl	 data_format_util_$new_cv_string_to_vector
      170 			    entry (ptr, ptr, ptr, fixed bin (35), ptr,
      171 			    ptr, fixed bin (35));
      172 
      173    dcl	 dm_vector_util_$append_simple_typed_vector
      174 			    entry options (variable) returns (ptr);
      175    dcl	 dm_vector_util_$free_typed_vector
      176 			    entry (ptr, ptr, ptr, fixed bin (35));
      177 
      178    dcl	 sub_err_		    entry options (variable);
      179 
      180 /* External */
      181 
      182    dcl	 (
      183 	 error_table_$area_too_small,
      184 	 error_table_$unimplemented_version,
      185 	 dm_error_$long_return_element,
      186 	 dm_error_$beginning_of_collection,
      187 	 dm_error_$end_of_collection,
      188 	 dm_error_$record_not_found,
      189 	 dm_error_$programming_error
      190 	 )		    fixed bin (35) ext;
      191 
      192 
      193 /* END OF DECLARATIONS */
      194 
      195 count:
      196    entry (p_record_cursor_ptr, p_field_table_ptr, p_specification_ptr,
      197         p_first_record_to_process, p_last_record_to_process,
      198         p_spec_is_always_satisfied, p_direction_to_process,
      199         p_maximum_number_of_records, p_number_of_records_accepted, p_code);
      200 
      201    count = TRUE;
      202    maximum_number_of_records = p_maximum_number_of_records;
      203    field_table_ptr = p_field_table_ptr;
      204    work_area_ptr = null;
      205    id_list_ptr = null;
      206    record_id_field_id = DEFAULT_RECORD_ID_FIELD_ID;
      207    element_id_list_ptr = null;
      208    typed_vector_array_ptr = null;
      209 
      210    go to JOIN;
      211 
      212 
      213 get:
      214    entry (p_record_cursor_ptr, p_field_table_ptr, p_specification_ptr,
      215         p_first_record_to_process, p_last_record_to_process,
      216         p_spec_is_always_satisfied, p_direction_to_process,
      217         p_maximum_number_of_records, p_work_area_ptr, p_id_list_ptr,
      218         p_typed_vector_array_ptr, p_code);
      219 
      220    get = TRUE;
      221    maximum_number_of_records = p_maximum_number_of_records;
      222    field_table_ptr = p_field_table_ptr;
      223    work_area_ptr = p_work_area_ptr;
      224    call SETUP_ID_LIST (p_id_list_ptr, id_list_ptr, record_id_field_id);
      225    element_id_list_ptr = null;
      226    call SETUP_OUTPUT_RECORDS (p_typed_vector_array_ptr,
      227         maximum_number_of_records, record_id_field_id, field_table_ptr,
      228         id_list_ptr, work_area_ptr, typed_vector_array_ptr);
      229    go to JOIN;
      230 
      231 get_id:
      232    entry (p_record_cursor_ptr, p_field_table_ptr, p_specification_ptr,
      233         p_first_record_to_process, p_last_record_to_process,
      234         p_spec_is_always_satisfied, p_direction_to_process,
      235         p_maximum_number_of_records, p_work_area_ptr, p_element_id_list_ptr,
      236         p_code);
      237 
      238    get_id = TRUE;
      239    maximum_number_of_records = p_maximum_number_of_records;
      240    field_table_ptr = p_field_table_ptr;
      241    work_area_ptr = p_work_area_ptr;
      242    call SETUP_ID_LIST (p_id_list_ptr, id_list_ptr, record_id_field_id);
      243    call SETUP_OUTPUT_IDS (p_element_id_list_ptr, maximum_number_of_records,
      244         element_id_list_ptr);
      245    typed_vector_array_ptr = null ();
      246 
      247    go to JOIN;
      248 
      249 get_records_and_ids:
      250    entry (p_record_cursor_ptr, p_field_table_ptr, p_specification_ptr,
      251         p_first_record_to_process, p_last_record_to_process,
      252         p_spec_is_always_satisfied, p_direction_to_process,
      253         p_maximum_number_of_records, p_work_area_ptr, p_element_id_list_ptr,
      254         p_typed_vector_array_ptr, p_code);
      255 
      256    get, get_id = TRUE;
      257    maximum_number_of_records = p_maximum_number_of_records;
      258    field_table_ptr = p_field_table_ptr;
      259    work_area_ptr = p_work_area_ptr;
      260    call SETUP_ID_LIST (p_id_list_ptr, id_list_ptr, record_id_field_id);
      261    call SETUP_OUTPUT_IDS (p_element_id_list_ptr, maximum_number_of_records,
      262         element_id_list_ptr);
      263    call SETUP_OUTPUT_RECORDS (p_typed_vector_array_ptr,
      264         maximum_number_of_records, record_id_field_id, field_table_ptr,
      265         id_list_ptr, work_area_ptr, typed_vector_array_ptr);
      266 
      267    go to JOIN;
      268 
      269 
      270 position:
      271    entry (p_record_cursor_ptr, p_field_table_ptr, p_specification_ptr,
      272         p_first_record_to_process, p_last_record_to_process,
      273         p_spec_is_always_satisfied, p_direction_to_process,
      274         p_maximum_number_of_records, p_code);
      275 
      276    position = TRUE;
      277    maximum_number_of_records = p_maximum_number_of_records;
      278    field_table_ptr = p_field_table_ptr;
      279    work_area_ptr = null;
      280    id_list_ptr = null;
      281    record_id_field_id = DEFAULT_RECORD_ID_FIELD_ID;
      282    element_id_list_ptr = null;
      283    typed_vector_array_ptr = null;
      284 
      285    go to JOIN;
      286 
      287 JOIN:
      288    p_code, code = 0;
      289    record_cursor_ptr = p_record_cursor_ptr;
      290    call CHECK_VERSION ((record_cursor.version), (RECORD_CURSOR_VERSION_2),
      291         "record_cursor");
      292    specification_ptr = p_specification_ptr;
      293    spec_is_always_satisfied = p_spec_is_always_satisfied;
      294    direction_to_process = p_direction_to_process;
      295    first_record_to_process = p_first_record_to_process;
      296    last_record_to_process = p_last_record_to_process;
      297 
      298    record_buffer_ptr = addr (local_record_buffer);
      299    record_buffer_length = length (unspec (local_record_buffer));
      300 
      301    current_ci_ptr = null;
      302 
      303    if get | ^spec_is_always_satisfied
      304    then get_each_record = TRUE;
      305    else get_each_record = FALSE;
      306 
      307    record_id = first_record_to_process;
      308    highest_accepted_record = NO_RECORD;
      309    number_of_records_accepted = 0;
      310    previous_record_id = NO_RECORD;
      311 
      312    on cleanup call FINISH ();
      313 
      314    if get_each_record
      315    then call GET_RECORD (current_ci_ptr, record_id, GET_CURRENT,
      316 	   record_buffer_ptr, record_buffer_length, record_string_ptr,
      317 	   record_string_length, record_id);
      318 
      319 RECORD_LOOP:
      320    do record_count = 1 to LIMIT_TO_STOP_INFINITE_LOOPING
      321         while (record_id ^= NO_RECORD);
      322 
      323       if spec_is_always_satisfied
      324       then record_satisfies_spec = TRUE;
      325       else
      326 COMPARE:
      327          do;
      328          record_satisfies_spec = FALSE;
      329          call data_format_util_$compare_sequential (field_table_ptr,
      330 	    specification_ptr, DEFAULT_AND_GROUP_ID_LIST_PTR,
      331 	    DEFAULT_NUMBER_OF_FULLY_STRUCTURAL_FIELDS,
      332 	    DEFAULT_PARTIAL_STRUCTURAL_FIELD, record_string,
      333 	    record_satisfies_spec, code);
      334          if code ^= 0
      335          then call ERROR_RETURN (code);
      336          end COMPARE;
      337 
      338       if record_satisfies_spec
      339       then
      340 ACCEPT_THIS_RECORD:
      341          do;
      342          number_of_records_accepted = number_of_records_accepted + 1;
      343          if direction_to_process = BACKWARD_DIRECTION
      344          then if highest_accepted_record = NO_RECORD
      345 	    then highest_accepted_record = record_id;
      346 	    else ;
      347          else highest_accepted_record = record_id;
      348 
      349          if get
      350          then call APPEND_OUTPUT_RECORD (record_string_ptr,
      351 	         record_string_length, typed_vector_array_ptr,
      352 	         field_table_ptr, work_area_ptr, id_list_ptr,
      353 	         record_id_field_id, record_id, area_status);
      354          if get_id & area_status = AREA_IS_BIG_ENOUGH
      355          then
      356 	  do;
      357 	  call APPEND_OUTPUT_RECORD_ID (record_id, element_id_list_ptr,
      358 	       number_of_records_accepted, maximum_number_of_records,
      359 	       temp_element_id_list_ptr, area_status);
      360 
      361 	  if area_status = AREA_IS_TOO_SMALL & get
      362 	  then
      363 	     do;
      364 	     call dm_vector_util_$free_typed_vector (work_area_ptr,
      365 		typed_vector_array_ptr,
      366 		typed_vector_array
      367 		.vector_slot (typed_vector_array.number_of_vectors), code);
      368 	     if code ^= 0
      369 	     then call ERROR_RETURN (code);
      370 	     typed_vector_array.number_of_vectors =
      371 		typed_vector_array.number_of_vectors - 1;
      372 	     end;
      373 	  end;
      374          end ACCEPT_THIS_RECORD;
      375 
      376       if number_of_records_accepted >= maximum_number_of_records
      377 	 | record_id = last_record_to_process
      378       then record_id = NO_RECORD;	         /* Finished */
      379       else if area_status = AREA_IS_TOO_SMALL
      380       then
      381          do;
      382          record_id = NO_RECORD;
      383          highest_accepted_record = previous_record_id;
      384          end;
      385       else
      386 GET_NEXT:
      387          do;			         /* More records to look at */
      388          previous_record_id = record_id;
      389          if get_each_record
      390          then call GET_RECORD (current_ci_ptr, previous_record_id,
      391 	         direction_to_process, record_buffer_ptr,
      392 	         record_buffer_length, record_string_ptr,
      393 	         record_string_length, record_id);
      394          else call GET_RECORD_ID (previous_record_id, direction_to_process,
      395 	         record_id);
      396          end GET_NEXT;
      397    end RECORD_LOOP;
      398 
      399    if record_count > LIMIT_TO_STOP_INFINITE_LOOPING
      400    then call sub_err_ (dm_error_$programming_error, MYNAME,
      401 	   ACTION_CANT_RESTART, null, 0,
      402 	   "^/The search algorithm was apparently looping indefinitely.");
      403 
      404    if number_of_records_accepted <= 0 & area_status = AREA_IS_BIG_ENOUGH
      405    then call ERROR_RETURN (dm_error_$record_not_found);
      406 
      407 /*** Records were found. Return 0 code and prepare return data. */
      408 
      409    if direction_to_process = BACKWARD_DIRECTION
      410    then
      411       do;
      412 
      413    /*** The records were retrieved backwards, and must be re-ordered before
      414*        returning to the caller. Reverse the order of the vectors in the
      415*        typed_vector_array and/or the element_ids in the element_id_list. */
      416 
      417       call REVERSE_RECORD_ORDER (typed_vector_array_ptr);
      418       call REVERSE_RECORD_ID_ORDER (element_id_list_ptr);
      419 
      420       end;
      421 
      422    if get
      423    then p_typed_vector_array_ptr = typed_vector_array_ptr;
      424 
      425    if get_id
      426    then
      427       do;
      428       p_element_id_list_ptr = element_id_list_ptr;
      429       element_id_list.number_of_elements = number_of_records_accepted;
      430       end;
      431 
      432    if count
      433    then p_number_of_records_accepted = number_of_records_accepted;
      434    else
      435       do;				         /* get | get_id | position */
      436       record_cursor.record_id = highest_accepted_record;
      437       record_cursor.flags.position_is_valid = TRUE;
      438       end;
      439 
      440    call RETURN (area_status);
      441 
      442 MAIN_RETURN:
      443    return;
      444 
      445 
      446 RETURN:
      447    proc (r_p_area_status);
      448    dcl	 r_p_area_status	    fixed bin parm;
      449 
      450    call FINISH ();
      451 
      452    if r_p_area_status = AREA_IS_TOO_SMALL
      453    then p_code = error_table_$area_too_small;
      454    else p_code = 0;
      455 
      456    goto MAIN_RETURN;
      457 
      458    end RETURN;
      459 
      460 CHECK_VERSION:
      461    proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);
      462 
      463    dcl	 cv_p_received_version  fixed bin (35);
      464    dcl	 cv_p_expected_version  fixed bin (35);
      465    dcl	 cv_p_structure_name    char (*);
      466 
      467    if cv_p_received_version ^= cv_p_expected_version
      468    then call sub_err_ (error_table_$unimplemented_version, MYNAME,
      469 	   ACTION_CANT_RESTART, null, 0,
      470 	   "^/Expected version ^d of the ^a structure. Received version ^d.",
      471 	   cv_p_expected_version, cv_p_structure_name, cv_p_received_version)
      472 	   ;
      473 
      474    end CHECK_VERSION;
      475 
      476 FINISH:
      477    proc ();
      478 
      479    call RESET_CI_PTR (current_ci_ptr, current_ci_ptr);
      480    if temp_typed_vector_array_ptr ^= null
      481    then free temp_typed_vector_array_ptr -> typed_vector_array;
      482    if temp_element_id_list_ptr ^= null
      483    then free temp_element_id_list_ptr -> element_id_list;
      484    if record_buffer_ptr ^= addr (local_record_buffer)
      485         & record_buffer_ptr ^= null ()
      486    then free record_buffer;
      487 
      488    end FINISH;
      489 
      490 ERROR_RETURN:
      491    proc (er_p_code);
      492 
      493    dcl	 er_p_code	    fixed bin (35);
      494 
      495    p_code = er_p_code;
      496    call FINISH;
      497    go to MAIN_RETURN;
      498 
      499    end ERROR_RETURN;
      500 
      501 GET_RECORD:
      502    proc (gr_p_ci_ptr, gr_p_previous_record_id, gr_p_direction,
      503         gr_p_record_buffer_ptr, gr_p_record_buffer_length,
      504         gr_p_record_string_ptr, gr_p_record_string_length, gr_p_record_id);
      505 
      506    dcl	 gr_p_ci_ptr	    ptr parameter;
      507    dcl	 gr_p_previous_record_id
      508 			    bit (36) aligned parameter;
      509    dcl	 gr_p_record_id	    bit (36) aligned parameter;
      510    dcl	 gr_p_record_string_ptr ptr parameter;
      511    dcl	 gr_p_direction	    fixed bin (17) parameter;
      512    dcl	 gr_p_record_string_length
      513 			    fixed bin (35) parameter;
      514    dcl	 gr_p_record_buffer_ptr ptr parameter;
      515    dcl	 gr_p_record_buffer_length
      516 			    fixed bin (35) parameter;
      517    dcl	 gr_p_record_buffer	    bit (gr_p_record_buffer_length) aligned
      518 			    based (gr_p_record_buffer_ptr);
      519 
      520    dcl	 gr_record_id	    bit (36) aligned;
      521    dcl	 gr_code		    fixed bin (35);
      522    dcl	 gr_new_ci_ptr	    ptr;
      523 
      524    gr_code = 0;
      525    gr_new_ci_ptr = null ();
      526    gr_record_id = gr_p_previous_record_id;
      527    call collection_manager_$get_by_ci_ptr (gr_p_ci_ptr,
      528         record_cursor.file_opening_id, record_cursor.collection_id,
      529         gr_record_id, gr_p_direction, gr_p_record_buffer_ptr,
      530         gr_p_record_buffer_length, work_area_ptr, ("0"b),
      531         gr_p_record_string_ptr, gr_p_record_string_length, gr_new_ci_ptr,
      532         gr_code);
      533    if gr_code = 0
      534    then gr_p_record_id = gr_record_id;
      535    else
      536       do;
      537       if gr_code = dm_error_$end_of_collection
      538 	 | gr_code = dm_error_$beginning_of_collection
      539       then gr_p_record_id = NO_RECORD;
      540       else if gr_code = dm_error_$long_return_element
      541       then call ERROR_RETURN (gr_code);
      542       else call sub_err_ (gr_code, MYNAME, ACTION_CANT_RESTART, null, 0,
      543 	      "^/This error, which occurred while retrieving record ^b3o, indicates that^/record collection ^b3o is damaged."
      544 	      , gr_p_record_id, record_cursor.collection_id);
      545       end;
      546 
      547    if gr_p_ci_ptr ^= null & gr_p_ci_ptr ^= gr_new_ci_ptr
      548    then call RESET_CI_PTR (gr_new_ci_ptr, gr_p_ci_ptr);
      549    else /* gr_p_ci_ptr remains the same */
      550         ;
      551 
      552    if gr_p_record_string_ptr ^= gr_p_record_buffer_ptr
      553    then
      554       do;
      555       if gr_p_record_buffer_ptr ^= addr (local_record_buffer)
      556       then free gr_p_record_buffer;
      557       gr_p_record_buffer_ptr = gr_p_record_string_ptr;
      558       gr_p_record_buffer_length = gr_p_record_string_length;
      559       end;
      560 
      561    return;
      562 
      563    end GET_RECORD;
      564 
      565 GET_RECORD_ID:
      566    proc (gri_p_previous_record_id, gri_p_direction, gri_p_record_id);
      567 
      568    dcl	 gri_p_previous_record_id
      569 			    bit (36) aligned parameter;
      570    dcl	 gri_p_record_id	    bit (36) aligned parameter;
      571    dcl	 gri_p_direction	    fixed bin (17) parameter;
      572 
      573    dcl	 gri_code		    fixed bin (35);
      574 
      575 
      576    call collection_manager_$get_id (record_cursor.file_opening_id,
      577         record_cursor.collection_id, gri_p_previous_record_id, gri_p_direction,
      578         IS_RELATIVE, gri_p_record_id, gri_code);
      579    if gri_code ^= 0
      580    then if gri_code = dm_error_$beginning_of_collection
      581 	   | gri_code = dm_error_$end_of_collection
      582         then gri_p_record_id = NO_RECORD;
      583         else call ERROR_RETURN (gri_code);
      584 
      585    return;
      586 
      587    end GET_RECORD_ID;
      588 
      589 RESET_CI_PTR:
      590    proc (rcp_p_new_ci_ptr, rcp_p_ci_ptr);
      591 
      592 /* Releases the ci_ptr held in rcp_p_ci_ptr, if non-null, then resets */
      593 /* rcp_p_ci_ptr with the value of rcp_p_new_ci_ptr. */
      594 
      595    dcl	 rcp_p_ci_ptr	    ptr parameter;
      596    dcl	 rcp_p_new_ci_ptr	    ptr parameter;
      597 
      598    if rcp_p_ci_ptr ^= null
      599    then /* After MR11, should call collection_manager_$release_ci_ptr */
      600         ;
      601 
      602    rcp_p_ci_ptr = rcp_p_new_ci_ptr;
      603 
      604    return;
      605 
      606    end RESET_CI_PTR;
      607 
      608 APPEND_OUTPUT_RECORD:
      609    proc (aor_p_record_string_ptr, aor_p_record_string_length,
      610         aor_p_typed_vector_array_ptr, aor_p_field_table_ptr,
      611         aor_p_work_area_ptr, aor_p_id_list_ptr, aor_p_record_id_field_id,
      612         aor_p_record_id, aor_p_area_status);
      613 
      614    dcl	 aor_p_record_string_ptr
      615 			    ptr parameter;
      616    dcl	 aor_p_record_string_length
      617 			    fixed bin (35) parameter;
      618    dcl	 aor_p_typed_vector_array_ptr
      619 			    ptr parameter;
      620    dcl	 aor_p_field_table_ptr  ptr parameter;
      621    dcl	 aor_p_work_area_ptr    ptr parameter;
      622    dcl	 aor_p_id_list_ptr	    ptr parameter;
      623    dcl	 aor_p_record_id_field_id
      624 			    fixed bin parameter;
      625    dcl	 aor_p_record_id	    bit (36) aligned parameter;
      626    dcl	 aor_p_area_status	    fixed bin parm;
      627 
      628    dcl	 aor_vector_ptr	    ptr;
      629    dcl	 aor_record_id_ptr	    ptr;
      630    dcl	 aor_code		    fixed bin (35);
      631 
      632    aor_code = 0;
      633 
      634    aor_vector_ptr =
      635         dm_vector_util_$append_simple_typed_vector (aor_p_work_area_ptr,
      636         VECTOR_SLOT_INCREMENT, FREE_OLD_TYPED_VECTOR_ARRAY,
      637         aor_p_typed_vector_array_ptr, aor_code);
      638    if aor_code ^= 0
      639    then if aor_code = error_table_$area_too_small
      640         then call AOR_RETURN (AREA_IS_TOO_SMALL);
      641         else call ERROR_RETURN (aor_code);
      642 
      643    call data_format_util_$new_cv_string_to_vector (aor_p_field_table_ptr,
      644         aor_p_work_area_ptr, aor_p_record_string_ptr,
      645         aor_p_record_string_length, aor_p_id_list_ptr, aor_vector_ptr,
      646         aor_code);
      647    if aor_code ^= 0
      648    then if aor_code = error_table_$area_too_small
      649         then
      650 	 do;
      651 	 aor_p_typed_vector_array_ptr
      652 	      -> typed_vector_array.number_of_vectors =
      653 	      aor_p_typed_vector_array_ptr
      654 	      -> typed_vector_array.number_of_vectors - 1;
      655 	 call dm_vector_util_$free_typed_vector (aor_p_work_area_ptr,
      656 	      aor_p_typed_vector_array_ptr, aor_vector_ptr, aor_code);
      657 	 if aor_code ^= 0
      658 	 then call ERROR_RETURN (aor_code);
      659 	 call AOR_RETURN (AREA_IS_TOO_SMALL);
      660 	 end;
      661         else call ERROR_RETURN (aor_code);
      662 
      663    if aor_p_record_id_field_id ^= DEFAULT_RECORD_ID_FIELD_ID
      664    then
      665       do;
      666       alloc element_id in (aor_p_work_area_ptr -> work_area)
      667 	 set (aor_record_id_ptr);
      668       aor_vector_ptr
      669 	 -> simple_typed_vector.dimension (aor_p_record_id_field_id)
      670 	 .value_ptr = aor_record_id_ptr;
      671       unspec (aor_record_id_ptr -> element_id) = aor_p_record_id;
      672       end;
      673 
      674    call AOR_RETURN (AREA_IS_BIG_ENOUGH);
      675 AOR_MAIN_RETURN:
      676    return;
      677 
      678 AOR_RETURN:
      679    proc (aorr_p_area_status);
      680    dcl	 aorr_p_area_status	    fixed bin parm;
      681    aor_p_area_status = aorr_p_area_status;
      682    goto AOR_MAIN_RETURN;
      683    end AOR_RETURN;
      684 
      685    end APPEND_OUTPUT_RECORD;
      686 
      687 APPEND_OUTPUT_RECORD_ID:
      688    proc (aori_p_record_id, aori_p_eil_ptr, aori_p_number_of_records_accepted,
      689         aori_p_maximum_number_of_records, aori_p_temp_eil_ptr,
      690         aori_p_area_status);
      691 
      692    dcl	 aori_p_record_id	    bit (36) aligned parameter;
      693    dcl	 aori_p_eil_ptr	    ptr parameter;
      694    dcl	 aori_p_number_of_records_accepted
      695 			    fixed bin (35) parameter;
      696    dcl	 aori_p_maximum_number_of_records
      697 			    fixed bin (35) parameter;
      698    dcl	 aori_p_temp_eil_ptr    ptr parameter;
      699    dcl	 aori_p_area_status	    fixed bin parm;
      700 
      701    dcl	 aori_eil_ptr	    ptr init (null);
      702    dcl	 aori_slot_idx	    fixed bin (35);
      703 
      704    if aori_p_eil_ptr -> element_id_list.number_of_elements
      705         < aori_p_number_of_records_accepted
      706    then
      707       do;
      708       eil_number_of_elements =
      709 	 min (aori_p_eil_ptr -> element_id_list.number_of_elements
      710 	 + ELEMENT_ID_LIST_INCREMENT, aori_p_maximum_number_of_records);
      711       aori_p_temp_eil_ptr = element_id_list_ptr;
      712 
      713       on area call AORI_RETURN (AREA_IS_TOO_SMALL);
      714       alloc element_id_list in (work_area) set (aori_eil_ptr);
      715       aori_p_eil_ptr = aori_eil_ptr;
      716 
      717       aori_p_eil_ptr -> element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
      718 
      719       do aori_slot_idx = 1
      720 	 to hbound (aori_p_temp_eil_ptr -> element_id_list.id, 1);
      721          aori_p_eil_ptr -> element_id_list.id (aori_slot_idx) =
      722 	    aori_p_temp_eil_ptr -> element_id_list.id (aori_slot_idx);
      723       end;
      724 
      725       free aori_p_temp_eil_ptr -> element_id_list;
      726       aori_p_temp_eil_ptr = null ();
      727       end;
      728    aori_p_eil_ptr -> element_id_list.id (aori_p_number_of_records_accepted) =
      729         aori_p_record_id;
      730 
      731    call AORI_RETURN (AREA_IS_BIG_ENOUGH);
      732 
      733 AORI_MAIN_RETURN:
      734    return;
      735 
      736 AORI_RETURN:
      737    proc (aorir_p_area_status);
      738    dcl	 aorir_p_area_status    fixed bin parm;
      739    aori_p_area_status = aorir_p_area_status;
      740 
      741    goto AORI_MAIN_RETURN;
      742    end AORI_RETURN;
      743 
      744    end APPEND_OUTPUT_RECORD_ID;
      745 
      746 REVERSE_RECORD_ORDER:
      747    proc (rro_p_tva_ptr);
      748 
      749    dcl	 rro_p_tva_ptr	    ptr;
      750 
      751    dcl	 rro_slot_idx	    fixed bin;
      752    dcl	 rro_vector_ptr	    ptr;
      753 
      754    if rro_p_tva_ptr = null
      755    then return;
      756 
      757    do rro_slot_idx = 1
      758         to
      759         divide (rro_p_tva_ptr -> typed_vector_array.number_of_vectors, 2, 35,
      760         0);
      761       rro_vector_ptr =
      762 	 rro_p_tva_ptr -> typed_vector_array.vector_slot (rro_slot_idx);
      763       rro_p_tva_ptr -> typed_vector_array.vector_slot (rro_slot_idx) =
      764 	 rro_p_tva_ptr
      765 	 -> typed_vector_array
      766 	 .
      767 	 vector_slot (rro_p_tva_ptr -> typed_vector_array.number_of_vectors
      768 	 - rro_slot_idx + 1);
      769       rro_p_tva_ptr
      770 	 -> typed_vector_array
      771 	 .
      772 	 vector_slot (rro_p_tva_ptr -> typed_vector_array.number_of_vectors
      773 	 - rro_slot_idx + 1) = rro_vector_ptr;
      774    end;
      775 
      776    return;
      777 
      778    end REVERSE_RECORD_ORDER;
      779 
      780 REVERSE_RECORD_ID_ORDER:
      781    proc (rrio_p_eil_ptr);
      782 
      783    dcl	 rrio_p_eil_ptr	    ptr;
      784    dcl	 rrio_slot_idx	    fixed bin;
      785    dcl	 rrio_id		    bit (36) aligned;
      786 
      787    if rrio_p_eil_ptr = null
      788    then return;
      789 
      790    do rrio_slot_idx = 1
      791         to divide (typed_vector_array.number_of_vectors, 2, 35, 0);
      792       rrio_id = rrio_p_eil_ptr -> element_id_list.id (rrio_slot_idx);
      793       rrio_p_eil_ptr -> element_id_list.id (rrio_slot_idx) =
      794 	 rrio_p_eil_ptr
      795 	 -> element_id_list
      796 	 .
      797 	 id (rrio_p_eil_ptr -> element_id_list.number_of_elements
      798 	 - rrio_slot_idx + 1);
      799       rrio_p_eil_ptr
      800 	 -> element_id_list
      801 	 .
      802 	 id (rrio_p_eil_ptr -> element_id_list.number_of_elements
      803 	 - rrio_slot_idx + 1) = rrio_id;
      804    end;
      805 
      806    return;
      807 
      808    end REVERSE_RECORD_ID_ORDER;
      809 
      810 SETUP_ID_LIST:
      811    proc (sil_p_input_id_list_ptr, sil_p_output_id_list_ptr,
      812         sil_p_record_id_field_id);
      813 
      814    dcl	 sil_p_input_id_list_ptr
      815 			    ptr parameter;
      816    dcl	 sil_p_output_id_list_ptr
      817 			    ptr parameter;
      818    dcl	 sil_p_record_id_field_id
      819 			    fixed bin;
      820 
      821    sil_p_output_id_list_ptr = sil_p_input_id_list_ptr;
      822    if sil_p_output_id_list_ptr = null ()
      823    then
      824       do;
      825       sil_p_record_id_field_id = DEFAULT_RECORD_ID_FIELD_ID;
      826       end;
      827    else
      828       do;
      829       call CHECK_VERSION (sil_p_output_id_list_ptr -> id_list.version,
      830 	 (ID_LIST_VERSION_1), "id_list");
      831       if sil_p_output_id_list_ptr -> id_list.number_of_ids = 0
      832       then
      833          do;
      834          sil_p_output_id_list_ptr = null ();
      835          sil_p_record_id_field_id = DEFAULT_RECORD_ID_FIELD_ID;
      836          end;
      837       else
      838          do;
      839          if sil_p_output_id_list_ptr
      840 	    -> id_list.id (sil_p_output_id_list_ptr -> id_list.number_of_ids)
      841 	    = DEFAULT_RECORD_ID_FIELD_ID
      842          then sil_p_record_id_field_id =
      843 	         sil_p_output_id_list_ptr -> id_list.number_of_ids;
      844          else sil_p_record_id_field_id = DEFAULT_RECORD_ID_FIELD_ID;
      845          end;
      846       end;
      847 
      848    return;
      849 
      850    end SETUP_ID_LIST;
      851 
      852 SETUP_OUTPUT_IDS:
      853    proc (soi_p_input_eil_ptr, soi_p_maximum_number_of_ids,
      854         soi_p_output_eil_ptr);
      855 
      856    dcl	 soi_p_input_eil_ptr    ptr parameter;
      857    dcl	 soi_p_maximum_number_of_ids
      858 			    fixed bin (35) parameter;
      859    dcl	 soi_p_output_eil_ptr   ptr parameter;
      860 
      861    if soi_p_input_eil_ptr = null ()
      862    then
      863       do;
      864       eil_number_of_elements =
      865 	 min (soi_p_maximum_number_of_ids, ELEMENT_ID_LIST_INCREMENT);
      866       alloc element_id_list in (work_area) set (soi_p_output_eil_ptr);
      867       soi_p_output_eil_ptr -> element_id_list.version =
      868 	 ELEMENT_ID_LIST_VERSION_1;
      869       end;
      870    else
      871       do;
      872       soi_p_output_eil_ptr = soi_p_input_eil_ptr;
      873       call CHECK_VERSION (soi_p_output_eil_ptr -> element_id_list.version,
      874 	 ELEMENT_ID_LIST_VERSION_1, "element_id");
      875       end;
      876 
      877    return;
      878 
      879    end SETUP_OUTPUT_IDS;
      880 
      881 SETUP_OUTPUT_RECORDS:
      882    proc (sor_p_input_tva_ptr, sor_p_maximum_number_of_records,
      883         sor_p_record_id_field_id, sor_p_field_table_ptr, sor_p_id_list_ptr,
      884         sor_p_work_area_ptr, sor_p_output_tva_ptr);
      885 
      886    dcl	 sor_p_input_tva_ptr    ptr parameter parameter;
      887    dcl	 sor_p_maximum_number_of_records
      888 			    fixed bin (35) parameter;
      889    dcl	 sor_p_record_id_field_id
      890 			    fixed bin parameter;
      891    dcl	 sor_p_field_table_ptr  ptr parameter;
      892    dcl	 sor_p_id_list_ptr	    ptr parameter;
      893    dcl	 sor_p_work_area_ptr    ptr parameter;
      894    dcl	 sor_p_output_tva_ptr   ptr parameter;
      895 
      896    dcl	 sor_p_work_area	    area based (sor_p_work_area_ptr);
      897 
      898    dcl	 sor_record_id_descriptor_ptr
      899 			    ptr;
      900    dcl	 sor_code		    fixed bin (35);
      901 
      902    if sor_p_input_tva_ptr = null ()
      903    then
      904       do;
      905       sor_code = 0;
      906       call data_format_util_$cv_table_to_typed_array (sor_p_field_table_ptr,
      907 	 sor_p_id_list_ptr, sor_p_work_area_ptr, (VECTOR_SLOT_INCREMENT),
      908 	 sor_p_output_tva_ptr, sor_code);
      909       if sor_code ^= 0
      910       then call ERROR_RETURN (sor_code);
      911       call CHECK_VERSION (sor_p_output_tva_ptr -> typed_vector_array.version,
      912 	 TYPED_VECTOR_ARRAY_VERSION_2, "typed_vector_array");
      913       if sor_p_record_id_field_id ^= DEFAULT_RECORD_ID_FIELD_ID
      914       then
      915          do;
      916          alloc arg_descriptor in (sor_p_work_area)
      917 	    set (sor_record_id_descriptor_ptr);
      918          sor_record_id_descriptor_ptr -> arg_descriptor.flag = TRUE;
      919          sor_record_id_descriptor_ptr -> arg_descriptor.type = bit_dtype;
      920          sor_record_id_descriptor_ptr -> arg_descriptor.packed = FALSE;
      921          sor_record_id_descriptor_ptr -> arg_descriptor.number_dims = 0;
      922          sor_record_id_descriptor_ptr -> arg_descriptor.size = 36;
      923          sor_p_output_tva_ptr
      924 	    -> typed_vector_array.dimension_table (sor_p_record_id_field_id)
      925 	    .name = "0";
      926          sor_p_output_tva_ptr
      927 	    -> typed_vector_array.dimension_table (sor_p_record_id_field_id)
      928 	    .descriptor_ptr = sor_record_id_descriptor_ptr;
      929          end;
      930       end;
      931    else
      932       do;
      933       sor_p_output_tva_ptr = sor_p_input_tva_ptr;
      934       call CHECK_VERSION (sor_p_output_tva_ptr -> typed_vector_array.version,
      935 	 TYPED_VECTOR_ARRAY_VERSION_2, "typed_vector_array");
      936       end;
      937 
      938    return;
      939 
      940    end SETUP_OUTPUT_RECORDS;
      941 
  1     1 /* BEGIN INCLUDE FILE - dm_rcm_cursor.incl.pl1 */
  1     2 
  1     3 /* HISTORY:
  1     4*Written by Matthew Pierret, 04/05/82.
  1     5*Modified:
  1     6*08/19/82 by Matthew Pierret:  Version 2. Changed collection_id to 
  1     7*            bit (36) aligned.
  1     8*07/28/83 by Matthew Pierret: Changed name from dm_rm_cursor.incl.pl1 to
  1     9*            dm_rcm_cursor.incl.pl1.
  1    10*04/13/84 by Lee Baldwin:  Renamed pf_opening_id to file_opening_id to coincide
  1    11*            with the naming conventions used in the rcm_XX routines.
  1    12**/
  1    13 
  1    14 /* format: style2,ind3 */
  1    15      dcl	   1 record_cursor	      aligned based (record_cursor_ptr),
  1    16 	     2 type	      fixed bin (17) unaligned,
  1    17 	     2 version	      fixed bin (17) unaligned,
  1    18 	     2 flags,
  1    19 	       3 position_is_valid
  1    20 			      bit (1) unal,
  1    21 	       3 pad	      bit (35) unal,
  1    22 	     2 area_ptr	      ptr,
  1    23 	     2 file_opening_id    bit (36) aligned,
  1    24 	     2 collection_id      bit (36) aligned,
  1    25 	     2 record_id	      bit (36) aligned,
  1    26 	     2 record_check_value bit (36) aligned;
  1    27 
  1    28      dcl	   record_cursor_ptr      ptr;
  1    29      dcl	   RECORD_CURSOR_VERSION_2
  1    30 			      init (2) fixed bin int static options (constant);
  1    31      dcl	   RECORD_CURSOR_TYPE     init (1) fixed bin int static options (constant);
  1    32      dcl	   BEGINNING_OF_COLLECTION_RECORD_ID
  1    33 			      init ("0"b) bit (36) aligned int static options (constant);
  1    34 
  1    35 /* END INCLUDE FILE - dm_rcm_cursor.incl.pl1 */
      942 
      943 
  2     1 /* ***********************************************************
  2     2*   *                                                         *
  2     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  2     4*   *                                                         *
  2     5*   *********************************************************** */
  2     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  2     7 
  2     8 /* Written by Lindsey Spratt, 03/04/82.
  2     9*Modified:
  2    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  2    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  2    12*	  the print_vector value (char varying), ptr to the typed_vector
  2    13*	  value location, and a code. cv_to_print now takes ptr to the
  2    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  2    15*	  (char(*) varying), the maximum allowed length for the print_vector
  2    16*	  value, a temp_seg to put the value in if its to big to fit into
  2    17*	  the print_vector, and a code.
  2    18**/
  2    19 
  2    20 /* format: style2,ind3 */
  2    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  2    22 	     2 version	      fixed bin (35),
  2    23 	     2 number_of_dimensions
  2    24 			      fixed bin (17),
  2    25 	     2 number_of_vectors  fixed bin (17),
  2    26 	     2 number_of_vector_slots
  2    27 			      fixed bin (17),
  2    28 	     2 maximum_dimension_name_length
  2    29 			      fixed bin (17),
  2    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  2    31 	       3 name	      char (tva_maximum_dimension_name_length
  2    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  2    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  2    34 						/* temp_seg_ptr, max_length_for_print_value, */
  2    35 						/* print_value, code) */
  2    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  2    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  2    38 						/* print_value_ptr, typed_value_ptr, code) */
  2    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  2    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  2    41 			      pointer;
  2    42 
  2    43      dcl	   typed_vector_array_ptr ptr;
  2    44      dcl	   tva_number_of_vector_slots
  2    45 			      fixed bin;
  2    46      dcl	   tva_number_of_dimensions
  2    47 			      fixed bin;
  2    48      dcl	   tva_maximum_dimension_name_length
  2    49 			      fixed bin;
  2    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  2    51 			      fixed bin (35) int static options (constant) init (2);
  2    52 
  2    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      944 
      945 
  3     1 /* ***********************************************************
  3     2*   *                                                         *
  3     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  3     4*   *                                                         *
  3     5*   *********************************************************** */
  3     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  3     7 
  3     8 /* Written by Lindsey Spratt, 04/02/82.
  3     9*Modified:
  3    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  3    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  3    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  3    13*	  type.
  3    14**/
  3    15 
  3    16 /* format: style2,ind3 */
  3    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  3    18 	     2 type	      fixed bin (17) unal,
  3    19 	     2 number_of_dimensions
  3    20 			      fixed bin (17) unal,
  3    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  3    22 	       3 value_ptr	      ptr unaligned;
  3    23 
  3    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  3    25 	     2 type	      fixed bin (17) unal,
  3    26 	     2 number_of_dimensions
  3    27 			      fixed bin (17) unal,
  3    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  3    29 	       3 identifier	      fixed bin (17) unal,
  3    30 	       3 pad	      bit (18) unal,
  3    31 	       3 value_ptr	      ptr unal;
  3    32 
  3    33      dcl	   simple_typed_vector_ptr
  3    34 			      ptr;
  3    35      dcl	   stv_number_of_dimensions
  3    36 			      fixed bin (17);
  3    37 
  3    38      dcl	   general_typed_vector_ptr
  3    39 			      ptr;
  3    40      dcl	   gtv_number_of_dimensions
  3    41 			      fixed bin (17);
  3    42 
  3    43      dcl	   (
  3    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  3    45 			      init (1),		/* value_ptr was aligned. */
  3    46 	   GENERAL_TYPED_VECTOR_TYPE
  3    47 			      init (2),
  3    48 	   SIMPLE_TYPED_VECTOR_TYPE
  3    49 			      init (3)
  3    50 	   )		      fixed bin (17) internal static options (constant);
  3    51 
  3    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      946 
      947 
  4     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        Contains the declaration of an element identifier.  Element
  4     6*   identifiers consist of two parts, the id (number) of the control interval
  4     7*   in which the element resides, and the index into the slot table of
  4     8*   the element in the control interval.  The declaration of the element_id 
  4     9*   structure reflects this division of the element identifier.  The structure 
  4    10*   is based on the automatic bit string element_id_string because programs
  4    11*   generally pass bit strings (element_id_string) to each other, then 
  4    12*   interpret the bit string by overlaying the element_id structure ony if
  4    13*   it is necessary to access the parts of the id.  Basing element_id on
  4    14*   addr(element_id_string) instead of on a pointer removes the necessity
  4    15*   for always setting that pointer explicitly and guarantees that changes
  4    16*   made to the string or structure do not get inconsistent.
  4    17*
  4    18*   Changes made to element_id must also be made to datum_id, declared in 
  4    19*   dm_cm_datum.incl.pl1.
  4    20**/
  4    21 
  4    22 /* HISTORY:
  4    23*Written by Matthew Pierret, 04/01/82.
  4    24*Modified:
  4    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  4    26**/
  4    27 
  4    28 /* format: style2,ind3,ll79 */
  4    29 
  4    30      dcl	   element_id_string      bit (36) aligned;
  4    31 
  4    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  4    33 	     2 control_interval_id
  4    34 			      fixed bin (24) unal unsigned,
  4    35 	     2 index	      fixed bin (12) unal unsigned;
  4    36 
  4    37 
  4    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      948 
      949 
  5     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*     This include file contains declarations of all collection_manager_ 
  5     5*     entrypoints.
  5     6**/
  5     7 
  5     8 /* HISTORY:
  5     9*Written by Matthew Pierret 
  5    10*Modified:
  5    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  5    12*	  allocate_control_interval operation to be unaligned, as well as
  5    13*	  unsigned.
  5    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  5    15*            removed the beginning_location parameter from the put_element
  5    16*            operation. Added the create_page_file_operation.
  5    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  5    18*            wherever collection_id was required.
  5    19*            Also changed the control_interval_id parameter of the 
  5    20*            allocate_control_interval operation back to be aligned. So there.
  5    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  5    22*            added the argument file_create_info_ptr to $create_file.
  5    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  5    24*	  include the zero_on_free bit.
  5    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  5    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  5    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  5    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  5    29*            cm_$put_unprotected_header.
  5    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  5    31*             $simple_get_buffered_element.
  5    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  5    33*            parameter for specifying absolute/relative nature of search.
  5    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  5    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  5    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  5    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  5    38*            delete_from_ci_buffer.
  5    39*            Re-named *_buffered_ci to =_ci_buffer.
  5    40*            get entries.
  5    41*            modify entries.
  5    42*            Changed calling sequence of modify entries to have a ptr/length
  5    43*            instead of length/ptr parameter pair.
  5    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  5    45**/
  5    46 
  5    47 /* This include file contains declarations of collection_manager_ entrypoints */
  5    48 
  5    49 /* format: style2,ind3 */
  5    50      dcl	   collection_manager_$allocate_control_interval
  5    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  5    52      dcl	   collection_manager_$compact_control_interval
  5    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  5    54      dcl	   collection_manager_$create_collection
  5    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  5    56      dcl	   collection_manager_$create_file
  5    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  5    58      dcl	   collection_manager_$destroy_collection
  5    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  5    60      dcl	   collection_manager_$free_control_interval
  5    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  5    62 			      fixed bin (35));
  5    63 
  5    64      dcl	   collection_manager_$delete
  5    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  5    66 			      fixed bin (35));
  5    67      dcl	   collection_manager_$delete_from_ci_buffer
  5    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  5    69 			      fixed bin (35));
  5    70 
  5    71      dcl	   collection_manager_$get
  5    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  5    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  5    74      dcl	   collection_manager_$get_control_interval_ptr
  5    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  5    76 			      fixed bin (35));
  5    77      dcl	   collection_manager_$get_from_ci_buffer
  5    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  5    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  5    80      dcl	   collection_manager_$get_by_ci_ptr
  5    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  5    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  5    83      dcl	   collection_manager_$get_header
  5    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  5    85 			      ptr, fixed bin (35), fixed bin (35));
  5    86      dcl	   collection_manager_$get_id
  5    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  5    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  5    89      dcl	   collection_manager_$get_portion
  5    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  5    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  5    92 			      fixed bin (35), fixed bin (35));
  5    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  5    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  5    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  5    96 			      fixed bin (35));
  5    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  5    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  5    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  5   100 			      fixed bin (35));
  5   101      dcl	   collection_manager_$modify
  5   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   103 			      fixed bin (35), fixed bin (35));
  5   104      dcl	   collection_manager_$modify_unprotected
  5   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   106 			      fixed bin (35), fixed bin (35));
  5   107      dcl	   collection_manager_$modify_in_ci_buffer
  5   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   109 			      fixed bin (35), fixed bin (35));
  5   110      dcl	   collection_manager_$modify_portion
  5   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  5   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  5   113      dcl	   collection_manager_$postcommit_increments
  5   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  5   115      dcl	   collection_manager_$put
  5   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   117 			      fixed bin (35), fixed bin (35));
  5   118      dcl	   collection_manager_$put_in_ci_buffer
  5   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   120 			      fixed bin (35), fixed bin (35));
  5   121      dcl	   collection_manager_$put_header
  5   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  5   123      dcl	   collection_manager_$put_unprotected_header
  5   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  5   125 
  5   126      dcl	   collection_manager_$replace_ci_buffer
  5   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  5   128 			      fixed bin (35));
  5   129      dcl	   collection_manager_$setup_ci_buffer
  5   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  5   131 			      fixed bin (35));
  5   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  5   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  5   134 			      fixed bin (35));
  5   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  5   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  5   137 			      fixed bin (35));
  5   138 
  5   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      950 
      951 
  6     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*          The element_id_list structure contains an array of element 
  6     5*     identifiers.  These identifiers are used as tuple, record or 
  6     6*     element identifiers.  This structure is used across the relation_manager_,
  6     7*     record_manager_ and index_manager_ interfaces.  At some time the 
  6     8*     version should be changed to be char(8)aligned, when such a conversion
  6     9*     can be coordinated with the other structures used at these interfaces.
  6    10**/
  6    11 
  6    12 /* HISTORY:
  6    13*Written by Matthew Pierret, 06/06/82.
  6    14*Modified:
  6    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
  6    16*            Did not change version.
  6    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
  6    18**/
  6    19 
  6    20 /* format: style2,ind3 */
  6    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
  6    22 	     2 version	      fixed bin (35),
  6    23 	     2 number_of_elements fixed bin (35),
  6    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
  6    25 
  6    26      dcl	   element_id_list_ptr    ptr;
  6    27      dcl	   eil_number_of_elements fixed bin (35);
  6    28      dcl	   ELEMENT_ID_LIST_VERSION_1
  6    29 			      init (1) fixed bin (35);
  6    30 
  6    31 
  6    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
      952 
      953 
  7     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  7     2 /* format: style3 */
  7     3 
  7     4 /* These constants are to be used for the flags argument of sub_err_ */
  7     5 /* They are just "string (condition_info_header.action_flags)" */
  7     6 
  7     7 declare	(
  7     8 	ACTION_CAN_RESTART	init (""b),
  7     9 	ACTION_CANT_RESTART init ("1"b),
  7    10 	ACTION_DEFAULT_RESTART
  7    11 			init ("01"b),
  7    12 	ACTION_QUIET_RESTART
  7    13 			init ("001"b),
  7    14 	ACTION_SUPPORT_SIGNAL
  7    15 			init ("0001"b)
  7    16 	)		bit (36) aligned internal static options (constant);
  7    17 
  7    18 /* End include file */
      954 
      955 
  8     1 /* BEGIN INCLUDE FILE ... arg_descriptor.incl.pl1
  8     2*
  8     3*   James R. Davis 1 Mar 79 */
  8     4 /* Modified June 83 JMAthane for extended arg descriptor format */
  8     5 
  8     6      dcl	   1 arg_descriptor	      based (arg_descriptor_ptr) aligned,
  8     7 	     2 flag	      bit (1) unal,
  8     8 	     2 type	      fixed bin (6) unsigned unal,
  8     9 	     2 packed	      bit (1) unal,
  8    10 	     2 number_dims	      fixed bin (4) unsigned unal,
  8    11 	     2 size	      fixed bin (24) unsigned unal;
  8    12 
  8    13      dcl	   1 fixed_arg_descriptor based (arg_descriptor_ptr) aligned,
  8    14 	     2 flag	      bit (1) unal,
  8    15 	     2 type	      fixed bin (6) unsigned unal,
  8    16 	     2 packed	      bit (1) unal,
  8    17 	     2 number_dims	      fixed bin (4) unsigned unal,
  8    18 	     2 scale	      fixed bin (11) unal,
  8    19 	     2 precision	      fixed bin (12) unsigned unal;
  8    20 
  8    21      dcl	   1 extended_arg_descriptor based (arg_descriptor_ptr) aligned,
  8    22 	     2 flag	      bit (1) unal,		/* = "1"b */
  8    23 	     2 type	      fixed bin (6) unsigned unal, /* = 58 */
  8    24 	     2 packed	      bit (1) unal,		/* significant if number_dims ^= 0 */
  8    25 	     2 number_dims	      fixed (4) unsigned unal,/* number of variable dimensions */
  8    26 	     2 size	      bit (24) unal,
  8    27 	     2 dims	      (0 refer (extended_arg_descriptor.number_dims)), /* part referenced by called generated code */
  8    28 	       3 low	      fixed bin (35),
  8    29 	       3 high	      fixed bin (35),
  8    30 	       3 multiplier	      fixed bin (35),	/* in bits if packed, in words if not */
  8    31 	     2 real_type	      fixed bin (18) unsigned unal,
  8    32 	     2 type_offset	      fixed bin (18) unsigned unal; /* offset rel to symbol tree to symbol node for type, if any */
  8    33 
  8    34      dcl	   arg_descriptor_ptr     ptr;
  8    35 
  8    36      dcl	   extended_arg_type      fixed bin init (58);
  8    37 
  8    38 /* END INCLUDE file .... arg_descriptor.incl.pl1  */
      956 
      957 
  9     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  9     2 
  9     3 
  9     4 /****^  HISTORY COMMENTS:
  9     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  9     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  9     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  9     8*     Objects of this type are PASCAL string types.
  9     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  9    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  9    11*     Added the new C types.
  9    12*                                                   END HISTORY COMMENTS */
  9    13 
  9    14 /* This include file defines mnemonic names for the Multics
  9    15*   standard descriptor types, using both pl1 and cobol terminology.
  9    16*   PG 780613
  9    17*   JRD 790530
  9    18*   JRD 791016
  9    19*   MBW 810731
  9    20*   TGO 830614 Add hex types.
  9    21*   Modified June 83 JMAthane to add PASCAL data types
  9    22*   TGO 840120 Add float dec extended and generic, float binary generic
  9    23**/
  9    24 
  9    25      dcl	   (real_fix_bin_1_dtype  init (1),
  9    26 	   real_fix_bin_2_dtype   init (2),
  9    27 	   real_flt_bin_1_dtype   init (3),
  9    28 	   real_flt_bin_2_dtype   init (4),
  9    29 	   cplx_fix_bin_1_dtype   init (5),
  9    30 	   cplx_fix_bin_2_dtype   init (6),
  9    31 	   cplx_flt_bin_1_dtype   init (7),
  9    32 	   cplx_flt_bin_2_dtype   init (8),
  9    33 	   real_fix_dec_9bit_ls_dtype init (9),
  9    34 	   real_flt_dec_9bit_dtype init (10),
  9    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  9    36 	   cplx_flt_dec_9bit_dtype init (12),
  9    37 	   pointer_dtype	      init (13),
  9    38 	   offset_dtype	      init (14),
  9    39 	   label_dtype	      init (15),
  9    40 	   entry_dtype	      init (16),
  9    41 	   structure_dtype	      init (17),
  9    42 	   area_dtype	      init (18),
  9    43 	   bit_dtype	      init (19),
  9    44 	   varying_bit_dtype      init (20),
  9    45 	   char_dtype	      init (21),
  9    46 	   varying_char_dtype     init (22),
  9    47 	   file_dtype	      init (23),
  9    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  9    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  9    50 	   real_fix_bin_1_uns_dtype init (33),
  9    51 	   real_fix_bin_2_uns_dtype init (34),
  9    52 	   real_fix_dec_9bit_uns_dtype init (35),
  9    53 	   real_fix_dec_9bit_ts_dtype init (36),
  9    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  9    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  9    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  9    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  9    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  9    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  9    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  9    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  9    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  9    63 	   real_flt_hex_1_dtype   init (47),
  9    64 	   real_flt_hex_2_dtype   init (48),
  9    65 	   cplx_flt_hex_1_dtype   init (49),
  9    66 	   cplx_flt_hex_2_dtype   init (50),
  9    67 	   c_typeref_dtype        init (54),
  9    68 	   c_enum_dtype           init (55),
  9    69              c_enum_const_dtype     init (56),
  9    70 	   c_union_dtype          init (57),
  9    71 	   algol68_straight_dtype init (59),
  9    72 	   algol68_format_dtype   init (60),
  9    73 	   algol68_array_descriptor_dtype init (61),
  9    74 	   algol68_union_dtype    init (62),
  9    75 
  9    76 	   cobol_comp_6_dtype     init (1),
  9    77 	   cobol_comp_7_dtype     init (1),
  9    78 	   cobol_display_ls_dtype init (9),
  9    79 	   cobol_structure_dtype  init (17),
  9    80 	   cobol_char_string_dtype init (21),
  9    81 	   cobol_display_ls_overp_dtype init (29),
  9    82 	   cobol_display_ts_overp_dtype init (30),
  9    83 	   cobol_display_uns_dtype init (35),
  9    84 	   cobol_display_ts_dtype init (36),
  9    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  9    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  9    87 	   cobol_comp_5_uns_dtype init (40),
  9    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  9    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  9    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  9    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  9    92 	   cplx_flt_dec_generic_dtype init (84),
  9    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  9    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  9    95 
  9    96      dcl	   (ft_integer_dtype      init (1),
  9    97 	   ft_real_dtype	      init (3),
  9    98 	   ft_double_dtype	      init (4),
  9    99 	   ft_complex_dtype	      init (7),
  9   100 	   ft_complex_double_dtype init (8),
  9   101 	   ft_external_dtype      init (16),
  9   102 	   ft_logical_dtype	      init (19),
  9   103 	   ft_char_dtype	      init (21),
  9   104 	   ft_hex_real_dtype      init (47),
  9   105 	   ft_hex_double_dtype    init (48),
  9   106 	   ft_hex_complex_dtype   init (49),
  9   107 	   ft_hex_complex_double_dtype init (50)
  9   108 	   )		      fixed bin internal static options (constant);
  9   109 
  9   110      dcl	   (algol68_short_int_dtype init (1),
  9   111 	   algol68_int_dtype      init (1),
  9   112 	   algol68_long_int_dtype init (2),
  9   113 	   algol68_real_dtype     init (3),
  9   114 	   algol68_long_real_dtype init (4),
  9   115 	   algol68_compl_dtype    init (7),
  9   116 	   algol68_long_compl_dtype init (8),
  9   117 	   algol68_bits_dtype     init (19),
  9   118 	   algol68_bool_dtype     init (19),
  9   119 	   algol68_char_dtype     init (21),
  9   120 	   algol68_byte_dtype     init (21),
  9   121 	   algol68_struct_struct_char_dtype init (22),
  9   122 	   algol68_struct_struct_bool_dtype init (20)
  9   123 	   )		      fixed bin internal static options (constant);
  9   124 
  9   125      dcl	   (label_constant_runtime_dtype init (24),
  9   126 	   int_entry_runtime_dtype init (25),
  9   127 	   ext_entry_runtime_dtype init (26),
  9   128 	   ext_procedure_runtime_dtype init (27),
  9   129 	   picture_runtime_dtype  init (63)
  9   130 	   )		      fixed bin internal static options (constant);
  9   131 
  9   132      dcl	   (pascal_integer_dtype  init (1),
  9   133 	   pascal_real_dtype      init (4),
  9   134 	   pascal_label_dtype     init (24),
  9   135 	   pascal_internal_procedure_dtype init (25),
  9   136 	   pascal_exportable_procedure_dtype init (26),
  9   137 	   pascal_imported_procedure_dtype init (27),
  9   138 	   pascal_typed_pointer_type_dtype init (64),
  9   139 	   pascal_char_dtype      init (65),
  9   140 	   pascal_boolean_dtype   init (66),
  9   141 	   pascal_record_file_type_dtype init (67),
  9   142 	   pascal_record_type_dtype init (68),
  9   143 	   pascal_set_dtype	      init (69),
  9   144 	   pascal_enumerated_type_dtype init (70),
  9   145 	   pascal_enumerated_type_element_dtype init (71),
  9   146 	   pascal_enumerated_type_instance_dtype init (72),
  9   147 	   pascal_user_defined_type_dtype init (73),
  9   148 	   pascal_user_defined_type_instance_dtype init (74),
  9   149 	   pascal_text_file_dtype init (75),
  9   150 	   pascal_procedure_type_dtype init (76),
  9   151 	   pascal_variable_formal_parameter_dtype init (77),
  9   152 	   pascal_value_formal_parameter_dtype init (78),
  9   153 	   pascal_entry_formal_parameter_dtype init (79),
  9   154 	   pascal_parameter_procedure_dtype init (80),
  9   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  9   156 
  9   157 
  9   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      958 
      959 
 10     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
 10     2 
 10     3 /* DESCRIPTION
 10     4*        The id_list structure is used to identify attributes, fields and
 10     5*   dimensions by various modules of the Data Management System.
 10     6**/
 10     7 
 10     8 /* HISTORY:
 10     9*Written by Matthew Pierret, '82.
 10    10*Modified:
 10    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
 10    12*            (constant)' and to initialize automatic variables.
 10    13**/
 10    14 
 10    15 /* format: style2,ind3 */
 10    16      dcl	   1 id_list	      aligned based (id_list_ptr),
 10    17 	     2 version	      fixed bin (35),
 10    18 	     2 number_of_ids      fixed bin (17),
 10    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
 10    20 
 10    21      dcl	   id_list_ptr	      ptr init (null);
 10    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
 10    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
 10    24 
 10    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      960 
      961    end rcm_get_by_spec;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/24/88  1400.0  rcm_get_by_spec.pl1               >special_ldd>install>MR12.2-1184>rcm_get_by_spec.pl1
942          1    01/07/85  0859.4  dm_rcm_cursor.incl.pl1            >ldd>include>dm_rcm_cursor.incl.pl1
944          2    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
946          3    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
948          4    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
950          5    04/05/85  0924.4  dm_collmgr_entry_dcls.incl.pl1    >ldd>include>dm_collmgr_entry_dcls.incl.pl1
952          6    03/06/85  1031.5  dm_element_id_list.incl.pl1       >ldd>include>dm_element_id_list.incl.pl1
954          7    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
956          8    11/02/83  1845.0  arg_descriptor.incl.pl1           >ldd>include>arg_descriptor.incl.pl1
958          9    10/24/88  1336.9  std_descriptor_types.incl.pl1     >special_ldd>install>MR12.2-1184>std_descriptor_types.incl.pl1
960         10    10/14/83  1609.1  dm_id_list.incl.pl1               >ldd>include>dm_id_list.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000002 constant        bit(36)                  initial dcl 7-7 set ref 43* 399* 467* 542*
AREA_IS_BIG_ENOUGH              000042 constant        fixed bin(17,0)          initial dcl 134 set ref 77 354 404 674* 731*
AREA_IS_TOO_SMALL               000041 constant        fixed bin(17,0)          initial dcl 134 set ref 361 379 452 638* 659* 713*
BACKWARD_DIRECTION              003456 constant        fixed bin(17,0)          initial dcl 134 ref 343 409
DEFAULT_AND_GROUP_ID_LIST_PTR   000004 constant        pointer                  initial dcl 134 set ref 329*
DEFAULT_NUMBER_OF_FULLY_STRUCTURAL_FIELDS
                                000032 constant        fixed bin(17,0)          initial dcl 134 set ref 329*
DEFAULT_PARTIAL_STRUCTURAL_FIELD
                                000032 constant        fixed bin(17,0)          initial dcl 134 set ref 329*
DEFAULT_RECORD_ID_FIELD_ID      003456 constant        fixed bin(17,0)          initial dcl 134 ref 96 206 281 663 825 835 839 844
                                                                                  913
DOUBLE_WORDS_PER_PAGE                  constant        fixed bin(17,0)          initial dcl 134 ref 104
ELEMENT_ID_LIST_INCREMENT              constant        fixed bin(17,0)          initial dcl 134 ref 708 864
ELEMENT_ID_LIST_VERSION_1       000175 automatic       fixed bin(35,0)          initial dcl 6-28 set ref 6-28* 717 867 873*
FALSE                                  constant        bit(1)                   initial dcl 134 ref 305 328 920
FREE_OLD_TYPED_VECTOR_ARRAY     000002 constant        bit(1)                   initial dcl 134 set ref 634*
GET_CURRENT                            constant        fixed bin(17,0)          initial dcl 134 set ref 314*
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 10-23 ref 829
IS_RELATIVE                     000032 constant        bit(1)                   initial dcl 134 set ref 576*
LIMIT_TO_STOP_INFINITE_LOOPING  000001 constant        fixed bin(35,0)          initial dcl 134 ref 319 399
MYNAME                          000006 constant        varying char(32)         initial dcl 132 set ref 43* 43* 43* 399* 467* 542*
NO_RECORD                              constant        bit(36)                  initial dcl 134 ref 82 84 86 91 95 308 310 319 343
                                                                                  376 382 537 579
RECORD_CURSOR_VERSION_2                constant        fixed bin(17,0)          initial dcl 1-29 ref 290
TRUE                                   constant        bit(1)                   initial dcl 134 ref 201 220 238 256 276 303 323 437
                                                                                  918
TYPED_VECTOR_ARRAY_VERSION_2    000041 constant        fixed bin(35,0)          initial dcl 2-50 set ref 911* 934*
VECTOR_SLOT_INCREMENT           000000 constant        fixed bin(17,0)          initial dcl 134 set ref 634* 906
addr                                                   builtin function         dcl 123 ref 298 484 555
aor_code                        000272 automatic       fixed bin(35,0)          dcl 630 set ref 632* 634* 638 638 641* 643* 647 647
                                                                                  655* 657 657* 661*
aor_p_area_status                      parameter       fixed bin(17,0)          dcl 626 set ref 608 681*
aor_p_field_table_ptr                  parameter       pointer                  dcl 620 set ref 608 643*
aor_p_id_list_ptr                      parameter       pointer                  dcl 622 set ref 608 643*
aor_p_record_id                        parameter       bit(36)                  dcl 625 ref 608 671
aor_p_record_id_field_id               parameter       fixed bin(17,0)          dcl 623 ref 608 663 668
aor_p_record_string_length             parameter       fixed bin(35,0)          dcl 616 set ref 608 643*
aor_p_record_string_ptr                parameter       pointer                  dcl 614 set ref 608 643*
aor_p_typed_vector_array_ptr           parameter       pointer                  dcl 618 set ref 608 634* 651 651 655*
aor_p_work_area_ptr                    parameter       pointer                  dcl 621 set ref 608 634* 643* 655* 666
aor_record_id_ptr               000270 automatic       pointer                  dcl 629 set ref 666* 668 671
aor_vector_ptr                  000266 automatic       pointer                  dcl 628 set ref 634* 643* 655* 668
aori_eil_ptr                    000100 automatic       pointer                  initial dcl 701 set ref 701* 714* 715
aori_p_area_status                     parameter       fixed bin(17,0)          dcl 699 set ref 687 739*
aori_p_eil_ptr                         parameter       pointer                  dcl 693 set ref 687 704 708 715* 717 721 728
aori_p_maximum_number_of_records       parameter       fixed bin(35,0)          dcl 696 ref 687 708
aori_p_number_of_records_accepted      parameter       fixed bin(35,0)          dcl 694 ref 687 704 728
aori_p_record_id                       parameter       bit(36)                  dcl 692 ref 687 728
aori_p_temp_eil_ptr                    parameter       pointer                  dcl 698 set ref 687 711* 719 721 725 726*
aori_slot_idx                   000102 automatic       fixed bin(35,0)          dcl 702 set ref 719* 721 721*
aorir_p_area_status                    parameter       fixed bin(17,0)          dcl 738 ref 736 739
aorr_p_area_status                     parameter       fixed bin(17,0)          dcl 680 ref 678 681
area                            000000 stack reference condition                dcl 128 ref 713
area_status                     000107 automatic       fixed bin(17,0)          initial dcl 77 set ref 77* 349* 354 357* 361 379 404
                                                                                  440*
arg_descriptor                         based           structure                level 1 dcl 8-6 set ref 916
based_bit_36_aligned_ptr        000152 automatic       pointer                  initial dcl 101 set ref 101*
bit_dtype                              constant        fixed bin(17,0)          initial dcl 9-25 ref 919
cleanup                         000160 stack reference condition                dcl 128 ref 312
code                            000110 automatic       fixed bin(35,0)          dcl 78 set ref 287* 329* 334 334* 364* 368 368*
collection_id             5            based           bit(36)                  level 2 dcl 1-15 set ref 527* 542* 576*
collection_manager_$get_by_ci_ptr
                                000042 constant        entry                    external dcl 5-80 ref 527
collection_manager_$get_id      000044 constant        entry                    external dcl 5-86 ref 576
count                           000102 automatic       bit(1)                   initial dcl 72 set ref 72* 201* 432
current_ci_ptr                  000112 automatic       pointer                  initial dcl 79 set ref 79* 301* 314* 389* 479* 479*
cv_p_expected_version                  parameter       fixed bin(35,0)          dcl 464 set ref 460 467 467*
cv_p_received_version                  parameter       fixed bin(35,0)          dcl 463 set ref 460 467 467*
cv_p_structure_name                    parameter       char                     packed unaligned dcl 465 set ref 460 467*
data_format_util_$compare_sequential
                                000010 constant        entry                    external dcl 163 ref 329
data_format_util_$cv_table_to_typed_array
                                000012 constant        entry                    external dcl 166 ref 906
data_format_util_$new_cv_string_to_vector
                                000014 constant        entry                    external dcl 169 ref 643
descriptor_ptr                         based           pointer                  array level 3 dcl 2-21 set ref 926*
dimension                 1            based           structure                array level 2 packed packed unaligned dcl 3-17
dimension_table           6            based           structure                array level 2 dcl 2-21
direction_to_process            000114 automatic       fixed bin(17,0)          dcl 80 set ref 294* 343 389* 394* 409
divide                                                 builtin function         dcl 123 ref 757 790
dm_error_$beginning_of_collection
                                000032 external static fixed bin(35,0)          dcl 182 ref 537 579
dm_error_$end_of_collection     000034 external static fixed bin(35,0)          dcl 182 ref 537 579
dm_error_$long_return_element   000030 external static fixed bin(35,0)          dcl 182 ref 540
dm_error_$programming_error     000040 external static fixed bin(35,0)          dcl 182 set ref 43* 399*
dm_error_$record_not_found      000036 external static fixed bin(35,0)          dcl 182 set ref 404*
dm_vector_util_$append_simple_typed_vector
                                000016 constant        entry                    external dcl 173 ref 634
dm_vector_util_$free_typed_vector
                                000020 constant        entry                    external dcl 175 ref 364 655
eil_number_of_elements          000174 automatic       fixed bin(35,0)          dcl 6-27 set ref 708* 714 714 864* 866 866
element_id                             based           structure                level 1 dcl 4-32 set ref 666 671*
element_id_list                        based           structure                level 1 dcl 6-21 set ref 482 714 725 866
element_id_list_ptr             000172 automatic       pointer                  dcl 6-26 set ref 207* 225* 243* 261* 282* 357* 418*
                                                                                  428 429 711
er_p_code                              parameter       fixed bin(35,0)          dcl 493 ref 490 495
error_table_$area_too_small     000024 external static fixed bin(35,0)          dcl 182 ref 452 638 647
error_table_$unimplemented_version
                                000026 external static fixed bin(35,0)          dcl 182 set ref 467*
extended_arg_type               000176 automatic       fixed bin(17,0)          initial dcl 8-36 set ref 8-36*
field_table_ptr                 000116 automatic       pointer                  initial dcl 81 set ref 81* 203* 222* 226* 240* 258*
                                                                                  263* 278* 329* 349*
file_opening_id           4            based           bit(36)                  level 2 dcl 1-15 set ref 527* 576*
first_record_to_process         000120 automatic       bit(36)                  initial dcl 82 set ref 82* 295* 307
flag                                   based           bit(1)                   level 2 packed packed unaligned dcl 8-6 set ref 918*
flags                     1            based           structure                level 2 dcl 1-15
get                             000100 automatic       bit(1)                   initial dcl 72 set ref 72* 220* 256* 303 349 361 422
get_each_record                 000104 automatic       bit(1)                   initial dcl 74 set ref 74* 303* 305* 314 389
get_id                          000101 automatic       bit(1)                   initial dcl 72 set ref 72* 238* 256* 354 425
gr_code                         000245 automatic       fixed bin(35,0)          dcl 521 set ref 524* 527* 533 537 537 540 540* 542*
gr_new_ci_ptr                   000246 automatic       pointer                  dcl 522 set ref 525* 527* 547 547*
gr_p_ci_ptr                            parameter       pointer                  dcl 506 set ref 501 527* 547 547 547*
gr_p_direction                         parameter       fixed bin(17,0)          dcl 511 set ref 501 527*
gr_p_previous_record_id                parameter       bit(36)                  dcl 507 ref 501 526
gr_p_record_buffer                     based           bit                      dcl 517 ref 555
gr_p_record_buffer_length              parameter       fixed bin(35,0)          dcl 515 set ref 501 527* 555 555 558*
gr_p_record_buffer_ptr                 parameter       pointer                  dcl 514 set ref 501 527* 552 555 555 557*
gr_p_record_id                         parameter       bit(36)                  dcl 509 set ref 501 533* 537* 542*
gr_p_record_string_length              parameter       fixed bin(35,0)          dcl 512 set ref 501 527* 558
gr_p_record_string_ptr                 parameter       pointer                  dcl 510 set ref 501 527* 552 557
gr_record_id                    000244 automatic       bit(36)                  dcl 520 set ref 526* 527* 533
gri_code                        000256 automatic       fixed bin(35,0)          dcl 573 set ref 576* 579 579 579 583*
gri_p_direction                        parameter       fixed bin(17,0)          dcl 571 set ref 565 576*
gri_p_previous_record_id               parameter       bit(36)                  dcl 568 set ref 565 576*
gri_p_record_id                        parameter       bit(36)                  dcl 570 set ref 565 576* 579*
hbound                                                 builtin function         dcl 123 ref 719
highest_accepted_record         000121 automatic       bit(36)                  initial dcl 84 set ref 84* 308* 343 343* 347* 383*
                                                                                  436
id                        2            based           bit(36)                  array level 2 in structure "element_id_list"
                                                                                  dcl 6-21 in procedure "rcm_get_by_spec" set ref
                                                                                  719 721* 721 728* 792 793* 793 799*
id                        2            based           fixed bin(17,0)          array level 2 in structure "id_list" dcl 10-16
                                                                                  in procedure "rcm_get_by_spec" ref 839
id_list                                based           structure                level 1 dcl 10-16
id_list_ptr                     000200 automatic       pointer                  initial dcl 10-21 set ref 205* 224* 226* 242* 260*
                                                                                  263* 280* 349* 10-21*
il_number_of_ids                000202 automatic       fixed bin(17,0)          initial dcl 10-22 set ref 10-22*
last_record_to_process          000122 automatic       bit(36)                  initial dcl 86 set ref 86* 296* 376
local_record_buffer             000154 automatic       fixed bin(71,0)          array dcl 104 set ref 298 299 484 555
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 2-21 ref 364 480 761 763 763 769 923 923
                                                                                  923 926 926 926
maximum_number_of_records       000123 automatic       fixed bin(35,0)          initial dcl 87 set ref 87* 202* 221* 226* 239* 243*
                                                                                  257* 261* 263* 277* 357* 376
min                                                    builtin function         dcl 123 ref 708 864
name                      6            based           varying char             array level 3 dcl 2-21 set ref 923*
null                                                   builtin function         dcl 123 ref 43 43 79 81 94 99 100 101 101 101 101
                                                                                  101 105 107 204 205 207 208 225 245 279 280 282
                                                                                  283 301 399 399 10-21 467 467 480 482 484 525 542
                                                                                  542 547 598 701 726 754 787 822 834 861 902
number_dims               0(08)        based           fixed bin(4,0)           level 2 packed packed unsigned unaligned dcl 8-6 set
                                                                                  ref 921*
number_of_dimensions      1            based           fixed bin(17,0)          level 2 dcl 2-21 ref 364 480 761 763 763 769
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 6-21 set ref 429* 482 704 708 714* 719
                                                                                  725 793 799 866*
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 10-16 ref 831 839 839
number_of_records_accepted      000124 automatic       fixed bin(35,0)          initial dcl 89 set ref 89* 309* 342* 342 357* 376
                                                                                  404 429 432
number_of_vector_slots
                          3            based           fixed bin(17,0)          level 2 dcl 2-21 ref 480
number_of_vectors         2            based           fixed bin(17,0)          level 2 dcl 2-21 set ref 364 370* 370 651* 651 757
                                                                                  763 769 790
old_eil_ptr                     000142 automatic       pointer                  initial dcl 101 set ref 101*
old_tva_ptr                     000144 automatic       pointer                  initial dcl 101 set ref 101*
p_code                                 parameter       fixed bin(35,0)          dcl 68 set ref 195 213 231 249 270 287* 452* 454*
                                                                                  495*
p_direction_to_process                 parameter       fixed bin(17,0)          dcl 57 ref 195 213 231 249 270 294
p_element_id_list_ptr                  parameter       pointer                  dcl 53 set ref 231 243* 249 261* 428*
p_field_table_ptr                      parameter       pointer                  dcl 51 ref 195 203 213 222 231 240 249 258 270 278
p_first_record_to_process              parameter       bit(36)                  dcl 58 ref 195 213 231 249 270 295
p_id_list_ptr                          parameter       pointer                  dcl 52 set ref 213 224* 242* 260*
p_last_record_to_process               parameter       bit(36)                  dcl 60 ref 195 213 231 249 270 296
p_maximum_number_of_records            parameter       fixed bin(35,0)          dcl 64 ref 195 202 213 221 231 239 249 257 270 277
p_number_of_records_accepted           parameter       fixed bin(35,0)          dcl 66 set ref 195 432*
p_record_cursor_ptr                    parameter       pointer                  dcl 49 ref 195 213 231 249 270 289
p_spec_is_always_satisfied             parameter       bit(1)                   dcl 62 ref 195 213 231 249 270 293
p_specification_ptr                    parameter       pointer                  dcl 54 ref 195 213 231 249 270 292
p_typed_vector_array_ptr               parameter       pointer                  dcl 55 set ref 213 226* 249 263* 422*
p_work_area_ptr                        parameter       pointer                  dcl 50 ref 213 223 231 241 249 259
packed                    0(07)        based           bit(1)                   level 2 packed packed unaligned dcl 8-6 set ref 920*
position                        000103 automatic       bit(1)                   initial dcl 72 set ref 72* 276*
position_is_valid         1            based           bit(1)                   level 3 packed packed unaligned dcl 1-15 set ref
                                                                                  437*
previous_record_id              000125 automatic       bit(36)                  initial dcl 91 set ref 91* 310* 383 388* 389* 394*
r_p_area_status                        parameter       fixed bin(17,0)          dcl 448 ref 446 452
rcp_p_ci_ptr                           parameter       pointer                  dcl 595 set ref 589 598 602*
rcp_p_new_ci_ptr                       parameter       pointer                  dcl 596 ref 589 602
record_buffer                          based           bit                      dcl 118 ref 484
record_buffer_length            000127 automatic       fixed bin(35,0)          initial dcl 93 set ref 93* 299* 314* 389* 484 484
record_buffer_ptr               000130 automatic       pointer                  initial dcl 94 set ref 94* 298* 314* 389* 484 484
                                                                                  484
record_count                    000126 automatic       fixed bin(35,0)          initial dcl 92 set ref 92* 319* 399
record_cursor                          based           structure                level 1 dcl 1-15
record_cursor_ptr               000166 automatic       pointer                  dcl 1-28 set ref 289* 290 436 437 527 527 542 576
                                                                                  576
record_id                 6            based           bit(36)                  level 2 in structure "record_cursor" dcl 1-15
                                                                                  in procedure "rcm_get_by_spec" set ref 436*
record_id                       000132 automatic       bit(36)                  initial dcl 95 in procedure "rcm_get_by_spec" set
                                                                                  ref 95* 307* 314* 314* 319 343 347 349* 357* 376
                                                                                  376* 382* 388 389* 394*
record_id_field_id              000133 automatic       fixed bin(17,0)          initial dcl 96 set ref 96* 206* 224* 226* 242* 260*
                                                                                  263* 281* 349*
record_satisfies_spec           000105 automatic       bit(1)                   initial dcl 74 set ref 74* 323* 328* 329* 338
record_string                          based           bit                      packed unaligned dcl 115 set ref 329*
record_string_length            000134 automatic       fixed bin(35,0)          initial dcl 98 set ref 98* 314* 329 329 349* 389*
record_string_ptr               000136 automatic       pointer                  initial dcl 99 set ref 99* 314* 329 349* 389*
rrio_id                         000325 automatic       bit(36)                  dcl 785 set ref 792* 799
rrio_p_eil_ptr                         parameter       pointer                  dcl 783 ref 780 787 792 793 793 793 799 799
rrio_slot_idx                   000324 automatic       fixed bin(17,0)          dcl 784 set ref 790* 792 793 793 799*
rro_p_tva_ptr                          parameter       pointer                  dcl 749 ref 746 754 757 761 763 763 763 769 769
rro_slot_idx                    000310 automatic       fixed bin(17,0)          dcl 751 set ref 757* 761 763 763 769*
rro_vector_ptr                  000312 automatic       pointer                  dcl 752 set ref 761* 769
sil_p_input_id_list_ptr                parameter       pointer                  dcl 814 ref 810 821
sil_p_output_id_list_ptr               parameter       pointer                  dcl 816 set ref 810 821* 822 829 831 834* 839 839
                                                                                  839
sil_p_record_id_field_id               parameter       fixed bin(17,0)          dcl 818 set ref 810 825* 835* 839* 844*
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 3-17
size                      0(12)        based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 8-6 set
                                                                                  ref 922*
soi_p_input_eil_ptr                    parameter       pointer                  dcl 856 ref 852 861 872
soi_p_maximum_number_of_ids            parameter       fixed bin(35,0)          dcl 857 ref 852 864
soi_p_output_eil_ptr                   parameter       pointer                  dcl 859 set ref 852 866* 867 872* 873
sor_code                        000354 automatic       fixed bin(35,0)          dcl 900 set ref 905* 906* 909 909*
sor_p_field_table_ptr                  parameter       pointer                  dcl 891 set ref 881 906*
sor_p_id_list_ptr                      parameter       pointer                  dcl 892 set ref 881 906*
sor_p_input_tva_ptr                    parameter       pointer                  dcl 886 ref 881 902 933
sor_p_maximum_number_of_records        parameter       fixed bin(35,0)          dcl 887 ref 881
sor_p_output_tva_ptr                   parameter       pointer                  dcl 894 set ref 881 906* 911 923 926 933* 934
sor_p_record_id_field_id               parameter       fixed bin(17,0)          dcl 889 ref 881 913 923 926
sor_p_work_area                        based           area(1024)               dcl 896 ref 916
sor_p_work_area_ptr                    parameter       pointer                  dcl 893 set ref 881 906* 916
sor_record_id_descriptor_ptr    000352 automatic       pointer                  dcl 898 set ref 916* 918 919 920 921 922 926
spec_is_always_satisfied        000106 automatic       bit(1)                   initial dcl 74 set ref 74* 293* 303 323
specification_ptr               000140 automatic       pointer                  initial dcl 100 set ref 100* 292* 329*
sub_err_                        000022 constant        entry                    external dcl 178 ref 43 399 467 542
temp_element_id_list_ptr        000154 automatic       pointer                  initial dcl 105 set ref 105* 357* 482 482
temp_typed_vector_array_ptr     000156 automatic       pointer                  initial dcl 107 set ref 107* 480 480
type                      0(01)        based           fixed bin(6,0)           level 2 packed packed unsigned unaligned dcl 8-6 set
                                                                                  ref 919*
typed_vector_array                     based           structure                level 1 dcl 2-21 set ref 480
typed_vector_array_ptr          000170 automatic       pointer                  dcl 2-43 set ref 208* 226* 245* 263* 283* 349* 364*
                                                                                  364 364 370 370 417* 422 790
unspec                                                 builtin function         dcl 123 set ref 299 671*
value_ptr                 1            based           pointer                  array level 3 packed packed unaligned dcl 3-17 set
                                                                                  ref 668*
vector_ptr                      000146 automatic       pointer                  initial dcl 101 set ref 101*
vector_slot                            based           pointer                  array level 2 dcl 2-21 set ref 364* 761 763* 763
                                                                                  769*
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 10-16
                                                                                  in procedure "rcm_get_by_spec" set ref 829*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "record_cursor" packed packed
                                                                                  unaligned dcl 1-15 in procedure "rcm_get_by_spec"
                                                                                  ref 290
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 2-21
                                                                                  in procedure "rcm_get_by_spec" set ref 911* 934*
version                                based           fixed bin(35,0)          level 2 in structure "element_id_list" dcl 6-21
                                                                                  in procedure "rcm_get_by_spec" set ref 717* 867*
                                                                                  873*
work_area                              based           area(1024)               dcl 117 ref 666 714 866
work_area_ptr                   000150 automatic       pointer                  initial dcl 101 set ref 101* 204* 223* 226* 241*
                                                                                  259* 263* 279* 349* 364* 527* 714 866

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 7-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 7-7
BEGINNING_OF_COLLECTION_RECORD_ID      internal static bit(36)                  initial dcl 1-32
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 3-43
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 3-43
RECORD_CURSOR_TYPE                     internal static fixed bin(17,0)          initial dcl 1-31
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 3-43
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 9-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 9-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 9-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 9-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 9-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 9-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 9-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 9-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 9-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 9-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 9-25
arg_descriptor_ptr                     automatic       pointer                  dcl 8-34
based_bit_36_aligned                   based           bit(36)                  dcl 112
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 9-25
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 9-25
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 9-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 9-25
char_dtype                             internal static fixed bin(17,0)          initial dcl 9-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 9-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 9-25
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 5-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 5-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 5-54
collection_manager_$create_file 000000 constant        entry                    external dcl 5-56
collection_manager_$delete      000000 constant        entry                    external dcl 5-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 5-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 5-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 5-60
collection_manager_$get         000000 constant        entry                    external dcl 5-71
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 5-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 5-77
collection_manager_$get_header  000000 constant        entry                    external dcl 5-83
collection_manager_$get_portion 000000 constant        entry                    external dcl 5-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 5-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 5-93
collection_manager_$modify      000000 constant        entry                    external dcl 5-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 5-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 5-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 5-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 5-113
collection_manager_$put         000000 constant        entry                    external dcl 5-115
collection_manager_$put_header  000000 constant        entry                    external dcl 5-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 5-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 5-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 5-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 5-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 5-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 5-135
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 9-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
element_id_string                      automatic       bit(36)                  dcl 4-30
entry_dtype                            internal static fixed bin(17,0)          initial dcl 9-25
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 9-125
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 9-125
extended_arg_descriptor                based           structure                level 1 dcl 8-21
file_dtype                             internal static fixed bin(17,0)          initial dcl 9-25
fixed_arg_descriptor                   based           structure                level 1 dcl 8-13
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 9-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 9-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 9-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 9-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 9-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 9-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 9-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 9-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 9-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 9-96
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 9-96
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 9-96
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 3-24
general_typed_vector_ptr               automatic       pointer                  dcl 3-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 3-40
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 9-125
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 9-125
label_dtype                            internal static fixed bin(17,0)          initial dcl 9-25
offset_dtype                           internal static fixed bin(17,0)          initial dcl 9-25
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 9-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 9-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 9-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 9-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 9-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 9-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 9-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 9-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 9-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 9-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 9-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 9-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 9-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 9-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 9-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 9-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 9-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 9-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 9-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 9-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 9-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 9-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 9-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 9-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 9-125
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 9-25
real_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 9-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 9-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
simple_typed_vector_ptr                automatic       pointer                  dcl 3-33
structure_dtype                        internal static fixed bin(17,0)          initial dcl 9-25
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 3-35
tva_maximum_dimension_name_length      automatic       fixed bin(17,0)          dcl 2-48
tva_number_of_dimensions               automatic       fixed bin(17,0)          dcl 2-46
tva_number_of_vector_slots             automatic       fixed bin(17,0)          dcl 2-44
varying_bit_dtype                      internal static fixed bin(17,0)          initial dcl 9-25
varying_char_dtype                     internal static fixed bin(17,0)          initial dcl 9-25

NAMES DECLARED BY EXPLICIT CONTEXT.
ACCEPT_THIS_RECORD              001137 constant        label                    dcl 338
AORI_MAIN_RETURN                002535 constant        label                    dcl 733 ref 741
AORI_RETURN                     002537 constant        entry                    internal dcl 736 ref 713 731
AOR_MAIN_RETURN                 002354 constant        label                    dcl 675 ref 682
AOR_RETURN                      002355 constant        entry                    internal dcl 678 ref 638 659 674
APPEND_OUTPUT_RECORD            002171 constant        entry                    internal dcl 608 ref 349
APPEND_OUTPUT_RECORD_ID         002364 constant        entry                    internal dcl 687 ref 357
CHECK_VERSION                   001455 constant        entry                    internal dcl 460 ref 290 829 873 911 934
COMPARE                         001062 constant        label                    dcl 325
ERROR_RETURN                    001656 constant        entry                    internal dcl 490 ref 334 368 404 540 583 641 657 661
                                                                                  909
FINISH                          001552 constant        entry                    internal dcl 476 ref 312 450 496
GET_NEXT                        001276 constant        label                    dcl 385
GET_RECORD                      001667 constant        entry                    internal dcl 501 ref 314 389
GET_RECORD_ID                   002106 constant        entry                    internal dcl 565 ref 394
JOIN                            000726 constant        label                    dcl 287 ref 210 229 247 267 285
MAIN_RETURN                     001434 constant        label                    dcl 442 ref 456 497
RECORD_LOOP                     001043 constant        label                    dcl 319
RESET_CI_PTR                    002153 constant        entry                    internal dcl 589 ref 479 547
RETURN                          001435 constant        entry                    internal dcl 446 ref 440
REVERSE_RECORD_ID_ORDER         002660 constant        entry                    internal dcl 780 ref 418
REVERSE_RECORD_ORDER            002554 constant        entry                    internal dcl 746 ref 417
SETUP_ID_LIST                   002720 constant        entry                    internal dcl 810 ref 224 242 260
SETUP_OUTPUT_IDS                003002 constant        entry                    internal dcl 852 ref 243 261
SETUP_OUTPUT_RECORDS            003061 constant        entry                    internal dcl 881 ref 226 263
count                           000352 constant        entry                    external dcl 195
get                             000415 constant        entry                    external dcl 213
get_id                          000511 constant        entry                    external dcl 231
get_records_and_ids             000567 constant        entry                    external dcl 249
position                        000674 constant        entry                    external dcl 270
rcm_get_by_spec                 000263 constant        entry                    external dcl 40

NAME DECLARED BY CONTEXT OR IMPLICATION.
length                                                 builtin function         ref 299

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4022        4070    3460        4032
Length      4540    3460        46         433     341           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rcm_get_by_spec                     553 external procedure  is an external procedure.  
on unit on line 312                  64 on unit               
RETURN                                  internal procedure  shares stack frame of external procedure rcm_get_by_spec.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rcm_get_by_spec.  
FINISH                               76 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure rcm_get_by_spec.  
GET_RECORD                              internal procedure  shares stack frame of external procedure rcm_get_by_spec.  
GET_RECORD_ID                           internal procedure  shares stack frame of external procedure rcm_get_by_spec.  
RESET_CI_PTR                         64 internal procedure  is called by several nonquick procedures.  
APPEND_OUTPUT_RECORD                    internal procedure  shares stack frame of external procedure rcm_get_by_spec.  
AOR_RETURN                              internal procedure  shares stack frame of external procedure rcm_get_by_spec.  
APPEND_OUTPUT_RECORD_ID              84 internal procedure  enables or reverts conditions.  
on unit on line 713                  70 on unit               
AORI_RETURN                          64 internal procedure  is called by several nonquick procedures.  
REVERSE_RECORD_ORDER                    internal procedure  shares stack frame of external procedure rcm_get_by_spec.  
REVERSE_RECORD_ID_ORDER                 internal procedure  shares stack frame of external procedure rcm_get_by_spec.  
SETUP_ID_LIST                           internal procedure  shares stack frame of external procedure rcm_get_by_spec.  
SETUP_OUTPUT_IDS                        internal procedure  shares stack frame of external procedure rcm_get_by_spec.  
SETUP_OUTPUT_RECORDS                    internal procedure  shares stack frame of external procedure rcm_get_by_spec.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
APPEND_OUTPUT_RECORD_ID  000100 aori_eil_ptr                APPEND_OUTPUT_RECORD_ID
                         000102 aori_slot_idx               APPEND_OUTPUT_RECORD_ID
rcm_get_by_spec          000100 get                         rcm_get_by_spec
                         000101 get_id                      rcm_get_by_spec
                         000102 count                       rcm_get_by_spec
                         000103 position                    rcm_get_by_spec
                         000104 get_each_record             rcm_get_by_spec
                         000105 record_satisfies_spec       rcm_get_by_spec
                         000106 spec_is_always_satisfied    rcm_get_by_spec
                         000107 area_status                 rcm_get_by_spec
                         000110 code                        rcm_get_by_spec
                         000112 current_ci_ptr              rcm_get_by_spec
                         000114 direction_to_process        rcm_get_by_spec
                         000116 field_table_ptr             rcm_get_by_spec
                         000120 first_record_to_process     rcm_get_by_spec
                         000121 highest_accepted_record     rcm_get_by_spec
                         000122 last_record_to_process      rcm_get_by_spec
                         000123 maximum_number_of_records   rcm_get_by_spec
                         000124 number_of_records_accepted  rcm_get_by_spec
                         000125 previous_record_id          rcm_get_by_spec
                         000126 record_count                rcm_get_by_spec
                         000127 record_buffer_length        rcm_get_by_spec
                         000130 record_buffer_ptr           rcm_get_by_spec
                         000132 record_id                   rcm_get_by_spec
                         000133 record_id_field_id          rcm_get_by_spec
                         000134 record_string_length        rcm_get_by_spec
                         000136 record_string_ptr           rcm_get_by_spec
                         000140 specification_ptr           rcm_get_by_spec
                         000142 old_eil_ptr                 rcm_get_by_spec
                         000144 old_tva_ptr                 rcm_get_by_spec
                         000146 vector_ptr                  rcm_get_by_spec
                         000150 work_area_ptr               rcm_get_by_spec
                         000152 based_bit_36_aligned_ptr    rcm_get_by_spec
                         000154 local_record_buffer         rcm_get_by_spec
                         000154 temp_element_id_list_ptr    rcm_get_by_spec
                         000156 temp_typed_vector_array_ptr rcm_get_by_spec
                         000166 record_cursor_ptr           rcm_get_by_spec
                         000170 typed_vector_array_ptr      rcm_get_by_spec
                         000172 element_id_list_ptr         rcm_get_by_spec
                         000174 eil_number_of_elements      rcm_get_by_spec
                         000175 ELEMENT_ID_LIST_VERSION_1   rcm_get_by_spec
                         000176 extended_arg_type           rcm_get_by_spec
                         000200 id_list_ptr                 rcm_get_by_spec
                         000202 il_number_of_ids            rcm_get_by_spec
                         000244 gr_record_id                GET_RECORD
                         000245 gr_code                     GET_RECORD
                         000246 gr_new_ci_ptr               GET_RECORD
                         000256 gri_code                    GET_RECORD_ID
                         000266 aor_vector_ptr              APPEND_OUTPUT_RECORD
                         000270 aor_record_id_ptr           APPEND_OUTPUT_RECORD
                         000272 aor_code                    APPEND_OUTPUT_RECORD
                         000310 rro_slot_idx                REVERSE_RECORD_ORDER
                         000312 rro_vector_ptr              REVERSE_RECORD_ORDER
                         000324 rrio_slot_idx               REVERSE_RECORD_ID_ORDER
                         000325 rrio_id                     REVERSE_RECORD_ID_ORDER
                         000352 sor_record_id_descriptor_ptr
                                                            SETUP_OUTPUT_RECORDS
                         000354 sor_code                    SETUP_OUTPUT_RECORDS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          tra_ext_1
alloc_auto_adj      enable_op           ext_entry           int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get_by_ci_ptr                           collection_manager_$get_id
data_format_util_$compare_sequential                        data_format_util_$cv_table_to_typed_array
data_format_util_$new_cv_string_to_vector                   dm_vector_util_$append_simple_typed_vector
dm_vector_util_$free_typed_vector                           sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$beginning_of_collection                           dm_error_$end_of_collection   dm_error_$long_return_element
dm_error_$programming_error   dm_error_$record_not_found    error_table_$area_too_small
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     72 000173        74 000177        77 000202        79 000204        81 000206        82 000207        84 000210
     86 000211        87 000212        89 000214        91 000215        92 000216        93 000217        94 000220
     95 000222        96 000223        98 000225        99 000227       100 000231       101 000232       104 000237
    105 000245       107 000247    6   28 000250    8   36 000252   10   21 000254   10   22 000256        40 000262
     43 000271       195 000341       201 000363       202 000365       203 000370       204 000373       205 000375
    206 000376       207 000400       208 000402       210 000403       213 000404       220 000426       221 000430
    222 000433       223 000436       224 000441       225 000453       226 000455       229 000500       231 000501
    238 000522       239 000524       240 000527       241 000532       242 000535       243 000547       245 000562
    247 000564       249 000565       256 000600       257 000603       258 000606       259 000611       260 000614
    261 000626       263 000641       267 000664       270 000665       276 000705       277 000707       278 000712
    279 000715       280 000717       281 000720       282 000722       283 000724       285 000725       287 000726
    289 000730       290 000734       292 000753       293 000757       294 000762       295 000764       296 000766
    298 000770       299 000772       301 000776       303 001000       305 001007       307 001010       308 001012
    309 001013       310 001014       312 001015       314 001037       319 001043       323 001055       328 001062
    329 001063       334 001130       338 001134       342 001137       343 001143       346 001152       347 001153
    349 001155       354 001161       357 001166       361 001206       364 001213       368 001250       370 001254
    376 001257       379 001267       382 001272       383 001273       384 001275       388 001276       389 001277
    394 001304       397 001306       399 001313       404 001360       409 001374       417 001377       418 001401
    422 001403       425 001410       428 001412       429 001415       432 001417       436 001425       437 001430
    440 001432       442 001434       446 001435       450 001437       452 001443       454 001453       456 001454
    460 001455       467 001466       474 001550       476 001551       479 001557       480 001570       482 001621
    484 001634       488 001655       490 001656       495 001660       496 001662       497 001666       501 001667
    524 001671       525 001672       526 001674       527 001676       533 001741       537 001747       540 001757
    542 001764       547 002036       552 002057       555 002064       557 002077       558 002103       561 002105
    565 002106       576 002110       579 002135       583 002147       585 002151       589 002152       598 002160
    602 002165       604 002170       608 002171       632 002173       634 002174       638 002230       641 002240
    643 002242       647 002266       651 002273       655 002300       657 002314       659 002320       660 002322
    661 002323       663 002325       666 002331       668 002340       671 002347       674 002352       675 002354
    678 002355       681 002357       682 002362       687 002363       701 002371       704 002373       708 002401
    711 002414       713 002416       714 002442       715 002455       717 002457       719 002462       721 002473
    723 002502       725 002507       726 002517       728 002522       731 002527       733 002535       736 002536
    739 002544       741 002551       746 002554       754 002556       757 002563       761 002575       763 002621
    769 002631       774 002655       776 002657       780 002660       787 002662       790 002667       792 002701
    793 002706       799 002713       804 002715       806 002717       810 002720       821 002722       822 002725
    825 002731       826 002733       829 002734       831 002757       834 002764       835 002766       836 002770
    839 002771       844 002777       848 003001       852 003002       861 003004       864 003010       866 003015
    867 003027       869 003031       872 003032       873 003035       877 003060       881 003061       902 003063
    905 003067       906 003070       909 003114       911 003120       913 003144       916 003150       918 003157
    919 003161       920 003165       921 003167       922 003173       923 003175       926 003230       930 003240
    933 003241       934 003244       938 003266


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
