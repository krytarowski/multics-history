	COMPILATION LISTING OF SEGMENT delete_
	Compiled by: Multics PL/I Compiler, Release 33d, of April 24, 1992
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 92-10-06_0057.46_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(90-07-30,Bubric), approve(90-07-30,MCR8185), audit(90-09-12,Vu),
       13*     install(90-09-20,MR12.4-1026):
       14*     Fix delete_$path to handle extended objects which are directories.
       15*  2) change(92-09-24,Vu), approve(92-09-24,MCR8266), audit(92-09-24,Zimmerman),
       16*     install(92-10-06,MR12.5-1025):
       17*     Fixed dl command for deleting forum.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: style2,idind30,indcomtxt */
       22 
       23 delete_$path:
       24      procedure (dirname, entryname, a_switches, caller, code);
       25 
       26 /* The delete_ subroutine takes care of deleting branches and unlinking links.  It
       27*   can ask questions if access is incorrect to the segment, and attempt to force delete access.
       28*
       29*   The path entry is called with the pathname of the thing to be deleted or unlinked.
       30*   The switches argument tells delete_ what it is to do:
       31*
       32*   1. force_sw      If ON, delete_ attempts to delete protected
       33*   .                as well as unprotected entries.
       34*   2. question_sw   If ON and force_sw is OFF, delete_ queries the user
       35*   .                about deleting protected entries. If force_sw is ON
       36*   .                and ename refers to a directory, delete_ prints a
       37*   .                message for each entry under that directory that
       38*   .                cannot be deleted.
       39*   3. directory_sw  A directory can be deleted only if ON.
       40*   4. segment_sw    A segment can be deleted only if ON.
       41*   5. link_sw       A link can be unlinked only if ON.
       42*   6. chase_sw      If ON, delete_ deletes through links.
       43*   7. lib_sw        If ON, calls through installation_tools_.
       44*   8. raw_sw        If ON, delete_$path calls hcs_ and not object_type_.
       45*
       46*   Initially coded April 1972 by Dan Bricklin.
       47*   Modified on November 1972 by E. Stone for new directory control
       48*   Modified on Jan 1974 by E. Stone to reflect that error_table_$moderr not returned from delentry
       49*   Modified on May 15, 1974 by Kobziar to delete initiate acl if seg not deleted.
       50*   Modified on Oct 1, 1974 by J. Whitmore to attempt to delete a directory before calling del_dir_tree also
       51*   to correct a bad error code if the ptr entry is called with a null pointer.
       52*   Modified on 8/27/75 to prevent infinite delete_again, etc. loops.
       53*   Modified April 1976 by Larry Johnson for master directories.
       54*   Modified Oct 4, 1979 by M. Pierret to skip unnecessary calls to term_$nomakeunknown.
       55*   Modified to work on mailboxes and queues 03/28/80 S. Herbst
       56*   Modified 30 June 1980 by G. Palter to make delete_$path not loop on inner ring segments and make delete_$ptr work again
       57*   Modified 21 October 1980 by G. Palter to not loop on inner ring segments with names shorter than 4 characters
       58*   Modified 01/17/83 by S. Herbst to recognize et_$action_not_performed fom dl_handler_
       59*   Modified 1/26/83 Jay Pattin for object_type_, added raw_sw
       60*   Modified 3/15/83 Jay Pattin to terminate segments when user answers no to "delete?" query
       61*   Modified 830927 BIM for object_type_ --> fs_util_.
       62*   Modified 831022 BIM to fix bug in descriptor checking for bit (6).
       63*   Modified 831027 BIM to never terminate until after checking safety switch.
       64*   Modified 840626 to suppress ssw/copysw query when force-deleting dir.
       65*   Modified 841119 MAP to generate all abs pathnames by using pathname_.
       66*   Modified 841203 Matthew Pierret: to not delete a directory which contains
       67*   a protected data management file if a transaction is in
       68*   progress.  This is because deletion of dm files is delayed
       69*   until the transaction commits.
       70*   Modified 850124 Steve Herbst to call hcs_$get_segment_ptr_path rather
       71*	than initiate a segment.
       72*   Modified 850206 Keith Loepere for correct error code $moderr instead of
       73*	$incorrect_access from hcs_$star_.
       74**/
       75 
       76 	dcl     a_switches		        bit (36) aligned;
       77 	dcl     all		        fixed bin (2) init (3);
       78 	dcl     bitcount		        fixed bin (24);
       79 	dcl     caller		        char (*);
       80 	dcl     code		        fixed bin (35);
       81 	dcl     com_err_		        entry options (variable);
       82 	dcl     delete_$path	        entry (char (*), char (*), bit (36) aligned, char (*), fixed bin (35));
       83 	dcl     directory_contents_code       fixed bin (35);
       84 	dcl     dirname		        char (*);
       85 	dcl     dl_handler_$switches	        entry (char (*), char (*), char (*), bit (36) aligned, fixed bin (35));
       86 	dcl     dname		        char (168);
       87 	dcl     ecount		        fixed bin;
       88 	dcl     ename		        char (32);
       89 	dcl     entryname		        char (*);
       90 	dcl     eptr		        pointer;
       91 	dcl     etype		        bit (2);
       92 	dcl     fs_util_type	        char (32);
       93 	dcl     get_group_id_$tag_star        entry returns (char (32) aligned);
       94 	dcl     get_system_free_area_	        entry returns (ptr);
       95 	dcl     path_entry		        bit (1);
       96 	dcl     fs_util_$get_type	        entry (character (*), character (*), character (*), fixed binary (35));
       97 	dcl     fs_util_$delentry_file        entry (character (*), character (*), fixed binary (35));
       98 
       99 	dcl     hcs_$add_dir_acl_entries      entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
      100 	dcl     hcs_$delentry_file	        entry (char (*), char (*), fixed bin (35));
      101 	dcl     hcs_$fs_get_path_name	        entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
      102 	dcl     hcs_$get_link_target	        entry (char (*), char (*), char (*), char (*), fixed bin (35));
      103 	dcl     hcs_$get_safety_sw_seg        entry (pointer, bit (1) aligned, fixed bin (35));
      104 	dcl     hcs_$get_segment_ptr_path     entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
      105 	dcl     hcs_$lv_attached	        entry (bit (36) aligned, fixed bin (35));
      106 	dcl     hcs_$star_		        entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr,
      107 				        fixed bin (35));
      108 	dcl     hcs_$status_minf	        entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24),
      109 				        fixed bin (35));
      110 	dcl     hcs_$status_long	        entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
      111 	dcl     installation_tools_$delentry_file
      112 				        entry (char (*), char (*), fixed bin (35));
      113 	dcl     i			        fixed bin;
      114 	dcl     init_acl_sw		        bit (1) aligned init ("0"b);
      115 	dcl     mdc_$delete_dir	        entry (char (*), char (*), fixed bin (35));
      116 	dcl     name		        char (32);
      117 	dcl     nptr		        pointer;
      118 	dcl     operation		        char (6);
      119 	dcl     pathname_		        entry (char (*), char (*)) returns (char (168));
      120 	dcl     pname		        char (168);
      121 	dcl     safety_switch	        bit (1) aligned;
      122 	dcl     segp		        ptr;
      123 	dcl     segptr		        ptr;
      124 	dcl     term_$seg_ptr	        entry (pointer, fixed binary (35));
      125 	dcl     type		        fixed bin (2);
      126 
      127 	dcl     error_table_$action_not_performed
      128 				        ext fixed bin (35);
      129 	dcl     error_table_$copy_sw_on       ext fixed bin (35);
      130 	dcl     dm_error_$delete_pending_transaction
      131 				        ext fixed bin (35);
      132 	dcl     error_table_$dirseg	        ext fixed bin (35);
      133 	dcl     error_table_$fulldir	        ext fixed bin (35);
      134 	dcl     error_table_$incorrect_access ext fixed bin (35);
      135 	dcl     error_table_$invalidsegno     ext fixed bin (35);
      136 	dcl     error_table_$master_dir       ext fixed bin (35);
      137 	dcl     error_table_$moderr	        ext fixed bin (35);
      138 	dcl     dm_error_$no_delete_dir_transaction
      139 				        ext fixed bin (35);
      140 	dcl     error_table_$nondirseg        ext fixed bin (35);
      141 	dcl     error_table_$not_a_branch     ext fixed bin (35);
      142 	dcl     error_table_$safety_sw_on     ext fixed bin (35);
      143 
      144 
      145 	dcl     (addr, fixed, null, rtrim, string, substr)
      146 				        builtin;
      147 
      148 
      149 	dcl     1 dir_acl		        aligned,
      150 		2 userid		        char (32),
      151 		2 mode		        bit (36),
      152 		2 status		        fixed bin (35);
      153 
      154 	dcl     1 entries		        (ecount) aligned based (eptr),
      155 		2 type		        bit (2) unaligned,
      156 		2 nnames		        bit (16) unaligned,
      157 		2 nindex		        bit (18) unaligned;
      158 
      159 	dcl     names		        (1000) char (32) aligned based (nptr);
      160 
      161 
      162 	dcl     1 lbranch		        aligned,	/* structure returned by status_long */
      163 		2 type		        bit (2) unaligned,
      164 		2 nnames		        fixed bin (15) unaligned,
      165 		2 nrp		        bit (18) unaligned,
      166 		2 dtm		        bit (36),
      167 		2 dtu		        bit (36),
      168 		2 mode		        bit (5) unaligned,
      169 		2 raw_mode	        bit (5) unaligned,
      170 						/* raw mode from acl entry */
      171 		2 pad1		        bit (8) unaligned,
      172 		2 records		        fixed bin (17) unaligned,
      173 		2 dtd		        bit (36),	/* date time segment and branch dumped */
      174 		2 dtem		        bit (36),	/* date time branch modified */
      175 		2 lvid		        bit (36),	/* logical volume id (sons_lvid for dirs) */
      176 		2 curlen		        fixed bin (11) unaligned,
      177 						/* highest 1024-word block used */
      178 		2 bitcnt		        bit (24) unaligned,
      179 						/* bit count */
      180 		2 did		        bit (4) unaligned,
      181 		2 mdid		        bit (4) unaligned,
      182 		2 copysw		        bit (1) unaligned,
      183 		2 tpd		        bit (1) unaligned,
      184 		2 pad3		        bit (8) unaligned,
      185 		2 rbs		        (0:2) fixed bin (5) unaligned,
      186 		2 uid		        bit (36);
      187 
  1     1 /* BEGIN INCLUDE FILE:  delete_options.incl.pl1 */
  1     2 
  1     3 /* control flag bit string passed to delete_$path and delete_$ptr
  1     4*
  1     5*   Jay Pattin 6/6/83 */
  1     6 
  1     7 declare   1 delete_options,
  1     8           2 force                       bit (1) unaligned,  /* ON = delete w/o asking is safety switch on */
  1     9           2 question                    bit (1) unaligned,  /* ON = ask user if safety switch on */
  1    10           2 directory                   bit (1) unaligned,  /* ON = delete directories */
  1    11           2 segment                     bit (1) unaligned,  /* ON = delete segments */
  1    12           2 link                        bit (1) unaligned,  /* ON = delete links */
  1    13           2 chase                       bit (1) unaligned,  /* ON = delete through links */
  1    14           2 library                     bit (1) unaligned,  /* ON = use installation_tools_ */
  1    15           2 raw                         bit (1) unaligned,  /* ON = use hcs_, not object_type_ */
  1    16           2 mbz                         bit (28) unaligned;
  1    17 
  1    18 /* END INCLUDE FILE:  delete_options.incl.pl1 */
      188 
  2     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  2     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  2     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  2     8*     Objects of this type are PASCAL string types.
  2     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  2    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  2    11*     Added the new C types.
  2    12*                                                   END HISTORY COMMENTS */
  2    13 
  2    14 /* This include file defines mnemonic names for the Multics
  2    15*   standard descriptor types, using both pl1 and cobol terminology.
  2    16*   PG 780613
  2    17*   JRD 790530
  2    18*   JRD 791016
  2    19*   MBW 810731
  2    20*   TGO 830614 Add hex types.
  2    21*   Modified June 83 JMAthane to add PASCAL data types
  2    22*   TGO 840120 Add float dec extended and generic, float binary generic
  2    23**/
  2    24 
  2    25      dcl	   (real_fix_bin_1_dtype  init (1),
  2    26 	   real_fix_bin_2_dtype   init (2),
  2    27 	   real_flt_bin_1_dtype   init (3),
  2    28 	   real_flt_bin_2_dtype   init (4),
  2    29 	   cplx_fix_bin_1_dtype   init (5),
  2    30 	   cplx_fix_bin_2_dtype   init (6),
  2    31 	   cplx_flt_bin_1_dtype   init (7),
  2    32 	   cplx_flt_bin_2_dtype   init (8),
  2    33 	   real_fix_dec_9bit_ls_dtype init (9),
  2    34 	   real_flt_dec_9bit_dtype init (10),
  2    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  2    36 	   cplx_flt_dec_9bit_dtype init (12),
  2    37 	   pointer_dtype	      init (13),
  2    38 	   offset_dtype	      init (14),
  2    39 	   label_dtype	      init (15),
  2    40 	   entry_dtype	      init (16),
  2    41 	   structure_dtype	      init (17),
  2    42 	   area_dtype	      init (18),
  2    43 	   bit_dtype	      init (19),
  2    44 	   varying_bit_dtype      init (20),
  2    45 	   char_dtype	      init (21),
  2    46 	   varying_char_dtype     init (22),
  2    47 	   file_dtype	      init (23),
  2    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  2    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  2    50 	   real_fix_bin_1_uns_dtype init (33),
  2    51 	   real_fix_bin_2_uns_dtype init (34),
  2    52 	   real_fix_dec_9bit_uns_dtype init (35),
  2    53 	   real_fix_dec_9bit_ts_dtype init (36),
  2    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  2    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  2    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  2    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  2    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  2    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  2    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  2    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  2    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  2    63 	   real_flt_hex_1_dtype   init (47),
  2    64 	   real_flt_hex_2_dtype   init (48),
  2    65 	   cplx_flt_hex_1_dtype   init (49),
  2    66 	   cplx_flt_hex_2_dtype   init (50),
  2    67 	   c_typeref_dtype        init (54),
  2    68 	   c_enum_dtype           init (55),
  2    69              c_enum_const_dtype     init (56),
  2    70 	   c_union_dtype          init (57),
  2    71 	   algol68_straight_dtype init (59),
  2    72 	   algol68_format_dtype   init (60),
  2    73 	   algol68_array_descriptor_dtype init (61),
  2    74 	   algol68_union_dtype    init (62),
  2    75 
  2    76 	   cobol_comp_6_dtype     init (1),
  2    77 	   cobol_comp_7_dtype     init (1),
  2    78 	   cobol_display_ls_dtype init (9),
  2    79 	   cobol_structure_dtype  init (17),
  2    80 	   cobol_char_string_dtype init (21),
  2    81 	   cobol_display_ls_overp_dtype init (29),
  2    82 	   cobol_display_ts_overp_dtype init (30),
  2    83 	   cobol_display_uns_dtype init (35),
  2    84 	   cobol_display_ts_dtype init (36),
  2    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  2    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  2    87 	   cobol_comp_5_uns_dtype init (40),
  2    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  2    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  2    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  2    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  2    92 	   cplx_flt_dec_generic_dtype init (84),
  2    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  2    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  2    95 
  2    96      dcl	   (ft_integer_dtype      init (1),
  2    97 	   ft_real_dtype	      init (3),
  2    98 	   ft_double_dtype	      init (4),
  2    99 	   ft_complex_dtype	      init (7),
  2   100 	   ft_complex_double_dtype init (8),
  2   101 	   ft_external_dtype      init (16),
  2   102 	   ft_logical_dtype	      init (19),
  2   103 	   ft_char_dtype	      init (21),
  2   104 	   ft_hex_real_dtype      init (47),
  2   105 	   ft_hex_double_dtype    init (48),
  2   106 	   ft_hex_complex_dtype   init (49),
  2   107 	   ft_hex_complex_double_dtype init (50)
  2   108 	   )		      fixed bin internal static options (constant);
  2   109 
  2   110      dcl	   (algol68_short_int_dtype init (1),
  2   111 	   algol68_int_dtype      init (1),
  2   112 	   algol68_long_int_dtype init (2),
  2   113 	   algol68_real_dtype     init (3),
  2   114 	   algol68_long_real_dtype init (4),
  2   115 	   algol68_compl_dtype    init (7),
  2   116 	   algol68_long_compl_dtype init (8),
  2   117 	   algol68_bits_dtype     init (19),
  2   118 	   algol68_bool_dtype     init (19),
  2   119 	   algol68_char_dtype     init (21),
  2   120 	   algol68_byte_dtype     init (21),
  2   121 	   algol68_struct_struct_char_dtype init (22),
  2   122 	   algol68_struct_struct_bool_dtype init (20)
  2   123 	   )		      fixed bin internal static options (constant);
  2   124 
  2   125      dcl	   (label_constant_runtime_dtype init (24),
  2   126 	   int_entry_runtime_dtype init (25),
  2   127 	   ext_entry_runtime_dtype init (26),
  2   128 	   ext_procedure_runtime_dtype init (27),
  2   129 	   picture_runtime_dtype  init (63)
  2   130 	   )		      fixed bin internal static options (constant);
  2   131 
  2   132      dcl	   (pascal_integer_dtype  init (1),
  2   133 	   pascal_real_dtype      init (4),
  2   134 	   pascal_label_dtype     init (24),
  2   135 	   pascal_internal_procedure_dtype init (25),
  2   136 	   pascal_exportable_procedure_dtype init (26),
  2   137 	   pascal_imported_procedure_dtype init (27),
  2   138 	   pascal_typed_pointer_type_dtype init (64),
  2   139 	   pascal_char_dtype      init (65),
  2   140 	   pascal_boolean_dtype   init (66),
  2   141 	   pascal_record_file_type_dtype init (67),
  2   142 	   pascal_record_type_dtype init (68),
  2   143 	   pascal_set_dtype	      init (69),
  2   144 	   pascal_enumerated_type_dtype init (70),
  2   145 	   pascal_enumerated_type_element_dtype init (71),
  2   146 	   pascal_enumerated_type_instance_dtype init (72),
  2   147 	   pascal_user_defined_type_dtype init (73),
  2   148 	   pascal_user_defined_type_instance_dtype init (74),
  2   149 	   pascal_text_file_dtype init (75),
  2   150 	   pascal_procedure_type_dtype init (76),
  2   151 	   pascal_variable_formal_parameter_dtype init (77),
  2   152 	   pascal_value_formal_parameter_dtype init (78),
  2   153 	   pascal_entry_formal_parameter_dtype init (79),
  2   154 	   pascal_parameter_procedure_dtype init (80),
  2   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  2   156 
  2   157 
  2   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      189 
      190 
  3     1 /* BEGIN INCLUDE FILE:  dl_handler_options.incl.pl1 */
  3     2 
  3     3 /* This is the switches argument to dl_handler_$switches
  3     4*
  3     5*   Jay Pattin 7/2/83 */
  3     6 
  3     7 declare   1 dl_handler_options,
  3     8           2 no_question                 bit (1) unaligned,  /* ON = reset switches without querying */
  3     9           2 library                     bit (1) unaligned,  /* ON = use installatio_tools_ */
  3    10           2 raw                         bit (1) unaligned,  /* ON = use hcs_, not object_type_ (library takes precedence) */
  3    11           2 mbz                         bit (33) unaligned;
  3    12 
  3    13 /* END INCLUDE FILE: dl_handler_options.incl.pl1 */
      191 
      192 
  4     1 /* BEGIN INCLUDE FILE: suffix_info.incl.pl1 */
  4     2 /* format: style3,indcomtxt,idind30 */
  4     3 /**** Jay Pattin 2/13/83
  4     4*      M. Pandolf 1984.11.30 to set FS_OBJECT_TYPE_MSF to -multisegment_file
  4     5*
  4     6*      The include file copy_flags.incl.pl1 must be included in any program using this include file.
  4     7*
  4     8*      This structure is returned by the suffix_XXX_$suffix_info subroutines */
  4     9 
  4    10 declare   suffix_info_ptr               ptr;
  4    11 
  4    12 declare   1 suffix_info                 aligned based (suffix_info_ptr),
  4    13             2 version                   char (8),
  4    14             2 type                      char (32) unaligned,
  4    15             2 type_name                 char (32) unaligned,          /* Singular name of the object type, e.g. "mailbox" */
  4    16             2 plural_name               char (32) unaligned,          /* Plural of above, e.g. "mailboxes" */
  4    17             2 flags                     unaligned,
  4    18               3 standard_object         bit (1) unaligned,  /* ON if not an extended object (no suffix_XXX_) */
  4    19               3 extended_acl            bit (1) unaligned,  /* ON if uses extended ACLs, off if regular ACLs */
  4    20               3 has_switches            bit (1) unaligned,  /* ON if supports switches for objects */
  4    21               3 mbz1                    bit (33) unaligned,
  4    22             2 modes                     char (36),          /* correspondence between bits and chars for extended modes */
  4    23             2 max_mode_len              fixed bin,          /* maximum number of modes on an object */
  4    24             2 num_ring_brackets         fixed bin,          /* number of ring brackets on object */
  4    25             2 copy_flags                like copy_flags,    /* See copy_flags.incl.pl1 */
  4    26             2 info_pathname             char (168) unaligned;
  4    27                                                             /* pathname of info segment containing more info */
  4    28 
  4    29 declare   SUFFIX_INFO_VERSION_1         char (8) static options (constant) init ("SUFFIX01");
  4    30 
  4    31 /* This information is returned by the suffix_XXX_$list_switches subroutines */
  4    32 
  4    33 declare   switch_list_ptr               ptr,
  4    34           alloc_switch_count            fixed bin,
  4    35           alloc_switch_name_count       fixed bin;
  4    36 
  4    37 declare   1 switch_list                 aligned based (switch_list_ptr),
  4    38             2 version                   char (8),           /* SWITCH_LIST_VERSION_1 */
  4    39             2 switch_count              fixed bin,          /* total number of switches */
  4    40             2 switch_name_count         fixed bin,          /* total number of names */
  4    41             2 switches                  (alloc_switch_count refer (switch_list.switch_count)),
  4    42               3 name_index              fixed bin,          /* index of first name for this switch */
  4    43               3 name_count              fixed bin,          /* number of names for this switch */
  4    44               3 default_value           bit (1) aligned,    /* default setting for this switch */
  4    45               3 mbz1                    bit (36) aligned,   /* reserved for future use */
  4    46             2 names                     (alloc_switch_name_count refer (switch_list.switch_name_count)) char (32);
  4    47 
  4    48 declare   SWITCH_LIST_VERSION_1         char (8) static options (constant) init ("SWLIST01");
  4    49 
  4    50 declare   (
  4    51           FS_OBJECT_TYPE_SEGMENT        init ("-segment"),
  4    52           FS_OBJECT_TYPE_DIRECTORY      init ("-directory"),
  4    53           FS_OBJECT_TYPE_MSF            init ("-multisegment_file"),
  4    54           FS_OBJECT_TYPE_DM_FILE        init ("-dm_file"),
  4    55           FS_OBJECT_TYPE_LINK           init ("-link")
  4    56           )                             char (32) unaligned int static options (constant);
  4    57 
  4    58 /* END INCLUDE FILE: suffix_info.incl.pl1 */
      193 
  5     1 /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  5     2 
  5     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  5     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  5     5*
  5     6*   Jay Pattin 6/23/83 */
  5     7 
  5     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  5     9           2 names                       bit (1) unaligned,
  5    10           2 acl                         bit (1) unaligned,
  5    11           2 ring_brackets               bit (1) unaligned,
  5    12           2 max_length                  bit (1) unaligned,
  5    13           2 copy_switch                 bit (1) unaligned,
  5    14           2 safety_switch               bit (1) unaligned,
  5    15           2 dumper_switches             bit (1) unaligned,
  5    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  5    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  5    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  5    19           2 mbz                         bit (26) unaligned;
  5    20 
  5    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
      194 
      195 
      196 /* Initialize variables.  Set code to zero, and remember that we have the pathname
      197*   of the thing to be deleted (the ptr entry does not provide it). */
      198 
      199 	code = 0;
      200 	dname = dirname;
      201 	ename = entryname;
      202 	path_entry = "1"b;
      203 	segp = null;
      204 	call check_switches (3);
      205 
      206 /* Find out what type of branch this is.  Then dispatch to the appropriate action routine,
      207*   or error message.  Note that a directory with a non-zero bitcount
      208*   is considered to be a segment - an MSF */
      209 
      210 check_type:
      211 	call hcs_$status_minf (dname, ename, 0, type, bitcount, code);
      212 	if code ^= 0
      213 	then return;
      214 
      215 	if ^delete_options.raw & type ^= 0
      216 	then do;
      217 		call fs_util_$get_type (dname, ename, fs_util_type, code);
      218 						/* Is this Xobj (not link to Xobj)? */
      219 		if code = 0 & (substr (fs_util_type, 1, 1) ^= "-" | fs_util_type = FS_OBJECT_TYPE_DM_FILE)
      220 		then do;				/* - at beginning implies standard object, but */
      221 						/* this program treats DM files as extended */
      222 						/* rather than standard objects */
      223             		/* if extended object, don't try to initiate */
      224 		          if type = 1 & ^delete_options.segment
      225                               then goto is_segment;
      226                               goto call_delete;
      227 		     end;
      228 	     end;
      229 
      230 	if type = 0
      231 	then /* link */
      232 	     if ^delete_options.link
      233 	     then go to is_link;
      234 	     else if delete_options.chase
      235 	     then do;
      236 		     call hcs_$get_link_target (dname, ename, dname, ename, code);
      237 		     if code ^= 0
      238 		     then return;			/* chase the link and start again */
      239 		     go to check_type;
      240 		end;
      241 	     else go to unlink_link;
      242 
      243 	else if type = 1
      244 	then /* segment */
      245 	     if ^delete_options.segment
      246 	     then go to is_segment;
      247 	     else go to delete_segment;
      248 
      249 	else if type = 2
      250 	then /* directory */
      251 	     if bitcount ^= 0
      252 	     then do;
      253 		     if ^delete_options.segment
      254 		     then go to is_segment;
      255 		     type = 3;			/* msf */
      256 		     go to delete_msf;
      257 		end;
      258 
      259 	     else if ^delete_options.directory
      260 	     then go to is_directory;
      261 	     else go to delete_directory;
      262 
      263 
      264 /* Call term_ on the segment to be deleted. */
      265 /* Initiate it here, so we can take advantage of segptr if we have it */
      266 
      267 delete_segment:
      268 	if segp = null ()
      269 	then do;
      270 		call hcs_$get_segment_ptr_path (dirname, ename, segp, "0"b, code);
      271 		if segp ^= null ()			/* segment was previously initiated */
      272 		then do;
      273 			call hcs_$get_safety_sw_seg (segp, safety_switch, (0));
      274 			if safety_switch
      275 			then go to protected_by_switch;
      276 			/*** * We don't check the copy switch, it is too much pain. */
      277 			call term_$seg_ptr (segp, (0));
      278 						/* begone! */
      279 		     end;
      280 		segp = null ();
      281 	     end;
      282 	else do;
      283 		call hcs_$fs_get_path_name (segp, dname, (0), ename, code);
      284 		if code ^= 0
      285 		then return;
      286 	     end;
      287 
      288 
      289 unlink_link:
      290 call_delete:
      291 	if delete_options.library
      292 	then call installation_tools_$delentry_file (dname, ename, code);
      293 	else if delete_options.raw | type = 0		/* flush links with hcs_ */
      294 	then call hcs_$delentry_file (dname, ename, code);
      295 	else call fs_util_$delentry_file (dname, ename, code);
      296 
      297 	if code ^= 0
      298 	then if code = error_table_$copy_sw_on | code = error_table_$safety_sw_on
      299 	     then
      300 protected_by_switch:				/* come here to avoid terminating before asking question */
      301 		do;				/* entry is protected - see whether to force */
      302 		     if (^delete_options.force & ^delete_options.question)
      303 		     then return;
      304 
      305 		     string (dl_handler_options) = ""b;
      306 		     dl_handler_options.no_question = delete_options.force;
      307 		     dl_handler_options.raw = delete_options.raw;
      308 		     dl_handler_options.library = delete_options.library;
      309 
      310 		     call dl_handler_$switches (caller, dname, ename, string (dl_handler_options), code);
      311 
      312 		     if code = 0
      313 		     then go to call_delete;
      314 		     else return;
      315 		end;
      316 	return;
      317 
      318 
      319 /* Delete a directory.  MSF's (directories with non-zero bitcounts) are treated the same way */
      320 
      321 delete_msf:
      322 delete_directory:
      323 	call hcs_$delentry_file (dname, ename, code);	/* try to delete it first */
      324 	if code = error_table_$fulldir
      325 	then do;					/* have to delete its contents */
      326 delete_contents:
      327 		call hcs_$status_long (dname, ename, 0, addr (lbranch), null, code);
      328 						/* must find out if mounted before deleting */
      329 		if code ^= 0
      330 		then return;
      331 		call hcs_$lv_attached (lbranch.lvid, code);
      332 		if code ^= 0
      333 		then return;
      334 		pname = pathname_ (rtrim (dname), ename);
      335 list_again:
      336 		call hcs_$star_ (pname, "**", all, get_system_free_area_ (), ecount, eptr, nptr, code);
      337 		if code ^= 0
      338 		then do;
      339 			if code = error_table_$moderr
      340 			then do;			/* force dir access */
      341 				if init_acl_sw
      342 				then return;
      343 				dir_acl.userid = get_group_id_$tag_star ();
      344 				dir_acl.mode = "111"b;
      345 				dir_acl.status = 0;
      346 				call hcs_$add_dir_acl_entries (dname, ename, addr (dir_acl), 1, code);
      347 				init_acl_sw = "1"b;
      348 				if code = 0 & dir_acl.status = 0
      349 				then go to list_again;
      350 			     end;
      351 			if delete_options.question
      352 			then call com_err_ (code, caller, "Unable to delete ^a", pname);
      353 			return;
      354 		     end;
      355 		directory_contents_code = 0;
      356 		do i = 1 to ecount;
      357 		     name = names (fixed (entries (i).nindex));
      358 		     etype = entries (i).type;
      359 		     delete_options.link, delete_options.segment = "1"b;
      360 		     init_acl_sw = "0"b;
      361 delete_again:
      362 		     call delete_$path (pname, name, (string (delete_options)), caller, code);
      363 						/* recurse */
      364 		     if code ^= 0
      365 		     then do;
      366 			     if code = error_table_$incorrect_access
      367 			     then do;		/* force dir access */
      368 				     if init_acl_sw
      369 				     then return;
      370 				     dir_acl.userid = get_group_id_$tag_star ();
      371 				     dir_acl.mode = "111"b;
      372 				     dir_acl.status = 0;
      373 				     call hcs_$add_dir_acl_entries (dname, ename, addr (dir_acl), 1, code);
      374 				     init_acl_sw = "1"b;
      375 				     if code = 0 & dir_acl.status = 0
      376 				     then go to delete_again;
      377 				end;
      378 			     if code = error_table_$action_not_performed
      379 			     then do;
      380 				     directory_contents_code = code;
      381 				     go to endloop;
      382 				end;
      383 			     if directory_contents_code ^= error_table_$action_not_performed
      384 				& (code = dm_error_$delete_pending_transaction
      385 				| code = dm_error_$no_delete_dir_transaction)
      386 			     then directory_contents_code = dm_error_$no_delete_dir_transaction;
      387 			     else directory_contents_code = error_table_$action_not_performed;
      388 			     if delete_options.question
      389 			     then if code = dm_error_$delete_pending_transaction
      390 				then call com_err_ (code, caller, " ^a>^a", pname, name);
      391 				else do;
      392 					if etype = "00"b
      393 					then operation = "unlink";
      394 					else operation = "delete";
      395 					call com_err_ (code, caller, "Unable to ^a ^a>^a", operation, pname,
      396 					     name);
      397 				     end;
      398 			end;
      399 endloop:
      400 		end;
      401 		code = directory_contents_code;
      402 		if code = 0
      403 		then go to delete_directory;		/* try again now that contents are deleted */
      404 	     end;
      405 	else if code = error_table_$copy_sw_on | code = error_table_$safety_sw_on
      406 	then do;
      407 		string (dl_handler_options) = ""b;
      408 		dl_handler_options.no_question = ^delete_options.question | delete_options.force;
      409 		dl_handler_options.raw = delete_options.raw;
      410 		dl_handler_options.library = delete_options.library;
      411 
      412 		if delete_options.question | delete_options.force
      413 						/* either dl handler will ask, or it is licensed to fix things without asking */
      414 		then call dl_handler_$switches (caller, dname, ename, string (dl_handler_options), code);
      415 		else return;
      416 		if code = 0
      417 		then go to delete_directory;
      418 	     end;
      419 
      420 	else if code = error_table_$master_dir
      421 	then do;					/* must call mdc to delete this */
      422 		call mdc_$delete_dir (dname, ename, code);
      423 		if code ^= 0
      424 		then if code = error_table_$fulldir
      425 		     then go to delete_contents;
      426 	     end;
      427 
      428 	return;
      429 
      430 
      431 
      432 
      433 
      434 
      435 ptr:
      436      entry (segptr, a_switches, caller, code);
      437 
      438 
      439 /* The ptr entry is similar to the path entry, except that the caller already has a ptr to the
      440*   segment, so we might as well save the initiate call.  You can only have a ptr to a segment (not
      441*   a link, directory, or MSF). */
      442 
      443 
      444 
      445 
      446 	if segptr = null
      447 	then do;
      448 		code = error_table_$invalidsegno;
      449 		return;
      450 	     end;
      451 
      452 	code = 0;
      453 	segp = segptr;
      454 	path_entry = "0"b;
      455 	type = 1;
      456 
      457 	call check_switches (2);
      458 	if ^delete_options.segment
      459 	then go to is_segment;
      460 	go to delete_segment;
      461 
      462 
      463 
      464 
      465 
      466 
      467 is_link:
      468 	code = error_table_$not_a_branch;
      469 	return;
      470 
      471 is_segment:
      472 	code = error_table_$nondirseg;
      473 	return;
      474 
      475 is_directory:
      476 	code = error_table_$dirseg;
      477 	return;
      478 
      479 check_switches:					/* Need to check whether old style call where switches were */
      480      proc (switch_arg);				/* declared bit (6) */
      481 
      482 	dcl     switch_arg		        fixed bin;
      483 	dcl     (size, type)	        fixed bin;
      484 	dcl     arg_ptr		        ptr,
      485 	        arg		        bit (6) based (arg_ptr);
      486 	dcl     cu_$arg_list_ptr	        entry returns (ptr);
      487 	dcl     cu_$arg_ptr		        entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      488 	dcl     decode_descriptor_	        entry (ptr, fixed bin, fixed bin, bit (1) aligned, fixed bin, fixed bin,
      489 				        fixed bin);
      490 
      491 	call decode_descriptor_ (cu_$arg_list_ptr (), switch_arg, type, ("0"b), (0), size, (0));
      492 
      493 /**** * THIS DEPENDS ON THE FACT THE A CHAR (*) IN THE ARG LIST
      494*      CAUSES ALL ARGUMENTS TO HAVE DESCRIPTORS! */
      495 	if type = bit_dtype & size = 36
      496 	then /* bit (36) */
      497 	     string (delete_options) = a_switches;
      498 	else do;
      499 		call cu_$arg_ptr (switch_arg, arg_ptr, (0), (0));
      500 		substr (string (delete_options), 1, 6) = arg;
      501 		substr (string (delete_options), 6) = ""b;
      502 	     end;
      503 
      504 	return;
      505      end check_switches;
      506 
      507 
      508      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/06/92  0057.4  delete_.pl1                       >spec>inst>1025>delete_.pl1
188          1    10/14/83  1706.7  delete_options.incl.pl1           >ldd>incl>delete_options.incl.pl1
189          2    10/26/88  1355.5  std_descriptor_types.incl.pl1     >ldd>incl>std_descriptor_types.incl.pl1
191          3    10/14/83  1706.7  dl_handler_options.incl.pl1       >ldd>incl>dl_handler_options.incl.pl1
193          4    03/05/85  1907.3  suffix_info.incl.pl1              >ldd>incl>suffix_info.incl.pl1
194          5    10/14/83  1706.7  copy_flags.incl.pl1               >ldd>incl>copy_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FS_OBJECT_TYPE_DM_FILE          000000 constant        char(32)                 initial packed unaligned dcl 4-50 ref 219
a_switches                             parameter       bit(36)                  dcl 76 ref 23 435 495
addr                                                   builtin function         dcl 145 ref 326 326 346 346 373 373
all                             000100 automatic       fixed bin(2,0)           initial dcl 77 set ref 77* 335*
arg                                    based           bit(6)                   packed unaligned dcl 484 ref 500
arg_ptr                         000350 automatic       pointer                  dcl 484 set ref 499* 500
bit_dtype                              constant        fixed bin(17,0)          initial dcl 2-25 ref 495
bitcount                        000101 automatic       fixed bin(24,0)          dcl 78 set ref 210* 249
caller                                 parameter       char                     packed unaligned dcl 79 set ref 23 310* 351* 361*
                                                                                  388* 395* 412* 435
chase                     0(05) 000323 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-7 set ref 234
code                                   parameter       fixed bin(35,0)          dcl 80 set ref 23 199* 210* 212 217* 219 236* 237
                                                                                  270* 283* 284 289* 293* 295* 297 297 297 310* 312
                                                                                  321* 324 326* 329 331* 332 335* 337 339 346* 348
                                                                                  351* 361* 364 366 373* 375 378 380 383 383 388
                                                                                  388* 395* 401* 402 405 405 412* 416 420 422* 423
                                                                                  423 435 448* 452* 467* 471* 475*
com_err_                        000010 constant        entry                    external dcl 81 ref 351 388 395
copy_flags                             based           structure                level 1 dcl 5-8
cu_$arg_list_ptr                000114 constant        entry                    external dcl 486 ref 491 491
cu_$arg_ptr                     000116 constant        entry                    external dcl 487 ref 499
decode_descriptor_              000120 constant        entry                    external dcl 488 ref 491
delete_$path                    000012 constant        entry                    external dcl 82 ref 361
delete_options                  000323 automatic       structure                level 1 packed packed unaligned dcl 1-7 set ref 361
                                                                                  495* 500 501
dir_acl                         000277 automatic       structure                level 1 dcl 149 set ref 346 346 373 373
directory                 0(02) 000323 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-7 set ref 259
directory_contents_code         000102 automatic       fixed bin(35,0)          dcl 83 set ref 355* 380* 383 383* 387* 401
dirname                                parameter       char                     packed unaligned dcl 84 set ref 23 200 270*
dl_handler_$switches            000014 constant        entry                    external dcl 85 ref 310 412
dl_handler_options              000324 automatic       structure                level 1 packed packed unaligned dcl 3-7 set ref 305*
                                                                                  310 310 407* 412 412
dm_error_$delete_pending_transaction
                                000066 external static fixed bin(35,0)          dcl 130 ref 383 388
dm_error_$no_delete_dir_transaction
                                000104 external static fixed bin(35,0)          dcl 138 ref 383 383
dname                           000103 automatic       char(168)                packed unaligned dcl 86 set ref 200* 210* 217* 236*
                                                                                  236* 283* 289* 293* 295* 310* 321* 326* 334 334
                                                                                  346* 373* 412* 422*
ecount                          000155 automatic       fixed bin(17,0)          dcl 87 set ref 335* 356
ename                           000156 automatic       char(32)                 packed unaligned dcl 88 set ref 201* 210* 217* 236*
                                                                                  236* 270* 283* 289* 293* 295* 310* 321* 326* 334*
                                                                                  346* 373* 412* 422*
entries                                based           structure                array level 1 dcl 154
entryname                              parameter       char                     packed unaligned dcl 89 ref 23 201
eptr                            000166 automatic       pointer                  dcl 90 set ref 335* 357 358
error_table_$action_not_performed
                                000062 external static fixed bin(35,0)          dcl 127 ref 378 383 387
error_table_$copy_sw_on         000064 external static fixed bin(35,0)          dcl 129 ref 297 405
error_table_$dirseg             000070 external static fixed bin(35,0)          dcl 132 ref 475
error_table_$fulldir            000072 external static fixed bin(35,0)          dcl 133 ref 324 423
error_table_$incorrect_access   000074 external static fixed bin(35,0)          dcl 134 ref 366
error_table_$invalidsegno       000076 external static fixed bin(35,0)          dcl 135 ref 448
error_table_$master_dir         000100 external static fixed bin(35,0)          dcl 136 ref 420
error_table_$moderr             000102 external static fixed bin(35,0)          dcl 137 ref 339
error_table_$nondirseg          000106 external static fixed bin(35,0)          dcl 140 ref 471
error_table_$not_a_branch       000110 external static fixed bin(35,0)          dcl 141 ref 467
error_table_$safety_sw_on       000112 external static fixed bin(35,0)          dcl 142 ref 297 405
etype                           000170 automatic       bit(2)                   packed unaligned dcl 91 set ref 358* 392
fixed                                                  builtin function         dcl 145 ref 357
force                           000323 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-7 set ref 302
                                                                                  306 408 412
fs_util_$delentry_file          000024 constant        entry                    external dcl 97 ref 295
fs_util_$get_type               000022 constant        entry                    external dcl 96 ref 217
fs_util_type                    000171 automatic       char(32)                 packed unaligned dcl 92 set ref 217* 219 219
get_group_id_$tag_star          000016 constant        entry                    external dcl 93 ref 343 370
get_system_free_area_           000020 constant        entry                    external dcl 94 ref 335 335
hcs_$add_dir_acl_entries        000026 constant        entry                    external dcl 99 ref 346 373
hcs_$delentry_file              000030 constant        entry                    external dcl 100 ref 293 321
hcs_$fs_get_path_name           000032 constant        entry                    external dcl 101 ref 283
hcs_$get_link_target            000034 constant        entry                    external dcl 102 ref 236
hcs_$get_safety_sw_seg          000036 constant        entry                    external dcl 103 ref 273
hcs_$get_segment_ptr_path       000040 constant        entry                    external dcl 104 ref 270
hcs_$lv_attached                000042 constant        entry                    external dcl 105 ref 331
hcs_$star_                      000044 constant        entry                    external dcl 106 ref 335
hcs_$status_long                000050 constant        entry                    external dcl 110 ref 326
hcs_$status_minf                000046 constant        entry                    external dcl 108 ref 210
i                               000202 automatic       fixed bin(17,0)          dcl 113 set ref 356* 357 358*
init_acl_sw                     000203 automatic       bit(1)                   initial dcl 114 set ref 114* 341 347* 360* 368 374*
installation_tools_$delentry_file
                                000052 constant        entry                    external dcl 111 ref 289
lbranch                         000311 automatic       structure                level 1 dcl 162 set ref 326 326
library                   0(06) 000323 automatic       bit(1)                   level 2 in structure "delete_options" packed packed
                                                                                  unaligned dcl 1-7 in procedure "delete_$path" set
                                                                                  ref 289 308 410
library                   0(01) 000324 automatic       bit(1)                   level 2 in structure "dl_handler_options" packed
                                                                                  packed unaligned dcl 3-7 in procedure
                                                                                  "delete_$path" set ref 308* 410*
link                      0(04) 000323 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-7 set ref 230
                                                                                  359*
lvid                      6     000311 automatic       bit(36)                  level 2 dcl 162 set ref 331*
mdc_$delete_dir                 000054 constant        entry                    external dcl 115 ref 422
mode                     10     000277 automatic       bit(36)                  level 2 dcl 149 set ref 344* 371*
name                            000204 automatic       char(32)                 packed unaligned dcl 116 set ref 357* 361* 388* 395*
names                                  based           char(32)                 array dcl 159 ref 357
nindex                    0(18)        based           bit(18)                  array level 2 packed packed unaligned dcl 154 ref
                                                                                  357
no_question                     000324 automatic       bit(1)                   level 2 packed packed unaligned dcl 3-7 set ref 306*
                                                                                  408*
nptr                            000214 automatic       pointer                  dcl 117 set ref 335* 357
null                                                   builtin function         dcl 145 ref 203 267 271 280 326 326 446
operation                       000216 automatic       char(6)                  packed unaligned dcl 118 set ref 392* 394* 395*
path_entry                      000201 automatic       bit(1)                   packed unaligned dcl 95 set ref 202* 454*
pathname_                       000056 constant        entry                    external dcl 119 ref 334
pname                           000220 automatic       char(168)                packed unaligned dcl 120 set ref 334* 335* 351* 361*
                                                                                  388* 395*
question                  0(01) 000323 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-7 set ref 302
                                                                                  351 388 408 412
raw                       0(07) 000323 automatic       bit(1)                   level 2 in structure "delete_options" packed packed
                                                                                  unaligned dcl 1-7 in procedure "delete_$path" set
                                                                                  ref 215 293 307 409
raw                       0(02) 000324 automatic       bit(1)                   level 2 in structure "dl_handler_options" packed
                                                                                  packed unaligned dcl 3-7 in procedure
                                                                                  "delete_$path" set ref 307* 409*
rtrim                                                  builtin function         dcl 145 ref 334 334
safety_switch                   000272 automatic       bit(1)                   dcl 121 set ref 273* 274
segment                   0(03) 000323 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-7 set ref 224
                                                                                  243 253 359* 458
segp                            000274 automatic       pointer                  dcl 122 set ref 203* 267 270* 271 273* 277* 280*
                                                                                  283* 453*
segptr                                 parameter       pointer                  dcl 123 ref 435 446 453
size                            000346 automatic       fixed bin(17,0)          dcl 483 set ref 491* 495
status                   11     000277 automatic       fixed bin(35,0)          level 2 dcl 149 set ref 345* 348 372* 375
string                                                 builtin function         dcl 145 set ref 305* 310 310 361 407* 412 412 495*
                                                                                  500 501
substr                                                 builtin function         dcl 145 set ref 219 500* 501*
switch_arg                             parameter       fixed bin(17,0)          dcl 482 set ref 479 491* 499*
term_$seg_ptr                   000060 constant        entry                    external dcl 124 ref 277
type                            000347 automatic       fixed bin(17,0)          dcl 483 in procedure "check_switches" set ref 491*
                                                                                  495
type                                   based           bit(2)                   array level 2 in structure "entries" packed packed
                                                                                  unaligned dcl 154 in procedure "delete_$path" ref
                                                                                  358
type                            000276 automatic       fixed bin(2,0)           dcl 125 in procedure "delete_$path" set ref 210* 215
                                                                                  224 230 243 249 255* 293 455*
userid                          000277 automatic       char(32)                 level 2 dcl 149 set ref 343* 370*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
FS_OBJECT_TYPE_DIRECTORY               internal static char(32)                 initial packed unaligned dcl 4-50
FS_OBJECT_TYPE_LINK                    internal static char(32)                 initial packed unaligned dcl 4-50
FS_OBJECT_TYPE_MSF                     internal static char(32)                 initial packed unaligned dcl 4-50
FS_OBJECT_TYPE_SEGMENT                 internal static char(32)                 initial packed unaligned dcl 4-50
SUFFIX_INFO_VERSION_1                  internal static char(8)                  initial packed unaligned dcl 4-29
SWITCH_LIST_VERSION_1                  internal static char(8)                  initial packed unaligned dcl 4-48
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 2-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 2-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 2-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 2-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 2-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 2-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 2-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 2-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 2-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 2-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 2-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 2-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 2-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 2-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 2-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 2-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 2-25
alloc_switch_count                     automatic       fixed bin(17,0)          dcl 4-33
alloc_switch_name_count                automatic       fixed bin(17,0)          dcl 4-33
area_dtype                             internal static fixed bin(17,0)          initial dcl 2-25
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 2-25
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 2-25
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 2-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 2-25
char_dtype                             internal static fixed bin(17,0)          initial dcl 2-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 2-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 2-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 2-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 2-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 2-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 2-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 2-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 2-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 2-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 2-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 2-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 2-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 2-25
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 2-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 2-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 2-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 2-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 2-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 2-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 2-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 2-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 2-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 2-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 2-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 2-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 2-25
entry_dtype                            internal static fixed bin(17,0)          initial dcl 2-25
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 2-125
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 2-125
file_dtype                             internal static fixed bin(17,0)          initial dcl 2-25
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 2-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 2-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 2-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 2-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 2-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 2-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 2-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 2-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 2-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 2-96
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 2-96
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 2-96
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 2-125
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 2-125
label_dtype                            internal static fixed bin(17,0)          initial dcl 2-25
offset_dtype                           internal static fixed bin(17,0)          initial dcl 2-25
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 2-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 2-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 2-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 2-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 2-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 2-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 2-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 2-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 2-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 2-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 2-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 2-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 2-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 2-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 2-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 2-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 2-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 2-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 2-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 2-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 2-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 2-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 2-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 2-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 2-125
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 2-25
real_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 2-25
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 2-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 2-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 2-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 2-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 2-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 2-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 2-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 2-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 2-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 2-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 2-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 2-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 2-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 2-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 2-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 2-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 2-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 2-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 2-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 2-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 2-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 2-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 2-25
structure_dtype                        internal static fixed bin(17,0)          initial dcl 2-25
suffix_info                            based           structure                level 1 dcl 4-12
suffix_info_ptr                        automatic       pointer                  dcl 4-10
switch_list                            based           structure                level 1 dcl 4-37
switch_list_ptr                        automatic       pointer                  dcl 4-33
varying_bit_dtype                      internal static fixed bin(17,0)          initial dcl 2-25
varying_char_dtype                     internal static fixed bin(17,0)          initial dcl 2-25

NAMES DECLARED BY EXPLICIT CONTEXT.
call_delete                     000502 constant        label                    dcl 289 ref 226 312
check_switches                  001771 constant        entry                    internal dcl 479 ref 204 457
check_type                      000145 constant        label                    dcl 210 set ref 239
delete_$path                    000067 constant        entry                    external dcl 23
delete_again                    001270 constant        label                    dcl 361 ref 375
delete_contents                 000720 constant        label                    dcl 326 ref 423
delete_directory                000673 constant        label                    dcl 321 ref 261 402 416
delete_msf                      000673 constant        label                    dcl 321 ref 256
delete_segment                  000345 constant        label                    dcl 267 ref 247 460
endloop                         001544 constant        label                    dcl 399 ref 381
is_directory                    001765 constant        label                    dcl 475 ref 259
is_link                         001755 constant        label                    dcl 467 ref 230
is_segment                      001761 constant        label                    dcl 471 ref 224 243 253 458
list_again                      001037 constant        label                    dcl 335 ref 348
protected_by_switch             000606 constant        label                    dcl 297 ref 274
ptr                             001705 constant        entry                    external dcl 435
unlink_link                     000502 constant        label                    dcl 289 ref 234

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2556        2700    2100        2566
Length      3240    2100       122         324     455           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
delete_$path                        330 external procedure  is an external procedure.  
check_switches                          internal procedure  shares stack frame of external procedure delete_$path.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
delete_$path             000100 all                         delete_$path
                         000101 bitcount                    delete_$path
                         000102 directory_contents_code     delete_$path
                         000103 dname                       delete_$path
                         000155 ecount                      delete_$path
                         000156 ename                       delete_$path
                         000166 eptr                        delete_$path
                         000170 etype                       delete_$path
                         000171 fs_util_type                delete_$path
                         000201 path_entry                  delete_$path
                         000202 i                           delete_$path
                         000203 init_acl_sw                 delete_$path
                         000204 name                        delete_$path
                         000214 nptr                        delete_$path
                         000216 operation                   delete_$path
                         000220 pname                       delete_$path
                         000272 safety_switch               delete_$path
                         000274 segp                        delete_$path
                         000276 type                        delete_$path
                         000277 dir_acl                     delete_$path
                         000311 lbranch                     delete_$path
                         000323 delete_options              delete_$path
                         000324 dl_handler_options          delete_$path
                         000346 size                        check_switches
                         000347 type                        check_switches
                         000350 arg_ptr                     check_switches

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          mpfx2               shorten_stack
ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_list_ptr              cu_$arg_ptr                   decode_descriptor_
delete_$path                  dl_handler_$switches          fs_util_$delentry_file        fs_util_$get_type
get_group_id_$tag_star        get_system_free_area_         hcs_$add_dir_acl_entries      hcs_$delentry_file
hcs_$fs_get_path_name         hcs_$get_link_target          hcs_$get_safety_sw_seg        hcs_$get_segment_ptr_path
hcs_$lv_attached              hcs_$star_                    hcs_$status_long              hcs_$status_minf
installation_tools_$delentry_file                           mdc_$delete_dir               pathname_
term_$seg_ptr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$delete_pending_transaction                        dm_error_$no_delete_dir_transaction
error_table_$action_not_performed                           error_table_$copy_sw_on       error_table_$dirseg
error_table_$fulldir          error_table_$incorrect_access error_table_$invalidsegno     error_table_$master_dir
error_table_$moderr           error_table_$nondirseg        error_table_$not_a_branch     error_table_$safety_sw_on




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     77 000055       114 000057        23 000062       199 000121       200 000122       201 000130       202 000135
    203 000137       204 000141       210 000145       212 000203       215 000205       217 000212       219 000236
    224 000250       226 000256       230 000257       234 000264       236 000267       237 000316       239 000320
    243 000321       247 000326       249 000327       253 000333       255 000336       256 000340       259 000341
    261 000344       267 000345       270 000351       271 000406       273 000412       274 000426       277 000431
    280 000443       281 000445       283 000446       284 000500       289 000502       293 000527       295 000556
    297 000577       302 000606       305 000615       306 000616       307 000622       308 000627       310 000634
    312 000667       314 000671       316 000672       321 000673       324 000714       326 000720       329 000761
    331 000763       332 000774       334 000776       335 001037       337 001114       339 001116       341 001121
    343 001123       344 001131       345 001133       346 001134       347 001171       348 001173       351 001177
    353 001232       355 001233       356 001234       357 001243       358 001257       359 001263       360 001267
    361 001270       364 001323       366 001325       368 001330       370 001332       371 001340       372 001342
    373 001343       374 001400       375 001402       378 001406       380 001412       381 001413       383 001414
    387 001427       388 001431       392 001472       394 001477       395 001502       399 001544       401 001546
    402 001550       404 001551       405 001552       407 001556       408 001557       409 001573       410 001600
    412 001605       415 001644       416 001645       418 001647       420 001650       422 001652       423 001672
    428 001677       435 001700       446 001725       448 001732       449 001735       452 001736       453 001737
    454 001742       455 001743       457 001745       458 001751       460 001754       467 001755       469 001760
    471 001761       473 001764       475 001765       477 001770       479 001771       491 001773       495 002032
    499 002043       500 002063       501 002067       504 002071


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
