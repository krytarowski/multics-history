	COMPILATION LISTING OF SEGMENT rlm_process_tuples_by_id
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/24/88  1533.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*          Deletes or modifies a tuple or set of tuples identified by a
       11*     tuple_id or by an array of identifiers (element_id_list).  For each tuple
       12*     to be deleted, the keys associated with the tuple are first deleted and
       13*     then the tuple itself is deleted from the record collection.  In order to
       14*     delete the keys, each tuple must be retrieved so that a
       15*     search_specification can be constructed which will match the key field
       16*     values.  For each tuple to be modified, the keys associated with the
       17*     tuple which have a field which may change in value are first deleted then
       18*     re-inserted.  The cursor supplied must be a relation_cursor.
       19*     
       20*          Four entries exist:
       21*     
       22*     rlm_process_tuples_by_id$delete - takes a single
       23*     tuple_id and deletes the tuple (record and associated keys);
       24*     
       25*     rlm_proess_tuples_by_id$delete_array - takes an array of tuple_ids
       26*     (element_id_list) and deletes each tuple identified;
       27*     
       28*     rlm_process_tuples_by_id$modify - modifies selected atribute values of a
       29*     single tuple identified by p_tuple_id;
       30*     
       31*     rlm_process_tuples_by_id$modify_array - modifies selected attribute
       32*     values of an array of tuples identified by an element_id_list
       33*     (p_element_id_list_ptr).
       34**/
       35 
       36 /* HISTORY:
       37*Written by Matthew Pierret 09/28/82.
       38*Modified:
       39*10/18/82 by Matthew Pierret:  Initialized ss.subset_specification_ptr to null.
       40*12/08/82 by Lindsey Spratt:  Fixed to put the new versions of keys when
       41*	  modifying, and to use the old values when doing deletions.
       42*12/09/82 by Lindsey Spratt:  Fixed to reference key_stv_ptr only when
       43*	  modifying. Fixed to use the ALL_RANGE_TYPE search spec.
       44*	  Changed the freeing logic in FINISH to use the current length when
       45*	  determining the amount of storage used by a varying string value,
       46*	  rather than the maximum length.  Changed the
       47*	  DELETE_KEYS_AND_RECORD_FOR_EACH_TUPLE_LOOP to free the
       48*	  simple_typed_vector for the record each time through the loop.
       49*12/21/82 by Matthew Pierret:  Changed to convert dm_error_$record_not_found to
       50*            dm_error_$no_tuple_id.
       51*01/18/83 by Matthew Pierret:  Changed to use relation_info version 2.
       52*03/10/83 by Matthew Pierret:  Changed to use get_dm_free_area_ instead of 
       53*            dm_data_$area_ptr. Changed to use relation_opening_info.
       54*            Changed to not assume that all index_attribute_map entries
       55*            contain an index.  Changed to allocate search_specification
       56*            with one more constraint than the maximum number of attributes
       57*            (to account for the tuple id).
       58*05/23/83 by Matthew Pierret: Changed to use relation_cursors. Moved cursor_ptr
       59*            parameter to be the first parameter in each calling sequence.
       60*            Changed the "do;call FINISH;return;end;" cliche to 
       61*            "call ERROR_RETURN (code);". Changed dm_error_$no_tuple_id to
       62*            dm_error_$tuple_not_found_id. Removed CHECK_TYPE.
       63*            Changed to use version 4 of specification_head.
       64*            Added dm_specification_head.incl.pl1, dm_range_constants.incl.pl1.
       65*06/27/83 by Lindsey L. Spratt:  Changed to use version 2 of the
       66*            relation_cursor.
       67*08/26/83 by Lindsey L. Spratt:  Fixed to only modify an index key when there
       68*	  is a real modification.
       69*05/29/84 by Matthew Pierret:  Changed to use RELATION_HEADER_VERSION_3.
       70*11/06/84 by Stanford S. Cox:  MAIN: Chg to ref simple_typed_vector by explicit ptr
       71*	  when alloc, Chg all sub_err_ calls for new syntax.  IKS: Chg to
       72*   	  set p_search_specification_ptr when alloc instead of global ptr,
       73*   	  Add unique var prefixes. FSTV: Add unique var prefixes.
       74*11/29/84 by Stanford S. Cox:  DELETE_KEYS*: Added by moving code from MAIN.
       75*12/11/84 by Lindsey Spratt:  Changed to call data_format_util_ instead of 
       76*	  data_mgmt_util_.
       77*03/19/85 by Matthew C. Pierret:  Added the ability to rollback a partially
       78*            modified tuple if the modification causes a key_duplication error.
       79*            Replaced the DELETE_KEYS_AND_RECORD_FOR_ONE_TUPLE with the
       80*            routines DELETE_TUPLE, MODIFY_TUPLE, and ROLLBACK_TUPLE, and added
       81*            the utility routines BUILD_RECORD, BUILD_KEY, and BUILD_SPEC.
       82*            Moved the ERROR_RETURN and FINISH routines to just after the main
       83*            return statement, as in most other modules.
       84*            Re-named INIT_KEY_SPECIFICATION to INIT_SPEC and fully 
       85*            parameterized its calling sequence.  Removed the check in FINISH
       86*            for number_of_tuples_processed > 0, as if it is 0, setting the
       87*            parameter to that value is correct.
       88*04/10/85 by Matthew C. Pierret:  Added BUILD_RECORD_TEMPLATE, which takes the
       89*            record returned by record_manager_$get_record_by_id, and replaces
       90*            the varying fields with varying fields allocated at the maximum
       91*            length.  This is so that the record can be used as input on
       92*            subsequent calls to record_manager_$get_record_by_id.
       93*04/12/85 by Matthew C. Pierret:  Changed BUILD_RECORD_TEMPLATE to allocate
       94*            values as aligned.
       95**/
       96 
       97 /* format: style2,ind3 */
       98 
       99 rlm_process_tuples_by_id:
      100    proc ();
      101 
      102       return;					/* Not a real entry */
      103 
      104 
      105 /* START OF DECLARATIONS */
      106 /* Parameter */
      107 
      108       dcl	    p_element_id_list_ptr  ptr;
      109       dcl	    p_tuple_id	       bit (36) aligned;
      110       dcl	    p_typed_vector_ptr     ptr;
      111       dcl	    p_relation_cursor_ptr  ptr;
      112       dcl	    p_number_of_tuples_processed
      113 			       fixed bin (35);
      114       dcl	    p_code	       fixed bin (35);
      115 
      116 /* Automatic */
      117 
      118       dcl	    an_index_field_is_modified
      119 			       bit (1) aligned init ("0"b);
      120       dcl	    delete	       bit (1) aligned;
      121       dcl	    process_single_tuple   bit (1) aligned init ("0"b);
      122       dcl	    (key_ptr, key_spec_ptr, new_record_ptr, old_record_ptr, dm_area_ptr, record_cursor_ptr)
      123 			       ptr init (null);
      124       dcl	    code		       fixed bin (35) init (0);
      125       dcl	    index_idx	       fixed bin init (0);
      126       dcl	    number_of_tuples_processed
      127 			       fixed bin (35) init (0);
      128       dcl	    number_of_tuples_to_process
      129 			       fixed bin (35) init (0);
      130       dcl	    tuple_idx	       fixed bin (17);
      131       dcl	    tuple_id	       bit (36) aligned;
      132 
      133 /* Based */
      134 
      135       dcl	    dm_area	       area (sys_info$max_seg_size) based (dm_area_ptr);
      136 
      137 /* Builtin */
      138 
      139       dcl	    (addr, hbound, null)   builtin;
      140 
      141 /* Constant */
      142 
      143       dcl	    BITS_PER_BYTE	       fixed bin init (9) int static options (constant);
      144       dcl	    BITS_PER_WORD	       fixed bin init (36) int static options (constant);
      145       dcl	    myname	       init ("rlm_process_tuple_by_id") char (32) varying static options (constant);
      146       dcl	    (
      147 	    TRUE		       init ("1"b),
      148 	    FALSE		       init ("0"b)
      149 	    )		       bit (1) aligned internal static options (constant);
      150 
      151 /* Condition */
      152 
      153       dcl	    cleanup	       condition;
      154 
      155 /* Entry */
      156 
      157       dcl	    data_format_util_$get_data_bit_length
      158 			       entry (bit (36) aligned, fixed bin (35), fixed bin (35));
      159       dcl	    get_dm_free_area_      entry () returns (ptr);
      160       dcl	    index_manager_$create_cursor
      161 			       entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
      162       dcl	    index_manager_$delete_key
      163 			       entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
      164       dcl	    index_manager_$put_key entry (ptr, ptr, fixed bin (35));
      165 
      166       dcl	    rlm_opening_info$get   entry (bit (36) aligned, ptr, fixed bin (35));
      167       dcl	    sub_err_	       entry () options (variable);
      168 
      169 /* External */
      170 
      171       dcl	    (
      172 	    dm_error_$key_duplication,
      173 	    dm_error_$key_not_found,
      174 	    dm_error_$record_not_found,
      175 	    dm_error_$tuple_not_found_id
      176 	    )		       ext fixed bin (35);
      177       dcl	    error_table_$unimplemented_version
      178 			       ext fixed bin (35);
      179       dcl	    sys_info$max_seg_size  ext fixed bin (35);
      180 
      181 /* END OF DECLARATIONS */
      182 
      183 delete:
      184    entry (p_relation_cursor_ptr, p_tuple_id, p_code);
      185 
      186       delete = "1"b;
      187       process_single_tuple = "1"b;
      188       number_of_tuples_to_process = 1;
      189       goto JOIN;
      190 
      191 
      192 delete_array:
      193    entry (p_relation_cursor_ptr, p_element_id_list_ptr, p_number_of_tuples_processed, p_code);
      194 
      195       delete = "1"b;
      196       process_single_tuple = "0"b;
      197 
      198       element_id_list_ptr = p_element_id_list_ptr;
      199       call CHECK_VERSION_FB ("element_id_list", (element_id_list.version), (ELEMENT_ID_LIST_VERSION_1));
      200 
      201       number_of_tuples_to_process = element_id_list.number_of_elements;
      202       goto JOIN;
      203 
      204 
      205 modify:
      206    entry (p_relation_cursor_ptr, p_tuple_id, p_typed_vector_ptr, p_code);
      207 
      208       delete = "0"b;
      209       process_single_tuple = "1"b;
      210       number_of_tuples_to_process = 1;
      211       goto MODIFY_JOIN;
      212 
      213 modify_array:
      214    entry (p_relation_cursor_ptr, p_element_id_list_ptr, p_typed_vector_ptr, p_number_of_tuples_processed, p_code);
      215 
      216       delete = "0"b;
      217       process_single_tuple = "0"b;
      218 
      219       element_id_list_ptr = p_element_id_list_ptr;
      220       call CHECK_VERSION_FB ("element_id_list", (element_id_list.version), (ELEMENT_ID_LIST_VERSION_1));
      221 
      222       number_of_tuples_to_process = element_id_list.number_of_elements;
      223 
      224 MODIFY_JOIN:
      225       general_typed_vector_ptr = p_typed_vector_ptr;
      226       if general_typed_vector.type ^= GENERAL_TYPED_VECTOR_TYPE
      227       then call sub_err_ (0, myname, ACTION_CANT_RESTART, null, 0,
      228 	      "The wrong type of typed_vector was supplied.^/Expected type ^d.  Received ^d.",
      229 	      GENERAL_TYPED_VECTOR_TYPE, general_typed_vector.type);
      230 
      231 
      232 JOIN:
      233       simple_typed_vector_ptr, key_ptr, old_record_ptr, new_record_ptr, key_spec_ptr = null ();
      234 
      235       p_code, code = 0;
      236 
      237       relation_cursor_ptr = p_relation_cursor_ptr;
      238 
      239       call CHECK_VERSION ("relation_cursor", (relation_cursor.version), (RELATION_CURSOR_VERSION_2));
      240 
      241       dm_area_ptr = get_dm_free_area_ ();
      242       on cleanup call FINISH;
      243 
      244 GET_OPENING_INFO_STRUCTURES:
      245       do;
      246 
      247          call rlm_opening_info$get (relation_cursor.file_opening_id, relation_opening_info_ptr, code);
      248          if code ^= 0
      249          then call ERROR_RETURN (code);
      250          call CHECK_VERSION ("relation_opening_info", relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2);
      251          relation_header_ptr = relation_opening_info.relation_header_ptr;
      252          call CHECK_VERSION ("relation_header", relation_header.version, RELATION_HEADER_VERSION_3);
      253          attribute_info_ptr = relation_opening_info.attribute_info_ptr;
      254          call CHECK_VERSION ("attribute_info", attribute_info.version, ATTRIBUTE_INFO_VERSION_1);
      255          index_attribute_map_ptr = relation_opening_info.index_attribute_map_ptr;
      256          call CHECK_VERSION ("index_attribute_map", index_attribute_map.version, INDEX_ATTRIBUTE_MAP_VERSION_2);
      257          index_cursor_array_ptr = relation_opening_info.per_process.index_cursor_array_ptr;
      258          call CHECK_VERSION ("index_cursor_array", index_cursor_array.version, INDEX_CURSOR_ARRAY_VERSION_1);
      259 
      260       end GET_OPENING_INFO_STRUCTURES;
      261 
      262 GET_CURSORS:
      263       do;
      264 
      265          record_cursor_ptr = SET_RECORD_COLLECTION_CURSOR_PTR (relation_cursor_ptr, relation_header.record_collection_id);
      266 
      267          do index_idx = 1 to hbound (index_attribute_map.index, 1);
      268 	  call SET_CURSOR_PTR_FOR_THIS_INDEX (index_idx);
      269          end;
      270 
      271       end GET_CURSORS;
      272 
      273       call INIT_SPEC (key_spec_ptr, index_attribute_map_ptr, dm_area_ptr);
      274 
      275       if delete
      276       then
      277 DELETE:
      278          do;
      279 	  if process_single_tuple
      280 	  then
      281 	     do;
      282 	        tuple_id = p_tuple_id;
      283 	        call DELETE_TUPLE (tuple_id, old_record_ptr, key_spec_ptr, index_attribute_map_ptr,
      284 		   index_cursor_array_ptr, record_cursor_ptr, dm_area_ptr);
      285 	     end;
      286 	  else
      287 	     do;
      288 	        tuple_id = element_id_list.id (1);
      289 	        call DELETE_TUPLE (tuple_id, old_record_ptr, key_spec_ptr, index_attribute_map_ptr,
      290 		   index_cursor_array_ptr, record_cursor_ptr, dm_area_ptr);
      291 	        number_of_tuples_processed = 1;
      292 	        call BUILD_RECORD_TEMPLATE (old_record_ptr, dm_area_ptr, attribute_info_ptr);
      293 	        do tuple_idx = 2 to number_of_tuples_to_process;
      294 		 tuple_id = element_id_list.id (tuple_idx);
      295 		 call DELETE_TUPLE (tuple_id, old_record_ptr, key_spec_ptr, index_attribute_map_ptr,
      296 		      index_cursor_array_ptr, record_cursor_ptr, dm_area_ptr);
      297 		 number_of_tuples_processed = number_of_tuples_processed + 1;
      298 	        end;
      299 	     end;
      300          end DELETE;
      301       else
      302 MODIFY:
      303          do;
      304 	  stv_number_of_dimensions = index_attribute_map.maximum_number_of_attributes_per_index + 1;
      305 	  alloc simple_typed_vector in (dm_area) set (key_ptr);
      306 	  key_ptr -> simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
      307 
      308 	  if process_single_tuple
      309 	  then
      310 	     do;
      311 	        tuple_id = p_tuple_id;
      312 	        call MODIFY_TUPLE (tuple_id, old_record_ptr, new_record_ptr, key_ptr, general_typed_vector_ptr,
      313 		   key_spec_ptr, index_attribute_map_ptr, index_cursor_array_ptr, record_cursor_ptr, dm_area_ptr);
      314 	     end;
      315 	  else
      316 	     do;
      317 	        tuple_id = element_id_list.id (1);
      318 	        call MODIFY_TUPLE (tuple_id, old_record_ptr, new_record_ptr, key_ptr, general_typed_vector_ptr,
      319 		   key_spec_ptr, index_attribute_map_ptr, index_cursor_array_ptr, record_cursor_ptr, dm_area_ptr);
      320 	        number_of_tuples_processed = 1;
      321 	        call BUILD_RECORD_TEMPLATE (old_record_ptr, dm_area_ptr, attribute_info_ptr);
      322 	        do tuple_idx = 2 to number_of_tuples_to_process;
      323 		 tuple_id = element_id_list.id (tuple_idx);
      324 		 call MODIFY_TUPLE (tuple_id, old_record_ptr, new_record_ptr, key_ptr, general_typed_vector_ptr,
      325 		      key_spec_ptr, index_attribute_map_ptr, index_cursor_array_ptr, record_cursor_ptr, dm_area_ptr);
      326 		 number_of_tuples_processed = number_of_tuples_processed + 1;
      327 	        end;
      328 	     end;
      329          end MODIFY;
      330 
      331 
      332       call FINISH ();
      333 MAIN_RETURN:
      334       return;




      335 
      336 FINISH:
      337    proc ();
      338       if ^process_single_tuple
      339       then p_number_of_tuples_processed = number_of_tuples_processed;
      340 
      341       if key_ptr ^= null
      342       then
      343          do;
      344 	  key_ptr -> simple_typed_vector.number_of_dimensions =
      345 	       index_attribute_map.maximum_number_of_attributes_per_index + 1;
      346 	  free key_ptr -> simple_typed_vector in (dm_area);
      347          end;
      348 
      349       if old_record_ptr ^= null
      350       then call FREE_SIMPLE_TYPED_VECTOR (old_record_ptr);	/* Free vector and targets of value_ptrs */
      351 
      352       if new_record_ptr ^= null
      353       then free new_record_ptr -> simple_typed_vector in (dm_area);
      354 						/* Don't free targets of value_ptrs */
      355 
      356       if key_spec_ptr ^= null
      357       then free key_spec_ptr -> search_specification in (dm_area);
      358 
      359       if record_cursor_ptr ^= null & record_cursor_ptr ^= relation_cursor.current.cursor_ptr
      360       then call record_manager_$destroy_cursor (record_cursor_ptr, (0));
      361 
      362    end FINISH;




      363 
      364 ERROR_RETURN:
      365    proc (er_p_code);
      366 
      367       dcl	    er_p_code	       fixed bin (35);
      368 
      369       p_code = er_p_code;
      370       call FINISH ();
      371       goto MAIN_RETURN;
      372 
      373    end ERROR_RETURN;
      374 
      375 BUILD_KEY:
      376    proc (bk_p_key_ptr, bk_p_old_record_ptr, bk_p_new_record_ptr, bk_p_record_id_ptr, bk_p_iam_ptr, bk_p_index_idx,
      377         bk_p_index_field_is_modified);
      378 
      379 /* DESCRIPTION
      380*        This routine builds a key from the values in a record/tuple which
      381*   is appropriate for the given index. */
      382 
      383       dcl	    bk_p_key_ptr	       ptr parameter;
      384       dcl	    bk_p_old_record_ptr    ptr parameter;
      385       dcl	    bk_p_new_record_ptr    ptr parameter;
      386       dcl	    bk_p_record_id_ptr     ptr parameter;
      387       dcl	    bk_p_iam_ptr	       ptr parameter;
      388       dcl	    bk_p_index_idx	       fixed bin parameter;
      389       dcl	    bk_p_index_field_is_modified
      390 			       bit (1) aligned parameter;
      391 
      392       dcl	    bk_field_idx	       fixed bin;
      393       dcl	    bk_record_field_idx    fixed bin;
      394       dcl	    bk_old_value_ptr       ptr;
      395       dcl	    bk_new_value_ptr       ptr;
      396 
      397       bk_p_index_field_is_modified = FALSE;
      398       bk_p_key_ptr -> simple_typed_vector.number_of_dimensions =
      399 	 bk_p_iam_ptr -> index_attribute_map.index (bk_p_index_idx).number_of_attributes + 1;
      400 BK_FIELD_LOOP:
      401       do bk_field_idx = 1 to bk_p_iam_ptr -> index_attribute_map.index (bk_p_index_idx).number_of_attributes;
      402          bk_record_field_idx = bk_p_iam_ptr -> index_attribute_map.index (bk_p_index_idx).attribute_id (bk_field_idx);
      403          bk_old_value_ptr = bk_p_old_record_ptr -> simple_typed_vector.dimension (bk_record_field_idx).value_ptr;
      404          bk_new_value_ptr = bk_p_new_record_ptr -> simple_typed_vector.dimension (bk_record_field_idx).value_ptr;
      405          bk_p_key_ptr -> simple_typed_vector.dimension (bk_field_idx).value_ptr = bk_new_value_ptr;
      406          if bk_new_value_ptr ^= bk_old_value_ptr
      407          then bk_p_index_field_is_modified = TRUE;
      408       end BK_FIELD_LOOP;
      409 
      410       bk_p_key_ptr -> simple_typed_vector.dimension (bk_field_idx).value_ptr = bk_p_record_id_ptr;
      411 
      412       return;
      413 
      414    end BUILD_KEY;
      415 
      416 BUILD_RECORD:
      417    proc (br_p_old_record_ptr, br_p_new_record_ptr, br_p_gtv_ptr, br_p_area_ptr);
      418 
      419 /* This routine builds a record containing the modified field values. */
      420 
      421       dcl	    (
      422 	    br_p_old_record_ptr    ptr,
      423 	    br_p_new_record_ptr    ptr,
      424 	    br_p_gtv_ptr	       ptr,
      425 	    br_p_area_ptr	       ptr
      426 	    )		       parameter;
      427 
      428       dcl	    br_dim_idx	       fixed bin;
      429       dcl	    br_field_idx	       fixed bin;
      430       dcl	    br_field_value_ptr     ptr;
      431 
      432       if br_p_new_record_ptr = null ()
      433       then
      434 BR_ALLOC_NEW_RECORD:
      435          do;
      436 	  stv_number_of_dimensions = br_p_old_record_ptr -> simple_typed_vector.number_of_dimensions;
      437 	  alloc simple_typed_vector in (br_p_area_ptr -> dm_area) set (br_p_new_record_ptr);
      438          end BR_ALLOC_NEW_RECORD;
      439 
      440       br_p_new_record_ptr -> simple_typed_vector = br_p_old_record_ptr -> simple_typed_vector;
      441 
      442 BR_DIMENSION_LOOP:
      443       do br_dim_idx = 1 to hbound (br_p_gtv_ptr -> general_typed_vector.dimension, 1);
      444          br_field_idx = br_p_gtv_ptr -> general_typed_vector.dimension (br_dim_idx).identifier;
      445          br_field_value_ptr = br_p_gtv_ptr -> general_typed_vector.dimension (br_dim_idx).value_ptr;
      446 
      447          if br_field_idx > 0
      448          then br_p_new_record_ptr -> simple_typed_vector.dimension (br_field_idx).value_ptr = br_field_value_ptr;
      449 
      450       end BR_DIMENSION_LOOP;
      451 
      452       return;
      453 
      454    end BUILD_RECORD;
      455 
      456 BUILD_RECORD_TEMPLATE:
      457    proc (brt_p_record_ptr, brt_p_area_ptr, brt_p_attr_info_ptr);
      458 
      459 /* This routine takes the pointer to a record simple_typed_vector and */
      460 /* converts it into one which has value_ptrs pointing to maximum sized */
      461 /* values so that the record can be used as input to record_manager_   */
      462 /* get_record_by_id entry.  This means finding the varying length      */
      463 /* values, freeing them, and re-allocating them at the maximum length. */
      464 
      465       dcl	    (
      466 	    brt_p_record_ptr       ptr,
      467 	    brt_p_area_ptr	       ptr,
      468 	    brt_p_attr_info_ptr    ptr
      469 	    )		       parameter;
      470 
      471       dcl	    brt_template_length    fixed bin (35);
      472       dcl	    brt_template_ptr       ptr;
      473       dcl	    brt_char_var_template  aligned char (brt_template_length) varying based (brt_template_ptr);
      474       dcl	    brt_bit_var_template   aligned bit (brt_template_length) varying based (brt_template_ptr);
      475       dcl	    brt_attr_idx	       fixed bin;
      476       dcl	    1 brt_descriptor       aligned like arg_descriptor;
      477 
      478 BRT_ATTRIBUTE_LOOP:
      479       do brt_attr_idx = 1 to brt_p_attr_info_ptr -> attribute_info.number_of_attributes;
      480          unspec (brt_descriptor) = brt_p_attr_info_ptr -> attribute_info.attribute (brt_attr_idx).descriptor;
      481          if brt_descriptor.type = varying_char_dtype
      482          then
      483 BRT_CHAR_VARYING:
      484 	  do;
      485 	     brt_template_length = 1 /* the length doesn't matter to free */;
      486 	     free brt_p_record_ptr -> simple_typed_vector.dimension (brt_attr_idx).value_ptr -> brt_char_var_template;
      487 	     brt_template_length = brt_descriptor.size;
      488 	     alloc brt_char_var_template in (brt_p_area_ptr -> dm_area) set (brt_template_ptr);
      489 	     brt_p_record_ptr -> simple_typed_vector.dimension (brt_attr_idx).value_ptr = brt_template_ptr;
      490 	  end BRT_CHAR_VARYING;
      491          else if brt_descriptor.type = varying_bit_dtype
      492          then
      493 BRT_BIT_VARYING:
      494 	  do;
      495 	     brt_template_length = 1 /* the length doesn't matter to free */;
      496 	     free brt_p_record_ptr -> simple_typed_vector.dimension (brt_attr_idx).value_ptr -> brt_bit_var_template;
      497 	     brt_template_length = brt_descriptor.size;
      498 	     alloc brt_bit_var_template in (brt_p_area_ptr -> dm_area) set (brt_template_ptr);
      499 	     brt_p_record_ptr -> simple_typed_vector.dimension (brt_attr_idx).value_ptr = brt_template_ptr;
      500 	  end BRT_BIT_VARYING;
      501          else
      502 BRT_FIXED_SIZE:					/* the existing is fixed size */
      503 	  ;
      504       end BRT_ATTRIBUTE_LOOP;
      505 
      506    end BUILD_RECORD_TEMPLATE;
      507 
      508 BUILD_SPEC:
      509    proc (bs_spec_ptr, bs_p_record_ptr, bs_p_record_id_ptr, bs_p_iam_ptr, bs_p_index_idx);
      510 
      511 /* DESCRIPTION
      512*        This routine builds a specification from the values in a record/tuple
      513*   which represents an exact match of the appropriate key in the given index. */
      514 
      515       dcl	    bs_spec_ptr	       ptr parameter;
      516       dcl	    bs_p_record_ptr	       ptr parameter;
      517       dcl	    bs_p_record_id_ptr     ptr parameter;
      518       dcl	    bs_p_iam_ptr	       ptr parameter;
      519       dcl	    bs_p_index_idx	       fixed bin parameter;
      520 
      521       dcl	    bs_field_idx	       fixed bin;
      522 
      523 BS_FIELD_LOOP:
      524       do bs_field_idx = 1 to bs_p_iam_ptr -> index_attribute_map.index (bs_p_index_idx).number_of_attributes;
      525          bs_spec_ptr -> search_specification.and_group (1).constraint (bs_field_idx).value_ptr =
      526 	    bs_p_record_ptr
      527 	    -> simple_typed_vector
      528 	    .dimension (bs_p_iam_ptr -> index_attribute_map.index (bs_p_index_idx).attribute_id (bs_field_idx))
      529 	    .value_ptr;
      530       end BS_FIELD_LOOP;
      531       bs_spec_ptr -> search_specification.and_group (1).constraint (bs_field_idx).value_ptr = bs_p_record_id_ptr;
      532       bs_spec_ptr -> search_specification.and_group (1).number_of_constraints = bs_field_idx;
      533 
      534       return;
      535 
      536    end BUILD_SPEC;




      537 
      538 INIT_SPEC:
      539    proc (is_p_spec_ptr, is_p_iam_ptr, is_p_area_ptr);
      540 
      541       dcl	    (
      542 	    is_p_spec_ptr	       ptr,
      543 	    is_p_iam_ptr	       ptr,
      544 	    is_p_area_ptr	       ptr
      545 	    )		       parameter;
      546       dcl	    is_field_idx	       fixed bin (17);
      547 
      548       ss_number_of_and_groups = 1;
      549       ss_maximum_number_of_constraints = is_p_iam_ptr -> index_attribute_map.maximum_number_of_attributes_per_index + 1;
      550 
      551       alloc search_specification in (is_p_area_ptr -> dm_area) set (is_p_spec_ptr);
      552 
      553       is_p_spec_ptr -> search_specification.head.version = SPECIFICATION_VERSION_4;
      554       is_p_spec_ptr -> search_specification.head.type = ABSOLUTE_SEARCH_SPECIFICATION_TYPE;
      555       is_p_spec_ptr -> search_specification.head.subset_specification_ptr = null;
      556       is_p_spec_ptr -> search_specification.range.type = ALL_RANGE_TYPE;
      557       is_p_spec_ptr -> search_specification.range.size = 0;
      558       is_p_spec_ptr -> search_specification.and_group (1).constraint (*).operator_code = EQUAL_OPERATOR_CODE;
      559       is_p_spec_ptr -> search_specification.and_group (1).constraint (*).value_field_id = -1;
      560 
      561       do is_field_idx = 1 to is_p_spec_ptr -> search_specification.maximum_number_of_constraints;
      562          is_p_spec_ptr -> search_specification.and_group (1).constraint (is_field_idx).field_id = is_field_idx;
      563       end;
      564 
      565       return;
      566 
      567    end INIT_SPEC;
      568 
      569 CHECK_VERSION:
      570    proc (cv_p_structure_name, cv_p_received_version, cv_p_expected_version);
      571 
      572       dcl	    cv_p_received_version  char (8) aligned;
      573       dcl	    cv_p_expected_version  char (8) aligned;
      574       dcl	    cv_p_structure_name    char (*);
      575 
      576       if cv_p_received_version ^= cv_p_expected_version
      577       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      578 	      "^/Expected version ^8a of the ^a structure.
      579 Received version ^8a, instead.", cv_p_expected_version, cv_p_structure_name, cv_p_received_version);
      580 
      581    end CHECK_VERSION;




      582 
      583 CHECK_VERSION_FB:
      584    proc (cvf_p_structure_name, cvf_p_received_version, cvf_p_expected_version);
      585 
      586       dcl	    cvf_p_received_version fixed bin (35);
      587       dcl	    cvf_p_expected_version fixed bin (35);
      588       dcl	    cvf_p_structure_name   char (*);
      589 
      590       if cvf_p_received_version ^= cvf_p_expected_version
      591       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      592 	      "^/Expected version ^d of the ^a structure.
      593 Received version ^d, instead.", cvf_p_expected_version, cvf_p_structure_name, cvf_p_received_version);
      594 
      595    end CHECK_VERSION_FB;
      596 
      597 DELETE_TUPLE:
      598    proc (dt_p_record_id, dt_p_record_ptr, dt_p_spec_ptr, dt_p_iam_ptr, dt_p_ica_ptr, dt_p_record_cursor_ptr,
      599         dt_p_area_ptr);
      600 
      601       dcl	    dt_p_record_id	       bit (36) aligned parameter;
      602       dcl	    dt_p_record_ptr	       ptr parameter;
      603       dcl	    dt_p_record_cursor_ptr ptr parameter;
      604       dcl	    dt_p_spec_ptr	       ptr parameter;
      605       dcl	    dt_p_iam_ptr	       ptr parameter;
      606       dcl	    dt_p_ica_ptr	       ptr parameter;
      607       dcl	    dt_p_area_ptr	       ptr parameter;
      608 
      609 
      610       dcl	    dt_code	       fixed bin (35);
      611       dcl	    dt_index_idx	       fixed bin;
      612       dcl	    dt_index_cursor_ptr    ptr init (null ());
      613 
      614       dt_code = 0;
      615 
      616       call record_manager_$get_record_by_id (dt_p_record_id, null (), dt_p_area_ptr, dt_p_record_cursor_ptr,
      617 	 dt_p_record_ptr, dt_code);
      618       if dt_code ^= 0
      619       then if dt_code = dm_error_$record_not_found
      620 	 then if TUPLE_ALREADY_PROCESSED (dt_p_record_id) = TRUE
      621 	      then return /* caller supplied id twice */;
      622 	      else call ERROR_RETURN (dm_error_$tuple_not_found_id);
      623 	 else call ERROR_RETURN (dt_code);
      624 
      625 
      626       do dt_index_idx = 1 to hbound (dt_p_iam_ptr -> index_attribute_map.index, 1);
      627 
      628          if dt_p_iam_ptr -> index_attribute_map.index (dt_index_idx).number_of_attributes > 0
      629          then
      630 	  do;
      631 	     dt_index_cursor_ptr = dt_p_ica_ptr -> index_cursor_array.cursor_ptr (dt_index_idx);
      632 	     call BUILD_SPEC (dt_p_spec_ptr, dt_p_record_ptr, addr (dt_p_record_id), dt_p_iam_ptr, dt_index_idx);
      633 	     call index_manager_$delete_key (dt_p_spec_ptr, dt_p_area_ptr, dt_index_cursor_ptr, (0), dt_code);
      634 	     if dt_code ^= 0
      635 	     then if dt_code = dm_error_$key_not_found
      636 		then dt_code = 0;
      637 		else call ERROR_RETURN (dt_code);
      638 	  end;
      639       end;
      640 
      641       call record_manager_$delete_record_by_id (dt_p_record_id, dt_p_record_cursor_ptr, dt_code);
      642       if dt_code ^= 0
      643       then call ERROR_RETURN (dt_code);
      644 
      645       return;
      646 
      647    end DELETE_TUPLE;
      648 
      649 FREE_SIMPLE_TYPED_VECTOR:
      650    proc (fstv_p_vector_ptr);
      651 
      652       dcl	    fstv_p_vector_ptr      ptr parameter;
      653 
      654       dcl	    fstv_vector_ptr	       ptr;
      655       dcl	    fstv_descriptor_string bit (36) aligned based;
      656       dcl	    fstv_dimension_idx     fixed bin;
      657       dcl	    fstv_storage_size      fixed bin (35);
      658       dcl	    fstv_storage_string    bit (fstv_storage_size) aligned based;
      659       dcl	    fstv_current_value_ptr ptr init (null);
      660       dcl	    fstv_based_real_fixed_bin_1u
      661 			       based fixed bin (35) unaligned;
      662 
      663       fstv_vector_ptr = fstv_p_vector_ptr;
      664       fstv_p_vector_ptr = null ();			/* So we don't try again */
      665 
      666       do fstv_dimension_idx = 1 to fstv_vector_ptr -> simple_typed_vector.number_of_dimensions;
      667          arg_descriptor_ptr = addr (attribute_info.attribute (fstv_dimension_idx).descriptor);
      668          fstv_current_value_ptr = fstv_vector_ptr -> simple_typed_vector.dimension (fstv_dimension_idx).value_ptr;
      669          if arg_descriptor.type = varying_char_dtype
      670          then fstv_storage_size = fstv_current_value_ptr -> fstv_based_real_fixed_bin_1u * BITS_PER_BYTE + BITS_PER_WORD;
      671          else if arg_descriptor.type = varying_bit_dtype
      672          then fstv_storage_size = fstv_current_value_ptr -> fstv_based_real_fixed_bin_1u + BITS_PER_WORD;
      673          else call data_format_util_$get_data_bit_length (arg_descriptor_ptr -> fstv_descriptor_string, fstv_storage_size,
      674 	         (0));
      675 
      676          free fstv_current_value_ptr -> fstv_storage_string in (dm_area);
      677       end;
      678 
      679       free fstv_vector_ptr -> simple_typed_vector in (dm_area);
      680 
      681       return;
      682 
      683    end FREE_SIMPLE_TYPED_VECTOR;
      684 
      685 MODIFY_TUPLE:
      686    proc (mt_p_record_id, mt_p_old_record_ptr, mt_p_new_record_ptr, mt_p_key_ptr, mt_p_gtv_ptr, mt_p_spec_ptr,
      687         mt_p_iam_ptr, mt_p_ica_ptr, mt_p_record_cursor_ptr, mt_p_area_ptr);
      688 
      689       dcl	    mt_p_record_id	       bit (36) aligned parameter;
      690       dcl	    mt_p_old_record_ptr    ptr parameter;
      691       dcl	    mt_p_new_record_ptr    ptr parameter;
      692       dcl	    mt_p_record_cursor_ptr ptr parameter;
      693       dcl	    mt_p_key_ptr	       ptr parameter;
      694       dcl	    mt_p_gtv_ptr	       ptr parameter;
      695       dcl	    mt_p_spec_ptr	       ptr parameter;
      696       dcl	    mt_p_iam_ptr	       ptr parameter;
      697       dcl	    mt_p_ica_ptr	       ptr parameter;
      698       dcl	    mt_p_area_ptr	       ptr parameter;
      699 
      700       dcl	    mt_code	       fixed bin (35);
      701       dcl	    mt_index_idx	       fixed bin;
      702       dcl	    mt_key_must_be_modified
      703 			       bit (1) aligned;
      704       dcl	    mt_index_cursor_ptr    ptr;
      705 
      706       mt_code = 0;
      707 
      708       call record_manager_$get_record_by_id (mt_p_record_id, null (), mt_p_area_ptr, mt_p_record_cursor_ptr,
      709 	 mt_p_old_record_ptr, mt_code);
      710       if mt_code ^= 0
      711       then if mt_code = dm_error_$record_not_found
      712 	 then call ERROR_RETURN (dm_error_$tuple_not_found_id);
      713 	 else call ERROR_RETURN (mt_code);
      714 
      715       call BUILD_RECORD (mt_p_old_record_ptr, mt_p_new_record_ptr, mt_p_gtv_ptr, mt_p_area_ptr);
      716 
      717 
      718       do mt_index_idx = 1 to hbound (mt_p_iam_ptr -> index_attribute_map.index, 1);
      719 
      720          if mt_p_iam_ptr -> index_attribute_map.index (mt_index_idx).number_of_attributes > 0
      721          then
      722 	  do;
      723 	     call BUILD_KEY (mt_p_key_ptr, mt_p_old_record_ptr, mt_p_new_record_ptr, addr (mt_p_record_id),
      724 		mt_p_iam_ptr, mt_index_idx, mt_key_must_be_modified);
      725 	     if mt_key_must_be_modified = TRUE
      726 	     then
      727 	        do;
      728 		 mt_index_cursor_ptr = mt_p_ica_ptr -> index_cursor_array.cursor_ptr (mt_index_idx);
      729 		 call BUILD_SPEC (mt_p_spec_ptr, mt_p_old_record_ptr, addr (mt_p_record_id), mt_p_iam_ptr,
      730 		      mt_index_idx);
      731 		 call index_manager_$delete_key (mt_p_spec_ptr, mt_p_area_ptr, mt_index_cursor_ptr, (0), mt_code);
      732 		 if mt_code ^= 0
      733 		 then call ERROR_RETURN (mt_code);
      734 		 call index_manager_$put_key (mt_p_key_ptr, mt_index_cursor_ptr, mt_code);
      735 		 if mt_code ^= 0
      736 		 then if mt_code = dm_error_$key_duplication
      737 		      then
      738 		         do;
      739 			  call ROLLBACK_TUPLE (mt_p_record_id, mt_p_old_record_ptr, mt_p_new_record_ptr,
      740 			       mt_p_key_ptr, mt_p_spec_ptr, mt_p_iam_ptr, mt_p_ica_ptr, mt_p_area_ptr,
      741 			       (mt_index_idx - 1));
      742 			  call ERROR_RETURN (mt_code);
      743 		         end;
      744 	        end;
      745 	  end;
      746       end;
      747 
      748       call record_manager_$modify_record_by_id (mt_p_record_id, mt_p_gtv_ptr, mt_p_record_cursor_ptr, mt_code);
      749       if mt_code ^= 0
      750       then call ERROR_RETURN (mt_code);
      751 
      752       return;
      753 
      754    end MODIFY_TUPLE;
      755 
      756 ROLLBACK_TUPLE:
      757    proc (rt_p_record_id, rt_p_old_record_ptr, rt_p_new_record_ptr, rt_p_key_ptr, rt_p_spec_ptr, rt_p_iam_ptr,
      758         rt_p_ica_ptr, rt_p_area_ptr, rt_p_last_modified_index);
      759 
      760       dcl	    rt_p_record_id	       bit (36) aligned parameter;
      761       dcl	    rt_p_old_record_ptr    ptr parameter;
      762       dcl	    rt_p_new_record_ptr    ptr parameter;
      763       dcl	    rt_p_key_ptr	       ptr parameter;
      764       dcl	    rt_p_spec_ptr	       ptr parameter;
      765       dcl	    rt_p_iam_ptr	       ptr parameter;
      766       dcl	    rt_p_ica_ptr	       ptr parameter;
      767       dcl	    rt_p_area_ptr	       ptr parameter;
      768       dcl	    rt_p_last_modified_index
      769 			       fixed bin parameter;
      770 
      771       dcl	    rt_code	       fixed bin (35);
      772       dcl	    rt_index_idx	       fixed bin;
      773       dcl	    rt_key_must_be_modified
      774 			       bit (1) aligned;
      775       dcl	    rt_index_cursor_ptr    ptr;
      776 
      777 
      778       do rt_index_idx = 1 to rt_p_last_modified_index;
      779 
      780          if rt_p_iam_ptr -> index_attribute_map.index (rt_index_idx).number_of_attributes > 0
      781          then
      782 	  do;
      783 	     call BUILD_KEY (rt_p_key_ptr, rt_p_new_record_ptr, rt_p_old_record_ptr, addr (rt_p_record_id),
      784 		rt_p_iam_ptr, rt_index_idx, rt_key_must_be_modified);
      785 	     if rt_key_must_be_modified = TRUE
      786 	     then
      787 	        do;
      788 		 rt_index_cursor_ptr = rt_p_ica_ptr -> index_cursor_array.cursor_ptr (rt_index_idx);
      789 		 if rt_index_idx < rt_p_last_modified_index
      790 		 then
      791 RT_REMOVE_NEW_VALUE:
      792 		    do;
      793 		       call BUILD_SPEC (rt_p_spec_ptr, rt_p_new_record_ptr, addr (rt_p_record_id), rt_p_iam_ptr,
      794 			  rt_index_idx);
      795 		       call index_manager_$delete_key (rt_p_spec_ptr, rt_p_area_ptr, rt_index_cursor_ptr, (0),
      796 			  rt_code);
      797 		       if rt_code ^= 0
      798 		       then call ERROR_RETURN (rt_code);
      799 		    end RT_REMOVE_NEW_VALUE;
      800 RT_REPLACE_OLD_VALUE:
      801 		 do;
      802 		    call index_manager_$put_key (rt_p_key_ptr, rt_index_cursor_ptr, rt_code);
      803 		    if rt_code ^= 0
      804 		    then call ERROR_RETURN (rt_code);
      805 		 end RT_REPLACE_OLD_VALUE;
      806 	        end;
      807 	  end;
      808       end;
      809 
      810       return;
      811 
      812    end ROLLBACK_TUPLE;
      813 
      814 SET_RECORD_COLLECTION_CURSOR_PTR:
      815    proc (srccp_p_relation_cursor_ptr, srccp_p_record_collection_id) returns (ptr);
      816 
      817       dcl	    srccp_p_relation_cursor_ptr
      818 			       ptr parameter;
      819       dcl	    srccp_p_record_collection_id
      820 			       bit (36) aligned parameter;
      821 
      822       dcl	    srccp_record_collection_cursor_ptr
      823 			       ptr init (null);
      824       dcl	    srccp_code	       fixed bin (35) init (0);
      825 
      826       call record_manager_$create_cursor (srccp_p_relation_cursor_ptr -> relation_cursor.file_opening_id,
      827 	 srccp_p_record_collection_id, srccp_p_relation_cursor_ptr -> relation_cursor.work_area_ptr,
      828 	 srccp_record_collection_cursor_ptr, srccp_code);
      829       if srccp_code ^= 0
      830       then call ERROR_RETURN (srccp_code);
      831 
      832       return (srccp_record_collection_cursor_ptr);
      833 
      834    end SET_RECORD_COLLECTION_CURSOR_PTR;
      835 
      836 SET_CURSOR_PTR_FOR_THIS_INDEX:
      837    proc (scpfti_index_idx);
      838 
      839       dcl	    scpfti_index_idx       fixed bin (17);
      840       dcl	    scpfti_code	       fixed bin (35);
      841       dcl	    scpfti_index_cursor_ptr
      842 			       ptr;
      843 
      844       if index_attribute_map.index (scpfti_index_idx).number_of_attributes > 0
      845       then if index_cursor_array.cursor_ptr (scpfti_index_idx) = null
      846 	 then
      847 	    do;
      848 	       call index_manager_$create_cursor (relation_cursor.file_opening_id,
      849 		  index_attribute_map.index (scpfti_index_idx).collection_id, dm_area_ptr, scpfti_index_cursor_ptr,
      850 		  scpfti_code);
      851 	       if scpfti_code ^= 0
      852 	       then call ERROR_RETURN (scpfti_code);
      853 
      854 	       index_cursor_array.cursor_ptr (scpfti_index_idx) = scpfti_index_cursor_ptr;
      855 	    end;
      856 
      857       return;
      858 
      859    end SET_CURSOR_PTR_FOR_THIS_INDEX;
      860 
      861 TUPLE_ALREADY_PROCESSED:
      862    proc (tap_p_tuple_id) returns (bit (1) aligned);
      863 
      864 /* This routine checks to see if tap_p_tuple_id is duplicated
      865*   in the element_id_list.  Specifically, it goes from the current
      866*   entry in the element_id_list.id array backwards looking for a match.
      867*   Global variables are used, in particular element_id_list_ptr and
      868*   tuple_idx.  This is because this routine is called from inside of
      869*   DELETE_TUPLE and MODIFY_TUPLE, which by design have no knowledge of 
      870*   those variables. */
      871 
      872       dcl	    tap_p_tuple_id	       bit (36) aligned parameter;
      873 
      874       dcl	    tap_tuple_idx	       fixed bin (35);
      875 
      876       if element_id_list_ptr = null ()
      877       then return (FALSE);
      878 
      879       tap_tuple_idx = tuple_idx - 1;
      880       do tap_tuple_idx = tap_tuple_idx by -1 to 1 while (element_id_list.id (tap_tuple_idx) ^= tap_p_tuple_id);
      881       end;
      882       if tap_tuple_idx >= 1
      883       then return (TRUE);
      884       else return (FALSE);
      885 
      886    end TUPLE_ALREADY_PROCESSED;
      887 
  1     1 /* BEGIN INCLUDE FILE dm_rlm_cursor.incl.pl1 */
  1     2 
  1     3 /* HISTORY:
  1     4*
  1     5*Written by Matthew Pierret, 05/19/83. 
  1     6*Modified:
  1     7*06/24/83 by Lindsey L. Spratt:  Changed to version 2.  Added the current.flags
  1     8*            structure, to add the search_index_and_record_collection flag.
  1     9*            This flag is only meaningful when doing a relative search.  It is
  1    10*            used by rlm_general_search to know what state the
  1    11*            internal_search_specification was left in (suitable for searching
  1    12*            the index or suitable for searching the records).
  1    13*10/29/84 by Stanford S. Cox:  Changed to not init version.
  1    14*02/12/85 by S. Cox:  Chg and_group_idx to fb17, current.flags.mbz to bit35.
  1    15**/
  1    16 
  1    17 /* format: style2,ind3 */
  1    18      dcl	   1 relation_cursor      aligned based (relation_cursor_ptr),
  1    19 	     2 version	      char (8),		/* version of this structure */
  1    20 	     2 work_area_ptr      ptr init (null),	/* points to area in which cursor is allocated. */
  1    21 	     2 file_opening_id    bit (36) aligned init ("0"b),
  1    22 						/* opening id of file in which relation resides */
  1    23 	     2 flags	      aligned,
  1    24 	       3 current_state_is_consistent
  1    25 			      bit (1) unal init ("0"b),
  1    26 						/* On if all values in current are insynch */
  1    27 	       3 mbz	      bit (35) unal init ("0"b),
  1    28 						/* must be zero */
  1    29 	     2 current,				/* current position in search */
  1    30 	       3 and_group_idx    fixed bin (17) aligned init (0),
  1    31 						/* in relation_search_specification */
  1    32 	       3 flags	      aligned,
  1    33 	         4 search_index_and_record_collection
  1    34 			      bit (1) unal init ("0"b),
  1    35 	         4 mbz	      bit (35) unal init ("0"b),
  1    36 	       3 collection_id    bit (36) aligned init ("0"b),
  1    37 						/* that cursor is define over */
  1    38 	       3 specification_ptr
  1    39 			      ptr init (null),	/* points to index or record specification */
  1    40 	       3 cursor_ptr	      ptr init (null);	/* points to index or record cursor */
  1    41 
  1    42      dcl	   relation_cursor_ptr    ptr init (null);
  1    43      dcl	   RELATION_CURSOR_VERSION_2
  1    44 			      init ("relcrs02") char (8) aligned internal static options (constant);
  1    45 
  1    46 /* END INCLUDE FILE dm_rlm_cursor.incl.pl1 */
      888 
      889 
  2     1 /* BEGIN INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
  2     2 
  2     3 /* Written by Matthew Pierret, 09/08/82. 
  2     4*Modified:
  2     5*01/18/83 by Matthew Pierret:  Changed version to be char (8). Added 
  2     6*            transaction_id.
  2     7*02/25/83 by Matthew Pierret:  Changed to relation_opening_info (from
  2     8*            relation_info).
  2     9*10/29/84 by Stanford S. Cox:  Changed to not init version.
  2    10**/
  2    11 
  2    12 
  2    13 /* format: style2,ind3 */
  2    14 
  2    15      dcl	   1 relation_opening_info
  2    16 			      aligned based (relation_opening_info_ptr),
  2    17 	     2 version	      char (8),
  2    18 	     2 per_process,
  2    19 	       3 current_transaction_id
  2    20 			      bit (36) aligned init ("0"b),
  2    21 	       3 current_rollback_count
  2    22 			      fixed bin (35) init (0),
  2    23 	       3 file_opening_id  bit (36) aligned init ("0"b),
  2    24 	       3 number_of_openings
  2    25 			      fixed bin (17) aligned init (0),
  2    26 	       3 lock_advice      aligned,
  2    27 	         4 this_process   bit (2) unaligned init ("0"b),
  2    28 	         4 other_processes
  2    29 			      bit (2) unaligned init ("0"b),
  2    30 	         4 mbz1	      bit (32) unaligned init ("0"b),
  2    31 	       3 record_cursor_ptr
  2    32 			      ptr init (null),
  2    33 	       3 index_cursor_array_ptr
  2    34 			      ptr init (null),
  2    35 	     2 relation_header_ptr
  2    36 			      ptr init (null),
  2    37 	     2 attribute_info_ptr ptr init (null),
  2    38 	     2 index_attribute_map_ptr
  2    39 			      ptr init (null);
  2    40 
  2    41      dcl	   relation_opening_info_ptr
  2    42 			      ptr;
  2    43      dcl	   RELATION_OPENING_INFO_VERSION_2
  2    44 			      init ("rlmopen2") char (8) aligned internal static options (constant);
  2    45 
  2    46 
  2    47 /* END INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
      890 
      891 
  3     1 /* BEGIN INCLUDE FILE - dm_rlm_header.incl.pl1 */
  3     2 
  3     3 /* HISTORY:
  3     4*Written by Matthew Pierret, 1982.
  3     5*Modified:
  3     6*02/25/83 by Matthew Pierret: Added attribute_info_element_id, 
  3     7*            header_info_update_count, RELATION_HEADER_VERSION_2.
  3     8*05/29/84 by Matthew Pierret: Added caller_header_element_id, 
  3     9*            RELATION_HEADER_VERSION_3.
  3    10*10/29/84 by Stanford S. Cox:  Changed to not init version.
  3    11**/
  3    12 
  3    13 /* format: style2,ind3 */
  3    14 
  3    15      dcl	   1 relation_header      aligned based (relation_header_ptr),
  3    16 	     2 version	      char (8),
  3    17 	     2 header_info_update_count
  3    18 			      fixed bin (35) aligned init (0),
  3    19 	     2 record_collection_id
  3    20 			      bit (36) aligned init ("0"b),
  3    21 	     2 cluster_index_id   bit (36) aligned init ("0"b),
  3    22 	     2 attribute_info_element_id
  3    23 			      bit (36) aligned init ("0"b),
  3    24 	     2 index_attribute_map_element_id
  3    25 			      bit (36) aligned init ("0"b),
  3    26 	     2 caller_header_element_id
  3    27 			      bit (36) aligned init ("0"b);
  3    28 
  3    29      dcl	   relation_header_ptr    ptr init (null);
  3    30      dcl	   RELATION_HEADER_VERSION_3
  3    31 			      init ("RelHdr 3") char (8) aligned internal static options (constant);
  3    32 
  3    33 /* END INCLUDE FILE - dm_rlm_header.incl.pl1 */
      892 
      893 
  4     1 /* BEGIN INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION
  4     4*        
  4     5*   Relation attributes descriptor and name.  This info is kept in the header
  4     6*   collection of existing files, therefore this incl should not be changed.
  4     7**/
  4     8 
  4     9 /* HISTORY:
  4    10*Written by Matthew Pierret, 02/25/83.
  4    11*Modified:
  4    12*10/29/84 by Stanford S. Cox:  Changed to not init version.
  4    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  4    14*   which were incompatible with existing DM files.        
  4    15**/
  4    16 
  4    17 /* format: style2,ind3 */
  4    18      dcl	   1 attribute_info	      aligned based (attribute_info_ptr),
  4    19 	     2 version	      char (8),
  4    20 	     2 number_of_attributes
  4    21 			      fixed bin (17) unal,
  4    22 	     2 maximum_attribute_name_length
  4    23 			      fixed bin (17) unal,
  4    24 	     2 attribute	      (ai_number_of_attributes refer (attribute_info.number_of_attributes)),
  4    25 	       3 descriptor	      bit (36) aligned,
  4    26 	       3 name	      char (ai_maximum_attribute_name_length
  4    27 			      refer (attribute_info.maximum_attribute_name_length)) varying;
  4    28 
  4    29      dcl	   attribute_info_ptr     ptr init (null);
  4    30      dcl	   ai_maximum_attribute_name_length
  4    31 			      fixed bin (17);
  4    32      dcl	   ai_number_of_attributes
  4    33 			      fixed bin (17);
  4    34      dcl	   ATTRIBUTE_INFO_VERSION_1
  4    35 			      init ("attrinf1") char (8) aligned internal static options (constant);
  4    36 
  4    37 /* END INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  4    38 
      894 
      895 
  5     1 /* BEGIN INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION
  5     4*        
  5     5*   Relation index components.  This info is kept in the header
  5     6*   collection of existing files, therefore this incl should not be changed.
  5     7**/
  5     8 
  5     9 /* HISTORY:
  5    10*Written by Matthew Pierret, 01/15/83.
  5    11*Modified:
  5    12*10/29/84 by Stanford S. Cox: Changed to not init version.
  5    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  5    14*   which were incompatible with existing DM files.        
  5    15**/
  5    16 
  5    17 /* format: style2,ind3 */
  5    18      dcl	   1 index_attribute_map  aligned based (index_attribute_map_ptr),
  5    19 	     2 version	      char (8),
  5    20 	     2 number_of_indices  fixed bin (17) unal init (0),
  5    21 	     2 maximum_number_of_indices
  5    22 			      fixed bin (17) unal,
  5    23 	     2 maximum_number_of_attributes_per_index
  5    24 			      fixed bin (17) unal,
  5    25 	     2 mbz	      fixed bin (17) unal,
  5    26 	     2 index	      (iam_maximum_number_of_indices refer (index_attribute_map.maximum_number_of_indices)),
  5    27 	       3 collection_id    bit (36) aligned,
  5    28 	       3 style	      fixed bin (17) unal,
  5    29 	       3 number_of_duplication_fields
  5    30 			      fixed bin (17) unal,
  5    31 	       3 number_of_attributes
  5    32 			      fixed bin (17) unal,
  5    33 	       3 attribute_id     (iam_maximum_number_of_attributes_per_index
  5    34 			      refer (index_attribute_map.maximum_number_of_attributes_per_index)) fixed
  5    35 			      bin (17) unal;
  5    36 
  5    37      dcl	   index_attribute_map_ptr
  5    38 			      ptr init (null);
  5    39      dcl	   iam_maximum_number_of_indices
  5    40 			      fixed bin (17);
  5    41      dcl	   iam_maximum_number_of_attributes_per_index
  5    42 			      fixed bin (17);
  5    43      dcl	   INDEX_ATTRIBUTE_MAP_VERSION_2
  5    44 			      init ("idx_map2") char (8) aligned internal static options (constant);
  5    45      dcl	   INITIAL_NUMBER_OF_INDICES
  5    46 			      init (5) fixed bin (17);
  5    47      dcl	   UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
  5    48 			      init (0) fixed bin (17);
  5    49 
  5    50 /* END INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
      896 
      897 
  6     1 /* BEGIN INCLUDE FILE dm_rlm_idx_cursor_array.incl.pl1 */
  6     2 
  6     3 /* HISTORY:
  6     4*Written by Matthew Pierret, 03/02/83. 
  6     5*Modified:
  6     6*10/30/84 by Stanford S. Cox: Changed to not init version.
  6     7**/
  6     8 
  6     9 /* format: style2,ind3 */
  6    10 
  6    11      dcl	   1 index_cursor_array   aligned based (index_cursor_array_ptr),
  6    12 	     2 version	      char (8),
  6    13 	     2 number_of_indices  fixed bin (35),
  6    14 	     2 mbz	      fixed bin (35) init (0),
  6    15 	     2 cursor_ptr	      (ica_number_of_indices refer (index_cursor_array.number_of_indices)) ptr;
  6    16 
  6    17      dcl	   index_cursor_array_ptr ptr init (null);
  6    18      dcl	   ica_number_of_indices  fixed bin (35) init (0);
  6    19      dcl	   INDEX_CURSOR_ARRAY_VERSION_1
  6    20 			      init ("ixcrsra1") char (8) aligned internal static options (constant);
  6    21 
  6    22 
  6    23 /* END INCLUDE FILE dm_rlm_idx_cursor_array.incl.pl1 */
      898 
      899 
  7     1 /* ***********************************************************
  7     2*   *                                                         *
  7     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  7     4*   *                                                         *
  7     5*   *********************************************************** */
  7     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  7     7 
  7     8 /* Written by Lindsey Spratt, 04/02/82.
  7     9*Modified:
  7    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  7    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  7    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  7    13*	  type.
  7    14**/
  7    15 
  7    16 /* format: style2,ind3 */
  7    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  7    18 	     2 type	      fixed bin (17) unal,
  7    19 	     2 number_of_dimensions
  7    20 			      fixed bin (17) unal,
  7    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  7    22 	       3 value_ptr	      ptr unaligned;
  7    23 
  7    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  7    25 	     2 type	      fixed bin (17) unal,
  7    26 	     2 number_of_dimensions
  7    27 			      fixed bin (17) unal,
  7    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  7    29 	       3 identifier	      fixed bin (17) unal,
  7    30 	       3 pad	      bit (18) unal,
  7    31 	       3 value_ptr	      ptr unal;
  7    32 
  7    33      dcl	   simple_typed_vector_ptr
  7    34 			      ptr;
  7    35      dcl	   stv_number_of_dimensions
  7    36 			      fixed bin (17);
  7    37 
  7    38      dcl	   general_typed_vector_ptr
  7    39 			      ptr;
  7    40      dcl	   gtv_number_of_dimensions
  7    41 			      fixed bin (17);
  7    42 
  7    43      dcl	   (
  7    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  7    45 			      init (1),		/* value_ptr was aligned. */
  7    46 	   GENERAL_TYPED_VECTOR_TYPE
  7    47 			      init (2),
  7    48 	   SIMPLE_TYPED_VECTOR_TYPE
  7    49 			      init (3)
  7    50 	   )		      fixed bin (17) internal static options (constant);
  7    51 
  7    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      900 
      901 
  8     1 /* ***********************************************************
  8     2*   *                                                         *
  8     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  8     4*   *                                                         *
  8     5*   *********************************************************** */
  8     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  8     7 
  8     8 /* Written by Lindsey Spratt, 03/04/82.
  8     9*Modified:
  8    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  8    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  8    12*	  the print_vector value (char varying), ptr to the typed_vector
  8    13*	  value location, and a code. cv_to_print now takes ptr to the
  8    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  8    15*	  (char(*) varying), the maximum allowed length for the print_vector
  8    16*	  value, a temp_seg to put the value in if its to big to fit into
  8    17*	  the print_vector, and a code.
  8    18**/
  8    19 
  8    20 /* format: style2,ind3 */
  8    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  8    22 	     2 version	      fixed bin (35),
  8    23 	     2 number_of_dimensions
  8    24 			      fixed bin (17),
  8    25 	     2 number_of_vectors  fixed bin (17),
  8    26 	     2 number_of_vector_slots
  8    27 			      fixed bin (17),
  8    28 	     2 maximum_dimension_name_length
  8    29 			      fixed bin (17),
  8    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  8    31 	       3 name	      char (tva_maximum_dimension_name_length
  8    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  8    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  8    34 						/* temp_seg_ptr, max_length_for_print_value, */
  8    35 						/* print_value, code) */
  8    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  8    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  8    38 						/* print_value_ptr, typed_value_ptr, code) */
  8    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  8    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  8    41 			      pointer;
  8    42 
  8    43      dcl	   typed_vector_array_ptr ptr;
  8    44      dcl	   tva_number_of_vector_slots
  8    45 			      fixed bin;
  8    46      dcl	   tva_number_of_dimensions
  8    47 			      fixed bin;
  8    48      dcl	   tva_maximum_dimension_name_length
  8    49 			      fixed bin;
  8    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  8    51 			      fixed bin (35) int static options (constant) init (2);
  8    52 
  8    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      902 
      903 
  9     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
  9     2 
  9     3 /* HISTORY:
  9     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
  9     5*Modified:
  9     6*05/20/83 by Matthew Pierret: Changed to use version 4.
  9     7**/
  9     8 
  9     9 /* format: style2,ind3 */
  9    10      dcl	   1 specification_head   based (specification_head_ptr),
  9    11 	     2 version	      fixed bin (35),
  9    12 	     2 type	      fixed bin (17) unal,
  9    13 	     2 pad	      bit (18) unal,
  9    14 	     2 subset_specification_ptr
  9    15 			      ptr;
  9    16 
  9    17 
  9    18      dcl	   specification_head_ptr ptr;
  9    19      dcl	   SPECIFICATION_VERSION_4
  9    20 			      init (4) fixed bin (35) internal static options (constant);
  9    21 
  9    22      dcl	   (
  9    23 	   SEARCH_SPECIFICATION_TYPE
  9    24 			      init (1),
  9    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
  9    26 			      init (1),
  9    27 	   NUMERIC_SPECIFICATION_TYPE
  9    28 			      init (2),
  9    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
  9    30 			      init (2),
  9    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
  9    32 			      init (3),
  9    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
  9    34 			      init (4),
  9    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
  9    36 			      init (5),
  9    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
  9    38 			      init (6),
  9    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
  9    40 			      init (7),
  9    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
  9    42 			      init (8)
  9    43 	   )		      fixed bin (17) internal static options (constant);
  9    44 
  9    45 
  9    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
      904 
      905 
 10     1 /* BEGIN INCLUDE FILE - dm_specification.incl.pl1 */
 10     2 
 10     3 /* DESCRIPTION:
 10     4*
 10     5*          The specification structure is used to identify sets items based on
 10     6*     the value of some of the contents of the items (the
 10     7*     search_specification), or based on the ordinal position (the
 10     8*     numeric_specification) of the first or last item in the desired set of
 10     9*     items in the set of all possible items.  It is used with the relation,
 10    10*     index and record managers.  The items for these three managers are
 10    11*     tuples, keys and records, respectively.  The sets of "all possible
 10    12*     items", for determination of ordinal position for these three managers
 10    13*     are: a relation, an index, and a record collection, respectively.
 10    14*     
 10    15*          The specification_head structure, in dm_specification_head.incl.pl1,
 10    16*     must be included in any program which uses this (the
 10    17*     dm_specification.incl.pl1) include file.
 10    18**/
 10    19 
 10    20 /* HISTORY:
 10    21*
 10    22*Written by Lindsey Spratt, 05/19/82.
 10    23*Modified:
 10    24*08/17/82 by Matthew Pierret:  Added all specification type constants.
 10    25*09/24/82 by Ronald Harvey: Changed version and added and_groups.
 10    26*10/22/82 by Lindsey Spratt:  Added the range_size to the numeric_specification.
 10    27*	  Changed the version to 3.
 10    28*05/11/83 by Matthew Pierret: Moved specification_head and and type constants
 10    29*            to dm_specification_head.incl.pl1. Added constraint.value_field_id.
 10    30*            Moved range type constants into dm_range_constants.incl.pl1.
 10    31*05/20/83 by Matthew Pierret: Added constraint.value_field_id for specifying
 10    32*            intra-key/record compares.
 10    33*10/02/84 by Lindsey L. Spratt:  Moved a misplaced journalization comment.
 10    34*            Added a DESCRIPTION comment.
 10    35**/
 10    36 
 10    37 /* format: style2,ind3 */
 10    38      dcl	   1 search_specification based (search_specification_ptr),
 10    39 	     2 head	      like specification_head,
 10    40 	     2 maximum_number_of_constraints
 10    41 			      fixed bin (17) unal,
 10    42 	     2 number_of_and_groups
 10    43 			      fixed bin (17) unal,
 10    44 	     2 range	      unal,
 10    45 	       3 type	      fixed bin (17),
 10    46 	       3 size	      fixed bin (17),
 10    47 	     2 and_group	      (ss_number_of_and_groups refer (search_specification.number_of_and_groups)),
 10    48 	       3 number_of_constraints
 10    49 			      fixed bin (17) unal,
 10    50 	       3 constraint	      (ss_maximum_number_of_constraints
 10    51 			      refer (search_specification.maximum_number_of_constraints)),
 10    52 	         4 field_id	      fixed bin (17) unal,
 10    53 	         4 operator_code  fixed bin (17) unal,
 10    54 	         4 value_field_id fixed bin (17) unal,
 10    55 	         4 pad	      bit (18) unal,
 10    56 	         4 value_ptr      ptr unal;
 10    57 
 10    58      dcl	   search_specification_ptr
 10    59 			      ptr;
 10    60      dcl	   (ss_number_of_and_groups, ss_maximum_number_of_constraints)
 10    61 			      fixed bin (17);
 10    62 
 10    63      dcl	   1 numeric_specification
 10    64 			      based (numeric_specification_ptr),
 10    65 	     2 head	      like specification_head,
 10    66 	     2 range_size	      fixed bin (35) aligned,
 10    67 	     2 position_number    fixed bin (17) unal,
 10    68 	     2 pad	      bit (18) unal;
 10    69 
 10    70      dcl	   numeric_specification_ptr
 10    71 			      ptr;
 10    72 
 10    73 /* END INCLUDE FILE - dm_specification.incl.pl1 */
      906 
      907 
 11     1 /* BEGIN INCLUDE FILE dm_range_constants.incl.pl1. */
 11     2 
 11     3 /* HISTORY:
 11     4*Written by Matthew Pierret, 05/27/83.
 11     5*Modified:
 11     6**/
 11     7 
 11     8      dcl	   (
 11     9 	   ALL_RANGE_TYPE	      init (1),
 11    10 	   LOW_RANGE_TYPE	      init (2),
 11    11 	   HIGH_RANGE_TYPE	      init (3)
 11    12 	   )		      fixed bin internal static options (constant);
 11    13 
 11    14 
 11    15 /* END INCLUDE FILE dm_range_constants.incl.pl1. */
      908 
      909 
 12     1 /* BEGIN INCLUDE FILE - dm_operator_constants.incl.pl1 */
 12     2 
 12     3 /* Written by Lindsey Spratt, 07/07/82
 12     4*Modified:
 12     5*10/07/82 by Lindsey Spratt:  Added the GREATER, LESS, GREATER_OR_EQUAL,
 12     6*	  LESS_OR_EQUAL and REGULAR_EXPRESSION operator codes.  Also, added
 12     7*	  bit(1) arrays for determining if a given operator code "uses" a
 12     8*	  given operator.  For example, USES_LESS_OPERATOR(x) = "1"b only if
 12     9*	  x = LESS_OPERATOR_CODE or x = LESS_OR_EQUAL_OPERATOR_CODE.
 12    10**/
 12    11 
 12    12 /* format: style2,ind3 */
 12    13      dcl	   (
 12    14 	   EQUAL_OPERATOR_CODE    init (1),
 12    15 	   GREATER_OPERATOR_CODE  init (2),
 12    16 	   LESS_OPERATOR_CODE     init (7),
 12    17 	   REGULAR_EXPRESSION_OPERATOR_CODE
 12    18 			      init (8),
 12    19 	   NOT_EQUAL_OPERATOR_CODE
 12    20 			      init (5),
 12    21 	   GREATER_OR_EQUAL_OPERATOR_CODE
 12    22 			      init (3),
 12    23 	   LESS_OR_EQUAL_OPERATOR_CODE
 12    24 			      init (6),
 12    25 	   EQUAL_IDX	      init (18),
 12    26 	   GREATER_IDX	      init (17),
 12    27 	   NOT_IDX	      init (16),
 12    28 	   REGULAR_EXPRESSION_IDX init (15)
 12    29 	   )		      fixed bin internal static options (constant);
 12    30 
 12    31      dcl	   (
 12    32 	   USES_LESS_OPERATOR     init ("0"b, (5) (1)"0"b, "1"b /* <= */, "1"b /* < */, (24) (1)"0"b),
 12    33 	   USES_GREATER_OPERATOR  init ("0"b, "0"b, "1"b /* > */, "1"b /* >= */, (28) (1)"0"b),
 12    34 	   USES_EQUAL_OPERATOR    init ("0"b, "1"b /* = */, "0"b, "1"b /* >= */, "0"b, "0"b, "1"b /* <= */,
 12    35 			      (25) (1)"0"b),
 12    36 	   USES_REGULAR_EXPRESSION_OPERATOR
 12    37 			      init ("0"b, (7) (1)"0"b, "1"b /* reg exp */, (3) (1)"0"b, "1"b /* not reg exp */,
 12    38 			      (19) (1)"0"b)
 12    39 	   )		      dimension (0:31) bit (1) unaligned internal static options (constant);
 12    40 
 12    41 /* END INCLUDE FILE - dm_operator_constants.incl.pl1 */
      910 
      911 
 13     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
 13     2 
 13     3 /* DESCRIPTION:
 13     4*          The element_id_list structure contains an array of element 
 13     5*     identifiers.  These identifiers are used as tuple, record or 
 13     6*     element identifiers.  This structure is used across the relation_manager_,
 13     7*     record_manager_ and index_manager_ interfaces.  At some time the 
 13     8*     version should be changed to be char(8)aligned, when such a conversion
 13     9*     can be coordinated with the other structures used at these interfaces.
 13    10**/
 13    11 
 13    12 /* HISTORY:
 13    13*Written by Matthew Pierret, 06/06/82.
 13    14*Modified:
 13    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
 13    16*            Did not change version.
 13    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
 13    18**/
 13    19 
 13    20 /* format: style2,ind3 */
 13    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
 13    22 	     2 version	      fixed bin (35),
 13    23 	     2 number_of_elements fixed bin (35),
 13    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
 13    25 
 13    26      dcl	   element_id_list_ptr    ptr;
 13    27      dcl	   eil_number_of_elements fixed bin (35);
 13    28      dcl	   ELEMENT_ID_LIST_VERSION_1
 13    29 			      init (1) fixed bin (35);
 13    30 
 13    31 
 13    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
      912 
      913 
 14     1 /* BEGIN INCLUDE FILE dm_rcdmgr_entry_dcls.incl.pl1 */
 14     2 
 14     3 /* This include file contains declarations of record_manager_ entry points. */
 14     4 
 14     5 /* HISTORY:
 14     6*Written by Matthew Pierret 05/12/82.
 14     7*Modified:
 14     8*12/14/82 by Matthew Pierret: Changed $get_ids to $get_id.
 14     9*04/01/83 by Matthew Pierret: Added $get_records_and_ids and
 14    10*            $get_records_and_ids_by_interval.
 14    11*04/04/83 by Matthew Pierret: Added $destroy_collection and $destroy_cursor.
 14    12*05/24/83 by Matthew Pierret: Corrected mis-spelling of "manger" for
 14    13*            rcm_$destroy_cursor.
 14    14*06/06/83 by Matthew Pierret: Corrected rcm_$get_record_count_by_intervals -
 14    15*            added a ptr parameter. 
 14    16*06/13/83 by Matthew Pierret:  Changed rcm_$*_by_intervals to correctly be
 14    17*            rcm_$=_by_interval.
 14    18*04/12/84 by Lee Baldwin:  Renamed some of the entry points (see 
 14    19*            record_manager_.alm) and changed the declarations of
 14    20*            those that used to pass a typed_vector_type and a
 14    21*            typed_vector_array_version.
 14    22*04/26/84 by Lee Baldwin:  Changed the arg list of
 14    23*            $get_record_count_by_interval to not take a work_area_ptr.
 14    24**/
 14    25 
 14    26 /* format: style2,ind3 */
 14    27      dcl	   record_manager_$create_collection
 14    28 			      entry (bit (36) aligned, ptr, ptr, ptr, bit (36) aligned, fixed bin (35));
 14    29      dcl	   record_manager_$create_cursor
 14    30 			      entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
 14    31      dcl	   record_manager_$destroy_collection
 14    32 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
 14    33      dcl	   record_manager_$destroy_cursor
 14    34 			      entry (ptr, fixed bin (35));
 14    35 
 14    36      dcl	   record_manager_$get_record_by_id
 14    37 			      entry (bit (36) aligned, ptr, ptr, ptr, ptr, fixed bin (35));
 14    38      dcl	   record_manager_$get_records_by_id_list
 14    39 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 14    40      dcl	   record_manager_$get_records_by_spec
 14    41 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 14    42      dcl	   record_manager_$get_records_by_interval
 14    43 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
 14    44      dcl	   record_manager_$get_records_and_ids_by_spec
 14    45 			      entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 14    46      dcl	   record_manager_$get_records_and_ids_by_interval
 14    47 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (17), ptr, ptr, ptr, fixed bin (35));
 14    48      dcl	   record_manager_$get_record_ids_by_spec
 14    49                                     entry (ptr, ptr, ptr, ptr, fixed bin (35));
 14    50      dcl	   record_manager_$get_record_ids_by_interval
 14    51 			      entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 14    52      dcl	   record_manager_$get_record_count
 14    53 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
 14    54      dcl	   record_manager_$get_record_count_by_interval
 14    55 			      entry (ptr, ptr, ptr, ptr, fixed bin (35), fixed bin (35));
 14    56 
 14    57      dcl	   record_manager_$put_record_by_id
 14    58 			      entry (bit (36) aligned, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35));
 14    59 
 14    60      dcl	   record_manager_$put_records_by_id
 14    61 			      entry (bit (36) aligned, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
 14    62 
 14    63      dcl	   record_manager_$delete_record_by_id
 14    64 			      entry (bit (36) aligned, ptr, fixed bin (35));
 14    65 
 14    66      dcl	   record_manager_$delete_records_by_id_list
 14    67 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
 14    68 
 14    69      dcl	   record_manager_$delete_records_by_spec
 14    70 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
 14    71 
 14    72      dcl	   record_manager_$modify_record_by_id
 14    73 			      entry (bit (36) aligned, ptr, ptr, fixed bin (35));
 14    74 
 14    75      dcl	   record_manager_$modify_records_by_id_list
 14    76 			      entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
 14    77 
 14    78      dcl	   record_manager_$modify_records_by_spec
 14    79 			      entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
 14    80 
 14    81 /* END INCLUDE FILE dm_rcdmgr_entry_dcls.incl.pl1 */
      914 
      915 
 15     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 15     2 /* format: style3 */
 15     3 
 15     4 /* These constants are to be used for the flags argument of sub_err_ */
 15     5 /* They are just "string (condition_info_header.action_flags)" */
 15     6 
 15     7 declare	(
 15     8 	ACTION_CAN_RESTART	init (""b),
 15     9 	ACTION_CANT_RESTART init ("1"b),
 15    10 	ACTION_DEFAULT_RESTART
 15    11 			init ("01"b),
 15    12 	ACTION_QUIET_RESTART
 15    13 			init ("001"b),
 15    14 	ACTION_SUPPORT_SIGNAL
 15    15 			init ("0001"b)
 15    16 	)		bit (36) aligned internal static options (constant);
 15    17 
 15    18 /* End include file */
      916 
      917 
 16     1 /* BEGIN INCLUDE FILE ... arg_descriptor.incl.pl1
 16     2*
 16     3*   James R. Davis 1 Mar 79 */
 16     4 /* Modified June 83 JMAthane for extended arg descriptor format */
 16     5 
 16     6      dcl	   1 arg_descriptor	      based (arg_descriptor_ptr) aligned,
 16     7 	     2 flag	      bit (1) unal,
 16     8 	     2 type	      fixed bin (6) unsigned unal,
 16     9 	     2 packed	      bit (1) unal,
 16    10 	     2 number_dims	      fixed bin (4) unsigned unal,
 16    11 	     2 size	      fixed bin (24) unsigned unal;
 16    12 
 16    13      dcl	   1 fixed_arg_descriptor based (arg_descriptor_ptr) aligned,
 16    14 	     2 flag	      bit (1) unal,
 16    15 	     2 type	      fixed bin (6) unsigned unal,
 16    16 	     2 packed	      bit (1) unal,
 16    17 	     2 number_dims	      fixed bin (4) unsigned unal,
 16    18 	     2 scale	      fixed bin (11) unal,
 16    19 	     2 precision	      fixed bin (12) unsigned unal;
 16    20 
 16    21      dcl	   1 extended_arg_descriptor based (arg_descriptor_ptr) aligned,
 16    22 	     2 flag	      bit (1) unal,		/* = "1"b */
 16    23 	     2 type	      fixed bin (6) unsigned unal, /* = 58 */
 16    24 	     2 packed	      bit (1) unal,		/* significant if number_dims ^= 0 */
 16    25 	     2 number_dims	      fixed (4) unsigned unal,/* number of variable dimensions */
 16    26 	     2 size	      bit (24) unal,
 16    27 	     2 dims	      (0 refer (extended_arg_descriptor.number_dims)), /* part referenced by called generated code */
 16    28 	       3 low	      fixed bin (35),
 16    29 	       3 high	      fixed bin (35),
 16    30 	       3 multiplier	      fixed bin (35),	/* in bits if packed, in words if not */
 16    31 	     2 real_type	      fixed bin (18) unsigned unal,
 16    32 	     2 type_offset	      fixed bin (18) unsigned unal; /* offset rel to symbol tree to symbol node for type, if any */
 16    33 
 16    34      dcl	   arg_descriptor_ptr     ptr;
 16    35 
 16    36      dcl	   extended_arg_type      fixed bin init (58);
 16    37 
 16    38 /* END INCLUDE file .... arg_descriptor.incl.pl1  */
      918 
      919 
 17     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
 17     2 
 17     3 
 17     4 /****^  HISTORY COMMENTS:
 17     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
 17     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
 17     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
 17     8*     Objects of this type are PASCAL string types.
 17     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
 17    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
 17    11*     Added the new C types.
 17    12*                                                   END HISTORY COMMENTS */
 17    13 
 17    14 /* This include file defines mnemonic names for the Multics
 17    15*   standard descriptor types, using both pl1 and cobol terminology.
 17    16*   PG 780613
 17    17*   JRD 790530
 17    18*   JRD 791016
 17    19*   MBW 810731
 17    20*   TGO 830614 Add hex types.
 17    21*   Modified June 83 JMAthane to add PASCAL data types
 17    22*   TGO 840120 Add float dec extended and generic, float binary generic
 17    23**/
 17    24 
 17    25      dcl	   (real_fix_bin_1_dtype  init (1),
 17    26 	   real_fix_bin_2_dtype   init (2),
 17    27 	   real_flt_bin_1_dtype   init (3),
 17    28 	   real_flt_bin_2_dtype   init (4),
 17    29 	   cplx_fix_bin_1_dtype   init (5),
 17    30 	   cplx_fix_bin_2_dtype   init (6),
 17    31 	   cplx_flt_bin_1_dtype   init (7),
 17    32 	   cplx_flt_bin_2_dtype   init (8),
 17    33 	   real_fix_dec_9bit_ls_dtype init (9),
 17    34 	   real_flt_dec_9bit_dtype init (10),
 17    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
 17    36 	   cplx_flt_dec_9bit_dtype init (12),
 17    37 	   pointer_dtype	      init (13),
 17    38 	   offset_dtype	      init (14),
 17    39 	   label_dtype	      init (15),
 17    40 	   entry_dtype	      init (16),
 17    41 	   structure_dtype	      init (17),
 17    42 	   area_dtype	      init (18),
 17    43 	   bit_dtype	      init (19),
 17    44 	   varying_bit_dtype      init (20),
 17    45 	   char_dtype	      init (21),
 17    46 	   varying_char_dtype     init (22),
 17    47 	   file_dtype	      init (23),
 17    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
 17    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
 17    50 	   real_fix_bin_1_uns_dtype init (33),
 17    51 	   real_fix_bin_2_uns_dtype init (34),
 17    52 	   real_fix_dec_9bit_uns_dtype init (35),
 17    53 	   real_fix_dec_9bit_ts_dtype init (36),
 17    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
 17    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
 17    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
 17    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
 17    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
 17    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
 17    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
 17    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
 17    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
 17    63 	   real_flt_hex_1_dtype   init (47),
 17    64 	   real_flt_hex_2_dtype   init (48),
 17    65 	   cplx_flt_hex_1_dtype   init (49),
 17    66 	   cplx_flt_hex_2_dtype   init (50),
 17    67 	   c_typeref_dtype        init (54),
 17    68 	   c_enum_dtype           init (55),
 17    69              c_enum_const_dtype     init (56),
 17    70 	   c_union_dtype          init (57),
 17    71 	   algol68_straight_dtype init (59),
 17    72 	   algol68_format_dtype   init (60),
 17    73 	   algol68_array_descriptor_dtype init (61),
 17    74 	   algol68_union_dtype    init (62),
 17    75 
 17    76 	   cobol_comp_6_dtype     init (1),
 17    77 	   cobol_comp_7_dtype     init (1),
 17    78 	   cobol_display_ls_dtype init (9),
 17    79 	   cobol_structure_dtype  init (17),
 17    80 	   cobol_char_string_dtype init (21),
 17    81 	   cobol_display_ls_overp_dtype init (29),
 17    82 	   cobol_display_ts_overp_dtype init (30),
 17    83 	   cobol_display_uns_dtype init (35),
 17    84 	   cobol_display_ts_dtype init (36),
 17    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
 17    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
 17    87 	   cobol_comp_5_uns_dtype init (40),
 17    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
 17    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
 17    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
 17    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
 17    92 	   cplx_flt_dec_generic_dtype init (84),
 17    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
 17    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
 17    95 
 17    96      dcl	   (ft_integer_dtype      init (1),
 17    97 	   ft_real_dtype	      init (3),
 17    98 	   ft_double_dtype	      init (4),
 17    99 	   ft_complex_dtype	      init (7),
 17   100 	   ft_complex_double_dtype init (8),
 17   101 	   ft_external_dtype      init (16),
 17   102 	   ft_logical_dtype	      init (19),
 17   103 	   ft_char_dtype	      init (21),
 17   104 	   ft_hex_real_dtype      init (47),
 17   105 	   ft_hex_double_dtype    init (48),
 17   106 	   ft_hex_complex_dtype   init (49),
 17   107 	   ft_hex_complex_double_dtype init (50)
 17   108 	   )		      fixed bin internal static options (constant);
 17   109 
 17   110      dcl	   (algol68_short_int_dtype init (1),
 17   111 	   algol68_int_dtype      init (1),
 17   112 	   algol68_long_int_dtype init (2),
 17   113 	   algol68_real_dtype     init (3),
 17   114 	   algol68_long_real_dtype init (4),
 17   115 	   algol68_compl_dtype    init (7),
 17   116 	   algol68_long_compl_dtype init (8),
 17   117 	   algol68_bits_dtype     init (19),
 17   118 	   algol68_bool_dtype     init (19),
 17   119 	   algol68_char_dtype     init (21),
 17   120 	   algol68_byte_dtype     init (21),
 17   121 	   algol68_struct_struct_char_dtype init (22),
 17   122 	   algol68_struct_struct_bool_dtype init (20)
 17   123 	   )		      fixed bin internal static options (constant);
 17   124 
 17   125      dcl	   (label_constant_runtime_dtype init (24),
 17   126 	   int_entry_runtime_dtype init (25),
 17   127 	   ext_entry_runtime_dtype init (26),
 17   128 	   ext_procedure_runtime_dtype init (27),
 17   129 	   picture_runtime_dtype  init (63)
 17   130 	   )		      fixed bin internal static options (constant);
 17   131 
 17   132      dcl	   (pascal_integer_dtype  init (1),
 17   133 	   pascal_real_dtype      init (4),
 17   134 	   pascal_label_dtype     init (24),
 17   135 	   pascal_internal_procedure_dtype init (25),
 17   136 	   pascal_exportable_procedure_dtype init (26),
 17   137 	   pascal_imported_procedure_dtype init (27),
 17   138 	   pascal_typed_pointer_type_dtype init (64),
 17   139 	   pascal_char_dtype      init (65),
 17   140 	   pascal_boolean_dtype   init (66),
 17   141 	   pascal_record_file_type_dtype init (67),
 17   142 	   pascal_record_type_dtype init (68),
 17   143 	   pascal_set_dtype	      init (69),
 17   144 	   pascal_enumerated_type_dtype init (70),
 17   145 	   pascal_enumerated_type_element_dtype init (71),
 17   146 	   pascal_enumerated_type_instance_dtype init (72),
 17   147 	   pascal_user_defined_type_dtype init (73),
 17   148 	   pascal_user_defined_type_instance_dtype init (74),
 17   149 	   pascal_text_file_dtype init (75),
 17   150 	   pascal_procedure_type_dtype init (76),
 17   151 	   pascal_variable_formal_parameter_dtype init (77),
 17   152 	   pascal_value_formal_parameter_dtype init (78),
 17   153 	   pascal_entry_formal_parameter_dtype init (79),
 17   154 	   pascal_parameter_procedure_dtype init (80),
 17   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
 17   156 
 17   157 
 17   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      920 
      921 
      922    end rlm_process_tuples_by_id;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/24/88  1400.0  rlm_process_tuples_by_id.pl1      >special_ldd>install>MR12.2-1184>rlm_process_tuples_by_id.pl1
888          1    03/06/85  1031.5  dm_rlm_cursor.incl.pl1            >ldd>include>dm_rlm_cursor.incl.pl1
890          2    01/07/85  0859.6  dm_rlm_opening_info.incl.pl1      >ldd>include>dm_rlm_opening_info.incl.pl1
892          3    01/07/85  0859.4  dm_rlm_header.incl.pl1            >ldd>include>dm_rlm_header.incl.pl1
894          4    01/07/85  0901.7  dm_rlm_attribute_info.incl.pl1    >ldd>include>dm_rlm_attribute_info.incl.pl1
896          5    01/07/85  0901.7  dm_rlm_index_attr_map.incl.pl1    >ldd>include>dm_rlm_index_attr_map.incl.pl1
898          6    01/07/85  0859.5  dm_rlm_idx_cursor_array.incl.pl1  >ldd>include>dm_rlm_idx_cursor_array.incl.pl1
900          7    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
902          8    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
904          9    10/14/83  1609.1  dm_specification_head.incl.pl1    >ldd>include>dm_specification_head.incl.pl1
906         10    01/07/85  0859.8  dm_specification.incl.pl1         >ldd>include>dm_specification.incl.pl1
908         11    10/14/83  1609.1  dm_range_constants.incl.pl1       >ldd>include>dm_range_constants.incl.pl1
910         12    10/14/83  1609.1  dm_operator_constants.incl.pl1    >ldd>include>dm_operator_constants.incl.pl1
912         13    03/06/85  1031.5  dm_element_id_list.incl.pl1       >ldd>include>dm_element_id_list.incl.pl1
914         14    01/07/85  0859.3  dm_rcdmgr_entry_dcls.incl.pl1     >ldd>include>dm_rcdmgr_entry_dcls.incl.pl1
916         15    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
918         16    11/02/83  1845.0  arg_descriptor.incl.pl1           >ldd>include>arg_descriptor.incl.pl1
920         17    10/24/88  1336.9  std_descriptor_types.incl.pl1     >special_ldd>install>MR12.2-1184>std_descriptor_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSOLUTE_SEARCH_SPECIFICATION_TYPE     constant        fixed bin(17,0)          initial dcl 9-22 ref 554
ACTION_CANT_RESTART             000043 constant        bit(36)                  initial dcl 15-7 set ref 226* 576* 590*
ALL_RANGE_TYPE                         constant        fixed bin(17,0)          initial dcl 11-8 ref 556
ATTRIBUTE_INFO_VERSION_1        000004 constant        char(8)                  initial dcl 4-34 set ref 254*
BITS_PER_BYTE                          constant        fixed bin(17,0)          initial dcl 143 ref 669
BITS_PER_WORD                          constant        fixed bin(17,0)          initial dcl 144 ref 669 671
ELEMENT_ID_LIST_VERSION_1       000166 automatic       fixed bin(35,0)          initial dcl 13-28 set ref 199 220 13-28*
EQUAL_OPERATOR_CODE                    constant        fixed bin(17,0)          initial dcl 12-13 ref 558
FALSE                                  constant        bit(1)                   initial dcl 146 ref 397 876 884
GENERAL_TYPED_VECTOR_TYPE       000047 constant        fixed bin(17,0)          initial dcl 7-43 set ref 226 226*
INDEX_ATTRIBUTE_MAP_VERSION_2   000002 constant        char(8)                  initial dcl 5-43 set ref 256*
INDEX_CURSOR_ARRAY_VERSION_1    000000 constant        char(8)                  initial dcl 6-19 set ref 258*
INITIAL_NUMBER_OF_INDICES       000146 automatic       fixed bin(17,0)          initial dcl 5-45 set ref 5-45*
RELATION_CURSOR_VERSION_2       000012 constant        char(8)                  initial dcl 1-43 ref 239
RELATION_HEADER_VERSION_3       000006 constant        char(8)                  initial dcl 3-30 set ref 252*
RELATION_OPENING_INFO_VERSION_2 000010 constant        char(8)                  initial dcl 2-43 set ref 250*
SIMPLE_TYPED_VECTOR_TYPE               constant        fixed bin(17,0)          initial dcl 7-43 ref 306
SPECIFICATION_VERSION_4                constant        fixed bin(35,0)          initial dcl 9-19 ref 553
TRUE                                   constant        bit(1)                   initial dcl 146 ref 406 618 725 785 882
UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                000147 automatic       fixed bin(17,0)          initial dcl 5-47 set ref 5-47*
addr                                                   builtin function         dcl 139 ref 632 632 667 723 723 729 729 783 783 793
                                                                                  793
an_index_field_is_modified      000100 automatic       bit(1)                   initial dcl 118 set ref 118*
and_group                 6            based           structure                array level 2 packed packed unaligned dcl 10-38
arg_descriptor                         based           structure                level 1 dcl 16-6
arg_descriptor_ptr              000170 automatic       pointer                  dcl 16-34 set ref 667* 669 671 673
attribute                 3            based           structure                array level 2 dcl 4-18
attribute_id              6(18)        based           fixed bin(17,0)          array level 3 packed packed unaligned dcl 5-18 ref
                                                                                  402 525
attribute_info                         based           structure                level 1 dcl 4-18
attribute_info_ptr              000142 automatic       pointer                  initial dcl 4-29 in procedure
                                                                                  "rlm_process_tuples_by_id" set ref 253* 254 292*
                                                                                  321* 4-29* 667
attribute_info_ptr       16            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure "rlm_process_tuples_by_id"
                                                                                  ref 253
bk_field_idx                    000220 automatic       fixed bin(17,0)          dcl 392 set ref 400* 402 405* 410
bk_new_value_ptr                000224 automatic       pointer                  dcl 395 set ref 404* 405 406
bk_old_value_ptr                000222 automatic       pointer                  dcl 394 set ref 403* 406
bk_p_iam_ptr                           parameter       pointer                  dcl 387 ref 375 398 400 402
bk_p_index_field_is_modified           parameter       bit(1)                   dcl 389 set ref 375 397* 406*
bk_p_index_idx                         parameter       fixed bin(17,0)          dcl 388 ref 375 398 400 402
bk_p_key_ptr                           parameter       pointer                  dcl 383 ref 375 398 405 410
bk_p_new_record_ptr                    parameter       pointer                  dcl 385 ref 375 404
bk_p_old_record_ptr                    parameter       pointer                  dcl 384 ref 375 403
bk_p_record_id_ptr                     parameter       pointer                  dcl 386 ref 375 410
bk_record_field_idx             000221 automatic       fixed bin(17,0)          dcl 393 set ref 402* 403 404
br_dim_idx                      000256 automatic       fixed bin(17,0)          dcl 428 set ref 442* 444 445*
br_field_idx                    000257 automatic       fixed bin(17,0)          dcl 429 set ref 444* 447 447
br_field_value_ptr              000260 automatic       pointer                  dcl 430 set ref 445* 447
br_p_area_ptr                          parameter       pointer                  dcl 421 ref 416 437
br_p_gtv_ptr                           parameter       pointer                  dcl 421 ref 416 442 444 445
br_p_new_record_ptr                    parameter       pointer                  dcl 421 set ref 416 432 437* 440 447
br_p_old_record_ptr                    parameter       pointer                  dcl 421 ref 416 436 440
brt_attr_idx                    000276 automatic       fixed bin(17,0)          dcl 475 set ref 478* 480 486 489 496 499*
brt_bit_var_template                   based           varying bit              dcl 474 ref 496 498
brt_char_var_template                  based           varying char             dcl 473 ref 486 488
brt_descriptor                  000277 automatic       structure                level 1 dcl 476 set ref 480*
brt_p_area_ptr                         parameter       pointer                  dcl 465 ref 456 488 498
brt_p_attr_info_ptr                    parameter       pointer                  dcl 465 ref 456 478 480
brt_p_record_ptr                       parameter       pointer                  dcl 465 ref 456 486 489 496 499
brt_template_length             000272 automatic       fixed bin(35,0)          dcl 471 set ref 485* 486 487* 488 495* 496 497* 498
brt_template_ptr                000274 automatic       pointer                  dcl 472 set ref 488* 489 498* 499
bs_field_idx                    000330 automatic       fixed bin(17,0)          dcl 521 set ref 523* 525 525* 531 532
bs_p_iam_ptr                           parameter       pointer                  dcl 518 ref 508 523 525
bs_p_index_idx                         parameter       fixed bin(17,0)          dcl 519 ref 508 523 525
bs_p_record_id_ptr                     parameter       pointer                  dcl 517 ref 508 531
bs_p_record_ptr                        parameter       pointer                  dcl 516 ref 508 525
bs_spec_ptr                            parameter       pointer                  dcl 515 ref 508 525 531 532
cleanup                         000126 stack reference condition                dcl 153 ref 242
code                            000120 automatic       fixed bin(35,0)          initial dcl 124 set ref 124* 235* 247* 248 248*
collection_id             4            based           bit(36)                  array level 3 dcl 5-18 set ref 848*
constraint                6(18)        based           structure                array level 3 packed packed unaligned dcl 10-38
current                   6            based           structure                level 2 dcl 1-18
cursor_ptr               14            based           pointer                  initial level 3 in structure "relation_cursor"
                                                                                  dcl 1-18 in procedure "rlm_process_tuples_by_id"
                                                                                  ref 359
cursor_ptr                4            based           pointer                  array level 2 in structure "index_cursor_array"
                                                                                  dcl 6-11 in procedure "rlm_process_tuples_by_id"
                                                                                  set ref 631 728 788 844 854*
cv_p_expected_version                  parameter       char(8)                  dcl 573 set ref 569 576 576*
cv_p_received_version                  parameter       char(8)                  dcl 572 set ref 569 576 576*
cv_p_structure_name                    parameter       char                     packed unaligned dcl 574 set ref 569 576*
cvf_p_expected_version                 parameter       fixed bin(35,0)          dcl 587 set ref 583 590 590*
cvf_p_received_version                 parameter       fixed bin(35,0)          dcl 586 set ref 583 590 590*
cvf_p_structure_name                   parameter       char                     packed unaligned dcl 588 set ref 583 590*
data_format_util_$get_data_bit_length
                                000010 constant        entry                    external dcl 157 ref 673
delete                          000101 automatic       bit(1)                   dcl 120 set ref 186* 195* 208* 216* 275
descriptor                3            based           bit(36)                  array level 3 dcl 4-18 set ref 480 667
dimension                 1            based           structure                array level 2 in structure "simple_typed_vector"
                                                                                  packed packed unaligned dcl 7-17 in procedure
                                                                                  "rlm_process_tuples_by_id"
dimension                 1            based           structure                array level 2 in structure "general_typed_vector"
                                                                                  packed packed unaligned dcl 7-24 in procedure
                                                                                  "rlm_process_tuples_by_id" ref 442
dm_area                                based           area                     dcl 135 ref 305 346 352 356 437 488 498 551 676 679
dm_area_ptr                     000114 automatic       pointer                  initial dcl 122 set ref 122* 241* 273* 283* 289*
                                                                                  292* 295* 305 312* 318* 321* 324* 346 352 356 676
                                                                                  679 848*
dm_error_$key_duplication       000026 external static fixed bin(35,0)          dcl 171 ref 735
dm_error_$key_not_found         000030 external static fixed bin(35,0)          dcl 171 ref 634
dm_error_$record_not_found      000032 external static fixed bin(35,0)          dcl 171 ref 618 710
dm_error_$tuple_not_found_id    000034 external static fixed bin(35,0)          dcl 171 set ref 622* 710*
dt_code                         000430 automatic       fixed bin(35,0)          dcl 610 set ref 614* 616* 618 618 623* 633* 634 634
                                                                                  634* 637* 641* 642 642*
dt_index_cursor_ptr             000432 automatic       pointer                  initial dcl 612 set ref 612* 631* 633*
dt_index_idx                    000431 automatic       fixed bin(17,0)          dcl 611 set ref 626* 628 631 632*
dt_p_area_ptr                          parameter       pointer                  dcl 607 set ref 597 616* 633*
dt_p_iam_ptr                           parameter       pointer                  dcl 605 set ref 597 626 628 632*
dt_p_ica_ptr                           parameter       pointer                  dcl 606 ref 597 631
dt_p_record_cursor_ptr                 parameter       pointer                  dcl 603 set ref 597 616* 641*
dt_p_record_id                         parameter       bit(36)                  dcl 601 set ref 597 616* 618* 632 632 641*
dt_p_record_ptr                        parameter       pointer                  dcl 602 set ref 597 616* 632*
dt_p_spec_ptr                          parameter       pointer                  dcl 604 set ref 597 632* 633*
element_id_list                        based           structure                level 1 dcl 13-21
element_id_list_ptr             000164 automatic       pointer                  dcl 13-26 set ref 198* 199 201 219* 220 222 288 294
                                                                                  317 323 876 880
er_p_code                              parameter       fixed bin(35,0)          dcl 367 ref 364 369
error_table_$unimplemented_version
                                000036 external static fixed bin(35,0)          dcl 177 set ref 576* 590*
extended_arg_type               000172 automatic       fixed bin(17,0)          initial dcl 16-36 set ref 16-36*
field_id                  6(18)        based           fixed bin(17,0)          array level 4 packed packed unaligned dcl 10-38 set
                                                                                  ref 562*
file_opening_id           4            based           bit(36)                  initial level 2 dcl 1-18 set ref 247* 826* 848*
fstv_based_real_fixed_bin_1u           based           fixed bin(35,0)          packed unaligned dcl 660 ref 669 671
fstv_current_value_ptr          000112 automatic       pointer                  initial dcl 659 set ref 659* 668* 669 671 676
fstv_descriptor_string                 based           bit(36)                  dcl 655 set ref 673*
fstv_dimension_idx              000110 automatic       fixed bin(17,0)          dcl 656 set ref 666* 667 668*
fstv_p_vector_ptr                      parameter       pointer                  dcl 652 set ref 649 663 664*
fstv_storage_size               000111 automatic       fixed bin(35,0)          dcl 657 set ref 669* 671* 673* 676 676
fstv_storage_string                    based           bit                      dcl 658 ref 676
fstv_vector_ptr                 000106 automatic       pointer                  dcl 654 set ref 663* 666 668 679
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 7-24
general_typed_vector_ptr        000160 automatic       pointer                  dcl 7-38 set ref 224* 226 226 312* 318* 324*
get_dm_free_area_               000012 constant        entry                    external dcl 159 ref 241
hbound                                                 builtin function         dcl 139 ref 267 442 626 718
head                                   based           structure                level 2 unaligned dcl 10-38
ica_number_of_indices           000152 automatic       fixed bin(35,0)          initial dcl 6-18 set ref 6-18*
id                        2            based           bit(36)                  array level 2 dcl 13-21 ref 288 294 317 323 880
identifier                1            based           fixed bin(17,0)          array level 3 packed packed unaligned dcl 7-24 ref
                                                                                  444
index                     4            based           structure                array level 2 dcl 5-18 set ref 267 626 718
index_attribute_map                    based           structure                level 1 dcl 5-18
index_attribute_map_ptr
                         20            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure "rlm_process_tuples_by_id"
                                                                                  ref 255
index_attribute_map_ptr         000144 automatic       pointer                  initial dcl 5-37 in procedure
                                                                                  "rlm_process_tuples_by_id" set ref 255* 256 267
                                                                                  273* 283* 289* 295* 304 312* 318* 324* 5-37* 344
                                                                                  844 848
index_cursor_array                     based           structure                level 1 dcl 6-11
index_cursor_array_ptr
                         12            based           pointer                  initial level 3 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure "rlm_process_tuples_by_id"
                                                                                  ref 257
index_cursor_array_ptr          000150 automatic       pointer                  initial dcl 6-17 in procedure
                                                                                  "rlm_process_tuples_by_id" set ref 257* 258 283*
                                                                                  289* 295* 312* 318* 324* 6-17* 844 854
index_idx                       000121 automatic       fixed bin(17,0)          initial dcl 125 set ref 125* 267* 268*
index_manager_$create_cursor    000014 constant        entry                    external dcl 160 ref 848
index_manager_$delete_key       000016 constant        entry                    external dcl 162 ref 633 731 795
index_manager_$put_key          000020 constant        entry                    external dcl 164 ref 734 802
is_field_idx                    000362 automatic       fixed bin(17,0)          dcl 546 set ref 561* 562 562*
is_p_area_ptr                          parameter       pointer                  dcl 541 ref 538 551
is_p_iam_ptr                           parameter       pointer                  dcl 541 ref 538 549
is_p_spec_ptr                          parameter       pointer                  dcl 541 set ref 538 551* 553 554 555 556 557 558 559
                                                                                  561 562
key_ptr                         000104 automatic       pointer                  initial dcl 122 set ref 122* 232* 305* 306 312* 318*
                                                                                  324* 341 344 346
key_spec_ptr                    000106 automatic       pointer                  initial dcl 122 set ref 122* 232* 273* 283* 289*
                                                                                  295* 312* 318* 324* 356 356
maximum_attribute_name_length
                          2(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-18 ref 480 480
                                                                                  667 667
maximum_number_of_attributes_per_index
                          3            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-18 ref 304 344
                                                                                  398 398 400 400 402 402 523 523 525 525 549 628
                                                                                  628 720 720 780 780 844 844 848 848
maximum_number_of_constraints
                          4            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 10-38 set ref
                                                                                  356 525 525 531 531 532 532 551* 558 558 558 559
                                                                                  559 559 561 562 562
maximum_number_of_indices
                          2(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-18 ref 267 626
                                                                                  718
mt_code                         000444 automatic       fixed bin(35,0)          dcl 700 set ref 706* 708* 710 710 713* 731* 732 732*
                                                                                  734* 735 735 742* 748* 749 749*
mt_index_cursor_ptr             000450 automatic       pointer                  dcl 704 set ref 728* 731* 734*
mt_index_idx                    000445 automatic       fixed bin(17,0)          dcl 701 set ref 718* 720 723* 728 729* 739*
mt_key_must_be_modified         000446 automatic       bit(1)                   dcl 702 set ref 723* 725
mt_p_area_ptr                          parameter       pointer                  dcl 698 set ref 685 708* 715* 731* 739*
mt_p_gtv_ptr                           parameter       pointer                  dcl 694 set ref 685 715* 748*
mt_p_iam_ptr                           parameter       pointer                  dcl 696 set ref 685 718 720 723* 729* 739*
mt_p_ica_ptr                           parameter       pointer                  dcl 697 set ref 685 728 739*
mt_p_key_ptr                           parameter       pointer                  dcl 693 set ref 685 723* 734* 739*
mt_p_new_record_ptr                    parameter       pointer                  dcl 691 set ref 685 715* 723* 739*
mt_p_old_record_ptr                    parameter       pointer                  dcl 690 set ref 685 708* 715* 723* 729* 739*
mt_p_record_cursor_ptr                 parameter       pointer                  dcl 692 set ref 685 708* 748*
mt_p_record_id                         parameter       bit(36)                  dcl 689 set ref 685 708* 723 723 729 729 739* 748*
mt_p_spec_ptr                          parameter       pointer                  dcl 695 set ref 685 729* 731* 739*
myname                          000014 constant        varying char(32)         initial dcl 145 set ref 226* 576* 590*
new_record_ptr                  000110 automatic       pointer                  initial dcl 122 set ref 122* 232* 312* 318* 324* 352
                                                                                  352
null                                                   builtin function         dcl 139 ref 122 122 122 122 122 122 226 226 232 1-42
                                                                                  3-29 4-29 5-37 6-17 341 349 352 356 359 432 555
                                                                                  576 576 590 590 612 616 616 659 664 708 708 822
                                                                                  844 876
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 10-38 set ref
                                                                                  356 551*
number_of_attributes      6            based           fixed bin(17,0)          array level 3 in structure "index_attribute_map"
                                                                                  packed packed unaligned dcl 5-18 in procedure
                                                                                  "rlm_process_tuples_by_id" ref 398 400 523 628 720
                                                                                  780 844
number_of_attributes      2            based           fixed bin(17,0)          level 2 in structure "attribute_info" packed packed
                                                                                  unaligned dcl 4-18 in procedure
                                                                                  "rlm_process_tuples_by_id" ref 478
number_of_constraints
                          6            based           fixed bin(17,0)          array level 3 packed packed unaligned dcl 10-38 set
                                                                                  ref 532*
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 7-17 in procedure
                                                                                  "rlm_process_tuples_by_id" set ref 305* 344* 346
                                                                                  352 398* 436 437* 440 666 679
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "general_typed_vector" packed
                                                                                  packed unaligned dcl 7-24 in procedure
                                                                                  "rlm_process_tuples_by_id" ref 442
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 13-21 ref 201 222
number_of_tuples_processed      000122 automatic       fixed bin(35,0)          initial dcl 126 set ref 126* 291* 297* 297 320* 326*
                                                                                  326 338
number_of_tuples_to_process     000123 automatic       fixed bin(35,0)          initial dcl 128 set ref 128* 188* 201* 210* 222* 293
                                                                                  322
old_record_ptr                  000112 automatic       pointer                  initial dcl 122 set ref 122* 232* 283* 289* 292*
                                                                                  295* 312* 318* 321* 324* 349 349*
operator_code             7            based           fixed bin(17,0)          array level 4 packed packed unaligned dcl 10-38 set
                                                                                  ref 558*
p_code                                 parameter       fixed bin(35,0)          dcl 114 set ref 183 192 205 213 235* 369*
p_element_id_list_ptr                  parameter       pointer                  dcl 108 ref 192 198 213 219
p_number_of_tuples_processed           parameter       fixed bin(35,0)          dcl 112 set ref 192 213 338*
p_relation_cursor_ptr                  parameter       pointer                  dcl 111 ref 183 192 205 213 237
p_tuple_id                             parameter       bit(36)                  dcl 109 ref 183 205 282 311
p_typed_vector_ptr                     parameter       pointer                  dcl 110 ref 205 213 224
per_process               2            based           structure                level 2 dcl 2-15
process_single_tuple            000102 automatic       bit(1)                   initial dcl 121 set ref 121* 187* 196* 209* 217* 279
                                                                                  308 338
range                     5            based           structure                level 2 packed packed unaligned dcl 10-38
record_collection_id      3            based           bit(36)                  initial level 2 dcl 3-15 set ref 265*
record_cursor_ptr               000116 automatic       pointer                  initial dcl 122 set ref 122* 265* 283* 289* 295*
                                                                                  312* 318* 324* 359 359 359*
record_manager_$create_cursor   000040 constant        entry                    external dcl 14-29 ref 826
record_manager_$delete_record_by_id
                                000046 constant        entry                    external dcl 14-63 ref 641
record_manager_$destroy_cursor  000042 constant        entry                    external dcl 14-33 ref 359
record_manager_$get_record_by_id
                                000044 constant        entry                    external dcl 14-36 ref 616 708
record_manager_$modify_record_by_id
                                000050 constant        entry                    external dcl 14-72 ref 748
relation_cursor                        based           structure                level 1 dcl 1-18
relation_cursor_ptr             000134 automatic       pointer                  initial dcl 1-42 set ref 237* 239 247 265* 1-42* 359
                                                                                  848
relation_header                        based           structure                level 1 dcl 3-15
relation_header_ptr             000140 automatic       pointer                  initial dcl 3-29 in procedure
                                                                                  "rlm_process_tuples_by_id" set ref 251* 252 265
                                                                                  3-29*
relation_header_ptr      14            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure "rlm_process_tuples_by_id"
                                                                                  ref 251
relation_opening_info                  based           structure                level 1 dcl 2-15
relation_opening_info_ptr       000136 automatic       pointer                  dcl 2-41 set ref 247* 250 251 253 255 257
rlm_opening_info$get            000022 constant        entry                    external dcl 166 ref 247
rt_code                         000462 automatic       fixed bin(35,0)          dcl 771 set ref 795* 797 797* 802* 803 803*
rt_index_cursor_ptr             000466 automatic       pointer                  dcl 775 set ref 788* 795* 802*
rt_index_idx                    000463 automatic       fixed bin(17,0)          dcl 772 set ref 778* 780 783* 788 789 793*
rt_key_must_be_modified         000464 automatic       bit(1)                   dcl 773 set ref 783* 785
rt_p_area_ptr                          parameter       pointer                  dcl 767 set ref 756 795*
rt_p_iam_ptr                           parameter       pointer                  dcl 765 set ref 756 780 783* 793*
rt_p_ica_ptr                           parameter       pointer                  dcl 766 ref 756 788
rt_p_key_ptr                           parameter       pointer                  dcl 763 set ref 756 783* 802*
rt_p_last_modified_index               parameter       fixed bin(17,0)          dcl 768 ref 756 778 789
rt_p_new_record_ptr                    parameter       pointer                  dcl 762 set ref 756 783* 793*
rt_p_old_record_ptr                    parameter       pointer                  dcl 761 set ref 756 783*
rt_p_record_id                         parameter       bit(36)                  dcl 760 set ref 756 783 783 793 793
rt_p_spec_ptr                          parameter       pointer                  dcl 764 set ref 756 793* 795*
scpfti_code                     000512 automatic       fixed bin(35,0)          dcl 840 set ref 848* 851 851*
scpfti_index_cursor_ptr         000514 automatic       pointer                  dcl 841 set ref 848* 854
scpfti_index_idx                       parameter       fixed bin(17,0)          dcl 839 ref 836 844 844 848 854
search_specification                   based           structure                level 1 unaligned dcl 10-38 set ref 356 551
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 7-17 set ref 305
                                                                                  346 352 437 440* 440 679
simple_typed_vector_ptr         000154 automatic       pointer                  dcl 7-33 set ref 232*
size                      0(12) 000277 automatic       fixed bin(24,0)          level 2 in structure "brt_descriptor" packed packed
                                                                                  unsigned unaligned dcl 476 in procedure
                                                                                  "BUILD_RECORD_TEMPLATE" set ref 487 497
size                      5(18)        based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  packed unaligned dcl 10-38 in procedure
                                                                                  "rlm_process_tuples_by_id" set ref 557*
specification_head                     based           structure                level 1 unaligned dcl 9-10
srccp_code                      000502 automatic       fixed bin(35,0)          initial dcl 824 set ref 824* 826* 829 829*
srccp_p_record_collection_id           parameter       bit(36)                  dcl 819 set ref 814 826*
srccp_p_relation_cursor_ptr            parameter       pointer                  dcl 817 ref 814 826 826
srccp_record_collection_cursor_ptr
                                000500 automatic       pointer                  initial dcl 822 set ref 822* 826* 832
ss_maximum_number_of_constraints
                                000163 automatic       fixed bin(17,0)          dcl 10-60 set ref 549* 551 551
ss_number_of_and_groups         000162 automatic       fixed bin(17,0)          dcl 10-60 set ref 548* 551 551
stv_number_of_dimensions        000156 automatic       fixed bin(17,0)          dcl 7-35 set ref 304* 305 305 436* 437 437
sub_err_                        000024 constant        entry                    external dcl 167 ref 226 576 590
subset_specification_ptr
                          2            based           pointer                  level 3 dcl 10-38 set ref 555*
tap_p_tuple_id                         parameter       bit(36)                  dcl 872 ref 861 880
tap_tuple_idx                   000524 automatic       fixed bin(35,0)          dcl 874 set ref 879* 880* 880 880* 882
tuple_id                        000125 automatic       bit(36)                  dcl 131 set ref 282* 283* 288* 289* 294* 295* 311*
                                                                                  312* 317* 318* 323* 324*
tuple_idx                       000124 automatic       fixed bin(17,0)          dcl 130 set ref 293* 294* 322* 323* 879
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 7-17 in procedure
                                                                                  "rlm_process_tuples_by_id" set ref 306*
type                      0(01) 000277 automatic       fixed bin(6,0)           level 2 in structure "brt_descriptor" packed packed
                                                                                  unsigned unaligned dcl 476 in procedure
                                                                                  "BUILD_RECORD_TEMPLATE" set ref 481 491
type                      5            based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  packed unaligned dcl 10-38 in procedure
                                                                                  "rlm_process_tuples_by_id" set ref 556*
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "arg_descriptor" packed packed
                                                                                  unsigned unaligned dcl 16-6 in procedure
                                                                                  "rlm_process_tuples_by_id" ref 669 671
type                      1            based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  packed unaligned dcl 10-38 in procedure
                                                                                  "rlm_process_tuples_by_id" set ref 554*
type                                   based           fixed bin(17,0)          level 2 in structure "general_typed_vector" packed
                                                                                  packed unaligned dcl 7-24 in procedure
                                                                                  "rlm_process_tuples_by_id" set ref 226 226*
value_field_id            7(18)        based           fixed bin(17,0)          array level 4 packed packed unaligned dcl 10-38 set
                                                                                  ref 559*
value_ptr                 2            based           pointer                  array level 3 in structure "general_typed_vector"
                                                                                  packed packed unaligned dcl 7-24 in procedure
                                                                                  "rlm_process_tuples_by_id" ref 445
value_ptr                 1            based           pointer                  array level 3 in structure "simple_typed_vector"
                                                                                  packed packed unaligned dcl 7-17 in procedure
                                                                                  "rlm_process_tuples_by_id" set ref 403 404 405*
                                                                                  410* 447* 486 489* 496 499* 525 668
value_ptr                10(18)        based           pointer                  array level 4 in structure "search_specification"
                                                                                  packed packed unaligned dcl 10-38 in procedure
                                                                                  "rlm_process_tuples_by_id" set ref 525* 531*
varying_bit_dtype                      constant        fixed bin(17,0)          initial dcl 17-25 ref 491 671
varying_char_dtype                     constant        fixed bin(17,0)          initial dcl 17-25 ref 481 669
version                                based           char(8)                  level 2 in structure "relation_cursor" dcl 1-18
                                                                                  in procedure "rlm_process_tuples_by_id" ref 239
version                                based           fixed bin(35,0)          level 2 in structure "element_id_list" dcl 13-21
                                                                                  in procedure "rlm_process_tuples_by_id" ref 199
                                                                                  220
version                                based           char(8)                  level 2 in structure "index_cursor_array" dcl 6-11
                                                                                  in procedure "rlm_process_tuples_by_id" set ref
                                                                                  258*
version                                based           char(8)                  level 2 in structure "index_attribute_map" dcl 5-18
                                                                                  in procedure "rlm_process_tuples_by_id" set ref
                                                                                  256*
version                                based           char(8)                  level 2 in structure "relation_header" dcl 3-15
                                                                                  in procedure "rlm_process_tuples_by_id" set ref
                                                                                  252*
version                                based           char(8)                  level 2 in structure "attribute_info" dcl 4-18
                                                                                  in procedure "rlm_process_tuples_by_id" set ref
                                                                                  254*
version                                based           fixed bin(35,0)          level 3 in structure "search_specification"
                                                                                  dcl 10-38 in procedure "rlm_process_tuples_by_id"
                                                                                  set ref 553*
version                                based           char(8)                  level 2 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure "rlm_process_tuples_by_id"
                                                                                  set ref 250*
work_area_ptr             2            based           pointer                  initial level 2 dcl 1-18 set ref 826*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 9-22
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 9-22
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 9-22
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 15-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 15-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 15-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 15-7
EQUAL_IDX                              internal static fixed bin(17,0)          initial dcl 12-13
GREATER_IDX                            internal static fixed bin(17,0)          initial dcl 12-13
GREATER_OPERATOR_CODE                  internal static fixed bin(17,0)          initial dcl 12-13
GREATER_OR_EQUAL_OPERATOR_CODE         internal static fixed bin(17,0)          initial dcl 12-13
HIGH_RANGE_TYPE                        internal static fixed bin(17,0)          initial dcl 11-8
LESS_OPERATOR_CODE                     internal static fixed bin(17,0)          initial dcl 12-13
LESS_OR_EQUAL_OPERATOR_CODE            internal static fixed bin(17,0)          initial dcl 12-13
LOW_RANGE_TYPE                         internal static fixed bin(17,0)          initial dcl 11-8
NOT_EQUAL_OPERATOR_CODE                internal static fixed bin(17,0)          initial dcl 12-13
NOT_IDX                                internal static fixed bin(17,0)          initial dcl 12-13
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 9-22
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 7-43
REGULAR_EXPRESSION_IDX                 internal static fixed bin(17,0)          initial dcl 12-13
REGULAR_EXPRESSION_OPERATOR_CODE       internal static fixed bin(17,0)          initial dcl 12-13
RELATIVE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 9-22
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 9-22
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 9-22
RELATIVE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 9-22
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 9-22
TYPED_VECTOR_ARRAY_VERSION_2           internal static fixed bin(35,0)          initial dcl 8-50
USES_EQUAL_OPERATOR                    internal static bit(1)                   initial array packed unaligned dcl 12-31
USES_GREATER_OPERATOR                  internal static bit(1)                   initial array packed unaligned dcl 12-31
USES_LESS_OPERATOR                     internal static bit(1)                   initial array packed unaligned dcl 12-31
USES_REGULAR_EXPRESSION_OPERATOR       internal static bit(1)                   initial array packed unaligned dcl 12-31
ai_maximum_attribute_name_length       automatic       fixed bin(17,0)          dcl 4-30
ai_number_of_attributes                automatic       fixed bin(17,0)          dcl 4-32
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 17-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 17-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 17-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 17-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 17-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 17-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 17-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 17-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 17-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 17-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 17-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 17-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 17-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 17-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 17-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 17-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 17-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 17-25
bit_dtype                              internal static fixed bin(17,0)          initial dcl 17-25
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 17-25
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 17-25
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 17-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 17-25
char_dtype                             internal static fixed bin(17,0)          initial dcl 17-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 17-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 17-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 17-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 17-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 17-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 17-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 17-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 17-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 17-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 17-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 17-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 17-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 17-25
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 17-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 17-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 17-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 17-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 17-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 17-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 17-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 17-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 17-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 17-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 17-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 17-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 17-25
eil_number_of_elements                 automatic       fixed bin(35,0)          dcl 13-27
entry_dtype                            internal static fixed bin(17,0)          initial dcl 17-25
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 17-125
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 17-125
extended_arg_descriptor                based           structure                level 1 dcl 16-21
file_dtype                             internal static fixed bin(17,0)          initial dcl 17-25
fixed_arg_descriptor                   based           structure                level 1 dcl 16-13
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 17-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 17-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 17-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 17-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 17-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 17-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 17-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 17-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 17-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 17-96
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 17-96
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 17-96
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 7-40
iam_maximum_number_of_attributes_per_index
                                       automatic       fixed bin(17,0)          dcl 5-41
iam_maximum_number_of_indices          automatic       fixed bin(17,0)          dcl 5-39
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 17-125
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 17-125
label_dtype                            internal static fixed bin(17,0)          initial dcl 17-25
numeric_specification                  based           structure                level 1 unaligned dcl 10-63
numeric_specification_ptr              automatic       pointer                  dcl 10-70
offset_dtype                           internal static fixed bin(17,0)          initial dcl 17-25
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 17-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 17-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 17-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 17-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 17-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 17-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 17-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 17-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 17-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 17-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 17-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 17-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 17-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 17-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 17-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 17-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 17-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 17-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 17-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 17-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 17-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 17-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 17-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 17-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 17-125
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 17-25
real_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 17-25
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 17-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 17-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 17-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 17-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 17-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 17-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 17-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 17-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 17-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 17-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 17-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 17-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 17-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 17-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 17-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 17-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 17-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 17-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 17-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 17-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 17-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 17-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 17-25
record_manager_$create_collection
                                000000 constant        entry                    external dcl 14-27
record_manager_$delete_records_by_id_list
                                000000 constant        entry                    external dcl 14-66
record_manager_$delete_records_by_spec
                                000000 constant        entry                    external dcl 14-69
record_manager_$destroy_collection
                                000000 constant        entry                    external dcl 14-31
record_manager_$get_record_count
                                000000 constant        entry                    external dcl 14-52
record_manager_$get_record_count_by_interval
                                000000 constant        entry                    external dcl 14-54
record_manager_$get_record_ids_by_interval
                                000000 constant        entry                    external dcl 14-50
record_manager_$get_record_ids_by_spec
                                000000 constant        entry                    external dcl 14-48
record_manager_$get_records_and_ids_by_interval
                                000000 constant        entry                    external dcl 14-46
record_manager_$get_records_and_ids_by_spec
                                000000 constant        entry                    external dcl 14-44
record_manager_$get_records_by_id_list
                                000000 constant        entry                    external dcl 14-38
record_manager_$get_records_by_interval
                                000000 constant        entry                    external dcl 14-42
record_manager_$get_records_by_spec
                                000000 constant        entry                    external dcl 14-40
record_manager_$modify_records_by_id_list
                                000000 constant        entry                    external dcl 14-75
record_manager_$modify_records_by_spec
                                000000 constant        entry                    external dcl 14-78
record_manager_$put_record_by_id
                                000000 constant        entry                    external dcl 14-57
record_manager_$put_records_by_id
                                000000 constant        entry                    external dcl 14-60
search_specification_ptr               automatic       pointer                  dcl 10-58
specification_head_ptr                 automatic       pointer                  dcl 9-18
structure_dtype                        internal static fixed bin(17,0)          initial dcl 17-25
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 179
tva_maximum_dimension_name_length      automatic       fixed bin(17,0)          dcl 8-48
tva_number_of_dimensions               automatic       fixed bin(17,0)          dcl 8-46
tva_number_of_vector_slots             automatic       fixed bin(17,0)          dcl 8-44
typed_vector_array                     based           structure                level 1 dcl 8-21
typed_vector_array_ptr                 automatic       pointer                  dcl 8-43

NAMES DECLARED BY EXPLICIT CONTEXT.
BK_FIELD_LOOP                   001410 constant        label                    dcl 400
BRT_ATTRIBUTE_LOOP              001656 constant        label                    dcl 478
BRT_BIT_VARYING                 001765 constant        label                    dcl 491
BRT_CHAR_VARYING                001716 constant        label                    dcl 481
BRT_FIXED_SIZE                  002031 constant        label                    dcl 501
BR_ALLOC_NEW_RECORD             001533 constant        label                    dcl 432
BR_DIMENSION_LOOP               001601 constant        label                    dcl 442
BS_FIELD_LOOP                   002037 constant        label                    dcl 523
BUILD_KEY                       001356 constant        entry                    internal dcl 375 ref 723 783
BUILD_RECORD                    001525 constant        entry                    internal dcl 416 ref 715
BUILD_RECORD_TEMPLATE           001654 constant        entry                    internal dcl 456 ref 292 321
BUILD_SPEC                      002035 constant        entry                    internal dcl 508 ref 632 729 793
CHECK_VERSION                   002330 constant        entry                    internal dcl 569 ref 239 250 252 254 256 258
CHECK_VERSION_FB                002432 constant        entry                    internal dcl 583 ref 199 220
DELETE                          001041 constant        label                    dcl 275
DELETE_TUPLE                    002526 constant        entry                    internal dcl 597 ref 283 289 295
ERROR_RETURN                    001345 constant        entry                    internal dcl 364 ref 248 622 623 637 642 710 713 732
                                                                                  742 749 797 803 829 851
FINISH                          001202 constant        entry                    internal dcl 336 ref 242 332 370
FREE_SIMPLE_TYPED_VECTOR        002754 constant        entry                    internal dcl 649 ref 349
GET_CURSORS                     001003 constant        label                    dcl 262
GET_OPENING_INFO_STRUCTURES     000605 constant        label                    dcl 244
INIT_SPEC                       002151 constant        entry                    internal dcl 538 ref 273
JOIN                            000524 constant        label                    dcl 232 ref 189 202
MAIN_RETURN                     001200 constant        label                    dcl 333 ref 371
MODIFY                          001105 constant        label                    dcl 301
MODIFY_JOIN                     000436 constant        label                    dcl 224 ref 211
MODIFY_TUPLE                    003114 constant        entry                    internal dcl 685 ref 312 318 324
ROLLBACK_TUPLE                  003441 constant        entry                    internal dcl 756 ref 739
RT_REMOVE_NEW_VALUE             003535 constant        label                    dcl 789
RT_REPLACE_OLD_VALUE            003602 constant        label                    dcl 800
SET_CURSOR_PTR_FOR_THIS_INDEX   003664 constant        entry                    internal dcl 836 ref 268
SET_RECORD_COLLECTION_CURSOR_PTR
                                003625 constant        entry                    internal dcl 814 ref 265
TUPLE_ALREADY_PROCESSED         003750 constant        entry                    internal dcl 861 ref 618
delete                          000261 constant        entry                    external dcl 183
delete_array                    000305 constant        entry                    external dcl 192
modify                          000353 constant        entry                    external dcl 205
modify_array                    000377 constant        entry                    external dcl 213
rlm_process_tuples_by_id        000246 constant        entry                    external dcl 99

NAME DECLARED BY CONTEXT OR IMPLICATION.
unspec                                                 builtin function         ref 480

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4524        4576    4212        4534
Length      5420    4212        52         605     311           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rlm_process_tuples_by_id            664 external procedure  is an external procedure.  
on unit on line 242                  64 on unit               
FINISH                              110 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  
BUILD_KEY                               internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  
BUILD_RECORD                            internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  
BUILD_RECORD_TEMPLATE                   internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  
BUILD_SPEC                              internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  
INIT_SPEC                               internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  
CHECK_VERSION_FB                        internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  
DELETE_TUPLE                            internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  
FREE_SIMPLE_TYPED_VECTOR                internal procedure  shares stack frame of internal procedure FINISH.  
MODIFY_TUPLE                            internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  
ROLLBACK_TUPLE                          internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  
SET_RECORD_COLLECTION_CURSOR_PTR
                                        internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  
SET_CURSOR_PTR_FOR_THIS_INDEX           internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  
TUPLE_ALREADY_PROCESSED                 internal procedure  shares stack frame of external procedure rlm_process_tuples_by_id.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
FINISH                   000106 fstv_vector_ptr             FREE_SIMPLE_TYPED_VECTOR
                         000110 fstv_dimension_idx          FREE_SIMPLE_TYPED_VECTOR
                         000111 fstv_storage_size           FREE_SIMPLE_TYPED_VECTOR
                         000112 fstv_current_value_ptr      FREE_SIMPLE_TYPED_VECTOR
rlm_process_tuples_by_id 000100 an_index_field_is_modified  rlm_process_tuples_by_id
                         000101 delete                      rlm_process_tuples_by_id
                         000102 process_single_tuple        rlm_process_tuples_by_id
                         000104 key_ptr                     rlm_process_tuples_by_id
                         000106 key_spec_ptr                rlm_process_tuples_by_id
                         000110 new_record_ptr              rlm_process_tuples_by_id
                         000112 old_record_ptr              rlm_process_tuples_by_id
                         000114 dm_area_ptr                 rlm_process_tuples_by_id
                         000116 record_cursor_ptr           rlm_process_tuples_by_id
                         000120 code                        rlm_process_tuples_by_id
                         000121 index_idx                   rlm_process_tuples_by_id
                         000122 number_of_tuples_processed  rlm_process_tuples_by_id
                         000123 number_of_tuples_to_process rlm_process_tuples_by_id
                         000124 tuple_idx                   rlm_process_tuples_by_id
                         000125 tuple_id                    rlm_process_tuples_by_id
                         000134 relation_cursor_ptr         rlm_process_tuples_by_id
                         000136 relation_opening_info_ptr   rlm_process_tuples_by_id
                         000140 relation_header_ptr         rlm_process_tuples_by_id
                         000142 attribute_info_ptr          rlm_process_tuples_by_id
                         000144 index_attribute_map_ptr     rlm_process_tuples_by_id
                         000146 INITIAL_NUMBER_OF_INDICES   rlm_process_tuples_by_id
                         000147 UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                                            rlm_process_tuples_by_id
                         000150 index_cursor_array_ptr      rlm_process_tuples_by_id
                         000152 ica_number_of_indices       rlm_process_tuples_by_id
                         000154 simple_typed_vector_ptr     rlm_process_tuples_by_id
                         000156 stv_number_of_dimensions    rlm_process_tuples_by_id
                         000160 general_typed_vector_ptr    rlm_process_tuples_by_id
                         000162 ss_number_of_and_groups     rlm_process_tuples_by_id
                         000163 ss_maximum_number_of_constraints
                                                            rlm_process_tuples_by_id
                         000164 element_id_list_ptr         rlm_process_tuples_by_id
                         000166 ELEMENT_ID_LIST_VERSION_1   rlm_process_tuples_by_id
                         000170 arg_descriptor_ptr          rlm_process_tuples_by_id
                         000172 extended_arg_type           rlm_process_tuples_by_id
                         000220 bk_field_idx                BUILD_KEY
                         000221 bk_record_field_idx         BUILD_KEY
                         000222 bk_old_value_ptr            BUILD_KEY
                         000224 bk_new_value_ptr            BUILD_KEY
                         000256 br_dim_idx                  BUILD_RECORD
                         000257 br_field_idx                BUILD_RECORD
                         000260 br_field_value_ptr          BUILD_RECORD
                         000272 brt_template_length         BUILD_RECORD_TEMPLATE
                         000274 brt_template_ptr            BUILD_RECORD_TEMPLATE
                         000276 brt_attr_idx                BUILD_RECORD_TEMPLATE
                         000277 brt_descriptor              BUILD_RECORD_TEMPLATE
                         000330 bs_field_idx                BUILD_SPEC
                         000362 is_field_idx                INIT_SPEC
                         000430 dt_code                     DELETE_TUPLE
                         000431 dt_index_idx                DELETE_TUPLE
                         000432 dt_index_cursor_ptr         DELETE_TUPLE
                         000444 mt_code                     MODIFY_TUPLE
                         000445 mt_index_idx                MODIFY_TUPLE
                         000446 mt_key_must_be_modified     MODIFY_TUPLE
                         000450 mt_index_cursor_ptr         MODIFY_TUPLE
                         000462 rt_code                     ROLLBACK_TUPLE
                         000463 rt_index_idx                ROLLBACK_TUPLE
                         000464 rt_key_must_be_modified     ROLLBACK_TUPLE
                         000466 rt_index_cursor_ptr         ROLLBACK_TUPLE
                         000500 srccp_record_collection_cursor_ptr
                                                            SET_RECORD_COLLECTION_CURSOR_PTR
                         000502 srccp_code                  SET_RECORD_COLLECTION_CURSOR_PTR
                         000512 scpfti_code                 SET_CURSOR_PTR_FOR_THIS_INDEX
                         000514 scpfti_index_cursor_ptr     SET_CURSOR_PTR_FOR_THIS_INDEX
                         000524 tap_tuple_idx               TUPLE_ALREADY_PROCESSED

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          enable_op
ext_entry           int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
data_format_util_$get_data_bit_length                       get_dm_free_area_             index_manager_$create_cursor
index_manager_$delete_key     index_manager_$put_key        record_manager_$create_cursor
record_manager_$delete_record_by_id                         record_manager_$destroy_cursor
record_manager_$get_record_by_id                            record_manager_$modify_record_by_id
rlm_opening_info$get          sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$key_duplication     dm_error_$key_not_found       dm_error_$record_not_found    dm_error_$tuple_not_found_id
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    118 000210       121 000211       122 000212       124 000221       125 000222       126 000223       128 000224
 1   42 000225    3   29 000226    4   29 000227    5   37 000230    5   45 000231    5   47 000233    6   17 000234
 6   18 000236   13   28 000237   16   36 000241        99 000245       102 000254       183 000255       186 000272
    187 000274       188 000275       189 000277       192 000300       195 000320       196 000322       198 000323
    199 000327       201 000342       202 000345       205 000346       208 000364       209 000365       210 000367
    211 000371       213 000372       216 000412       217 000413       219 000414       220 000420       222 000433
    224 000436       226 000442       232 000524       235 000532       237 000534       239 000540       241 000554
    242 000563       247 000605       248 000621       250 000625       251 000652       252 000655       253 000700
    254 000703       255 000726       256 000731       257 000753       258 000756       265 001003       267 001016
    268 001031       269 001033       273 001035       275 001037       279 001041       282 001043       283 001046
    285 001050       288 001051       289 001054       291 001056       292 001060       293 001062       294 001071
    295 001074       297 001076       298 001102       300 001104       304 001105       305 001112       306 001126
    308 001131       311 001133       312 001136       314 001140       317 001141       318 001144       320 001146
    321 001150       322 001152       323 001161       324 001164       326 001166       327 001172       332 001174
    333 001200       336 001201       338 001207       341 001214       344 001220       346 001232       349 001242
    352 001255       356 001273       359 001320       362 001344       364 001345       369 001347       370 001351
    371 001355       375 001356       397 001360       398 001361       400 001410       402 001427       403 001456
    404 001465       405 001474       406 001503       408 001511       410 001513       412 001524       416 001525
    432 001527       436 001533       437 001543       440 001562       442 001601       444 001617       445 001633
    447 001641       450 001651       452 001653       456 001654       478 001656       480 001671       481 001710
    485 001716       486 001720       487 001735       488 001740       489 001752       490 001762       491 001763
    495 001765       496 001767       497 002004       498 002007       499 002021       501 002031       504 002032
    506 002034       508 002035       523 002037       525 002063       530 002131       531 002133       532 002145
    534 002150       538 002151       548 002153       549 002155       551 002163       553 002207       554 002211
    555 002213       556 002215       557 002221       558 002223       559 002253       561 002276       562 002311
    563 002325       565 002327       569 002330       576 002341       581 002431       583 002432       590 002443
    595 002525       597 002526       612 002530       614 002532       616 002533       618 002557       622 002602
    623 002612       626 002614       628 002631       631 002651       632 002657       633 002677       634 002720
    637 002727       639 002731       641 002733       642 002747       645 002753       649 002754       659 002756
    663 002760       664 002763       666 002764       667 002777       668 003015       669 003024       671 003043
    673 003057       676 003073       677 003100       679 003102       681 003113       685 003114       706 003116
    708 003117       710 003143       713 003157       715 003161       718 003176       720 003213       723 003233
    725 003257       728 003263       729 003272       731 003312       732 003333       734 003337       735 003353
    739 003360       742 003412       746 003414       748 003416       749 003434       752 003440       756 003441
    778 003443       780 003453       783 003473       785 003517       788 003523       789 003532       793 003535
    795 003555       797 003576       802 003602       803 003616       808 003622       810 003624       814 003625
    822 003627       824 003631       826 003632       829 003654       832 003660       836 003664       844 003666
    848 003714       851 003735       854 003741       857 003747       861 003750       876 003752       879 003760
    880 003763       881 003774       882 004001       884 004007


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
