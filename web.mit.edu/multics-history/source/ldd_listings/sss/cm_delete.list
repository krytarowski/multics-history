	COMPILATION LISTING OF SEGMENT cm_delete
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/06/86  1300.8 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-02-27,Pierret), approve(86-02-27,MCR7340),
       12*     audit(86-04-28,Newcomb), install(86-05-06,MR12.0-1054):
       13*     Changed GET_CONTINUATION to correctly use a continued-datum header, not a
       14*     continued-continuation-datum header, to get the continuation datum id.
       15*  2) change(86-04-22,Pierret), approve(86-04-22,MCR7340),
       16*     audit(86-04-28,Newcomb), install(86-05-06,MR12.0-1054):
       17*     Removed dm_cm_datum_constants.incl.pl1 as it was not used.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* DESCRIPTION
       22*
       23*          This routine deletes an element specified by p_element_id.  If using
       24*     the Basic Element Storage Method the return value of p_element_id is
       25*     the id of the next non-free, non-continuation datum (if there is one in
       26*     the collection); otherwise p_element_id is "0"b, meaning that the deleted
       27*     element was the last element of the collection.
       28*     
       29*          Basic ESM elements are deleted by zeroing the slot in which the 
       30*     containing datum is stored;  Ordered ESM elements are deleted by shifting
       31*     slots to the right of the containing datum one slot towards the left.
       32*     If this action leaves free slots at the end of the slot table, those slots
       33*     are removed and the number of slots is decremented. If there remain any 
       34*     free slots withinn the table, the free_slot_is_present flag is turned on.
       35*     
       36*          The zero-on-free option (indicated by p_zero_on_free) is not yet
       37*     implemented.
       38*
       39*CONVENTIONS:
       40*     
       41*     Labels, internal procedure labels and constant names are all in
       42*     upper-case. Parameter variables are prefixed with "p_". Variables
       43*     declared in subroutine are perfixed with the lowercase initials of the
       44*     subroutine name.  Subroutine parameters are prefixed with <initials>_p_.
       45*     
       46*     When an error is encountered, whether in the main procedure are in a
       47*     subroutine, the ERROR_RETURN subroutine is invoked, which sets the 
       48*     output code p_code and causes a return to the caller of the main 
       49*     procedure.  For this reason, code checks are unnecessary after control
       50*     returns from a subroutine.
       51**/
       52 
       53 /* HISTORY:
       54*Written by Matthew Pierret 04/../82.
       55*Modified:
       56*05/20/82 by Matthew Pierret: Changed to use collection_header instead of
       57*            collmgr_header.collection (), and to call cm_get_collection_header.
       58*            Added ability to free uninitialized trailing slots.
       59*06/15/82 by Matthew Pierret: Changed to use bci_header, dm_cm_basic_ci.incl.pl1,
       60*            ci_parts offset to ignore non-addressable ci header.
       61*08/13/82 by Matthew Pierret:  Added Basic ESM.
       62*09/09/82 by Matthew Pierret:  Changed to return the element_id of the next
       63*            element.  Fixed bug in calculation of offset of slots to shift.
       64*            Changed datum_slots_buffer to always be based on number_of_slots,
       65*            removing number_of_slots_to_shift.
       66*09/10/82 by Lindsey Spratt: Changed to call PUT_HEADER_AND_SLOTS in each of
       67*	  the freeing cases.  This is necessary because the data being put,
       68*	  in some cases, is allocated in a begin block and therefore
       69*	  vanishes at the end of the code for that case.
       70*10/20/82 by Matthew Pierret:  Converted to use file_manager_.
       71*11/10/82 by Matthew Pierret:  Changed to support multi-datum elements, free
       72*            control interval if nothing left (BESM only).
       73*02/08/83 by Mathew Pierret:  Upgraded to CM_INFO_VERSION_2. Changed to use
       74*            cm_get_bci_header$slot instead of cm_get_header_and_slot.
       75*            Changed to return dm_error_$no_element if p_element_id.index = 0.
       76*04/06/83 by Lindsey L. Spratt:  Fixed to use the correct datum header size
       77*            when getting the continuation of a multi-datum element.  It was
       78*            using the continued-continuation datum header length when it
       79*            should have been using the conintued datum header length.
       80*            Fixed GET_CONTINUED_CONTINUATION to correctly interpret the datum
       81*            header.
       82*07/14/83 by Matthew Pierret:  Essentially re-wrote most of the module to
       83*            simplify the code and make the ordered and basic ESMs behave in a
       84*            similar fashion.  Now both get the whole slot table always, modify
       85*            the slots, check for free slots, decrement the number of datums
       86*            and replace the bci_header and slot table.  Both also use
       87*            cm_get_id to position.  Also, added an ERROR_RETURN routine which
       88*            sets p_code and non-locally goes to the main return statement in
       89*            the main procedure.  Internal subroutines use ERROR_RETURN, so
       90*            their callers can assume that if control is returned to the
       91*            caller, no errors were encountered.  Also, renamed subroutine
       92*            variables to be prefixed with the initials of the subroutine.
       93*10/14/83 by Lindsey L. Spratt:  Changed to use cm_get_id$info_header instead
       94*            of cm_get_id$header.
       95*02/07/84 by Matthew Pierret:  Changed to use cm_get_id$id instead of
       96*            $info_header.  $info_header is now obsolete.  In the future, this
       97*            routine should be changed to look at data in control intervals by
       98*            getting a pointer to the addressable portion of the control
       99*            interval via file_manager_$get_ci_ptr, and should use
      100*            cm_get_id$ptr.
      101*05/21/84 by Matthew Pierret: Renamed include file dm_cm_esm_info to
      102*            dm_esm_info.
      103*09/28/84 by Matthew Pierret: Renamed to cm_delete from cm_free_element in
      104*            accordance with new naming scheme for operations. Corrected a
      105*            situation wherein it was possible to free a control interval 
      106*            because there was no datum left after the deletion, but then
      107*            write into that freed control interval by calling
      108*            PUT_HEADER_AND_SLOTS. Removed include files from subroutines,
      109*            adding explicit pointer references in those subroutines to
      110*            structures that are declared globally. Cleaned up incorrect
      111*            declarations.  Added use of file_mnager_$simple_get.
      112*12/03/84 by Matthew Pierret: Changed to use my_ci_parts instead of
      113*            automatic_ci_parts_buffer, the former using a "like" to
      114*            ci_parts.part.  Fixed the improper use of the glogal
      115*            datum_slot instead of using an explicit pointer reference in
      116*            PUT_HEADER_AND_SLOTS.
      117*12/11/84 by Matthew Pierret:  Initialized my_ci_parts.pad to 0.
      118*05/21/85 by Matthew C. Pierret:  Changed GET_CONTINUATION to correctly assume
      119*            the supplied offset is to the beginning of a continued-datum, not
      120*            a continued-continuation-datum.  The two have different headers,
      121*            so incorrect an value was being returned.
      122**/
      123 
      124 /* format: style2,ind3 */
      125 
      126 cm_delete:
      127    proc (p_file_opening_id, p_collection_id, p_element_id, p_zero_on_free, p_code);
      128 
      129 
      130 /* START OF DECLARATIONS */
      131 /* Parameter */
      132 
      133       dcl	    p_cm_info_ptr	       ptr;
      134       dcl	    p_file_opening_id      bit (36) aligned;
      135       dcl	    p_collection_id	       bit (36) aligned;
      136       dcl	    p_element_id	       bit (36) aligned;
      137       dcl	    p_zero_on_free	       bit (1) aligned;
      138       dcl	    p_code	       fixed bin (35);
      139 
      140 /* Automatic */
      141 
      142       dcl	    code		       fixed bin (35);
      143       dcl	    1 automatic_bci_header aligned like bci_header;
      144       dcl	    1 automatic_datum_slot aligned like datum_slot;
      145       dcl	    1 my_ci_parts	       aligned,
      146 	      2 number_of_ci_parts fixed bin init (0),
      147 	      2 pad	       fixed bin init (0),
      148 	      2 part	       (2) like ci_parts.part;
      149 
      150       dcl	    continuation_datum_id_string
      151 			       bit (36) aligned init ("0"b);
      152       dcl	    next_element_id_string bit (36) aligned init ("0"b);
      153 
      154       dcl	    is_ordered_esm	       bit (1) aligned init ("0"b);
      155 
      156       dcl	    first_free_slot_idx    fixed bin (17);
      157       dcl	    slot_idx	       fixed bin (17);
      158       dcl	    st_number_of_slots     fixed bin (17);
      159 
      160 /* Based */
      161 /* Builtin */
      162 
      163       dcl	    (addr, divide, null, size, unspec)
      164 			       builtin;
      165 
      166 /* Controlled */
      167 /*  Constant */
      168 
      169       dcl	    myname	       init ("cm_delete") char (32) varying int static options (constant);
      170       dcl	    RELATIVE	       init ("0"b) bit (1) aligned int static options (constant);
      171       dcl	    NEXT_ELEMENT	       init (1) fixed bin (17) int static options (constant);
      172       dcl	    BITS_PER_BYTE	       init (9) fixed bin int static options (constant);
      173       dcl	    BYTES_PER_WORD	       init (4) fixed bin int static options (constant);
      174 
      175 /* Entry */
      176 
      177       dcl	    file_manager_$get      entry (bit (36) aligned, fixed bin (27), ptr, fixed bin (35));
      178       dcl	    file_manager_$put      entry (bit (36) aligned, fixed bin (27), ptr, fixed bin (35));
      179       dcl	    file_manager_$simple_get
      180 			       entry (bit (36) aligned, fixed bin (27), fixed bin (21), ptr, fixed bin (21),
      181 			       fixed bin (35));
      182       dcl	    sub_err_	       entry () options (variable);
      183 
      184 /* External */
      185 
      186       dcl	    (
      187 	    dm_error_$end_of_collection,
      188 	    dm_error_$no_element,
      189 	    dm_error_$ci_not_in_collection
      190 	    )		       ext fixed bin (35);
      191       dcl	    error_table_$unimplemented_version
      192 			       ext fixed bin (35);
      193 
      194 /* END OF DECLARATIONS */
      195 
      196 /* format: ^indblkcom,indcomtxt */
      197 
      198       code = 0;
      199       call cm_opening_info$get (p_file_opening_id, p_collection_id, cm_info_ptr, code);
      200       if code ^= 0
      201       then call ERROR_RETURN (code);
      202       else go to JOIN;
      203 
      204 
      205 info:
      206    entry (p_cm_info_ptr, p_element_id, p_zero_on_free, p_code);
      207 
      208       code = 0;
      209       cm_info_ptr = p_cm_info_ptr;
      210       go to JOIN;
      211 
      212 JOIN:
      213       p_code = 0;
      214 
      215       call CHECK_VERSION ("cm_info", cm_info.version, CM_INFO_VERSION_2);
      216 
      217       collection_header_ptr = cm_info.header_ptr;
      218       call CHECK_VERSION ("collection_header", collection_header.version, COLLECTION_HEADER_VERSION_2);
      219 
      220       element_id_string = p_element_id;
      221       if element_id.index = 0
      222       then call ERROR_RETURN (dm_error_$no_element);
      223 
      224       bci_header_ptr = addr (automatic_bci_header);
      225       datum_slot_ptr = addr (automatic_datum_slot);
      226 
      227       call cm_get_bci_header$slot (cm_info.file_oid, bci_header_ptr, datum_slot_ptr, element_id_string, code);
      228       if code ^= 0
      229       then call ERROR_RETURN (code);
      230 
      231       if bci_header.collection_id ^= cm_info.collection_id
      232       then call ERROR_RETURN (dm_error_$ci_not_in_collection);
      233 
      234       if datum_slot.offset_in_bytes = FREE_SLOT | datum_slot.flags.is_continuation
      235       then call ERROR_RETURN (dm_error_$no_element);
      236 
      237 
      238       if collection_header.element_storage_method = ORDERED_ELEMENT_STORAGE_METHOD
      239       then is_ordered_esm = "1"b;
      240       else is_ordered_esm = "0"b;
      241 
      242       if datum_slot.is_continued
      243       then
      244          do;
      245 
      246          /*** The element is a multi-datum element. Free the trailing
      247*	    datums first. It is necessary to get the id of the first continuation
      248*	    datum out of this initial datum.  The routine cm_delete_cn_datum will
      249*	    return subsequent continuation ids. */
      250 
      251 	  continuation_datum_id_string =
      252 	       GET_CONTINUATION ((element_id.control_interval_id), (datum_slot.offset_in_bytes));
      253 
      254 	  do while (continuation_datum_id_string ^= "0"b);
      255 
      256 	     call cm_delete_cn_datum (cm_info_ptr, p_zero_on_free, continuation_datum_id_string, code);
      257 	     if code ^= 0
      258 	     then call ERROR_RETURN (code);
      259 	  end;
      260 
      261          end;
      262 
      263       st_number_of_slots = bci_header.number_of_datums;
      264 
      265 BEGIN_BLOCK:
      266       begin;
      267 
      268          dcl     1 slot_table		aligned,
      269 	         2 slot		(st_number_of_slots) like datum_slot;
      270 
      271          ci_parts_ptr = addr (my_ci_parts);
      272          ci_parts.number_of_parts = 1;
      273          call GET_SLOT_TABLE (cm_info.file_oid, (element_id.control_interval_id), addr (slot_table), st_number_of_slots,
      274 	    ci_parts_ptr);
      275 
      276          if ^is_ordered_esm
      277          then
      278 	  do;
      279 
      280 	  /*** This is a basic collection. Find the id of the next element, to be returned
      281*	       to the caller. This must be done before deleteing the specified element. */
      282 
      283 	     call cm_get_id$id (cm_info.file_oid, cm_info.collection_id, element_id_string, NEXT_ELEMENT, RELATIVE,
      284 		next_element_id_string, code);
      285 	     if code ^= 0
      286 	     then if code = dm_error_$end_of_collection
      287 		then code = 0;
      288 		else call ERROR_RETURN (code);
      289 	  end;
      290 
      291          if is_ordered_esm
      292          then
      293 	  do;
      294 
      295 	  /*** This is an ordered collection. Shift slots one to left and
      296*	       decrement the number of datums in the control interval. */
      297 
      298 	     do slot_idx = element_id.index to bci_header.number_of_datums - 1;
      299 	        slot_table.slot (slot_idx) = slot_table.slot (slot_idx + 1);
      300 	     end;
      301 	     unspec (slot_table.slot (slot_idx)) = "0"b;
      302 	     bci_header.number_of_datums = bci_header.number_of_datums - 1;
      303 
      304 	  end;
      305          else /* Simply free the specified slot */
      306 	    unspec (slot_table.slot (element_id.index)) = "0"b;
      307 
      308 
      309          do slot_idx = bci_header.number_of_datums to 1 by -1 while (unspec (slot_table.slot (slot_idx)) = "0"b);
      310          end;
      311 
      312 
      313          if ^is_ordered_esm & slot_idx <= 0
      314          then
      315 FREE_ENTIRE_CI:
      316 	  do;
      317 
      318 	  /*** The control interval is empty.  Free it */
      319 
      320 	     call cm_free_ci$info (cm_info_ptr, (element_id.control_interval_id), p_zero_on_free, code);
      321 	     if code ^= 0
      322 	     then call ERROR_RETURN (code);
      323 	  end FREE_ENTIRE_CI;
      324          else
      325 UPDATE_CI:
      326 	  do;
      327 
      328 	  /*** There remains at least one datum in the control interval.
      329*	       Update the number of datums in the bci_header, and the
      330*	       free_slot_is_resent flag if there remain any free slots.
      331*	       Then put the modified bci_header and datum_slot_table back
      332*	       in the control interval. */
      333 
      334 	     bci_header.number_of_datums = slot_idx;
      335 
      336 	     do first_free_slot_idx = 1 to bci_header.number_of_datums
      337 		while (unspec (slot_table.slot (first_free_slot_idx)) ^= ""b);
      338 	     end;
      339 	     if first_free_slot_idx < bci_header.number_of_datums
      340 	     then bci_header.flags.free_slot_is_present = "1"b;
      341 	     else bci_header.flags.free_slot_is_present = "0"b;
      342 
      343 	     call PUT_HEADER_AND_SLOTS (cm_info.file_oid, bci_header_ptr, datum_slot_ptr,
      344 		(element_id.control_interval_id), ci_parts_ptr);
      345 
      346 	  end UPDATE_CI;
      347       end BEGIN_BLOCK;
      348 
      349       if ^is_ordered_esm
      350       then p_element_id = next_element_id_string;
      351 
      352 MAIN_RETURN:
      353       return;
      354 
      355 ERROR_RETURN:
      356    proc (er_p_code);
      357 
      358       dcl	    er_p_code	       fixed bin (35);
      359 
      360       p_code = er_p_code;
      361       go to MAIN_RETURN;
      362 
      363    end ERROR_RETURN;
      364 
      365 CHECK_VERSION:
      366    proc (cv_p_structure_name, cv_p_given_version, cv_p_correct_version);
      367 
      368       dcl	    cv_p_structure_name    char (*);
      369       dcl	    cv_p_given_version     char (8) aligned;
      370       dcl	    cv_p_correct_version   char (8) aligned;
      371 
      372       if cv_p_given_version ^= cv_p_correct_version
      373       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      374 	      "^/Expected version ^8a of ^a structure; received ^8a.", cv_p_correct_version, cv_p_structure_name,
      375 	      cv_p_given_version);
      376       else return;
      377 
      378    end CHECK_VERSION;
      379 
      380 PUT_HEADER_AND_SLOTS:
      381    proc (phas_p_file_opening_id, phas_p_bci_header_ptr, phas_p_datum_slot_ptr, phas_p_control_interval_id,
      382         phas_p_ci_parts_ptr);
      383 
      384       dcl	    phas_p_file_opening_id bit (36) aligned;
      385       dcl	    phas_p_bci_header_ptr  ptr;
      386       dcl	    phas_p_datum_slot_ptr  ptr;
      387       dcl	    phas_p_control_interval_id
      388 			       fixed bin (27);
      389       dcl	    phas_p_ci_parts_ptr    ptr;
      390       dcl	    phas_code	       fixed bin (35);
      391 
      392       phas_code = 0;
      393 
      394       if phas_p_datum_slot_ptr -> datum_slot.offset_in_bytes = phas_p_bci_header_ptr -> bci_header.start_of_used_space
      395       then phas_p_bci_header_ptr -> bci_header.start_of_used_space =
      396 	      phas_p_bci_header_ptr -> bci_header.start_of_used_space
      397 	      + BITS_TO_BYTES ((phas_p_datum_slot_ptr -> datum_slot.length_in_bits));
      398       else phas_p_bci_header_ptr -> bci_header.scattered_free_space =
      399 	      phas_p_bci_header_ptr -> bci_header.scattered_free_space
      400 	      + BITS_TO_BYTES ((phas_p_datum_slot_ptr -> datum_slot.length_in_bits));
      401 
      402 
      403       phas_p_ci_parts_ptr -> ci_parts.number_of_parts = 2;
      404       phas_p_ci_parts_ptr -> ci_parts.part (2).offset_in_bytes = 0;
      405       phas_p_ci_parts_ptr -> ci_parts.part (2).length_in_bytes = size (bci_header) * BYTES_PER_WORD;
      406       phas_p_ci_parts_ptr -> ci_parts.part (2).local_ptr = phas_p_bci_header_ptr;
      407 
      408       call file_manager_$put (phas_p_file_opening_id, phas_p_control_interval_id, phas_p_ci_parts_ptr, phas_code);
      409       if phas_code ^= 0
      410       then call ERROR_RETURN (phas_code);
      411       else return;
      412 
      413    end PUT_HEADER_AND_SLOTS;
      414 
      415 BITS_TO_BYTES:
      416    proc (btb_p_bits) returns (fixed bin (17));
      417 
      418       dcl	    btb_p_bits	       fixed bin (35);
      419 
      420       return (divide (btb_p_bits + BITS_PER_BYTE - 1, BITS_PER_BYTE, 17, 0));
      421 
      422    end BITS_TO_BYTES;
      423 
      424 GET_CONTINUATION:
      425    proc (gc_p_ci, gc_p_offset) returns (bit (36) aligned);
      426 
      427 /* Given the CI and the offset in bytes within the CI of a continued_datum
      428*   (i.e., the first datum of a multi-datum element), this routine returns
      429*   the continuation id in the continued_datum's header. This is the id of
      430*   the second datum of the multi-datum element. */
      431 
      432       dcl	    gc_p_ci	       fixed bin (27);
      433       dcl	    gc_p_offset	       fixed bin (21);
      434       dcl	    1 gc_continued_datum_header
      435 			       aligned like continued_datum.header;
      436       dcl	    gc_code	       fixed bin (35);
      437 
      438       call file_manager_$simple_get (cm_info.file_oid, gc_p_ci, gc_p_offset, addr (gc_continued_datum_header),
      439 	 (size (gc_continued_datum_header) * BYTES_PER_WORD), gc_code);
      440       if gc_code ^= 0
      441       then call ERROR_RETURN (gc_code);
      442       else return (unspec (gc_continued_datum_header.continuation));
      443 
      444 
      445    end GET_CONTINUATION;
      446 
      447 GET_SLOT_TABLE:
      448    proc (gst_p_file_oid, gst_p_control_interval_id, gst_p_slot_table_ptr, gst_p_slot_table_length_in_words,
      449         gst_p_ci_parts_ptr);
      450 
      451       dcl	    gst_p_file_oid	       bit (36) aligned;
      452       dcl	    gst_p_control_interval_id
      453 			       fixed bin (27);
      454       dcl	    gst_p_slot_table_ptr   ptr;
      455       dcl	    gst_p_slot_table_length_in_words
      456 			       fixed bin (17);
      457       dcl	    gst_p_ci_parts_ptr     ptr;
      458 
      459       dcl	    gst_code	       fixed bin (35);
      460 
      461       gst_p_ci_parts_ptr -> ci_parts.number_of_parts = 1;
      462       gst_p_ci_parts_ptr -> ci_parts.part (1).offset_in_bytes = size (bci_header) * BYTES_PER_WORD;
      463       gst_p_ci_parts_ptr -> ci_parts.part (1).length_in_bytes = gst_p_slot_table_length_in_words * BYTES_PER_WORD;
      464       gst_p_ci_parts_ptr -> ci_parts.part (1).local_ptr = gst_p_slot_table_ptr;
      465 
      466       call file_manager_$get (gst_p_file_oid, gst_p_control_interval_id, gst_p_ci_parts_ptr, gst_code);
      467       if gst_code ^= 0
      468       then call ERROR_RETURN (gst_code);
      469       else return;
      470 
      471 
      472    end GET_SLOT_TABLE;
      473 
  1     1 /* BEGIN INCLUDE FILE dm_cm_datum.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*        This include file contains the declarations of datum structures.
  1     5*   There are four tyes of datums: your ordinary, run-of-the-mill datum
  1     6*   (Datum); a continuation datum (CN Datum), which is a continuation of
  1     7*   another datum; a continued datum (CD Datum), which is continued (has a
  1     8*   continuation datum) but is not a continuation itself; and a continued
  1     9*   continuation datum (CDCN Datum), which is both continued and is a
  1    10*   continuation.  To illustrate, datums can be pieced combined in the
  1    11*   following ways:
  1    12*   
  1    13*   1) Datum alone.
  1    14*   
  1    15*   2) CD Datum -> CN Datum.
  1    16*   
  1    17*   3) CD Datum -> CDCN Datum {-> CDCN Datum -> ...-> CDCN Datum} -> CN Datum.
  1    18*
  1    19*   continued_datum and continued_continuation_datum each contains a header
  1    20*   which includes the identifier of the datum which is its continuation.
  1    21*   continued_datum.header.full_length is the length in bits of the entire
  1    22*   element, i.e., the addition of the length of contents structure component
  1    23*   of all of the datums from CD Datum to CN Datum.
  1    24**/
  1    25 
  1    26 /* HISTORY:
  1    27*Written by Matthew Pierret, 02/07/82.
  1    28*Modified:
  1    29*03/25/82 by Matthew Pierret: Changed all datum structures to be unaligned.
  1    30*06/14/82 by Matthew Pierret: Added DATUM_HEADER_LENGTH_IN_BYTES.
  1    31*08/04/82 by Matthew Pierret: Added DATUM_HEADER_LENGTH_IN_BITS.
  1    32*10/20/82 by Matthew Pierret:  Split into two include files, this one and
  1    33*            dm_cm_datum_constants.  The latter holds only and all constants
  1    34*            formerly in this include file.
  1    35*10/29/82 by Matthew Pierret:  Removed datum headers.
  1    36*09/18/84 by Matthew Pierret:  Added DESCRIPTION section.  Added datum and
  1    37*            continuation_datum (mainly for illustration).
  1    38*12/03/84 by Matthew Pierret:  Removed the non-based structures
  1    39*            (cd cdcn)_datum_headers.
  1    40**/
  1    41 
  1    42 /* format: style2,ll79,ind3 */
  1    43 
  1    44      dcl	   1 datum	      unaligned based (datum_ptr),
  1    45 	     2 contents	      bit (datum_contents_length_in_bits);
  1    46 
  1    47      dcl	   1 continuation_datum   unaligned based (datum_ptr),
  1    48 	     2 contents	      bit (datum_contents_length_in_bits);
  1    49 
  1    50      dcl	   1 continued_datum      unaligned based (datum_ptr),
  1    51 	     2 header,
  1    52 	       3 full_length      fixed bin (35),
  1    53 	       3 continuation     like datum_id,
  1    54 	     2 contents	      bit (datum_contents_length_in_bits);
  1    55 
  1    56      dcl	   1 continued_continuation_datum
  1    57 			      unaligned based (datum_ptr),
  1    58 	     2 header,
  1    59 	       3 continuation     like datum_id,
  1    60 	     2 contents	      bit (datum_contents_length_in_bits);
  1    61 
  1    62      dcl	   1 datum_id	      aligned based (datum_id_ptr),
  1    63 	     2 control_interval_id
  1    64 			      fixed bin (24) unal uns,
  1    65 	     2 index	      fixed bin (12) unal uns;
  1    66 
  1    67      dcl	   datum_ptr	      ptr init (null ());
  1    68      dcl	   datum_id_ptr	      ptr init (null ());
  1    69      dcl	   datum_contents_length_in_bits
  1    70 			      fixed bin (35) init (-1);
  1    71 
  1    72 
  1    73 
  1    74 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      474 
      475 
  2     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*        The cm_info structure is used to hold per-process opening information
  2     5*   about a collection.  It is generally allocated in the process' DM free
  2     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  2     7*   is used to provide access the cm_info structure, keeping it in a hash
  2     8*   table keyed on file opening id and collection id combined.
  2     9*        Currently cm_info is never freed until the process terminates.  Each
  2    10*   time a new transaction is started, detected when the current transaction
  2    11*   id of a process differs from cm_info.current_transaction_id, the information
  2    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  2    13*   demand, as most modules do not need the information in the storage record.
  2    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  2    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  2    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  2    17*   requested, it is placed at the location pointed to by
  2    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  2    19**/
  2    20 
  2    21 /* HISTORY:
  2    22*Written by Matthew Pierret, 10/27/82. 
  2    23*Modified:
  2    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  2    25*            storage_record_buffer_ptr. This points to the storage_record.
  2    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  2    27*            but storage_record_buffer_ptr continues to point at where the
  2    28*            storage_record was. When the storge_record is again requested,
  2    29*            it is put back in the same place rather than allocating a new
  2    30*            storage_record.
  2    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  2    32*            init clause from the version component.
  2    33**/
  2    34 
  2    35 /* format: style2,ind3,ll79 */
  2    36 
  2    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  2    38 	     2 version	      char (8),
  2    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  2    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  2    41 	     2 collection_id      bit (36) aligned init ("0"b),
  2    42 	     2 header_ptr	      ptr init (null),
  2    43 	     2 storage_record_ptr ptr init (null),
  2    44 	     2 storage_record_buffer_ptr
  2    45 			      ptr init (null);
  2    46 
  2    47      dcl	   cm_info_ptr	      ptr init (null);
  2    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  2    49 			      internal static options (constant);
  2    50 
  2    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      476 
      477 
  3     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*        The collection_manager_ manages the structure of the addressable
  3     6*   portion of a control interval.  The addressable portion is that portion of
  3     7*   a control interval which the file_manager_ will allow the
  3     8*   collection_manager_ to address.  In this description control interval will
  3     9*   be used to mean the addressable portion of a control interval.
  3    10*   
  3    11*        A control interval is divided into four parts: the header, the datum
  3    12*   position table (also known as the slot table or slots), un-used space and
  3    13*   used space.  The beginning of the header is at offset 0, and the end of the
  3    14*   used space is at the end of the control interval (curently offset 4072).
  3    15*   Pictoriarly, a control interval is structured as follows:
  3    16*   
  3    17*   ----------------------------------------------------------------------
  3    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  3    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  3    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  3    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  3    22*   ----------------------------------------------------------------------
  3    23*                                           ^ ^    ^      ^    ^  ^   ^
  3    24*                                           | |    |      |    |  |   |
  3    25*                                           | |...........|.......|...|
  3    26*                        start of used space|      |           |      |
  3    27*                                                  |           |  each|
  3    28*                                          scattered free space|  is a used
  3    29*                                                                 datum
  3    30*   
  3    31*      The basic_control_interval structure describes the header
  3    32*   (basic_control_interval.header, bci_header) and the slots
  3    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  3    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  3    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  3    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  3    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  3    38**/
  3    39 
  3    40 /* HISTORY:
  3    41*Written by Matthew Pierret, 02/07/82.
  3    42*Modified:
  3    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  3    44*            and its sub-structures.
  3    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  3    46*            basic_ci_header to bci_header. Added previous_control_interval.
  3    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  3    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  3    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  3    50*            is not used.
  3    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  3    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  3    53**/
  3    54 
  3    55 /* format: style2 */
  3    56      dcl	   1 basic_control_interval
  3    57 			      aligned based (basic_control_interval_ptr),
  3    58 	     2 header	      like bci_header,
  3    59 	     2 datum_position_table
  3    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  3    61 
  3    62 
  3    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  3    64 	     2 layout_type	      char (4) aligned,
  3    65 	     2 collection_id      bit (36) aligned,
  3    66 	     2 next_control_interval
  3    67 			      fixed bin (24) uns unal,
  3    68 	     2 previous_control_interval
  3    69 			      fixed bin (24) uns unal,
  3    70 	     2 flags	      unal,
  3    71 	       3 continuation_datum_is_present
  3    72 			      bit (1) unal,
  3    73 	       3 free_slot_is_present
  3    74 			      bit (1) unal,
  3    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  3    76 	     2 scattered_free_space
  3    77 			      fixed bin (17) unal,
  3    78 	     2 start_of_used_space
  3    79 			      fixed bin (17) unal,
  3    80 	     2 number_of_datums   fixed bin (17) unal;
  3    81 
  3    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  3    83 	     2 flags	      unal,
  3    84 	       3 special_format_datum
  3    85 			      bit (1) unal,		/* reserved */
  3    86 	       3 is_continued     bit (1) unal,
  3    87 	       3 is_continuation  bit (1) unal,
  3    88 	       3 mbz	      bit (1) unal,		/* reserved */
  3    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  3    90 	     2 length_in_bits     fixed bin (17) uns unal;
  3    91 
  3    92      dcl	   basic_control_interval_ptr
  3    93 			      ptr;
  3    94      dcl	   bci_header_ptr	      ptr;
  3    95      dcl	   datum_slot_ptr	      ptr;
  3    96 
  3    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  3    98 
  3    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      478 
      479 
  4     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*   Contains constants useful in describing parts of a basic control interval.
  4     6**/
  4     7 
  4     8 /* HISTORY:
  4     9*Written by Matthew Pierret, 09/20/84.
  4    10*Modified:
  4    11**/
  4    12 
  4    13      dcl	   FREE_SLOT	      init (0) fixed bin (15) uns internal static options (constant);
  4    14      dcl	   BCI_HEADER_LENGTH_IN_BYTES
  4    15 			      init (20) fixed bin internal static options (constant);
  4    16      dcl	   DATUM_POSITION_TABLE_OFFSET_IN_BYTES
  4    17 			      init (20) fixed bin internal static options (constant);
  4    18 
  4    19 
  4    20 /* END INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
      480 
      481 
  5     1 /* BEGIN INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*       Associated with each collection is the following collection_header
  5     5*   structure stored as an element in the Header Collection of the file.
  5     6*   The identifier of this element is also the idenfifier of the collection.
  5     7*   Even the Header Collection has a collection_header stored in the Header
  5     8*   Collection itself in the element identified by the constant
  5     9*   HEADER_COLLECTION_HEADER_ELEMENT_ID declared in dm_cm_hdr_col_ids.incl.pl1.
  5    10*   The information in collection_header is expected to be stable information.
  5    11*   The structure elements are described as follows:
  5    12*   
  5    13*   version is a character string version equal to COLLECTION_HEADER_VERSION_2.
  5    14*   
  5    15*   flags.fixed_size_elements indicates, if on that all elements in the
  5    16*   collection are of a fixed length.
  5    17*   
  5    18*   flags.thread_elements indicates that elements in a collection are to be
  5    19*   threaded in a linked list.  This is currrently unupported.
  5    20*   
  5    21*   flags.thread_control_intervals indicates, if on, that control intervals in
  5    22*   a collection are to be threaded in a linked list.  This is only useful if
  5    23*   the control interval storage method is blocked.
  5    24*   
  5    25*   flags.must_be_zero1 is reserved for future use and must be "0"b.
  5    26*   
  5    27*   control_interval_storage_method is the method of storage management of
  5    28*   control intervals for this collection, either
  5    29*   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD (not yet supported) or
  5    30*   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, declared in
  5    31*   dm_cism_info.incl.pl1.
  5    32*   
  5    33*   element_storage_method is the method of storage management of elements in
  5    34*   this collection, either BASIC_ELEMENT_STORAGE_METHOD or
  5    35*   ORDERED_ELEMENT_STORAGE_METHOD, declared in dm_esm_info.incl.pl1.
  5    36*   
  5    37*   maximum_element_size is the maximum size of an element in bits in this
  5    38*   collection.
  5    39*   
  5    40*   header_record_element_id is the identifier of an element containing a
  5    41*   caller-defined header for this collection.  If equal to "0"b, no
  5    42*   caller-defined header yet exists.  The put_header collection_manager_
  5    43*   operation stores such a header.
  5    44*   
  5    45*   storage_record_element_id is the identifier of the element containing the
  5    46*   storage_record for this collection.  The storage_record contains
  5    47*   information expected to be dynamic, such as the identifier of the last
  5    48*   control interval of the collection.  Its format is also dependent upon the
  5    49*   storage methods in effect for this collection.  storage_record structures
  5    50*   are declared in dm_cm_storage_record.incl.pl1.
  5    51*
  5    52**/
  5    53 
  5    54 /* HISTORY:
  5    55*Written by Matthew Pierret, 04/01/82.
  5    56*Modified:
  5    57*07/01/82 by Matthew Pierret: Changed to version A, added storage_record_area.
  5    58*10/29/82 by Matthew Pierret: Changed to version 2 ("col_hdr2"), separated
  5    59*            storage_record_area out, leaving storage_record_element_id behind.
  5    60*09/18/84 by Matthew Pierret: Added DESCRIPTION section.
  5    61**/
  5    62 
  5    63 /* format: style2,ind3,ll79 */
  5    64 
  5    65      dcl	   1 collection_header    aligned based (collection_header_ptr),
  5    66 	     2 version	      char (8),
  5    67 	     2 flags	      unaligned,
  5    68 	       3 fixed_size_elements
  5    69 			      bit (1),
  5    70 	       3 thread_elements  bit (1),
  5    71 	       3 thread_control_intervals
  5    72 			      bit (1),
  5    73 	       3 must_be_zero1    bit (15),
  5    74 	     2 control_interval_storage_method
  5    75 			      fixed bin (17) unal,
  5    76 	     2 element_storage_method
  5    77 			      fixed bin (17),
  5    78 	     2 maximum_element_size
  5    79 			      fixed bin (35),
  5    80 	     2 header_record_element_id
  5    81 			      bit (36) aligned,
  5    82 	     2 storage_record_element_id
  5    83 			      bit (36) aligned;
  5    84 
  5    85      dcl	   collection_header_ptr  ptr;
  5    86      dcl	   COLLECTION_HEADER_VERSION_2
  5    87 			      init ("col_hdr2") char (8) aligned
  5    88 			      int static options (constant);
  5    89 
  5    90 /* END INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
      482 
      483 
  6     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*        Contains the declaration of an element identifier.  Element
  6     6*   identifiers consist of two parts, the id (number) of the control interval
  6     7*   in which the element resides, and the index into the slot table of
  6     8*   the element in the control interval.  The declaration of the element_id 
  6     9*   structure reflects this division of the element identifier.  The structure 
  6    10*   is based on the automatic bit string element_id_string because programs
  6    11*   generally pass bit strings (element_id_string) to each other, then 
  6    12*   interpret the bit string by overlaying the element_id structure ony if
  6    13*   it is necessary to access the parts of the id.  Basing element_id on
  6    14*   addr(element_id_string) instead of on a pointer removes the necessity
  6    15*   for always setting that pointer explicitly and guarantees that changes
  6    16*   made to the string or structure do not get inconsistent.
  6    17*
  6    18*   Changes made to element_id must also be made to datum_id, declared in 
  6    19*   dm_cm_datum.incl.pl1.
  6    20**/
  6    21 
  6    22 /* HISTORY:
  6    23*Written by Matthew Pierret, 04/01/82.
  6    24*Modified:
  6    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  6    26**/
  6    27 
  6    28 /* format: style2,ind3,ll79 */
  6    29 
  6    30      dcl	   element_id_string      bit (36) aligned;
  6    31 
  6    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  6    33 	     2 control_interval_id
  6    34 			      fixed bin (24) unal unsigned,
  6    35 	     2 index	      fixed bin (12) unal unsigned;
  6    36 
  6    37 
  6    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      484 
      485 
  7     1 /* BEGIN INCLUDE FILE dm_esm_info.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*     This include file contains the basic_esm_info and ordered_esm_info
  7     6*     structures, as well as constants used to distinguish element storage
  7     7*     methods.  They are used by several managers to describe the type of
  7     8*     element storage management to be used in a collection.
  7     9**/
  7    10 
  7    11 /* HISTORY:
  7    12*Written 02/07/82 by Matthew Pierret.
  7    13*Modified:
  7    14*05/17/84 by Matthew Pierret:  Changed name from dm_cm_esm_info (the cm_
  7    15*            dropped because the include file is used by multiple managers),
  7    16*            to align structure elements and to add a version string.
  7    17**/
  7    18 
  7    19 /* format: style2 */
  7    20 
  7    21      dcl	   1 basic_esm_info	      based (basic_esm_info_ptr) aligned,
  7    22 	     2 version	      char (8) aligned init (ESM_INFO_VERSION_1),
  7    23 	     2 type	      fixed bin (17) init (BASIC_ELEMENT_STORAGE_METHOD),
  7    24 	     2 flags	      aligned,
  7    25 	       3 threaded	      bit (1) unal,
  7    26 	       3 fixed_length     bit (1) unal,
  7    27 	       3 pad	      bit (34) unal,
  7    28 	     2 maximum_element_length
  7    29 			      fixed bin (35);
  7    30 
  7    31      dcl	   1 ordered_esm_info     based (ordered_esm_info_ptr) aligned,
  7    32 	     2 version	      char (8) aligned init (ESM_INFO_VERSION_1),
  7    33 	     2 type	      fixed bin (17) init (ORDERED_ELEMENT_STORAGE_METHOD),
  7    34 	     2 flags	      aligned,
  7    35 	       3 fixed_length     bit (1) unal,
  7    36 	       3 pad	      bit (35) unal,
  7    37 	     2 maximum_element_length
  7    38 			      fixed bin (35);
  7    39 
  7    40      dcl	   basic_esm_info_ptr     ptr;
  7    41      dcl	   ordered_esm_info_ptr   ptr;
  7    42 
  7    43      dcl	   ESM_INFO_VERSION_1     init ("ESMinfo1") char (8) aligned internal static options (constant);
  7    44      dcl	   BASIC_ELEMENT_STORAGE_METHOD
  7    45 			      fixed bin init (1) internal static options (constant);
  7    46      dcl	   ORDERED_ELEMENT_STORAGE_METHOD
  7    47 			      fixed bin init (2) internal static options (constant);
  7    48 
  7    49 
  7    50 /* END INCLUDE FILE dm_esm_info.incl.pl1 */
      486 
      487 
  8     1 /*  BEGIN INCLUDE FILE:  dm_ci_parts.incl.pl1  */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*
  8     5*        This include file contains the ci_parts structure.  This structure
  8     6*   is used across the file_manager_ interface to specify the parts of a
  8     7*   control interval to get or put.  If the number_of parts is equal to 0,
  8     8*   modules which take ci_parts interpret this case to mean to do everything
  8     9*   except the actual requested operation, i.e., lock the control interval
  8    10*   but don't get anything.  offset_in_bytes is the 0-originned offset in
  8    11*   bytes from the beginning of the addressable portion of the control interval.
  8    12*   An offset_in_bytes which is in the addressable portion is in error.
  8    13*   Likewise, if offset_in_bytes + length_in_bytes is outside of the addressable
  8    14*   portion, it is in error.
  8    15**/
  8    16 
  8    17 /* HISTORY:
  8    18*Written by Matthew Pierret, 01/28/82.
  8    19*  (01/28/82 Andre Bensoussan, Design.)
  8    20*Modified:
  8    21*11/07/84 by Matthew Pierret:  To add must_be_zero, initial attributes on
  8    22*            automatic storge.
  8    23**/
  8    24 
  8    25 /* format: style2,ind3 */
  8    26 
  8    27      dcl	   1 ci_parts	      aligned based (ci_parts_ptr),
  8    28 	     2 number_of_parts    fixed bin (17),
  8    29 	     2 must_be_zero	      fixed bin,
  8    30 	     2 part	      (cip_number_of_parts refer (ci_parts.number_of_parts)),
  8    31 	       3 offset_in_bytes  fixed bin (17),
  8    32 	       3 length_in_bytes  fixed bin (17),
  8    33 	       3 local_ptr	      ptr;
  8    34 
  8    35      dcl	   ci_parts_ptr	      ptr init (null ());
  8    36      dcl	   cip_number_of_parts    fixed bin (17) init (0);
  8    37 
  8    38 
  8    39 /*  BEGIN INCLUDE FILE:   dm_ci_parts.incl.pl1   */
      488 
      489 
  9     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*
  9     5*   Contains entry declarations of internally available collection_manager_
  9     6*   entries.  Entries which are only available via the collection_manager_
  9     7*   transfer vector are not included here, but are declared instead in 
  9     8*   dm_collmgr_entry_dcls.incl.pl1.
  9     9**/
  9    10 
  9    11 /* HISTORY:
  9    12*Written by Mathew Pierret, 04/01/82.
  9    13*Modified:
  9    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
  9    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
  9    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
  9    17*            Added cm_get_element$info*, $header*.  The former is used when
  9    18*            the caller has a cm_info structure already; the latter is used to
  9    19*            get collection headers.
  9    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
  9    21*            Added cm_allocate_element$info.
  9    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
  9    23*            calling sequence for returning free space.
  9    24*            Added cm_free_cn_datum("" $header).
  9    25*01/07/83 by Matthew Pierret:  Added:
  9    26*            cm_allocate_element$buffered("" _info);
  9    27*            cm_put_element$buffered("" _info);
  9    28*            cm_put_datum_in_place$buffered("" _continued);
  9    29*            cm_put_datum_in_pool$buffered("" _continued);
  9    30*            cm_compact$buffered.
  9    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
  9    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
  9    33*            Added cm_opening_info$get_storage_record.
  9    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
  9    35*            id of the previous datum.
  9    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
  9    37*            which is for the number of slots after allocation.
  9    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
  9    39*            header header_return_slot).
  9    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
  9    41*            Added cm_get_element$bypass_info.
  9    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
  9    43*            cm_free_opening_info.
  9    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
  9    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
  9    46*            $does_replacement_fit to cm_determine_free_space.  These entries
  9    47*            return flags indicating if a datum fits in the ci and the pool.
  9    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
  9    49*            returned the new value of bci_header.free_slot_is_present.
  9    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
  9    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
  9    52*            entries.  Changed cm_get_element_$bypass_info to have the same
  9    53*            calling sequence as other cm_get_element entries.
  9    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
  9    55*            and cm_allocate_element to cm_put.
  9    56*            Switched the element_length/element_ptr parameter pair to be
  9    57*            element_ptr/element_length in cm_modify and cm_put.
  9    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
  9    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
  9    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
  9    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
  9    62*            Removed cm_find_free_space. Commented out un-used entries.
  9    63*            Re-named allocate  entries to put entries, except for allocate_ci.
  9    64*            Re-named free element and free datum entries to use delete instead
  9    65*            of free, and cm_recursive_put to cm_recursive_modify.
  9    66*            Removed cm_get_element$bypass_info.
  9    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
  9    68*            that cm_modify$buffered uses it.
  9    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
  9    70**/
  9    71 
  9    72 /* format: style2,ind3 */
  9    73 
  9    74 
  9    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  9    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
  9    77      dcl	   cm_allocate_ci$info_header
  9    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
  9    79 
  9    80 
  9    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  9    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  9    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  9    84      dcl	   cm_compact$buffered_replacement
  9    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  9    86 
  9    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  9    88 
  9    89      dcl	   cm_delete_cn_datum$header
  9    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  9    91 
  9    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  9    93 			      fixed bin (35));
  9    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
  9    95 
  9    96      dcl	   cm_determine_free_space$all
  9    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
  9    98      dcl	   cm_determine_free_space$effective
  9    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
  9   100 			      fixed bin (35));
  9   101      dcl	   cm_determine_free_space$does_new_datum_fit
  9   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
  9   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
  9   104 
  9   105 /**** Not yet used *********************************************************
  9   106*     dcl	   cm_determine_free_space$does_replacement_fit
  9   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
  9   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
  9   109*************************************************************************** */
  9   110 
  9   111      dcl	   cm_find_ci_to_alloc_datum
  9   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
  9   113 			      fixed bin (24) uns, fixed bin (35));
  9   114 
  9   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
  9   116 			      bit (1) aligned, fixed bin (35));
  9   117 
  9   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
  9   119      dcl	   cm_free_ci$raw_return_prev_next
  9   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
  9   121 			      fixed bin (24) uns, fixed bin (35));
  9   122      dcl	   cm_free_ci$trace_thread_modifications_on
  9   123 			      entry ();
  9   124      dcl	   cm_free_ci$trace_thread_modifications_off
  9   125 			      entry ();
  9   126 
  9   127 
  9   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  9   129 
  9   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  9   131      dcl	   cm_get_bci_header$exclusive
  9   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  9   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  9   134 
  9   135 /**** Not yet used ********************************************************
  9   136*     dcl	   cm_get_bci_header$slot_exclusive
  9   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  9   138*************************************************************************** */
  9   139 
  9   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  9   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  9   142      dcl	   cm_get_element$exclusive
  9   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  9   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  9   145 
  9   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  9   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  9   148 			      fixed bin (35), fixed bin (35));
  9   149 
  9   150 /**** Not yet used ********************************************************
  9   151*     dcl	   cm_get_element_portion$exclusive
  9   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  9   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  9   154*			      fixed bin (35), fixed bin (35));
  9   155*************************************************************************** */
  9   156 
  9   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  9   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  9   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  9   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  9   161 
  9   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   163 			      fixed bin (35), fixed bin (35));
  9   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   165 			      fixed bin (35), fixed bin (35));
  9   166 
  9   167 /******* Not yet used *****************************************************
  9   168*     dcl	   cm_modify$buffered_info
  9   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  9   170*			      fixed bin (35));
  9   171*****************************************************************************/
  9   172 
  9   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  9   174      dcl	   cm_modify$unprotected_info
  9   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  9   176 
  9   177 
  9   178 /******* Not yet used *****************************************************
  9   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
  9   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
  9   181*****************************************************************************/
  9   182 
  9   183 
  9   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  9   185      dcl	   cm_opening_info$get_storage_record
  9   186 			      entry (ptr, fixed bin (35));
  9   187      dcl	   cm_opening_info$full_get
  9   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  9   189      dcl	   cm_opening_info$opening_table_ptr
  9   190 			      entry () returns (ptr);
  9   191 
  9   192      dcl	   cm_postcommit_increment
  9   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  9   194 
  9   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   196 			      fixed bin (35), fixed bin (35));
  9   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   198 			      fixed bin (35), fixed bin (35));
  9   199 
  9   200 /******* Not yet used *****************************************************
  9   201*     dcl	   cm_put$buffered_info
  9   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  9   203*			      fixed bin (35));
  9   204*****************************************************************************/
  9   205 
  9   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  9   207 
  9   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  9   209 			      fixed bin (35));
  9   210 
  9   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
  9   212 
  9   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  9   214 			      fixed bin (35));
  9   215      dcl	   cm_put_datum_in_place$buffered
  9   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  9   217      dcl	   cm_put_datum_in_place$buffered_continued
  9   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  9   219 			      fixed bin (35));
  9   220      dcl	   cm_put_datum_in_place$continued
  9   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  9   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  9   223 
  9   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  9   225 			      fixed bin (35));
  9   226      dcl	   cm_put_datum_in_pool$buffered
  9   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  9   228      dcl	   cm_put_datum_in_pool$buffered_continued
  9   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  9   230 			      fixed bin (35));
  9   231      dcl	   cm_put_datum_in_pool$continued
  9   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  9   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  9   234 
  9   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  9   236 			      fixed bin (35));
  9   237      dcl	   cm_put_ordered_element$buffered
  9   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  9   239 			      fixed bin (35));
  9   240 
  9   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
  9   242 
  9   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
  9   244 			      fixed bin (35));
  9   245 
  9   246 
  9   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
  9   248 			      entry ();
  9   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
  9   250 			      entry ();
  9   251 
  9   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      490 
      491 
 10     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 10     2 /* format: style3 */
 10     3 
 10     4 /* These constants are to be used for the flags argument of sub_err_ */
 10     5 /* They are just "string (condition_info_header.action_flags)" */
 10     6 
 10     7 declare	(
 10     8 	ACTION_CAN_RESTART	init (""b),
 10     9 	ACTION_CANT_RESTART init ("1"b),
 10    10 	ACTION_DEFAULT_RESTART
 10    11 			init ("01"b),
 10    12 	ACTION_QUIET_RESTART
 10    13 			init ("001"b),
 10    14 	ACTION_SUPPORT_SIGNAL
 10    15 			init ("0001"b)
 10    16 	)		bit (36) aligned internal static options (constant);
 10    17 
 10    18 /* End include file */
      492 
      493 
      494    end cm_delete;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/06/86  1259.1  cm_delete.pl1                     >spec>install>1054>cm_delete.pl1
474          1    01/07/85  0901.2  dm_cm_datum.incl.pl1              >ldd>include>dm_cm_datum.incl.pl1
476          2    01/07/85  0858.4  dm_cm_info.incl.pl1               >ldd>include>dm_cm_info.incl.pl1
478          3    01/07/85  0858.0  dm_cm_basic_ci.incl.pl1           >ldd>include>dm_cm_basic_ci.incl.pl1
480          4    01/07/85  0858.1  dm_cm_basic_ci_const.incl.pl1     >ldd>include>dm_cm_basic_ci_const.incl.pl1
482          5    01/07/85  0858.2  dm_cm_collection_header.incl.pl1  >ldd>include>dm_cm_collection_header.incl.pl1
484          6    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
486          7    01/07/85  0858.5  dm_esm_info.incl.pl1              >ldd>include>dm_esm_info.incl.pl1
488          8    01/07/85  0900.8  dm_ci_parts.incl.pl1              >ldd>include>dm_ci_parts.incl.pl1
490          9    04/05/85  0924.3  dm_cm_entry_dcls.incl.pl1         >ldd>include>dm_cm_entry_dcls.incl.pl1
492         10    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000023 constant        bit(36)                  initial dcl 10-7 set ref 372*
BITS_PER_BYTE                   000004 constant        fixed bin(17,0)          initial dcl 172 ref 420 420
BYTES_PER_WORD                         constant        fixed bin(17,0)          initial dcl 173 ref 405 438 462 463
CM_INFO_VERSION_2               000002 constant        char(8)                  initial dcl 2-48 set ref 215*
COLLECTION_HEADER_VERSION_2     000000 constant        char(8)                  initial dcl 5-86 set ref 218*
FREE_SLOT                              constant        fixed bin(15,0)          initial unsigned dcl 4-13 ref 234
NEXT_ELEMENT                    000034 constant        fixed bin(17,0)          initial dcl 171 set ref 283*
ORDERED_ELEMENT_STORAGE_METHOD         constant        fixed bin(17,0)          initial dcl 7-46 ref 238
RELATIVE                        000027 constant        bit(1)                   initial dcl 170 set ref 283*
addr                                                   builtin function         dcl 163 ref 221 224 225 251 271 273 273 273 298 305
                                                                                  320 343 438 438
automatic_bci_header            000101 automatic       structure                level 1 dcl 143 set ref 224
automatic_datum_slot            000106 automatic       structure                level 1 dcl 144 set ref 225
bci_header                             based           structure                level 1 dcl 3-63 set ref 405 462
bci_header_ptr                  000140 automatic       pointer                  dcl 3-94 set ref 224* 227* 231 263 298 302 302 309
                                                                                  334 336 339 339 341 343* 405 462
btb_p_bits                             parameter       fixed bin(35,0)          dcl 418 ref 415 420
ci_parts                               based           structure                level 1 dcl 8-27
ci_parts_ptr                    000150 automatic       pointer                  initial dcl 8-35 set ref 8-35* 271* 272 273* 343*
cip_number_of_parts             000152 automatic       fixed bin(17,0)          initial dcl 8-36 set ref 8-36*
cm_delete_cn_datum              000030 constant        entry                    external dcl 9-87 ref 256
cm_free_ci$info                 000032 constant        entry                    external dcl 9-118 ref 320
cm_get_bci_header$slot          000034 constant        entry                    external dcl 9-133 ref 227
cm_get_id$id                    000036 constant        entry                    external dcl 9-157 ref 283
cm_info                                based           structure                level 1 dcl 2-37
cm_info_ptr                     000136 automatic       pointer                  initial dcl 2-47 set ref 199* 209* 215 217 227 231
                                                                                  256* 2-47* 273 283 283 320* 343 438
cm_opening_info$get             000040 constant        entry                    external dcl 9-184 ref 199
code                            000100 automatic       fixed bin(35,0)          dcl 142 set ref 198* 199* 200 200* 208* 227* 228
                                                                                  228* 256* 257 257* 283* 285 285 285* 288* 320* 321
                                                                                  321*
collection_header                      based           structure                level 1 dcl 5-65
collection_header_ptr           000144 automatic       pointer                  dcl 5-85 set ref 217* 218 238
collection_id             4            based           bit(36)                  initial level 2 in structure "cm_info" dcl 2-37
                                                                                  in procedure "cm_delete" set ref 231 283*
collection_id             1            based           bit(36)                  level 2 in structure "bci_header" dcl 3-63
                                                                                  in procedure "cm_delete" ref 231
continuation              1     000176 automatic       structure                level 2 dcl 434 set ref 442
continuation_datum_id_string    000122 automatic       bit(36)                  initial dcl 150 set ref 150* 251* 254 256*
continued_datum                        based           structure                level 1 packed unaligned dcl 1-50
control_interval_id                    based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 6-32 ref 251
                                                                                  273 320 343
cv_p_correct_version                   parameter       char(8)                  dcl 370 set ref 365 372 372*
cv_p_given_version                     parameter       char(8)                  dcl 369 set ref 365 372 372*
cv_p_structure_name                    parameter       char                     unaligned dcl 368 set ref 365 372*
datum_contents_length_in_bits   000134 automatic       fixed bin(35,0)          initial dcl 1-69 set ref 1-69*
datum_id                               based           structure                level 1 dcl 1-62
datum_id_ptr                    000132 automatic       pointer                  initial dcl 1-68 set ref 1-68*
datum_ptr                       000130 automatic       pointer                  initial dcl 1-67 set ref 1-67*
datum_slot                             based           structure                level 1 dcl 3-82
datum_slot_ptr                  000142 automatic       pointer                  dcl 3-95 set ref 225* 227* 234 234 242 251 343*
divide                                                 builtin function         dcl 163 ref 420
dm_error_$ci_not_in_collection  000024 external static fixed bin(35,0)          dcl 186 set ref 231*
dm_error_$end_of_collection     000020 external static fixed bin(35,0)          dcl 186 ref 285
dm_error_$no_element            000022 external static fixed bin(35,0)          dcl 186 set ref 221* 234*
element_id                             based           structure                level 1 dcl 6-32
element_id_string               000146 automatic       bit(36)                  dcl 6-30 set ref 220* 221 227* 251 273 283* 298 305
                                                                                  320 343
element_storage_method
                          3            based           fixed bin(17,0)          level 2 dcl 5-65 ref 238
er_p_code                              parameter       fixed bin(35,0)          dcl 358 ref 355 360
error_table_$unimplemented_version
                                000026 external static fixed bin(35,0)          dcl 191 set ref 372*
file_manager_$get               000010 constant        entry                    external dcl 177 ref 466
file_manager_$put               000012 constant        entry                    external dcl 178 ref 408
file_manager_$simple_get        000014 constant        entry                    external dcl 179 ref 438
file_oid                  3            based           bit(36)                  initial level 2 dcl 2-37 set ref 227* 273* 283* 343*
                                                                                  438*
first_free_slot_idx             000125 automatic       fixed bin(17,0)          dcl 156 set ref 336* 336* 339
flags                                  based           structure                level 2 in structure "datum_slot" packed unaligned
                                                                                  dcl 3-82 in procedure "cm_delete"
flags                     3(12)        based           structure                level 2 in structure "bci_header" packed unaligned
                                                                                  dcl 3-63 in procedure "cm_delete"
free_slot_is_present      3(13)        based           bit(1)                   level 3 packed unaligned dcl 3-63 set ref 339* 341*
gc_code                         000200 automatic       fixed bin(35,0)          dcl 436 set ref 438* 440 440*
gc_continued_datum_header       000176 automatic       structure                level 1 dcl 434 set ref 438 438 438
gc_p_ci                                parameter       fixed bin(27,0)          dcl 432 set ref 424 438*
gc_p_offset                            parameter       fixed bin(21,0)          dcl 433 set ref 424 438*
gst_code                        000152 automatic       fixed bin(35,0)          dcl 459 set ref 466* 467 467*
gst_p_ci_parts_ptr                     parameter       pointer                  dcl 457 set ref 447 461 462 463 464 466*
gst_p_control_interval_id              parameter       fixed bin(27,0)          dcl 452 set ref 447 466*
gst_p_file_oid                         parameter       bit(36)                  dcl 451 set ref 447 466*
gst_p_slot_table_length_in_words       parameter       fixed bin(17,0)          dcl 455 ref 447 463
gst_p_slot_table_ptr                   parameter       pointer                  dcl 454 ref 447 464
header                                 based           structure                level 2 packed unaligned dcl 1-50
header_ptr                6            based           pointer                  initial level 2 dcl 2-37 ref 217
index                     0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 6-32 ref 221
                                                                                  298 305
is_continuation           0(02)        based           bit(1)                   level 3 packed unaligned dcl 3-82 ref 234
is_continued              0(01)        based           bit(1)                   level 3 packed unaligned dcl 3-82 ref 242
is_ordered_esm                  000124 automatic       bit(1)                   initial dcl 154 set ref 154* 238* 240* 276 291 313
                                                                                  349
length_in_bits            0(19)        based           fixed bin(17,0)          level 2 packed unsigned unaligned dcl 3-82 ref 394
                                                                                  398
length_in_bytes           3            based           fixed bin(17,0)          array level 3 dcl 8-27 set ref 405* 463*
local_ptr                 4            based           pointer                  array level 3 dcl 8-27 set ref 406* 464*
my_ci_parts                     000110 automatic       structure                level 1 dcl 145 set ref 271
myname                          000004 constant        varying char(32)         initial dcl 169 set ref 372*
next_element_id_string          000123 automatic       bit(36)                  initial dcl 152 set ref 152* 283* 349
null                                                   builtin function         dcl 163 ref 1-67 1-68 2-47 8-35 372 372
number_of_ci_parts              000110 automatic       fixed bin(17,0)          initial level 2 dcl 145 set ref 145*
number_of_datums          4(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 3-63 set ref 263 298
                                                                                  302* 302 309 334* 336 339
number_of_parts                        based           fixed bin(17,0)          level 2 dcl 8-27 set ref 272* 403* 461*
offset_in_bytes           0(04)        based           fixed bin(15,0)          level 2 in structure "datum_slot" packed unsigned
                                                                                  unaligned dcl 3-82 in procedure "cm_delete" ref
                                                                                  234 251 394
offset_in_bytes           2            based           fixed bin(17,0)          array level 3 in structure "ci_parts" dcl 8-27
                                                                                  in procedure "cm_delete" set ref 404* 462*
p_cm_info_ptr                          parameter       pointer                  dcl 133 ref 205 209
p_code                                 parameter       fixed bin(35,0)          dcl 138 set ref 126 205 212* 360*
p_collection_id                        parameter       bit(36)                  dcl 135 set ref 126 199*
p_element_id                           parameter       bit(36)                  dcl 136 set ref 126 205 220 349*
p_file_opening_id                      parameter       bit(36)                  dcl 134 set ref 126 199*
p_zero_on_free                         parameter       bit(1)                   dcl 137 set ref 126 205 256* 320*
pad                       1     000110 automatic       fixed bin(17,0)          initial level 2 dcl 145 set ref 145*
part                      2            based           structure                array level 2 dcl 8-27
phas_code                       000134 automatic       fixed bin(35,0)          dcl 390 set ref 392* 408* 409 409*
phas_p_bci_header_ptr                  parameter       pointer                  dcl 385 ref 380 394 394 394 398 398 406
phas_p_ci_parts_ptr                    parameter       pointer                  dcl 389 set ref 380 403 404 405 406 408*
phas_p_control_interval_id             parameter       fixed bin(27,0)          dcl 387 set ref 380 408*
phas_p_datum_slot_ptr                  parameter       pointer                  dcl 386 ref 380 394 394 398
phas_p_file_opening_id                 parameter       bit(36)                  dcl 384 set ref 380 408*
scattered_free_space      3(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 3-63 set ref 398* 398
size                                                   builtin function         dcl 163 ref 405 438 462
slot                            000100 automatic       structure                array level 2 dcl 268 set ref 299* 299 301* 305* 309
                                                                                  336
slot_idx                        000126 automatic       fixed bin(17,0)          dcl 157 set ref 298* 299 299* 301 309* 309* 313 334
slot_table                      000100 automatic       structure                level 1 dcl 268 set ref 273 273
st_number_of_slots              000127 automatic       fixed bin(17,0)          dcl 158 set ref 263* 268 273*
start_of_used_space       4            based           fixed bin(17,0)          level 2 packed unaligned dcl 3-63 set ref 394 394*
                                                                                  394
sub_err_                        000016 constant        entry                    external dcl 182 ref 372
unspec                                                 builtin function         dcl 163 set ref 301* 305* 309 336 442
version                                based           char(8)                  level 2 in structure "cm_info" dcl 2-37 in procedure
                                                                                  "cm_delete" set ref 215*
version                                based           char(8)                  level 2 in structure "collection_header" dcl 5-65
                                                                                  in procedure "cm_delete" set ref 218*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 10-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 10-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 10-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 10-7
BASIC_CI_LAYOUT_1                      internal static char(4)                  initial dcl 3-97
BASIC_ELEMENT_STORAGE_METHOD           internal static fixed bin(17,0)          initial dcl 7-44
BCI_HEADER_LENGTH_IN_BYTES             internal static fixed bin(17,0)          initial dcl 4-14
DATUM_POSITION_TABLE_OFFSET_IN_BYTES   internal static fixed bin(17,0)          initial dcl 4-16
ESM_INFO_VERSION_1                     internal static char(8)                  initial dcl 7-43
basic_control_interval                 based           structure                level 1 dcl 3-56
basic_control_interval_ptr             automatic       pointer                  dcl 3-92
basic_esm_info                         based           structure                level 1 dcl 7-21
basic_esm_info_ptr                     automatic       pointer                  dcl 7-40
cm_allocate_ci                  000000 constant        entry                    external dcl 9-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 9-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 9-77
cm_compact                      000000 constant        entry                    external dcl 9-81
cm_compact$buffered             000000 constant        entry                    external dcl 9-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 9-84
cm_compact$replacement          000000 constant        entry                    external dcl 9-83
cm_delete                       000000 constant        entry                    external dcl 9-92
cm_delete$info                  000000 constant        entry                    external dcl 9-94
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 9-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 9-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 9-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 9-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 9-111
cm_find_free_slot               000000 constant        entry                    external dcl 9-115
cm_free_ci$raw_return_prev_next 000000 constant        entry                    external dcl 9-119
cm_free_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 9-124
cm_free_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 9-122
cm_free_opening_info            000000 constant        entry                    external dcl 9-128
cm_get_bci_header               000000 constant        entry                    external dcl 9-130
cm_get_bci_header$exclusive     000000 constant        entry                    external dcl 9-131
cm_get_element                  000000 constant        entry                    external dcl 9-140
cm_get_element$exclusive        000000 constant        entry                    external dcl 9-142
cm_get_element_portion          000000 constant        entry                    external dcl 9-146
cm_get_id$ptr                   000000 constant        entry                    external dcl 9-159
cm_modify                       000000 constant        entry                    external dcl 9-162
cm_modify$buffered              000000 constant        entry                    external dcl 9-164
cm_modify$info                  000000 constant        entry                    external dcl 9-173
cm_modify$unprotected_info      000000 constant        entry                    external dcl 9-174
cm_opening_info$full_get        000000 constant        entry                    external dcl 9-187
cm_opening_info$get_storage_record
                                000000 constant        entry                    external dcl 9-185
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 9-189
cm_postcommit_increment         000000 constant        entry                    external dcl 9-192
cm_put                          000000 constant        entry                    external dcl 9-195
cm_put$buffered                 000000 constant        entry                    external dcl 9-197
cm_put$info                     000000 constant        entry                    external dcl 9-206
cm_put_basic_element            000000 constant        entry                    external dcl 9-208
cm_put_cn_datum                 000000 constant        entry                    external dcl 9-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 9-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 9-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 9-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 9-220
cm_put_datum_in_pool            000000 constant        entry                    external dcl 9-224
cm_put_datum_in_pool$buffered   000000 constant        entry                    external dcl 9-226
cm_put_datum_in_pool$buffered_continued
                                000000 constant        entry                    external dcl 9-228
cm_put_datum_in_pool$continued  000000 constant        entry                    external dcl 9-231
cm_put_ordered_element          000000 constant        entry                    external dcl 9-235
cm_put_ordered_element$buffered 000000 constant        entry                    external dcl 9-237
cm_put_overlength_tail          000000 constant        entry                    external dcl 9-241
cm_recursive_modify             000000 constant        entry                    external dcl 9-243
cm_replace_buffered_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 9-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 9-247
continuation_datum                     based           structure                level 1 packed unaligned dcl 1-47
continued_continuation_datum           based           structure                level 1 packed unaligned dcl 1-56
datum                                  based           structure                level 1 packed unaligned dcl 1-44
ordered_esm_info                       based           structure                level 1 dcl 7-31
ordered_esm_info_ptr                   automatic       pointer                  dcl 7-41

NAMES DECLARED BY EXPLICIT CONTEXT.
BEGIN_BLOCK                     000453 constant        label                    dcl 265
BITS_TO_BYTES                   001223 constant        entry                    internal dcl 415 ref 394 398
CHECK_VERSION                   001001 constant        entry                    internal dcl 365 ref 215 218
ERROR_RETURN                    000765 constant        entry                    internal dcl 355 ref 200 221 228 231 234 257 288 321
                                                                                  409 440 467
FREE_ENTIRE_CI                  000650 constant        label                    dcl 313
GET_CONTINUATION                001241 constant        entry                    internal dcl 424 ref 251
GET_SLOT_TABLE                  001314 constant        entry                    internal dcl 447 ref 273
JOIN                            000216 constant        label                    dcl 212 ref 200 210
MAIN_RETURN                     000763 constant        label                    dcl 352 ref 361
PUT_HEADER_AND_SLOTS            001105 constant        entry                    internal dcl 380 ref 343
UPDATE_CI                       000703 constant        label                    dcl 324
cm_delete                       000121 constant        entry                    external dcl 126
info                            000173 constant        entry                    external dcl 205

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1622        1664    1414        1632
Length      2264    1414        42         363     205           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_delete                           234 external procedure  is an external procedure.  
begin block on line 265             164 begin block         uses auto adjustable storage.  
ERROR_RETURN                         64 internal procedure  is called by several nonquick procedures.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure cm_delete.  
PUT_HEADER_AND_SLOTS                    internal procedure  shares stack frame of begin block on line 265.  
BITS_TO_BYTES                           internal procedure  shares stack frame of begin block on line 265.  
GET_CONTINUATION                        internal procedure  shares stack frame of external procedure cm_delete.  
GET_SLOT_TABLE                          internal procedure  shares stack frame of begin block on line 265.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 265  000100 slot_table                  begin block on line 265
                         000134 phas_code                   PUT_HEADER_AND_SLOTS
                         000152 gst_code                    GET_SLOT_TABLE
cm_delete                000100 code                        cm_delete
                         000101 automatic_bci_header        cm_delete
                         000106 automatic_datum_slot        cm_delete
                         000110 my_ci_parts                 cm_delete
                         000122 continuation_datum_id_string
                                                            cm_delete
                         000123 next_element_id_string      cm_delete
                         000124 is_ordered_esm              cm_delete
                         000125 first_free_slot_idx         cm_delete
                         000126 slot_idx                    cm_delete
                         000127 st_number_of_slots          cm_delete
                         000130 datum_ptr                   cm_delete
                         000132 datum_id_ptr                cm_delete
                         000134 datum_contents_length_in_bits
                                                            cm_delete
                         000136 cm_info_ptr                 cm_delete
                         000140 bci_header_ptr              cm_delete
                         000142 datum_slot_ptr              cm_delete
                         000144 collection_header_ptr       cm_delete
                         000146 element_id_string           cm_delete
                         000150 ci_parts_ptr                cm_delete
                         000152 cip_number_of_parts         cm_delete
                         000176 gc_continued_datum_header   GET_CONTINUATION
                         000200 gc_code                     GET_CONTINUATION

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
enter_begin         leave_begin         call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              tra_ext             alloc_auto_adj      signal              ext_entry           int_entry
divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_delete_cn_datum            cm_free_ci$info               cm_get_bci_header$slot        cm_get_id$id
cm_opening_info$get           file_manager_$get             file_manager_$put             file_manager_$simple_get
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$ci_not_in_collection                              dm_error_$end_of_collection   dm_error_$no_element
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    145 000074       150 000076       152 000077       154 000100    1   67 000101    1   68 000103    1   69 000104
 2   47 000106    8   35 000110    8   36 000111       126 000114       198 000136       199 000137       200 000155
    205 000165       208 000210       209 000211       210 000215       212 000216       215 000217       217 000240
    218 000243       220 000270       221 000272       224 000304       225 000306       227 000310       228 000330
    231 000340       234 000354       238 000372       240 000401       242 000402       251 000405       254 000416
    256 000420       257 000435       259 000445       263 000446       265 000453       268 000456       271 000463
    272 000465       273 000467       276 000513       283 000516       285 000542       288 000552       291 000561
    298 000564       299 000602       300 000605       301 000607       302 000611       304 000617       305 000620
    309 000624       310 000641       313 000644       320 000650       321 000670       323 000702       334 000703
    336 000705       338 000717       339 000721       341 000732       343 000734       347 000756       349 000757
    352 000763       355 000764       360 000772       361 000776       365 001001       372 001012       376 001103
    378 001104       380 001105       392 001107       394 001110       398 001140       403 001157       404 001162
    405 001164       406 001167       408 001172       409 001207       411 001221       413 001222       415 001223
    420 001225       424 001241       438 001243       440 001273       442 001304       445 001310       447 001314
    461 001316       462 001321       463 001325       464 001330       466 001333       467 001351       469 001363
    472 001364


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
