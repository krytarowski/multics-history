	COMPILATION LISTING OF SEGMENT record_stream_attach_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx, AZ, Sys-M  
	Compiled on: 09/10/87  1506.3 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(84-08-22,Ranzenbach), approve(), audit(), install():
       15*     Modified to call unique_chars_.
       16*  2) change(87-07-01,GWMay), approve(87-07-01,MCR7730), audit(87-09-10,GDixon),
       17*     install(87-09-10,MR12.1-1104):
       18*     Completely restructured the code. Added any_other handlers.
       19*     Changed the close routine to always close the control block.
       20*     Changed the detach routine to always detach the control block.
       21*     Changed recursive call for -target attachment to a nonrecursive
       22*     method.
       23*                                                   END HISTORY COMMENTS */
       24 
       25 
       26 /* format: off */
       27 
       28 /* main program of record_stream_ io module */
       29 
       30 record_stream_attach: proc (Piocb_ptr,	/* (input) - control block pointer  */
       31 		        option_array, 
       32 				/* (input) - control arguments      */
       33 		        Pcom_err,	/* (input) - ON = report errors     */
       34 		        Pcode);	/* (output)- error status	      */
       35 
       36        iocb_ptr = Piocb_ptr;
       37        Scom_err = Pcom_err;
       38        call initialize$attach();
       39 
       40        if iocb.attach_descrip_ptr ^= null then
       41 	call CHECK_CODE_return_on_error (error_table_$not_detached, ME,
       42 	"^a", iocb.name);
       43 
       44        call get_args ();
       45 
       46 /* create and initialize rs attach block, with cleanup handler for block */
       47 
       48        rsab_ptr = null;
       49        on cleanup call record_stream_detach_ ();
       50        EXIT = EXIT_WITH_DETACH;
       51 
       52        call alloc_cb_file (size (rs_attach_block), rsab_ptr);
       53 
       54 /* If the -target option is present. Attach the target descrip. */
       55 
       56        if target_args ^= "" then do;
       57 	rs_attach_desc.switch_name =  "rs_" || unique_chars_ ("0"b);
       58 	rs_attach_block.i_attached_target = TRUE;
       59 	call iox_$attach_name (rs_attach_desc.switch_name,
       60 	   rs_attach_block.target_iocb_ptr, (target_args), null, code);
       61 	call CHECK_CODE_return_on_error (code, ME,
       62 	   "Target attach description failed:^/^a",
       63 	      target_args);
       64 	end;
       65 
       66 /* Otherwise, find target IOCB. */
       67 
       68        else do;
       69 	rs_attach_block.i_attached_target = FALSE;
       70 	call iox_$find_iocb (rs_attach_desc.switch_name,
       71 	   rs_attach_block.target_iocb_ptr, code);
       72 	call CHECK_CODE_return_on_error (code, ME,
       73 	   "Looking for target IOCB ^a",
       74 	   rs_attach_desc.switch_name);
       75 	end;
       76 
       77        rs_attach_block.attach_descrip_string =
       78 	rs_attach_desc.module_name 
       79 	|| rtrim(rs_attach_desc.switch_name)
       80 	|| rtrim(rs_attach_desc.args);
       81        rs_attach_block.attach_descrip_len = 
       82 	length (rtrim (rs_attach_block.attach_descrip_string));
       83 
       84        rs_attach_block.target_name = rs_attach_desc.switch_name;
       85        rs_attach_block.length_n = arg_record_length;
       86        rs_attach_block.open_descrip_len = 0;
       87        rs_attach_block.open_descrip_string = "";
       88        rs_attach_block.mode = 0;
       89        rs_attach_block.i_opened_target = FALSE;
       90        rs_attach_block.base = 0;
       91        rs_attach_block.n_left = 0;
       92 
       93 /* Set the iocb to the attach state */
       94        
       95        ips_mask = ""b;
       96        on any_other call hcs_$reset_ips_mask (ips_mask, ips_mask);
       97        call hcs_$set_ips_mask ("0"b, ips_mask);
       98        iocb.attach_data_ptr = rsab_ptr;
       99        iocb.attach_descrip_ptr = addr (rs_attach_block.attach_descrip);
      100        iocb.detach_iocb = record_stream_detach;
      101        iocb.open = record_stream_open;
      102        iocb.modes = record_stream_modes;
      103        iocb.control = record_stream_control;
      104 
      105        call iox_$propagate (iocb_ptr);
      106        call hcs_$reset_ips_mask (ips_mask, ips_mask);
      107 
      108 EXIT_BY_RETURN:
      109        return;
      110 
      111 EXIT_WITH_DETACH:  
      112        call record_stream_detach_();
      113        return;
      114 
      115 get_args: proc ();
      116 
      117        arg_record_length = 0;
      118        rs_attach_desc.module_name = ME;
      119        rs_attach_desc.switch_name = "";
      120        rs_attach_desc.args = "";
      121        target_args = "";
      122 
      123        do i = 1 to hbound (option_array, 1);
      124 
      125 	code = 0;
      126 
      127 	if option_array (i) = "-no_newline" | option_array (i) = "-nnl" then
      128 	   arg_record_length = -1;
      129 	else
      130 	   if option_array (i) = "-length"
      131 	      | option_array (i) = "-ln" then do;
      132 	      if i + 1 > hbound (option_array, 1) then
      133 	         call CHECK_CODE (error_table_$noarg, ME,
      134 "^/^a requires a positive integer value.",
      135 		  option_array (i));
      136 	      else do;
      137 	         i = i + 1;
      138 	         arg_record_length =
      139 		  cv_dec_check_ ((option_array (i)), ercode);
      140 	         if ercode ^= 0
      141 		  | arg_record_length <= 0
      142 		  | arg_record_length > CHARS_PER_SEGMENT then
      143 		  call CHECK_CODE (error_table_$bad_arg, ME,
      144 "^/^a ^a.  The value must be a positive integer less than ^d.",
      145 		  option_array (i - 1), option_array (i),
      146 		  CHARS_PER_SEGMENT+1);
      147 	         end;
      148 	      end;
      149 
      150           else
      151 	   if option_array (i) = "-target" then do;
      152 
      153 /* Build the attach description for the target I/O module. */
      154 
      155 	      if i + 1 > hbound (option_array, 1) then
      156 	         call CHECK_CODE (error_table_$noarg, ME,
      157 	         "^a requires an attach description operand.",
      158 	         option_array(i));
      159 	      else do;
      160 	         i = i + 1;
      161 	         target_args = target_args || option_array (i);
      162 	         do i = i + 1 to hbound (option_array, 1);	
      163 		  target_args = target_args || " ";
      164 		  target_args =
      165 		     target_args || requote_string_ ((option_array (i)));
      166 		  end;
      167 	         end;
      168 	      end;
      169 
      170           else
      171 	   if i = 1 then do;	/* switch name must be in position 1*/
      172 	      if length (option_array (i)) >
      173 	         length(rs_attach_desc.switch_name) then
      174 	         call CHECK_CODE (error_table_$bigarg, ME,
      175 "^/Target switch name value is longer than ^a characters: ^a.",
      176 		  length(rs_attach_desc.switch_name), option_array (i));
      177 	      else
      178 	         rs_attach_desc.switch_name = option_array (i);
      179 	      end;
      180 
      181 	else
      182 	   if index (option_array(i), "-") = 1 then
      183 	      call CHECK_CODE (error_table_$bad_opt, ME,
      184 	   "^a", option_array (i));
      185 
      186           else
      187 	   call CHECK_CODE (error_table_$bad_arg, ME,
      188 	   "^a", option_array (i));
      189 	end;
      190 
      191        if rs_attach_desc.switch_name = "" then do;
      192 	if target_args = "" then
      193 	   call CHECK_CODE (error_table_$noarg, ME, "Target switch name");
      194           end;
      195        else
      196 	if target_args ^= "" then
      197 	   call CHECK_CODE (error_table_$bad_arg, ME,
      198 "^/Cannot give both a target switch name and -target attach description.");
      199 
      200        if Serror_occurred then 
      201 	go to EXIT;
      202 
      203        if arg_record_length < 0 then	/* leading space separates switch    */
      204 	rs_attach_desc.args = " -nnl";/* name from control args in attach  */
      205        else			/* description.		       */
      206 	if arg_record_length > 0 then		
      207 	   rs_attach_desc.args =			
      208 	      " -length " || ltrim (char (arg_record_length));
      209 
      210        return;
      211        end get_args;
      212 
      213 record_stream_open: entry (Piocb_ptr,	/* (input) - control block pointer  */
      214 		       open_mode,	/* (input) - opening mode(sqi etc.) */
      215 		       Sextend,	/* (input) - ON = add to the file   */
      216 		       Pcode);	/* (output)- error status	      */
      217 
      218        dcl open_mode		fixed bin parameter,
      219 	 Sextend			bit (1) aligned parameter;
      220 
      221        call initialize;
      222 				/* verify open args & set descript. */
      223 
      224        if open_mode < lbound (iox_modes, 1)
      225 	| open_mode > hbound(iox_modes, 1)
      226 	| Sextend then
      227 	call CHECK_CODE_return_on_error (error_table_$bad_arg, ME);
      228 
      229        else
      230 	if open_mode = Stream_input_output
      231 	   | open_mode > Sequential_output then
      232 	   call CHECK_CODE_return_on_error (error_table_$bad_mode, ME);
      233 
      234        else
      235 	if open_mode = Stream_output | open_mode = Sequential_input then do;
      236 	   if rs_attach_block.length_n < 0 then
      237 	      call CHECK_CODE_return_on_error (
      238 	      error_table_$invalid_record_length, ME);
      239 	   end;
      240 
      241        else
      242 	if open_mode = Sequential_output | open_mode = Stream_input then do;
      243 	   if rs_attach_block.length_n > 0 then
      244 	      call CHECK_CODE_return_on_error (
      245 	      error_table_$invalid_record_length, ME);
      246 	   end;
      247 
      248 /* The open_mode is valid set the open description */
      249 
      250        rs_attach_block.mode = open_mode;
      251        rs_attach_block.open_descrip_len =
      252 	length (rtrim (iox_modes (open_mode)));
      253        rs_attach_block.open_descrip_string = iox_modes (open_mode);
      254 
      255 /* If the target switch exists, find out how the targets was opened. */
      256        
      257        if rs_attach_block.target_iocb_ptr = null then
      258 	call CHECK_CODE_return_on_error (error_table_$no_iocb, ME);
      259 
      260        target_open_mode_ptr =
      261 	rs_attach_block.target_iocb_ptr -> iocb.open_descrip_ptr;
      262 
      263        if target_open_mode_ptr ^= null then
      264 	target_open_mode = before (target_open_mode, SPACE);
      265 
      266 /* If switch is its own target report the error -- looping attachment */
      267 
      268        if iocb_ptr -> iocb.actual_iocb_ptr
      269 	= rs_attach_block.target_iocb_ptr -> iocb.actual_iocb_ptr then
      270 	   call CHECK_CODE_return_on_error (error_table_$att_loop, ME);
      271 
      272 /* Set i_opened_target before the cleanup handler. */
      273 
      274        if rs_attach_block.target_iocb_ptr -> iocb.open_descrip_ptr = null then
      275 	rs_attach_block.i_opened_target = TRUE;
      276 
      277        on cleanup call record_stream_close_ ();
      278        EXIT = EXIT_WITH_CLOSE;
      279 
      280 /* If not open, open the target switch else check its current open mode. */
      281 /* Open the target switch using the opposite mode of what was input. */
      282 
      283        if rs_attach_block.i_opened_target then
      284 	call iox_$open (rs_attach_block.target_iocb_ptr,
      285 	   (op_mode (rs_attach_block.mode)), "0"b, code);
      286 
      287        else			/* target already opened            */
      288 	if (target_open_mode ^= iox_modes (op_mode (rs_attach_block.mode)))
      289 	   & (target_open_mode ^= iox_modes (op_io_mode (rs_attach_block.mode))) then
      290 	   code = error_table_$incompatible_attach;
      291 
      292        call CHECK_CODE_return_on_error (code, ME);
      293 
      294 /* Non-Sequential outputs require an internal buffer. */
      295 
      296        if rs_attach_block.mode ^= Sequential_output then do;
      297 	call get_temp_segment_ (ME, iocb.open_data_ptr, code);
      298 	call CHECK_CODE_return_on_error (code, ME);
      299 	end;
      300 
      301 /* call initialization routine appropriate to opening mode */
      302 
      303        ips_mask = ""b;
      304        on any_other call hcs_$reset_ips_mask (ips_mask, ips_mask);
      305        call hcs_$set_ips_mask ("0"b, ips_mask);
      306 
      307        if rs_attach_block.mode = Stream_input then
      308 	call rs_open_str_in_ (iocb_ptr);
      309        else
      310 	if rs_attach_block.mode = Stream_output then
      311 	   call rs_open_str_out_ (iocb_ptr);
      312        else
      313 	if rs_attach_block.mode = Sequential_input then
      314 	   call rs_open_seq_in_ (iocb_ptr);
      315        else
      316 	call rs_open_seq_out_ (iocb_ptr);
      317 
      318 /* Set up the iocb entries */
      319 
      320        iocb.open_descrip_ptr = addr (rs_attach_block.open_descrip);
      321        iocb.close = record_stream_close;
      322 
      323        call iox_$propagate (iocb_ptr);
      324 
      325        call hcs_$reset_ips_mask (ips_mask, ips_mask);
      326        return;
      327 
      328 EXIT_WITH_CLOSE:
      329        call record_stream_close_();
      330        return;
      331 
      332 record_stream_close: entry (Piocb_ptr,	/* (input) control block pointer   */
      333 		        Pcode);	/* (output) error status	     */
      334 
      335        call initialize;
      336        call record_stream_close_ ();
      337        call CHECK_CODE_return_on_error (code, ME);
      338        return;
      339 
      340 
      341 record_stream_close_: proc ();
      342 
      343 /* This is an internal procedure so that the open entry can use it
      344*   in its cleanup handler. */
      345 
      346 /* If Stream_output, the target is open for sequential output. Flush the
      347*   temp work buffer. */
      348 
      349        if rs_attach_block.mode ^= Sequential_output then do;
      350 
      351 	if rs_attach_block.mode = Stream_output
      352 	   & rs_attach_block.n_left > 0 then
      353 	   call iox_$write_record (rs_attach_block.target_iocb_ptr,
      354 	      iocb.open_data_ptr, rs_attach_block.n_left, code);
      355 
      356 	if iocb.open_data_ptr ^= null then
      357 	   call release_temp_segment_ (ME, iocb.open_data_ptr, ercode);
      358 	end;
      359 
      360        if rs_attach_block.i_opened_target then do;
      361 	call iox_$close (rs_attach_block.target_iocb_ptr, ercode);
      362 	if code = 0 then
      363 	   code = ercode;
      364 	end;
      365 
      366        ips_mask = ""b;
      367        on any_other call hcs_$reset_ips_mask (ips_mask, ips_mask);
      368        call hcs_$set_ips_mask ("0"b, ips_mask);
      369 
      370        iocb.open_descrip_ptr = null;
      371        iocb.open_data_ptr = null;
      372        iocb.detach_iocb = record_stream_detach;
      373        iocb.open = record_stream_open;
      374 
      375        call iox_$propagate (iocb_ptr);
      376 
      377        call hcs_$reset_ips_mask (ips_mask, ips_mask);
      378        return;
      379        end record_stream_close_;
      380 
      381 record_stream_detach: entry (Piocb_ptr, /* (input) - control block pointer  */
      382 		         Pcode);	/* (output)- error status	      */
      383 
      384        call initialize();		  
      385        call record_stream_detach_ ();
      386        call CHECK_CODE_return_on_error (code, ME);
      387        return;
      388 
      389 record_stream_detach_: proc ();
      390 
      391 /* This is an internal procedure so that the attach entry can use it
      392*   in its cleanup handler. */
      393 
      394 /* detach target if it was attached with the -target option */
      395 
      396        if rsab_ptr = null then
      397 	return;
      398 	
      399        if rs_attach_block.i_attached_target then do;
      400 	call iox_$detach_iocb (rs_attach_block.target_iocb_ptr, code);
      401 	call iox_$destroy_iocb (rs_attach_block.target_iocb_ptr, ercode);
      402 	end;
      403 
      404        ips_mask = ""b;
      405        on any_other call hcs_$reset_ips_mask (ips_mask, ips_mask);
      406        call hcs_$set_ips_mask ("0"b, ips_mask);
      407 
      408        iocb.attach_data_ptr = null;
      409        iocb.attach_descrip_ptr = null;
      410 
      411        call iox_$propagate (iocb_ptr);
      412        call hcs_$reset_ips_mask (ips_mask, ips_mask);
      413 
      414        call free_cb_file (size (rs_attach_block), rsab_ptr);
      415        rsab_ptr = null;
      416 
      417        return;
      418        end record_stream_detach_;
      419 
      420 record_stream_modes: entry (Piocb_ptr,	/* (input) - control block pointer  */
      421 		        new_modes,	/* (input) - modes to set to        */
      422 		        old_modes,	/* (output)- current modes	      */
      423 		        Pcode);	/* (output)- error status	      */
      424 
      425        dcl new_modes		char (*) parameter,
      426 	 old_modes		char (*) parameter;
      427 
      428        call initialize;
      429        call iox_$modes (rs_attach_block.target_iocb_ptr, new_modes, old_modes,
      430 	Pcode);
      431 				/* pass call to target              */
      432        return;
      433 
      434 record_stream_control: entry (Piocb_ptr,/* (input) - control block pointer  */
      435 		          order,    /* (input) - requested order	      */
      436 			info_ptr, /* (input) - info for the control et*/
      437 			Pcode);	/* (output)- error status           */
      438 
      439        dcl order			char(*) parameter,
      440 	 info_ptr			ptr parameter;
      441 
      442        call initialize;
      443        call iox_$control (rs_attach_block.target_iocb_ptr, order, info_ptr,
      444 	Pcode);
      445 				/* pass call to target              */
      446        return;
      447 
      448 initialize: proc;
      449 /* internal procedure for initializing pointers and other variables */
      450 
      451        iocb_ptr = Piocb_ptr -> iocb.actual_iocb_ptr;
      452        rsab_ptr = iocb.attach_data_ptr;
      453        Scom_err = FALSE;
      454 
      455 initialize$attach:
      456        entry;
      457 
      458        Pcode, code = 0;
      459        Serror_occurred = FALSE;
      460        EXIT = EXIT_BY_RETURN;
      461        return;
      462 
      463        end initialize;
      464 
      465 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      466 /*							       */
      467 /* This procedure examines its code parameter.  If it is nonzero, it sets    */
      468 /* the code output parameter of the current external entrypoint.  It	       */
      469 /* optionally prints an error message.  Execution stops (via nonlocal goto)  */
      470 /* for nonzero codes passed to CHECK_CODE_return_on_error.  If code is 0,    */
      471 /* these programs do nothing but return to their caller.		       */
      472 /*							       */
      473 /* Syntax:  call CHECK_CODE (code, program_name, ioa_ctl_str, ioa_args);     */
      474 /*	  call CHECK_CODE_return_on_error			       */
      475 /*	       (code, program_name, ioa_ctl_str, ioa_args);	       */
      476 /*							       */
      477 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      478 
      479 CHECK_CODE:
      480        proc options(variable);
      481 
      482        dcl error_code		fixed bin(35) based (p_error_code),
      483 	 p_error_code		ptr;
      484 
      485        dcl Sfatal			bit (1) aligned;
      486 
      487        dcl cu_$arg_list_ptr		entry returns(ptr),
      488 	 cu_$arg_ptr		entry (fixed bin, ptr, fixed bin(21),
      489 				      fixed bin(35)),
      490            cu_$generate_call		entry (entry, ptr);
      491 
      492        Sfatal = FALSE;
      493        go to ERROR_COMMON;
      494 
      495 CHECK_CODE_return_on_error:
      496        entry options (variable);
      497        
      498        Sfatal = TRUE;
      499 
      500 ERROR_COMMON:
      501 
      502        call cu_$arg_ptr (1, p_error_code, 0, 0);
      503        if error_code = 0 then return;
      504        if Pcode = 0 then		/* set output code parameter if it   */
      505 	Pcode = error_code;		/*  hasn't been set before.	       */
      506 
      507        if Scom_err then
      508 	call cu_$generate_call (com_err_, cu_$arg_list_ptr());
      509 
      510        Serror_occurred = TRUE;
      511        if Sfatal then
      512 	go to EXIT;
      513        return;
      514        end CHECK_CODE;
      515 
      516 /* parameters */
      517 
      518        dcl Piocb_ptr		ptr parameter,
      519 	 Pcom_err			bit (1) aligned parameter,
      520 	 Pcode			fixed bin (35) parameter,
      521 	 option_array(*)		char (*) varying parameter;
      522 
      523 /* automatic */
      524 
      525        dcl EXIT			label variable,
      526 	 Scom_err			bit (1) aligned,
      527 	 Serror_occurred		bit (1) aligned,
      528 	 arg_record_length		fixed bin (35),
      529 	 code			fixed bin(35),
      530 	 ercode			fixed bin (35),
      531 	 i			fixed bin,
      532 	 ips_mask			bit(36) aligned,
      533            1 rs_attach_desc		aligned,
      534 	   2 module_name		char (15),
      535 	   2 switch_name		char (32) unal,
      536 	   2 args			char (20),
      537            target_args		char (1024) varying;
      538 
      539 /* based */
      540 
      541        dcl target_open_mode_ptr	ptr,
      542 	 target_open_mode		char (24) varying
      543 				based (target_open_mode_ptr);
      544 
      545 /* entries */
      546 
      547        dcl alloc_cb_file		entry (fixed bin, ptr),
      548 	 cv_dec_check_		entry (char(*), fixed bin(35)) returns(fixed bin(35)),
      549 	 com_err_			entry() options(variable),
      550 	 get_temp_segment_		entry (char(*), ptr, fixed bin(35)),
      551 	 free_cb_file		entry (fixed bin, ptr),
      552 	 hcs_$reset_ips_mask	entry (bit(36) aligned, bit(36) aligned),
      553 	 hcs_$set_ips_mask		entry (bit(36) aligned, bit(36) aligned),
      554 	 release_temp_segment_	entry (char(*), ptr, fixed bin(35)),
      555            requote_string_		entry (char(*)) returns(char(*)),
      556 	 rs_open_seq_in_		entry (ptr),
      557 	 rs_open_seq_out_		entry (ptr),
      558 	 rs_open_str_in_		entry (ptr),
      559 	 rs_open_str_out_		entry (ptr),
      560 	 unique_chars_		entry (bit(*)) returns(char(15));
      561 
      562 /* external static */  
      563 
      564        dcl (error_table_$att_loop,
      565 	 error_table_$bad_arg,
      566 	 error_table_$bad_opt ,
      567 	 error_table_$bad_mode,	
      568 	 error_table_$bigarg,
      569 	 error_table_$incompatible_attach,
      570 	 error_table_$invalid_record_length,
      571 	 error_table_$no_iocb,
      572 	 error_table_$noarg,
      573 	 error_table_$not_detached)	fixed bin(35) ext static;
      574 
      575 /* internal static */  
      576 
      577        dcl FALSE			bit (1) aligned internal static
      578 				options (constant) init ("0"b);
      579 
      580        dcl ME			char (14) internal static
      581 				options (constant) 
      582 				init ("record_stream_");
      583 
      584        dcl TRUE			bit (1) aligned internal static
      585 				options (constant) init ("1"b);
      586 
      587        dcl SPACE			char (1) aligned internal static
      588 				options (constant) init (" ");
      589 
      590        dcl op_io_mode (5)		fixed bin internal static options
      591 				(constant) init (6, 6, 6, 3, 3);
      592 
      593        dcl op_mode (5)		fixed bin internal static options
      594 				(constant) init (4, 5, 6, 1, 2);
      595 
      596 /* builtins */
      597 
      598        dcl (addr, before, char, hbound, index, lbound, length, ltrim, null,
      599 	 rtrim, size)		builtin;
      600 
      601 /* conditions */
      602 
      603        dcl (any_other, cleanup)	condition;
      604 
  1     1 /*  BEGIN:   rs_attach_block.incl.pl1			  *  *  *  *  *  */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(75-02-13,Asherman), approve(), audit(), install():
  1     6*     Initial coding.
  1     7*  2) change(87-08-30,GWMay), approve(87-08-30,MCR7730), audit(87-09-10,GDixon),
  1     8*     install(87-09-10,MR12.1-1104):
  1     9*     Changed target_name to be unaligned.
  1    10*                                                   END HISTORY COMMENTS */
  1    11 
  1    12 
  1    13 dcl	   rsab_ptr	      ptr;
  1    14      dcl	   1 rs_attach_block      based (rsab_ptr) aligned,
  1    15 						/* record_stream_ attach block */
  1    16 						/* the following are set during attachment */
  1    17 	     2 attach_descrip,
  1    18 	       3 attach_descrip_len
  1    19 			      fixed (35),
  1    20 	       3 attach_descrip_string
  1    21 			      char (66),		/* "record_stream_ <targ_sw_name> <option>" */
  1    22 	     2 target_name	      char (32) unaligned,	/* name of the target switch */
  1    23 	     2 length_n	      fixed (21),		/* =-1 --> -nnl option, */
  1    24 						/* = 0 --> default option, */
  1    25 						/* > 0 --> -length option */
  1    26 	     2 i_attached_target  bit (1) aligned,	/* ="1"b --> target attached via -target option */
  1    27 						/* the following are set during opening */
  1    28 	     2 open_descrip,
  1    29 	       3 open_descrip_len fixed (35),
  1    30 	       3 open_descrip_string
  1    31 			      char (24),
  1    32 	     2 mode	      fixed,		/* opening mode-- may be 1,2,4, or 5 if open */
  1    33 	     2 target_iocb_ptr    ptr,		/* points to the iocb for the target switch */
  1    34 	     2 i_opened_target    bit (1) aligned,	/* ="1"b --> this opening caused target to be opened */
  1    35 	     2 base	      fixed (21),		/* offset of next byte in rs_buffer */
  1    36 	     2 n_left	      fixed (21);		/* number of unprocessed bytes in rs_buffer */
  1    37 
  1    38 /*  END OF:  rs_attach_block.incl.pl1			  *  *  *  *  *  */
      605 
      606 
      607        dcl iocb_ptr			ptr;
  2     1 
  2     2      dcl	   1 iocb		      aligned based (iocb_ptr),
  2     3 						/* I/O control block. */
  2     4 	     2 iocb_version	      fixed init (1),	/* Version number of structure. */
  2     5 	     2 name	      char (32),		/* I/O name of this block. */
  2     6 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  2     7 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  2     8 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  2     9 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  2    10 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  2    11 	     2 reserved	      bit (72),		/* Reserved for future use. */
  2    12 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  2    13 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  2    14 						/* open(p,mode,not_used,s) */
  2    15 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  2    16 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    17 						/* get_line(p,bufptr,buflen,actlen,s) */
  2    18 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    19 						/* get_chars(p,bufptr,buflen,actlen,s) */
  2    20 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    21 						/* put_chars(p,bufptr,buflen,s) */
  2    22 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  2    23 						/* modes(p,newmode,oldmode,s) */
  2    24 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  2    25 						/* position(p,u1,u2,s) */
  2    26 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  2    27 						/* control(p,order,infptr,s) */
  2    28 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    29 						/* read_record(p,bufptr,buflen,actlen,s) */
  2    30 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    31 						/* write_record(p,bufptr,buflen,s) */
  2    32 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  2    33 						/* rewrite_record(p,bufptr,buflen,s) */
  2    34 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  2    35 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    36 						/* seek_key(p,key,len,s) */
  2    37 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    38 						/* read_key(p,key,len,s) */
  2    39 	     2 read_length	      entry (ptr, fixed (21), fixed (35));
  2    40 						/* read_length(p,len,s) */
  2    41 
      608 
      609 
  3     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  3     2 
  3     3 /* Written 05/04/78 by C. D. Tavares */
  3     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  3     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  3     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  3     7 
  3     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  3     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  3    10      iox_$close entry (pointer, fixed bin (35)),
  3    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  3    12      iox_$delete_record entry (pointer, fixed bin (35)),
  3    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  3    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  3    15      iox_$err_not_attached entry options (variable),
  3    16      iox_$err_not_closed entry options (variable),
  3    17      iox_$err_no_operation entry options (variable),
  3    18      iox_$err_not_open entry options (variable),
  3    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  3    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  3    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  3    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  3    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  3    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  3    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  3    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  3    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  3    28      iox_$propagate entry (pointer),
  3    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  3    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  3    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  3    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  3    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  3    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  3    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  3    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  3    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  3    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  3    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  3    40 
  3    41 dcl (iox_$user_output,
  3    42      iox_$user_input,
  3    43      iox_$user_io,
  3    44      iox_$error_output) external static pointer;
  3    45 
  3    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      610 
      611 
  4     1 /* Begin include file ..... iox_modes.incl.pl1 */
  4     2 
  4     3 /* Written by C. D. Tavares, 03/17/75 */
  4     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  4     5 
  4     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  4     7     ("stream_input", "stream_output", "stream_input_output",
  4     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  4     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  4    10      "direct_input", "direct_output", "direct_update");
  4    11 
  4    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  4    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  4    14 
  4    15 dcl (Stream_input initial (1),
  4    16      Stream_output initial (2),
  4    17      Stream_input_output initial (3),
  4    18      Sequential_input initial (4),
  4    19      Sequential_output initial (5),
  4    20      Sequential_input_output initial (6),
  4    21      Sequential_update initial (7),
  4    22      Keyed_sequential_input initial (8),
  4    23      Keyed_sequential_output initial (9),
  4    24      Keyed_sequential_update initial (10),
  4    25      Direct_input initial (11),
  4    26      Direct_output initial (12),
  4    27      Direct_update initial (13)) fixed bin int static options (constant);
  4    28 
  4    29 /* End include file ..... iox_modes.incl.pl1 */
      612 
      613 
  5     1 /* BEGIN INCLUDE FILE ... system_constants.incl.pl1 */
  5     2 
  5     3 /****^  HISTORY COMMENTS:
  5     4*  1) change(86-11-12,GWMay), approve(86-11-12,MCR7445), audit(86-11-19,GDixon),
  5     5*     install(86-11-21,MR12.0-1223):
  5     6*     created.
  5     7*                                                   END HISTORY COMMENTS */
  5     8 
  5     9 /* format: off */
  5    10 
  5    11 /* ************************************************************************ */
  5    12 /*							      */
  5    13 /* Function: Provides constants for commonly used Multics system values.    */
  5    14 /*							      */
  5    15 /* Usage: These values are available for use in place of "magic" numbers    */
  5    16 /*        (unexplained numbers) in programming applications.	      */
  5    17 /*							      */
  5    18 /* Definitions:						      */
  5    19 /*							      */
  5    20 /*   PER             bit     character/byte     word     page     segment   */
  5    21 /*		 					      */
  5    22 /*   bits              1            9             36     36864    9400320   */
  5    23 /*   characters/bytes	      1	           4      4096    1044480   */
  5    24 /*   words				 1      1024     261120   */
  5    25 /*   pages				           1        255   */
  5    26 /*   segments						  1   */
  5    27 /*							      */
  5    28 /*  The base values for a bit, char, word and page are determined by the    */
  5    29 /*  Multics hardware implementation.  The other values are calculated from  */
  5    30 /*  their relation to one another as shown in the matrix above.	      */
  5    31 /*							      */
  5    32 /*  BITS_PER_CHAR     = 9 (defined by the hardware)		      */
  5    33 /*  BITS_PER_WORD     = BITS_PER_CHAR * CHARS_PER_WORD		      */
  5    34 /*		  = 9 * 4					      */
  5    35 /*		  = 36					      */
  5    36 /*  BITS_PER_PAGE     = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE     */
  5    37 /*		  = 9 * 4 * 1024				      */
  5    38 /*		  = 36864					      */
  5    39 /*  BITS_PER_SEGMENT  = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE *   */
  5    40 /*		    PAGES_PER_SEGMENT			      */
  5    41 /*		  = 9 * 4 * 1024 * 255			      */
  5    42 /*		  = 9400320				      */
  5    43 /*							      */
  5    44 /*  CHARS_PER_WORD    = 4 (defined by the hardware)		      */
  5    45 /*  CHARS_PER_PAGE    = CHARS_PER_WORD * WORDS_PER_PAGE		      */
  5    46 /*		  = 4 * 1024				      */
  5    47 /*		  = 4096					      */
  5    48 /*  CHARS_PER_SEGMENT = CHARS_PER_WORD * WORDS_PER_PAGE * PAGES_PER_SEGMENT */
  5    49 /*		  = 4 * 1024 * 255				      */
  5    50 /*		  = 1044480				      */
  5    51 /*							      */
  5    52 /*  WORDS_PER_PAGE    = 1024 (defined by the hardware)		      */
  5    53 /*  WORDS_PER_SEGMENT = WORDS_PER_PAGE * PAGES_PER_SEGMENT		      */
  5    54 /*		  = 1024 * 255				      */
  5    55 /*		  = 261120				      */
  5    56 /*							      */
  5    57 /*  PAGES_PER_SEGMENT = 255 (defined by system standard)		      */
  5    58 /*							      */
  5    59 /* ************************************************************************ */
  5    60 
  5    61        declare BITS_PER_CHAR		fixed bin (4) internal static
  5    62 				options (constant) initial (9);
  5    63 
  5    64        declare BITS_PER_WORD		fixed bin (6) internal static
  5    65 				options (constant) initial (36);
  5    66 
  5    67        declare BITS_PER_PAGE		fixed bin (16) internal static
  5    68 				options (constant) initial (36864);
  5    69 
  5    70        declare BITS_PER_SEGMENT	fixed bin (24) internal static
  5    71 				options (constant) initial (9400320);
  5    72 
  5    73        declare CHARS_PER_WORD		fixed bin (3) internal static
  5    74 				options (constant) initial (4);
  5    75 
  5    76        declare CHARS_PER_PAGE		fixed bin (13) internal static
  5    77 				options (constant) initial (4096);
  5    78 
  5    79        declare CHARS_PER_SEGMENT	fixed bin (21) internal static
  5    80 				options (constant) initial (1044480);
  5    81 
  5    82        /* Note: WORDS_PER_PAGE should be equal to sys_info$max_page_size    */
  5    83 
  5    84        declare WORDS_PER_PAGE		fixed bin (11) internal static
  5    85 				options (constant) initial (1024);
  5    86 
  5    87        /* Note: WORDS_PER_SEGMENT should be equal to sys_info$max_seg_size  */
  5    88 
  5    89        declare WORDS_PER_SEGMENT	fixed bin (21) internal static
  5    90 				options (constant) initial (261120);
  5    91 
  5    92        declare PAGES_PER_SEGMENT	fixed bin (8) internal static
  5    93 				options (constant) initial (255);
  5    94 
  5    95 /* END INCLUDE FILE ... system_constants.incl.pl1 */
  5    96 
      614 
      615 
  6     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  6     2 /* format: style3 */
  6     3 
  6     4 /* These constants are to be used for the flags argument of sub_err_ */
  6     5 /* They are just "string (condition_info_header.action_flags)" */
  6     6 
  6     7 declare	(
  6     8 	ACTION_CAN_RESTART	init (""b),
  6     9 	ACTION_CANT_RESTART init ("1"b),
  6    10 	ACTION_DEFAULT_RESTART
  6    11 			init ("01"b),
  6    12 	ACTION_QUIET_RESTART
  6    13 			init ("001"b),
  6    14 	ACTION_SUPPORT_SIGNAL
  6    15 			init ("0001"b)
  6    16 	)		bit (36) aligned internal static options (constant);
  6    17 
  6    18 /* End include file */
      616 
      617 
      618 end record_stream_attach;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/10/87  1445.7  record_stream_attach_.pl1         >special_ldd>install>MR12.1-1104>record_stream_attach_.pl1
605          1    09/10/87  1444.7  rs_attach_block.incl.pl1          >special_ldd>install>MR12.1-1104>rs_attach_block.incl.pl1
608          2    07/02/81  1905.0  iocbv.incl.pl1                    >ldd>include>iocbv.incl.pl1
610          3    05/23/83  0916.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
612          4    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
614          5    11/24/86  1243.9  system_constants.incl.pl1         >ldd>include>system_constants.incl.pl1
616          6    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CHARS_PER_SEGMENT               000000 constant        fixed bin(21,0)          initial dcl 5-79 ref 140 140
EXIT                            000100 automatic       label variable           dcl 525 set ref 50* 200 278* 460* 511
FALSE                                  constant        bit(1)                   initial dcl 577 ref 69 89 453 459 492
ME                              000131 constant        char(14)                 initial unaligned dcl 580 set ref 40* 61* 72* 118
                                                                                  132* 140* 155* 172* 181* 186* 192* 195* 224* 229*
                                                                                  236* 243* 257* 268* 292* 297* 298* 337* 356* 386*
Pcode                                  parameter       fixed bin(35,0)          dcl 518 set ref 30 213 332 381 420 429* 434 443*
                                                                                  458* 504 504*
Pcom_err                               parameter       bit(1)                   dcl 518 ref 30 37
Piocb_ptr                              parameter       pointer                  dcl 518 ref 30 36 213 332 381 420 434 451
SPACE                                  constant        char(1)                  initial dcl 587 ref 263
Scom_err                        000104 automatic       bit(1)                   dcl 525 set ref 37* 453* 507
Sequential_input                       constant        fixed bin(17,0)          initial dcl 4-15 ref 234 312
Sequential_output                      constant        fixed bin(17,0)          initial dcl 4-15 ref 229 241 296 349
Serror_occurred                 000105 automatic       bit(1)                   dcl 525 set ref 200 459* 510*
Sextend                                parameter       bit(1)                   dcl 218 ref 213 224
Sfatal                          000102 automatic       bit(1)                   dcl 485 set ref 492* 498* 511
Stream_input                           constant        fixed bin(17,0)          initial dcl 4-15 ref 241 307
Stream_input_output                    constant        fixed bin(17,0)          initial dcl 4-15 ref 229
Stream_output                          constant        fixed bin(17,0)          initial dcl 4-15 ref 234 309 351
TRUE                                   constant        bit(1)                   initial dcl 584 ref 58 274 498 510
actual_iocb_ptr          12            based           pointer                  level 2 dcl 2-2 ref 268 268 451
addr                                                   builtin function         dcl 598 ref 99 320
alloc_cb_file                   000010 constant        entry                    external dcl 547 ref 52
any_other                       000540 stack reference condition                dcl 603 ref 96 304 367 405
arg_record_length               000106 automatic       fixed bin(35,0)          dcl 525 set ref 85 117* 127* 138* 140 140 203 205
                                                                                  205
args                     14     000113 automatic       char(20)                 level 2 dcl 525 set ref 77 120* 203* 205*
attach_data_ptr          16            based           pointer                  level 2 dcl 2-2 set ref 98* 408* 452
attach_descrip                         based           structure                level 2 dcl 1-14 set ref 99
attach_descrip_len                     based           fixed bin(35,0)          level 3 dcl 1-14 set ref 81*
attach_descrip_ptr       14            based           pointer                  level 2 dcl 2-2 set ref 40 99* 409*
attach_descrip_string
                          1            based           char(66)                 level 3 dcl 1-14 set ref 77* 81
base                     47            based           fixed bin(21,0)          level 2 dcl 1-14 set ref 90*
before                                                 builtin function         dcl 598 ref 263
char                                                   builtin function         dcl 598 ref 205
cleanup                         000546 stack reference condition                dcl 603 ref 49 277
close                    36            based           entry variable           level 2 dcl 2-2 set ref 321*
code                            000107 automatic       fixed bin(35,0)          dcl 525 set ref 59* 61* 70* 72* 125* 283* 287* 292*
                                                                                  297* 298* 337* 351* 362 362* 386* 400* 458*
com_err_                        000014 constant        entry                    external dcl 547 ref 507 507
control                  66            based           entry variable           level 2 dcl 2-2 set ref 103*
cu_$arg_list_ptr                000114 constant        entry                    external dcl 487 ref 507 507
cu_$arg_ptr                     000116 constant        entry                    external dcl 487 ref 500
cu_$generate_call               000120 constant        entry                    external dcl 487 ref 507
cv_dec_check_                   000012 constant        entry                    external dcl 547 ref 138
detach_iocb              26            based           entry variable           level 2 dcl 2-2 set ref 100* 372*
ercode                          000110 automatic       fixed bin(35,0)          dcl 525 set ref 138* 140 356* 361* 362 401*
error_code                             based           fixed bin(35,0)          dcl 482 ref 503 504
error_table_$att_loop           000044 external static fixed bin(35,0)          dcl 564 set ref 268*
error_table_$bad_arg            000046 external static fixed bin(35,0)          dcl 564 set ref 140* 186* 195* 224*
error_table_$bad_mode           000052 external static fixed bin(35,0)          dcl 564 set ref 229*
error_table_$bad_opt            000050 external static fixed bin(35,0)          dcl 564 set ref 181*
error_table_$bigarg             000054 external static fixed bin(35,0)          dcl 564 set ref 172*
error_table_$incompatible_attach
                                000056 external static fixed bin(35,0)          dcl 564 ref 287
error_table_$invalid_record_length
                                000060 external static fixed bin(35,0)          dcl 564 set ref 236* 243*
error_table_$no_iocb            000062 external static fixed bin(35,0)          dcl 564 set ref 257*
error_table_$noarg              000064 external static fixed bin(35,0)          dcl 564 set ref 132* 155* 192*
error_table_$not_detached       000066 external static fixed bin(35,0)          dcl 564 set ref 40*
free_cb_file                    000020 constant        entry                    external dcl 547 ref 414
get_temp_segment_               000016 constant        entry                    external dcl 547 ref 297
hbound                                                 builtin function         dcl 598 ref 123 132 155 162 224
hcs_$reset_ips_mask             000022 constant        entry                    external dcl 547 ref 96 106 304 325 367 377 405 412
hcs_$set_ips_mask               000024 constant        entry                    external dcl 547 ref 97 305 368 406
i                               000111 automatic       fixed bin(17,0)          dcl 525 set ref 123* 127 127 129 129 132 132 137*
                                                                                  137Äq^    
˙     *@          Äq^            *           Äq^    B"  &Tb»Ø*∂|#   8: Œa   8     k    project_management.proceedings      Tb»Ø,Å    €	á˜ï              í  FÊ: Œa               SÒπ›         π    pm.proceedings                      Tb»ØN    :  *@          Tb»Ø    VF      *@          Tb»Ø    ^N    *@          Tb»Ø    fV  H  *@          Tb»Ø    n^   †  *@          Tb»Ø    vf   Ñ  *@          Tb»Ø    ~n  Ä  *@          Tb»Ø    Üv   Æ  *@          Tb»Ø    é~    *@          Tb»Ø    ñÜ  r  *@          Tb»Ø    ûé  ‘  *@          Tb»Ø    ¶ñ  ∆  *@          Tb»Ø    Æû    *@          Tb»Ø    ∂¶  ,  *@          Tb»Ø    æÆ  ú  *@          Tb»Ø    ∆∂  ™  *@          Tb»Ø    Œæ     h*@          Tb»Ø    ÷∆     Œ*@          Tb»Ø    ﬁŒ     ‹*@          Tb»Ø    Ê÷     *@          Tb»Ø      ﬁ      *           Tb»Ø    V  &Äqr*WÑ8   ˆÄ Ía       Ó ≠    source_code_control.control         ÄqrRy“å    €	á˜¬              í  Ä Ía               SÒπ›      ˆ  Ó √    scc.control                         Äqr<       h*@  ¿       ^áq"    ö       h*@  ¿       i√^    :¥     *@          ÄqN      2      *           ÄqN    ≤  &Tbÿ˝*ºïZ   Jh: a   h    B Z    basic.proceedings                   Tbÿ˝+Ç¬    €	Õõ              í  vé: a               SÒπ›      J  B Ç    bas.proceedings                     Tbÿ˝~    :  *@          Tbÿ˝    Üv     h*@          Tbÿ˝    é~     *@          Tbÿ˝      Ü      *           Tbÿ˝    V&  &Äq^*∂|#   ûº: Œa   º    ñ Ù  project_management.control          Äq^Ry“Ä    €Ó2Æâ              í  Ù
: Œa               SÒπ›      û  ñ -    pm.control                          Äq^0       h*@  ¿       {˚Pa    h    R*           ó@sH        ™ v*@          ó@sH              *@  ¿       ñ&“    ¢*  &éÏ¨7”Ö   Ú 0»a       Í •    Operations.forum                    éÏ¨Ry“c    €Ó2Æ[               ∏ 6. 0»a   ‡˝∞°        SÒπ›      Ú  Í =    opr.forum                           éÏ¨÷       h*@  ¿       ê≈qH              *@  ¿       éy»f      6      *@  ¿       éÏ¨    .       h*@  ¿       éÏ¨    î6  &ë	k∫HùV/   Fd™ va   d    > †
  sei_org_roles.forum                 ë	k∫           '>udd>Multics>Collin>sei_org_roles.forum     SÒπ›      F  > S    org_roles.forum                     ë	k∫Ù       h*@  ¿       {kfì    $       h*@  ¿       Ä‹ÍL    ä	.     *@          Äqe    íÇ     Í*@          Äqe    öä     >*@          Äqe    ¢í     *@          Äqe    ™ö     v*@          Äqe      ¢      *           Äqe    |B  &Wµ¯J+^Z   ∫ÿ í a   ÿ    ≤ Ø    soft_dev_analysis.proceedings       Wµ¯J,Ëıﬁ    €	á˜ã              í  Ê í a               SÒπ›      ∫  ≤ N    sda.proceedings                     Wµ¯JÓ     í  *@          Wµ¯J    ˆÊ     h*@          Wµ¯J    ˛Ó     *@          Wµ¯J    ˆ     Í*@          Wµ¯J    ˛     >*@          Wµ¯J         *@          Wµ¯J         v*@          Wµ¯J            *           Wµ¯J                -*—           Za   \    & 4    Terminal_Evaluation.control         Äqh@ÆÁÇ        >udd>m>mba>meetings>Terminal_Evaluation.control     SÒπ›                                                                                                                                      ƒ  º ≈    mac.forum                           ñ…Ç\Ï≤  &[8óf-¢ùó   Ñ¢: a   ¢    | O    pse_prototype.forum                 [8ófRy“Ñ    ¬üzåu               ∏ r∞: a   ‡˝∞°        SÒπ›      Ñ  | í    pse.forum                           [8óf  r      *@  ¿       [8óf    r  &ê≈q>HzB	   ¿F¢ ha   j    ∏ 
b  Tools_from_SystemM.forum            ê≈q>Ry“i    €	Õ               ∏ ¶‘¢ ha   ‡˝∞°        SÒπ›      ñ  é ¶    test.forum                          Äq_D|  &^áq"KEû,   Ù   Za   .    Ï l    meetings_dir.forum              09 415
old_modes                              parameter       char                     unaligned dcl 425 set ref 420 429*
op_io_mode                      000124 constant        fixed bin(17,0)          initial array dcl 590 ref 287
op_mode                         000117 constant        fixed bin(17,0)          initial array dcl 593 ref 283 287
open                     32            based           entry variable           level 2 dcl 2-2 set ref 101* 373*
open_data_ptr            22            based           pointer                  level 2 dcl 2-2 set ref 297* 351* 356 356* 371*
open_descrip             34            based           structure                level 2 dcl 1-14 set ref 320
open_descrip_len         34            based           fixed bin(35,0)          level 3 dcl 1-14 set ref 86* 251*
open_descrip_ptr         20            based           pointer                  level 2 dcl 2-2 set ref 260 274 320* 370*
open_descrip_string      35            based           char(24)                 level 3 dcl 1-14 set ref 87* 253*
open_mode                              parameter       fixed bin(17,0)          dcl 218 ref 213 224 224 229 229 234 234 241 241 250
                                                                                  251 253
option_array                           parameter       varying char             array dcl 518 set ref 30 123 127 127 129 129 132
                                                                                  132* 138 140* 140* 150 155 155* 161 162 164 172
                                                                                  172* 177 181 181* 186*
order                                  parameter       char                     unaligned dcl 439 set ref 434 443*
p_error_code                    000100 automatic       pointer                  dcl 482 set ref 500* 503 504
release_temp_segment_           000026 constant        entry                    external dcl 547 ref 356
requote_string_                 000030 constant        entry                    external dcl 547 ref 164
rs_attach_block                        based           structure                level 1 dcl 1-14 set ref 52 52 414 414
rs_attach_desc                  000113 automatic       structure                level 1 dcl 525
rs_open_seq_in_                 000032 constant        entry                    external dcl 547 ref 312
rs_open_seq_out_                000034 constant        entry                    external dcl 547 ref 315
rs_open_str_in_                 000036 constant        entry                    external dcl 547 ref 307
rs_open_str_out_                000040 constant        entry                    external dcl 547 ref 309
rsab_ptr                        000554 automatic       pointer                  dcl 1-13 set ref 48* 52 52 52* 58 59 69 70 77 81 81
                                                                                  84 85 86 87 88 89 90 91 98 99 236 243 250 251 253
                                                                                  257 260 268 274 274 283 283 283 287 287 296 307
                                                                                  309 312 320 349 351 351 351 351 360 361 396 399
                                                                                  400 401 414 414 414* 415* 429 443 452*
rtrim                                                  builtin function         dcl 598 ref 77 77 81 251
size                                                   builtin function         dcl 598 ref 52 52 414 414
switch_name               4     000113 automatic       char(32)                 level 2 packed unaligned dcl 525 set ref 57* 59* 70*
                                                                                  72* 77 84 119* 172 172 172 177* 191
target_args                     000134 automatic       varying char(1024)       dcl 525 set ref 56 59 61* 121* 161* 161 163* 163
                                                                                  164* 164 192 195
target_iocb_ptr          44            based           pointer                  level 2 dcl 1-14 set ref 59* 70* 257 260 268 274
                                                                                  283* 351* 361* 400* 401* 429* 443*
target_name              22            based           char(32)                 level 2 packed unaligned dcl 1-14 set ref 84*
target_open_mode                       based           varying char(24)         dcl 541 set ref 263* 263 287 287
target_open_mode_ptr            000536 automatic       pointer                  dcl 541 set ref 260* 263 263 263 287 287
unique_chars_                   000042 constant        entry                    external dcl 547 ref 57

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CANT_RESTART                    internal static bit(36)                  initial dcl 6-7
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 6-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 6-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 6-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 6-7
BITS_PER_CHAR                          internal static fixed bin(4,0)           initial dcl 5-61
BITS_PER_PAGE                          internal static fixed bin(16,0)          initial dcl 5-67
BITS_PER_SEGMENT                       internal static fixed bin(24,0)          initial dcl 5-70
BITS_PER_WORD                          internal static fixed bin(6,0)           initial dcl 5-64
CHARS_PER_PAGE                         internal static fixed bin(13,0)          initial dcl 5-76
CHARS_PER_WORD                         internal static fixed bin(3,0)           initial dcl 5-73
Direct_input                           internal static fixed bin(17,0)          initial dcl 4-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 4-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 4-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 4-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 4-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 4-15
PAGES_PER_SEGMENT                      internal static fixed bin(8,0)           initial dcl 5-92
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 4-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 4-15
WORDS_PER_PAGE                         internal static fixed bin(11,0)          initial dcl 5-84
WORDS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 5-89
iox_$attach_loud                000000 constant        entry                    external dcl 3-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 3-8
iox_$close_file                 000000 constant        entry                    external dcl 3-8
iox_$delete_record              000000 constant        entry                    external dcl 3-8
iox_$detach                     000000 constant        entry                    external dcl 3-8
iox_$err_no_operation           000000 constant        entry                    external dcl 3-8
iox_$err_not_attached           000000 constant        entry                    external dcl 3-8
iox_$err_not_closed             000000 constant        entry                    external dcl 3-8
iox_$err_not_open               000000 constant        entry                    external dcl 3-8
iox_$error_output                      external static pointer                  dcl 3-41
iox_$find_iocb_n                000000 constant        entry                    external dcl 3-8
iox_$get_chars                  000000 constant        entry                    external dcl 3-8
iox_$get_line                   000000 constant        entry                    external dcl 3-8
iox_$look_iocb                  000000 constant        entry                    external dcl 3-8
iox_$move_attach                000000 constant        entry                    external dcl 3-8
iox_$open_file                  000000 constant        entry                    external dcl 3-8
iox_$position                   000000 constant        entry                    external dcl 3-8
iox_$put_chars                  000000 constant        entry                    external dcl 3-8
iox_$read_key                   000000 constant        entry                    external dcl 3-8
iox_$read_length                000000 constant        entry                    external dcl 3-8
iox_$read_record                000000 constant        entry                    external dcl 3-8
iox_$rewrite_record             000000 constant        entry                    external dcl 3-8
iox_$seek_key                   000000 constant        entry                    external dcl 3-8
iox_$user_input                        external static pointer                  dcl 3-41
iox_$user_io                           external static pointer                  dcl 3-41
iox_$user_output                       external static pointer                  dcl 3-41
short_iox_modes                        internal static char(4)                  initial array dcl 4-12

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_CODE                      003577 constant        entry                    internal dcl 479 ref 132 140 155 172 181 186 192 195
CHECK_CODE_return_on_error      003607 constant        entry                    internal dcl 495 ref 40 61 72 224 229 236 243 257
                                                                                  268 292 298 337 386
ERROR_COMMON                    003616 constant        label                    dcl 500 ref 493
EXIT_BY_RETURN                  001116 constant        label                    dcl 108 ref 460
EXIT_WITH_CLOSE                 001724 constant        label                    dcl 328 ref 278
EXIT_WITH_DETACH                001117 constant        label                    dcl 111 ref 50
get_args                        002161 constant        entry                    internal dcl 115 ref 44
initialize                      003554 constant        entry                    internal dcl 448 ref 221 335 384 428 442
initialize$attach               003566 constant        entry                    internal dcl 455 ref 38
record_stream_attach            000355 constant        entry                    external dcl 30
record_stream_close             001735 constant        entry                    external dcl 332 ref 321
record_stream_close_            003173 constant        entry                    internal dcl 341 ref 277 328 336
record_stream_control           002112 constant        entry                    external dcl 434 ref 103
record_stream_detach            001771 constant        entry                    external dcl 381 ref 100 372
record_stream_detach_           003402 constant        entry                    internal dcl 389 ref 49 111 385
record_stream_modes             002030 constant        entry                    external dcl 420 ref 102
record_stream_open              001131 constant        entry                    external dcl 213 ref 101 373

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4522        4644    3713        4532
Length      5276    3713       122         416     606           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
record_stream_attach                514 external procedure  is an external procedure.  
on unit on line 49                   64 on unit               
on unit on line 96                   70 on unit               
get_args                                internal procedure  shares stack frame of external procedure record_stream_attach.  
on unit on line 277                  64 on unit               
on unit on line 304                  70 on unit               
record_stream_close_                 95 internal procedure  enables or reverts conditions.  
on unit on line 367                  70 on unit               
record_stream_detach_                77 internal procedure  enables or reverts conditions.  
on unit on line 405                  70 on unit               
initialize                              internal procedure  shares stack frame of external procedure record_stream_attach.  
CHECK_CODE                           92 internal procedure  is declared options(variable).  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
CHECK_CODE               000100 p_error_code                CHECK_CODE
                         000102 Sfatal                      CHECK_CODE
record_stream_attach     000100 EXIT                        record_stream_attach
                         000104 Scom_err                    record_stream_attach
                         000105 Serror_occurred             record_stream_attach
                         000106 arg_record_length           record_stream_attach
                         000107 code                        record_stream_attach
                         000110 ercode                      record_stream_attach
                         000111 i                           record_stream_attach
                         000112 ips_mask                    record_stream_attach
                         000113 rs_attach_desc              record_stream_attach
                         000134 target_args                 record_stream_attach
                         000536 target_open_mode_ptr        record_stream_attach
                         000554 rsab_ptr                    record_stream_attach
                         000556 iocb_ptr                    record_stream_attach

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return_mac          tra_ext_2           enable_op           shorten_stack       ext_entry
ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
alloc_cb_file                 com_err_                      cu_$arg_list_ptr              cu_$arg_ptr
cu_$generate_call             cv_dec_check_                 free_cb_file                  get_temp_segment_
hcs_$reset_ips_mask           hcs_$set_ips_mask             iox_$attach_name              iox_$close
iox_$control                  iox_$destroy_iocb             iox_$detach_iocb              iox_$find_iocb
iox_$modes                    iox_$open                     iox_$propagate                iox_$write_record
release_temp_segment_         requote_string_               rs_open_seq_in_               rs_open_seq_out_
rs_open_str_in_               rs_open_str_out_              unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$att_loop         error_table_$bad_arg          error_table_$bad_mode         error_table_$bad_opt
error_table_$bigarg           error_table_$incompatible_attach
error_table_$invalid_record_length                          error_table_$no_iocb          error_table_$noarg
error_table_$not_detached




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     30 000350        36 000373        37 000376        38 000401        40 000402        44 000436        48 000437
     49 000441        50 000463        52 000466        56 000501        57 000506        58 000540        59 000544
     61 000606        64 000636        69 000637        70 000641        72 000662        77 000711        81 000764
     84 000777        85 001002        86 001004        87 001005        88 001010        89 001011        90 001012
     91 001013        95 001014        96 001015        97 001042        98 001055        99 001060       100 001062
    101 001066       102 001071       103 001074       105 001077       106 001106            @                        SÒπ›€	Õ‡˝∞°        3 
  ƒ   º Œ‚ v  E 
 Ú @                                                                                                   ˚ L º     >ËÑˇˇˇˇ  í                                                Sw√a     Ú  ôˇÍ          && H   Ç               Ç  Í  ñ      z  X¿Ï
¢    Ã    j  .ú  ‹\        
nÊ  @          	Æ	‘÷ê&        	Í@  ⁄Ü    "      	l÷Æ    íÃ            ,V
"∆$j  Ddå      4Jﬁ    &            >ò
2»‰  |Ù  	ò	  |`  ¯ƒ  ¯              ö`    ‚  î        h∂        
≤Ä∞  Ê  D∏  B    0¨F    n  ÚñXà\  ∫  ˆ  ∫»L
÷	ˆv‘      8  :  ËÆ  Lú  
ú  n  *  @  †          L  	F
8  Ù  à‚  
Ïæ            Ä            ∆*       ˆ*        Í      SÒπ›Z           ASPD                                SÒπ› ÍZ         DCS                                 SÒπ›R ‹         Fortran                             SÒπ› R         HIS                                 SÒπ›  ¯     è    Multics                             SÒπ› "          Office                              SÒπ›»          OperDevel                           SÒπ›
ÿ™         Sherwood                            SÒπ› L»         PSE                                 SÒπ› Z >         Service                             SÒπ› h L         SysAdmin                            SÒπ› v Z     ,    SysDaemon                           SÒπ›   h         SysMaint                            SÒπ› º         BWong                               SÒπ›
»         Chandler                            SÒπ›		ä     
    DGHowe                              SÒπ›N	         Dewar                               SÒπ› Ñ           ANeal                               SÒπ›Ë∏         Fudge                               SÒπ› ÊË         Gatha                               SÒπ› Ù ÿ         Gee                                 SÒπ›  Ê         Ginter                              SÒπ›          Gray                                SÒπ›6         Hoover                              SÒπ›,6     *    Hussein                             SÒπ›:         LJHarris                            SÒπ›H,         Leskiw                              SÒπ›V:         MJMallmes                           SÒπ›LH         Mabey                               SÒπ›àL         Mallmes                             SÒπ›∂à         McGuire        

                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
