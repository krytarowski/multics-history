	COMPILATION LISTING OF SEGMENT le_combine_init_info_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/05/87  1306.4 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
        9*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
       10*     Originally written to create a single initialization info block for each
       11*     external variable reference by combining the init info blocks for all of
       12*     the links referring to that external variable.
       13*  2) change(86-12-19,Elhard), approve(86-12-19,PBF7505),
       14*     audit(86-12-22,DGHowe), install(87-01-05,MR12.0-1256):
       15*     Changed to scan for multiple *system/*heap links to the same target within
       16*     one linkage section when looking for init infos so that references to
       17*     *heap$p and *heap$p,* references in the same linkage section both get the
       18*     correct initialization.
       19*                                                   END HISTORY COMMENTS */
       20 
       21 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       22 
       23 le_combine_init_info_:
       24   proc (lecp);			/** components pointer  (in )	*/
       25 
       26   /*** ****************************************************************/
       27   /***							*/
       28   /***	Name:	le_combine_init_info_			*/
       29   /***	Input:	lecp					*/
       30   /***	Function:	combines the init_infos for multiple *system or	*/
       31   /***		*heap links to the same target into a single init	*/
       32   /***		info.					*/
       33   /***	Output:	lecp					*/
       34   /***							*/
       35   /*** ****************************************************************/
       36 
       37   /* constants */
       38 
       39   dcl true		bit (1) static options (constant) init ("1"b);
       40   dcl false		bit (1) static options (constant) init ("0"b);
       41   dcl None		fixed bin static options (constant) init (0);
       42 
       43   /* parameters */
       44 
       45   dcl lecp		ptr parameter;
       46 
       47   /* procedures */
       48 
       49   dcl le_debug_		entry options (variable);
       50   dcl le_error_		entry options (variable);
       51 
       52   /* external */
       53 
       54   dcl le_et_$incompatible_init
       55 			external fixed bin (35);
       56   dcl le_et_$multiple_inits	external fixed bin (35);
       57 
       58   /* based */
       59 
       60   dcl 01 lec		aligned based (lecp),
       61        02 header		aligned like le_components.header,
       62        02 comp		dim (0 refer (lec.n_components)) like le_comp;
       63   dcl 01 lel		aligned based (lelp),
       64        02 header		aligned like le_links.header,
       65        02 link		dim (0 refer (lel.n_links)) like le_link;
       66   dcl 01 name		aligned based (namep),
       67        02 count		fixed bin (9) unsigned unaligned,
       68        02 string		char (0 refer (name.count)) unaligned;
       69   dcl 01 new_name		aligned based (new_namep),
       70        02 count		fixed bin (9) unsigned unaligned,
       71        02 string		char (0 refer (new_name.count)) unaligned;
       72   dcl 01 tlel		aligned based (tlelp),
       73        02 header		aligned like le_links.header,
       74        02 link		dim (0 refer (tlel.n_links)) like le_link;
       75 
       76   /* automatic */
       77 
       78   dcl c			fixed bin automatic;
       79   dcl chase_c		fixed bin automatic;
       80   dcl chase_l		fixed bin automatic;
       81   dcl extend		bit (1) automatic;
       82   dcl extension		fixed bin (35) automatic;
       83   dcl incompatible		bit (1) automatic;
       84   dcl initp		ptr automatic;
       85   dcl l			fixed bin automatic;
       86   dcl lelp		ptr automatic;
       87   dcl message		bit (1) automatic;
       88   dcl min			fixed bin automatic;
       89   dcl namep		ptr automatic;
       90   dcl new_initp		ptr automatic;
       91   dcl new_len		fixed bin (35) automatic;
       92   dcl new_namep		ptr automatic;
       93   dcl next_c		fixed bin automatic;
       94   dcl next_l		fixed bin automatic;
       95   dcl owner		fixed bin automatic;
       96   dcl print_message		bit (1) automatic;
       97   dcl replace		bit (1) automatic;
       98   dcl target_comp		fixed bin automatic;
       99   dcl target_link		fixed bin automatic;
      100   dcl tc			fixed bin automatic;
      101   dcl tl			fixed bin automatic;
      102   dcl tlelp		ptr automatic;
      103 
      104   /* builtin */
      105 
      106   dcl max			builtin;
      107   dcl null		builtin;
      108   dcl unspec		builtin;
      109 
      110   call le_debug_ ("Beginning init_info resolution.");
      111 
      112   /* for each component . . . */
      113 
      114   do c = 1 to lec.n_components;
      115 
      116     /* only process included component */
      117 
      118     if lec.comp (c).flags.include
      119       then do;
      120 
      121         /* get the link table */
      122 
      123         lelp = lec.comp (c).tables.lelp;
      124 
      125         /* for each link . . . */
      126 
      127         do l = 1 to lel.n_links;
      128 
      129 	/* if a *system or *heap link */
      130 
      131 	if lel.link (l).type = LINK_SELF_OFFSETNAME &
      132 	     (lel.link (l).class = CLASS_SYSTEM |
      133 	     lel.link (l).class = CLASS_HEAP) &
      134 	     lel.link (l).target_link = None
      135 	  then do;
      136 
      137 	    /* initialize the flags and other init status info */
      138 
      139 	    print_message = false;
      140 
      141 	    namep = lel.link (l).offsetp;
      142 	    initp = lel.link (l).initp;
      143 	    target_comp = c;
      144 	    target_link = l;
      145 	    extension = 0;
      146 
      147 	    call le_debug_ ("Combining init infos for " ||
      148 	         "*^[system^;heap^]$^a" ||
      149 	         "^/   using init info from component ^a",
      150 	         (lel.link (l).class = CLASS_SYSTEM), name.string,
      151 	         lec.comp (c).name);
      152 
      153 	    /* assume that there is only one copy of a given link	*/
      154 	    /* in any one component, so search the other components	*/
      155 	    /* for similar links.				*/
      156 
      157 	    do tc = c to lec.n_components;
      158 	      if lec.comp (tc).flags.include
      159 	        then do;
      160 
      161 		/* get the new components link table */
      162 
      163 		tlelp = lec.comp (tc).tables.lelp;
      164 
      165 		/* search for a matching link */
      166 
      167 		if tc = c
      168 		  then min = l + 1;
      169 		  else min = 1;
      170 		
      171 		do tl = min to tlel.n_links;
      172 		  if tlel.link (tl).type = LINK_SELF_OFFSETNAME &
      173 		       tlel.link (tl).class = lel.link (l).class &
      174 		       tlel.link (tl).target_link = None
      175 		    then do;
      176 		      new_namep = tlel.link (tl).offsetp;
      177 		      new_initp = tlel.link (tl).initp;
      178 
      179 		      if name.count = new_name.count
      180 			 & name.string = new_name.string
      181 		        then do;
      182 
      183 			/* the links match, so compare the init infos */
      184 
      185 			call compare_init (initp, extension, new_initp,
      186 			     replace, extend, message, incompatible,
      187 			     new_len);
      188 
      189 			/* print a message if the inits cant be	*/
      190 			/* merged.			*/
      191 
      192 			if incompatible
      193 			  then call le_error_ (LE_FATAL_ERROR,
      194 				  le_et_$incompatible_init,
      195 				  "^/Combining init infos for " ||
      196 				  "^[external^;heap^] " ||
      197 				  "variable ""^a"".",
      198 				  (lel.link (l).class = CLASS_SYSTEM),
      199 				  name.string);
      200 			  else do;
      201 
      202 			    /* thread the links together for	*/
      203 			    /* processing later when we know	*/
      204 			    /* what init_info will be used.	*/
      205 
      206 			    tlel.link (tl).target_comp =
      207 			         lel.link (l).target_comp;
      208 			    tlel.link (tl).target_link =
      209 			         lel.link (l).target_link;
      210 			    lel.link (l).target_comp = tc;
      211 			    lel.link (l).target_link = tl;
      212 
      213 			    if replace
      214 			      then do;
      215 
      216 			        /* we will use the new init info */
      217 
      218 			        call le_debug_ (
      219 				   "Replacing initialization with " ||
      220 				   "version in ^a",
      221 				   lec.comp (tc).name);
      222 
      223 			        initp = new_initp;
      224 			        extension = new_len -
      225 				   new_initp -> link_init.n_words;
      226 			        target_comp = tc;
      227 			        target_link = tl;
      228 			      end;
      229 			    if extend
      230 			      then do;
      231 
      232 			        /* the current init_info must	*/
      233 			        /* be extended.		*/
      234 
      235 			        call le_debug_ (
      236 				   "Extending initialization " ||
      237 				   "to ^d words.",
      238 				   new_len);
      239 			        extension = new_len -
      240 				   initp -> link_init.n_words;
      241 			      end;
      242 
      243 			    /* if a message is required at any	*/
      244 			    /* stage, remember and print it at	*/
      245 			    /* the end			*/
      246 
      247 			    print_message = print_message | message;
      248 			  end;
      249 		        end;
      250 		    end;
      251 		end;
      252 	        end;
      253 	    end;
      254 
      255 	    /* non-matching init_infos were found so print a	*/
      256 	    /* message to identify the one we will use.		*/
      257 
      258 	    if print_message
      259 	      then call le_error_ (LE_WARNING, le_et_$multiple_inits,
      260 		      "for ^[external^;heap^] variable ""^a""." ||
      261 		      "^/The one in ^a will be used.",
      262 		      (lel.link (l).class = CLASS_SYSTEM),
      263 		      name.string, lec.comp (target_comp).name);
      264 
      265 	    /* determine which output component will actually	*/
      266 	    /* contain the init info (non-deferred init references)	*/
      267 
      268 	    owner = lec.comp (target_comp).target;
      269 
      270 	    chase_c = c;
      271 	    chase_l = l;
      272 
      273 	    /* now chase through the linked list of link table	*/
      274 	    /* entries that refer to this variable, and set their	*/
      275 	    /* init info data so that the init info is emitted	*/
      276 	    /* correctly (if in the target component) or a valid	*/
      277 	    /* deferred initialization.			*/
      278 
      279 	    do while (chase_l ^= None);
      280 
      281 	      tlelp = lec.comp (chase_c).tables.lelp;
      282 
      283 	      next_l = tlel.link (chase_l).target_link;
      284 	      next_c = tlel.link (chase_l).target_comp;
      285 
      286 	      tlel.link (chase_l).target_link = target_link;
      287 	      tlel.link (chase_l).target_comp = target_comp;
      288 
      289 	      if lec.comp (chase_c).target = owner
      290 	        then do;
      291 
      292 		/* this link will be in the output component that	*/
      293 		/* actually contains the init_info, so fill in	*/
      294 		/* the information on how to generate it.	*/
      295 
      296 		tlel.link (chase_l).initp = initp;
      297 		tlel.link (chase_l).extension = extension;
      298 	        end;
      299 	        else do;
      300 
      301 		/* this link is in another output component.  We	*/
      302 		/* will be generating a deferred_init init info	*/
      303 		/* for it, so all we need is the target link.	*/
      304 
      305 		tlel.link (chase_l).initp = null;
      306 		tlel.link (chase_l).extension = None;
      307 	        end;
      308 	      chase_l = next_l;
      309 	      chase_c = next_c;
      310 	    end;
      311 	  end;
      312         end;
      313       end;
      314   end;
      315 
      316   call le_debug_ ("Completed init_info resolution.^2/");
      317 
      318   return;
      319 
      320 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      321 
      322 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      323 
      324 
      325 compare_init:
      326   proc (oldp,			/** old init info ptr   (in )	*/
      327        extension,			/** amount extended	    (in ) */
      328        newp,			/** new init info ptr   (in ) */
      329        replace,			/** use new init sw	    (out) */
      330        extend,			/** must be extended    (out) */
      331        message,			/** print an error msg  (out) */
      332        incompatible,		/** cannot be combined  (out) */
      333        new_len);			/** new init length	    (out) */
      334 
      335   /*** ****************************************************************/
      336   /***							*/
      337   /***	Name:	compare_init				*/
      338   /***	Input:	oldp, newp				*/
      339   /***	Function:	compares two init_info structures and determines	*/
      340   /***		which of them should be used, and whether it must	*/
      341   /***		be extended.  The rules for this are:		*/
      342   /***							*/
      343   /***		A.  init infos are same size			*/
      344   /***		  1.  no new initialization	     use old init	*/
      345   /***		  2.  new initialization			*/
      346   /***		    i.  was init before	     use old and	*/
      347   /***					     print message	*/
      348   /***		    ii. was not init before	     use new init	*/
      349   /***		B.  new initialization smaller		*/
      350   /***		  1.  no new initialization	     use old init	*/
      351   /***		  2.  new initialization			*/
      352   /***		    i.  was init before	     use old and	*/
      353   /***					     print message	*/
      354   /***		    ii. was not init before	     use new with	*/
      355   /***					     larger size	*/
      356   /***		C.  new initialization larger			*/
      357   /***		  1.  no new initialization			*/
      358   /***		    i.  was init before	     use old with	*/
      359   /***					     larger size	*/
      360   /***		    ii. was not init before	     use new	*/
      361   /***		  2.  new initialization			*/
      362   /***		    i.  was init before	     use new and	*/
      363   /***					     print message	*/
      364   /***		    ii. was not init before	     use new	*/
      365   /***	Output:	replace, extend, message, incompatible, new_len	*/
      366   /***							*/
      367   /*** ****************************************************************/
      368 
      369   /* parameters */
      370 
      371   dcl oldp		ptr parameter;
      372   dcl extension		fixed bin (35) parameter;
      373   dcl newp		ptr parameter;
      374   dcl replace		bit (1) parameter;
      375   dcl extend		bit (1) parameter;
      376   dcl message		bit (1) parameter;
      377   dcl incompatible		bit (1) parameter;
      378   dcl new_len		fixed bin (35) parameter;
      379 
      380   /* automatic */
      381 
      382   dcl have_new		bit (1) automatic;
      383   dcl have_old		bit (1) automatic;
      384   dcl larger		bit (1) automatic;
      385   dcl smaller		bit (1) automatic;
      386 
      387   /* preset return args */
      388 
      389   replace, extend, message, incompatible = false;
      390   new_len = max (oldp -> link_init.n_words + extension,
      391        newp -> link_init.n_words);
      392 
      393   /* preset flags */
      394 
      395   larger, smaller, have_old, have_new = false;
      396 
      397   /* see if the init_infos are the same */
      398 
      399   if oldp -> link_init.n_words + extension = newp -> link_init.n_words &
      400        oldp -> link_init.type = newp -> link_init.type
      401     then do;
      402 
      403       if oldp -> link_init.type = INIT_COPY_INFO
      404         then if unspec (oldp -> link_init_copy_info) =
      405 	        unspec (newp -> link_init_copy_info)
      406 	     then return;
      407 	     else ;
      408       else if oldp -> link_init.type = INIT_LIST_TEMPLATE
      409         then if unspec (oldp -> link_init_list_template) =
      410 	        unspec (newp -> link_init_list_template)
      411 	     then return;
      412 	     else ;
      413       else return;
      414     end;
      415 
      416   /* at this point we know that the new and old templates are	*/
      417   /* different, so we have to either select one of them or create	*/
      418   /* a new combined template.					*/
      419 
      420   /* area initialization is incompatible with any other type of init	*/
      421 
      422   if oldp -> link_init.type ^= newp -> link_init.type
      423     then if oldp -> link_init.type = INIT_DEFINE_AREA |
      424 	    newp -> link_init.type = INIT_DEFINE_AREA
      425 	 then do;
      426 	   incompatible = true;
      427 	   return;
      428 	 end;
      429 
      430   /* determine if the size is different */
      431 
      432   if oldp -> link_init.n_words + extension > newp -> link_init.n_words
      433     then smaller = true;
      434   else if oldp -> link_init.n_words + extension < newp -> link_init.n_words
      435     then larger = true;
      436 
      437   /* determine whether we already have initialiation info */
      438 
      439   if oldp -> link_init.type = INIT_NO_INIT
      440     then have_old = false;
      441     else have_old = true;
      442 
      443   /* determine if the new one has init info */
      444 
      445   if newp -> link_init.type = INIT_NO_INIT
      446     then have_new = false;
      447     else have_new = true;
      448 
      449   /* apply rules for what we do with init infos */
      450 
      451   if larger
      452     then if have_new
      453 	 then if have_old
      454 	        then message, replace = true;
      455 	        else replace = true;
      456          else if have_old
      457 	 then extend = true;
      458          else replace = true;
      459   else if smaller
      460     then if have_new
      461 	 then if have_old
      462 	        then message = true;
      463 	        else replace, extend = true;
      464 	 else ;
      465   else if have_new
      466     then if have_old
      467 	 then message = true;
      468 	 else replace = true;
      469   else ;
      470 
      471   end compare_init;
      472 
      473 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      474 
      475 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      476 
      477 
  1     1 /****  START OF:	le_data.incl.pl1			 *  *  *  *  *  */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  1     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  1     6*     Originally written to define the structures used internally by le_.
  1     7*                                                   END HISTORY COMMENTS */
  1     8 
  1     9   /*** ****************************************************************/
  1    10   /***							*/
  1    11   /***	Name:	le_data					*/
  1    12   /***	Function:	This include file defines the data structures	*/
  1    13   /***		used internally by the linkage_editor subroutine.	*/
  1    14   /***							*/
  1    15   /*** ****************************************************************/
  1    16   
  1    17   /* error severity constants */
  1    18   
  1    19   dcl LE_WARNING		fixed bin static options (constant) init (1);
  1    20   dcl LE_ERROR		fixed bin static options (constant) init (2);
  1    21   dcl LE_FATAL_ERROR	fixed bin static options (constant) init (3);
  1    22   dcl LE_ABORT_ERROR	fixed bin static options (constant) init (4);
  1    23   
  1    24   /* section identifier constants */
  1    25   
  1    26   dcl Text		fixed bin (3) static options (constant)
  1    27 			init (0);
  1    28   dcl Linkage		fixed bin (3) static options (constant)
  1    29 			init (1);
  1    30   dcl Symbol		fixed bin (3) static options (constant)
  1    31 			init (2);
  1    32   dcl Definition		fixed bin (3) static options (constant)
  1    33 			init (3);
  1    34   dcl Static		fixed bin (3) static options (constant)
  1    35 			init (4);
  1    36   dcl System		fixed bin (3) static options (constant)
  1    37 			init (5);
  1    38   dcl Heap		fixed bin (3) static options (constant)
  1    39 			init (6);
  1    40   
  1    41   dcl section_nm		(0:6) char (16) static options (constant)
  1    42 			init ("text", "linkage", "symbol", "definition",
  1    43 			"static", "system", "heap");
  1    44   
  1    45   /* link type constants */
  1    46   
  1    47   dcl Self_Base		fixed bin (3) static options (constant)
  1    48 			init (1);
  1    49   dcl Refname_Base		fixed bin (3) static options (constant)
  1    50 			init (3);
  1    51   dcl Refname_Offsetname	fixed bin (3) static options (constant)
  1    52 			init (4);
  1    53   dcl Self_Offsetname	fixed bin (3) static options (constant)
  1    54 			init (5);
  1    55   
  1    56   /* backpatch type constants */
  1    57   
  1    58   dcl Patch_Link		fixed bin static options (constant) init (1);
  1    59   dcl Patch_Init		fixed bin static options (constant) init (2);
  1    60   dcl Patch_Symbol_Ref	fixed bin static options (constant) init (3);
  1    61   dcl Patch_Self_Init	fixed bin static options (constant) init (4);
  1    62   
  1    63   /*** ****************************************************************/
  1    64   /***							*/
  1    65   /***	Name:	le_components				*/
  1    66   /***	Function:	the component table is used to keep information	*/
  1    67   /***		about the input components being used and their	*/
  1    68   /***		disposition in output components.		*/
  1    69   /***							*/
  1    70   /*** ****************************************************************/
  1    71   
  1    72   dcl 01 le_components	aligned based,
  1    73        02 header		aligned,
  1    74         03 flags		aligned,
  1    75          04 separate_static	bit (1) unaligned,
  1    76          04 perprocess_static	bit (1) unaligned,
  1    77          04 mbz		bit (34) unaligned,
  1    78         03 n_components	fixed bin,
  1    79        02 comp		(0 refer (le_components.n_components))
  1    80 			like le_comp;
  1    81   
  1    82   /*** ****************************************************************/
  1    83   /***							*/
  1    84   /***	Name:	le_comp					*/
  1    85   /***	Function:	this is a single component table entry.		*/
  1    86   /***							*/
  1    87   /*** ****************************************************************/
  1    88   
  1    89   dcl 01 le_comp		aligned based,
  1    90        02 segp		ptr,
  1    91        02 bc		fixed bin (24),
  1    92        02 uid		bit (36) aligned,
  1    93        02 dtcm		fixed bin (71),
  1    94        02 name		char (32) varying,
  1    95        02 path		char (194) varying,
  1    96        02 compiler		char (8),
  1    97        02 target		fixed bin,
  1    98        02 flags		aligned,
  1    99         03 library		bit (1) unaligned,
  1   100         03 include		bit (1) unaligned,
  1   101         03 delete_table	bit (1) unaligned,
  1   102         03 separate_static	bit (1) unaligned,
  1   103         03 io_table		bit (1) unaligned,
  1   104         03 unique_path	bit (1) unaligned,
  1   105         03 mbz		bit (30) unaligned,
  1   106        02 tables		aligned,
  1   107         03 lesp		ptr,
  1   108         03 ledp		ptr,
  1   109         03 lelp		ptr,
  1   110        02 orig		aligned,
  1   111         03 textp		ptr,
  1   112         03 defnp		ptr,
  1   113         03 linkp		ptr,
  1   114         03 statp		ptr,
  1   115         03 symbp		ptr,
  1   116         03 rel_textp	ptr,
  1   117         03 rel_symbp	ptr,
  1   118         03 rel_linkp	ptr,
  1   119         03 textl		fixed bin (18) unsigned unaligned,
  1   120         03 defnl		fixed bin (18) unsigned unaligned,
  1   121         03 linkl		fixed bin (18) unsigned unaligned,
  1   122         03 statl		fixed bin (18) unsigned unaligned,
  1   123         03 symbl		fixed bin (18) unsigned unaligned,
  1   124         03 symbl_no_rel	fixed bin (18) unsigned unaligned,
  1   125         03 symbl_no_table	fixed bin (18) unsigned unaligned,
  1   126         03 n_symb_blocks	fixed bin (18) unsigned unaligned,
  1   127         03 text_boundary	fixed bin (9) unsigned unaligned,
  1   128         03 static_boundary	fixed bin (9) unsigned unaligned,
  1   129         03 next_comp	fixed bin (18) unsigned unaligned,
  1   130        02 new		aligned,
  1   131         03 rel_text		fixed bin (18) unsigned unaligned,
  1   132         03 rel_symb		fixed bin (18) unsigned unaligned,
  1   133         03 rel_stat		fixed bin (18) unsigned unaligned,
  1   134         03 text_pad		fixed bin (18) unsigned unaligned,
  1   135         03 static_pad	fixed bin (18) unsigned unaligned,
  1   136         03 symbol_pad	fixed bin (18) unsigned unaligned;
  1   137   
  1   138   /*** ****************************************************************/
  1   139   /***							*/
  1   140   /***	Name:	le_segnames				*/
  1   141   /***	Function:	the segname table is used for two purposes:	*/
  1   142   /***		 - to determine the target components of links	*/
  1   143   /***		   being resolved internally.			*/
  1   144   /***		 - to determine the segname definitions to be	*/
  1   145   /***		   emited for definitions being retained.	*/
  1   146   /***							*/
  1   147   /*** ****************************************************************/
  1   148   
  1   149   dcl 01 le_segnames	aligned based,
  1   150        02 header		aligned,
  1   151         03 n_segnames	fixed bin,
  1   152        02 segname		(segname_count refer (le_segnames.n_segnames)),
  1   153         03 str		char (32) varying,
  1   154         03 relp		fixed bin (18) unsigned unaligned,
  1   155         03 pad		bit (18) unaligned;
  1   156   dcl segname_count		fixed bin automatic;
  1   157   
  1   158   /*** ****************************************************************/
  1   159   /***							*/
  1   160   /***	Name:	le_definitions				*/
  1   161   /***	Function:	the definition table contains the definitions	*/
  1   162   /***		from the input components and is used to resolve	*/
  1   163   /***		link targets, and regenerate definition entries	*/
  1   164   /***							*/
  1   165   /*** ****************************************************************/
  1   166   
  1   167   dcl 01 le_definitions	aligned based,
  1   168        02 header		aligned,
  1   169         03 n_defs		fixed bin,
  1   170         03 pad		bit (36),
  1   171        02 def		(def_count refer (le_definitions.n_defs))
  1   172 			like le_definition;
  1   173   dcl def_count		fixed bin automatic;
  1   174   
  1   175   dcl 01 le_definition	aligned based,
  1   176        02 str		char (256) varying,
  1   177        02 type		fixed bin (18) unsigned unaligned,
  1   178        02 relp		fixed bin (18) unsigned unaligned,
  1   179        02 offset		fixed bin (18) unsigned unaligned,
  1   180        02 new_offset	fixed bin (18) unsigned unaligned,
  1   181        02 flags		aligned,
  1   182         03 force_retain	bit (1) unaligned,
  1   183         03 entrypoint	bit (1) unaligned,
  1   184         03 ignore		bit (1) unaligned,
  1   185         03 referenced	bit (1) unaligned,
  1   186         03 no_link		bit (1) unaligned,
  1   187         03 retain		bit (1) unaligned,
  1   188         03 delete		bit (1) unaligned,
  1   189         03                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   NË    Frankepolz                         Ä   Ràfî~Xbƒ                        ˙≤@B™ƒ                        Frankepolz                              STDSPPT         Å      _         QuÃ±‘ã  Rìµ{(Â  Râ(´`cnone   VT100                                                                     QaúD˜                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        3 textl		fixed bin (18) unsigned unaligned,
  1   276         03 defnl		fixed bin (18) unsigned unaligned,
  1   277         03 linkl		fixed bin (18) unsigned unaligned,
  1   278         03 symbl		fixed bin (18) unsigned unaligned,
  1   279         03 statl		fixed bin (18) unsigned unaligned,
  1   280         03 mbz2		bit (18) unaligned;
  1   281   
  1   282   /*** ****************************************************************/
  1   283   /***							*/
  1   284   /***	Name:	le_patches				*/
  1   285   /***	Function:	This table contains the list of backpatches to be	*/
  1   286   /***		performed when the rest of the object creation is	*/
  1   287   /***		complete. Since le_backpatch_ is the only routine	*/
  1   288   /***		concerned with this,  it is maintained completely	*/
  1   289   /***		internal to le_backpatch_.			*/
  1   290   /***							*/
  1   291   /*** ****************************************************************/
  1   292   
  1   293   dcl 01 le_patches		aligned based,
  1   294        02 header		aligned,
  1   295         03 n_patches	fixed bin,
  1   296        02 patch		(0 refer (le_patches.n_patches)) like le_patch;
  1   297        
  1   298   dcl 01 le_patch		aligned based,
  1   299        02 type		fixed bin,
  1   300        02 comp		fixed bin,
  1   301        02 relp		fixed bin (18) unsigned,
  1   302        02 target		fixed bin,
  1   303        02 index		fixed bin;
  1   304   
  1   305 /****  END OF:	le_data.incl.pl1			 *  *  *  *  *  */
      478 
  2     1 /* Begin include file definition_dcls.incl.pl1 BIM 1981 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  2     6*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  2     7*     Modified to add indirect bit to definition flags, add msf_map_relp to the
  2     8*     definition header, declare the msf_map, and add structures and constants
  2     9*     for deferred initialization.
  2    10*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420),
  2    11*     audit(86-08-05,Schroth), install(86-11-20,MR12.0-1222):
  2    12*     added the structures for pointer initialization. pointer_init_template.
  2    13*     changed list_template_entry
  2    14*                                                   END HISTORY COMMENTS */
  2    15 
  2    16 
  2    17 /* Modified:  */
  2    18 /*   13 Dec 1982 by Lee A. Newcomb to put definition_header.hash_table_relp */
  2    19 /*	after unused half-word instead of before it. */
  2    20 /*   1 March 1983 by M. Weaver to add list template init type */
  2    21 
  2    22 /* format: style3,idind25 */
  2    23 /* everything for the definition section */
  2    24 
  2    25 declare	(
  2    26 	CLASS_TEXT	     init (0),		/* text section definition */
  2    27 	CLASS_LINKAGE	     init (1),		/* linkage section definition */
  2    28 	CLASS_SYMBOL	     init (2),		/* symbol section definition */
  2    29 	CLASS_SEGNAME	     init (3),		/* segment name definition */
  2    30 	CLASS_STATIC	     init (4),		/* static section definition */
  2    31 	CLASS_SYSTEM	     init (5),		/* valid only in self links, not def class */
  2    32 	CLASS_HEAP	     init (6)		/* valid only in self links, not def class */
  2    33 	)		     fixed bin (3) unsigned internal static options (constant);
  2    34 
  2    35 declare	CLASS_NAMES	     (0:6) character (12) internal static options (constant)
  2    36 			     init ("text", "linkage", "symbol", "segname", "static", "system", "heap");
  2    37 
  2    38 declare	SYMBOLIC_SECTION_NAMES   (0:6) character (8)
  2    39 			     init ("*text", "*link", "*symbol", *, "*static", "*system", "*heap") internal static
  2    40 			     options (constant);
  2    41 
  2    42 declare	1 definition_flags	     unaligned based,
  2    43 	  2 new		     bit (1),		/* should be "1"b */
  2    44 	  2 ignore	     bit (1),		/* cannot snap link to this */
  2    45 	  2 entry		     bit (1),		/* can tra here */
  2    46 	  2 retain	     bit (1),		/* binder respects this */
  2    47 	  2 argcount	     bit (1),		/* OBSOLETE */
  2    48 	  2 descriptors	     bit (1),		/* OBSOLETE */
  2    49 	  2 indirect	     bit (1),		/* target is a pointer to actual target */
  2    50 	  2 unused	     bit (8);		/* Must be zero */
  2    51 
  2    52 
  2    53 
  2    54 
  2    55 /* Header of the definition section */
  2    56 
  2    57 declare	def_header_ptr	     pointer;
  2    58 declare	1 definition_header	     aligned based (def_header_ptr),
  2    59 	  2 def_list_relp	     fixed bin (18) unsigned unaligned,
  2    60 						/* first definition, reloc def18 */
  2    61 	  2 msf_map_relp	     fixed bin (18) unsigned unaligned,
  2    62 						/* msf_map if any, or 0 if none.  reloc def18 unless none */
  2    63 	  2 hash_table_relp	     fixed bin (18) unsigned unaligned,
  2    64 						/* def hash table, if any, or 0 if none. reloc def18 unless none */
  2    65 	  2 flags		     unaligned like definition_flags;
  2    66 						/* both new and ignore must be "1"b here */
  2    67 
  2    68 /* A non class=3 definition. See segname_definition below for class=3 */
  2    69 
  2    70 
  2    71 declare	def_ptr		     pointer;
  2    72 declare	1 definition	     aligned based (def_ptr),
  2    73 	  2 forward_relp	     unal fixed bin (18) unsigned,
  2    74 						/* offset of next def */
  2    75 	  2 backward_relp	     unal fixed bin (18) unsigned,
  2    76 						/* offset of previous def */
  2    77 	  2 thing_relp	     unal fixed bin (18) unsigned,
  2    78 						/* offset in section specified by class of thing this defines */
  2    79 	  2 flags		     unaligned like definition_flags,
  2    80 	  2 class		     unal fixed bin (3) unsigned,
  2    81 						/* Type of definition */
  2    82 	  2 name_relp	     unal fixed bin (18) unsigned,
  2    83 						/* offset of ACC for symbol */
  2    84 	  2 segname_relp	     unal fixed bin (18) unsigned;
  2    85 						/* offset of segname def to which this belongs */
  2    86 
  2    87 /* Class=3, segname definition */
  2    88 
  2    89 declare	segname_ptr	     pointer;
  2    90 declare	1 segname_definition     aligned based (segname_ptr),
  2    91 	  2 forward_relp	     unal fixed bin (18) unsigned,
  2    92 						/* offset of next def */
  2    93 	  2 backward_relp	     unal fixed bin (18) unsigned,
  2    94 						/* offset of previous def */
  2    95 	  2 next_segname_relp    unal fixed bin (18) unsigned,
  2    96 						/* offset of next segname def */
  2    97 	  2 flags		     unaligned like definition_flags,
  2    98 	  2 class		     unal fixed bin (3) unsigned,
  2    99 						/* 3 for segname */
  2   100 	  2 name_relp	     unal fixed bin (18) unsigned,
  2   101 						/* offset of ACC for symbol */
  2   102 	  2 first_relp	     unal fixed bin (18) unsigned;
  2   103 						/* see following : */
  2   104 
  2   105 /* Definition blocks are chained off of segname definitions.
  2   106*   segname_definition.first_relp is one of three things:
  2   107*    (1) the def section offset of the first ordinary (class^=3) definition
  2   108*      belonging to this segname block. In the case where there are more than
  2   109*      one segname's on a block, all their first_relp will point
  2   110*      to the same place.
  2   111*
  2   112*    (2) if there are no ordinary definitions associated with this segname,
  2   113*      then it is the def section offset of the next segname. 
  2   114*
  2   115*    (3) if there are no ordinary definitions in the block, and it
  2   116*      is the last block, then it points to a word containing 0.
  2   117*
  2   118* Thus the end of a list of synonym segnames can be detected by forward_relp
  2   119*   pointing to a class=3 definition whose first_relp is not the same as
  2   120*   the current definitions first_relp.
  2   121**/
  2   122 
  2   123 /* All the definitions are linked through the forward and
  2   124*   backward thread variables. The end of the chain can is indicated
  2   125*   by forward pointing to a zero word. */
  2   126 
  2   127 
  2   128 declare	exp_ptr		     pointer;
  2   129 declare	1 exp_word	     based (exp_ptr) aligned, /* expression word in link definition */
  2   130 	  2 type_relp	     fixed bin (18) unsigned unal,
  2   131 						/* pointer (rel to defs) of type pair structure */
  2   132 	  2 expression	     fixed bin (17) unal;	/* constant expression to be added in when snapping link */
  2   133 
  2   134 declare	(
  2   135 	LINK_SELF_BASE	     init (1),		/* *section|0+expression,modifier */
  2   136 						/* which section determined by segname_relp */
  2   137 	LINK_OBSOLETE_2	     init (2),		/* not used */
  2   138 	LINK_REFNAME_BASE	     init (3),		/* refname|0+expression,modifier */
  2   139 	LINK_REFNAME_OFFSETNAME  init (4),		/* refname|offsetname+expression,modifier */
  2   140 	LINK_SELF_OFFSETNAME     init (5),		/* *section|offsetname+expression,modifier */
  2   141 	LINK_CREATE_IF_NOT_FOUND init (6),		/* OBSOLETE: like LINK_REFNAME_OFFSETNAME except that it will create instead of taking linkage_error */
  2   142 	SECTION_TEXT	     init (0),		/* *text */
  2   143 	SECTION_LINK	     init (1),		/* *link */
  2   144 	SECTION_SYMBOL	     init (2),		/* *symbol */
  2   145 	SECTION_UNUSED	     init (3),		/* reserved */
  2   146 	SECTION_STATIC	     init (4),		/* *static */
  2   147 	SECTION_SYSTEM	     init (5),		/* *system */
  2   148 	SECTION_HEAP	     init (6)		/* *heap */
  2   149 	)		     fixed bin (18) unsigned unaligned internal static options (constant);
  2   150 
  2   151 /* use CLASS_NAMES for section names */
  2   152 
  2   153 declare	LINK_TYPE_NAMES	     (1:6)
  2   154 			     init ("absolute in section", "unused", "absolute off of refname",
  2   155 			     "symbolic off of refname", "symbolic in section", "symbolic off of refname; create")
  2   156 			     character (32) varying internal static options (constant);
  2   157 
  2   158 
  2   159 declare	type_ptr		     pointer;
  2   160 declare	1 type_pair	     based (type_ptr) aligned,/* type pair in link definition */
  2   161 	  2 type		     fixed bin (18) unsigned unal,
  2   162 						/* see above */
  2   163 	  2 trap_relp	     fixed bin (18) unsigned unal,
  2   164 						/* pointer (rel to defs) to the trap word */
  2   165 						/* unless LINK_SELF_OFFSETNAME off of *system or create link */
  2   166 	  2 segname_relp	     fixed bin (18) unsigned unal,
  2   167 						/* pointer (rel to defs) to ACC reference name for segment referenced, 
  2   168* /*or section code for SELF links */
  2   169 	  2 offsetname_relp	     fixed bin (18) unsigned unal;
  2   170 						/* for OFFSETNAME links, ACC string of name of location. */
  2   171 						/* for others, must be ZERO */
  2   172 
  2   173 
  2   174 /* Link Trap Pair */
  2   175 
  2   176 declare	link_trap_ptr	     pointer;
  2   177 declare	1 link_trap_pair	     aligned based (link_trap_ptr),
  2   178 	  2 call_relp	     fixed bin (18) unsigned unaligned,
  2   179 						/* LINK18, link to thing to call */
  2   180 	  2 info_relp	     fixed bin (18) unsigned unaligned;
  2   181 						/* LINK18, link to argument list */
  2   182 
  2   183 
  2   184 /* initialization info for *system or *heap link */
  2   185 
  2   186 
  2   187 /* NOTE --------------------------------------------------
  2   188*   the following structures defining initialization information are also
  2   189*   defined in fortran_storage.incl.pl1  system_link_init_info.incl.pl1
  2   190*   and should be kept equivalent
  2   191*   -------------------------------------------------------
  2   192**/
  2   193 
  2   194 declare	(
  2   195 	INIT_NO_INIT	     init (0),
  2   196 	INIT_COPY_INFO	     init (3),
  2   197 	INIT_DEFINE_AREA	     init (4),
  2   198 	INIT_LIST_TEMPLATE	     init (5),
  2   199 	INIT_DEFERRED	     init (6)
  2   200 	)		     fixed bin internal static options (constant);
  2   201 
  2   202 /* for type = 0 or 4 */
  2   203 
  2   204 declare	link_init_ptr	     pointer;
  2   205 declare	1 link_init	     aligned based (link_init_ptr),
  2   206 	  2 n_words	     fixed bin (35),	/* number to invent */
  2   207 	  2 type		     fixed bin;		/* see types above */
  2   208 
  2   209 /* for type=3, there is data to copy */
  2   210 
  2   211 declare	1 link_init_copy_info    aligned based (link_init_ptr),
  2   212 	  2 header	     aligned like link_init,
  2   213 	  2 initial_data	     (link_init_n_words refer (link_init_copy_info.header.n_words)) bit (36) aligned;
  2   214 
  2   215 declare	link_init_n_words	     fixed bin;
  2   216 
  2   217 /* for type = 5, there is a list template to copy */
  2   218 
  2   219 declare	1 link_init_list_template
  2   220 			     aligned based (link_init_ptr),
  2   221 	  2 header	     aligned like link_init,
  2   222 	  2 pad		     bit (18) unaligned,
  2   223 	  2 n_words_in_list	     fixed bin (18) unsigned unaligned,
  2   224 	  2 template	     (link_init_n_words_in_list refer (link_init_list_template.n_words_in_list));
  2   225 
  2   226 declare	link_init_n_words_in_list
  2   227 			     fixed bin;
  2   228 
  2   229 /* A list template consists of a series of entries with the following
  2   230*   description, concatenated together.  n_bits and datum are bit items,
  2   231*   to permit a wide range of inputs.
  2   232*
  2   233*   1.  A 'repeat' of '0' signifies skipping of 'n_bits' bits.
  2   234*   2.  A 'n_bits' of '0' signifies the last item of the list.
  2   235*
  2   236*   COMMON, VLA's, and LA's are presumed to start at the base pointer
  2   237*   of their particular storage section. */
  2   238 
  2   239 declare	1 list_template_entry    aligned based,
  2   240 	  2 n_bits	     fixed bin (35) aligned,	/* size of datum */
  2   241 	  2 mbz		     bit (3) unaligned,	/* future expansion */
  2   242 	  2 init_type	     fixed bin (3) unsigned unaligned, /* 0 normal init, 1 ptr init, 2 packed ptr init */
  2   243 	  2 repeat	     fixed bin (30) unsigned unaligned,
  2   244 						/* number of times to repeat datum */
  2   245 	  2 datum		     bit (link_init_n_bits_in_datum refer (list_template_entry.n_bits));
  2   246 
  2   247 
  2   248 /* the pointer_init_template represents the initialization information
  2   249*   for ITS and packed pointers.  Both pointer types require the entire
  2   250*   72 bit structure.
  2   251**/
  2   252 
  2   253 dcl       1 pointer_init_template  based,
  2   254 	  2 ptr_type	     fixed bin (18) unsigned unaligned,  /* 0 text section, 1 linkage section, 2 static section */
  2   255 	  2 section_offset	     fixed bin (18) unsigned unaligned,  /* offset to item in specified section */
  2   256 	  2 word_offset	     fixed bin (18) unsigned unaligned,  /* offset from section item to target in words */
  2   257 	  2 mbz		     bit (12) unaligned,
  2   258 	  2 bit_offset	     fixed bin (6) unsigned unaligned;   /* offset from section item|word offset to target in bits */
  2   259 
  2   260 
  2   261 declare	link_init_n_bits_in_datum
  2   262 			     fixed bin (35);
  2   263 
  2   264 /* for type = 6, the init_info resides in another MSF component */
  2   265 /* target_relp is a linkage section offset to a partial link to */
  2   266 /* the base of the linkage section of the component containing  */
  2   267 /* the actual init_info. link_relp is the offset of the actual  */
  2   268 /* link within that linkage section.			    */
  2   269 
  2   270 declare	1 link_init_deferred     aligned based (link_init_ptr),
  2   271 	  2 header	     aligned like link_init,
  2   272 	  2 target_relp	     fixed bin (18) unsigned unaligned,
  2   273 	  2 link_relp	     fixed bin (18) unsigned unaligned;
  2   274 
  2   275 /* Definition section hash table */
  2   276 
  2   277 declare	def_ht_ptr	     pointer;
  2   278 declare	1 definition_ht	     aligned based (def_ht_ptr),
  2   279 	  2 n_entries	     fixed bin,
  2   280 	  2 table		     (def_ht_n_entries refer (definition_ht.n_entries)) aligned,
  2   281 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  2   282 	    3 unused	     bit (18) unaligned;
  2   283 
  2   284 declare	def_ht_n_entries	     fixed bin;
  2   285 
  2   286 
  2   287 /* Component name ht */
  2   288 declare	comp_ht_ptr	     pointer;
  2   289 declare	1 component_ht	     aligned based (comp_ht_ptr),
  2   290 	  2 n_entries	     fixed bin,
  2   291 	  2 table		     (comp_ht_n_entries refer (component_ht.n_entries)) aligned,
  2   292 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  2   293 						/* hashed segname */
  2   294 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  2   295 						/* first segname def of block containing def_relp */
  2   296 
  2   297 declare	comp_ht_n_entries	     fixed bin;
  2   298 
  2   299 /* Duplicate name table */
  2   300 
  2   301 declare	dup_table_ptr	     pointer;
  2   302 declare	1 duplicate_table	     aligned based (dup_table_ptr),
  2   303 	  2 mbz		     bit (18) unaligned,	/* to tell it from a definition */
  2   304 	  2 n_names	     fixed bin (18) unsigned unaligned,
  2   305 						/* n in table */
  2   306 	  2 table		     (dup_table_n_names refer (duplicate_table.n_names)) aligned,
  2   307 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  2   308 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  2   309 
  2   310 declare	dup_table_n_names	     fixed bin;
  2   311 
  2   312 /* The msf_map is found in the definition section of an	*/
  2   313 /* object MSF component.  It is used by the linker to	*/
  2   314 /* determine whether a segment is a component of an object	*/
  2   315 /* MSF or a standard single-segment object.		*/
  2   316   
  2   317   dcl msf_map_ptr		ptr;
  2   318   dcl 01 msf_map		aligned based (msf_map_ptr),
  2   319        02 version		char (8),
  2   320        02 component_count	fixed bin (15) unsigned,
  2   321        02 my_component	fixed bin (15) unsigned;
  2   322   
  2   323   dcl msf_map_version_1	char (8) static options (constant)
  2   324 			     init ("msfmp1.0");
  2   325   
  2   326 declare	acc_string_ptr	     pointer;
  2   327 declare	1 acc_string	     aligned based (acc_string_ptr),
  2   328 	  2 count		     fixed bin (9) unsigned unaligned,
  2   329 	  2 string	     character (max (3, acc_string_length) refer (acc_string.count)) unaligned,
  2   330 	  2 mbz		     bit (0) aligned;	/* this causes the statement */
  2   331 						/* unspec (acc_string) = ""b to zero out */
  2   332 						/* the last word, if the string is not of length 0mod4 */
  2   333 
  2   334 declare	acc_string_length	     fixed bin (21);
  2   335 
  2   336 
  2   337 /* end include file definitions_dcls.incl.pl1 */
      479 
  3     1 /* BEGIN INCLUDE FILE object_link_dcls.incl.pl1 BIM 1981 from linkdcl */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  3     6*     audit(86-11-18,Schroth), install(86-11-20,MR12.0-1222):
  3     7*     Modified to add partial_link structure for an object MSF partially snapped
  3     8*     link.
  3     9*  2) change(86-11-13,DGHowe), approve(86-11-13,MCR7391), audit(86-11-13,Zwick),
  3    10*     install(86-11-20,MR12.0-1222):
  3    11*     Added a declaration of FAULT_TAG_1, FAULT_TAG_2 and FAULT_TAG_3.
  3    12*                                                   END HISTORY COMMENTS */
  3    13 
  3    14 
  3    15 /* format: style3 */
  3    16 /* everything you ever wanted in a linkage section */
  3    17 
  3    18 /*
  3    19* Last Modified (Date and Reason):
  3    20*  15 Nov 1971 by C Garman 
  3    21*   6/75 by M.Weaver to add virgin_linkage_header declaration
  3    22*   6/75 by S.Webber to comment existing structures better
  3    23*   9/77 by M. Weaver to add run_depth to link
  3    24*   7/81 by B. Margulies for firstref structure, unsigned fixed bins.
  3    25*   3/83 by M. Weaver to add flags overlaying def_ptr
  3    26**/
  3    27 
  3    28 declare	1 object_link	based aligned,		/* link pair in linkage section */
  3    29 	  2 header_relp	fixed bin (17) unal,	/* rel pointer to beginning of linkage, always negative */
  3    30 	  2 ringno	fixed bin (3) unsigned unal,	/* MBZ */
  3    31 	  2 mbz		bit (6) unal,
  3    32 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  3    33 	  2 tag		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  3    34 	  2 expression_relp fixed bin (18) unsigned unal, /* pointer (rel to defs) of expression word */
  3    35 	  2 mbz2		bit (12) unal,
  3    36 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  3    37 
  3    38 declare	1 partial_link	based aligned,		/* partially snapped link */
  3    39 	  2 type		fixed bin (3) unsigned unal,	/* target section of link */
  3    40 	  2 component	fixed bin (15) unsigned unal,	/* target component index */
  3    41 	  2 mbz1		bit (12) unal,
  3    42 	  2 tag		bit (6) unal,		/* fault tag 3 47(8), ITS 43(8) if snapped */
  3    43 	  
  3    44 	  2 offset	fixed bin (18) unsigned unal,	/* word offset of link */
  3    45 	  2 mbz2		bit (3) unal,
  3    46 	  2 bit_offset	fixed bin (6) unsigned unal,	/* bit offset (in practice, always 0) */
  3    47 	  2 mbz3		bit (3) unal,
  3    48 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  3    49 
  3    50 declare	1 linkage_header	based aligned,		/* linkage block header */
  3    51 	  2 def_ptr	ptr,			/* pointer to definition section */
  3    52 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  3    53 	  2 original_linkage_ptr
  3    54 			ptr unal,			/* pointer to linkage section in object segment */
  3    55 	  2 unused	bit (72),
  3    56 	  2 stats,
  3    57 	    3 begin_links	fixed bin (18) unsigned unal, /* offset (rel to this section) of first link */
  3    58 	    3 block_length	fixed bin (18) unsigned unal, /* number of words in this linkage section */
  3    59 	    3 segment_number
  3    60 			fixed bin (18) unsigned unal, /* text segment number associated with this section */
  3    61 	    3 static_length fixed bin (18) unsigned unal; /* number of words of static for this segment */
  3    62 
  3    63 declare	1 linkage_header_flags
  3    64 			aligned based,		/* overlay of def_ptr for flags */
  3    65 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  3    66 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  3    67 	  2 perprocess_static
  3    68 			bit (1) unaligned,		/* 1 copy of static section is shared among all tasks/run units */
  3    69 	  2 pad2		bit (6) unaligned;
  3    70 
  3    71 declare	1 virgin_linkage_header
  3    72 			aligned based,		/* template for linkage header in object segment */
  3    73 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  3    74 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  3    75 	  2 def_offset	fixed bin (18) unsigned unaligned,
  3    76 						/* offset of definition section */
  3    77 	  2 first_ref_relp	fixed bin (18) unsigned unaligned,
  3    78 						/* offset of trap-at-first-reference offset array */
  3    79 	  2 filled_in_later bit (144),
  3    80 	  2 link_begin	fixed bin (18) unsigned unaligned,
  3    81 						/* offset of first link */
  3    82 	  2 linkage_section_lng
  3    83 			fixed bin (18) unsigned unaligned,
  3    84 						/* length of linkage section */
  3    85 	  2 segno_pad	fixed bin (18) unsigned unaligned,
  3    86 						/* will be segment number of copied linkage */
  3    87 	  2 static_length	fixed bin (18) unsigned unaligned;
  3    88 						/* length of static section */
  3    89 
  3    90 declare	1 fr_traps	based aligned,		/* First Reference Trap Procedures */
  3    91 	  2 decl_vers	fixed bin,		/* version of this struc, value=1, ABS reloc */
  3    92 	  2 n_traps	fixed bin,		/* number of traps on this segment, ABS */
  3    93 	  2 trap_array	(n_fr_traps refer (fr_traps.n_traps)) aligned,
  3    94 	    3 call_relp	fixed bin (18) unsigned unaligned,
  3    95 						/* LINK18, offset of link defining procedure to call */
  3    96 	    3 info_relp	fixed bin (18) unsigned unaligned;
  3    97 						/* LINK18, offser of link defining argument list for trap proc */
  3    98 
  3    99 declare	FR_TRAPS_VERSION_1	init (1) fixed bin internal static options (constant);
  3   100 declare   FAULT_TAG_1	bit(6) unaligned init ("40"b3) static options (constant);
  3   101 declare   FAULT_TAG_2	bit(6) unaligned init ("46"b3) static options (constant);
  3   102 declare   FAULT_TAG_3	bit(6) unaligned init ("47"b3) static options (constant);
  3   103 
  3   104 /* END INCLUDE FILE object_link_dcls.incl.pl1 */
      480 
      481 
      482   end le_combine_init_info_;
      483 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/05/87  1304.0  le_combine_init_info_.pl1         >spec>install>1256>le_combine_init_info_.pl1
478          1    12/10/86  1316.8  le_data.incl.pl1                  >ldd>include>le_data.incl.pl1
479          2    11/24/86  1226.9  definition_dcls.incl.pl1          >ldd>include>definition_dcls.incl.pl1
480          3    11/24/86  1226.9  object_link_dcls.incl.pl1         >ldd>include>object_link_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CLASS_HEAP                             constant        fixed bin(3,0)           initial unsigned dcl 2-25 ref 131
CLASS_SYSTEM                           constant        fixed bin(3,0)           initial unsigned dcl 2-25 ref 131 147 192 258
INIT_COPY_INFO                         constant        fixed bin(17,0)          initial dcl 2-194 ref 403
INIT_DEFINE_AREA                       constant        fixed bin(17,0)          initial dcl 2-194 ref 422 422
INIT_LIST_TEMPLATE                     constant        fixed bin(17,0)          initial dcl 2-194 ref 408
INIT_NO_INIT                           constant        fixed bin(17,0)          initial dcl 2-194 ref 439 445
LE_FATAL_ERROR                  000015 constant        fixed bin(17,0)          initial dcl 1-21 set ref 192*
LE_WARNING                      000016 constant        fixed bin(17,0)          initial dcl 1-19 set ref 258*
LINK_SELF_OFFSETNAME                   constant        fixed bin(18,0)          initial unsigned unaligned dcl 2-134 ref 131 172
None                                   constant        fixed bin(17,0)          initial dcl 41 ref 131 172 279 306
c                               000100 automatic       fixed bin(17,0)          dcl 78 set ref 114* 118 123 143 147 157 167 270*
chase_c                         000101 automatic       fixed bin(17,0)          dcl 79 set ref 270* 281 289 309*
chase_l                         000102 automatic       fixed bin(17,0)          dcl 80 set ref 271* 279 283 284 286 287 296 297 305
                                                                                  306 308*
class                     3(06)        based           fixed bin(6,0)           array level 3 in structure "lel" packed unsigned
                                                                                  unaligned dcl 63 in procedure
                                                                                  "le_combine_init_info_" ref 131 131 147 172 192
                                                                                  258
class                     3(06)        based           fixed bin(6,0)           array level 3 in structure "tlel" packed unsigned
                                                                                  unaligned dcl 72 in procedure
                                                                                  "le_combine_init_info_" ref 172
comp                      2            based           structure                array level 2 dcl 60
count                                  based           fixed bin(9,0)           level 2 in structure "new_name" packed unsigned
                                                                                  unaligned dcl 69 in procedure
                                                                                  "le_combine_init_info_" ref 179 179
count                                  based           fixed bin(9,0)           level 2 in structure "name" packed unsigned
                                                                                  unaligned dcl 66 in procedure
                                                                                  "le_combine_init_info_" ref 147 147 179 179 192
                                                                                  192 258 258
definition_flags                       based           structure                level 1 packed unaligned dcl 2-42
extend                          000103 automatic       bit(1)                   unaligned dcl 81 in procedure
                                                                                  "le_combine_init_info_" set ref 185* 229
extend                                 parameter       bit(1)                   unaligned dcl 375 in procedure "compare_init" set
                                                                                  ref 325 389* 456* 463*
extension                       000104 automatic       fixed bin(35,0)          dcl 82 in procedure "le_combine_init_info_" set ref
                                                                                  145* 185* 224* 239* 297
extension                 6(18)        based           fixed bin(18,0)          array level 3 in structure "tlel" packed unsigned
                                                                                  unaligned dcl 72 in procedure
                                                                                  "le_combine_init_info_" set ref 297* 306*
extension                              parameter       fixed bin(35,0)          dcl 372 in procedure "compare_init" ref 325 390 399
                                                                                  432 434
false                                  constant        bit(1)                   initial unaligned dcl 40 ref 139 389 395 439 445
flags                   106            based           structure                array level 3 dcl 60
have_new                        000154 automatic       bit(1)                   unaligned dcl 382 set ref 395* 445* 447* 451 459 465
have_old                        000155 automatic       bit(1)                   unaligned dcl 383 set ref 395* 439* 441* 451 456 459
                                                                                  465
header                                 based           structure                level 2 in structure "lec" dcl 60 in procedure
                                                                                  "le_combine_init_info_"
header                                 based           structure                level 2 in structure "link_init_copy_info" dcl 2-211
                                                                                  in procedure "le_combine_init_info_"
header                                 based           structure                level 2 in structure "le_links" dcl 1-225
                                                                                  in procedure "le_combine_init_info_"
header                                 based           structure                level 2 in structure "le_components" dcl 1-72
                                                                                  in procedure "le_combine_init_info_"
header                                 based           structure                level 2 in structure "lel" dcl 63 in procedure
                                                                                  "le_combine_init_info_"
header                                 based           structure                level 2 in structure "tlel" dcl 72 in procedure
                                                                                  "le_combine_init_info_"
include                 106(01)        based           bit(1)                   array level 4 packed unaligned dcl 60 ref 118 158
incompatible                    000105 automatic       bit(1)                   unaligned dcl 83 in procedure
                                                                                  "le_combine_init_info_" set ref 185* 192
incompatible                           parameter       bit(1)                   unaligned dcl 377 in procedure "compare_init" set
                                                                                  ref 325 389* 426*
initp                     7            based           pointer                  array level 3 in structure "lel" packed unaligned
                                                                                  dcl 63 in procedure "le_combine_init_info_" ref
                                                                                  142
initp                     7            based           pointer                  array level 3 in structure "tlel" packed unaligned
                                                                                  dcl 72 in procedure "le_combine_init_info_" set
                                                                                  ref 177 296* 305*
initp                           000106 automatic       pointer                  dcl 84 in procedure "le_combine_init_info_" set ref
                                                                                  142* 185* 223* 239 296
l                               000110 automatic       fixed bin(17,0)          dcl 85 set ref 127* 131 131 131 131 141 142 144 147
                                                                                  167 172 192 206 208 210 211 258 271*
larger                          000156 automatic       bit(1)                   unaligned dcl 384 set ref 395* 434* 451
le_comp                                based           structure                level 1 dcl 1-89
le_components                          based           structure                level 1 dcl 1-72
le_debug_                       000010 constant        entry                    external dcl 49 ref 110 147 218 235 316
le_definition                          based           structure                level 1 dcl 1-175
le_error_                       000012 constant        entry                    external dcl 50 ref 192 258
le_et_$incompatible_init        000014 external static fixed bin(35,0)          dcl 54 set ref 192*
le_et_$multiple_inits           000016 external static fixed bin(35,0)          dcl 56 set ref 258*
le_link                                based           structure                level 1 dcl 1-233
le_links                               based           structure                level 1 dcl 1-225
le_patch                               based           structure                level 1 dcl 1-298
lec                                    based           structure                level 1 dcl 60
lecp                                   parameter       pointer                  dcl 45 ref 23 114 118 123 147 157 158 163 218 258
                                                                                  268 281 289
lel                                    based           structure                level 1 dcl 63
lelp                            000112 automatic       pointer                  dcl 86 in procedure "le_combine_init_info_" set ref
                                                                                  123* 127 131 131 131 131 141 142 147 172 192 206
                                                                                  208 210 211 258
lelp                    114            based           pointer                  array level 4 in structure "lec" dcl 60 in procedure
                                                                                  "le_combine_init_info_" ref 123 163 281
link                      2            based           structure                array level 2 in structure "tlel" dcl 72
                                                                                  in procedure "le_combine_init_info_"
link                      2            based           structure                array level 2 in structure "lel" dcl 63 in procedure
                                                                                  "le_combine_init_info_"
link_init                              based           structure                level 1 dcl 2-205
link_init_copy_info                    based           structure                level 1 dcl 2-211 ref 403 403
link_init_list_template                based           structure                level 1 dcl 2-219 ref 408 408
max                                                    builtin function         dcl 106 ref 390
message                                parameter       bit(1)                   unaligned dcl 376 in procedure "compare_init" set
                                                                                  ref 325 389* 451* 459* 465*
message                         000114 automatic       bit(1)                   unaligned dcl 87 in procedure
                                                                                  "le_combine_init_info_" set ref 185* 247
min                             000115 automatic       fixed bin(17,0)          dcl 88 set ref 167* 169* 171
n_components              1            based           fixed bin(17,0)          level 3 dcl 60 ref 114 157
n_links                   1            based           fixed bin(17,0)          level 3 in structure "lel" dcl 63 in procedure
                                                                                  "le_combine_init_info_" ref 127
n_links                   1            based           fixed bin(17,0)          level 3 in structure "tlel" dcl 72 in procedure
                                                                                  "le_combine_init_info_" ref 171
n_words                                based           fixed bin(35,0)          level 2 in structure "link_init" dcl 2-205
                                                                                  in procedure "le_combine_init_info_" ref 224 239
                                                                                  390 390 399 399 432 432 434 434
n_words                                based           fixed bin(35,0)          level 3 in structure "link_init_copy_info" dcl 2-211
                                                                                  in procedure "le_combine_init_info_" ref 403 403
n_words_in_list           2(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 2-219 ref 408
                                                                                  408
name                                   based           structure                level 1 dcl 66 in procedure "le_combine_init_info_"
name                     10            based           varying char(32)         array level 3 in structure "lec" dcl 60 in procedure
                                                                                  "le_combine_init_info_" set ref 147* 218* 258*
namep                           000116 automatic       pointer                  dcl 89 set ref 141* 147 179 179 192 258
new_initp                       000120 automatic       pointer                  dcl 90 set ref 177* 185* 223 224
new_len                         000122 automatic       fixed bin(35,0)          dcl 91 in procedure "le_combine_init_info_" set ref
                                                                                  185* 224 235* 239
new_len                                parameter       fixed bin(35,0)          dcl 378 in procedure "compare_init" set ref 325 390*
new_name                               based           structure                level 1 dcl 69
new_namep                       000124 automatic       pointer                  dcl 92 set ref 176* 179 179
newp                                   parameter       pointer                  dcl 373 ref 325 390 399 399 403 408 422 422 432 434
                                                                                  445
next_c                          000126 automatic       fixed bin(17,0)          dcl 93 set ref 284* 309
next_l                          000127 automatic       fixed bin(17,0)          dcl 94 set ref 283* 308
null                                                   builtin function         dcl 107 ref 305
offsetp                  11            based           pointer                  array level 3 in structure "tlel" packed unaligned
                                                                                  dcl 72 in procedure "le_combine_init_info_" ref
                                                                                  176
offsetp                  11            based           pointer                  array level 3 in structure "lel" packed unaligned
                                                                                  dcl 63 in procedure "le_combine_init_info_" ref
                                                                                  141
oldp                                   parameter       pointer                  dcl 371 ref 325 390 399 399 403 403 408 408 422 422
                                                                                  432 434 439
owner                           000130 automatic       fixed bin(17,0)          dcl 95 set ref 268* 289
print_message                   000131 automatic       bit(1)                   unaligned dcl 96 set ref 139* 247* 247 258
replace                         000132 automatic       bit(1)                   unaligned dcl 97 in procedure
                                                                                  "le_combine_init_info_" set ref 185* 213
replace                                parameter       bit(1)                   unaligned dcl 374 in procedure "compare_init" set
                                                                                  ref 325 389* 451* 455* 458* 463* 468*
smaller                         000157 automatic       bit(1)                   unaligned dcl 385 set ref 395* 432* 459
string                    0(09)        based           char                     level 2 in structure "name" packed unaligned dcl 66
                                                                                  in procedure "le_combine_init_info_" set ref 147*
                                                                                  179 192* 258*
string                    0(09)        based           char                     level 2 in structure "new_name" packed unaligned
                                                                                  dcl 69 in procedure "le_combine_init_info_" ref
                                                                                  179
tables                  110            based           structure                array level 3 dcl 60
target                  105            based           fixed bin(17,0)          array level 3 dcl 60 ref 268 289
target_comp                     000133 automatic       fixed bin(17,0)          dcl 98 in procedure "le_combine_init_info_" set ref
                                                                                  143* 226* 258 268 287
target_comp               5(18)        based           fixed bin(18,0)          array level 3 in structure "lel" packed unsigned
                                                                                  unaligned dcl 63 in procedure
                                                                                  "le_combine_init_info_" set ref 206 210*
target_comp               5(18)        based           fixed bin(18,0)          array level 3 in structure "tlel" packed unsigned
                                                                                  unaligned dcl 72 in procedure
                                                                                  "le_combine_init_info_" set ref 206* 284 287*
target_link               6            based           fixed bin(18,0)          array level 3 in structure "lel" packed unsigned
                                                                                  unaligned dcl 63 in procedure
                                                                                  "le_combine_init_info_" set ref 131 208 211*
target_link               6            based           fixed bin(18,0)          array level 3 in structure "tlel" packed unsigned
                                                                                  unaligned dcl 72 in procedure
                                                                                  "le_combine_init_info_" set ref 172 208* 283 286*
target_link                     000134 automatic       fixed bin(17,0)          dcl 99 in procedure "le_combine_init_info_" set ref
                                                                                  144* 227* 286
tc                              000135 automatic       fixed bin(17,0)          dcl 100 set ref 157* 158 163 167 210 218 226*
tl                              000136 automatic       fixed bin(17,0)          dcl 101 set ref 171* 172 172 172 176 177 206 208 211
                                                                                  227*
tlel                                   based           structure                level 1 dcl 72
tlelp                           000140 automatic       pointer                  dcl 102 set ref 163* 171 172 172 172 176 177 206 208
                                                                                  281* 283 284 286 287 296 297 305 306
true                                   constant        bit(1)                   initial unaligned dcl 39 ref 426 432 434 441 447 451
                                                                                  455 456 458 459 463 465 468
type                      1            based           fixed bin(17,0)          level 2 in structure "link_init" dcl 2-205
                                                                                  in procedure "le_combine_init_info_" ref 399 399
                                                                                  403 408 422 422 422 422 439 445
type                      3            based           fixed bin(6,0)           array level 3 in structure "lel" packed unsigned
                                                                                  unaligned dcl 63 in procedure
                                                                                  "le_combine_init_info_" ref 131
type                      3            based           fixed bin(6,0)           array level 3 in structure "tlel" packed unsigned
                                                                                  unaligned dcl 72 in procedure
                                                                                  "le_combine_init_info_" ref 172
unspec                                                 builtin function         dcl 108 ref 403 403 408 408

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CLASS_LINKAGE                          internal static fixed bin(3,0)           initial unsigned dcl 2-25
CLASS_NAMES                            internal static char(12)                 initial array unaligned dcl 2-35
CLASS_SEGNAME                          internal static fixed bin(3,0)           initial unsigned dcl 2-25
CLASS_STATIC                           internal static fixed bin(3,0)           initial unsigned dcl 2-25
CLASS_SYMBOL                           internal static fixed bin(3,0)           initial unsigned dcl 2-25
CLASS_TEXT                             internal static fixed bin(3,0)           initial unsigned dcl 2-25
Definition                             internal static fixed bin(3,0)           initial dcl 1-32
FAULT_TAG_1                            internal static bit(6)                   initial unaligned dcl 3-100
FAULT_TAG_2                            internal static bit(6)                   initial unaligned dcl 3-101
FAULT_TAG_3                            internal static bit(6)                   initial unaligned dcl 3-102
FR_TRAPS_VERSION_1                     internal static fixed bin(17,0)          initial dcl 3-99
Heap                                   internal static fixed bin(3,0)           initial dcl 1-38
INIT_DEFERRED                          internal static fixed bin(17,0)          initial dcl 2-194
LE_ABORT_ERROR                         internal static fixed bin(17,0)          initial dcl 1-22
LE_ERROR                               internal static fixed bin(17,0)          initial dcl 1-20
LINK_CREATE_IF_NOT_FOUND               internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_OBSOLETE_2                        internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_REFNAME_BASE                      internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_REFNAME_OFFSETNAME                internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_SELF_BASE                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_TYPE_NAMES                        internal static varying char(32)         initial array dcl 2-153
Linkage                                internal static fixed bin(3,0)           initial dcl 1-28
Patch_Init                             internal static fixed bin(17,0)          initial dcl 1-59
Patch_Link                             internal static fixed bin(17,0)          initial dcl 1-58
Patch_Self_Init                        internal static fixed bin(17,0)          initial dcl 1-61
Patch_Symbol_Ref                       internal static fixed bin(17,0)          initial dcl 1-60
Refname_Base                           internal static fixed bin(3,0)           initial dcl 1-49
Refname_Offsetname                     internal static fixed bin(3,0)           initial dcl 1-51
SECTION_HEAP                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_LINK                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_STATIC                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_SYMBOL                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_SYSTEM                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_TEXT                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_UNUSED                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SYMBOLIC_SECTION_NAMES                 internal static char(8)                  initial array unaligned dcl 2-38
Self_Base                              internal static fixed bin(3,0)           initial dcl 1-47
Self_Offsetname                        internal static fixed bin(3,0)           initial dcl 1-53
Static                                 internal static fixed bin(3,0)           initial dcl 1-34
Symbol                                 internal static fixed bin(3,0)           initial dcl 1-30
System                                 internal static fixed bin(3,0)           initial dcl 1-36
Text                                   internal static fixed bin(3,0)           initial dcl 1-26
acc_string                             based           structure                level 1 dcl 2-327
acc_string_length                      automatic       fixed bin(21,0)          dcl 2-334
acc_string_ptr                         automatic       pointer                  dcl 2-326
comp_ht_n_entries                      automatic       fixed bin(17,0)          dcl 2-297
comp_ht_ptr                            automatic       pointer                  dcl 2-288
component_ht                           based           structure                level 1 dcl 2-289
def_count                              automatic       fixed bin(17,0)          dcl 1-173
def_header_ptr                         automatic       pointer                  dcl 2-57
def_ht_n_entries                       automatic       fixed bin(17,0)          dcl 2-284
def_ht_ptr                             automatic       pointer                  dcl 2-277
def_ptr                                automatic       pointer                  dcl 2-71
definition                             based           structure                level 1 dcl 2-72
definition_header                      based           structure                level 1 dcl 2-58
definition_ht                          based           structure                level 1 dcl 2-278
dup_table_n_names                      automatic       fixed bin(17,0)          dcl 2-310
dup_table_ptr                          automatic       pointer                  dcl 2-301
duplicate_table                        based           structure                level 1 dcl 2-302
exp_ptr                                automatic       pointer                  dcl 2-128
exp_word                               based           structure                level 1 dcl 2-129
fr_traps                               based           structure                level 1 dcl 3-90
le_binaries                            based           structure                level 1 dcl 1-260
le_definitions                         based           structure                level 1 dcl 1-167
le_options                             based           structure                level 1 dcl 1-202
le_patches                             based           structure                level 1 dcl 1-293
le_segnames                            based           structure                level 1 dcl 1-149
link_count                             automatic       fixed bin(17,0)          dcl 1-231
link_init_deferred                     based           structure                level 1 dcl 2-270
link_init_n_bits_in_datum              automatic       fixed bin(35,0)          dcl 2-261
link_init_n_words                      automatic       fixed bin(17,0)          dcl 2-215
link_init_n_words_in_list              automatic       fixed bin(17,0)          dcl 2-226
link_init_ptr                          automatic       pointer                  dcl 2-204
link_trap_pair                         based           structure                level 1 dcl 2-177
link_trap_ptr                          automatic       pointer                  dcl 2-176
linkage_header                         based           structure                level 1 dcl 3-50
linkage_header_flags                   based           structure                level 1 dcl 3-63
list_template_entry                    based           structure                level 1 dcl 2-239
msf_map                                based           structure                level 1 dcl 2-318
msf_map_ptr                            automatic       pointer                  dcl 2-317
msf_map_version_1                      internal static char(8)                  initial unaligned dcl 2-323
object_link                            based           structure                level 1 dcl 3-28
partial_link                           based           structure                level 1 dcl 3-38
pointer_init_template                  based           structure                level 1 packed unaligned dcl 2-253
section_nm                             internal static char(16)                 initial array unaligned dcl 1-41
segname_count                          automatic       fixed bin(17,0)          dcl 1-156
segname_definition                     based           structure                level 1 dcl 2-90
segname_ptr                            automatic       pointer                  dcl 2-89
type_pair                              based           structure                level 1 dcl 2-160
type_ptr                               automatic       pointer                  dcl 2-159
virgin_linkage_header                  based           structure                level 1 dcl 3-71

NAMES DECLARED BY EXPLICIT CONTEXT.
compare_init                    001107 constant        entry                    internal dcl 325 ref 185
le_combine_init_info_           000160 constant        entry                    external dcl 23

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1522        1542    1436        1532
Length      1770    1436        20         211      64           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
le_combine_init_info_               222 external procedure  is an external procedure.  
compare_init                            internal procedure  shares stack frame of external procedure le_combine_init_info_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
le_combine_init_info_    000100 c                           le_combine_init_info_
                         000101 chase_c                     le_combine_init_info_
                         000102 chase_l                     le_combine_init_info_
                         000103 extend                      le_combine_init_info_
                         000104 extension                   le_combine_init_info_
                         000105 incompatible                le_combine_init_info_
                         000106 initp                       le_combine_init_info_
                         000110 l                           le_combine_init_info_
                         000112 lelp                        le_combine_init_info_
                         000114 message                     le_combine_init_info_
                         000115 min                         le_combine_init_info_
                         000116 namep                       le_combine_init_info_
                         000120 new_initp                   le_combine_init_info_
                         000122 new_len                     le_combine_init_info_
                         000124 new_namep                   le_combine_init_info_
                         000126 next_c                      le_combine_init_info_
                         000127 next_l                      le_combine_init_info_
                         000130 owner                       le_combine_init_info_
                         000131 print_message               le_combine_init_info_
                         000132 replace                     le_combine_init_info_
                         000133 target_comp                 le_combine_init_info_
                         000134 target_link                 le_combine_init_info_
                         000135 tc                          le_combine_init_info_
                         000136 tl                          le_combine_init_info_
                         000140 tlelp                       le_combine_init_info_
                         000154 have_new                    compare_init
                         000155 have_old                    compare_init
                         000156 larger                      compare_init
                         000157 smaller                     compare_init

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
le_debug_                     le_error_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
le_et_$incompatible_init      le_et_$multiple_inits




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     23 000155       110 000165       114 000200       118 000213       123 000222       127 000224       131 000233
    139 000262       141 000263       142 000265       143 000267       144 000271       145 000273       147 000274
    157 000346       158 000361       163 000370       167 000372       169 000401       171 000403       172 000413
    176 000444       177 000446       179 000450       185 000466       192 000470       206 000550       208 000562
    210 000565       211 000571       213 000575       218 000600       223 000627       224 000631       226 000637
    227 000641       229 000643       235 000646       239 000666       247 000674       251 000677       253 000701
    258 000703       268 000774       270 001003       271 001005       279 001007       281 001012       283 001021
    284 001030       286 001033       287 001037       289 001042       296 001046       297 001050       298 001053
    305 001054       306 001056       308 001061       309 001063       310 001065       312 001066       314 001070
    316 001072       318 001106       325 001107       389 001111       390 001133       395 001147       399 001154
    403 001171       407 001210       408 001211       412 001233       413 001234       422 001235       426 001252
    427 001256       432 001257       434 001266       439 001271       441 001275       445 001277       447 001303
    451 001305       455 001326       456 001333       458 001342       459 001347       463 001362       464 001374
    465 001375       468 001406       471 001412


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
