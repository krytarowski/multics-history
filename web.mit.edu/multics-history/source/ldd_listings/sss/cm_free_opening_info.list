	COMPILATION LISTING OF SEGMENT cm_free_opening_info
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/03/85  1635.5 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*         This   routine  frees  the  opening  information  maintained  for  a
       10*     collection, and removes the  collection  from  the  collection_manager_'s
       11*     per-process opening table.
       12**/
       13 
       14 /* HISTORY:
       15*Written by Matthew Pierret, 03/25/83.
       16*Modified:
       17*05/21/84 by Matthew Pierret: Renamed include file dm_cm_cism_info to
       18*            dm_cism_info.
       19*10/01/84 by Matthew Pierret: Added FREE_STORAGE routine, which actually frees
       20*            the structures.  FINISH now calls this routine.  Added RETURN
       21*            and ERROR_RETURN routines.  Removed "in (dm_area)" from free
       22*            statements, as it is unnecessary, and removed declarations for
       23*            dm_area, dm_area_ptr and get_dm_free_area_. Changed 
       24*            REPORT_WRONG_VERSION to the standard CHECK_VERSION.
       25*
       26**/
       27 
       28 /* format: style2,ind3 */
       29 
       30 cm_free_opening_info:
       31    proc (p_file_opening_id, p_collection_id, p_code);
       32 
       33 
       34 /* START OF DECLARATIONS */
       35 /* Parameter */
       36 
       37       dcl	    p_file_opening_id      bit (36) aligned parameter;
       38       dcl	    p_collection_id	       bit (36) aligned parameter;
       39       dcl	    p_code	       fixed bin (35) parameter;
       40 
       41 /* Automatic */
       42 
       43       dcl	    code		       fixed bin (35);
       44       dcl	    collection_opening_id  bit (72) aligned;
       45       dcl	    (per_process_opening_table_ptr, temp_cm_info_ptr)
       46 			       ptr;
       47 
       48 /* Based */
       49 /* Builtin */
       50 
       51       dcl	    null		       builtin;
       52 
       53 /* Condition */
       54 
       55       dcl	    cleanup	       condition;
       56 
       57 /* Constant */
       58 
       59       dcl	    myname	       init ("cm_free_opening_info") char (32) varying internal static options (constant);
       60       dcl	    NO_ERRORS	       init (0) fixed bin (35) internal static options (constant);
       61 
       62 /* Entry */
       63 
       64       dcl	    cm_opening_info$opening_table_ptr
       65 			       entry () returns (ptr);
       66       dcl	    opening_manager_$get_opening
       67 			       entry (ptr, bit (72) aligned, ptr, fixed bin (35));
       68       dcl	    opening_manager_$free_opening
       69 			       entry (ptr, bit (72) aligned, fixed bin (35));
       70       dcl	    sub_err_	       entry () options (variable);
       71 
       72 /* External */
       73 
       74       dcl	    (
       75 	    dm_error_$no_opening,
       76 	    error_table_$unimplemented_version
       77 	    )		       fixed bin (35) ext;
       78 
       79 /* END OF DECLARATIONS */
       80 
       81       p_code, code = 0;
       82       cm_info_ptr, collection_header_ptr, blocked_storage_record_ptr, unblocked_storage_record_ptr = null;
       83 
       84       per_process_opening_table_ptr = cm_opening_info$opening_table_ptr ();
       85       if per_process_opening_table_ptr = null
       86       then call RETURN (NO_ERRORS);
       87 
       88       collection_opening_id = p_file_opening_id || p_collection_id;
       89 
       90       call opening_manager_$get_opening (per_process_opening_table_ptr, collection_opening_id, temp_cm_info_ptr, code);
       91       if code ^= 0
       92       then if code = dm_error_$no_opening
       93 	 then call RETURN (NO_ERRORS);
       94 	 else call ERROR_RETURN (code);
       95 
       96       if temp_cm_info_ptr = null
       97       then call RETURN (NO_ERRORS);
       98 
       99       call CHECK_VERSION (temp_cm_info_ptr -> cm_info.version, CM_INFO_VERSION_2, "cm_info");
      100       cm_info_ptr = temp_cm_info_ptr;
      101 
      102       if cm_info.header_ptr ^= null
      103       then
      104          do;
      105 	  call CHECK_VERSION (cm_info.header_ptr -> collection_header.version, COLLECTION_HEADER_VERSION_2,
      106 	       "collection_header");
      107 
      108 	  collection_header_ptr = cm_info.header_ptr;
      109 
      110 	  if cm_info.storage_record_buffer_ptr ^= null
      111 	  then if collection_header.control_interval_storage_method = UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
      112 	       then unblocked_storage_record_ptr = cm_info.storage_record_buffer_ptr;
      113 	       else if collection_header.control_interval_storage_method = BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
      114 	       then blocked_storage_record_ptr = cm_info.storage_record_buffer_ptr;
      115          end;
      116 
      117 
      118       call opening_manager_$free_opening (per_process_opening_table_ptr, collection_opening_id, p_code);
      119       if p_code ^= 0
      120       then return;
      121 
      122       on cleanup call FINISH ();
      123 
      124       call FREE_STORAGE ();
      125 MAIN_RETURN:
      126       return;
      127 
      128 RETURN:
      129    proc (r_p_code);
      130 
      131       dcl	    r_p_code	       fixed bin (35);
      132 
      133       p_code = r_p_code;
      134       go to MAIN_RETURN;
      135 
      136    end RETURN;
      137 
      138 
      139 ERROR_RETURN:
      140    proc (er_p_code);
      141 
      142       dcl	    er_p_code	       fixed bin (35);
      143 
      144       call RETURN (er_p_code);
      145 
      146    end ERROR_RETURN;
      147 
      148 FINISH:
      149    proc ();
      150 
      151       call FREE_STORAGE ();
      152 
      153    end FINISH;
      154 
      155 FREE_STORAGE:
      156    proc ();
      157 
      158       if cm_info_ptr ^= null
      159       then free cm_info;
      160       if collection_header_ptr ^= null
      161       then free collection_header;
      162       if blocked_storage_record_ptr ^= null
      163       then free blocked_storage_record;
      164       if unblocked_storage_record_ptr ^= null
      165       then free unblocked_storage_record;
      166 
      167    end FREE_STORAGE;
      168 
      169 CHECK_VERSION:
      170    proc (cv_p_given_version, cv_p_correct_version, cv_p_structure_name);
      171 
      172       dcl	    cv_p_structure_name    char (*);
      173       dcl	    cv_p_given_version     char (8) aligned;
      174       dcl	    cv_p_correct_version   char (8) aligned;
      175 
      176       if cv_p_given_version ^= cv_p_correct_version
      177       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      178 	      "^/Expected version ^8a of ^a structure; received ^8a.", cv_p_correct_version, cv_p_structure_name,
      179 	      cv_p_given_version);
      180 
      181       return;
      182 
      183    end CHECK_VERSION;
      184 
  1     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*        The cm_info structure is used to hold per-process opening information
  1     5*   about a collection.  It is generally allocated in the process' DM free
  1     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  1     7*   is used to provide access the cm_info structure, keeping it in a hash
  1     8*   table keyed on file opening id and collection id combined.
  1     9*        Currently cm_info is never freed until the process terminates.  Each
  1    10*   time a new transaction is started, detected when the current transaction
  1    11*   id of a process differs from cm_info.current_transaction_id, the information
  1    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  1    13*   demand, as most modules do not need the information in the storage record.
  1    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  1    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  1    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  1    17*   requested, it is placed at the location pointed to by
  1    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  1    19**/
  1    20 
  1    21 /* HISTORY:
  1    22*Written by Matthew Pierret, 10/27/82. 
  1    23*Modified:
  1    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  1    25*            storage_record_buffer_ptr. This points to the storage_record.
  1    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  1    27*            but storage_record_buffer_ptr continues to point at where the
  1    28*            storage_record was. When the storge_record is again requested,
  1    29*            it is put back in the same place rather than allocating a new
  1    30*            storage_record.
  1    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  1    32*            init clause from the version component.
  1    33**/
  1    34 
  1    35 /* format: style2,ind3,ll79 */
  1    36 
  1    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  1    38 	     2 version	      char (8),
  1    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  1    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  1    41 	     2 collection_id      bit (36) aligned init ("0"b),
  1    42 	     2 header_ptr	      ptr init (null),
  1    43 	     2 storage_record_ptr ptr init (null),
  1    44 	     2 storage_record_buffer_ptr
  1    45 			      ptr init (null);
  1    46 
  1    47      dcl	   cm_info_ptr	      ptr init (null);
  1    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  1    49 			      internal static options (constant);
  1    50 
  1    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      185 
      186 
  2     1 /* BEGIN INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*       Associated with each collection is the following collection_header
  2     5*   structure stored as an element in the Header Collection of the file.
  2     6*   The identifier of this element is also the idenfifier of the collection.
  2     7*   Even the Header Collection has a collection_header stored in the Header
  2     8*   Collection itself in the element identified by the constant
  2     9*   HEADER_COLLECTION_HEADER_ELEMENT_ID declared in dm_cm_hdr_col_ids.incl.pl1.
  2    10*   The information in collection_header is expected to be stable information.
  2    11*   The structure elements are described as follows:
  2    12*   
  2    13*   version is a character string version equal to COLLECTION_HEADER_VERSION_2.
  2    14*   
  2    15*   flags.fixed_size_elements indicates, if on that all elements in the
  2    16*   collection are of a fixed length.
  2    17*   
  2    18*   flags.thread_elements indicates that elements in a collection are to be
  2    19*   threaded in a linked list.  This is currrently unupported.
  2    20*   
  2    21*   flags.thread_control_intervals indicates, if on, that control intervals in
  2    22*   a collection are to be threaded in a linked list.  This is only useful if
  2    23*   the control interval storage method is blocked.
  2    24*   
  2    25*   flags.must_be_zero1 is reserved for future use and must be "0"b.
  2    26*   
  2    27*   control_interval_storage_method is the method of storage management of
  2    28*   control intervals for this collection, either
  2    29*   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD (not yet supported) or
  2    30*   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, declared in
  2    31*   dm_cism_info.incl.pl1.
  2    32*   
  2    33*   element_storage_method is the method of storage management of elements in
  2    34*   this collection, either BASIC_ELEMENT_STORAGE_METHOD or
  2    35*   ORDERED_ELEMENT_STORAGE_METHOD, declared in dm_esm_info.incl.pl1.
  2    36*   
  2    37*   maximum_element_size is the maximum size of an element in bits in this
  2    38*   collection.
  2    39*   
  2    40*   header_record_element_id is the identifier of an element containing a
  2    41*   caller-defined header for this collection.  If equal to "0"b, no
  2    42*   caller-defined header yet exists.  The put_header collection_manager_
  2    43*   operation stores such a header.
  2    44*   
  2    45*   storage_record_element_id is the identifier of the element containing the
  2    46*   storage_record for this collection.  The storage_record contains
  2    47*   information expected to be dynamic, such as the identifier of the last
  2    48*   control interval of the collection.  Its format is also dependent upon the
  2    49*   storage methods in effect for this collection.  storage_record structures
  2    50*   are declared in dm_cm_storage_record.incl.pl1.
  2    51*
  2    52**/
  2    53 
  2    54 /* HISTORY:
  2    55*Written by Matthew Pierret, 04/01/82.
  2    56*Modified:
  2    57*07/01/82 by Matthew Pierret: Changed to version A, added storage_record_area.
  2    58*10/29/82 by Matthew Pierret: Changed to version 2 ("col_hdr2"), separated
  2    59*            storage_record_area out, leaving storage_record_element_id behind.
  2    60*09/18/84 by Matthew Pierret: Added DESCRIPTION section.
  2    61**/
  2    62 
  2    63 /* format: style2,ind3,ll79 */
  2    64 
  2    65      dcl	   1 collection_header    aligned based (collection_header_ptr),
  2    66 	     2 version	      char (8),
  2    67 	     2 flags	      unaligned,
  2    68 	       3 fixed_size_elements
  2    69 			      bit (1),
  2    70 	       3 thread_elements  bit (1),
  2    71 	       3 thread_control_intervals
  2    72 			      bit (1),
  2    73 	       3 must_be_zero1    bit (15),
  2    74 	     2 control_interval_storage_method
  2    75 			      fixed bin (17) unal,
  2    76 	     2 element_storage_method
  2    77 			      fixed bin (17),
  2    78 	     2 maximum_element_size
  2    79 			      fixed bin (35),
  2    80 	     2 header_record_element_id
  2    81 			      bit (36) aligned,
  2    82 	     2 storage_record_element_id
  2    83 			      bit (36) aligned;
  2    84 
  2    85      dcl	   collection_header_ptr  ptr;
  2    86      dcl	   COLLECTION_HEADER_VERSION_2
  2    87 			      init ("col_hdr2") char (8) aligned
  2    88 			      int static options (constant);
  2    89 
  2    90 /* END INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
      187 
      188 
  3     1 /* BEGIN INCLUDE FILE dm_cm_storage_record.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*        A storage record is an extension to the collection_header structure.
  3     6*   It is expected to be more volatile than collection_header and has a 
  3     7*   different format depending on the control interval storage method in use
  3     8*   for the collection.  A storage record is stored as an element in the 
  3     9*   file's Header Collection with the element identifier 
  3    10*   collection_header.storage_record_element_id.
  3    11*   
  3    12*        The unblocked_storage_record contains the control interval numbers
  3    13*   of the first and last control intervals of a collection.  Unblocked
  3    14*   control intervals are chained together, so all control intervals can be 
  3    15*   found by starting at one end and following the chain forward or backward.
  3    16*   
  3    17*        The blocked_storage_record is not yet used, as the Blocked Control
  3    18*   Interval Storage Method is not yet implemented.
  3    19**/
  3    20 
  3    21 /* HISTORY:
  3    22*Written by Matthew Pierret, 09/24/84.
  3    23*Modified:
  3    24**/
  3    25 
  3    26 /* format: style2,ind3,ll79 */
  3    27 
  3    28      dcl	   1 unblocked_storage_record
  3    29 			      aligned
  3    30 			      based (unblocked_storage_record_ptr),
  3    31 	     2 first_control_interval
  3    32 			      fixed bin (24) uns,
  3    33 	     2 last_control_interval
  3    34 			      fixed bin (24) uns;
  3    35 
  3    36      dcl	   1 blocked_storage_record
  3    37 			      aligned based (blocked_storage_record_ptr),
  3    38 	     2 last_control_interval
  3    39 			      fixed bin (24) uns,
  3    40 	     2 number_of_blocks   fixed bin (17) unal,
  3    41 	     2 number_of_control_intervals_per_block
  3    42 			      fixed bin (17) unal,
  3    43 	     2 allocation_map_element_id
  3    44 			      bit (36) aligned;
  3    45 
  3    46      dcl	   unblocked_storage_record_ptr
  3    47 			      ptr init (null ());
  3    48      dcl	   blocked_storage_record_ptr
  3    49 			      ptr init (null ());
  3    50 
  3    51 /* END INCLUDE FILE dm_cm_storage_record.incl.pl1 */
      189 
      190 
  4     1 /* BEGIN INCLUDE FILE dm_cism_info.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*     This include file contains the blocked_cism_info and unblocked_cism_info
  4     6*     structures, as well as constants relevant to control interval storage
  4     7*     management.  These structures and constants are used by several managers.
  4     8*     The structures each describe a method of control interval storage 
  4     9*     management.
  4    10**/
  4    11 
  4    12 /* HISTORY:
  4    13*
  4    14*Written 02/07/82 by Matthew Pierret.
  4    15*Modified:
  4    16*05/17/84 by Matthew Pierret:  Changed to align structure elements and add
  4    17*            a version string.
  4    18**/
  4    19 
  4    20 /* format: style2 */
  4    21 
  4    22      dcl	   1 blocked_cism_info    based (blocked_cism_info_ptr) aligned,
  4    23 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  4    24 	     2 type	      fixed bin (17) init (BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  4    25 	     2 number_of_control_intervals_per_block
  4    26 			      fixed bin (17);
  4    27 
  4    28      dcl	   1 unblocked_cism_info  based (unblocked_cism_info_ptr) aligned,
  4    29 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  4    30 	     2 type	      fixed bin (17) init (UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  4    31 	     2 must_be_zero	      fixed bin (17);
  4    32 
  4    33      dcl	   blocked_cism_info_ptr  ptr;
  4    34      dcl	   unblocked_cism_info_ptr
  4    35 			      ptr;
  4    36 
  4    37      dcl	   CISM_INFO_VERSION_1    init ("CISMinf1") char (8) aligned internal static options (constant);
  4    38      dcl	   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  4    39 			      fixed bin init (1) internal static options (constant);
  4    40      dcl	   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  4    41 			      fixed bin init (2) internal static options (constant);
  4    42 
  4    43 /* END INCLUDE FILE dm_cism_info.incl.pl1 ---------- */
      191 
      192 
  5     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  5     2 /* format: style3 */
  5     3 
  5     4 /* These constants are to be used for the flags argument of sub_err_ */
  5     5 /* They are just "string (condition_info_header.action_flags)" */
  5     6 
  5     7 declare	(
  5     8 	ACTION_CAN_RESTART	init (""b),
  5     9 	ACTION_CANT_RESTART init ("1"b),
  5    10 	ACTION_DEFAULT_RESTART
  5    11 			init ("01"b),
  5    12 	ACTION_QUIET_RESTART
  5    13 			init ("001"b),
  5    14 	ACTION_SUPPORT_SIGNAL
  5    15 			init ("0001"b)
  5    16 	)		bit (36) aligned internal static options (constant);
  5    17 
  5    18 /* End include file */
      193 
      194    end cm_free_opening_info;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/03/85  1148.4  cm_free_opening_info.pl1          >spec>temp>famis1>cm_free_opening_info.pl1
185          1    01/03/85  1003.1  dm_cm_info.incl.pl1               >spec>temp>famis1>dm_cm_info.incl.pl1
187          2    01/03/85  1003.1  dm_cm_collection_header.incl.pl1  >spec>temp>famis1>dm_cm_collection_header.incl.pl1
189          3    01/03/85  1003.1  dm_cm_storage_record.incl.pl1     >spec>temp>famis1>dm_cm_storage_record.incl.pl1
191          4    01/03/85  1003.0  dm_cism_info.incl.pl1             >spec>temp>famis1>dm_cism_info.incl.pl1
193          5    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000000 constant        bit(36)                  initial dcl 5-7 set ref 176*
BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                       constant        fixed bin(17,0)          initial dcl 4-38 ref 113
CM_INFO_VERSION_2               000004 constant        char(8)                  initial dcl 1-48 set ref 99*
COLLECTION_HEADER_VERSION_2     000002 constant        char(8)                  initial dcl 2-86 set ref 105*
NO_ERRORS                              constant        fixed bin(35,0)          initial dcl 60 set ref 85* 91* 96*
UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                       constant        fixed bin(17,0)          initial dcl 4-40 ref 110
blocked_storage_record                 based           structure                level 1 dcl 3-36 ref 162
blocked_storage_record_ptr      000124 automatic       pointer                  initial dcl 3-48 set ref 82* 113* 3-48* 162 162
cleanup                         000110 stack reference condition                dcl 55 ref 122
cm_info                                based           structure                level 1 dcl 1-37 set ref 158
cm_info_ptr                     000116 automatic       pointer                  initial dcl 1-47 set ref 82* 100* 102 105 108 110
                                                                                  110 113 1-47* 158 158
cm_opening_info$opening_table_ptr
                                000010 constant        entry                    external dcl 64 ref 84
code                            000100 automatic       fixed bin(35,0)          dcl 43 set ref 81* 90* 91 91 94*
collection_header                      based           structure                level 1 dcl 2-65 set ref 160
collection_header_ptr           000120 automatic       pointer                  dcl 2-85 set ref 82* 108* 110 113 160 160
collection_opening_id           000102 automatic       bit(72)                  dcl 44 set ref 88* 90* 118*
control_interval_storage_method
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-65 ref 110 113
cv_p_correct_version                   parameter       char(8)                  dcl 174 set ref 169 176 176*
cv_p_given_version                     parameter       char(8)                  dcl 173 set ref 169 176 176*
cv_p_structure_name                    parameter       char                     unaligned dcl 172 set ref 169 176*
dm_error_$no_opening            000020 external static fixed bin(35,0)          dcl 74 ref 91
er_p_code                              parameter       fixed bin(35,0)          dcl 142 set ref 139 144*
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 74 set ref 176*
header_ptr                6            based           pointer                  initial level 2 dcl 1-37 ref 102 105 108
myname                          000006 constant        varying char(32)         initial dcl 59 set ref 176*
null                                                   builtin function         dcl 51 ref 82 85 96 102 110 1-47 3-46 3-48 158 160
                                                                                  162 164 176 176
opening_manager_$free_opening   000014 constant        entry                    external dcl 68 ref 118
opening_manager_$get_opening    000012 constant        entry                    external dcl 66 ref 90
p_code                                 parameter       fixed bin(35,0)          dcl 39 set ref 30 81* 118* 119 133*
p_collection_id                        parameter       bit(36)                  dcl 38 ref 30 88
p_file_opening_id                      parameter       bit(36)                  dcl 37 ref 30 88
per_process_opening_table_ptr   000104 automatic       pointer                  dcl 45 set ref 84* 85 90* 118*
r_p_code                               parameter       fixed bin(35,0)          dcl 131 ref 128 133
storage_record_buffer_ptr
                         12            based           pointer                  initial level 2 dcl 1-37 ref 110 110 113
sub_err_                        000016 constant        entry                    external dcl 70 ref 176
temp_cm_info_ptr                000106 automatic       pointer                  dcl 45 set ref 90* 96 99 100
unblocked_storage_record               based           structure                level 1 dcl 3-28 ref 164
unblocked_storage_record_ptr    000122 automatic       pointer                  initial dcl 3-46 set ref 82* 110* 3-46* 164 164
version                                based           char(8)                  level 2 in structure "collection_header" dcl 2-65
                                                                                  in procedure "cm_free_opening_info" set ref 105*
version                                based           char(8)                  level 2 in structure "cm_info" dcl 1-37 in procedure
                                                                                  "cm_free_opening_info" set ref 99*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 5-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 5-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 5-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 5-7
CISM_INFO_VERSION_1                    internal static char(8)                  initial dcl 4-37
blocked_cism_info                      based           structure                level 1 dcl 4-22
blocked_cism_info_ptr                  automatic       pointer                  dcl 4-33
unblocked_cism_info                    based           structure                level 1 dcl 4-28
unblocked_cism_info_ptr                automatic       pointer                  dcl 4-34

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000422 constant        entry                    internal dcl 169 ref 99 105
ERROR_RETURN                    000337 constant        entry                    internal dcl 139 ref 94
FINISH                          000350 constant        entry                    internal dcl 148 ref 122
FREE_STORAGE                    000360 constant        entry                    internal dcl 155 ref 124 151
MAIN_RETURN                     000330 constant        label                    dcl 125 ref 134
RETURN                          000331 constant        entry                    internal dcl 128 ref 85 91 96 144
cm_free_opening_info            000067 constant        entry                    external dcl 30

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       672         716     534         702
Length      1214     534        24         261     136           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_free_opening_info                200 external procedure  is an external procedure.  
on unit on line 122                  70 on unit               
RETURN                                  internal procedure  shares stack frame of external procedure cm_free_opening_info.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure cm_free_opening_info.  
FINISH                                  internal procedure  shares stack frame of on unit on line 122.  
FREE_STORAGE                         64 internal procedure  is called by several nonquick procedures.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure cm_free_opening_info.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_free_opening_info     000100 code                        cm_free_opening_info
                         000102 collection_opening_id       cm_free_opening_info
                         000104 per_process_opening_table_ptr
                                                            cm_free_opening_info
                         000106 temp_cm_info_ptr            cm_free_opening_info
                         000116 cm_info_ptr                 cm_free_opening_info
                         000120 collection_header_ptr       cm_free_opening_info
                         000122 unblocked_storage_record_ptr
                                                            cm_free_opening_info
                         000124 blocked_storage_record_ptr  cm_free_opening_info

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return              enable
ext_entry           int_entry           free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_opening_info$opening_table_ptr                           opening_manager_$free_opening opening_manager_$get_opening
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$no_opening          error_table_$unimplemented_version


CONSTANTS
000524  aa     000002000000
000525  aa     000000000000
000526  aa     600000000041
000527  aa     000100000000

000530  aa     000002000000
000531  aa     000000000000
000532  ta     000026000000
000533  aa     000000000000

000000  aa     400000000000

000002  aa  143 157 154 137	col_
000003  aa  150 144 162 062	hdr2

000004  aa  143 155 137 151	cm_i
000005  aa  156 146 157 062	nfo2

000006  aa     000000000024
000007  aa  143 155 137 146	cm_f
000010  aa  162 145 145 137	ree_
000011  aa  157 160 145 156	open
000012  aa  151 156 147 137	ing_
000013  aa  151 156 146 157	info
000014  aa  040 040 040 040	    
000015  aa  040 040 040 040	    
000016  aa  040 040 040 040	    

000017  aa     524000000065

000020  aa     404000000005

000021  aa     530000000040

000022  aa     526077777777

000023  aa     524000000021

000024  aa     524000000007

000025  aa     524000000010

000026  aa     000000000000

000027  aa     464000000000

000030  aa     404000000043

000031  aa     514000000044

000032  aa  143 155 137 151	cm_i
000033  aa  156 146 157 000	nfo

000034  aa     077777000043
000035  aa     000001000000

000036  aa  143 154 145 141	clea
000037  aa  156 165 160 000	nup

000040  aa  143 157 154 154	coll
000041  aa  145 143 164 151	ecti
000042  aa  157 156 137 150	on_h
000043  aa  145 141 144 145	eade
000044  aa  162 000 000 000	r

000045  aa  136 057 105 170	^/Ex
000046  aa  160 145 143 164	pect
000047  aa  145 144 040 166	ed v
000050  aa  145 162 163 151	ersi
000051  aa  157 156 040 136	on ^
000052  aa  070 141 040 157	8a o
000053  aa  146 040 136 141	f ^a
000054  aa  040 163 164 162	 str
000055  aa  165 143 164 165	uctu
000056  aa  162 145 073 040	re; 
000057  aa  162 145 143 145	rece
000060  aa  151 166 145 144	ived
000061  aa  040 136 070 141	 ^8a
000062  aa  056 000 000 000	.

BEGIN PROCEDURE cm_free_opening_info
ENTRY TO cm_free_opening_info                               STATEMENT 1 ON LINE 30
cm_free_opening_info:
   proc (p_file_opening_id, p_collection_id, p_code);

000063  at     000003000031
000064  tt     000031000030
000065  ta     000063000000
000066  da     000115300000
000067  aa   000320 6270 00	eax7 	208
000070  aa  7 00034 3521 20	epp2 	pr7|28,*
000071  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000072  aa     000006000000
000073  aa     000000000000
						STATEMENT 1 ON LINE 47 OF FILE 1
000074  aa   777740 2370 04	ldaq 	-32,ic		000034 = 077777000043 000001000000
000075  aa  6 00116 7571 00	staq 	pr6|78		cm_info_ptr
						STATEMENT 1 ON LINE 46 OF FILE 3
000076  aa  6 00122 7571 00	staq 	pr6|82		unblocked_storage_record_ptr
						STATEMENT 1 ON LINE 48 OF FILE 3
000077  aa  6 00124 7571 00	staq 	pr6|84		blocked_storage_record_ptr
						STATEMENT 1 ON LINE 81
      p_code, code = 0;

000100  aa  6 00032 3735 20	epp7 	pr6|26,*
000101  aa  7 00006 4501 20	stz  	pr7|6,*		p_code
000102  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 82
      cm_info_ptr, collection_header_ptr, blocked_storage_record_ptr, unblocked_storage_record_ptr = null;

000103  aa   777731 3714 24	epp5 	-39,ic*
000104  aa  6 00116 6515 00	spri5	pr6|78		cm_info_ptr
000105  aa  6 00120 6515 00	spri5	pr6|80		collection_header_ptr
000106  aa  6 00124 6515 00	spri5	pr6|84		blocked_storage_record_ptr
000107  aa  6 00122 6515 00	spri5	pr6|82		unblocked_storage_record_ptr
						STATEMENT 1 ON LINE 84
      per_process_opening_table_ptr = cm_opening_info$opening_table_ptr ();

000110  aa  6 00104 3521 00	epp2 	pr6|68		per_process_opening_table_ptr
000111  aa  6 00154 2521 00	spri2	pr6|108
000112  aa  6 00152 6211 00	eax1 	pr6|106
000113  aa   004000 4310 07	fld  	2048,dl
000114  la  4 00010 3521 20	epp2 	pr4|8,*		cm_opening_info$opening_table_ptr
000115  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 85
      if per_process_opening_table_ptr = null
      then call RETURN (NO_ERRORS);

000116  aa  6 00104 2371 00	ldaq 	pr6|68		per_process_opening_table_ptr
000117  aa   777715 6770 04	eraq 	-51,ic		000034 = 077777000043 000001000000
000120  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000121  aa   000003 6010 04	tnz  	3,ic		000124
000122  aa   000406 3520 04	epp2 	262,ic		000530 = 000002000000
000123  aa   000206 6700 04	tsp4 	134,ic		000331
						STATEMENT 1 ON LINE 88
      collection_opening_id = p_file_opening_id || p_collection_id;

000124  aa  6 00032 3735 20	epp7 	pr6|26,*
000125  aa  7 00002 2351 20	lda  	pr7|2,*		p_file_opening_id
000126  aa  7 00004 2361 20	ldq  	pr7|4,*		p_collection_id
000127  aa  6 00102 7571 00	staq 	pr6|66		collection_opening_id
						STATEMENT 1 ON LINE 90
      call opening_manager_$get_opening (per_process_opening_table_ptr, collection_opening_id, temp_cm_info_ptr, code);

000130  aa  6 00104 3521 00	epp2 	pr6|68		per_process_opening_table_ptr
000131  aa  6 00160 2521 00	spri2	pr6|112
000132  aa  6 00102 3521 00	epp2 	pr6|66		collection_opening_id
000133  aa  6 00162 2521 00	spri2	pr6|114
000134  aa  6 00106 3521 00	epp2 	pr6|70		temp_cm_info_ptr
000135  aa  6 00164 2521 00	spri2	pr6|116
000136  aa  6 00100 3521 00	epp2 	pr6|64		code
000137  aa  6 00166 2521 00	spri2	pr6|118
000140  aa  6 00156 6211 00	eax1 	pr6|110
000141  aa   020000 4310 07	fld  	8192,dl
000142  aa  6 00044 3701 20	epp4 	pr6|36,*
000143  la  4 00012 3521 20	epp2 	pr4|10,*		opening_manager_$get_opening
000144  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 91
      if code ^= 0
      then if code = dm_error_$no_opening
	 then call RETURN (NO_ERRORS);

000145  aa  6 00100 2361 00	ldq  	pr6|64		code
000146  aa   000011 6000 04	tze  	9,ic		000157
000147  aa  6 00044 3701 20	epp4 	pr6|36,*
000150  la  4 00020 1161 20	cmpq 	pr4|16,*		dm_error_$no_opening
000151  aa   000004 6010 04	tnz  	4,ic		000155
000152  aa   000356 3520 04	epp2 	238,ic		000530 = 000002000000
000153  aa   000156 6700 04	tsp4 	110,ic		000331
000154  aa   000003 7100 04	tra  	3,ic		000157
						STATEMENT 1 ON LINE 94
	 else call ERROR_RETURN (code);

000155  aa   000347 3520 04	epp2 	231,ic		000524 = 000002000000
000156  aa   000161 6700 04	tsp4 	113,ic		000337
						STATEMENT 1 ON LINE 96
      if temp_cm_info_ptr = null
      then call RETURN (NO_ERRORS);

000157  aa  6 00106 2371 00	ldaq 	pr6|70		temp_cm_info_ptr
000160  aa   777654 6770 04	eraq 	-84,ic		000034 = 077777000043 000001000000
000161  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000162  aa   000003 6010 04	tnz  	3,ic		000165
000163  aa   000345 3520 04	epp2 	229,ic		000530 = 000002000000
000164  aa   000145 6700 04	tsp4 	101,ic		000331
						STATEMENT 1 ON LINE 99
      call CHECK_VERSION (temp_cm_info_ptr -> cm_info.version, CM_INFO_VERSION_2, "cm_info");

000165  aa   777645 2370 04	ldaq 	-91,ic		000032 = 143155137151 156146157000
000166  aa  6 00150 7571 00	staq 	pr6|104
000167  aa  6 00106 3521 20	epp2 	pr6|70,*		cm_info.version
000170  aa  6 00172 2521 00	spri2	pr6|122
000171  aa   777613 3520 04	epp2 	-117,ic		000004 = 143155137151
000172  aa  6 00174 2521 00	spri2	pr6|124
000173  aa  6 00150 3521 00	epp2 	pr6|104
000174  aa  6 00176 2521 00	spri2	pr6|126
000175  aa   777630 3520 04	epp2 	-104,ic		000025 = 524000000010
000176  aa  6 00200 2521 00	spri2	pr6|128
000177  aa  6 00202 2521 00	spri2	pr6|130
000200  aa   777624 3520 04	epp2 	-108,ic		000024 = 524000000007
000201  aa  6 00204 2521 00	spri2	pr6|132
000202  aa  6 00170 3521 00	epp2 	pr6|120
000203  aa   014000 4310 07	fld  	6144,dl
000204  aa  2 00000 7571 00	staq 	pr2|0
000205  aa   000215 6700 04	tsp4 	141,ic		000422
						STATEMENT 1 ON LINE 100
      cm_info_ptr = temp_cm_info_ptr;

000206  aa  6 00106 3735 20	epp7 	pr6|70,*		temp_cm_info_ptr
000207  aa  6 00116 6535 00	spri7	pr6|78		cm_info_ptr
						STATEMENT 1 ON LINE 102
      if cm_info.header_ptr ^= null
      then
         do;

000210  aa  6 00116 3715 20	epp5 	pr6|78,*		cm_info_ptr
000211  aa  5 00006 2371 00	ldaq 	pr5|6		cm_info.header_ptr
000212  aa   777622 6770 04	eraq 	-110,ic		000034 = 077777000043 000001000000
000213  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000214  aa   000053 6000 04	tze  	43,ic		000267
						STATEMENT 1 ON LINE 105
	  call CHECK_VERSION (cm_info.header_ptr -> collection_header.version, COLLECTION_HEADER_VERSION_2,
	       "collection_header");

000215  aa   777623 2370 04	ldaq 	-109,ic		000040 = 143157154154 145143164151
000216  aa  6 00156 7571 00	staq 	pr6|110
000217  aa   777623 2370 04	ldaq 	-109,ic		000042 = 157156137150 145141144145
000220  aa  6 00160 7571 00	staq 	pr6|112
000221  aa   162000 2350 03	lda  	58368,du
000222  aa  6 00162 7551 00	sta  	pr6|114
000223  aa  5 00006 3521 20	epp2 	pr5|6,*		collection_header.version
000224  aa  6 00172 2521 00	spri2	pr6|122
000225  aa   777555 3520 04	epp2 	-147,ic		000002 = 143157154137
000226  aa  6 00174 2521 00	spri2	pr6|124
000227  aa  6 00156 3521 00	epp2 	pr6|110
000230  aa  6 00176 2521 00	spri2	pr6|126
000231  aa   777574 3520 04	epp2 	-132,ic		000025 = 524000000010
000232  aa  6 00200 2521 00	spri2	pr6|128
000233  aa  6 00202 2521 00	spri2	pr6|130
000234  aa   777567 3520 04	epp2 	-137,ic		000023 = 524000000021
000235  aa  6 00204 2521 00	spri2	pr6|132
000236  aa  6 00170 3521 00	epp2 	pr6|120
000237  aa   014000 4310 07	fld  	6144,dl
000240  aa  2 00000 7571 00	staq 	pr2|0
000241  aa   000161 6700 04	tsp4 	113,ic		000422
						STATEMENT 1 ON LINE 108
	  collection_header_ptr = cm_info.header_ptr;

000242  aa  6 00116 3735 20	epp7 	pr6|78,*		cm_info_ptr
000243  aa  7 00006 3735 20	epp7 	pr7|6,*		cm_info.header_ptr
000244  aa  6 00120 6535 00	spri7	pr6|80		collection_header_ptr
						STATEMENT 1 ON LINE 110
	  if cm_info.storage_record_buffer_ptr ^= null
	  then if collection_header.control_interval_storage_method = UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
	       then unblocked_storage_record_ptr = cm_info.storage_record_buffer_ptr;

000245  aa  6 00116 3715 20	epp5 	pr6|78,*		cm_info_ptr
000246  aa  5 00012 2371 00	ldaq 	pr5|10		cm_info.storage_record_buffer_ptr
000247  aa   777565 6770 04	eraq 	-139,ic		000034 = 077777000043 000001000000
000250  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000251  aa   000016 6000 04	tze  	14,ic		000267
000252  aa  7 00002 2351 00	lda  	pr7|2		collection_header.control_interval_storage_method
000253  aa   000022 7350 00	als  	18
000254  aa   000066 7330 00	lrs  	54
000255  aa  6 00210 7561 00	stq  	pr6|136		collection_header.control_interval_storage_method
000256  aa   000002 1160 07	cmpq 	2,dl
000257  aa   000004 6010 04	tnz  	4,ic		000263
000260  aa  5 00012 3535 20	epp3 	pr5|10,*		cm_info.storage_record_buffer_ptr
000261  aa  6 00122 2535 00	spri3	pr6|82		unblocked_storage_record_ptr
000262  aa   000005 7100 04	tra  	5,ic		000267
						STATEMENT 1 ON LINE 113
	       else if collection_header.control_interval_storage_method = BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
	       then blocked_storage_record_ptr = cm_info.storage_record_buffer_ptr;

000263  aa   000001 1160 07	cmpq 	1,dl
000264  aa   000003 6010 04	tnz  	3,ic		000267
000265  aa  5 00012 3535 20	epp3 	pr5|10,*		cm_info.storage_record_buffer_ptr
000266  aa  6 00124 2535 00	spri3	pr6|84		blocked_storage_record_ptr
						STATEMENT 1 ON LINE 115
         end;

						STATEMENT 1 ON LINE 118
      call opening_manager_$free_opening (per_process_opening_table_ptr, collection_opening_id, p_code);

000267  aa  6 00104 3521 00	epp2 	pr6|68		per_process_opening_table_ptr
000270  aa  6 00160 2521 00	spri2	pr6|112
000271  aa  6 00102 3521 00	epp2 	pr6|66		collection_opening_id
000272  aa  6 00162 2521 00	spri2	pr6|114
000273  aa  6 00032 3735 20	epp7 	pr6|26,*
000274  aa  7 00006 3521 20	epp2 	pr7|6,*		p_code
000275  aa  6 00164 2521 00	spri2	pr6|116
000276  aa  6 00156 6211 00	eax1 	pr6|110
000277  aa   014000 4310 07	fld  	6144,dl
000300  aa  6 00044 3701 20	epp4 	pr6|36,*
000301  la  4 00014 3521 20	epp2 	pr4|12,*		opening_manager_$free_opening
000302  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 119
      if p_code ^= 0
      then return;

000303  aa  6 00032 3735 20	epp7 	pr6|26,*
000304  aa  7 00006 2361 20	ldq  	pr7|6,*		p_code
000305  aa  0 00631 6011 00	tnz  	pr0|409		return
						STATEMENT 1 ON LINE 122
      on cleanup call FINISH ();

000306  aa   000007 7260 07	lxl6 	7,dl
000307  aa   777527 3520 04	epp2 	-169,ic		000036 = 143154145141
000310  aa  0 00717 7001 00	tsx0 	pr0|463		enable
000311  aa   000004 7100 04	tra  	4,ic		000315
000312  aa     000110000000
000313  aa   000011 7100 04	tra  	9,ic		000324
BEGIN CONDITION cleanup.1
ENTRY TO cleanup.1                                          STATEMENT 1 ON LINE 122
      on cleanup call FINISH ();

000314  da     000123200000
000315  aa   000120 6270 00	eax7 	80
000316  aa  7 00034 3521 20	epp2 	pr7|28,*
000317  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000320  aa     000000000000
000321  aa     000000000000
000322  aa   000026 6700 04	tsp4 	22,ic		000350
000323  aa  0 00631 7101 00	tra  	pr0|409		return
  END CONDITION cleanup.1
						STATEMENT 1 ON LINE 124
      call FREE_STORAGE ();

000324  aa  6 00056 6211 00	eax1 	pr6|46
000325  aa   000000 4310 07	fld  	0,dl
000326  aa   000032 3520 04	epp2 	26,ic		000360 = 000100627000
000327  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 125
MAIN_RETURN:
      return;

000330  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 194
   end cm_free_opening_info;

BEGIN PROCEDURE RETURN
ENTRY TO RETURN                                             STATEMENT 1 ON LINE 128
RETURN:
   proc (r_p_code);

000331  aa  6 00126 6501 00	spri4	pr6|86
000332  aa  6 00130 2521 00	spri2	pr6|88
						STATEMENT 1 ON LINE 133
      p_code = r_p_code;

000333  aa  2 00002 2361 20	ldq  	pr2|2,*		r_p_code
000334  aa  6 00032 3735 20	epp7 	pr6|26,*
000335  aa  7 00006 7561 20	stq  	pr7|6,*		p_code
						STATEMENT 1 ON LINE 134
      go to MAIN_RETURN;

000336  aa   777772 7100 04	tra  	-6,ic		000330
						STATEMENT 1 ON LINE 136
   end RETURN;

  END PROCEDURE RETURN
BEGIN PROCEDURE ERROR_RETURN
ENTRY TO ERROR_RETURN                                       STATEMENT 1 ON LINE 139
ERROR_RETURN:
   proc (er_p_code);

000337  aa  6 00134 6501 00	spri4	pr6|92
000340  aa  6 00136 2521 00	spri2	pr6|94
						STATEMENT 1 ON LINE 144
      call RETURN (er_p_code);

000341  aa  2 00002 3521 20	epp2 	pr2|2,*		er_p_code
000342  aa  6 00214 2521 00	spri2	pr6|140
000343  aa  6 00212 3521 00	epp2 	pr6|138
000344  aa   004000 4310 07	fld  	2048,dl
000345  aa  2 00000 7571 00	staq 	pr2|0
000346  aa   777763 6700 04	tsp4 	-13,ic		000331
						STATEMENT 1 ON LINE 146
   end ERROR_RETURN;

000347  aa  6 00134 6101 00	rtcd 	pr6|92
  END PROCEDURE ERROR_RETURN
BEGIN PROCEDURE FINISH
ENTRY TO FINISH                                             STATEMENT 1 ON LINE 148
FINISH:
   proc ();

000350  aa  6 00100 6501 00	spri4	pr6|64
						STATEMENT 1 ON LINE 151
      call FREE_STORAGE ();

000351  aa   000001 7270 07	lxl7 	1,dl
000352  aa  6 00056 6211 00	eax1 	pr6|46
000353  aa   000000 4310 07	fld  	0,dl
000354  aa   000004 3520 04	epp2 	4,ic		000360 = 000100627000
000355  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 153
   end FINISH;

000356  aa  6 00100 6101 00	rtcd 	pr6|64
  END PROCEDURE FINISH
BEGIN PROCEDURE FREE_STORAGE
ENTRY TO FREE_STORAGE                                       STATEMENT 1 ON LINE 155
FREE_STORAGE:
   proc ();

000357  da     000132200000
000360  aa   000100 6270 00	eax7 	64
000361  aa  7 00034 3521 20	epp2 	pr7|28,*
000362  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000363  aa     000000000000
000364  aa     000000000000
						STATEMENT 1 ON LINE 158
      if cm_info_ptr ^= null
      then free cm_info;

000365  aa  6 00040 3735 20	epp7 	pr6|32,*
000366  aa  7 00116 2371 00	ldaq 	pr7|78		cm_info_ptr
000367  aa   777445 6770 04	eraq 	-219,ic		000034 = 077777000043 000001000000
000370  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000371  aa   000003 6000 04	tze  	3,ic		000374
000372  aa  7 00116 3715 00	epp5 	pr7|78		cm_info_ptr
000373  aa  0 01404 7001 00	tsx0 	pr0|772		free_based
						STATEMENT 1 ON LINE 160
      if collection_header_ptr ^= null
      then free collection_header;

000374  aa  6 00040 3735 20	epp7 	pr6|32,*
000375  aa  7 00120 2371 00	ldaq 	pr7|80		collection_header_ptr
000376  aa   777436 6770 04	eraq 	-226,ic		000034 = 077777000043 000001000000
000377  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000400  aa   000003 6000 04	tze  	3,ic		000403
000401  aa  7 00120 3715 00	epp5 	pr7|80		collection_header_ptr
000402  aa  0 01404 7001 00	tsx0 	pr0|772		free_based
						STATEMENT 1 ON LINE 162
      if blocked_storage_record_ptr ^= null
      then free blocked_storage_record;

000403  aa  6 00040 3735 20	epp7 	pr6|32,*
000404  aa  7 00124 2371 00	ldaq 	pr7|84		blocked_storage_record_ptr
000405  aa   777427 6770 04	eraq 	-233,ic		000034 = 077777000043 000001000000
000406  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000407  aa   000003 6000 04	tze  	3,ic		000412
000410  aa  7 00124 3715 00	epp5 	pr7|84		blocked_storage_record_ptr
000411  aa  0 01404 7001 00	tsx0 	pr0|772		free_based
						STATEMENT 1 ON LINE 164
      if unblocked_storage_record_ptr ^= null
      then free unblocked_storage_record;

000412  aa  6 00040 3735 20	epp7 	pr6|32,*
000413  aa  7 00122 2371 00	ldaq 	pr7|82		unblocked_storage_record_ptr
000414  aa   777420 6770 04	eraq 	-240,ic		000034 = 077777000043 000001000000
000415  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000416  aa   000003 6000 04	tze  	3,ic		000421
000417  aa  7 00122 3715 00	epp5 	pr7|82		unblocked_storage_record_ptr
000420  aa  0 01404 7001 00	tsx0 	pr0|772		free_based
						STATEMENT 1 ON LINE 167
   end FREE_STORAGE;

000421  aa  0 00631 7101 00	tra  	pr0|409		return
  END PROCEDURE FREE_STORAGE
BEGIN PROCEDURE CHECK_VERSION
ENTRY TO CHECK_VERSION                                      STATEMENT 1 ON LINE 169
CHECK_VERSION:
   proc (cv_p_given_version, cv_p_correct_version, cv_p_structure_name);

000422  aa  6 00142 6501 00	spri4	pr6|98
000423  aa  6 00144 2521 00	spri2	pr6|100
000424  aa  2 00002 3521 01	epp2 	pr2|2,au
000425  aa  6 00146 2521 00	spri2	pr6|102
000426  aa  2 00004 2361 20	ldq  	pr2|4,*
000427  aa   000002 6040 04	tmi  	2,ic		000431
000430  aa   777777 3760 07	anq  	262143,dl
000431  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000432  aa  6 00220 7561 00	stq  	pr6|144
						STATEMENT 1 ON LINE 176
      if cv_p_given_version ^= cv_p_correct_version
      then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
	      "^/Expected version ^8a of ^a structure; received ^8a.", cv_p_correct_version, cv_p_structure_name,
	      cv_p_given_version);

000433  aa  6 00144 3735 20	epp7 	pr6|100,*
000434  aa  7 00002 3715 20	epp5 	pr7|2,*
000435  aa  5 00000 2351 00	lda  	pr5|0		cv_p_given_version
000436  aa  5 00001 2361 00	ldq  	pr5|1		cv_p_given_version
000437  aa  7 00004 3535 20	epp3 	pr7|4,*
000440  aa  3 00000 1151 00	cmpa 	pr3|0		cv_p_correct_version
000441  aa   000002 6010 04	tnz  	2,ic		000443
000442  aa  3 00001 1161 00	cmpq 	pr3|1		cv_p_correct_version
000443  aa   000060 6000 04	tze  	48,ic		000523
000444  aa   777370 3514 24	epp1 	-264,ic*
000445  aa  6 00222 2515 00	spri1	pr6|146
000446  aa  6 00221 4501 00	stz  	pr6|145
000447  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000450  aa   777376 00 0070	desc9a	-258,56		000045 = 136057105170
000451  aa  6 00224 00 0070	desc9a	pr6|148,56
000452  aa  6 00044 3701 20	epp4 	pr6|36,*
000453  la  4 00022 3521 20	epp2 	pr4|18,*		error_table_$unimplemented_version
000454  aa  6 00244 2521 00	spri2	pr6|164
000455  aa   777332 3520 04	epp2 	-294,ic		000007 = 143155137146
000456  aa  6 00246 2521 00	spri2	pr6|166
000457  aa   777321 3520 04	epp2 	-303,ic		000000 = 400000000000
000460  aa  6 00250 2521 00	spri2	pr6|168
000461  aa  6 00222 3521 00	epp2 	pr6|146
000462  aa  6 00252 2521 00	spri2	pr6|170
000463  aa  6 00221 3521 00	epp2 	pr6|145
000464  aa  6 00254 2521 00	spri2	pr6|172
000465  aa  6 00224 3521 00	epp2 	pr6|148
000466  aa  6 00256 2521 00	spri2	pr6|174
000467  aa  7 00004 3521 20	epp2 	pr7|4,*		cv_p_correct_version
000470  aa  6 00260 2521 00	spri2	pr6|176
000471  aa  7 00006 3521 20	epp2 	pr7|6,*		cv_p_structure_name
000472  aa  6 00262 2521 00	spri2	pr6|178
000473  aa  7 00002 3521 20	epp2 	pr7|2,*		cv_p_given_version
000474  aa  6 00264 2521 00	spri2	pr6|180
000475  aa   777333 3520 04	epp2 	-293,ic		000030 = 404000000043
000476  aa  6 00266 2521 00	spri2	pr6|182
000477  aa   777322 3520 04	epp2 	-302,ic		000021 = 530000000040
000500  aa  6 00270 2521 00	spri2	pr6|184
000501  aa   777330 3520 04	epp2 	-296,ic		000031 = 514000000044
000502  aa  6 00272 2521 00	spri2	pr6|186
000503  aa   777324 3520 04	epp2 	-300,ic		000027 = 464000000000
000504  aa  6 00274 2521 00	spri2	pr6|188
000505  aa   777313 3520 04	epp2 	-309,ic		000020 = 404000000005
000506  aa  6 00276 2521 00	spri2	pr6|190
000507  aa   777310 3520 04	epp2 	-312,ic		000017 = 524000000065
000510  aa  6 00300 2521 00	spri2	pr6|192
000511  aa   777314 3520 04	epp2 	-308,ic		000025 = 524000000010
000512  aa  6 00302 2521 00	spri2	pr6|194
000513  aa  6 00306 2521 00	spri2	pr6|198
000514  aa  6 00146 3715 20	epp5 	pr6|102,*
000515  aa  5 00004 3521 20	epp2 	pr5|4,*
000516  aa  6 00304 2521 00	spri2	pr6|196
000517  aa  6 00242 6211 00	eax1 	pr6|162
000520  aa   044000 4310 07	fld  	18432,dl
000521  la  4 00016 3521 20	epp2 	pr4|14,*		sub_err_
000522  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 181
      return;

000523  aa  6 00142 6101 00	rtcd 	pr6|98
						STATEMENT 1 ON LINE 183
   end CHECK_VERSION;

  END PROCEDURE CHECK_VERSION
  END PROCEDURE cm_free_opening_info


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
