	COMPILATION LISTING OF SEGMENT probe_requests_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 11/11/88  1547.9 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(87-06-18,RWaters), approve(87-06-18,MCR7687), audit(87-06-24,Huen),
       14*     install(87-07-15,MR12.1-1040):
       15*     Probe error #108: allow the object command to work w/o source code.
       16*  2) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       17*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       18*     Added format control comment to make the source more readable.
       19*                                                   END HISTORY COMMENTS */
       20 
       21 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       22 
       23 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       24 
       25 probe_requests_:
       26   proc ();
       27 
       28   call probe_error_$malfunction ();	/* dummy entry */
       29 
       30   /* THE PROBE REQUESTS WE CONTAIN ARE:
       31*
       32*   after,
       33*   args,
       34*   before,
       35*   enable,
       36*   execute,
       37*   handlers,
       38*   input_description,
       39*   input_switch,
       40*   object,
       41*   output_description,
       42*   output_switch,
       43*   position/use,
       44*   reset,
       45*   source,
       46*   status,
       47*   where
       48*
       49*
       50*   Modified 16 Sept 79 JRDavis for version 4 break_mgr_ syntax
       51*   Modified 09/20/80 WOS, to make args request work in breakpoint request list. (bug 198) */
       52   /* Make input_switch & output_switch static (per-process) 09/30/81 S. Herbst */
       53   /* Add input_description and output_description requetsts 10/01/81 S. Herbst */
       54   /* Add arguments LEVEL_N and PROC_NAME to args request 10/02/81 S. Herbst */
       55   /* Add "ps line +N", "ps level +N", and "b STRING" syntax 10/09/81 S. Herbst */
       56   /* Added object request 11/10/81 S. Herbst */
       57   /* Fixed for "ps N.M" and "args N.M" (support frames) 12/19/81 S. Herbst */
       58   /* Fixed object request to not show break instructions 09/15/82 S. Herbst */
       59   /* Fixed "handlers" to test for null source_info.stack_ptr 10/27/82 S. Herbst */
       60   /* Added "enable" request (undocumented) for use when debugging probe itself 08/15/83 S. Herbst */
       61   /* Changed to call probe_block_name_ with "0"b (brief form) 08/26/83 S. Herbst */
       62   /* Fixed "sc path" to set seg_info.(directory entry)_name 10/11/83 S. Herbst */
       63   /* Changed position to allow "ps lines +N" and "ps +N line(s)" same as "ps line +N" 02/09/84 S. Herbst */
       64   /* Fixed (input output)_description to use un-parsed attach description 03/30/84 S. Herbst */
       65   /* Fixed "ps" (no args) to fill in source_info.instruction_ptr if null 08/02/84 S. Herbst */
       66   /* Fixed "sc path" to not set seg_info.(directory_name entry_name);these refer to the object 11/07/84 S. Herbst */
       67   /* Added "wh object", "wh object path", "wh source path" 11/07/84 S. Herbst */
       68   /* Added synonym "wh obj" for "wh object" 01/03/85 Steve Herbst */
       69   /* Fixed "wh control" to print stack level as "wh source" does 01/31/85 Steve Herbst */
       70   /* Changed to allow "object" to work without a source file 05/21/87 RWaters */
       71 
       72 
       73   dcl P_probe_info_ptr	pointer parameter;
       74 
       75   dcl (
       76       PRIVATE		init ("1"b),
       77       NOT_PRIVATE		init ("0"b)
       78       )			bit (1) aligned int static options (constant);
       79   dcl (
       80       STREAM_INPUT		init (1),
       81       STREAM_OUTPUT		init (2)
       82       )			fixed bin int static options (constant);
       83 
       84   dcl NL			char (1) int static options (constant) init ("
       85 ");
       86 
       87   dcl code		fixed bin (35);
       88 
       89   dcl 1 new_source_info	aligned like source_info;
       90   dcl source_ptr		ptr;
       91   dcl level_string		char (32) varying;
       92   dcl (frame_number, frame_decimal, level)
       93 			fixed bin;
       94 
       95   dcl 1 map_array		(map_size) aligned based (stmt_map_ptr)
       96 			like statement_map;
       97   dcl map_size		fixed bin (21);
       98   dcl stmt_map_ptr		ptr;
       99 
      100   dcl constant_string	char (probe_info.ct -> constant.precision)
      101 			based (probe_info.ct -> constant.data_ptr);
      102   dcl pathname		char (256) varying;
      103   dcl attach_description	char (256) varying;
      104 
      105   dcl (
      106       probe_et_$e_syntax_err,
      107       probe_et_$bad_ctl_arg,
      108       probe_et_$bad_line,
      109       probe_et_$no_statement_map,
      110       probe_et_$noarg,
      111       probe_et_$none_active,
      112       probe_et_$syntax_error,
      113       probe_et_$too_many_args,
      114       probe_et_$unimplemented_request
      115       )			fixed bin (35) external static;
      116 
      117   dcl probe_break_mgr_$print_instructions
      118 			entry (ptr, ptr, ptr, fixed bin);
      119   dcl probe_error_$malfunction
      120 			entry options (variable);
      121   dcl probe_error_$warning	entry options (variable);
      122   dcl error_table_$noentry	fixed bin (35) ext static;
      123   dcl probe_get_$decimal	entry (ptr, fixed bin, fixed bin,
      124 			fixed bin (35));
      125   dcl probe_get_$integer	entry (ptr, fixed bin, fixed bin (35));
      126   dcl probe_get_$line	entry (ptr, ptr, fixed bin, bit (36) aligned,
      127 			fixed bin, fixed bin (35));
      128   dcl probe_get_$pathname	entry (ptr, char (*) varying, fixed bin (35));
      129   dcl probe_get_$object	entry (ptr, ptr, fixed bin (35));
      130   dcl probe_get_$request_list entry (ptr, ptr, fixed bin (21), fixed bin (35))
      131 			;
      132   dcl probe_block_name_	entry (ptr, ptr, bit (1) aligned)
      133 			returns (char (256) varying);
      134   dcl probe_error_		entry options (variable);
      135   dcl probe_line_number_	entry (ptr, 1 aligned like source_info)
      136 			returns (char (64));
      137   dcl probe_pretty_source_info_
      138 			entry (ptr, ptr, char (*));
      139   dcl probe_source_segment_$get_file_ptr
      140 			entry (ptr, ptr, fixed bin) returns (ptr);
      141   dcl probe_source_segment_$list_statement
      142 			entry (ptr, ptr, fixed bin, fixed bin (35));
      143   dcl probe_stack_trace_$where_source_info
      144 			entry (ptr, ptr, fixed bin, char (*));
      145   dcl probe_trace_a_stack_	entry (ptr, ptr, bit (1) aligned);
      146 
      147   dcl cv_dec_		entry (char (*)) returns (fixed bin);
      148   dcl hcs_$fs_get_path_name	entry (ptr, char (*), fixed bin, char (*),
      149 			fixed bin (35));
      150   dcl ioa_$ioa_switch	entry options (variable);
      151   dcl ioa_$rsnnl		entry options (variable);
      152   dcl iox_$attach_name	entry (char (*), ptr, char (*), ptr,
      153 			fixed bin (35));
      154   dcl iox_$close		entry (ptr, fixed bin (35));
      155   dcl iox_$destroy_iocb	entry (ptr, fixed bin (35));
      156   dcl iox_$detach_iocb	entry (ptr, fixed bin (35));
      157   dcl iox_$open		entry (ptr, fixed bin, bit (1) aligned,
      158 			fixed bin (35));
      159   dcl pathname_		entry (char (*), char (*)) returns (char (168));
      160   dcl unique_chars_		entry (bit (*)) returns (char (15));
      161 
      162   dcl (addr, binary, fixed, length, min, null, pointer, rel, rtrim, substr)
      163 			builtin;
      164 SYNTAX_ERROR:			/* general-purpose error exit */
      165   code = probe_et_$syntax_error;
      166 
      167   call probe_error_ (probe_info_ptr, code, probe_info.request_name);
      168   goto MAIN_RETURN;
      169 
      170 
      171 SOME_ERROR:			/* general for error code type errors */
      172   call probe_error_ (probe_info_ptr, code);
      173 				/* never returns */
      174   goto MAIN_RETURN;			/* just in case */
      175 
      176 
      177 MAIN_RETURN:
      178   return;				/* only such exit from this procedure */
      179 
      180 
      181   dcl probe_get_$io_switch	entry (ptr, ptr, fixed bin (35));
      182   dcl (
      183       iox_$user_input,
      184       iox_$user_output,
      185       iox_$error_output,
      186       iox_$user_io
      187       )			ptr external;
      188 
      189   dcl iocb_ptr		pointer;
      190 
      191 input_switch_request:
      192   entry (P_probe_info_ptr);
      193 
      194   /* *	This request sets the IOCB pointer from which probe does input */
      195 
      196 
      197   probe_info_ptr = P_probe_info_ptr;
      198 
      199   if ^probe_info.execute
      200     then goto MAIN_RETURN;
      201 
      202   if probe_info.ct -> token.type < probe_info.end_token then do;
      203 				/* an argument was supplied */
      204       call probe_get_$io_switch (probe_info_ptr, iocb_ptr, code);
      205       if code ^= 0
      206         then goto SOME_ERROR;
      207       call reject_argument ();	/* too many arguments */
      208       if iocb_ptr ^= null ()
      209         then
      210 	   call set_iocb (probe_static_info.input_switch,
      211 	        probe_static_info.private_input_sw,
      212 	        iocb_ptr, NOT_PRIVATE);
      213     end;
      214 
      215     else call set_iocb (probe_static_info.input_switch,
      216 	    probe_static_info.private_input_sw,
      217 	    iox_$user_input, NOT_PRIVATE);
      218 				/* default value */
      219 
      220   probe_info.input_switch = probe_static_info.input_switch;
      221 
      222   goto MAIN_RETURN;
      223 
      224 
      225 
      226 
      227 output_switch_request:
      228   entry (P_probe_info_ptr);
      229 
      230   /* *	This request sets the IOCB pointer to which probe does output */
      231 
      232 
      233   probe_info_ptr = P_probe_info_ptr;
      234 
      235   if ^probe_info.execute
      236     then goto MAIN_RETURN;
      237 
      238   if probe_info.ct -> token.type < probe_info.end_token then do;
      239 				/* an argument was supplied */
      240       call probe_get_$io_switch (probe_info_ptr, iocb_ptr, code);
      241       if code ^= 0
      242         then goto SOME_ERROR;
      243       call reject_argument ();	/* too many arguments */
      244       if iocb_ptr ^= null ()
      245         then
      246 	   call set_iocb (probe_static_info.output_switch,
      247 	        probe_static_info.private_output_sw,
      248 	        iocb_ptr, NOT_PRIVATE);
      249     end;
      250     else call set_iocb (probe_static_info.output_switch,
      251 	    probe_static_info.private_output_sw,
      252 	    iox_$user_output, NOT_PRIVATE);
      253 				/* default value */
      254 
      255   probe_info.output_switch = probe_static_info.output_switch;
      256 
      257   goto MAIN_RETURN;
      258 
      259 input_description_request:
      260   entry (P_probe_info_ptr);
      261 
      262   /* This request creates a new IOCB from an attach description and sets the switch for reading input */
      263 
      264   probe_info_ptr = P_probe_info_ptr;
      265 
      266   if ^probe_info.execute
      267     then goto MAIN_RETURN;
      268 
      269   if probe_info.ct -> token.type >= probe_info.end_token
      270     then
      271          call probe_error_ (probe_info_ptr, 0,
      272 	    "Usage: input_description attach_description");
      273 
      274   call rest_of_request (attach_description);
      275 
      276   call iox_$attach_name ("probe_input." || unique_chars_ ("0"b), iocb_ptr,
      277        (attach_description), null, code);
      278   if code ^= 0
      279     then call probe_error_ (probe_info_ptr, code, "^a", attach_description);
      280   call iox_$open (iocb_ptr, STREAM_INPUT, "0"b, code);
      281   if code ^= 0 then do;
      282       call iox_$detach_iocb (iocb_ptr, (0));
      283       call probe_error_ (probe_info_ptr, code,
      284 	 "Unable to open switch for reading.");
      285     end;
      286 
      287   call set_iocb (probe_static_info.input_switch,
      288        probe_static_info.private_input_sw,
      289        iocb_ptr, PRIVATE);
      290 
      291   probe_info.input_switch = probe_static_info.input_switch;
      292 
      293   go to MAIN_RETURN;
      294 
      295 output_description_request:
      296   entry (P_probe_info_ptr);
      297 
      298   /* Creates an IOCB from an attach description and sets the switch for printing output */
      299 
      300   probe_info_ptr = P_probe_info_ptr;
      301 
      302   if ^probe_info.execute
      303     then goto MAIN_RETURN;
      304 
      305   if probe_info.ct -> token.type >= probe_info.end_token
      306     then
      307          call probe_error_ (probe_info_ptr, (0),
      308 	    "Usage: output_description attach_description");
      309 
      310   call rest_of_request (attach_description);
      311 
      312   call iox_$attach_name ("probe_output." || unique_chars_ ("0"b), iocb_ptr,
      313        (attach_description), null, code);
      314   if code ^= 0
      315     then call probe_error_ (probe_info_ptr, code, "^a", attach_description);
      316   call iox_$open (iocb_ptr, STREAM_OUTPUT, "0"b, code);
      317   if code ^= 0 then do;
      318       call iox_$detach_iocb (iocb_ptr, (0));
      319       call probe_error_ (probe_info_ptr, code,
      320 	 "Unable to open switch for writing.");
      321     end;
      322 
      323   call set_iocb (probe_static_info.output_switch,
      324        probe_static_info.private_output_sw,
      325        iocb_ptr, PRIVATE);
      326 
      327   probe_info.output_switch = probe_static_info.output_switch;
      328 
      329   go to MAIN_RETURN;
      330 
      331 args_request:
      332   entry (P_probe_info_ptr);
      333 
      334   dcl block_name		char (256) varying;
      335   dcl probe_print_arglist_	entry (ptr, ptr);
      336 
      337   probe_info_ptr = P_probe_info_ptr;
      338 
      339   if probe_info.execute then do;
      340       if probe_info.ct -> token.type >= probe_info.end_token
      341         then source_ptr = probe_info.ptr_to_current_source;
      342 
      343         else do;
      344 	call probe_trace_a_stack_
      345 	     (probe_info_ptr,
      346 	     probe_info.current_stack_frame -> stack_frame.prev_sp, "1"b);
      347 
      348 	lfp = stack_info.level_chain;
      349 	if probe_info.ct -> token.type = CONSTANT_TYPE then do;
      350 				/* args for frame number N */
      351 	    if probe_info.ct -> constant.scale ^= 0
      352 	      then
      353 		 call probe_get_$decimal (probe_info_ptr, frame_number,
      354 		      frame_decimal, code);
      355 	      else do;
      356 	        call probe_get_$integer (probe_info_ptr, frame_number, code)
      357 		   ;
      358 	        frame_decimal = 0;
      359 	      end;
      360 	    if code ^= 0
      361 	      then call probe_error_ (probe_info_ptr, code);
      362 	    if frame_number > stack_info.max_level | frame_number = 0
      363 	      then
      364 NO_FRAME:
      365 	        call probe_error_ (probe_info_ptr, 0,
      366 		   "No frame number ^d^[.^d^]",
      367 		   frame_number, frame_decimal ^= 0, frame_decimal);
      368 
      369 	    do while (level_frame.printed_number ^= frame_number |
      370 	         level_frame.printed_decimal ^= frame_decimal);
      371 	      lfp = level_frame.next;
      372 	      if lfp = null
      373 	        then go to NO_FRAME;
      374 	    end;
      375 	    source_ptr = addr (level_frame.source_info);
      376 	  end;
      377 	else if probe_info.ct -> token.type = NAME_TYPE then do;
      378 	    source_ptr = null;
      379 	    do while (source_ptr = null);
      380 
      381 	      block_name =
      382 		 probe_block_name_ (probe_info_ptr,
      383 		 addr (level_frame.source_info), "0"b);
      384 
      385 	      if block_name = current_identifier_name
      386 	        then
      387 		   source_ptr = addr (level_frame.source_info);
      388 	      else if level_frame.next = null
      389 	        then call probe_error_
      390 		        (probe_info_ptr, 0, "No frame for ^a",
      391 		        current_identifier_name);
      392 	      else lfp = level_frame.next;
      393 	    end;
      394 	  end;
      395 
      396 	else go to SYNTAX_ERROR;
      397         end;
      398 
      399       call probe_print_arglist_ (probe_info_ptr, source_ptr);
      400     end;
      401   goto MAIN_RETURN;
      402 
      403 handlers_request:
      404   entry (P_probe_info_ptr);
      405 
      406   dcl probe_print_handlers_	entry (ptr, ptr);
      407   dcl token_type		bit (18);
      408   dcl token_name		char (168);
      409 
      410   probe_info_ptr = P_probe_info_ptr;
      411 
      412   if probe_info.execute then do;
      413 
      414       token_type = probe_info.ct -> token.type;
      415       if token_type = NAME_TYPE
      416         then token_name = current_identifier_name;
      417 
      418       if probe_info.ct -> token.type >= probe_info.end_token then do;
      419 	source_ptr = probe_info.ptr_to_current_source;
      420 	if source_ptr -> source_info.stack_ptr = null then do;
      421 	    token_type = NAME_TYPE;
      422 	    token_name =
      423 	         source_ptr -> source_info.seg_info_ptr
      424 	         -> seg_info.entry_name;
      425 	    go to FIND_FRAME;
      426 	  end;
      427         end;
      428 
      429         else do;
      430 FIND_FRAME:
      431 	call probe_trace_a_stack_
      432 	     (probe_info_ptr,
      433 	     probe_info.current_stack_frame -> stack_frame.prev_sp, "0"b);
      434 
      435 	lfp = stack_info.level_chain;
      436 	if token_type = CONSTANT_TYPE then do;
      437 				/* args for frame number N */
      438 	    call probe_get_$integer (probe_info_ptr, frame_number, code);
      439 	    if code ^= 0
      440 	      then call probe_error_ (probe_info_ptr, code);
      441 	    if frame_number > stack_info.max_level | frame_number = 0
      442 	      then
      443 		 call probe_error_ (probe_info_ptr, 0,
      444 		      "No frame number ^d", frame_number);
      445 
      446 	    do while (level_frame.printed_number ^= frame_number
      447 	         | level_frame.printed_decimal ^= 0);
      448 	      lfp = level_frame.next;
      449 	    end;
      450 	    source_ptr = addr (level_frame.source_info);
      451 	  end;
      452 	else if token_type = NAME_TYPE then do;
      453 	    source_ptr = null;
      454 	    do while (source_ptr = null);
      455 
      456 	      block_name =
      457 		 probe_block_name_ (probe_info_ptr,
      458 		 addr (level_frame.source_info), "0"b);
      459 
      460 	      if block_name = token_name
      461 	        then
      462 		   source_ptr = addr (level_frame.source_info);
      463 	      else if level_frame.next = null
      464 	        then call probe_error_
      465 		        (probe_info_ptr, 0, "No frame for ^a",
      466 		        current_identifier_name);
      467 	      else lfp = level_frame.next;
      468 	    end;
      469 	  end;
      470 
      471 	else go to SYNTAX_ERROR;
      472         end;
      473 
      474       call probe_print_handlers_ (probe_info_ptr, source_ptr);
      475     end;
      476   goto MAIN_RETURN;
      477 
      478 execute_request:
      479   entry (P_probe_info_ptr);
      480 
      481   /* *	This is used to execute Multics commands from within probe, primarily
      482*   *	within probe breakpoints. Its syntax is considerably more restrictive
      483*   *	than necessary, and this will be fixed someday soon */
      484 
      485   dcl command_line_lth	fixed bin (21);
      486   dcl cu_$cp		entry (pointer, fixed bin (21), fixed bin (35));
      487 
      488   dcl command_line_ptr	pointer;
      489 
      490 
      491   probe_info_ptr = P_probe_info_ptr;
      492 
      493   call require_argument ();
      494 
      495   if probe_info.ct -> token.type ^= CONSTANT_TYPE
      496     then
      497          call probe_error_ (probe_info_ptr, probe_et_$e_syntax_err);
      498 
      499   if probe_info.ct -> constant.data_type ^= char_dtype * 2
      500     then
      501          call probe_error_ (probe_info_ptr, probe_et_$e_syntax_err);
      502 
      503   command_line_ptr = probe_info.ct -> constant.data_ptr;
      504   command_line_lth = probe_info.ct -> constant.scale_and_precision;
      505 
      506   call bump_ct ();			/* get the next token */
      507   call reject_argument ();		/* only one string at a time */
      508 
      509   if probe_info.execute
      510     then /* give it to Multics */
      511          call cu_$cp (command_line_ptr, command_line_lth, (0));
      512 
      513   goto MAIN_RETURN;			/* end of code for execute request */
      514 
      515 
      516 
      517 source_request:
      518   entry (P_probe_info_ptr);
      519 
      520   /* *	The source request prints source lines from the program, and can
      521*   *	also be used to specify a pathname to look for the source. */
      522 
      523   dcl number_to_print	fixed bin;
      524   dcl source_dname		char (168);
      525   dcl source_ename		char (32);
      526   dcl source_seg_ptr	pointer;
      527   dcl expand_pathname_	entry (char (*), char (*), char (*),
      528 			fixed bin (35));
      529   dcl hcs_$initiate		entry (char (*), char (*), char (*),
      530 			fixed bin (1), fixed bin (2), pointer,
      531 			fixed bin (35));
      532 
      533 
      534   probe_info_ptr = P_probe_info_ptr;
      535 
      536   if probe_info.ct -> token.type ^= NAME_TYPE then do;
      537       if probe_info.ct -> token.type >= probe_info.end_token
      538         then /* nothing specified, print one line */
      539 	   number_to_print = 1;
      540 
      541       else if probe_info.ct -> token.type = CONSTANT_TYPE then do;
      542 				/* print N lines */
      543 	call probe_get_$integer (probe_info_ptr, number_to_print, code);
      544 	if code ^= 0
      545 	  then goto SOME_ERROR;
      546 	call reject_argument ();	/* can have at most one number */
      547 	if number_to_print < 0
      548 	  then /* and can only print a positive number */
      549 	       call probe_error_ (probe_info_ptr, 0,
      550 		  "Number of source lines to print must be positive.");
      551         end;
      552 
      553       else goto SYNTAX_ERROR;		/* wrong kind of token here */
      554 
      555       if probe_info.execute then do;	/* do it, if we're supposed to */
      556 	call probe_source_segment_$list_statement
      557 	     (probe_info_ptr, addr (current_source), number_to_print, code);
      558 	if code ^= 0
      559 	  then goto SOME_ERROR;
      560         end;
      561     end;
      562 
      563     else do;			/* otherwise, hope it's "source path" */
      564       if current_identifier_name ^= "path"
      565         then goto SYNTAX_ERROR;
      566       call bump_ct ();
      567       call require_argument ();
      568 
      569       call probe_get_$pathname (probe_info_ptr, pathname, code);
      570       if code ^= 0
      571         then goto SOME_ERROR;
      572 
      573       call reject_argument ();	/* can't have anything following the pathname */
      574 
      575       call expand_pathname_ ((pathname), source_dname, source_ename, code);
      576       if code ^= 0
      577         then call probe_error_ (probe_info_ptr, code, "^a", pathname);
      578 
      579       call hcs_$initiate (source_dname, source_ename, "", 0, 0,
      580 	 source_seg_ptr, code);
      581       if source_seg_ptr = null ()
      582         then
      583 	   call probe_error_ (probe_info_ptr, code, "^a>^a", source_dname,
      584 	        source_ename);
      585 
      586       if probe_info.execute
      587         then /* set the pointer in seg_info so we'll remember later */
      588 	   current_source.seg_info_ptr -> seg_info.file_pointers (1) =
      589 	        source_seg_ptr;
      590 
      591     end;				/* of code for "source path" */
      592   goto MAIN_RETURN;			/* end of code for source request */
      593 
      594 
      595 object_request:
      596   entry (P_probe_info_ptr);
      597 
      598 
      599   /* Say "object {N}" to print N or 1 stmt's worth of object code. */
      600 
      601   dcl seg_info_ptr		ptr;
      602   dcl start_offset		fixed bin (21);
      603   dcl (i, len)		fixed bin;
      604 
      605   probe_info_ptr = P_probe_info_ptr;
      606 
      607   if probe_info.ct -> token.type >= probe_info.end_token
      608     then number_to_print = 1;
      609     else do;
      610       call probe_get_$integer (probe_info_ptr, number_to_print, code);
      611       if code ^= 0
      612         then go to SOME_ERROR;
      613     end;
      614 
      615   seg_info_ptr = current_source.seg_info_ptr;
      616   if seg_info_ptr = null then do;
      617       code = probe_et_$bad_line;
      618       go to SOME_ERROR;
      619     end;
      620   stmt_map_ptr = seg_info_ptr -> seg_info.statement_map_ptr;
      621   if stmt_map_ptr = null then do;
      622       code = probe_et_$no_statement_map;
      623       go to SOME_ERROR;
      624     end;
      625 
      626   map_size = seg_info_ptr -> seg_info.map_size;
      627 
      628   new_source_info = current_source;
      629 
      630   do i = current_source.stmnt_map_entry_index to min (map_size,
      631        current_source.stmnt_map_entry_index + number_to_print - 1);
      632 
      633     call print_object (i);
      634   end;
      635   goto MAIN_RETURN;
      636 
      637 
      638 print_object:
      639   proc (P_i);
      640 
      641   /* Prints source line followed by the instructions for it */
      642 
      643   dcl P_i			fixed bin;
      644 
      645   new_source_info.stmnt_map_entry_index = P_i;
      646 
      647   call probe_source_segment_$list_statement (probe_info_ptr,
      648        addr (new_source_info), 1, code);
      649 
      650   /* Any problems? */
      651   if code ^= 0 then do;
      652 				/* If we couldn't find the source print a warning, but print the object anyway */
      653       if code = error_table_$noentry then do;
      654 	call probe_error_$warning (probe_info_ptr, code);
      655 	code = 0;
      656         end;
      657         else go to SOME_ERROR;
      658     end;
      659 
      660   start_offset = fixed (map_array (P_i).location);
      661   if P_i >= map_size
      662     then len = 1;
      663     else len = fixed (map_array (P_i + 1).location) - start_offset;
      664 
      665   call probe_break_mgr_$print_instructions (probe_info_ptr,
      666        addr (new_source_info),
      667        pointer (current_source.instruction_ptr, map_array (P_i).location),
      668        len);
      669 
      670   end print_object;
      671 
      672 position_request:
      673   entry (P_probe_info_ptr);
      674 
      675 
      676   /* Both "position" and "use"
      677*
      678*   we accept:
      679*
      680*   +N
      681*   -N
      682*   level N
      683*   STRING
      684*   < STRING
      685*   LINE
      686*   PROCEDURE
      687*
      688**/
      689   dcl print_it		bit (1) aligned;
      690 				/* are we "ps" or "use" */
      691   dcl (use_level, use_decimal)
      692 			fixed bin;
      693   dcl line_invocation	fixed bin;
      694   dcl number_to_position	fixed bin;
      695   dcl position_lines	bit (1) aligned;
      696   dcl position_backwards	bit (1) aligned;
      697   dcl rel_level_sw		bit (1) aligned;
      698   dcl hp			ptr;
      699   dcl (loc, next_token_type)	bit (18);
      700 
      701   dcl probe_source_segment_$position_source
      702 			entry (ptr, ptr, fixed bin, fixed bin (35));
      703   dcl probe_source_segment_$position_source_lines
      704 			entry (ptr, ptr, fixed bin, fixed bin (35));
      705   dcl probe_source_segment_$find_source
      706 			entry (ptr, ptr, char (*), fixed bin (35));
      707   dcl probe_stack_trace_$current_level
      708 			entry (ptr) returns (fixed bin);
      709   dcl probe_stack_trace_$get_level
      710 			entry (ptr, ptr, fixed bin, fixed bin);
      711 
      712   print_it = "1"b;
      713   goto ps_use_com;
      714 
      715 
      716 use_request:
      717   entry (P_probe_info_ptr);
      718 
      719 
      720   print_it = "0"b;
      721   goto ps_use_com;
      722 
      723 ps_use_com:
      724   probe_info_ptr = P_probe_info_ptr;
      725 
      726   code = 0;			/* assume we will win */
      727   position_lines, position_backwards = "0"b;
      728 
      729   if probe_info.ct -> operator.type >= probe_info.end_token then do;
      730 				/* if no args, return to where we began */
      731       new_source_info = initial_source;
      732       if new_source_info.instruction_ptr = null
      733 	 & new_source_info.seg_info_ptr ^= null then do;
      734 	stmt_map_ptr =
      735 	     new_source_info.seg_info_ptr -> seg_info.statement_map_ptr;
      736 	if stmt_map_ptr ^= null then do;
      737 	    loc = map_array (new_source_info.stmnt_map_entry_index)
      738 	         .location;
      739 	    hp = new_source_info.seg_info_ptr -> seg_info.symbol_header_ptr;
      740 	    new_source_info.instruction_ptr = pointer (hp, loc);
      741 	  end;
      742         end;
      743       go to GOT_LOCATION;
      744     end;
      745 
      746   next_token_type = probe_info.ct -> token.next -> token.type;
      747 
      748   if probe_info.ct -> operator.type = MINUS
      749        | probe_info.ct -> operator.type = PLUS then do;
      750 POSITION_REL:
      751       if probe_info.ct -> operator.type = MINUS
      752         then
      753 	   position_backwards = "1"b;
      754 
      755       call bump_ct ();
      756       if probe_info.ct -> token.type ^= CONSTANT_TYPE
      757         then
      758 	   goto SYNTAX_ERROR;
      759 
      760       call probe_get_$integer (probe_info_ptr, number_to_position, code);
      761       if code ^= 0
      762         then goto SOME_ERROR;
      763 
      764       if probe_info.ct -> token.type = NAME_TYPE
      765         then
      766 	   if current_identifier_name = "line"
      767 	        | current_identifier_name = "lines" then do;
      768 	       position_lines = "1"b;
      769 	       call bump_ct ();
      770 	     end;
      771 
      772       call reject_argument ();
      773 
      774       if position_backwards
      775         then number_to_position = -number_to_position;
      776 				/* negate it */
      777 
      778       if probe_info.execute then do;
      779 	new_source_info = current_source;
      780 				/* all the same, except for statement # */
      781 	if position_lines
      782 	  then call probe_source_segment_$position_source_lines
      783 		  (probe_info_ptr, addr (new_source_info),
      784 		  number_to_position, code);
      785 
      786 	  else call probe_source_segment_$position_source
      787 		  (probe_info_ptr, addr (new_source_info),
      788 		  number_to_position, code);
      789         end;
      790     end;
      791 
      792 
      793   else if probe_info.ct -> token.type = CONSTANT_TYPE /* a string */
      794        & probe_info.ct -> constant.data_type = (char_dtype * 2) then do;
      795       call reject_next_argument ();	/* make sure theres nothing more */
      796 
      797       if probe_info.execute then do;
      798 	new_source_info = current_source;
      799 	call probe_source_segment_$find_source
      800 	     (probe_info_ptr, addr (new_source_info), constant_string, code)
      801 	     ;
      802         end;
      803 
      804       call bump_ct ();		/* keep syntax happy */
      805     end;
      806 
      807   else if probe_info.ct -> token.type = LESS_THAN &
      808        probe_info.ct -> token.next -> constant.data_type = (char_dtype * 2)
      809     then do;
      810 				/* < STRING search */
      811       probe_info.ct = probe_info.ct -> token.next;
      812 
      813       call reject_next_argument;
      814 
      815       call probe_error_ (probe_info_ptr, probe_et_$unimplemented_request,
      816 	 "backwards searching for STRING");
      817 
      818       if probe_info.execute
      819         then do;
      820 	new_source_info = current_source;
      821 				/* start from here */
      822 
      823 	/* add code ere someday */
      824 
      825         end;
      826 
      827       call bump_ct ();
      828 
      829     end;				/* < STRING */
      830 
      831   else if probe_info.ct -> token.type = NAME_TYPE &
      832        (next_token_type = CONSTANT_TYPE | next_token_type = MINUS
      833        | next_token_type = PLUS) then do;
      834       if current_identifier_name = "line" | current_identifier_name = "lines"
      835         then do;
      836 	position_lines = "1"b;
      837 
      838 	call bump_ct ();
      839 	if probe_info.ct -> operator.type = MINUS
      840 	     | probe_info.ct -> operator.type = PLUS
      841 	  then
      842 	       go to POSITION_REL;
      843 	  else go to POSITION_LINE;
      844         end;
      845 
      846       else if current_identifier_name = "level"
      847 	 | current_identifier_name = "lvl" |
      848 	 current_identifier_name = "lv" then do;
      849 
      850 	if next_token_type = MINUS | next_token_type = PLUS then do;
      851 	    rel_level_sw = "1"b;
      852 	    position_backwards = (next_token_type = MINUS);
      853 
      854 	    call bump_ct ();
      855 	    if probe_info.ct -> token.next -> token.type ^= CONSTANT_TYPE
      856 	      then go to SYNTAX_ERROR;
      857 	  end;
      858 	  else rel_level_sw = "0"b;
      859 
      860 	call bump_ct ();
      861 	call reject_next_argument;
      862 
      863 	if probe_info.ct -> constant.scale ^= 0 & ^rel_level_sw
      864 	  then
      865 	       call probe_get_$decimal (probe_info_ptr, use_level,
      866 		  use_decimal, code);
      867 	  else do;
      868 	    call probe_get_$integer (probe_info_ptr, use_level, code);
      869 	    use_decimal = 0;
      870 	  end;
      871 	if code ^= 0
      872 	  then goto SOME_ERROR;
      873 
      874 	if probe_info.execute then do;
      875 
      876 	    if rel_level_sw then do;
      877 	        if position_backwards
      878 		then use_level = -use_level;
      879 
      880 	        use_level =
      881 		   probe_stack_trace_$current_level (probe_info_ptr)
      882 		   + use_level;
      883 	      end;
      884 
      885 	    call probe_stack_trace_$get_level (probe_info_ptr,
      886 	         addr (new_source_info),
      887 	         use_level, use_decimal);
      888 	  end;
      889         end;
      890 
      891       else go to SYNTAX_ERROR;
      892     end;				/* level N */
      893 
      894   else /* LINE or PROCEDURE */
      895 POSITION_LINE:
      896     call get_location ();
      897 GOT_LOCATION:
      898   call reject_argument ();
      899 
      900   /* Now the Syntax is known good */
      901 
      902   /* *	If executing, new_source_info is set, so assign it to current_source.
      903*   *	code is 0 unless search failed, so print if appropriate */
      904 
      905   if probe_info.execute then do;	/* print the new one, if desired */
      906       if code = 0 then do;		/* it worked. code was left set by all paths above */
      907 
      908 	probe_info.language_type =
      909 	     new_source_info.seg_info_ptr -> seg_info.language_type;
      910 	current_source = new_source_info;
      911 
      912 	/* in old probe this was also controlled by "mode brief" */
      913 
      914 	if print_it
      915 	  then call probe_source_segment_$list_statement (probe_info_ptr,
      916 		  addr (current_source), 1, code);
      917 	if code ^= 0
      918 	  then goto SOME_ERROR;
      919         end;
      920 
      921         else call probe_error_ (probe_info_ptr, code);
      922 				/* lose, otherwise */
      923     end;
      924   goto MAIN_RETURN;			/* end of code for position request */
      925 
      926 
      927 get_location:
      928   proc;				/* also used by reset/status */
      929 
      930   if resembles_path ()
      931     then do;
      932       call probe_get_$object (probe_info_ptr, addr (new_source_info), code);
      933       data_type_found = ext_procedure_runtime_dtype;
      934     end;
      935     else do;
      936       call probe_get_$line (probe_info_ptr, addr (new_source_info),
      937 	 line_invocation, "1110"b, data_type_found, code);
      938     end;
      939   if code ^= 0
      940     then goto SOME_ERROR;
      941   return;
      942 
      943 
      944 resembles_path:
      945   proc () returns (bit (1) aligned);
      946 
      947   if probe_info.ct -> token.type = LESS_THAN |
      948        probe_info.ct -> token.type = GREATER_THAN
      949     then return ("1"b);
      950   if probe_info.ct -> token.type = NAME_TYPE &
      951        probe_info.ct -> token.next -> token.type = GREATER_THAN
      952     then return ("1"b);
      953   return ("0"b);
      954   end resembles_path;
      955   end get_location;
      956 
      957 
      958 where_request:
      959   entry (P_probe_info_ptr);
      960 
      961   /* *	This prints out information about the current values of the pointers */
      962 
      963 
      964   dcl 1 want_locs		aligned,
      965        2 source		bit (1) unal,
      966        2 control		bit (1) unal,
      967        2 path		bit (1) unal;
      968   dcl location_string	char (256);
      969   dcl dn			char (168);
      970   dcl (en, proc_name)	char (32);
      971   dcl dn_len		fixed bin;
      972   dcl sip			ptr;
      973 
      974   probe_info_ptr = P_probe_info_ptr;
      975 
      976   want_locs = "0"b;
      977 
      978   if probe_info.ct -> token.type >= probe_info.end_token
      979     then /* if none specified, print them all */
      980          want_locs.source, want_locs.control = "1"b;
      981 
      982     else
      983       do while (probe_info.ct -> token.type < probe_info.end_token);
      984 				/* otherwise, look for good keywords */
      985       if probe_info.ct -> token.type ^= NAME_TYPE
      986         then goto WHERE_USAGE;
      987 
      988       if current_identifier_name = "source" | current_identifier_name = "sc" |
      989 	 current_identifier_name = "block" | current_identifier_name = "bk"
      990 				/* allow old forms for a while */
      991         then want_locs.source = "1"b;
      992       else if current_identifier_name = "control"
      993 	 | current_identifier_name = "ctl" |
      994 	 current_identifier_name = "object"
      995 	 | current_identifier_name = "obj" |
      996 	 current_identifier_name = "oj"
      997         then want_locs.control = "1"b;
      998       else if current_identifier_name = "path"
      999         then want_locs.path = "1"b;
     1000       else goto WHERE_USAGE;
     1001 
     1002       call bump_ct ();		/* look at the next token */
     1003     end;
     1004 
     1005   if ^want_locs.source & ^want_locs.control
     1006     then want_locs.source, want_locs.control = "1"b;
     1007 				/* default */
     1008 
     1009   if ^probe_info.execute
     1010     then goto MAIN_RETURN;
     1011 
     1012   if want_locs.source then do;
     1013       if want_locs.path then do;
     1014 	source_ptr = probe_source_segment_$get_file_ptr
     1015 	     (probe_info_ptr, probe_info.ptr_to_current_source, 1);
     1016 	call hcs_$fs_get_path_name (source_ptr, dn, dn_len, en, code);
     1017 	if code ^= 0 then do;
     1018 	    call probe_error_ (probe_info_ptr, code,
     1019 	         "Evaluating source pointer.");
     1020 	    goto MAIN_RETURN;
     1021 	  end;
     1022 	location_string = pathname_ (substr (dn, 1, dn_len), en);
     1023         end;
     1024         else call probe_pretty_source_info_ (probe_info_ptr,
     1025 	        probe_info.ptr_to_current_source, location_string);
     1026       call ioa_$ioa_switch (probe_info.output_switch, "^a", location_string);
     1027     end;
     1028 
     1029   if want_locs.control then do;
     1030 
     1031       call probe_stack_trace_$where_source_info (probe_info_ptr,
     1032 	 probe_info.ptr_to_initial_source, level, "");
     1033       call ioa_$rsnnl ("^[(level ^d)^;^s(no active frame)^]",
     1034 	 level_string, length (level_string), level >= 0, level);
     1035 
     1036       if want_locs.path then do;	/* "where object path" */
     1037 	sip = current_source.seg_info_ptr;
     1038 	location_string =
     1039 	     pathname_ (sip -> seg_info.directory_name,
     1040 	     sip -> seg_info.entry_name);
     1041 	proc_name = sip -> seg_info.segname;
     1042 	if proc_name ^= sip -> seg_info.entry_name
     1043 	  then /* bound component */
     1044 	       location_string =
     1045 		  rtrim (sip -> seg_info.segname) || " in "
     1046 		  || location_string;
     1047 	call ioa_$ioa_switch (probe_info.output_switch, "^a ^a",
     1048 	     location_string, level_string);
     1049         end;
     1050       else if initial_source.seg_info_ptr -> seg_info.statement_map_ptr
     1051 	 ^= null
     1052         then
     1053 	   call ioa_$ioa_switch (probe_info.output_switch,
     1054 	        "Control at ^a of ^a ^a",
     1055 	        probe_line_number_ (probe_info_ptr, initial_source),
     1056 	        probe_block_name_ (probe_info_ptr,
     1057 	        probe_info.ptr_to_initial_source, "0"b), level_string);
     1058       else call ioa_$ioa_switch (probe_info.output_switch,
     1059 	      "Control at ^a|^o. ^a",
     1060 	      probe_block_name_ (probe_info_ptr,
     1061 	      probe_info.ptr_to_initial_source, "0"b),
     1062 	      binary (rel (initial_source.instruction_ptr), 18, 0),
     1063 	      level_string);
     1064     end;
     1065 
     1066   goto MAIN_RETURN;
     1067 
     1068 WHERE_USAGE:
     1069   call probe_error_ (probe_info_ptr, 0,
     1070        "Only the keywords ""source"", ""control"" or ""object"", and ""path"" are allowed."
     1071        );
     1072   goto MAIN_RETURN;			/* end of code for where request */
     1073 
     1074 
     1075 
     1076 reset_request:
     1077   entry (P_probe_info_ptr);
     1078 
     1079   reset_req = "1"b;
     1080   goto S_R_COM;
     1081 
     1082 
     1083 status_request:
     1084   entry (P_probe_info_ptr);
     1085 
     1086   reset_req = "0"b;
     1087   goto S_R_COM;
     1088   dcl reset_req		bit (1) aligned;
     1089 				/* as distinct from source req */
     1090   dcl long_sw		bit (1) aligned;
     1091   dcl case		fixed bin;
     1092   dcl data_type_found	fixed bin;/* LINE: what kind did you find ? */
     1093   dcl mod_type		fixed bin;
     1094   dcl ctl			char (64) varying;
     1095 
     1096 
     1097   dcl probe_listen_$check_line
     1098 			entry (ptr, ptr, fixed bin (21), fixed bin (35))
     1099 			;
     1100   dcl probe_break_mgr_$reset_break_at_line
     1101 			entry (ptr, ptr, fixed bin, bit (1) aligned,
     1102 			fixed bin (35));
     1103   dcl probe_break_mgr_$reset_breaks_in_seg
     1104 			entry (ptr, ptr, bit (1) aligned,
     1105 			fixed bin (35));
     1106   dcl probe_break_mgr_$reset_breaks_in_world
     1107 			entry (ptr, bit (1) aligned, fixed bin (35));
     1108 
     1109   dcl probe_break_mgr_$list_breaks_at_line
     1110 			entry (ptr, ptr, fixed bin, bit (1) aligned,
     1111 			fixed bin (35));
     1112   dcl probe_break_mgr_$list_breaks_in_seg
     1113 			entry (ptr, ptr, bit (1) aligned,
     1114 			fixed bin (35));
     1115   dcl probe_break_mgr_$list_breaks_in_world
     1116 			entry (ptr, bit (1) aligned, fixed bin (35));
     1117   dcl probe_break_mgr_$list_broken_segs
     1118 			entry (ptr, fixed bin (35));
     1119 
     1120   dcl (
     1121       DEFAULT_CASE		init (1), /* nothing */
     1122       WORLD_CASE		init (2), /* -all */
     1123       LINE_CASE		init (3), /* LINE */
     1124       SEG_CASE		init (4), /* OBJECT */
     1125       STAR_CASE		init (5), /* * */
     1126       STRING_CASE		init (6)	/* STRING */
     1127       )			fixed bin internal static options (constant);
     1128 
     1129 
     1130   dcl probe_get_$control_arg	entry (ptr, char (64) varying, fixed bin (35));
     1131 
     1132 
     1133 S_R_COM:
     1134 
     1135   probe_info_ptr = P_probe_info_ptr;
     1136 
     1137   /* Now to parse */
     1138 
     1139   call probe_get_$control_arg (probe_info_ptr, ctl, code);
     1140   if code ^= 0
     1141     then goto SOME_ERROR;
     1142 
     1143   if ctl = "brief" | ctl = "bf" then do;
     1144       case = DEFAULT_CASE;
     1145       long_sw = "0"b;
     1146     end;
     1147   else if ctl = "long" | ctl = "lg" then do;
     1148       case = DEFAULT_CASE;
     1149       long_sw = "1"b;
     1150     end;
     1151   else do;			/* ctl may be null or supplied - we shall see */
     1152     if ctl = "all" | ctl = "a"
     1153       then case = WORLD_CASE;
     1154     else if ctl ^= ""		/* some other ctl arg, yechh ! */
     1155       then call probe_error_ (probe_info_ptr, probe_et_$bad_ctl_arg,
     1156 	      "-" || ctl);
     1157     else if probe_info.ct -> token.type >= probe_info.end_token
     1158       then case = DEFAULT_CASE;
     1159     else if probe_info.ct -> token.type = TIMES
     1160          | probe_info.ct -> token.type = C_INDIRECTION then do;
     1161         call bump_ct ();		/* past * */
     1162         case = STAR_CASE;
     1163       end;
     1164     else if probe_info.ct -> token.type = CONSTANT_TYPE &
     1165          probe_info.ct -> constant.data_type = (char_dtype * 2) then do;
     1166         case = STRING_CASE;
     1167         mod_type = BREAK_AT;
     1168         search_string = constant_string;
     1169 
     1170         call bump_ct ();
     1171       end;
     1172 
     1173     else do;			/* it must be LINE or OBJECT */
     1174 
     1175       /* if a LINE MOD is there, it must be a line */
     1176 
     1177       mod_type = -1;		/* no such type */
     1178       if probe_info.ct -> token.type = NAME_TYPE
     1179         then if current_identifier_name = "after" |
     1180 	        current_identifier_name = "af" |
     1181 	        current_identifier_name = "a"
     1182 	     then do;
     1183 	       call bump_ct ();
     1184 	       mod_type = BREAK_AFTER;
     1185 	     end;
     1186 	   else if current_identifier_name = "before" |
     1187 	        current_identifier_name = "be" |
     1188 	        current_identifier_name = "b"
     1189 	     then do;
     1190 	       call bump_ct ();
     1191 	       mod_type = BREAK_BEFORE;
     1192 	     end;
     1193 	   else if current_identifier_name = "at"
     1194 	     then do;
     1195 	       call bump_ct ();
     1196 	       mod_type = BREAK_AT;
     1197 	     end;
     1198 
     1199       call get_location ();		/* much LINE and OBJECT */
     1200       if data_type_found = ext_procedure_runtime_dtype |
     1201 	 data_type_found = ext_entry_runtime_dtype
     1202         then do;
     1203 	case = SEG_CASE;
     1204 	if mod_type >= 0
     1205 	  then
     1206 	       call probe_error_ (probe_info_ptr, 0,
     1207 		  """^a"" not allowed before external procedure.",
     1208 		  PLACE (mod_type));
     1209         end;
     1210         else do;
     1211 	case = LINE_CASE;
     1212 	if mod_type < 0
     1213 	  then mod_type = BREAK_AT;
     1214         end;
     1215     end;				/* parsing LINE or PROC */
     1216 
     1217 
     1218     call probe_get_$control_arg (probe_info_ptr, ctl, code);
     1219   end;
     1220   if code ^= 0
     1221     then goto SOME_ERROR;
     1222 
     1223   call reject_argument ();
     1224 
     1225   /* all parsing done - but must examine ctl */
     1226 
     1227   if reset_req
     1228     then long_sw = "1"b;		/* default */
     1229   else if case = LINE_CASE
     1230     then long_sw = "1"b;
     1231   else long_sw = "0"b;
     1232 
     1233   if ctl = "long" | ctl = "lg"
     1234     then long_sw = "1"b;
     1235   else if ctl = "brief" | ctl = "bf"
     1236     then long_sw = "0"b;
     1237   else if ctl ^= ""
     1238     then call probe_error_ (probe_info_ptr, probe_et_$bad_ctl_arg, "-" || ctl)
     1239 	    ;
     1240 
     1241   /* SYNTAX IS NOW KNOWN TO BE GOOD */
     1242 
     1243   if probe_info.execute
     1244     then if reset_req
     1245 	 then do;
     1246 	   if case = DEFAULT_CASE
     1247 	     then if probe_info.break_slot_ptr = null ()
     1248 		  then call probe_error_ (probe_info_ptr,
     1249 			  probe_et_$none_active);
     1250 		  else do;
     1251 		    new_source_info = initial_source;
     1252 		    call probe_break_mgr_$reset_break_at_line (
     1253 		         probe_info_ptr, addr (initial_source),
     1254 		         probe_info.break_slot_ptr -> break_slot.type,
     1255 		         long_sw, code);
     1256 		  end;
     1257 	   else if case = WORLD_CASE | case = STAR_CASE
     1258 	     then call probe_break_mgr_$reset_breaks_in_world
     1259 		     (probe_info_ptr, long_sw, code);
     1260 	   else if case = STRING_CASE then do;
     1261 				/* r STRING: reset all matches */
     1262 	       new_source_info = current_source;
     1263 
     1264 	       call probe_source_segment_$find_source
     1265 		  (probe_info_ptr, addr (new_source_info),
     1266 		  (search_string), code);
     1267 	       if code ^= 0
     1268 	         then goto MAIN_RETURN;
     1269 	       first_match = new_source_info.stmnt_map_entry_index;
     1270 	       do while ("1"b);
     1271 	         call probe_break_mgr_$reset_break_at_line
     1272 		    (probe_info_ptr, addr (new_source_info), mod_type,
     1273 		    long_sw, code);
     1274 
     1275 	         call probe_source_segment_$find_source
     1276 		    (probe_info_ptr, addr (new_source_info),
     1277 		    (search_string), code);
     1278 	         if code ^= 0
     1279 		    | new_source_info.stmnt_map_entry_index = first_match
     1280 		 then goto MAIN_RETURN;
     1281 	       end;
     1282 	     end;
     1283 	   else if case = LINE_CASE
     1284 	     then call probe_break_mgr_$reset_break_at_line
     1285 		     (probe_info_ptr, addr (new_source_info), mod_type,
     1286 		     long_sw, code);
     1287 	   else if case = SEG_CASE
     1288 	     then call probe_break_mgr_$reset_breaks_in_seg (probe_info_ptr,
     1289 		     addr (new_source_info), long_sw, code);
     1290 	 end;			/* reset cases */
     1291 	 else do;
     1292 	   if case = DEFAULT_CASE
     1293 	     then do;
     1294 	       call probe_break_mgr_$list_breaks_in_seg (probe_info_ptr,
     1295 		  addr (current_source),
     1296 		  long_sw, code);
     1297 	       new_source_info = current_source;
     1298 	     end;
     1299 	   else if case = WORLD_CASE
     1300 	     then call probe_break_mgr_$list_breaks_in_world (
     1301 		     probe_info_ptr, long_sw, code);
     1302 	   else if case = LINE_CASE
     1303 	     then call probe_break_mgr_$list_breaks_at_line (probe_info_ptr,
     1304 		     addr (new_source_info), mod_type,
     1305 		     long_sw, code);
     1306 	   else if case = SEG_CASE
     1307 	     then call probe_break_mgr_$list_breaks_in_seg (probe_info_ptr,
     1308 		     addr (new_source_info),
     1309 		     long_sw, code);
     1310 	   else if case = STAR_CASE
     1311 	     then call probe_break_mgr_$list_broken_segs (probe_info_ptr,
     1312 		     code);
     1313 	 end;			/* status  cases */
     1314 
     1315   dcl (
     1316       probe_et_$breakless,
     1317       probe_et_$no_breaks
     1318       )			fixed bin (35) external static;
     1319 
     1320   if code = probe_et_$breakless
     1321     then call probe_error_ (probe_info_ptr, probe_et_$breakless,
     1322 	    PLACE (mod_type),
     1323 	    probe_line_number_ (probe_info_ptr, new_source_info));
     1324   else if code = probe_et_$no_breaks then do;
     1325       pathname =
     1326 	 rtrim (new_source_info.seg_info_ptr -> seg_info.directory_name);
     1327       pathname = pathname || ">";
     1328 				/* it turns out that .entry_name is really the segname */
     1329       pathname =
     1330 	 pathname
     1331 	 || rtrim (new_source_info.seg_info_ptr -> seg_info.entry_name);
     1332       pathname = pathname || "$";
     1333       pathname =
     1334 	 pathname
     1335 	 || rtrim (new_source_info.seg_info_ptr -> seg_info.segname);
     1336 				/* and .segname is really the entry point name */
     1337       call probe_error_ (probe_info_ptr, probe_et_$no_breaks, pathname);
     1338     end;
     1339 
     1340   if code ^= 0
     1341     then goto SOME_ERROR;
     1342   goto MAIN_RETURN;
     1343 
     1344 
     1345 after_request:
     1346   entry (P_probe_info_ptr);
     1347 
     1348   /* *	This request sets a breakpoint after the specified line */
     1349 
     1350   dcl break_location	fixed bin;
     1351   dcl requests_ptr		pointer;
     1352   dcl requests_lth		fixed bin (21);
     1353   dcl search_sw		bit (1) aligned;
     1354   dcl search_string		char (256) varying;
     1355   dcl first_match		fixed bin;
     1356   dcl done		bit (1) aligned;
     1357   dcl DEFAULT_BREAK_REQUEST	char (4) aligned internal static
     1358 			options (constant) init ("halt");
     1359   dcl probe_break_mgr_$set_break
     1360 			entry (ptr, ptr, fixed bin, pointer,
     1361 			fixed bin (21), fixed bin (35));
     1362 
     1363   break_location = BREAK_AFTER;
     1364   goto AFTER_BEFORE_COMMON;
     1365 
     1366 before_request:
     1367   entry (P_probe_info_ptr);
     1368 
     1369   /* *     This request sets a breakpoint before the specified line */
     1370 
     1371   break_location = BREAK_BEFORE;
     1372   goto AFTER_BEFORE_COMMON;
     1373 
     1374 
     1375 AFTER_BEFORE_COMMON:
     1376   probe_info_ptr = P_probe_info_ptr;
     1377 
     1378 
     1379   /* We can accept the following:
     1380*   b	default loc and default break list
     1381*   b N	explicit loc default break
     1382*   b : R	default loc, explicit break list
     1383*   b N:R	explicit both
     1384*
     1385**/
     1386 
     1387   search_sw = "0"b;
     1388 
     1389   if probe_info.ct -> token.type >= probe_info.end_token |
     1390        probe_info.ct -> token.type = COLON
     1391     then new_source_info = current_source;
     1392 
     1393   else if probe_info.ct -> token.type = CONSTANT_TYPE &
     1394        probe_info.ct -> constant.data_type = (char_dtype * 2) then do;
     1395       search_sw = "1"b;
     1396       search_string = constant_string;
     1397 
     1398       call bump_ct ();
     1399     end;
     1400 
     1401   else do;
     1402     call probe_get_$line (probe_info_ptr, addr (new_source_info), (0),
     1403          "0000"b, (0), code);
     1404     if code ^= 0
     1405       then goto SOME_ERROR;
     1406   end;
     1407 
     1408   /* now have loc, default or explicit */
     1409 
     1410 
     1411   if probe_info.ct -> token.type >= end_token /* default commands */
     1412     then do;
     1413       requests_ptr = addr (DEFAULT_BREAK_REQUEST);
     1414       requests_lth = length (DEFAULT_BREAK_REQUEST);
     1415 
     1416     end;
     1417   else if probe_info.ct -> operator.type = COLON then do;
     1418       call bump_ct ();		/* skip over the colon */
     1419       call require_argument ();
     1420 
     1421       call probe_get_$request_list (probe_info_ptr, requests_ptr,
     1422 	 requests_lth, code);
     1423       if code ^= 0
     1424         then goto SOME_ERROR;
     1425 
     1426       call reject_argument ();	/* nothing may follow the request line */
     1427 
     1428       probe_info.setting_break = "1"b;
     1429 
     1430       call probe_listen_$check_line (probe_info_ptr, requests_ptr,
     1431 	 requests_lth, code);
     1432       if code ^= 0
     1433         then goto SOME_ERROR;		/* check the syntax */
     1434 
     1435       probe_info.setting_break = "0"b;
     1436     end;
     1437   else call probe_error_ (probe_info_ptr, 0,
     1438 				/* probably commands */
     1439 	  "The break location and the requests to be executed must be separated by a colon."
     1440 	  );
     1441 
     1442 
     1443   if probe_info.execute then do;	/* set the break */
     1444       if search_sw then do;		/* b STRING */
     1445 	new_source_info = current_source;
     1446 
     1447 	call probe_source_segment_$find_source
     1448 	     (probe_info_ptr, addr (new_source_info), (search_string), code)
     1449 	     ;
     1450 	if code ^= 0
     1451 	  then call probe_error_ (probe_info_ptr, code);
     1452 	  else do;
     1453 	    first_match = new_source_info.stmnt_map_entry_index;
     1454 
     1455 	    done = "0"b;
     1456 	    do while (^done);
     1457 
     1458 	      call set_break;
     1459 
     1460 	      call probe_source_segment_$find_source (probe_info_ptr,
     1461 		 addr (new_source_info),
     1462 		 (search_string), code);
     1463 	      if code ^= 0
     1464 		 | new_source_info.stmnt_map_entry_index = first_match
     1465 	        then
     1466 		   done = "1"b;
     1467 	    end;
     1468 	    code = 0;
     1469 	  end;
     1470         end;
     1471 
     1472         else call set_break;
     1473     end;
     1474 
     1475   goto MAIN_RETURN;			/* end of code for after and before requests */
     1476 
     1477 
     1478 
     1479 set_break:
     1480   proc;
     1481 
     1482   call probe_break_mgr_$set_break (probe_info_ptr, addr (new_source_info),
     1483        break_location, requests_ptr, requests_lth, code);
     1484   if code ^= 0
     1485     then goto SOME_ERROR;
     1486   if ^probe_static_info.brief_sw
     1487     then
     1488          call ioa_$ioa_switch (probe_info.output_switch, "Break set ^a ^a",
     1489 	    PLACE (break_location),
     1490 	    probe_line_number_ (probe_info_ptr, new_source_info));
     1491 
     1492   end set_break;
     1493 
     1494 enable_request:
     1495   entry (P_probe_info_ptr);
     1496 
     1497   /* Undocumented request used when debugging probe itself. Resets the value
     1498*   (probe_static_info.last_break_segno, compared against .probe_segno)
     1499*   that tells probe it is already stopped at a break inside probe and therefore
     1500*   should ignore any recursively hit breaks. Despite "continue", cleanup, and
     1501*   other precautions to reset this value when leaving a break in probe, it is
     1502*   still sometimes inexplicably left set. */
     1503 
     1504   P_probe_info_ptr -> probe_info.static_info_ptr
     1505        -> probe_static_info.last_break_segno = "0"b;
     1506 
     1507   goto MAIN_RETURN;
     1508 
     1509 
     1510   /*	INTERNAL PROCEDURES 	*/
     1511 
     1512 reject_argument:
     1513   proc ();
     1514 
     1515   /* *	This procedure simply calls probe_error_ if the current token is not the
     1516*   *	end of the token chain -- it is called by requests which have processed all
     1517*   *	expected arguments and want to barf if there are any extras */
     1518 
     1519   if probe_info.ct -> token.type < probe_info.end_token
     1520     then
     1521          call probe_error_ (probe_info_ptr, probe_et_$too_many_args);
     1522 
     1523   return;
     1524   end;				/* reject_argument internal procedure */
     1525 
     1526 
     1527 reject_next_argument:
     1528   proc ();
     1529 
     1530   /* *	This is just like reject_argument, except that it tests whether there are any
     1531*   *	argument tokens AFTER the current one, rather than starting with the current one */
     1532 
     1533   if probe_info.ct -> token.next = null ()
     1534     then
     1535          call probe_error_ (probe_info_ptr, probe_et_$too_many_args);
     1536 
     1537   if probe_info.ct -> token.next -> token.type < probe_info.end_token
     1538     then
     1539          call probe_error_ (probe_info_ptr, probe_et_$too_many_args);
     1540 
     1541   return;
     1542   end;				/* reject_next_argument internal procedure */
     1543 
     1544 
     1545 require_argument:
     1546   proc ();
     1547 
     1548   /* *	This is just like reject_argument, except that it barfs if there are not
     1549*   *	any more arguments */
     1550 
     1551   if probe_info.ct -> token.type >= probe_info.end_token
     1552     then
     1553          call probe_error_ (probe_info_ptr, probe_et_$noarg);
     1554 
     1555   return;
     1556   end;				/* require_argument internal procedure */
     1557 
     1558 
     1559 bump_ct:
     1560   proc ();
     1561 
     1562   /* *	This procedure makes probe_info.ct point at the next token. */
     1563 
     1564 
     1565   probe_info.ct = probe_info.ct -> token.next;
     1566 
     1567   if probe_info.ct = null ()
     1568     then goto SYNTAX_ERROR;		/* some protection against mistakes */
     1569 
     1570   return;
     1571   end;				/* bump_ct internal procedure */
     1572 
     1573 rest_of_request:
     1574   proc (P_str);
     1575 
     1576   /* Returns the rest of the request as a character string */
     1577 
     1578   dcl P_str		char (*) varying;
     1579   dcl input_buffer		char (probe_info.buffer_lth)
     1580 			based (probe_info.buffer_ptr);
     1581   dcl (start_pos, end_pos)	fixed bin (21);
     1582 
     1583   start_pos = probe_info.ct -> token.location;
     1584 
     1585   do while (probe_info.ct -> token.type < probe_info.end_token);
     1586 
     1587     call bump_ct ();
     1588   end;
     1589 
     1590   end_pos = probe_info.ct -> token.location;
     1591 
     1592   P_str =
     1593        rtrim (substr (input_buffer, start_pos, end_pos - start_pos + 1), NL);
     1594 
     1595   return;
     1596 
     1597   end rest_of_request;
     1598 
     1599 
     1600 
     1601 
     1602 set_iocb:
     1603   proc (P_iocb_ptr, P_private_sw, P_new_iocb_ptr, P_new_private_sw);
     1604 
     1605   /* Destroys the old IOCB if it was private (created by ids or ods) and
     1606*   sets the static IOCB to the new value */
     1607 
     1608   dcl (P_iocb_ptr, P_new_iocb_ptr)
     1609 			ptr;
     1610   dcl (P_private_sw, P_new_private_sw)
     1611 			bit (1) aligned;
     1612 
     1613 
     1614   if P_private_sw & /* previous IOCB was set by ids or ods */
     1615        P_iocb_ptr ^= iox_$user_input & P_iocb_ptr ^= iox_$user_output &
     1616        P_iocb_ptr ^= iox_$error_output & P_iocb_ptr ^= iox_$user_io then do;
     1617       call iox_$close (P_iocb_ptr, (0));
     1618       call iox_$detach_iocb (P_iocb_ptr, (0));
     1619       call iox_$destroy_iocb (P_iocb_ptr, (0));
     1620     end;
     1621 
     1622   P_iocb_ptr = P_new_iocb_ptr;
     1623   P_private_sw = P_new_private_sw;
     1624 
     1625   end set_iocb;
     1626 
     1627 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
     1628 
     1629 
  2     1 /*	BEGIN INCLUDE FILE probe_static_info.incl.pl1	*/
  2     2 
  2     3 /* *	This include file describes per-process information about probe, such
  2     4*   *	as various options available and the info directories and modes.
  2     5*   *
  2     6*   *	Created: 06/06/79 W. Olin Sibert */
  2     7 
  2     8 dcl 1 probe_static_info aligned based (probe_info.static_info_ptr), /* per-process data about probe */
  2     9     2 probe_info_version fixed bin,			/* same as probe_info.probe_info_version */
  2    10 
  2    11     2 version aligned,
  2    12       3 major_version fixed bin,
  2    13       3 minor_version fixed bin,
  2    14       3 version_string char (32) unaligned,		/* like "4.3f, patch 1" */
  2    15 
  2    16     2 name char (32) unaligned,			/* "probe" */
  2    17     2 prompt character (40) varying,			/* prompt for reading requests */
  2    18     2 switches,
  2    19       3 brief_sw bit (1) unaligned,			/* briefer break messages, no header (default OFF) */
  2    20       3 no_handle_faults_sw bit (1) unaligned,		/* don't handle bad ptr faults (default OFF) */
  2    21       3 recursive_breaks_sw bit (1) unaligned,		/* don't ignore recursive breaks in probe */
  2    22       3 prompt_on_sw bit (1) unaligned,			/* prompt for request lines */
  2    23       3 switch_pad bit (32) unaligned,
  2    24 
  2    25     2 scratch_segment_ptr pointer,			/* pointer to probe_scratch_ -- always valid */
  2    26     2 break_segment_ptr pointer,			/* pointer to Person.breaks -- valid only if needed */
  2    27 
  2    28     2 seg_info_offset_ptr pointer,			/* pointer to seg_info_offset array */
  2    29 
  2    30     2 probe_segno bit (18),				/* segment number of probe itself */
  2    31    2 last_break_segno bit (18),			/* segment number of last interrupted program */
  2    32 
  2    33     2 stack_info aligned,				/* information about the stack trace in probe_scratch_ */
  2    34       3 level_chain pointer unaligned,			/* first level frame entry pointer */
  2    35       3 max_level fixed bin,				/* number of stack levels */
  2    36       3 flags aligned,
  2    37        (4 good_stack,
  2    38         4 traced_with_all,				/* whether the stack trace includes support frames */
  2    39         4 pad1 (34)) bit (1) unaligned,
  2    40 
  2    41     2 modes_ptr pointer unaligned,			/* pointer to modes -- same as probe_info.modes_ptr */
  2    42 
  2    43     2 request_table_info aligned,			/* info for request definitions */
  2    44       3 array_ptr pointer,				/* pointer to array of request table pointers */
  2    45       3 array_size fixed bin, 			/* number of elements in use */
  2    46       3 array_max_size fixed bin,			/* max number of elements in array */
  2    47       3 using_internal_array bit (1) aligned,		/* whether or not we are using the array in probe_static_info */
  2    48 
  2    49     2 io_switches,					/* switches probe does its I/O on */
  2    50       3 input_switch pointer,
  2    51       3 output_switch pointer,
  2    52       3 (private_input_sw, private_output_sw) bit (1) aligned,
  2    53 						/* created by ids, ods and should be destroyed */
  2    54 
  2    55     2 info_directory_info aligned,			/* info about info directories */
  2    56       3 array_ptr pointer,
  2    57       3 array_size fixed bin,
  2    58       3 array_max_size fixed bin,
  2    59       3 using_internal_array bit (1) aligned,
  2    60 
  2    61     2 exclude_name_info aligned,			/* info for exclude array used in printing values */
  2    62       3 array_ptr pointer,
  2    63       3 array_size fixed bin,
  2    64       3 array_max_size fixed bin,
  2    65       3 using_internal_array bit (1) aligned,
  2    66 
  2    67     2 null_seg_info_ptr pointer unaligned,		/* pointer to the "null" seg_info block */
  2    68 
  2    69     2 initial_arrays,				/* initial versions of various arrays */
  2    70       3 request_table_ptr_array (10) pointer aligned,
  2    71       3 info_directory_name_array (3) char (168) unaligned,
  2    72       3 exclude_name_array (6) char (32) unaligned,
  2    73 
  2    74     2 metering_info,					/* last values for "mode meter" */
  2    75       3 last_clock fixed bin (71),
  2    76       3 last_vclock fixed bin (71),
  2    77       3 last_page_faults fixed bin,
  2    78 
  2    79     2 end_of_probe_static_info fixed bin;
  2    80 
  2    81 
  2    82 dcl 1 probe_seg_info_array aligned based (probe_static_info.seg_info_offset_ptr),
  2    83     2 count fixed bin,				/* number of entries in seg_info_offset array */
  2    84     2 seg_info_offset (0 : seg_info_offset_count refer (probe_seg_info_array.count)) bit (18) aligned;
  2    85 
  2    86 dcl  seg_info_offset_count fixed bin;			/* one less than the number of info_offsets */
  2    87 
  2    88 dcl  probe_request_tables (probe_static_info.request_table_info.array_max_size) /* array of request table pointers */
  2    89      pointer aligned based (probe_static_info.request_table_info.array_ptr);
  2    90 
  2    91 dcl  probe_info_directories (probe_static_info.info_directory_info.array_max_size) /* array of info directories */
  2    92      char (168) unaligned based (probe_static_info.info_directory_info.array_ptr);
  2    93 
  2    94 dcl  probe_exclude_names (probe_static_info.exclude_name_info.array_max_size) /* array of exclude names */
  2    95      char (168) unaligned based (probe_static_info.exclude_name_info.array_ptr);
  2    96 
  2    97 /*	END INCLUDE FILE probe_static_info.incl.pl1	*/
     1630 
     1631 
  3     1 /*	BEGIN INCLUDE FILE probe_tokens.incl.pl1	*/
  3     2 /*	Split up into probe_tokens and probe_references, 04/22/79 WOS */
  3     3 
  3     4 dcl 1 token_header aligned based,			/* header information common to all tokens */
  3     5     2 next pointer unaligned,				/* pointer to next token in chain */
  3     6     2 prev pointer unaligned,				/* same for previous token */
  3     7     2 type bit (18) aligned,
  3     8     2 buffer_ptr pointer unaligned,			/* pointer to beginning of input buffer */
  3     9     2 location fixed bin (17) unal,			/* offset in input buffer */
  3    10     2 length fixed bin (17) unal,
  3    11     2 flags aligned,
  3    12      (3 leading_whitespace,				/* there is whitespace before thios token */
  3    13       3 trailing_whitespace) bit (1) unaligned,		/* and same for after */
  3    14       3 pad1 bit (34) unaligned;
  3    15 
  3    16 dcl 1 token aligned based,				/* produced by scan_probe_input_ */
  3    17     2 header aligned like token_header;			/* that's all there is */
  3    18 
  3    19 dcl 1 identifier aligned based,			/* keyword or identifier token */
  3    20     2 header aligned like token_header,
  3    21     2 length fixed bin,				/* length of name */
  3    22     2 name pointer unaligned;				/* to string in buffer containing name */
  3    23 
  3    24 dcl 1 operator aligned based,				/* for punctuation */
  3    25     2 header aligned like token_header;			/* nothing but a header here */
  3    26 
  3    27 dcl 1 constant aligned based,				/* for strings pointers numbers etc */
  3    28     2 header aligned like token_header,
  3    29     2 encoded_precision aligned,			/* encoded precision kludge for assign_ */
  3    30       3 scale fixed bin (17) unaligned,			/* arithmetic scale */
  3    31       3 precision fixed bin (17) unaligned,		/* arithmetic precision or other size */
  3    32     2 scale_and_precision fixed bin (35),		/* An identical copy of the two values above */
  3    33     2 data_type fixed bin,				/* standard data type code + packed bit */
  3    34     2 data_ptr pointer unaligned;
  3    35 
  3    36 
  3    37 dcl (OPERATOR_TYPE init ("100"b),			/* types for above */
  3    38      NAME_TYPE init ("010"b),
  3    39      CONSTANT_TYPE init ("001"b)) bit (18) internal static options (constant);
  3    40 
  3    41 
  3    42 dcl  current_identifier_name				/* Overlays for looking at the current tokens */
  3    43      char (probe_info.ct -> identifier.length) based (probe_info.ct -> identifier.name);
  3    44 dcl 1 current_constant aligned like constant based (probe_info.ct);
  3    45 dcl 1 current_token aligned like token based (probe_info.ct);
  3    46 
  3    47 /*	END INCLUDE FILE probe_tokens.incl.pl1		*/
     1632 
     1633 
  4     1 /*	BEGIN INCLUDE FILE probe_references.incl.pl1	*/
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  4     5*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  4     6*     Added new field (c_symbol) for C-Probe support.
  4     7*  2) change(88-10-28,WAAnderson), approve(88-10-28,MCR7952),
  4     8*     audit(88-10-31,RWaters), install(88-11-11,MR12.2-1210):
  4     9*     Added new field (c_sub_c_ptr) for C-Probe_support.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 /*	Split out of probe_tokens, 04/22/79 WOS 	*/
  4    13 /*       modified for probe variables Feb 19 80 JRD         */
  4    14 /*   Modified June 83 JMAthane to add "type_ptr" and "builtin" fields */
  4    15 
  4    16      dcl	   1 reference_node	      aligned based,	/* information about a reference */
  4    17 	     2 symbol_ptr	      pointer aligned,	/* to symbol table entry for reference */
  4    18 	     2 type_ptr	      pointer aligned,	/* to symbol table entry for type (null if none) */
  4    19 	     2 address_ptr	      pointer aligned,	/* to location of variable */
  4    20 	     2 base_addr	      pointer aligned,	/* pointer on which whole symbol is based */
  4    21 	     2 source_info_ptr    pointer aligned,	/* to symbol structure for reference */
  4    22 
  4    23 	     2 name	      char (256) unaligned varying, /* symbol name */
  4    24 
  4    25 	     2 type	      fixed bin (35),	/* data type */
  4    26 	     2 descriptor	      fixed bin (35),	/* type || packed */
  4    27 	     2 precision	      fixed bin (35),	/* scale and precision */
  4    28 	     2 flags,
  4    29 	       3 packed	      bit (1) unal,		/* data is in packed format */
  4    30 	       3 constant	      bit (1) unal,		/* data is really a constant */
  4    31 	       3 cross_section    bit (1) unal,		/* reference is an array cross-section */
  4    32 	       3 function	      bit (1) unal,		/* reference is function value */
  4    33 	       3 octal	      bit (1) unal,		/* indicates that this is the octal bif */
  4    34 	       3 star_extent      bit (1) unal,		/* reference is a star subscript for father */
  4    35 	       3 have_generation  bit (1) unal,		/* this reference has an explicitly specified generation */
  4    36 	       3 pseudo_var	      bit (1) unal,		/* it is ok to assign to it */
  4    37 	       3 probe_variable   bit (1) unal,
  4    38 	       3 path	      bit (1) unal,		/* it's a pathname/virtual entry */
  4    39 	       3 builtin	      bit (1) unal,		/* probe builtinvalue */
  4    40 	       3 c_ptr_to_char    bit (1)  unal,
  4    41                  3 c_sub_c_ptr      bit (1)  unal,
  4    42 	       3 pad2	      bit (23) unal,
  4    43 
  4    44 	     2 optional_info,			/* information which may or may not be present */
  4    45 	       3 argument_list    pointer unaligned,	/* pointer to reference_arg_list */
  4    46 	       3 subscript_ptr    pointer unaligned,	/* pointer to reference_subscripts */
  4    47 	       3 n_arguments      fixed bin,		/* number of arguments in argument list */
  4    48 	       3 n_subscripts     fixed bin,		/* number of subscripts present */
  4    49 
  4    50 	     2 constant_token_ptr pointer unaligned,	/* pointer to constant token if this is a constant */
  4    51 	     2 subscript_refs_ptr pointer unaligned,	/* pointer to array of subscript reference node pointers */
  4    52 	     2 invocation_level   fixed bin,		/* invocation level number ("[-17]") for this reference */
  4    53 	     2 probe_var_info_ptr ptr unal,		/* only if flags.probe_variable */
  4    54                2 c_symbol_ptr  ptr unal,
  4    55 	     2 pad1	      (9) pointer unaligned,
  4    56 	     2 end_of_reference_node pointer aligned;
  4    57 
  4    58 
  4    59      dcl	   1 reference_arg_list   aligned based,	/* argument list; based on reference.argument_list */
  4    60 	     2 number	      fixed bin,		/* number of arguments actually present */
  4    61 	     2 node	      (16) pointer aligned;	/* reference node pointers for each argument */
  4    62 
  4    63 
  4    64      dcl	   1 reference_subscripts aligned based,	/* subscript array; based on reference.subscript_ptr */
  4    65 	     2 number	      fixed bin,		/* number actually present */
  4    66 	     2 value	      (2, 16) fixed bin (24); /* values for lower and upper bound for each */
  4    67 
  4    68 
  4    69      dcl	   1 subscript_reference_ptrs aligned based,	/* array of pointers to subscript reference nodes */
  4    70 	     2 ptr	      (2, 16) pointer aligned;
  4    71 
  4    72 /*	END INCLUDE FILE probe_references.incl.pl1	*/
     1634 
     1635 
  5     1 /* BEGIN INCLUDE FILE ... probe_level_frame.incl.pl1  */
  5     2 
  5     3 /* Modified 25 Aug 79 JRDavis */
  5     4 /* Added printed_(number decimal) for numbering support frames 12/10/81 S. Herbst */
  5     5 
  5     6 dcl 1 level_frame based (lfp) aligned,
  5     7       2 next ptr unal,
  5     8       2 prev ptr unal,
  5     9       2 number fixed bin,
  5    10       2 printed_number fixed bin,
  5    11       2 printed_decimal fixed bin,
  5    12       2 condition_frame_ptr ptr,
  5    13       2 flags unal,
  5    14         3 quick bit (1) unal,
  5    15         3 error_signalled bit (1) unal,
  5    16         3 support bit (1) unal,
  5    17         3 run_unit_manager bit (1) unal,
  5    18         3 pad bit (32) unal,
  5    19       2 source_info aligned like source_info,
  5    20       2 component_info aligned,
  5    21        3 component_name char (32),
  5    22        3 component_text_ptr ptr;
  5    23 
  5    24 dcl lfp ptr;
  5    25 
  5    26 /* END INCLUDE FILE ... probe_level_frame.incl.pl1 */
     1636 
     1637 
  6     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  6     2*
  6     3*  James R. Davis 2 July 79 */
  6     4 
  6     5 dcl 1 source_info based aligned,
  6     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  6     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  6     8       2 block_ptr ptr,				/* to runtime_block node */
  6     9       2 stack_ptr ptr,				/* to a stack frame */
  6    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  6    11       2 seg_info_ptr ptr;				/* to seg_info */
  6    12 
  6    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  6    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  6    15 
  6    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
     1638 
     1639 
  7     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  7     2 
  7     3 /* format: off */
  7     4 
  7     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  7     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  7     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  7     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  7     9 
  7    10 
  7    11 /****^  HISTORY COMMENTS:
  7    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  7    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  7    14*     Modified to add constants for the translator_id field in the stack_frame
  7    15*     structure.
  7    16*                                                   END HISTORY COMMENTS */
  7    17 
  7    18 
  7    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  7    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  7    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  7    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  7    23 
  7    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  7    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  7    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  7    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  7    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  7    29 
  7    30 
  7    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  7    32 
  7    33 dcl  stack_frame_min_length fixed bin static init(48);
  7    34 
  7    35 
  7    36 dcl 1 stack_frame based(sp) aligned,
  7    37     2 pointer_registers(0 : 7) ptr,
  7    38     2 prev_sp pointer,
  7    39     2 next_sp pointer,
  7    40     2 return_ptr pointer,
  7    41     2 entry_ptr pointer,
  7    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  7    43     2 arg_ptr pointer,
  7    44     2 static_ptr ptr unaligned,
  7    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  7    46     2 on_unit_relp1 bit(18) unaligned,
  7    47     2 on_unit_relp2 bit(18) unaligned,
  7    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  7    49*						   0 => PL/I version II
  7    50*						   1 => ALM
  7    51*						   2 => PL/I version I   
  7    52*						   3 => signal caller frame
  7    53*						   4 => signaller frame */
  7    54     2 operator_return_offset bit(18) unaligned,
  7    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  7    56     2 a bit(36),					/* accumulator */
  7    57     2 q bit(36),					/* q-register */
  7    58     2 e bit(36),					/* exponent */
  7    59     2 timer bit(27) unaligned,				/* timer */
  7    60     2 pad bit(6) unaligned,
  7    61     2 ring_alarm_reg bit(3) unaligned;
  7    62 
  7    63 
  7    64 dcl 1 stack_frame_flags based(sp) aligned,
  7    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  7    66     2 xx0 bit(22) unal,
  7    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  7    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  7    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  7    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  7    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  7    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  7    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  7    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  7    75     2 xx0a bit(6) unal,
  7    76     2 xx1 fixed bin,
  7    77     2 xx2 fixed bin,
  7    78     2 xx3 bit(25) unal,
  7    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  7    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  7    81     2 xx3a bit(9) unaligned,
  7    82     2 xx4(9) bit(72) aligned,
  7    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  7    84*						*  operator puts a pointer to the base of
  7    85*						*  the calling procedure here. (text base ptr)  */
  7    86     2 xx5 bit(72) aligned,
  7    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  7    88 
  7    89 /* format: on */
  7    90 
  7    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
     1640 
     1641 
  8     1 /* BEGIN INCLUDE FILE ... probe_operators.incl.pl1 */
  8     2 
  8     3 
  8     4 
  8     5 /****^  HISTORY COMMENTS:
  8     6*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  8     7*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  8     8*     Added new C operators.
  8     9*                                                   END HISTORY COMMENTS */
  8    10 
  8    11 
  8    12 /* These are the operator.types for each defined operator */
  8    13 /* Modified June 83 JMAthane for PASCAL_ARROW new operator */
  8    14 /* Added PASCAL_RANGE and PASCAL_ASSIGN 07/26/83 S. Herbst */
  8    15 /* Modified April 88 Hinatsu Addition of C types */
  8    16 
  8    17      dcl	   (PLUS		      init ("400001"b3), MINUS init ("400002"b3),
  8    18 	   TIMES		      init ("400003"b3), SLASH init ("400004"b3),
  8    19 	   OR_BAR		      init ("400005"b3), NOT_SIGN init ("400006"b3),
  8    20 	   LESS_THAN	      init ("400007"b3), GREATER_THAN init ("400010"b3),
  8    21 	   EQUALS		      init ("400011"b3), NOT_EQUALS init ("400012"b3),
  8    22 	   NOT_GREATER_THAN	      init ("400013"b3), NOT_LESS_THAN init ("400014"b3),
  8    23 	   PERIOD		      init ("400015"b3), COLON init ("400016"b3),
  8    24 	   AMPERSAND	      init ("400017"b3), PERCENT init ("400020"b3),
  8    25 	   DOLLAR_SIGN	      init ("400021"b3), LEFT_BRACKET init ("400022"b3),
  8    26 	   RIGHT_BRACKET	      init ("400023"b3), ARROW init ("400024"b3),
  8    27 	   COMMA		      init ("400025"b3), QUESTION_MARK init ("400026"b3),
  8    28 	   PASCAL_ARROW	      init ("400027"b3), PASCAL_RANGE init ("400030"b3),
  8    29 	   PASCAL_ASSIGN	      init ("400031"b3),
  8    30 
  8    31 /* Additons to support C types */
  8    32 	   C_LEFT_SHIFT           init ("400032"b3), C_RIGHT_SHIFT init ("400033"b3),
  8    33 
  8    34 /* operator 28 are left for future expansion */
  8    35 
  8    36 	   LEFT_PAREN	      init ("400035"b3), RIGHT_PAREN init ("400036"b3),
  8    37              C_EQUAL                init ("400037"b3), C_NOT_EQUAL init ("400040"b3),
  8    38 	   SEMI_COLON	      init ("400041"b3), NEW_LINE init ("400042"b3),
  8    39 	   C_INDIRECTION          init ("400034"b3)
  8    40 
  8    41 	   )		      bit (18) aligned internal static options (constant);
  8    42 
  8    43      dcl	   OPERATOR_VALUES	      (0:34) char (4) varying internal static options (constant) init
  8    44 			      ("????", "+", "-", "*", "/", "|", "^", "<",
  8    45 			      ">", "=", "^=", "<=", ">=", ".", ":", "&",
  8    46 			      "%", "$", "[", "]", "->", ",", "?", "^",
  8    47 			      "..", ":=", "<<", ">>", "*", "(", ")",
  8    48 			      "==", "!=", ";","
  8    49 ");
  8    50 
  8    51 /* END INCLUDE FILE ... probe_operators.incl.pl1 */
     1642 
     1643 
  9     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  9     2 
  9     3 
  9     4 /****^  HISTORY COMMENTS:
  9     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  9     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  9     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  9     8*     Objects of this type are PASCAL string types.
  9     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  9    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  9    11*     Added the new C types.
  9    12*                                                   END HISTORY COMMENTS */
  9    13 
  9    14 /* This include file defines mnemonic names for the Multics
  9    15*   standard descriptor types, using both pl1 and cobol terminology.
  9    16*   PG 780613
  9    17*   JRD 790530
  9    18*   JRD 791016
  9    19*   MBW 810731
  9    20*   TGO 830614 Add hex types.
  9    21*   Modified June 83 JMAthane to add PASCAL data types
  9    22*   TGO 840120 Add float dec extended and generic, float binary generic
  9    23**/
  9    24 
  9    25      dcl	   (real_fix_bin_1_dtype  init (1),
  9    26 	   real_fix_bin_2_dtype   init (2),
  9    27 	   real_flt_bin_1_dtype   init (3),
  9    28 	   real_flt_bin_2_dtype   init (4),
  9    29 	   cplx_fix_bin_1_dtype   init (5),
  9    30 	   cplx_fix_bin_2_dtype   init (6),
  9    31 	   cplx_flt_bin_1_dtype   init (7),
  9    32 	   cplx_flt_bin_2_dtype   init (8),
  9    33 	   real_fix_dec_9bit_ls_dtype init (9),
  9    34 	   real_flt_dec_9bit_dtype init (10),
  9    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  9    36 	   cplx_flt_dec_9bit_dtype init (12),
  9    37 	   pointer_dtype	      init (13),
  9    38 	   offset_dtype	      init (14),
  9    39 	   label_dtype	      init (15),
  9    40 	   entry_dtype	      init (16),
  9    41 	   structure_dtype	      init (17),
  9    42 	   area_dtype	      init (18),
  9    43 	   bit_dtype	      init (19),
  9    44 	   varying_bit_dtype      init (20),
  9    45 	   char_dtype	      init (21),
  9    46 	   varying_char_dtype     init (22),
  9    47 	   file_dtype	      init (23),
  9    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  9    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  9    50 	   real_fix_bin_1_uns_dtype init (33),
  9    51 	   real_fix_bin_2_uns_dtype init (34),
  9    52 	   real_fix_dec_9bit_uns_dtype init (35),
  9    53 	   real_fix_dec_9bit_ts_dtype init (36),
  9    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  9    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  9    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  9    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  9    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  9    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  9    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  9    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  9    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  9    63 	   real_flt_hex_1_dtype   init (47),
  9    64 	   real_flt_hex_2_dtype   init (48),
  9    65 	   cplx_flt_hex_1_dtype   init (49),
  9    66 	   cplx_flt_hex_2_dtype   init (50),
  9    67 	   c_typeref_dtype        init (54),
  9    68 	   c_enum_dtype           init (55),
  9    69              c_enum_const_dtype     init (56),
  9    70 	   c_union_dtype          init (57),
  9    71 	   algol68_straight_dtype init (59),
  9    72 	   algol68_format_dtype   init (60),
  9    73 	   algol68_array_descriptor_dtype init (61),
  9    74 	   algol68_union_dtype    init (62),
  9    75 
  9    76 	   cobol_comp_6_dtype     init (1),
  9    77 	   cobol_comp_7_dtype     init (1),
  9    78 	   cobol_display_ls_dtype init (9),
  9    79 	   cobol_structure_dtype  init (17),
  9    80 	   cobol_char_string_dtype init (21),
  9    81 	   cobol_display_ls_overp_dtype init (29),
  9    82 	   cobol_display_ts_overp_dtype init (30),
  9    83 	   cobol_display_uns_dtype init (35),
  9    84 	   cobol_display_ts_dtype init (36),
  9    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  9    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  9    87 	   cobol_comp_5_uns_dtype init (40),
  9    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  9    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  9    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  9    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  9    92 	   cplx_flt_dec_generic_dtype init (84),
  9    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  9    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  9    95 
  9    96      dcl	   (ft_integer_dtype      init (1),
  9    97 	   ft_real_dtype	      init (3),
  9    98 	   ft_double_dtype	      init (4),
  9    99 	   ft_complex_dtype	      init (7),
  9   100 	   ft_complex_double_dtype init (8),
  9   101 	   ft_external_dtype      init (16),
  9   102 	   ft_logical_dtype	      init (19),
  9   103 	   ft_char_dtype	      init (21),
  9   104 	   ft_hex_real_dtype      init (47),
  9   105 	   ft_hex_double_dtype    init (48),
  9   106 	   ft_hex_complex_dtype   init (49),
  9   107 	   ft_hex_complex_double_dtype init (50)
  9   108 	   )		      fixed bin internal static options (constant);
  9   109 
  9   110      dcl	   (algol68_short_int_dtype init (1),
  9   111 	   algol68_int_dtype      init (1),
  9   112 	   algol68_long_int_dtype init (2),
  9   113 	   algol68_real_dtype     init (3),
  9   114 	   algol68_long_real_dtype init (4),
  9   115 	   algol68_compl_dtype    init (7),
  9   116 	   algol68_long_compl_dtype init (8),
  9   117 	   algol68_bits_dtype     init (19),
  9   118 	   algol68_bool_dtype     init (19),
  9   119 	   algol68_char_dtype     init (21),
  9   120 	   algol68_byte_dtype     init (21),
  9   121 	   algol68_struct_struct_char_dtype init (22),
  9   122 	   algol68_struct_struct_bool_dtype init (20)
  9   123 	   )		      fixed bin internal static options (constant);
  9   124 
  9   125      dcl	   (label_constant_runtime_dtype init (24),
  9   126 	   int_entry_runtime_dtype init (25),
  9   127 	   ext_entry_runtime_dtype init (26),
  9   128 	   ext_procedure_runtime_dtype init (27),
  9   129 	   picture_runtime_dtype  init (63)
  9   130 	   )		      fixed bin internal static options (constant);
  9   131 
  9   132      dcl	   (pascal_integer_dtype  init (1),
  9   133 	   pascal_real_dtype      init (4),
  9   134 	   pascal_label_dtype     init (24),
  9   135 	   pascal_internal_procedure_dtype init (25),
  9   136 	   pascal_exportable_procedure_dtype init (26),
  9   137 	   pascal_imported_procedure_dtype init (27),
  9   138 	   pascal_typed_pointer_type_dtype init (64),
  9   139 	   pascal_char_dtype      init (65),
  9   140 	   pascal_boolean_dtype   init (66),
  9   141 	   pascal_record_file_type_dtype init (67),
  9   142 	   pascal_record_type_dtype init (68),
  9   143 	   pascal_set_dtype	      init (69),
  9   144 	   pascal_enumerated_type_dtype init (70),
  9   145 	   pascal_enumerated_type_element_dtype init (71),
  9   146 	   pascal_enumerated_type_instance_dtype init (72),
  9   147 	   pascal_user_defined_type_dtype init (73),
  9   148 	   pascal_user_defined_type_instance_dtype init (74),
  9   149 	   pascal_text_file_dtype init (75),
  9   150 	   pascal_procedure_type_dtype init (76),
  9   151 	   pascal_variable_formal_parameter_dtype init (77),
  9   152 	   pascal_value_formal_parameter_dtype init (78),
  9   153 	   pascal_entry_formal_parameter_dtype init (79),
  9   154 	   pascal_parameter_procedure_dtype init (80),
  9   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  9   156 
  9   157 
  9   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
     1644 
     1645 
 10     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
 10     2*
 10     3*   25 June 79 JRDavis
 10     4*
 10     5*   Modified  7 April 1983, TO - Add fields for character offset/line
 10     6*	correction per file.
 10     7**/
 10     8 
 10     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
 10    10     2 language_type fixed bin,			/* language of source program */
 10    11     2 bits aligned,
 10    12       3 ignore_case bit (1) unal,
 10    13       3 bound_segment bit (1) unaligned,
 10    14       3 component bit (1) unaligned,
 10    15       3 pad bit (33) unal,
 10    16     2 names,					/* where to find it */
 10    17       3 directory_name character (168) unal,		/* what directory */
 10    18       3 entry_name character (32) unal,			/* what segment */
 10    19       3 segname character (32) unal,			/* procedure segname definition */
 10    20     2 identifier fixed bin (71),			/* time of object creation */
 10    21     2 pointers,					/* location of various parts of segment */
 10    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
 10    23       3 original_source_ptr ptr unal,			/* to segment source map */
 10    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
 10    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
 10    26*						   bound ones, -> break_map !obsolete, I think! */
 10    27       3 chain ptr unal,				/* to entry for next component if bound */
 10    28       3 linkage_ptr ptr unal,				/* to linkage section */
 10    29     2 bounds aligned,				/* structure of bounds information */
 10    30       3 text_bounds,
 10    31         4 start fixed bin (35),
 10    32         4 end fixed bin (35),
 10    33       3 symbol_bounds,
 10    34         4 start fixed bin (35),
 10    35         4 end fixed bin (35),
 10    36     2 map_size fixed bin,				/* size of statement map */
 10    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
 10    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
 10    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
 10    40     2 pad (1) fixed bin (35),
 10    41 
 10    42     2 nfiles fixed bin,
 10    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
 10    44       3 file_pointers ptr unal,
 10    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
 10    46 
 10    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
 10    48 
 10    49 
 10    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
     1646 
     1647 
 11     1 dcl	1 statement_map	aligned based,
 11     2 	2 location	bit(18) unaligned,
 11     3 	2 source_id	unaligned,
 11     4 	  3 file		bit(8),
 11     5 	  3 line		bit(14),
 11     6 	  3 statement	bit(5),
 11     7 	2 source_info	unaligned,
 11     8 	  3 start		bit(18),
 11     9 	  3 length	bit(9);
     1648 
     1649 
 12     1 /* BEGIN INCLUDE FILE ...  probe_break_slot.incl.pl1
 12     2*
 12     3*   This is separate from probe_break_info.incl.pl1 because many programs
 12     4*   need to get at a break_slot, but don't deserve to see the rest of that information
 12     5*
 12     6**/
 12     7 
 12     8 dcl 1 break_slot based (bsp) aligned,			/* describes (and handles) each probe break */
 12     9     2 item_type fixed bin,				/* 0 -> break_slot type code */
 12    10     2 breakmap_header_offset bit (18) unal,		/* to break map header, chain is not used */
 12    11     2 statement_item_offset bit (18) unal,
 12    12     2 size fixed bin,				/* number of words in the break_slot */
 12    13     2 sequence (0:7),				/* "before" or "after" instructions to "trap" the break */
 12    14       3 offset bit (18) unaligned,			/* address portion, some patched */
 12    15       3 skip bit (18) unaligned,			/* op code portion */
 12    16     2 old_instruction bit (36) aligned,			/* instruction that was replaced by break */
 12    17     2 symbol_block_offset bit (18) unal,		/*  for containing block */
 12    18     2 location bit (18) unal,				/* offset of instruction that was replaced by break */
 12    19     2 type fixed bin,				/* 0 -> after, 1 -> before */
 12    20     2 count fixed bin,				/* number of characters in command list */
 12    21     2 command_list character (0 refer (break_slot.count));	/* command list associated with break */
 12    22 
 12    23 dcl bsp ptr;
 12    24 
 12    25 dcl (BREAK_AFTER init (0),
 12    26      BREAK_BEFORE init (1),
 12    27      BREAK_AT init (2)) fixed bin internal static options (constant);
 12    28 
 12    29 dcl  PLACE (0:2) char (8) aligned internal static options (constant) init ("after", "before", "at");
 12    30 
 12    31 /* END INCLUDE FILE ... probe_break_slot.incl.pl1 */
     1650 
     1651 
 13     1 /* BEGIN INCLUDE FILE  ... probe_lang_types.incl.pl1
 13     2*
 13     3*   JRD 26 June 79
 13     4*   MBW 31 July 1981 to add algol68 */
 13     5 
 13     6 
 13     7 /****^  HISTORY COMMENTS:
 13     8*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
 13     9*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
 13    10*     Added C Language type.
 13    11*                                                   END HISTORY COMMENTS */
 13    12 
 13    13 
 13    14 /*   Modified June 83 JMAthane to add PASCAL language type */
 13    15 /*   Modified April 88 Hinatsu to add C language type */
 13    16 
 13    17      dcl	   (UNKNOWN_lang_type     init (1),
 13    18 	   OTHER_lang_type	      init (2),
 13    19 	   PL1_lang_type	      init (3),
 13    20 	   FORTRAN_lang_type      init (4),
 13    21 	   COBOL_lang_type	      init (5),
 13    22 	   ALM_lang_type	      init (6),
 13    23 	   ALGOL68_lang_type      init (7),
 13    24 	   PASCAL_lang_type	      init (8),
 13    25 	   C_lang_type	      init (9)) fixed bin internal static options (constant);
 13    26 
 13    27      dcl	   official_language_names (9) char (32) internal static options (constant) init
 13    28 			      ("Unknown", "other", "PL/I", "FORTRAN", "COBOL", "ALM", "Algol 68", "Pascal", "C");
 13    29 
 13    30      dcl	   palatable_language_names (9) char (32) internal static options (constant) init
 13    31 			      ("Unknown", "Other", "pl1", "fortran", "cobol", "alm", "algol68", "pascal", "c");
 13    32 
 13    33 /* END INCLUDE FILE ... probe_lang_types.incl.pl1 */
     1652 
     1653 
 14     1 /*	BEGIN INCLUDE FILE probe_info_constants.incl.pl1	*/
 14     2 /*	Created: 06/25/79 W. Olin Sibert		*/
 14     3 
 14     4 dcl (RETURN_TO_CALLER init (1),			/* return methods */
 14     5      RETURN_TO_FRAME init (2),
 14     6      RETURN_TO_CONDITION init (3),
 14     7      RETURN_TO_BREAK init (4)) fixed bin internal static options (constant);
 14     8 
 14     9 dcl (ENTRY_AT_CALL init (1),				/* entered by a call to probe */
 14    10      ENTRY_AT_BREAK init (2), 			/* entered by a call to probe$break */
 14    11      ENTRY_AT_HALT init (3)) fixed bin internal static options (constant); /* entered by a call to probe$halt */
 14    12 
 14    13 dcl (CONSOLE_INPUT init (1),
 14    14      BREAK_INPUT init (2),
 14    15      MACRO_INPUT init (3)) fixed bin internal static options (constant);
 14    16 
 14    17 /*	END INCLUDE FILE probe_info_constants.incl.pl1	*/
     1654 
     1655 
     1656   end probe_requests_;		/* external procedure */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/88  1545.0  probe_requests_.pl1               >spec>install>MR12.2-1210>probe_requests_.pl1
1628         1    10/27/88  1339.2  probe_info.incl.pl1               >ldd>include>probe_info.incl.pl1
1630         2    11/12/82  1624.3  probe_static_info.incl.pl1        >ldd>include>probe_static_info.incl.pl1
1632         3    11/26/79  1320.6  probe_tokens.incl.pl1             >ldd>include>probe_tokens.incl.pl1
1634         4    11/11/88  1543.8  probe_references.incl.pl1         >spec>install>MR12.2-1210>probe_references.incl.pl1
1636         5    05/17/82  1411.1  probe_level_frame.incl.pl1        >ldd>include>probe_level_frame.incl.pl1
1638         6    11/26/79  1320.6  probe_source_info.incl.pl1        >ldd>include>probe_source_info.incl.pl1
1640         7    11/07/86  1550.3  stack_frame.incl.pl1              >ldd>include>stack_frame.incl.pl1
1642         8    10/26/88  1255.5  probe_operators.incl.pl1          >ldd>include>probe_operators.incl.pl1
1644         9    10/26/88  1255.5  std_descriptor_types.incl.pl1     >ldd>include>std_descriptor_types.incl.pl1
1646        10    11/02/83  1845.0  probe_seg_info.incl.pl1           >ldd>include>probe_seg_info.incl.pl1
1648        11    05/06/74  1751.6  statement_map.incl.pl1            >ldd>include>statement_map.incl.pl1
1650        12    07/15/80  1728.8  probe_break_slot.incl.pl1         >ldd>include>probe_break_slot.incl.pl1
1652        13    10/26/88  1255.5  probe_lang_types.incl.pl1         >ldd>include>probe_lang_types.incl.pl1
1654        14    11/26/79  1320.9  probe_info_constants.incl.pl1     >ldd>include>probe_info_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BREAK_AFTER                            constant        fixed bin(17,0)          initial dcl 12-25 ref 1184 1363
BREAK_AT                               constant        fixed bin(17,0)          initial dcl 12-25 ref 1167 1196 1212
BREAK_BEFORE                           constant        fixed bin(17,0)          initial dcl 12-25 ref 1191 1371
COLON                                  constant        bit(18)                  initial dcl 8-17 ref 1389 1417
CONSTANT_TYPE                          constant        bit(18)                  initial packed unaligned dcl 3-37 ref 349 436 495
                                                                                  541 756 793 831 855 1164 1393
C_INDIRECTION                          constant        bit(18)                  initial dcl 8-17 ref 1159
DEFAULT_BREAK_REQUEST           000006 constant        char(4)                  initial dcl 1357 set ref 1413 1414
DEFAULT_CASE                           constant        fixed bin(17,0)          initial dcl 1120 ref 1144 1148 1157 1246 1292
GREATER_THAN                           constant        bit(18)                  initial dcl 8-17 ref 947 950
LESS_THAN                              constant        bit(18)                  initial dcl 8-17 ref 807 947
LINE_CASE                              constant        fixed bin(17,0)          initial dcl 1120 ref 1211 1229 1283 1302
MINUS                                  constant        bit(18)                  initial dcl 8-17 ref 748 750 831 839 850 852
NAME_TYPE                              constant        bit(18)                  initial packed unaligned dcl 3-37 ref 377 415 421
                                                                                  452 536 764 831 950 985 1178
NL                                     constant        char(1)                  initial packed unaligned dcl 84 ref 1592
NOT_PRIVATE                     000057 constant        bit(1)                   initial dcl 75 set ref 208* 215* 244* 250*
PLACE                           000000 constant        char(8)                  initial array dcl 12-29 set ref 1204* 1320* 1486*
PLUS                                   constant        bit(18)                  initial dcl 8-17 ref 748 831 839 850
PRIVATE                         000045 constant        bit(1)                   initial dcl 75 set ref 287* 323*
P_i                                    parameter       fixed bin(17,0)          dcl 643 ref 638 645 660 661 663 665 665
P_iocb_ptr                             parameter       pointer                  dcl 1608 set ref 1602 1614 1614 1614 1614 1617*
                                                                                  1618* 1619* 1622*
P_new_iocb_ptr                         parameter       pointer                  dcl 1608 ref 1602 1622
P_new_private_sw                       parameter       bit(1)                   dcl 1610 ref 1602 1623
P_private_sw                           parameter       bit(1)                   dcl 1610 set ref 1602 1614 1623*
P_probe_info_ptr                       parameter       pointer                  dcl 73 ref 191 197 227 233 259 264 295 300 331 337
                                                                                  403 410 478 491 517 534 595 605 672 716 723 958
                                                                                  974 1076 1083 1133 1345 1366 1375 1494 1504
P_str                                  parameter       varying char             dcl 1578 set ref 1573 1592*
SEG_CASE                               constant        fixed bin(17,0)          initial dcl 1120 ref 1203 1287 1306
STAR_CASE                              constant        fixed bin(17,0)          initial dcl 1120 ref 1162 1257 1310
STREAM_INPUT                    000070 constant        fixed bin(17,0)          initial dcl 79 set ref 280*
STREAM_OUTPUT                   000067 constant        fixed bin(17,0)          initial dcl 79 set ref 316*
STRING_CASE                            constant        fixed bin(17,0)          initial dcl 1120 ref 1166 1260
TIMES                                  constant        bit(18)                  initial dcl 8-17 ref 1159
WORLD_CASE                             constant        fixed bin(17,0)          initial dcl 1120 ref 1152 1257 1299
addr                                                   builtin function         dcl 162 ref 375 381 381 385 450 456 456 460 556 556
                                                                                  647 647 665 665 781 781 786 786 799 799 885 885
                                                                                  914 914 932 932 936 936 1252 1252 1264 1264 1271
                                                                                  1271 1275 1275 1283 1283 1287 1287 1294 1294 1302
                                                                                  1302 1306 1306 1402 1402 1413 1447 1447 1460 1460
                                                                                  1482 1482
attach_description              000241 automatic       varying char(256)        dcl 103 set ref 274* 276 278* 310* 312 314*
binary                                                 builtin function         dcl 162 ref 1058 1058
block_name                      000344 automatic       varying char(256)        dcl 334 set ref 381* 385 456* 460
break_info               50            based           structure                level 2 dcl 1-18
break_location                  001060 automatic       fixed bin(17,0)          dcl 1350 set ref 1363* 1371* 1482* 1486
break_slot                             based           structure                level 1 dcl 12-8
break_slot_ptr           50            based           pointer                  level 3 dcl 1-18 ref 1246 1252
brief_sw                 36            based           bit(1)                   level 3 packed packed unaligned dcl 2-8 ref 1486
buffer_lth               16            based           fixed bin(21,0)          level 3 dcl 1-18 ref 1592
buffer_ptr               15            based           pointer                  level 3 packed packed unaligned dcl 1-18 ref 1592
case                            001034 automatic       fixed bin(17,0)          dcl 1091 set ref 1144* 1148* 1152* 1157* 1162* 1166*
                                                                                  1203* 1211* 1229 1246 1257 1257 1260 1283 1287
                                                                                  1292 1299 1302 1306 1310
char_dtype                             constant        fixed bin(17,0)          initial dcl 9-25 ref 499 793 807 1164 1393
code                            000100 automatic       fixed bin(35,0)          dcl 87 set ref 164* 167* 171* 204* 205 240* 241 276*
                                                                                  278 278* 280* 281 283* 312* 314 314* 316* 317 319*
                                                                                  351* 356* 360 360* 438* 439 439* 543* 544 556* 558
                                                                                  569* 570 575* 576 576* 579* 581* 610* 611 617*
                                                                                  622* 647* 651 653 654* 655* 726* 760* 761 781*
                                                                                  786* 799* 863* 868* 871 906 914* 917 921* 932*
                                                                                  936* 939 1016* 1017 1018* 1139* 1140 1218* 1220
                                                                                  1252* 1257* 1264* 1267 1271* 1275* 1278 1283*
                                                                                  1287* 1294* 1299* 1302* 1306* 1310* 1320 1324 1340
                                                                                  1402* 1404 1421* 1423 1430* 1432 1447* 1450 1450*
                                                                                  1460* 1463 1468* 1482* 1484
command_line_lth                000520 automatic       fixed bin(21,0)          dcl 485 set ref 504* 509*
command_line_ptr                000522 automatic       pointer                  dcl 488 set ref 503* 509*
constant                               based           structure                level 1 dcl 3-27
constant_string                        based           char                     packed unaligned dcl 100 set ref 799* 1168 1396
control                   0(01) 000634 automatic       bit(1)                   level 2 packed packed unaligned dcl 964 set ref 978*
                                                                                  992* 1005 1005* 1029
ct                       13            based           pointer                  level 3 packed packed unaligned dcl 1-18 set ref 202
                                                                                  238 269 305 340 349 351 377 385 385 388 388 388
                                                                                  414 415 415 418 463 463 463 495 499 503 504 536
                                                                                  537 541 564 564 607 729 746 748 748 750 756 764
                                                                                  764 764 764 764 793 793 799 799 799 807 807 811*
                                                                                  811 831 834 834 834 834 839 839 846 846 846 846
                                                                                  846 846 855 863 947 947 950 950 978 982 985 988
                                                                                  988 988 988 988 988 988 988 992 992 992 992 992
                                                                                  992 992 992 992 992 998 998 1157 1159 1159 1164
                                                                                  1164 1168 1168 1178 1178 1178 1178 1178 1178 1178
                                                                                  1186 1186 1186 1186 1186 1186 1193 1193 1389 1389
                                                                                  1393 1393 1396 1396 1411 1417 1519 1533 1537 1551
                                                                                  1565* 1565 1567 1583 1585 1590
ctl                             001037 automatic       varying char(64)         dcl 1094 set ref 1139* 1143 1143 1147 1147 1152 1152
                                                                                  1154 1154 1218* 1233 1233 1235 1235 1237 1237
cu_$cp                          000140 constant        entry                    external dcl 486 ref 509
current_identifier_name                based           char                     packed unaligned dcl 3-42 set ref 385 388* 415 463*
                                                                                  564 764 764 834 834 846 846 846 988 988 988 988
                                                                                  992 992 992 992 992 998 1178 1178 1178 1186 1186
                                                                                  1186 1193
current_source                         based           structure                level 1 dcl 6-13 set ref 556 556 628 779 798 820
                                                                                  910* 914 914 1262 1294 1294 1297 1389 1445
current_stack_frame      17            based           pointer                  level 3 packed packed unaligned dcl 1-18 ref 344 430
data_ptr                 11            based           pointer                  level 2 packed packed unaligned dcl 3-27 ref 503 799
                                                                                  1168 1396
data_type                10            based           fixed bin(17,0)          level 2 dcl 3-27 ref 499 793 807 1164 1393
data_type_found                 001035 automatic       fixed bin(17,0)          dcl 1092 set ref 933* 936* 1200 1200
directory_name            2            based           char(168)                level 3 packed packed unaligned dcl 10-9 set ref
                                                                                  1038* 1325
dn                              000735 automatic       char(168)                packed unaligned dcl 969 set ref 1016* 1022 1022
dn_len                          001027 automatic       fixed bin(17,0)          dcl 971 set ref 1016* 1022 1022
done                            001170 automatic       bit(1)                   dcl 1356 set ref 1455* 1456 1463*
en                              001007 automatic       char(32)                 packed unaligned dcl 970 set ref 1016* 1022*
encoded_precision         6            based           structure                level 2 dcl 3-27
end_pos                         001267 automatic       fixed bin(21,0)          dcl 1581 set ref 1590* 1592
end_token                14            based           bit(18)                  level 3 dcl 1-18 ref 202 238 269 305 340 418 537 607
                                                                                  729 978 982 1157 1389 1411 1519 1537 1551 1585
entry_name               54            based           char(32)                 level 3 packed packed unaligned dcl 10-9 set ref 422
                                                                                  1038* 1042 1329
error_table_$noentry            000040 external static fixed bin(35,0)          dcl 122 ref 653
execute                  64            based           bit(1)                   level 3 packed packed unaligned dcl 1-18 ref 199 235
                                                                                  266 302 339 412 509 555 586 778 797 818 874 905
                                                                                  1009 1243 1443
expand_pathname_                000142 constant        entry                    external dcl 527 ref 575
ext_entry_runtime_dtype                constant        fixed bin(17,0)          initial dcl 9-125 ref 1200
ext_procedure_runtime_dtype            constant        fixed bin(17,0)          initial dcl 9-125 ref 933 1200
file_pointers           117            based           pointer                  array level 3 packed packed unaligned dcl 10-9 set
                                                                                  ref 586*
first_match                     001167 automatic       fixed bin(17,0)          dcl 1355 set ref 1269* 1278 1453* 1463
fixed                                                  builtin function         dcl 162 ref 660 663
flags                    64            based           structure                level 2 dcl 1-18
frame_decimal                   000132 automatic       fixed bin(17,0)          dcl 92 set ref 351* 358* 362 362* 369
frame_number                    000131 automatic       fixed bin(17,0)          dcl 92 set ref 351* 356* 362 362 362* 369 438* 441
                                                                                  441 441* 446
hcs_$fs_get_path_name           000076 constant        entry                    external dcl 148 ref 1016
hcs_$initiate                   000144 constant        entry                    external dcl 529 ref 579
header                                 based           structure                level 2 in structure "operator" dcl 3-24
                                                                                  in procedure "probe_requests_"
header                                 based           structure                level 2 in structure "token" dcl 3-16 in procedure
                                                                                  "probe_requests_"
hp                              000630 automatic       pointer                  dcl 698 set ref 739* 740
i                               000615 automatic       fixed bin(17,0)          dcl 603 set ref 630* 633*
identifier                             based           structure                level 1 dcl 3-19
initial_source                         based           structure                level 1 dcl 6-14 set ref 731 1050* 1050* 1251 1252
                                                                                  1252
input_buffer                           based           char                     packed unaligned dcl 1579 ref 1592
input_switch             66            based           pointer                  level 3 in structure "probe_info" dcl 1-18
                                                                                  in procedure "probe_requests_" set ref 220* 291*
input_switch             62            based           pointer                  level 3 in structure "probe_static_info" dcl 2-8
                                                                                  in procedure "probe_requests_" set ref 208* 215*
                                                                                  220 287* 291
instruction_ptr           2            based           pointer                  level 2 in structure "current_source" dcl 6-13
                                                                                  in procedure "probe_requests_" set ref 665 665
instruction_ptr           2     000102 automatic       pointer                  level 2 in structure "new_source_info" dcl 89
                                                                                  in procedure "probe_requests_" set ref 732 740*
instruction_ptr           2            based           pointer                  level 2 in structure "initial_source" dcl 6-14
                                                                                  in procedure "probe_requests_" set ref 1058 1058
io_switches              62            based           structure                level 2 in structure "probe_static_info" dcl 2-8
                                                                                  in procedure "probe_requests_"
io_switches              66            based           structure                level 2 in structure "probe_info" dcl 1-18
                                                                                  in procedure "probe_requests_"
ioa_$ioa_switch                 000100 constant        entry                    external dcl 150 ref 1026 1047 1050 1058 1486
ioa_$rsnnl                      000102 constant        entry                    external dcl 151 ref 1033
iocb_ptr                        000342 automatic       pointer                  dcl 189 set ref 204* 208 208* 240* 244 244* 276*
                                                                                  280* 282* 287* 312* 316* 318* 323*
iox_$attach_name                000104 constant        entry                    external dcl 152 ref 276 312
iox_$close                      000106 constant        entry                    external dcl 154 ref 1617
iox_$destroy_iocb               000110 constant        entry                    external dcl 155 ref 1619
iox_$detach_iocb                000112 constant        entry                    external dcl 156 ref 282 318 1618
iox_$error_output               000130 external static pointer                  dcl 182 ref 1614
iox_$open                       000114 constant        entry                    external dcl 157 ref 280 316
iox_$user_input                 000124 external static pointer                  dcl 182 set ref 215* 1614
iox_$user_io                    000132 external static pointer                  dcl 182 ref 1614
iox_$user_output                000126 external static pointer                  dcl 182 set ref 250* 1614
language_type            21            based           fixed bin(17,0)          level 3 in structure "probe_info" dcl 1-18
                                                                                  in procedure "probe_requests_" set ref 908*
language_type                          based           fixed bin(17,0)          level 2 in structure "seg_info" dcl 10-9
                                                                                  in procedure "probe_requests_" ref 908
last_break_segno         47            based           bit(18)                  level 2 dcl 2-8 set ref 1504*
len                             000616 automatic       fixed bin(17,0)          dcl 603 set ref 661* 663* 665*
length                                                 builtin function         dcl 162 in procedure "probe_requests_" ref 1033 1033
                                                                                  1414
length                    6            based           fixed bin(17,0)          level 2 in structure "identifier" dcl 3-19
                                                                                  in procedure "probe_requests_" ref 385 388 388 415
                                                                                  463 463 564 764 764 834 834 846 846 846 988 988
                                                                                  988 988 992 992 992 992 992 998 1178 1178 1178
                                                                                  1186 1186 1186 1193
level                           000133 automatic       fixed bin(17,0)          dcl 92 set ref 1031* 1033 1033*
level_chain              50            based           pointer                  level 3 packed packed unaligned dcl 2-8 ref 348 435
level_frame                            based           structure                level 1 dcl 5-6
level_string                    000120 automatic       varying char(32)         dcl 91 set ref 1033* 1033 1033 1047* 1050* 1058*
lfp                             001174 automatic       pointer                  dcl 5-24 set ref 348* 369 369 371* 371 372 375 381
                                                                                  381 385 388 392* 392 435* 446 446 448* 448 450 456
                                                                                  456 460 463 467* 467
line_invocation                 000622 automatic       fixed bin(17,0)          dcl 693 set ref 936*
listener_info           210            based           structure                level 2 dcl 1-18
loc                             000632 automatic       bit(18)                  packed unaligned dcl 699 set ref 737* 740
location                               based           bit(18)                  array level 2 in structure "map_array" packed packed
                                                                                  unaligned dcl 95 in procedure "probe_requests_"
                                                                                  ref 660 663 665 665 737
location                  4            based           fixed bin(17,0)          level 3 in structure "token" packed packed unaligned
                                                                                  dcl 3-16 in procedure "probe_requests_" ref 1583
                                                                                  1590
location_string                 000635 automatic       char(256)                packed unaligned dcl 968 set ref 1022* 1024* 1026*
                                                                                  1038* 1042* 1042 1047*
long_sw                         001033 automatic       bit(1)                   dcl 1090 set ref 1145* 1149* 1227* 1229* 1231* 1233*
                                                                                  1235* 1252* 1257* 1271* 1283* 1287* 1294* 1299*
                                                                                  1302* 1306*
map_array                              based           structure                array level 1 dcl 95
map_size                110            based           fixed bin(17,0)          level 2 in structure "seg_info" dcl 10-9
                                                                                  in procedure "probe_requests_" ref 626
map_size                        000134 automatic       fixed bin(21,0)          dcl 97 in procedure "probe_requests_" set ref 626*
                                                                                  630 661
max_level                51            based           fixed bin(17,0)          level 3 dcl 2-8 ref 362 441
min                                                    builtin function         dcl 162 ref 630
mod_type                        001036 automatic       fixed bin(17,0)          dcl 1093 set ref 1167* 1177* 1184* 1191* 1196* 1204
                                                                                  1204 1212 1212* 1271* 1283* 1302* 1320
name                      7            based           pointer                  level 2 packed packed unaligned dcl 3-19 ref 385 388
                                                                                  415 463 564 764 764 834 834 846 846 846 988 988
                                                                                  988 988 992 992 992 992 992 998 1178 1178 1178
                                                                                  1186 1186 1186 1193
names                     2            based           structure                level 2 dcl 10-9
new_source_info                 000102 automatic       structure                level 1 dcl 89 set ref 628* 647 647 665 665 731*
                                                                                  779* 781 781 786 786 798* 799 799 820* 885 885 910
                                                                                  932 932 936 936 1251* 1262* 1264 1264 1271 1271
                                                                                  1275 1275 1283 1283 1287 1287 1297* 1302 1302 1306
                                                                                  1306 1320* 1320* 1389* 1402 1402 1445* 1447 1447
                                                                                  1460 1460 1482 1482 1486* 1486*
next                                   based           pointer                  level 3 in structure "token" packed packed unaligned
                                                                                  dcl 3-16 in procedure "probe_requests_" ref 746
                                                                                  807 811 855 950 1533 1537 1565
next                                   based           pointer                  level 2 in structure "level_frame" packed packed
                                                                                  unaligned dcl 5-6 in procedure "probe_requests_"
                                                                                  ref 371 388 392 448 463 467
next_token_type                 000633 automatic       bit(18)                  packed unaligned dcl 699 set ref 746* 831 831 831
                                                                                  850 850 852
null                                                   builtin function         dcl 162 ref 208 244 276 276 312 312 372 378 379 388
                                                                                  420 453 454 463 581 616 621 732 732 736 1050 1246
                                                                                  1533 1567
number_to_position              000623 automatic       fixed bin(17,0)          dcl 694 set ref 760* 774* 774 781* 786*
number_to_print                 000524 automatic       fixed bin(17,0)          dcl 523 set ref 537* 543* 547 556* 607* 610* 630
operator                               based           structure                level 1 dcl 3-24
output_switch            64            based           pointer                  level 3 in structure "probe_static_info" dcl 2-8
                                                                                  in procedure "probe_requests_" set ref 244* 250*
                                                                                  255 323* 327
output_switch            70            based           pointer                  level 3 in structure "probe_info" dcl 1-18
                                                                                  in procedure "probe_requests_" set ref 255* 327*
                                                                                  1026* 1047* 1050* 1058* 1486*
path                      0(02) 000634 automatic       bit(1)                   level 2 packed packed unaligned dcl 964 set ref 998*
                                                                                  1013 1036
pathname                        000140 automatic       varying char(256)        dcl 102 set ref 569* 575 576* 1325* 1327* 1327 1329*
                                                                                  1329 1332* 1332 1333* 1333 1337*
pathname_                       000116 constant        entry                    external dcl 159 ref 1022 1038
per_file                117            based           structure                array level 2 dcl 10-9
pointer                                                builtin function         dcl 162 ref 665 665 740
pointers                 76            based           structure                level 2 dcl 10-9
position_backwards              000625 automatic       bit(1)                   dcl 696 set ref 727* 750* 774 852* 877
position_lines                  000624 automatic       bit(1)                   dcl 695 set ref 727* 768* 781 836*
precision                 6(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 3-27 ref 799 799
                                                                                  1168 1396
prev_sp                  20            based           pointer                  level 2 dcl 7-36 set ref 344* 430*
print_it                        000617 automatic       bit(1)                   dcl 689 set ref 712* 720* 914
printed_decimal           4            based           fixed bin(17,0)          level 2 dcl 5-6 ref 369 446
printed_number            3            based           fixed bin(17,0)          level 2 dcl 5-6 ref 369 446
private_input_sw         66            based           bit(1)                   level 3 dcl 2-8 set ref 208* 215* 287*
private_output_sw        67            based           bit(1)                   level 3 dcl 2-8 set ref 244* 250* 323*
probe_block_name_               000056 constant        entry                    external dcl 132 ref 381 456 1050 1058
probe_break_mgr_$list_breaks_at_line
                                000170 constant        entry                    external dcl 1109 ref 1302
probe_break_mgr_$list_breaks_in_seg
                                000172 constant        entry                    external dcl 1112 ref 1294 1306
probe_break_mgr_$list_breaks_in_world
                                000174 constant        entry                    external dcl 1115 ref 1299
probe_break_mgr_$list_broken_segs
                                000176 constant        entry                    external dcl 1117 ref 1310
probe_break_mgr_$print_instructions
                                000032 constant        entry                    external dcl 117 ref 665
probe_break_mgr_$reset_break_at_line
                                000162 constant        entry                    external dcl 1100 ref 1252 1271 1283
probe_break_mgr_$reset_breaks_in_seg
                                000164 constant        entry                    external dcl 1103 ref 1287
probe_break_mgr_$reset_breaks_in_world
                                000166 constant        entry                    external dcl 1106 ref 1257
probe_break_mgr_$set_break      000206 constant        entry                    external dcl 1359 ref 1482
probe_error_                    000060 constant        entry                    external dcl 134 ref 167 171 269 278 283 305 314 319
                                                                                  360 362 388 439 441 463 495 499 547 576 581 815
                                                                                  921 1018 1068 1154 1204 1237 1246 1320 1337 1437
                                                                                  1450 1519 1533 1537 1551
probe_error_$malfunction        000034 constant        entry                    external dcl 119 ref 28
probe_error_$warning            000036 constant        entry                    external dcl 121 ref 654
probe_et_$bad_ctl_arg           000012 external static fixed bin(35,0)          dcl 105 set ref 1154* 1237*
probe_et_$bad_line              000014 external static fixed bin(35,0)          dcl 105 ref 617
probe_et_$breakless             000202 external static fixed bin(35,0)          dcl 1315 set ref 1320 1320*
probe_et_$e_syntax_err          000010 external static fixed bin(35,0)          dcl 105 set ref 495* 499*
probe_et_$no_breaks             000204 external static fixed bin(35,0)          dcl 1315 set ref 1324 1337*
probe_et_$no_statement_map      000016 external static fixed bin(35,0)          dcl 105 ref 622
probe_et_$noarg                 000020 external static fixed bin(35,0)          dcl 105 set ref 1551*
probe_et_$none_active           000022 external static fixed bin(35,0)          dcl 105 set ref 1246*
probe_et_$syntax_error          000024 external static fixed bin(35,0)          dcl 105 ref 164
probe_et_$too_many_args         000026 external static fixed bin(35,0)          dcl 105 set ref 1519* 1533* 1537*
probe_et_$unimplemented_request 000030 external static fixed bin(35,0)          dcl 105 set ref 815*
probe_get_$control_arg          000200 constant        entry                    external dcl 1130 ref 1139 1218
probe_get_$decimal              000042 constant        entry                    external dcl 123 ref 351 863
probe_get_$integer              000044 constant        entry                    external dcl 125 ref 356 438 543 610 760 868
probe_get_$io_switch            000122 constant        entry                    external dcl 181 ref 204 240
probe_get_$line                 000046 constant        entry                    external dcl 126 ref 936 1402
probe_get_$object               000052 constant        entry                    external dcl 129 ref 932
probe_get_$pathname             000050 constant        entry                    external dcl 128 ref 569
probe_get_$request_list         000054 constant        entry                    external dcl 130 ref 1421
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  001172 automatic       pointer                  dcl 1-86 set ref 167* 167 171* 197* 199 202 202 204*
                                                                                  208 208 215 215 220 220 233* 235 238 238 240* 244
                                                                                  244 250 250 255 255 264* 266 269 269 269* 278*
                                                                                  283* 287 287 291 291 300* 302 305 305 305* 314*
                                                                                  319* 323 323 327 327 337* 339 340 340 340 344* 344
                                                                                  348 349 351 351* 356* 360* 362 362* 377 381* 385
                                                                                  385 388* 388 388 388 399* 410* 412 414 415 415 418
                                                                                  418 419 430* 430 435 438* 439* 441 441* 456* 463*
                                                                                  463 463 463 474* 491* 495 495* 499 499* 503 504
                                                                                  509 534* 536 537 537 541 543* 547* 555 556* 556
                                                                                  556 564 564 569* 576* 581* 586 586 605* 607 607
                                                                                  610* 615 628 630 630 647* 654* 665* 665 665 723*
                                                                                  729 729 731 746 748 748 750 756 760* 764 764 764
                                                                                  764 764 778 779 781* 786* 793 793 797 798 799* 799
                                                                                  799 799 807 807 811 811 815* 818 820 831 834 834
                                                                                  834 834 839 839 846 846 846 846 846 846 855 863
                                                                                  863* 868* 874 880* 885* 905 908 910 914* 914 914
                                                                                  921* 932* 936* 947 947 950 950 974* 978 978 982
                                                                                  982 985 988 988 988 988 988 988 988 988 992 992
                                                                                  992 992 992 992 992 992 992 992 998 998 1009 1014*
                                                                                  1014 1018* 1024* 1024 1026 1031* 1031 1037 1047
                                                                                  1050 1050 1050* 1050 1050* 1050 1050* 1050 1058
                                                                                  1058* 1058 1058 1058 1068* 1133* 1139* 1154* 1157
                                                                                  1157 1159 1159 1164 1164 1168 1168 1178 1178 1178
                                                                                  1178 1178 1178 1178 1186 1186 1186 1186 1186 1186
                                                                                  1193 1193 1204* 1218* 1237* 1243 1246 1246* 1251
                                                                                  1252* 1252 1252 1252 1257* 1262 1264* 1271* 1275*
                                                                                  1283* 1287* 1294* 1294 1294 1297 1299* 1302* 1306*
                                                                                  1310* 1320* 1320* 1320* 1337* 1375* 1389 1389 1389
                                                                                  1389 1393 1393 1396 1396 1402* 1411 1411 1417
                                                                                  1421* 1428 1430* 1435 1437* 1443 1445 1447* 1450*
                                                                                  1460* 1482* 1486 1486 1486* 1486* 1519 1519 1519*
                                                                                  1533 1533* 1537 1537 1537* 1551 1551 1551* 1565
                                                                                  1565 1567 1583 1585 1585 1590 1592 1592
probe_line_number_              000062 constant        entry                    external dcl 135 ref 1050 1050 1320 1320 1486 1486
probe_listen_$check_line        000160 constant        entry                    external dcl 1097 ref 1430
probe_pretty_source_info_       000064 constant        entry                    external dcl 137 ref 1024
probe_print_arglist_            000134 constant        entry                    external dcl 335 ref 399
probe_print_handlers_           000136 constant        entry                    external dcl 406 ref 474
probe_source_segment_$find_source
                                000152 constant        entry                    external dcl 705 ref 799 1264 1275 1447 1460
probe_source_segment_$get_file_ptr
                                000066 constant        entry                    external dcl 139 ref 1014
probe_source_segment_$list_statement
                                000070 constant        entry                    external dcl 141 ref 556 647 914
probe_source_segment_$position_source
                                000146 constant        entry                    external dcl 701 ref 786
probe_source_segment_$position_source_lines
                                000150 constant        entry                    external dcl 703 ref 781
probe_stack_trace_$current_level
                                000154 constant        entry                    external dcl 707 ref 880
probe_stack_trace_$get_level    000156 constant        entry                    external dcl 709 ref 885
probe_stack_trace_$where_source_info
                                000072 constant        entry                    external dcl 143 ref 1031
probe_static_info                      based           structure                level 1 dcl 2-8
probe_trace_a_stack_            000074 constant        entry                    external dcl 145 ref 344 430
proc_name                       001017 automatic       char(32)                 packed unaligned dcl 970 set ref 1041* 1042
ptr_to_current_source
                          4            based           pointer                  level 2 dcl 1-18 set ref 340 419 556 556 586 615 628
                                                                                  630 630 665 665 779 798 820 910 914 914 1014*
                                                                                  1024* 1037 1262 1294 1294 1297 1389 1445
ptr_to_initial_source
                          6            based           pointer                  level 2 dcl 1-18 set ref 731 1031* 1050 1050 1050
                                                                                  1050* 1058* 1058 1058 1251 1252 1252
random_info              17            based           structure                level 2 dcl 1-18
rel                                                    builtin function         dcl 162 ref 1058 1058
rel_level_sw                    000626 automatic       bit(1)                   dcl 697 set ref 851* 858* 863 876
request_name            210            based           varying char(32)         level 3 dcl 1-18 set ref 167*
requests_lth                    001064 automatic       fixed bin(21,0)          dcl 1352 set ref 1414* 1421* 1430* 1482*
requests_ptr                    001062 automatic       pointer                  dcl 1351 set ref 1413* 1421* 1430* 1482*
reset_req                       001032 automatic       bit(1)                   dcl 1088 set ref 1079* 1086* 1227 1243
rtrim                                                  builtin function         dcl 162 ref 1042 1325 1329 1333 1592
scale                     6            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 3-27 ref 351 863
scale_and_precision       7            based           fixed bin(35,0)          level 2 dcl 3-27 ref 504
search_string                   001066 automatic       varying char(256)        dcl 1354 set ref 1168* 1264 1275 1396* 1447 1460
search_sw                       001065 automatic       bit(1)                   dcl 1353 set ref 1387* 1395* 1444
seg_info                               based           structure                level 1 dcl 10-9
seg_info_ptr             12            based           pointer                  level 2 in structure "current_source" dcl 6-13
                                                                                  in procedure "probe_requests_" set ref 586 615
                                                                                  1037
seg_info_ptr             12     000102 automatic       pointer                  level 2 in structure "new_source_info" dcl 89
                                                                                  in procedure "probe_requests_" set ref 732 734 739
                                                                                  908 1325 1329 1333
seg_info_ptr                    000612 automatic       pointer                  dcl 601 in procedure "probe_requests_" set ref 615*
                                                                                  616 620 626
seg_info_ptr             12            based           pointer                  level 2 in structure "initial_source" dcl 6-14
                                                                                  in procedure "probe_requests_" set ref 1050
seg_info_ptr             12            based           pointer                  level 2 in structure "source_info" dcl 6-5
                                                                                  in procedure "probe_requests_" ref 422
segname                  64            based           char(32)                 level 3 packed packed unaligned dcl 10-9 ref 1041
                                                                                  1042 1333
setting_break            64(04)        based           bit(1)                   level 3 packed packed unaligned dcl 1-18 set ref
                                                                                  1428* 1435*
sip                             001030 automatic       pointer                  dcl 972 set ref 1037* 1038 1038 1041 1042 1042
source                          000634 automatic       bit(1)                   level 2 packed packed unaligned dcl 964 set ref 978*
                                                                                  988* 1005 1005* 1012
source_dname                    000525 automatic       char(168)                packed unaligned dcl 524 set ref 575* 579* 581*
source_ename                    000577 automatic       char(32)                 packed unaligned dcl 525 set ref 575* 579* 581*
source_info                            based           structure                level 1 dcl 6-5 in procedure "probe_requests_"
source_info              12            based           structure                level 2 in structure "level_frame" dcl 5-6
                                                                                  in procedure "probe_requests_" set ref 375 381 381
                                                                                  385 450 456 456 460
source_ptr                      000116 automatic       pointer                  dcl 90 set ref 340* 375* 378* 379 385* 399* 419* 420
                                                                                  422 450* 453* 454 460* 474* 1014* 1016*
source_seg_ptr                  000610 automatic       pointer                  dcl 526 set ref 579* 581 586
stack_frame                            based           structure                level 1 dcl 7-36
stack_info               50            based           structure                level 2 dcl 2-8
stack_ptr                 6            based           pointer                  level 2 dcl 6-5 ref 420
start_offset                    000614 automatic       fixed bin(21,0)          dcl 602 set ref 660* 663
start_pos                       001266 automatic       fixed bin(21,0)          dcl 1581 set ref 1583* 1592 1592
statement_map                          based           structure                level 1 dcl 11-1
statement_map_ptr       100            based           pointer                  level 3 packed packed unaligned dcl 10-9 ref 620 734
                                                                                  1050
static_info_ptr           1            based           pointer                  level 2 packed packed unaligned dcl 1-18 ref 208 208
                                                                                  215 215 220 244 244 250 250 255 287 287 291 323
                                                                                  323 327 348 362 435 441 1486 1504
stmnt_map_entry_index           000102 automatic       fixed bin(17,0)          level 2 in structure "new_source_info" dcl 89
                                                                                  in procedure "probe_requests_" set ref 645* 737
                                                                                  1269 1278 1453 1463
stmnt_map_entry_index                  based           fixed bin(17,0)          level 2 in structure "current_source" dcl 6-13
                                                                                  in procedure "probe_requests_" set ref 630 630
stmt_map_ptr                    000136 automatic       pointer                  dcl 98 set ref 620* 621 660 663 665 665 734* 736 737
substr                                                 builtin function         dcl 162 ref 1022 1022 1592
switches                 36            based           structure                level 2 dcl 2-8
symbol_header_ptr        76            based           pointer                  level 3 packed packed unaligned dcl 10-9 ref 739
token                                  based           structure                level 1 dcl 3-16
token_header                           based           structure                level 1 dcl 3-4
token_info               12            based           structure                level 2 dcl 1-18
token_name                      000446 automatic       char(168)                packed unaligned dcl 408 set ref 415* 422* 460
token_type                      000445 automatic       bit(18)                  packed unaligned dcl 407 set ref 414* 415 421* 436
                                                                                  452
type                      2            based           bit(18)                  level 3 in structure "operator" dcl 3-24
                                                                                  in procedure "probe_requests_" ref 729 748 748 750
                                                                                  839 839 1417
type                     15            based           fixed bin(17,0)          level 2 in structure "break_slot" dcl 12-8
                                                                                  in procedure "probe_requests_" set ref 1252*
type                      2            based           bit(18)                  level 3 in structure "token" dcl 3-16 in procedure
                                                                                  "probe_requests_" ref 202 238 269 305 340 349 377
                                                                                  414 418 495 536 537 541 607 746 756 764 793 807
                                                                                  831 855 947 947 950 950 978 982 985 1157 1159 1159
                                                                                  1164 1178 1389 1389 1393 1411 1519 1537 1551 1585
unique_chars_                   000120 constant        entry                    external dcl 160 ref 276 312
use_decimal                     000621 automatic       fixed bin(17,0)          dcl 691 set ref 863* 869* 885*
use_level                       000620 automatic       fixed bin(17,0)          dcl 691 set ref 863* 868* 877* 877 880* 880 885*
want_locs                       000634 automatic       structure                level 1 dcl 964 set ref 976*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALGOL68_lang_type                      internal static fixed bin(17,0)          initial dcl 13-17
ALM_lang_type                          internal static fixed bin(17,0)          initial dcl 13-17
AMPERSAND                              internal static bit(18)                  initial dcl 8-17
ARROW                                  internal static bit(18)                  initial dcl 8-17
BREAK_INPUT                            internal static fixed bin(17,0)          initial dcl 14-13
COBOL_lang_type                        internal static fixed bin(17,0)          initial dcl 13-17
COMMA                                  internal static bit(18)                  initial dcl 8-17
CONSOLE_INPUT                          internal static fixed bin(17,0)          initial dcl 14-13
C_EQUAL                                internal static bit(18)                  initial dcl 8-17
C_LEFT_SHIFT                           internal static bit(18)                  initial dcl 8-17
C_NOT_EQUAL                            internal static bit(18)                  initial dcl 8-17
C_RIGHT_SHIFT                          internal static bit(18)                  initial dcl 8-17
C_lang_type                            internal static fixed bin(17,0)          initial dcl 13-17
DOLLAR_SIGN                            internal static bit(18)                  initial dcl 8-17
ENTRY_AT_BREAK                         internal static fixed bin(17,0)          initial dcl 14-9
ENTRY_AT_CALL                          internal static fixed bin(17,0)          initial dcl 14-9
ENTRY_AT_HALT                          internal static fixed bin(17,0)          initial dcl 14-9
EQUALS                                 internal static bit(18)                  initial dcl 8-17
FORTRAN_lang_type                      internal static fixed bin(17,0)          initial dcl 13-17
LEFT_BRACKET                           internal static bit(18)                  initial dcl 8-17
LEFT_PAREN                             internal static bit(18)                  initial dcl 8-17
MACRO_INPUT                            internal static fixed bin(17,0)          initial dcl 14-13
NEW_LINE                               internal static bit(18)                  initial dcl 8-17
NOT_EQUALS                             internal static bit(18)                  initial dcl 8-17
NOT_GREATER_THAN                       internal static bit(18)                  initial dcl 8-17
NOT_LESS_THAN                          internal static bit(18)                  initial dcl 8-17
NOT_SIGN                               internal static bit(18)                  initial dcl 8-17
OPERATOR_TYPE                          internal static bit(18)                  initial packed unaligned dcl 3-37
OPERATOR_VALUES                        internal static varying char(4)          initial array dcl 8-43
OR_BAR                                 internal static bit(18)                  initial dcl 8-17
OTHER_lang_type                        internal static fixed bin(17,0)          initial dcl 13-17
PASCAL_ARROW                           internal static bit(18)                  initial dcl 8-17
PASCAL_ASSIGN                          internal static bit(18)                  initial dcl 8-17
PASCAL_RANGE                           internal static bit(18)                  initial dcl 8-17
PASCAL_lang_type                       internal static fixed bin(17,0)          initial dcl 13-17
PERCENT                                internal static bit(18)                  initial dcl 8-17
PERIOD                                 internal static bit(18)                  initial dcl 8-17
PL1_lang_type                          internal static fixed bin(17,0)          initial dcl 13-17
QUESTION_MARK                          internal static bit(18)                  initial dcl 8-17
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 7-19
RETURN_TO_BREAK                        internal static fixed bin(17,0)          initial dcl 14-4
RETURN_TO_CALLER                       internal static fixed bin(17,0)          initial dcl 14-4
RETURN_TO_CONDITION                    internal static fixed bin(17,0)          initial dcl 14-4
RETURN_TO_FRAME                        internal static fixed bin(17,0)          initial dcl 14-4
RIGHT_BRACKET                          internal static bit(18)                  initial dcl 8-17
RIGHT_PAREN                            internal static bit(18)                  initial dcl 8-17
SEMI_COLON                             internal static bit(18)                  initial dcl 8-17
SLASH                                  internal static bit(18)                  initial dcl 8-17
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 7-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 7-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 7-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 7-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 7-27
UNKNOWN_lang_type                      internal static fixed bin(17,0)          initial dcl 13-17
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 9-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 9-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 9-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 9-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 9-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 9-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 9-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 9-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 9-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 9-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 9-25
bit_dtype                              internal static fixed bin(17,0)          initial dcl 9-25
bsp                                    automatic       pointer                  dcl 12-23
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 9-25
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 9-25
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 9-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 9-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 9-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 9-25
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 9-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
current_constant                       based           structure                level 1 dcl 3-44
current_token                          based           structure                level 1 dcl 3-45
cv_dec_                         000000 constant        entry                    external dcl 147
entry_dtype                            internal static fixed bin(17,0)          initial dcl 9-25
expression_area                        based           area(1024)               dcl 1-95
file_dtype                             internal static fixed bin(17,0)          initial dcl 9-25
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 9-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 9-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 9-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 9-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 9-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 9-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 9-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 9-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 9-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 9-96
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 9-96
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 9-96
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 9-125
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 9-125
label_dtype                            internal static fixed bin(17,0)          initial dcl 9-25
official_language_names                internal static char(32)                 initial array packed unaligned dcl 13-27
offset_dtype                           internal static fixed bin(17,0)          initial dcl 9-25
palatable_language_names               internal static char(32)                 initial array packed unaligned dcl 13-30
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 9-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 9-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 9-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 9-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 9-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 9-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 9-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 9-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 9-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 9-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 9-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 9-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 9-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 9-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 9-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 9-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 9-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 9-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 9-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 9-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 9-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 9-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 9-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 9-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 9-125
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 9-25
probe_area                             based           area(1024)               dcl 1-93
probe_exclude_names                    based           char(168)                array packed unaligned dcl 2-94
probe_info_directories                 based           char(168)                array packed unaligned dcl 2-91
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
probe_request_tables                   based           pointer                  array dcl 2-88
probe_seg_info_array                   based           structure                level 1 dcl 2-82
real_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 9-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 9-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
reference_arg_list                     based           structure                level 1 dcl 4-59
reference_node                         based           structure                level 1 dcl 4-16
reference_subscripts                   based           structure                level 1 dcl 4-64
scratch_area                           based           area(1024)               dcl 1-92
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 10-47
seg_info_offset_count                  automatic       fixed bin(17,0)          dcl 2-86
sp                                     automatic       pointer                  dcl 7-31
stack_frame_flags                      based           structure                level 1 dcl 7-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 7-33
structure_dtype                        internal static fixed bin(17,0)          initial dcl 9-25
subscript_reference_ptrs               based           structure                level 1 dcl 4-69
varying_bit_dtype                      internal static fixed bin(17,0)          initial dcl 9-25
varying_char_dtype                     internal static fixed bin(17,0)          initial dcl 9-25
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
AFTER_BEFORE_COMMON             006500 constant        label                    dcl 1375 ref 1364 1372
FIND_FRAME                      002110 constant        label                    dcl 430 ref 425
GOT_LOCATION                    004013 constant        label                    dcl 897 ref 743
MAIN_RETURN                     000444 constant        label                    dcl 177 ref 168 174 199 222 235 257 266 293 302 329
                                                                                  401 476 513 592 635 924 1009 1020 1066 1072 1267
                                                                                  1278 1342 1475 1507
NO_FRAME                        001620 constant        label                    dcl 362 ref 372
POSITION_LINE                   004012 constant        label                    dcl 894 ref 843
POSITION_REL                    003307 constant        label                    dcl 750 ref 839
SOME_ERROR                      000426 constant        label                    dcl 171 ref 205 241 544 558 570 611 618 623 653 761
                                                                                  871 917 939 1140 1220 1340 1404 1423 1432 1484
SYNTAX_ERROR                    000401 constant        label                    dcl 164 ref 377 452 541 564 756 846 855 1567
S_R_COM                         005117 constant        label                    dcl 1133 ref 1080 1087
WHERE_USAGE                     005046 constant        label                    dcl 1068 ref 985 998
after_request                   006456 constant        entry                    external dcl 1345
args_request                    001462 constant        entry                    external dcl 331
before_request                  006470 constant        entry                    external dcl 1366
bump_ct                         007565 constant        entry                    internal dcl 1559 ref 506 566 755 769 804 827 838
                                                                                  854 860 1002 1161 1170 1183 1190 1195 1398 1418
                                                                                  1587
enable_request                  007066 constant        entry                    external dcl 1494
execute_request                 002376 constant        entry                    external dcl 478
get_location                    007226 constant        entry                    internal dcl 927 ref 894 1199
handlers_request                002041 constant        entry                    external dcl 403
input_description_request       000666 constant        entry                    external dcl 259
input_switch_request            000450 constant        entry                    external dcl 191
object_request                  003067 constant        entry                    external dcl 595
output_description_request      001164 constant        entry                    external dcl 295
output_switch_request           000557 constant        entry                    external dcl 227
position_request                003202 constant        entry                    external dcl 672
print_object                    007101 constant        entry                    internal dcl 638 ref 633
probe_requests_                 000370 constant        entry                    external dcl 25
ps_use_com                      003223 constant        label                    dcl 723 ref 713 721
reject_argument                 007443 constant        entry                    internal dcl 1512 ref 207 243 507 546 573 772 897
                                                                                  1223 1426
reject_next_argument            007470 constant        entry                    internal dcl 1527 ref 795 813 861
require_argument                007540 constant        entry                    internal dcl 1545 ref 493 567 1419
resembles_path                  007304 constant        entry                    internal dcl 944 ref 930
reset_request                   005076 constant        entry                    external dcl 1076
rest_of_request                 007576 constant        entry                    internal dcl 1573 ref 274 310
set_break                       007334 constant        entry                    internal dcl 1479 ref 1458 1472
set_iocb                        007660 constant        entry                    internal dcl 1602 ref 208 215 244 250 287 323
source_request                  002507 constant        entry                    external dcl 517
status_request                  005110 constant        entry                    external dcl 1083
use_request                     003214 constant        entry                    external dcl 716
where_request                   004076 constant        entry                    external dcl 958

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11174       11404   10020       11204
Length     12330   10020       210         707    1154           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_requests_                    1072 external procedure  is an external procedure.  
print_object                            internal procedure  shares stack frame of external procedure probe_requests_.  
get_location                            internal procedure  shares stack frame of external procedure probe_requests_.  
resembles_path                          internal procedure  shares stack frame of external procedure probe_requests_.  
set_break                               internal procedure  shares stack frame of external procedure probe_requests_.  
reject_argument                         internal procedure  shares stack frame of external procedure probe_requests_.  
reject_next_argument                    internal procedure  shares stack frame of external procedure probe_requests_.  
require_argument                        internal procedure  shares stack frame of external procedure probe_requests_.  
bump_ct                                 internal procedure  shares stack frame of external procedure probe_requests_.  
rest_of_request                         internal procedure  shares stack frame of external procedure probe_requests_.  
set_iocb                                internal procedure  shares stack frame of external procedure probe_requests_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_requests_          000100 code                        probe_requests_
                         000102 new_source_info             probe_requests_
                         000116 source_ptr                  probe_requests_
                         000120 level_string                probe_requests_
                         000131 frame_number                probe_requests_
                         000132 frame_decimal               probe_requests_
                         000133 level                       probe_requests_
                         000134 map_size                    probe_requests_
                         000136 stmt_map_ptr                probe_requests_
                         000140 pathname                    probe_requests_
                         000241 attach_description          probe_requests_
                         000342 iocb_ptr                    probe_requests_
                         000344 block_name                  probe_requests_
                         000445 token_type                  probe_requests_
                         000446 token_name                  probe_requests_
                         000520 command_line_lth            probe_requests_
                         000522 command_line_ptr            probe_requests_
                         000524 number_to_print             probe_requests_
                         000525 source_dname                probe_requests_
                         000577 source_ename                probe_requests_
                         000610 source_seg_ptr              probe_requests_
                         000612 seg_info_ptr                probe_requests_
                         000614 start_offset                probe_requests_
                         000615 i                           probe_requests_
                         000616 len                         probe_requests_
                         000617 print_it                    probe_requests_
                         000620 use_level                   probe_requests_
                         000621 use_decimal                 probe_requests_
                         000622 line_invocation             probe_requests_
                         000623 number_to_position          probe_requests_
                         000624 position_lines              probe_requests_
                         000625 position_backwards          probe_requests_
                         000626 rel_level_sw                probe_requests_
                         000630 hp                          probe_requests_
                         000632 loc                         probe_requests_
                         000633 next_token_type             probe_requests_
                         000634 want_locs                   probe_requests_
                         000635 location_string             probe_requests_
                         000735 dn                          probe_requests_
                         001007 en                          probe_requests_
                         001017 proc_name                   probe_requests_
                         001027 dn_len                      probe_requests_
                         001030 sip                         probe_requests_
                         001032 reset_req                   probe_requests_
                         001033 long_sw                     probe_requests_
                         001034 case                        probe_requests_
                         001035 data_type_found             probe_requests_
                         001036 mod_type                    probe_requests_
                         001037 ctl                         probe_requests_
                         001060 break_location              probe_requests_
                         001062 requests_ptr                probe_requests_
                         001064 requests_lth                probe_requests_
                         001065 search_sw                   probe_requests_
                         001066 search_string               probe_requests_
                         001167 first_match                 probe_requests_
                         001170 done                        probe_requests_
                         001172 probe_info_ptr              probe_requests_
                         001174 lfp                         probe_requests_
                         001266 start_pos                   rest_of_request
                         001267 end_pos                     rest_of_request

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             r_ge_a              alloc_char_temp     cat_realloc_chars   call_ext_out_desc
call_ext_out        return_mac          shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$cp                        expand_pathname_              hcs_$fs_get_path_name         hcs_$initiate
ioa_$ioa_switch               ioa_$rsnnl                    iox_$attach_name              iox_$close
iox_$destroy_iocb             iox_$detach_iocb              iox_$open                     pathname_
probe_block_name_             probe_break_mgr_$list_breaks_at_line
probe_break_mgr_$list_breaks_in_seg                         probe_break_mgr_$list_breaks_in_world
probe_break_mgr_$list_broken_segs                           probe_break_mgr_$print_instructions
probe_break_mgr_$reset_break_at_line                        probe_break_mgr_$reset_breaks_in_seg
probe_break_mgr_$reset_breaks_in_world                      probe_break_mgr_$set_break    probe_error_
probe_error_$malfunction      probe_error_$warning          probe_get_$control_arg        probe_get_$decimal
probe_get_$integer            probe_get_$io_switch          probe_get_$line               probe_get_$object
probe_get_$pathname           probe_get_$request_list       probe_line_number_            probe_listen_$check_line
probe_pretty_source_info_     probe_print_arglist_          probe_print_handlers_
probe_source_segment_$find_source                           probe_source_segment_$get_file_ptr
probe_source_segment_$list_statement                        probe_source_segment_$position_source
probe_source_segment_$position_source_lines                 probe_stack_trace_$current_level
probe_stack_trace_$get_level  probe_stack_trace_$where_source_info                        probe_trace_a_stack_
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$noentry          iox_$error_output             iox_$user_input               iox_$user_io
iox_$user_output              probe_et_$bad_ctl_arg         probe_et_$bad_line            probe_et_$breakless
probe_et_$e_syntax_err        probe_et_$no_breaks           probe_et_$no_statement_map    probe_et_$noarg
probe_et_$none_active         probe_et_$syntax_error        probe_et_$too_many_args
probe_et_$unimplemented_request




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000367        28 000375       164 000401       167 000404       168 000425       171 000426       174 000443
    177 000444       191 000445       197 000455       199 000461       202 000464       204 000470       205 000503
    207 000505       208 000506       213 000530       215 000531       220 000547       222 000554       227 000555
    233 000564       235 000570       238 000573       240 000577       241 000612       243 000614       244 000615
    249 000637       250 000640       255 000656       257 000663       259 000664       264 000673       266 000677
    269 000702       274 000733       276 000736       278 001025       280 001057       281 001076       282 001100
    283 001112       287 001136       291 001154       293 001161       295 001162       300 001171       302 001175
    305 001200       310 001231       312 001234       314 001323       316 001355       317 001374       318 001376
    319 001410       323 001434       327 001452       329 001457       331 001460       337 001467       339 001473
    340 001476       344 001505       348 001523       349 001527       351 001535       356 001556       358 001571
    360 001572       362 001611       369 001663       371 001673       372 001675       374 001701       375 001702
    376 001704       377 001705       378 001707       379 001711       381 001716       385 001740       388 001757
    392 002022       393 002024       399 002025       401 002036       403 002037       410 002046       412 002052
    414 002055       415 002060       418 002070       419 002072       420 002074       421 002100       422 002102
    425 002106       427 002107       430 002110       435 002126       436 002132       438 002135       439 002150
    441 002167       446 002232       448 002240       449 002242       450 002243       451 002245       452 002246
    453 002250       454 002252       456 002256       460 002300       463 002311       467 002357       468 002361
    474 002362       476 002373       478 002374       491 002403       493 002407       495 002410       499 002432
    503 002454       504 002460       506 002462       507 002463       509 002464       513 002504       517 002505
    534 002514       536 002520       537 002525       541 002532       543 002534       544 002547       546 002551
    547 002552       555 002601       556 002605       558 002624       561 002626       564 002627       566 002635
    567 002636       569 002637       570 002660       573 002662       575 002663       576 002720       579 002752
    581 003015       586 003054       592 003064       595 003065       605 003074       607 003100       610 003107
    611 003122       615 003124       616 003130       617 003134       618 003137       620 003140       621 003142
    622 003146       623 003151       626 003152       628 003154       630 003157       633 003173       634 003175
    635 003177       672 003200       712 003207       713 003211       716 003212       720 003221       721 003222
    723 003223       726 003227       727 003230       729 003232       731 003237       732 003243       734 003253
    736 003256       737 003262       739 003267       740 003272       743 003275       746 003276       748 003301
    750 003307       755 003316       756 003317       760 003324       761 003337       764 003341       768 003362
    769 003364       772 003365       774 003366       778 003372       779 003376       781 003402       786 003424
    790 003443       793 003444       795 003453       797 003454       798 003460       799 003464       804 003522
    805 003523       807 003524       811 003530       813 003532       815 003533       818 003557       820 003563
    827 003567       829 003570       831 003571       834 003613       836 003626       838 003630       839 003631
    843 003640       846 003641       850 003655       851 003661       852 003663       854 003667       855 003670
    857 003676       858 003677       860 003700       861 003701       863 003702       868 003727       869 003742
    871 003743       874 003745       876 003751       877 003753       880 003757       885 003772       892 004011
    894 004012       897 004013       905 004014       906 004020       908 004022       910 004024       914 004030
    917 004053       919 004055       921 004056       924 004073       958 004074       974 004103       976 004107
    978 004115       982 004126       985 004135       988 004137       992 004165       998 004214      1002 004222
   1003 004223      1005 004224      1009 004233      1012 004236      1013 004241      1014 004244      1016 004263
   1017 004314      1018 004316      1020 004342      1022 004343      1023 004376      1024 004400      1026 004420
   1029 004444      1031 004447      1033 004474      1036 004533      1037 004536      1038 004542      1041 004565
   1042 004571      1047 004634      1049 004665      1050 004666      1058 004765      1066 005045      1068 005046
   1072 005073      1076 005074      1079 005103      1080 005105      1083 005106      1086 005115      1087 005116
   1133 005117      1139 005123      1140 005136      1143 005140      1144 005152      1145 005154      1146 005155
   1147 005156      1148 005170      1149 005172      1150 005174      1152 005175      1154 005212      1157 005256
   1159 005271      1161 005275      1162 005276      1163 005300      1164 005301      1166 005306      1167 005310
   1168 005312      1170 005325      1171 005326      1177 005327      1178 005331      1183 005353      1184 005354
   1185 005356      1186 005357      1190 005373      1191 005374      1192 005376      1193 005377      1195 005403
   1196 005404      1199 005406      1200 005407      1203 005414      1204 005416      1209 005452      1211 005453
   1212 005455      1218 005461      1220 005474      1223 005476      1227 005477      1229 005504      1231 005512
   1233 005513      1235 005530      1237 005544      1243 005607      1246 005616      1251 005643      1252 005647
   1256 005671      1257 005672      1260 005712      1262 005714      1264 005720      1267 005756      1269 005761
   1270 005763      1271 005764      1275 006005      1278 006043      1281 006051      1282 006052      1283 006053
   1287 006077      1290 006120      1292 006121      1294 006124      1297 006143      1298 006150      1299 006151
   1302 006167      1306 006213      1310 006235      1320 006250      1324 006320      1325 006322      1327 006343
   1329 006352      1332 006376      1333 006405      1337 006431      1340 006451      1342 006453      1345 006454
   1363 006463      1364 006465      1366 006466      1371 006475      1372 006477      1375 006500      1387 006504
   1389 006505      1393 006521      1395 006526      1396 006530      1398 006543      1399 006544      1402 006545
   1404 006574      1411 006576      1413 006605      1414 006607      1416 006611      1417 006612      1418 006615
   1419 006616      1421 006617      1423 006634      1426 006636      1428 006637      1430 006642      1432 006657
   1435 006661      1436 006664      1437 006665      1443 006712      1444 006716      1445 006720      1447 006724
   1450 006762      1453 007003      1455 007005      1456 007006      1458 007010      1460 007011      1463 007047
   1467 007057      1468 007060      1470 007061      1472 007062      1475 007063      1494 007064      1504 007073
   1507 007100       638 007101       645 007103       647 007105       651 007126       653 007130       654 007133
    655 007147       660 007150       661 007160       663 007166       665 007175       670 007225       927 007226
    930 007227       932 007234       933 007251       934 007253       936 007254       939 007301       941 007303
    944 007304       947 007306       950 007321       953 007332      1479 007334      1482 007335      1484 007360
   1486 007362      1492 007442      1512 007443      1519 007444      1523 007467      1527 007470      1533 007471
   1537 007513      1541 007537      1545 007540      1551 007541      1555 007564      1559 007565      1565 007566
   1567 007573      1570 007575      1573 007576      1583 007607      1585 007614      1587 007623      1588 007624
   1590 007625      1592 007630      1595 007657      1602 007660      1614 007662      1617 007706      1618 007717
   1619 007732      1622 007745      1623 007751      1625 007754


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
