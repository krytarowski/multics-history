	COMPILATION LISTING OF SEGMENT debug
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/05/86  1030.3 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* ******************************************************
        8*   *                                                    *
        9*   *                                                    *
       10*   * Copyright (c) 1972 by Massachusetts Institute of   *
       11*   * Technology and Honeywell Information Systems, Inc. *
       12*   *                                                    *
       13*   *                                                    *
       14*   ****************************************************** */
       15 
       16 debug: db: procedure;
       17 /*	This is the main procedure of the  debug  package.  It has two entries:
       18*   *
       19*   *	1.  The  CALLED entry "debug" or "db" is entered when debug is called by
       20*   *	    a user.
       21*   *
       22*   *	2.  "mme2_fault"  is entered to handle a mme2 fault, i.e., a break.
       23**/
       24 
       25 /*		PARAMETER  DATA		*/
       26 dcl  arg_mcp ptr;					/* Pointer to the machine conditions that is
       27*						   *  passed to the mme2 fault entry.  This pointer
       28*						   *  is generated by the "signaller" and is
       29*						   *  handed down to  "debug".  */
       30 
       31 /*		AUTOMATIC  DATA		*/
       32 /*	Below is the automatic area reserved for common data.   Also declared is the area
       33*   *	where the  SNT  table is built.
       34**/
       35 
       36 dcl  common_auto_area (88) fixed bin aligned,
       37 
       38      snt_area (70) fixed bin aligned;
       39 
       40 dcl 1 save aligned like db_ext_stat_$db_ext_stat_;
       41 dcl  break_num fixed bin,				/* Number of the break that caused the
       42*						   *  mme2 fault.  */
       43 
       44      break_ptr ptr,					/* Pointer to where the break occurred.  */
       45 
       46      temp_break_ptr ptr;				/* Pointer to where a temporary break will
       47*						   *  be set.  */
       48 dcl  comd_len fixed bin,				/* The length of the command line in a break.
       49*						   *  0 => no command line.  */
       50 
       51      comd_ptr ptr,					/* Pointer to the command line  IN THE BREAK.  */
       52 
       53      cond_flag fixed bin;				/* A flag indicating whether a given break
       54*						   *  should be skipped due to an unsatisfied
       55*						   *  condition.  Its values are:
       56*						   *  0 => NO - No condition or condition met.
       57*						   *  1 => YES - Skip break, condition not met.  */
       58 dcl  i fixed bin;					/* Work variable.  */
       59 
       60 dcl  input_buffer char (132) aligned,			/* Area where the user commands are read.  */
       61 
       62      input_buffer_ptr ptr,				/* Pointer to the beginning of this area.  */
       63 
       64      input_line_len21 fixed bin (21),			/* For use with iox_ */
       65      input_line_len fixed bin;			/* Actual length of user's input command.  */
       66 
       67 dcl  printer_on char (1) init ("");			/* Turn printer on "006" */
       68 
       69 dcl  line_num fixed bin,				/* Source line number associated with an
       70*						   *  offset in an object segment.  */
       71 
       72      line_1st_inst_off fixed bin,			/* The offset of the FIRST instruction of
       73*						   *  a given source line.  */
       74 
       75      line_num_inst fixed bin;				/* Number of instructions used to implement
       76*						   *  a given source line.  */
       77 
       78 dcl  line_info char (14) aligned;			/* Line number for printing. */
       79 
       80 dcl  last_sp ptr;					/* Pointer to the last stack frame in the
       81*						   *  stack history which we will use as
       82*						   *  part of our trace.  */
       83 
       84 dcl  cleanup condition;
       85 dcl  command_abort_ condition;
       86 dcl  code fixed bin (35);
       87 dcl  new_line char (1) init ("
       88 ");						/* new line character */
       89 /*	The label used by the condition handling procedures.  */
       90 dcl  read_line_label label;
       91 
       92 
       93 /*		INTERNAL  STATIC  DATA	*/
       94 /*	Below is the static area reserved for common data.  */
       95 
       96 dcl  common_static_area (1063) fixed bin internal static aligned;
       97 dcl  static_init_count fixed bin internal static init (0);
       98 dcl  initial_flag bit (1) int static init ("0"b);
       99 
      100 
      101 
      102 /*		EXTERNAL  DATA		*/
  1     1 /*	BEGIN INCLUDE FILE . . .  db_ext_stat_.incl.pl1
  1     2*   *
  1     3*   *	This include file is used to reference the common data  that is passed from the
  1     4*   *	main debug procedure  "debug" to other debug procedures.  This data is in db_ext_stat_.alm
  1     5*   *
  1     6*   *	modified 7/75 by S.E. Barr for the break instructions
  1     7**/
  1     8 
  1     9 dcl 1 db_ext_stat_$db_ext_stat_ ext static aligned,
  1    10 
  1    11     2 debug_input char (32) aligned,			/* Input switch name.  Initially "user_input" */
  1    12     2 debug_output char (32) aligned,			/* output switch name.  Initially "user_output" */
  1    13     2 return_label label,				/* The label used to do a non local goto out of debug when
  1    14*						   it was entered via a fault.  It will go to debug in
  1    15*						   another frame.  */
  1    16 
  1    17     2 debug_io_ptr (2) ptr,				/* pointers to iocb for i/o
  1    18*						   1 = input switch iocb ptr
  1    19*						   2 = output switch iocb ptr      */
  1    20     2 flags aligned,
  1    21       3 debug_io_attach (2) bit (1) unaligned,		/* 1= debug made the attachment */
  1    22       3 debug_io_open (2) bit (1) unaligned,		/* 1 = debug opened the switch */
  1    23       3 in_debug bit (1) unaligned,			/* Switch for the any_other condition.  0 = send the
  1    24*						   condition on;  1 = use the debug condition handler */
  1    25       3 static_handler_call bit (1) unal,		/* ON if mme2 call from static handler */
  1    26       3 pad bit (30) unaligned;			/* Reserved for future use */
  1    27 dcl  db_ext_stat_$break_instructions (9) bit (36) ext static aligned;
  1    28 
  1    29 /*	END OF INCLUDE FILE  ... db_ext_stat_.incl.pl1  */
      103 
      104 
      105 dcl 1 d like db_ext_stat_$db_ext_stat_ based (addr (db_ext_stat_$db_ext_stat_));
      106 dcl  condition_ ext entry (char (*), entry),
      107      cu_$stack_frame_ptr ext entry returns (ptr),
      108      db_break$check_break ext entry (ptr, fixed bin, ptr, fixed bin, fixed bin,
      109      fixed bin, ptr, fixed bin),
      110      db_break$restart ext entry (ptr, fixed bin, fixed bin, ptr, fixed bin),
      111      db_break$set_break ext entry (ptr, fixed bin, ptr, fixed bin),
      112      db_fill_snt ext entry (ptr, ptr),
      113      db_find_mc ext entry (ptr, bit (1) aligned, ptr),
      114      db_parse ext entry (ptr, fixed bin, ptr, ptr),
      115      debug$mme2_fault ext entry (ptr),
      116      hcs_$high_low_seg_count ext entry (fixed bin, fixed bin),
      117      ioa_$ioa_stream ext entry options (variable),
      118      ioa_$rsnnl ext entry options (variable),
      119      legal_f_ ext entry (ptr) returns (fixed bin),
      120      db_line_no ext entry (ptr, fixed bin (18), fixed bin, fixed bin, fixed bin);
      121 dcl  iox_$control ext entry (ptr, char (*), ptr, fixed bin (35));
      122 dcl  iox_$user_output ptr ext;
      123 dcl  iox_$user_input ptr ext;
      124 dcl  iox_$get_line ext entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      125 dcl  iox_$close ext entry (ptr, fixed bin (35));
      126 dcl  iox_$detach_iocb ext entry (ptr, fixed bin (35));
      127 dcl  com_err_ ext entry options (variable);
      128 dcl  error_table_$long_record ext fixed bin (35);
      129 dcl  error_table_$not_attached ext fixed bin (35);
      130 dcl  error_table_$not_open ext fixed bin (35);
      131 dcl (addr,
      132      addrel,
      133      baseptr,
      134      fixed,
      135      null,
      136      ptr) builtin;
      137 						/*  */
  2     1 /*	BEGIN INCLUDE FILE  ...  db_common_auto.incl.pl1
  2     2**
  2     3**	Written  Dec 72  for the  6180  by  Bill Silver.
  2     4**	Modified Dec 73 to add dummy_arg array by RObert S. Coren.
  2     5**
  2     6**	This include file is used to reference the common data that is passed from the
  2     7**	main debug procedure  "debug"  to other debug procedures.  This data is kept in
  2     8**	"debug's"  automatic storage.
  2     9**/
  2    10 
  2    11 
  2    12 
  2    13 dcl	com_auto_ptr	ptr;	/* The default pointer to the structure which contains
  2    14*				*  common automatic data.  */
  2    15 
  2    16 
  2    17 
  2    18 /*	The following declaration is an overlay of  data  found in the automatic storage
  2    19**	of the main debug procedure.  This data is re-initialixed each time the  "debug"  procedure
  2    20**	is entered - either called by a user  or  via  a  mme2 fault.
  2    21**/
  2    22 
  2    23 
  2    24 dcl    1	com_auto_data	based( com_auto_ptr )	aligned,
  2    25 
  2    26 
  2    27 	2 db_mc_ptr	ptr,		/* Pointer to the current copy of the machine
  2    28*					*  conditions.  They are found in the stack. */
  2    29 
  2    30 	2 snt_ptr		ptr,		/* Pointer to the area in automatic storage
  2    31*					*  where  "debug"  keeps its segment name table. */
  2    32 
  2    33 	2 max_sp_x	fixed bin,	/* Index of the last entry in the stack pointer
  2    34*					*  array which can be used in a stack trace. */
  2    35 
  2    36 	2 first_call_flag	fixed bin,	/* This flag is used by procedures called by  "debug"
  2    37*					*  to tell if this is the first time they have
  2    38*					*  been called since "debug" was entered.
  2    39*					*  0 => this is the first call out from "debug".
  2    40*					*  1 => procedure returned to db and was called again. */
  2    41 
  2    42 	2 db_action_code	fixed bin,	/* This code tells "debug" what it should do
  2    43*					*  after it is returned to by a parsing procedure.
  2    44*					*  0 => Read next command line - then parse it.
  2    45*					*  1 => Wipe out read ahead and then read the next
  2    46*					*       line  - then parse it.
  2    47*					*  2 => Quit debug, return to command level.
  2    48*					*  3 => Restart the procedure that was interrupted
  2    49*					*       by the mme2 break fault.  */
  2    50 
  2    51 	2 num_skips	fixed bin,	/* Number of times to skip the current break.  */
  2    52 
  2    53 	2 dummy_arg (10)	aligned,		/* Space for "%" arguments */
  2    54 	    3 (p1, p2, p3, p4)  ptr;
  2    55 
  2    56 
  2    57 
  2    58 /*	END OF INCLUDE FILE  ...  db_common_auto.incl.pl1	        */
      138 
  3     1 /*	BEGIN INCLUDE FILE  ...  db_common_static.incl.pl1
  3     2**
  3     3**	Written  Dec 72  for the  6180  by  Bill Silver.
  3     4**
  3     5**	This include file is used to reference the common data that is passed from the
  3     6**	main  debug procedure  "debug"  to other debug procedures.  This data is kept
  3     7**	in internal static storage.
  3     8**/
  3     9 
  3    10 
  3    11 
  3    12 dcl	com_stat_ptr	ptr;	/* The default pointer to the common internal static
  3    13*				*  structure.  */
  3    14 
  3    15 
  3    16 
  3    17 /*	The following declaration is an overlay of  data  found in static storage.
  3    18**	It is initialized by "debug" the first time it is called in a process.  A pointer
  3    19**	to this data is found in the external variable  "debug$common_static_ptr".
  3    20**/
  3    21 
  3    22 
  3    23 dcl    1	com_static_data	based ( com_stat_ptr ) 	aligned,
  3    24 
  3    25 
  3    26 	2 lotp		ptr,		/* Pointer to the base of the combined
  3    27*					*  linkage segment.  */
  3    28 
  3    29 	2 hcs_count	fixed bin,	/* Highest hard core segment number. */
  3    30 
  3    31 	2 print_mode	fixed bin,	/* This word is a flag which specifies the
  3    32*					*  volume of information to be printed.
  3    33*					*  0 => SHORT MODE:  Only error messages
  3    34*					*       and essential data will be printed.
  3    35*					*  1 => LONG  MODE: As much information as
  3    36*					*       possible will be printed.  */
  3    37 
  3    38 	2 stack_ptr_array (0:511)	ptr,	/* Pointers to the stack frames which make up
  3    39*					*  the stack history of the process.  */
  3    40 
  3    41 	2 temp_comd_len	fixed bin,	/* Length of temporary global break command line.
  3    42*					*  0 => there is no command line.  */
  3    43 
  3    44 	2 temp_comd_line	char(132),	/* The temporary global break command line.
  3    45*					*  This debug command will be executed each time
  3    46*					*  a break occurs.  It is temporary since it is
  3    47*					*  maintained in static storage and thus goes
  3    48*					*  away when the process terminates.  */
  3    49 
  3    50 	2 temp_break_mode	fixed bin;	/* This is a flag which indicates whether or
  3    51*					*  not we are in temporary break mode.
  3    52*					*  0 => regular break mode.
  3    53*					*  1 => temporary break mode.  */
  3    54 
  3    55 
  3    56 
  3    57 /*	END OF INCLUDE FILE  ...  db_common_static.incl.pl1	        */
      139 
      140 /*  */
  4     1 /*	BEGIN INCLUDE FILE ... db_inst.incl.pl1  Last modified Nov 72 - WSS. */
  4     2 
  4     3 
  4     4 /*	PL/I  definitions of an instruction word.  There are two definitions.
  4     5**	One defines a full 18 bit offset field (now meaningful with 256K segments)
  4     6**	and the other defines an instruction with a pointer register field and a
  4     7**	15 bit offset field.
  4     8**/
  4     9 
  4    10 dcl	ilc_ptr	  ptr;			/* Pointer to the instruction word. */
  4    11 
  4    12 
  4    13 dcl     1	instr	  based (ilc_ptr)  	aligned,	
  4    14          (2  offset	  fixed bin (17),		/* Full 18 bit offset.  No pr field. */
  4    15 	2  opcode	  bit (10),		/* Instruction opcode. */
  4    16 	2  inhibit  bit (1),		/* ON => interrupts inhibitted. */
  4    17 	2  pr_bit	  bit (1),		/* ON => instruction has  pr  field. */
  4    18 	2  tag	  bit (6))  unaligned;	/* Tag field. */
  4    19 
  4    20 
  4    21 dcl     1	instr_pr	  based (ilc_ptr)  	aligned,	
  4    22          (2  pr	  bit (3),		/* Pointer register field. */
  4    23 	2  offset	  fixed bin (14),		/* 15 bit offset due to pr field. */
  4    24 	2  pad	  bit (18))  unaligned;
  4    25 
  4    26 
  4    27 /*	END OF INCLUDE FILE ... db_inst.incl.pl1	*/
      141 
      142 /*  */
  5     1 /*	BEGIN  INCLUDE  FILE ...  db_snt.incl.pl1  Last modified  Nov 1972.  WSS  */
  5     2 /*	Modified 8/75 to add internal static pointer by S.E. Barr */
  5     3 
  5     4 
  5     5 /*	Overlay of  segment name table.  */
  5     6 
  5     7 dcl	sntp	ptr;		/* Pointer to segment name table. */
  5     8 
  5     9 dcl     1	snt	based (sntp)  aligned,
  5    10 	2  ent_pt_name char(32),	/* Entry point name. */
  5    11 	2  ent_name    char(32),	/* Entry name of segment. */
  5    12 	2  dir_name    char(168),	/* Directory name. */
  5    13 	2  pp	     ptr,		/* Pointer to current procedure. */
  5    14 	2  sp          ptr,		/* Pointer to current stack frame. */
  5    15 	2  lp          ptr,		/* Pointer to linkage section. */
  5    16 	2  symp        ptr,		/* Pointer to current symbol table block. */
  5    17 	2  symflag     bit(1) unal,	/* ON => no symbol table defined. */
  5    18 	2  std	     bit(1) unal,	/* ON => standard symbol header.  */
  5    19 	2  headp	     ptr,		/* Pointer to current symbol header. */
  5    20 	2  static_ptr  ptr;		/* Pointer to current static section. */
  5    21 
  5    22 /*	END OF INCLUDE FILE...  db_snt.incl.pl1  */
      143 
      144 /*  */
  6     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  6     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  6     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  6     4 /*	Modified April 1983 by C. Hornig for tasking */
  6     5 
  6     6 /****^  HISTORY COMMENTS:
  6     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  6     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  6     9*     added the heap_header_ptr definition.
  6    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  6    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  6    12*     Modified to support control point management.  These changes were actually
  6    13*     made in February 1985 by G. Palter.
  6    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  6    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  6    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  6    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  6    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  6    19*     (ITS pair).
  6    20*                                                   END HISTORY COMMENTS */
  6    21 
  6    22 /* format: style2 */
  6    23 
  6    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  6    25 
  6    26      dcl	   1 stack_header	      based (sb) aligned,
  6    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  6    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  6    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  6    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  6    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  6    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  6    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  6    34 	     2 pad4	      bit (2) unal,
  6    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  6    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  6    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  6    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  6    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  6    40 	     2 null_ptr	      ptr,		/*  (16)  */
  6    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  6    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  6    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  6    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  6    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  6    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  6    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  6    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  6    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  6    50 	     2 return_no_pop_op_ptr
  6    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  6    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  6    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  6    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  6    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  6    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  6    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  6    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  6    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  6    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  6    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  6    62 	     2 trace,
  6    63 	       3 frames,
  6    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  6    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  6    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  6    67 	     2 pad2	      bit (36),		/*  (61) */
  6    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  6    69 
  6    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  6    71 
  6    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  6    73 						/* (551) octal */
  6    74 
  6    75 
  6    76 /*	The following constants are offsets within this transfer vector table.  */
  6    77 
  6    78      dcl	   (
  6    79 	   call_offset	      fixed bin init (271),
  6    80 	   push_offset	      fixed bin init (272),
  6    81 	   return_offset	      fixed bin init (273),
  6    82 	   return_no_pop_offset   fixed bin init (274),
  6    83 	   entry_offset	      fixed bin init (275)
  6    84 	   )		      internal static;
  6    85 
  6    86 
  6    87 
  6    88 
  6    89 
  6    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  6    91*	move the whole stack header should use this overlay.
  6    92**/
  6    93 
  6    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  6    95 
  6    96 
  6    97 
  6    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      145 
  7     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  7     2 
  7     3 /* format: off */
  7     4 
  7     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  7     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  7     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  7     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  7     9 
  7    10 
  7    11 /****^  HISTORY COMMENTS:
  7    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  7    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  7    14*     Modified to add constants for the translator_id field in the stack_frame
  7    15*     structure.
  7    16*                                                   END HISTORY COMMENTS */
  7    17 
  7    18 
  7    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  7    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  7    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  7    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  7    23 
  7    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  7    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  7    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  7    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  7    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  7    29 
  7    30 
  7    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  7    32 
  7    33 dcl  stack_frame_min_length fixed bin static init(48);
  7    34 
  7    35 
  7    36 dcl 1 stack_frame based(sp) aligned,
  7    37     2 pointer_registers(0 : 7) ptr,
  7    38     2 prev_sp pointer,
  7    39     2 next_sp pointer,
  7    40     2 return_ptr pointer,
  7    41     2 entry_ptr pointer,
  7    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  7    43     2 arg_ptr pointer,
  7    44     2 static_ptr ptr unaligned,
  7    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  7    46     2 on_unit_relp1 bit(18) unaligned,
  7    47     2 on_unit_relp2 bit(18) unaligned,
  7    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  7    49*						   0 => PL/I version II
  7    50*						   1 => ALM
  7    51*						   2 => PL/I version I   
  7    52*						   3 => signal caller frame
  7    53*						   4 => signaller frame */
  7    54     2 operator_return_offset bit(18) unaligned,
  7    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  7    56     2 a bit(36),					/* accumulator */
  7    57     2 q bit(36),					/* q-register */
  7    58     2 e bit(36),					/* exponent */
  7    59     2 timer bit(27) unaligned,				/* timer */
  7    60     2 pad bit(6) unaligned,
  7    61     2 ring_alarm_reg bit(3) unaligned;
  7    62 
  7    63 
  7    64 dcl 1 stack_frame_flags based(sp) aligned,
  7    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  7    66     2 xx0 bit(22) unal,
  7    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  7    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  7    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  7    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  7    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  7    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  7    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  7    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  7    75     2 xx0a bit(6) unal,
  7    76     2 xx1 fixed bin,
  7    77     2 xx2 fixed bin,
  7    78     2 xx3 bit(25) unal,
  7    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  7    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  7    81     2 xx3a bit(9) unaligned,
  7    82     2 xx4(9) bit(72) aligned,
  7    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  7    84*						*  operator puts a pointer to the base of
  7    85*						*  the calling procedure here. (text base ptr)  */
  7    86     2 xx5 bit(72) aligned,
  7    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  7    88 
  7    89 /* format: on */
  7    90 
  7    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      146 
  8     1 /*  */
  8     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  8     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  8     4 /* Modified 07/07/76 by Morris for fault register data */
  8     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  8     6 /* Modified '82 to make values constant */
  8     7 
  8     8 /* words 0-15 pointer registers */
  8     9 
  8    10 dcl  mcp ptr;
  8    11 
  8    12 dcl 1 mc based (mcp) aligned,
  8    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  8    14    (2 regs,					/* registers */
  8    15       3 x (0:7) bit (18),				/* index registers */
  8    16       3 a bit (36),					/* accumulator */
  8    17       3 q bit (36),					/* q-register */
  8    18       3 e bit (8),					/* exponent */
  8    19       3 pad1 bit (28),
  8    20       3 t bit (27),					/* timer register */
  8    21       3 pad2 bit (6),
  8    22       3 ralr bit (3),				/* ring alarm register */
  8    23 
  8    24     2 scu (0:7) bit (36),
  8    25 
  8    26     2 mask bit (72),				/* mem controller mask at time of fault */
  8    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  8    28     2 errcode fixed bin (35),				/* fault handler's error code */
  8    29     2 fim_temp,
  8    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  8    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  8    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  8    33     2 fault_reg bit (36),				/* fault register */
  8    34     2 pad2 bit (1),
  8    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  8    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  8    37     2 fault_time bit (54),				/* time of fault */
  8    38 
  8    39     2 eis_info (0:7) bit (36)) unaligned;
  8    40 
  8    41 
  8    42 dcl (apx fixed bin init (0),
  8    43      abx fixed bin init (1),
  8    44      bpx fixed bin init (2),
  8    45      bbx fixed bin init (3),
  8    46      lpx fixed bin init (4),
  8    47      lbx fixed bin init (5),
  8    48      spx fixed bin init (6),
  8    49      sbx fixed bin init (7)) internal static options (constant);
  8    50 
  8    51 
  8    52 
  8    53 
  8    54 dcl  scup ptr;
  8    55 
  8    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  8    57 
  8    58 
  8    59 /*	WORD (0)		*/
  8    60 
  8    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  8    62       3 prr bit (3),				/* procedure ring register */
  8    63       3 psr bit (15),				/* procedure segment register */
  8    64       3 p bit (1),					/* procedure privileged bit */
  8    65 
  8    66     2 apu,					/* APPENDING UNIT STATUS */
  8    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  8    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  8    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  8    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  8    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  8    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  8    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  8    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  8    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  8    76       3 ptw bit (1),				/* Fetch of PTW */
  8    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  8    78       3 fap bit (1),				/* Fetch of final address paged */
  8    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  8    80       3 fabs bit (1),				/* Fetch of final address absolute */
  8    81 
  8    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  8    83 
  8    84 
  8    85 /*	WORD (1)		*/
  8    86 
  8    87     2 fd,						/* FAULT  DATA */
  8    88       3 iro bit (1),				/* illegal ring order */
  8    89       3 oeb bit (1),				/* out of execute bracket */
  8    90       3 e_off bit (1),				/* no execute */
  8    91       3 orb bit (1),				/* out of read bracket */
  8    92       3 r_off bit (1),				/* no read */
  8    93       3 owb bit (1),				/* out of write bracket */
  8    94       3 w_off bit (1),				/* no write */
  8    95       3 no_ga bit (1),				/* not a gate */
  8    96       3 ocb bit (1),				/* out of call bracket */
  8    97       3 ocall bit (1),				/* outward call */
  8    98       3 boc bit (1),				/* bad outward call */
  8    99       3 inret bit (1),				/* inward return */
  8   100       3 crt bit (1),				/* cross ring transfer */
  8   101       3 ralr bit (1),				/* ring alarm register */
  8   102       3 am_er bit (1),				/* associative memory fault */
  8   103       3 oosb bit (1),				/* out of segment bounds */
  8   104       3 paru bit (1),				/* processor parity upper */
  8   105       3 parl bit (1),				/* processor parity lower */
  8   106       3 onc_1 bit (1),				/* op not complete type 1 */
  8   107       3 onc_2 bit (1),				/* op not complete type 2 */
  8   108 
  8   109     2 port_stat,					/* PORT  STATUS */
  8   110       3 ial bit (4),				/* illegal action lines */
  8   111       3 iac bit (3),				/* illegal action channel */
  8   112       3 con_chan bit (3),				/* connect channel */
  8   113 
  8   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  8   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  8   116 
  8   117 
  8   118 /*	WORD (2)		*/
  8   119 
  8   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  8   121       3 trr bit (3),				/* temporary ring register */
  8   122       3 tsr bit (15),				/* temporary segment register */
  8   123 
  8   124     2 pad2 bit (9),
  8   125 
  8   126     2 cpu_no bit (3),				/* CPU number */
  8   127 
  8   128     2 delta bit (6),				/* tally modification DELTA */
  8   129 
  8   130 
  8   131 /*	WORD (3)		*/
  8   132 
  8   133     2 word3 bit (18),
  8   134 
  8   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  8   136       3 tsna,					/* Word 1 status */
  8   137         4 prn bit (3),				/* Word 1  PR  number */
  8   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  8   139       3 tsnb,					/* Word 2  status */
  8   140         4 prn bit (3),				/* Word 2  PR  number */
  8   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  8   142       3 tsnc,					/* Word 3  status */
  8   143         4 prn bit (3),				/* Word 3  PR  number */
  8   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  8   145 
  8   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  8   147 
  8   148 
  8   149 /* 	WORD (4)		*/
  8   150 
  8   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  8   152 
  8   153     2 ir,						/* INDICATOR  REGISTERS */
  8   154       3 zero bit (1),				/* zero indicator */
  8   155       3 neg bit (1),				/* negative indicator */
  8   156       3 carry bit (1),				/* carryry indicator */
  8   157       3 ovfl bit (1),				/* overflow indicator */
  8   158       3 eovf bit (1),				/* eponent overflow */
  8   159       3 eufl bit (1),				/* exponent underflow */
  8   160       3 oflm bit (1),				/* overflow mask */
  8   161       3 tro bit (1),				/* tally runout */
  8   162       3 par bit (1),				/* parity error */
  8   163       3 parm bit (1),				/* parity mask */
  8   164       3 bm bit (1),					/* ^bar mode */
  8   165       3 tru bit (1),				/* truncation mode */
  8   166       3 mif bit (1),				/* multi-word instruction mode */
  8   167       3 abs bit (1),				/* absolute mode */
  8   168       3 hex bit (1),				/* hexadecimal exponent mode */
  8   169       3 pad bit (3),
  8   170 
  8   171 
  8   172 /*	WORD (5)		*/
  8   173 
  8   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  8   175 
  8   176     2 cu,						/* CONTROL UNIT STATUS */
  8   177       3 rf bit (1),					/* on first cycle of repeat instr */
  8   178       3 rpt bit (1),				/* repeat instruction */
  8   179       3 rd bit (1),					/* repeat double instruction */
  8   180       3 rl bit (1),					/* repeat link instruciton */
  8   181       3 pot bit (1),				/* IT  modification */
  8   182       3 pon bit (1),				/* return type instruction */
  8   183       3 xde bit (1),				/* XDE from Even location */
  8   184       3 xdo bit (1),				/* XDE from Odd  location */
  8   185       3 poa bit (1),				/* operation preparation */
  8   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  8   187       3 its bit (1),				/* ITS modification */
  8   188       3 if bit (1),					/* fault occured during instruction fetch */
  8   189 
  8   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  8   191 
  8   192 
  8   193 /*	WORDS (6,7)	*/
  8   194 
  8   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  8   196 
  8   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  8   198 
  8   199 
  8   200 
  8   201 
  8   202 
  8   203 
  8   204 /*	ALTERNATE   SCU  DECLARATION		*/
  8   205 
  8   206 
  8   207 dcl 1 scux based (scup) aligned,
  8   208 
  8   209    (2 pad0 bit (36),
  8   210 
  8   211     2 fd,						/* GROUP II  FAULT DATA */
  8   212       3 isn bit (1),				/* illegal segment number */
  8   213       3 ioc bit (1),				/* illegal op  code  */
  8   214       3 ia_am bit (1),				/* illegal address - modifier */
  8   215       3 isp bit (1),				/* illegal slave  procedure */
  8   216       3 ipr bit (1),				/* illegal procedure */
  8   217       3 nea bit (1),				/* non existent address */
  8   218       3 oobb bit (1),				/* out of bounds */
  8   219       3 pad bit (29),
  8   220 
  8   221     2 pad2 bit (36),
  8   222 
  8   223     2 pad3a bit (18),
  8   224 
  8   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  8   226       3 prn bit (3),				/* PR  number */
  8   227       3 prv bit (1),				/* PR  valid bit */
  8   228 
  8   229     2 pad3b bit (6)) unaligned,
  8   230 
  8   231     2 pad45 (0:1) bit (36),
  8   232 
  8   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  8   234 
  8   235 
  8   236 
  8   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      147 
      148 /*  */
      149 /* CALLED  ENTRY  -  This is where  "debug" is entered when the user calls "debug". */
      150 
      151 	if static_init_count = 0 then call set_internal_stat;
      152 
      153 	call set_ext_stat;
      154 	d.static_handler_call = "0"b;
      155 
      156 	com_stat_ptr = addr (common_static_area);
      157 	com_auto_ptr = addr (common_auto_area);
      158 	sntp = addr (snt_area);
      159 
      160 	call condition_ ("mme2", debug$mme2_fault);
      161 
      162 	break_num = 0;				/* debug was called so there is no break number */
      163 	temp_break_mode = 0;			/* Not in temporary break mode */
      164 	num_skips = 0;				/* No skip count since no break. */
      165 
      166 /* Now get a pointer to the last  sp  we will use in the stack history trace.  It
      167*   must be the frame before the  "debug"  frame. */
      168 
      169 	last_sp = cu_$stack_frame_ptr () ->		/* Pointer to our frame. */
      170 	     stack_frame.prev_sp;			/* ptr to the frame of the procedure that called debug */
      171 /* Now get a pointer to the machine conditions of the last fault that was taken
      172*   before  "debug" was called.  The stack frame of the procedure that took the
      173*   fault must still be in the stack history if we are to get a pointer to the
      174*   machine conditions.  If there is no fault frame in the stack history it is OK.
      175*   The user just won't have any registers to play with.  If he tries to reference
      176*   a machine register  "db_regs"  will tell him.
      177**/
      178 
      179 	call db_find_mc (last_sp, "0"b, db_mc_ptr);
      180 
      181 /* Now call an internal procedure that will perform the rest of the initialization.
      182*   Once this is done we can start reading in user commands. */
      183 
      184 	call common_init;
      185 
      186 	goto read_line;				/* Go get user commands. */
      187 
      188 /*  */
      189 /* This entry is entered via a mme2 fault that occurred at a break point.  The input
      190*   argument points to the machine conditions associated with this fault.
      191*
      192*   There are two cases in which the break will be skipped.  In both cases debug will not print any message
      193*   a)  The break has a non zero skip count.
      194*   b)  The break contains a condition but the condition has not been met.
      195*   */
      196 mme2_fault: entry (arg_mcp);
      197 
      198 	if static_init_count = 0 then do;		/* in case debug is entered via static handler */
      199 	     call set_internal_stat;
      200 	     call set_ext_stat;
      201 	     d.static_handler_call = "1"b;
      202 	end;
      203 
      204 	com_stat_ptr = addr (common_static_area);
      205 	com_auto_ptr = addr (common_auto_area);
      206 	sntp = addr (snt_area);
      207 
      208 	db_mc_ptr = arg_mcp;			/* The machine conditions associated with
      209*						   *  this fault serve as our registers.  */
      210 
      211 /* From the SCU data we get the address of where the mme2 fault occurred - in effect the PPR.  The
      212*   The address field of the mme2 instruction contains the break number.
      213**/
      214 	scup = addr (db_mc_ptr -> mc.scu);
      215 	break_ptr = ptr (baseptr (fixed (scup -> scu.ppr.psr)), scup -> scu.ilc);
      216 	break_num = fixed (break_ptr -> instr.offset);
      217 	last_sp = db_mc_ptr -> mc.prs (spx);		/* stack frame of the procedure that took the fault. */
      218 	call db_fill_snt (last_sp, sntp);
      219 	call db_break$check_break (break_ptr, break_num, sntp, cond_flag, num_skips, comd_len, comd_ptr, line_num);
      220 
      221 /* If the break could not be handled (it was not enabled, it was a version 1 break), the user will enter command
      222*   mode for debug. */
      223 
      224 	if break_ptr = null then do;
      225 	     call common_init;
      226 	     goto  read_line_label;
      227 	end;
      228 
      229 	if (cond_flag = 1) | (num_skips > 0) then goto restart_break;
      230 
      231 	call common_init;
      232 
      233 	if line_num > 0 then call ioa_$rsnnl ("at line ^d", line_info, i, line_num);
      234 	else line_info = "";
      235 
      236 	if print_mode = 0 then call ioa_$ioa_stream (d.debug_output, "Break  ^d ^a  of  ^a", break_num, line_info, snt.ent_name);
      237 	else call ioa_$ioa_stream (d.debug_output, "^RBreak  ^d  ^a  of  ^a  -  at  ^p^B",
      238 	     break_num, line_info, snt.ent_name, break_ptr);
      239 	if temp_comd_len ^= 0			/* temporary global command */
      240 	then call db_parse (addr (temp_comd_line), temp_comd_len, com_auto_ptr, com_stat_ptr);
      241 
      242 	if comd_len ^= 0				/* conditional break */
      243 	then call db_parse (comd_ptr, comd_len, com_auto_ptr, com_stat_ptr);
      244 
      245 	goto db_action_label (db_action_code);
      246 						/*  */
      247 
      248 /*	These condition handlers  return to "read_line".  The stack frame that
      249*   *	"debug" will be running on will be the last  "debug" stack frame regardless of
      250*   *	how  "debug" was entered.
      251**/
      252 
      253 conversion_handler: procedure;
      254 
      255 	     call ioa_$ioa_stream (d.debug_output, "Conversion error");
      256 	     goto read_line_label;
      257 
      258 	end conversion_handler;
      259 
      260 prog_interrupt_handler: procedure;
      261 
      262 	     goto read_line_label;
      263 
      264 	end prog_interrupt_handler;
      265 /*  The any_other_handler prints the name of the condition and goes to read the next
      266*   request from the user.  The condition will be passed on if the user was not in
      267*   debug when the condition occurred or the condition is not in the conditions table.
      268*
      269*   The user is not in debug in the following cases:
      270*
      271*   *	db_parse		(..) when a procedure is executed
      272*   *			(:=) when a subroutine call is made
      273*
      274*   *	debug		(.c) when the user continues execution after a break
      275**/
      276 
      277 any_other_handler: proc (mcptr, name, wcptr, info_ptr, cont);
      278 
      279 dcl  mcptr ptr,
      280      name char (*),
      281      wcptr ptr,
      282      info_ptr ptr,
      283      cont bit (1);
      284 dcl  conditions char (106) init ("conversion,fixedoverflow,out_of_bounds,overflow,underflow,zerodivide,stringrange,stringsize,subscriptrange");
      285 
      286 	     if d.in_debug then do;			/* only handle debug conditions */
      287 
      288 		if name = "db_conversion" then name = "conversion";
      289 		if index (conditions, name) > 0 then do;
      290 		     call ioa_$ioa_stream (d.debug_output, "db: ^a", name);
      291 		     go to read_line_label;
      292 		end;
      293 	     end;
      294 
      295 	     cont = "1"b;
      296 	     return;
      297 
      298 	end any_other_handler;
      299 
      300 /*  */
      301 
      302 /*	This routine will read a user command and then call the parsing procedure to
      303*   *	process the command line.  What we do when the parsing procedure returns depends
      304*   *	upon the action code which the parsing procedure sets.  Thus the contents of the
      305*   *	command line determines what we do next.
      306**/
      307 
      308 read_line:
      309 db_action_label (0):
      310 	call iox_$get_line (d.debug_io_ptr (1), input_buffer_ptr, 132, input_line_len21, code);
      311 	input_line_len = input_line_len21;
      312 
      313 	if code ^= 0 then do;
      314 	     call com_err_ (code, "debug");
      315 	     if code = error_table_$long_record then go to read_line;
      316 	     else go to quit;
      317 	end;
      318 	if input_line_len = 1 then goto read_line;	/* Is it a blank line?  */
      319 	db_action_code = 0;				/* in case different value was returned before */
      320 
      321 	call db_parse (input_buffer_ptr, input_line_len, com_auto_ptr, com_stat_ptr);
      322 
      323 	goto db_action_label (db_action_code);
      324 
      325 /* resetread:	Flush read ahead because last request was incorrect */
      326 
      327 db_action_label (1):
      328 
      329 	call iox_$control (d.debug_io_ptr (1), "resetread", null, code);
      330 	if code ^= 0 then call com_err_ (code, "debug");
      331 	goto read_line;
      332 
      333 /*  Quit  debug  */
      334 db_action_label (2):
      335 quit:
      336 
      337 	if break_num = 0 then do;			/* debug was CALLED */
      338 	     call restore;
      339 	     return;
      340 	end;
      341 
      342 /* If this invocation was through a mme2 fault, return is made to the stack frame that had the call to debug.
      343*   If debug was originally invoked via a static handler and return is not possible. */
      344 
      345 	if ^d.flags.static_handler_call then goto d.return_label;
      346 	signal command_abort_;
      347 	goto read_line;
      348 
      349 return_from_debug:					/* This is where the previous goto will transfer to.
      350*						   However, we will now be in a different stack frame. */
      351 
      352 	call restore;				/* Restore i/o attachments & external data */
      353 	return;					/* Return to CALLER. */
      354 
      355 /*	This routine is called when the user wants to restart a break.  Note that all of
      356*   *	the data needed to restart the break has been set up by  "debug".  Only the num_skips
      357*   *	field could have been modified by a user if  the parse procedure was called to
      358*   *	process a command line.  If there is no break number then  "debug" was entered
      359*   *	via a  CALL.  Thus there is no break to restart.  We will just go and read in
      360*   *	another command line.
      361*   */
      362 
      363 restart_break:
      364 db_action_label (3):
      365 	if break_num = 0 | break_ptr = null
      366 
      367 	then do;
      368 	     call ioa_$ioa_stream (d.debug_output, "No break fault, cannot restart break.");
      369 	     goto read_line;
      370 	end;
      371 /*	There was a break fault so we can restart this break.  First we will check to
      372*   *	see if we are in  temporary break mode.  If we are we will set a temporary break.
      373*   *	The location of the temporary break will be at the beginning of the next line if
      374*   *	there are line numbers available.  Otherwise it will be at the next instruction.
      375**/
      376 
      377 	if temp_break_mode ^= 0			/* Are we in temporary break mode?  */
      378 
      379 	then do;					/* YES */
      380 
      381 	     call db_fill_snt (last_sp, sntp);
      382 
      383 	     call get_line_num;			/* Get temporary break pointer.  */
      384 
      385 	     call db_break$set_break (temp_break_ptr, 1, sntp, print_mode);
      386 
      387 	end;
      388 /*	Now we will call  db_break to restart the break.  It will fiddle with our  SCU
      389*   *	data so that when we say  "return"  the instruction that was replaced by the
      390*   *	mme2  will eventually be executed.  We return to the procedure that called  "debug"
      391*   *	at the  mme2 fault entry.  Eventually a return is made to the signaller who does
      392*   *	an  "RCU"  instruction from our  SCU  data.  This will restart the procedure which
      393*   *	will execute as if the break never happened.
      394**/
      395 
      396 	d.in_debug = "0"b;				/* restart break means leaving debug */
      397 	call db_break$restart (break_ptr, break_num, num_skips, scup, print_mode);
      398 	return;					/* This will begin the process which will
      399*						   *  restart the procedure.  */
      400 						/*  */
      401 common_init: procedure;
      402 /*	This procedure is called to perform initialization that is common the both the
      403*   *	CALLED and the  mme2_fault entries.  It will not be called at all if the  mme2 fault
      404*   *	entry immediately restarts the break.
      405**/
      406 
      407 /*	First initialize the rest of the common automatic variables.  Also set up
      408*   *	the pointer to the input buffer.
      409**/
      410 
      411 	     first_call_flag,
      412 		db_action_code = 0;
      413 
      414 	     input_buffer_ptr = addr (input_buffer);
      415 /*	Establish condition handlers for illegal  debug  conversions and for program
      416*   *	interrupts.  Both of these condition handlers will go to  "read_line"  to get
      417*   *	another input line.  At that time  "debug"  will be executing out of the last
      418*   *	"debug"  stack frame regardless of how it was entered.
      419**/
      420 
      421 	     read_line_label = read_line;
      422 	     call condition_ ("db_conversion", conversion_handler);
      423 	     call condition_ ("program_interrupt", prog_interrupt_handler);
      424 
      425 	     call condition_ ("any_other", any_other_handler);
      426 	     d.in_debug = "1"b;
      427 
      428 /*	Now trace the stack history.  We will start at the beginning of the stack and
      429*   *	trace until we reach the frame we have designated as the last frame.  The pointer
      430*   *	to this frame is in  "last_sp".  The index of the  stack_ptr_array  entry for
      431*   *	this last frame will be saved in the common variable  "max_sp_x".
      432**/
      433 	     sp = ptr (last_sp, 0) -> stack_header.stack_begin_ptr; /* Get a pointer to the first
      434*						   *  frame in the stack.  Note,
      435*						   *  it is a dummy and will
      436*						   *  be skipped.  */
      437 	     do i = 0 to 511;
      438 
      439 		if legal_f_ (sp) ^= 0		/* Is it a legal frame?  */
      440 
      441 		then do;				/* NO. */
      442 
      443 		     max_sp_x = i - 1;		/* Previous frame is the last one
      444*						   *  we can use in the stack history.  */
      445 
      446 		     call ioa_$ioa_stream (d.debug_output, "Cannot trace stack past depth  ^d", i-1);
      447 
      448 		     goto get_snt_data;		/* End stack trace. */
      449 
      450 		end;
      451 		stack_ptr_array (i) = sp;		/* Stack is legal. Save its pointer
      452*						   *  in the stack array. */
      453 
      454 		if sp = last_sp			/* Is this the last stack frame we
      455*						   *  want to trace?  */
      456 
      457 		then do;				/* YES.  This is the end of the trace.  */
      458 
      459 		     max_sp_x = i;			/* Save number of valid stack frames
      460*						   *  in the trace.  */
      461 
      462 		     goto get_snt_data;
      463 
      464 		end;
      465 
      466 		sp = sp -> stack_frame.next_sp;	/* Get a pointer to the next frame. */
      467 
      468 	     end;
      469 /*	If we get here we have overflowed the stack array area.  Tell the user. */
      470 
      471 	     call ioa_$ioa_stream (d.debug_output, "Stack array overflow has occurred.");
      472 
      473 	     max_sp_x = i - 1;
      474 /*	Now that the stack trace has finished we will fill in the SNT table from the data
      475*   *	in the last stack frame in the trace.
      476**/
      477 
      478 get_snt_data:
      479 
      480 	     call db_fill_snt (stack_ptr_array (max_sp_x), sntp);
      481 
      482 	     snt_ptr = sntp;
      483 
      484 	end common_init;
      485 						/*  */
      486 get_line_num: procedure;
      487 /*	This internal procedure is called to get the line number of the instruction at
      488*   *	the current break point.  It will also return a pointer to where the next temporary
      489*   *	break point should be set.  If we can't get the line number then a line number
      490*   *	value of (-1) will be returned.  This procedure assumes that "break_ptr" points to
      491*   *	the break point and that "sntp" points to valid  SNT  data of the fault frame.
      492**/
      493 
      494 /*	Get the line number. */
      495 
      496 	     call db_line_no (sntp, fixed (rel (break_ptr), 18), line_1st_inst_off,
      497 		line_num_inst, line_num);
      498 	     if line_num > -1			/* Did we get a line number.  */
      499 	     then do;				/* YES, temporary pointer is beginning of
      500*						   *  next line.  */
      501 
      502 		temp_break_ptr = ptr (break_ptr, line_1st_inst_off + line_num_inst);
      503 
      504 		return;
      505 	     end;
      506 
      507 /*	Either we couldn't get a symbol pointer or we couldn't get a line number.  In
      508*   *	any case we will return a line number of (-1) and the temporary break pointer
      509*   *	will be equal to the instruction after the break point.
      510**/
      511 
      512 	     line_num = -1;
      513 
      514 	     temp_break_ptr = addrel (break_ptr, 1);
      515 	end get_line_num;
      516 restore:	proc;
      517 
      518 /*	This procedure is called when the user quits debug or when the cleanup condition
      519*   *	is signaled.
      520*   *	  1.  Any i/o attachments that were made by debug are detached.
      521*   *	  2.  The external data is restore to its initial value when debug was called.
      522**/
      523 
      524 	     do i = 1 to 2;
      525 
      526 		if d.debug_io_open (i) then do;
      527 		     call iox_$close (d.debug_io_ptr (i), code);
      528 		     if code ^= 0 then if code ^= error_table_$not_open then call com_err_ (code, "debug");
      529 		end;
      530 
      531 		if d.debug_io_attach (i) then do;
      532 		     call iox_$detach_iocb (d.debug_io_ptr (i), code);
      533 		     if code ^= 0 then if code ^= error_table_$not_attached then call com_err_ (code, "debug");
      534 		end;
      535 	     end;
      536 
      537 	     d = save;				/* restore external static data */
      538 	     static_init_count = static_init_count - 1;
      539 
      540 	     return;
      541 	end restore;
      542 
      543 /*  */
      544 /* The external static is setup to work like controlled storage.  When debug is called, the
      545*   external static is copied into automatic storage.  Before the user returns from debug, the external static is
      546*   restored using the values saved in automatic storage.  This is required for the return_label and is also
      547*   convienent for cleanup for users who change the io switches. */
      548 
      549 set_ext_stat: proc;
      550 
      551 	     save = d;				/* save ext static data */
      552 	     d.debug_input = "user_input";
      553 	     d.debug_output = "user_output";
      554 	     d.debug_io_open (1), d.debug_io_open (2), d.debug_io_attach (1), d.debug_io_attach (2) = "0"b;
      555 	     d.debug_io_ptr (1) = iox_$user_input;
      556 	     d.debug_io_ptr (2) = iox_$user_output;
      557 	     static_init_count = static_init_count + 1;
      558 
      559 /* When the user issues a debug quit command we want to return to the procedure which
      560*   called "debug".  Thus we must be using the stack frame of "debug" when it was entered
      561*   via a call.  In order to quit out of debug when it was entered via a fault we must
      562*   do a non local goto back to the stack frame of "debug" when it was entered via a call. */
      563 
      564 	     d.return_label = return_from_debug;
      565 
      566 	     on cleanup call restore;
      567 
      568 	end set_ext_stat;
      569 set_internal_stat: proc;
      570 
      571 	     com_stat_ptr = addr (common_static_area);	/* common static data */
      572 	     if initial_flag then return;
      573 
      574 	     call hcs_$high_low_seg_count (i, hcs_count);
      575 
      576 	     sb = ptr (cu_$stack_frame_ptr (), 0);	/* ptr to base of stack */
      577 	     lotp = sb -> stack_header.lot_ptr;		/* ptr to base of the linkage */
      578 
      579 	     print_mode = 1;			/* long message mode */
      580 	     temp_comd_len = 0;			/* no temporary global break command line */
      581 	     initial_flag = "1"b;
      582 
      583 	end set_internal_stat;
      584      end debug;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/86  1034.0  debug.pl1                         >special_ldd>install>MR12.0-1206>debug.pl1
103          1    08/12/76  1010.2  db_ext_stat_.incl.pl1             >ldd>include>db_ext_stat_.incl.pl1
138          2    05/06/74  1741.6  db_common_auto.incl.pl1           >ldd>include>db_common_auto.incl.pl1
139          3    05/06/74  1741.6  db_common_static.incl.pl1         >ldd>include>db_common_static.incl.pl1
141          4    05/06/74  1741.6  db_inst.incl.pl1                  >ldd>include>db_inst.incl.pl1
143          5    11/06/75  1110.0  db_snt.incl.pl1                   >ldd>include>db_snt.incl.pl1
145          6    11/04/86  1324.3  stack_header.incl.pl1             >special_ldd>install>MR12.0-1206>stack_header.incl.pl1
146          7    11/03/86  1114.7  stack_frame.incl.pl1              >special_ldd>install>MR12.0-1206>stack_frame.incl.pl1
147          8    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 131 ref 154 156 157 158 201 204 205 206 214 236
                                                                                  237 239 239 255 286 290 308 327 345 345 368 396
                                                                                  414 426 446 471 526 527 531 532 537 551 552 553
                                                                                  554 554 554 554 555 556 564 571
addrel                                                 builtin function         dcl 131 ref 514
arg_mcp                                parameter       pointer                  dcl 26 ref 196 208
baseptr                                                builtin function         dcl 131 ref 215
break_num                       000367 automatic       fixed bin(17,0)          dcl 41 set ref 162* 216* 219* 236* 237* 334 363 397*
break_ptr                       000370 automatic       pointer                  dcl 41 set ref 215* 216 219* 224 237* 363 397* 496
                                                                                  496 502 514
cleanup                         000000 stack reference condition                dcl 84 ref 566
code                            000470 automatic       fixed bin(35,0)          dcl 86 set ref 308* 313 314* 315 327* 330 330* 527*
                                                                                  528 528 528* 532* 533 533 533*
com_auto_data                          based           structure                level 1 dcl 2-24
com_auto_ptr                    000476 automatic       pointer                  dcl 2-13 set ref 157* 164 179 205* 208 214 217 219
                                                                                  229 239* 242* 245 319 321* 323 397 411 411 443 459
                                                                                  473 478 482
com_err_                        002134 constant        entry                    external dcl 127 ref 314 330 528 533
com_stat_ptr                    000500 automatic       pointer                  dcl 3-12 set ref 156* 163 204* 236 239 239 239 239
                                                                                  239* 242* 321* 377 385 397 451 478 571* 574 577
                                                                                  579 580
com_static_data                        based           structure                level 1 dcl 3-23
comd_len                        000374 automatic       fixed bin(17,0)          dcl 48 set ref 219* 242 242*
comd_ptr                        000376 automatic       pointer                  dcl 48 set ref 219* 242*
command_abort_                  000462 stack reference condition                dcl 85 ref 346
common_auto_area                000100 automatic       fixed bin(17,0)          array dcl 36 set ref 157 205
common_static_area              000010 internal static fixed bin(17,0)          array dcl 96 set ref 156 204 571
cond_flag                       000400 automatic       fixed bin(17,0)          dcl 48 set ref 219* 229
condition_                      002064 constant        entry                    external dcl 106 ref 160 422 423 425
conditions                      000100 automatic       char(106)                initial unaligned dcl 284 set ref 284* 289
cont                                   parameter       bit(1)                   unaligned dcl 279 set ref 277 295*
cu_$stack_frame_ptr             002066 constant        entry                    external dcl 106 ref 169 576
d                                      based           structure                level 1 unaligned dcl 105 set ref 537* 551
db_action_code            6            based           fixed bin(17,0)          level 2 dcl 2-24 set ref 245 319* 323 411*
db_break$check_break            002070 constant        entry                    external dcl 106 ref 219
db_break$restart                002072 constant        entry                    external dcl 106 ref 397
db_break$set_break              002074 constant        entry                    external dcl 106 ref 385
db_ext_stat_$db_ext_stat_       002062 external static structure                level 1 dcl 1-9 set ref 154 201 236 237 255 286 290
                                                                                  308 327 345 345 368 396 426 446 471 526 527 531
                                                                                  532 537 551 552 553 554 554 554 554 555 556 564
db_fill_snt                     002076 constant        entry                    external dcl 106 ref 218 381 478
db_find_mc                      002100 constant        entry                    external dcl 106 ref 179
db_line_no                      002116 constant        entry                    external dcl 106 ref 496
db_mc_ptr                              based           pointer                  level 2 dcl 2-24 set ref 179* 208* 214 217
db_parse                        002102 constant        entry                    external dcl 106 ref 239 242 321
debug$mme2_fault                002104 constant        entry                    external dcl 106 ref 160 160
debug_input                            based           char(32)                 level 2 dcl 105 set ref 552*
debug_io_attach          30            based           bit(1)                   array level 3 packed unaligned dcl 105 set ref 531
                                                                                  554* 554*
debug_io_open            30(02)        based           bit(1)                   array level 3 packed unaligned dcl 105 set ref 526
                                                                                  554* 554*
debug_io_ptr             24            based           pointer                  array level 2 dcl 105 set ref 308* 327* 527* 532*
                                                                                  555* 556*
debug_output             10            based           char(32)                 level 2 dcl 105 set ref 236* 237* 255* 290* 368*
                                                                                  446* 471* 553*
ent_name                 10            based           char(32)                 level 2 dcl 5-9 set ref 236* 237*
error_table_$long_record        002136 external static fixed bin(35,0)          dcl 128 ref 315
error_table_$not_attached       002140 external static fixed bin(35,0)          dcl 129 ref 533
error_table_$not_open           002142 external static fixed bin(35,0)          dcl 130 ref 528
first_call_flag           5            based           fixed bin(17,0)          level 2 dcl 2-24 set ref 411*
fixed                                                  builtin function         dcl 131 ref 215 216 496 496
flags                    30            based           structure                level 2 dcl 105
hcs_$high_low_seg_count         002106 constant        entry                    external dcl 106 ref 574
hcs_count                 2            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 574*
i                               000401 automatic       fixed bin(17,0)          dcl 58 set ref 233* 437* 443 446 451 459* 473 524*
                                                                                  526 527 531 532* 574*
ilc                       4            based           bit(18)                  level 2 packed unaligned dcl 8-56 ref 215
in_debug                 30(04)        based           bit(1)                   level 3 packed unaligned dcl 105 set ref 286 396*
                                                                                  426*
info_ptr                               parameter       pointer                  dcl 279 ref 277
initial_flag                    002060 internal static bit(1)                   initial unaligned dcl 98 set ref 572 581*
input_buffer                    000402 automatic       char(132)                dcl 60 set ref 414
input_buffer_ptr                000444 automatic       pointer                  dcl 60 set ref 308* 321* 414*
input_line_len                  000447 automatic       fixed bin(17,0)          dcl 60 set ref 311* 318 321*
input_line_len21                000446 automatic       fixed bin(21,0)          dcl 60 set ref 308* 311
instr                                  based           structure                level 1 dcl 4-13
ioa_$ioa_stream                 002110 constant        entry                    external dcl 106 ref 236 237 255 290 368 446 471
ioa_$rsnnl                      002112 constant        entry                    external dcl 106 ref 233
iox_$close                      002130 constant        entry                    external dcl 125 ref 527
iox_$control                    002120 constant        entry                    external dcl 121 ref 327
iox_$detach_iocb                002132 constant        entry                    external dcl 126 ref 532
iox_$get_line                   002126 constant        entry                    external dcl 124 ref 308
iox_$user_input                 002124 external static pointer                  dcl 123 ref 555
iox_$user_output                002122 external static pointer                  dcl 122 ref 556
last_sp                         000460 automatic       pointer                  dcl 80 set ref 169* 179* 217* 218* 381* 433 454
legal_f_                        002114 constant        entry                    external dcl 106 ref 439
line_1st_inst_off               000452 automatic       fixed bin(17,0)          dcl 69 set ref 496* 502
line_info                       000454 automatic       char(14)                 dcl 78 set ref 233* 234* 236* 237*
line_num                        000451 automatic       fixed bin(17,0)          dcl 69 set ref 219* 233 233* 496* 498 512*
line_num_inst                   000453 automatic       fixed bin(17,0)          dcl 69 set ref 496* 502
lot_ptr                  26            based           pointer                  level 2 dcl 6-26 ref 577
lotp                                   based           pointer                  level 2 dcl 3-23 set ref 577*
max_sp_x                  4            based           fixed bin(17,0)          level 2 dcl 2-24 set ref 443* 459* 473* 478
mc                                     based           structure                level 1 dcl 8-12
mcptr                                  parameter       pointer                  dcl 279 ref 277
name                                   parameter       char                     unaligned dcl 279 set ref 277 288 288* 289 290*
new_line                        000471 automatic       char(1)                  initial unaligned dcl 87 set ref 87*
next_sp                  22            based           pointer                  level 2 dcl 7-36 ref 466
null                                                   builtin function         dcl 131 ref 224 327 327 363
num_skips                 7            based           fixed bin(17,0)          level 2 dcl 2-24 set ref 164* 219* 229 397*
offset                                 based           fixed bin(17,0)          level 2 packed unaligned dcl 4-13 ref 216
ppr                                    based           structure                level 2 packed unaligned dcl 8-56
prev_sp                  20            based           pointer                  level 2 dcl 7-36 ref 169
print_mode                3            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 236 385* 397* 579*
printer_on                      000450 automatic       char(1)                  initial unaligned dcl 67 set ref 67*
prs                                    based           pointer                  array level 2 dcl 8-12 ref 217
psr                       0(03)        based           bit(15)                  level 3 packed unaligned dcl 8-56 ref 215
ptr                                                    builtin function         dcl 131 ref 215 433 502 576
read_line_label                 000472 automatic       label variable           dcl 90 set ref 226 256 262 291 421*
return_label             20            based           label variable           level 2 dcl 105 set ref 345 564*
save                            000336 automatic       structure                level 1 dcl 40 set ref 537 551*
sb                              000504 automatic       pointer                  dcl 6-24 set ref 576* 577
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed unaligned
                                                                                  dcl 8-12 in procedure "db" set ref 214
scu                                    based           structure                level 1 dcl 8-56 in procedure "db"
scup                            000510 automatic       pointer                  dcl 8-54 set ref 214* 215 215 397*
snt                                    based           structure                level 1 dcl 5-9
snt_area                        000230 automatic       fixed bin(17,0)          array dcl 36 set ref 158 206
snt_ptr                   2            based           pointer                  level 2 dcl 2-24 set ref 482*
sntp                            000502 automatic       pointer                  dcl 5-7 set ref 158* 206* 218* 219* 236 237 381*
                                                                                  385* 478* 482 496*
sp                              000506 automatic       pointer                  dcl 7-31 set ref 433* 439* 451 454 466* 466
spx                                    constant        fixed bin(17,0)          initial dcl 8-42 ref 217
stack_begin_ptr          22            based           pointer                  level 2 dcl 6-26 ref 433
stack_frame                            based           structure                level 1 dcl 7-36
stack_header                           based           structure                level 1 dcl 6-26
stack_ptr_array           4            based           pointer                  array level 2 dcl 3-23 set ref 451* 478*
static_handler_call      30(05)        based           bit(1)                   level 3 packed unaligned dcl 105 set ref 154* 201*
                                                                                  345
static_init_count               002057 internal static fixed bin(17,0)          initial dcl 97 set ref 151 198 538* 538 557* 557
temp_break_mode        2046            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 163* 377
temp_break_ptr                  000372 automatic       pointer                  dcl 41 set ref 385* 502* 514*
temp_comd_len          2004            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 239 239* 580*
temp_comd_line         2005            based           char(132)                level 2 dcl 3-23 set ref 239 239
wcptr                                  parameter       pointer                  dcl 279 ref 277

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
RETURN_PTR_MASK                        internal static bit(72)                  initial unaligned dcl 7-19
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial unaligned dcl 7-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial unaligned dcl 7-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial unaligned dcl 7-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial unaligned dcl 7-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial unaligned dcl 7-27
abx                                    internal static fixed bin(17,0)          initial dcl 8-42
apx                                    internal static fixed bin(17,0)          initial dcl 8-42
bbx                                    internal static fixed bin(17,0)          initial dcl 8-42
bpx                                    internal static fixed bin(17,0)          initial dcl 8-42
call_offset                            internal static fixed bin(17,0)          initial dcl 6-78
db_ext_stat_$break_instructions        external static bit(36)                  array dcl 1-27
entry_offset                           internal static fixed bin(17,0)          initial dcl 6-78
ilc_ptr                                automatic       pointer                  dcl 4-10
instr_pr                               based           structure                level 1 dcl 4-21
lbx                                    internal static fixed bin(17,0)          initial dcl 8-42
lpx                                    internal static fixed bin(17,0)          initial dcl 8-42
mcp                                    automatic       pointer                  dcl 8-10
push_offset                            internal static fixed bin(17,0)          initial dcl 6-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 6-78
return_offset                          internal static fixed bin(17,0)          initial dcl 6-78
sbx                                    internal static fixed bin(17,0)          initial dcl 8-42
scux                                   based           structure                level 1 dcl 8-207
stack_frame_flags                      based           structure                level 1 dcl 7-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 7-33
stack_header_overlay                   based           fixed bin(17,0)          array dcl 6-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 6-72

NAMES DECLARED BY EXPLICIT CONTEXT.
any_other_handler               001267 constant        entry                    internal dcl 277 ref 425 425
common_init                     001365 constant        entry                    internal dcl 401 ref 184 225 231
conversion_handler              001224 constant        entry                    internal dcl 253 ref 422 422
db                              000224 constant        entry                    external dcl 16
db_action_label                 000000 constant        label                    array(0:3) dcl 308 ref 245 323
debug                           000234 constant        entry                    external dcl 16
get_line_num                    001647 constant        entry                    internal dcl 486 ref 383
get_snt_data                    001626 constant        label                    dcl 478 ref 448 462
mme2_fault                      000347 constant        entry                    external dcl 196
prog_interrupt_handler          001256 constant        entry                    internal dcl 260 ref 423 423
quit                            001061 constant        label                    dcl 334 ref 316
read_line                       000705 constant        label                    dcl 308 ref 186 315 318 331 347 369 421
restart_break                   001111 constant        label                    dcl 363 ref 229
restore                         001712 constant        entry                    internal dcl 516 ref 338 349 566
return_from_debug               001104 constant        label                    dcl 349 ref 564
set_ext_stat                    002147 constant        entry                    internal dcl 549 ref 153 200
set_internal_stat               002333 constant        entry                    internal dcl 569 ref 151 199

NAMES DECLARED BY CONTEXT OR IMPLICATION.
index                                                  builtin function         ref 289
rel                                                    builtin function         ref 496 496

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2760        5124    2406        2770
Length      5556    2406      2144         416     352        2052

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
db                                  498 external procedure  is an external procedure.  
conversion_handler                   78 internal procedure  is assigned to an entry variable.  
prog_interrupt_handler               64 internal procedure  is assigned to an entry variable.  
any_other_handler                   110 internal procedure  is assigned to an entry variable.  
common_init                             internal procedure  shares stack frame of external procedure db.  
get_line_num                            internal procedure  shares stack frame of external procedure db.  
restore                              84 internal procedure  is called by several nonquick procedures.  
set_ext_stat                         71 internal procedure  enables or reverts conditions.  
on unit on line 566                  64 on unit               
set_internal_stat                       internal procedure  shares stack frame of external procedure db.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 common_static_area          db
002057 static_init_count           db
002060 initial_flag                db

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
any_other_handler        000100 conditions                  any_other_handler
db                       000100 common_auto_area            db
                         000230 snt_area                    db
                         000336 save                        db
                         000367 break_num                   db
                         000370 break_ptr                   db
                         000372 temp_break_ptr              db
                         000374 comd_len                    db
                         000376 comd_ptr                    db
                         000400 cond_flag                   db
                         000401 i                           db
                         000402 input_buffer                db
                         000444 input_buffer_ptr            db
                         000446 input_line_len21            db
                         000447 input_line_len              db
                         000450 printer_on                  db
                         000451 line_num                    db
                         000452 line_1st_inst_off           db
                         000453 line_num_inst               db
                         000454 line_info                   db
                         000460 last_sp                     db
                         000470 code                        db
                         000471 new_line                    db
                         000472 read_line_label             db
                         000476 com_auto_ptr                db
                         000500 com_stat_ptr                db
                         000502 sntp                        db
                         000504 sb                          db
                         000506 sp                          db
                         000510 scup                        db

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          move_label_var
make_label_var      tra_ext_2           signal_op           enable_op           ext_entry           int_entry
int_entry_desc      set_chars_eis       index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      condition_                    cu_$stack_frame_ptr           db_break$check_break
db_break$restart              db_break$set_break            db_fill_snt                   db_find_mc
db_line_no                    db_parse                      debug$mme2_fault              hcs_$high_low_seg_count
ioa_$ioa_stream               ioa_$rsnnl                    iox_$close                    iox_$control
iox_$detach_iocb              iox_$get_line                 legal_f_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
db_ext_stat_$db_ext_stat_     error_table_$long_record      error_table_$not_attached     error_table_$not_open
iox_$user_input               iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     67 000215        87 000217        16 000223       151 000242       153 000246       154 000252       156 000256
    157 000260       158 000262       160 000264       162 000306       163 000307       164 000311       169 000313
    179 000325       184 000342       186 000343       196 000344       198 000355       199 000360       200 000361
    201 000365       204 000371       205 000373       206 000375       208 000377       214 000403       215 000405
    216 000416       217 000421       218 000424       219 000434       224 000462       225 000466       226 000467
    229 000471       231 000477       233 000500       234 000534       236 000537       237 000600       239 000641
    242 000663       245 000702       308 000705       311 000727       313 000731       314 000733       315 000752
    316 000756       318 000757       319 000762       321 000764       323 001001       327 001004       330 001037
    331 001060       334 001061       338 001063       339 001067       345 001070       346 001100       347 001103
    349 001104       353 001110       363 001111       368 001117       369 001140       377 001141       381 001144
    383 001155       385 001156       396 001176       397 001202       398 001222       253 001223       255 001231
    256 001252       260 001255       262 001263       277 001266       284 001302       286 001305       288 001312
    289 001323       290 001332       291 001354       295 001357       296 001364       401 001365       411 001366
    414 001371       421 001373       422 001376       423 001422       425 001450       426 001474       433 001500
    437 001503       439 001507       443 001522       446 001526       448 001556       451 001557       454 001564
    459 001570       462 001573       466 001574       468 001577       471 001601       473 001622       478 001626
    482 001643       484 001646       486 001647       496 001650       498 001672       502 001675       504 001702
    512 001703       514 001705       515 001710       516 001711       524 001717       526 001726       527 001734
    528 001745       531 001771       532 002001       533 002013       535 002037       537 002042       538 002143
    540 002145       549 002146       551 002154       552 002255       553 002261       554 002264       555 002274
    556 002277       557 002302       564 002303       566 002310       568 002332       569 002333       571 002334
    572 002337       574 002342       576 002352       577 002363       579 002365       580 002370       581 002371
    583 002374


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
