	COMPILATION LISTING OF SEGMENT cm_create_collection
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0950.5 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*          This routine creates a collection. Basically this consists of the
       11*     following steps:
       12*     1) initialize and store a collection_header structure as a regular
       13*     element in the header collection.  The element id of this element is
       14*     the collection's id.
       15*     2) initialize and store a storage record.  Depending on the requested
       16*     control interval storage method, this will either be an
       17*     unblocked_storage_record structure or a blocked_storage_record structure.
       18*     3) Add the new collection id to the collection_id_table structure and
       19*     put it back in the header collection. The CIT is infinitely (nearly)
       20*     extendable.
       21*     4) Update the number of collections in the cm_file_header structure and
       22*     put it back in the header collection.
       23**/
       24 
       25 /* HISTORY:
       26*Written by Matthew Pierret.
       27*Modified:
       28*03/26/82 by Matthew Pierret: Fixed a bug which used wrong value to signify
       29*            beginning-of-element to put_element.
       30*            Also fixed bug that tried to put, instead of allocate, the 
       31*            collmgr_header the first time around.
       32*            Extended collmgr_header to contain an entry for the header 
       33*            collection, initialized the first tiem this module is called.
       34*04/16/82 by Matthew Pierret: Made to set the thread_control_intervals flag.
       35*04/21/82 by Matthew Pierret: Removed code to create collmgr_header if not found.
       36*            This function has been moved to cm_init_ci_0, which is called by
       37*            page_file_manager_$create.
       38*05/19/82 by Matthew Pierret: Changed collmgr_header to contain an array of
       39*            element ids "pointing" to collection_header's, each stored as an
       40*            element in the header collection.
       41*06/15/82 by Matthew Pierret: Changed to use bci_header, dm_cm_basic_ci.incl,
       42*            new calling sequence to cm_put_element.
       43*07/28/82 by Matthew Pierret: Adjusted for extensibility of collmgr_header.
       44*10/12/82 by Matthew Pierret:  Fixed bug that truncated collection_id_table.
       45*11/03/82 by Matthew Pierret:  Changed to use version 2 of collection_header,
       46*            separate element for storage element, cm_file_header instead of
       47*            collmgr_header, opening info (cm_info).
       48*12/03/82 by Lindsey Spratt:  Changed to set the collection_id_table_ptr when
       49*            there are no collections.  It was just being used uninitialized.
       50*04/29/83 by Matthew Pierret: Removed some unused variables.
       51*05/21/84 by Matthew Pierret: Renamed include files dm_cm_(esm csim)_info
       52*            to dm_(esm cism)_info. Added ERROR_RETURN procedure. Added version
       53*            checks for the *esm_info and *cism_info structures.
       54*06/12/84 by Matthew Pierret: Re-named cm_put_element to cm_modify,
       55*            cm_allocate_element to cm_put.
       56*09/26/84 by Matthew Pierret: Moved declaration of et_$unimplemented_version
       57*            to the main procedure.
       58**/
       59 
       60 
       61 /* format: style2,ind3 */
       62 
       63 cm_create_collection:
       64    proc (p_file_opening_id, p_cism_info_ptr, p_esm_info_ptr, p_collection_id, p_code);
       65 
       66 
       67 /* START OF DECLARATIONS */
       68 /* Parameter */
       69 
       70       dcl	    p_file_opening_id      bit (36) aligned;
       71       dcl	    p_cism_info_ptr	       ptr;
       72       dcl	    p_esm_info_ptr	       ptr;
       73       dcl	    p_collection_id	       bit (36) aligned;
       74       dcl	    p_code	       fixed bin (35);
       75 
       76 /* Automatic */
       77 
       78       dcl	    1 automatic_collection_header
       79 			       aligned like collection_header;
       80       dcl	    1 automatic_cm_file_header
       81 			       aligned like cm_file_header;
       82       dcl	    automatic_storage_record_buffer
       83 			       (6) fixed bin (71) init (0, 0, 0, 0, 0, 0);
       84       dcl	    code		       fixed bin (35);
       85       dcl	    collection_id	       bit (36) aligned;
       86       dcl	    collection_entry_idx   fixed bin;
       87       dcl	    collection_id_table_length_in_dwords
       88 			       fixed bin (17);
       89       dcl	    collection_id_table_length_in_bits
       90 			       fixed bin (35);
       91 
       92 /* Based */
       93 /* Builtin */
       94 
       95       dcl	    (length, unspec, null, addr, divide)
       96 			       builtin;
       97 
       98 /* Controlled */
       99 /* Constant */
      100 
      101       dcl	    FULL_LENGTH_OF_ELEMENT fixed bin (35) init (-1);
      102       dcl	    BITS_PER_BYTE	       fixed bin init (4);
      103       dcl	    BITS_PER_WORD	       fixed bin init (36);
      104       dcl	    NO_HEADER_RECORD       bit (36) aligned init ("0"b);
      105       dcl	    myname	       init ("cm_create_collection") char (20);
      106 
      107 /* Entry */
      108 
      109       dcl	    sub_err_	       entry () options (variable);
      110 
      111 /* External */
      112 
      113       dcl	    dm_error_$unimplemented_cism
      114 			       ext fixed bin (35);
      115       dcl	    dm_error_$unimplemented_esm
      116 			       ext fixed bin (35);
      117       dcl	    error_table_$unimplemented_version
      118 			       ext fixed bin (35);
      119 
      120 /* END OF DECLARATIONS */
      121 
      122       p_code, code = 0;
      123 
      124       call cm_opening_info$get (p_file_opening_id, HEADER_COLLECTION_ID, cm_info_ptr, code);
      125       if code ^= 0
      126       then call ERROR_RETURN (code);
      127 
      128       unblocked_cism_info_ptr = p_cism_info_ptr;
      129       call CHECK_VERSION ("cism_info", unblocked_cism_info.version, CISM_INFO_VERSION_1);
      130       basic_esm_info_ptr = p_esm_info_ptr;
      131       call CHECK_VERSION ("cism_info", basic_esm_info.version, ESM_INFO_VERSION_1);
      132 
      133       collection_id = "0"b;
      134 
      135       unspec (automatic_cm_file_header) = "0"b;
      136       unspec (automatic_collection_header) = "0"b;
      137 
      138 /*
      139*     Get the cm_file_header.  
      140**/
      141 
      142       call cm_get_element (cm_info.file_oid, cm_info.collection_id, CM_FILE_HEADER_ELEMENT_ID, 0,
      143 	 addr (automatic_cm_file_header), length (unspec (automatic_cm_file_header)), null, ("0"b), cm_file_header_ptr,
      144 	 (0), code);
      145       if code ^= 0
      146       then call ERROR_RETURN (code);
      147 
      148       call CHECK_VERSION ("cm_file_header", cm_file_header.version, CM_FILE_HEADER_VERSION_1);
      149 
      150 /*
      151*     Set up space for the collection_id_table. Each collection id takes up one
      152*     word in the collection_id_table and one may be added for the new
      153*     collection.
      154**/
      155 
      156       collection_id_table_length_in_dwords = divide (cm_file_header.number_of_collections, 2, 17, 0) + 1;
      157       collection_id_table_length_in_bits = cm_file_header.number_of_collections * BITS_PER_WORD;
      158 
      159 BEGIN_BLOCK:
      160       begin;
      161 
      162          dcl     automatic_cit_buffer	(collection_id_table_length_in_dwords) fixed bin (71);
      163 
      164          automatic_cit_buffer = 0;
      165          cit_number_of_collections = cm_file_header.number_of_collections;
      166 
      167          if cm_file_header.number_of_collections > 0
      168          then call cm_get_element (cm_info.file_oid, HEADER_COLLECTION_ID, cm_file_header.collection_id_table_element_id,
      169 	         0, addr (automatic_cit_buffer), collection_id_table_length_in_bits, null, ("0"b),
      170 	         collection_id_table_ptr, (0), code);
      171          else collection_id_table_ptr = addr (automatic_cit_buffer);
      172          if code ^= 0
      173          then call ERROR_RETURN (code);
      174 
      175 /*
      176*    Find a free slot in the collection_id_table, extending the table by one if
      177*    necessary.
      178**/
      179 
      180          do collection_entry_idx = 1 to cm_file_header.number_of_collections
      181 	    while (collection_id_table (collection_entry_idx) ^= "0"b);
      182          end;
      183 
      184          if collection_entry_idx > cm_file_header.number_of_collections
      185          then
      186 	  do;
      187 	     collection_id_table_length_in_bits = collection_id_table_length_in_bits + BITS_PER_WORD;
      188 	     cit_number_of_collections = cm_file_header.number_of_collections + 1;
      189 	     cm_file_header.number_of_collections = cit_number_of_collections;
      190 
      191 	  end;
      192 
      193 /* 
      194*     Initialize the collection_header for the new collection from the supplied
      195*     information.
      196**/
      197 
      198          collection_header_ptr = addr (automatic_collection_header);
      199          collection_header.version = COLLECTION_HEADER_VERSION_2;
      200          collection_header.control_interval_storage_method = unblocked_cism_info.type;
      201          collection_header.element_storage_method = basic_esm_info.type;
      202 
      203          if basic_esm_info.type = BASIC_ELEMENT_STORAGE_METHOD
      204          then
      205 BASIC_ESM:
      206 	  do;
      207 	     collection_header.flags.fixed_size_elements = basic_esm_info.flags.fixed_length;
      208 	     collection_header.flags.thread_elements = basic_esm_info.flags.threaded;
      209 	     collection_header.flags.must_be_zero1 = "0"b;
      210 	     collection_header.maximum_element_size = basic_esm_info.maximum_element_length;
      211 
      212 	  end BASIC_ESM;
      213 
      214          else if basic_esm_info.type = ORDERED_ELEMENT_STORAGE_METHOD
      215          then
      216 ORDERED_ESM:
      217 	  do;
      218 	     ordered_esm_info_ptr = p_esm_info_ptr;
      219 	     collection_header.flags.fixed_size_elements = ordered_esm_info.flags.fixed_length;
      220 	     collection_header.flags.thread_elements = "0"b;
      221 	     collection_header.flags.must_be_zero1 = "0"b;
      222 	     collection_header.maximum_element_size = ordered_esm_info.maximum_element_length;
      223 
      224 	  end ORDERED_ESM;
      225 
      226          else call sub_err_ (dm_error_$unimplemented_esm, myname, ACTION_CANT_RESTART, null, 0,
      227 	         "^/This routine does not implement element storage method ^d.", basic_esm_info.type);
      228 
      229 
      230          if unblocked_cism_info.type = UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
      231          then
      232 UNBLOCKED:
      233 	  do;
      234 	     unblocked_storage_record_ptr = addr (automatic_storage_record_buffer);
      235 
      236 	     unblocked_storage_record.first_control_interval = 0;
      237 	     unblocked_storage_record.last_control_interval = 0;
      238 
      239 	     collection_header.flags.thread_control_intervals = "1"b;
      240 
      241 	     call cm_put$info (cm_info_ptr, unblocked_storage_record_ptr, length (unspec (unblocked_storage_record)),
      242 		collection_header.storage_record_element_id, (0), code);
      243 	     if code ^= 0
      244 	     then call ERROR_RETURN (code);
      245 
      246 	  end UNBLOCKED;
      247 
      248          else if unblocked_cism_info.type = BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
      249          then
      250 BLOCKED:
      251 	  do;
      252 	     call sub_err_ (dm_error_$unimplemented_cism, myname, ACTION_CANT_RESTART, null, 0,
      253 		"^/This routine does not implement control interval storage method ^d.", unblocked_cism_info.type);
      254 						/* Not yet anyway */
      255 
      256 	     blocked_cism_info_ptr = p_cism_info_ptr;
      257 	     blocked_storage_record_ptr = addr (automatic_storage_record_buffer);
      258 
      259 	     blocked_storage_record.last_control_interval = 0;
      260 	     blocked_storage_record.number_of_blocks = 1;
      261 	     blocked_storage_record.number_of_control_intervals_per_block =
      262 		blocked_cism_info.number_of_control_intervals_per_block;
      263 
      264 	     call cm_put$info (cm_info_ptr, unblocked_storage_record_ptr, length (unspec (blocked_storage_record)),
      265 		collection_header.storage_record_element_id, (0), code);
      266 	     if code ^= 0
      267 	     then call ERROR_RETURN (code);
      268 
      269 	  end BLOCKED;
      270 
      271          else call sub_err_ (dm_error_$unimplemented_cism, myname, ACTION_CANT_RESTART, null, 0,
      272 	         "^/This routine does not implement control interval storage method ^d.", unblocked_cism_info.type);
      273 
      274 /* Allocate a new element and put the new collection_header in it. */
      275 
      276          call cm_put$info (cm_info_ptr, collection_header_ptr, length (unspec (collection_header)), collection_id, (0),
      277 	    code);
      278          if code ^= 0
      279          then call ERROR_RETURN (code);
      280 
      281 /* Put back the table of collection_header element_ids, with the new id */
      282 
      283          collection_id_table (collection_entry_idx) = collection_id;
      284 
      285          call cm_modify$info (cm_info_ptr, collection_id_table_ptr, collection_id_table_length_in_bits,
      286 	    cm_file_header.collection_id_table_element_id, (0), code);
      287          if code ^= 0
      288          then call ERROR_RETURN (code);
      289 
      290 /* Put the cm_file_header. */
      291 
      292          call cm_modify$info (cm_info_ptr, cm_file_header_ptr, FULL_LENGTH_OF_ELEMENT, CM_FILE_HEADER_ELEMENT_ID, (0),
      293 	    code);
      294          if code ^= 0
      295          then call ERROR_RETURN (code);
      296 
      297 
      298       end BEGIN_BLOCK;
      299 
      300       p_collection_id = collection_id;
      301       p_code = code;
      302 
      303 MAIN_RETURN:
      304       return;
      305 
      306 ERROR_RETURN:
      307    proc (er_p_code);
      308 
      309       dcl	    er_p_code	       fixed bin (35);
      310 
      311       p_code = er_p_code;
      312       go to MAIN_RETURN;
      313 
      314    end ERROR_RETURN;
      315 
      316 
      317 CHECK_VERSION:
      318    proc (cv_p_structure_name, cv_p_given_version, cv_p_correct_version);
      319 
      320       dcl	    cv_p_structure_name    char (*);
      321       dcl	    cv_p_given_version     char (8) aligned;
      322       dcl	    cv_p_correct_version   char (8) aligned;
      323 
      324       if cv_p_given_version ^= cv_p_correct_version
      325       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      326 	      "^/Expected version ""^8a"" of ^a structure; received ""^8a"".", cv_p_correct_version,
      327 	      cv_p_structure_name, cv_p_given_version);
      328       else return;
      329 
      330    end CHECK_VERSION;
      331 
  1     1 /* BEGIN INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        Contains the identifier of the Header Collection for a file
  1     6*   managed by the collection_manager_.  This is used by callers of 
  1     7*   collection_manager who wish to maintain their own file header or who wish
  1     8*   to maintain their own collection header information beyond the caller
  1     9*   collection header provided by colleciton_manager_$(get put)_header.
  1    10**/
  1    11 
  1    12 /* HISTORY:
  1    13*Written by Matthew Pierret, 09/24/84.
  1    14*Modified:
  1    15**/
  1    16 
  1    17 /* format: style2,ind3,ll79 */
  1    18 
  1    19      dcl	   HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36)
  1    20 			      aligned internal static options (constant);
  1    21 
  1    22 /* END INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
      332 
      333 
  2     1 /* BEGIN INCLUDE FILE dm_cm_hdr_col_ids.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*   Contains element identifiers of some elements in the Header Collection.
  2     6*   HEADER_COLLECTION_HEADER_ELEMENT_ID is the identifier of the element in
  2     7*   which the collection_header for the Header Collection is stored (see
  2     8*   dm_cm_collection_header.incl.pl1).
  2     9*   CALLER_HEADER_ELEMENT_ID is the identifier of the element in which the
  2    10*   caller's file header is stored.
  2    11*   CM_FILE_HEADER_ELEMENT_ID is the identifier of the element in which the
  2    12*   cm_file_header structure is stored (see dm_cm_file_header.incl.pl1).
  2    13**/
  2    14 
  2    15 /* HISTORY:
  2    16*Written by Matthew Pierret, 09/24/84.
  2    17*Modified:
  2    18**/
  2    19 
  2    20 /* format: style2,ind3,ll79 */
  2    21      dcl	   (
  2    22 	   HEADER_COLLECTION_HEADER_ELEMENT_ID
  2    23 			      init ("000000000001"b3),
  2    24 	   CM_FILE_HEADER_ELEMENT_ID
  2    25 			      init ("000000000002"b3),
  2    26 	   CALLER_HEADER_ELEMENT_ID
  2    27 			      init ("000000000003"b3)
  2    28 	   )		      bit (36) aligned int static
  2    29 			      options (constant);
  2    30 
  2    31 /* END INCLUDE FILE  dm_cm_hdr_col_ids.incl.pl1 */
      334 
      335 
  3     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*        The cm_info structure is used to hold per-process opening information
  3     5*   about a collection.  It is generally allocated in the process' DM free
  3     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  3     7*   is used to provide access the cm_info structure, keeping it in a hash
  3     8*   table keyed on file opening id and collection id combined.
  3     9*        Currently cm_info is never freed until the process terminates.  Each
  3    10*   time a new transaction is started, detected when the current transaction
  3    11*   id of a process differs from cm_info.current_transaction_id, the information
  3    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  3    13*   demand, as most modules do not need the information in the storage record.
  3    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  3    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  3    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  3    17*   requested, it is placed at the location pointed to by
  3    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  3    19**/
  3    20 
  3    21 /* HISTORY:
  3    22*Written by Matthew Pierret, 10/27/82. 
  3    23*Modified:
  3    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  3    25*            storage_record_buffer_ptr. This points to the storage_record.
  3    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  3    27*            but storage_record_buffer_ptr continues to point at where the
  3    28*            storage_record was. When the storge_record is again requested,
  3    29*            it is put back in the same place rather than allocating a new
  3    30*            storage_record.
  3    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  3    32*            init clause from the version component.
  3    33**/
  3    34 
  3    35 /* format: style2,ind3,ll79 */
  3    36 
  3    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  3    38 	     2 version	      char (8),
  3    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  3    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  3    41 	     2 collection_id      bit (36) aligned init ("0"b),
  3    42 	     2 header_ptr	      ptr init (null),
  3    43 	     2 storage_record_ptr ptr init (null),
  3    44 	     2 storage_record_buffer_ptr
  3    45 			      ptr init (null);
  3    46 
  3    47      dcl	   cm_info_ptr	      ptr init (null);
  3    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  3    49 			      internal static options (constant);
  3    50 
  3    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      336 
      337 
  4     1 /* BEGIN INCLUDE FILE dm_cm_file_header.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        This include file contains the cm_file_header and collection_id_table 
  4     6*   structure.  These structures are stored as elements in the Header Collection
  4     7*   of a file and contain per-file, as opposed to per-collection, information.
  4     8*   
  4     9*        The cm_file_header structure is always stored in the element whose
  4    10*   identifier is CM_FILE_HEADER_ELEMENT_ID, declared in 
  4    11*   dm_cm_hdr_col_ids.incl.pl1.  
  4    12*   
  4    13*        The collection_id_table is an array of identifiers of each collection 
  4    14*   in the file, excepting the Header Collection.  The identifier of a 
  4    15*   collection is the same as the identifier of the element which holds that
  4    16*   collection's collection_header, described in dm_cm_collection_header.incl.pl1.
  4    17*   The identifier of the element in which the collection_id_table is
  4    18*   stored is cm_file_header.collection_id_table_element_id.
  4    19*   
  4    20*      A file also has a reservation map for determining which controls 
  4    21*   intervals have been reserved by a collection.  It is divided into
  4    22*   several blocks, or fragments.  The file_reservation_map is actually an
  4    23*   array of element identifiers of the fragments of the map.  The 
  4    24*   file_reservation_map is stored in the element whose identifier is 
  4    25*   cm_file_header.allocation_map_element_id (quite a misnomer).  The number
  4    26*   of fragments of the map is cm_file_header.number_of_blocks.  The size
  4    27*   of each is fragment is cm_file_header.number_of_control_intervals_per_block
  4    28*   bits long, representing equally as many control intervals.  The
  4    29*   file_reservation_map is described in dm_cm_reservation_map.incl.pl1.
  4    30*   cm_file_header.highest_numbered_ci is the number of the control
  4    31*   interval in the file with the highest control interval number.  It is not 
  4    32*   yet used or maintained.
  4    33*
  4    34**/
  4    35 
  4    36 /* HISTORY:
  4    37*Written by Matthew Pierret, 03/23/82.
  4    38*Modified:
  4    39*04/08/82 by Matthew Pierret: Removed storage method constants.
  4    40*05/18/82 by Matthew Pierret: Made the array of collections an array of element
  4    41*            ids referring to collection_header's. Reduced buffer length to 120,
  4    42*            enough bytes to hold the collmgr_header with 25 collection header
  4    43*            element ids.
  4    44*06/03/82 by Matthew Pierret: Added collmgr_header_header.
  4    45*07/01/82 by Matthew Pierret: Removed collmgr_header_header. Changed to version A
  4    46*            made fixed length, split off array of collection_ids (also known as
  4    47*            element_ids of collection_headers).
  4    48*10/29/82 by Matthew Pierret: Changed from collmgr_header to cm_file_header.
  4    49*09/18/84 by Matthew Pierret: Added DESCRIPTION section. Moved constants to
  4    50*            dm_cm_hdr_col_ids.incl.pl1.  
  4    51**/
  4    52 
  4    53 /* format: style2,ind3,ll79 */
  4    54 
  4    55      dcl	   1 cm_file_header	      aligned based (cm_file_header_ptr),
  4    56 	     2 version	      char (8),
  4    57 	     2 highest_numbered_ci
  4    58 			      fixed bin (24) uns,
  4    59 	     2 number_of_collections
  4    60 			      fixed bin (17) unal,
  4    61 	     2 number_of_blocks   fixed bin (17) unal,
  4    62 	     2 number_of_control_intervals_per_block
  4    63 			      fixed bin (17),
  4    64 	     2 allocation_map_element_id
  4    65 			      bit (36) aligned,
  4    66 	     2 collection_id_table_element_id
  4    67 			      bit (36) aligned;
  4    68 
  4    69      dcl	   cm_file_header_ptr     ptr;
  4    70      dcl	   CM_FILE_HEADER_VERSION_1
  4    71 			      char (8) aligned init ("cm_fhdr1")
  4    72 			      int static options (constant);
  4    73 
  4    74 
  4    75      dcl	   collection_id_table    (cit_number_of_collections)
  4    76 			      bit (36) aligned
  4    77 			      based (collection_id_table_ptr);
  4    78 
  4    79      dcl	   collection_id_table_ptr
  4    80 			      ptr;
  4    81      dcl	   cit_number_of_collections
  4    82 			      fixed bin (17);
  4    83 
  4    84 
  4    85 
  4    86 /* ----------End include file dm_cm_file_header.incl.pl1---------- */
  4    87 
      338 
      339 
  5     1 /* BEGIN INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*       Associated with each collection is the following collection_header
  5     5*   structure stored as an element in the Header Collection of the file.
  5     6*   The identifier of this element is also the idenfifier of the collection.
  5     7*   Even the Header Collection has a collection_header stored in the Header
  5     8*   Collection itself in the element identified by the constant
  5     9*   HEADER_COLLECTION_HEADER_ELEMENT_ID declared in dm_cm_hdr_col_ids.incl.pl1.
  5    10*   The information in collection_header is expected to be stable information.
  5    11*   The structure elements are described as follows:
  5    12*   
  5    13*   version is a character string version equal to COLLECTION_HEADER_VERSION_2.
  5    14*   
  5    15*   flags.fixed_size_elements indicates, if on that all elements in the
  5    16*   collection are of a fixed length.
  5    17*   
  5    18*   flags.thread_elements indicates that elements in a collection are to be
  5    19*   threaded in a linked list.  This is currrently unupported.
  5    20*   
  5    21*   flags.thread_control_intervals indicates, if on, that control intervals in
  5    22*   a collection are to be threaded in a linked list.  This is only useful if
  5    23*   the control interval storage method is blocked.
  5    24*   
  5    25*   flags.must_be_zero1 is reserved for future use and must be "0"b.
  5    26*   
  5    27*   control_interval_storage_method is the method of storage management of
  5    28*   control intervals for this collection, either
  5    29*   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD (not yet supported) or
  5    30*   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, declared in
  5    31*   dm_cism_info.incl.pl1.
  5    32*   
  5    33*   element_storage_method is the method of storage management of elements in
  5    34*   this collection, either BASIC_ELEMENT_STORAGE_METHOD or
  5    35*   ORDERED_ELEMENT_STORAGE_METHOD, declared in dm_esm_info.incl.pl1.
  5    36*   
  5    37*   maximum_element_size is the maximum size of an element in bits in this
  5    38*   collection.
  5    39*   
  5    40*   header_record_element_id is the identifier of an element containing a
  5    41*   caller-defined header for this collection.  If equal to "0"b, no
  5    42*   caller-defined header yet exists.  The put_header collection_manager_
  5    43*   operation stores such a header.
  5    44*   
  5    45*   storage_record_element_id is the identifier of the element containing the
  5    46*   storage_record for this collection.  The storage_record contains
  5    47*   information expected to be dynamic, such as the identifier of the last
  5    48*   control interval of the collection.  Its format is also dependent upon the
  5    49*   storage methods in effect for this collection.  storage_record structures
  5    50*   are declared in dm_cm_storage_record.incl.pl1.
  5    51*
  5    52**/
  5    53 
  5    54 /* HISTORY:
  5    55*Written by Matthew Pierret, 04/01/82.
  5    56*Modified:
  5    57*07/01/82 by Matthew Pierret: Changed to version A, added storage_record_area.
  5    58*10/29/82 by Matthew Pierret: Changed to version 2 ("col_hdr2"), separated
  5    59*            storage_record_area out, leaving storage_record_element_id behind.
  5    60*09/18/84 by Matthew Pierret: Added DESCRIPTION section.
  5    61**/
  5    62 
  5    63 /* format: style2,ind3,ll79 */
  5    64 
  5    65      dcl	   1 collection_header    aligned based (collection_header_ptr),
  5    66 	     2 version	      char (8),
  5    67 	     2 flags	      unaligned,
  5    68 	       3 fixed_size_elements
  5    69 			      bit (1),
  5    70 	       3 thread_elements  bit (1),
  5    71 	       3 thread_control_intervals
  5    72 			      bit (1),
  5    73 	       3 must_be_zero1    bit (15),
  5    74 	     2 control_interval_storage_method
  5    75 			      fixed bin (17) unal,
  5    76 	     2 element_storage_method
  5    77 			      fixed bin (17),
  5    78 	     2 maximum_element_size
  5    79 			      fixed bin (35),
  5    80 	     2 header_record_element_id
  5    81 			      bit (36) aligned,
  5    82 	     2 storage_record_element_id
  5    83 			      bit (36) aligned;
  5    84 
  5    85      dcl	   collection_header_ptr  ptr;
  5    86      dcl	   COLLECTION_HEADER_VERSION_2
  5    87 			      init ("col_hdr2") char (8) aligned
  5    88 			      int static options (constant);
  5    89 
  5    90 /* END INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
      340 
      341 
  6     1 /* BEGIN INCLUDE FILE dm_cm_storage_record.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*        A storage record is an extension to the collection_header structure.
  6     6*   It is expected to be more volatile than collection_header and has a 
  6     7*   different format depending on the control interval storage method in use
  6     8*   for the collection.  A storage record is stored as an element in the 
  6     9*   file's Header Collection with the element identifier 
  6    10*   collection_header.storage_record_element_id.
  6    11*   
  6    12*        The unblocked_storage_record contains the control interval numbers
  6    13*   of the first and last control intervals of a collection.  Unblocked
  6    14*   control intervals are chained together, so all control intervals can be 
  6    15*   found by starting at one end and following the chain forward or backward.
  6    16*   
  6    17*        The blocked_storage_record is not yet used, as the Blocked Control
  6    18*   Interval Storage Method is not yet implemented.
  6    19**/
  6    20 
  6    21 /* HISTORY:
  6    22*Written by Matthew Pierret, 09/24/84.
  6    23*Modified:
  6    24**/
  6    25 
  6    26 /* format: style2,ind3,ll79 */
  6    27 
  6    28      dcl	   1 unblocked_storage_record
  6    29 			      aligned
  6    30 			      based (unblocked_storage_record_ptr),
  6    31 	     2 first_control_interval
  6    32 			      fixed bin (24) uns,
  6    33 	     2 last_control_interval
  6    34 			      fixed bin (24) uns;
  6    35 
  6    36      dcl	   1 blocked_storage_record
  6    37 			      aligned based (blocked_storage_record_ptr),
  6    38 	     2 last_control_interval
  6    39 			      fixed bin (24) uns,
  6    40 	     2 number_of_blocks   fixed bin (17) unal,
  6    41 	     2 number_of_control_intervals_per_block
  6    42 			      fixed bin (17) unal,
  6    43 	     2 allocation_map_element_id
  6    44 			      bit (36) aligned;
  6    45 
  6    46      dcl	   unblocked_storage_record_ptr
  6    47 			      ptr init (null ());
  6    48      dcl	   blocked_storage_record_ptr
  6    49 			      ptr init (null ());
  6    50 
  6    51 /* END INCLUDE FILE dm_cm_storage_record.incl.pl1 */
      342 
      343 
  7     1 /* BEGIN INCLUDE FILE dm_cism_info.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*     This include file contains the blocked_cism_info and unblocked_cism_info
  7     6*     structures, as well as constants relevant to control interval storage
  7     7*     management.  These structures and constants are used by several managers.
  7     8*     The structures each describe a method of control interval storage 
  7     9*     management.
  7    10**/
  7    11 
  7    12 /* HISTORY:
  7    13*
  7    14*Written 02/07/82 by Matthew Pierret.
  7    15*Modified:
  7    16*05/17/84 by Matthew Pierret:  Changed to align structure elements and add
  7    17*            a version string.
  7    18**/
  7    19 
  7    20 /* format: style2 */
  7    21 
  7    22      dcl	   1 blocked_cism_info    based (blocked_cism_info_ptr) aligned,
  7    23 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  7    24 	     2 type	      fixed bin (17) init (BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  7    25 	     2 number_of_control_intervals_per_block
  7    26 			      fixed bin (17);
  7    27 
  7    28      dcl	   1 unblocked_cism_info  based (unblocked_cism_info_ptr) aligned,
  7    29 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  7    30 	     2 type	      fixed bin (17) init (UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  7    31 	     2 must_be_zero	      fixed bin (17);
  7    32 
  7    33      dcl	   blocked_cism_info_ptr  ptr;
  7    34      dcl	   unblocked_cism_info_ptr
  7    35 			      ptr;
  7    36 
  7    37      dcl	   CISM_INFO_VERSION_1    init ("CISMinf1") char (8) aligned internal static options (constant);
  7    38      dcl	   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  7    39 			      fixed bin init (1) internal static options (constant);
  7    40      dcl	   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  7    41 			      fixed bin init (2) internal static options (constant);
  7    42 
  7    43 /* END INCLUDE FILE dm_cism_info.incl.pl1 ---------- */
      344 
      345 
  8     1 /* BEGIN INCLUDE FILE dm_esm_info.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*
  8     5*     This include file contains the basic_esm_info and ordered_esm_info
  8     6*     structures, as well as constants used to distinguish element storage
  8     7*     methods.  They are used by several managers to describe the type of
  8     8*     element storage management to be used in a collection.
  8     9**/
  8    10 
  8    11 /* HISTORY:
  8    12*Written 02/07/82 by Matthew Pierret.
  8    13*Modified:
  8    14*05/17/84 by Matthew Pierret:  Changed name from dm_cm_esm_info (the cm_
  8    15*            dropped because the include file is used by multiple managers),
  8    16*            to align structure elements and to add a version string.
  8    17**/
  8    18 
  8    19 /* format: style2 */
  8    20 
  8    21      dcl	   1 basic_esm_info	      based (basic_esm_info_ptr) aligned,
  8    22 	     2 version	      char (8) aligned init (ESM_INFO_VERSION_1),
  8    23 	     2 type	      fixed bin (17) init (BASIC_ELEMENT_STORAGE_METHOD),
  8    24 	     2 flags	      aligned,
  8    25 	       3 threaded	      bit (1) unal,
  8    26 	       3 fixed_length     bit (1) unal,
  8    27 	       3 pad	      bit (34) unal,
  8    28 	     2 maximum_element_length
  8    29 			      fixed bin (35);
  8    30 
  8    31      dcl	   1 ordered_esm_info     based (ordered_esm_info_ptr) aligned,
  8    32 	     2 version	      char (8) aligned init (ESM_INFO_VERSION_1),
  8    33 	     2 type	      fixed bin (17) init (ORDERED_ELEMENT_STORAGE_METHOD),
  8    34 	     2 flags	      aligned,
  8    35 	       3 fixed_length     bit (1) unal,
  8    36 	       3 pad	      bit (35) unal,
  8    37 	     2 maximum_element_length
  8    38 			      fixed bin (35);
  8    39 
  8    40      dcl	   basic_esm_info_ptr     ptr;
  8    41      dcl	   ordered_esm_info_ptr   ptr;
  8    42 
  8    43      dcl	   ESM_INFO_VERSION_1     init ("ESMinfo1") char (8) aligned internal static options (constant);
  8    44      dcl	   BASIC_ELEMENT_STORAGE_METHOD
  8    45 			      fixed bin init (1) internal static options (constant);
  8    46      dcl	   ORDERED_ELEMENT_STORAGE_METHOD
  8    47 			      fixed bin init (2) internal static options (constant);
  8    48 
  8    49 
  8    50 /* END INCLUDE FILE dm_esm_info.incl.pl1 */
      346 
      347 
  9     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*
  9     5*        Contains the declaration of an element identifier.  Element
  9     6*   identifiers consist of two parts, the id (number) of the control interval
  9     7*   in which the element resides, and the index into the slot table of
  9     8*   the element in the control interval.  The declaration of the element_id 
  9     9*   structure reflects this division of the element identifier.  The structure 
  9    10*   is based on the automatic bit string element_id_string because programs
  9    11*   generally pass bit strings (element_id_string) to each other, then 
  9    12*   interpret the bit string by overlaying the element_id structure ony if
  9    13*   it is necessary to access the parts of the id.  Basing element_id on
  9    14*   addr(element_id_string) instead of on a pointer removes the necessity
  9    15*   for always setting that pointer explicitly and guarantees that changes
  9    16*   made to the string or structure do not get inconsistent.
  9    17*
  9    18*   Changes made to element_id must also be made to datum_id, declared in 
  9    19*   dm_cm_datum.incl.pl1.
  9    20**/
  9    21 
  9    22 /* HISTORY:
  9    23*Written by Matthew Pierret, 04/01/82.
  9    24*Modified:
  9    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  9    26**/
  9    27 
  9    28 /* format: style2,ind3,ll79 */
  9    29 
  9    30      dcl	   element_id_string      bit (36) aligned;
  9    31 
  9    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  9    33 	     2 control_interval_id
  9    34 			      fixed bin (24) unal unsigned,
  9    35 	     2 index	      fixed bin (12) unal unsigned;
  9    36 
  9    37 
  9    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      348 
      349 
 10     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
 10     2 
 10     3 /* DESCRIPTION:
 10     4*
 10     5*   Contains entry declarations of internally available collection_manager_
 10     6*   entries.  Entries which are only available via the collection_manager_
 10     7*   transfer vector are not included here, but are declared instead in 
 10     8*   dm_collmgr_entry_dcls.incl.pl1.
 10     9**/
 10    10 
 10    11 /* HISTORY:
 10    12*Written by Mathew Pierret, 04/01/82.
 10    13*Modified:
 10    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
 10    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
 10    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
 10    17*            Added cm_get_element$info*, $header*.  The former is used when
 10    18*            the caller has a cm_info structure already; the latter is used to
 10    19*            get collection headers.
 10    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
 10    21*            Added cm_allocate_element$info.
 10    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
 10    23*            calling sequence for returning free space.
 10    24*            Added cm_free_cn_datum("" $header).
 10    25*01/07/83 by Matthew Pierret:  Added:
 10    26*            cm_allocate_element$buffered("" _info);
 10    27*            cm_put_element$buffered("" _info);
 10    28*            cm_put_datum_in_place$buffered("" _continued);
 10    29*            cm_put_datum_in_pool$buffered("" _continued);
 10    30*            cm_compact$buffered.
 10    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
 10    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
 10    33*            Added cm_opening_info$get_storage_record.
 10    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
 10    35*            id of the previous datum.
 10    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
 10    37*            which is for the number of slots after allocation.
 10    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
 10    39*            header header_return_slot).
 10    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
 10    41*            Added cm_get_element$bypass_info.
 10    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
 10    43*            cm_free_opening_info.
 10    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
 10    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
 10    46*            $does_replacement_fit to cm_determine_free_space.  These entries
 10    47*            return flags indicating if a datum fits in the ci and the pool.
 10    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
 10    49*            returned the new value of bci_header.free_slot_is_present.
 10    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
 10    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
 10    52*            entries.  Changed cm_get_element_$bypass_info to have the same
 10    53*            calling sequence as other cm_get_element entries.
 10    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
 10    55*            and cm_allocate_element to cm_put.
 10    56*            Switched the element_length/element_ptr parameter pair to be
 10    57*            element_ptr/element_length in cm_modify and cm_put.
 10    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
 10    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
 10    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
 10    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
 10    62*            Removed cm_find_free_space. Commented out un-used entries.
 10    63*            Re-named allocate  entries to put entries, except for allocate_ci.
 10    64*            Re-named free element and free datum entries to use delete instead
 10    65*            of free, and cm_recursive_put to cm_recursive_modify.
 10    66*            Removed cm_get_element$bypass_info.
 10    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
 10    68*            that cm_modify$buffered uses it.
 10    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
 10    70**/
 10    71 
 10    72 /* format: style2,ind3 */
 10    73 
 10    74 
 10    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
 10    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
 10    77      dcl	   cm_allocate_ci$info_header
 10    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
 10    79 
 10    80 
 10    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
 10    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
 10    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
 10    84      dcl	   cm_compact$buffered_replacement
 10    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
 10    86 
 10    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
 10    88 
 10    89      dcl	   cm_delete_cn_datum$header
 10    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
 10    91 
 10    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
 10    93 			      fixed bin (35));
 10    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
 10    95 
 10    96      dcl	   cm_determine_free_space$all
 10    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
 10    98      dcl	   cm_determine_free_space$effective
 10    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
 10   100 			      fixed bin (35));
 10   101      dcl	   cm_determine_free_space$does_new_datum_fit
 10   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
 10   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
 10   104 
 10   105 /**** Not yet used *********************************************************
 10   106*     dcl	   cm_determine_free_space$does_replacement_fit
 10   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
 10   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
 10   109*************************************************************************** */
 10   110 
 10   111      dcl	   cm_find_ci_to_alloc_datum
 10   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
 10   113 			      fixed bin (24) uns, fixed bin (35));
 10   114 
 10   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
 10   116 			      bit (1) aligned, fixed bin (35));
 10   117 
 10   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
 10   119      dcl	   cm_free_ci$raw_return_prev_next
 10   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
 10   121 			      fixed bin (24) uns, fixed bin (35));
 10   122      dcl	   cm_free_ci$trace_thread_modifications_on
 10   123 			      entry ();
 10   124      dcl	   cm_free_ci$trace_thread_modifications_off
 10   125 			      entry ();
 10   126 
 10   127 
 10   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
 10   129 
 10   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
 10   131      dcl	   cm_get_bci_header$exclusive
 10   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
 10   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 10   134 
 10   135 /**** Not yet used ********************************************************
 10   136*     dcl	   cm_get_bci_header$slot_exclusive
 10   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 10   138*************************************************************************** */
 10   139 
 10   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
 10   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
 10   142      dcl	   cm_get_element$exclusive
 10   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
 10   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
 10   145 
 10   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
 10   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
 10   148 			      fixed bin (35), fixed bin (35));
 10   149 
 10   150 /**** Not yet used ********************************************************
 10   151*     dcl	   cm_get_element_portion$exclusive
 10   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
 10   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
 10   154*			      fixed bin (35), fixed bin (35));
 10   155*************************************************************************** */
 10   156 
 10   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
 10   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
 10   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
 10   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 10   161 
 10   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 10   163 			      fixed bin (35), fixed bin (35));
 10   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 10   165 			      fixed bin (35), fixed bin (35));
 10   166 
 10   167 /******* Not yet used *****************************************************
 10   168*     dcl	   cm_modify$buffered_info
 10   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
 10   170*			      fixed bin (35));
 10   171*****************************************************************************/
 10   172 
 10   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
 10   174      dcl	   cm_modify$unprotected_info
 10   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
 10   176 
 10   177 
 10   178 /******* Not yet used *****************************************************
 10   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
 10   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
 10   181*****************************************************************************/
 10   182 
 10   183 
 10   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
 10   185      dcl	   cm_opening_info$get_storage_record
 10   186 			      entry (ptr, fixed bin (35));
 10   187      dcl	   cm_opening_info$full_get
 10   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
 10   189      dcl	   cm_opening_info$opening_table_ptr
 10   190 			      entry () returns (ptr);
 10   191 
 10   192      dcl	   cm_postcommit_increment
 10   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
 10   194 
 10   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 10   196 			      fixed bin (35), fixed bin (35));
 10   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 10   198 			      fixed bin (35), fixed bin (35));
 10   199 
 10   200 /******* Not yet used *****************************************************
 10   201*     dcl	   cm_put$buffered_info
 10   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
 10   203*			      fixed bin (35));
 10   204*****************************************************************************/
 10   205 
 10   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
 10   207 
 10   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
 10   209 			      fixed bin (35));
 10   210 
 10   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
 10   212 
 10   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
 10   214 			      fixed bin (35));
 10   215      dcl	   cm_put_datum_in_place$buffered
 10   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
 10   217      dcl	   cm_put_datum_in_place$buffered_continued
 10   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
 10   219 			      fixed bin (35));
 10   220      dcl	   cm_put_datum_in_place$continued
 10   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
 10   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
 10   223 
 10   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
 10   225 			      fixed bin (35));
 10   226      dcl	   cm_put_datum_in_pool$buffered
 10   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
 10   228      dcl	   cm_put_datum_in_pool$buffered_continued
 10   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
 10   230 			      fixed bin (35));
 10   231      dcl	   cm_put_datum_in_pool$continued
 10   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
 10   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
 10   234 
 10   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
 10   236 			      fixed bin (35));
 10   237      dcl	   cm_put_ordered_element$buffered
 10   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
 10   239 			      fixed bin (35));
 10   240 
 10   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
 10   242 
 10   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
 10   244 			      fixed bin (35));
 10   245 
 10   246 
 10   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
 10   248 			      entry ();
 10   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
 10   250 			      entry ();
 10   251 
 10   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      350 
      351 
 11     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 11     2 /* format: style3 */
 11     3 
 11     4 /* These constants are to be used for the flags argument of sub_err_ */
 11     5 /* They are just "string (condition_info_header.action_flags)" */
 11     6 
 11     7 declare	(
 11     8 	ACTION_CAN_RESTART	init (""b),
 11     9 	ACTION_CANT_RESTART init ("1"b),
 11    10 	ACTION_DEFAULT_RESTART
 11    11 			init ("01"b),
 11    12 	ACTION_QUIET_RESTART
 11    13 			init ("001"b),
 11    14 	ACTION_SUPPORT_SIGNAL
 11    15 			init ("0001"b)
 11    16 	)		bit (36) aligned internal static options (constant);
 11    17 
 11    18 /* End include file */
      352 
      353 
      354    end cm_create_collection;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0912.4  cm_create_collection.pl1          >spec>on>7192.pbf-04/04/85>cm_create_collection.pl1
332          1    01/07/85  0858.8  dm_hdr_collection_id.incl.pl1     >ldd>include>dm_hdr_collection_id.incl.pl1
334          2    01/07/85  0858.4  dm_cm_hdr_col_ids.incl.pl1        >ldd>include>dm_cm_hdr_col_ids.incl.pl1
336          3    01/07/85  0858.4  dm_cm_info.incl.pl1               >ldd>include>dm_cm_info.incl.pl1
338          4    01/07/85  0858.3  dm_cm_file_header.incl.pl1        >ldd>include>dm_cm_file_header.incl.pl1
340          5    01/07/85  0858.2  dm_cm_collection_header.incl.pl1  >ldd>include>dm_cm_collection_header.incl.pl1
342          6    01/07/85  0858.4  dm_cm_storage_record.incl.pl1     >ldd>include>dm_cm_storage_record.incl.pl1
344          7    01/07/85  0858.0  dm_cism_info.incl.pl1             >ldd>include>dm_cism_info.incl.pl1
346          8    01/07/85  0858.5  dm_esm_info.incl.pl1              >ldd>include>dm_esm_info.incl.pl1
348          9    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
350         10    04/04/85  0819.0  dm_cm_entry_dcls.incl.pl1         >spec>on>7192.pbf-04/04/85>dm_cm_entry_dcls.incl.pl1
352         11    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000013 constant        bit(36)                  initial dcl 11-7 set ref 226* 252* 271* 324*
BASIC_ELEMENT_STORAGE_METHOD           constant        fixed bin(17,0)          initial dcl 8-44 ref 203
BITS_PER_BYTE                   000140 automatic       fixed bin(17,0)          initial dcl 102 set ref 102*
BITS_PER_WORD                   000141 automatic       fixed bin(17,0)          initial dcl 103 set ref 103* 157 187
BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                       constant        fixed bin(17,0)          initial dcl 7-38 ref 248
CISM_INFO_VERSION_1             000002 constant        char(8)                  initial dcl 7-37 set ref 129*
CM_FILE_HEADER_ELEMENT_ID       000024 constant        bit(36)                  initial dcl 2-21 set ref 142* 292*
CM_FILE_HEADER_VERSION_1        000006 constant        char(8)                  initial dcl 4-70 set ref 148*
COLLECTION_HEADER_VERSION_2     000004 constant        char(8)                  initial dcl 5-86 ref 199
ESM_INFO_VERSION_1              000000 constant        char(8)                  initial dcl 8-43 set ref 131*
FULL_LENGTH_OF_ELEMENT          000137 automatic       fixed bin(35,0)          initial dcl 101 set ref 101* 292*
HEADER_COLLECTION_ID            000026 constant        bit(36)                  initial dcl 1-19 set ref 124* 167*
NO_HEADER_RECORD                000142 automatic       bit(36)                  initial dcl 104 set ref 104*
ORDERED_ELEMENT_STORAGE_METHOD         constant        fixed bin(17,0)          initial dcl 8-46 ref 214
UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                       constant        fixed bin(17,0)          initial dcl 7-40 ref 230
addr                                                   builtin function         dcl 95 ref 142 142 167 167 171 198 234 257
automatic_cit_buffer            000100 automatic       fixed bin(71,0)          array dcl 162 set ref 164* 167 167 171
automatic_cm_file_header        000107 automatic       structure                level 1 dcl 80 set ref 135* 142 142 142 142
automatic_collection_header     000100 automatic       structure                level 1 dcl 78 set ref 136* 198
automatic_storage_record_buffer 000116 automatic       fixed bin(71,0)          initial array dcl 82 set ref 82* 82* 82* 82* 82* 82*
                                                                                  234 257
basic_esm_info                         based           structure                level 1 dcl 8-21
basic_esm_info_ptr              000172 automatic       pointer                  dcl 8-40 set ref 130* 131 201 203 207 208 210 214
                                                                                  226
blocked_cism_info                      based           structure                level 1 dcl 7-22
blocked_cism_info_ptr           000166 automatic       pointer                  dcl 7-33 set ref 256* 261
blocked_storage_record                 based           structure                level 1 dcl 6-36 set ref 264 264
blocked_storage_record_ptr      000164 automatic       pointer                  initial dcl 6-48 set ref 6-48* 257* 259 260 261 264
                                                                                  264
cit_number_of_collections       000156 automatic       fixed bin(17,0)          dcl 4-81 set ref 165* 188* 189
cm_file_header                         based           structure                level 1 dcl 4-55
cm_file_header_ptr              000152 automatic       pointer                  dcl 4-69 set ref 142* 148 156 157 165 167 167 180
                                                                                  184 188 189 285 292*
cm_get_element                  000020 constant        entry                    external dcl 10-140 ref 142 167
cm_info                                based           structure                level 1 dcl 3-37
cm_info_ptr                     000150 automatic       pointer                  initial dcl 3-47 set ref 124* 142 142 3-47* 167 241*
                                                                                  264* 276* 285* 292*
cm_modify$info                  000022 constant        entry                    external dcl 10-173 ref 285 292
cm_opening_info$get             000024 constant        entry                    external dcl 10-184 ref 124
cm_put$info                     000026 constant        entry                    external dcl 10-206 ref 241 264 276
code                            000132 automatic       fixed bin(35,0)          dcl 84 set ref 122* 124* 125 125* 142* 145 145* 167*
                                                                                  172 172* 241* 243 243* 264* 266 266* 276* 278 278*
                                                                                  285* 287 287* 292* 294 294* 301
collection_entry_idx            000134 automatic       fixed bin(17,0)          dcl 86 set ref 180* 180* 184 283
collection_header                      based           structure                level 1 dcl 5-65 set ref 276 276
collection_header_ptr           000160 automatic       pointer                  dcl 5-85 set ref 198* 199 200 201 207 208 209 210
                                                                                  219 220 221 222 239 241 264 276* 276 276
collection_id             4            based           bit(36)                  initial level 2 in structure "cm_info" dcl 3-37
                                                                                  in procedure "cm_create_collection" set ref 142*
collection_id                   000133 automatic       bit(36)                  dcl 85 in procedure "cm_create_collection" set ref
                                                                                  133* 276* 283 300
collection_id_table                    based           bit(36)                  array dcl 4-75 set ref 180 283*
collection_id_table_element_id
                          6            based           bit(36)                  level 2 dcl 4-55 set ref 167* 285*
collection_id_table_length_in_bits
                                000136 automatic       fixed bin(35,0)          dcl 89 set ref 157* 167* 187* 187 285*
collection_id_table_length_in_dwords
                                000135 automatic       fixed bin(17,0)          dcl 87 set ref 156* 162
collection_id_table_ptr         000154 automatic       pointer                  dcl 4-79 set ref 167* 171* 180 283 285*
control_interval_storage_method
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-65 set ref 200*
cv_p_correct_version                   parameter       char(8)                  dcl 322 set ref 317 324 324*
cv_p_given_version                     parameter       char(8)                  dcl 321 set ref 317 324 324*
cv_p_structure_name                    parameter       char                     unaligned dcl 320 set ref 317 324*
divide                                                 builtin function         dcl 95 ref 156
dm_error_$unimplemented_cism    000012 external static fixed bin(35,0)          dcl 113 set ref 252* 271*
dm_error_$unimplemented_esm     000014 external static fixed bin(35,0)          dcl 115 set ref 226*
element_storage_method
                          3            based           fixed bin(17,0)          level 2 dcl 5-65 set ref 201*
er_p_code                              parameter       fixed bin(35,0)          dcl 309 ref 306 311
error_table_$unimplemented_version
                                000016 external static fixed bin(35,0)          dcl 117 set ref 324*
file_oid                  3            based           bit(36)                  initial level 2 dcl 3-37 set ref 142* 167*
first_control_interval                 based           fixed bin(24,0)          level 2 unsigned dcl 6-28 set ref 236*
fixed_length              3(01)        based           bit(1)                   level 3 in structure "basic_esm_info" packed
                                                                                  unaligned dcl 8-21 in procedure
                                                                                  "cm_create_collection" ref 207
fixed_length              3            based           bit(1)                   level 3 in structure "ordered_esm_info" packed
                                                                                  unaligned dcl 8-31 in procedure
                                                                                  "cm_create_collection" ref 219
fixed_size_elements       2            based           bit(1)                   level 3 packed unaligned dcl 5-65 set ref 207* 219*
flags                     2            based           structure                level 2 in structure "collection_header" packed
                                                                                  unaligned dcl 5-65 in procedure
                                                                                  "cm_create_collection"
flags                     3            based           structure                level 2 in structure "basic_esm_info" dcl 8-21
                                                                                  in procedure "cm_create_collection"
flags                     3            based           structure                level 2 in structure "ordered_esm_info" dcl 8-31
                                                                                  in procedure "cm_create_collection"
last_control_interval                  based           fixed bin(24,0)          level 2 in structure "blocked_storage_record"
                                                                                  unsigned dcl 6-36 in procedure
                                                                                  "cm_create_collection" set ref 259*
last_control_interval
                          1            based           fixed bin(24,0)          level 2 in structure "unblocked_storage_record"
                                                                                  unsigned dcl 6-28 in procedure
                                                                                  "cm_create_collection" set ref 237*
length                                                 builtin function         dcl 95 ref 142 142 241 241 264 264 276 276
maximum_element_length
                          4            based           fixed bin(35,0)          level 2 in structure "basic_esm_info" dcl 8-21
                                                                                  in procedure "cm_create_collection" ref 210
maximum_element_length
                          4            based           fixed bin(35,0)          level 2 in structure "ordered_esm_info" dcl 8-31
                                                                                  in procedure "cm_create_collection" ref 222
maximum_element_size      4            based           fixed bin(35,0)          level 2 dcl 5-65 set ref 210* 222*
must_be_zero1             2(03)        based           bit(15)                  level 3 packed unaligned dcl 5-65 set ref 209* 221*
myname                          000143 automatic       char(20)                 initial unaligned dcl 105 set ref 105* 226* 252*
                                                                                  271* 324*
null                                                   builtin function         dcl 95 ref 142 142 3-47 6-46 6-48 167 167 226 226
                                                                                  252 252 271 271 324 324
number_of_blocks          1            based           fixed bin(17,0)          level 2 packed unaligned dcl 6-36 set ref 260*
number_of_collections
                          3            based           fixed bin(17,0)          level 2 packed unaligned dcl 4-55 set ref 156 157
                                                                                  165 167 180 184 188 189*
number_of_control_intervals_per_block
                          1(18)        based           fixed bin(17,0)          level 2 in structure "blocked_storage_record" packed
                                                                                  unaligned dcl 6-36 in procedure
                                                                                  "cm_create_collection" set ref 261*
number_of_control_intervals_per_block
                          3            based           fixed bin(17,0)          level 2 in structure "blocked_cism_info" dcl 7-22
                                                                                  in procedure "cm_create_collection" ref 261
ordered_esm_info                       based           structure                level 1 dcl 8-31
ordered_esm_info_ptr            000174 automatic       pointer                  dcl 8-41 set ref 218* 219 222
p_cism_info_ptr                        parameter       pointer                  dcl 71 ref 63 128 256
p_code                                 parameter       fixed bin(35,0)          dcl 74 set ref 63 122* 301* 311*
p_collection_id                        parameter       bit(36)                  dcl 73 set ref 63 300*
p_esm_info_ptr                         parameter       pointer                  dcl 72 ref 63 130 218
p_file_opening_id                      parameter       bit(36)                  dcl 70 set ref 63 124*
storage_record_element_id
                          6            based           bit(36)                  level 2 dcl 5-65 set ref 241* 264*
sub_err_                        000010 constant        entry                    external dcl 109 ref 226 252 271 324
thread_control_intervals
                          2(02)        based           bit(1)                   level 3 packed unaligned dcl 5-65 set ref 239*
thread_elements           2(01)        based           bit(1)                   level 3 packed unaligned dcl 5-65 set ref 208* 220*
threaded                  3            based           bit(1)                   level 3 packed unaligned dcl 8-21 ref 208
type                      2            based           fixed bin(17,0)          initial level 2 in structure "basic_esm_info"
                                                                                  dcl 8-21 in procedure "cm_create_collection" set
                                                                                  ref 201 203 214 226*
type                      2            based           fixed bin(17,0)          initial level 2 in structure "unblocked_cism_info"
                                                                                  dcl 7-28 in procedure "cm_create_collection" set
                                                                                  ref 200 230 248 252* 271*
unblocked_cism_info                    based           structure                level 1 dcl 7-28
unblocked_cism_info_ptr         000170 automatic       pointer                  dcl 7-34 set ref 128* 129 200 230 248 252 271
unblocked_storage_record               based           structure                level 1 dcl 6-28 set ref 241 241
unblocked_storage_record_ptr    000162 automatic       pointer                  initial dcl 6-46 set ref 6-46* 234* 236 237 241* 241
                                                                                  241 264*
unspec                                                 builtin function         dcl 95 set ref 135* 136* 142 142 241 241 264 264 276
                                                                                  276
version                                based           char(8)                  initial level 2 in structure "basic_esm_info"
                                                                                  dcl 8-21 in procedure "cm_create_collection" set
                                                                                  ref 131*
version                                based           char(8)                  level 2 in structure "cm_file_header" dcl 4-55
                                                                                  in procedure "cm_create_collection" set ref 148*
version                                based           char(8)                  initial level 2 in structure "unblocked_cism_info"
                                                                                  dcl 7-28 in procedure "cm_create_collection" set
                                                                                  ref 129*
version                                based           char(8)                  level 2 in structure "collection_header" dcl 5-65
                                                                                  in procedure "cm_create_collection" set ref 199*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 11-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 11-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 11-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 11-7
CALLER_HEADER_ELEMENT_ID               internal static bit(36)                  initial dcl 2-21
CM_INFO_VERSION_2                      internal static char(8)                  initial dcl 3-48
HEADER_COLLECTION_HEADER_ELEMENT_ID    internal static bit(36)                  initial dcl 2-21
cm_allocate_ci                  000000 constant        entry                    external dcl 10-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 10-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 10-77
cm_compact                      000000 constant        entry                    external dcl 10-81
cm_compact$buffered             000000 constant        entry                    external dcl 10-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 10-84
cm_compact$replacement          000000 constant        entry                    external dcl 10-83
cm_delete                       000000 constant        entry                    external dcl 10-92
cm_delete$info                  000000 constant        entry                    external dcl 10-94
cm_delete_cn_datum              000000 constant        entry                    external dcl 10-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 10-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 10-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 10-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 10-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 10-111
cm_find_free_slot               000000 constant        entry                    external dcl 10-115
cm_free_ci$info                 000000 constant        entry                    external dcl 10-118
cm_free_ci$raw_return_prev_next 000000 constant        entry                    external dcl 10-119
cm_free_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 10-124
cm_free_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 10-122
cm_free_opening_info            000000 constant        entry                    external dcl 10-128
cm_get_bci_header               000000 constant        entry                    external dcl 10-130
cm_get_bci_header$exclusive     000000 constant        entry                    external dcl 10-131
cm_get_bci_header$slot          000000 constant        entry                    external dcl 10-133
cm_get_element$exclusive        000000 constant        entry                    external dcl 10-142
cm_get_element_portion          000000 constant        entry                    external dcl 10-146
cm_get_id$id                    000000 constant        entry                    external dcl 10-157
cm_get_id$ptr                   000000 constant        entry                    external dcl 10-159
cm_modify                       000000 constant        entry                    external dcl 10-162
cm_modify$buffered              000000 constant        entry                    external dcl 10-164
cm_modify$unprotected_info      000000 constant        entry                    external dcl 10-174
cm_opening_info$full_get        000000 constant        entry                    external dcl 10-187
cm_opening_info$get_storage_record
                                000000 constant        entry                    external dcl 10-185
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 10-189
cm_postcommit_increment         000000 constant        entry                    external dcl 10-192
cm_put                          000000 constant        entry                    external dcl 10-195
cm_put$buffered                 000000 constant        entry                    external dcl 10-197
cm_put_basic_element            000000 constant        entry                    external dcl 10-208
cm_put_cn_datum                 000000 constant        entry                    external dcl 10-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 10-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 10-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 10-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 10-220
cm_put_datum_in_pool            000000 constant        entry                    external dcl 10-224
cm_put_datum_in_pool$buffered   000000 constant        entry                    external dcl 10-226
cm_put_datum_in_pool$buffered_continued
                                000000 constant        entry                    external dcl 10-228
cm_put_datum_in_pool$continued  000000 constant        entry                    external dcl 10-231
cm_put_ordered_element          000000 constant        entry                    external dcl 10-235
cm_put_ordered_element$buffered 000000 constant        entry                    external dcl 10-237
cm_put_overlength_tail          000000 constant        entry                    external dcl 10-241
cm_recursive_modify             000000 constant        entry                    external dcl 10-243
cm_replace_buffered_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 10-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 10-247
element_id                             based           structure                level 1 dcl 9-32
element_id_string                      automatic       bit(36)                  dcl 9-30

NAMES DECLARED BY EXPLICIT CONTEXT.
BASIC_ESM                       000652 constant        label                    dcl 203
BEGIN_BLOCK                     000456 constant        label                    dcl 159
BLOCKED                         001037 constant        label                    dcl 248
CHECK_VERSION                   001414 constant        entry                    internal dcl 317 ref 129 131 148
ERROR_RETURN                    001377 constant        entry                    internal dcl 306 ref 125 145 172 243 266 278 287 294
MAIN_RETURN                     001375 constant        label                    dcl 303 ref 312
ORDERED_ESM                     000673 constant        label                    dcl 214
UNBLOCKED                       000767 constant        label                    dcl 230
cm_create_collection            000135 constant        entry                    external dcl 63

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1662        1712    1522        1672
Length      2336    1522        30         410     140           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_create_collection                250 external procedure  is an external procedure.  
begin block on line 159             148 begin block         uses auto adjustable storage.  
ERROR_RETURN                         64 internal procedure  is called by several nonquick procedures.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure cm_create_collection.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 159  000100 automatic_cit_buffer        begin block on line 159
cm_create_collection     000100 automatic_collection_header cm_create_collection
                         000107 automatic_cm_file_header    cm_create_collection
                         000116 automatic_storage_record_buffer
                                                            cm_create_collection
                         000132 code                        cm_create_collection
                         000133 collection_id               cm_create_collection
                         000134 collection_entry_idx        cm_create_collection
                         000135 collection_id_table_length_in_dwords
                                                            cm_create_collection
                         000136 collection_id_table_length_in_bits
                                                            cm_create_collection
                         000137 FULL_LENGTH_OF_ELEMENT      cm_create_collection
                         000140 BITS_PER_BYTE               cm_create_collection
                         000141 BITS_PER_WORD               cm_create_collection
                         000142 NO_HEADER_RECORD            cm_create_collection
                         000143 myname                      cm_create_collection
                         000150 cm_info_ptr                 cm_create_collection
                         000152 cm_file_header_ptr          cm_create_collection
                         000154 collection_id_table_ptr     cm_create_collection
                         000156 cit_number_of_collections   cm_create_collection
                         000160 collection_header_ptr       cm_create_collection
                         000162 unblocked_storage_record_ptr
                                                            cm_create_collection
                         000164 blocked_storage_record_ptr  cm_create_collection
                         000166 blocked_cism_info_ptr       cm_create_collection
                         000170 unblocked_cism_info_ptr     cm_create_collection
                         000172 basic_esm_info_ptr          cm_create_collection
                         000174 ordered_esm_info_ptr        cm_create_collection

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
enter_begin         leave_begin         call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              tra_ext             alloc_auto_adj      ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_get_element                cm_modify$info                cm_opening_info$get           cm_put$info
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$unimplemented_cism  dm_error_$unimplemented_esm   error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     63 000130        82 000142       101 000207       102 000211       103 000213       104 000215       105 000216
 3   47 000221    6   46 000223    6   48 000224       122 000225       124 000230       125 000244       128 000254
    129 000260       130 000303       131 000307       133 000332       135 000333       136 000336       142 000341
    145 000407       148 000417       156 000444       157 000453       159 000456       162 000461       164 000470
    165 000504       167 000511       171 000560       172 000562       180 000574       182 000613       184 000615
    187 000622       188 000627       189 000632       198 000634       199 000636       200 000641       201 000644
    203 000647       207 000652       208 000657       209 000664       210 000666       212 000670       214 000671
    218 000673       219 000677       220 000704       221 000706       222 000710       224 000712       226 000713
    230 000762       234 000767       236 000771       237 000772       239 000773       241 000776       243 001022
    246 001034       248 001035       252 001037       256 001106       257 001113       259 001115       260 001116
    261 001120       264 001122       266 001147       269 001161       271 001162       276 001231       278 001256
    283 001270       285 001275       287 001320       292 001332       294 001355       298 001367       300 001370
    301 001373       303 001375       306 001376       311 001404       312 001411       317 001414       324 001425
    328 001516       330 001517


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
