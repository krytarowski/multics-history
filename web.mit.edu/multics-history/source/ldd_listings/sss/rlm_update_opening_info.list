	COMPILATION LISTING OF SEGMENT rlm_update_opening_info
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  1000.3 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*Update per relation opening info: $(increment decrement)_openings - Number of
       11*openings for this relation, $lock_advice - Set lock advice, $relation_header -
       12*Update relation header in opening info and relation header, $attribute_info -
       13*Update attribute info as for relation_header.
       14*
       15**/
       16 
       17 /* HISTORY:
       18*Written by Matthew Pierret, 02/28/83.
       19*Modified:
       20*05/16/83 by Lindsey L. Spratt:  Changed to set the parameter
       21*            p_relation_opening_info_ptr to null if the call to
       22*            rlm_opening_info$free is successful.
       23*06/22/83 by Lindsey L. Spratt:  Fixed index_attribute_map entry to set the
       24*            relation_opening_info.per_process.index_cursor_array_ptr when the
       25*            index_cursor_array is expanded.
       26*05/29/84 by Matthew Pierret:  Changed to use RELATION_HEADER_VERSION_3.
       27*06/12/84 by Matthew Pierret:  Re-named cm_$put_element to cm_$modify,
       28*            cm_$allocate_element to cm_$put.
       29*10/25/84 by Stanford S. Cox:  $index_attribute_map - Added asgn. of
       30*   index_cursor_array.version.
       31**/
       32 
       33 /* format: style2,ind3 */
       34 
       35 rlm_update_opening_info:
       36    proc ();
       37 
       38       call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
       39 	 "^/^a$^a is not a valid entrypoint", myname, myname);
       40 
       41 
       42 
       43 /* START OF DECLARATIONS */
       44 /* Parameter */
       45 
       46       dcl	    p_relation_opening_info_ptr
       47 			       ptr parameter;
       48       dcl	    p_relation_header_ptr  ptr parameter;
       49       dcl	    p_attribute_info_ptr   ptr parameter;
       50       dcl	    p_index_attribute_map_ptr
       51 			       ptr parameter;
       52       dcl	    (p_this_process_permission, p_other_processes_permission)
       53 			       bit (2) aligned;
       54       dcl	    p_code	       fixed bin (35) parameter;
       55 
       56 /* Automatic */
       57 
       58       dcl	    (current_number_of_openings, index_idx, increment)
       59 			       fixed bin (17);
       60       dcl	    1 current_lock_advice  aligned like relation_opening_info.per_process.lock_advice;
       61       dcl	    (old_relation_header_ptr, old_attribute_info_ptr, old_index_attribute_map_ptr, old_index_cursor_array_ptr)
       62 			       ptr init (null);
       63 
       64 /* Based */
       65 
       66       dcl	    dm_area	       area (sys_info$max_seg_size) based (static_dm_area_ptr);
       67 
       68 /* Builtin */
       69 
       70       dcl	    (currentsize, length, null, unspec)
       71 			       builtin;
       72 
       73 /* Condition */
       74 
       75       dcl	    cleanup	       condition;
       76 
       77 /* Constant */
       78 
       79       dcl	    (
       80 	    myname	       init ("rlm_update_opening_info") char (32) varying,
       81 	    BITS_PER_WORD	       init (36) fixed bin (17)
       82 	    )		       internal static options (constant);
       83 
       84 /* Entry */
       85 
       86       dcl	    rlm_opening_info$free  entry (ptr, fixed bin (35));
       87       dcl	    get_dm_free_area_      entry () returns (ptr);
       88       dcl	    sub_err_	       entry () options (variable);
       89 
       90 /* External */
       91 
       92       dcl	    dm_error_$programming_error
       93 			       fixed bin (35) ext;
       94       dcl	    error_table_$unimplemented_version
       95 			       fixed bin (35) ext;
       96       dcl	    sys_info$max_seg_size  fixed bin (35) ext;
       97 
       98 /* Static */
       99 
      100       dcl	    static_dm_area_ptr     ptr internal static init (null);
      101 
      102 /* END OF DECLARATIONS */
      103 
      104 /* format: ^indblkcom,indcomtxt */
      105 
      106 increment_openings:
      107    entry (p_relation_opening_info_ptr, p_code);
      108 
      109       increment = 1;
      110       goto OPENINGS_JOIN;
      111 
      112 decrement_openings:
      113    entry (p_relation_opening_info_ptr, p_code);
      114 
      115       increment = -1;
      116 
      117 OPENINGS_JOIN:
      118       relation_opening_info_ptr = p_relation_opening_info_ptr;
      119 
      120       call CHECK_VERSION ("relation_opening_info", relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2);
      121 
      122       p_code = 0;
      123       current_number_of_openings = relation_opening_info.per_process.number_of_openings;
      124       on cleanup relation_opening_info.per_process.number_of_openings = current_number_of_openings;
      125 
      126       relation_opening_info.per_process.number_of_openings =
      127 	 relation_opening_info.per_process.number_of_openings + increment;
      128 
      129       if increment = -1 & relation_opening_info.per_process.number_of_openings <= 0
      130       then
      131          do;
      132 	  call rlm_opening_info$free (relation_opening_info_ptr, p_code);
      133 	  if p_code ^= 0
      134 	  then return;
      135 	  p_relation_opening_info_ptr = null;
      136          end;
      137 
      138       return;
      139 
      140 lock_advice:
      141    entry (p_relation_opening_info_ptr, p_this_process_permission, p_other_processes_permission, p_code);
      142 
      143       relation_opening_info_ptr = p_relation_opening_info_ptr;
      144 
      145       call CHECK_VERSION ("relation_opening_info", relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2);
      146 
      147       p_code = 0;
      148       current_lock_advice = relation_opening_info.per_process.lock_advice;
      149       on cleanup relation_opening_info.per_process.lock_advice = current_lock_advice;
      150 
      151       relation_opening_info.per_process.lock_advice.this_process = p_this_process_permission;
      152       relation_opening_info.per_process.lock_advice.other_processes = p_other_processes_permission;
      153 
      154       return;
      155 
      156 relation_header:
      157    entry (p_relation_opening_info_ptr, p_relation_header_ptr, p_code);
      158 
      159       relation_opening_info_ptr = p_relation_opening_info_ptr;
      160       call CHECK_VERSION ("relation_opening_info", relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2);
      161 
      162       relation_header_ptr = p_relation_header_ptr;
      163       call CHECK_VERSION ("relation_header", relation_header.version, RELATION_HEADER_VERSION_3);
      164 
      165       relation_header.header_info_update_count = relation_header.header_info_update_count + 1;
      166 
      167       call collection_manager_$modify (relation_opening_info.per_process.file_opening_id, HEADER_COLLECTION_ID,
      168 	 relation_header_ptr, length (unspec (relation_header)), CALLER_HEADER_ELEMENT_ID, (0), p_code);
      169       if p_code ^= 0
      170       then return;
      171 
      172       if relation_opening_info.relation_header_ptr ^= relation_header_ptr
      173       then
      174          do;
      175 	  old_relation_header_ptr = relation_opening_info.relation_header_ptr;
      176 	  relation_opening_info.relation_header_ptr = relation_header_ptr;
      177 	  if old_relation_header_ptr ^= null
      178 	  then
      179 	     do;
      180 	        if static_dm_area_ptr = null
      181 	        then static_dm_area_ptr = get_dm_free_area_ ();
      182 	        free old_relation_header_ptr -> relation_header in (dm_area);
      183 	     end;
      184          end;
      185 
      186       return;
      187 
      188 attribute_info:
      189    entry (p_relation_opening_info_ptr, p_attribute_info_ptr, p_code);
      190 
      191       relation_opening_info_ptr = p_relation_opening_info_ptr;
      192       call CHECK_VERSION ("relation_opening_info", relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2);
      193 
      194       relation_header_ptr = relation_opening_info.relation_header_ptr;
      195       call CHECK_VERSION ("relation_header", relation_header.version, RELATION_HEADER_VERSION_3);
      196 
      197       attribute_info_ptr = p_attribute_info_ptr;
      198       call CHECK_VERSION ("attribute_info", attribute_info.version, ATTRIBUTE_INFO_VERSION_1);
      199 
      200       if relation_header.attribute_info_element_id = "0"b
      201       then call collection_manager_$put (relation_opening_info.per_process.file_opening_id, HEADER_COLLECTION_ID,
      202 	      attribute_info_ptr, currentsize (attribute_info) * BITS_PER_WORD,
      203 	      relation_header.attribute_info_element_id, (0), p_code);
      204       else call collection_manager_$modify (relation_opening_info.per_process.file_opening_id, HEADER_COLLECTION_ID,
      205 	      attribute_info_ptr, currentsize (attribute_info) * BITS_PER_WORD,
      206 	      relation_header.attribute_info_element_id, (0), p_code);
      207 
      208       if p_code ^= 0
      209       then return;
      210 
      211       relation_header.header_info_update_count = relation_header.header_info_update_count + 1;
      212 
      213       call collection_manager_$modify (relation_opening_info.per_process.file_opening_id, HEADER_COLLECTION_ID,
      214 	 relation_header_ptr, currentsize (relation_header) * BITS_PER_WORD, CALLER_HEADER_ELEMENT_ID, (0), p_code);
      215       if p_code ^= 0
      216       then return;
      217 
      218       if relation_opening_info.attribute_info_ptr ^= attribute_info_ptr
      219       then
      220          do;
      221 	  old_attribute_info_ptr = relation_opening_info.attribute_info_ptr;
      222 	  relation_opening_info.attribute_info_ptr = attribute_info_ptr;
      223 	  if old_attribute_info_ptr ^= null
      224 	  then
      225 	     do;
      226 	        if static_dm_area_ptr = null
      227 	        then static_dm_area_ptr = get_dm_free_area_ ();
      228 	        free old_attribute_info_ptr -> attribute_info in (dm_area);
      229 	     end;
      230          end;
      231 
      232       return;
      233 
      234 index_attribute_map:
      235    entry (p_relation_opening_info_ptr, p_index_attribute_map_ptr, p_code);
      236 
      237       relation_opening_info_ptr = p_relation_opening_info_ptr;
      238       call CHECK_VERSION ("relation_opening_info", relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2);
      239 
      240       relation_header_ptr = relation_opening_info.relation_header_ptr;
      241       call CHECK_VERSION ("relation_header", relation_header.version, RELATION_HEADER_VERSION_3);
      242 
      243       index_attribute_map_ptr = p_index_attribute_map_ptr;
      244       call CHECK_VERSION ("index_attribute_map", index_attribute_map.version, INDEX_ATTRIBUTE_MAP_VERSION_2);
      245 
      246       if relation_header.index_attribute_map_element_id = "0"b
      247       then call collection_manager_$put (relation_opening_info.per_process.file_opening_id, HEADER_COLLECTION_ID,
      248 	      index_attribute_map_ptr, currentsize (index_attribute_map) * BITS_PER_WORD,
      249 	      relation_header.index_attribute_map_element_id, (0), p_code);
      250       else call collection_manager_$modify (relation_opening_info.per_process.file_opening_id, HEADER_COLLECTION_ID,
      251 	      index_attribute_map_ptr, currentsize (index_attribute_map) * BITS_PER_WORD,
      252 	      relation_header.index_attribute_map_element_id, (0), p_code);
      253 
      254       if p_code ^= 0
      255       then return;
      256 
      257       relation_header.header_info_update_count = relation_header.header_info_update_count + 1;
      258 
      259       call collection_manager_$modify (relation_opening_info.per_process.file_opening_id, HEADER_COLLECTION_ID,
      260 	 relation_header_ptr, currentsize (relation_header) * BITS_PER_WORD, CALLER_HEADER_ELEMENT_ID, (0), p_code);
      261       if p_code ^= 0
      262       then return;
      263 
      264       if static_dm_area_ptr = null
      265       then static_dm_area_ptr = get_dm_free_area_ ();
      266 
      267       if relation_opening_info.per_process.index_cursor_array_ptr = null
      268       then
      269          do;
      270 
      271          /*** No index_cursor_array exists, so set one up with a null cursor_ptr for each index. */
      272 
      273 	  ica_number_of_indices = hbound (index_attribute_map.index, 1);
      274 	  alloc index_cursor_array in (dm_area);
      275 	  index_cursor_array.version = INDEX_CURSOR_ARRAY_VERSION_1;
      276 	  index_cursor_array.cursor_ptr (*) = null;
      277 	  relation_opening_info.per_process.index_cursor_array_ptr = index_cursor_array_ptr;
      278          end;
      279       else
      280          do;
      281 	  index_cursor_array_ptr = relation_opening_info.per_process.index_cursor_array_ptr;
      282 	  call CHECK_VERSION ("index_cursor_array", index_cursor_array.version, INDEX_CURSOR_ARRAY_VERSION_1);
      283          end;
      284 
      285       if hbound (index_cursor_array.cursor_ptr, 1) >= hbound (index_attribute_map.index, 1)
      286       then
      287 REMOVE_CURSORS_FOR_DELETED_INDICES:
      288          do;
      289 
      290          /*** Indices for which cursors are stored in index_cursor_array may have been
      291*	    deleted. Destroy the cursors for any such index. */
      292 
      293 	  do index_idx = 1 to hbound (index_attribute_map.index, 1);
      294 	     if index_cursor_array.cursor_ptr (index_idx) ^= null
      295 	     then if index_attribute_map.index (index_idx).number_of_attributes <= 0
      296 		then
      297 		   do;				/* call index_manager_$destroy_cursor (index_cursor_array.cursor_ptr(index_idx), (0)); */
      298 		      index_cursor_array.cursor_ptr (index_idx) = null;
      299 		   end;
      300 	  end;
      301          end REMOVE_CURSORS_FOR_DELETED_INDICES;
      302       else
      303 EXTEND_INDEX_CURSOR_ARRAY:
      304          do;
      305 
      306          /*** The index_attribute_map has been extended to contain more indices than
      307*	    index_cursor_array components, so index_cursor_array must likewise be
      308*	    extended. Allocate a new one, and copy over the old cursor_ptr values.
      309*	    If a non-null cursor_ptr exists for an index which no longer exists,
      310*	    destroy the cursor. */
      311 
      312 	  old_index_cursor_array_ptr = index_cursor_array_ptr;
      313 	  ica_number_of_indices = hbound (index_attribute_map.index, 1);
      314 
      315 	  alloc index_cursor_array in (dm_area);
      316 	  index_cursor_array.version = INDEX_CURSOR_ARRAY_VERSION_1;
      317 	  relation_opening_info.per_process.index_cursor_array_ptr = index_cursor_array_ptr;
      318 
      319 	  index_cursor_array.cursor_ptr (*) = null;
      320 
      321 	  do index_idx = 1 to hbound (old_index_cursor_array_ptr -> index_cursor_array.cursor_ptr, 1);
      322 	     if old_index_cursor_array_ptr -> index_cursor_array.cursor_ptr (index_idx) ^= null
      323 	     then if index_attribute_map.index (index_idx).number_of_attributes > 0
      324 		then index_cursor_array.cursor_ptr (index_idx) =
      325 			old_index_cursor_array_ptr -> index_cursor_array.cursor_ptr (index_idx);
      326 	  /***	          else call index_manager_$destroy_cursor (old_index_cursor_array_ptr->index_cursor_array.cursor_ptr(index_idx), (0)); */
      327 	  end;
      328 	  free old_index_cursor_array_ptr -> index_cursor_array in (dm_area);
      329 
      330          end EXTEND_INDEX_CURSOR_ARRAY;
      331 
      332 
      333 
      334       if relation_opening_info.index_attribute_map_ptr ^= index_attribute_map_ptr
      335       then
      336          do;
      337 	  old_index_attribute_map_ptr = relation_opening_info.index_attribute_map_ptr;
      338 	  relation_opening_info.index_attribute_map_ptr = index_attribute_map_ptr;
      339 	  if old_index_attribute_map_ptr ^= null
      340 	  then free old_index_attribute_map_ptr -> index_attribute_map in (dm_area);
      341          end;
      342 
      343       return;
      344 
      345 CHECK_VERSION:
      346    proc (cv_p_structure_name, cv_p_received_version, cv_p_expected_version);
      347 
      348       dcl	    cv_p_received_version  char (8) aligned;
      349       dcl	    cv_p_expected_version  char (8) aligned;
      350       dcl	    cv_p_structure_name    char (*);
      351 
      352       if cv_p_received_version ^= cv_p_expected_version
      353       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      354 	      "^/Expected version ^8a of the ^a structure.
      355 Received version ^8a instead.", cv_p_expected_version, cv_p_structure_name, cv_p_received_version);
      356    end CHECK_VERSION;
      357 
  1     1 /* BEGIN INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
  1     2 
  1     3 /* Written by Matthew Pierret, 09/08/82. 
  1     4*Modified:
  1     5*01/18/83 by Matthew Pierret:  Changed version to be char (8). Added 
  1     6*            transaction_id.
  1     7*02/25/83 by Matthew Pierret:  Changed to relation_opening_info (from
  1     8*            relation_info).
  1     9*10/29/84 by Stanford S. Cox:  Changed to not init version.
  1    10**/
  1    11 
  1    12 
  1    13 /* format: style2,ind3 */
  1    14 
  1    15      dcl	   1 relation_opening_info
  1    16 			      aligned based (relation_opening_info_ptr),
  1    17 	     2 version	      char (8),
  1    18 	     2 per_process,
  1    19 	       3 current_transaction_id
  1    20 			      bit (36) aligned init ("0"b),
  1    21 	       3 current_rollback_count
  1    22 			      fixed bin (35) init (0),
  1    23 	       3 file_opening_id  bit (36) aligned init ("0"b),
  1    24 	       3 number_of_openings
  1    25 			      fixed bin (17) aligned init (0),
  1    26 	       3 lock_advice      aligned,
  1    27 	         4 this_process   bit (2) unaligned init ("0"b),
  1    28 	         4 other_processes
  1    29 			      bit (2) unaligned init ("0"b),
  1    30 	         4 mbz1	      bit (32) unaligned init ("0"b),
  1    31 	       3 record_cursor_ptr
  1    32 			      ptr init (null),
  1    33 	       3 index_cursor_array_ptr
  1    34 			      ptr init (null),
  1    35 	     2 relation_header_ptr
  1    36 			      ptr init (null),
  1    37 	     2 attribute_info_ptr ptr init (null),
  1    38 	     2 index_attribute_map_ptr
  1    39 			      ptr init (null);
  1    40 
  1    41      dcl	   relation_opening_info_ptr
  1    42 			      ptr;
  1    43      dcl	   RELATION_OPENING_INFO_VERSION_2
  1    44 			      init ("rlmopen2") char (8) aligned internal static options (constant);
  1    45 
  1    46 
  1    47 /* END INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
      358 
      359 
  2     1 /* BEGIN INCLUDE FILE - dm_rlm_header.incl.pl1 */
  2     2 
  2     3 /* HISTORY:
  2     4*Written by Matthew Pierret, 1982.
  2     5*Modified:
  2     6*02/25/83 by Matthew Pierret: Added attribute_info_element_id, 
  2     7*            header_info_update_count, RELATION_HEADER_VERSION_2.
  2     8*05/29/84 by Matthew Pierret: Added caller_header_element_id, 
  2     9*            RELATION_HEADER_VERSION_3.
  2    10*10/29/84 by Stanford S. Cox:  Changed to not init version.
  2    11**/
  2    12 
  2    13 /* format: style2,ind3 */
  2    14 
  2    15      dcl	   1 relation_header      aligned based (relation_header_ptr),
  2    16 	     2 version	      char (8),
  2    17 	     2 header_info_update_count
  2    18 			      fixed bin (35) aligned init (0),
  2    19 	     2 record_collection_id
  2    20 			      bit (36) aligned init ("0"b),
  2    21 	     2 cluster_index_id   bit (36) aligned init ("0"b),
  2    22 	     2 attribute_info_element_id
  2    23 			      bit (36) aligned init ("0"b),
  2    24 	     2 index_attribute_map_element_id
  2    25 			      bit (36) aligned init ("0"b),
  2    26 	     2 caller_header_element_id
  2    27 			      bit (36) aligned init ("0"b);
  2    28 
  2    29      dcl	   relation_header_ptr    ptr init (null);
  2    30      dcl	   RELATION_HEADER_VERSION_3
  2    31 			      init ("RelHdr 3") char (8) aligned internal static options (constant);
  2    32 
  2    33 /* END INCLUDE FILE - dm_rlm_header.incl.pl1 */
      360 
      361 
  3     1 /* BEGIN INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION
  3     4*        
  3     5*   Relation attributes descriptor and name.  This info is kept in the header
  3     6*   collection of existing files, therefore this incl should not be changed.
  3     7**/
  3     8 
  3     9 /* HISTORY:
  3    10*Written by Matthew Pierret, 02/25/83.
  3    11*Modified:
  3    12*10/29/84 by Stanford S. Cox:  Changed to not init version.
  3    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  3    14*   which were incompatible with existing DM files.        
  3    15**/
  3    16 
  3    17 /* format: style2,ind3 */
  3    18      dcl	   1 attribute_info	      aligned based (attribute_info_ptr),
  3    19 	     2 version	      char (8),
  3    20 	     2 number_of_attributes
  3    21 			      fixed bin (17) unal,
  3    22 	     2 maximum_attribute_name_length
  3    23 			      fixed bin (17) unal,
  3    24 	     2 attribute	      (ai_number_of_attributes refer (attribute_info.number_of_attributes)),
  3    25 	       3 descriptor	      bit (36) aligned,
  3    26 	       3 name	      char (ai_maximum_attribute_name_length
  3    27 			      refer (attribute_info.maximum_attribute_name_length)) varying;
  3    28 
  3    29      dcl	   attribute_info_ptr     ptr init (null);
  3    30      dcl	   ai_maximum_attribute_name_length
  3    31 			      fixed bin (17);
  3    32      dcl	   ai_number_of_attributes
  3    33 			      fixed bin (17);
  3    34      dcl	   ATTRIBUTE_INFO_VERSION_1
  3    35 			      init ("attrinf1") char (8) aligned internal static options (constant);
  3    36 
  3    37 /* END INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  3    38 
      362 
      363 
  4     1 /* BEGIN INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION
  4     4*        
  4     5*   Relation index components.  This info is kept in the header
  4     6*   collection of existing files, therefore this incl should not be changed.
  4     7**/
  4     8 
  4     9 /* HISTORY:
  4    10*Written by Matthew Pierret, 01/15/83.
  4    11*Modified:
  4    12*10/29/84 by Stanford S. Cox: Changed to not init version.
  4    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  4    14*   which were incompatible with existing DM files.        
  4    15**/
  4    16 
  4    17 /* format: style2,ind3 */
  4    18      dcl	   1 index_attribute_map  aligned based (index_attribute_map_ptr),
  4    19 	     2 version	      char (8),
  4    20 	     2 number_of_indices  fixed bin (17) unal init (0),
  4    21 	     2 maximum_number_of_indices
  4    22 			      fixed bin (17) unal,
  4    23 	     2 maximum_number_of_attributes_per_index
  4    24 			      fixed bin (17) unal,
  4    25 	     2 mbz	      fixed bin (17) unal,
  4    26 	     2 index	      (iam_maximum_number_of_indices refer (index_attribute_map.maximum_number_of_indices)),
  4    27 	       3 collection_id    bit (36) aligned,
  4    28 	       3 style	      fixed bin (17) unal,
  4    29 	       3 number_of_duplication_fields
  4    30 			      fixed bin (17) unal,
  4    31 	       3 number_of_attributes
  4    32 			      fixed bin (17) unal,
  4    33 	       3 attribute_id     (iam_maximum_number_of_attributes_per_index
  4    34 			      refer (index_attribute_map.maximum_number_of_attributes_per_index)) fixed
  4    35 			      bin (17) unal;
  4    36 
  4    37      dcl	   index_attribute_map_ptr
  4    38 			      ptr init (null);
  4    39      dcl	   iam_maximum_number_of_indices
  4    40 			      fixed bin (17);
  4    41      dcl	   iam_maximum_number_of_attributes_per_index
  4    42 			      fixed bin (17);
  4    43      dcl	   INDEX_ATTRIBUTE_MAP_VERSION_2
  4    44 			      init ("idx_map2") char (8) aligned internal static options (constant);
  4    45      dcl	   INITIAL_NUMBER_OF_INDICES
  4    46 			      init (5) fixed bin (17);
  4    47      dcl	   UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
  4    48 			      init (0) fixed bin (17);
  4    49 
  4    50 /* END INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
      364 
      365 
  5     1 /* BEGIN INCLUDE FILE dm_rlm_idx_cursor_array.incl.pl1 */
  5     2 
  5     3 /* HISTORY:
  5     4*Written by Matthew Pierret, 03/02/83. 
  5     5*Modified:
  5     6*10/30/84 by Stanford S. Cox: Changed to not init version.
  5     7**/
  5     8 
  5     9 /* format: style2,ind3 */
  5    10 
  5    11      dcl	   1 index_cursor_array   aligned based (index_cursor_array_ptr),
  5    12 	     2 version	      char (8),
  5    13 	     2 number_of_indices  fixed bin (35),
  5    14 	     2 mbz	      fixed bin (35) init (0),
  5    15 	     2 cursor_ptr	      (ica_number_of_indices refer (index_cursor_array.number_of_indices)) ptr;
  5    16 
  5    17      dcl	   index_cursor_array_ptr ptr init (null);
  5    18      dcl	   ica_number_of_indices  fixed bin (35) init (0);
  5    19      dcl	   INDEX_CURSOR_ARRAY_VERSION_1
  5    20 			      init ("ixcrsra1") char (8) aligned internal static options (constant);
  5    21 
  5    22 
  5    23 /* END INCLUDE FILE dm_rlm_idx_cursor_array.incl.pl1 */
      366 
      367 
  6     1 /* BEGIN INCLUDE FILE dm_cm_hdr_col_ids.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*   Contains element identifiers of some elements in the Header Collection.
  6     6*   HEADER_COLLECTION_HEADER_ELEMENT_ID is the identifier of the element in
  6     7*   which the collection_header for the Header Collection is stored (see
  6     8*   dm_cm_collection_header.incl.pl1).
  6     9*   CALLER_HEADER_ELEMENT_ID is the identifier of the element in which the
  6    10*   caller's file header is stored.
  6    11*   CM_FILE_HEADER_ELEMENT_ID is the identifier of the element in which the
  6    12*   cm_file_header structure is stored (see dm_cm_file_header.incl.pl1).
  6    13**/
  6    14 
  6    15 /* HISTORY:
  6    16*Written by Matthew Pierret, 09/24/84.
  6    17*Modified:
  6    18**/
  6    19 
  6    20 /* format: style2,ind3,ll79 */
  6    21      dcl	   (
  6    22 	   HEADER_COLLECTION_HEADER_ELEMENT_ID
  6    23 			      init ("000000000001"b3),
  6    24 	   CM_FILE_HEADER_ELEMENT_ID
  6    25 			      init ("000000000002"b3),
  6    26 	   CALLER_HEADER_ELEMENT_ID
  6    27 			      init ("000000000003"b3)
  6    28 	   )		      bit (36) aligned int static
  6    29 			      options (constant);
  6    30 
  6    31 /* END INCLUDE FILE  dm_cm_hdr_col_ids.incl.pl1 */
      368 
      369 
  7     1 /* BEGIN INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*        Contains the identifier of the Header Collection for a file
  7     6*   managed by the collection_manager_.  This is used by callers of 
  7     7*   collection_manager who wish to maintain their own file header or who wish
  7     8*   to maintain their own collection header information beyond the caller
  7     9*   collection header provided by colleciton_manager_$(get put)_header.
  7    10**/
  7    11 
  7    12 /* HISTORY:
  7    13*Written by Matthew Pierret, 09/24/84.
  7    14*Modified:
  7    15**/
  7    16 
  7    17 /* format: style2,ind3,ll79 */
  7    18 
  7    19      dcl	   HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36)
  7    20 			      aligned internal static options (constant);
  7    21 
  7    22 /* END INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
      370 
      371 
  8     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  8     2 /* format: style3 */
  8     3 
  8     4 /* These constants are to be used for the flags argument of sub_err_ */
  8     5 /* They are just "string (condition_info_header.action_flags)" */
  8     6 
  8     7 declare	(
  8     8 	ACTION_CAN_RESTART	init (""b),
  8     9 	ACTION_CANT_RESTART init ("1"b),
  8    10 	ACTION_DEFAULT_RESTART
  8    11 			init ("01"b),
  8    12 	ACTION_QUIET_RESTART
  8    13 			init ("001"b),
  8    14 	ACTION_SUPPORT_SIGNAL
  8    15 			init ("0001"b)
  8    16 	)		bit (36) aligned internal static options (constant);
  8    17 
  8    18 /* End include file */
      372 
      373 
  9     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*     This include file contains declarations of all collection_manager_ 
  9     5*     entrypoints.
  9     6**/
  9     7 
  9     8 /* HISTORY:
  9     9*Written by Matthew Pierret 
  9    10*Modified:
  9    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  9    12*	  allocate_control_interval operation to be unaligned, as well as
  9    13*	  unsigned.
  9    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  9    15*            removed the beginning_location parameter from the put_element
  9    16*            operation. Added the create_page_file_operation.
  9    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  9    18*            wherever collection_id was required.
  9    19*            Also changed the control_interval_id parameter of the 
  9    20*            allocate_control_interval operation back to be aligned. So there.
  9    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  9    22*            added the argument file_create_info_ptr to $create_file.
  9    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  9    24*	  include the zero_on_free bit.
  9    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  9    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  9    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  9    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  9    29*            cm_$put_unprotected_header.
  9    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  9    31*             $simple_get_buffered_element.
  9    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  9    33*            parameter for specifying absolute/relative nature of search.
  9    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  9    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  9    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  9    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  9    38*            delete_from_ci_buffer.
  9    39*            Re-named *_buffered_ci to =_ci_buffer.
  9    40*            get entries.
  9    41*            modify entries.
  9    42*            Changed calling sequence of modify entries to have a ptr/length
  9    43*            instead of length/ptr parameter pair.
  9    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  9    45**/
  9    46 
  9    47 /* This include file contains declarations of collection_manager_ entrypoints */
  9    48 
  9    49 /* format: style2,ind3 */
  9    50      dcl	   collection_manager_$allocate_control_interval
  9    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  9    52      dcl	   collection_manager_$compact_control_interval
  9    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  9    54      dcl	   collection_manager_$create_collection
  9    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  9    56      dcl	   collection_manager_$create_file
  9    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  9    58      dcl	   collection_manager_$destroy_collection
  9    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  9    60      dcl	   collection_manager_$free_control_interval
  9    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  9    62 			      fixed bin (35));
  9    63 
  9    64      dcl	   collection_manager_$delete
  9    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  9    66 			      fixed bin (35));
  9    67      dcl	   collection_manager_$delete_from_ci_buffer
  9    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  9    69 			      fixed bin (35));
  9    70 
  9    71      dcl	   collection_manager_$get
  9    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  9    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  9    74      dcl	   collection_manager_$get_control_interval_ptr
  9    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  9    76 			      fixed bin (35));
  9    77      dcl	   collection_manager_$get_from_ci_buffer
  9    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  9    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  9    80      dcl	   collection_manager_$get_by_ci_ptr
  9    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  9    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  9    83      dcl	   collection_manager_$get_header
  9    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  9    85 			      ptr, fixed bin (35), fixed bin (35));
  9    86      dcl	   collection_manager_$get_id
  9    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  9    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  9    89      dcl	   collection_manager_$get_portion
  9    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  9    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  9    92 			      fixed bin (35), fixed bin (35));
  9    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  9    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  9    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  9    96 			      fixed bin (35));
  9    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  9    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  9    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  9   100 			      fixed bin (35));
  9   101      dcl	   collection_manager_$modify
  9   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   103 			      fixed bin (35), fixed bin (35));
  9   104      dcl	   collection_manager_$modify_unprotected
  9   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   106 			      fixed bin (35), fixed bin (35));
  9   107      dcl	   collection_manager_$modify_in_ci_buffer
  9   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   109 			      fixed bin (35), fixed bin (35));
  9   110      dcl	   collection_manager_$modify_portion
  9   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  9   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  9   113      dcl	   collection_manager_$postcommit_increments
  9   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  9   115      dcl	   collection_manager_$put
  9   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   117 			      fixed bin (35), fixed bin (35));
  9   118      dcl	   collection_manager_$put_in_ci_buffer
  9   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   120 			      fixed bin (35), fixed bin (35));
  9   121      dcl	   collection_manager_$put_header
  9   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  9   123      dcl	   collection_manager_$put_unprotected_header
  9   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  9   125 
  9   126      dcl	   collection_manager_$replace_ci_buffer
  9   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  9   128 			      fixed bin (35));
  9   129      dcl	   collection_manager_$setup_ci_buffer
  9   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  9   131 			      fixed bin (35));
  9   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  9   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  9   134 			      fixed bin (35));
  9   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  9   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  9   137 			      fixed bin (35));
  9   138 
  9   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      374 
      375 
      376    end rlm_update_opening_info;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0914.0  rlm_update_opening_info.pl1       >spec>on>7192.pbf-04/04/85>rlm_update_opening_info.pl1
358          1    01/07/85  0859.6  dm_rlm_opening_info.incl.pl1      >ldd>include>dm_rlm_opening_info.incl.pl1
360          2    01/07/85  0859.4  dm_rlm_header.incl.pl1            >ldd>include>dm_rlm_header.incl.pl1
362          3    01/07/85  0901.7  dm_rlm_attribute_info.incl.pl1    >ldd>include>dm_rlm_attribute_info.incl.pl1
364          4    01/07/85  0901.7  dm_rlm_index_attr_map.incl.pl1    >ldd>include>dm_rlm_index_attr_map.incl.pl1
366          5    01/07/85  0859.5  dm_rlm_idx_cursor_array.incl.pl1  >ldd>include>dm_rlm_idx_cursor_array.incl.pl1
368          6    01/07/85  0858.4  dm_cm_hdr_col_ids.incl.pl1        >ldd>include>dm_cm_hdr_col_ids.incl.pl1
370          7    01/07/85  0858.8  dm_hdr_collection_id.incl.pl1     >ldd>include>dm_hdr_collection_id.incl.pl1
372          8    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
374          9    04/04/85  0819.0  dm_collmgr_entry_dcls.incl.pl1    >spec>on>7192.pbf-04/04/85>dm_collmgr_entry_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000000 constant        bit(36)                  initial dcl 8-7 set ref 38* 352*
ATTRIBUTE_INFO_VERSION_1        000006 constant        char(8)                  initial dcl 3-34 set ref 198*
BITS_PER_WORD                          constant        fixed bin(17,0)          initial dcl 79 ref 200 204 213 246 250 259
CALLER_HEADER_ELEMENT_ID        000042 constant        bit(36)                  initial dcl 6-21 set ref 167* 213* 259*
HEADER_COLLECTION_ID            000044 constant        bit(36)                  initial dcl 7-19 set ref 167* 200* 204* 213* 246*
                                                                                  250* 259*
INDEX_ATTRIBUTE_MAP_VERSION_2   000004 constant        char(8)                  initial dcl 4-43 set ref 244*
INDEX_CURSOR_ARRAY_VERSION_1    000002 constant        char(8)                  initial dcl 5-19 set ref 275 282* 316
INITIAL_NUMBER_OF_INDICES       000132 automatic       fixed bin(17,0)          initial dcl 4-45 set ref 4-45*
RELATION_HEADER_VERSION_3       000010 constant        char(8)                  initial dcl 2-30 set ref 163* 195* 241*
RELATION_OPENING_INFO_VERSION_2 000012 constant        char(8)                  initial dcl 1-43 set ref 120* 145* 160* 192* 238*
UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                000133 automatic       fixed bin(17,0)          initial dcl 4-47 set ref 4-47*
attribute_info                         based           structure                level 1 dcl 3-18 set ref 200 204 228
attribute_info_element_id
                          5            based           bit(36)                  initial level 2 dcl 2-15 set ref 200 200* 204*
attribute_info_ptr       16            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 1-15 in procedure "rlm_update_opening_info"
                                                                                  set ref 218 221 222*
attribute_info_ptr              000126 automatic       pointer                  initial dcl 3-29 in procedure
                                                                                  "rlm_update_opening_info" set ref 197* 198 200*
                                                                                  200 204* 204 218 222 3-29*
cleanup                         000114 stack reference condition                dcl 75 ref 124 149
collection_manager_$modify      000024 constant        entry                    external dcl 9-101 ref 167 204 213 250 259
collection_manager_$put         000026 constant        entry                    external dcl 9-115 ref 200 246
current_lock_advice             000103 automatic       structure                level 1 dcl 60 set ref 148* 149
current_number_of_openings      000100 automatic       fixed bin(17,0)          dcl 58 set ref 123* 124
currentsize                                            builtin function         dcl 70 ref 200 204 213 246 250 259
cursor_ptr                4            based           pointer                  array level 2 dcl 5-11 set ref 276* 285 294 298*
                                                                                  319* 321 322 322* 322
cv_p_expected_version                  parameter       char(8)                  dcl 349 set ref 345 352 352*
cv_p_received_version                  parameter       char(8)                  dcl 348 set ref 345 352 352*
cv_p_structure_name                    parameter       char                     unaligned dcl 350 set ref 345 352*
dm_area                                based           area                     dcl 66 ref 182 228 274 315 328 339
dm_error_$programming_error     000020 external static fixed bin(35,0)          dcl 92 set ref 38*
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 94 set ref 352*
file_opening_id           4            based           bit(36)                  initial level 3 dcl 1-15 set ref 167* 200* 204* 213*
                                                                                  246* 250* 259*
get_dm_free_area_               000014 constant        entry                    external dcl 87 ref 180 226 264
header_info_update_count
                          2            based           fixed bin(35,0)          initial level 2 dcl 2-15 set ref 165* 165 211* 211
                                                                                  257* 257
ica_number_of_indices           000136 automatic       fixed bin(35,0)          initial dcl 5-18 set ref 273* 274 274 313* 315 315
                                                                                  5-18*
increment                       000102 automatic       fixed bin(17,0)          dcl 58 set ref 109* 115* 126 129
index                     4            based           structure                array level 2 dcl 4-18 ref 273 285 293 313
index_attribute_map                    based           structure                level 1 dcl 4-18 set ref 246 250 339
index_attribute_map_element_id
                          6            based           bit(36)                  initial level 2 dcl 2-15 set ref 246 246* 250*
index_attribute_map_ptr
                         20            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 1-15 in procedure "rlm_update_opening_info"
                                                                                  set ref 334 337 338*
index_attribute_map_ptr         000130 automatic       pointer                  initial dcl 4-37 in procedure
                                                                                  "rlm_update_opening_info" set ref 243* 244 246*
                                                                                  246 250* 250 273 285 293 294 313 322 334 338 4-37*
index_cursor_array                     based           structure                level 1 dcl 5-11 set ref 274 315 328
index_cursor_array_ptr
                         12            based           pointer                  initial level 3 in structure "relation_opening_info"
                                                                                  dcl 1-15 in procedure "rlm_update_opening_info"
                                                                                  set ref 267 277* 281 317*
index_cursor_array_ptr          000134 automatic       pointer                  initial dcl 5-17 in procedure
                                                                                  "rlm_update_opening_info" set ref 274* 275 276 277
                                                                                  281* 282 285 294 298 312 315* 316 317 319 322
                                                                                  5-17*
index_idx                       000101 automatic       fixed bin(17,0)          dcl 58 set ref 293* 294 294 298* 321* 322 322 322
                                                                                  322*
length                                                 builtin function         dcl 70 ref 167 167
lock_advice               6            based           structure                level 3 dcl 1-15 set ref 148 149*
maximum_attribute_name_length
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 3-18 ref 200 204 228
maximum_number_of_attributes_per_index
                          3            based           fixed bin(17,0)          level 2 packed unaligned dcl 4-18 ref 246 250 294
                                                                                  294 322 322 339
maximum_number_of_indices
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 4-18 ref 246 250 273
                                                                                  285 293 313 339
mbz                       3            based           fixed bin(35,0)          initial level 2 dcl 5-11 set ref 274* 315*
mbz1                      0(04) 000103 automatic       bit(32)                  initial level 2 packed unaligned dcl 60 set ref 60*
myname                          000014 constant        varying char(32)         initial dcl 79 set ref 38* 38* 38* 352*
null                                                   builtin function         dcl 70 ref 38 38 61 61 61 61 135 177 180 223 226 264
                                                                                  267 276 294 298 319 322 339 2-29 3-29 4-37 5-17
                                                                                  352 352
number_of_attributes      6            based           fixed bin(17,0)          array level 3 in structure "index_attribute_map"
                                                                                  packed unaligned dcl 4-18 in procedure
                                                                                  "rlm_update_opening_info" ref 294 322
number_of_attributes      2            based           fixed bin(17,0)          level 2 in structure "attribute_info" packed
                                                                                  unaligned dcl 3-18 in procedure
                                                                                  "rlm_update_opening_info" ref 200 204 228
number_of_indices         2            based           fixed bin(35,0)          level 2 dcl 5-11 set ref 274* 276 285 315* 319 321
                                                                                  328
number_of_openings        5            based           fixed bin(17,0)          initial level 3 dcl 1-15 set ref 123 124* 126* 126
                                                                                  129
old_attribute_info_ptr          000106 automatic       pointer                  initial dcl 61 set ref 61* 221* 223 228
old_index_attribute_map_ptr     000110 automatic       pointer                  initial dcl 61 set ref 61* 337* 339 339
old_index_cursor_array_ptr      000112 automatic       pointer                  initial dcl 61 set ref 61* 312* 321 322 322 328
old_relation_header_ptr         000104 automatic       pointer                  initial dcl 61 set ref 61* 175* 177 182
other_processes           6(02)        based           bit(2)                   initial level 4 in structure "relation_opening_info"
                                                                                  packed unaligned dcl 1-15 in procedure
                                                                                  "rlm_update_opening_info" set ref 152*
other_processes           0(02) 000103 automatic       bit(2)                   initial level 2 in structure "current_lock_advice"
                                                                                  packed unaligned dcl 60 in procedure
                                                                                  "rlm_update_opening_info" set ref 60*
p_attribute_info_ptr                   parameter       pointer                  dcl 49 ref 188 197
p_code                                 parameter       fixed bin(35,0)          dcl 54 set ref 106 112 122* 132* 133 140 147* 156
                                                                                  167* 169 188 200* 204* 208 213* 215 234 246* 250*
                                                                                  254 259* 261
p_index_attribute_map_ptr              parameter       pointer                  dcl 50 ref 234 243
p_other_processes_permission           parameter       bit(2)                   dcl 52 ref 140 152
p_relation_header_ptr                  parameter       pointer                  dcl 48 ref 156 162
p_relation_opening_info_ptr            parameter       pointer                  dcl 46 set ref 106 112 117 135* 140 143 156 159 188
                                                                                  191 234 237
p_this_process_permission              parameter       bit(2)                   dcl 52 ref 140 151
per_process               2            based           structure                level 2 dcl 1-15
relation_header                        based           structure                level 1 dcl 2-15 set ref 167 167 182 213 259
relation_header_ptr             000124 automatic       pointer                  initial dcl 2-29 in procedure
                                                                                  "rlm_update_opening_info" set ref 162* 163 165 165
                                                                                  167* 167 167 172 176 194* 195 200 200 204 211 211
                                                                                  213* 213 240* 241 246 246 250 257 257 259* 259
                                                                                  2-29*
relation_header_ptr      14            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 1-15 in procedure "rlm_update_opening_info"
                                                                                  set ref 172 175 176* 194 240
relation_opening_info                  based           structure                level 1 dcl 1-15
relation_opening_info_ptr       000122 automatic       pointer                  dcl 1-41 set ref 117* 120 123 124 126 126 129 132*
                                                                                  143* 145 148 149 151 152 159* 160 167 172 175 176
                                                                                  191* 192 194 200 204 213 218 221 222 237* 238 240
                                                                                  246 250 259 267 277 281 317 334 337 338
rlm_opening_info$free           000012 constant        entry                    external dcl 86 ref 132
static_dm_area_ptr              000010 internal static pointer                  initial dcl 100 set ref 180 180* 182 226 226* 228
                                                                                  264 264* 274 315 328 339
sub_err_                        000016 constant        entry                    external dcl 88 ref 38 352
this_process                    000103 automatic       bit(2)                   initial level 2 in structure "current_lock_advice"
                                                                                  packed unaligned dcl 60 in procedure
                                                                                  "rlm_update_opening_info" set ref 60*
this_process              6            based           bit(2)                   initial level 4 in structure "relation_opening_info"
                                                                                  packed unaligned dcl 1-15 in procedure
                                                                                  "rlm_update_opening_info" set ref 151*
unspec                                                 builtin function         dcl 70 ref 167 167
version                                based           char(8)                  level 2 in structure "index_attribute_map" dcl 4-18
                                                                                  in procedure "rlm_update_opening_info" set ref
                                                                                  244*
version                                based           char(8)                  level 2 in structure "index_cursor_array" dcl 5-11
                                                                                  in procedure "rlm_update_opening_info" set ref
                                                                                  275* 282* 316*
version                                based           char(8)                  level 2 in structure "relation_header" dcl 2-15
                                                                                  in procedure "rlm_update_opening_info" set ref
                                                                                  163* 195* 241*
version                                based           char(8)                  level 2 in structure "attribute_info" dcl 3-18
                                                                                  in procedure "rlm_update_opening_info" set ref
                                                                                  198*
version                                based           char(8)                  level 2 in structure "relation_opening_info"
                                                                                  dcl 1-15 in procedure "rlm_update_opening_info"
                                                                                  set ref 120* 145* 160* 192* 238*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 8-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 8-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 8-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 8-7
CM_FILE_HEADER_ELEMENT_ID              internal static bit(36)                  initial dcl 6-21
HEADER_COLLECTION_HEADER_ELEMENT_ID    internal static bit(36)                  initial dcl 6-21
ai_maximum_attribute_name_length       automatic       fixed bin(17,0)          dcl 3-30
ai_number_of_attributes                automatic       fixed bin(17,0)          dcl 3-32
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 9-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 9-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 9-54
collection_manager_$create_file 000000 constant        entry                    external dcl 9-56
collection_manager_$delete      000000 constant        entry                    external dcl 9-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 9-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 9-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 9-60
collection_manager_$get         000000 constant        entry                    external dcl 9-71
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 9-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 9-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 9-77
collection_manager_$get_header  000000 constant        entry                    external dcl 9-83
collection_manager_$get_id      000000 constant        entry                    external dcl 9-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 9-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 9-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 9-93
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 9-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 9-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 9-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 9-113
collection_manager_$put_header  000000 constant        entry                    external dcl 9-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 9-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 9-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 9-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 9-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 9-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 9-135
iam_maximum_number_of_attributes_per_index
                                       automatic       fixed bin(17,0)          dcl 4-41
iam_maximum_number_of_indices          automatic       fixed bin(17,0)          dcl 4-39
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 96

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   002106 constant        entry                    internal dcl 345 ref 120 145 160 163 192 195 198 238
                                                                                  241 244 282
EXTEND_INDEX_CURSOR_ARRAY       001736 constant        label                    dcl 302
OPENINGS_JOIN                   000302 constant        label                    dcl 117 set ref 110
REMOVE_CURSORS_FOR_DELETED_INDICES
                                001674 constant        label                    dcl 285
attribute_info                  000706 constant        entry                    external dcl 188
decrement_openings              000267 constant        entry                    external dcl 112
increment_openings              000251 constant        entry                    external dcl 106
index_attribute_map             001251 constant        entry                    external dcl 234
lock_advice                     000413 constant        entry                    external dcl 140
relation_header                 000522 constant        entry                    external dcl 156
rlm_update_opening_info         000166 constant        entry                    external dcl 35

NAME DECLARED BY CONTEXT OR IMPLICATION.
hbound                                                 builtin function         ref 273 285 285 293 313 321

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2430        2460    2213        2440
Length      3076    2213        30         402     215           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rlm_update_opening_info             220 external procedure  is an external procedure.  
on unit on line 124                  64 on unit               
on unit on line 149                  64 on unit               
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rlm_update_opening_info.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 static_dm_area_ptr          rlm_update_opening_info

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rlm_update_opening_info  000100 current_number_of_openings  rlm_update_opening_info
                         000101 index_idx                   rlm_update_opening_info
                         000102 increment                   rlm_update_opening_info
                         000103 current_lock_advice         rlm_update_opening_info
                         000104 old_relation_header_ptr     rlm_update_opening_info
                         000106 old_attribute_info_ptr      rlm_update_opening_info
                         000110 old_index_attribute_map_ptr rlm_update_opening_info
                         000112 old_index_cursor_array_ptr  rlm_update_opening_info
                         000122 relation_opening_info_ptr   rlm_update_opening_info
                         000124 relation_header_ptr         rlm_update_opening_info
                         000126 attribute_info_ptr          rlm_update_opening_info
                         000130 index_attribute_map_ptr     rlm_update_opening_info
                         000132 INITIAL_NUMBER_OF_INDICES   rlm_update_opening_info
                         000133 UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                                            rlm_update_opening_info
                         000134 index_cursor_array_ptr      rlm_update_opening_info
                         000136 ica_number_of_indices       rlm_update_opening_info

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              enable              ext_entry           int_entry
alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$modify    collection_manager_$put       get_dm_free_area_             rlm_opening_info$free
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$programming_error   error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     60 000137        61 000145    2   29 000152    3   29 000153    4   37 000154    4   45 000155    4   47 000157
 5   17 000160    5   18 000162        35 000165        38 000174       106 000244       109 000262       110 000264
    112 000265       115 000300       117 000302       120 000306       122 000333       123 000334       124 000337
    126 000360       129 000363       132 000367       133 000400       135 000402       138 000405       140 000406
    143 000424       145 000430       147 000455       148 000456       149 000461       151 000502       152 000510
    154 000515       156 000516       159 000533       160 000537       162 000564       163 000570       165 000613
    167 000620       169 000647       172 000651       175 000656       176 000660       177 000662       180 000666
    182 000701       186 000703       188 000704       191 000717       192 000723       194 000750       195 000753
    197 000776       198 001002       200 001025       204 001074       208 001137       211 001141       213 001146
    215 001176       218 001200       221 001205       222 001207       223 001211       226 001215       228 001230
    232 001246       234 001247       237 001262       238 001266       240 001313       241 001316       243 001341
    244 001345       246 001367       250 001441       254 001507       257 001511       259 001516       261 001546
    264 001550       267 001563       273 001570       274 001575       275 001610       276 001613       277 001630
    278 001632       281 001633       282 001635       285 001662       293 001674       294 001703       298 001730
    300 001733       301 001735       312 001736       313 001737       315 001741       316 001754       317 001757
    319 001761       321 001776       322 002007       327 002040       328 002042       334 002050       337 002055
    338 002057       339 002061       343 002105       345 002106       352 002117       356 002207


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
