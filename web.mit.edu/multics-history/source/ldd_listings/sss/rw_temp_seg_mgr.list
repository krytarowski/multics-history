	COMPILATION LISTING OF SEGMENT rw_temp_seg_mgr
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/16/84  1128.4 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend */
       12 rw_temp_seg_mgr:
       13 	proc ();
       14 
       15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       16 	/*								        */
       17 	/*    This program implements the temporary segment management features	        */
       18 	/*    as used by the report writer (and possibly other modules later).	        */
       19 	/*								        */
       20 	/*    Last Modified: (date and reason):					        */
       21 	/*    04/06/83         original coding by Dave Schimke			        */
       22 	/*                     taken from get_temporary_segments_.pl1, but modified to add      */
       23 	/*                     directory specification.				        */
       24 	/*    03/09/84 Al Dupuis - Changed when the LINUS report writer was broken out 	        */
       25 	/*    to be free-standing.						        */
       26 	/*								        */
       27 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       28 
       29 
       30 /* Parameters */
       31 
       32 dcl  a_table_info_ptr ptr;
       33 dcl  a_caller char (*);
       34 dcl  a_dir char (*);
       35 dcl  a_ptrs (*) ptr;
       36 dcl  a_ptr ptr;
       37 dcl  a_code fixed bin (35);
       38 
       39 /**/
       40 
       41 get_segments:
       42 	entry (a_table_info_ptr, a_caller, a_dir, a_ptr, a_code);
       43 
       44 	n_segs = dim (a_ptrs, 1);			/* get number of segments wanted */
       45 	array_ptr = addr (a_ptrs);			/* get ptr to the array of ptrs */
       46 
       47 gts_join:
       48 	call initialize;
       49 	a_code = 0;
       50 	n_found = 0;				/* initialize indicating we've found no free entries */
       51  	if a_dir = ""
       52 	     then dir_name = get_pdir_ ();
       53 	else dir_name = a_dir;	     
       54 	status_ip = addr(status_info);
       55 	call expand_pathname_ (dir_name, containing_dir, dir_entryname, code);
       56 	if code ^= 0 then do;
       57 	     a_code = code;
       58 	     return;
       59 	     end;
       60 	call hcs_$status_long (containing_dir, dir_entryname, 1, status_ip, null(), code);
       61 	if code ^= 0 & code ^= error_table_$no_s_permission then do;
       62 	     a_code = code;
       63 	     return;
       64 	     end;
       65 	
       66 	dir_uid = status_info.long.uid;
       67 	
       68 	if block_ptr = null then do;			/* we haven't yet gotten any segments */
       69 	     temp_seg_info.number_of_temp_segs,
       70 		n_blocks = n_segs;			/* so get the exact amount requested */ 
       71 	     allocate block in (area) set (block_ptr);	/* get the needed storage */
       72 	     temp_seg_info.seg_block_ptr = block_ptr;
       73 	     old_blocks = 0;			/* needed by get_new_segments routine */
       74 	     call get_new_segments;			/* do the work in this subr */
       75 	     return;
       76 	     end;
       77 
       78 	do i = 1 to n_blocks while (n_found < n_segs);	/* search for the necessary free segments */
       79 	     if (^block (i).used & block(i).uid = dir_uid)
       80 		then do;				/* we found another free one */
       81 		block (i).used = "1"b;		/* mark entry as being used */
       82 		block (i).caller = a_caller;		/* save name of whose using it */
       83 		n_found = n_found + 1;
       84 		ptrs (n_found) = block (i).segptr;
       85 		end;
       86 	end;
       87 	if n_found < n_segs then do;			/* there weren't enough free ones */
       88 	     new_blocks = n_blocks + n_segs - n_found;	/* get more storage, just large enough */
       89 	     old_blocks = n_blocks;
       90 
       91 	     allocate new_block in (area) set (new_block_ptr);
       92 						/* get the needed storage */
       93 	     new_block_ptr -> block = block;		/* copy the current structure */
       94 	     free block in (area);
       95 	     temp_seg_info.number_of_temp_segs,
       96 		n_blocks = new_blocks;
       97 	     temp_seg_info.seg_block_ptr,
       98 		block_ptr = new_block_ptr;
       99 	     call get_new_segments;			/* get the needed segments */
      100 	     end;
      101 
      102 	return;
      103 
      104 get_new_segments:
      105      proc;
      106 
      107 dcl  (i, j) fixed bin;
      108 
      109 	do i = old_blocks + 1 to n_blocks;		/* initialize the new entries */
      110 	     block (i).used = "1"b;			/* the caller will use these blocks */
      111 	     block (i).caller = a_caller;		/* ditto */
      112 	     block (i).uid = dir_uid;		          /* save the dir_uid */
      113 	     ename2 = unique_chars_ (unique_bits_ ()) || ".temp.";
      114 	     ename = substr(ename2, 1, 20);
      115 	     call hcs_$make_seg (dir_name, ename, "", 01110b, block (i).segptr, code);
      116 	     if code ^= 0 then do;
      117 		call undo;
      118 		return;
      119 		end;
      120 	     segment_number = bin (baseno (block (i).segptr), 18);
      121 	     do j = 1 to 4;
      122 		segno (j) = substr ("01234567", bin (digit (j), 3) + 1, 1);
      123 	     end;
      124 	     call hcs_$chname_seg (block (i).segptr, ename, ename2, code);
      125 	     if code ^= 0 then do;
      126 		call undo;
      127 		return;
      128 		end;
      129 
      130 	     call hcs_$set_safety_sw_seg (block (i).segptr, "1"b, code);
      131 
      132 	     block (i).name = substr(ename2, 1, 25);
      133 	     n_found = n_found + 1;
      134 	     ptrs (n_found) = block (i).segptr;
      135 	end;
      136 
      137 undo:
      138 	proc;
      139 
      140 	     a_code = code;
      141 	     temp_seg_info.number_of_temp_segs,
      142 		n_blocks = old_blocks;		/* reset to the way things were */
      143 	     do j = old_blocks + 1 to i - 1;		/* clean up the segments we already got */
      144 		call delete_$ptr (block (j).segptr, "100100"b, "", code);
      145 	     end;
      146 
      147 	end;
      148      end;						/*						*/
      149 get_segment:
      150      entry (a_table_info_ptr, a_caller, a_dir, a_ptr, a_code);
      151 
      152 	n_segs = 1;				/* only 1 segment is being processed */
      153 	array_ptr = addr (a_ptr);
      154 	go to gts_join;				/*						*/
      155 release_segments:
      156      entry (a_table_info_ptr, a_caller, a_ptrs, a_code);
      157 
      158           n_segs = dim (a_ptrs, 1);			/* get number of segments wanted */
      159 	array_ptr = addr (a_ptrs);			/* get ptr to the array of ptrs */
      160 
      161 rts_join:
      162           call initialize;
      163 	a_code = 0;
      164 	do i = 1 to n_segs;				/* release each segment passed in */
      165 	     if ptrs (i) ^= null then do;
      166 		found_it = "0"b;			/* flag says we've not yet found this segment */
      167 		do j = 1 to n_blocks while (^found_it); /* search for segment in array */
      168 		     if block (j).used then do;	/* candidate, see if right one */
      169 			if ptrs (i) = block (j).segptr then do;
      170 						/* we found the given segment */
      171 			     if block (j).caller ^= substr(a_caller, 1, min (length (a_caller),32))
      172 			     then a_code = error_table_$argerr;
      173 			     else do;		/* the right guy (as far as we care) */
      174 				call hcs_$truncate_seg (block (j).segptr, 0, code);
      175 						/* truncate now */
      176 				if code ^= 0 then a_code = code;
      177 						/* accumulate error */
      178 				block (j).used = "0"b;
      179 						/* ditto */
      180 				block (j).caller = "";
      181 				ptrs (i) = null;
      182 				found_it = "1"b;
      183 				end;
      184 			     end;
      185 			end;
      186 		end;
      187 		if ^found_it then a_code = error_table_$argerr;
      188 		end;
      189 	end;
      190 	return;
      191 
      192 /**/
      193 release_segment:
      194      entry (a_table_info_ptr, a_caller, a_ptr, a_code);
      195 
      196           n_segs = 1;				/* only 1 segment is being processed */
      197 	array_ptr = addr (a_ptr);
      198 	goto rts_join;
      199 
      200 /**/
      201 terminate:
      202 	entry (a_table_info_ptr, a_code);
      203 
      204 	call initialize;
      205 	a_code = 0;
      206 	do i = 1 to n_blocks;			/* delete all */
      207 	     if block(i).used then call com_err_ (0, "rw_temp_seg_mgr", "Warning. An unreleased temp seg has been found. (^a)", block(i).caller);
      208 	     call delete_$ptr (block(i).segptr, "100100"b, "rw_temp_seg_mgr", a_code);
      209 	     end;
      210 	call release_temp_segment_ ("rw_temp_seg_mgr", temp_seg_info.work_area_ptr, a_code);
      211 	table_control_info.temp_seg_info_ptr = null;
      212 	return;
      213 /**/
      214 initialize:
      215 	proc;
      216 
      217 	table_control_ip = a_table_info_ptr;
      218 	sci_ptr = table_control_info.subsystem_control_info_ptr;
      219 	info_ptr = table_control_info.temp_seg_info_ptr;
      220 	work_area_ptr = table_control_info.general_work_area_ptr;
      221 	if info_ptr = null then do;
      222 	     allocate temp_seg_info in (work_area) set (info_ptr);
      223 	     table_control_info.temp_seg_info_ptr = info_ptr;
      224 	     end;
      225 	area_p = temp_seg_info.work_area_ptr;
      226 	if area_p = null then do;
      227 	     call get_temp_segment_ ("rw_temp_seg_mgr", temp_seg_info.work_area_ptr, a_code);
      228 	     allocate area_info set (area_infop);
      229 	     area_info.version = 1;
      230 	     area_info.control.extend = "0"b;
      231 	     area_info.control.zero_on_alloc = "0"b;
      232 	     area_info.control.zero_on_free = "0"b;
      233 	     area_info.control.no_freeing = "0"b;
      234 	     area_info.control.system = "0"b;
      235 	     area_info.owner = a_caller;
      236 	     area_info.pad = "0"b;
      237 	     area_info.size = sys_info$max_seg_size;
      238 	     area_info.areap = temp_seg_info.work_area_ptr;
      239 	     call define_area_ (area_infop, a_code);
      240 	     area_p = temp_seg_info.work_area_ptr;
      241 	     free area_info;
      242 	     end;
      243 	block_ptr = temp_seg_info.seg_block_ptr;
      244 	n_blocks = temp_seg_info.number_of_temp_segs;
      245 end initialize;
      246 /* Areas */
      247 
      248 dcl work_area area (sys_info$max_seg_size) based (work_area_ptr);
      249 dcl work_area_ptr ptr;
      250 /* Automatic */
      251 
      252 dcl  area_p ptr init (null);
      253 dcl  array_ptr ptr;
      254 dcl  block_ptr ptr init (null);
      255 dcl  code fixed bin (35);
      256 dcl  containing_dir char(168);
      257 dcl  dir_entryname char(32);
      258 dcl  dir_name char(168);
      259 dcl  dir_uid bit(36) unal;
      260 dcl  ename char (20);
      261 dcl  ename2 char (32);
      262 dcl  found_it bit (1);
      263 dcl  i fixed bin;
      264 dcl  info_ptr ptr;
      265 dcl  j fixed bin;
      266 dcl  n_blocks fixed bin init (0);
      267 dcl  n_found fixed bin;
      268 dcl  n_segs fixed bin;
      269 dcl  new_block_ptr ptr;
      270 dcl  new_blocks fixed bin;
      271 dcl  old_blocks fixed bin;
      272 dcl  sci_ptr ptr;
      273 dcl  segment_number fixed bin;
      274 dcl  segno (4) char (1) defined (ename2) pos (22);
      275 dcl  status_ip ptr;
      276 
      277 /* Based */
      278 
      279 dcl  area area based (area_p);
      280 dcl  1 block (n_blocks) aligned based (block_ptr),
      281        2 caller char (32),
      282        2 segptr ptr,
      283        2 name char (25),
      284        2 uid bit(36) unal,
      285        2 used bit (1);
      286 dcl  1 temp_seg_info based (info_ptr),
      287        2 number_of_temp_segs fixed bin init (0),
      288        2 seg_block_ptr ptr init(null),
      289        2 work_area_ptr ptr init(null);
      290 dcl  1 new_block (new_blocks) aligned based (new_block_ptr) like block;
      291 dcl  1 octal_digits aligned based (addr (segment_number)),
      292        2 filler bit (24) unal,
      293        2 digit (4) bit (3) unal;
      294 dcl  ptrs (n_segs) ptr based (array_ptr);
      295 dcl 1 status_info like status_branch;
      296 
      297 /* Builtin */
      298 
      299 dcl  (addr, baseno, bin, dim, length, min, null, substr) builtin;
      300 
      301 /* Entries */
      302 
      303 dcl  com_err_ entry() options(variable);
      304 dcl  define_area_ entry (ptr, fixed bin(35));
      305 dcl  delete_$ptr entry (ptr, bit(6), char(*), fixed bin(35));
      306 dcl  expand_pathname_ entry (char(*), char(*), char(*), fixed bin(35));
      307 dcl  get_pdir_ entry() returns(char(168));
      308 dcl  get_temp_segment_ entry (char(*), ptr, fixed bin(35));
      309 dcl  hcs_$chname_seg entry (ptr, char (*), char (*), fixed bin (35));
      310 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      311 dcl  hcs_$status_long entry (char(*), char(*), fixed bin(1), ptr, ptr, fixed bin(35));
      312 dcl  hcs_$set_safety_sw_seg entry (ptr, bit (1), fixed bin (35));
      313 dcl  hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
      314 dcl  release_temp_segment_ entry (char(*), ptr, fixed bin(35));
      315 dcl  unique_bits_ entry returns (bit (70));
      316 dcl  unique_chars_ entry (bit (*)) returns (char (15));
      317 
      318 /* External */
      319 
      320 dcl  error_table_$argerr fixed bin (35) ext;
      321 dcl  error_table_$no_s_permission fixed bin(35) ext static;
      322 dcl  sys_info$max_seg_size fixed bin(35) ext static;
      323 
      324 
  1     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  1     2 
  1     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  1     4 
  1     5 dcl  area_infop ptr;
  1     6 
  1     7 dcl 1 area_info aligned based (area_infop),
  1     8     2 version fixed bin,				/* version number for this structure is 1 */
  1     9     2 control aligned like area_control,		/* control bits for the area */
  1    10     2 owner char (32) unal,				/* creator of the area */
  1    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  1    12     2 size fixed bin (18),				/* size of the area in words */
  1    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  1    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  1    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  1    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  1    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  1    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  1    19 
  1    20 dcl 1 area_control aligned based,
  1    21     2 extend bit (1) unal,				/* says area is extensible */
  1    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  1    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  1    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  1    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  1    26     2 system bit (1) unal,				/* says area is managed by system */
  1    27     2 pad bit (30) unal;
  1    28 
  1    29 /* END INCLUDE FILE area_info.incl.pl1 */
      325 
  2     1 /*   BEGIN INCLUDE FILE rw_table_info.incl.pl1
  2     2*
  2     3*     Written - Al Dupuis
  2     4**/
  2     5 /* format: off */

  2     6 
  2     7 dcl 1 table_info aligned based (table_ip),
  2     8       2 version char (8),
  2     9       2 column_count fixed bin,
  2    10       2 maximum_column_name_length fixed bin,	   
  2    11       2 maximum_column_value_length fixed bin,
  2    12       2 row_value_length fixed bin (21),
  2    13       2 row_value_ptr ptr,
  2    14       2 columns (ti_init_column_count refer (table_info.column_count)),    
  2    15         3 column_name char (69) varying,
  2    16         3 column_data_type  bit (36),
  2    17         3 column_length fixed bin (21),
  2    18         3 column_index fixed bin (21);

  2    19 
  2    20 dcl table_ip ptr;
  2    21 dcl ti_init_column_count fixed bin;
  2    22 dcl TABLE_INFO_VERSION_1 char (8) internal static options (constant) init ("rwti_001");

  2    23 
  2    24 /* END INCLUDE FILE view_master_table_info.incl.pl1    */
      326 
  3     1 /*   BEGIN INCLUDE FILE rw_table_control_info.incl.pl1
  3     2*
  3     3*     Written - Al Dupuis
  3     4**/
  3     5 /* format: off */

  3     6 
  3     7 dcl 1 row_ptrs aligned based (row_ptrs_ptr),
  3     8       2 number_of_ptrs_in_this_segment fixed bin (21),
  3     9       2 row_value_ptr (row_ptrs.number_of_ptrs_in_this_segment) ptr unaligned;

  3    10 
  3    11 dcl 1 table_control_info aligned based (table_control_ip),
  3    12       2 row_count fixed bin (35),
  3    13       2 number_of_components fixed bin,
  3    14       2 maximum_number_of_rows_per_segment fixed bin (21),
  3    15       2 current_segment_row_count fixed bin (21),
  3    16       2 table_information_ptr ptr,
  3    17       2 table_segments_info_ptr ptr,
  3    18       2 msf_file_control_block_ptr ptr,
  3    19       2 current_component_ptr ptr,
  3    20       2 general_work_area_ptr ptr,
  3    21       2 temp_seg_info_ptr ptr,
  3    22       2 subsystem_control_info_ptr ptr,
  3    23       2 msf_file_name char (32) unaligned,
  3    24       2 msf_directory_name char (168) unaligned;

  3    25 
  3    26 dcl 1 table_segments_info aligned based (table_segments_ip),
  3    27       2 maximum_number_of_segments fixed bin,
  3    28       2 maximum_number_of_ptrs_per_segment fixed bin (21),
  3    29       2 current_number_of_segments fixed bin,
  3    30       2 segment_ptrs (tsi_init_maximum_number_of_segments refer
  3    31         (table_segments_info.maximum_number_of_segments)) ptr;

  3    32 
  3    33 dcl row_ptrs_ptr ptr;
  3    34 dcl table_segments_ip ptr;
  3    35 dcl table_control_ip ptr;
  3    36 dcl tsi_init_maximum_number_of_segments fixed bin (21);

  3    37 
  3    38 /* END INCLUDE FILE rw_table_control_info.incl.pl1    */
      327 
  4     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  4     2 
  4     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  4     4 
  4     5 /* This include file contains branch and link structures returned by
  4     6*   hcs_$status_ and hcs_$status_long. */
  4     7 
  4     8 dcl 1 status_branch aligned based (status_ptr),
  4     9     2 short aligned,
  4    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  4    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  4    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  4    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  4    14       3 dtu bit (36) unaligned,			/* date/time last used */
  4    15       3 mode bit (5) unaligned,			/* caller's effective access */
  4    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  4    17       3 pad1 bit (8) unaligned,
  4    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  4    19 
  4    20 /* Limit of information returned by hcs_$status_ */
  4    21 
  4    22     2 long aligned,
  4    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  4    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  4    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  4    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  4    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  4    28       3 pad2 bit (8) unaligned,
  4    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  4    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  4    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  4    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  4    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  4    34       3 pad3 bit (5) unaligned,
  4    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  4    36       3 uid bit (36) unaligned;			/* unique ID */
  4    37 
  4    38 dcl 1 status_link aligned based (status_ptr),
  4    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  4    40     2 nnames fixed bin (16) unaligned unsigned,
  4    41     2 names_relp bit (18) unaligned,
  4    42     2 dtem bit (36) unaligned,
  4    43     2 dtd bit (36) unaligned,
  4    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  4    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  4    46 
  4    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  4    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  4    49 						/* array of names returned */
  4    50      status_pathname character (status_link.pathname_length) aligned
  4    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  4    52 						/* link target path */
  4    53      status_area_ptr pointer,
  4    54      status_ptr pointer;
  4    55 
  4    56 dcl (Link initial (0),
  4    57      Segment initial (1),
  4    58      Directory initial (2)) fixed bin internal static options (constant);
  4    59 						/* values for type fields declared above */
  4    60 
  4    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      328 
      329 
      330      end rw_temp_seg_mgr;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/16/84  1107.3  rw_temp_seg_mgr.pl1               >special_ldd>online>7001-11/16/84>rw_temp_seg_mgr.pl1
325          1    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
326          2    11/16/84  1107.6  rw_table_info.incl.pl1            >special_ldd>online>7001-11/16/84>rw_table_info.incl.pl1
327          3    11/16/84  1107.6  rw_table_control_info.incl.pl1    >special_ldd>online>7001-11/16/84>rw_table_control_info.incl.pl1
328          4    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_caller                               parameter       char                     unaligned dcl 33 ref 41 82 111 149 155 171 171 193
                                                                                  235
a_code                                 parameter       fixed bin(35,0)          dcl 37 set ref 41 49* 57* 62* 140* 149 155 163* 171*
                                                                                  176* 187* 193 201 205* 208* 210* 227* 239*
a_dir                                  parameter       char                     unaligned dcl 34 ref 41 51 53 149
a_ptr                                  parameter       pointer                  dcl 36 set ref 41 149 153 193 197
a_ptrs                                 parameter       pointer                  array dcl 35 set ref 44 45 155 158 159
a_table_info_ptr                       parameter       pointer                  dcl 32 ref 41 149 155 193 201 217
addr                                                   builtin function         dcl 299 ref 45 54 122 153 159 197
area                                   based           area(1024)               dcl 279 ref 71 91 94
area_control                           based           structure                level 1 dcl 1-20
area_info                              based           structure                level 1 dcl 1-7 set ref 228 241
area_infop                      000320 automatic       pointer                  dcl 1-5 set ref 228* 229 230 231 232 233 234 235 236
                                                                                  237 238 239* 241
area_p                          000102 automatic       pointer                  initial dcl 252 set ref 71 91 94 225* 226 240* 252*
areap                    16            based           pointer                  level 2 dcl 1-7 set ref 238*
array_ptr                       000104 automatic       pointer                  dcl 253 set ref 45* 84 134 153* 159* 165 169 181
                                                                                  197*
baseno                                                 builtin function         dcl 299 ref 120
bin                                                    builtin function         dcl 299 ref 120 122
block                                  based           structure                array level 1 dcl 280 set ref 71 93* 93 94
block_ptr                       000106 automatic       pointer                  initial dcl 254 set ref 68 71* 72 79 79 81 82 84 93
                                                                                  94 97* 110 111 112 115 120 124 130 132 134 144 168
                                                                                  169 171 174 178 180 207 207 208 243* 254*
caller                                 based           char(32)                 array level 2 dcl 280 set ref 82* 111* 171 180* 207*
code                            000110 automatic       fixed bin(35,0)          dcl 255 set ref 55* 56 57 60* 61 61 62 115* 116 124*
                                                                                  125 130* 140 144* 174* 176 176
com_err_                        000010 constant        entry                    external dcl 303 ref 207
containing_dir                  000111 automatic       char(168)                unaligned dcl 256 set ref 55* 60*
control                   1            based           structure                level 2 dcl 1-7
define_area_                    000012 constant        entry                    external dcl 304 ref 239
delete_$ptr                     000014 constant        entry                    external dcl 305 ref 144 208
digit                     0(24)        based           bit(3)                   array level 2 packed unaligned dcl 291 ref 122
dim                                                    builtin function         dcl 299 ref 44 158
dir_entryname                   000163 automatic       char(32)                 unaligned dcl 257 set ref 55* 60*
dir_name                        000173 automatic       char(168)                unaligned dcl 258 set ref 51* 53* 55* 115*
dir_uid                         000245 automatic       bit(36)                  unaligned dcl 259 set ref 66* 79 112
ename                           000246 automatic       char(20)                 unaligned dcl 260 set ref 114* 115* 124*
ename2                          000253 automatic       char(32)                 unaligned dcl 261 set ref 113* 114 122* 122 124* 132
error_table_$argerr             000044 external static fixed bin(35,0)          dcl 320 ref 171 187
error_table_$no_s_permission    000046 external static fixed bin(35,0)          dcl 321 ref 61
expand_pathname_                000016 constant        entry                    external dcl 306 ref 55
extend                    1            based           bit(1)                   level 3 packed unaligned dcl 1-7 set ref 230*
found_it                        000263 automatic       bit(1)                   unaligned dcl 262 set ref 166* 167 182* 187
general_work_area_ptr
                         14            based           pointer                  level 2 dcl 3-11 ref 220
get_pdir_                       000020 constant        entry                    external dcl 307 ref 51
get_temp_segment_               000022 constant        entry                    external dcl 308 ref 227
hcs_$chname_seg                 000024 constant        entry                    external dcl 309 ref 124
hcs_$make_seg                   000026 constant        entry                    external dcl 310 ref 115
hcs_$set_safety_sw_seg          000032 constant        entry                    external dcl 312 ref 130
hcs_$status_long                000030 constant        entry                    external dcl 311 ref 60
hcs_$truncate_seg               000034 constant        entry                    external dcl 313 ref 174
i                               000264 automatic       fixed bin(17,0)          dcl 263 in procedure "rw_temp_seg_mgr" set ref 78*
                                                                                  79 79 81 82 84* 164* 165 169 181* 206* 207 207
                                                                                  208*
i                               000342 automatic       fixed bin(17,0)          dcl 107 in procedure "get_new_segments" set ref 109*
                                                                                  110 111 112 115 120 124 130 132 134* 143
info_ptr                        000266 automatic       pointer                  dcl 264 set ref 69 72 95 97 141 210 219* 221 222*
                                                                                  223 225 227 238 240 243 244
j                               000343 automatic       fixed bin(17,0)          dcl 107 in procedure "get_new_segments" set ref 121*
                                                                                  122 122* 143* 144*
j                               000270 automatic       fixed bin(17,0)          dcl 265 in procedure "rw_temp_seg_mgr" set ref 167*
                                                                                  168 169 171 174 178 180*
length                                                 builtin function         dcl 299 ref 171
long                      4     000306 automatic       structure                level 2 dcl 295
min                                                    builtin function         dcl 299 ref 171
n_blocks                        000271 automatic       fixed bin(17,0)          initial dcl 266 set ref 69* 71 78 88 89 93 94 95*
                                                                                  109 141* 167 206 244* 266*
n_found                         000272 automatic       fixed bin(17,0)          dcl 267 set ref 50* 78 83* 83 84 87 88 133* 133 134
n_segs                          000273 automatic       fixed bin(17,0)          dcl 268 set ref 44* 69 78 87 88 152* 158* 164 196*
name                     12            based           char(25)                 array level 2 dcl 280 set ref 132*
new_block                              based           structure                array level 1 dcl 290 ref 91
new_block_ptr                   000274 automatic       pointer                  dcl 269 set ref 91* 93 97
new_blocks                      000276 automatic       fixed bin(17,0)          dcl 270 set ref 88* 91 95
no_freeing                1(04)        based           bit(1)                   level 3 packed unaligned dcl 1-7 set ref 233*
null                                                   builtin function         dcl 299 ref 60 60 68 165 181 211 221 222 222 226 252
                                                                                  254
number_of_temp_segs                    based           fixed bin(17,0)          initial level 2 dcl 286 set ref 69* 95* 141* 222*
                                                                                  244
octal_digits                           based           structure                level 1 dcl 291
old_blocks                      000277 automatic       fixed bin(17,0)          dcl 271 set ref 73* 89* 109 141 143
owner                     2            based           char(32)                 level 2 packed unaligned dcl 1-7 set ref 235*
pad                       1(06)        based           bit(30)                  level 3 packed unaligned dcl 1-7 set ref 236*
ptrs                                   based           pointer                  array dcl 294 set ref 84* 134* 165 169 181*
release_temp_segment_           000036 constant        entry                    external dcl 314 ref 210
sci_ptr                         000300 automatic       pointer                  dcl 272 set ref 218*
seg_block_ptr             2            based           pointer                  initial level 2 dcl 286 set ref 72* 97* 222* 243
segment_number                  000302 automatic       fixed bin(17,0)          dcl 273 set ref 120* 122
segno                                  defined         char(1)                  array unaligned dcl 274 set ref 122*
segptr                   10            based           pointer                  array level 2 dcl 280 set ref 84 115* 120 124* 130*
                                                                                  134 144* 169 174* 208*
size                     13            based           fixed bin(18,0)          level 2 dcl 1-7 set ref 237*
status_branch                          based           structure                level 1 dcl 4-8
status_info                     000306 automatic       structure                level 1 unaligned dcl 295 set ref 54
status_ip                       000304 automatic       pointer                  dcl 275 set ref 54* 60*
substr                                                 builtin function         dcl 299 ref 114 122 132 171
subsystem_control_info_ptr
                         20            based           pointer                  level 2 dcl 3-11 ref 218
sys_info$max_seg_size           000050 external static fixed bin(35,0)          dcl 322 ref 237
system                    1(05)        based           bit(1)                   level 3 packed unaligned dcl 1-7 set ref 234*
table_control_info                     based           structure                level 1 dcl 3-11
table_control_ip                000322 automatic       pointer                  dcl 3-35 set ref 211 217* 218 219 220 223
temp_seg_info                          based           structure                level 1 unaligned dcl 286 set ref 222
temp_seg_info_ptr        16            based           pointer                  level 2 dcl 3-11 set ref 211* 219 223*
uid                      11     000306 automatic       bit(36)                  level 3 in structure "status_info" packed unaligned
                                                                                  dcl 295 in procedure "rw_temp_seg_mgr" set ref 66
uid                      21            based           bit(36)                  array level 2 in structure "block" packed unaligned
                                                                                  dcl 280 in procedure "rw_temp_seg_mgr" set ref 79
                                                                                  112*
unique_bits_                    000040 constant        entry                    external dcl 315 ref 113 113
unique_chars_                   000042 constant        entry                    external dcl 316 ref 113
used                     22            based           bit(1)                   array level 2 dcl 280 set ref 79 81* 110* 168 178*
                                                                                  207
version                                based           fixed bin(17,0)          level 2 dcl 1-7 set ref 229*
work_area                              based           area                     dcl 248 ref 222
work_area_ptr                   000100 automatic       pointer                  dcl 249 in procedure "rw_temp_seg_mgr" set ref 220*
                                                                                  222
work_area_ptr             4            based           pointer                  initial level 2 in structure "temp_seg_info" dcl 286
                                                                                  in procedure "rw_temp_seg_mgr" set ref 210* 222*
                                                                                  225 227* 238 240
zero_on_alloc             1(01)        based           bit(1)                   level 3 packed unaligned dcl 1-7 set ref 231*
zero_on_free              1(02)        based           bit(1)                   level 3 packed unaligned dcl 1-7 set ref 232*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Directory                              internal static fixed bin(17,0)          initial dcl 4-56
Link                                   internal static fixed bin(17,0)          initial dcl 4-56
Segment                                internal static fixed bin(17,0)          initial dcl 4-56
TABLE_INFO_VERSION_1                   internal static char(8)                  initial unaligned dcl 2-22
area_info_version_1                    internal static fixed bin(17,0)          initial dcl 1-3
row_ptrs                               based           structure                level 1 dcl 3-7
row_ptrs_ptr                           automatic       pointer                  dcl 3-33
status_area_ptr                        automatic       pointer                  dcl 4-47
status_entry_names                     based           char(32)                 array dcl 4-47
status_link                            based           structure                level 1 dcl 4-38
status_pathname                        based           char                     dcl 4-47
status_ptr                             automatic       pointer                  dcl 4-47
table_info                             based           structure                level 1 dcl 2-7
table_ip                               automatic       pointer                  dcl 2-20
table_segments_info                    based           structure                level 1 dcl 3-26
table_segments_ip                      automatic       pointer                  dcl 3-34
ti_init_column_count                   automatic       fixed bin(17,0)          dcl 2-21
tsi_init_maximum_number_of_segments    automatic       fixed bin(21,0)          dcl 3-36

NAMES DECLARED BY EXPLICIT CONTEXT.
get_new_segments                001073 constant        entry                    internal dcl 104 ref 74 99
get_segment                     000423 constant        entry                    external dcl 149
get_segments                    000077 constant        entry                    external dcl 41
gts_join                        000140 constant        label                    dcl 47 ref 154
initialize                      001442 constant        entry                    internal dcl 214 ref 47 161 204
release_segment                 000657 constant        entry                    external dcl 193
release_segments                000463 constant        entry                    external dcl 155
rts_join                        000515 constant        label                    dcl 161 ref 198
rw_temp_seg_mgr                 000063 constant        entry                    external dcl 12
terminate                       000711 constant        entry                    external dcl 201
undo                            001363 constant        entry                    internal dcl 137 ref 117 126

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2104        2156    1617        2114
Length      2474    1617        52         301     264           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rw_temp_seg_mgr                     386 external procedure  is an external procedure.  
get_new_segments                        internal procedure  shares stack frame of external procedure rw_temp_seg_mgr.  
undo                                    internal procedure  shares stack frame of external procedure rw_temp_seg_mgr.  
initialize                              internal procedure  shares stack frame of external procedure rw_temp_seg_mgr.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rw_temp_seg_mgr          000100 work_area_ptr               rw_temp_seg_mgr
                         000102 area_p                      rw_temp_seg_mgr
                         000104 array_ptr                   rw_temp_seg_mgr
                         000106 block_ptr                   rw_temp_seg_mgr
                         000110 code                        rw_temp_seg_mgr
                         000111 containing_dir              rw_temp_seg_mgr
                         000163 dir_entryname               rw_temp_seg_mgr
                         000173 dir_name                    rw_temp_seg_mgr
                         000245 dir_uid                     rw_temp_seg_mgr
                         000246 ename                       rw_temp_seg_mgr
                         000253 ename2                      rw_temp_seg_mgr
                         000263 found_it                    rw_temp_seg_mgr
                         000264 i                           rw_temp_seg_mgr
                         000266 info_ptr                    rw_temp_seg_mgr
                         000270 j                           rw_temp_seg_mgr
                         000271 n_blocks                    rw_temp_seg_mgr
                         000272 n_found                     rw_temp_seg_mgr
                         000273 n_segs                      rw_temp_seg_mgr
                         000274 new_block_ptr               rw_temp_seg_mgr
                         000276 new_blocks                  rw_temp_seg_mgr
                         000277 old_blocks                  rw_temp_seg_mgr
                         000300 sci_ptr                     rw_temp_seg_mgr
                         000302 segment_number              rw_temp_seg_mgr
                         000304 status_ip                   rw_temp_seg_mgr
                         000306 status_info                 rw_temp_seg_mgr
                         000320 area_infop                  rw_temp_seg_mgr
                         000322 table_control_ip            rw_temp_seg_mgr
                         000342 i                           get_new_segments
                         000343 j                           get_new_segments

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              shorten_stack       ext_entry
ext_entry_desc      alloc_based         alloc_based_storage free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      define_area_                  delete_$ptr                   expand_pathname_
get_pdir_                     get_temp_segment_             hcs_$chname_seg               hcs_$make_seg
hcs_$set_safety_sw_seg        hcs_$status_long              hcs_$truncate_seg             release_temp_segment_
unique_bits_                  unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$argerr           error_table_$no_s_permission  sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    252 000054       254 000056       266 000057        12 000062        41 000071        44 000125        45 000135
     47 000140        49 000141        50 000142        51 000143        53 000162        54 000165        55 000167
     56 000213        57 000215        58 000216        60 000217        61 000257        62 000264        63 000265
     66 000266        68 000270        69 000274        71 000277        72 000305        73 000307        74 000310
     75 000311        78 000312        79 000324        81 000335        82 000337        83 000346        84 000347
     86 000355        87 000357        88 000362        89 000366        91 000370        93 000376        94 000406
     95 000410        97 000413        99 000417       102 000420       149 000421       152 000451       153 000453
    154 000455       155 000456       158 000502       159 000512       161 000515       163 000516       164 000517
    165 000527       166 000535       167 000536       168 000547       169 000554       171 000565       174 000604
    176 000620       178 000623       180 000626       181 000632       182 000636       186 000640       187 000642
    189 000647       190 000651       193 000652       196 000700       197 000702       198 000704       201 000705
    204 000722       205 000723       206 000724       207 000733       208 001000       209 001037       210 001041
    211 001067       212 001072       104 001073       109 001074       110 001105       111 001111       112 001120
    113 001122       114 001162       115 001166       116 001231       117 001233       118 001234       120 001235
    121 001243       122 001251       123 001263       124 001265       125 001320       126 001322       127 001323
    130 001324       132 001343       133 001351       134 001352       135 001360       148 001362       137 001363
    140 001364       141 001366       143 001371       144 001403       145 001437       147 001441       214 001442
    217 001443       218 001447       219 001451       220 001453       221 001455       222 001461       223 001472
    225 001474       226 001477       227 001503       228 001531       229 001535       230 001537       231 001541
    232 001543       233 001545       234 001547       235 001551       236 001557       237 001561       238 001564
    239 001567       240 001577       241 001602       243 001604       244 001607       245 001611


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
