	COMPILATION LISTING OF SEGMENT cm_put_datum_in_pool
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/03/85  1639.1 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*        This routine puts a datum in the free pool of a control interval.
       10*   It assumes that the caller has already determined that the datum will fit
       11*   in the free pool.  This will put the datum in the file copy of the
       12*   specified control interval (p_element_id.control_interval_id) or on a
       13*   buffered copy of the control interval, depending on whether the entry into
       14*   this routine was from a non-buffered or buffered entry point.
       15*   
       16*        The areas of a control interval that this routine may modify are
       17*   highlighted with *'s, as follows:
       18*   
       19*    ---------------------------------------------------------------
       20*    |        || | | | | | | ||                   ||                |
       21*    | Header || | | Slots | ||     Free pool     ||   Used space   |
       22*    |        || | | | | | | ||   (Un-used space) ||                |
       23*    ----------------------------------------------------------------
       24*     ********      *                     (**)*****(****)
       25*       (1)        (2)                     (4)  (3)  
       26*   
       27*   (1) The start_of_used_space component of bci_header is modified to the 
       28*   location of the start of the new datum. The caller may also have modified
       29*   other components of bci_header and is relying on this routine to actually
       30*   put the modified bci_header back into the file copy of the control interval.
       31*   
       32*   (2) The datum_slot for the datum to put has its length_in_bits component
       33*   and perhaps the is_continuation flag set by this routine.  The 
       34*   offset_in_bytes and is_continued flag are set by the caller.  The 
       35*   length_in_bits is p_datum_contents_length_in_bits plus the length of the
       36*   datum header, if there is one.
       37*   
       38*   (3) This is the actual contents of the datum.  This may actually spill over
       39*   into the used space portion of the control interval if this call is made to
       40*   replace a datum which happened to start at the start of the used space.
       41*   This routine, however, does not make that determination, trusting the caller
       42*   to have correctly calculated the proper offset for the datum.
       43*   
       44*   (4) This is the header of the datum, and is only put if called through the
       45*   $continued or $buffered_continued entry points.  It is a continued_datum
       46*   header if p_element_length_in_bits is non-negative. p_element_length_in_bits
       47*   and p_continuation are used to fill in the continued_datum.header
       48*   (cd_datum_header) structure.  If negative, this indicates the datum
       49*   requires a continued_continuation_datum header (cdcn_datum_header), which 
       50*   only uses p_continuation.
       51*   
       52*        If the datum is to be put into a buffered copy of the control interval
       53*   (i.e., routine was entered through $buffered or $buffered_continued),
       54*   p_ci_buffer_ptr points to the control interval buffer, and, because of
       55*   the construction of the control interval, to bci_header.  p_datum_slot_ptr
       56*   is assumed to point at the datum slot in the control interval buffer.
       57*   Any modifications to bci_header and datum_slot, then, are made directly
       58*   to the control interval buffer.
       59*   
       60*        If the datum is to be put into the file copy of the control interval
       61*   (i.e., routine was entered through $cm_put_datum_in_pool or $continued)
       62*   p_bci_header_ptr and p_datum_slot_ptr are assumed to point to copies of
       63*   the bci_header and datum_slot in the caller's local storage.  Modifications
       64*   made to these structures, and to datum header structures, do not change the
       65*   file copy of the control interval.  The modified structures must be put back
       66*   into the file copy via a call to file_manager_$put.
       67*   
       68**/
       69 
       70 /* HISTORY:
       71*Written by Matthew Pierret.
       72*Modified:
       73*04/13/82 by Matthew Pierret: Fixed bug. Uninitialized element_ptr was being used 
       74*            instead of p_element_ptr.
       75*06/15/82 by Matthew Pierret: Changed to use bci_header, dm_cm_basic_ci.incl.pl1,
       76*            ignore non-addressable portion of CI, new calling sequence of 
       77*            cm_add_ci_part.
       78*08/04/82 by Matthew Pierret: Removed calls to cm_add_ci_part, making that code
       79*            in-line.
       80*10/20/82 by Matthew Pierret:  Converted to use file_manager_. Changed
       81*            from element_(ptr length_in_bytes length_in_bits) to
       82*            datum_contents_=.
       83*01/04/83 by Matthew Pierret: Added $buffered and $buffered_continued to do
       84*            puts into a supplied ci buffer.
       85*01/21/83 by Matthew Pierret: Removed an invalid use of p_bci_header_ptr when
       86*            entered through $buffered or $buffered_continued. These entries
       87*            do not take that parameter.
       88*            Changed based_ci_string character overlay to be based_ci, a bit (9)
       89*            array.  This was to remove the "addr(substr())" construct, which
       90*            is not guaranteed to be correct in all cases.
       91*10/03/84 by Matthew Pierret:  Removed dm_cm_entry_dcls.incl.pl1, ceil and
       92*            null.  Changed calculation of bits to bytes from
       93*            bytes = ceil (divide (bits, BITS_PER_BYTES, 35, 18)) to
       94*            bytes = divide (bits + BITS_PER_BYTE - 1, BITS_PER_BYTE, 17, 0),
       95*            the latter being more efficient.  Added size, unspec and 
       96*            DESCRIPTION section.  Also changed buffer upon which ci_parts
       97*            is based from automatic__parts_buffer to my_ci_parts, which is
       98*            a structure "like"-ed to ci_parts.
       99*10/05/84 by Matthew Pierret:  Changed to increment the scattered_free_space
      100*            if the datum already existed (datum_slot.offset_in_bytes is not
      101*            equal to FREE_SLOT) and the existing datum is not at the beginning 
      102*            of the used space (datum_slot.offset_in_bytes is equal to 
      103*            bci_header.start_of_used_space).  If it is at the beginning of
      104*            the used space, the space it takes up is recovered immediately.
      105*12/03/84 by Matthew Pierret:  Added the local cdcn_datum_header and
      106*            cd_datum_header structures which were removed from
      107*            dm_cm_datum.incl.pl1
      108**/
      109 
      110 /* format: style2,ind3 */
      111 
      112 cm_put_datum_in_pool:
      113    proc (p_file_opening_id, p_element_id, p_datum_contents_ptr, p_datum_contents_length_in_bits, p_datum_slot_ptr,
      114         p_bci_header_ptr, p_code);
      115 
      116 /* START OF DECLARATIONS */
      117 /* Parameter */
      118 
      119       dcl	    p_file_opening_id      bit (36) aligned;
      120       dcl	    p_element_id	       bit (36) aligned;
      121       dcl	    p_datum_contents_ptr   ptr;
      122       dcl	    p_datum_contents_length_in_bits
      123 			       fixed bin (35);
      124       dcl	    p_datum_slot_ptr       ptr;
      125       dcl	    p_bci_header_ptr       ptr;
      126       dcl	    p_ci_buffer_ptr	       ptr;
      127       dcl	    p_element_length_in_bits
      128 			       fixed bin (35);
      129       dcl	    p_continuation	       bit (36) aligned;
      130       dcl	    p_code	       fixed bin (35);
      131 
      132 /* Automatic */
      133 
      134       dcl	    is_buffered	       bit (1) aligned init ("0"b);
      135       dcl	    1 my_ci_parts	       aligned,
      136 	      2 number_of_parts    fixed bin,
      137 	      2 part	       (4) like ci_parts.part;
      138       dcl	    based_byte_string_length
      139 			       fixed bin (35) init (0);
      140       dcl	    datum_contents_length_in_bytes
      141 			       fixed bin (17) init (0);
      142       dcl	    datum_header_length_in_bytes
      143 			       fixed bin (17) init (0);
      144       dcl	    old_datum_length_in_bytes
      145 			       fixed bin (17) init (0);
      146       dcl	    (ci_datum_contents_ptr, ci_datum_header_ptr, datum_header_ptr)
      147 			       ptr;
      148 
      149       dcl	    1 cd_datum_header      aligned like continued_datum.header;
      150       dcl	    1 cdcn_datum_header    aligned like continued_continuation_datum.header;
      151 
      152 /* Based */
      153 
      154       dcl	    1 based_ci	       based (bci_header_ptr),
      155 	      2 byte	       (CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES) bit (9) unaligned;
      156       dcl	    based_byte_string      char (based_byte_string_length) based;
      157 
      158 /* Builtin */
      159 
      160       dcl	    (addr, divide, null, size, unspec)
      161 			       builtin;
      162 
      163 /* Controlled */
      164 /* Constant */
      165 
      166       dcl	    BITS_PER_BYTE	       fixed bin init (9) int static options (constant);
      167       dcl	    BYTES_PER_WORD	       fixed bin init (4) int static options (constant);
      168       dcl	    HEADER_PART_IDX	       fixed bin init (1) int static options (constant);
      169       dcl	    DATUM_SLOT_PART_IDX    fixed bin init (2) int static options (constant);
      170       dcl	    DATUM_CONTENTS_PART_IDX
      171 			       fixed bin init (3) int static options (constant);
      172       dcl	    DATUM_HEADER_PART_IDX  fixed bin init (4) int static options (constant);
      173 
      174 /* Entry */
      175 
      176       dcl	    file_manager_$put      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
      177 
      178 /* External */
      179 /* END OF DECLARATIONS */
      180 
      181       bci_header_ptr = p_bci_header_ptr;
      182       datum_slot_ptr = p_datum_slot_ptr;
      183 
      184       goto JOIN;
      185 
      186 buffered:
      187    entry (p_ci_buffer_ptr, p_datum_contents_ptr, p_datum_contents_length_in_bits, p_datum_slot_ptr, p_code);
      188 
      189       bci_header_ptr = p_ci_buffer_ptr;
      190       datum_slot_ptr = p_datum_slot_ptr;
      191       is_buffered = "1"b;
      192 
      193       goto JOIN;
      194 
      195 continued:
      196    entry (p_file_opening_id, p_element_id, p_datum_contents_ptr, p_datum_contents_length_in_bits, p_datum_slot_ptr,
      197         p_bci_header_ptr, p_element_length_in_bits, p_continuation, p_code);
      198 
      199       bci_header_ptr = p_bci_header_ptr;
      200 
      201       goto CD_JOIN;
      202 
      203 buffered_continued:
      204    entry (p_ci_buffer_ptr, p_datum_contents_ptr, p_datum_contents_length_in_bits, p_datum_slot_ptr,
      205         p_element_length_in_bits, p_continuation, p_code);
      206 
      207       bci_header_ptr = p_ci_buffer_ptr;
      208       is_buffered = "1"b;
      209 
      210 CD_JOIN:
      211       datum_slot_ptr = p_datum_slot_ptr;
      212 
      213       datum_slot.flags.is_continued = "1"b;
      214 
      215       if p_element_length_in_bits < 0
      216       then
      217          do;
      218 	  datum_slot.flags.is_continuation = "1"b;
      219 	  datum_header_length_in_bytes = CDCN_DATUM_HEADER_LENGTH_IN_BYTES;
      220 
      221 	  unspec (cdcn_datum_header.continuation) = p_continuation;
      222 	  datum_header_ptr = addr (cdcn_datum_header);
      223          end;
      224       else
      225          do;
      226 	  datum_slot.flags.is_continuation = "0"b;
      227 	  datum_header_length_in_bytes = CD_DATUM_HEADER_LENGTH_IN_BYTES;
      228 
      229 	  cd_datum_header.full_length = p_element_length_in_bits;
      230 	  unspec (cd_datum_header.continuation) = p_continuation;
      231 
      232 	  datum_header_ptr = addr (cd_datum_header);
      233          end;
      234 
      235       goto JOIN;
      236 
      237 JOIN:
      238       p_code = 0;
      239 
      240       datum_contents_length_in_bits = p_datum_contents_length_in_bits;
      241       datum_contents_length_in_bytes = divide (datum_contents_length_in_bits + BITS_PER_BYTE - 1, BITS_PER_BYTE, 17, 0);
      242 
      243       if datum_slot.offset_in_bytes = bci_header.start_of_used_space
      244       then datum_slot.offset_in_bytes =
      245 	      datum_slot.offset_in_bytes - (datum_contents_length_in_bytes + datum_header_length_in_bytes)
      246 	      + divide (datum_slot.length_in_bits + BITS_PER_BYTE - 1, BITS_PER_BYTE, 17, 0);
      247       else
      248          do;
      249 	  if datum_slot.offset_in_bytes ^= FREE_SLOT
      250 	  then bci_header.scattered_free_space =
      251 		  bci_header.scattered_free_space
      252 		  + divide (datum_slot.length_in_bits + BITS_PER_BYTE - 1, BITS_PER_BYTE, 17, 0);
      253 	  else /* no old space to remember */
      254 	       ;
      255 
      256 	  datum_slot.offset_in_bytes =
      257 	       bci_header.start_of_used_space - (datum_contents_length_in_bytes + datum_header_length_in_bytes);
      258          end;
      259 
      260       datum_slot.length_in_bits = datum_header_length_in_bytes * BITS_PER_BYTE + datum_contents_length_in_bits;
      261       bci_header.start_of_used_space = datum_slot.offset_in_bytes;
      262 
      263       if is_buffered
      264       then
      265 COPY_INTO_BUFFERED_CI:
      266          do;
      267 
      268 	  based_byte_string_length = datum_contents_length_in_bytes;
      269 	  ci_datum_contents_ptr = addr (based_ci.byte (datum_slot.offset_in_bytes + datum_header_length_in_bytes + 1));
      270 	  ci_datum_contents_ptr -> based_byte_string = p_datum_contents_ptr -> based_byte_string;
      271 
      272 	  if datum_header_length_in_bytes > 0
      273 	  then
      274 	     do;
      275 	        based_byte_string_length = datum_header_length_in_bytes;
      276 	        ci_datum_header_ptr = addr (based_ci.byte (datum_slot.offset_in_bytes + 1));
      277 	        ci_datum_header_ptr -> based_byte_string = datum_header_ptr -> based_byte_string;
      278 	     end;
      279 
      280          end COPY_INTO_BUFFERED_CI;
      281       else
      282 COPY_INTO_FILE_CI:
      283          do;
      284 
      285 	  element_id_string = p_element_id;
      286 
      287 	  ci_parts_ptr = addr (my_ci_parts);
      288 	  ci_parts.number_of_parts = 3;
      289 
      290 	  ci_parts.part (DATUM_SLOT_PART_IDX).offset_in_bytes =
      291 	       BYTES_PER_WORD * ((element_id.index - 1) + size (bci_header));
      292 	  ci_parts.part (DATUM_SLOT_PART_IDX).length_in_bytes = BYTES_PER_WORD;
      293 	  ci_parts.part (DATUM_SLOT_PART_IDX).local_ptr = datum_slot_ptr;
      294 
      295 	  ci_parts.part (HEADER_PART_IDX).offset_in_bytes = 0;
      296 	  ci_parts.part (HEADER_PART_IDX).length_in_bytes = size (bci_header) * BYTES_PER_WORD;
      297 	  ci_parts.part (HEADER_PART_IDX).local_ptr = bci_header_ptr;
      298 
      299 	  ci_parts.part (DATUM_CONTENTS_PART_IDX).offset_in_bytes =
      300 	       datum_slot.offset_in_bytes + datum_header_length_in_bytes;
      301 	  ci_parts.part (DATUM_CONTENTS_PART_IDX).length_in_bytes = datum_contents_length_in_bytes;
      302 	  ci_parts.part (DATUM_CONTENTS_PART_IDX).local_ptr = p_datum_contents_ptr;
      303 
      304 	  if datum_slot.is_continued
      305 	  then
      306 	     do;
      307 	        ci_parts.number_of_parts = 4;
      308 
      309 	        ci_parts.part (DATUM_HEADER_PART_IDX).offset_in_bytes = datum_slot.offset_in_bytes;
      310 	        ci_parts.part (DATUM_HEADER_PART_IDX).length_in_bytes = datum_header_length_in_bytes;
      311 	        ci_parts.part (DATUM_HEADER_PART_IDX).local_ptr = datum_header_ptr;
      312 
      313 	     end;
      314 
      315 	  call file_manager_$put (p_file_opening_id, (element_id.control_interval_id), ci_parts_ptr, p_code);
      316 
      317          end COPY_INTO_FILE_CI;
      318 
      319       return;
      320 
      321 
  1     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        The collection_manager_ manages the structure of the addressable
  1     6*   portion of a control interval.  The addressable portion is that portion of
  1     7*   a control interval which the file_manager_ will allow the
  1     8*   collection_manager_ to address.  In this description control interval will
  1     9*   be used to mean the addressable portion of a control interval.
  1    10*   
  1    11*        A control interval is divided into four parts: the header, the datum
  1    12*   position table (also known as the slot table or slots), un-used space and
  1    13*   used space.  The beginning of the header is at offset 0, and the end of the
  1    14*   used space is at the end of the control interval (curently offset 4072).
  1    15*   Pictoriarly, a control interval is structured as follows:
  1    16*   
  1    17*   ----------------------------------------------------------------------
  1    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  1    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  1    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  1    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  1    22*   ----------------------------------------------------------------------
  1    23*                                           ^ ^    ^      ^    ^  ^   ^
  1    24*                                           | |    |      |    |  |   |
  1    25*                                           | |...........|.......|...|
  1    26*                        start of used space|      |           |      |
  1    27*                                                  |           |  each|
  1    28*                                          scattered free space|  is a used
  1    29*                                                                 datum
  1    30*   
  1    31*      The basic_control_interval structure describes the header
  1    32*   (basic_control_interval.header, bci_header) and the slots
  1    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  1    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  1    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  1    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  1    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  1    38**/
  1    39 
  1    40 /* HISTORY:
  1    41*Written by Matthew Pierret, 02/07/82.
  1    42*Modified:
  1    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  1    44*            and its sub-structures.
  1    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  1    46*            basic_ci_header to bci_header. Added previous_control_interval.
  1    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  1    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  1    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  1    50*            is not used.
  1    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  1    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  1    53**/
  1    54 
  1    55 /* format: style2 */
  1    56      dcl	   1 basic_control_interval
  1    57 			      aligned based (basic_control_interval_ptr),
  1    58 	     2 header	      like bci_header,
  1    59 	     2 datum_position_table
  1    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  1    61 
  1    62 
  1    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  1    64 	     2 layout_type	      char (4) aligned,
  1    65 	     2 collection_id      bit (36) aligned,
  1    66 	     2 next_control_interval
  1    67 			      fixed bin (24) uns unal,
  1    68 	     2 previous_control_interval
  1    69 			      fixed bin (24) uns unal,
  1    70 	     2 flags	      unal,
  1    71 	       3 continuation_datum_is_present
  1    72 			      bit (1) unal,
  1    73 	       3 free_slot_is_present
  1    74 			      bit (1) unal,
  1    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  1    76 	     2 scattered_free_space
  1    77 			      fixed bin (17) unal,
  1    78 	     2 start_of_used_space
  1    79 			      fixed bin (17) unal,
  1    80 	     2 number_of_datums   fixed bin (17) unal;
  1    81 
  1    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  1    83 	     2 flags	      unal,
  1    84 	       3 special_format_datum
  1    85 			      bit (1) unal,		/* reserved */
  1    86 	       3 is_continued     bit (1) unal,
  1    87 	       3 is_continuation  bit (1) unal,
  1    88 	       3 mbz	      bit (1) unal,		/* reserved */
  1    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  1    90 	     2 length_in_bits     fixed bin (17) uns unal;
  1    91 
  1    92      dcl	   basic_control_interval_ptr
  1    93 			      ptr;
  1    94      dcl	   bci_header_ptr	      ptr;
  1    95      dcl	   datum_slot_ptr	      ptr;
  1    96 
  1    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  1    98 
  1    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      322 
      323 
  2     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*   Contains constants useful in describing parts of a basic control interval.
  2     6**/
  2     7 
  2     8 /* HISTORY:
  2     9*Written by Matthew Pierret, 09/20/84.
  2    10*Modified:
  2    11**/
  2    12 
  2    13      dcl	   FREE_SLOT	      init (0) fixed bin (15) uns internal static options (constant);
  2    14      dcl	   BCI_HEADER_LENGTH_IN_BYTES
  2    15 			      init (20) fixed bin internal static options (constant);
  2    16      dcl	   DATUM_POSITION_TABLE_OFFSET_IN_BYTES
  2    17 			      init (20) fixed bin internal static options (constant);
  2    18 
  2    19 
  2    20 /* END INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
      324 
      325 
  3     1 /* BEGIN INCLUDE FILE dm_cm_datum.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*        This include file contains the declarations of datum structures.
  3     5*   There are four tyes of datums: your ordinary, run-of-the-mill datum
  3     6*   (Datum); a continuation datum (CN Datum), which is a continuation of
  3     7*   another datum; a continued datum (CD Datum), which is continued (has a
  3     8*   continuation datum) but is not a continuation itself; and a continued
  3     9*   continuation datum (CDCN Datum), which is both continued and is a
  3    10*   continuation.  To illustrate, datums can be pieced combined in the
  3    11*   following ways:
  3    12*   
  3    13*   1) Datum alone.
  3    14*   
  3    15*   2) CD Datum -> CN Datum.
  3    16*   
  3    17*   3) CD Datum -> CDCN Datum {-> CDCN Datum -> ...-> CDCN Datum} -> CN Datum.
  3    18*
  3    19*   continued_datum and continued_continuation_datum each contains a header
  3    20*   which includes the identifier of the datum which is its continuation.
  3    21*   continued_datum.header.full_length is the length in bits of the entire
  3    22*   element, i.e., the addition of the length of contents structure component
  3    23*   of all of the datums from CD Datum to CN Datum.
  3    24**/
  3    25 
  3    26 /* HISTORY:
  3    27*Written by Matthew Pierret, 02/07/82.
  3    28*Modified:
  3    29*03/25/82 by Matthew Pierret: Changed all datum structures to be unaligned.
  3    30*06/14/82 by Matthew Pierret: Added DATUM_HEADER_LENGTH_IN_BYTES.
  3    31*08/04/82 by Matthew Pierret: Added DATUM_HEADER_LENGTH_IN_BITS.
  3    32*10/20/82 by Matthew Pierret:  Split into two include files, this one and
  3    33*            dm_cm_datum_constants.  The latter holds only and all constants
  3    34*            formerly in this include file.
  3    35*10/29/82 by Matthew Pierret:  Removed datum headers.
  3    36*09/18/84 by Matthew Pierret:  Added DESCRIPTION section.  Added datum and
  3    37*            continuation_datum (mainly for illustration).
  3    38*12/03/84 by Matthew Pierret:  Removed the non-based structures
  3    39*            (cd cdcn)_datum_headers.
  3    40**/
  3    41 
  3    42 /* format: style2,ll79,ind3 */
  3    43 
  3    44      dcl	   1 datum	      unaligned based (datum_ptr),
  3    45 	     2 contents	      bit (datum_contents_length_in_bits);
  3    46 
  3    47      dcl	   1 continuation_datum   unaligned based (datum_ptr),
  3    48 	     2 contents	      bit (datum_contents_length_in_bits);
  3    49 
  3    50      dcl	   1 continued_datum      unaligned based (datum_ptr),
  3    51 	     2 header,
  3    52 	       3 full_length      fixed bin (35),
  3    53 	       3 continuation     like datum_id,
  3    54 	     2 contents	      bit (datum_contents_length_in_bits);
  3    55 
  3    56      dcl	   1 continued_continuation_datum
  3    57 			      unaligned based (datum_ptr),
  3    58 	     2 header,
  3    59 	       3 continuation     like datum_id,
  3    60 	     2 contents	      bit (datum_contents_length_in_bits);
  3    61 
  3    62      dcl	   1 datum_id	      aligned based (datum_id_ptr),
  3    63 	     2 control_interval_id
  3    64 			      fixed bin (24) unal uns,
  3    65 	     2 index	      fixed bin (12) unal uns;
  3    66 
  3    67      dcl	   datum_ptr	      ptr init (null ());
  3    68      dcl	   datum_id_ptr	      ptr init (null ());
  3    69      dcl	   datum_contents_length_in_bits
  3    70 			      fixed bin (35) init (-1);
  3    71 
  3    72 
  3    73 
  3    74 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      326 
      327 
  4     1 /* BEGIN INCLUDE FILE dm_cm_datum_constants.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*        Contains constants describing the extents of datums and datum
  4     5*   headers.  The datum headers are described in dm_cm_datum.incl.pl1.
  4     6*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES is the byte length of the largest
  4     7*   datum that can be stored in a control interval, allowing for the largest
  4     8*   possibledatum header. MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS is the same
  4     9*   in bits instead of bytes.  MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  4    10*   is the smallest length in bits which requires 
  4    11*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES bytes to store.
  4    12**/
  4    13 
  4    14 /*
  4    15*HISTORY:
  4    16*Written by Matthew Pierret, 02/07/82.
  4    17*Modified:
  4    18*10/29/82 by Matthew Pierret:  Removed DATUM_HEADER*.
  4    19*11/02/82 by Matthew Pierret:  Added maximum datum contents lengths.
  4    20*12/01/82 by Lindsey Spratt:   Corrected values for datum header lengths.
  4    21*09/18/84 by Matthew Pierret:  Corrected values for maximum lengths. Added
  4    22*            MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS.  Added
  4    23*            DESCRIPTION section.
  4    24**/
  4    25 
  4    26 /* format: style2,ind3,ll79 */
  4    27      dcl	   CD_DATUM_HEADER_LENGTH_IN_BYTES
  4    28 			      fixed bin init (8) internal static
  4    29 			      options (constant);
  4    30 
  4    31      dcl	   CD_DATUM_HEADER_LENGTH_IN_BITS
  4    32 			      fixed bin init (72) internal static
  4    33 			      options (constant);
  4    34 
  4    35      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BYTES
  4    36 			      init (4) fixed bin int static
  4    37 			      options (constant);
  4    38 
  4    39      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BITS
  4    40 			      init (36) fixed bin int static
  4    41 			      options (constant);
  4    42 
  4    43      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  4    44 			      init (36360) fixed bin (35) internal
  4    45 			      static options (constant);
  4    46 
  4    47      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES
  4    48 			      init (4040) fixed bin (35) internal
  4    49 			      static options (constant);
  4    50 
  4    51      dcl	   MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  4    52 			      init (36352) fixed bin (35) internal
  4    53 			      static options (constant);
  4    54 
  4    55 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      328 
      329 
  5     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        Contains the declaration of an element identifier.  Element
  5     6*   identifiers consist of two parts, the id (number) of the control interval
  5     7*   in which the element resides, and the index into the slot table of
  5     8*   the element in the control interval.  The declaration of the element_id 
  5     9*   structure reflects this division of the element identifier.  The structure 
  5    10*   is based on the automatic bit string element_id_string because programs
  5    11*   generally pass bit strings (element_id_string) to each other, then 
  5    12*   interpret the bit string by overlaying the element_id structure ony if
  5    13*   it is necessary to access the parts of the id.  Basing element_id on
  5    14*   addr(element_id_string) instead of on a pointer removes the necessity
  5    15*   for always setting that pointer explicitly and guarantees that changes
  5    16*   made to the string or structure do not get inconsistent.
  5    17*
  5    18*   Changes made to element_id must also be made to datum_id, declared in 
  5    19*   dm_cm_datum.incl.pl1.
  5    20**/
  5    21 
  5    22 /* HISTORY:
  5    23*Written by Matthew Pierret, 04/01/82.
  5    24*Modified:
  5    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  5    26**/
  5    27 
  5    28 /* format: style2,ind3,ll79 */
  5    29 
  5    30      dcl	   element_id_string      bit (36) aligned;
  5    31 
  5    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  5    33 	     2 control_interval_id
  5    34 			      fixed bin (24) unal unsigned,
  5    35 	     2 index	      fixed bin (12) unal unsigned;
  5    36 
  5    37 
  5    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      330 
      331 
  6     1 /*  BEGIN INCLUDE FILE:  dm_ci_parts.incl.pl1  */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*        This include file contains the ci_parts structure.  This structure
  6     6*   is used across the file_manager_ interface to specify the parts of a
  6     7*   control interval to get or put.  If the number_of parts is equal to 0,
  6     8*   modules which take ci_parts interpret this case to mean to do everything
  6     9*   except the actual requested operation, i.e., lock the control interval
  6    10*   but don't get anything.  offset_in_bytes is the 0-originned offset in
  6    11*   bytes from the beginning of the addressable portion of the control interval.
  6    12*   An offset_in_bytes which is in the addressable portion is in error.
  6    13*   Likewise, if offset_in_bytes + length_in_bytes is outside of the addressable
  6    14*   portion, it is in error.
  6    15**/
  6    16 
  6    17 /* HISTORY:
  6    18*Written by Matthew Pierret, 01/28/82.
  6    19*  (01/28/82 Andre Bensoussan, Design.)
  6    20*Modified:
  6    21*11/07/84 by Matthew Pierret:  To add must_be_zero, initial attributes on
  6    22*            automatic storge.
  6    23**/
  6    24 
  6    25 /* format: style2,ind3 */
  6    26 
  6    27      dcl	   1 ci_parts	      aligned based (ci_parts_ptr),
  6    28 	     2 number_of_parts    fixed bin (17),
  6    29 	     2 must_be_zero	      fixed bin,
  6    30 	     2 part	      (cip_number_of_parts refer (ci_parts.number_of_parts)),
  6    31 	       3 offset_in_bytes  fixed bin (17),
  6    32 	       3 length_in_bytes  fixed bin (17),
  6    33 	       3 local_ptr	      ptr;
  6    34 
  6    35      dcl	   ci_parts_ptr	      ptr init (null ());
  6    36      dcl	   cip_number_of_parts    fixed bin (17) init (0);
  6    37 
  6    38 
  6    39 /*  BEGIN INCLUDE FILE:   dm_ci_parts.incl.pl1   */
      332 
      333 
  7     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*       This include file contains constants which are the length in bytes
  7     5*   of the addressable portion of a control interval.  The addressable portion
  7     6*   is that part of the control interval which callers of file_manager_
  7     7*   may access, specifically, everything between the end of the control
  7     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
  7     9*   Control interval 0 is slightly different, as it also contains an 
  7    10*   unaddressable portion in which it maintains the file attributes.  For
  7    11*   control interval 0 the addressable portion is everything between the end
  7    12*   of the control interval header and the beginning of the file attributes.
  7    13**/
  7    14 
  7    15 /* HISTORY:
  7    16*Written by Matthew Pierret, 11/02/84.
  7    17*Modified:
  7    18**/
  7    19 
  7    20 /* format: style2,ind3 */
  7    21 
  7    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
  7    23 			      fixed bin (17) init (4072) int static options (constant);
  7    24 
  7    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
  7    26 			      fixed bin (17) init (3176) int static options (constant);
  7    27 
  7    28 
  7    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
  7    30 
  7    31      dcl	   CI_0_ADDRESSABLE_LENGTH
  7    32 			      fixed bin (17) init (3176) int static options (constant);
  7    33 
  7    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
      334 
      335 
      336    end cm_put_datum_in_pool;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/03/85  1149.0  cm_put_datum_in_pool.pl1          >spec>temp>famis1>cm_put_datum_in_pool.pl1
322          1    01/03/85  1003.0  dm_cm_basic_ci.incl.pl1           >spec>temp>famis1>dm_cm_basic_ci.incl.pl1
324          2    01/03/85  1003.0  dm_cm_basic_ci_const.incl.pl1     >spec>temp>famis1>dm_cm_basic_ci_const.incl.pl1
326          3    01/03/85  1005.4  dm_cm_datum.incl.pl1              >spec>temp>famis1>dm_cm_datum.incl.pl1
328          4    01/03/85  1003.1  dm_cm_datum_constants.incl.pl1    >spec>temp>famis1>dm_cm_datum_constants.incl.pl1
330          5    01/03/85  1003.2  dm_element_id.incl.pl1            >spec>temp>famis1>dm_element_id.incl.pl1
332          6    01/03/85  1005.2  dm_ci_parts.incl.pl1              >spec>temp>famis1>dm_ci_parts.incl.pl1
334          7    01/03/85  1005.2  dm_ci_lengths.incl.pl1            >spec>temp>famis1>dm_ci_lengths.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BITS_PER_BYTE                   000525 constant        fixed bin(17,0)          initial dcl 166 ref 241 241 243 243 249 249 260
BYTES_PER_WORD                         constant        fixed bin(17,0)          initial dcl 167 ref 290 292 296
CDCN_DATUM_HEADER_LENGTH_IN_BYTES      constant        fixed bin(17,0)          initial dcl 4-35 ref 219
CD_DATUM_HEADER_LENGTH_IN_BYTES        constant        fixed bin(17,0)          initial dcl 4-27 ref 227
DATUM_CONTENTS_PART_IDX                constant        fixed bin(17,0)          initial dcl 170 ref 299 301 302
DATUM_HEADER_PART_IDX                  constant        fixed bin(17,0)          initial dcl 172 ref 309 310 311
DATUM_SLOT_PART_IDX                    constant        fixed bin(17,0)          initial dcl 169 ref 290 292 293
FREE_SLOT                              constant        fixed bin(15,0)          initial unsigned dcl 2-13 ref 249
HEADER_PART_IDX                        constant        fixed bin(17,0)          initial dcl 168 ref 295 296 297
addr                                                   builtin function         dcl 160 ref 222 232 269 276 287 290 315
based_byte_string                      based           char                     unaligned dcl 156 set ref 270* 270 277* 277
based_byte_string_length        000124 automatic       fixed bin(35,0)          initial dcl 138 set ref 138* 268* 270 270 275* 277
                                                                                  277
based_ci                               based           structure                level 1 packed unaligned dcl 154
bci_header                             based           structure                level 1 dcl 1-63 set ref 290 296
bci_header_ptr                  000142 automatic       pointer                  dcl 1-94 set ref 181* 189* 199* 207* 243 249 249 256
                                                                                  261 269 276 290 296 297
byte                                   based           bit(9)                   array level 2 packed unaligned dcl 154 set ref 269
                                                                                  276
cd_datum_header                 000136 automatic       structure                level 1 dcl 149 set ref 232
cdcn_datum_header               000140 automatic       structure                level 1 dcl 150 set ref 222
ci_datum_contents_ptr           000130 automatic       pointer                  dcl 146 set ref 269* 270
ci_datum_header_ptr             000132 automatic       pointer                  dcl 146 set ref 276* 277
ci_parts                               based           structure                level 1 dcl 6-27
ci_parts_ptr                    000154 automatic       pointer                  initial dcl 6-35 set ref 287* 288 290 292 293 295
                                                                                  296 297 299 301 302 307 309 310 311 315* 6-35*
cip_number_of_parts             000156 automatic       fixed bin(17,0)          initial dcl 6-36 set ref 6-36*
continuation              1     000136 automatic       structure                level 2 in structure "cd_datum_header" dcl 149
                                                                                  in procedure "cm_put_datum_in_pool" set ref 230*
continuation                    000140 automatic       structure                level 2 in structure "cdcn_datum_header" dcl 150
                                                                                  in procedure "cm_put_datum_in_pool" set ref 221*
continued_continuation_datum           based           structure                level 1 packed unaligned dcl 3-56
continued_datum                        based           structure                level 1 packed unaligned dcl 3-50
control_interval_id                    based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 5-32 ref 315
datum_contents_length_in_bits   000152 automatic       fixed bin(35,0)          initial dcl 3-69 set ref 240* 241 260 3-69*
datum_contents_length_in_bytes  000125 automatic       fixed bin(17,0)          initial dcl 140 set ref 140* 241* 243 256 268 301
datum_header_length_in_bytes    000126 automatic       fixed bin(17,0)          initial dcl 142 set ref 142* 219* 227* 243 256 260
                                                                                  269 272 275 299 310
datum_header_ptr                000134 automatic       pointer                  dcl 146 set ref 222* 232* 277 311
datum_id                               based           structure                level 1 dcl 3-62
datum_id_ptr                    000150 automatic       pointer                  initial dcl 3-68 set ref 3-68*
datum_ptr                       000146 automatic       pointer                  initial dcl 3-67 set ref 3-67*
datum_slot                             based           structure                level 1 dcl 1-82
datum_slot_ptr                  000144 automatic       pointer                  dcl 1-95 set ref 182* 190* 210* 213 218 226 243 243
                                                                                  243 243 249 249 256 260 261 269 276 293 299 304
                                                                                  309
divide                                                 builtin function         dcl 160 ref 241 243 249
element_id                             based           structure                level 1 dcl 5-32
element_id_string               000153 automatic       bit(36)                  dcl 5-30 set ref 285* 290 315
file_manager_$put               000010 constant        entry                    external dcl 176 ref 315
flags                                  based           structure                level 2 packed unaligned dcl 1-82
full_length                     000136 automatic       fixed bin(35,0)          level 2 dcl 149 set ref 229*
header                                 based           structure                level 2 in structure "continued_datum" packed
                                                                                  unaligned dcl 3-50 in procedure
                                                                                  "cm_put_datum_in_pool"
header                                 based           structure                level 2 in structure "continued_continuation_datum"
                                                                                  packed unaligned dcl 3-56 in procedure
                                                                                  "cm_put_datum_in_pool"
index                     0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 5-32 ref 290
is_buffered                     000100 automatic       bit(1)                   initial dcl 134 set ref 134* 191* 208* 263
is_continuation           0(02)        based           bit(1)                   level 3 packed unaligned dcl 1-82 set ref 218* 226*
is_continued              0(01)        based           bit(1)                   level 3 packed unaligned dcl 1-82 set ref 213* 304
length_in_bits            0(19)        based           fixed bin(17,0)          level 2 packed unsigned unaligned dcl 1-82 set ref
                                                                                  243 249 260*
length_in_bytes           3            based           fixed bin(17,0)          array level 3 dcl 6-27 set ref 292* 296* 301* 310*
local_ptr                 4            based           pointer                  array level 3 dcl 6-27 set ref 293* 297* 302* 311*
my_ci_parts                     000102 automatic       structure                level 1 dcl 135 set ref 287
null                                                   builtin function         dcl 160 ref 3-67 3-68 6-35
number_of_parts                        based           fixed bin(17,0)          level 2 dcl 6-27 set ref 288* 307*
offset_in_bytes           2            based           fixed bin(17,0)          array level 3 in structure "ci_parts" dcl 6-27
                                                                                  in procedure "cm_put_datum_in_pool" set ref 290*
                                                                                  295* 299* 309*
offset_in_bytes           0(04)        based           fixed bin(15,0)          level 2 in structure "datum_slot" packed unsigned
                                                                                  unaligned dcl 1-82 in procedure
                                                                                  "cm_put_datum_in_pool" set ref 243 243* 243 249
                                                                                  256* 261 269 276 299 309
old_datum_length_in_bytes       000127 automatic       fixed bin(17,0)          initial dcl 144 set ref 144*
p_bci_header_ptr                       parameter       pointer                  dcl 125 ref 112 181 195 199
p_ci_buffer_ptr                        parameter       pointer                  dcl 126 ref 186 189 203 207
p_code                                 parameter       fixed bin(35,0)          dcl 130 set ref 112 186 195 203 237* 315*
p_continuation                         parameter       bit(36)                  dcl 129 ref 195 203 221 230
p_datum_contents_length_in_bits        parameter       fixed bin(35,0)          dcl 122 ref 112 186 195 203 240
p_datum_contents_ptr                   parameter       pointer                  dcl 121 ref 112 186 195 203 270 302
p_datum_slot_ptr                       parameter       pointer                  dcl 124 ref 112 182 186 190 195 203 210
p_element_id                           parameter       bit(36)                  dcl 120 ref 112 195 285
p_element_length_in_bits               parameter       fixed bin(35,0)          dcl 127 ref 195 203 215 229
p_file_opening_id                      parameter       bit(36)                  dcl 119 set ref 112 195 315*
part                      2            based           structure                array level 2 dcl 6-27
scattered_free_space      3(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-63 set ref 249* 249
size                                                   builtin function         dcl 160 ref 290 296
start_of_used_space       4            based           fixed bin(17,0)          level 2 packed unaligned dcl 1-63 set ref 243 256
                                                                                  261*
unspec                                                 builtin function         dcl 160 set ref 221* 230*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BASIC_CI_LAYOUT_1                      internal static char(4)                  initial dcl 1-97
BCI_HEADER_LENGTH_IN_BYTES             internal static fixed bin(17,0)          initial dcl 2-14
CDCN_DATUM_HEADER_LENGTH_IN_BITS       internal static fixed bin(17,0)          initial dcl 4-39
CD_DATUM_HEADER_LENGTH_IN_BITS         internal static fixed bin(17,0)          initial dcl 4-31
CI_0_ADDRESSABLE_LENGTH                internal static fixed bin(17,0)          initial dcl 7-31
CI_ADDRESSABLE_LENGTH                  internal static fixed bin(17,0)          initial dcl 7-29
CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 7-22
CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 7-25
DATUM_POSITION_TABLE_OFFSET_IN_BYTES   internal static fixed bin(17,0)          initial dcl 2-16
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS  internal static fixed bin(35,0)          initial dcl 4-43
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES internal static fixed bin(35,0)          initial dcl 4-47
MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
                                       internal static fixed bin(35,0)          initial dcl 4-51
basic_control_interval                 based           structure                level 1 dcl 1-56
basic_control_interval_ptr             automatic       pointer                  dcl 1-92
continuation_datum                     based           structure                level 1 packed unaligned dcl 3-47
datum                                  based           structure                level 1 packed unaligned dcl 3-44

NAMES DECLARED BY EXPLICIT CONTEXT.
CD_JOIN                         000217 constant        label                    dcl 210 ref 201
COPY_INTO_BUFFERED_CI           000367 constant        label                    dcl 263
COPY_INTO_FILE_CI               000423 constant        label                    dcl 281
JOIN                            000252 constant        label                    dcl 237 set ref 184 193 235
buffered                        000070 constant        entry                    external dcl 186
buffered_continued              000166 constant        entry                    external dcl 203
cm_put_datum_in_pool            000034 constant        entry                    external dcl 112
continued                       000130 constant        entry                    external dcl 195

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       612         624     526         622
Length      1152     526        12         312      63           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_put_datum_in_pool                138 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_put_datum_in_pool     000100 is_buffered                 cm_put_datum_in_pool
                         000102 my_ci_parts                 cm_put_datum_in_pool
                         000124 based_byte_string_length    cm_put_datum_in_pool
                         000125 datum_contents_length_in_bytes
                                                            cm_put_datum_in_pool
                         000126 datum_header_length_in_bytes
                                                            cm_put_datum_in_pool
                         000127 old_datum_length_in_bytes   cm_put_datum_in_pool
                         000130 ci_datum_contents_ptr       cm_put_datum_in_pool
                         000132 ci_datum_header_ptr         cm_put_datum_in_pool
                         000134 datum_header_ptr            cm_put_datum_in_pool
                         000136 cd_datum_header             cm_put_datum_in_pool
                         000140 cdcn_datum_header           cm_put_datum_in_pool
                         000142 bci_header_ptr              cm_put_datum_in_pool
                         000144 datum_slot_ptr              cm_put_datum_in_pool
                         000146 datum_ptr                   cm_put_datum_in_pool
                         000150 datum_id_ptr                cm_put_datum_in_pool
                         000152 datum_contents_length_in_bits
                                                            cm_put_datum_in_pool
                         000153 element_id_string           cm_put_datum_in_pool
                         000154 ci_parts_ptr                cm_put_datum_in_pool
                         000156 cip_number_of_parts         cm_put_datum_in_pool

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              ext_entry           divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
file_manager_$put

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.


CONSTANTS
000523  aa     037777400000

000524  aa     677777777777

000525  aa     000000000011

000000  aa     404000000043

000001  aa     464000000000

000002  aa     514000000044

000004  aa     077777000043
000005  aa     000001000000

BEGIN PROCEDURE cm_put_datum_in_pool
PROLOGUE SEQUENCE
000006  aa  6 00174 4401 00	sxl0 	pr6|124
						STATEMENT 1 ON LINE 134
000007  aa  6 00100 4501 00	stz  	pr6|64		is_buffered
						STATEMENT 1 ON LINE 138
000010  aa  6 00124 4501 00	stz  	pr6|84		based_byte_string_length
						STATEMENT 1 ON LINE 140
000011  aa  6 00125 4501 00	stz  	pr6|85		datum_contents_length_in_bytes
						STATEMENT 1 ON LINE 142
000012  aa  6 00126 4501 00	stz  	pr6|86		datum_header_length_in_bytes
						STATEMENT 1 ON LINE 144
000013  aa  6 00127 4501 00	stz  	pr6|87		old_datum_length_in_bytes
						STATEMENT 1 ON LINE 67 OF FILE 3
000014  aa   777770 2370 04	ldaq 	-8,ic		000004 = 077777000043 000001000000
000015  aa  6 00146 7571 00	staq 	pr6|102		datum_ptr
						STATEMENT 1 ON LINE 68 OF FILE 3
000016  aa  6 00150 7571 00	staq 	pr6|104		datum_id_ptr
						STATEMENT 1 ON LINE 69 OF FILE 3
000017  aa   000001 3360 07	lcq  	1,dl
000020  aa  6 00152 7561 00	stq  	pr6|106		datum_contents_length_in_bits
						STATEMENT 1 ON LINE 35 OF FILE 6
000021  aa   777763 2370 04	ldaq 	-13,ic		000004 = 077777000043 000001000000
000022  aa  6 00154 7571 00	staq 	pr6|108		ci_parts_ptr
						STATEMENT 1 ON LINE 36 OF FILE 6
000023  aa  6 00156 4501 00	stz  	pr6|110		cip_number_of_parts
000024  aa  6 00174 7201 00	lxl0 	pr6|124
000025  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO cm_put_datum_in_pool                               STATEMENT 1 ON LINE 112
cm_put_datum_in_pool:
   proc (p_file_opening_id, p_element_id, p_datum_contents_ptr, p_datum_contents_length_in_bits, p_datum_slot_ptr,
        p_bci_header_ptr, p_code);

000026  at     000007000002
000027  tt     000002000001
000030  tt     000000000001
000031  tt     000001000000
000032  ta     000026000000
000033  da     000033300000
000034  aa   000220 6270 00	eax7 	144
000035  aa  7 00034 3521 20	epp2 	pr7|28,*
000036  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000037  aa     000016000000
000040  aa     000000000000
000041  aa  6 00032 3735 20	epp7 	pr6|26,*
000042  aa  7 00006 3715 20	epp5 	pr7|6,*
000043  aa  6 00160 6515 00	spri5	pr6|112
000044  aa  7 00010 3535 20	epp3 	pr7|8,*
000045  aa  6 00162 2535 00	spri3	pr6|114
000046  aa  7 00012 3515 20	epp1 	pr7|10,*
000047  aa  6 00164 2515 00	spri1	pr6|116
000050  aa  7 00016 3715 20	epp5 	pr7|14,*
000051  aa  6 00172 6515 00	spri5	pr6|122
000052  aa   777734 7000 04	tsx0 	-36,ic		000006
						STATEMENT 1 ON LINE 181
      bci_header_ptr = p_bci_header_ptr;

000053  aa  6 00032 3735 20	epp7 	pr6|26,*
000054  aa  7 00014 3715 20	epp5 	pr7|12,*		p_bci_header_ptr
000055  aa  5 00000 3715 20	epp5 	pr5|0,*		p_bci_header_ptr
000056  aa  6 00142 6515 00	spri5	pr6|98		bci_header_ptr
						STATEMENT 1 ON LINE 182
      datum_slot_ptr = p_datum_slot_ptr;

000057  aa  6 00164 3535 20	epp3 	pr6|116,*		p_datum_slot_ptr
000060  aa  3 00000 3535 20	epp3 	pr3|0,*		p_datum_slot_ptr
000061  aa  6 00144 2535 00	spri3	pr6|100		datum_slot_ptr
						STATEMENT 1 ON LINE 184
      goto JOIN;

000062  aa   000170 7100 04	tra  	120,ic		000252
ENTRY TO buffered                                           STATEMENT 1 ON LINE 186
buffered:
   entry (p_ci_buffer_ptr, p_datum_contents_ptr, p_datum_contents_length_in_bits, p_datum_slot_ptr, p_code);

000063  at     000005000001
000064  tt     000001000000
000065  tt     000001000000
000066  ta     000063000000
000067  da     000041300000
000070  aa   000220 6270 00	eax7 	144
000071  aa  7 00034 3521 20	epp2 	pr7|28,*
000072  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000073  aa     000012000000
000074  aa     000000000000
000075  aa  6 00032 3735 20	epp7 	pr6|26,*
000076  aa  7 00004 3715 20	epp5 	pr7|4,*
000077  aa  6 00160 6515 00	spri5	pr6|112
000100  aa  7 00006 3535 20	epp3 	pr7|6,*
000101  aa  6 00162 2535 00	spri3	pr6|114
000102  aa  7 00010 3515 20	epp1 	pr7|8,*
000103  aa  6 00164 2515 00	spri1	pr6|116
000104  aa  7 00012 3715 20	epp5 	pr7|10,*
000105  aa  6 00172 6515 00	spri5	pr6|122
000106  aa   777700 7000 04	tsx0 	-64,ic		000006
						STATEMENT 1 ON LINE 189
      bci_header_ptr = p_ci_buffer_ptr;

000107  aa  6 00032 3735 20	epp7 	pr6|26,*
000110  aa  7 00002 3715 20	epp5 	pr7|2,*		p_ci_buffer_ptr
000111  aa  5 00000 3715 20	epp5 	pr5|0,*		p_ci_buffer_ptr
000112  aa  6 00142 6515 00	spri5	pr6|98		bci_header_ptr
						STATEMENT 1 ON LINE 190
      datum_slot_ptr = p_datum_slot_ptr;

000113  aa  6 00164 3535 20	epp3 	pr6|116,*		p_datum_slot_ptr
000114  aa  3 00000 3535 20	epp3 	pr3|0,*		p_datum_slot_ptr
000115  aa  6 00144 2535 00	spri3	pr6|100		datum_slot_ptr
						STATEMENT 1 ON LINE 191
      is_buffered = "1"b;

000116  aa   400000 2350 03	lda  	131072,du
000117  aa  6 00100 7551 00	sta  	pr6|64		is_buffered
						STATEMENT 1 ON LINE 193
      goto JOIN;

000120  aa   000132 7100 04	tra  	90,ic		000252
ENTRY TO continued                                          STATEMENT 1 ON LINE 195
continued:
   entry (p_file_opening_id, p_element_id, p_datum_contents_ptr, p_datum_contents_length_in_bits, p_datum_slot_ptr,
        p_bci_header_ptr, p_element_length_in_bits, p_continuation, p_code);

000121  at     000011000002
000122  tt     000002000001
000123  tt     000000000001
000124  tt     000001000000
000125  tt     000002000000
000126  ta     000121000000
000127  da     000047300000
000130  aa   000220 6270 00	eax7 	144
000131  aa  7 00034 3521 20	epp2 	pr7|28,*
000132  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000133  aa     000022000000
000134  aa     000000000000
000135  aa  6 00032 3735 20	epp7 	pr6|26,*
000136  aa  7 00006 3715 20	epp5 	pr7|6,*
000137  aa  6 00160 6515 00	spri5	pr6|112
000140  aa  7 00010 3535 20	epp3 	pr7|8,*
000141  aa  6 00162 2535 00	spri3	pr6|114
000142  aa  7 00012 3515 20	epp1 	pr7|10,*
000143  aa  6 00164 2515 00	spri1	pr6|116
000144  aa  7 00016 3715 20	epp5 	pr7|14,*
000145  aa  6 00166 6515 00	spri5	pr6|118
000146  aa  7 00020 3535 20	epp3 	pr7|16,*
000147  aa  6 00170 2535 00	spri3	pr6|120
000150  aa  7 00022 3515 20	epp1 	pr7|18,*
000151  aa  6 00172 2515 00	spri1	pr6|122
000152  aa   777634 7000 04	tsx0 	-100,ic		000006
						STATEMENT 1 ON LINE 199
      bci_header_ptr = p_bci_header_ptr;

000153  aa  6 00032 3735 20	epp7 	pr6|26,*
000154  aa  7 00014 3715 20	epp5 	pr7|12,*		p_bci_header_ptr
000155  aa  5 00000 3715 20	epp5 	pr5|0,*		p_bci_header_ptr
000156  aa  6 00142 6515 00	spri5	pr6|98		bci_header_ptr
						STATEMENT 1 ON LINE 201
      goto CD_JOIN;

000157  aa   000040 7100 04	tra  	32,ic		000217
ENTRY TO buffered_continued                                 STATEMENT 1 ON LINE 203
buffered_continued:
   entry (p_ci_buffer_ptr, p_datum_contents_ptr, p_datum_contents_length_in_bits, p_datum_slot_ptr,
        p_element_length_in_bits, p_continuation, p_code);

000160  at     000007000001
000161  tt     000001000000
000162  tt     000001000000
000163  tt     000002000000
000164  ta     000160000000
000165  da     000057300000
000166  aa   000220 6270 00	eax7 	144
000167  aa  7 00034 3521 20	epp2 	pr7|28,*
000170  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000171  aa     000016000000
000172  aa     000000000000
000173  aa  6 00032 3735 20	epp7 	pr6|26,*
000174  aa  7 00004 3715 20	epp5 	pr7|4,*
000175  aa  6 00160 6515 00	spri5	pr6|112
000176  aa  7 00006 3535 20	epp3 	pr7|6,*
000177  aa  6 00162 2535 00	spri3	pr6|114
000200  aa  7 00010 3515 20	epp1 	pr7|8,*
000201  aa  6 00164 2515 00	spri1	pr6|116
000202  aa  7 00012 3715 20	epp5 	pr7|10,*
000203  aa  6 00166 6515 00	spri5	pr6|118
000204  aa  7 00014 3535 20	epp3 	pr7|12,*
000205  aa  6 00170 2535 00	spri3	pr6|120
000206  aa  7 00016 3515 20	epp1 	pr7|14,*
000207  aa  6 00172 2515 00	spri1	pr6|122
000210  aa   777576 7000 04	tsx0 	-130,ic		000006
						STATEMENT 1 ON LINE 207
      bci_header_ptr = p_ci_buffer_ptr;

000211  aa  6 00032 3735 20	epp7 	pr6|26,*
000212  aa  7 00002 3715 20	epp5 	pr7|2,*		p_ci_buffer_ptr
000213  aa  5 00000 3715 20	epp5 	pr5|0,*		p_ci_buffer_ptr
000214  aa  6 00142 6515 00	spri5	pr6|98		bci_header_ptr
						STATEMENT 1 ON LINE 208
      is_buffered = "1"b;

000215  aa   400000 2350 03	lda  	131072,du
000216  aa  6 00100 7551 00	sta  	pr6|64		is_buffered
						STATEMENT 1 ON LINE 210
CD_JOIN:
      datum_slot_ptr = p_datum_slot_ptr;

000217  aa  6 00164 3535 20	epp3 	pr6|116,*		p_datum_slot_ptr
000220  aa  3 00000 3535 20	epp3 	pr3|0,*		p_datum_slot_ptr
000221  aa  6 00144 2535 00	spri3	pr6|100		datum_slot_ptr
						STATEMENT 1 ON LINE 213
      datum_slot.flags.is_continued = "1"b;

000222  aa   200000 2350 03	lda  	65536,du
000223  aa  3 00000 2551 00	orsa 	pr3|0		datum_slot.is_continued
						STATEMENT 1 ON LINE 215
      if p_element_length_in_bits < 0
      then
         do;

000224  aa  6 00166 2361 20	ldq  	pr6|118,*		p_element_length_in_bits
000225  aa   000012 6050 04	tpl  	10,ic		000237
						STATEMENT 1 ON LINE 218
	  datum_slot.flags.is_continuation = "1"b;

000226  aa   100000 2350 03	lda  	32768,du
000227  aa  3 00000 2551 00	orsa 	pr3|0		datum_slot.is_continuation
						STATEMENT 1 ON LINE 219
	  datum_header_length_in_bytes = CDCN_DATUM_HEADER_LENGTH_IN_BYTES;

000230  aa   000004 2360 07	ldq  	4,dl
000231  aa  6 00126 7561 00	stq  	pr6|86		datum_header_length_in_bytes
						STATEMENT 1 ON LINE 221
	  unspec (cdcn_datum_header.continuation) = p_continuation;

000232  aa  6 00170 2351 20	lda  	pr6|120,*		p_continuation
000233  aa  6 00140 7551 00	sta  	pr6|96
						STATEMENT 1 ON LINE 222
	  datum_header_ptr = addr (cdcn_datum_header);

000234  aa  6 00140 3515 00	epp1 	pr6|96		cdcn_datum_header
000235  aa  6 00134 2515 00	spri1	pr6|92		datum_header_ptr
						STATEMENT 1 ON LINE 223
         end;

000236  aa   000014 7100 04	tra  	12,ic		000252
						STATEMENT 1 ON LINE 224
      else
         do;

						STATEMENT 1 ON LINE 226
	  datum_slot.flags.is_continuation = "0"b;

000237  aa   000265 2350 04	lda  	181,ic		000524 = 677777777777
000240  aa  3 00000 3551 00	ansa 	pr3|0		datum_slot.is_continuation
						STATEMENT 1 ON LINE 227
	  datum_header_length_in_bytes = CD_DATUM_HEADER_LENGTH_IN_BYTES;

000241  aa   000010 2360 07	ldq  	8,dl
000242  aa  6 00126 7561 00	stq  	pr6|86		datum_header_length_in_bytes
						STATEMENT 1 ON LINE 229
	  cd_datum_header.full_length = p_element_length_in_bits;

000243  aa  6 00166 2361 20	ldq  	pr6|118,*		p_element_length_in_bits
000244  aa  6 00136 7561 00	stq  	pr6|94		cd_datum_header.full_length
						STATEMENT 1 ON LINE 230
	  unspec (cd_datum_header.continuation) = p_continuation;

000245  aa  6 00170 2351 20	lda  	pr6|120,*		p_continuation
000246  aa  6 00137 7551 00	sta  	pr6|95
						STATEMENT 1 ON LINE 232
	  datum_header_ptr = addr (cd_datum_header);

000247  aa  6 00136 3515 00	epp1 	pr6|94		cd_datum_header
000250  aa  6 00134 2515 00	spri1	pr6|92		datum_header_ptr
						STATEMENT 1 ON LINE 233
         end;

						STATEMENT 1 ON LINE 235
      goto JOIN;

000251  aa   000001 7100 04	tra  	1,ic		000252
						STATEMENT 1 ON LINE 237
JOIN:
      p_code = 0;

000252  aa  6 00172 4501 20	stz  	pr6|122,*		p_code
						STATEMENT 1 ON LINE 240
      datum_contents_length_in_bits = p_datum_contents_length_in_bits;

000253  aa  6 00162 2361 20	ldq  	pr6|114,*		p_datum_contents_length_in_bits
000254  aa  6 00152 7561 00	stq  	pr6|106		datum_contents_length_in_bits
						STATEMENT 1 ON LINE 241
      datum_contents_length_in_bytes = divide (datum_contents_length_in_bits + BITS_PER_BYTE - 1, BITS_PER_BYTE, 17, 0);

000255  aa   000044 7770 00	llr  	36
000256  aa   000044 7330 00	lrs  	36
000257  aa   000011 0330 07	adl  	9,dl
000260  aa   000000 5330 00	negl 	0
000261  aa   000001 0330 07	adl  	1,dl
000262  aa   000000 5330 00	negl 	0
000263  aa   000242 3520 04	epp2 	162,ic		000525 = 000000000011
000264  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
000265  aa     000000000000
000266  aa  6 00125 7561 00	stq  	pr6|85		datum_contents_length_in_bytes
						STATEMENT 1 ON LINE 243
      if datum_slot.offset_in_bytes = bci_header.start_of_used_space
      then datum_slot.offset_in_bytes =
	      datum_slot.offset_in_bytes - (datum_contents_length_in_bytes + datum_header_length_in_bytes)
	      + divide (datum_slot.length_in_bits + BITS_PER_BYTE - 1, BITS_PER_BYTE, 17, 0);

000267  aa  3 00000 2351 00	lda  	pr3|0		datum_slot.offset_in_bytes
000270  aa   000004 7350 00	als  	4
000271  aa   000071 7730 00	lrl  	57
000272  aa  6 00175 7561 00	stq  	pr6|125		datum_slot.offset_in_bytes
000273  aa  5 00004 2351 00	lda  	pr5|4		bci_header.start_of_used_space
000274  aa   000066 7330 00	lrs  	54
000275  aa  6 00175 1161 00	cmpq 	pr6|125		datum_slot.offset_in_bytes
000276  aa   000022 6010 04	tnz  	18,ic		000320
000277  aa  3 00000 2361 00	ldq  	pr3|0		datum_slot.length_in_bits
000300  aa  0 00376 3771 00	anaq 	pr0|254		= 000000000000 000000377777
000301  aa  2 00000 0761 00	adq  	pr2|0		BITS_PER_BYTE
000302  aa   000001 1760 07	sbq  	1,dl
000303  aa  2 00000 5061 00	div  	pr2|0		BITS_PER_BYTE
000304  aa  6 00176 7561 00	stq  	pr6|126
000305  aa  6 00125 2361 00	ldq  	pr6|85		datum_contents_length_in_bytes
000306  aa  6 00126 0761 00	adq  	pr6|86		datum_header_length_in_bytes
000307  aa  6 00177 7561 00	stq  	pr6|127
000310  aa  6 00175 2361 00	ldq  	pr6|125		datum_slot.offset_in_bytes
000311  aa  6 00177 1761 00	sbq  	pr6|127
000312  aa  6 00176 0761 00	adq  	pr6|126
000313  aa   000065 7370 00	lls  	53
000314  aa  3 00000 6751 00	era  	pr3|0		datum_slot.offset_in_bytes
000315  aa   000206 3750 04	ana  	134,ic		000523 = 037777400000
000316  aa  3 00000 6551 00	ersa 	pr3|0		datum_slot.offset_in_bytes
000317  aa   000030 7100 04	tra  	24,ic		000347
						STATEMENT 1 ON LINE 247
      else
         do;

						STATEMENT 1 ON LINE 249
	  if datum_slot.offset_in_bytes ^= FREE_SLOT
	  then bci_header.scattered_free_space =
		  bci_header.scattered_free_space
		  + divide (datum_slot.length_in_bits + BITS_PER_BYTE - 1, BITS_PER_BYTE, 17, 0);

000320  aa  6 00175 2361 00	ldq  	pr6|125		datum_slot.offset_in_bytes
000321  aa   000014 6000 04	tze  	12,ic		000335
000322  aa  3 00000 2361 00	ldq  	pr3|0		datum_slot.length_in_bits
000323  aa  0 00376 3771 00	anaq 	pr0|254		= 000000000000 000000377777
000324  aa  2 00000 0761 00	adq  	pr2|0		BITS_PER_BYTE
000325  aa   000001 1760 07	sbq  	1,dl
000326  aa  2 00000 5061 00	div  	pr2|0		BITS_PER_BYTE
000327  aa  6 00175 7561 00	stq  	pr6|125
000330  aa  5 00003 2351 00	lda  	pr5|3		bci_header.scattered_free_space
000331  aa   000022 7350 00	als  	18
000332  aa   000066 7330 00	lrs  	54
000333  aa  6 00175 0761 00	adq  	pr6|125
000334  aa  5 00003 5521 14	stbq 	pr5|3,14		bci_header.scattered_free_space
						STATEMENT 1 ON LINE 256
	  datum_slot.offset_in_bytes =
	       bci_header.start_of_used_space - (datum_contents_length_in_bytes + datum_header_length_in_bytes);

000335  aa  6 00125 2361 00	ldq  	pr6|85		datum_contents_length_in_bytes
000336  aa  6 00126 0761 00	adq  	pr6|86		datum_header_length_in_bytes
000337  aa  6 00175 7561 00	stq  	pr6|125
000340  aa  5 00004 2351 00	lda  	pr5|4		bci_header.start_of_used_space
000341  aa   000066 7330 00	lrs  	54
000342  aa  6 00175 1761 00	sbq  	pr6|125
000343  aa   000065 7370 00	lls  	53
000344  aa  3 00000 6751 00	era  	pr3|0		datum_slot.offset_in_bytes
000345  aa   000156 3750 04	ana  	110,ic		000523 = 037777400000
000346  aa  3 00000 6551 00	ersa 	pr3|0		datum_slot.offset_in_bytes
						STATEMENT 1 ON LINE 258
         end;

						STATEMENT 1 ON LINE 260
      datum_slot.length_in_bits = datum_header_length_in_bytes * BITS_PER_BYTE + datum_contents_length_in_bits;

000347  aa  6 00126 2361 00	ldq  	pr6|86		datum_header_length_in_bytes
000350  aa  2 00000 4021 00	mpy  	pr2|0		BITS_PER_BYTE
000351  aa   000044 7770 00	llr  	36
000352  aa   000044 7330 00	lrs  	36
000353  aa  6 00152 0331 00	adl  	pr6|106		datum_contents_length_in_bits
000354  aa  3 00000 6761 00	erq  	pr3|0		datum_slot.length_in_bits
000355  aa   377777 3760 07	anq  	131071,dl
000356  aa  3 00000 6561 00	ersq 	pr3|0		datum_slot.length_in_bits
						STATEMENT 1 ON LINE 261
      bci_header.start_of_used_space = datum_slot.offset_in_bytes;

000357  aa  3 00000 2351 00	lda  	pr3|0		datum_slot.offset_in_bytes
000360  aa   000004 7350 00	als  	4
000361  aa   000071 7730 00	lrl  	57
000362  aa  6 00175 7561 00	stq  	pr6|125		datum_slot.offset_in_bytes
000363  aa   000066 7370 00	lls  	54
000364  aa  5 00004 5511 60	stba 	pr5|4,60		bci_header.start_of_used_space
						STATEMENT 1 ON LINE 263
      if is_buffered
      then
COPY_INTO_BUFFERED_CI:
         do;

000365  aa  6 00100 2351 00	lda  	pr6|64		is_buffered
000366  aa   000035 6000 04	tze  	29,ic		000423
						STATEMENT 1 ON LINE 268
	  based_byte_string_length = datum_contents_length_in_bytes;

000367  aa  6 00125 2361 00	ldq  	pr6|85		datum_contents_length_in_bytes
000370  aa  6 00124 7561 00	stq  	pr6|84		based_byte_string_length
						STATEMENT 1 ON LINE 269
	  ci_datum_contents_ptr = addr (based_ci.byte (datum_slot.offset_in_bytes + datum_header_length_in_bytes + 1));

000371  aa  6 00175 2361 00	ldq  	pr6|125		datum_slot.offset_in_bytes
000372  aa  6 00126 0761 00	adq  	pr6|86		datum_header_length_in_bytes
000373  aa   000011 4020 07	mpy  	9,dl
000374  aa  5 00000 3521 00	epp2 	pr5|0		based_ci.byte
000375  aa  2 00000 5035 06	abd  	pr2|0,ql
000376  aa  6 00130 2521 00	spri2	pr6|88		ci_datum_contents_ptr
						STATEMENT 1 ON LINE 270
	  ci_datum_contents_ptr -> based_byte_string = p_datum_contents_ptr -> based_byte_string;

000377  aa  6 00160 3515 20	epp1 	pr6|112,*		p_datum_contents_ptr
000400  aa  1 00000 3515 20	epp1 	pr1|0,*		p_datum_contents_ptr
000401  aa  6 00124 2351 00	lda  	pr6|84		based_byte_string_length
000402  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000403  aa  1 00000 00 0005	desc9a	pr1|0,al		based_byte_string
000404  aa  2 00000 00 0005	desc9a	pr2|0,al		based_byte_string
						STATEMENT 1 ON LINE 272
	  if datum_header_length_in_bytes > 0
	  then
	     do;

000405  aa  6 00126 2361 00	ldq  	pr6|86		datum_header_length_in_bytes
000406  aa   000114 6044 04	tmoz 	76,ic		000522
						STATEMENT 1 ON LINE 275
	        based_byte_string_length = datum_header_length_in_bytes;

000407  aa  6 00124 7561 00	stq  	pr6|84		based_byte_string_length
						STATEMENT 1 ON LINE 276
	        ci_datum_header_ptr = addr (based_ci.byte (datum_slot.offset_in_bytes + 1));

000410  aa  6 00175 2361 00	ldq  	pr6|125		datum_slot.offset_in_bytes
000411  aa   000011 4020 07	mpy  	9,dl
000412  aa  5 00000 3521 00	epp2 	pr5|0		based_ci.byte
000413  aa  2 00000 5035 06	abd  	pr2|0,ql
000414  aa  6 00132 2521 00	spri2	pr6|90		ci_datum_header_ptr
						STATEMENT 1 ON LINE 277
	        ci_datum_header_ptr -> based_byte_string = datum_header_ptr -> based_byte_string;

000415  aa  6 00134 3515 20	epp1 	pr6|92,*		datum_header_ptr
000416  aa  6 00124 2351 00	lda  	pr6|84		based_byte_string_length
000417  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000420  aa  1 00000 00 0005	desc9a	pr1|0,al		based_byte_string
000421  aa  2 00000 00 0005	desc9a	pr2|0,al		based_byte_string
						STATEMENT 1 ON LINE 278
	     end;

						STATEMENT 1 ON LINE 280
         end COPY_INTO_BUFFERED_CI;

000422  aa   000100 7100 04	tra  	64,ic		000522
						STATEMENT 1 ON LINE 281
      else
COPY_INTO_FILE_CI:
         do;

						STATEMENT 1 ON LINE 285
	  element_id_string = p_element_id;

000423  aa  7 00004 2351 20	lda  	pr7|4,*		p_element_id
000424  aa  6 00153 7551 00	sta  	pr6|107		element_id_string
						STATEMENT 1 ON LINE 287
	  ci_parts_ptr = addr (my_ci_parts);

000425  aa  6 00102 3515 00	epp1 	pr6|66		my_ci_parts
000426  aa  6 00154 2515 00	spri1	pr6|108		ci_parts_ptr
						STATEMENT 1 ON LINE 288
	  ci_parts.number_of_parts = 3;

000427  aa   000003 2360 07	ldq  	3,dl
000430  aa  1 00000 7561 00	stq  	pr1|0		ci_parts.number_of_parts
						STATEMENT 1 ON LINE 290
	  ci_parts.part (DATUM_SLOT_PART_IDX).offset_in_bytes =
	       BYTES_PER_WORD * ((element_id.index - 1) + size (bci_header));

000431  aa   000010 2360 07	ldq  	8,dl
000432  aa  6 00153 2351 00	lda  	pr6|107		element_id.index
000433  aa   000030 7350 00	als  	24
000434  aa   000000 6270 06	eax7 	0,ql
000435  aa   000074 7730 00	lrl  	60
000436  aa   000004 0760 07	adq  	4,dl
000437  aa   000004 4020 07	mpy  	4,dl
000440  aa  1 77776 7561 17	stq  	pr1|-2,7		ci_parts.offset_in_bytes
						STATEMENT 1 ON LINE 292
	  ci_parts.part (DATUM_SLOT_PART_IDX).length_in_bytes = BYTES_PER_WORD;

000441  aa   000004 2360 07	ldq  	4,dl
000442  aa  1 77777 7561 17	stq  	pr1|-1,7		ci_parts.length_in_bytes
						STATEMENT 1 ON LINE 293
	  ci_parts.part (DATUM_SLOT_PART_IDX).local_ptr = datum_slot_ptr;

000443  aa  1 00000 2535 17	spri3	pr1|0,7		ci_parts.local_ptr
						STATEMENT 1 ON LINE 295
	  ci_parts.part (HEADER_PART_IDX).offset_in_bytes = 0;

000444  aa   000004 2360 07	ldq  	4,dl
000445  aa  1 77776 4501 06	stz  	pr1|-2,ql		ci_parts.offset_in_bytes
						STATEMENT 1 ON LINE 296
	  ci_parts.part (HEADER_PART_IDX).length_in_bytes = size (bci_header) * BYTES_PER_WORD;

000446  aa   000000 6260 06	eax6 	0,ql
000447  aa   000005 2360 07	ldq  	5,dl
000450  aa   000004 4020 07	mpy  	4,dl
000451  aa  1 77777 7561 16	stq  	pr1|-1,6		ci_parts.length_in_bytes
						STATEMENT 1 ON LINE 297
	  ci_parts.part (HEADER_PART_IDX).local_ptr = bci_header_ptr;

000452  aa  1 00000 6515 16	spri5	pr1|0,6		ci_parts.local_ptr
						STATEMENT 1 ON LINE 299
	  ci_parts.part (DATUM_CONTENTS_PART_IDX).offset_in_bytes =
	       datum_slot.offset_in_bytes + datum_header_length_in_bytes;

000453  aa   000014 2360 07	ldq  	12,dl
000454  aa   000000 6250 06	eax5 	0,ql
000455  aa  6 00175 2361 00	ldq  	pr6|125		datum_slot.offset_in_bytes
000456  aa  6 00126 0761 00	adq  	pr6|86		datum_header_length_in_bytes
000457  aa  1 77776 7561 15	stq  	pr1|-2,5		ci_parts.offset_in_bytes
						STATEMENT 1 ON LINE 301
	  ci_parts.part (DATUM_CONTENTS_PART_IDX).length_in_bytes = datum_contents_length_in_bytes;

000460  aa  6 00125 2361 00	ldq  	pr6|85		datum_contents_length_in_bytes
000461  aa  1 77777 7561 15	stq  	pr1|-1,5		ci_parts.length_in_bytes
						STATEMENT 1 ON LINE 302
	  ci_parts.part (DATUM_CONTENTS_PART_IDX).local_ptr = p_datum_contents_ptr;

000462  aa  6 00160 3535 20	epp3 	pr6|112,*		p_datum_contents_ptr
000463  aa  3 00000 3535 20	epp3 	pr3|0,*		p_datum_contents_ptr
000464  aa  1 00000 2535 15	spri3	pr1|0,5		ci_parts.local_ptr
						STATEMENT 1 ON LINE 304
	  if datum_slot.is_continued
	  then
	     do;

000465  aa  6 00144 2351 20	lda  	pr6|100,*		datum_slot.is_continued
000466  aa   200000 3150 03	cana 	65536,du
000467  aa   000013 6000 04	tze  	11,ic		000502
						STATEMENT 1 ON LINE 307
	        ci_parts.number_of_parts = 4;

000470  aa   000004 2360 07	ldq  	4,dl
000471  aa  1 00000 7561 00	stq  	pr1|0		ci_parts.number_of_parts
						STATEMENT 1 ON LINE 309
	        ci_parts.part (DATUM_HEADER_PART_IDX).offset_in_bytes = datum_slot.offset_in_bytes;

000472  aa   000020 2360 07	ldq  	16,dl
000473  aa   000000 6240 06	eax4 	0,ql
000474  aa  6 00175 2361 00	ldq  	pr6|125		datum_slot.offset_in_bytes
000475  aa  1 77776 7561 14	stq  	pr1|-2,4		ci_parts.offset_in_bytes
						STATEMENT 1 ON LINE 310
	        ci_parts.part (DATUM_HEADER_PART_IDX).length_in_bytes = datum_header_length_in_bytes;

000476  aa  6 00126 2361 00	ldq  	pr6|86		datum_header_length_in_bytes
000477  aa  1 77777 7561 14	stq  	pr1|-1,4		ci_parts.length_in_bytes
						STATEMENT 1 ON LINE 311
	        ci_parts.part (DATUM_HEADER_PART_IDX).local_ptr = datum_header_ptr;

000500  aa  6 00134 3535 20	epp3 	pr6|92,*		datum_header_ptr
000501  aa  1 00000 2535 14	spri3	pr1|0,4		ci_parts.local_ptr
						STATEMENT 1 ON LINE 313
	     end;

						STATEMENT 1 ON LINE 315
	  call file_manager_$put (p_file_opening_id, (element_id.control_interval_id), ci_parts_ptr, p_code);

000502  aa  6 00153 2351 00	lda  	pr6|107		element_id.control_interval_id
000503  aa   000060 7730 00	lrl  	48
000504  aa  6 00176 7561 00	stq  	pr6|126
000505  aa  7 00002 3521 20	epp2 	pr7|2,*		p_file_opening_id
000506  aa  6 00202 2521 00	spri2	pr6|130
000507  aa  6 00176 3521 00	epp2 	pr6|126
000510  aa  6 00204 2521 00	spri2	pr6|132
000511  aa  6 00154 3521 00	epp2 	pr6|108		ci_parts_ptr
000512  aa  6 00206 2521 00	spri2	pr6|134
000513  aa  6 00172 3521 20	epp2 	pr6|122,*		p_code
000514  aa  6 00210 2521 00	spri2	pr6|136
000515  aa  6 00200 6211 00	eax1 	pr6|128
000516  aa   020000 4310 07	fld  	8192,dl
000517  aa  6 00044 3701 20	epp4 	pr6|36,*
000520  la  4 00010 3521 20	epp2 	pr4|8,*		file_manager_$put
000521  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 317
         end COPY_INTO_FILE_CI;

						STATEMENT 1 ON LINE 319
      return;

000522  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 336
   end cm_put_datum_in_pool;

  END PROCEDURE cm_put_datum_in_pool


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
