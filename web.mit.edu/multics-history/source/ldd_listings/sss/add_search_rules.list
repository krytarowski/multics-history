	COMPILATION LISTING OF SEGMENT add_search_rules
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 01/19/88  1549.3 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(85-09-18,Spitzer), approve(85-09-18,MCR7272),
       16*     audit(85-12-05,Lippard), install(85-12-16,MR12.0-1001):
       17*     Fix error msgs for delete_search_rules.
       18*  2) change(85-12-17,GDixon), approve(85-12-17,PBF7272),
       19*     audit(85-12-17,Martinson), install(85-12-17,MR12.0-1002):
       20*     Change test to look for non-control-arg instead of a control arg.
       21*  3) change(87-11-05,Lippard), approve(87-11-23,MCR7797),
       22*     audit(88-01-13,GWMay), install(88-01-19,MR12.2-1016):
       23*     Added -no_force, -inhibit_error, -no_inhibit_error.
       24*                                                   END HISTORY COMMENTS */
       25 
       26 /* format: off */
       27 add_search_rules: asr: proc;
       28 
       29 /* written around August 1972 by C. D. Tavares */
       30 /* Modified April 7, 1973 by C. D. Tavares to add keyword handling and
       31*   prepare for AML submission */
       32 /* Modified 4/13/76 by Steve Herbst */
       33 /* Changed for installation-modifiable keywords 8/76 THVV */
       34 /* Short control arg names -be/-before -af/-after added 09/28/79 S. Herbst */
       35 /* Add -force and remain silent if already in intended position 03/09/81 S. Herbst */
       36 
       37 /* Usage is 'add_search_rules pathname (-before or -after pathname2) pathname3 etc...
       38*   Rules are added to end of current search rules unless followed by -after or -before,
       39*   when they will be put after or before the next (existing) search rule.
       40*   Since the rule matching is done by directory unique ID, there is no need to
       41*   type in the rule exactly as hardcore remembers it. Relative pathnames are acceptable. */
       42 
       43 dcl  nargs fixed bin,
       44      explanation char (168) aligned,
       45      ioa_$rsnnl ext entry options (variable),
       46      ref_rule char (168) aligned,
       47      argno fixed bin,
       48      error_gotten bit (1) aligned initial (""b),
       49      rule_ids (21) bit (36) aligned,
       50      new_id bit (36),
       51     (force_sw, inhibit_err_sw, namedup_sw) bit (1),
       52      namedup_index fixed,
       53      after fixed bin,
       54     (i, j) fixed bin,
       55      cu_$arg_count ext entry returns (fixed bin),
       56      (com_err_, com_err_$suppress_name) entry options (variable),
       57      cu_$arg_ptr ext entry (fixed bin, pointer, fixed bin(21), fixed bin(35)),
       58      ap pointer,
       59      al fixed bin (21),
       60      code fixed bin (35),
       61      absolute_pathname_ ext entry (char (*), char (*) aligned, fixed bin (35)),
       62     (addr, hbound, index, null, substr) builtin,
       63      new_rule char (168) aligned,
       64      get_pdir_ entry () returns (char (168) aligned),
       65      user_info_$homedir entry (char (*) aligned),
       66      hcs_$status_long ext entry (char (*) aligned, char (*), fixed bin, ptr, ptr, fixed bin (35)),
       67      hcs_$get_search_rules ext entry (pointer),
       68      hcs_$get_system_search_rules entry (ptr, fixed bin (35)),
       69     (error_table_$too_many_sr,
       70      error_table_$no_s_permission,
       71      error_table_$name_not_found,
       72      error_table_$badopt,
       73      error_table_$namedup) ext fixed bin (35),
       74      place fixed bin,
       75      arg char (al) based (ap),
       76      hcs_$initiate_search_rules ext entry (pointer, fixed bin(35)),
       77      myname char (32);
       78 
  1     1      declare		/* Structure returned by hcs_$status_long */
  1     2 
  1     3 	1 branch_status aligned,				/* automatic: hcs_$status uses a pointer */
  1     4 
  1     5 	  2 type bit(2) unaligned,				/* type of entry: link, segment, dir */
  1     6 	  2 number_names bit(16) unaligned,			/* unused by directory_status_ */
  1     7 	  2 names_rel_pointer bit(18) unaligned,		/* unused by directory_status_ */
  1     8 	  2 date_time_modified bit(36) unaligned,		/* date time modified */
  1     9 	  2 date_time_used bit(36) unaligned,			/* date time entry used */
  1    10 	  2 mode bit(5) unaligned,				/* effective access of caller */
  1    11 	  2 raw_mode bit(5) unaligned,
  1    12 	  2 pad1 bit(8) unaligned,
  1    13 	  2 records bit(18) unaligned,			/* number of records in use */
  1    14 	  2 date_time_dumped bit(36) unaligned,			/* date time last dumped */
  1    15 	  2 date_time_entry_modified bit(36) unaligned,		/* date time entry modified */
  1    16 	  2 lvid bit(36) unaligned,				/* logical volume id */
  1    17 	  2 current_length bit(12) unaligned,			/* number of blocks currently allocated */
  1    18 	  2 bit_count bit(24) unaligned,			/* bit count of entry */
  1    19 	  2 pad3 bit(8) unaligned,
  1    20 	  2 copy_switch bit(1) unaligned,			/* the copy switch */
  1    21 	  2 tpd bit(1) unaligned,				/* transparent to paging device */
  1    22 	  2 mdir bit(1) unaligned,				/* master directory switch */
  1    23 	  2 damaged_switch bit (1) unaligned,			/* true if contents damaged */
  1    24 	  2 synchronized_switch bit (1) unaligned,		/* true if a DM synchronized file */
  1    25 	  2 pad4 bit(5) unaligned,
  1    26 	  2 ring_brackets (0:2) bit(6) unaligned,		/* branch ring brackets */
  1    27 	  2 unique_id bit(36) unaligned,			/* entry unique id */
  1    28 
  1    29 
  1    30 	     /* The types of each class of branch */
  1    31 	segment_type bit(2) aligned internal static initial ("01"b),
  1    32 	directory_type bit(2) aligned internal static initial ("10"b),
  1    33 	msf_type bit(2) aligned internal static initial ("10"b),	/* will eventually be different */
  1    34 	link_type bit(2) aligned internal static initial ("00"b);
  1    35 
  1    36 
       79 
  2     1 /* BEGIN INCLUDE FILE ... system_dft_sr.incl.pl1 */
  2     2 
  2     3 dcl  xsp ptr;
  2     4 dcl 1 dft_sr_arg based (xsp) aligned,
  2     5     2 ntags fixed bin,
  2     6     2 nrules fixed bin,
  2     7     2 tags (10),
  2     8       3 name char (32),
  2     9       3 flag bit (36),
  2    10     2 rules (50),
  2    11       3 name char (168),
  2    12       3 flag bit (36);
  2    13 
  2    14 /* END INCLUDE FILE ... system_dft_sr.incl.pl1 */
       80 
  3     1 /* BEGIN INCLUDE FILE ... search_rule_flags.incl.pl1 */
  3     2 
  3     3 dcl  INITIATED_RULE bit (18) static options (constant) init ("000000000000000001"b);
  3     4 dcl  REFERENCING_DIR_RULE bit (18) static options (constant) init ("000000000000000010"b);
  3     5 dcl  WDIR_RULE bit (18) static options (constant) init ("000000000000000011"b);
  3     6 dcl  END_RULE bit (18) static options (constant) init ("000000000000000100"b);
  3     7 dcl  BAD_RULE bit (18) static options (constant) init ("000000000000001000"b);
  3     8 
  3     9 dcl  search_rule_names (8) char (32) aligned static options (constant) init
  3    10     ("initiated_segments",
  3    11      "referencing_dir",
  3    12      "working_dir",
  3    13      "end_rules",
  3    14      "",
  3    15      "",
  3    16      "",
  3    17      "bad search rule");
  3    18 
  3    19 /* END INCLUDE FILE ... search_rule_flags.incl.pl1 */
       81 
       82 
       83 dcl 1 system_rules aligned like dft_sr_arg;
       84 
       85 dcl 1 myrules aligned,
       86     2 number_of_rules fixed bin,
       87     2 rules (21) char (168);
       88 
       89 	myname = "add_search_rules";
       90 	nargs = cu_$arg_count ();
       91 	if nargs = 0 then do;			/* user probably wants instructions */
       92 usage_error:   call com_err_$suppress_name (0, myname,
       93 		"Usage:  ^a path1 {-before path2} {-after path2} etc.", myname);
       94 	     return;
       95 	end;
       96 
       97 	call setup;				/* get current search rules and initialize environment */
       98 
       99 /* ----------------------------------------------------------------------------- */
      100 
      101 setup:	proc;					/* this initializes our data structure */
      102 
      103 	     call hcs_$get_system_search_rules (addr (system_rules), (0));
      104 	     call hcs_$get_search_rules (addr (myrules));
      105 
      106 	     do i = 1 to number_of_rules;
      107 		rule_ids (i) = ""b;			/* so we don't garbage out */
      108 		call hcs_$status_long (myrules.rules (i), "", 1, addr (branch_status), null, code);
      109 		if (code = 0 | code = error_table_$no_s_permission)
      110 		then rule_ids (i) = branch_status.unique_id; /* unique id is ok */
      111 		else do;
      112 		     do j = 1 to hbound (search_rule_names, 1); /* it may be a keyword */
      113 			if myrules.rules (i) = search_rule_names (j) then do;
      114 			     substr (rule_ids (i), j, 1) = "1"b; /* give it a "unique" id */
      115 			     go to nxrule;
      116 			end;
      117 		     end;
      118 		end;
      119 nxrule:	     end;
      120 
      121 
      122 	end setup;
      123 
      124 /* ----------------------------------------------------------------------------- */
      125 
      126 	force_sw, inhibit_err_sw = "0"b;
      127 	do i = 1 to nargs;
      128 	     call cu_$arg_ptr (i, ap, al, code);
      129 	     if arg = "-force" | arg = "-fc" then force_sw = "1"b;  /* it's global */
      130 	     else if arg = "-no_force" | arg = "-nfc" then force_sw = "0"b;
      131 	     else if arg = "-inhibit_error" | arg = "-ihe" then inhibit_err_sw = "1"b;
      132 	     else if arg = "-no_inhibit_error" | arg = "-nihe" then inhibit_err_sw = "0"b;
      133 	end;
      134 
      135 	argno = 0;
      136 
      137 another:						/* to process next arg */
      138 	argno = argno + 1;
      139 	call get_and_validate (new_rule, all_done, new_id, error); /* setup next arg */
      140 
      141 /* ----------------------------------------------------------------------------- */
      142 
      143 get_and_validate: proc (which_rule, no_arg_label, which_id, error_label);
      144 						/* gets unique ID of next arg and processes errors, etc */
      145 
      146 dcl  which_rule char (*) aligned,
      147      which_id bit (36),
      148      error_label label,
      149      no_arg_label label;
      150 
      151 start_gav:					/* for false starts */
      152 	     call cu_$arg_ptr (argno, ap, al, code);	/* get next arg */
      153 	     if code ^= 0 then go to no_arg_label;	/* no arg */
      154 
      155 	     if index (arg, "-") = 1 then
      156 		if arg = "-before" | arg = "-be" | arg = "-after" | arg = "-af" then
      157 		     if error_gotten then do;
      158 			argno = argno+2;
      159 			error_gotten = "0"b;
      160 			go to start_gav;
      161 		     end;
      162 		     else go to usage_error;
      163 		else if arg = "-force" | arg = "-fc" | arg = "-no_force" | arg = "-nfc"
      164 		     | arg = "-inhibit_error" | arg = "-ihe" | arg = "-no_inhibit_error" | arg = "-nihe" then do;
      165 		     argno = argno + 1;
      166 		     go to start_gav;
      167 		end;
      168 		else go to bad_option;
      169 
      170 	     if arg = "process_dir" then which_rule = get_pdir_ ();
      171 	     else if arg = "home_dir" then call user_info_$homedir (which_rule);
      172 	     else do;
      173 		call absolute_pathname_ (arg, which_rule, code);
      174 		if code ^= 0 then do;		/* hmmm */
      175 		     explanation = arg;
      176 		     go to error_label;
      177 		end;
      178 	     end;
      179 
      180 	     call hcs_$status_long (which_rule, "", 1, addr (branch_status), null, code); /* get unique id of dir */
      181 
      182 	     if code ^= 0 & code ^= error_table_$no_s_permission then do;
      183 
      184 		which_id = ""b;			/* check for keywords */
      185 		do i = 1 to 3;
      186 		     if search_rule_names (i) = arg then do; /* matches */
      187 			substr (which_id, i, 1) = "1"b; /* generate our "unique" id for matching */
      188 			which_rule = search_rule_names (i); /* this is the string we want */
      189 			return;
      190 		     end;
      191 		end;
      192 		do i = 1 to system_rules.ntags;
      193 		     if system_rules.tags (i).name = arg then do;
      194 			which_rule = arg;		/* can introduce dupe by this path. always could */
      195 			return;
      196 		     end;
      197 		end;
      198 
      199 		explanation = which_rule;		/* pathname not found */
      200 		go to error_label;
      201 	     end;
      202 
      203 	     which_id = branch_status.unique_id;	/* we have valid dir, return its id */
      204 
      205 	     return;
      206 
      207 	end get_and_validate;
      208 
      209 /* ----------------------------------------------------------------------------- */
      210 
      211 	if number_of_rules = hbound (rule_ids, 1) then do;  /* can't add another */
      212 	     code = error_table_$too_many_sr;
      213 	     go to error_fin;
      214 	end;
      215 
      216 	error_gotten = ""b;				/* none yet */
      217 	namedup_sw = ""b;
      218 
      219 	do i = 1 to number_of_rules;			/* hardcore accepts duplications, but we won't */
      220 	     if (rule_ids (i) = new_id & new_id ^= ""b) | myrules.rules (i) = new_rule then do; /* rule already there */
      221 		if force_sw then do;		/* delete the old occurrence */
      222 		     number_of_rules = number_of_rules - 1;
      223 		     do i = i to number_of_rules;
      224 			myrules.rules (i) = myrules.rules (i + 1);
      225 			rule_ids (i) = rule_ids (i + 1);
      226 		     end;
      227 		end;
      228 		else do;				/* complain later if not intended for same place */
      229 		     namedup_sw = "1"b;
      230 		     namedup_index = i;
      231 		end;
      232 	     end;
      233 	end;
      234 
      235 next_arg:
      236 	argno = argno + 1;				/* see if there is a position option */
      237 	call cu_$arg_ptr (argno, ap, al, code);
      238 	if code ^= 0 then do;			/* no more args */
      239 one_string:					/* add this one to end */
      240 	     if namedup_sw then
      241 		if namedup_index = number_of_rules then go to all_done;  /* already in right place */
      242 		else do;
      243 namedup_error:	   if ^inhibit_err_sw then do;
      244 		      code = error_table_$namedup;
      245 		      call ioa_$rsnnl ("^a already elsewhere in search path.", explanation, 0, new_rule);
      246 		      go to error;
      247 		      end;
      248 		   end;
      249 
      250 	     place = number_of_rules + 1;
      251 	     argno = argno - 1;			/* so we will finish when we try */
      252 	     go to simple_add;
      253 	end;
      254 
      255 	if index (arg, "-") ^= 1 then go to one_string;	/* not an option, add last arg to end */
      256 	else if arg = "-force" | arg = "-fc" then go to next_arg;
      257 	else if arg = "-no_force" | arg = "-nfc" then go to next_arg;
      258 	else if arg = "-inhibit_error" | arg = "-ihe" then go to next_arg;
      259 	else if arg = "-no_inhibit_error" | arg = "-nihe" then go to next_arg;
      260 	else if arg = "-before" | arg = "-be" then after = 0;
      261 	else if arg = "-after" | arg = "-af" then after = 1;
      262 	else do;					/* and yell if neither */
      263 bad_option:    call com_err_ (error_table_$badopt, myname, "^a", arg);
      264 	     return;
      265 	end;
      266 
      267 	explanation = "";
      268 	argno = argno + 1;				/* if we are here, we have had a position option */
      269 	call get_and_validate (ref_rule, error, branch_status.unique_id, error); /* get what we are supposed to add after or before */
      270 
      271 	do i = 1 to number_of_rules;			/* search for it */
      272 	     if rule_ids (i) = branch_status.unique_id & branch_status.unique_id ^= ""b then go to found_ref; /* unique id's match */
      273 	     if myrules.rules (i) = ref_rule then go to found_ref; /* pathnames match */
      274 	end;
      275 
      276 	code = error_table_$name_not_found;		/* not there, can't add before or after it */
      277 	call ioa_$rsnnl ("^a is not in search path.", explanation, 0, ref_rule);
      278 	go to error;
      279 
      280 found_ref:
      281 	if namedup_sw then
      282 	     if after = 0 /* -before */ then
      283 		if namedup_index = i - 1 then go to another;  /* already there; remain silent */
      284 		else go to namedup_error;
      285 	     else if namedup_index = i + 1 then go to another;  /* remain silent */
      286 		else go to namedup_error;
      287 
      288 	place = i + after;				/* ordinal number for new rule */
      289 
      290 	do i = number_of_rules to place by -1;		/* move all the others up one */
      291 	     myrules.rules (i+1) = myrules.rules (i);
      292 	     rule_ids (i+1) = rule_ids (i);		/* so we don't lose track of correspondence */
      293 	end;
      294 
      295 simple_add:
      296 	myrules.rules (place) = new_rule;		/* put it in */
      297 	rule_ids (place) = new_id;
      298 	number_of_rules = number_of_rules + 1;
      299 
      300 	go to another;				/* and do it again! */
      301 
      302 error:	call com_err_ (code, myname, explanation);	/* make user feel bad */
      303 	error_gotten = "1"b;			/* to skip any following "-after" or "-before" */
      304 	go to another;				/* do it again */
      305 
      306 error_fin: call com_err_ (code, myname, "While processing ^a", new_rule); /* bad error, give up */
      307 all_done:
      308 	call hcs_$initiate_search_rules (addr (myrules), code); /* hand them to hardcore */
      309 	if code ^= 0 then call com_err_ (code, myname);	/* hardcore ungrateful */
      310 
      311 	return;
      312 
      313 delete_search_rules: dsr: entry;
      314 
      315 	myname = "delete_search_rules";
      316 	nargs = cu_$arg_count ();
      317 	if nargs = 0 then do;			/* user wants explanation, probably */
      318 	     call com_err_$suppress_name (0, myname,
      319 		"Usage:  ^a paths", myname);
      320 	     return;
      321 	end;
      322 
      323 	call setup;				/* get present rules */
      324 
      325 	do argno = 1 to nargs;			/* thru all args */
      326 
      327 	     call get_and_validate (ref_rule, del_error, branch_status.unique_id, del_error); /* set up for id match */
      328 
      329 	     do i = 1 to number_of_rules;		/* find it */
      330 		if rule_ids (i) = branch_status.unique_id & branch_status.unique_id ^= ""b then go to del_rule; /* id's match */
      331 		if myrules.rules (i) = ref_rule then go to del_rule; /* pathnames match */
      332 	     end;
      333 
      334 	     code = error_table_$name_not_found;	/* isn't in search rules */
      335 	     call ioa_$rsnnl ("^a not in search path.", explanation, 0, ref_rule);
      336 del_error:     call com_err_ (code, myname, explanation);	/* yell at user again */
      337 	     go to endloop;
      338 
      339 del_rule:	     do i = i to number_of_rules - 1;		/* scruntch them all down */
      340 		myrules.rules (i) = myrules.rules (i+1);
      341 		rule_ids (i) = rule_ids (i+1);
      342 	     end;
      343 
      344 	     number_of_rules = number_of_rules - 1;	/* one away */
      345 
      346 endloop:	end;					/* until we are all done */
      347 
      348 	go to all_done;
      349 
      350      end add_search_rules;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/19/88  1529.8  add_search_rules.pl1              >special_ldd>install>MR12.2-1016>add_search_rules.pl1
79           1    11/22/82  0955.6  branch_status.incl.pl1            >ldd>include>branch_status.incl.pl1
80           2    03/10/77  1345.4  system_dft_sr.incl.pl1            >ldd>include>system_dft_sr.incl.pl1
81           3    09/13/76  1100.5  search_rule_flags.incl.pl1        >ldd>include>search_rule_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
absolute_pathname_              000022 constant        entry                    external dcl 43 ref 173
addr                                                   builtin function         dcl 43 ref 103 103 104 104 108 108 180 180 307 307
after                           000261 automatic       fixed bin(17,0)          dcl 43 set ref 260* 261* 280 288
al                              000266 automatic       fixed bin(21,0)          dcl 43 set ref 128* 129 129 130 130 131 131 132 132
                                                                                  151* 155 155 155 155 155 163 163 163 163 163 163
                                                                                  163 163 170 171 173 173 175 186 193 194 237* 255
                                                                                  256 256 257 257 258 258 259 259 260 260 261 261
                                                                                  263 263
ap                              000264 automatic       pointer                  dcl 43 set ref 128* 129 129 130 130 131 131 132 132
                                                                                  151* 155 155 155 155 155 163 163 163 163 163 163
                                                                                  163 163 170 171 173 175 186 193 194 237* 255 256
                                                                                  256 257 257 258 258 259 259 260 260 261 261 263
arg                                    based           char                     unaligned dcl 43 set ref 129 129 130 130 131 131 132
                                                                                  132 155 155 155 155 155 163 163 163 163 163 163
                                                                                  163 163 170 171 173* 175 186 193 194 255 256 256
                                                                                  257 257 258 258 259 259 260 260 261 261 263*
argno                           000225 automatic       fixed bin(17,0)          dcl 43 set ref 135* 137* 137 151* 158* 158 165* 165
                                                                                  235* 235 237* 251* 251 268* 268 325*
branch_status                   000353 automatic       structure                level 1 dcl 1-1 set ref 108 108 180 180
code                            000267 automatic       fixed bin(35,0)          dcl 43 set ref 108* 109 109 128* 151* 153 173* 174
                                                                                  180* 182 182 212* 237* 238 244* 276* 302* 306*
                                                                                  307* 309 309* 334* 336*
com_err_                        000014 constant        entry                    external dcl 43 ref 263 302 306 309 336
com_err_$suppress_name          000016 constant        entry                    external dcl 43 ref 92 318
cu_$arg_count                   000012 constant        entry                    external dcl 43 ref 90 316
cu_$arg_ptr                     000020 constant        entry                    external dcl 43 ref 128 151 237
dft_sr_arg                             based           structure                level 1 dcl 2-4
error_gotten                    000226 automatic       bit(1)                   initial dcl 43 set ref 43* 155 159* 216* 303*
error_label                            parameter       label variable           dcl 146 ref 143 176 200
error_table_$badopt             000044 external static fixed bin(35,0)          dcl 43 set ref 263*
error_table_$name_not_found     000042 external static fixed bin(35,0)          dcl 43 ref 276 334
error_table_$namedup            000046 external static fixed bin(35,0)          dcl 43 ref 244
error_table_$no_s_permission    000040 external static fixed bin(35,0)          dcl 43 ref 109 182
error_table_$too_many_sr        000036 external static fixed bin(35,0)          dcl 43 ref 212
explanation                     000101 automatic       char(168)                dcl 43 set ref 175* 199* 245* 267* 277* 302* 335*
                                                                                  336*
force_sw                        000255 automatic       bit(1)                   unaligned dcl 43 set ref 126* 129* 130* 221
get_pdir_                       000024 constant        entry                    external dcl 43 ref 170
hbound                                                 builtin function         dcl 43 ref 112 211
hcs_$get_search_rules           000032 constant        entry                    external dcl 43 ref 104
hcs_$get_system_search_rules    000034 constant        entry                    external dcl 43 ref 103
hcs_$initiate_search_rules      000050 constant        entry                    external dcl 43 ref 307
hcs_$status_long                000030 constant        entry                    external dcl 43 ref 108 180
i                               000262 automatic       fixed bin(17,0)          dcl 43 set ref 106* 107 108 109 113 114* 127* 128*
                                                                                  185* 186 187 188* 192* 193* 219* 220 220 223* 223*
                                                                                  224 224 225 225* 230* 271* 272 273* 280 285 288
                                                                                  290* 291 291 292 292* 329* 330 331* 339* 339* 340
                                                                                  340 341 341*
index                                                  builtin function         dcl 43 ref 155 255
inhibit_err_sw                  000256 automatic       bit(1)                   unaligned dcl 43 set ref 126* 131* 132* 243
ioa_$rsnnl                      000010 constant        entry                    external dcl 43 ref 245 277 335
j                               000263 automatic       fixed bin(17,0)          dcl 43 set ref 112* 113 114*
myname                          000343 automatic       char(32)                 unaligned dcl 43 set ref 89* 92* 92* 263* 302* 306*
                                                                                  309* 315* 318* 318* 336*
myrules                         004667 automatic       structure                level 1 dcl 85 set ref 104 104 307 307
name                      2     000365 automatic       char(32)                 array level 3 dcl 83 set ref 193
namedup_index                   000260 automatic       fixed bin(17,0)          dcl 43 set ref 230* 239 280 285
namedup_sw                      000257 automatic       bit(1)                   unaligned dcl 43 set ref 217* 229* 239 280
nargs                           000100 automatic       fixed bin(17,0)          dcl 43 set ref 90* 91 127 316* 317 325
new_id                          000254 automatic       bit(36)                  unaligned dcl 43 set ref 139* 220 220 297
new_rule                        000270 automatic       char(168)                dcl 43 set ref 139* 220 245* 295 306*
no_arg_label                           parameter       label variable           dcl 146 ref 143 153
ntags                           000365 automatic       fixed bin(17,0)          level 2 dcl 83 set ref 192
null                                                   builtin function         dcl 43 ref 108 108 180 180
number_of_rules                 004667 automatic       fixed bin(17,0)          level 2 dcl 85 set ref 106 211 219 222* 222 223 239
                                                                                  250 271 290 298* 298 329 339 344* 344
place                           000342 automatic       fixed bin(17,0)          dcl 43 set ref 250* 288* 290 295 297
ref_rule                        000153 automatic       char(168)                dcl 43 set ref 269* 273 277* 327* 331 335*
rule_ids                        000227 automatic       bit(36)                  array dcl 43 set ref 107* 109* 114* 211 220 225* 225
                                                                                  272 292* 292 297* 330 341* 341
rules                     1     004667 automatic       char(168)                array level 2 dcl 85 set ref 108* 113 220 224* 224
                                                                                  273 291* 291 295* 331 340* 340
search_rule_names               000000 constant        char(32)                 initial array dcl 3-9 ref 112 113 186 188
substr                                                 builtin function         dcl 43 set ref 114* 187*
system_rules                    000365 automatic       structure                level 1 dcl 83 set ref 103 103
tags                      2     000365 automatic       structure                array level 2 dcl 83
unique_id                11     000353 automatic       bit(36)                  level 2 packed unaligned dcl 1-1 set ref 109 203
                                                                                  269* 272 272 327* 330 330
user_info_$homedir              000026 constant        entry                    external dcl 43 ref 171
which_id                               parameter       bit(36)                  unaligned dcl 146 set ref 143 184* 187* 203*
which_rule                             parameter       char                     dcl 146 set ref 143 170* 171* 173* 180* 188* 194*
                                                                                  199

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BAD_RULE                               internal static bit(18)                  initial unaligned dcl 3-7
END_RULE                               internal static bit(18)                  initial unaligned dcl 3-6
INITIATED_RULE                         internal static bit(18)                  initial unaligned dcl 3-3
REFERENCING_DIR_RULE                   internal static bit(18)                  initial unaligned dcl 3-4
WDIR_RULE                              internal static bit(18)                  initial unaligned dcl 3-5
directory_type                         internal static bit(2)                   initial dcl 1-1
link_type                              internal static bit(2)                   initial dcl 1-1
msf_type                               internal static bit(2)                   initial dcl 1-1
segment_type                           internal static bit(2)                   initial dcl 1-1
xsp                                    automatic       pointer                  dcl 2-3

NAMES DECLARED BY EXPLICIT CONTEXT.
add_search_rules                000265 constant        entry                    external dcl 27
all_done                        001221 constant        label                    dcl 307 ref 139 139 239 348
another                         000446 constant        label                    dcl 137 ref 280 285 300 304
asr                             000255 constant        entry                    external dcl 27
bad_option                      000740 constant        label                    dcl 263 ref 163
del_error                       001440 constant        label                    dcl 336 ref 327 327 327 327
del_rule                        001462 constant        label                    dcl 339 ref 330 331
delete_search_rules             001265 constant        entry                    external dcl 313
dsr                             001255 constant        entry                    external dcl 313
endloop                         001510 constant        label                    dcl 346 ref 337
error                           001146 constant        label                    dcl 302 ref 139 139 246 269 269 269 269 278
error_fin                       001172 constant        label                    dcl 306 ref 213
found_ref                       001067 constant        label                    dcl 280 ref 272 273
get_and_validate                001667 constant        entry                    internal dcl 143 ref 139 269 327
namedup_error                   000574 constant        label                    dcl 243 ref 284 286
next_arg                        000547 constant        label                    dcl 235 ref 256 257 258 259
nxrule                          001664 constant        label                    dcl 119 ref 115
one_string                      000567 constant        label                    dcl 239 ref 255
setup                           001513 constant        entry                    internal dcl 101 ref 97 323
simple_add                      001133 constant        label                    dcl 295 set ref 252
start_gav                       001700 constant        label                    dcl 151 ref 160 166
usage_error                     000307 constant        label                    dcl 92 ref 155

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2616        2670    2356        2626
Length      3156    2356        52         252     240           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
asr                                3534 external procedure  is an external procedure.  
setup                                   internal procedure  shares stack frame of external procedure asr.  
get_and_validate                        internal procedure  shares stack frame of external procedure asr.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
asr                      000100 nargs                       asr
                         000101 explanation                 asr
                         000153 ref_rule                    asr
                         000225 argno                       asr
                         000226 error_gotten                asr
                         000227 rule_ids                    asr
                         000254 new_id                      asr
                         000255 force_sw                    asr
                         000256 inhibit_err_sw              asr
                         000257 namedup_sw                  asr
                         000260 namedup_index               asr
                         000261 after                       asr
                         000262 i                           asr
                         000263 j                           asr
                         000264 ap                          asr
                         000266 al                          asr
                         000267 code                        asr
                         000270 new_rule                    asr
                         000342 place                       asr
                         000343 myname                      asr
                         000353 branch_status               asr
                         000365 system_rules                asr
                         004667 myrules                     asr

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          tra_ext_2           ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            com_err_                      com_err_$suppress_name        cu_$arg_count
cu_$arg_ptr                   get_pdir_                     hcs_$get_search_rules         hcs_$get_system_search_rules
hcs_$initiate_search_rules    hcs_$status_long              ioa_$rsnnl                    user_info_$homedir

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$name_not_found   error_table_$namedup          error_table_$no_s_permission
error_table_$too_many_sr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     43 000251        27 000254        89 000273        90 000276        91 000305        92 000307        94 000337
     97 000340       126 000341       127 000343       128 000353       129 000370       130 000405       131 000417
    132 000432       133 000443       135 000445       137 000446       139 000447       211 000460       212 000463
    213 000466       216 000467       217 000470       219 000471       220 000477       221 000512       222 000514
    223 000516       224 000525       225 000533       226 000536       227 000540       229 000541       230 000543
    233 000545       235 000547       237 000550       238 000565       239 000567       243 000574       244 000576
    245 000601       246 000630       250 000631       251 000634       252 000636       255 000637       256 000653
    257 000663       258 000673       259 000703       260 000713       261 000725       263 000740       264 000772
    267 000773       268 000776       269 000777       271 001010       272 001017       273 001024       274 001032
    276 001034       277 001037       278 001066       280 001067       284 001077       285 001100       286 001104
    288 001105       290 001110       291 001117       292 001125       293 001130       295 001133       297 001141
    298 001144       300 001145       302 001146       303 001167       304 001171       306 001172       307 001221
    309 001234       311 001253       313 001254       315 001273       316 001276       317 001305       318 001307
    320 001340       323 001341       325 001342       327 001351       329 001362       330 001371       331 001376
    332 001404       334 001406       335 001411       336 001440       337 001461       339 001462       340 001473
    341 001501       342 001504       344 001506       346 001510       348 001512       101 001513       103 001514
    104 001530       106 001541       107 001551       108 001552       109 001616       112 001627       113 001635
    114 001650       115 001661       117 001662       119 001664       122 001666       143 001667       151 001700
    153 001715       155 001722       158 001760       159 001762       160 001763       163 001764       165 002024
    166 002025       170 002026       171 002052       173 002072       174 002120       175 002122       176 002127
    180 002132       182 002176       184 002203       185 002210       186 002215       187 002226       188 002234
    189 002241       191 002242       192 002244       193 002253       194 002263       195 002271       197 002272
    199 002274       200 002302       203 002304       205 002311


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
