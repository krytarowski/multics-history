	COMPILATION LISTING OF SEGMENT cm_put
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0953.6 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION
        9*
       10*        This module implements collection_manager_$put.
       11*
       12*        This module is a transfer vector of sorts for routines which put
       13*   an element.  Two things determine the proper routine to invoke: the Element
       14*   Storage Method used by the collection and the entry through which this
       15*   routine was invoked.  The ESM is determined by looking in the
       16*   collection_header.  The $info and $buffered_info entries are passed the
       17*   collection_header as part of the cm_info structure; The other entries get
       18*   the collection_header by setting up a cm_info structure
       19*   (cm_opening_info$get).  If entered through one of the buffered entries,
       20*   this is a "buffered allocation".  Buffered puts are only supported for
       21*   ordered ESM collections.
       22*   
       23*        If Ordered ESM is in force, p_element_id contains the control
       24*   interval/slot number to put; if Basic ESM, p_element_id holds ci/slot
       25*   of the "related" element (see the documentation for explanation of related
       26*   element).  If BESM, a free slot is looked for; if OESM slots to the right
       27*   of the specified slot are shifted over one.  An optimization exists which
       28*   should be implemented in the next phase which will keep track of whether a
       29*   free slot exists in a ci.
       30*
       31*
       32*   ***** NOTE: The term "put" was previously referred to as "allocate" *****
       33*   ***** "Put" means to allocate space for a new element, and put the  *****
       34*   ***** value of the element in that space.                           *****
       35**/
       36 
       37 /* HISTORY:
       38*Written by Matthew C Pierret.
       39*Modified:
       40*03/23/82 by Matthew Pierret: Added "header" entry to allow collection manager
       41*            routines to supply the collmgr_header.  This saves a get of that
       42*            structure and assures that all modules are working on the same copy
       43*            of the structure.
       44*04/07/82 by Matthew Pierret: Added calculation of maxim space available.
       45*                 Added following logic: If the requested control 
       46*            interval is 0 but the requested collection is not the header
       47*            collection (meaning that no particular control interval is
       48*            requested) then check the last_used_ci for the collection. If
       49*            non-zero, then set element_id.control_interval_id to be the
       50*            last_used_ci. If zero, then allocate a new control interval and set
       51*            element_id.control_interval_id to be the new control interval.
       52*            This is done for Basic ESM only. It is an error for such a situation
       53*            to occur using Ordered ESM
       54*04/17/82 by Matthew Pierret: Removed call to cm_get_header_and_slot. This is
       55*            now done at a later stage for each control interval attempted.
       56*            This approach helps eliminate inconsistencies between the ci
       57*            header this routine looks at and the one its subroutines look at.
       58*06/08/82 by Matthew Pierret: Changed to use collection_header instead of
       59*            collmgr_header.collection (). Also made calculation of maximum
       60*            free space take datum header into account, returning only the
       61*            largest element acceptable instead of the largest datum.
       62*06/15/82 by Matthew Pierret: Changed to use bci_header, dm_cm_basic_ci.incl.
       63*08/03/82 by Matthew Pierret: Changed to use last_control_interval in calling
       64*            sequence to cm_allocate_basic_element.
       65*09/07/82 by Matthew Pierret: Fixed p_code/code bug in call to cm_get_element.
       66*11/09/82 by Matthew Pierret: Added opening info. Moved calculation of free
       67*            space into lower routines.
       68*01/07/83 by Matthew Pierret: Added $buffered and $buffered_info entries.
       69*            Basic ESM still does not support buffered allocation.
       70*01/07/83 by Matthew Pierret: Fixed bug which set bci_header_ptr to the addr of
       71*            a local automatic_bci_header even if p_ci_buffer_ptr was supplied.
       72*02/02/83 by Matthew Pierret: Upgraded to CM_INFO_VERSION_2.
       73*05/21/84 by Matthew Pierret: Renamed include file dm_cm_esm_info to dm_esm_info
       74*10/03/84 by Matthew Pierret: Removed un-used constants. Added unspec builtin.
       75*            Removed unnecessary calls-by-value to CHECK_VERSION.  Changed to
       76*            use the standard sub_err_ action flags and to use the code
       77*            dm_error_$unimplemented_esm instead of 0 in sub_err_ call
       78*            reporting that the Basic ESM cannot use the buffered access method.
       79**/
       80 
       81 
       82 /* format: style2,ind3 */
       83 
       84 cm_put:
       85    proc (p_file_opening_id, p_collection_id, p_element_ptr, p_element_length, p_element_id, p_maximum_space_available,
       86         p_code);
       87 
       88 
       89 /* START OF DECLARATIONS */
       90 /* Parameter */
       91 
       92       dcl	    p_cm_info_ptr	       ptr;
       93       dcl	    p_ci_buffer_ptr	       ptr;
       94       dcl	    p_file_opening_id      bit (36) aligned;
       95       dcl	    p_collection_id	       bit (36) aligned;
       96       dcl	    p_element_length       fixed bin (35);
       97       dcl	    p_element_ptr	       ptr;
       98       dcl	    p_element_id	       bit (36) aligned;
       99       dcl	    p_maximum_space_available
      100 			       fixed bin (35);
      101       dcl	    p_code	       fixed bin (35);
      102 
      103 /* Automatic */
      104 
      105       dcl	    1 automatic_bci_header aligned like bci_header;
      106       dcl	    element_length_in_bits fixed bin (35);
      107       dcl	    is_buffered	       bit (1) aligned init ("0"b);
      108 
      109 /* Based */
      110 /* Builtin */
      111 
      112       dcl	    (addr, null, unspec)   builtin;
      113 
      114 /* Controlled */
      115 /* Constant */
      116 
      117       dcl	    myname	       init ("cm_put") char (32) varying int static options (constant);
      118 
      119 /* Entry */
      120 
      121       dcl	    sub_err_	       entry () options (variable);
      122 
      123 /* External */
      124 
      125       dcl	    dm_error_$unimplemented_esm
      126 			       ext fixed bin (35);
      127       dcl	    error_table_$unimplemented_version
      128 			       ext fixed bin (35);
      129 
      130 
      131 /* END OF DECLARATIONS */
      132 
      133       unspec (automatic_bci_header) = "0"b;
      134       bci_header_ptr = addr (automatic_bci_header);
      135 
      136       goto NO_INFO_JOIN;
      137 
      138 buffered:
      139    entry (p_ci_buffer_ptr, p_file_opening_id, p_collection_id, p_element_ptr, p_element_length, p_element_id,
      140         p_maximum_space_available, p_code);
      141 
      142       is_buffered = "1"b;
      143       bci_header_ptr = p_ci_buffer_ptr;
      144 
      145 NO_INFO_JOIN:
      146       call cm_opening_info$get (p_file_opening_id, p_collection_id, cm_info_ptr, p_code);
      147       if p_code ^= 0
      148       then return;
      149 
      150       goto JOIN;
      151 
      152 
      153 info:
      154    entry (p_cm_info_ptr, p_element_ptr, p_element_length, p_element_id, p_maximum_space_available, p_code);
      155 
      156       cm_info_ptr = p_cm_info_ptr;
      157       unspec (automatic_bci_header) = "0"b;
      158       bci_header_ptr = addr (automatic_bci_header);
      159 
      160       goto JOIN;
      161 
      162 /********************* Not yet used. ********************
      163*
      164*buffered_info:
      165*   entry (p_cm_info_ptr, p_ci_buffer_ptr, p_element_ptr, p_element_length, p_element_id, p_maximum_space_available,
      166*      p_code);
      167*
      168*      is_buffered = "1"b;
      169*      cm_info_ptr = p_cm_info_ptr;
      170*      bci_header_ptr = p_ci_buffer_ptr;
      171*
      172*      goto JOIN;
      173*
      174************************************************************* */
      175 
      176 
      177 JOIN:
      178       call CHECK_VERSION ("cm_info", cm_info.version, CM_INFO_VERSION_2);
      179 
      180       collection_header_ptr = cm_info.header_ptr;
      181 
      182       call CHECK_VERSION ("collection_header", collection_header.version, COLLECTION_HEADER_VERSION_2);
      183 
      184       p_code = 0;
      185       p_maximum_space_available = -1;
      186 
      187       element_id_string = p_element_id;
      188 
      189       if collection_header.flags.fixed_size_elements
      190       then element_length_in_bits = collection_header.maximum_element_size;
      191       else element_length_in_bits = p_element_length;
      192 
      193       if collection_header.element_storage_method = ORDERED_ELEMENT_STORAGE_METHOD
      194       then if is_buffered
      195 	 then call cm_put_ordered_element$buffered (cm_info_ptr, bci_header_ptr, element_length_in_bits, p_element_ptr,
      196 		 element_id_string, p_maximum_space_available, p_code);
      197 	 else call cm_put_ordered_element (cm_info_ptr, bci_header_ptr, element_length_in_bits, p_element_ptr,
      198 		 element_id_string, p_maximum_space_available, p_code);
      199 
      200       else if is_buffered
      201       then call sub_err_ (dm_error_$unimplemented_esm, myname, ACTION_CANT_RESTART, null, 0,
      202 	      "Buffered element allocation is not supported for collections using the^/Basic element storage method.");
      203       else call cm_put_basic_element (cm_info_ptr, bci_header_ptr, element_length_in_bits, p_element_ptr,
      204 	      element_id_string, p_maximum_space_available, p_code);
      205 
      206 
      207       if p_code = 0
      208       then p_element_id = element_id_string;
      209 
      210 
      211       return;					/* Effective end of cm_put */
      212 
      213 
      214 CHECK_VERSION:
      215    proc (p_structure_name, p_given_version, p_correct_version);
      216 
      217       dcl	    p_structure_name       char (*);
      218       dcl	    p_given_version	       char (8) aligned;
      219       dcl	    p_correct_version      char (8) aligned;
      220 
      221       if p_given_version ^= p_correct_version
      222       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      223 	      "^/Expected version ""^8a"" of ^a structure; received ""^8a"".", p_correct_version, p_structure_name,
      224 	      p_given_version);
      225 
      226       return;
      227 
      228    end CHECK_VERSION;
      229 
  1     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*        The cm_info structure is used to hold per-process opening information
  1     5*   about a collection.  It is generally allocated in the process' DM free
  1     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  1     7*   is used to provide access the cm_info structure, keeping it in a hash
  1     8*   table keyed on file opening id and collection id combined.
  1     9*        Currently cm_info is never freed until the process terminates.  Each
  1    10*   time a new transaction is started, detected when the current transaction
  1    11*   id of a process differs from cm_info.current_transaction_id, the information
  1    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  1    13*   demand, as most modules do not need the information in the storage record.
  1    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  1    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  1    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  1    17*   requested, it is placed at the location pointed to by
  1    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  1    19**/
  1    20 
  1    21 /* HISTORY:
  1    22*Written by Matthew Pierret, 10/27/82. 
  1    23*Modified:
  1    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  1    25*            storage_record_buffer_ptr. This points to the storage_record.
  1    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  1    27*            but storage_record_buffer_ptr continues to point at where the
  1    28*            storage_record was. When the storge_record is again requested,
  1    29*            it is put back in the same place rather than allocating a new
  1    30*            storage_record.
  1    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  1    32*            init clause from the version component.
  1    33**/
  1    34 
  1    35 /* format: style2,ind3,ll79 */
  1    36 
  1    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  1    38 	     2 version	      char (8),
  1    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  1    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  1    41 	     2 collection_id      bit (36) aligned init ("0"b),
  1    42 	     2 header_ptr	      ptr init (null),
  1    43 	     2 storage_record_ptr ptr init (null),
  1    44 	     2 storage_record_buffer_ptr
  1    45 			      ptr init (null);
  1    46 
  1    47      dcl	   cm_info_ptr	      ptr init (null);
  1    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  1    49 			      internal static options (constant);
  1    50 
  1    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      230 
      231 
  2     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*        The collection_manager_ manages the structure of the addressable
  2     6*   portion of a control interval.  The addressable portion is that portion of
  2     7*   a control interval which the file_manager_ will allow the
  2     8*   collection_manager_ to address.  In this description control interval will
  2     9*   be used to mean the addressable portion of a control interval.
  2    10*   
  2    11*        A control interval is divided into four parts: the header, the datum
  2    12*   position table (also known as the slot table or slots), un-used space and
  2    13*   used space.  The beginning of the header is at offset 0, and the end of the
  2    14*   used space is at the end of the control interval (curently offset 4072).
  2    15*   Pictoriarly, a control interval is structured as follows:
  2    16*   
  2    17*   ----------------------------------------------------------------------
  2    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  2    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  2    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  2    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  2    22*   ----------------------------------------------------------------------
  2    23*                                           ^ ^    ^      ^    ^  ^   ^
  2    24*                                           | |    |      |    |  |   |
  2    25*                                           | |...........|.......|...|
  2    26*                        start of used space|      |           |      |
  2    27*                                                  |           |  each|
  2    28*                                          scattered free space|  is a used
  2    29*                                                                 datum
  2    30*   
  2    31*      The basic_control_interval structure describes the header
  2    32*   (basic_control_interval.header, bci_header) and the slots
  2    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  2    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  2    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  2    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  2    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  2    38**/
  2    39 
  2    40 /* HISTORY:
  2    41*Written by Matthew Pierret, 02/07/82.
  2    42*Modified:
  2    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  2    44*            and its sub-structures.
  2    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  2    46*            basic_ci_header to bci_header. Added previous_control_interval.
  2    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  2    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  2    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  2    50*            is not used.
  2    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  2    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  2    53**/
  2    54 
  2    55 /* format: style2 */
  2    56      dcl	   1 basic_control_interval
  2    57 			      aligned based (basic_control_interval_ptr),
  2    58 	     2 header	      like bci_header,
  2    59 	     2 datum_position_table
  2    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  2    61 
  2    62 
  2    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  2    64 	     2 layout_type	      char (4) aligned,
  2    65 	     2 collection_id      bit (36) aligned,
  2    66 	     2 next_control_interval
  2    67 			      fixed bin (24) uns unal,
  2    68 	     2 previous_control_interval
  2    69 			      fixed bin (24) uns unal,
  2    70 	     2 flags	      unal,
  2    71 	       3 continuation_datum_is_present
  2    72 			      bit (1) unal,
  2    73 	       3 free_slot_is_present
  2    74 			      bit (1) unal,
  2    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  2    76 	     2 scattered_free_space
  2    77 			      fixed bin (17) unal,
  2    78 	     2 start_of_used_space
  2    79 			      fixed bin (17) unal,
  2    80 	     2 number_of_datums   fixed bin (17) unal;
  2    81 
  2    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  2    83 	     2 flags	      unal,
  2    84 	       3 special_format_datum
  2    85 			      bit (1) unal,		/* reserved */
  2    86 	       3 is_continued     bit (1) unal,
  2    87 	       3 is_continuation  bit (1) unal,
  2    88 	       3 mbz	      bit (1) unal,		/* reserved */
  2    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  2    90 	     2 length_in_bits     fixed bin (17) uns unal;
  2    91 
  2    92      dcl	   basic_control_interval_ptr
  2    93 			      ptr;
  2    94      dcl	   bci_header_ptr	      ptr;
  2    95      dcl	   datum_slot_ptr	      ptr;
  2    96 
  2    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  2    98 
  2    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      232 
      233 
  3     1 /* BEGIN INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*       Associated with each collection is the following collection_header
  3     5*   structure stored as an element in the Header Collection of the file.
  3     6*   The identifier of this element is also the idenfifier of the collection.
  3     7*   Even the Header Collection has a collection_header stored in the Header
  3     8*   Collection itself in the element identified by the constant
  3     9*   HEADER_COLLECTION_HEADER_ELEMENT_ID declared in dm_cm_hdr_col_ids.incl.pl1.
  3    10*   The information in collection_header is expected to be stable information.
  3    11*   The structure elements are described as follows:
  3    12*   
  3    13*   version is a character string version equal to COLLECTION_HEADER_VERSION_2.
  3    14*   
  3    15*   flags.fixed_size_elements indicates, if on that all elements in the
  3    16*   collection are of a fixed length.
  3    17*   
  3    18*   flags.thread_elements indicates that elements in a collection are to be
  3    19*   threaded in a linked list.  This is currrently unupported.
  3    20*   
  3    21*   flags.thread_control_intervals indicates, if on, that control intervals in
  3    22*   a collection are to be threaded in a linked list.  This is only useful if
  3    23*   the control interval storage method is blocked.
  3    24*   
  3    25*   flags.must_be_zero1 is reserved for future use and must be "0"b.
  3    26*   
  3    27*   control_interval_storage_method is the method of storage management of
  3    28*   control intervals for this collection, either
  3    29*   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD (not yet supported) or
  3    30*   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, declared in
  3    31*   dm_cism_info.incl.pl1.
  3    32*   
  3    33*   element_storage_method is the method of storage management of elements in
  3    34*   this collection, either BASIC_ELEMENT_STORAGE_METHOD or
  3    35*   ORDERED_ELEMENT_STORAGE_METHOD, declared in dm_esm_info.incl.pl1.
  3    36*   
  3    37*   maximum_element_size is the maximum size of an element in bits in this
  3    38*   collection.
  3    39*   
  3    40*   header_record_element_id is the identifier of an element containing a
  3    41*   caller-defined header for this collection.  If equal to "0"b, no
  3    42*   caller-defined header yet exists.  The put_header collection_manager_
  3    43*   operation stores such a header.
  3    44*   
  3    45*   storage_record_element_id is the identifier of the element containing the
  3    46*   storage_record for this collection.  The storage_record contains
  3    47*   information expected to be dynamic, such as the identifier of the last
  3    48*   control interval of the collection.  Its format is also dependent upon the
  3    49*   storage methods in effect for this collection.  storage_record structures
  3    50*   are declared in dm_cm_storage_record.incl.pl1.
  3    51*
  3    52**/
  3    53 
  3    54 /* HISTORY:
  3    55*Written by Matthew Pierret, 04/01/82.
  3    56*Modified:
  3    57*07/01/82 by Matthew Pierret: Changed to version A, added storage_record_area.
  3    58*10/29/82 by Matthew Pierret: Changed to version 2 ("col_hdr2"), separated
  3    59*            storage_record_area out, leaving storage_record_element_id behind.
  3    60*09/18/84 by Matthew Pierret: Added DESCRIPTION section.
  3    61**/
  3    62 
  3    63 /* format: style2,ind3,ll79 */
  3    64 
  3    65      dcl	   1 collection_header    aligned based (collection_header_ptr),
  3    66 	     2 version	      char (8),
  3    67 	     2 flags	      unaligned,
  3    68 	       3 fixed_size_elements
  3    69 			      bit (1),
  3    70 	       3 thread_elements  bit (1),
  3    71 	       3 thread_control_intervals
  3    72 			      bit (1),
  3    73 	       3 must_be_zero1    bit (15),
  3    74 	     2 control_interval_storage_method
  3    75 			      fixed bin (17) unal,
  3    76 	     2 element_storage_method
  3    77 			      fixed bin (17),
  3    78 	     2 maximum_element_size
  3    79 			      fixed bin (35),
  3    80 	     2 header_record_element_id
  3    81 			      bit (36) aligned,
  3    82 	     2 storage_record_element_id
  3    83 			      bit (36) aligned;
  3    84 
  3    85      dcl	   collection_header_ptr  ptr;
  3    86      dcl	   COLLECTION_HEADER_VERSION_2
  3    87 			      init ("col_hdr2") char (8) aligned
  3    88 			      int static options (constant);
  3    89 
  3    90 /* END INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
      234 
      235 
  4     1 /* BEGIN INCLUDE FILE dm_esm_info.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*     This include file contains the basic_esm_info and ordered_esm_info
  4     6*     structures, as well as constants used to distinguish element storage
  4     7*     methods.  They are used by several managers to describe the type of
  4     8*     element storage management to be used in a collection.
  4     9**/
  4    10 
  4    11 /* HISTORY:
  4    12*Written 02/07/82 by Matthew Pierret.
  4    13*Modified:
  4    14*05/17/84 by Matthew Pierret:  Changed name from dm_cm_esm_info (the cm_
  4    15*            dropped because the include file is used by multiple managers),
  4    16*            to align structure elements and to add a version string.
  4    17**/
  4    18 
  4    19 /* format: style2 */
  4    20 
  4    21      dcl	   1 basic_esm_info	      based (basic_esm_info_ptr) aligned,
  4    22 	     2 version	      char (8) aligned init (ESM_INFO_VERSION_1),
  4    23 	     2 type	      fixed bin (17) init (BASIC_ELEMENT_STORAGE_METHOD),
  4    24 	     2 flags	      aligned,
  4    25 	       3 threaded	      bit (1) unal,
  4    26 	       3 fixed_length     bit (1) unal,
  4    27 	       3 pad	      bit (34) unal,
  4    28 	     2 maximum_element_length
  4    29 			      fixed bin (35);
  4    30 
  4    31      dcl	   1 ordered_esm_info     based (ordered_esm_info_ptr) aligned,
  4    32 	     2 version	      char (8) aligned init (ESM_INFO_VERSION_1),
  4    33 	     2 type	      fixed bin (17) init (ORDERED_ELEMENT_STORAGE_METHOD),
  4    34 	     2 flags	      aligned,
  4    35 	       3 fixed_length     bit (1) unal,
  4    36 	       3 pad	      bit (35) unal,
  4    37 	     2 maximum_element_length
  4    38 			      fixed bin (35);
  4    39 
  4    40      dcl	   basic_esm_info_ptr     ptr;
  4    41      dcl	   ordered_esm_info_ptr   ptr;
  4    42 
  4    43      dcl	   ESM_INFO_VERSION_1     init ("ESMinfo1") char (8) aligned internal static options (constant);
  4    44      dcl	   BASIC_ELEMENT_STORAGE_METHOD
  4    45 			      fixed bin init (1) internal static options (constant);
  4    46      dcl	   ORDERED_ELEMENT_STORAGE_METHOD
  4    47 			      fixed bin init (2) internal static options (constant);
  4    48 
  4    49 
  4    50 /* END INCLUDE FILE dm_esm_info.incl.pl1 */
      236 
      237 
  5     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        Contains the declaration of an element identifier.  Element
  5     6*   identifiers consist of two parts, the id (number) of the control interval
  5     7*   in which the element resides, and the index into the slot table of
  5     8*   the element in the control interval.  The declaration of the element_id 
  5     9*   structure reflects this division of the element identifier.  The structure 
  5    10*   is based on the automatic bit string element_id_string because programs
  5    11*   generally pass bit strings (element_id_string) to each other, then 
  5    12*   interpret the bit string by overlaying the element_id structure ony if
  5    13*   it is necessary to access the parts of the id.  Basing element_id on
  5    14*   addr(element_id_string) instead of on a pointer removes the necessity
  5    15*   for always setting that pointer explicitly and guarantees that changes
  5    16*   made to the string or structure do not get inconsistent.
  5    17*
  5    18*   Changes made to element_id must also be made to datum_id, declared in 
  5    19*   dm_cm_datum.incl.pl1.
  5    20**/
  5    21 
  5    22 /* HISTORY:
  5    23*Written by Matthew Pierret, 04/01/82.
  5    24*Modified:
  5    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  5    26**/
  5    27 
  5    28 /* format: style2,ind3,ll79 */
  5    29 
  5    30      dcl	   element_id_string      bit (36) aligned;
  5    31 
  5    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  5    33 	     2 control_interval_id
  5    34 			      fixed bin (24) unal unsigned,
  5    35 	     2 index	      fixed bin (12) unal unsigned;
  5    36 
  5    37 
  5    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      238 
      239 
  6     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*   Contains entry declarations of internally available collection_manager_
  6     6*   entries.  Entries which are only available via the collection_manager_
  6     7*   transfer vector are not included here, but are declared instead in 
  6     8*   dm_collmgr_entry_dcls.incl.pl1.
  6     9**/
  6    10 
  6    11 /* HISTORY:
  6    12*Written by Mathew Pierret, 04/01/82.
  6    13*Modified:
  6    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
  6    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
  6    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
  6    17*            Added cm_get_element$info*, $header*.  The former is used when
  6    18*            the caller has a cm_info structure already; the latter is used to
  6    19*            get collection headers.
  6    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
  6    21*            Added cm_allocate_element$info.
  6    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
  6    23*            calling sequence for returning free space.
  6    24*            Added cm_free_cn_datum("" $header).
  6    25*01/07/83 by Matthew Pierret:  Added:
  6    26*            cm_allocate_element$buffered("" _info);
  6    27*            cm_put_element$buffered("" _info);
  6    28*            cm_put_datum_in_place$buffered("" _continued);
  6    29*            cm_put_datum_in_pool$buffered("" _continued);
  6    30*            cm_compact$buffered.
  6    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
  6    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
  6    33*            Added cm_opening_info$get_storage_record.
  6    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
  6    35*            id of the previous datum.
  6    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
  6    37*            which is for the number of slots after allocation.
  6    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
  6    39*            header header_return_slot).
  6    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
  6    41*            Added cm_get_element$bypass_info.
  6    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
  6    43*            cm_free_opening_info.
  6    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
  6    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
  6    46*            $does_replacement_fit to cm_determine_free_space.  These entries
  6    47*            return flags indicating if a datum fits in the ci and the pool.
  6    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
  6    49*            returned the new value of bci_header.free_slot_is_present.
  6    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
  6    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
  6    52*            entries.  Changed cm_get_element_$bypass_info to have the same
  6    53*            calling sequence as other cm_get_element entries.
  6    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
  6    55*            and cm_allocate_element to cm_put.
  6    56*            Switched the element_length/element_ptr parameter pair to be
  6    57*            element_ptr/element_length in cm_modify and cm_put.
  6    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
  6    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
  6    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
  6    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
  6    62*            Removed cm_find_free_space. Commented out un-used entries.
  6    63*            Re-named allocate  entries to put entries, except for allocate_ci.
  6    64*            Re-named free element and free datum entries to use delete instead
  6    65*            of free, and cm_recursive_put to cm_recursive_modify.
  6    66*            Removed cm_get_element$bypass_info.
  6    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
  6    68*            that cm_modify$buffered uses it.
  6    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
  6    70**/
  6    71 
  6    72 /* format: style2,ind3 */
  6    73 
  6    74 
  6    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  6    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
  6    77      dcl	   cm_allocate_ci$info_header
  6    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
  6    79 
  6    80 
  6    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  6    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  6    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  6    84      dcl	   cm_compact$buffered_replacement
  6    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  6    86 
  6    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  6    88 
  6    89      dcl	   cm_delete_cn_datum$header
  6    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  6    91 
  6    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  6    93 			      fixed bin (35));
  6    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
  6    95 
  6    96      dcl	   cm_determine_free_space$all
  6    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
  6    98      dcl	   cm_determine_free_space$effective
  6    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
  6   100 			      fixed bin (35));
  6   101      dcl	   cm_determine_free_space$does_new_datum_fit
  6   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
  6   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
  6   104 
  6   105 /**** Not yet used *********************************************************
  6   106*     dcl	   cm_determine_free_space$does_replacement_fit
  6   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
  6   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
  6   109*************************************************************************** */
  6   110 
  6   111      dcl	   cm_find_ci_to_alloc_datum
  6   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
  6   113 			      fixed bin (24) uns, fixed bin (35));
  6   114 
  6   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
  6   116 			      bit (1) aligned, fixed bin (35));
  6   117 
  6   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
  6   119      dcl	   cm_free_ci$raw_return_prev_next
  6   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
  6   121 			      fixed bin (24) uns, fixed bin (35));
  6   122      dcl	   cm_free_ci$trace_thread_modifications_on
  6   123 			      entry ();
  6   124      dcl	   cm_free_ci$trace_thread_modifications_off
  6   125 			      entry ();
  6   126 
  6   127 
  6   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  6   129 
  6   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  6   131      dcl	   cm_get_bci_header$exclusive
  6   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  6   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  6   134 
  6   135 /**** Not yet used ********************************************************
  6   136*     dcl	   cm_get_bci_header$slot_exclusive
  6   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  6   138*************************************************************************** */
  6   139 
  6   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  6   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  6   142      dcl	   cm_get_element$exclusive
  6   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  6   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  6   145 
  6   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  6   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  6   148 			      fixed bin (35), fixed bin (35));
  6   149 
  6   150 /**** Not yet used ********************************************************
  6   151*     dcl	   cm_get_element_portion$exclusive
  6   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  6   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  6   154*			      fixed bin (35), fixed bin (35));
  6   155*************************************************************************** */
  6   156 
  6   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  6   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  6   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  6   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  6   161 
  6   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   163 			      fixed bin (35), fixed bin (35));
  6   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   165 			      fixed bin (35), fixed bin (35));
  6   166 
  6   167 /******* Not yet used *****************************************************
  6   168*     dcl	   cm_modify$buffered_info
  6   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  6   170*			      fixed bin (35));
  6   171*****************************************************************************/
  6   172 
  6   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  6   174      dcl	   cm_modify$unprotected_info
  6   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  6   176 
  6   177 
  6   178 /******* Not yet used *****************************************************
  6   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
  6   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
  6   181*****************************************************************************/
  6   182 
  6   183 
  6   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  6   185      dcl	   cm_opening_info$get_storage_record
  6   186 			      entry (ptr, fixed bin (35));
  6   187      dcl	   cm_opening_info$full_get
  6   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  6   189      dcl	   cm_opening_info$opening_table_ptr
  6   190 			      entry () returns (ptr);
  6   191 
  6   192      dcl	   cm_postcommit_increment
  6   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  6   194 
  6   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   196 			      fixed bin (35), fixed bin (35));
  6   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   198 			      fixed bin (35), fixed bin (35));
  6   199 
  6   200 /******* Not yet used *****************************************************
  6   201*     dcl	   cm_put$buffered_info
  6   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  6   203*			      fixed bin (35));
  6   204*****************************************************************************/
  6   205 
  6   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  6   207 
  6   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  6   209 			      fixed bin (35));
  6   210 
  6   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
  6   212 
  6   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  6   214 			      fixed bin (35));
  6   215      dcl	   cm_put_datum_in_place$buffered
  6   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  6   217      dcl	   cm_put_datum_in_place$buffered_continued
  6   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  6   219 			      fixed bin (35));
  6   220      dcl	   cm_put_datum_in_place$continued
  6   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  6   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  6   223 
  6   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  6   225 			      fixed bin (35));
  6   226      dcl	   cm_put_datum_in_pool$buffered
  6   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  6   228      dcl	   cm_put_datum_in_pool$buffered_continued
  6   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  6   230 			      fixed bin (35));
  6   231      dcl	   cm_put_datum_in_pool$continued
  6   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  6   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  6   234 
  6   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  6   236 			      fixed bin (35));
  6   237      dcl	   cm_put_ordered_element$buffered
  6   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  6   239 			      fixed bin (35));
  6   240 
  6   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
  6   242 
  6   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
  6   244 			      fixed bin (35));
  6   245 
  6   246 
  6   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
  6   248 			      entry ();
  6   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
  6   250 			      entry ();
  6   251 
  6   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      240 
      241 
  7     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  7     2 /* format: style3 */
  7     3 
  7     4 /* These constants are to be used for the flags argument of sub_err_ */
  7     5 /* They are just "string (condition_info_header.action_flags)" */
  7     6 
  7     7 declare	(
  7     8 	ACTION_CAN_RESTART	init (""b),
  7     9 	ACTION_CANT_RESTART init ("1"b),
  7    10 	ACTION_DEFAULT_RESTART
  7    11 			init ("01"b),
  7    12 	ACTION_QUIET_RESTART
  7    13 			init ("001"b),
  7    14 	ACTION_SUPPORT_SIGNAL
  7    15 			init ("0001"b)
  7    16 	)		bit (36) aligned internal static options (constant);
  7    17 
  7    18 /* End include file */
      242 
      243 
      244    end cm_put;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0912.5  cm_put.pl1                        >spec>on>7192.pbf-04/04/85>cm_put.pl1
230          1    01/07/85  0858.4  dm_cm_info.incl.pl1               >ldd>include>dm_cm_info.incl.pl1
232          2    01/07/85  0858.0  dm_cm_basic_ci.incl.pl1           >ldd>include>dm_cm_basic_ci.incl.pl1
234          3    01/07/85  0858.2  dm_cm_collection_header.incl.pl1  >ldd>include>dm_cm_collection_header.incl.pl1
236          4    01/07/85  0858.5  dm_esm_info.incl.pl1              >ldd>include>dm_esm_info.incl.pl1
238          5    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
240          6    04/04/85  0819.0  dm_cm_entry_dcls.incl.pl1         >spec>on>7192.pbf-04/04/85>dm_cm_entry_dcls.incl.pl1
242          7    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000025 constant        bit(36)                  initial dcl 7-7 set ref 200* 221*
CM_INFO_VERSION_2               000002 constant        char(8)                  initial dcl 1-48 set ref 177*
COLLECTION_HEADER_VERSION_2     000000 constant        char(8)                  initial dcl 3-86 set ref 182*
ORDERED_ELEMENT_STORAGE_METHOD         constant        fixed bin(17,0)          initial dcl 4-46 ref 193
addr                                                   builtin function         dcl 112 ref 134 158
automatic_bci_header            000100 automatic       structure                level 1 dcl 105 set ref 133* 134 157* 158
bci_header                             based           structure                level 1 dcl 2-63
bci_header_ptr                  000112 automatic       pointer                  dcl 2-94 set ref 134* 143* 158* 193* 197* 203*
cm_info                                based           structure                level 1 dcl 1-37
cm_info_ptr                     000110 automatic       pointer                  initial dcl 1-47 set ref 145* 156* 177 180 193* 197*
                                                                                  203* 1-47*
cm_opening_info$get             000016 constant        entry                    external dcl 6-184 ref 145
cm_put_basic_element            000020 constant        entry                    external dcl 6-208 ref 203
cm_put_ordered_element          000022 constant        entry                    external dcl 6-235 ref 197
cm_put_ordered_element$buffered 000024 constant        entry                    external dcl 6-237 ref 193
collection_header                      based           structure                level 1 dcl 3-65
collection_header_ptr           000114 automatic       pointer                  dcl 3-85 set ref 180* 182 189 189 193
datum_slot                             based           structure                level 1 dcl 2-82
dm_error_$unimplemented_esm     000012 external static fixed bin(35,0)          dcl 125 set ref 200*
element_id_string               000116 automatic       bit(36)                  dcl 5-30 set ref 187* 193* 197* 203* 207
element_length_in_bits          000105 automatic       fixed bin(35,0)          dcl 106 set ref 189* 191* 193* 197* 203*
element_storage_method
                          3            based           fixed bin(17,0)          level 2 dcl 3-65 ref 193
error_table_$unimplemented_version
                                000014 external static fixed bin(35,0)          dcl 127 set ref 221*
fixed_size_elements       2            based           bit(1)                   level 3 packed unaligned dcl 3-65 ref 189
flags                     2            based           structure                level 2 packed unaligned dcl 3-65
header_ptr                6            based           pointer                  initial level 2 dcl 1-37 ref 180
is_buffered                     000106 automatic       bit(1)                   initial dcl 107 set ref 107* 142* 193 200
maximum_element_size      4            based           fixed bin(35,0)          level 2 dcl 3-65 ref 189
myname                          000004 constant        varying char(32)         initial dcl 117 set ref 200* 221*
null                                                   builtin function         dcl 112 ref 200 200 1-47 221 221
p_ci_buffer_ptr                        parameter       pointer                  dcl 93 ref 138 143
p_cm_info_ptr                          parameter       pointer                  dcl 92 ref 153 156
p_code                                 parameter       fixed bin(35,0)          dcl 101 set ref 84 138 145* 147 153 184* 193* 197*
                                                                                  203* 207
p_collection_id                        parameter       bit(36)                  dcl 95 set ref 84 138 145*
p_correct_version                      parameter       char(8)                  dcl 219 set ref 214 221 221*
p_element_id                           parameter       bit(36)                  dcl 98 set ref 84 138 153 187 207*
p_element_length                       parameter       fixed bin(35,0)          dcl 96 ref 84 138 153 191
p_element_ptr                          parameter       pointer                  dcl 97 set ref 84 138 153 193* 197* 203*
p_file_opening_id                      parameter       bit(36)                  dcl 94 set ref 84 138 145*
p_given_version                        parameter       char(8)                  dcl 218 set ref 214 221 221*
p_maximum_space_available              parameter       fixed bin(35,0)          dcl 99 set ref 84 138 153 185* 193* 197* 203*
p_structure_name                       parameter       char                     unaligned dcl 217 set ref 214 221*
sub_err_                        000010 constant        entry                    external dcl 121 ref 200 221
unspec                                                 builtin function         dcl 112 set ref 133* 157*
version                                based           char(8)                  level 2 in structure "collection_header" dcl 3-65
                                                                                  in procedure "cm_put" set ref 182*
version                                based           char(8)                  level 2 in structure "cm_info" dcl 1-37 in procedure
                                                                                  "cm_put" set ref 177*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 7-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 7-7
BASIC_CI_LAYOUT_1                      internal static char(4)                  initial dcl 2-97
BASIC_ELEMENT_STORAGE_METHOD           internal static fixed bin(17,0)          initial dcl 4-44
ESM_INFO_VERSION_1                     internal static char(8)                  initial dcl 4-43
basic_control_interval                 based           structure                level 1 dcl 2-56
basic_control_interval_ptr             automatic       pointer                  dcl 2-92
basic_esm_info                         based           structure                level 1 dcl 4-21
basic_esm_info_ptr                     automatic       pointer                  dcl 4-40
cm_allocate_ci                  000000 constant        entry                    external dcl 6-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 6-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 6-77
cm_compact                      000000 constant        entry                    external dcl 6-81
cm_compact$buffered             000000 constant        entry                    external dcl 6-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 6-84
cm_compact$replacement          000000 constant        entry                    external dcl 6-83
cm_delete                       000000 constant        entry                    external dcl 6-92
cm_delete$info                  000000 constant        entry                    external dcl 6-94
cm_delete_cn_datum              000000 constant        entry                    external dcl 6-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 6-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 6-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 6-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 6-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 6-111
cm_find_free_slot               000000 constant        entry                    external dcl 6-115
cm_free_ci$info                 000000 constant        entry                    external dcl 6-118
cm_free_ci$raw_return_prev_next 000000 constant        entry                    external dcl 6-119
cm_free_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 6-124
cm_free_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 6-122
cm_free_opening_info            000000 constant        entry                    external dcl 6-128
cm_get_bci_header               000000 constant        entry                    external dcl 6-130
cm_get_bci_header$exclusive     000000 constant        entry                    external dcl 6-131
cm_get_bci_header$slot          000000 constant        entry                    external dcl 6-133
cm_get_element                  000000 constant        entry                    external dcl 6-140
cm_get_element$exclusive        000000 constant        entry                    external dcl 6-142
cm_get_element_portion          000000 constant        entry                    external dcl 6-146
cm_get_id$id                    000000 constant        entry                    external dcl 6-157
cm_get_id$ptr                   000000 constant        entry                    external dcl 6-159
cm_modify                       000000 constant        entry                    external dcl 6-162
cm_modify$buffered              000000 constant        entry                    external dcl 6-164
cm_modify$info                  000000 constant        entry                    external dcl 6-173
cm_modify$unprotected_info      000000 constant        entry                    external dcl 6-174
cm_opening_info$full_get        000000 constant        entry                    external dcl 6-187
cm_opening_info$get_storage_record
                                000000 constant        entry                    external dcl 6-185
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 6-189
cm_postcommit_increment         000000 constant        entry                    external dcl 6-192
cm_put                          000000 constant        entry                    external dcl 6-195
cm_put$buffered                 000000 constant        entry                    external dcl 6-197
cm_put$info                     000000 constant        entry                    external dcl 6-206
cm_put_cn_datum                 000000 constant        entry                    external dcl 6-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 6-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 6-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 6-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 6-220
cm_put_datum_in_pool            000000 constant        entry                    external dcl 6-224
cm_put_datum_in_pool$buffered   000000 constant        entry                    external dcl 6-226
cm_put_datum_in_pool$buffered_continued
                                000000 constant        entry                    external dcl 6-228
cm_put_datum_in_pool$continued  000000 constant        entry                    external dcl 6-231
cm_put_overlength_tail          000000 constant        entry                    external dcl 6-241
cm_recursive_modify             000000 constant        entry                    external dcl 6-243
cm_replace_buffered_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 6-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 6-247
datum_slot_ptr                         automatic       pointer                  dcl 2-95
element_id                             based           structure                level 1 dcl 5-32
ordered_esm_info                       based           structure                level 1 dcl 4-31
ordered_esm_info_ptr                   automatic       pointer                  dcl 4-41

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000550 constant        entry                    internal dcl 214 ref 177 182
JOIN                            000306 constant        label                    dcl 177 ref 150 160
NO_INFO_JOIN                    000225 constant        label                    dcl 145 ref 136
buffered                        000172 constant        entry                    external dcl 138
cm_put                          000130 constant        entry                    external dcl 84
info                            000253 constant        entry                    external dcl 153

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1004        1032     652        1014
Length      1354     652        26         305     131           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_put                              240 external procedure  is an external procedure.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure cm_put.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_put                   000100 automatic_bci_header        cm_put
                         000105 element_length_in_bits      cm_put
                         000106 is_buffered                 cm_put
                         000110 cm_info_ptr                 cm_put
                         000112 bci_header_ptr              cm_put
                         000114 collection_header_ptr       cm_put
                         000116 element_id_string           cm_put

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_opening_info$get           cm_put_basic_element          cm_put_ordered_element
cm_put_ordered_element$buffered                             sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$unimplemented_esm   error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    107 000115    1   47 000116        84 000122       133 000155       134 000160       136 000162       138 000163
    142 000217       143 000221       145 000225       147 000242       150 000244       153 000245       156 000274
    157 000300       158 000303       160 000305       177 000306       180 000327       182 000332       184 000357
    185 000360       187 000362       189 000364       191 000373       193 000375       197 000426       200 000452
    203 000520       207 000543       211 000547       214 000550       221 000561       226 000651


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
