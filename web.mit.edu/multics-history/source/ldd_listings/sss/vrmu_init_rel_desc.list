	COMPILATION LISTING OF SEGMENT vrmu_init_rel_desc
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1346.1 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 vrmu_init_rel_desc: proc (I_db_path, I_rel_name, I_uid, I_model_ptr, I_vrm_com_ptr, I_oid, O_vrm_open_info_ptr, O_code);
        8 
        9 /*        BEGIN_DESCRIPTION
       10*
       11*   The purpose of this procedure is to create and initialize the vrm_rel_desc
       12*   for a given relation.
       13*
       14*          END_DESCRIPTION
       15**/
       16 
       17 /*  HISTORY
       18*
       19*   82-08-17 Written by Roger Lackey
       20*   82-11-02 Modified by R. Harvey for opening_info/rel_desc structure split
       21*   82-11-17 Modified by Roger Lackey : to calculate the pri_key_offset for
       22*                                        varying strings like encode_key does
       23*
       24*   82-12-09 Modified by Roger Lackey : To added vrm_iocb_list_block handling
       25*
       26*   82-12-20 Modified by Roger Lackey : To add initiate the vfile_ component 
       27*                                       that contains the vrm_rel_desc for an
       28*	                             internal model so the vfile opening 
       29*			         could be destroy in this program.
       30*                                       This allows 
       31*			         vrm_open_info.relation_model_ptr valid.
       32*
       33*   83-05-26 Modified by Roger Lackey : Added  vrm_attr_info.key_head bit 
       34*			         and vrm_attr_info.primary_key_attr bit
       35*
       36*   83-06-14 Modified by Ron Harvey :   Changed the substr for the file_id field
       37*			         so that it doesn't pick up the last 7 
       38*			         bits, but instead acts like MR 10.0 and
       39*			         previous MRDS code.
       40*
       41*  83-10-03 Modified by Roger Lackey : to put the key_bit_len in vrm_collection_info
       42*
       43*  84-05-25 Modified by Bert Moberg : 	to use vrmu_encode_key$compute_offset_and_length
       44*				so that key lengths are properly calculated
       45*
       46*  84-05-30 Modified by Bert Moberg : Changed new call to use
       47*			       vrmu_encode_key$compute_alignment_and_length
       48*			       because there was a case that was not being
       49*			       handled properly
       50**/
       51 
       52 
       53 /*  PARAMETERS  */
       54 
       55 	dcl     I_db_path		 char (*) parameter;/* Absolute database path */
       56 	dcl     I_rel_name		 char (*) parameter;/* Relation name */
       57 	dcl     I_uid		 bit (36) aligned parameter; /* uid of relation */
       58 	dcl     I_model_ptr		 ptr parameter;	/* Pointer to relation model */
       59 	dcl     I_vrm_com_ptr	 pointer parameter; /* Pointer to segment where vrm_rel_desc is to be allocated */
       60 	dcl     I_oid		 bit (36) aligned parameter; /* Opening id associdated with this desc */
       61 	dcl     O_vrm_open_info_ptr	 pointer parameter; /* Pointer to the opening info structure */
       62 	dcl     O_code		 fixed bin (35) parameter; /* Error code */
       63 
       64 	O_vrm_open_info_ptr = null;
       65 	O_code = 0;
       66 	vrm_com_ptr = I_vrm_com_ptr;
       67 	rel_name = I_rel_name;
       68 	fm_ptr = I_model_ptr;
       69 
       70 	vrm_open_info_ptr = null;
       71 	vrm_rel_desc_ptr = null;
       72 	vrm_iocb_list_block_ptr = null;
       73 	iocb_ptr = null;
       74 
       75 	on cleanup call tidy_up;
       76 
       77 	if fm_ptr ^= null then call build_from_MRDS_model;
       78 	else call build_from_internal_model;
       79 
       80 	O_vrm_open_info_ptr = vrm_open_info_ptr;
       81 
       82 exit:	return;
       83 
       84 build_from_MRDS_model: proc;
       85 
       86 	call hcs_$initiate (I_db_path, "db_model", "", 0, 0, dbm_ptr, code);
       87 	if dbm_ptr = null then call error (error_table_$noentry);
       88 
       89 	ri_ptr = pointer (fm_ptr, file_model.rel_ptr);
       90 
       91 /* In order to create the opening info structure, we must know the number of
       92*   index collections (secondary indexes + primary key) */
       93 
       94 	voi_no_of_index_collections = 0;
       95 	do i = 1 to rel_info.num_attr;
       96 	     if i = 1 then ai_ptr = pointer (fm_ptr, rel_info.attr_ptr);
       97 	     else ai_ptr = pointer (fm_ptr, attr_info.fwd_thread);
       98 
       99 	     if attr_info.index_attr & attr_info.index_id ^= "0"b
      100 	     then voi_no_of_index_collections = voi_no_of_index_collections + 1;
      101 	end;
      102 
      103 	call create_open_info (voi_no_of_index_collections);
      104 
      105 /* We'll build the collection info later while walking attribute chain again */
      106 
      107 	vrd_no_of_attrs = rel_info.num_attr;
      108 	allocate vrm_rel_desc in (wa) set (vrm_rel_desc_ptr);
      109 
      110 	unspec (vrm_rel_desc) = "0"b;			/* Init every thing to zeros */
      111 	vrm_open_info.relation_model_ptr = vrm_rel_desc_ptr;
      112 	vrm_rel_desc.version = VRM_REL_DESC_VERSION_1;
      113 
      114 	vrm_rel_desc.switches.stationary_records = "0"b;	/* Will get changed if varing attr is found */
      115 	vrm_rel_desc.switches.indexed = rel_info.indexed;
      116 	vrm_rel_desc.switches.pad = "0"b;
      117 
      118 	vrm_rel_desc.version = VRM_REL_DESC_VERSION_1;
      119 
      120 	fi_ptr = pointer (dbm_ptr, db_model.file_ptr);
      121 	found = "0"b;
      122 
      123 	do while (^found & rel (fi_ptr) ^= NULL_OFFSET);
      124 	     if file_info.file_name = rel_name then do;
      125 		     found = "1"b;
      126 
      127 /*  Pick up the file_id from the last seven but two bits of the field. This
      128*    is due to a stringrange bug in previous implementations of MRDS.  It is
      129*    almost certain that the value we pick up is guaranteed to be ZEROS.     */
      130 
      131 		     vrm_rel_desc.file_id = substr (file_info.file_id, 28, 7);
      132 		end;
      133 	     fi_ptr = pointer (dbm_ptr, file_info.fwd_ptr);
      134 	end;
      135 
      136 	if ^found then call error (error_table_$noentry);
      137 
      138 	vrm_rel_desc.rel_id = substr (rel_info.id, 1, 12);
      139 	vrm_rel_desc.switches.MRDS_compatible = "1"b;
      140 	vrm_rel_desc.var_offset = rel_info.var_offset;
      141 	vrm_rel_desc.maximum_data_length = divide (rel_info.max_data_len, 9, 21, 0); /* convert from bit count to char count */
      142 	if mod (rel_info.max_data_len, 9) ^= 0
      143 	then vrm_rel_desc.maximum_data_length = vrm_rel_desc.maximum_data_length + 1;
      144 	vrm_rel_desc.number_primary_key_attrs = rel_info.num_key_attrs;
      145 	vrm_rel_desc.number_sec_indexes = 0;		/* Calculated during walk through attrs */
      146 	vrm_rel_desc.last_var_attr_no = 0;		/* Calculated during walk through attrs */
      147 	vrm_rel_desc.number_var_attrs = rel_info.nvar_atts;
      148 	vrm_rel_desc.number_attrs = vrd_no_of_attrs;
      149 
      150 
      151 	pri_key_offset = 0;				/* Offset within primary key in chars */
      152 	key_attr_index = 1;				/* index for key_attrs substructure */
      153 
      154 	vci_no_of_attributes = rel_info.num_key_attrs;
      155 	allocate vrm_collection_info in (wa) set (key_collection_info_ptr);
      156 	key_collection_info_ptr -> vrm_collection_info.unique = "1"b;
      157 	key_collection_info_ptr -> vrm_collection_info.primary_key = "1"b;
      158 	key_collection_info_ptr -> vrm_collection_info.id = "0"b;
      159 	key_coll_index = 1;
      160 	vrm_open_info.primary_key_info_ptr = key_collection_info_ptr;
      161 	open_info_coll_index = 1;			/* set for first secondary index */
      162 
      163 	do i = 1 to vrm_rel_desc.number_attrs;
      164 
      165 	     if i = 1 then ai_ptr = pointer (fm_ptr, rel_info.attr_ptr);
      166 	     else ai_ptr = pointer (fm_ptr, attr_info.fwd_thread);
      167 
      168 	     di_ptr = pointer (dbm_ptr, attr_info.domain_ptr);
      169 
      170 	     desc_ptr = addr (domain_info.db_desc);
      171 	     if descriptor.type = 20 | descriptor.type = 22 /* Bit varying or char varying */
      172 	     then vrm_rel_desc.switches.stationary_records = "1"b;
      173 
      174 	     vrm_rel_desc.attr (i).name = attr_info.name;
      175 	     vrm_rel_desc.attr (i).descriptor = domain_info.db_desc;
      176 	     desc_ptr = addr (domain_info.db_desc);
      177 
      178 	     if descriptor.type = 20 | descriptor.type = 22 /* varying bit string or varying character string */
      179 	     then do;
      180 		     vrm_rel_desc.attr (i).varying = "1"b;
      181 		     vrm_rel_desc.last_var_attr_no = i;
      182 		end;
      183 	     else vrm_rel_desc.attr (i).varying = "0"b;
      184 
      185 	     vrm_rel_desc.attr (i).key_head = "0"b;
      186 	     vrm_rel_desc.attr (i).primary_key_attr = "0"b;
      187 
      188 	     if attr_info.key_attr then do;
      189 		     vrm_rel_desc.attr (i).primary_key_attr = "1"b;
      190 		     if pri_key_offset = 0 then vrm_rel_desc.attr (i).key_head = "1"b;
      191 
      192 		     call vrmu_encode_key$compute_alignment_and_length (desc_ptr, pri_key_offset, pri_key_align, pri_key_bit_len);
      193 
      194 		     pri_key_offset = pri_key_offset + pri_key_align;
      195 		     vrm_collection_info_ptr = key_collection_info_ptr;
      196 		     vrm_collection_info.attribute (key_coll_index).attr_index = i;
      197 		     vrm_collection_info.attribute (key_coll_index).key_offset = pri_key_offset;
      198 
      199 		     vrm_collection_info.attribute (key_coll_index).key_bit_len = pri_key_bit_len;
      200 		     pri_key_offset = pri_key_offset + pri_key_bit_len;
      201 
      202 		     key_coll_index = key_coll_index + 1;
      203 		end;
      204 
      205 	     if attr_info.index_attr & attr_info.index_id ^= "0"b
      206 	     then do;
      207 		     vrm_rel_desc.attr (i).key_head = "1"b;
      208 		     vrm_rel_desc.number_sec_indexes = vrm_rel_desc.number_sec_indexes + 1;
      209 		     vci_no_of_attributes = 1;
      210 		     allocate vrm_collection_info in (wa) set (vrm_collection_info_ptr);
      211 		     vrm_open_info.index_collection (open_info_coll_index).info_ptr = vrm_collection_info_ptr;
      212 		     vrm_open_info.index_collection (open_info_coll_index).id = substr (attr_info.index_id, 1, 8);
      213 		     vrm_collection_info.id = substr (attr_info.index_id, 1, 8);
      214 		     vrm_collection_info.unique = "0"b;
      215 		     vrm_collection_info.primary_key = "0"b;
      216 		     vrm_collection_info.attribute (1).attr_index = i;
      217 		     vrm_collection_info.attribute (1).key_offset = 0;
      218 
      219 		     dummy_offset = 0;	/* offset not needed for secondary indexes */
      220 		     call vrmu_encode_key$compute_alignment_and_length (desc_ptr, dummy_offset,
      221 			dummy_align, vrm_collection_info.attribute (1).key_bit_len);
      222 
      223 		     open_info_coll_index = open_info_coll_index + 1;
      224 		end;
      225 	     vrm_rel_desc.attr (i).pad = "0"b;
      226 	     vrm_rel_desc.attr (i).bit_length = attr_info.bit_length;
      227 	     vrm_rel_desc.attr (i).bit_offset = attr_info.bit_offset;
      228 
      229 	end;
      230 
      231      end build_from_MRDS_model;
      232 
      233 build_from_internal_model: proc;
      234 
      235 /* Now we must find the internal relation description (if there is one) */
      236 
      237 	call vrmu_iocb_manager$create_iocb (I_db_path, I_rel_name, KSQR, "1"b, "vrm_open", iocb_ptr, code);
      238 	if code ^= 0 then call error (code);
      239 
      240 	call iox_$seek_key (iocb_ptr, VRM_REL_DESC_KEY, (0), code);
      241 	if code = 0 then call iox_$control (iocb_ptr, "record_status", addr (rs_info), code);
      242 	if code ^= 0 then call error (code);
      243 
      244 /* rs_info.record_ptr is the pointer to vrm_rel_desc which is a record inf vfile */
      245 
      246 /* Make sure the segment that contains the vrm_rel_desc is initiated so we can use the pointer to it */
      247 
      248 	call hcs_$fs_get_path_name (rs_info.record_ptr, dir, dir_len, ent, code);
      249 	if code ^= 0 then call error (code);
      250 
      251 	call hcs_$initiate (dir, ent, "", 0, 0, seg_ptr, code);
      252 	if seg_ptr = null then call error (code);
      253 
      254 	call create_open_info (rs_info.record_ptr -> vrm_rel_desc.number_sec_indexes);
      255 	vrm_open_info.relation_model_ptr = rs_info.record_ptr;
      256 
      257 /* Now destroy the iocb used to get the vrm_rel_desc */
      258 
      259 	call vrmu_iocb_manager$destroy_iocb (iocb_ptr, code);
      260 	if code ^= 0 then call error (code);
      261 
      262      end build_from_internal_model;
      263 
      264 create_open_info: proc (no_of_indexes);
      265 
      266 	dcl     no_of_indexes	 fixed bin parameter;
      267 
      268 	voi_no_of_index_collections = no_of_indexes;
      269 	allocate vrm_open_info in (wa) set (vrm_open_info_ptr);
      270 
      271 
      272 	vrm_open_info.version = VRM_OPEN_INFO_VERSION_1;
      273 	vrm_open_info.opening_id = I_oid;
      274 
      275 	vrm_open_info.file_uid = I_uid;
      276 	vrm_open_info.number_of_openings = 1;
      277 	vrm_open_info.switches.shared = "0"b;
      278 	vrm_open_info.database_dir_path = I_db_path;
      279 	vrm_open_info.relation_name = rel_name;
      280 	vrm_open_info.relation_model_ptr = null ();	/* for now */
      281 	vrm_open_info.com_ptr = I_vrm_com_ptr;
      282 
      283 /* Allocate first vrm_list_iocb_block and set its pointer in vrm_open_info */
      284 
      285 	allocate vrm_iocb_list_block in (wa) set (vrm_iocb_list_block_ptr);
      286 
      287 	vrm_iocb_list_block.num_iocbs_used = 0;
      288 	vrm_iocb_list_block.prev_block_ptr = null;
      289 	vrm_iocb_list_block.next_block_ptr = null;
      290 	vrm_iocb_list_block.iocbs = null;		/* Init all to null */
      291 
      292 	vrm_open_info.iocb_list_ptr = vrm_iocb_list_block_ptr;
      293 
      294 
      295 /* Initialize the collections */
      296 
      297 	do i = 1 to vrm_open_info.number_of_index_collections;
      298 	     vrm_open_info.index_collection (i).id = "0"b;
      299 	     vrm_open_info.index_collection (i).info_ptr = null ();
      300 	end;
      301 
      302      end create_open_info;
      303 
      304 error: proc (cd);
      305 
      306 	dcl     cd		 fixed bin (35) parameter;
      307 
      308 	O_code = cd;
      309 	goto exit;
      310 
      311      end error;
      312 
      313 
      314 
      315 
      316 
      317 
      318 
      319 tidy_up: proc;
      320 
      321 	if vrm_iocb_list_block_ptr ^= null then free vrm_iocb_list_block;
      322 
      323 	if vrm_rel_desc_ptr ^= null then free vrm_rel_desc;
      324 
      325 	if iocb_ptr ^= null then
      326 	     call vrmu_iocb_manager$destroy_iocb (iocb_ptr, code);
      327 
      328 
      329      end tidy_up;
      330 
  1     1 /*   BEGIN INCLUDE   vrm_open_info.incl.pl1		    */
  1     2 
  1     3 /* R. Harvey  82-11-02 
  1     4*   82-09-82 Roger Lackey: added iocb_list_ptr */
  1     5 
  1     6 dcl 1 vrm_open_info aligned based (vrm_open_info_ptr),	/* Vfile relation description */
  1     7     2 version char (8),				/* Version number of this structure */
  1     8     2 opening_id bit (36) aligned,			/* Opening id associated with this desc */
  1     9     2 file_uid bit (36) aligned,			/* Unique id of msf dir */
  1    10     2 number_of_openings fixed bin,			/* Number of separate calls to vrm$open */
  1    11     2 switches,
  1    12       3 shared bit (1) unal,				/* Open relation in shared mode */
  1    13       3 pad bit (35) unal init ("0"b),			/* Unused must be zero */
  1    14     2 database_dir_path char (168) varying,		/* Absolute path of database */
  1    15     2 relation_name char (30) varying,			/* Name of relation */
  1    16     2 relation_model_ptr pointer,			/* Pointer to the relation_model in the relation itself or a temp seg */
  1    17     2 com_ptr pointer,				/* Temp seg for cursors and scratch space */
  1    18     2 iocb_list_ptr pointer,				/* Pointer to first vrm_iocb_list_block */
  1    19     2 primary_key_info_ptr pointer,			/* Special case collection info ptr */
  1    20     2 number_of_index_collections fixed bin,		/* Count of index collections (include primary key) */
  1    21     2 index_collection (voi_no_of_index_collections
  1    22 		   refer (vrm_open_info.number_of_index_collections)),
  1    23       3 id bit (36),
  1    24       3 info_ptr ptr unal;				/* Points to more detailed info */
  1    25 
  1    26 
  1    27 dcl  VRM_OPEN_INFO_VERSION_1 char (8) int static options (constant) init ("       1");
  1    28 dcl  vrm_open_info_ptr ptr;
  1    29 dcl  voi_no_of_index_collections fixed bin;
  1    30 
  1    31 /*   END INCLUDE  vrm_open_info.incl.pl1	   */
      331 
      332 
  2     1 /*   BEGIN INCLUDE  vrm_rel_desc.incl.pl1		   */
  2     2 
  2     3 /* 83-05-26 Roger Lackey : Added vrm_attr_info.key_head bit for relation_cursors */
  2     4 
  2     5 dcl 1 vrm_rel_desc based (vrm_rel_desc_ptr),
  2     6     2 record_id bit (12) unal,			/* Distinguish us from tuples and collection records */
  2     7     2 version char (8),				/* Version of this structure */
  2     8     2 file_id bit (7),				/* Value of file id from model */
  2     9     2 rel_id bit (12),				/* Relation id */
  2    10     2 switches,
  2    11       3 MRDS_compatible bit (1) unal,			/* For pre-relation_manager_ MRDS */
  2    12       3 stationary_records
  2    13      bit (1) unal,					/* On = stationary */
  2    14       3 indexed bit (1) unal,				/* This relation has attributes with secondary indices */
  2    15       3 pad bit (33) unal,
  2    16     2 var_offset fixed bin (35),			/* Position of first varying attr */
  2    17     2 maximum_data_length
  2    18      fixed bin (35),				/* Maximum size of tuple in characters */
  2    19     2 number_primary_key_attrs
  2    20      fixed bin,					/* Number of attributes which make up the primary key */
  2    21     2 number_sec_indexes fixed bin,			/* Number of attributes which have a secondary index */
  2    22     2 last_var_attr_no fixed bin,			/* Attr index of last varying attribute */
  2    23     2 number_var_attrs fixed bin,			/* Number of varying attributes */
  2    24     2 number_attrs fixed bin,				/* Number of attribute in rel */
  2    25     2 attr (vrd_no_of_attrs				/* Description of each attribute */
  2    26      refer (vrm_rel_desc.number_attrs)) aligned like vrm_attr_info;
  2    27 
  2    28 dcl 1 vrm_attr_info based (vrm_attr_info_ptr),
  2    29 						/* Attribute specific info */
  2    30     2 name char (32),				/* Name of the attribute */
  2    31     2 descriptor bit (36) aligned,			/* domain descriptor */
  2    32     2 varying bit (1) unal,				/* ON = This is a varying string */
  2    33     2 key_head bit (1) unal,				/* ON = This attr can be a keyhead */
  2    34     2 primary_key_attr bit (1) unal,			/* ON = This is a primary key attribute */
  2    35     2 pad bit (15) unal,				/* unused */
  2    36     2 index_collextion_ix fixed bin (17) unal,		/* Index into vrm_open_info.index_collection array if key_head is on */
  2    37     2 bit_length fixed bin (35),			/* Maximum bit length of tuple */
  2    38     2 bit_offset fixed bin (35);			/* Offset in tuple if fixed, index to offset in tuple if varying */
  2    39 
  2    40 
  2    41 dcl  vrm_rel_desc_ptr pointer;
  2    42 dcl  vrd_no_of_attrs fixed bin;
  2    43 dcl  VRM_REL_DESC_RECORD_ID bit (12) unal int static options (constant) init ("100000000000"b);
  2    44 dcl  VRM_REL_DESC_VERSION_1 char (8) int static options (constant) init ("       1");
  2    45 dcl  vrm_attr_info_ptr pointer;
  2    46 dcl  VRM_REL_DESC_KEY char (256) varying int static options (constant) init ("@relation_description");
  2    47 
  2    48 /*   END INCLUDE  vrm_rel_desc.incl.pl1		   */
      333 
      334 
  3     1 /*   BEGIN INCLUDE   vrm_collection_info.incl.pl1		    */
  3     2 
  3     3 /*  R. Harvey  82-11-02 */
  3     4 
  3     5 
  3     6      dcl	   1 vrm_collection_info  aligned based (vrm_collection_info_ptr),
  3     7 						/* Index collection description */
  3     8 	     2 record_id	      unal,
  3     9 	       3 header	      bit (4) unal,		/* collection type */
  3    10 	       3 id	      bit (8) unal,		/* index id */
  3    11 	     2 unique	      bit (1) unal,
  3    12 	     2 primary_key	      bit (1) unal,		/* This is the MRDS primary key collection */
  3    13 	     2 pad	      bit (26) unal,
  3    14 	     2 number_of_attributes
  3    15 			      fixed bin,
  3    16 	     2 attribute	      (vci_no_of_attributes refer (vrm_collection_info.number_of_attributes)),
  3    17 	       3 attr_index	      fixed bin,		/* Attribute number in relation description */
  3    18 	       3 key_offset	      fixed bin,		/* Offset within key in bits */
  3    19 	       3 key_bit_len      fixed bin ;		/* Length of key in bits */
  3    20 
  3    21      dcl	   vrm_collection_info_ptr
  3    22 			      ptr;
  3    23      dcl	   vci_no_of_attributes   fixed bin;
  3    24      dcl	   vrm_collection_header_type
  3    25 			      bit (4) unal int static options (constant) init ("1100"b);
  3    26      dcl	   VRM_COLLECTION_KEY_HEAD char (16) int static options (constant) init ("@collection_info");
  3    27 
  3    28 /*   END INCLUDE  vrm_collection_info.incl.pl1	   */
      335 
      336 
  4     1 /*  BEGIN INCLUDE   vrm_com.incl.pl1		 */
  4     2 
  4     3 /*  Written 82-08-23 by R. Harvey		 */
  4     4 
  4     5      dcl	   vrm_com_ptr	      ptr;
  4     6      dcl	   1 vrm_com	      aligned based (vrm_com_ptr),
  4     7 	     2 get_seg_ptr	      ptr,		/* temp seg for retrieve routines */
  4     8 	     2 put_seg_ptr	      ptr,		/* temp seg for store routines */
  4     9 	     2 mod_seg_ptr	      ptr,		/* temp seg for modify routines */
  4    10 	     2 work_area_ptr      ptr,		/* freeing area for oid_table sections and rel_descriptors */
  4    11 	     2 highest_oid	      bit (36) aligned,	/* highest valid oid */
  4    12 	     2 next_free_oid      bit (36) aligned,	/* offset of first in free chain */
  4    13 	     2 first_assigned_oid bit (36) aligned,	/* offset of first in assigned chain */
  4    14 	     2 oid_area	      area (sys_info$max_seg_size - fixed (rel (addr (vrm_com.work_area_ptr))));
  4    15 
  4    16 /*  END INCLUDE    vrm_com.incl.pl1		 */
      337 
      338 
  5     1 /* BEGIN INCLUDE vrm_iocb_list_block.incl.pl1             */
  5     2 
  5     3 dcl vrm_iocb_list_block_ptr pointer;
  5     4 
  5     5 dcl 1 vrm_iocb_list_block aligned based (vrm_iocb_list_block_ptr),
  5     6        2 num_iocbs_used fixed bin,			/* Number of iocbs used in this block */
  5     7        2 prev_block_ptr ptr unal,			/* Pointer to previous block or 
  5     8*                                                               or null if first block */
  5     9        2 next_block_ptr ptr unal,			/* Pointer to next block or null */
  5    10        2 iocbs (vrm_data_$iocb_list_block_size) pointer;	/* Iocb pointers */
  5    11 
  5    12 /* END INCLUDE vrm_iocb_list_block.incl.pl1             */
      339 
      340 
  6     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  6     6*     modified to save space occupied by model
  6     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  6     8*     to add mdbm_secured bit in db_model
  6     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  6    10*     collapsed the following into an unused_offset array:
  6    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  6    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  6    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  6    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  6    15*       unused_1
  6    16*     Also changed the name of unused_2 to restructuring_history_offset
  6    17*     and changed the comment on the changer structure to indicate
  6    18*     that it will contain on database creation information.
  6    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  6    20*     used one of the unused_offsets to point to a message which indicates
  6    21*     why the db is inconsistent. The offset will be null when the db is created
  6    22*     and set the first time the message is used. this is so it will be
  6    23*     consistent with existing data bases. Also added the message structure.
  6    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  6    25*     added the undo_request element to the message structure
  6    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  6    27*     changed unused_offset (12) to last_restructruring_history_offset and
  6    28*     changed restructuring_history_offset to first_restructuring_history_offset
  6    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  6    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  6    31*     1 => vfile database and 2 => page_file database. Up to this point all
  6    32*     database types were equal to 1.
  6    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  6    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  6    35*     flags. This will allow information about transactions and dm_file
  6    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  6    37*     change is compatable with all datamodels created by the released version
  6    38*     of mrds.
  6    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  6    40*     added the rollback_on flag to the db_type_flags since it appears that you
  6    41*     can have a dmfile database that requires transactions but does not have any
  6    42*     journalizing. Also switched the order of the transactions_needed and
  6    43*     concurrency_on flags - this makes the change compatable with existing
  6    44*     dmfile databases except when displaying the model since concurrency_on and
  6    45*     rollback_on will be off in the model even though the dmfile relations had
  6    46*     them on during creation.
  6    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  6    48*      Removed ctl_file_path_ptr.
  6    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  6    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  6    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  6    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  6    53*      in the flag word for rmdb copying.
  6    54*                                                   END HISTORY COMMENTS */
  6    55 
  6    56 
  6    57 /* this include file contains the structures that go into the make up
  6    58*   of the "db_model" segment in the model for the database.
  6    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  6    60*
  6    61*   the db_model structure goes at the base of the segment, and contains items unique to
  6    62*   the whole databse. in addition, it has an area of size to fill the
  6    63*   rest of a segment, that holds the lists of files and domains in the database.
  6    64*   these lists are singly forward linked lists. all "pointers" in the database model
  6    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  6    66*   since actual pointers are process dependent on segment number.
  6    67*   the remaining structures are first a path_entry one to save pathnames in,
  6    68*   and the stack_item and constent structures, used to save a boolean
  6    69*   expression in polish form, with the stack represented by a linked list.
  6    70*   the final structure is one for identifying the status of version information */
  6    71 
  6    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  6    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  6    74 	     2 db_type_flags      unal,
  6    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  6    76 	       3 unused	      (13) bit (1) unal,
  6    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  6    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  6    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  6    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  6    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  6    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  6    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  6    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  6    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  6    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  6    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  6    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  6    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  6    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  6    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  6    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  6    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  6    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  6    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  6    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  6    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  6    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  6    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  6   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  6   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  6   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  6   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  6   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  6   105 
  6   106      dcl	   dbm_ptr	      ptr;
  6   107 
  6   108 /* the files in the database each have a file_info containing
  6   109*   their name, the file_model for each file is found by initiating the
  6   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  6   111*   the file_info list is a singly linked list in definition order */
  6   112 
  6   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  6   114 	     2 file_name	      char (30),		/* name of file */
  6   115 	     2 file_id	      bit (36),		/* id number of file */
  6   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  6   117 	     2 unused	      unal bit (18);	/* for future expansion */
  6   118 
  6   119      dcl	   fi_ptr		      ptr;
  6   120 
  6   121 /* each domain used in the database will have a domain info saved in the db_model
  6   122*   segment. it describes the domain of the given name, and it's options.
  6   123*   the domain_info's form a singly linked list in definition order */
  6   124 
  6   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  6   126 	     2 name	      char (32),		/* name of domain */
  6   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  6   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  6   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  6   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  6   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  6   132 	     2 reserved	      bit (31) unal,
  6   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  6   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  6   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  6   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  6   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  6   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  6   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  6   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  6   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  6   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  6   143 	     2 str_err_path_ptr   unal bit (18),
  6   144 	     2 str_after_path_ptr unal bit (18),
  6   145 	     2 get_before_path_ptr unal bit (18),
  6   146 	     2 get_err_path_ptr   unal bit (18),
  6   147 	     2 get_after_path_ptr unal bit (18),
  6   148 	     2 mod_before_path_ptr unal bit (18),
  6   149 	     2 mod_err_path_ptr   unal bit (18),
  6   150 	     2 mod_after_path_ptr unal bit (18),
  6   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  6   152 	     2 unused_2	      unal bit (18),
  6   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  6   154 
  6   155      dcl	   di_ptr		      ptr;
  6   156 
  6   157 /* information necessary for attributes that are not used in any relation */
  6   158 
  6   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  6   160 	     2 name char (32),			/* name of attribute */
  6   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  6   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  6   163 	     2 unused (2) bit (18) unal;
  6   164 
  6   165      dcl     ua_ptr ptr;
  6   166 
  6   167 
  6   168 /* space saving pathname$entryname structure, to be allocated
  6   169*   only when a path$entry has to be saved, else only a bit(18)
  6   170*   offset takes up space in the main model structure */
  6   171 
  6   172      declare 1 path_entry	      based (path_entry_ptr),
  6   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  6   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  6   175 	     2 reserved	      unal bit (36);	/* for future use */
  6   176 
  6   177      declare path_entry_ptr	      ptr;
  6   178 
  6   179 
  6   180 
  6   181 
  6   182 
  6   183 /* declarations for model of postfix stack holding the check option boolean expression
  6   184*   the following encoding values indicate the corresponding type of stack element
  6   185*
  6   186*   1  =
  6   187*   2  ^=
  6   188*   3  >
  6   189*   4  <
  6   190*   5  >=
  6   191*   6  <=
  6   192*
  6   193*   10  and
  6   194*   20  or
  6   195*   30  not
  6   196*
  6   197*   40  - (minus)
  6   198*
  6   199*   50  domain variable(same name as domain)
  6   200*
  6   201*   60  constant(number, bit string, or character string)
  6   202*
  6   203**/
  6   204 
  6   205 
  6   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  6   207 	     2 next	      bit (18),		/* link to next in list */
  6   208 	     2 type	      fixed binary,		/* code for this element type */
  6   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  6   210*						   if this is a constant element type */
  6   211 
  6   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  6   213 
  6   214 
  6   215 
  6   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  6   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  6   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  6   219 
  6   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  6   221 
  6   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  6   223 
  6   224 /* version structure, giving status of source for CMDB/RMDB,
  6   225*   status of model, and status of resultant */
  6   226 
  6   227 /* version number is in form MM.N.Y
  6   228*   where MM is the major version number, N is the minor version alteration,
  6   229*   and Y is the lastest modification to that alteration,
  6   230*   where M and N represent numbers 0-9, and Y is a letter */
  6   231 
  6   232      declare 1 version_status	      unal based (version_status_ptr),
  6   233 	     2 cmdb_rmdb,
  6   234 	       3 major	      fixed bin,
  6   235 	       3 minor	      fixed bin,
  6   236 	       3 modification     char (4),
  6   237 	     2 model,
  6   238 	       3 major	      fixed bin,
  6   239 	       3 minor	      fixed bin,
  6   240 	       3 modification     char (4),
  6   241 	     2 resultant,
  6   242 	       3 major	      fixed bin,
  6   243 	       3 minor	      fixed bin,
  6   244 	       3 modification     char (4);
  6   245 
  6   246      declare version_status_ptr     ptr;
  6   247 
  6   248 
  6   249 /* maintains information only about the db creation */
  6   250 
  6   251      declare 1 changer	      unal based (changer_ptr),
  6   252 	     2 id		      char (32),
  6   253 	     2 time	      fixed bin (71),
  6   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  6   255 
  6   256      declare changer_ptr	      ptr;
  6   257 
  6   258 
  6   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  6   260 	     02 len	      fixed bin,		/* length of the message */
  6   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  6   262 	     02 name	      char (32),		/* name of thing that set the message */
  6   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  6   264*                                                               that caused the database to become inconsistent */
  6   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  6   266 
  6   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  6   268 
  6   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  6   270 
  6   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  6   272 
  6   273 
      341 
      342 
  7     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  7     6*     modified to save space occupied by model
  7     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  7     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  7     9*     the number of secondary indices in the relation - it was always zero.
  7    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  7    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  7    12*     DMS conversion.
  7    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  7    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  7    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  7    16*     for relation manager changes.
  7    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  7    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  7    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  7    20*     <rel> files are good (for rmdb)
  7    21*                                                   END HISTORY COMMENTS */
  7    22 
  7    23 
  7    24 /* each file in the database will have a model segment with the name
  7    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  7    26*   the file_model structure is allocated at the base of the segment for a given file.
  7    27*   it contains an area with which all other structures in this include file are allocated.
  7    28*   these structures contain the information about which relations, foreign keys,
  7    29*   and attributes are members of this file. all lists are singly linked lists in
  7    30*   definition order. pointers to these structures are obtained by using the "pointer"
  7    31*   builtin function with arguments of the segment base pointer, and the
  7    32*   offset (bit (18)) relative to that pointer that is actually stored in
  7    33*   the file model itself. this is because pointer segment numbers are
  7    34*   per process dependent. the major lists pointed to by the file_model structure
  7    35*   are the list of relations in this file(each with a contained attribute list),
  7    36*   and the list of foreign keys whose parent relation resides in this file
  7    37*   (along with a participating attribute sublist, and the child relation list,
  7    38*   if they are also in this file) */
  7    39 
  7    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  7    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  7    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  7    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  7    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  7    45     2 reserved bit (32) unal,				/* reserved for future flags */
  7    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  7    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  7    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  7    49     2 pad_1 fixed bin (35),				/* for future use */
  7    50     2 pad_2 fixed bin (35),
  7    51     2 ratd_len fixed bin (21),			/* length of above */
  7    52     2 mratd_len fixed bin (21),			/* length of above */
  7    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  7    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  7    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  7    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  7    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  7    58     2 block_size unal fixed bin,			/* no. pages in block */
  7    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  7    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  7    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  7    62     2 num_rels unal fixed bin,			/* number of relations in file */
  7    63     2 num_links unal fixed bin,			/* number of links in file */
  7    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  7    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  7    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  7    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  7    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  7    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  7    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  7    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  7    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  7    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  7    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  7    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  7    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  7    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  7    78     2 open_eu_err_path_ptr unal bit (18),
  7    79     2 open_eu_after_path_ptr unal bit (18),
  7    80     2 open_er_before_path_ptr unal bit (18),
  7    81     2 open_er_err_path_ptr unal bit (18),
  7    82     2 open_er_after_path_ptr unal bit (18),
  7    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  7    84     2 open_neu_err_path_ptr unal bit (18),
  7    85     2 open_neu_after_path_ptr unal bit (18),
  7    86     2 open_ner_before_path_ptr unal bit (18),
  7    87     2 open_ner_err_path_ptr unal bit (18),
  7    88     2 open_ner_after_path_ptr unal bit (18),
  7    89     2 open_pu_before_path_ptr unal bit (18),
  7    90     2 open_pu_err_path_ptr unal bit (18),
  7    91     2 open_pu_after_path_ptr unal bit (18),
  7    92     2 open_pr_before_path_ptr unal bit (18),
  7    93     2 open_pr_err_path_ptr unal bit (18),
  7    94     2 open_pr_after_path_ptr unal bit (18),
  7    95     2 open_cu_before_path_ptr unal bit (18),
  7    96     2 open_cu_err_path_ptr unal bit (18),
  7    97     2 open_cu_after_path_ptr unal bit (18),
  7    98     2 open_cr_before_path_ptr unal bit (18),
  7    99     2 open_cr_err_path_ptr unal bit (18),
  7   100     2 open_cr_after_path_ptr unal bit (18),
  7   101     2 close_before_path_ptr unal bit (18),
  7   102     2 close_err_path_ptr unal bit (18),
  7   103     2 close_after_path_ptr unal bit (18),
  7   104     2 unused_1 unal bit (18),				/* for future expansion */
  7   105     2 unused_2 unal bit (18),
  7   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  7   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  7   108 dcl  fm_ptr ptr;
  7   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  7   110 dcl  atd_ptr ptr;
  7   111 dcl  atd_len fixed bin;
  7   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  7   113     2 ncomponents fixed bin,
  7   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  7   115 dcl  cna_ptr ptr;
  7   116 dcl  ncomp_init fixed bin;
  7   117 
  7   118 /* a rel_info structure contains information describing a relation.
  7   119*   a relation may only occur in one file, thus there is one rel_info
  7   120*   per relation per database, each stored in the file_model area for
  7   121*   the file that contains it. the list of rel_info's in this file
  7   122*   form a singly linked list in definition order.
  7   123*   the rel_info itself points to a list of the attributes it contains,
  7   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  7   125 
  7   126 dcl 1 rel_info aligned based (ri_ptr),
  7   127     2 name char (32),				/* relation name */
  7   128     2 id  bit (36) aligned,				/* relation id number */
  7   129     2 hashed bit (1) unal,				/* on if hashed */
  7   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  7   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  7   132     2 system bit (1) unal,				/* on if dont care how stored */
  7   133     2 indexed bit (1) unal,				/* on if secondary index */
  7   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  7   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  7   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  7   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  7   138     2 reserved bit (27) unal,				/* for future flags */
  7   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  7   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  7   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  7   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  7   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  7   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  7   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  7   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  7   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  7   148     2 unused_3 unal fixed bin,			/* element that was never used */
  7   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  7   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  7   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  7   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  7   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  7   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  7   155     2 attr_ptr unal bit (18),				/* to attr. info */
  7   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  7   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  7   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  7   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  7   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  7   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  7   162     2 link_err_path_ptr unal bit (18),
  7   163     2 link_after_path_ptr unal bit (18),
  7   164     2 unlk_before_path_ptr unal bit (18),
  7   165     2 unlk_err_path_ptr unal bit (18),
  7   166     2 unlk_after_path_ptr unal bit (18),
  7   167     2 str_before_path_ptr unal bit (18),
  7   168     2 str_err_path_ptr unal bit (18),
  7   169     2 str_after_path_ptr unal bit (18),
  7   170     2 del_before_path_ptr unal bit (18),
  7   171     2 del_err_path_ptr unal bit (18),
  7   172     2 del_after_path_ptr unal bit (18),
  7   173     2 mod_before_path_ptr unal bit (18),
  7   174     2 mod_err_path_ptr unal bit (18),
  7   175     2 mod_after_path_ptr unal bit (18),
  7   176     2 find_before_path_ptr unal bit (18),
  7   177     2 find_err_path_ptr unal bit (18),
  7   178     2 find_after_path_ptr unal bit (18),
  7   179     2 retr_before_path_ptr unal bit (18),
  7   180     2 retr_err_path_ptr unal bit (18),
  7   181     2 retr_after_path_ptr unal bit (18),
  7   182     2 unused_1 unal bit (18),				/* for future expansion */
  7   183     2 unused_2 unal bit (18),
  7   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  7   185 dcl  ri_ptr ptr;
  7   186 
  7   187 /* a attr_info structure contains information about an attribute in a given relation.
  7   188*   since attributes may appear in more than one relation, each occurence of an attribute
  7   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  7   190*   the list is singly linked in definition order. the attr_info describes
  7   191*   the data it represents, and how that data is used during a database search. */
  7   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  7   193     2 name char (32),				/* name of attribute */
  7   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  7   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  7   196     2 link_attr bit (1) unal,				/* on if participates in link */
  7   197     2 reserved bit (33) unal,
  7   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  7   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  7   200     2 key_order unal fixed bin,			/* relative posit. in key */
  7   201     2 bit_offset fixed bin (35),			/* position in tuple */
  7   202     2 bit_length fixed bin (35),			/* length if fixed */
  7   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  7   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  7   205     2 domain_ptr unal bit (18),			/* to domain info */
  7   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  7   207     2 fwd_thread unal bit (18),			/* to next in list */
  7   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  7   209 dcl  ai_ptr ptr;
  7   210 
  7   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  7   212*   each time a foreign key definition indicates a relation as it's parent,
  7   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  7   214*   a relation can be parent and/or child in any number of foreign keys.
  7   215*   the parent_link_info structure describes the foreign key, and also points
  7   216*   to a list of the attributes that participate in this foreign key.
  7   217*   (this could be from 1 up to all attributes in the relation)
  7   218*   the attr_list structures are in a singly linked list in definition order
  7   219*   for this purpose. also pointed to is a list of child_link_info's
  7   220*   that describe the child relations in this foreign key. since foreign keys
  7   221*   may span files, not all related child_link_info's have to be in this file's
  7   222*   model area. */
  7   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  7   224     2 name char (32),				/* name of link */
  7   225     2 singular bit (1) unal,				/* on if system owned link */
  7   226     2 temp bit (1) unal,				/* on if temp. order */
  7   227     2 first bit (1) unal,				/* insertion indicators */
  7   228     2 last bit (1) unal,
  7   229     2 next bit (1) unal,
  7   230     2 prior bit (1) unal,
  7   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  7   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  7   233     2 dup_first bit (1) unal,				/* duplicates first */
  7   234     2 dup_last bit (1) unal,				/* duplicates last */
  7   235     2 indexed bit (1) unal,				/* locate parent via index */
  7   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  7   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  7   238     2 thread_27 bit (1) unal,
  7   239     2 thread_18 bit (1) unal,
  7   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  7   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  7   242     2 reserved bit (19) unal,				/* reserved for future flags */
  7   243     2 index_id aligned bit (8),			/* id of index if indexed */
  7   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  7   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  7   246     2 n_children unal fixed bin,			/* no. children in link */
  7   247     2 child_fn char (30),				/* file name for first child in list */
  7   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  7   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  7   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  7   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  7   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  7   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  7   254     2 sort_err_path_ptr unal bit (18),
  7   255     2 sort_after_path_ptr unal bit (18),
  7   256     2 srch_before_path_ptr unal bit (18),
  7   257     2 srch_err_path_ptr unal bit (18),
  7   258     2 srch_after_path_ptr unal bit (18),
  7   259     2 link_before_path_ptr unal bit (18),
  7   260     2 link_err_path_ptr unal bit (18),
  7   261     2 link_after_path_ptr unal bit (18),
  7   262     2 unlk_before_path_ptr unal bit (18),
  7   263     2 unlk_err_path_ptr unal bit (18),
  7   264     2 unlk_after_path_ptr unal bit (18),
  7   265     2 unused_1 unal bit (18),				/* for future expansion */
  7   266     2 unused_2 unal bit (18),
  7   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  7   268 dcl  pli_ptr ptr;
  7   269 
  7   270 /* a child_link_info structure is the counter part of a parent_link_info
  7   271*   for foreign key child relations. each time a relation is defined to be
  7   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  7   273*   this list is singly linked in foreign key definition order.
  7   274*   the child_link_info points to a list of participating attributes from the
  7   275*   child relation by means of a singly linked list of attr_list structures
  7   276*   in definition order. the number of attributes in the parent attr_list
  7   277*   and the child attr_list lists are the same with corresponding attr_list
  7   278*   attributes having the same domain. all child_link_infos in this file
  7   279*   are on a seperately linked list. this may not include all
  7   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  7   281*   since foreign keys may span files, and the child_link_info will
  7   282*   reside in the file containing it's associated relation_info. */
  7   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  7   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  7   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  7   286     2 fixed bit (1) unal,				/* on if membership fixed */
  7   287     2 optional bit (1) unal,				/* on if membership optional */
  7   288     2 auto bit (1) unal,				/* on if insertion automatic */
  7   289     2 manual bit (1) unal,				/* on if insertion manual */
  7   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  7   291     2 range_sel bit (1) unal,				/* on if range type selection */
  7   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  7   293     2 key_dup_last bit (1) unal,
  7   294     2 key_null bit (1) unal,				/* on if null allowed */
  7   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  7   296     2 sel_current bit (1) unal,
  7   297     2 sel_key bit (1) unal,
  7   298     2 sel_proc bit (1) unal,
  7   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  7   300     2 reserved bit (21) unal,
  7   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  7   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  7   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  7   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  7   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  7   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  7   307     2 parent_fn char (30),				/* file name for parent info */
  7   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  7   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  7   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  7   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  7   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  7   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  7   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  7   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  7   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  7   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  7   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  7   319     2 link_err_path_ptr unal bit (18),
  7   320     2 link_after_path_ptr unal bit (18),
  7   321     2 unlk_before_path_ptr unal bit (18),
  7   322     2 unlk_err_path_ptr unal bit (18),
  7   323     2 unlk_after_path_ptr unal bit (18),
  7   324     2 srch_before_path_ptr unal bit (18),
  7   325     2 srch_err_path_ptr unal bit (18),
  7   326     2 srch_after_path_ptr unal bit (18),
  7   327     2 unused_1 unal bit (18),				/* for future expansion */
  7   328     2 unused_2 unal bit (18) ;
  7   329 dcl  cli_ptr ptr;
  7   330 
  7   331 /* the attr_list structure is associated with the parent_link_info
  7   332*   and child_link_info structures to represent by means of a singly linked list
  7   333*   the participating attributes from relations in a foreign key.
  7   334*   the parent_link_info has a list for the parent relation,
  7   335*   and the child_link_info has a list for the child relation.
  7   336*   the participating attributes are a subset(not necessary proper) of
  7   337*   those attributes contained in a relation definition.
  7   338*   there are equal numbers of attr_list structures in the parent and
  7   339*   child lists of the same foreign key. the corresponding attributes in these
  7   340*   lists must have the same domain. */
  7   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  7   342     2 attr_fn char (30),				/* file name for attr. */
  7   343     2 attr_ptr unal bit (18),				/* to attr info block */
  7   344     2 fwd_thread unal bit (18);			/* to next in list */
  7   345 dcl  al_ptr ptr;
  7   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  7   347     2 ascend bit (1) unal,				/* ascending order */
  7   348     2 descend bit (1) unal,				/* descending order */
  7   349     2 reserved bit (34) unal,
  7   350     2 attr_ptr unal bit (18),				/* to attr info */
  7   351     2 fwd_thread unal bit (18);			/* to next in list */
  7   352 dcl  sk_ptr ptr;
  7   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  7   354     2 attr_ptr unal bit (18),				/* to attr info */
  7   355     2 fwd_thread unal bit (18);			/* to next in list */
  7   356 dcl  dp_ptr ptr;
  7   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  7   358     2 link_fn char (30),				/* file name for thru link */
  7   359     2 link_ptr unal bit (18),				/* to parent link info */
  7   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  7   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  7   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  7   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  7   364     2 fwd_thread unal bit (18);			/* to next in chain */
  7   365 dcl  sc_ptr ptr;
  7   366 
  7   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  7   368 
  7   369 
      343 
      344 
      345 	dcl     desc_ptr		 ptr;
      346 
      347 	dcl     1 descriptor	 based (desc_ptr),
      348 		2 version		 bit (1) unal,
      349 		2 type		 fixed bin (6) unsigned unal,
      350 		2 packed		 bit (1) unal,
      351 		2 number_dims	 bit (4) unal,
      352 		2 size		 fixed bin (24) unsigned unal;
      353 
      354 /* Automatic */
      355 
      356 	dcl     code		 fixed bin (35);
      357 	dcl     dir		 char (168);
      358 	dcl     dir_len		 fixed bin;
      359 	dcl     dummy_align		 fixed bin;
      360 	dcl     dummy_offset	 fixed bin;
      361 	dcl     ent		 char (32);
      362 	dcl     found		 bit (1);
      363 	dcl     i			 fixed bin;
      364 	dcl     iocb_ptr		 ptr;
      365 	dcl     key_attr_index	 fixed bin;
      366 	dcl     key_collection_info_ptr ptr;
      367 	dcl     key_coll_index	 fixed bin;
      368 	dcl     open_info_coll_index	 fixed bin;
      369 	dcl     pri_key_align	 fixed bin;
      370 	dcl     pri_key_bit_len	 fixed bin;
      371 	dcl     pri_key_offset	 fixed bin;
      372 	dcl     rel_name		 char (30);
      373 	dcl     seg_ptr		 ptr;
      374 
      375 /* Based */
      376 
      377 	dcl     wa		 area (sys_info$max_seg_size) based (vrm_com.work_area_ptr);
      378 
      379 
      380 /* Builtin */
      381 
      382 	dcl     (
      383 	        addr,
      384 	        divide,
      385 	        fixed,
      386 	        mod,
      387 	        null,
      388 	        pointer,
      389 	        rel,
      390 	        substr
      391 	        )			 builtin;
      392 
      393 
      394 /* Condition */
      395 
      396 	dcl     cleanup		 condition;
      397 
      398 /* External entries */
      399 
      400 	dcl     hcs_$fs_get_path_name	 entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
      401 	dcl     hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      402 	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
      403 	dcl     iox_$seek_key	 entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
      404 	dcl     vrmu_encode_key$compute_alignment_and_length entry (ptr, fixed bin, fixed bin, fixed bin);
      405 	dcl     vrmu_iocb_manager$create_iocb entry (char (*), char (*), fixed bin, bit (1) aligned, char (*), ptr,
      406 				 fixed bin (35));
      407 	dcl     vrmu_iocb_manager$destroy_iocb entry (ptr, fixed bin (35));
      408 
      409 /* External static */
      410 
      411 	dcl     (error_table_$noentry,
      412 	        sys_info$max_seg_size) ext static fixed bin (35);
      413 	dcl     vrm_data_$iocb_list_block_size ext static fixed bin;
      414 
      415 /* Internal static */
      416 
      417 	dcl     KSQR		 fixed bin int static options (constant) init (8);
      418 	dcl     NULL_OFFSET		 bit (18) int static options (constant) init ((18)"1"b);
      419 
      420 /* Structure */
      421 
      422 	dcl     1 rs_info		 aligned,
      423 		2 version		 fixed bin init (2),
      424 		2 flags		 aligned,
      425 		  3 lock_sw	 bit (1) unal init ("0"b),
      426 		  3 unlock_sw	 bit (1) unal init ("0"b),
      427 		  3 create_sw	 bit (1) unal init ("0"b),
      428 		  3 locate_sw	 bit (1) unal init ("0"b),
      429 		  3 inc_ref_count	 bit (1) unal init ("0"b),
      430 		  3 dec_ref_count	 bit (1) unal init ("0"b),
      431 		  3 locate_pos_sw	 bit (1) unal init ("0"b),
      432 		  3 mbz		 bit (29) unal init ("0"b),
      433 		2 record_length	 fixed bin (21) init (0),
      434 		2 max_rec_len	 fixed bin (21) init (0),
      435 		2 record_ptr	 ptr init (null),
      436 		2 descriptor	 fixed bin (35) init (0),
      437 		2 ref_count	 fixed bin (34) init (0),
      438 		2 time_last_modified fixed bin (71) init (0),
      439 		2 modifier	 fixed bin (35) init (0),
      440 		2 block_ptr	 ptr unal init (null),
      441 		2 mbz2		 (2) fixed bin init (0, 0);
      442 
      443 
      444 	dcl     1 sh_info		 aligned,
      445 		2 relation_type	 fixed bin init (1),/* greater than or equal to */
      446 		2 n		 fixed bin init (4),/* number of relevant chars in key */
      447 		2 search_key	 char (4);
      448 
      449      end vrmu_init_rel_desc;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1143.7  vrmu_init_rel_desc.pl1            >special_ldd>install>MR12.0-1187>vrmu_init_rel_desc.pl1
331          1    10/14/83  1609.1  vrm_open_info.incl.pl1            >ldd>include>vrm_open_info.incl.pl1
333          2    10/14/83  1609.1  vrm_rel_desc.incl.pl1             >ldd>include>vrm_rel_desc.incl.pl1
335          3    10/14/83  1609.1  vrm_collection_info.incl.pl1      >ldd>include>vrm_collection_info.incl.pl1
337          4    10/14/83  1609.1  vrm_com.incl.pl1                  >ldd>include>vrm_com.incl.pl1
339          5    10/14/83  1609.1  vrm_iocb_list_block.incl.pl1      >ldd>include>vrm_iocb_list_block.incl.pl1
341          6    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
343          7    10/16/86  1139.9  mdbm_file_model.incl.pl1          >special_ldd>install>MR12.0-1187>mdbm_file_model.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
I_db_path                              parameter       char                     unaligned dcl 55 set ref 7 86* 237* 278
I_model_ptr                            parameter       pointer                  dcl 58 ref 7 68
I_oid                                  parameter       bit(36)                  dcl 60 ref 7 273
I_rel_name                             parameter       char                     unaligned dcl 56 set ref 7 67 237*
I_uid                                  parameter       bit(36)                  dcl 57 ref 7 275
I_vrm_com_ptr                          parameter       pointer                  dcl 59 ref 7 66 281
KSQR                            000117 constant        fixed bin(17,0)          initial dcl 417 set ref 237*
MRDS_compatible           3(01)        based           bit(1)                   level 3 packed unaligned dcl 2-5 set ref 139*
NULL_OFFSET                            constant        bit(18)                  initial unaligned dcl 418 ref 123
O_code                                 parameter       fixed bin(35,0)          dcl 62 set ref 7 65* 308*
O_vrm_open_info_ptr                    parameter       pointer                  dcl 61 set ref 7 64* 80*
VRM_OPEN_INFO_VERSION_1         000104 constant        char(8)                  initial unaligned dcl 1-27 ref 272
VRM_REL_DESC_KEY                000000 constant        varying char(256)        initial dcl 2-46 set ref 240*
VRM_REL_DESC_VERSION_1          000102 constant        char(8)                  initial unaligned dcl 2-44 ref 112 118
addr                                                   builtin function         dcl 382 ref 170 176 241 241
ai_ptr                          000132 automatic       pointer                  dcl 7-209 set ref 96* 97* 97 99 99 165* 166* 166 168
                                                                                  174 188 205 205 212 213 226 227
attr                     14            based           structure                array level 2 dcl 2-5
attr_index                3            based           fixed bin(17,0)          array level 3 dcl 3-6 set ref 196* 216*
attr_info                              based           structure                level 1 dcl 7-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 7-126 ref 96 165
attribute                 3            based           structure                array level 2 dcl 3-6
bit_length               14            based           fixed bin(35,0)          level 2 in structure "attr_info" dcl 7-192
                                                                                  in procedure "vrmu_init_rel_desc" ref 226
bit_length               26            based           fixed bin(35,0)          array level 3 in structure "vrm_rel_desc" dcl 2-5
                                                                                  in procedure "vrmu_init_rel_desc" set ref 226*
bit_offset               13            based           fixed bin(35,0)          level 2 in structure "attr_info" dcl 7-192
                                                                                  in procedure "vrmu_init_rel_desc" ref 227
bit_offset               27            based           fixed bin(35,0)          array level 3 in structure "vrm_rel_desc" dcl 2-5
                                                                                  in procedure "vrmu_init_rel_desc" set ref 227*
block_ptr                13     000262 automatic       pointer                  initial level 2 packed unaligned dcl 422 set ref
                                                                                  422*
cd                                     parameter       fixed bin(35,0)          dcl 306 ref 304 308
cleanup                         000254 stack reference condition                dcl 396 ref 75
code                            000136 automatic       fixed bin(35,0)          dcl 356 set ref 86* 237* 238 238* 240* 241 241* 242
                                                                                  242* 248* 249 249* 251* 252* 259* 260 260* 325*
com_ptr                  74            based           pointer                  level 2 dcl 1-6 set ref 281*
create_sw                 1(02) 000262 automatic       bit(1)                   initial level 3 packed unaligned dcl 422 set ref
                                                                                  422*
database_dir_path         6            based           varying char(168)        level 2 dcl 1-6 set ref 278*
db_desc                  11            based           bit(36)                  level 2 dcl 6-125 set ref 170 175 176
db_model                               based           structure                level 1 dcl 6-72
dbm_ptr                         000120 automatic       pointer                  dcl 6-106 set ref 86* 87 120 120 133 168
dec_ref_count             1(05) 000262 automatic       bit(1)                   initial level 3 packed unaligned dcl 422 set ref
                                                                                  422*
desc_ptr                        000134 automatic       pointer                  dcl 345 set ref 170* 171 171 176* 178 178 192* 220*
descriptor               24            based           bit(36)                  array level 3 in structure "vrm_rel_desc" dcl 2-5
                                                                                  in procedure "vrmu_init_rel_desc" set ref 175*
descriptor                6     000262 automatic       fixed bin(35,0)          initial level 2 in structure "rs_info" dcl 422
                                                                                  in procedure "vrmu_init_rel_desc" set ref 422*
descriptor                             based           structure                level 1 packed unaligned dcl 347 in procedure
                                                                                  "vrmu_init_rel_desc"
di_ptr                          000124 automatic       pointer                  dcl 6-155 set ref 168* 170 175 176
dir                             000137 automatic       char(168)                unaligned dcl 357 set ref 248* 251*
dir_len                         000211 automatic       fixed bin(17,0)          dcl 358 set ref 248*
divide                                                 builtin function         dcl 382 ref 141
domain_info                            based           structure                level 1 dcl 6-125
domain_ptr               17            based           bit(18)                  level 2 packed unaligned dcl 7-192 ref 168
dummy_align                     000212 automatic       fixed bin(17,0)          dcl 359 set ref 220*
dummy_offset                    000213 automatic       fixed bin(17,0)          dcl 360 set ref 219* 220*
ent                             000214 automatic       char(32)                 unaligned dcl 361 set ref 248* 251*
error_table_$noentry            000026 external static fixed bin(35,0)          dcl 411 set ref 87* 136*
fi_ptr                          000122 automatic       pointer                  dcl 6-119 set ref 120* 123 124 131 133* 133
file_id                   2(18)        based           bit(7)                   level 2 in structure "vrm_rel_desc" packed unaligned
                                                                                  dcl 2-5 in procedure "vrmu_init_rel_desc" set ref
                                                                                  131*
file_id                  10            based           bit(36)                  level 2 in structure "file_info" dcl 6-113
                                                                                  in procedure "vrmu_init_rel_desc" ref 131
file_info                              based           structure                level 1 dcl 6-113
file_model                             based           structure                level 1 dcl 7-40
file_name                              based           char(30)                 level 2 dcl 6-113 ref 124
file_ptr                 22            based           bit(18)                  level 2 packed unaligned dcl 6-72 ref 120
file_uid                  3            based           bit(36)                  level 2 dcl 1-6 set ref 275*
flags                     1     000262 automatic       structure                level 2 dcl 422
fm_ptr                          000126 automatic       pointer                  dcl 7-108 set ref 68* 77 89 89 96 97 165 166
found                           000224 automatic       bit(1)                   unaligned dcl 362 set ref 121* 123 125* 136
fwd_ptr                  11            based           bit(18)                  level 2 packed unaligned dcl 6-113 ref 133
fwd_thread               20            based           bit(18)                  level 2 packed unaligned dcl 7-192 ref 97 166
hcs_$fs_get_path_name           000010 constant        entry                    external dcl 400 ref 248
hcs_$initiate                   000012 constant        entry                    external dcl 401 ref 86 251
i                               000225 automatic       fixed bin(17,0)          dcl 363 set ref 95* 96* 163* 165 174 175 180 181 183
                                                                                  185 186 189 190 196 207 216 225 226 227* 297* 298
                                                                                  299*
id                      103            based           bit(36)                  array level 3 in structure "vrm_open_info" dcl 1-6
                                                                                  in procedure "vrmu_init_rel_desc" set ref 212*
                                                                                  298*
id                        0(04)        based           bit(8)                   level 3 in structure "vrm_collection_info" packed
                                                                                  unaligned dcl 3-6 in procedure
                                                                                  "vrmu_init_rel_desc" set ref 158* 213*
id                       10            based           bit(36)                  level 2 in structure "rel_info" dcl 7-126
                                                                                  in procedure "vrmu_init_rel_desc" ref 138
inc_ref_count             1(04) 000262 automatic       bit(1)                   initial level 3 packed unaligned dcl 422 set ref
                                                                                  422*
index_attr               10(01)        based           bit(1)                   level 2 packed unaligned dcl 7-192 ref 99 205
index_collection        103            based           structure                array level 2 dcl 1-6
index_id                 11            based           bit(36)                  level 2 dcl 7-192 ref 99 205 212 213
indexed                   3(03)        based           bit(1)                   level 3 in structure "vrm_rel_desc" packed unaligned
                                                                                  dcl 2-5 in procedure "vrmu_init_rel_desc" set ref
                                                                                  115*
indexed                  11(04)        based           bit(1)                   level 2 in structure "rel_info" packed unaligned
                                                                                  dcl 7-126 in procedure "vrmu_init_rel_desc" ref
                                                                                  115
info_ptr                104            based           pointer                  array level 3 packed unaligned dcl 1-6 set ref 211*
                                                                                  299*
iocb_list_ptr            76            based           pointer                  level 2 dcl 1-6 set ref 292*
iocb_ptr                        000226 automatic       pointer                  dcl 364 set ref 73* 237* 240* 241* 259* 325 325*
iocbs                     4            based           pointer                  array level 2 dcl 5-5 set ref 290*
iox_$control                    000014 constant        entry                    external dcl 402 ref 241
iox_$seek_key                   000016 constant        entry                    external dcl 403 ref 240
key_attr                 10            based           bit(1)                   level 2 packed unaligned dcl 7-192 ref 188
key_attr_index                  000230 automatic       fixed bin(17,0)          dcl 365 set ref 152*
key_bit_len               5            based           fixed bin(17,0)          array level 3 dcl 3-6 set ref 199* 220*
key_coll_index                  000234 automatic       fixed bin(17,0)          dcl 367 set ref 159* 196 197 199 202* 202
key_collection_info_ptr         000232 automatic       pointer                  dcl 366 set ref 155* 156 157 158 160 195
key_head                 25(01)        based           bit(1)                   array level 3 packed unaligned dcl 2-5 set ref 185*
                                                                                  190* 207*
key_offset                4            based           fixed bin(17,0)          array level 3 dcl 3-6 set ref 197* 217*
last_var_attr_no         11            based           fixed bin(17,0)          level 2 dcl 2-5 set ref 146* 181*
locate_pos_sw             1(06) 000262 automatic       bit(1)                   initial level 3 packed unaligned dcl 422 set ref
                                                                                  422*
locate_sw                 1(03) 000262 automatic       bit(1)                   initial level 3 packed unaligned dcl 422 set ref
                                                                                  422*
lock_sw                   1     000262 automatic       bit(1)                   initial level 3 packed unaligned dcl 422 set ref
                                                                                  422*
max_data_len             17            based           fixed bin(35,0)          level 2 dcl 7-126 ref 141 142
max_rec_len               3     000262 automatic       fixed bin(21,0)          initial level 2 dcl 422 set ref 422*
maximum_data_length       6            based           fixed bin(35,0)          level 2 dcl 2-5 set ref 141* 142* 142
mbz                       1(07) 000262 automatic       bit(29)                  initial level 3 packed unaligned dcl 422 set ref
                                                                                  422*
mbz2                     14     000262 automatic       fixed bin(17,0)          initial array level 2 dcl 422 set ref 422* 422*
mod                                                    builtin function         dcl 382 ref 142
modifier                 12     000262 automatic       fixed bin(35,0)          initial level 2 dcl 422 set ref 422*
n                         1     000300 automatic       fixed bin(17,0)          initial level 2 dcl 444 set ref 444*
name                     14            based           char(32)                 array level 3 in structure "vrm_rel_desc" dcl 2-5
                                                                                  in procedure "vrmu_init_rel_desc" set ref 174*
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 7-192
                                                                                  in procedure "vrmu_init_rel_desc" ref 174
next_block_ptr            2            based           pointer                  level 2 packed unaligned dcl 5-5 set ref 289*
no_of_indexes                          parameter       fixed bin(17,0)          dcl 266 ref 264 268
null                                                   builtin function         dcl 382 ref 64 70 71 72 73 77 87 252 280 288 289 290
                                                                                  299 321 323 325 422 422
num_attr                 12            based           fixed bin(17,0)          level 2 packed unaligned dcl 7-126 ref 95 107
num_iocbs_used                         based           fixed bin(17,0)          level 2 dcl 5-5 set ref 287*
num_key_attrs            14            based           fixed bin(17,0)          level 2 packed unaligned dcl 7-126 ref 144 154
number_attrs             13            based           fixed bin(17,0)          level 2 dcl 2-5 set ref 108* 110 148* 163 323
number_of_attributes      2            based           fixed bin(17,0)          level 2 dcl 3-6 set ref 155* 210*
number_of_index_collections
                        102            based           fixed bin(17,0)          level 2 dcl 1-6 set ref 269* 297
number_of_openings        4            based           fixed bin(17,0)          level 2 dcl 1-6 set ref 276*
number_primary_key_attrs
                          7            based           fixed bin(17,0)          level 2 dcl 2-5 set ref 144*
number_sec_indexes       10            based           fixed bin(17,0)          level 2 dcl 2-5 set ref 145* 208* 208 254*
number_var_attrs         12            based           fixed bin(17,0)          level 2 dcl 2-5 set ref 147*
nvar_atts                14(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 7-126 ref 147
open_info_coll_index            000235 automatic       fixed bin(17,0)          dcl 368 set ref 161* 211 212 223* 223
opening_id                2            based           bit(36)                  level 2 dcl 1-6 set ref 273*
pad                       3(04)        based           bit(33)                  level 3 in structure "vrm_rel_desc" packed unaligned
                                                                                  dcl 2-5 in procedure "vrmu_init_rel_desc" set ref
                                                                                  116*
pad                       5(01)        based           bit(35)                  initial level 3 in structure "vrm_open_info" packed
                                                                                  unaligned dcl 1-6 in procedure
                                                                                  "vrmu_init_rel_desc" set ref 269*
pad                      25(03)        based           bit(15)                  array level 3 in structure "vrm_rel_desc" packed
                                                                                  unaligned dcl 2-5 in procedure
                                                                                  "vrmu_init_rel_desc" set ref 225*
pointer                                                builtin function         dcl 382 ref 89 96 97 120 133 165 166 168
prev_block_ptr            1            based           pointer                  level 2 packed unaligned dcl 5-5 set ref 288*
pri_key_align                   000236 automatic       fixed bin(17,0)          dcl 369 set ref 192* 194
pri_key_bit_len                 000237 automatic       fixed bin(17,0)          dcl 370 set ref 192* 199 200
pri_key_offset                  000240 automatic       fixed bin(17,0)          dcl 371 set ref 151* 190 192* 194* 194 197 200* 200
primary_key               0(13)        based           bit(1)                   level 2 packed unaligned dcl 3-6 set ref 157* 215*
primary_key_attr         25(02)        based           bit(1)                   array level 3 packed unaligned dcl 2-5 set ref 186*
                                                                                  189*
primary_key_info_ptr    100            based           pointer                  level 2 dcl 1-6 set ref 160*
record_id                              based           structure                level 2 packed unaligned dcl 3-6
record_length             2     000262 automatic       fixed bin(21,0)          initial level 2 dcl 422 set ref 422*
record_ptr                4     000262 automatic       pointer                  initial level 2 dcl 422 set ref 248* 254 255 422*
ref_count                 7     000262 automatic       fixed bin(34,0)          initial level 2 dcl 422 set ref 422*
rel                                                    builtin function         dcl 382 ref 123
rel_id                    2(25)        based           bit(12)                  level 2 packed unaligned dcl 2-5 set ref 138*
rel_info                               based           structure                level 1 dcl 7-126
rel_name                        000241 automatic       char(30)                 unaligned dcl 372 set ref 67* 124 279
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 7-40 ref 89
relation_model_ptr       72            based           pointer                  level 2 dcl 1-6 set ref 111* 255* 280*
relation_name            61            based           varying char(30)         level 2 dcl 1-6 set ref 279*
relation_type                   000300 automatic       fixed bin(17,0)          initial level 2 dcl 444 set ref 444*
ri_ptr                          000130 automatic       pointer                  dcl 7-185 set ref 89* 95 96 107 115 138 140 141 142
                                                                                  144 147 154 165
rs_info                         000262 automatic       structure                level 1 dcl 422 set ref 241 241
seg_ptr                         000252 automatic       pointer                  dcl 373 set ref 251* 252
sh_info                         000300 automatic       structure                level 1 dcl 444
shared                    5            based           bit(1)                   level 3 packed unaligned dcl 1-6 set ref 277*
stationary_records        3(02)        based           bit(1)                   level 3 packed unaligned dcl 2-5 set ref 114* 171*
substr                                                 builtin function         dcl 382 ref 131 138 212 213
switches                  5            based           structure                level 2 in structure "vrm_open_info" dcl 1-6
                                                                                  in procedure "vrmu_init_rel_desc"
switches                  3(01)        based           structure                level 2 in structure "vrm_rel_desc" packed unaligned
                                                                                  dcl 2-5 in procedure "vrmu_init_rel_desc"
time_last_modified       10     000262 automatic       fixed bin(71,0)          initial level 2 dcl 422 set ref 422*
type                      0(01)        based           fixed bin(6,0)           level 2 packed unsigned unaligned dcl 347 ref 171
                                                                                  171 178 178
unique                    0(12)        based           bit(1)                   level 2 packed unaligned dcl 3-6 set ref 156* 214*
unlock_sw                 1(01) 000262 automatic       bit(1)                   initial level 3 packed unaligned dcl 422 set ref
                                                                                  422*
var_offset                5            based           fixed bin(35,0)          level 2 in structure "vrm_rel_desc" dcl 2-5
                                                                                  in procedure "vrmu_init_rel_desc" set ref 140*
var_offset               22            based           fixed bin(35,0)          level 2 in structure "rel_info" dcl 7-126
                                                                                  in procedure "vrmu_init_rel_desc" ref 140
varying                  25            based           bit(1)                   array level 3 packed unaligned dcl 2-5 set ref 180*
                                                                                  183*
vci_no_of_attributes            000112 automatic       fixed bin(17,0)          dcl 3-23 set ref 154* 155 155 209* 210 210
version                         000262 automatic       fixed bin(17,0)          initial level 2 in structure "rs_info" dcl 422
                                                                                  in procedure "vrmu_init_rel_desc" set ref 422*
version                   0(18)        based           char(8)                  level 2 in structure "vrm_rel_desc" packed unaligned
                                                                                  dcl 2-5 in procedure "vrmu_init_rel_desc" set ref
                                                                                  112* 118*
version                                based           char(8)                  level 2 in structure "vrm_open_info" dcl 1-6
                                                                                  in procedure "vrmu_init_rel_desc" set ref 272*
voi_no_of_index_collections     000102 automatic       fixed bin(17,0)          dcl 1-29 set ref 94* 99* 99 103* 268* 269 269
vrd_no_of_attrs                 000106 automatic       fixed bin(17,0)          dcl 2-42 set ref 107* 108 108 148
vrm_attr_info                          based           structure                level 1 unaligned dcl 2-28
vrm_collection_info                    based           structure                level 1 dcl 3-6 set ref 155 210
vrm_collection_info_ptr         000110 automatic       pointer                  dcl 3-21 set ref 195* 196 197 199 210* 211 213 214
                                                                                  215 216 217 220
vrm_com                                based           structure                level 1 dcl 4-6
vrm_com_ptr                     000114 automatic       pointer                  dcl 4-5 set ref 66* 108 155 210 269 285
vrm_data_$iocb_list_block_size  000030 external static fixed bin(17,0)          dcl 413 ref 285 290 321
vrm_iocb_list_block                    based           structure                level 1 dcl 5-5 set ref 285 321
vrm_iocb_list_block_ptr         000116 automatic       pointer                  dcl 5-3 set ref 72* 285* 287 288 289 290 292 321 321
vrm_open_info                          based           structure                level 1 dcl 1-6 set ref 269
vrm_open_info_ptr               000100 automatic       pointer                  dcl 1-28 set ref 70* 80 111 160 211 212 255 269* 272
                                                                                  273 275 276 277 278 279 280 281 292 297 298 299
vrm_rel_desc                           based           structure                level 1 unaligned dcl 2-5 set ref 108 110* 323
vrm_rel_desc_ptr                000104 automatic       pointer                  dcl 2-41 set ref 71* 108* 110 111 112 114 115 116
                                                                                  118 131 138 139 140 141 142 142 144 145 146 147
                                                                                  148 163 171 174 175 180 181 183 185 186 189 190
                                                                                  207 208 208 225 226 227 323 323
vrmu_encode_key$compute_alignment_and_length
                                000020 constant        entry                    external dcl 404 ref 192 220
vrmu_iocb_manager$create_iocb   000022 constant        entry                    external dcl 405 ref 237
vrmu_iocb_manager$destroy_iocb  000024 constant        entry                    external dcl 407 ref 259 325
wa                                     based           area                     dcl 377 ref 108 155 210 269 285
work_area_ptr             6            based           pointer                  level 2 dcl 4-6 ref 108 155 210 269 285

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
VRM_COLLECTION_KEY_HEAD                internal static char(16)                 initial unaligned dcl 3-26
VRM_REL_DESC_RECORD_ID                 internal static bit(12)                  initial unaligned dcl 2-43
al_ptr                                 automatic       pointer                  dcl 7-345
alloc_length                           internal static fixed bin(35,0)          dcl 6-222
atd                                    based           char                     unaligned dcl 7-109
atd_len                                automatic       fixed bin(17,0)          dcl 7-111
atd_ptr                                automatic       pointer                  dcl 7-110
attr_list                              based           structure                level 1 dcl 7-341
changer                                based           structure                level 1 packed unaligned dcl 6-251
changer_ptr                            automatic       pointer                  dcl 6-256
child_link_info                        based           structure                level 1 dcl 7-283
cli_ptr                                automatic       pointer                  dcl 7-329
cna_ptr                                automatic       pointer                  dcl 7-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 7-112
constant                               based           structure                level 1 unaligned dcl 6-216
constant_ptr                           automatic       pointer                  dcl 6-220
dp_ptr                                 automatic       pointer                  dcl 7-356
dup_prev                               based           structure                level 1 dcl 7-353
fixed                                                  builtin function         dcl 382
message_str                            based           structure                level 1 packed unaligned dcl 6-259
message_str_len                        automatic       fixed bin(17,0)          dcl 6-269
message_str_ptr                        automatic       pointer                  dcl 6-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 7-116
parent_link_info                       based           structure                level 1 dcl 7-223
path_entry                             based           structure                level 1 packed unaligned dcl 6-172
path_entry_ptr                         automatic       pointer                  dcl 6-177
pli_ptr                                automatic       pointer                  dcl 7-268
sc_ptr                                 automatic       pointer                  dcl 7-365
select_chain                           based           structure                level 1 dcl 7-357
sk_ptr                                 automatic       pointer                  dcl 7-352
sort_key                               based           structure                level 1 dcl 7-346
stack_item                             based           structure                level 1 unaligned dcl 6-206
stack_item_ptr                         automatic       pointer                  dcl 6-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 411
ua_ptr                                 automatic       pointer                  dcl 6-165
unreferenced_attribute                 based           structure                level 1 dcl 6-159
version_status                         based           structure                level 1 packed unaligned dcl 6-232
version_status_ptr                     automatic       pointer                  dcl 6-246
vrm_attr_info_ptr                      automatic       pointer                  dcl 2-45
vrm_collection_header_type             internal static bit(4)                   initial unaligned dcl 3-24

NAMES DECLARED BY EXPLICIT CONTEXT.
build_from_MRDS_model           000316 constant        entry                    internal dcl 84 ref 77
build_from_internal_model       001173 constant        entry                    internal dcl 233 ref 78
create_open_info                001463 constant        entry                    internal dcl 264 ref 103 254
error                           001620 constant        entry                    internal dcl 304 ref 87 136 238 242 249 252 260
exit                            000315 constant        label                    dcl 82 ref 309
tidy_up                         001626 constant        entry                    internal dcl 319 ref 75
vrmu_init_rel_desc              000151 constant        entry                    external dcl 7

NAME DECLARED BY CONTEXT OR IMPLICATION.
unspec                                                 builtin function         ref 110

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2104        2136    1725        2114
Length      2500    1725        32         326     157           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vrmu_init_rel_desc                  334 external procedure  is an external procedure.  
on unit on line 75                   76 on unit               
build_from_MRDS_model                   internal procedure  shares stack frame of external procedure vrmu_init_rel_desc.  
build_from_internal_model               internal procedure  shares stack frame of external procedure vrmu_init_rel_desc.  
create_open_info                        internal procedure  shares stack frame of external procedure vrmu_init_rel_desc.  
error                                   internal procedure  shares stack frame of external procedure vrmu_init_rel_desc.  
tidy_up                                 internal procedure  shares stack frame of on unit on line 75.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
vrmu_init_rel_desc       000100 vrm_open_info_ptr           vrmu_init_rel_desc
                         000102 voi_no_of_index_collections vrmu_init_rel_desc
                         000104 vrm_rel_desc_ptr            vrmu_init_rel_desc
                         000106 vrd_no_of_attrs             vrmu_init_rel_desc
                         000110 vrm_collection_info_ptr     vrmu_init_rel_desc
                         000112 vci_no_of_attributes        vrmu_init_rel_desc
                         000114 vrm_com_ptr                 vrmu_init_rel_desc
                         000116 vrm_iocb_list_block_ptr     vrmu_init_rel_desc
                         000120 dbm_ptr                     vrmu_init_rel_desc
                         000122 fi_ptr                      vrmu_init_rel_desc
                         000124 di_ptr                      vrmu_init_rel_desc
                         000126 fm_ptr                      vrmu_init_rel_desc
                         000130 ri_ptr                      vrmu_init_rel_desc
                         000132 ai_ptr                      vrmu_init_rel_desc
                         000134 desc_ptr                    vrmu_init_rel_desc
                         000136 code                        vrmu_init_rel_desc
                         000137 dir                         vrmu_init_rel_desc
                         000211 dir_len                     vrmu_init_rel_desc
                         000212 dummy_align                 vrmu_init_rel_desc
                         000213 dummy_offset                vrmu_init_rel_desc
                         000214 ent                         vrmu_init_rel_desc
                         000224 found                       vrmu_init_rel_desc
                         000225 i                           vrmu_init_rel_desc
                         000226 iocb_ptr                    vrmu_init_rel_desc
                         000230 key_attr_index              vrmu_init_rel_desc
                         000232 key_collection_info_ptr     vrmu_init_rel_desc
                         000234 key_coll_index              vrmu_init_rel_desc
                         000235 open_info_coll_index        vrmu_init_rel_desc
                         000236 pri_key_align               vrmu_init_rel_desc
                         000237 pri_key_bit_len             vrmu_init_rel_desc
                         000240 pri_key_offset              vrmu_init_rel_desc
                         000241 rel_name                    vrmu_init_rel_desc
                         000252 seg_ptr                     vrmu_init_rel_desc
                         000262 rs_info                     vrmu_init_rel_desc
                         000300 sh_info                     vrmu_init_rel_desc

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mdfx1               enable_op           ext_entry_desc
int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
hcs_$fs_get_path_name         hcs_$initiate                 iox_$control                  iox_$seek_key
vrmu_encode_key$compute_alignment_and_length                vrmu_iocb_manager$create_iocb
vrmu_iocb_manager$destroy_iocb

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$noentry          vrm_data_$iocb_list_block_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      7 000142       422 000171       444 000235        64 000241        65 000244        66 000245        67 000250
     68 000255        70 000260        71 000262        72 000263        73 000264        75 000265        77 000303
     78 000311        80 000312        82 000315        84 000316        86 000317        87 000366        89 000401
     94 000411        95 000412        96 000423        97 000434        99 000442       101 000450       103 000452
    107 000454       108 000460       110 000472       111 000502       112 000504       114 000507       115 000511
    116 000517       120 000522       121 000530       123 000531       124 000541       125 000546       131 000550
    133 000556       134 000563       136 000564       138 000575       139 000606       140 000610       141 000612
    142 000615       144 000625       145 000630       146 000631       147 000632       148 000637       151 000641
    152 000642       154 000644       155 000646       156 000660       157 000662       158 000664       159 000666
    160 000670       161 000672       163 000673       165 000703       166 000714       168 000722       170 000727
    171 000731       174 000746       175 000754       176 000757       178 000761       180 000774       181 000777
    182 001001       183 001002       185 001005       186 001007       188 001011       189 001014       190 001016
    192 001022       194 001037       195 001041       196 001043       197 001050       199 001053       200 001055
    202 001057       205 001060       207 001066       208 001073       209 001074       210 001076       211 001110
    212 001114       213 001121       214 001126       215 001130       216 001132       217 001134       219 001135
    220 001136       223 001154       225 001155       226 001162       227 001166       229 001170       231 001172
    233 001173       237 001174       238 001243       240 001247       241 001265       242 001321       248 001325
    249 001356       251 001362       252 001425       254 001433       255 001442       259 001445       260 001456
    262 001462       264 001463       268 001465       269 001467       272 001503       273 001506       275 001511
    276 001513       277 001515       278 001517       279 001530       280 001535       281 001537       285 001542
    287 001553       288 001554       289 001556       290 001557       292 001575       297 001577       298 001607
    299 001612       300 001615       302 001617       304 001620       308 001622       309 001625       319 001626
    321 001627       323 001642       325 001655       329 001673


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
