	COMPILATION LISTING OF SEGMENT vrm_get_by_id
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1156.02_Tue_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 get_tuple_by_id: proc (I_relation_cursor_ptr, I_element_id, I_id_list_ptr,
        8 	I_return_area_ptr, O_simple_typed_vector_ptr, O_code);
        9 
       10 /* .	    BEGIN_DESCRIPTION
       11*
       12*     Get the value of the specified tuple.  The input specification must
       13*     be converted to a value for vfile_. The record then retrieved from 
       14*     the vfile must then be converted to a vector.
       15*
       16*   .          END_DESCRIPTION		    */
       17 
       18 /* History:
       19*
       20*   82-08-23  R. Harvey:  Initially written.
       21*   83-05-24 Roger Lackey: replaced call to record_status to get record_ptr
       22*                          with call to vrmu_cv_vf_desc_to_ptr
       23*   84-11-27 John Hergert: commented out code that locks file. There doesn't
       24*   appear to be a reason for locking the file for a retrieve and it was
       25*   causing numerous file_busy errors.
       26**/
       27 
       28 /*	  Parameters	  */
       29 
       30 	dcl     I_relation_cursor_ptr	 ptr;		/* Cursor of relation */
       31 	dcl     I_element_id	 bit (36) aligned;	/* Tuple identifier of tuple to be retrieved */
       32 	dcl     I_id_list_ptr	 ptr;		/* List of attribute numbers to be returned */
       33 	dcl     I_return_area_ptr	 ptr;		/* User area for tuple and vector allocation */
       34 	dcl     O_simple_typed_vector_ptr ptr;		/* The returned tuple as a vector */
       35 	dcl     O_code		 fixed bin (35);
       36 
       37 
       38 	O_code = 0;
       39 	file_locked = "0"b;
       40 
       41 	vrm_cursor_ptr = I_relation_cursor_ptr;
       42 
       43 	on cleanup call tidy_up;
       44 
       45 	call init_get;
       46 
       47 	call process_one_tuple_id (I_element_id, I_id_list_ptr, O_simple_typed_vector_ptr, code);
       48 	if code ^= 0 then call error (code);
       49 
       50 	O_code = 0;
       51 
       52 	if metering_sw then do;
       53 		call cpu_time_and_paging_ (pf_2, t2, pf_dummy);
       54 		vrm_meter.last_call_stats.last_time_of_stats = clock;
       55 
       56 		t3 = t2 - t1;
       57 		vrm_meter.last_call_stats.vcpu_time = divide (t3, 1000000, 63);
       58 		vrm_meter.last_call_stats.page_faults = pf_2 - pf_1;
       59 		vrm_meter.last_call_stats.number_times_used = 1;
       60 		vrm_meter.total_stats.last_time_of_stats = 0;
       61 		vrm_meter.total_stats = vrm_meter.total_stats + vrm_meter.last_call_stats;
       62 
       63 	     end;
       64 
       65 Exit:	return;
       66 
       67 get_tuples_by_id: entry (I_relation_cursor_ptr, I_element_id_list_ptr, I_id_list_ptr, I_return_area_ptr, O_simple_typed_vector_list_ptr, O_code);
       68 
       69 /* Parameters */
       70 
       71 	dcl     I_element_id_list_ptr	 ptr;		/* Tuple identifiers of tuples to be retrieved */
       72 						/*	dcl     I_return_area_ptr	 ptr;	       */ /* User area for tuple and vector allocation */
       73 
       74 /*	dcl     I_id_list_ptr	 ptr;	       */ /* List of attribute numbers to be returned */
       75 /*	dcl     I_relation_cursor_ptr ptr;	       */ /* Cursor of relation */
       76 	dcl     O_simple_typed_vector_list_ptr ptr;	/* The returned tuple as a vector */
       77 						/*	dcl     O_code		 fixed bin (35); */
       78 
       79 
       80 	O_simple_typed_vector_list_ptr = null;
       81 	O_code = 0;
       82 	file_locked = "0"b;
       83 
       84 	on cleanup call tidy_up;
       85 
       86 	on area call error (error_table_$noalloc);
       87 
       88 	element_id_list_ptr = I_element_id_list_ptr;
       89 
       90 	vrm_cursor_ptr = I_relation_cursor_ptr;
       91 
       92 	call init_get;
       93 
       94 	tvl_maximum_number_of_vectors = element_id_list.number_of_elements;
       95 	allocate typed_vector_list in (return_area) set (typed_vector_list_ptr);
       96 	O_simple_typed_vector_list_ptr = typed_vector_list_ptr;
       97 	typed_vector_list.version = TYPED_VECTOR_LIST_VERSION_1;
       98 	typed_vector_list.number_of_vectors = 0;
       99 
      100 	do i = 1 to element_id_list.number_of_elements;
      101 
      102 	     typed_vector_list.vector_ptr (i) = null ();	/* So it gets allocated properly... */
      103 	     call process_one_tuple_id (element_id_list.id (i), I_id_list_ptr, typed_vector_list.vector_ptr (i), code);
      104 	     if code ^= 0 then call error (code);
      105 	     typed_vector_list.number_of_vectors = i;	/* Count stored pointers */
      106 	end;
      107 
      108 	O_code = 0;
      109 	call tidy_up;
      110 
      111 	return;
      112 
      113 
      114 init_get: proc;
      115 
      116 	if vrm_cursor.switches.meter_sw then do;
      117 
      118 		call cpu_time_and_paging_ (pf_1, t1, pf_dummy);
      119 		vrm_meter_ptr = vrm_cursor.meter_ptr;
      120 		vrm_meter.last_call_stats = 0;
      121 		metering_sw = "1"b;
      122 	     end;
      123 
      124 	else metering_sw = "0"b;
      125 
      126 	vrm_open_info_ptr = vrm_cursor.open_info_ptr;
      127 	vrm_com_ptr = vrm_open_info.com_ptr;
      128 	if vrm_com.get_seg_ptr = null () then do;	/* Segment for vfile_ to store retrieved record */
      129 		call get_temp_segment_ ("vrm_get_", vrm_com.get_seg_ptr, code);
      130 		if code ^= 0 then call error (code);
      131 		get_work_area = empty ();
      132 	     end;
      133 
      134 	vrm_cursor.switches.shared = vrm_open_info.switches.shared;
      135 
      136 
      137 	iocb_ptr = vrm_cursor.iocb_ptr;
      138 
      139      end;
      140 
      141 process_one_tuple_id: proc (tuple_id, id_list_ptr, simple_typed_vector_ptr, pcode);
      142 
      143 	dcl     tuple_id		 bit (36) aligned parameter;
      144 	dcl     simple_typed_vector_ptr ptr parameter;
      145 	dcl     id_list_ptr		 ptr parameter;
      146 	dcl     pcode		 fixed bin (35) parameter;
      147 
      148 
      149 	vf_desc = 0;
      150 	tid_ptr = addr (tuple_id);
      151 	vfd_ptr = addr (vf_desc);
      152 
      153 	vfd.comp_number = tid.comp_num;
      154 	vfd.comp_offset = tid.offset;
      155 
      156 /* No need to lock file when retrieving. This action causes many file busy
      157*   errors returned to the user on a heavily used db.
      158*	if vrm_cursor.switches.shared then do;
      159*		if vrm_cursor.opening_mode = KSQU then call lock;
      160*	     end;
      161**/
      162 	call vrmu_cv_vf_desc_to_ptr (iocb_ptr, vf_desc, rec_ptr, rec_len, pcode);
      163 	if pcode = 0 then do;
      164 		vrm_rel_desc_ptr = vrm_cursor.vrm_relation_desc_ptr;
      165 		call vrmu_cv_tuple_to_vector$simple_vector (rec_ptr,
      166 		     I_return_area_ptr, id_list_ptr, vrm_rel_desc_ptr, simple_typed_vector_ptr, pcode);
      167 		if metering_sw then
      168 		     vrm_meter.last_call_stats.number_items_returned =
      169 			vrm_meter.last_call_stats.number_items_returned + 1;
      170 end;
      171 
      172 /* If we dont lock earlier, no need to unlock now.
      173*	if file_locked then call unlock;
      174**/
      175 	return;
      176 
      177      end process_one_tuple_id;
      178 
      179 error: proc (ecode);
      180 
      181 	dcl     ecode		 fixed bin (35);
      182 
      183 	if ecode = error_table_$no_record then
      184 	     O_code = dm_error_$no_tuple_id;
      185 	else O_code = ecode;
      186 
      187 	call tidy_up;
      188 	go to Exit;
      189 
      190      end;
      191 
      192 
      193 
      194 
      195 tidy_up: proc;
      196 
      197 /* File was never locked.
      198*	if file_locked then call iox_$control (iocb_ptr, "set_file_lock", addr (UNLOCK), code);
      199**/
      200 	if metering_sw then do;
      201 		call cpu_time_and_paging_ (pf_2, t2, pf_dummy);
      202 		vrm_meter.last_call_stats.last_time_of_stats = clock;
      203 
      204 		t3 = t2 - t1;
      205 		vrm_meter.last_call_stats.vcpu_time = divide (t3, 1000000, 63);
      206 		vrm_meter.last_call_stats.page_faults = pf_2 - pf_1;
      207 		vrm_meter.last_call_stats.number_times_used = 1;
      208 		vrm_meter.total_stats.last_time_of_stats = 0;
      209 		vrm_meter.total_stats = vrm_meter.total_stats + vrm_meter.last_call_stats;
      210 
      211 	     end;
      212 
      213 
      214      end tidy_up;
      215 
      216 /* * * * * * * * * * * * * *     lock   * * * * * * * * * * * * * * * *  */
      217 
      218 /* since we arent locking... no need for a lock routine.
      219*lock: proc;
      220*
      221*	call iox_$control (iocb_ptr, "set_file_lock", addr (LOCK), lock_err_code);
      222*	if lock_err_code ^= 0 then call error (lock_err_code);
      223*
      224*	file_locked = "1"b;
      225*
      226*	if metering_sw then
      227*	     vrm_meter.last_call_stats.number_times_locked =
      228*		vrm_meter.last_call_stats.number_times_locked + 1;
      229*
      230*
      231*     end lock;
      232*
      233**/
      234 
      235 
      236 
      237 
      238 
      239 /* * * * * * * * * * * * * *     unlock   * * * * * * * * * * * * * * * *  */
      240 
      241 /* Since we arent locking... no need for an unlock routine.
      242*unlock: proc;
      243*
      244*	if file_locked then do;
      245*		call iox_$control (iocb_ptr, "set_file_lock", addr (UNLOCK), lock_err_code);
      246*		if lock_err_code ^= 0 then call error (lock_err_code);
      247*	     end;
      248*
      249*	file_locked = "0"b;
      250*
      251*     end unlock;
      252**/
      253 
      254 
      255 /* External entries */
      256 	dcl     vrmu_cv_tuple_to_vector$simple_vector entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
      257 	dcl     clock		 builtin;
      258 	dcl     cpu_time_and_paging_	 entry (fixed bin, fixed bin (71), fixed bin);
      259 	dcl     divide		 builtin;
      260 	dcl     pf_1		 fixed bin;
      261 	dcl     pf_2		 fixed bin;
      262 	dcl     pf_dummy		 fixed bin;
      263 	dcl     t1		 fixed bin (71);
      264 	dcl     t2		 fixed bin (71);
      265 	dcl     t3		 float bin (63);
      266 	dcl     UNLOCK		 bit (2) aligned int static options (constant) init ("00"b);
      267 	dcl     LOCK		 bit (2) aligned int static options (constant) init ("10"b);
      268 	dcl     cleanup		 condition;
      269 	dcl     file_locked		 bit (1);
      270 	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
      271 	dcl     get_temp_segment_	 entry (char (*), ptr, fixed bin (35));
      272 
      273 /* External static */
      274 	dcl     dm_error_$no_tuple_id	 fixed bin (35) ext static;
      275 	dcl     error_table_$noalloc	 fixed bin (35) ext static;
      276 	dcl     error_table_$no_record fixed bin (35) ext static;
      277 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
      278 
      279 /* Automatic */
      280 	dcl     code		 fixed bin (35);
      281 	dcl     i			 fixed bin (35);
      282 	dcl     iocb_ptr		 ptr;
      283 	dcl     KSQU		 fixed bin int static options (constant) init (10);
      284 	dcl     lock_err_code	 fixed bin (35);
      285 
      286 	dcl     rec_len		 fixed bin (21);
      287 	dcl     rec_ptr		 ptr;
      288 	dcl     vf_desc		 fixed bin (35) aligned;
      289 	dcl     vrmu_cv_vf_desc_to_ptr entry (ptr, fixed bin (35), ptr, fixed bin (21), fixed bin (35));
      290 
      291 
      292 /* Based */
      293 
      294 	dcl     1 tid		 aligned based (tid_ptr), /* MRDS tuple id (tid) */
      295 		2 non_std_desc	 bit (1) unal,	/* Non-standard descriptor bit */
      296 		2 temp		 bit (1) unal,	/* On if temp relation */
      297 		2 file_id		 bit (7) unal,	/* File id from mrds db_model file_id_list */
      298 		2 comp_num	 bit (10) unal,	/* Component number */
      299 		2 offset		 bit (17) unal;	/* Offset within component */
      300 
      301 	dcl     tid_ptr		 pointer;
      302 
      303 
      304 	dcl     1 vfd		 aligned based (vfd_ptr), /* Vfile desc */
      305 		2 pad_1		 bit (8) unal,
      306 		2 comp_number	 bit (10) unal,	/* Component number */
      307 		2 comp_offset	 bit (17) unal,	/* Offset with in component */
      308 		2 pade_2		 bit (1) unal;
      309 
      310 	dcl     vfd_ptr		 pointer;		/* Pointer to vfd structure */
      311 	dcl     metering_sw		 bit (1) aligned;
      312 	dcl     return_area		 area based (I_return_area_ptr);
      313 	dcl     get_work_area	 area (sys_info$max_seg_size) based (vrm_com.get_seg_ptr);
      314 						/* Builtin */
      315 	dcl     (addr, empty, fixed, null, rel) builtin;
      316 
      317 /* Conditions */
      318 	dcl     area		 condition;
      319 
  1     1 /* BEGIN INCLUDE   vrm_cursor.incl.pl1		*/
  1     2 
  1     3 /* 83-05-26 Roger Lackey : Modifyed for relation cursors */
  1     4 
  1     5 dcl  vrm_cursor_ptr pointer;				/* Pointer to this structure */
  1     6 
  1     7 dcl 1 vrm_cursor aligned based (vrm_cursor_ptr),		/* vfile relation manager cursor */
  1     8     2 opening_id bit (36) aligned,			/* ID of opening associated with this cursor */
  1     9     2 debug_sw unal,				/* Undefined MBZ */
  1    10       3 trace_open bit (1) unal,			/* Show opening of iocb cursor creation time */
  1    11       3 pad bit (35) unal,
  1    12     2 switches,
  1    13       3 shared bit (1) unal,				/* Other processes can use this relation */
  1    14       3 meter_sw bit (1) unal,			/* On = Keep meters for this cursor */
  1    15       3 pad bit (7) unal,				/* Unsed */
  1    16     2 opening_mode fixed bin,				/* Opening mode for this cursor (8 = KSQR  10 = KSQU) */
  1    17     2 open_info_ptr pointer,				/* Pointer to parent opening info structure */
  1    18     2 vrm_relation_desc_ptr pointer,			/* Pointer to parent rel desc */
  1    19     2 iocb_ptr pointer,				/* Pointer to attach iocb */
  1    20     2 secondary_iocb_ptr ptr,				/* Second iocb_ptr used by vrmu_search */
  1    21     2 search_list_ptr ptr,				/* Pointer to search_list */
  1    22     2 search_keys_ptr ptr,				/* Pointer to search_keys array */
  1    23     2 meter_ptr pointer,				/* Pointer metering str if metering is on or null */
  1    24     2 vrm_iocb_list_block_ptr pointer,			/* Pointer to vrm_iocb_list_block that contains this cursors iocb */
  1    25     2 vrm_iocb_list_block_iocbs_ix fixed bin;		/* Index into list_block.iocbs for location of iocb */
  1    26 
  1    27 
  1    28 /* END  INCLUDE vrm_cursor.incl.pl1	                  */
      320 
      321 
  2     1 /*   BEGIN INCLUDE   vrm_open_info.incl.pl1		    */
  2     2 
  2     3 /* R. Harvey  82-11-02 
  2     4*   82-09-82 Roger Lackey: added iocb_list_ptr */
  2     5 
  2     6 dcl 1 vrm_open_info aligned based (vrm_open_info_ptr),	/* Vfile relation description */
  2     7     2 version char (8),				/* Version number of this structure */
  2     8     2 opening_id bit (36) aligned,			/* Opening id associated with this desc */
  2     9     2 file_uid bit (36) aligned,			/* Unique id of msf dir */
  2    10     2 number_of_openings fixed bin,			/* Number of separate calls to vrm$open */
  2    11     2 switches,
  2    12       3 shared bit (1) unal,				/* Open relation in shared mode */
  2    13       3 pad bit (35) unal init ("0"b),			/* Unused must be zero */
  2    14     2 database_dir_path char (168) varying,		/* Absolute path of database */
  2    15     2 relation_name char (30) varying,			/* Name of relation */
  2    16     2 relation_model_ptr pointer,			/* Pointer to the relation_model in the relation itself or a temp seg */
  2    17     2 com_ptr pointer,				/* Temp seg for cursors and scratch space */
  2    18     2 iocb_list_ptr pointer,				/* Pointer to first vrm_iocb_list_block */
  2    19     2 primary_key_info_ptr pointer,			/* Special case collection info ptr */
  2    20     2 number_of_index_collections fixed bin,		/* Count of index collections (include primary key) */
  2    21     2 index_collection (voi_no_of_index_collections
  2    22 		   refer (vrm_open_info.number_of_index_collections)),
  2    23       3 id bit (36),
  2    24       3 info_ptr ptr unal;				/* Points to more detailed info */
  2    25 
  2    26 
  2    27 dcl  VRM_OPEN_INFO_VERSION_1 char (8) int static options (constant) init ("       1");
  2    28 dcl  vrm_open_info_ptr ptr;
  2    29 dcl  voi_no_of_index_collections fixed bin;
  2    30 
  2    31 /*   END INCLUDE  vrm_open_info.incl.pl1	   */
      322 
      323 
  3     1 /*   BEGIN INCLUDE  vrm_rel_desc.incl.pl1		   */
  3     2 
  3     3 /* 83-05-26 Roger Lackey : Added vrm_attr_info.key_head bit for relation_cursors */
  3     4 
  3     5 dcl 1 vrm_rel_desc based (vrm_rel_desc_ptr),
  3     6     2 record_id bit (12) unal,			/* Distinguish us from tuples and collection records */
  3     7     2 version char (8),				/* Version of this structure */
  3     8     2 file_id bit (7),				/* Value of file id from model */
  3     9     2 rel_id bit (12),				/* Relation id */
  3    10     2 switches,
  3    11       3 MRDS_compatible bit (1) unal,			/* For pre-relation_manager_ MRDS */
  3    12       3 stationary_records
  3    13      bit (1) unal,					/* On = stationary */
  3    14       3 indexed bit (1) unal,				/* This relation has attributes with secondary indices */
  3    15       3 pad bit (33) unal,
  3    16     2 var_offset fixed bin (35),			/* Position of first varying attr */
  3    17     2 maximum_data_length
  3    18      fixed bin (35),				/* Maximum size of tuple in characters */
  3    19     2 number_primary_key_attrs
  3    20      fixed bin,					/* Number of attributes which make up the primary key */
  3    21     2 number_sec_indexes fixed bin,			/* Number of attributes which have a secondary index */
  3    22     2 last_var_attr_no fixed bin,			/* Attr index of last varying attribute */
  3    23     2 number_var_attrs fixed bin,			/* Number of varying attributes */
  3    24     2 number_attrs fixed bin,				/* Number of attribute in rel */
  3    25     2 attr (vrd_no_of_attrs				/* Description of each attribute */
  3    26      refer (vrm_rel_desc.number_attrs)) aligned like vrm_attr_info;
  3    27 
  3    28 dcl 1 vrm_attr_info based (vrm_attr_info_ptr),
  3    29 						/* Attribute specific info */
  3    30     2 name char (32),				/* Name of the attribute */
  3    31     2 descriptor bit (36) aligned,			/* domain descriptor */
  3    32     2 varying bit (1) unal,				/* ON = This is a varying string */
  3    33     2 key_head bit (1) unal,				/* ON = This attr can be a keyhead */
  3    34     2 primary_key_attr bit (1) unal,			/* ON = This is a primary key attribute */
  3    35     2 pad bit (15) unal,				/* unused */
  3    36     2 index_collextion_ix fixed bin (17) unal,		/* Index into vrm_open_info.index_collection array if key_head is on */
  3    37     2 bit_length fixed bin (35),			/* Maximum bit length of tuple */
  3    38     2 bit_offset fixed bin (35);			/* Offset in tuple if fixed, index to offset in tuple if varying */
  3    39 
  3    40 
  3    41 dcl  vrm_rel_desc_ptr pointer;
  3    42 dcl  vrd_no_of_attrs fixed bin;
  3    43 dcl  VRM_REL_DESC_RECORD_ID bit (12) unal int static options (constant) init ("100000000000"b);
  3    44 dcl  VRM_REL_DESC_VERSION_1 char (8) int static options (constant) init ("       1");
  3    45 dcl  vrm_attr_info_ptr pointer;
  3    46 dcl  VRM_REL_DESC_KEY char (256) varying int static options (constant) init ("@relation_description");
  3    47 
  3    48 /*   END INCLUDE  vrm_rel_desc.incl.pl1		   */
      324 
      325 
  4     1 /*  BEGIN INCLUDE   vrm_com.incl.pl1		 */
  4     2 
  4     3 /*  Written 82-08-23 by R. Harvey		 */
  4     4 
  4     5      dcl	   vrm_com_ptr	      ptr;
  4     6      dcl	   1 vrm_com	      aligned based (vrm_com_ptr),
  4     7 	     2 get_seg_ptr	      ptr,		/* temp seg for retrieve routines */
  4     8 	     2 put_seg_ptr	      ptr,		/* temp seg for store routines */
  4     9 	     2 mod_seg_ptr	      ptr,		/* temp seg for modify routines */
  4    10 	     2 work_area_ptr      ptr,		/* freeing area for oid_table sections and rel_descriptors */
  4    11 	     2 highest_oid	      bit (36) aligned,	/* highest valid oid */
  4    12 	     2 next_free_oid      bit (36) aligned,	/* offset of first in free chain */
  4    13 	     2 first_assigned_oid bit (36) aligned,	/* offset of first in assigned chain */
  4    14 	     2 oid_area	      area (sys_info$max_seg_size - fixed (rel (addr (vrm_com.work_area_ptr))));
  4    15 
  4    16 /*  END INCLUDE    vrm_com.incl.pl1		 */
      326 
      327 
  5     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*          The element_id_list structure contains an array of element 
  5     5*     identifiers.  These identifiers are used as tuple, record or 
  5     6*     element identifiers.  This structure is used across the relation_manager_,
  5     7*     record_manager_ and index_manager_ interfaces.  At some time the 
  5     8*     version should be changed to be char(8)aligned, when such a conversion
  5     9*     can be coordinated with the other structures used at these interfaces.
  5    10**/
  5    11 
  5    12 /* HISTORY:
  5    13*Written by Matthew Pierret, 06/06/82.
  5    14*Modified:
  5    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
  5    16*            Did not change version.
  5    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
  5    18**/
  5    19 
  5    20 /* format: style2,ind3 */
  5    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
  5    22 	     2 version	      fixed bin (35),
  5    23 	     2 number_of_elements fixed bin (35),
  5    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
  5    25 
  5    26      dcl	   element_id_list_ptr    ptr;
  5    27      dcl	   eil_number_of_elements fixed bin (35);
  5    28      dcl	   ELEMENT_ID_LIST_VERSION_1
  5    29 			      init (1) fixed bin (35);
  5    30 
  5    31 
  5    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
      328 
      329 
  6     1 /*  BEGIN INCLUDE	dm_typed_vector_list.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 /* Written by R. Harvey, 09/24/82 
  6     4*Modified:
  6     5*09/27/82 by Matthew Pierret:  Changed "max" to "maximum", tvl_number_of_vectors
  6     6*            to tvl_maximum_number_of_vectors.
  6     7**/
  6     8 
  6     9 /* format: style2,ind3 */
  6    10      dcl	   1 typed_vector_list    aligned based (typed_vector_list_ptr),
  6    11 	     2 version	      fixed bin (17),
  6    12 	     2 maximum_number_of_vectors
  6    13 			      fixed bin (35),	/* vectors available */
  6    14 	     2 number_of_vectors  fixed bin (35),	/* number of vector_ptrs used */
  6    15 	     2 pad	      fixed bin (35),	/* (even word boundary) */
  6    16 	     2 vector_ptr	      (tvl_maximum_number_of_vectors refer (typed_vector_list.maximum_number_of_vectors)) ptr;
  6    17 
  6    18      dcl	   typed_vector_list_ptr  ptr;
  6    19      dcl	   TYPED_VECTOR_LIST_VERSION_1
  6    20 			      fixed bin (17) int static options (constant) init (1);
  6    21      dcl	   tvl_maximum_number_of_vectors  fixed bin (35);
  6    22 
  6    23 /*  END INCLUDE	dm_typed_vector_list.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      330 
      331 
  7     1 /* BEGIN INCLUDE  vrm_meter.incl.pl1      */
  7     2 
  7     3 dcl  vrm_meter_ptr pointer;
  7     4 
  7     5 dcl 1 vrm_meter aligned based (vrm_meter_ptr),
  7     6     2 cursor_name char (32),				/* Name of cursor */
  7     7     2 meter_start_time fixed bin (71),
  7     8     2 switches,
  7     9       3 metering bit (1) unal,			/* On = meter being done */
  7    10       3 mbz bit (35) unal,
  7    11     2 cursor_ptr ptr,				/* Pointer to vrm_cursor structure */
  7    12     2 last_call_stats like statistics,
  7    13     2 total_stats like statistics;
  7    14 
  7    15 dcl 1 statistics based,				/* Used in like above */
  7    16     2 last_time_of_stats fixed bin (71),		/* Last clock value for stats taken */
  7    17     2 vcpu_time float bin (63),			/* The vcpu for this cursor */
  7    18     2 page_faults fixed bin (70),			/* Page faults for this cursor */
  7    19     2 number_times_locked fixed bin (70),		/* Number of time a lock was set */
  7    20     2 number_times_used fixed bin (70),			/* Number of time cursor was used */
  7    21     2 num_times_search_called fixed bin (70),		/* Number of time vrm_search was called */
  7    22     2 records_searched fixed bin (70),			/* The records searched */
  7    23     2 seek_heads fixed bin (70),			/* The seek heads done for key searches */
  7    24     2 special_seek_heads fixed bin (70),		/* The seek heads done for key searches */
  7    25     2 keys_read fixed bin (70),			/* The keys read by key search */
  7    26     2 keys_compared fixed bin (70),			/* The keys compared in key search */
  7    27     2 key_hits fixed bin (70),			/* The key hits for key search */
  7    28     2 non_key_compares fixed bin (70),			/* The non_key compares done for this cursor */
  7    29     2 non_key_hits fixed bin (70),			/* The non_key hits for this cursor */
  7    30     2 upper_limit_found_count fixed bin (70),		/* The number of times upper limit was exceeded */
  7    31     2 number_items_returned fixed bin (70),		/* Number of tuples or tid returned */
  7    32     2 number_tuples_deleted fixed bin (70),		/* Number of tuples deleted */
  7    33     2 number_tuples_modified fixed bin (70),		/* Number of tuples modified */
  7    34     2 number_tuples_stored fixed bin (70);		/* Number of tuples stored */
  7    35 
  7    36 /* END INCLUDE  vrm_meter.incl.pl1      */
      332 
      333 
      334      end get_tuple_by_id;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1156.0  vrm_get_by_id.pl1                 >udd>sm>ds>w>ml>vrm_get_by_id.pl1
320          1    10/14/83  1709.1  vrm_cursor.incl.pl1               >ldd>incl>vrm_cursor.incl.pl1
322          2    10/14/83  1709.1  vrm_open_info.incl.pl1            >ldd>incl>vrm_open_info.incl.pl1
324          3    10/14/83  1709.1  vrm_rel_desc.incl.pl1             >ldd>incl>vrm_rel_desc.incl.pl1
326          4    10/14/83  1709.1  vrm_com.incl.pl1                  >ldd>incl>vrm_com.incl.pl1
328          5    03/06/85  1131.5  dm_element_id_list.incl.pl1       >ldd>incl>dm_element_id_list.incl.pl1
330          6    10/14/83  1709.1  dm_typed_vector_list.incl.pl1     >ldd>incl>dm_typed_vector_list.incl.pl1
332          7    10/14/83  1709.1  vrm_meter.incl.pl1                >ldd>incl>vrm_meter.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ELEMENT_ID_LIST_VERSION_1       000162 automatic       fixed bin(35,0)          initial dcl 5-28 set ref 5-28*
I_element_id                           parameter       bit(36)                  dcl 31 set ref 7 47*
I_element_id_list_ptr                  parameter       pointer                  dcl 71 ref 67 88
I_id_list_ptr                          parameter       pointer                  dcl 32 set ref 7 47* 67 103*
I_relation_cursor_ptr                  parameter       pointer                  dcl 30 ref 7 41 67 90
I_return_area_ptr                      parameter       pointer                  dcl 33 set ref 7 67 95 165*
O_code                                 parameter       fixed bin(35,0)          dcl 35 set ref 7 38* 50* 67 81* 108* 183* 185*
O_simple_typed_vector_list_ptr         parameter       pointer                  dcl 76 set ref 67 80* 96*
O_simple_typed_vector_ptr              parameter       pointer                  dcl 34 set ref 7 47*
TYPED_VECTOR_LIST_VERSION_1            constant        fixed bin(17,0)          initial dcl 6-19 ref 97
addr                                                   builtin function         dcl 315 ref 150 151
area                            000142 stack reference condition                dcl 318 ref 86
cleanup                         000112 stack reference condition                dcl 268 ref 43 84
clock                                                  builtin function         dcl 257 ref 54 202
code                            000121 automatic       fixed bin(35,0)          dcl 280 set ref 47* 48 48* 103* 104 104* 129* 130
                                                                                  130*
com_ptr                  74            based           pointer                  level 2 dcl 2-6 ref 127
comp_num                  0(09)        based           bit(10)                  level 2 packed packed unaligned dcl 294 ref 153
comp_number               0(08)        based           bit(10)                  level 2 packed packed unaligned dcl 304 set ref 153*
comp_offset               0(18)        based           bit(17)                  level 2 packed packed unaligned dcl 304 set ref 154*
cpu_time_and_paging_            000012 constant        entry                    external dcl 258 ref 53 118 201
divide                                                 builtin function         dcl 259 ref 57 205
dm_error_$no_tuple_id           000016 external static fixed bin(35,0)          dcl 274 ref 183
ecode                                  parameter       fixed bin(35,0)          dcl 181 ref 179 183 185
element_id_list                        based           structure                level 1 dcl 5-21
element_id_list_ptr             000160 automatic       pointer                  dcl 5-26 set ref 88* 94 100 103
empty                                                  builtin function         dcl 315 ref 131
error_table_$no_record          000022 external static fixed bin(35,0)          dcl 276 ref 183
error_table_$noalloc            000020 external static fixed bin(35,0)          dcl 275 set ref 86*
file_locked                     000120 automatic       bit(1)                   packed unaligned dcl 269 set ref 39* 82*
get_seg_ptr                            based           pointer                  level 2 dcl 4-6 set ref 128 129* 131
get_temp_segment_               000014 constant        entry                    external dcl 271 ref 129
get_work_area                          based           area                     dcl 313 set ref 131*
i                               000122 automatic       fixed bin(35,0)          dcl 281 set ref 100* 102 103 103 105*
id                        2            based           bit(36)                  array level 2 dcl 5-21 set ref 103*
id_list_ptr                            parameter       pointer                  dcl 145 set ref 141 165*
iocb_ptr                 10            based           pointer                  level 2 in structure "vrm_cursor" dcl 1-7
                                                                                  in procedure "get_tuple_by_id" ref 137
iocb_ptr                        000124 automatic       pointer                  dcl 282 in procedure "get_tuple_by_id" set ref 137*
                                                                                  162*
last_call_stats          16            based           structure                level 2 dcl 7-5 set ref 61 120* 209
last_time_of_stats       64            based           fixed bin(71,0)          level 3 in structure "vrm_meter" dcl 7-5
                                                                                  in procedure "get_tuple_by_id" set ref 60* 208*
last_time_of_stats       16            based           fixed bin(71,0)          level 3 in structure "vrm_meter" dcl 7-5
                                                                                  in procedure "get_tuple_by_id" set ref 54* 202*
maximum_number_of_vectors
                          1            based           fixed bin(35,0)          level 2 dcl 6-10 set ref 95*
meter_ptr                20            based           pointer                  level 2 dcl 1-7 ref 119
meter_sw                  2(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1-7 ref 116
metering_sw                     000140 automatic       bit(1)                   dcl 311 set ref 52 121* 124* 167 200
null                                                   builtin function         dcl 315 ref 80 102 128
number_items_returned
                         54            based           fixed bin(70,0)          level 3 dcl 7-5 set ref 167* 167
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 5-21 ref 94 100
number_of_vectors         2            based           fixed bin(35,0)          level 2 dcl 6-10 set ref 98* 105*
number_times_used        26            based           fixed bin(70,0)          level 3 dcl 7-5 set ref 59* 207*
offset                    0(19)        based           bit(17)                  level 2 packed packed unaligned dcl 294 ref 154
open_info_ptr             4            based           pointer                  level 2 dcl 1-7 ref 126
page_faults              22            based           fixed bin(70,0)          level 3 dcl 7-5 set ref 58* 206*
pcode                                  parameter       fixed bin(35,0)          dcl 146 set ref 141 162* 163 165*
pf_1                            000100 automatic       fixed bin(17,0)          dcl 260 set ref 58 118* 206
pf_2                            000101 automatic       fixed bin(17,0)          dcl 261 set ref 53* 58 201* 206
pf_dummy                        000102 automatic       fixed bin(17,0)          dcl 262 set ref 53* 118* 201*
rec_len                         000126 automatic       fixed bin(21,0)          dcl 286 set ref 162*
rec_ptr                         000130 automatic       pointer                  dcl 287 set ref 162* 165*
return_area                            based           area(1024)               dcl 312 ref 95
shared                    5            based           bit(1)                   level 3 in structure "vrm_open_info" packed packed
                                                                                  unaligned dcl 2-6 in procedure "get_tuple_by_id"
                                                                                  ref 134
shared                    2            based           bit(1)                   level 3 in structure "vrm_cursor" packed packed
                                                                                  unaligned dcl 1-7 in procedure "get_tuple_by_id"
                                                                                  set ref 134*
simple_typed_vector_ptr                parameter       pointer                  dcl 144 set ref 141 165*
statistics                             based           structure                level 1 unaligned dcl 7-15
switches                  5            based           structure                level 2 in structure "vrm_open_info" dcl 2-6
                                                                                  in procedure "get_tuple_by_id"
switches                  2            based           structure                level 2 in structure "vrm_cursor" dcl 1-7
                                                                                  in procedure "get_tuple_by_id"
sys_info$max_seg_size           000024 external static fixed bin(35,0)          dcl 277 ref 131
t1                              000104 automatic       fixed bin(71,0)          dcl 263 set ref 56 118* 204
t2                              000106 automatic       fixed bin(71,0)          dcl 264 set ref 53* 56 201* 204
t3                              000110 automatic       float bin(63)            dcl 265 set ref 56* 57 204* 205
tid                                    based           structure                level 1 dcl 294
tid_ptr                         000134 automatic       pointer                  dcl 301 set ref 150* 153 154
total_stats              64            based           structure                level 2 dcl 7-5 set ref 61* 61 209* 209
tuple_id                               parameter       bit(36)                  dcl 143 set ref 141 150
tvl_maximum_number_of_vectors   000166 automatic       fixed bin(35,0)          dcl 6-21 set ref 94* 95 95
typed_vector_list                      based           structure                level 1 dcl 6-10 set ref 95
typed_vector_list_ptr           000164 automatic       pointer                  dcl 6-18 set ref 95* 96 97 98 102 103 105
vcpu_time                20            based           float bin(63)            level 3 dcl 7-5 set ref 57* 205*
vector_ptr                4            based           pointer                  array level 2 dcl 6-10 set ref 102* 103*
version                                based           fixed bin(17,0)          level 2 dcl 6-10 set ref 97*
vf_desc                         000132 automatic       fixed bin(35,0)          dcl 288 set ref 149* 151 162*
vfd                                    based           structure                level 1 dcl 304
vfd_ptr                         000136 automatic       pointer                  dcl 310 set ref 151* 153 154
vrm_attr_info                          based           structure                level 1 unaligned dcl 3-28
vrm_com                                based           structure                level 1 dcl 4-6
vrm_com_ptr                     000156 automatic       pointer                  dcl 4-5 set ref 127* 128 129 131
vrm_cursor                             based           structure                level 1 dcl 1-7
vrm_cursor_ptr                  000150 automatic       pointer                  dcl 1-5 set ref 41* 90* 116 119 126 134 137 164
vrm_meter                              based           structure                level 1 dcl 7-5
vrm_meter_ptr                   000170 automatic       pointer                  dcl 7-3 set ref 54 57 58 59 60 61 61 61 119* 120 167
                                                                                  167 202 205 206 207 208 209 209 209
vrm_open_info                          based           structure                level 1 dcl 2-6
vrm_open_info_ptr               000152 automatic       pointer                  dcl 2-28 set ref 126* 127 134
vrm_rel_desc_ptr                000154 automatic       pointer                  dcl 3-41 set ref 164* 165*
vrm_relation_desc_ptr
                          6            based           pointer                  level 2 dcl 1-7 ref 164
vrmu_cv_tuple_to_vector$simple_vector
                                000010 constant        entry                    external dcl 256 ref 165
vrmu_cv_vf_desc_to_ptr          000026 constant        entry                    external dcl 289 ref 162

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
KSQU                                   internal static fixed bin(17,0)          initial dcl 283
LOCK                                   internal static bit(2)                   initial dcl 267
UNLOCK                                 internal static bit(2)                   initial dcl 266
VRM_OPEN_INFO_VERSION_1                internal static char(8)                  initial packed unaligned dcl 2-27
VRM_REL_DESC_KEY                       internal static varying char(256)        initial dcl 3-46
VRM_REL_DESC_RECORD_ID                 internal static bit(12)                  initial packed unaligned dcl 3-43
VRM_REL_DESC_VERSION_1                 internal static char(8)                  initial packed unaligned dcl 3-44
eil_number_of_elements                 automatic       fixed bin(35,0)          dcl 5-27
fixed                                                  builtin function         dcl 315
iox_$control                    000000 constant        entry                    external dcl 270
lock_err_code                          automatic       fixed bin(35,0)          dcl 284
rel                                                    builtin function         dcl 315
voi_no_of_index_collections            automatic       fixed bin(17,0)          dcl 2-29
vrd_no_of_attrs                        automatic       fixed bin(17,0)          dcl 3-42
vrm_attr_info_ptr                      automatic       pointer                  dcl 3-45
vrm_rel_desc                           based           structure                level 1 unaligned dcl 3-5

NAMES DECLARED BY EXPLICIT CONTEXT.
Exit                            000254 constant        label                    dcl 65 ref 188
error                           000722 constant        entry                    internal dcl 179 ref 48 86 104 130
get_tuple_by_id                 000035 constant        entry                    external dcl 7
get_tuples_by_id                000263 constant        entry                    external dcl 67
init_get                        000462 constant        entry                    internal dcl 114 ref 45 92
process_one_tuple_id            000621 constant        entry                    internal dcl 141 ref 47 103
tidy_up                         000754 constant        entry                    internal dcl 195 ref 43 84 109 187

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1322        1352    1114        1332
Length      1672    1114        30         303     205           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_tuple_by_id                     200 external procedure  is an external procedure.  
on unit on line 43                   64 on unit               
on unit on line 84                   64 on unit               
on unit on line 86                   70 on unit               
init_get                                internal procedure  shares stack frame of external procedure get_tuple_by_id.  
process_one_tuple_id                    internal procedure  shares stack frame of external procedure get_tuple_by_id.  
error                                64 internal procedure  is called by several nonquick procedures.  
tidy_up                              72 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get_tuple_by_id          000100 pf_1                        get_tuple_by_id
                         000101 pf_2                        get_tuple_by_id
                         000102 pf_dummy                    get_tuple_by_id
                         000104 t1                          get_tuple_by_id
                         000106 t2                          get_tuple_by_id
                         000110 t3                          get_tuple_by_id
                         000120 file_locked                 get_tuple_by_id
                         000121 code                        get_tuple_by_id
                         000122 i                           get_tuple_by_id
                         000124 iocb_ptr                    get_tuple_by_id
                         000126 rec_len                     get_tuple_by_id
                         000130 rec_ptr                     get_tuple_by_id
                         000132 vf_desc                     get_tuple_by_id
                         000134 tid_ptr                     get_tuple_by_id
                         000136 vfd_ptr                     get_tuple_by_id
                         000140 metering_sw                 get_tuple_by_id
                         000150 vrm_cursor_ptr              get_tuple_by_id
                         000152 vrm_open_info_ptr           get_tuple_by_id
                         000154 vrm_rel_desc_ptr            get_tuple_by_id
                         000156 vrm_com_ptr                 get_tuple_by_id
                         000160 element_id_list_ptr         get_tuple_by_id
                         000162 ELEMENT_ID_LIST_VERSION_1   get_tuple_by_id
                         000164 typed_vector_list_ptr       get_tuple_by_id
                         000166 tvl_maximum_number_of_vectors
                                                            get_tuple_by_id
                         000170 vrm_meter_ptr               get_tuple_by_id

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          tra_ext_1
enable_op           ext_entry           int_entry           op_alloc_           op_empty_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cpu_time_and_paging_          get_temp_segment_             vrmu_cv_tuple_to_vector$simple_vector
vrmu_cv_vf_desc_to_ptr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$no_tuple_id         error_table_$no_record        error_table_$noalloc          sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 5   28 000023         7 000027        38 000043        39 000045        41 000046        43 000051        45 000073
     47 000074        48 000111        50 000121        52 000123        53 000125        54 000140        56 000143
     57 000150        58 000153        59 000160        60 000162        61 000164        65 000254        67 000255
     80 000271        81 000274        82 000275        84 000276        86 000320        88 000344        90 000350
     92 000353        94 000354        95 000357        96 000372        97 000374        98 000376       100 000377
    102 000407       103 000414       104 000433       105 000443       106 000446       108 000453       109 000455
    111 000461       114 000462       116 000463       118 000467       119 000502       120 000505       121 000533
    122 000535       124 000536       126 000537       127 000542       128 000544       129 000550       130 000573
    131 000603       134 000610       137 000616       139 000620       141 000621       149 000623       150 000624
    151 000626       153 000630       154 000635       162 000642       163 000662       164 000665       165 000670
    167 000712       175 000720       179 000721       183 000727       185 000740       187 000743       188 000750
    195 000753       200 000761       201 000764       202 000776       204 001002       205 001007       206 001012
    207 001017       208 001021       209 001023       214 001113


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
