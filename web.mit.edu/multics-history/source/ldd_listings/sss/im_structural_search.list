	COMPILATION LISTING OF SEGMENT im_structural_search
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/02/86  1217.7 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*         This   subroutine  searches  an  index  under  the  control  of  the
       11*     structural_specification (produced  by  im_build_structural_spec).    The
       12*     basic  algorithm  is  to  loop over the intervals in the structural spec,
       13*     invoking im_search_ on the high and low ends of each interval.
       14**/
       15 
       16 /* HISTORY:
       17*
       18*Written by Lindsey L. Spratt, 06/17/82.
       19*Modified:
       20*08/26/82 by Lindsey Spratt:  Added "relative" searching, based on the current
       21*	  value of the cursor.  Extended the im_basic_search calling
       22*	  sequence to take the p_is_relative_search flag and a
       23*	  "position_stack" which it fills in if it calculates the location
       24*	  of the cursor.
       25*10/07/82 by Lindsey Spratt:  Changed to use the interval_specification.
       26*10/26/82 by Lindsey Spratt:  Changed to check for matches being found within
       27*	  each interval.  If no match is found for any interval then
       28*	  p_no_match is set on.  Intervals in which no match was found have
       29*	  their id_strings set to "0"b.
       30*10/27/82 by Lindsey Spratt:  Changed to use a "number of partial duplication
       31*	  fields" of simple_typed_vector.number_of_dimensions + 1.
       32*11/04/82 by Lindsey Spratt:  Fixed bug where ranges were always returning "not
       33*	  found".  
       34*02/25/83 by Lindsey Spratt:  Changed to take p_index_opening_info_ptr as an
       35*	  input parameter.  Changed to call im_basic_search with
       36*	  index_opening_info_ptr instead of field_table_ptr and root_id
       37*	  values.  Changed to use version 3 index_cursor.  Changed the
       38*	  calling sequence of this module to have p_index_opening_info_otr
       39*	  instead of p_root_node_id and p_field_table_ptr.
       40*03/24/83 by Lindsey Spratt:   Changed to use version 2 of the field_table.
       41*	  Uppercased all of the internal proc names.
       42*04/10/83 by Lindsey L. Spratt:  Fixed to check the validity of a range where
       43*            values for both the low and high ends have been found by (among
       44*            other things) looking to see if the "high" key is in the previous
       45*            CI of the CI holding the "low" key.  This indicates that no keys
       46*            satisfied the range, if true.
       47*           Added error analysis and reporting to the RANGE case.
       48*05/04/84 by Matthew Pierret:  Changed to use FIELD_TABLE_VERSION_3, added
       49*            undeclared builtins, and changed to use dm_error_$bad_vector_type
       50*            instead of $wrong_vector_type.
       51*06/07/84 by Matthew Pierret:  Re-named cm_$get_element to cm_$get.
       52*10/28/84 by Lindsey L. Spratt:  Changed to use version 2 index_opening_info.
       53*            Changed to use ERROR_RETURN.
       54*03/01/85 by Matthew C. Pierret:  Changed to always check if the low_id_string
       55*            is "greater" than the high_id_string if both are non-zero.
       56*            Previously it was thought that this case could only occur in an
       57*            equals-only search.  but it can happen in a range search also.
       58*03/07/85 by R. Michael Tague:  Changed opening info version to version 3.
       59*03/12/85 by Lindsey Spratt:  Fixed RANGE portion of algorithm to only do the
       60*	  low_id_string/high_id_string check if there is a non-null
       61*	  low.value_ptr (i.e., there is an explicit low end of the range).
       62*03/30/85 by Lindsey Spratt: Fixed RANGE searches to always honor the equal
       63*	  portions of the constraint.  When only one of the two ends of the
       64*	  range is explicitly given in a RANGE, and there are one or more
       65*	  equal fields (preceding the RANGE field), then the other end of
       66*	  the range must be searched for explicitly to be the most distant
       67*	  keys from the specified end which still meet the equality
       68*	  contraints.
       69**/
       70 /* format: style2,ind3 */
       71 
       72 /* format: style2,ind3 */
       73 
       74 im_structural_search:
       75    proc (p_index_opening_info_ptr, p_index_cursor_ptr, p_is_relative_search, p_interval_specification_ptr, p_no_match,
       76         p_code);
       77 
       78 
       79 /* START OF DECLARATIONS */
       80 /* Parameter */
       81 
       82       dcl	    p_index_opening_info_ptr
       83 			       ptr parameter;
       84       dcl	    p_index_cursor_ptr     ptr parameter;
       85       dcl	    p_is_relative_search   bit (1) aligned parameter;
       86       dcl	    p_interval_specification_ptr
       87 			       ptr parameter;
       88       dcl	    p_no_match	       bit (1) aligned parameter;
       89       dcl	    p_code	       fixed bin (35) parameter;
       90 
       91 /* Automatic */
       92 
       93       dcl	    found_key	       bit (1) aligned init ("0"b);
       94       dcl	    1 local_leaf_ci_header like leaf_ci_header;
       95       dcl	    1 position_stack       aligned,
       96 	      2 depth	       fixed bin (17),
       97 	      2 id_string	       (10) bit (36) aligned;
       98 
       99       dcl	    interval_idx	       fixed bin;
      100 
      101 /* Based */
      102 /* Builtin */
      103 
      104       dcl	    (addr, length, null, unspec)
      105 			       builtin;
      106 
      107 /* Controlled */
      108 /* Constant */
      109 
      110       dcl	    myname	       init ("im_structural_search") char (32) varying internal static options (constant);
      111       dcl	    (WANT_EQUAL, WANT_GREATER, WANT_LESS)
      112 			       init ("1"b) bit (1) aligned options (constant) internal static;
      113 
      114       dcl	    WANT_KEY_LESS_THAN_VECTOR
      115 			       init ("1"b) bit (1) aligned internal static options (constant);
      116 
      117 /* Entry */
      118 
      119       dcl	    sub_err_	       entry () options (variable);
      120       dcl	    im_basic_search	       entry (ptr, ptr, bit (1) aligned, ptr, bit (1) aligned, bit (1) aligned,
      121 			       bit (1) aligned, ptr, bit (36) aligned, ptr, fixed bin (35));
      122 
      123 /* External */
      124 
      125       dcl	    (
      126 	    dm_error_$wrong_cursor_type,
      127 	    dm_error_$programming_error,
      128 	    dm_error_$bad_first_key_idx,
      129 	    dm_error_$bad_last_key_idx,
      130 	    dm_error_$bad_leaf_node,
      131 	    dm_error_$bad_vector_type,
      132 	    error_table_$unimplemented_version
      133 	    )		       fixed bin (35) ext;
      134 
      135 /* END OF DECLARATIONS */
      136 
      137       index_opening_info_ptr = p_index_opening_info_ptr;
      138       call CHECK_VERSION_CHAR (index_opening_info.version, INDEX_OPENING_INFO_VERSION_3, "index_opening_info");
      139 
      140       index_cursor_ptr = p_index_cursor_ptr;
      141       if index_cursor.type ^= INDEX_CURSOR_TYPE
      142       then call sub_err_ (dm_error_$wrong_cursor_type, myname, ACTION_CANT_RESTART, null, 0,
      143 	      "^/Expected an ""index"" type cursor (type ^d).  Received a cursor of type ^d.", INDEX_CURSOR_TYPE,
      144 	      index_cursor.type);
      145       call CHECK_VERSION ((index_cursor.version), (INDEX_CURSOR_VERSION_3), "index_cursor");
      146 
      147       field_table_ptr = index_opening_info.field_table_ptr;
      148       call CHECK_VERSION_CHAR (field_table.version, FIELD_TABLE_VERSION_3, "field_table");
      149 
      150       interval_specification_ptr = p_interval_specification_ptr;
      151       call CHECK_VERSION_CHAR (interval_specification.version, INTERVAL_SPECIFICATION_VERSION_2, "interval_specification")
      152 	 ;
      153 
      154       p_code = 0;
      155 
      156       position_stack.depth = 0;
      157       interval_bead_ptr = interval_specification.first_interval_bead_ptr;
      158 
      159       p_no_match = "1"b;
      160 
      161 INTERVAL_LOOP:
      162       do interval_idx = 1 to interval_specification.number_of_intervals;
      163          simple_typed_vector_ptr = interval_bead.simple_typed_vector_ptr;
      164 
      165          if simple_typed_vector.type ^= SIMPLE_TYPED_VECTOR_TYPE
      166          then call sub_err_ (dm_error_$bad_vector_type, myname, ACTION_CANT_RESTART, null, 0,
      167 	         "^/Expecting a simple_typed_vector, type ^d, 
      168 but received a type ^d structure.", SIMPLE_TYPED_VECTOR_TYPE, simple_typed_vector.type);
      169 
      170          found_key = "0"b;
      171          if interval_bead.low.value_ptr = interval_bead.high.value_ptr
      172 	    & simple_typed_vector.number_of_dimensions = field_table.number_of_fields
      173          then
      174 EXACT_MATCH:
      175 	  do;
      176 	     simple_typed_vector.dimension (simple_typed_vector.number_of_dimensions).value_ptr =
      177 		interval_bead.low.value_ptr;
      178 
      179 	     call im_basic_search (index_opening_info_ptr, p_index_cursor_ptr, p_is_relative_search,
      180 		addr (position_stack), WANT_EQUAL, "0"b, "0"b, simple_typed_vector_ptr, interval_bead.low.id_string,
      181 		null, p_code);
      182 	     if p_code ^= 0
      183 	     then call ERROR_RETURN (p_code);
      184 	     interval_bead.high.id_string = interval_bead.low.id_string;
      185 	     found_key = (interval_bead.low.id_string ^= "0"b);
      186 
      187 	  end EXACT_MATCH;
      188          else
      189 RANGE:
      190 	  do;
      191 	     if interval_bead.low.value_ptr ^= null
      192 	     then
      193 	        do;
      194 		 simple_typed_vector.dimension (simple_typed_vector.number_of_dimensions).value_ptr =
      195 		      interval_bead.low.value_ptr;
      196 
      197 		 call im_basic_search (index_opening_info_ptr, p_index_cursor_ptr, p_is_relative_search,
      198 		      addr (position_stack), (USES_EQUAL_OPERATOR (interval_bead.low.operator_code)),
      199 		      (USES_GREATER_OPERATOR (interval_bead.low.operator_code)), "0"b, simple_typed_vector_ptr,
      200 		      interval_bead.low.id_string, null, p_code);
      201 		 if p_code ^= 0
      202 		 then call ERROR_RETURN (p_code);
      203 		 found_key = (interval_bead.low.id_string ^= "0"b);
      204 	        end;
      205 	     else if simple_typed_vector.number_of_dimensions > 1
      206 	     then
      207 	        do;				/* There are one or more fields constrained to be equal,  All of the keys
      208*found must be greater than or equal to the key-head consisting of only 
      209*these equal fields.
      210**/
      211 		 simple_typed_vector.number_of_dimensions = simple_typed_vector.number_of_dimensions - 1;
      212 						/* Hide the Range Field from basic search. */
      213 		 call im_basic_search (index_opening_info_ptr, p_index_cursor_ptr, p_is_relative_search,
      214 		      addr (position_stack), WANT_EQUAL, WANT_GREATER, "0"b, simple_typed_vector_ptr,
      215 		      interval_bead.low.id_string, null, p_code);
      216 		 if p_code ^= 0
      217 		 then call ERROR_RETURN (p_code);
      218 		 simple_typed_vector.number_of_dimensions = simple_typed_vector.number_of_dimensions + 1;
      219 						/* Put it back the way it's supposed to be. */
      220 		 found_key = (interval_bead.low.id_string ^= "0"b);
      221 	        end;
      222 
      223 	     if (interval_bead.high.value_ptr ^= null | simple_typed_vector.number_of_dimensions > 1)
      224 		& (interval_bead.low.value_ptr = null | found_key)
      225 	     then
      226 	        do;
      227 		 if interval_bead.high.value_ptr ^= null ()
      228 		 then
      229 		    do;
      230 		       simple_typed_vector.dimension (simple_typed_vector.number_of_dimensions).value_ptr =
      231 			  interval_bead.high.value_ptr;
      232 
      233 		       call im_basic_search (index_opening_info_ptr, p_index_cursor_ptr, p_is_relative_search,
      234 			  addr (position_stack), (LESS_OR_EQUAL_OPERATOR_CODE = interval_bead.high.operator_code),
      235 			  "0"b, WANT_KEY_LESS_THAN_VECTOR, simple_typed_vector_ptr, interval_bead.high.id_string,
      236 			  null, p_code);
      237 		       if p_code ^= 0
      238 		       then call ERROR_RETURN (p_code);
      239 		    end;
      240 		 else
      241 		    do;				/* This case is for when there is one or more "equal" fields, the highest key 
      242*in this range must still be less than or equal to the equal fields key-head.
      243**/
      244 		       simple_typed_vector.number_of_dimensions = simple_typed_vector.number_of_dimensions - 1;
      245 						/* Hide the Range Field from basic search. */
      246 		       call im_basic_search (index_opening_info_ptr, p_index_cursor_ptr, p_is_relative_search,
      247 			  addr (position_stack), WANT_EQUAL, "0"b, WANT_LESS, simple_typed_vector_ptr,
      248 			  interval_bead.high.id_string, null, p_code);
      249 		       if p_code ^= 0
      250 		       then call ERROR_RETURN (p_code);
      251 		       simple_typed_vector.number_of_dimensions = simple_typed_vector.number_of_dimensions + 1;
      252 						/* Put it back the way it's supposed to be. */
      253 		    end;
      254 		 if interval_bead.high.id_string = "0"b
      255 		 then found_key = "0"b;
      256 		 else if interval_bead.low.value_ptr = null ()
      257 		 then found_key = "1"b;
      258 
      259 /* For special search situations, it is possible for the "high" search to
      260*return a key which is one below the key returned by the "low" search.  This
      261*indicates that there are no keys which satisfy the range specification.
      262*This situation is easy to check for when the keys are in the same CI.  When
      263*they are in different CIs, it is necessary to get the CI header for the "low"
      264*key.  Then, if the "low" key is the first key in its CI, it is possible that
      265*the "high" key is the last key in the "low" key CI's preceding CI (indicating
      266*that no keys in the index satisfy the range request).
      267**/
      268 
      269 		 else if addr (interval_bead.low.id_string) -> element_id.control_interval_id
      270 		      = addr (interval_bead.high.id_string) -> element_id.control_interval_id
      271 		 then
      272 		    do;
      273 		       found_key =
      274 			  (addr (interval_bead.low.id_string) -> element_id.index
      275 			  <= addr (interval_bead.high.id_string) -> element_id.index);
      276 		       if ^found_key
      277 		       then if (addr (interval_bead.low.id_string) -> element_id.index - 1
      278 			       ^= addr (interval_bead.high.id_string) -> element_id.index)
      279 			  then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
      280 				  "^/A range search failed with the ""low"" key more than one slot greater than
      281 the ""high"" key.  They are in control interval ^d, slots ^d and ^d
      282 respectively. The ""low"" key and the ""high"" key may only be in reverse
      283 order if they are consecutive.", addr (interval_bead.low.id_string) -> element_id.control_interval_id,
      284 				  addr (interval_bead.low.id_string) -> element_id.index,
      285 				  addr (interval_bead.high.id_string) -> element_id.index);
      286 		    end;
      287 		 else
      288 		    do;
      289 		       call GET_CI_HEADER ((addr (interval_bead.low.id_string) -> element_id.control_interval_id),
      290 			  addr (local_leaf_ci_header));
      291 		       found_key =
      292 			  (local_leaf_ci_header.common.previous_id
      293 			  ^= addr (interval_bead.high.id_string) -> element_id.control_interval_id);
      294 		       if ^found_key
      295 		       then if addr (interval_bead.low.id_string) -> element_id.index
      296 			       ^= local_leaf_ci_header.common.key_range.first
      297 			  then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
      298 				  "^a (^d)^/^a (^d), ^a^/^a ^d ^a (^d). ^a^/^a",
      299 				  "^/A range search failed with the ""low"" key in the control interval",
      300 				  addr (interval_bead.low.id_string) -> element_id.control_interval_id,
      301 				  "following the ""high"" key's control interval",
      302 				  addr (interval_bead.high.id_string) -> element_id.control_interval_id,
      303 				  "but the ""low"" key was", "in slot",
      304 				  addr (interval_bead.low.id_string) -> element_id.index,
      305 				  "instead of the first key slot", local_leaf_ci_header.common.key_range.first,
      306 				  "The ""low"" key and the",
      307 				  """high"" key may only be in reverse order if they are consecutive.");
      308 			  else
      309 			     do;
      310 			        call GET_CI_HEADER
      311 				   ((addr (interval_bead.high.id_string) -> element_id.control_interval_id),
      312 				   addr (local_leaf_ci_header));
      313 			        if local_leaf_ci_header.common.key_range.last
      314 				   ^= addr (interval_bead.high.id_string) -> element_id.index
      315 			        then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null,
      316 				        0, "^a (^d)^/^a (^d), ^a^/^a ^d ^a (^d). ^a^/^a",
      317 				        "^/A range search failed with the ""low"" key in the control interval",
      318 				        addr (interval_bead.low.id_string) -> element_id.control_interval_id,
      319 				        "following the ""high"" key's control interval",
      320 				        addr (interval_bead.high.id_string) -> element_id.control_interval_id,
      321 				        "but the ""high"" key was", "in slot",
      322 				        addr (interval_bead.high.id_string) -> element_id.index,
      323 				        "instead of the last key slot",
      324 				        local_leaf_ci_header.common.key_range.last, "The ""low"" key and the",
      325 				        """high"" key may only be in reverse order if they are consecutive.");
      326 			     end;
      327 		    end;
      328 	        end;
      329 	  end RANGE;
      330 
      331          if ^found_key
      332          then interval_bead.low.id_string, interval_bead.high.id_string = "0"b;
      333          p_no_match = p_no_match & ^found_key;
      334          interval_bead_ptr = interval_bead.next;
      335 
      336       end INTERVAL_LOOP;
      337 MAIN_RETURN:
      338       return;
      339 
      340 
      341 ERROR_RETURN:
      342    proc (er_p_code);
      343       dcl	    er_p_code	       fixed bin (35) parameter;
      344       p_code = er_p_code;
      345       goto MAIN_RETURN;
      346    end ERROR_RETURN;
      347 
      348 CHECK_VERSION:
      349    proc (p_received_version, p_expected_version, p_structure_name);
      350       dcl	    p_received_version     fixed bin (35);
      351       dcl	    p_expected_version     fixed bin (35);
      352       dcl	    p_structure_name       char (*);
      353 
      354       if p_received_version ^= p_expected_version
      355       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      356 	      "^/Expected version ^d of the ^a structure.
      357 Received version ^d instead.", p_expected_version, p_structure_name, p_received_version);
      358 
      359    end CHECK_VERSION;
      360 
      361 CHECK_VERSION_CHAR:
      362    proc (p_expected_version, p_received_version, p_structure_name);
      363 
      364       dcl	    (p_expected_version, p_received_version)
      365 			       char (8) aligned;
      366       dcl	    p_structure_name       char (*) parameter;
      367 
      368       if p_expected_version ^= p_received_version
      369       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      370 	      "^/Expected version ^a of the ^a structure.  
      371 Received version ^a, instead.", p_expected_version, p_structure_name, p_received_version);
      372    end CHECK_VERSION_CHAR;
      373 
      374 GET_CI_HEADER:
      375    proc (gch_p_control_interval_id, gch_p_leaf_ci_header_ptr);
      376       dcl	    gch_p_control_interval_id
      377 			       fixed bin (24) unsigned;
      378       dcl	    gch_p_leaf_ci_header_ptr
      379 			       ptr;
      380 
      381       dcl	    gch_code	       fixed bin (35);
      382       dcl	    1 gch_element_id       aligned like element_id;
      383       dcl	    gch_element_id_string  bit (36) aligned based (addr (gch_element_id));
      384 
      385       gch_element_id.control_interval_id = gch_p_control_interval_id;
      386       gch_element_id.index = DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT;
      387       gch_code = 0;
      388 
      389       call collection_manager_$get (index_cursor.file_opening_id, index_cursor.collection_id, gch_element_id_string, 0,
      390 	 gch_p_leaf_ci_header_ptr, length (unspec (gch_p_leaf_ci_header_ptr -> leaf_ci_header)), null, "0"b,
      391 	 gch_p_leaf_ci_header_ptr, (0), gch_code);
      392       if gch_code ^= 0
      393       then call ERROR_RETURN (gch_code);
      394 
      395       if gch_p_leaf_ci_header_ptr -> common_ci_header.is_leaf
      396       then
      397          do;
      398 	  if gch_p_leaf_ci_header_ptr -> leaf_ci_header.common.key_range.first < 0
      399 	  then call ERROR_RETURN (dm_error_$bad_first_key_idx);
      400 	  else if gch_p_leaf_ci_header_ptr -> leaf_ci_header.common.key_range.last
      401 	       < gch_p_leaf_ci_header_ptr -> leaf_ci_header.common.key_range.first
      402 	  then call ERROR_RETURN (dm_error_$bad_last_key_idx);
      403          end;
      404       else call ERROR_RETURN (dm_error_$bad_leaf_node);
      405       return;
      406 
      407    end GET_CI_HEADER;
      408 
  1     1 /* ***********************************************************
  1     2*   *                                                         *
  1     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  1     4*   *                                                         *
  1     5*   *********************************************************** */
  1     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  1     7 
  1     8 /* Written by Lindsey Spratt, 04/02/82.
  1     9*Modified:
  1    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  1    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  1    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  1    13*	  type.
  1    14**/
  1    15 
  1    16 /* format: style2,ind3 */
  1    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  1    18 	     2 type	      fixed bin (17) unal,
  1    19 	     2 number_of_dimensions
  1    20 			      fixed bin (17) unal,
  1    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  1    22 	       3 value_ptr	      ptr unaligned;
  1    23 
  1    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  1    25 	     2 type	      fixed bin (17) unal,
  1    26 	     2 number_of_dimensions
  1    27 			      fixed bin (17) unal,
  1    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  1    29 	       3 identifier	      fixed bin (17) unal,
  1    30 	       3 pad	      bit (18) unal,
  1    31 	       3 value_ptr	      ptr unal;
  1    32 
  1    33      dcl	   simple_typed_vector_ptr
  1    34 			      ptr;
  1    35      dcl	   stv_number_of_dimensions
  1    36 			      fixed bin (17);
  1    37 
  1    38      dcl	   general_typed_vector_ptr
  1    39 			      ptr;
  1    40      dcl	   gtv_number_of_dimensions
  1    41 			      fixed bin (17);
  1    42 
  1    43      dcl	   (
  1    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  1    45 			      init (1),		/* value_ptr was aligned. */
  1    46 	   GENERAL_TYPED_VECTOR_TYPE
  1    47 			      init (2),
  1    48 	   SIMPLE_TYPED_VECTOR_TYPE
  1    49 			      init (3)
  1    50 	   )		      fixed bin (17) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      409 
      410 
  2     1 /* BEGIN INCLUDE FILE - dm_interval_spec.incl.pl1 */
  2     2 
  2     3 
  2     4 
  2     5 
  2     6 /****^  HISTORY COMMENTS:
  2     7*  1) change(86-09-19,Dupuis), approve(86-09-19,MCR7401), audit(86-09-24,Blair),
  2     8*     install(86-10-02,MR12.0-1173):
  2     9*     Changed the declaration of interval_bead to also initialize id_string and
  2    10*     id_list_ptr. The declare had initialized all of the structure but forgot
  2    11*     these elements.
  2    12*                                                   END HISTORY COMMENTS */
  2    13 
  2    14 
  2    15 
  2    16 /* DESCRIPTION:
  2    17*
  2    18*          The interval_specification is used in the index manager searching as
  2    19*     an internal (normalized) representation of the search specification.
  2    20*     Each interval_bead is a separate search problem, a separate interval.
  2    21*     The im_build_interval_spec module builds the interval_specification by
  2    22*     analyzing the search_specification.  The im_structural_search module
  2    23*     applies the interval_specification to the index.
  2    24**/
  2    25 
  2    26 /* HISTORY:
  2    27*
  2    28*Written by Lindsey Spratt, 10/06/82.
  2    29*Modified:
  2    30*10/26/84 by Lindsey L. Spratt:  Added documentation.  Changed to have a
  2    31*            char(8) version in interval_specification.
  2    32**/
  2    33 
  2    34 /* format: style2,ind3 */
  2    35      dcl	   1 interval_specification
  2    36 			      based (interval_specification_ptr) aligned,
  2    37 	     2 version	      char (8) aligned,
  2    38 	     2 number_of_intervals
  2    39 			      fixed bin (17) unaligned init (0),
  2    40 	     2 pad	      bit (18) unaligned init ("0"b),
  2    41 	     2 first_interval_bead_ptr
  2    42 			      ptr init (null),
  2    43 	     2 last_interval_bead_ptr
  2    44 			      ptr init (null);
  2    45 
  2    46      dcl	   1 interval_bead	      based (interval_bead_ptr) aligned,
  2    47 	     2 simple_typed_vector_ptr
  2    48 			      ptr init (null),
  2    49 	     2 next	      ptr init (null),
  2    50 	     2 number_of_fully_structural_fields
  2    51 			      fixed bin (17) init (0) unal,
  2    52 	     2 low,
  2    53 	       3 id_string	      bit (36) aligned init ("0"b),
  2    54 	       3 value_ptr	      ptr unaligned init (null),
  2    55 	       3 operator_code    fixed bin (18) uns unal init (0),
  2    56 	       3 pad	      bit (18) init ("0"b) unal,
  2    57 	     2 high	      like interval_bead.low,
  2    58 	     2 id_list_ptr	      ptr init (null);	/* This points at an id_list as declared in dm_id_list.incl.pl1 */
  2    59 						/* The ids in this list are of and_groups in */
  2    60 						/* the original search_specification. */
  2    61 
  2    62      dcl	   interval_specification_ptr
  2    63 			      ptr init (null);
  2    64      dcl	   interval_bead_ptr      ptr init (null);
  2    65      dcl	   INTERVAL_SPECIFICATION_VERSION_2
  2    66 			      init ("IntSpc 2") aligned char (8) internal static options (constant);
  2    67 
  2    68 
  2    69 /* END INCLUDE FILE - dm_interval_spec.incl.pl1 */
      411 
      412 
  3     1 /* BEGIN INCLUDE FILE - dm_operator_constants.incl.pl1 */
  3     2 
  3     3 /* Written by Lindsey Spratt, 07/07/82
  3     4*Modified:
  3     5*10/07/82 by Lindsey Spratt:  Added the GREATER, LESS, GREATER_OR_EQUAL,
  3     6*	  LESS_OR_EQUAL and REGULAR_EXPRESSION operator codes.  Also, added
  3     7*	  bit(1) arrays for determining if a given operator code "uses" a
  3     8*	  given operator.  For example, USES_LESS_OPERATOR(x) = "1"b only if
  3     9*	  x = LESS_OPERATOR_CODE or x = LESS_OR_EQUAL_OPERATOR_CODE.
  3    10**/
  3    11 
  3    12 /* format: style2,ind3 */
  3    13      dcl	   (
  3    14 	   EQUAL_OPERATOR_CODE    init (1),
  3    15 	   GREATER_OPERATOR_CODE  init (2),
  3    16 	   LESS_OPERATOR_CODE     init (7),
  3    17 	   REGULAR_EXPRESSION_OPERATOR_CODE
  3    18 			      init (8),
  3    19 	   NOT_EQUAL_OPERATOR_CODE
  3    20 			      init (5),
  3    21 	   GREATER_OR_EQUAL_OPERATOR_CODE
  3    22 			      init (3),
  3    23 	   LESS_OR_EQUAL_OPERATOR_CODE
  3    24 			      init (6),
  3    25 	   EQUAL_IDX	      init (18),
  3    26 	   GREATER_IDX	      init (17),
  3    27 	   NOT_IDX	      init (16),
  3    28 	   REGULAR_EXPRESSION_IDX init (15)
  3    29 	   )		      fixed bin internal static options (constant);
  3    30 
  3    31      dcl	   (
  3    32 	   USES_LESS_OPERATOR     init ("0"b, (5) (1)"0"b, "1"b /* <= */, "1"b /* < */, (24) (1)"0"b),
  3    33 	   USES_GREATER_OPERATOR  init ("0"b, "0"b, "1"b /* > */, "1"b /* >= */, (28) (1)"0"b),
  3    34 	   USES_EQUAL_OPERATOR    init ("0"b, "1"b /* = */, "0"b, "1"b /* >= */, "0"b, "0"b, "1"b /* <= */,
  3    35 			      (25) (1)"0"b),
  3    36 	   USES_REGULAR_EXPRESSION_OPERATOR
  3    37 			      init ("0"b, (7) (1)"0"b, "1"b /* reg exp */, (3) (1)"0"b, "1"b /* not reg exp */,
  3    38 			      (19) (1)"0"b)
  3    39 	   )		      dimension (0:31) bit (1) unaligned internal static options (constant);
  3    40 
  3    41 /* END INCLUDE FILE - dm_operator_constants.incl.pl1 */
      413 
      414 
  4     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  4     2 /* format: style3 */
  4     3 
  4     4 /* These constants are to be used for the flags argument of sub_err_ */
  4     5 /* They are just "string (condition_info_header.action_flags)" */
  4     6 
  4     7 declare	(
  4     8 	ACTION_CAN_RESTART	init (""b),
  4     9 	ACTION_CANT_RESTART init ("1"b),
  4    10 	ACTION_DEFAULT_RESTART
  4    11 			init ("01"b),
  4    12 	ACTION_QUIET_RESTART
  4    13 			init ("001"b),
  4    14 	ACTION_SUPPORT_SIGNAL
  4    15 			init ("0001"b)
  4    16 	)		bit (36) aligned internal static options (constant);
  4    17 
  4    18 /* End include file */
      415 
      416 
  5     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        Contains the declaration of an element identifier.  Element
  5     6*   identifiers consist of two parts, the id (number) of the control interval
  5     7*   in which the element resides, and the index into the slot table of
  5     8*   the element in the control interval.  The declaration of the element_id 
  5     9*   structure reflects this division of the element identifier.  The structure 
  5    10*   is based on the automatic bit string element_id_string because programs
  5    11*   generally pass bit strings (element_id_string) to each other, then 
  5    12*   interpret the bit string by overlaying the element_id structure ony if
  5    13*   it is necessary to access the parts of the id.  Basing element_id on
  5    14*   addr(element_id_string) instead of on a pointer removes the necessity
  5    15*   for always setting that pointer explicitly and guarantees that changes
  5    16*   made to the string or structure do not get inconsistent.
  5    17*
  5    18*   Changes made to element_id must also be made to datum_id, declared in 
  5    19*   dm_cm_datum.incl.pl1.
  5    20**/
  5    21 
  5    22 /* HISTORY:
  5    23*Written by Matthew Pierret, 04/01/82.
  5    24*Modified:
  5    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  5    26**/
  5    27 
  5    28 /* format: style2,ind3,ll79 */
  5    29 
  5    30      dcl	   element_id_string      bit (36) aligned;
  5    31 
  5    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  5    33 	     2 control_interval_id
  5    34 			      fixed bin (24) unal unsigned,
  5    35 	     2 index	      fixed bin (12) unal unsigned;
  5    36 
  5    37 
  5    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      417 
      418 
  6     1 /* BEGIN INCLUDE FILE - dm_im_ci_header.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*          Each node (control interval) in the index has a header which
  6     6*     describes the contents of that node.  Although there are two different
  6     7*     kinds of headers, leaf and branch, they have a great deal in common, the
  6     8*     common_ci_header.  The common_ci_header states which slots are used by
  6     9*     the keys (leaf or branch) in the key_range substructure.  There is an
  6    10*     "upward pointer" to the node's parent branch key (parent_id_string).
  6    11*     There are pointers to the previous and next nodes (previous_id and
  6    12*     next_id) on the same level to facilitate rotation of keys, and sequential
  6    13*     searching.  There is also a count of how much space is in use by the keys.
  6    14*
  6    15**/
  6    16 
  6    17 /* HISTORY:
  6    18*
  6    19*Written by Lindsey Spratt, 03/29/82.
  6    20*Modified:
  6    21*10/25/84 by Lindsey L. Spratt:  Added a description and fixed the history
  6    22*            section format.
  6    23**/
  6    24 
  6    25 /* format: style2,ind3 */
  6    26      dcl	   1 common_ci_header     based (common_ci_header_ptr),
  6    27 	     2 flags	      unaligned,
  6    28 	       3 is_leaf	      bit (1) unaligned,	/* ON for leaf_ci, OFF for branch_ci. */
  6    29 	       3 pad	      bit (17) unaligned,	/* Must be zero. */
  6    30 	     2 key_tail_space_used_since_last_prefix_compaction
  6    31 			      fixed bin (18) unsigned unal,
  6    32 	     2 key_range	      unaligned,
  6    33 	       3 first	      fixed bin (18) unsigned,
  6    34 	       3 last	      fixed bin (18) unsigned,
  6    35 	     2 parent_id_string   bit (36) aligned,
  6    36 	     2 previous_id	      fixed bin (24) unsigned unaligned,
  6    37 	     2 next_id	      fixed bin (24) unsigned unaligned,
  6    38 	     2 pad	      bit (24) unaligned;
  6    39 
  6    40 
  6    41      dcl	   common_ci_header_ptr   ptr;
  6    42 
  6    43      dcl	   1 leaf_ci_header	      based (leaf_ci_header_ptr),
  6    44 	     2 common	      like common_ci_header;
  6    45 
  6    46      dcl	   leaf_ci_header_ptr     ptr;
  6    47 
  6    48      dcl	   1 branch_ci_header     based (branch_ci_header_ptr),
  6    49 	     2 common	      like common_ci_header,
  6    50 	     2 low_branch_id      fixed bin (24) unsigned unaligned,
  6    51 	     2 pad	      bit (12) unaligned;
  6    52 
  6    53      dcl	   branch_ci_header_ptr   ptr;
  6    54 
  6    55 
  6    56      dcl	   (
  6    57 	   DEFAULT_INITIAL_KEY_SLOT
  6    58 			      init (2),
  6    59 	   DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
  6    60 			      init (1),
  6    61 	   LEAF_CI_HEADER_LENGTH_IN_BITS
  6    62 			      init (180),
  6    63 	   BRANCH_CI_HEADER_LENGTH_IN_BITS
  6    64 			      init (216)
  6    65 	   )		      internal static options (constant) fixed bin;
  6    66 
  6    67 /* END INCLUDE FILE - dm_im_ci_header.incl.pl1 */
      419 
      420 
  7     1 /* BEGIN INCLUDE FILE - dm_im_cursor.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*          This structure specifies a DM file, an index collection in that DM
  7     6*file, and a position (key) in that index collection.
  7     7*
  7     8**/
  7     9 
  7    10 /* HISTORY:
  7    11*
  7    12*Written by Lindsey Spratt, 03/29/82
  7    13*Modified:
  7    14*08/09/82 by Matthew Pierret: Changed collection_id from "fixed bin (17)" to
  7    15*            "bit (35) aligned".
  7    16*08/26/82 by Lindsey Spratt:  Changed to version 2.  Added the is_valid and
  7    17*	  is_at_end_of_index flags.  Changed the key_check_value to fixed
  7    18*	  bin (35).  Added the IM_HASH_BIAS, which is used to increment the
  7    19*	  value developed by hash_index_, and IM_HASH_NUMBER_OF_BUCKETS,
  7    20*	  which is a unique number used by hash_index_ to develop the
  7    21*	  key_check_value.
  7    22*02/23/83 by Lindsey Spratt: Changed to keep the current key value in the
  7    23*	  cursor.  Also, implemented the ability to have the cursor
  7    24*	  positioned before or after the index.  
  7    25*10/23/84 by Lindsey L. Spratt:  Added a description section.
  7    26**/
  7    27 
  7    28 /* format: style2,ind3 */
  7    29      dcl	   1 index_cursor	      based (index_cursor_ptr),
  7    30 	     2 type	      fixed bin (17) unaligned,
  7    31 	     2 version	      fixed bin (17) unaligned,
  7    32 	     2 file_opening_id    bit (36) aligned,
  7    33 	     2 collection_id      bit (36) aligned,
  7    34 	     2 key_id_string      bit (36) aligned,	/* Is the location of the current key, */
  7    35 						/* if flags.current_key_exists is on. Is the location */
  7    36 						/* of the end of the index if flags.is_at_end_of_index */
  7    37 						/* is on, which is only available via an operation */
  7    38 						/* requiring the "previous" key.  Is the location of */
  7    39 						/* the "next" key, otherwise. */
  7    40 	     2 area_ptr	      ptr,		/* Area in which the cursor and key_string area allocated. */
  7    41 						/* Must be a freeing area. */
  7    42 	     2 current_key_string_ptr
  7    43 			      ptr,		/* Points to the value of the current key. */
  7    44 	     2 current_key_string_length
  7    45 			      fixed bin (24) unal,	/* Is the length of the current key in bits. */
  7    46 	     2 pad	      bit (12) unal,
  7    47 	     2 flags	      aligned,
  7    48 	       3 is_at_beginning_of_index
  7    49 			      bit (1) unaligned,	/* Only the "next" key is defined. */
  7    50 	       3 is_at_end_of_index
  7    51 			      bit (1) unaligned,	/* Only the "previous" key is defined. */
  7    52 	       3 current_key_exists
  7    53 			      bit (1) unaligned,	/* If on, indicates that the "current" key is identified */
  7    54 						/* by the key_id_string.  If off, the "current" position */
  7    55 						/* is undefined, and the key_id_string identifies the */
  7    56 						/* previous or next key, depending on whether */
  7    57 						/* flags.is_at_end_of_index is off or on, respectively. */
  7    58 	       3 is_valid	      bit (1) unaligned,	/* If off, the index_manager_ was interrupted while */
  7    59 						/* setting the cursor position and the cursor is not */
  7    60 						/* to be trusted for relative position operations. */
  7    61 	       3 pad	      bit (32) unal;
  7    62 
  7    63 
  7    64      dcl	   index_cursor_ptr	      ptr;
  7    65 
  7    66      dcl	   INDEX_CURSOR_VERSION_3 fixed bin (17) init (3) internal static options (constant);
  7    67      dcl	   INDEX_CURSOR_TYPE      init (2) fixed bin (17) internal static options (constant);
  7    68 
  7    69 /* END INCLUDE FILE - dm_im_cursor.incl.pl1 */
      421 
      422 
  8     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*     This include file contains declarations of all collection_manager_ 
  8     5*     entrypoints.
  8     6**/
  8     7 
  8     8 /* HISTORY:
  8     9*Written by Matthew Pierret 
  8    10*Modified:
  8    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  8    12*	  allocate_control_interval operation to be unaligned, as well as
  8    13*	  unsigned.
  8    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  8    15*            removed the beginning_location parameter from the put_element
  8    16*            operation. Added the create_page_file_operation.
  8    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  8    18*            wherever collection_id was required.
  8    19*            Also changed the control_interval_id parameter of the 
  8    20*            allocate_control_interval operation back to be aligned. So there.
  8    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  8    22*            added the argument file_create_info_ptr to $create_file.
  8    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  8    24*	  include the zero_on_free bit.
  8    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  8    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  8    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  8    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  8    29*            cm_$put_unprotected_header.
  8    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  8    31*             $simple_get_buffered_element.
  8    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  8    33*            parameter for specifying absolute/relative nature of search.
  8    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  8    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  8    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  8    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  8    38*            delete_from_ci_buffer.
  8    39*            Re-named *_buffered_ci to =_ci_buffer.
  8    40*            get entries.
  8    41*            modify entries.
  8    42*            Changed calling sequence of modify entries to have a ptr/length
  8    43*            instead of length/ptr parameter pair.
  8    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  8    45**/
  8    46 
  8    47 /* This include file contains declarations of collection_manager_ entrypoints */
  8    48 
  8    49 /* format: style2,ind3 */
  8    50      dcl	   collection_manager_$allocate_control_interval
  8    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  8    52      dcl	   collection_manager_$compact_control_interval
  8    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  8    54      dcl	   collection_manager_$create_collection
  8    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  8    56      dcl	   collection_manager_$create_file
  8    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  8    58      dcl	   collection_manager_$destroy_collection
  8    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  8    60      dcl	   collection_manager_$free_control_interval
  8    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  8    62 			      fixed bin (35));
  8    63 
  8    64      dcl	   collection_manager_$delete
  8    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  8    66 			      fixed bin (35));
  8    67      dcl	   collection_manager_$delete_from_ci_buffer
  8    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  8    69 			      fixed bin (35));
  8    70 
  8    71      dcl	   collection_manager_$get
  8    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  8    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  8    74      dcl	   collection_manager_$get_control_interval_ptr
  8    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  8    76 			      fixed bin (35));
  8    77      dcl	   collection_manager_$get_from_ci_buffer
  8    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  8    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  8    80      dcl	   collection_manager_$get_by_ci_ptr
  8    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  8    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  8    83      dcl	   collection_manager_$get_header
  8    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  8    85 			      ptr, fixed bin (35), fixed bin (35));
  8    86      dcl	   collection_manager_$get_id
  8    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  8    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  8    89      dcl	   collection_manager_$get_portion
  8    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  8    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  8    92 			      fixed bin (35), fixed bin (35));
  8    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  8    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  8    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  8    96 			      fixed bin (35));
  8    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  8    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  8    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  8   100 			      fixed bin (35));
  8   101      dcl	   collection_manager_$modify
  8   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   103 			      fixed bin (35), fixed bin (35));
  8   104      dcl	   collection_manager_$modify_unprotected
  8   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   106 			      fixed bin (35), fixed bin (35));
  8   107      dcl	   collection_manager_$modify_in_ci_buffer
  8   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   109 			      fixed bin (35), fixed bin (35));
  8   110      dcl	   collection_manager_$modify_portion
  8   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  8   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  8   113      dcl	   collection_manager_$postcommit_increments
  8   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  8   115      dcl	   collection_manager_$put
  8   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   117 			      fixed bin (35), fixed bin (35));
  8   118      dcl	   collection_manager_$put_in_ci_buffer
  8   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   120 			      fixed bin (35), fixed bin (35));
  8   121      dcl	   collection_manager_$put_header
  8   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  8   123      dcl	   collection_manager_$put_unprotected_header
  8   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  8   125 
  8   126      dcl	   collection_manager_$replace_ci_buffer
  8   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  8   128 			      fixed bin (35));
  8   129      dcl	   collection_manager_$setup_ci_buffer
  8   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  8   131 			      fixed bin (35));
  8   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  8   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  8   134 			      fixed bin (35));
  8   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  8   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  8   137 			      fixed bin (35));
  8   138 
  8   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      423 
      424 
  9     1 /* ********** BEGIN INCLUDE FILE dm_field_table.incl.pl1 ********** */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*
  9     5*          The field_table describes the layout of a set of fields in a
  9     6*     formatted data string.  Such a string is the stored representation of a
  9     7*     record or a key.  Fields are placed side-by-side in the string in the
  9     8*     order they appear in the field_table.field array.  The string is divided
  9     9*     into the fixed portion and the varying portion.  In the fixed portion
  9    10*     appear fixed-length fields and fixed-size length-fields for
  9    11*     varying-length fields.  In the varying portion appear varying length
  9    12*     fields.  The length-field for a varying-length field contains the length
  9    13*     of the field values either in bits or in characters, depending on the
  9    14*     data type of the field.
  9    15**/
  9    16 
  9    17 /* HISTORY:
  9    18*Written by Matthew Pierret, 04/01/82.
  9    19*Modified:
  9    20*04/20/82 by Matthew Pierret: Added length_is_in_characters, meaning, if on,
  9    21*	  that if the field is varying, its length is expressed in
  9    22*	  bytes/characters.
  9    23*03/22/83 by Lindsey Spratt:  Changed lofvf to have a precision of 35 instead
  9    24*	  of 17, changed version to 2, changed version field to char(8) from
  9    25*	  fixed bin (17).
  9    26*05/01/84 by Matthew Pierret:  Changed version to 3. Removed field.name and
  9    27*            put field names in one string (field_names) at the end of the 
  9    28*            structure. Added field.location_of_name and field.length_of_name
  9    29*            for locating the field name in field_names. Aligned all "fixed bin"
  9    30*            structure elements.  Changed maximum_field_name_length to 
  9    31*            length_of_field_names.
  9    32**/
  9    33 
  9    34 /* format: style2 */
  9    35 
  9    36      dcl	   1 field_table	      aligned based (field_table_ptr),
  9    37 	     2 version	      char (8) aligned init (FIELD_TABLE_VERSION_3),
  9    38 	     2 number_of_fields   fixed bin (17),
  9    39 	     2 length_of_field_names
  9    40 			      fixed bin (17),	/* length of field_names in characters */
  9    41 	     2 location_of_first_varying_field
  9    42 			      fixed bin (35),	/* location of first bit in the varying portion of the formatted string */
  9    43 	     2 field	      (ft_number_of_fields refer (field_table.number_of_fields)),
  9    44 	       3 flags	      aligned,
  9    45 	         4 descriptor_is_varying
  9    46 			      bit (1) unal,		/* if on, the descriptor is not limited to the standard 36 bits */
  9    47 						/* and is stored in a stand-alone fashion, with field.descriptor */
  9    48 						/* containing the id of the element in which the descriptor is stored. */
  9    49 	         4 length_is_in_characters
  9    50 			      bit (1) unal,		/* if field is varying, the length field describes its length */
  9    51 						/* in characters instead of in bits */
  9    52 	         4 must_be_zero   bit (34) unal,
  9    53 	       3 descriptor	      bit (36) aligned,
  9    54 	       3 location	      fixed bin (35),	/* location of first bit of field in formatted string */
  9    55 	       3 length_in_bits   fixed bin (35),	/* length of field in bits */
  9    56 	     3 location_of_name   fixed bin (17),	/* location of first character of field name in field_names */
  9    57 	     3 length_of_name     fixed bin (17),	/* length of name in characters */
  9    58 	     2 varying_field_map  (ft_number_of_fields refer (field_table.number_of_fields)),
  9    59 	       3 field_id	      fixed bin (17),	/* field_id of Nth varying field */
  9    60 	       3 varying_field_index
  9    61 			      fixed bin (17),	/* ordinality among varying fields of field N */
  9    62 	     2 field_names	      char (ft_length_of_field_names refer (field_table.length_of_field_names));
  9    63 
  9    64 
  9    65      dcl	   field_table_ptr	      ptr;
  9    66      dcl	   ft_length_of_field_names
  9    67 			      fixed bin;
  9    68      dcl	   ft_number_of_fields    fixed bin;
  9    69      dcl	   FIELD_TABLE_VERSION_3  char (8) aligned init ("FldTbl 3") internal static options (constant);
  9    70 
  9    71 dcl field_name char (field_name_length) based (field_name_ptr);
  9    72 
  9    73 dcl field_name_length fixed bin;
  9    74 dcl field_name_ptr ptr;
  9    75 
  9    76 /* END INCLUDE FILE dm_field_table.incl.pl1 */
      425 
      426 
 10     1 /* BEGIN INCLUDE FILE - dm_im_opening_info.incl.pl1 */
 10     2 
 10     3 /* DESRIPTION:
 10     4*
 10     5*          The index_opening_info is per-process information, stored in a
 10     6*     hash_table managed by the opening_manager_, which allows the
 10     7*     index_manager_ to quickly reference certain unchanging pieces of
 10     8*     information rapidly.
 10     9**/
 10    10 
 10    11 /* HISTORY:
 10    12*
 10    13*Written by Lindsey Spratt, 10/28/82.
 10    14*Modified:
 10    15*10/26/84 by Lindsey L. Spratt:  Changed version to char(8).  Added a
 10    16*            description.  Added the current_rollback_count.  Added the
 10    17*	  key_count_array_ptr.
 10    18*03/07/85 by R. Michael Tague:  Added key_count_increments_ptr and 
 10    19*	  key_counts_postcommit_written.  Changed to version 3.
 10    20*03/25/85 by R. Michael Tague:  Added key_count_unprotected_file.  This
 10    21*	  flag is used by im_update_opening_info to help it maintain the
 10    22*	  key count array info.
 10    23**/
 10    24 
 10    25 /* format: style2,ind3 */
 10    26      dcl	   1 index_opening_info   based (index_opening_info_ptr) aligned,
 10    27 	     2 version	      char (8) aligned,
 10    28 	     2 file_opening_id    bit (36) aligned,
 10    29 	     2 collection_id      bit (36) aligned,
 10    30 	     2 index_header_ptr   ptr init (null),
 10    31 	     2 field_table_ptr    ptr init (null),
 10    32 	     2 key_count_array_ptr
 10    33 			      ptr init (null),
 10    34 	     2 key_count_increments_ptr
 10    35 			      ptr init (null),
 10    36 	     2 flags,
 10    37 	       3 key_count_postcommit_written
 10    38 			      bit (1) unal init ("0"b),
 10    39 	       3 key_count_unprotected_file
 10    40 			      bit (1) unal init ("0"b),
 10    41 	       3 pad	      bit (34) unal init (""b),
 10    42 	     2 current_txn_id     fixed bin (35) init (0),
 10    43 	     2 current_rollback_count
 10    44 			      fixed bin (35) init (0);
 10    45 
 10    46      dcl	   index_opening_info_ptr ptr init (null);
 10    47      dcl	   INDEX_OPENING_INFO_VERSION_3
 10    48 			      init ("IdxOpn 3") char (8) aligned internal static options (constant);
 10    49 
 10    50 /* END INCLUDE FILE - dm_im_opening_info.incl.pl1 */
      427 
      428    end im_structural_search;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/02/86  1204.8  im_structural_search.pl1          >special_ldd>install>MR12.0-1173>im_structural_search.pl1
409          1    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
411          2    10/02/86  1056.4  dm_interval_spec.incl.pl1         >special_ldd>install>MR12.0-1173>dm_interval_spec.incl.pl1
413          3    10/14/83  1609.1  dm_operator_constants.incl.pl1    >ldd>include>dm_operator_constants.incl.pl1
415          4    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
417          5    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
419          6    01/07/85  0858.8  dm_im_ci_header.incl.pl1          >ldd>include>dm_im_ci_header.incl.pl1
421          7    01/07/85  0858.9  dm_im_cursor.incl.pl1             >ldd>include>dm_im_cursor.incl.pl1
423          8    04/05/85  0924.4  dm_collmgr_entry_dcls.incl.pl1    >ldd>include>dm_collmgr_entry_dcls.incl.pl1
425          9    01/07/85  0858.8  dm_field_table.incl.pl1           >ldd>include>dm_field_table.incl.pl1
427         10    04/05/85  0924.4  dm_im_opening_info.incl.pl1       >ldd>include>dm_im_opening_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000041 constant        bit(36)                  initial dcl 4-7 set ref 141* 165* 276* 294* 313*
                                                                                  354* 368*
DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
                                       constant        fixed bin(17,0)          initial dcl 6-56 ref 386
FIELD_TABLE_VERSION_3           000002 constant        char(8)                  initial dcl 9-69 set ref 148*
INDEX_CURSOR_TYPE               000060 constant        fixed bin(17,0)          initial dcl 7-67 set ref 141 141*
INDEX_CURSOR_VERSION_3                 constant        fixed bin(17,0)          initial dcl 7-66 ref 145
INDEX_OPENING_INFO_VERSION_3    000000 constant        char(8)                  initial dcl 10-47 set ref 138*
INTERVAL_SPECIFICATION_VERSION_2
                                000006 constant        char(8)                  initial dcl 2-65 set ref 151*
LESS_OR_EQUAL_OPERATOR_CODE            constant        fixed bin(17,0)          initial dcl 3-13 ref 233
SIMPLE_TYPED_VECTOR_TYPE        000056 constant        fixed bin(17,0)          initial dcl 1-43 set ref 165 165*
USES_EQUAL_OPERATOR             000004 constant        bit(1)                   initial array unaligned dcl 3-31 ref 197
USES_GREATER_OPERATOR           000005 constant        bit(1)                   initial array unaligned dcl 3-31 ref 197
WANT_EQUAL                      000041 constant        bit(1)                   initial dcl 111 set ref 179* 213* 246*
WANT_GREATER                    000041 constant        bit(1)                   initial dcl 111 set ref 213*
WANT_KEY_LESS_THAN_VECTOR       000041 constant        bit(1)                   initial dcl 114 set ref 233*
WANT_LESS                       000041 constant        bit(1)                   initial dcl 111 set ref 246*
addr                                                   builtin function         dcl 104 ref 179 179 197 197 213 213 233 233 246 246
                                                                                  269 269 273 273 276 276 276 276 276 289 289 289
                                                                                  291 294 294 294 294 310 310 310 313 313 313 313
                                                                                  389
collection_id             2            based           bit(36)                  level 2 dcl 7-29 set ref 389*
collection_manager_$get         000032 constant        entry                    external dcl 8-71 ref 389
common                          000101 automatic       structure                level 2 in structure "local_leaf_ci_header"
                                                                                  unaligned dcl 94 in procedure
                                                                                  "im_structural_search"
common                                 based           structure                level 2 in structure "leaf_ci_header" unaligned
                                                                                  dcl 6-43 in procedure "im_structural_search"
common_ci_header                       based           structure                level 1 unaligned dcl 6-26
control_interval_id             000211 automatic       fixed bin(24,0)          level 2 in structure "gch_element_id" packed
                                                                                  unsigned unaligned dcl 382 in procedure
                                                                                  "GET_CI_HEADER" set ref 385*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 5-32 in procedure
                                                                                  "im_structural_search" set ref 269 269 276* 289
                                                                                  291 294* 294* 310 313* 313*
depth                           000106 automatic       fixed bin(17,0)          level 2 dcl 95 set ref 156*
dimension                 1            based           structure                array level 2 packed unaligned dcl 1-17
dm_error_$bad_first_key_idx     000020 external static fixed bin(35,0)          dcl 125 set ref 398*
dm_error_$bad_last_key_idx      000022 external static fixed bin(35,0)          dcl 125 set ref 400*
dm_error_$bad_leaf_node         000024 external static fixed bin(35,0)          dcl 125 set ref 404*
dm_error_$bad_vector_type       000026 external static fixed bin(35,0)          dcl 125 set ref 165*
dm_error_$programming_error     000016 external static fixed bin(35,0)          dcl 125 set ref 276* 294* 313*
dm_error_$wrong_cursor_type     000014 external static fixed bin(35,0)          dcl 125 set ref 141*
element_id                             based           structure                level 1 dcl 5-32
er_p_code                              parameter       fixed bin(35,0)          dcl 343 ref 341 344
error_table_$unimplemented_version
                                000030 external static fixed bin(35,0)          dcl 125 set ref 354* 368*
field_table                            based           structure                level 1 dcl 9-36
field_table_ptr           6            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 10-26 in procedure "im_structural_search" ref
                                                                                  147
field_table_ptr                 000132 automatic       pointer                  dcl 9-65 in procedure "im_structural_search" set ref
                                                                                  147* 148 171
file_opening_id           1            based           bit(36)                  level 2 dcl 7-29 set ref 389*
first                     1     000101 automatic       fixed bin(18,0)          level 4 in structure "local_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 94 in procedure
                                                                                  "im_structural_search" set ref 294 294*
first                     1            based           fixed bin(18,0)          level 4 in structure "leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 6-43 in procedure
                                                                                  "im_structural_search" ref 398 400
first_interval_bead_ptr
                          4            based           pointer                  initial level 2 dcl 2-35 ref 157
flags                                  based           structure                level 2 packed unaligned dcl 6-26
found_key                       000100 automatic       bit(1)                   initial dcl 93 set ref 93* 170* 185* 203* 220* 223
                                                                                  254* 256* 273* 276 291* 294 331 333
gch_code                        000210 automatic       fixed bin(35,0)          dcl 381 set ref 387* 389* 392 392*
gch_element_id                  000211 automatic       structure                level 1 dcl 382 set ref 389
gch_element_id_string                  based           bit(36)                  dcl 383 set ref 389*
gch_p_control_interval_id              parameter       fixed bin(24,0)          unsigned dcl 376 ref 374 385
gch_p_leaf_ci_header_ptr               parameter       pointer                  dcl 378 set ref 374 389* 389 389 389* 395 398 400
                                                                                  400
high                     10            based           structure                level 2 dcl 2-46
id_string                 5            based           bit(36)                  initial level 3 in structure "interval_bead"
                                                                                  dcl 2-46 in procedure "im_structural_search" set
                                                                                  ref 179* 184 185 197* 203 213* 220 269 273 276 276
                                                                                  276 289 294 294 294 313 331*
id_string                10            based           bit(36)                  initial level 3 in structure "interval_bead"
                                                                                  dcl 2-46 in procedure "im_structural_search" set
                                                                                  ref 184* 233* 246* 254 269 273 276 276 291 294 310
                                                                                  313 313 313 331*
im_basic_search                 000012 constant        entry                    external dcl 120 ref 179 197 213 233 246
index                     0(24) 000211 automatic       fixed bin(12,0)          level 2 in structure "gch_element_id" packed
                                                                                  unsigned unaligned dcl 382 in procedure
                                                                                  "GET_CI_HEADER" set ref 386*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 5-32 in procedure
                                                                                  "im_structural_search" set ref 273 273 276 276
                                                                                  276* 276* 294 294* 313 313*
index_cursor                           based           structure                level 1 unaligned dcl 7-29
index_cursor_ptr                000130 automatic       pointer                  dcl 7-64 set ref 140* 141 141 145 389 389
index_opening_info                     based           structure                level 1 dcl 10-26
index_opening_info_ptr          000134 automatic       pointer                  initial dcl 10-46 set ref 137* 138 147 179* 197*
                                                                                  213* 233* 246* 10-46*
interval_bead                          based           structure                level 1 dcl 2-46
interval_bead_ptr               000126 automatic       pointer                  initial dcl 2-64 set ref 157* 163 171 171 176 179
                                                                                  184 184 185 191 194 197 197 197 203 213 220 223
                                                                                  223 227 230 233 233 246 254 256 269 269 273 273
                                                                                  276 276 276 276 276 289 291 294 294 294 294 310
                                                                                  313 313 313 313 331 331 334* 334 2-64*
interval_idx                    000121 automatic       fixed bin(17,0)          dcl 99 set ref 161*
interval_specification                 based           structure                level 1 dcl 2-35
interval_specification_ptr      000124 automatic       pointer                  initial dcl 2-62 set ref 150* 151 157 161 2-62*
is_leaf                                based           bit(1)                   level 3 packed unaligned dcl 6-26 ref 395
key_range                 1            based           structure                level 3 in structure "leaf_ci_header" packed
                                                                                  unaligned dcl 6-43 in procedure
                                                                                  "im_structural_search"
key_range                 1     000101 automatic       structure                level 3 in structure "local_leaf_ci_header" packed
                                                                                  unaligned dcl 94 in procedure
                                                                                  "im_structural_search"
last                      1(18)        based           fixed bin(18,0)          level 4 in structure "leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 6-43 in procedure
                                                                                  "im_structural_search" ref 400
last                      1(18) 000101 automatic       fixed bin(18,0)          level 4 in structure "local_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 94 in procedure
                                                                                  "im_structural_search" set ref 313 313*
leaf_ci_header                         based           structure                level 1 unaligned dcl 6-43 ref 389 389
length                                                 builtin function         dcl 104 ref 389 389
local_leaf_ci_header            000101 automatic       structure                level 1 unaligned dcl 94 set ref 289 289 310 310
low                       5            based           structure                level 2 dcl 2-46
myname                          000010 constant        varying char(32)         initial dcl 110 set ref 141* 165* 276* 294* 313*
                                                                                  354* 368*
next                      2            based           pointer                  initial level 2 dcl 2-46 ref 334
null                                                   builtin function         dcl 104 ref 141 141 165 165 179 179 191 197 197 213
                                                                                  213 223 223 227 233 233 246 246 256 276 276 294
                                                                                  294 313 313 2-62 2-64 10-46 354 354 368 368 389
                                                                                  389
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-17 set ref 171 176
                                                                                  194 205 211* 211 218* 218 223 230 244* 244 251*
                                                                                  251
number_of_fields          2            based           fixed bin(17,0)          level 2 dcl 9-36 ref 171
number_of_intervals       2            based           fixed bin(17,0)          initial level 2 packed unaligned dcl 2-35 ref 161
operator_code             7            based           fixed bin(18,0)          initial level 3 in structure "interval_bead" packed
                                                                                  unsigned unaligned dcl 2-46 in procedure
                                                                                  "im_structural_search" ref 197 197
operator_code            12            based           fixed bin(18,0)          initial level 3 in structure "interval_bead" packed
                                                                                  unsigned unaligned dcl 2-46 in procedure
                                                                                  "im_structural_search" ref 233
p_code                                 parameter       fixed bin(35,0)          dcl 89 set ref 74 154* 179* 182 182* 197* 201 201*
                                                                                  213* 216 216* 233* 237 237* 246* 249 249* 344*
p_expected_version                     parameter       char(8)                  dcl 364 in procedure "CHECK_VERSION_CHAR" set ref
                                                                                  361 368 368*
p_expected_version                     parameter       fixed bin(35,0)          dcl 351 in procedure "CHECK_VERSION" set ref 348 354
                                                                                  354*
p_index_cursor_ptr                     parameter       pointer                  dcl 84 set ref 74 140 179* 197* 213* 233* 246*
p_index_opening_info_ptr               parameter       pointer                  dcl 82 ref 74 137
p_interval_specification_ptr           parameter       pointer                  dcl 86 ref 74 150
p_is_relative_search                   parameter       bit(1)                   dcl 85 set ref 74 179* 197* 213* 233* 246*
p_no_match                             parameter       bit(1)                   dcl 88 set ref 74 159* 333* 333
p_received_version                     parameter       fixed bin(35,0)          dcl 350 in procedure "CHECK_VERSION" set ref 348 354
                                                                                  354*
p_received_version                     parameter       char(8)                  dcl 364 in procedure "CHECK_VERSION_CHAR" set ref
                                                                                  361 368 368*
p_structure_name                       parameter       char                     unaligned dcl 366 in procedure "CHECK_VERSION_CHAR"
                                                                                  set ref 361 368*
p_structure_name                       parameter       char                     unaligned dcl 352 in procedure "CHECK_VERSION" set
                                                                                  ref 348 354*
position_stack                  000106 automatic       structure                level 1 dcl 95 set ref 179 179 197 197 213 213 233
                                                                                  233 246 246
previous_id               3     000101 automatic       fixed bin(24,0)          level 3 packed unsigned unaligned dcl 94 set ref 291
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 1-17
simple_typed_vector_ptr         000122 automatic       pointer                  dcl 1-33 in procedure "im_structural_search" set ref
                                                                                  163* 165 165 171 176 176 179* 194 194 197* 205 211
                                                                                  211 213* 218 218 223 230 230 233* 244 244 246* 251
                                                                                  251
simple_typed_vector_ptr                based           pointer                  initial level 2 in structure "interval_bead"
                                                                                  dcl 2-46 in procedure "im_structural_search" ref
                                                                                  163
sub_err_                        000010 constant        entry                    external dcl 119 ref 141 165 276 294 313 354 368
type                                   based           fixed bin(17,0)          level 2 in structure "index_cursor" packed unaligned
                                                                                  dcl 7-29 in procedure "im_structural_search" set
                                                                                  ref 141 141*
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  unaligned dcl 1-17 in procedure
                                                                                  "im_structural_search" set ref 165 165*
unspec                                                 builtin function         dcl 104 ref 389 389
value_ptr                 6            based           pointer                  initial level 3 in structure "interval_bead" packed
                                                                                  unaligned dcl 2-46 in procedure
                                                                                  "im_structural_search" ref 171 176 191 194 223 256
value_ptr                 1            based           pointer                  array level 3 in structure "simple_typed_vector"
                                                                                  packed unaligned dcl 1-17 in procedure
                                                                                  "im_structural_search" set ref 176* 194* 230*
value_ptr                11            based           pointer                  initial level 3 in structure "interval_bead" packed
                                                                                  unaligned dcl 2-46 in procedure
                                                                                  "im_structural_search" ref 171 223 227 230
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "index_cursor" packed unaligned
                                                                                  dcl 7-29 in procedure "im_structural_search" ref
                                                                                  145
version                                based           char(8)                  level 2 in structure "interval_specification"
                                                                                  dcl 2-35 in procedure "im_structural_search" set
                                                                                  ref 151*
version                                based           char(8)                  level 2 in structure "index_opening_info" dcl 10-26
                                                                                  in procedure "im_structural_search" set ref 138*
version                                based           char(8)                  initial level 2 in structure "field_table" dcl 9-36
                                                                                  in procedure "im_structural_search" set ref 148*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 4-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 4-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 4-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 4-7
BRANCH_CI_HEADER_LENGTH_IN_BITS        internal static fixed bin(17,0)          initial dcl 6-56
DEFAULT_INITIAL_KEY_SLOT               internal static fixed bin(17,0)          initial dcl 6-56
EQUAL_IDX                              internal static fixed bin(17,0)          initial dcl 3-13
EQUAL_OPERATOR_CODE                    internal static fixed bin(17,0)          initial dcl 3-13
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 1-43
GREATER_IDX                            internal static fixed bin(17,0)          initial dcl 3-13
GREATER_OPERATOR_CODE                  internal static fixed bin(17,0)          initial dcl 3-13
GREATER_OR_EQUAL_OPERATOR_CODE         internal static fixed bin(17,0)          initial dcl 3-13
LEAF_CI_HEADER_LENGTH_IN_BITS          internal static fixed bin(17,0)          initial dcl 6-56
LESS_OPERATOR_CODE                     internal static fixed bin(17,0)          initial dcl 3-13
NOT_EQUAL_OPERATOR_CODE                internal static fixed bin(17,0)          initial dcl 3-13
NOT_IDX                                internal static fixed bin(17,0)          initial dcl 3-13
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 1-43
REGULAR_EXPRESSION_IDX                 internal static fixed bin(17,0)          initial dcl 3-13
REGULAR_EXPRESSION_OPERATOR_CODE       internal static fixed bin(17,0)          initial dcl 3-13
USES_LESS_OPERATOR                     internal static bit(1)                   initial array unaligned dcl 3-31
USES_REGULAR_EXPRESSION_OPERATOR       internal static bit(1)                   initial array unaligned dcl 3-31
branch_ci_header                       based           structure                level 1 unaligned dcl 6-48
branch_ci_header_ptr                   automatic       pointer                  dcl 6-53
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 8-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 8-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 8-54
collection_manager_$create_file 000000 constant        entry                    external dcl 8-56
collection_manager_$delete      000000 constant        entry                    external dcl 8-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 8-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 8-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 8-60
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 8-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 8-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 8-77
collection_manager_$get_header  000000 constant        entry                    external dcl 8-83
collection_manager_$get_id      000000 constant        entry                    external dcl 8-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 8-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 8-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 8-93
collection_manager_$modify      000000 constant        entry                    external dcl 8-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 8-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 8-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 8-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 8-113
collection_manager_$put         000000 constant        entry                    external dcl 8-115
collection_manager_$put_header  000000 constant        entry                    external dcl 8-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 8-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 8-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 8-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 8-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 8-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 8-135
common_ci_header_ptr                   automatic       pointer                  dcl 6-41
element_id_string                      automatic       bit(36)                  dcl 5-30
field_name                             based           char                     unaligned dcl 9-71
field_name_length                      automatic       fixed bin(17,0)          dcl 9-73
field_name_ptr                         automatic       pointer                  dcl 9-74
ft_length_of_field_names               automatic       fixed bin(17,0)          dcl 9-66
ft_number_of_fields                    automatic       fixed bin(17,0)          dcl 9-68
general_typed_vector                   based           structure                level 1 packed unaligned dcl 1-24
general_typed_vector_ptr               automatic       pointer                  dcl 1-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 1-40
leaf_ci_header_ptr                     automatic       pointer                  dcl 6-46
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 1-35

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   002275 constant        entry                    internal dcl 348 ref 145
CHECK_VERSION_CHAR              002371 constant        entry                    internal dcl 361 ref 138 148 151
ERROR_RETURN                    002267 constant        entry                    internal dcl 341 ref 182 201 216 237 249 392 398 400
                                                                                  404
EXACT_MATCH                     001024 constant        label                    dcl 171
GET_CI_HEADER                   002473 constant        entry                    internal dcl 374 ref 289 310
INTERVAL_LOOP                   000706 constant        label                    dcl 161
MAIN_RETURN                     002266 constant        label                    dcl 337 ref 345
RANGE                           001117 constant        label                    dcl 188
im_structural_search            000456 constant        entry                    external dcl 74

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3036        3072    2662        3046
Length      3512    2662        34         404     153           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_structural_search                594 external procedure  is an external procedure.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure im_structural_search.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_structural_search.  
CHECK_VERSION_CHAR                      internal procedure  shares stack frame of external procedure im_structural_search.  
GET_CI_HEADER                           internal procedure  shares stack frame of external procedure im_structural_search.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_structural_search     000100 found_key                   im_structural_search
                         000101 local_leaf_ci_header        im_structural_search
                         000106 position_stack              im_structural_search
                         000121 interval_idx                im_structural_search
                         000122 simple_typed_vector_ptr     im_structural_search
                         000124 interval_specification_ptr  im_structural_search
                         000126 interval_bead_ptr           im_structural_search
                         000130 index_cursor_ptr            im_structural_search
                         000132 field_table_ptr             im_structural_search
                         000134 index_opening_info_ptr      im_structural_search
                         000210 gch_code                    GET_CI_HEADER
                         000211 gch_element_id              GET_CI_HEADER

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             r_le_a              call_ext_out_desc   call_ext_out        return_mac
ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get       im_basic_search               sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bad_first_key_idx   dm_error_$bad_last_key_idx    dm_error_$bad_leaf_node       dm_error_$bad_vector_type
dm_error_$programming_error   dm_error_$wrong_cursor_type   error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     74 000450        93 000463    2   62 000464    2   64 000466   10   46 000467       137 000470       138 000474
    140 000521       141 000525       145 000604       147 000622       148 000625       150 000650       151 000654
    154 000676       156 000700       157 000701       159 000704       161 000706       163 000717       165 000722
    170 001004       171 001005       176 001024       179 001033       182 001077       184 001110       185 001113
    187 001116       191 001117       194 001122       197 001130       201 001203       203 001214       204 001220
    205 001221       211 001224       213 001232       216 001275       218 001306       220 001322       223 001326
    227 001351       230 001354       233 001362       237 001431       239 001442       244 001443       246 001452
    249 001515       251 001526       254 001542       256 001547       269 001555       273 001570       276 001600
    286 001665       289 001666       291 001674       294 001705       310 002062       313 002070       331 002245
    333 002254       334 002261       336 002264       337 002266       341 002267       344 002271       345 002274
    348 002275       354 002306       359 002370       361 002371       368 002402       372 002472       374 002473
    385 002475       386 002500       387 002502       389 002503       392 002550       395 002554       398 002561
    400 002576       403 002611       404 002612       405 002621


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
