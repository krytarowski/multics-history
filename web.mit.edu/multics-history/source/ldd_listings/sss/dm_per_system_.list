	COMPILATION LISTING OF SEGMENT dm_per_system_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/24/85  0831.8 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *						 *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *						 *
        5*   *********************************************************** */
        6 
        7 /*  DESCRIPTION:
        8*
        9*	Utility for initializing per-system segments (actually, they are
       10*     per-AIM authorization segments, but they appear to most everyone else
       11*     as per-system segments).  All entries use the sub_err_ program to
       12*     report any errors that occur.  It is recommended that callers wishing
       13*     to catch non-fatal errors handle the sub_error_ condition.  None of
       14*     the entries called only at system initialization time produce
       15*     recoverable errors.
       16*
       17*	There are three types of entries to this program: DM
       18*     initialization and shutdown, per-system file/table handling, and DM
       19*     directory utilities.  The entries are described in these groups below;
       20*     see dm_per_system_.info for more help.
       21*
       22*	NOTE:  the system_low AIM classification is special cased to use
       23*     the "system_low" dir under the DM system dir.  This code should be
       24*     removed when all sites wanting to use DM from system_low have
       25*     installed the MR11 version of convert_access_class_; it is being left
       26*     in currently for our controlled release sites.
       27*
       28*
       29*     Initialization & Shutdown Entries:
       30*
       31*     init: create the per-bootload directory with the name of the enabled
       32*	per-bootload directory with a ".init" suffix, create the segment
       33*	dm_system_data_ in the new dir, and populate it with the contents
       34*	of dm_system_data_template_ as found via (DM ring) search rules.
       35*	If an active DM bootload exists, try to take over the Daemon
       36*	caretaker function.  If we takeover an existing system, either a
       37*	running or partially shutdown one, we reset any administratively
       38*	set shutdown information (i.e., the Daemon will use the Multics
       39*	shutdown time as the sole source of DM shutdown scheduling after
       40*	takeover) and make sure transactions can be started.
       41*
       42*     enable:  make the per-bootload directory accessible, by deleting the
       43*	".init" suffix from the name.
       44*
       45*     cleanup:  called if there is an error between initialization and enable.
       46*	Deletes the temporary initialization directory if it was created.
       47*
       48*     set_system_state:  called to set the current state of a DMS if the
       49*	process doing the setting is outside the DM ring.  Programs
       50*	executing in the DM ring will directly set the state.
       51*
       52*     File/Table Handling Entries:
       53*
       54*     create:  creates a segment in the per-bootload directory, and makes
       55*	it known.
       56*
       57*     alloc:  allocates a block in the area located in dm_system_data_.
       58*
       59*     initiate:  used in per-process initialization to make a segment known
       60*	which was created by the create entry in per-system initialization.
       61*
       62*     Directory Handling Entries:  (NOTE: these entries are in
       63*	dm_per_system_ because of their ties with the $init and $enable
       64*	entries.)
       65*
       66*     get_aim_dir: gets the DM directory under the DM system directory for
       67*	the calling process' AIM authorization.
       68*
       69*     get_bootload_dir: get the DM bootload directory under the AIM dir for
       70*	the current process.  The name is taken from the Multics system
       71*	up time and can have a .init suffix if the Daemon uses it and is
       72*	in the process of booting a system.  For normal users, the
       73*	returned name will never have .init added.
       74*
       75*     get_enabled_bootload_dirname: returns the entryname portion of the
       76*	bootload directory pathname that will be used when a DMS is
       77*	enabled, regardless of the current state of the DMS.  This is
       78*	useful for things like part two before journal manager per-system
       79*	initialization which must store the entryname of the bootload
       80*	directory before the .init suffix has been removed (e.g., the
       81*	location of the default system before journal.
       82*
       83*     get_system_dir:  current system directory for the calling process.
       84*
       85*     set_system_dir:  to set the system dir for the calling process.  Only
       86*	recommended for development and testing, but is unprivileged.
       87**/
       88 
       89 /*  HISTORY:
       90*
       91*Written by J. Bongiovanni, 08/15/82.
       92*Modified:
       93*11/11/82 by L. A. Newcomb: to add in the recovery entrypoint and have init,
       94*	  enable, and recovery set dm_system_data_$current_dm_state,
       95*	  and change the name given to the bootload dirs.
       96*12/08/82 by M. Pandolf: to tune dm_system_data_ with site generated parameters.
       97*03/09/83 by L. A. Newcomb: create directory & files write brackets of the
       98*	  DMS ring and read brackets of ring 5.
       99*03/15/83 by L. A. Newcomb: fill in dm_system_data_$initializer_name.
      100*04/22/83 by L. A. Newcomb:  changed the per-bootload dir name to work off of
      101*            the request_id_ subr and fixed problem of needing to know the name
      102*            of the enabled per-bootload dir name in part-2 initialization
      103*            BEFORE it is renamed.  For less problems, we truncate the seconds
      104*	  and microseconds off the request ID generated.
      105*05/17/83 by L. A. Newcomb:  Removed the recovery entrypoint (dm_initializer_
      106*            calls dm_recovery_ directly).  Started integration of
      107*            per-AIM control file parameters and merging dm_aim_dir_util_ into
      108*            this program for consistency.  All code parameters are now
      109*            obsolete as sub_err_ is used, and are being purged.
      110*06/13/83 by L. A. Newcomb:  Added creation of the privileged command message
      111*            segment for passing abitrary commands to a running Daemon.
      112*03/05/84 by L. A. Newcomb:  changed to use the include file dm_system_states
      113*            (renamed from dm_statuses); also changed creation of the
      114*            per-bootload directory and tables to have ring brackets of the DM
      115*            ring instead of DM ring, 5, 5 as it was for debugging.
      116*04/06/84 by Lindsey L. Spratt:  Added handling of the intermediate shutdown
      117*            system states to the takeover procedure, TRY_DM_SYSTEM_TAKEOVER.
      118*05/29/84 by Lindsey L. Spratt:  Changed to use version 2 of dm_system_config.
      119*            Added use of the CHECK_VERSION proc.
      120*08/02/84 by Lee A. Newcomb:  added the entries $set_system_state and
      121*	  $start_shutdown.
      122*08/13/84 by Lee A. Newcomb:  removed understanding of all DMS shutdown states
      123*	  from the TRY_DM_SYSTEM_TAKEOVER int. proc. except final shutdown.
      124*09/05/84 by Lee A. Newcomb:  Renamed dm_system_data_$initializer_shutdown_time
      125*	  to be $user_shutdown_time to agree with dm_system_data_ changes.
      126*09/27/84 by Lee A. Newcomb:  moved $start_shutdown to
      127*            dm_dmn_system_shutdown_$schedule and fixed error of not always
      128*            calling cu_$level_set before returning.
      129*11/05/84 by Lindsey L. Spratt:  Changed to use dm_system_data_template_ and 
      130*	  old_dm_system_data_, instead of just dm_system_data_.  Changed to
      131*	  use ERROR_RETURN, and to build pathnames for error msgs using
      132*	  pathname_.  Changed to only establish the cleanup handler once in
      133*	  the $init entry, changed CLEAN_UP_INIT to use FINISH_INIT.
      134*11/20/84 by Lee A. Newcomb:  moved all DM directory handling to this module,
      135*	  obsoleting dm_aim_dir_util_, at the same time, removing the notion
      136*	  of an AIM control segment and using convert_authorization_$encode
      137*	  to find per-AIM dirs; changed ERROR_RETURN to be "options
      138*	  (variable)" (kudos to CLJones), changed to always use
      139*	  dm_misc_util_ to get to the directory entries, and made internal
      140*	  proc variables use a prefix of the proc's initials as per project
      141*	  standards.
      142*12/02/84 by Lee A. Newcomb:  fixed a bug in takeover of an active DMS where we
      143*	  only used the enabled bootload dir name, not its path, to find the
      144*	  per-bootload tables; removed obsolete p_initializer_event_channel
      145*	  parameter from $enable.
      146*12/07/84 by Lee A. Newcomb:  Changed myname to the constant MYNAME as sub_err_
      147*	  only allows 32 chars. for the module name and octal garbage was
      148*	  resulting from the char varying; added the entryname variable
      149*	  for use in reporting errors.
      150*12/09/84 by Lee A. Newcomb:  Fixed to report process id's in octal (had
      151*	  used ^a instead of ^.3b in ioa_ strings).
      152*12/12/84 by Lindsey Spratt:  Fixed to everywhere use DM_SYSTEM_STATE_RUNNING
      153*	  to test and indicate  a successful takeover, even when the actual
      154*	  state is one of the intermediate shutdown states.
      155*02/19/85 by Lee A. Newcomb:  Fixed TRY_DM_SYSTEM_TAKEOVER to allow rebooting
      156*            if the system was partially shutdown and to reset the
      157*            administratively set shutdown information on ANY takeover; fixed
      158*            so we can boot a new DMS in the same Multics bootload if the
      159*            previous bootload completely finished; changed to use ^w instead
      160*            of ^.3b in ioa_ strings for octal output; fixed special case of
      161*            system_low per-AIM dir to use "system_low" instead of per-system
      162*            dir.
      163*03/05/85 by Steve Herbst: Replaced dm_log_ with dm_misc_util_$log.
      164*03/20/85 by R. Michael Tague: Removed the daemon message segment creation.
      165*04/09/85 by Lee A. Newcomb:  To use convert_access_class_ and not the obsolete
      166*            convert_authorization_.
      167**/
      168 
      169 /* format: style2,ll79,ind3,^indprocbody,ifthendo,ifthen,^indnoniterdo */
      170 /* format: ^inddcls,dclind5,idind35,linecom */
      171 
      172 dm_per_system_$init:
      173    proc (p_initializer_event_channel) returns (char (4) aligned);
      174 
      175 /* START OF DECLARATIONS */
      176 
      177 /* Parameter */
      178 dcl  (
      179      p_aim_directory		char (*),		/* per-AIM dir for current process */
      180      p_block_ptr			ptr,		/* Pointer to allocated block */
      181      p_bootload_dir			char (*),		/* Bootload directory name */
      182      p_initializer_event_channel	fixed bin (71),	/* event channel to talk to Daemon on */
      183      p_n_words			fixed bin (18),	/* Size of block to allocate */
      184      p_new_system_state		char (4) aligned,	/* for $set_system_state */
      185      p_reference_name		char (*),		/* Reference name */
      186      p_segment_name			char (*),		/* Name of segment to create */
      187      p_seg_ptr			ptr,		/* Pointer to created segment */
      188      p_system_directory		char (*)		/* Current system dir for DMS */
      189      )				parameter;
      190 
      191 /* Automatic */
      192 
      193 dcl  (
      194      aim_dir			char (168),	/* current DM AIM dir. for this process */
      195      aim_dir_name			char (32),	/* current AIM dir ename */
      196      areap			ptr,		/* $alloc, ptr to area in dm_system_data_ */
      197      block_ptr			ptr,		/* $alloc, ptr to allocation in dm_system_data_ area */
      198      bit_count			fixed bin (24),	/* $init, for setting bit count on dm_system_data_ */
      199      bootload_dir_name		char (32),
      200      code				fixed bin (35),	/* status/error code returned from some calls */
      201      current_bootload_directory	char (168),
      202      dm_system_copyp		ptr,		/* $init, loc. of per-bootload copy of dm_system_data_ */
      203      dm_system_data_template_ptr	ptr,		/* loc. of installed dm_system_data_ to copy */
      204      enabled_bootload_dir_name	char (32),
      205      entrypoint_name		char (32) varying,	/* globally used by ERROR_RETURN */
      206      initialization_bootload_dir_name	char (32),
      207      initialization_bootload_directory			/* $init, curr. name of per-bootload dir. */
      208 				char (168),
      209      level			fixed bin,	/* saved validation level */
      210      1 local_area_info		aligned like area_info,
      211      n_words			fixed bin (18),	/* $init, for making copy of installed dm_system_data_ */
      212 						/* $alloc, block size to allocate */
      213      ring_brackets			dim (3) fixed bin (3),
      214 						/* $init & $create, so seg. creation works in testing */
      215      seg_ptr			ptr,
      216      segname			char (32),
      217      system_dir			char (168),
      218      temp_dir			char (168),
      219      temp_dir_name			char (32)
      220      )				automatic;
      221 
      222 /* Based */
      223 dcl  based_area			area based (areap),
      224      block			dim (n_words) bit (36) aligned
      225 				based (block_ptr),
      226      seg_array			dim (n_words) bit (36) aligned based;
      227 
      228 /* Builtin */
      229 dcl  (addr, bin, bit, clock, divide, null, ptr, substr, unspec)
      230 				builtin;
      231 
      232 /* Condition */
      233 dcl  (area, cleanup, sub_error_)	condition;
      234 
      235 /* Constant */
      236 dcl  (
      237      ACL_ID			char (32) unaligned init ("*.*.*"),
      238      ENABLED_BOOTLOAD_DIR_NAME	bit (1) aligned init ("0"b),
      239 						/* for GET_BOOTLOAD_DIR_NAME int proc */
      240      INITIALIZATION_BOOTLOAD_DIR_NAME	bit (1) aligned init ("1"b),
      241 						/* for GET_BOOTLOAD_DIR_NAME int proc */
      242      IOA_GENERAL_RS_NO_NEW_LINE	bit (1) aligned init ("0"b),
      243      IOA_GENERAL_RS_DONT_PAD		bit (1) aligned init ("1"b),
      244      UNLOCK_CONFIG			bit (1) aligned init ("1"b),
      245 						/* for FINISH_INIT int. proc.*/
      246      DONT_UNLOCK_CONFIG		bit (1) aligned init ("0"b),
      247 						/* for FINISH_INIT int. proc.*/
      248      MYNAME			char (32) init ("dm_per_system_"),
      249      OLD_SYS_SEG			char (19) init ("old_dm_system_data_"),
      250      SYS_SEG			char (15) init ("dm_system_data_"),
      251      SYS_SEG_TEMPLATE		char (24)
      252 				init ("dm_system_data_template_")
      253      )				internal static options (constant);
      254 
      255 /* Entry */
      256 
      257 dcl  (
      258      convert_access_class_$encode	entry (bit (72) aligned, char (*)),
      259      cu_$arg_list_ptr		entry (ptr),
      260      cu_$level_get			entry (fixed bin),
      261      cu_$level_set			entry (fixed bin),
      262      define_area_			entry (ptr, fixed bin (35)),
      263      delete_$path			entry (char (*), char (*), bit (6),
      264 				char (*), fixed bin (35)),
      265      delete_$ptr			entry (ptr, bit (6), char (*),
      266 				fixed bin (35)),
      267      dm_check_configuration_		entry (ptr),
      268      dm_find_configuration_		entry () returns (ptr),
      269      dm_find_configuration_$terminate	entry (ptr),
      270      dm_load_configuration_		entry (ptr),
      271      dm_lock_configuration_		entry (ptr),
      272      dm_lock_configuration_$unlock	entry (ptr),
      273      dm_misc_util_$log		entry () options (variable),
      274      dm_misc_util_$get_aim_dir	entry (char (*)),
      275      dm_misc_util_$get_bootload_dir	entry (char (*)),
      276      dm_misc_util_$get_enabled_bootload_dirname
      277 				entry () returns (char (32)),
      278      dm_misc_util_$get_system_dir	entry (char (*)),
      279      dm_misc_util_$is_process_using_dm	entry () returns (bit (1) aligned),
      280      expand_pathname_		entry (char (*), char (*), char (*),
      281 				fixed bin (35)),
      282      get_authorization_		entry () returns (bit (72) aligned),
      283      get_group_id_$tag_star		entry () returns (char (32)),
      284      get_process_id_		entry () returns (bit (36)),
      285      get_ring_			entry () returns (fixed bin (3)),
      286      hcs_$append_branchx		entry (char (*), char (*),
      287 				fixed bin (5), (3) fixed bin (3),
      288 				char (*), fixed bin (1), fixed bin (1),
      289 				fixed bin (24), fixed bin (35)),
      290      hcs_$chname_file		entry (char (*), char (*), char (*),
      291 				char (*), fixed bin (35)),
      292      hcs_$initiate			entry (char (*), char (*), char (*),
      293 				fixed bin (1), fixed bin (2), ptr,
      294 				fixed bin (35)),
      295      hcs_$set_bc_seg		entry (ptr, fixed bin (24),
      296 				fixed bin (35)),
      297      hcs_$status_minf		entry (char (*), char (*),
      298 				fixed bin (1), fixed bin (2),
      299 				fixed bin (24), fixed bin (35)),
      300      hcs_$status_mins		entry (ptr, fixed bin (2),
      301 				fixed bin (24), fixed bin (35)),
      302      hcs_$validate_processid		entry (bit (36) aligned,
      303 				fixed bin (35)),
      304      ioa_$general_rs		entry (ptr, fixed bin, fixed bin,
      305 				char (*), fixed bin (21),
      306 				bit (1) aligned, bit (1) aligned),
      307      pathname_			entry (char (*), char (*))
      308 				returns (char (168)),
      309      request_id_			entry (fixed bin (71))
      310 				returns (char (19)),
      311      sub_err_			entry options (variable),
      312      system_info_$timeup		entry (fixed bin (71)),
      313      term_$seg_ptr			entry (ptr, fixed bin (35)),
      314      term_$single_refname		entry (char (*), fixed bin (35)),
      315      transaction_manager_$begins_on	entry ()
      316      )				external;
      317 
      318 /* External */
      319 dcl  (
      320      (
      321      dm_error_$area_overflow,
      322      dm_error_$per_system_not_init
      323      )				fixed bin (35),
      324      dm_system_data_template_$,
      325      dm_system_data_$,
      326      dm_system_data_$area_rel		bit (18) aligned,
      327      dm_system_data_$command_ms_name	char (32),
      328      dm_system_data_$current_dm_state	char (4) aligned,
      329      dm_system_data_$initialized	bit (1) aligned,
      330      dm_system_data_$initializer_name	char (32),
      331      dm_system_data_$initializer_processid
      332 				bit (36) aligned,
      333      (
      334      dm_system_data_$bootload_time,
      335      dm_system_data_$initializer_event_chn,
      336      dm_system_data_$initialization_time,
      337      dm_system_data_$saved_begin_shutdown_time,
      338      dm_system_data_$saved_daemon_logout_time,
      339      dm_system_data_$saved_user_bump_time,
      340      dm_system_data_$saved_user_shutdown_time,
      341      dm_system_data_$saved_user_warning_time
      342      )				fixed bin (71),
      343      dm_system_data_$saved_shutdown_reason
      344 				char (64) aligned,
      345      (
      346      error_table_$namedup,
      347      error_table_$segknown,
      348      error_table_$unimplemented_version
      349      )				fixed bin (35),
      350      old_dm_system_data_$initializer_processid
      351 				bit (36) aligned,
      352      old_dm_system_data_$initializer_name
      353 				char (32),
      354      old_dm_system_data_$current_dm_state
      355 				char (4) aligned,
      356      sys_info$max_seg_size		fixed bin (19)
      357      )				external static;
      358 
      359 /* Static */
      360 dcl  (
      361      dms_initializer_process		bit (1) aligned init (""b),
      362 						/* are we doing per-system initialization */
      363      multics_bootload_request_id_str	char (17) unaligned init (""),
      364 						/* for per-bootload dir. naming */
      365      system_dir_in_static		char (168)
      366 				init (">site>Data_Management")
      367      )				internal static;
      368 
      369 /* END OF DECLARATIONS */
      370 
      371 /*  dm_per_system_$init: proc (p_initializer_event_channel) returns (char (4) aligned);
      372*
      373* - Find the per-AIM directory
      374* - Make sure the per-bootload directory does not already exist (try to adopt
      375*     if one does)
      376* - Create a directory subordinate to it with a unique name, so that
      377*	it cannot be accessed (yet) by Data Management users.
      378* - Copy dm_system_data_template_ to this directory with the name
      379*	dm_system_data_ and make it known with ref. name dm_system_data_.
      380* - Initialize dm_system_data_ values.
      381**/
      382 
      383    entrypoint_name = "init";
      384 
      385    dm_system_data_template_ptr = null ();		/* don't know where installed dm_system_data_template_ is */
      386    dm_system_copyp = null ();				/* haven't made dm_system_data_ copy yet */
      387    dm_system_config_ptr = null ();			/* have not found per-AIM control file */
      388 
      389    dms_initializer_process = ""b;			/* assume the system is running for the moment */
      390 
      391    call cu_$level_get (level);
      392    on cleanup call CLEAN_UP_INIT ();
      393    call cu_$level_set (get_ring_ ());
      394 
      395    call dm_misc_util_$get_aim_dir (aim_dir);
      396 
      397 /* get ptr to the per-AIM configuration file and lock it.  This is our */
      398 /* main defense against multiple processes attempting to bootload a DMS */
      399 /* at the same AIM level in the same Multics bootload. */
      400 
      401    dm_system_config_ptr = dm_find_configuration_ ();
      402    call CHECK_VERSION (dm_system_config.version, DM_CONFIG_VERSION_2,
      403         "dm_system_config");
      404 
      405    call dm_lock_configuration_ (dm_system_config_ptr);
      406    call dm_check_configuration_ (dm_system_config_ptr);
      407 
      408 /* The configuration file is now locked.  See if a current bootload exists */
      409 
      410    enabled_bootload_dir_name = dm_misc_util_$get_enabled_bootload_dirname ();
      411    call hcs_$status_minf (aim_dir, enabled_bootload_dir_name, 0, (0), (0),
      412         code);
      413    if code = 0 then do;				/* if exists, try to adopt */
      414 						/* takeover will fail with sub_err_ call if system has */
      415 						/* a caretaker Daemon already */
      416       if TRY_DM_SYSTEM_TAKEOVER (p_initializer_event_channel,
      417 	 pathname_ (aim_dir, enabled_bootload_dir_name))
      418 	 = DM_SYSTEM_STATE_RUNNING then do;		/* successful takeover */
      419          call FINISH_INIT (UNLOCK_CONFIG);
      420          return (DM_SYSTEM_STATE_RUNNING);		/* Must be the running state if we took over */
      421       end;
      422    end;
      423 
      424    dms_initializer_process = "1"b;			/* no takeover to do, we will do initialization */
      425    ring_brackets (1), ring_brackets (2), ring_brackets (3) = get_ring_ ();
      426 						/* DMS ring */
      427 
      428 
      429 /* Create a temporary initialization bootload directory for the */
      430 /* DMS tables in the per-AIM directory */
      431 
      432    initialization_bootload_dir_name =
      433         GET_BOOTLOAD_DIR_NAME (INITIALIZATION_BOOTLOAD_DIR_NAME);
      434    call hcs_$append_branchx (aim_dir, initialization_bootload_dir_name,
      435         SMA_ACCESS_BIN, ring_brackets, ACL_ID, 1, 0, 0, code);
      436    if code = error_table_$namedup then do;		/* delete old, dead one and start fresh */
      437       call delete_$path (aim_dir, initialization_bootload_dir_name,
      438 	 "101000"b /* force,dir */, MYNAME, code);
      439       if code ^= 0 then
      440          call ERROR_RETURN (code,
      441 	    "Could not delete old initialization bootload directory ^a.",
      442 	    pathname_ (aim_dir, initialization_bootload_dir_name));
      443 						/* start fresh */
      444       call hcs_$append_branchx (aim_dir, initialization_bootload_dir_name,
      445 	 SMA_ACCESS_BIN, ring_brackets, ACL_ID, 1, 0, 0, code);
      446    end;
      447    if code ^= 0 then
      448       call ERROR_RETURN (code,
      449 	 "Could not create initialization bootload directory ^a.",
      450 	 pathname_ (aim_dir, initialization_bootload_dir_name));
      451 
      452    call dm_misc_util_$get_bootload_dir (initialization_bootload_directory);
      453 
      454 /* Now create a segment to be dm_system_data_, initiate it with the	*/
      455 /* required reference name, and copy the template system data segment	*/
      456 /* to the newly created one.  Note we find the template via search	*/
      457 /* rules in the DM ring.					*/
      458 
      459    call hcs_$append_branchx (initialization_bootload_directory, SYS_SEG,
      460         RW_ACCESS_BIN, ring_brackets, ACL_ID, 0, 0, 0, code);
      461    if code ^= 0 then
      462       call ERROR_RETURN (code,
      463 	 "Cannot create system data segment (^a) for this bootload in ^a.",
      464 	 SYS_SEG, initialization_bootload_directory);
      465 
      466    call hcs_$initiate (initialization_bootload_directory, SYS_SEG, SYS_SEG, 0,
      467         0, dm_system_copyp, code);
      468    if code ^= 0 & code ^= error_table_$segknown then
      469       call ERROR_RETURN (code,
      470 	 "Cannot initiate system data segment ^a for this bootload, with reference name ^a.",
      471 	 pathname_ (initialization_bootload_directory, SYS_SEG), SYS_SEG);
      472 
      473    dm_system_data_template_ptr = addr (dm_system_data_template_$);
      474    call hcs_$status_mins (dm_system_data_template_ptr, (0), bit_count, code);
      475    if code ^= 0 then
      476       call ERROR_RETURN (code,
      477 	 "Cannot find out bit count of system data segment template ^a.",
      478 	 SYS_SEG_TEMPLATE);
      479 
      480    n_words = divide (bit_count + 35, 36, 17);		/* copy installed to bootload version */
      481    unspec (dm_system_copyp -> seg_array) =
      482         unspec (dm_system_data_template_ptr -> seg_array);
      483 
      484 
      485    call hcs_$set_bc_seg (dm_system_copyp, bit_count, code);
      486    if code ^= 0 then
      487       call ERROR_RETURN (code,
      488 	 "Cannot set bit count on bootload version of system data segment: ^a.",
      489 	 pathname_ (initialization_bootload_directory, SYS_SEG));
      490 
      491    dm_system_data_$current_dm_state = DM_SYSTEM_STATE_INITIALIZING;
      492    dm_system_data_$initialization_time = clock ();
      493    call system_info_$timeup (dm_system_data_$bootload_time);
      494    dm_system_data_$initializer_processid = get_process_id_ ();
      495    dm_system_data_$initializer_name = get_group_id_$tag_star ();
      496    dm_system_data_$initializer_event_chn = p_initializer_event_channel;
      497    dm_system_data_$area_rel =
      498         bit (bin (divide (n_words + 1, 2, 17) * 2, 18), 18);
      499 
      500    unspec (local_area_info) = ""b;
      501    local_area_info.version = area_info_version_1;
      502    local_area_info.control.zero_on_alloc = "1"b;
      503    local_area_info.owner = SYS_SEG;
      504    local_area_info.size =
      505         sys_info$max_seg_size - bin (dm_system_data_$area_rel, 18);
      506    local_area_info.areap = ptr (dm_system_copyp, dm_system_data_$area_rel);
      507 
      508    call define_area_ (addr (local_area_info), code);
      509    if code ^= 0 then
      510       call ERROR_RETURN (code, "Cannot create area in system data segment ^a.",
      511 	 pathname_ (initialization_bootload_directory, SYS_SEG));
      512 
      513    call dm_load_configuration_ (dm_system_config_ptr);	/* tune dm_system_data_ */
      514 
      515    call FINISH_INIT (DONT_UNLOCK_CONFIG);
      516 
      517    return (dm_system_data_$current_dm_state);
      518 
      519 /* end dm_per_system_$init; */
      520 
      521 dm_per_system_$enable:
      522    entry ();
      523 
      524    entrypoint_name = "enable";			/* for error reporting */
      525 
      526 /* Now we let the users at the system, but finish some housecleaning first. */
      527 /* We must set the indicators in the system data segment to show that */
      528 /* initialization has finished, rename the initialization bootload directory */
      529 /* so users can find it, and unlock the per-AIM control file */
      530 
      531    if dm_system_data_$current_dm_state = DM_SYSTEM_STATE_UNDEFINED
      532         | dm_system_data_$current_dm_state = DM_SYSTEM_STATE_NORMAL_SHUTDOWN
      533         then
      534       call ERROR_RETURN (dm_error_$per_system_not_init,
      535 	 "Current Data Management state = ^a.",
      536 	 (dm_system_data_$current_dm_state));
      537 
      538    dm_system_data_$initialized = "1"b;
      539    dm_system_data_$current_dm_state = DM_SYSTEM_STATE_RUNNING;
      540 
      541    call dm_misc_util_$get_aim_dir (aim_dir);
      542 
      543 /* change bootload dir name to findable one */
      544 /* if this call works, users may use the system */
      545 
      546    enabled_bootload_dir_name = dm_misc_util_$get_enabled_bootload_dirname ();
      547    initialization_bootload_dir_name =
      548         GET_BOOTLOAD_DIR_NAME (INITIALIZATION_BOOTLOAD_DIR_NAME);
      549 
      550    call cu_$level_get (level);
      551    on cleanup call RESET_VALIDATION_LEVEL ();
      552    call cu_$level_set (get_ring_ ());
      553 
      554    call hcs_$chname_file (aim_dir, initialization_bootload_dir_name,
      555         initialization_bootload_dir_name, enabled_bootload_dir_name, code);
      556    if code ^= 0 then
      557       call ERROR_RETURN (code,
      558 	 "Cannot rename initialization bootload directory to an enabled name: ^a to ^a.",
      559 	 pathname_ (aim_dir, initialization_bootload_dir_name),
      560 	 enabled_bootload_dir_name);
      561 
      562    dm_system_config_ptr = dm_find_configuration_ ();	/* find control file for unlocking and termination */
      563    call dm_lock_configuration_$unlock (dm_system_config_ptr);
      564 						/* free up the control file */
      565    call dm_find_configuration_$terminate (dm_system_config_ptr);
      566 						/* cleanup address space */
      567 
      568    dms_initializer_process = "0"b;			/* at least we better be */
      569 
      570    call RESET_VALIDATION_LEVEL ();
      571 
      572    call RETURN ();
      573 
      574 /* end dm_per_system_$enable; */
      575 
      576 dm_per_system_$create:
      577    entry (p_segment_name, p_seg_ptr);
      578 
      579    entrypoint_name = "create";
      580 
      581 /*  Create a segment in the per-bootload directory, make it known, and */
      582 /*  return a pointer to it. */
      583 
      584    segname = p_segment_name;
      585    p_seg_ptr = null ();
      586 
      587    if dm_system_data_$current_dm_state = DM_SYSTEM_STATE_UNDEFINED
      588         | dm_system_data_$current_dm_state = DM_SYSTEM_STATE_NORMAL_SHUTDOWN
      589         then
      590       call ERROR_RETURN (dm_error_$per_system_not_init,
      591 	 "Current Data Management state = ^a.",
      592 	 (dm_system_data_$current_dm_state));
      593 
      594 
      595    call dm_misc_util_$get_bootload_dir (current_bootload_directory);
      596 						/* external entry in this program */
      597 
      598    ring_brackets (1), ring_brackets (2), ring_brackets (3) = get_ring_ ();
      599 						/* DMS ring */
      600    call cu_$level_get (level);
      601    on cleanup call RESET_VALIDATION_LEVEL ();
      602    call cu_$level_set (get_ring_ ());
      603 
      604    call hcs_$append_branchx (current_bootload_directory, segname,
      605         RW_ACCESS_BIN, ring_brackets, ACL_ID, 0, 0, 0, code);
      606    if code ^= 0 then
      607       call ERROR_RETURN (code, "Cannot create system segment ^a.",
      608 	 pathname_ (current_bootload_directory, segname));
      609 
      610    call hcs_$initiate (current_bootload_directory, segname, "", 0, 0, seg_ptr,
      611         code);
      612    if code ^= 0 then
      613       call ERROR_RETURN (code,
      614 	 "Cannot initiate newly created system segment ^a.",
      615 	 pathname_ (current_bootload_directory, segname));
      616 
      617    call RESET_VALIDATION_LEVEL ();
      618    p_seg_ptr = seg_ptr;
      619 
      620    call RETURN ();
      621 
      622 /* end dm_per_system_$create; */
      623 
      624 dm_per_system_$alloc:
      625    entry (p_n_words, p_block_ptr);
      626 
      627    entrypoint_name = "alloc";
      628 
      629 /*  allocate a block in the area in the system data segment */
      630 
      631    p_block_ptr = null ();
      632    n_words = p_n_words;
      633 
      634    if dm_system_data_$current_dm_state = DM_SYSTEM_STATE_UNDEFINED
      635         | dm_system_data_$current_dm_state = DM_SYSTEM_STATE_NORMAL_SHUTDOWN
      636         then
      637       call ERROR_RETURN (dm_error_$per_system_not_init,
      638 	 "Current Data Management state = ^a.",
      639 	 (dm_system_data_$current_dm_state));
      640 
      641    areap = ptr (addr (dm_system_data_$), dm_system_data_$area_rel);
      642 
      643    on area
      644       call ERROR_RETURN (dm_error_$area_overflow,
      645 	 "Cannot do more allocation in system data area, # of words asked for = ^d.",
      646 	 p_n_words);
      647 
      648    allocate block in (based_area) set (block_ptr);
      649 
      650    p_block_ptr = block_ptr;
      651 
      652    call RETURN ();
      653 
      654 /* end dm_per_system_$alloc; */
      655 
      656 dm_per_system_$cleanup:
      657    entry ();
      658 
      659    entrypoint_name = "cleanup";
      660 
      661 /*  undo what we've done so far, only for dm_initializer_ to call */
      662 
      663    if ^dms_initializer_process then			/* we haven't anything to undo */
      664       call RETURN ();
      665 
      666    if dm_system_data_$current_dm_state = DM_SYSTEM_STATE_NORMAL_SHUTDOWN then
      667       call ERROR_RETURN (dm_error_$per_system_not_init,
      668 	 "(Current) Data Management state = ^a.",
      669 	 (dm_system_data_$current_dm_state));
      670 
      671    on sub_error_					/* ignore errors in next two calls */
      672       go to CLEANUP_PROC_DONE;
      673    call dm_misc_util_$get_aim_dir (aim_dir);
      674 
      675    dm_system_config_ptr = dm_find_configuration_ ();	/* so we can unlock it if locked */
      676 
      677    on sub_error_					/* don't miss the terminate of config file */
      678       go to CLEANUP_PROC_TERM_CONFIG_FILE;
      679    call dm_lock_configuration_$unlock (dm_system_config_ptr);
      680 
      681 CLEANUP_PROC_TERM_CONFIG_FILE:
      682    on sub_error_					/* now back to original handling */
      683       go to CLEANUP_PROC_DONE;
      684    call dm_find_configuration_$terminate (dm_system_config_ptr);
      685 
      686    bootload_dir_name = GET_BOOTLOAD_DIR_NAME (dms_initializer_process);
      687    call delete_$path (aim_dir, bootload_dir_name, "001000"b /* dir */, "",
      688         code);
      689 
      690    revert sub_error_;
      691 
      692 CLEANUP_PROC_DONE:
      693    call RETURN ();
      694 
      695 /* end dm_per_system_$cleanup; */
      696 
      697 dm_per_system_$initiate:
      698    entry (p_segment_name, p_reference_name, p_seg_ptr);
      699 
      700    entrypoint_name = "initiate";
      701 
      702 /*  makes a segment in the per-bootload directory known and returns a */
      703 /*  pointer to it. */
      704 
      705    if dm_system_data_$current_dm_state = DM_SYSTEM_STATE_UNDEFINED
      706         | dm_system_data_$current_dm_state = DM_SYSTEM_STATE_NORMAL_SHUTDOWN
      707         then
      708       call ERROR_RETURN (dm_error_$per_system_not_init,
      709 	 "Current Data Management state = ^a.",
      710 	 (dm_system_data_$current_dm_state));
      711 
      712    p_seg_ptr = null ();
      713 
      714    call dm_misc_util_$get_bootload_dir (current_bootload_directory);
      715 
      716    call cu_$level_get (level);
      717    on cleanup call RESET_VALIDATION_LEVEL ();
      718    call cu_$level_set (get_ring_ ());
      719 
      720    call hcs_$initiate (current_bootload_directory, p_segment_name,
      721         p_reference_name, 0, 0, p_seg_ptr, code);
      722    if p_seg_ptr = null () then
      723       call ERROR_RETURN (code,
      724 	 "Cannot initiate system segment ^a with ref name of ^a.",
      725 	 pathname_ (current_bootload_directory, p_segment_name),
      726 	 p_reference_name);
      727 
      728    call RESET_VALIDATION_LEVEL ();
      729 
      730    call RETURN ();
      731 
      732 /* end dm_per_system_$initiate; */
      733 
      734 dm_per_system_$get_system_dir:
      735    entry (p_system_directory);
      736 
      737    entrypoint_name = "get_system_dir";
      738 
      739 /*  get_system_dir - entry to get the system dir for the current process' */
      740 /*  data management system.  We must verify the system dir exists before  */
      741 /*  returning, however.					    */
      742 
      743    call expand_pathname_ (system_dir_in_static, temp_dir, temp_dir_name, code);
      744    if code ^= 0 then
      745       call ERROR_RETURN (code, "Unable to expand system directory path ^a.",
      746 	 system_dir_in_static);
      747 
      748    call hcs_$status_minf (temp_dir, temp_dir_name, 0, 0, 0, code);
      749    if code ^= 0 then
      750       call ERROR_RETURN (code, "Unable to find system direcotry ^a.",
      751 	 system_dir_in_static);
      752 
      753    p_system_directory = system_dir_in_static;
      754 
      755    call RETURN ();
      756 
      757 /* end dm_per_system_$get_system_dir; */




      758 
      759 dm_per_system_$set_system_dir:
      760    entry (p_system_directory);
      761 
      762    entrypoint_name = "set_system_dir";
      763 
      764 /* set the internal static variable which holds the process' current system */
      765 /* directory.  This is only recommended for developers and testers of DM.   */
      766 
      767    if dm_misc_util_$is_process_using_dm () then
      768       call ERROR_RETURN (0,
      769 	 "Cannot set DM system directory to ^a, you must do DM user shutdown first.",
      770 	 p_system_directory);
      771 
      772    system_dir = p_system_directory;
      773    call expand_pathname_ (system_dir, temp_dir, temp_dir_name, code);
      774    if code ^= 0 then
      775       call ERROR_RETURN (code,
      776 	 "Unable to set DM system directory to ^a, expand_pathname_ failed on it.",
      777 	 system_dir);
      778 
      779    call hcs_$status_minf (temp_dir, temp_dir_name, 0, 0, 0, code);
      780    if code = 0 then					/* OK, set it */
      781       system_dir_in_static = pathname_ (temp_dir, temp_dir_name);
      782    else call ERROR_RETURN (code,
      783 	   "Cannot set DM system directory to the non-existent directory ^a.",
      784 	   system_dir);
      785 
      786    call RETURN ();
      787 
      788 /* end dm_per_system_$set_system_dir; */
      789 
      790 dm_per_system_$get_aim_dir:
      791    entry (p_aim_directory);
      792 
      793    entrypoint_name = "get_aim_dir";
      794 
      795 /*  Entry to return the pathname of the per-AIM directory for this process */
      796 /*  in the current DM system directory.   IF THERE IS NO AIM DIRECTORY FOR */
      797 /*  THIS PROCESS' AUTHORIZATION, WE USE ERROR_RETURN.  We could instead    */
      798 /*  let no error occur and let the firstref trap signal dm_not_available_, */
      799 /*  but there are modules calling this without setting off the trap; and   */
      800 /*  even if they did, it would imply there did exist an AIM dir giving     */
      801 /*  hope a DMS would be booted when it cannot be.  The only exception is   */
      802 /*  system_low since its AIM dir IS the system dir.		     */
      803 
      804    call convert_access_class_$encode (get_authorization_ (), aim_dir_name);
      805    call dm_misc_util_$get_system_dir (system_dir);
      806    if aim_dir_name = "" then
      807 SYSTEM_LOW_PROCESS:
      808       p_aim_directory = pathname_ (system_dir, "system_low");
      809 						/* it better exist */
      810    else
      811 NON_SYSTEM_LOW_PROCESS:
      812       do;						/* verify AIM dir exists */
      813       call hcs_$status_minf (system_dir, aim_dir_name, 0, 0, 0, code);
      814       if code ^= 0 then
      815          call ERROR_RETURN (code,
      816 	    "DM is not usable from the current AIM authorization, trying to find the directory ^a.",
      817 	    pathname_ (system_dir, aim_dir_name));
      818       p_aim_directory = pathname_ (system_dir, aim_dir_name);
      819    end NON_SYSTEM_LOW_PROCESS;
      820 
      821    call RETURN ();
      822 
      823 /* end dm_per_system_$get_aim_dir; */




      824 
      825 dm_per_system_$get_bootload_dir:
      826    entry (p_bootload_dir);
      827 
      828    entrypoint_name = "get_bootload_dir";
      829 
      830 /*  Entry to return the name of the per-bootload directory for this      */
      831 /*  bootload and AIM authorization.  It takes into account that the      */
      832 /*  caller may be the Daemon process booting a new DMS.  We do not	   */
      833 /*  report errors from this entry.				   */
      834 
      835    call dm_misc_util_$get_aim_dir (aim_dir);
      836 
      837    p_bootload_dir =
      838         pathname_ (aim_dir, GET_BOOTLOAD_DIR_NAME (dms_initializer_process));
      839 
      840    call RETURN ();
      841 
      842 /* end dm_per_system_$get_bootload_dir; */




      843 
      844 dm_per_system_$get_enabled_bootload_dirname:
      845    entry () returns (char (32));
      846 
      847    entrypoint_name = "get_enabled_bootload_dirname";
      848 
      849 /* entry to return entryname of enabled bootload directory regardless of */
      850 /* the current DMS state (i.e., the .init suffix will never be returned. */
      851 /* We do not report any errors from this entry.			   */
      852 
      853    return (GET_BOOTLOAD_DIR_NAME (ENABLED_BOOTLOAD_DIR_NAME));
      854 
      855 /* end dm_per_system_$get_enabled_bootload_dirname; */




      856 
      857 dm_per_system_$set_system_state:
      858    entry (p_new_system_state);
      859 
      860 /* We currently trust the new state passed to us.  If desired, error	*/
      861 /* detection may be added at a later date (e.g., incorrect sequence	*/
      862 /* of change, invalid state); however, more definition of the states	*/
      863 /* will probably be necessary before doing so.			*/
      864 
      865 /* set the state and return */
      866    dm_system_data_$current_dm_state = p_new_system_state;
      867 
      868    call RETURN ();
      869 
      870 /* end dm_per_system_$set_system_state */
      871 
      872 TRY_DM_SYSTEM_TAKEOVER:
      873    proc (tdst_p_new_event_channel, tdst_p_old_bootload_directory)
      874         returns (char (4) aligned);
      875 
      876 /* This internal procedure tries to adopt a running DMS.  If it	*/
      877 /* fails, the sub_err_ routine will be called to report the failure.	*/
      878 /* If the DMS for the current Multics bootload has shutdown, no	*/
      879 /* takeover is done and the shutdown status is returned so the Daemon	*/
      880 /* may bring up another DMS.  Also, if the DMS should have shutdown,	*/
      881 /* but has not and the time to bump users and logout the Daemon has	*/
      882 /* past, we: reset the shutdown information, allow new transactions,	*/
      883 /* and set the DMS state to running.  This code used to be in the	*/
      884 /* Daemon overseer, but has been moved here to ease maintenance.	*/
      885 
      886 dcl  (
      887      tdst_p_new_event_channel		fixed bin (71) aligned,
      888      tdst_p_old_bootload_directory	char (*)
      889      )				parameter;
      890 
      891 dcl  tdst_old_dm_system_data_ptr	ptr init (null) automatic;
      892 
      893    on cleanup call TDST_CLEANUP ();
      894 
      895    call hcs_$initiate (tdst_p_old_bootload_directory, SYS_SEG, OLD_SYS_SEG, 0,
      896         0, tdst_old_dm_system_data_ptr, code);
      897    if code ^= 0 | tdst_old_dm_system_data_ptr = null () then
      898       call ERROR_RETURN (code,
      899 	 "Unable to initiate the system data segment ^a with the reference name ^a, in the old DM system directory ^a.",
      900 	 SYS_SEG, OLD_SYS_SEG, tdst_p_old_bootload_directory);
      901 
      902    call hcs_$validate_processid (old_dm_system_data_$initializer_processid,
      903         code);
      904    if code = 0 then					/* we have a current caretaker */
      905       call ERROR_RETURN (0,
      906 	 "Current DM system ^a already has caretaker Daemon ^a (pid ^w).",
      907 	 tdst_p_old_bootload_directory, old_dm_system_data_$initializer_name,
      908 	 old_dm_system_data_$initializer_processid);
      909 
      910 
      911    if old_dm_system_data_$current_dm_state ^= DM_SYSTEM_STATE_RUNNING
      912         & old_dm_system_data_$current_dm_state
      913         ^= DM_SYSTEM_STATE_SHUTDOWN_BEGUN
      914         & old_dm_system_data_$current_dm_state
      915         ^= DM_SYSTEM_STATE_SHUTDOWN_BUMP_USERS then
      916 NO_DMS_TO_TAKEOVER:
      917       do;
      918       if old_dm_system_data_$current_dm_state = DM_SYSTEM_STATE_NORMAL_SHUTDOWN
      919 	 then
      920 MAY_BOOT_AFTER_NORMAL_SHUT:				/* recovery will take care of boot dir */
      921          return (DM_SYSTEM_STATE_NORMAL_SHUTDOWN);
      922 
      923       else					/* should not happen, arbitrary damage */
      924 	 call ERROR_RETURN (dm_error_$per_system_not_init,/* need human intervention */
      925 	      "Unable to takeover non-running DMS, state: ^a, bootload dir: ^a.",
      926 	      (old_dm_system_data_$current_dm_state),
      927 	      tdst_p_old_bootload_directory);
      928    end NO_DMS_TO_TAKEOVER;
      929 
      930    if dm_system_config.adopt = DM_DO_NOT_ADOPT_OLD_BOOTLOAD then
      931       call ERROR_RETURN (0,
      932 	 "Configuration file disallows takeover of running DM system ^a.",
      933 	 tdst_p_old_bootload_directory);
      934 
      935 /* If we get to this point, we must try to take over the current running DM */
      936 /* system's per-bootload directory */
      937 
      938    call hcs_$initiate (tdst_p_old_bootload_directory, SYS_SEG, SYS_SEG, 0, 0,
      939         null (), code);
      940    if code ^= 0 & code ^= error_table_$segknown then
      941       call ERROR_RETURN (code,
      942 	 "Unable to initiate the system data segment ^a with the reference name ^a, in the old DM system directory ^a.  Attempted takeover of running system failed.",
      943 	 SYS_SEG, SYS_SEG, tdst_p_old_bootload_directory);
      944 
      945    call dm_misc_util_$log (LOG_SV, "");			/* dummy to get a blank line */
      946    call dm_misc_util_$log (LOG_SV,
      947         "STARTING TAKEOVER of DM system ^a by process ^a (pid = ^w), from ^a (pid = ^w).",
      948         tdst_p_old_bootload_directory, get_group_id_$tag_star (),
      949         get_process_id_ (), dm_system_data_$initializer_name,
      950         dm_system_data_$initializer_processid);
      951 
      952 RESET_SHUTDOWN_INFO:
      953    do;
      954 
      955 /* Any takeover resets the admin and active shutdown data, makes sure	*/
      956 /* transactions may be started, and sets the system state to running.	*/
      957 /* The login ring module is responsible for always scheduling a DMS	*/
      958 /* shutdown based on the Multics shutdown time.			*/
      959 
      960       dm_system_data_$current_dm_state = DM_SYSTEM_STATE_RUNNING;
      961       if dm_system_data_$saved_begin_shutdown_time ^= 0 then do;
      962          dm_system_data_$saved_user_warning_time,
      963 	    dm_system_data_$saved_begin_shutdown_time,
      964 	    dm_system_data_$saved_user_shutdown_time,
      965 	    dm_system_data_$saved_user_bump_time,
      966 	    dm_system_data_$saved_daemon_logout_time = 0; /* calc from Mutlics shut time */
      967          dm_system_data_$saved_shutdown_reason =
      968 	    "NO REASON FOR SHUTDOWN GIVEN";		/* same as in dm_system_data_template_ */
      969          call dm_misc_util_$log (LOG_SV,
      970 	    "Previous admin shutdown infomration reset during takeover of DM."
      971 	    );
      972       end;
      973 
      974       call transaction_manager_$begins_on ();		/* make sure users can get in */
      975    end RESET_SHUTDOWN_INFO;
      976 
      977    dm_system_data_$initializer_event_chn = tdst_p_new_event_channel;
      978    dm_system_data_$initializer_name = get_group_id_$tag_star ();
      979    dm_system_data_$initializer_processid = get_process_id_ ();
      980 						/* we now "own" it */
      981 
      982    call dm_misc_util_$log (LOG_SV, "Finished takeover of DM system.");
      983 
      984    call term_$single_refname ((OLD_SYS_SEG), (0));
      985 
      986    return (DM_SYSTEM_STATE_RUNNING);			/* This indicates successful takeover. Actual state may be one of the shutdown states. */
      987 
      988 TDST_CLEANUP:
      989    proc ();
      990 
      991    if tdst_old_dm_system_data_ptr ^= null () then
      992       call term_$seg_ptr (tdst_old_dm_system_data_ptr, (0));
      993 
      994    end TDST_CLEANUP;
      995 
      996    end TRY_DM_SYSTEM_TAKEOVER;
      997 
      998 GET_BOOTLOAD_DIR_NAME:
      999    proc (gbdn_p_is_process_initializing_dms) returns (char (32));
     1000 
     1001 /*  Internal Procedure to generate the name of the per-bootload directory  */
     1002 /*  It accepts one input argument to decide if it should return the name of */
     1003 /*  the directory before or after the DMS system has been enabled */
     1004 /*  The name is based on the Multics bootload time after running it through */
     1005 /*  the request_id_ subr. and truncating the time to the minute.  This */
     1006 /*  allows the use of the construct "cwd {aim_dir}>[substr [request_id */
     1007 /*  [system date_time_last_up]] 1 10]" from command level and helps prevent */
     1008 /*  multiple DMS's running at the same AIM level. */
     1009 
     1010 dcl  gbdn_p_is_process_initializing_dms bit (1) aligned parameter;
     1011 
     1012 dcl  gbdn_time_of_multics_bootload	fixed bin (71) automatic;
     1013 
     1014 /* fill in the internal static that will give the base of all naming of */
     1015 /* any per-bootload directory. */
     1016    if multics_bootload_request_id_str = "" then do;
     1017       call system_info_$timeup (gbdn_time_of_multics_bootload);
     1018       multics_bootload_request_id_str =
     1019 	 "dm_dir."
     1020 	 || substr (request_id_ (gbdn_time_of_multics_bootload), 1, 10);
     1021    end;
     1022 
     1023    if gbdn_p_is_process_initializing_dms then
     1024       return (multics_bootload_request_id_str || ".init");
     1025    else return (multics_bootload_request_id_str);
     1026 
     1027    end GET_BOOTLOAD_DIR_NAME;
     1028 
     1029 RESET_VALIDATION_LEVEL:
     1030    proc ();
     1031 
     1032    call cu_$level_set (level);
     1033 
     1034    return;
     1035 
     1036    end RESET_VALIDATION_LEVEL;




     1037 
     1038 CLEAN_UP_INIT:
     1039    proc ();
     1040 
     1041 /*  Internal Procedure to clean up for $init entry only.
     1042*
     1043* - delete dm_system_data_ if created
     1044* - delete the per-bootload directory if created
     1045**/
     1046 
     1047 dcl  cui_initialization_bootload_dir	char (168) automatic;
     1048 
     1049    if dm_system_copyp ^= null () then do;
     1050       call delete_$ptr (dm_system_copyp, "000100"b, "", 0);
     1051       dm_system_copyp = null ();
     1052    end;
     1053 
     1054    if dms_initializer_process then do;			/* must delete the init dir if created */
     1055       cui_initialization_bootload_dir =
     1056 	 GET_BOOTLOAD_DIR_NAME (INITIALIZATION_BOOTLOAD_DIR_NAME);
     1057       call delete_$path (aim_dir, cui_initialization_bootload_dir, "001000"b,
     1058 	 "", 0);
     1059       dms_initializer_process = "0"b;
     1060    end;
     1061 
     1062    call FINISH_INIT (UNLOCK_CONFIG);
     1063 
     1064    return;
     1065 
     1066    end CLEAN_UP_INIT;
     1067 
     1068 FINISH_INIT:
     1069    proc (fi_p_config_lock_action);
     1070 dcl  fi_p_config_lock_action		bit (1) aligned parameter;
     1071 
     1072    if fi_p_config_lock_action = UNLOCK_CONFIG then
     1073       if dm_system_config_ptr ^= null () then do;
     1074          on sub_error_ go to FI_TERM_CONFIG;
     1075          call dm_lock_configuration_$unlock (dm_system_config_ptr);
     1076 FI_TERM_CONFIG:
     1077          on sub_error_ go to FI_CANT_TERM_CONFIG;
     1078          call dm_find_configuration_$terminate (dm_system_config_ptr);
     1079 FI_CANT_TERM_CONFIG:
     1080          revert sub_error_;
     1081       end;
     1082 
     1083    call RESET_VALIDATION_LEVEL ();
     1084 
     1085    return;
     1086 
     1087    end FINISH_INIT;




     1088 
     1089 RETURN:
     1090    proc ();					/* common return procedure for ease of debugging by needing only one break */
     1091 
     1092    go to MAIN_RETURN;
     1093 
     1094    end RETURN;




     1095 
     1096 MAIN_RETURN:
     1097    return;
     1098 
     1099 ERROR_RETURN:
     1100    proc options (variable);
     1101 
     1102 dcl  (
     1103      er_arg_list_ptr		ptr,
     1104      er_code			fixed bin (35),
     1105      er_message			char (1024),
     1106      er_message_length		fixed bin (21)
     1107      )				automatic;
     1108 
     1109 dcl  (
     1110      er_fixed_bin_35_value		fixed bin (35),
     1111      er_message_overlay		char (er_message_length)
     1112      )				based;
     1113 
     1114    call cu_$arg_list_ptr (er_arg_list_ptr);
     1115    er_code = er_arg_list_ptr -> arg_list.arg_ptrs (1) -> er_fixed_bin_35_value;
     1116 
     1117    call ioa_$general_rs (er_arg_list_ptr, 2, 3, er_message, er_message_length,
     1118         IOA_GENERAL_RS_DONT_PAD, IOA_GENERAL_RS_NO_NEW_LINE);
     1119    call sub_err_ (er_code, MYNAME, ACTION_CANT_RESTART, null (), 0,
     1120         "By entry ^a:  ^a", entrypoint_name,
     1121         addr (er_message) -> er_message_overlay);
     1122 
     1123    end ERROR_RETURN;




     1124 
     1125 CHECK_VERSION:
     1126    proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);
     1127 
     1128 dcl  cv_p_received_version		char (8) aligned;
     1129 dcl  cv_p_expected_version		char (8) aligned;
     1130 dcl  cv_p_structure_name		char (*);
     1131 
     1132    if cv_p_received_version ^= cv_p_expected_version then
     1133       call ERROR_RETURN (error_table_$unimplemented_version,
     1134 	 "^/Expected version ^d of the ^a structure.^/Received version ^d, instead.",
     1135 	 cv_p_expected_version, cv_p_structure_name, cv_p_received_version);
     1136 
     1137    end CHECK_VERSION;
     1138 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     1139 
     1140 
  2     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  2     2 
  2     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  2     4 
  2     5 dcl  area_infop ptr;
  2     6 
  2     7 dcl 1 area_info aligned based (area_infop),
  2     8     2 version fixed bin,				/* version number for this structure is 1 */
  2     9     2 control aligned like area_control,		/* control bits for the area */
  2    10     2 owner char (32) unal,				/* creator of the area */
  2    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  2    12     2 size fixed bin (18),				/* size of the area in words */
  2    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  2    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  2    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  2    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  2    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  2    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  2    19 
  2    20 dcl 1 area_control aligned based,
  2    21     2 extend bit (1) unal,				/* says area is extensible */
  2    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  2    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  2    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  2    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  2    26     2 system bit (1) unal,				/* says area is managed by system */
  2    27     2 pad bit (30) unal;
  2    28 
  2    29 /* END INCLUDE FILE area_info.incl.pl1 */
     1141 
     1142 
  3     1 /* BEGIN INCLUDE FILE dm_log_sv_codes.incl.pl1 */
  3     2 
  3     3 /* format: ^indcom */
  3     4 
  3     5 /* DESCRIPTION:
  3     6*   These are the severity codes used by the dms daemon when calling its logger.
  3     7*   The severity is ranked thusly:
  3     8*
  3     9*   severity log write situation
  3    10*   -------- --- ----- ---------
  3    11*          0 no  yes   standard output, query, etc.
  3    12*          1 yes yes   fatal error, terminate dms daemon.
  3    13*          2 yes yes   nonfatal error.
  3    14*          3 yes yes   informative message.
  3    15*          4 yes no    log information only.
  3    16**/
  3    17 
  3    18 /* HISTORY:
  3    19*
  3    20*Written by M. Pandolf, 10/06/82.
  3    21*Modified:
  3    22*12/10/84 by R. Michael Tague: Rename and reformat description/history.
  3    23*01/13/85 by Lee A. Newcomb:  Renamed to dm_log_sv_codes from
  3    24*            dm_daemon_sv_codes as the severity codes for the DM log are not
  3    25*            restrained to the DM Daemon's use.
  3    26*01/24/85 by Lee A. Newcomb:  Fixed to say dm_log_sv_codes.incl.pl1 in the
  3    27*            BEGIN and END INCLUDE comments, instead of dm_daemon_sv_codes.==.
  3    28**/
  3    29 
  3    30 /* format: style5 */
  3    31 
  3    32      dcl	   (PRINT_SV, QUERY_SV)    fixed bin internal static
  3    33 			       options (constant) init (0);
  3    34      dcl	   (CRASH_SV, FATAL_SV)    fixed bin internal static
  3    35 			       options (constant) init (1);
  3    36      dcl	   ERROR_SV	       fixed bin internal static
  3    37 			       options (constant) init (2);
  3    38      dcl	   INFORM_SV	       fixed bin internal static
  3    39 			       options (constant) init (3);
  3    40      dcl	   LOG_SV		       fixed bin internal static
  3    41 			       options (constant) init (4);
  3    42 
  3    43 /* END INCLUDE FILE dm_log_sv_codes.incl.pl1 */
     1143 
     1144 
  4     1 /* BEGIN INCLUDE FILE - dm_system_states.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*	This include file gives all defined values that
  4     6*     dm_system_data_$current_dm_state may have.
  4     7**/
  4     8 
  4     9 /* HISTORY:
  4    10*Written by Lee A. Newcomb, CISL, 11/04/82
  4    11*Modified:
  4    12*03/02/84 by Lee A. Newcomb:  added DM_SYSTEM_STATE_SHUTDOWN_WARNING and
  4    13*	  DM_SYSTEM_STATE_USER_SHUTDOWN; also renamed from dm_statuses to
  4    14*	  dm_system_states.incl.pl1.
  4    15*04/06/84 by Lindsey Spratt:  Added DM_SYSTEM_STATE_SYSTEM_SHUTDOWN.
  4    16*09/05/84 by Lee A. Newcomb:  renamed DM_SYSTEM_STATE_SHUTDOWN_WARNING do
  4    17*            ...SHUTDOWN_BEGUN and ...SYSTEM_SHUTDOWN to
  4    18*            ...SHUTDOWN_BUMP_USERS; deleted ...USER_SHUTDOWN.
  4    19**/
  4    20 /* format:  style2,^inddcls,linecom,ifthendo,ifthen,^indnoniterdo,dclind5,idind35 */
  4    21 
  4    22 dcl  (						/* valid statuses of data management */
  4    23 						/* ordered to expected sequence of use */
  4    24      DM_SYSTEM_STATE_UNDEFINED	init ("undf"),	/* found in a template dm_system_data_ */
  4    25      DM_SYSTEM_STATE_INITIALIZING	init ("init"),
  4    26      DM_SYSTEM_STATE_RECOVERING	init ("rcov"),
  4    27      DM_SYSTEM_STATE_RUNNING		init ("run "),
  4    28      DM_SYSTEM_STATE_SHUTDOWN_BEGUN	init ("sbgn"),
  4    29      DM_SYSTEM_STATE_SHUTDOWN_BUMP_USERS
  4    30 				init ("sbmp"),
  4    31      DM_SYSTEM_STATE_NORMAL_SHUTDOWN	init ("shut")
  4    32      )				char (4) aligned int static options (constant);
  4    33 
  4    34 /* END INCLUDE FILE - dm_system_states.incl.pl1 */
     1145 
     1146 
  5     1 /* BEGIN INCLUDE FILE dm_system_config.incl.pl1 */
  5     2 
  5     3 /* format: style4,indattr,ifthenstmt,ifthen,^indcomtxt,idind33 */
  5     4 
  5     5 /* DESCRIPTION:
  5     6*	This is the structure of the data in a Data Management configuration
  5     7*     file.  The configuration data is used during Data Management per-system
  5     8*     initialization to override hardcoded default in dm_system_data_ and
  5     9*     give the disposition of old bootloads.  This table is created at runtime
  5    10*     via a call to dm_translate_system_config_ subroutine.
  5    11*
  5    12*	NOTE:  only the data in the dm_system_config_info structure is used
  5    13*     to generate the checksum; the dm_system_config structure is used to
  5    14*     overlay the segment containing the configuration data, including the
  5    15*     lock and checksum cells.
  5    16**/
  5    17 /* HISTORY:
  5    18*Written by M. Pandolf, 12/06/82.
  5    19*Modified:
  5    20*03/14/83 by M. Pandolf: for single AIM class structure and more items.
  5    21*03/28/83 by M. Pandolf: for default default_bj and log_terms.
  5    22*05/04/83 by L. A. Newcomb:  Added new element, recovery_check_mode, and
  5    23*	  changed the version and most character values to "char (8)"'s for
  5    24*	  ease of use.  A string of 8 blanks is no longer a valid value for
  5    25*	  any of the char strings.
  5    26*06/09/83 by L. A. Newcomb:  moved lock to just before checksum so we can
  5    27*	  correctly determine checksum without the lock in the way.
  5    28*05/29/84 by Lindsey L. Spratt:  Changed to version 2.  Removed various cells
  5    29*            which are not used; first_boot, trace_stack_mode, max_n_bj and
  5    30*            subsystem_disposition (to enable/disable bjm, tm or lm).
  5    31*06/12/84 by Lindsey L. Spratt:  Added the shutdown_delay cell.
  5    32**/
  5    33 
  5    34 dcl  dm_system_config_ptr	        pointer;
  5    35 
  5    36 dcl  1 dm_system_config	        aligned based (dm_system_config_ptr),
  5    37        2 information	        like dm_system_config_info,
  5    38 						/* NEXT MUST NOT BE IN CHECKSUM VALUE */
  5    39        2 lock		        bit (36) aligned,	/* to prevent installations during initialization */
  5    40        2 checksum		        fixed bin (35);	/* for error detection */
  5    41 
  5    42 dcl  1 dm_system_config_info	        aligned based (dm_system_config_ptr),
  5    43        2 version		        char (8) aligned,	/* = DM_CONFIG_VERSION_2 */
  5    44        2 idle_timeout	        fixed bin,		/* max time daemon will remain idle before wakeup */
  5    45        2 shutdown_delay	        fixed bin (71),	/* Default time offset from issuing shutdown warning to forcing user shutdown */
  5    46        2 log_proc_terms	        bit (1) aligned,	/* true if process terminations to be logged */
  5    47        2 max_n_txn		        fixed bin,		/* found in the data segment */
  5    48        2 max_n_proc		        fixed bin,		/* dm_system_data_ */
  5    49        2 default_bj_size	        fixed bin,		/* size of before journal made by daemon */
  5    50        2 default_bj		        aligned,
  5    51          3 dir		        char (168),		/* dir containing default before journal */
  5    52          3 entry		        char (32),		/* entryname of default before journal */
  5    53        2 prev_dm_disp	        aligned,		/* what to do with old botload */
  5    54          3 adopt		        char (8),		/* DM_ADOPT_OLD_BOOTLOAD | DM_DO_NOT_ADOPT_OLD_BOOTLOAD */
  5    55          3 hold		        char (8),		/* DM_HOLD_OLD_BOOTLOAD_DIRECTORY | */
  5    56 						/*   DM_DO_NOT_HOLD_OLD_BOOTLOAD_DIRECTORY */
  5    57          3 recover		        char (8),		/* DM_RECOVER_OLD_BOOTLOAD | */
  5    58 						/*   DM_DO_NOT_RECOVER_OLD_BOOTLOAD */
  5    59          3 recovery_check_mode        char (8),		/* DM_RECOVERY_CHECK_MODE_ON | DM_RECOVERY_CHECK_MODE_OFF */
  5    60        2 curr_dm_enable	        char (8);		/* DM_FORCE_ENABLE_NEW_BOOTLOAD | */
  5    61 						/*   DM_DO_NOT_FORCE_ENABLE_NEW_BOOTLOAD */
  5    62 
  5    63 dcl  (						/* all the "char (8) aligned" constants */
  5    64      DM_CONFIG_VERSION_2	        init ("dmcnfg_2"),
  5    65 
  5    66      DM_ADOPT_OLD_BOOTLOAD	        init ("adopt"),
  5    67      DM_DO_NOT_ADOPT_OLD_BOOTLOAD     init ("no_adopt"),
  5    68 
  5    69      DM_FORCE_ENABLE_NEW_BOOTLOAD     init ("fc_enabl"),
  5    70      DM_DO_NOT_FORCE_ENABLE_NEW_BOOTLOAD init ("no_enabl"),
  5    71 
  5    72      DM_HOLD_OLD_BOOTLOAD_DIRECTORY   init ("hold"),
  5    73      DM_DO_NOT_HOLD_OLD_BOOTLOAD_DIRECTORY init ("no_hold"),
  5    74 
  5    75      DM_RECOVER_OLD_BOOTLOAD	        init ("do_recov"),
  5    76      DM_DO_NOT_RECOVER_OLD_BOOTLOAD   init ("no_recov"),
  5    77 
  5    78      DM_RECOVERY_CHECK_MODE_ON        init ("rcvck_on"),
  5    79      DM_RECOVERY_CHECK_MODE_OFF       init ("rcvck_of")
  5    80 
  5    81      )			        char (8) aligned internal static options (constant);
  5    82 
  5    83 /* END INCLUDE FILE dm_system_config.incl.pl1 */
     1147 
     1148 
  6     1 /* BEGIN INCLUDE FILE ... arg_list.incl.pl1
  6     2*
  6     3*   James R. Davis 10 May 79 */
  6     4 
  6     5      dcl	   1 arg_list	      aligned based,
  6     6 	     2 header,
  6     7 	       3 arg_count	      fixed bin (17) unsigned unal,
  6     8 	       3 pad1	      bit (1) unal,
  6     9 	       3 call_type	      fixed bin (18) unsigned unal,
  6    10 	       3 desc_count	      fixed bin (17) unsigned unal,
  6    11 	       3 pad2	      bit (19) unal,
  6    12 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr,
  6    13 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr;
  6    14 
  6    15 
  6    16 
  6    17      dcl	   1 arg_list_with_envptr aligned based,	/* used with non-quick int and entry-var calls */
  6    18 	     2 header,
  6    19 	       3 arg_count	      fixed bin (17) unsigned unal,
  6    20 	       3 pad1	      bit (1) unal,
  6    21 	       3 call_type	      fixed bin (18) unsigned unal,
  6    22 	       3 desc_count	      fixed bin (17) unsigned unal,
  6    23 	       3 pad2	      bit (19) unal,
  6    24 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr,
  6    25 	     2 envptr	      ptr,
  6    26 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr;
  6    27 
  6    28 
  6    29      dcl	   (
  6    30 	   Quick_call_type	      init (0),
  6    31 	   Interseg_call_type     init (4),
  6    32 	   Envptr_supplied_call_type
  6    33 			      init (8)
  6    34 	   )		      fixed bin (18) unsigned unal int static options (constant);
  6    35 
  6    36 /* The user must declare arg_list_arg_count - if an adjustable automatic structure
  6    37*   is being "liked" then arg_list_arg_count may be a parameter, in order to allocate
  6    38*   an argument list of the proper size in the user's stack
  6    39*
  6    40**/
  6    41 /* END INCLUDE FILE ... arg_list.incl.pl1 */
     1149 
     1150 
  7     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  7     2 /* format: style3 */
  7     3 
  7     4 /* These constants are to be used for the flags argument of sub_err_ */
  7     5 /* They are just "string (condition_info_header.action_flags)" */
  7     6 
  7     7 declare	(
  7     8 	ACTION_CAN_RESTART	init (""b),
  7     9 	ACTION_CANT_RESTART init ("1"b),
  7    10 	ACTION_DEFAULT_RESTART
  7    11 			init ("01"b),
  7    12 	ACTION_QUIET_RESTART
  7    13 			init ("001"b),
  7    14 	ACTION_SUPPORT_SIGNAL
  7    15 			init ("0001"b)
  7    16 	)		bit (36) aligned internal static options (constant);
  7    17 
  7    18 /* End include file */
     1151 
     1152 
     1153 
     1154    end dm_per_system_$init;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/24/85  0803.1  dm_per_system_.pl1                >spec>on>41-21>dm_per_system_.pl1
1139         1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
1141         2    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
1143         3    03/06/85  1031.1  dm_log_sv_codes.incl.pl1          >ldd>include>dm_log_sv_codes.incl.pl1
1145         4    01/07/85  0900.0  dm_system_states.incl.pl1         >ldd>include>dm_system_states.incl.pl1
1147         5    01/07/85  0859.9  dm_system_config.incl.pl1         >ldd>include>dm_system_config.incl.pl1
1149         6    10/23/81  1948.6  arg_list.incl.pl1                 >ldd>include>arg_list.incl.pl1
1151         7    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACL_ID                          000042 constant        char(32)                 initial unaligned dcl 236 set ref 434* 444* 459*
                                                                                  604*
ACTION_CANT_RESTART             000116 constant        bit(36)                  initial dcl 7-7 set ref 1119*
DM_CONFIG_VERSION_2             000002 constant        char(8)                  initial dcl 5-63 set ref 402*
DM_DO_NOT_ADOPT_OLD_BOOTLOAD    000000 constant        char(8)                  initial dcl 5-63 ref 930
DM_SYSTEM_STATE_INITIALIZING    000127 constant        char(4)                  initial dcl 4-22 ref 491
DM_SYSTEM_STATE_NORMAL_SHUTDOWN 000004 constant        char(4)                  initial dcl 4-22 ref 531 587 634 666 705 918 918
DM_SYSTEM_STATE_RUNNING         000007 constant        char(4)                  initial dcl 4-22 ref 416 420 539 911 960 986
DM_SYSTEM_STATE_SHUTDOWN_BEGUN  000006 constant        char(4)                  initial dcl 4-22 ref 911
DM_SYSTEM_STATE_SHUTDOWN_BUMP_USERS
                                000005 constant        char(4)                  initial dcl 4-22 ref 911
DM_SYSTEM_STATE_UNDEFINED       000010 constant        char(4)                  initial dcl 4-22 ref 531 587 634 705
DONT_UNLOCK_CONFIG              000126 constant        bit(1)                   initial dcl 236 set ref 515*
ENABLED_BOOTLOAD_DIR_NAME       000126 constant        bit(1)                   initial dcl 236 set ref 853*
INITIALIZATION_BOOTLOAD_DIR_NAME
                                000116 constant        bit(1)                   initial dcl 236 set ref 432* 547* 1055*
IOA_GENERAL_RS_DONT_PAD         000116 constant        bit(1)                   initial dcl 236 set ref 1117*
IOA_GENERAL_RS_NO_NEW_LINE      000126 constant        bit(1)                   initial dcl 236 set ref 1117*
LOG_SV                          000011 constant        fixed bin(17,0)          initial dcl 3-40 set ref 945* 946* 969* 982*
MYNAME                          000032 constant        char(32)                 initial unaligned dcl 236 set ref 437* 1119*
OLD_SYS_SEG                     000025 constant        char(19)                 initial unaligned dcl 236 set ref 895* 897* 984
RW_ACCESS_BIN                   000056 constant        fixed bin(5,0)           initial dcl 1-36 set ref 459* 604*
SMA_ACCESS_BIN                  000012 constant        fixed bin(5,0)           initial dcl 1-36 set ref 434* 444*
SYS_SEG                         000021 constant        char(15)                 initial unaligned dcl 236 set ref 459* 461* 466*
                                                                                  466* 468* 468* 468* 486* 486* 503 509* 509* 895*
                                                                                  897* 938* 938* 940* 940*
SYS_SEG_TEMPLATE                000013 constant        char(24)                 initial unaligned dcl 236 set ref 475*
UNLOCK_CONFIG                   000116 constant        bit(1)                   initial dcl 236 set ref 419* 1062* 1072
addr                                                   builtin function         dcl 229 ref 473 508 508 641 1119
adopt                    74            based           char(8)                  level 4 dcl 5-36 ref 930
aim_dir                         000100 automatic       char(168)                unaligned dcl 193 set ref 395* 411* 416* 416* 434*
                                                                                  437* 439* 439* 444* 447* 447* 541* 554* 556* 556*
                                                                                  673* 687* 835* 837* 1057*
aim_dir_name                    000152 automatic       char(32)                 unaligned dcl 193 set ref 804* 806 813* 814* 814*
                                                                                  818*
area                            000560 stack reference condition                dcl 233 ref 643
area_control                           based           structure                level 1 dcl 2-20
area_info                              based           structure                level 1 dcl 2-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 2-3 ref 501
areap                    16     000362 automatic       pointer                  level 2 in structure "local_area_info" dcl 193
                                                                                  in procedure "dm_per_system_$init" set ref 506*
areap                           000162 automatic       pointer                  dcl 193 in procedure "dm_per_system_$init" set ref
                                                                                  641* 648
arg_list                               based           structure                level 1 dcl 6-5
arg_ptrs                  2            based           pointer                  array level 2 dcl 6-5 ref 1115
based_area                             based           area(1024)               dcl 223 ref 648
bin                                                    builtin function         dcl 229 ref 497 504
bit                                                    builtin function         dcl 229 ref 497
bit_count                       000166 automatic       fixed bin(24,0)          dcl 193 set ref 474* 480 485*
block                                  based           bit(36)                  array dcl 223 ref 648
block_ptr                       000164 automatic       pointer                  dcl 193 set ref 648* 650
bootload_dir_name               000167 automatic       char(32)                 unaligned dcl 193 set ref 686* 687*
cleanup                         000566 stack reference condition                dcl 233 ref 392 551 601 717 893
clock                                                  builtin function         dcl 229 ref 492
code                            000177 automatic       fixed bin(35,0)          dcl 193 set ref 411* 413 434* 436 437* 439 439* 444*
                                                                                  447 447* 459* 461 461* 466* 468 468 468* 474* 475
                                                                                  475* 485* 486 486* 508* 509 509* 554* 556 556*
                                                                                  604* 606 606* 610* 612 612* 687* 720* 722* 743*
                                                                                  744 744* 748* 749 749* 773* 774 774* 779* 780 782*
                                                                                  813* 814 814* 895* 897 897* 902* 904 938* 940 940
                                                                                  940*
control                   1     000362 automatic       structure                level 2 dcl 193
convert_access_class_$encode    000070 constant        entry                    external dcl 257 ref 804
cu_$arg_list_ptr                000072 constant        entry                    external dcl 257 ref 1114
cu_$level_get                   000074 constant        entry                    external dcl 257 ref 391 550 600 716
cu_$level_set                   000076 constant        entry                    external dcl 257 ref 393 552 602 718 1032
cui_initialization_bootload_dir 000106 automatic       char(168)                unaligned dcl 1047 set ref 1055* 1057*
current_bootload_directory      000200 automatic       char(168)                unaligned dcl 193 set ref 595* 604* 606* 606* 610*
                                                                                  612* 612* 714* 720* 722* 722*
cv_p_expected_version                  parameter       char(8)                  dcl 1129 set ref 1125 1132 1132*
cv_p_received_version                  parameter       char(8)                  dcl 1128 set ref 1125 1132 1132*
cv_p_structure_name                    parameter       char                     unaligned dcl 1130 set ref 1125 1132*
define_area_                    000100 constant        entry                    external dcl 257 ref 508
delete_$path                    000102 constant        entry                    external dcl 257 ref 437 687 1057
delete_$ptr                     000104 constant        entry                    external dcl 257 ref 1050
divide                                                 builtin function         dcl 229 ref 480 497
dm_check_configuration_         000106 constant        entry                    external dcl 257 ref 406
dm_error_$area_overflow         000206 external static fixed bin(35,0)          dcl 319 set ref 643*
dm_error_$per_system_not_init   000210 external static fixed bin(35,0)          dcl 319 set ref 531* 587* 634* 666* 705* 923*
dm_find_configuration_          000110 constant        entry                    external dcl 257 ref 401 562 675
dm_find_configuration_$terminate
                                000112 constant        entry                    external dcl 257 ref 565 684 1078
dm_load_configuration_          000114 constant        entry                    external dcl 257 ref 513
dm_lock_configuration_          000116 constant        entry                    external dcl 257 ref 405
dm_lock_configuration_$unlock   000120 constant        entry                    external dcl 257 ref 563 679 1075
dm_misc_util_$get_aim_dir       000124 constant        entry                    external dcl 257 ref 395 541 673 835
dm_misc_util_$get_bootload_dir  000126 constant        entry                    external dcl 257 ref 452 595 714
dm_misc_util_$get_enabled_bootload_dirname
                                000130 constant        entry                    external dcl 257 ref 410 546
dm_misc_util_$get_system_dir    000132 constant        entry                    external dcl 257 ref 805
dm_misc_util_$is_process_using_dm
                                000134 constant        entry                    external dcl 257 ref 767
dm_misc_util_$log               000122 constant        entry                    external dcl 257 ref 945 946 969 982
dm_system_config                       based           structure                level 1 dcl 5-36
dm_system_config_info                  based           structure                level 1 dcl 5-42
dm_system_config_ptr            000602 automatic       pointer                  dcl 5-34 set ref 387* 401* 402 405* 406* 513* 562*
                                                                                  563* 565* 675* 679* 684* 930 1072 1075* 1078*
dm_system_copyp                 000252 automatic       pointer                  dcl 193 set ref 386* 466* 481 485* 506 1049 1050*
                                                                                  1051*
dm_system_data_$                000214 external static fixed bin(17,0)          dcl 319 set ref 641
dm_system_data_$area_rel        000216 external static bit(18)                  dcl 319 set ref 497* 504 506 641
dm_system_data_$bootload_time   000230 external static fixed bin(71,0)          dcl 319 set ref 493*
dm_system_data_$current_dm_state
                                000220 external static char(4)                  dcl 319 set ref 491* 517 531 531 531 539* 587 587
                                                                                  587 634 634 634 666 666 705 705 705 866* 960*
dm_system_data_$initialization_time
                                000234 external static fixed bin(71,0)          dcl 319 set ref 492*
dm_system_data_$initialized     000222 external static bit(1)                   dcl 319 set ref 538*
dm_system_data_$initializer_event_chn
                                000232 external static fixed bin(71,0)          dcl 319 set ref 496* 977*
dm_system_data_$initializer_name
                                000224 external static char(32)                 unaligned dcl 319 set ref 495* 946* 978*
dm_system_data_$initializer_processid
                                000226 external static bit(36)                  dcl 319 set ref 494* 946* 979*
dm_system_data_$saved_begin_shutdown_time
                                000236 external static fixed bin(71,0)          dcl 319 set ref 961 962*
dm_system_data_$saved_daemon_logout_time
                                000240 external static fixed bin(71,0)          dcl 319 set ref 962*
dm_system_data_$saved_shutdown_reason
                                000250 external static char(64)                 dcl 319 set ref 967*
dm_system_data_$saved_user_bump_time
                                000242 external static fixed bin(71,0)          dcl 319 set ref 962*
dm_system_data_$saved_user_shutdown_time
                                000244 external static fixed bin(71,0)          dcl 319 set ref 962*
dm_system_data_$saved_user_warning_time
                                000246 external static fixed bin(71,0)          dcl 319 set ref 962*
dm_system_data_template_$       000212 external static fixed bin(17,0)          dcl 319 set ref 473
dm_system_data_template_ptr     000254 automatic       pointer                  dcl 193 set ref 385* 473* 474* 481
dms_initializer_process         000010 internal static bit(1)                   initial dcl 360 set ref 389* 424* 568* 663 686* 837*
                                                                                  837* 1054 1059*
enabled_bootload_dir_name       000256 automatic       char(32)                 unaligned dcl 193 set ref 410* 411* 416* 416* 546*
                                                                                  554* 556*
entrypoint_name                 000266 automatic       varying char(32)         dcl 193 set ref 383* 524* 579* 627* 659* 700* 737*
                                                                                  762* 793* 828* 847* 1119*
er_arg_list_ptr                 000100 automatic       pointer                  dcl 1102 set ref 1114* 1115 1117*
er_code                         000102 automatic       fixed bin(35,0)          dcl 1102 set ref 1115* 1119*
er_fixed_bin_35_value                  based           fixed bin(35,0)          dcl 1109 ref 1115
er_message                      000103 automatic       char(1024)               unaligned dcl 1102 set ref 1117* 1119
er_message_length               000503 automatic       fixed bin(21,0)          dcl 1102 set ref 1117* 1119 1119
er_message_overlay                     based           char                     unaligned dcl 1109 set ref 1119*
error_table_$namedup            000252 external static fixed bin(35,0)          dcl 319 ref 436
error_table_$segknown           000254 external static fixed bin(35,0)          dcl 319 ref 468 940
error_table_$unimplemented_version
                                000256 external static fixed bin(35,0)          dcl 319 set ref 1132*
expand_pathname_                000136 constant        entry                    external dcl 257 ref 743 773
fi_p_config_lock_action                parameter       bit(1)                   dcl 1070 ref 1068 1072
gbdn_p_is_process_initializing_dms     parameter       bit(1)                   dcl 1010 ref 998 1023
gbdn_time_of_multics_bootload   000100 automatic       fixed bin(71,0)          dcl 1012 set ref 1017* 1018*
get_authorization_              000140 constant        entry                    external dcl 257 ref 804 804
get_group_id_$tag_star          000142 constant        entry                    external dcl 257 ref 495 946 946 978
get_process_id_                 000144 constant        entry                    external dcl 257 ref 494 946 946 979
get_ring_                       000146 constant        entry                    external dcl 257 ref 393 393 425 552 552 598 602 602
                                                                                  718 718
hcs_$append_branchx             000150 constant        entry                    external dcl 257 ref 434 444 459 604
hcs_$chname_file                000152 constant        entry                    external dcl 257 ref 554
hcs_$initiate                   000154 constant        entry                    external dcl 257 ref 466 610 720 895 938
hcs_$set_bc_seg                 000156 constant        entry                    external dcl 257 ref 485
hcs_$status_minf                000160 constant        entry                    external dcl 257 ref 411 748 779 813
hcs_$status_mins                000162 constant        entry                    external dcl 257 ref 474
hcs_$validate_processid         000164 constant        entry                    external dcl 257 ref 902
information                            based           structure                level 2 dcl 5-36
initialization_bootload_dir_name
                                000277 automatic       char(32)                 unaligned dcl 193 set ref 432* 434* 437* 439* 439*
                                                                                  444* 447* 447* 547* 554* 554* 556* 556*
initialization_bootload_directory
                                000307 automatic       char(168)                unaligned dcl 193 set ref 452* 459* 461* 466* 468*
                                                                                  468* 486* 486* 509* 509*
ioa_$general_rs                 000166 constant        entry                    external dcl 257 ref 1117
level                           000361 automatic       fixed bin(17,0)          dcl 193 set ref 391* 550* 600* 716* 1032*
local_area_info                 000362 automatic       structure                level 1 dcl 193 set ref 500* 508 508
multics_bootload_request_id_str 000011 internal static char(17)                 initial unaligned dcl 360 set ref 1016 1018* 1023
                                                                                  1025
n_words                         000406 automatic       fixed bin(18,0)          dcl 193 set ref 480* 481 481 497 632* 648
null                                                   builtin function         dcl 229 ref 385 386 387 585 631 712 722 891 897 938
                                                                                  938 991 1049 1051 1072 1119 1119
old_dm_system_data_$current_dm_state
                                000264 external static char(4)                  dcl 319 ref 911 911 911 918 923
old_dm_system_data_$initializer_name
                                000262 external static char(32)                 unaligned dcl 319 set ref 904*
old_dm_system_data_$initializer_processid
                                000260 external static bit(36)                  dcl 319 set ref 902* 904*
owner                     2     000362 automatic       char(32)                 level 2 packed unaligned dcl 193 set ref 503*
p_aim_directory                        parameter       char                     unaligned dcl 178 set ref 790 806* 818*
p_block_ptr                            parameter       pointer                  dcl 178 set ref 624 631* 650*
p_bootload_dir                         parameter       char                     unaligned dcl 178 set ref 825 837*
p_initializer_event_channel            parameter       fixed bin(71,0)          dcl 178 set ref 172 416* 496
p_n_words                              parameter       fixed bin(18,0)          dcl 178 set ref 624 632 643*
p_new_system_state                     parameter       char(4)                  dcl 178 ref 857 866
p_reference_name                       parameter       char                     unaligned dcl 178 set ref 697 720* 722*
p_seg_ptr                              parameter       pointer                  dcl 178 set ref 576 585* 618* 697 712* 720* 722
p_segment_name                         parameter       char                     unaligned dcl 178 set ref 576 584 697 720* 722* 722*
p_system_directory                     parameter       char                     unaligned dcl 178 set ref 734 753* 759 767* 772
pathname_                       000170 constant        entry                    external dcl 257 ref 416 416 439 439 447 447 468 468
                                                                                  486 486 509 509 556 556 606 606 612 612 722 722
                                                                                  780 806 814 814 818 837
prev_dm_disp             74            based           structure                level 3 dcl 5-36
ptr                                                    builtin function         dcl 229 ref 506 641
request_id_                     000172 constant        entry                    external dcl 257 ref 1018
ring_brackets                   000407 automatic       fixed bin(3,0)           array dcl 193 set ref 425* 425* 425* 434* 444* 459*
                                                                                  598* 598* 598* 604*
seg_array                              based           bit(36)                  array dcl 223 set ref 481* 481
seg_ptr                         000412 automatic       pointer                  dcl 193 set ref 610* 618
segname                         000414 automatic       char(32)                 unaligned dcl 193 set ref 584* 604* 606* 606* 610*
                                                                                  612* 612*
size                     13     000362 automatic       fixed bin(18,0)          level 2 dcl 193 set ref 504*
sub_err_                        000174 constant        entry                    external dcl 257 ref 1119
sub_error_                      000574 stack reference condition                dcl 233 ref 671 677 681 690 1074 1076 1079
substr                                                 builtin function         dcl 229 ref 1018
sys_info$max_seg_size           000266 external static fixed bin(19,0)          dcl 319 ref 504
system_dir                      000424 automatic       char(168)                unaligned dcl 193 set ref 772* 773* 774* 782* 805*
                                                                                  806* 813* 814* 814* 818*
system_dir_in_static            000016 internal static char(168)                initial unaligned dcl 360 set ref 743* 744* 749* 753
                                                                                  780*
system_info_$timeup             000176 constant        entry                    external dcl 257 ref 493 1017
tdst_old_dm_system_data_ptr     000100 automatic       pointer                  initial dcl 891 set ref 891* 895* 897 991 991*
tdst_p_new_event_channel               parameter       fixed bin(71,0)          dcl 886 ref 872 977
tdst_p_old_bootload_directory          parameter       char                     unaligned dcl 886 set ref 872 895* 897* 904* 923*
                                                                                  930* 938* 940* 946*
temp_dir                        000476 automatic       char(168)                unaligned dcl 193 set ref 743* 748* 773* 779* 780*
temp_dir_name                   000550 automatic       char(32)                 unaligned dcl 193 set ref 743* 748* 773* 779* 780*
term_$seg_ptr                   000200 constant        entry                    external dcl 257 ref 991
term_$single_refname            000202 constant        entry                    external dcl 257 ref 984
transaction_manager_$begins_on  000204 constant        entry                    external dcl 257 ref 974
unspec                                                 builtin function         dcl 229 set ref 481* 481 500*
version                                based           char(8)                  level 3 in structure "dm_system_config" dcl 5-36
                                                                                  in procedure "dm_per_system_$init" set ref 402*
version                         000362 automatic       fixed bin(17,0)          level 2 in structure "local_area_info" dcl 193
                                                                                  in procedure "dm_per_system_$init" set ref 501*
zero_on_alloc             1(01) 000362 automatic       bit(1)                   level 3 packed unaligned dcl 193 set ref 502*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 7-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 7-7
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
CRASH_SV                               internal static fixed bin(17,0)          initial dcl 3-34
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
DM_ADOPT_OLD_BOOTLOAD                  internal static char(8)                  initial dcl 5-63
DM_DO_NOT_FORCE_ENABLE_NEW_BOOTLOAD    internal static char(8)                  initial dcl 5-63
DM_DO_NOT_HOLD_OLD_BOOTLOAD_DIRECTORY  internal static char(8)                  initial dcl 5-63
DM_DO_NOT_RECOVER_OLD_BOOTLOAD         internal static char(8)                  initial dcl 5-63
DM_FORCE_ENABLE_NEW_BOOTLOAD           internal static char(8)                  initial dcl 5-63
DM_HOLD_OLD_BOOTLOAD_DIRECTORY         internal static char(8)                  initial dcl 5-63
DM_RECOVERY_CHECK_MODE_OFF             internal static char(8)                  initial dcl 5-63
DM_RECOVERY_CHECK_MODE_ON              internal static char(8)                  initial dcl 5-63
DM_RECOVER_OLD_BOOTLOAD                internal static char(8)                  initial dcl 5-63
DM_SYSTEM_STATE_RECOVERING             internal static char(4)                  initial dcl 4-22
ERROR_SV                               internal static fixed bin(17,0)          initial dcl 3-36
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Envptr_supplied_call_type              internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-29
FATAL_SV                               internal static fixed bin(17,0)          initial dcl 3-34
INFORM_SV                              internal static fixed bin(17,0)          initial dcl 3-38
Interseg_call_type                     internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-29
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
PRINT_SV                               internal static fixed bin(17,0)          initial dcl 3-32
QUERY_SV                               internal static fixed bin(17,0)          initial dcl 3-32
Quick_call_type                        internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-29
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
area_infop                             automatic       pointer                  dcl 2-5
arg_list_with_envptr                   based           structure                level 1 dcl 6-17
dm_system_data_$command_ms_name        external static char(32)                 unaligned dcl 319

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   007275 constant        entry                    internal dcl 1125 ref 402
CLEANUP_PROC_DONE               004213 constant        label                    dcl 692 ref 671 681
CLEANUP_PROC_TERM_CONFIG_FILE   004120 constant        label                    dcl 681 ref 677
CLEAN_UP_INIT                   006672 constant        entry                    internal dcl 1038 ref 392
ERROR_RETURN                    007131 constant        entry                    internal dcl 1099 ref 439 447 461 468 475 486 509
                                                                                  531 556 587 606 612 634 643 666 705 722 744 749
                                                                                  767 774 782 814 897 904 923 930 940 1132
FINISH_INIT                     007022 constant        entry                    internal dcl 1068 ref 419 515 1062
FI_CANT_TERM_CONFIG             007117 constant        label                    dcl 1079 ref 1076
FI_TERM_CONFIG                  007070 constant        label                    dcl 1076 ref 1074
GET_BOOTLOAD_DIR_NAME           006567 constant        entry                    internal dcl 998 ref 432 547 686 837 837 853 1055
MAIN_RETURN                     005636 constant        label                    dcl 1096 ref 1092
MAY_BOOT_AFTER_NORMAL_SHUT      006106 constant        label                    dcl 918
NON_SYSTEM_LOW_PROCESS          005314 constant        label                    dcl 810
NO_DMS_TO_TAKEOVER              006104 constant        label                    dcl 911
RESET_SHUTDOWN_INFO             006412 constant        label                    dcl 952
RESET_VALIDATION_LEVEL          006655 constant        entry                    internal dcl 1029 ref 551 570 601 617 717 728 1083
RETURN                          007126 constant        entry                    internal dcl 1089 ref 572 620 652 663 692 730 755
                                                                                  786 821 840 868
SYSTEM_LOW_PROCESS              005261 constant        label                    dcl 806
TDST_CLEANUP                    006545 constant        entry                    internal dcl 988 ref 893
TRY_DM_SYSTEM_TAKEOVER          005651 constant        entry                    internal dcl 872 ref 416
dm_per_system_$alloc            003624 constant        entry                    external dcl 624
dm_per_system_$cleanup          003762 constant        entry                    external dcl 656
dm_per_system_$create           003175 constant        entry                    external dcl 576
dm_per_system_$enable           002662 constant        entry                    external dcl 521
dm_per_system_$get_aim_dir      005176 constant        entry                    external dcl 790
dm_per_system_$get_bootload_dir 005453 constant        entry                    external dcl 825
dm_per_system_$get_enabled_bootload_dirname
                                005552 constant        entry                    external dcl 844
dm_per_system_$get_system_dir   004526 constant        entry                    external dcl 734
dm_per_system_$init             001214 constant        entry                    external dcl 172
dm_per_system_$initiate         004221 constant        entry                    external dcl 697
dm_per_system_$set_system_dir   004723 constant        entry                    external dcl 759
dm_per_system_$set_system_state 005622 constant        entry                    external dcl 857

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11010       11300    7354       11020
Length     12112    7354       270         575    1434          60

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dm_per_system_$init                 572 external procedure  is an external procedure.  
on unit on line 392                 164 on unit               
on unit on line 551                  64 on unit               
on unit on line 601                  64 on unit               
on unit on line 643                 100 on unit               
on unit on line 671                  64 on unit               
on unit on line 677                  64 on unit               
on unit on line 681                  64 on unit               
on unit on line 717                  64 on unit               
TRY_DM_SYSTEM_TAKEOVER              171 internal procedure  enables or reverts conditions.  
on unit on line 893                  78 on unit               
TDST_CLEANUP                            internal procedure  shares stack frame of on unit on line 893.  
GET_BOOTLOAD_DIR_NAME                82 internal procedure  is called by several nonquick procedures.  
RESET_VALIDATION_LEVEL               68 internal procedure  is called by several nonquick procedures.  
CLEAN_UP_INIT                           internal procedure  shares stack frame of on unit on line 392.  
FINISH_INIT                          74 internal procedure  enables or reverts conditions.  
on unit on line 1074                 64 on unit               
on unit on line 1076                 64 on unit               
RETURN                                  internal procedure  shares stack frame of external procedure dm_per_system_$init.  
ERROR_RETURN                        396 internal procedure  is declared options(variable).  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure dm_per_system_$init.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 dms_initializer_process     dm_per_system_$init
000011 multics_bootload_request_id_str
                                   dm_per_system_$init
000016 system_dir_in_static        dm_per_system_$init

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ERROR_RETURN             000100 er_arg_list_ptr             ERROR_RETURN
                         000102 er_code                     ERROR_RETURN
                         000103 er_message                  ERROR_RETURN
                         000503 er_message_length           ERROR_RETURN
GET_BOOTLOAD_DIR_NAME    000100 gbdn_time_of_multics_bootload
                                                            GET_BOOTLOAD_DIR_NAME
TRY_DM_SYSTEM_TAKEOVER   000100 tdst_old_dm_system_data_ptr TRY_DM_SYSTEM_TAKEOVER
dm_per_system_$init      000100 aim_dir                     dm_per_system_$init
                         000152 aim_dir_name                dm_per_system_$init
                         000162 areap                       dm_per_system_$init
                         000164 block_ptr                   dm_per_system_$init
                         000166 bit_count                   dm_per_system_$init
                         000167 bootload_dir_name           dm_per_system_$init
                         000177 code                        dm_per_system_$init
                         000200 current_bootload_directory  dm_per_system_$init
                         000252 dm_system_copyp             dm_per_system_$init
                         000254 dm_system_data_template_ptr dm_per_system_$init
                         000256 enabled_bootload_dir_name   dm_per_system_$init
                         000266 entrypoint_name             dm_per_system_$init
                         000277 initialization_bootload_dir_name
                                                            dm_per_system_$init
                         000307 initialization_bootload_directory
                                                            dm_per_system_$init
                         000361 level                       dm_per_system_$init
                         000362 local_area_info             dm_per_system_$init
                         000406 n_words                     dm_per_system_$init
                         000407 ring_brackets               dm_per_system_$init
                         000412 seg_ptr                     dm_per_system_$init
                         000414 segname                     dm_per_system_$init
                         000424 system_dir                  dm_per_system_$init
                         000476 temp_dir                    dm_per_system_$init
                         000550 temp_dir_name               dm_per_system_$init
                         000602 dm_system_config_ptr        dm_per_system_$init
on unit on line 392      000106 cui_initialization_bootload_dir
                                                            CLEAN_UP_INIT

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc
call_int_other      return              tra_ext             signal              enable              ext_entry
ext_entry_desc      int_entry           int_entry_desc      alloc_based         clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
convert_access_class_$encode  cu_$arg_list_ptr              cu_$level_get                 cu_$level_set
define_area_                  delete_$path                  delete_$ptr                   dm_check_configuration_
dm_find_configuration_        dm_find_configuration_$terminate                            dm_load_configuration_
dm_lock_configuration_        dm_lock_configuration_$unlock dm_misc_util_$get_aim_dir
dm_misc_util_$get_bootload_dir                              dm_misc_util_$get_enabled_bootload_dirname
dm_misc_util_$get_system_dir  dm_misc_util_$is_process_using_dm                           dm_misc_util_$log
expand_pathname_              get_authorization_            get_group_id_$tag_star        get_process_id_
get_ring_                     hcs_$append_branchx           hcs_$chname_file              hcs_$initiate
hcs_$set_bc_seg               hcs_$status_minf              hcs_$status_mins              hcs_$validate_processid
ioa_$general_rs               pathname_                     request_id_                   sub_err_
system_info_$timeup           term_$seg_ptr                 term_$single_refname
transaction_manager_$begins_on

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$area_overflow       dm_error_$per_system_not_init dm_system_data_$              dm_system_data_$area_rel
dm_system_data_$bootload_time dm_system_data_$current_dm_state
dm_system_data_$initialization_time                         dm_system_data_$initialized
dm_system_data_$initializer_event_chn                       dm_system_data_$initializer_name
dm_system_data_$initializer_processid                       dm_system_data_$saved_begin_shutdown_time
dm_system_data_$saved_daemon_logout_time                    dm_system_data_$saved_shutdown_reason
dm_system_data_$saved_user_bump_time                        dm_system_data_$saved_user_shutdown_time
dm_system_data_$saved_user_warning_time                     dm_system_data_template_$     error_table_$namedup
error_table_$segknown         error_table_$unimplemented_version
old_dm_system_data_$current_dm_state                        old_dm_system_data_$initializer_name
old_dm_system_data_$initializer_processid                   sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    172 001210       383 001223       385 001227       386 001231       387 001232       389 001233       391 001234
    392 001242       393 001260       395 001300       401 001311       402 001320       405 001345       406 001354
    410 001363       411 001372       413 001432       416 001434       419 001500       420 001506       424 001530
    425 001533       432 001545       434 001555       436 001630       437 001634       439 001665       444 001732
    447 002005       452 002052       459 002063       461 002136       466 002167       468 002230       473 002303
    474 002306       475 002323       480 002350       481 002354       485 002362       486 002375       491 002442
    492 002445       493 002450       494 002456       495 002470       496 002476       497 002502       500 002514
    501 002517       502 002521       503 002523       504 002526       506 002534       508 002540       509 002552
    513 002617       515 002626       517 002634       521 002661       524 002671       531 002676       538 002730
    539 002733       541 002735       546 002745       547 002754       550 002764       551 002773       552 003015
    554 003035       556 003063       562 003134       563 003143       565 003152       568 003161       570 003163
    572 003167       576 003170       579 003215       584 003222       585 003230       587 003232       595 003264
    598 003275       600 003310       601 003317       602 003341       604 003361       606 003433       610 003500
    612 003543       617 003610       618 003614       620 003616       624 003617       627 003633       631 003640
    632 003643       634 003645       641 003677       643 003705       648 003750       650 003755       652 003757
    656 003760       659 003771       663 003776       666 004003       671 004033       673 004052       675 004063
    677 004072       679 004111       681 004120       684 004137       686 004146       687 004157       690 004212
    692 004213       697 004214       700 004246       705 004253       712 004305       714 004307       716 004320
    717 004327       718 004351       720 004371       722 004436       728 004515       730 004521       734 004522
    737 004543       743 004550       744 004574       748 004622       749 004662       753 004710       755 004717
    759 004720       762 004740       767 004745       772 005005       773 005013       774 005037       779 005064
    780 005124       782 005147       786 005172       790 005173       793 005213       804 005220       805 005244
    806 005255       813 005314       814 005354       818 005421       821 005447       825 005450       828 005470
    835 005475       837 005506       840 005545       844 005546       847 005560       853 005565       857 005617
    866 005631       868 005635      1096 005636      1154 005647       872 005650       891 005664       893 005666
    895 005704       897 005752       902 006017       904 006031       911 006074       918 006104       923 006112
    930 006145       938 006202       940 006250       945 006312       946 006327       960 006412       961 006415
    962 006417       967 006425       969 006431       974 006450       977 006455       978 006461       979 006467
    982 006501       984 006520       986 006541       988 006545       991 006546       994 006565       998 006566
   1016 006574      1017 006600      1018 006606      1023 006626      1025 006647      1029 006654      1032 006662
   1034 006671      1038 006672      1049 006673      1050 006700      1051 006730      1054 006733      1055 006737
   1057 006753      1059 007007      1062 007011      1064 007020      1068 007021      1072 007027      1074 007041
   1075 007060      1076 007070      1078 007107      1079 007117      1083 007120      1085 007125      1089 007126
   1092 007127      1099 007130      1114 007136      1115 007144      1117 007147      1119 007212      1123 007274
   1125 007275      1132 007306      1137 007353


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
