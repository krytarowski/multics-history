	COMPILATION LISTING OF SEGMENT load
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-05-05_1826.10_Fri_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* Procedure to generate instructions to load a value
       12*
       13*   Initial Version: 23 September 1971 by BLW
       14*	Modified:  5 November 1972 by BLW
       15*	Modified:	15 February 1973 by RAB
       16*	Modified:	22 June 1973 by RAB for EIS
       17*	Modified:	15 June 1976 by RAB to fix 1502
       18*	Modified:	19 March 1977 by RAB for aq_man$left_shift
       19*	Modified: 16 July 1978 by PCK for unsigned binary
       20*	Modified:	9 December 1978 by RAB to fix 1803 (faults on get list(picture);)
       21*	Modified:	17 July 1979 by RAB to check for load(decimal_value,...).
       22**/
       23 
       24 load:	proc(pt,control);
       25 
       26 dcl	pt ptr,		/* points at reference node */
       27 	control fixed bin;	/* non-zero if negative should be loaded */
       28 
       29 dcl	(p,q) ptr,
       30 	(i,n,type,size,d,dt,k,aq_length,units,cfo) fixed bin,
       31 	offset fixed bin(8),
       32 	(mac,macro,shift) fixed bin(15),
       33 	mask bit(72) aligned,
       34 	(fs,ft,arith,available) bit(1) aligned,
       35 	for_save bit(1) aligned init("0"b),
       36 	cg_stat$cur_statement ptr ext static,
       37 	error entry(fixed bin,ptr,ptr),
       38 	c_a entry(fixed bin,fixed bin) returns(ptr),
       39 	generate_constant entry(bit(*) aligned,fixed bin) returns(ptr),
       40 	stack_temp$free_temp entry(ptr),
       41 	(long_op,long_op$c_or_b) entry(ptr,fixed bin,fixed bin(15)),
       42 	(xr_man$load_var,adjust_ref_count) entry(ptr,fixed bin),
       43 	xr_man$load_const entry(fixed bin,fixed bin),
       44 	aq_man$trim_aq entry(fixed bin),
       45 	aq_man$left_shift entry(fixed bin(8),bit(1) aligned),
       46 	save_value entry(ptr),
       47 	make_n_addressable entry(ptr,fixed bin),
       48 	get_reference entry() returns(ptr),
       49 	state_man$erase_reg entry(bit(19) aligned),
       50 	expmac$two_eis entry(fixed bin(15),ptr,ptr),
       51 	expmac$one entry(fixed bin(15),ptr,fixed bin),
       52 	expmac$zero entry(fixed bin(15)),
       53 	expmac entry(fixed bin(15),ptr);
       54 
       55 dcl	(addr,bit,fixed,mod,null,substr) builtin;
       56 
       57 dcl (	ldfx1		init(7),
       58 	ldfx2		init(8),
       59 	negate_op(4)	init(255,38,39,39),
       60 	testfx1		init(508),
       61 	test_lda		init(332),
       62 	cana		init(323),
       63 	lda		init(1),
       64 	als		init(134),
       65 	lls		init(63),
       66 	anaq		init(42),
       67 	lrl		init(62),
       68 	lrs		init(492),
       69 	unpack_fl1	init(486),
       70 	unpack_cfl1	init(488),
       71 	clear_aq		init(58),
       72 	move_cs_load_1	init(100),
       73 	set_chars		init(436),
       74 	load_logical	init(380)) fixed bin(15) int static;
       75 
       76 dcl	operator_table	init(262046) fixed bin(18) int static;	/* = 262144 - 98 */
       77 
  1     1 /* BEGIN INCLUDE FILE ... cgsystem.incl.pl1 */
  1     2 
  1     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
  1     4 
  1     5 dcl (	bits_per_char		init(9),
  1     6 	bits_per_half		init(18),
  1     7 	bits_per_word		init(36),
  1     8 	bits_per_two_words		init(72),
  1     9 	bits_per_four_words		init(144),
  1    10 	bits_per_words(2)		init(36,72),
  1    11 	packed_digits_per_char	init(2),
  1    12 	chars_per_word		init(4),
  1    13 	packed_digits_per_word	init(8),
  1    14 
  1    15 	break_even_bits		init(216),
  1    16 	break_even_words		init(6),
  1    17 
  1    18 	label_size		init(4),
  1    19 
  1    20 	convert_size(13:14)		init(9,1),
  1    21 	max_offset(13:14)		init(27,35),
  1    22 	max_short_size(13:14)	init(8,72),
  1    23 
  1    24 	units_per_word(0:5)		init(1,36,8,4,2,1),
  1    25 
  1    26 	max_dec_scale		init(32),
  1    27 	min_dec_scale		init(-31),
  1    28 	max_p_xreg		init(18),
  1    29 	max_p_fix_bin_1		init(35),
  1    30 	max_p_flt_bin_1		init(27),
  1    31 	max_p_fix_dec		init(59),
  1    32 	max_length_p		init(24),
  1    33 	default_fix_bin_p		init(17)) fixed bin(8) int static options(constant);
  1    34 
  1    35 dcl      (convert_offset(0:5)		init(36,1,4.5,9,18,36),
  1    36 	bits_per_packed_digit	init(4.5)) fixed bin(8,1) int static options(constant);
  1    37 
  1    38 dcl	max_index_register_value	init(262143) fixed bin(31) int static options(constant);
  1    39 
  1    40 /* END INCLUDE FILE ... cgsystem.incl.pl1 */
  1    41 
       78 
  2     1 /* BEGIN INCLUDE FILE ... cg_reference.incl.pl1 */
  2     2 
  2     3 dcl	1 reference		based aligned,
  2     4 	2 node_type		bit(9) unaligned,
  2     5 	2 array_ref		bit(1) unaligned,
  2     6 	2 varying_ref		bit(1) unaligned,
  2     7 	2 shared			bit(1) unaligned,
  2     8 	2 put_data_sw		bit(1) unaligned,
  2     9 	2 processed		bit(1) unaligned,
  2    10 	2 units			fixed(3) unaligned,
  2    11 	2 ref_count		fixed(17) unaligned,
  2    12 	2 c_offset		fixed(24),
  2    13 	2 c_length		fixed(24),
  2    14 	2 symbol			ptr unaligned,
  2    15 	2 qualifier		ptr unaligned,
  2    16 	2 offset			ptr unaligned,
  2    17 	2 length			ptr unaligned,
  2    18 						/* these fields are used by the 645 code generator */
  2    19 	2 c_f_offset		fixed bin(6),
  2    20 	2 address			structure unaligned,
  2    21 	  3 base			bit(3),
  2    22 	  3 offset		bit(15),
  2    23 	  3 op			bit(9),
  2    24 	  3 no_address		bit(1),
  2    25 	  3 inhibit		bit(1),
  2    26 	  3 ext_base		bit(1),
  2    27 	  3 tag			bit(6),
  2    28 	2 info			structure unaligned,
  2    29 	  3 address_in		structure,
  2    30 	    4 b			dimension(0:7) bit(1),
  2    31 	    4 storage		bit(1),
  2    32 	  3 value_in		structure,
  2    33 	    4 a			bit(1),
  2    34 	    4 q			bit(1),
  2    35 	    4 aq			bit(1),
  2    36 	    4 string_aq		bit(1),
  2    37 	    4 complex_aq		bit(1),
  2    38 	    4 decimal_aq		bit(1),
  2    39 	    4 b			dimension(0:7) bit(1),
  2    40 	    4 storage		bit(1),
  2    41 	    4 indicators		bit(1),
  2    42 	    4 x			dimension(0:7) bit(1),
  2    43 	  3 other			structure,
  2    44 	    4 big_offset		bit(1),
  2    45 	    4 big_length		bit(1),
  2    46 	    4 modword_in_offset	bit(1),
  2    47 	2 data_type		fixed(5) unaligned,
  2    48 	2 bits			structure unaligned,
  2    49 	  3 padded_ref		bit(1),
  2    50 	  3 aligned_ref		bit(1),
  2    51 	  3 long_ref		bit(1),
  2    52 	  3 forward_ref		bit(1),
  2    53 	  3 ic_ref		bit(1),
  2    54 	  3 temp_ref		bit(1),
  2    55 	  3 defined_ref		bit(1),
  2    56 	  3 evaluated		bit(1),
  2    57 	  3 allocate		bit(1),
  2    58 	  3 allocated		bit(1),
  2    59 	  3 aliasable		bit(1),
  2    60 	  3 even			bit(1),
  2    61 	  3 perm_address		bit(1),
  2    62 	  3 aggregate		bit(1),
  2    63 	  3 hit_zero		bit(1),
  2    64 	  3 dont_save		bit(1),
  2    65 	  3 fo_in_qual		bit(1),
  2    66 	  3 hard_to_load		bit(1),
  2    67 	2 relocation		bit(12) unaligned,
  2    68 	2 more_bits		structure unaligned,
  2    69 	  3 substr		bit(1),
  2    70 	  3 padded_for_store_ref	bit(1),
  2    71 	  3 aligned_for_store_ref	bit(1),
  2    72 	  3 mbz			bit(15),
  2    73 	2 store_ins		bit(18) unaligned;
  2    74 
  2    75 /* END INCLUDE FILE ... cg_reference.incl.pl1 */
       79 
  3     1 dcl (	real_fix_bin_1		init(1),
  3     2 	real_fix_bin_2		init(2),
  3     3 	real_flt_bin_1		init(3),
  3     4 	real_flt_bin_2		init(4),
  3     5 	complex_fix_bin_1		init(5),
  3     6 	complex_fix_bin_2		init(6),
  3     7 	complex_flt_bin_1		init(7),
  3     8 	complex_flt_bin_2		init(8),
  3     9 	real_fix_dec		init(9),
  3    10 	real_flt_dec		init(10),
  3    11 	complex_fix_dec		init(11),
  3    12 	complex_flt_dec		init(12),
  3    13 	char_string		init(13),
  3    14 	bit_string		init(14),
  3    15 	label_constant		init(15),
  3    16 	local_label_variable	init(16),
  3    17 	label_variable		init(17),
  3    18 	entry_variable		init(18),
  3    19 	ext_entry_in		init(19),
  3    20 	ext_entry_out		init(20),
  3    21 	int_entry			init(21),
  3    22 	int_entry_other		init(22),
  3    23 	unpacked_ptr		init(23),
  3    24 	packed_ptr		init(24)) fixed bin(15) int static options(constant);
       80 
  4     1 /* BEGIN INCLUDE FILE ... machine_state.incl.pl1 */
  4     2 
  4     3 dcl	cg_static_$m_s_p ptr ext static,
  4     4 	m_s_p ptr init(cg_static_$m_s_p);
  4     5 
  4     6 dcl	1 machine_state	aligned based(m_s_p),
  4     7 	2 node_type	bit(9),
  4     8 	2 indicators	fixed bin,
  4     9 	2 next		ptr unal,
  4    10 	2 a_reg,
  4    11 	  3 variable(10)	ptr unal,
  4    12 	  3 number	fixed bin(17),
  4    13 	  3 size		fixed bin(8),
  4    14 	  3 length	fixed bin(8),
  4    15 	  3 offset	fixed bin(8),
  4    16 	  3 constant	fixed bin(24),
  4    17 	  3 changed	fixed bin(18),
  4    18 	  3 instruction	bit(36),
  4    19 	  3 locked	bit(1) aligned,
  4    20 	  3 number_h_o	fixed bin,
  4    21 	  3 has_offset(3)	ptr unal,
  4    22 	2 q_reg,
  4    23 	  3 variable(10)	ptr unal,
  4    24 	  3 number	fixed bin(17),
  4    25 	  3 size		fixed bin(8),
  4    26 	  3 length	fixed bin(8),
  4    27 	  3 offset	fixed bin(8),
  4    28 	  3 constant	fixed bin(24),
  4    29 	  3 changed	fixed bin(18),
  4    30 	  3 instruction	bit(36),
  4    31 	  3 locked	bit(1) aligned,
  4    32 	  3 number_h_o	fixed bin,
  4    33 	  3 has_offset(3)	ptr unal,
  4    34 	2 string_reg,
  4    35 	  3 variable	ptr unal,
  4    36 	  3 size		fixed bin(8),
  4    37 	  3 offset	fixed bin(8),
  4    38 	2 complex_reg,
  4    39 	  3 variable	ptr unal,
  4    40 	  3 size		fixed bin(8),
  4    41 	  3 scale		fixed bin(8),
  4    42 	2 decimal_reg,
  4    43 	  3 variable	ptr unal,
  4    44 	  3 size		fixed bin(8),
  4    45 	  3 scale		fixed bin(8),
  4    46 	2 index_regs(0:7),
  4    47 	  3 variable	ptr unal,
  4    48 	  3 constant	fixed bin,
  4    49 	  3 type		fixed bin(8),
  4    50 	  3 used		fixed bin(18),
  4    51 	  3 changed	fixed bin(18),
  4    52 	  3 instruction	bit(36),
  4    53 	  3 filler	fixed bin,
  4    54 	2 base_regs(0:7),
  4    55 	  3 variable	ptr unal,
  4    56 	  3 constant	fixed bin,
  4    57 	  3 type		fixed bin(8),
  4    58 	  3 pad (12)	fixed bin,	/* future...room to make 5 element array for variable, constant, type */
  4    59 	  3 number	fixed bin (17),	/* future...number of valid elements in array */
  4    60 	  3 used		fixed bin(18),
  4    61 	  3 changed	fixed bin(18),
  4    62 	  3 instruction	bit(36),
  4    63 	  3 locked	fixed bin(2),
  4    64 	2 indicators_ref(2:3) ptr unal;
  4    65 
  4    66 /* Permissible values for machine_state.indicators. */
  4    67 
  4    68 dcl (	ind_known_refs	init (-2),		/* set by comparison of known, nonzero, references */
  4    69 	ind_invalid	init (-1),
  4    70 	ind_string_aq	init (0),			/* logical value in storage */
  4    71 	ind_logical	init (1),			/* logical value in A or AQ */
  4    72 	ind_arithmetic	init (2),			/* arith value in Q, AQ, or EAQ */
  4    73 	ind_x (0:7)	init (6, 7, 8, 9, 10, 11, 12, 13),
  4    74 	ind_decimal_reg	init (14)
  4    75 	) fixed bin internal static options (constant);
  4    76 
  4    77 /* END INCLUDE FILE ... machine_state.incl.pl1 */
       81 
  5     1 /* BEGIN INCLUDE FILE ... boundary.incl.pl1 */
  5     2 
  5     3 /* Modified: 26 Apr 1979 by PCK to implement 4-bit decimal */
  5     4 
  5     5 dcl (	bit_		init(1),
  5     6 	digit_		init(2),
  5     7 	character_	init(3),
  5     8 	half_		init(4),
  5     9 	word_		init(5),
  5    10 	mod2_		init(6),
  5    11 	mod4_		init(7)) fixed bin(3) int static options(constant);
  5    12 
  5    13 /* END INCLUDE FILE ... boundary.incl.pl1 */
       82 
  6     1 /* BEGIN INCLUDE FILE ... symbol.incl.pl1 */
  6     2 
  6     3 dcl	1 symbol			based aligned,
  6     4 	2 node_type		bit(9) unal,
  6     5 	2 source_id		structure unal,
  6     6 	  3 file_number		bit(8),
  6     7 	  3 line_number		bit(14),
  6     8 	  3 statement_number	bit(5),
  6     9 	2 location		fixed(18) unal unsigned,
  6    10 	2 allocated		bit(1) unal,
  6    11 	2 dcl_type		bit(3) unal,
  6    12 	2 reserved		bit(6) unal,
  6    13 	2 pix			unal,
  6    14 	  3 pic_fixed		bit(1) unal,
  6    15 	  3 pic_float		bit(1) unal,
  6    16 	  3 pic_char		bit(1) unal,
  6    17 	  3 pic_scale		fixed(7) unal,
  6    18 	  3 pic_size		fixed(7) unal,
  6    19 	2 level			fixed(8) unal,
  6    20 	2 boundary		fixed(3) unal,
  6    21 	2 size_units		fixed(3) unal,
  6    22 	2 scale			fixed(7) unal,
  6    23 	2 runtime			bit(18) unal,
  6    24 	2 runtime_offset		bit(18) unal,
  6    25 	2 block_node		ptr unal,
  6    26 	2 token			ptr unal,
  6    27 	2 next			ptr unal,
  6    28 	2 multi_use		ptr unal,
  6    29 	2 cross_references		ptr unal,
  6    30 	2 initial			ptr unal,
  6    31 	2 array			ptr unal,
  6    32 	2 descriptor		ptr unal,
  6    33 	2 equivalence		ptr unal,
  6    34 	2 reference		ptr unal,
  6    35 	2 general			ptr unal,
  6    36 	2 father			ptr unal,
  6    37 	2 brother			ptr unal,
  6    38 	2 son			ptr unal,
  6    39 	2 word_size		ptr unal,
  6    40 	2 bit_size		ptr unal,
  6    41 	2 dcl_size		ptr unal,
  6    42 	2 symtab_size		ptr unal,
  6    43 	2 c_word_size		fixed(24),
  6    44 	2 c_bit_size		fixed(24),
  6    45 	2 c_dcl_size		fixed(24),
  6    46 
  6    47 	2 attributes		structure aligned,
  6    48 	  3 data_type		structure unal,
  6    49 	    4 structure		bit(1) ,
  6    50 	    4 fixed		bit(1),
  6    51 	    4 float		bit(1),
  6    52 	    4 bit			bit(1),
  6    53 	    4 char		bit(1),
  6    54 	    4 ptr			bit(1),
  6    55 	    4 offset		bit(1),
  6    56 	    4 area		bit(1),
  6    57 	    4 label		bit(1),
  6    58 	    4 entry		bit(1),
  6    59 	    4 file		bit(1),
  6    60 	    4 arg_descriptor	bit(1),
  6    61 	    4 storage_block		bit(1),
  6    62 	    4 explicit_packed	bit(1), /* options(packed) */
  6    63 	    4 condition		bit(1),
  6    64 	    4 format		bit(1),
  6    65 	    4 builtin		bit(1),
  6    66 	    4 generic		bit(1),
  6    67 	    4 picture		bit(1),
  6    68 
  6    69 	  3 misc_attributes		structure unal,
  6    70 	    4 dimensioned		bit(1),
  6    71 	    4 initialed		bit(1),
  6    72 	    4 aligned		bit(1),
  6    73 	    4 unaligned		bit(1),
  6    74 	    4 signed		bit(1),
  6    75 	    4 unsigned		bit(1),
  6    76 	    4 precision		bit(1),
  6    77 	    4 varying		bit(1),
  6    78 	    4 local		bit(1),
  6    79 	    4 decimal		bit(1),
  6    80 	    4 binary		bit(1),
  6    81 	    4 real		bit(1),
  6    82 	    4 complex		bit(1),
  6    83 	    4 variable		bit(1),
  6    84 	    4 reducible		bit(1),
  6    85 	    4 irreducible		bit(1),
  6    86 	    4 returns		bit(1),
  6    87 	    4 position		bit(1),
  6    88 	    4 internal		bit(1),
  6    89 	    4 external		bit(1),
  6    90 	    4 like		bit(1),
  6    91 	    4 member		bit(1),
  6    92 	    4 non_varying		bit(1),
  6    93 	    4 options		bit(1),
  6    94 	    4 variable_arg_list 	bit(1),		/* options(variable) */
  6    95 	    4 alloc_in_text		bit(1),		/* options(constant) */
  6    96 
  6    97 	  3 storage_class		structure unal,
  6    98 	    4 auto		bit(1),
  6    99 	    4 based		bit(1),
  6   100 	    4 static		bit(1),
  6   101 	    4 controlled		bit(1),
  6   102 	    4 defined		bit(1),
  6   103 	    4 parameter		bit(1),
  6   104 	    4 param_desc		bit(1),
  6   105 	    4 constant		bit(1),
  6   106 	    4 temporary		bit(1),
  6   107 	    4 return_value		bit(1),
  6   108 
  6   109 	  3 file_attributes		structure unal,
  6   110 	    4 print		bit(1),
  6   111 	    4 input		bit(1),
  6   112 	    4 output		bit(1),
  6   113 	    4 update		bit(1),
  6   114 	    4 stream		bit(1),
  6   115 	    4 reserved_1		bit(1),
  6   116 	    4 record		bit(1),
  6   117 	    4 sequential		bit(1),
  6   118 	    4 direct		bit(1),
  6   119 	    4 interactive		bit(1),		/* env(interactive) */
  6   120 	    4 reserved_2		bit(1),
  6   121 	    4 reserved_3		bit(1),
  6   122 	    4 stringvalue		bit(1),		/* env(stringvalue) */
  6   123 	    4 keyed		bit(1),
  6   124 	    4 reserved_4		bit(1),
  6   125 	    4 environment		bit(1),
  6   126 
  6   127 	  3 compiler_developed	structure unal,
  6   128 	    4 aliasable		bit(1),
  6   129 	    4 packed		bit(1),
  6   130 	    4 passed_as_arg		bit(1),
  6   131 	    4 allocate		bit(1),
  6   132 	    4 set			bit(1),
  6   133 	    4 exp_extents		bit(1),
  6   134 	    4 refer_extents		bit(1),
  6   135 	    4 star_extents		bit(1),
  6   136 	    4 isub		bit(1),
  6   137 	    4 put_in_symtab		bit(1),
  6   138 	    4 contiguous		bit(1),
  6   139 	    4 put_data		bit(1),
  6   140 	    4 overlayed		bit(1),
  6   141 	    4 error		bit(1),
  6   142 	    4 symtab_processed	bit(1),
  6   143 	    4 overlayed_by_builtin	bit(1),
  6   144 	    4 defaulted		bit(1),
  6   145 	    4 connected		bit(1);
  6   146 
  6   147 /* END INCLUDE FILE ... symbol.incl.pl1 */
       83 
       84 
       85 	p = pt;
       86 
       87 begin:	available, fs, ft = "0"b;
       88 
       89 	type = p -> reference.data_type;
       90 
       91 l4:	if type = unpacked_ptr
       92 	then do;
       93 	     type = real_fix_bin_2;
       94 	     goto chk;
       95 	     end;
       96 
       97 	if type = packed_ptr
       98 	then do;
       99 	     mac = lrl;
      100 	     type = real_fix_bin_1;
      101 	     goto chk;
      102 	     end;
      103 
      104 	if type >= char_string
      105 	then do;
      106 	     arith = "0"b;
      107 	     goto string_;
      108 	     end;
      109 
      110 	if type >= real_fix_dec
      111 	then do;
      112 	     call error(374,cg_stat$cur_statement,p);
      113 	     return;
      114 	     end;
      115 
      116 	mac = lrs;
      117 	if p -> reference.symbol ^= null
      118 	then if p -> reference.symbol -> symbol.unsigned
      119 	     then mac = lrl;
      120 
      121 chk:	arith = "1"b;
      122 
      123 	if control ^= 0
      124 	then do;
      125 	     n = 3;
      126 	     if p -> reference.value_in.q
      127 	     then if type >= real_fix_bin_2 | (p -> reference.temp_ref & ^ p -> reference.value_in.storage)
      128 		then do;
      129 		     call adjust_ref_count(p,-1);
      130 		     call expmac$zero((negate_op(type)));
      131 		     return;
      132 		     end;
      133 	     end;
      134 	else do;
      135 	     n = -1;
      136 
      137 	     if p -> reference.value_in.q
      138 	     then do;
      139 		if ft
      140 		then if machine_state.indicators ^= 2
      141 		     then if (p -> reference.temp_ref & ^ p -> reference.value_in.storage) | ^ p -> reference.aligned_ref
      142 			then do;
      143 			     call expmac$zero(testfx1 + type - 1);
      144 			     machine_state.indicators = 2;
      145 			     end;
      146 			else go to l1;
      147 
      148 drop:		if ^ p -> reference.shared
      149 		     then call adjust_ref_count(p,-1);
      150 
      151 		if ^ p -> reference.long_ref
      152 		     then call sv_value;
      153 
      154 		return;
      155 		end;
      156 	     end;
      157 
      158 l1:	if ^ p -> reference.aligned_ref
      159 	then do;
      160 	     size = p -> reference.c_length;
      161 	     type = bit_string;
      162 	     if fs then goto l2; else goto str1;
      163 	     end;
      164 
      165 	if type = complex_flt_bin_1 then macro = ldfx2;
      166 	else macro = ldfx1 + n + type;
      167 
      168 	call expmac(macro,p);
      169 
      170 thru:	call sv_value;
      171 
      172 	if control = 0
      173 	then do;
      174 	     q_reg.variable(1) = p;
      175 	     q_reg.number = 1;
      176 	     machine_state.indicators = 2;
      177 	     p -> reference.value_in.q = "1"b;
      178 	     end;
      179 
      180 	return;
      181 
      182 	/* we have a bit or character string to be loaded */
      183 
      184 string_:	if p -> reference.long_ref
      185 	then do;
      186 
      187 lg:	     if p -> reference.value_in.string_aq
      188 		then goto drop;
      189 
      190 	     call long_op$c_or_b(p,0,(set_chars));
      191 
      192 	     string_reg.variable = p;
      193 	     string_reg.size = p -> reference.c_length;
      194 
      195 	     p -> reference.value_in.string_aq = "1"b;
      196 	     return;
      197 	     end;
      198 
      199 	size = p -> reference.c_length * convert_size(type);
      200 
      201 	if size = 0
      202 	then do;
      203 caq:	     call expmac$zero((clear_aq));
      204 	     goto l72;
      205 	     end;
      206 
      207 l2:	if p -> reference.value_in.a
      208 	then do;
      209 	     if ft
      210 	     then if machine_state.indicators ^= 1
      211 		then goto str1;
      212 
      213 	     if a_reg.size < size then goto str1;
      214 
      215 	     call adjust_ref_count(p,-1);
      216 
      217 	     offset = a_reg.offset;
      218 	     if offset ^= 0
      219 	     then do;
      220 		aq_length, k = offset + size;
      221 
      222 		if size ^= a_reg.size
      223 		     then a_reg.length = k;
      224 		     else k, aq_length = a_reg.length;
      225 		goto sh;
      226 		end;
      227 
      228 	     if mod(a_reg.length,bits_per_word) ^= 0 & ^ fs then goto mask_it;
      229 
      230 	     if a_reg.size = size
      231 	     then do;
      232 		if mod(a_reg.length,bits_per_word) = 0
      233 		     then call sv_value;
      234 		return;
      235 		end;
      236 
      237 	     goto mask_it;
      238 	     end;
      239 
      240 	/* the following section handles the case which arises from
      241*		unspec(fixed(float_var))
      242*	   where the value we want can be in the q register */
      243 
      244 	if p -> reference.value_in.q
      245 	then do;
      246 slide:	     units = p -> reference.units;
      247 	     if units = word_ then cfo = 0;
      248 	     else do;
      249 		cfo = mod(p -> reference.c_offset * convert_offset(units),
      250 		 bits_per_word);
      251 		if cfo < 0 then cfo = cfo + bits_per_word;
      252 		end;
      253 
      254 	     call adjust_ref_count(p,-1);
      255 
      256 	     /* this operation effectively erases both a and q
      257*	        since the shift moves the value from q to a
      258*	        rather than simply changing a_reg.offset */
      259 
      260 	     call state_man$erase_reg("11"b);	/* fixes bug 1502 */
      261 
      262 	     call expmac((lls),c_a((cfo + bits_per_word),1));
      263 
      264 	     k, aq_length = size;
      265 
      266 	     if fs then goto done; else goto l5;
      267 	     end;
      268 
      269 str1:	if size > bits_per_word then d = fixed(control ^= 0,1); else d = 0;
      270 
      271 	aq_length = bits_per_word*(d + 1);
      272 
      273 	if p -> reference.aligned_ref
      274 	then do;
      275 	     if ft then macro = test_lda; else macro = lda;
      276 	     call expmac$one(macro,p,d);
      277 	     goto done;
      278 	     end;
      279 
      280 	call setup;
      281 
      282 sh:	if offset > 0
      283 	then do;
      284 	     call aq_man$left_shift(offset, k > bits_per_word);
      285 	     k, aq_length = a_reg.length;
      286 	     end;
      287 	else if p -> reference.padded_ref then goto done;
      288 
      289 l5:	if mod(k,bits_per_word) ^= 0
      290 	then do;
      291 mask_it:	     call aq_man$trim_aq(size);
      292 l72:	     aq_length = bits_per_two_words;
      293 	     end;
      294 
      295 done:	if arith & ^ fs
      296 	then do;
      297 
      298 	     type = p -> reference.data_type;
      299 
      300 	     if type <= real_fix_bin_2 | type = packed_ptr
      301 	     then do;
      302 		k = bits_per_two_words - size;
      303 em:		call expmac(mac,c_a(k,1));
      304 		goto thru;
      305 		end;
      306 
      307 	     if type <= real_flt_bin_2
      308 	     then do;
      309 		call expmac$zero(unpack_fl1 - real_flt_bin_1 + type);
      310 		goto thru;
      311 		end;
      312 
      313 	     if type = complex_flt_bin_1
      314 	     then do;
      315 		k = bits_per_word - divide(size,2,17,0);
      316 		if k > 0
      317 		then do;
      318 		     mac = unpack_cfl1;
      319 		     goto em;
      320 		     end;
      321 		end;
      322 
      323 	     goto thru;
      324 	     end;
      325 
      326 	a_reg.length = aq_length;
      327 	a_reg.offset = 0;
      328 
      329 done1:	a_reg.size = size;
      330 
      331 	if a_reg.offset = 0
      332 	then call sv_value;
      333 
      334 	a_reg.number = 1;
      335 	a_reg.variable(1) = p;
      336 	p -> reference.value_in.a = "1"b;
      337 
      338 	if fs
      339 	then if ^ p -> reference.aligned_ref
      340 	     then if a_reg.offset ^= 0 | mod(a_reg.length,bits_per_word) ^= 0
      341 		then machine_state.indicators = 0;
      342 
      343 back:	return;
      344 
      345 load$for_test: entry(pt,control);
      346 
      347 	/* this entry is called to load a bit string whose value
      348*	   is to be tested against zero */
      349 
      350 	p = pt;
      351 
      352 	if ^ p -> reference.aligned_ref
      353 	then if p -> reference.ref_count > 1
      354 		then goto begin;
      355 
      356 	ft = "1"b;
      357 	arith, fs, available = "0"b;
      358 
      359 	type = p -> reference.data_type;
      360 
      361 	if p -> reference.ref_count > 1 then goto l4;
      362 
      363 	if type ^= bit_string then goto l4;
      364 
      365 	if p -> reference.value_in.a
      366 	then do;
      367 	     if machine_state.indicators = 1
      368 	     then if a_reg.offset = 0
      369 		then if mod(a_reg.length,bits_per_word) = 0
      370 		      then goto drop;
      371 
      372 	     call adjust_ref_count(p,-1);
      373 	     available = "1"b;
      374 	     end;
      375 
      376 	size = p -> reference.c_length;
      377 
      378 	if p -> reference.aligned_ref & ^ available
      379 	then do;
      380 	     call expmac$one((test_lda),p,control);
      381 	     a_reg.offset = 0;
      382 	     a_reg.length = fixed(size > bits_per_word,1) * bits_per_word + bits_per_word;
      383 	     goto done1;
      384 	     end;
      385 
      386 	call setup;
      387 
      388 	mask = (72)"0"b;
      389 	substr(mask,cfo+1,size) = (72)"1"b;
      390 
      391 	q = generate_constant(mask,d+1);
      392 
      393 	call expmac(cana+d,q);
      394 
      395 	if available then return;
      396 
      397 done2:	a_reg.offset = cfo;
      398 	a_reg.length = k;
      399 	goto done1;
      400 
      401 load$for_store: entry(pt,control);
      402 
      403 	/* this entry is called to load a value which will be stored elsewhere */
      404 
      405 	p = pt;
      406 
      407 	if ^ p -> reference.aligned_ref
      408 	then if p -> reference.ref_count > 1
      409 	     then goto begin;
      410 
      411 	fs = "1"b;
      412 	arith, available, ft = "0"b;
      413 
      414 	type = p -> reference.data_type;
      415 
      416 	if type ^= char_string
      417 	then if type ^= bit_string
      418 	     then goto l4;
      419 
      420 	if p -> reference.long_ref then goto lg;
      421 
      422 	size = p -> reference.c_length * convert_size(type);
      423 
      424 	if p -> reference.value_in.a
      425 	     then if a_reg.size >= size
      426 		then goto drop;
      427 		else;
      428 	     else if p -> reference.value_in.q
      429 		then goto slide;
      430 
      431 	if size = 0 then goto caq;
      432 
      433 	if p -> reference.aligned_ref then goto str1;
      434 
      435 	call setup;
      436 
      437 	goto done2;
      438 
      439 load$short_string: entry(pt,control);
      440 
      441 	/* this procedure is called to load the first word or two
      442*	   of a long string */
      443 
      444 	fs = "1"b;
      445 	arith, available, ft = "0"b;
      446 
      447 	p = pt;
      448 	type = p -> reference.data_type;
      449 
      450 	size = bits_per_word*(control+1);
      451 	goto l2;
      452 
      453 load$long_string: entry(pt);
      454 
      455 	/* this entry is called to load the long string register
      456*	   with a short string */
      457 
      458 	p = pt;
      459 	type = p -> reference.data_type;
      460 	goto lg;
      461 
      462 load$for_save:	entry(pt,control);
      463 
      464 	/* called by compile_exp$save when it has a hard_to_load string that wants to be
      465*	   converted to an aligned temporary in storage and does not need to be loaded */
      466 
      467 	p = pt;
      468 	for_save = "1"b;
      469 	go to begin;
      470 
      471 sv_value:	     proc;
      472 
      473 	     if ^ p -> reference.aligned_ref
      474 	     then if p -> reference.ref_count > 0
      475 		then call save_value(p);
      476 
      477 	     end;
      478 
      479 setup:	     proc;
      480 
      481 	     dcl (p1,p2) ptr;
      482 
      483 	     units = p -> reference.units;
      484 	     if available
      485 	     then cfo, offset = a_reg.offset;
      486 	     else if units = word_
      487 		then cfo, offset = 0;
      488 		else do;
      489 		     cfo = mod(p -> reference.c_offset * convert_offset(units),bits_per_word);
      490 		     if cfo < 0 then cfo = cfo + bits_per_word;
      491 
      492 		     if ^ p -> reference.hard_to_load
      493 			then offset = cfo;
      494 			else offset = 0;
      495 		     end;
      496 
      497 	     k = size + offset;
      498 
      499 	     d = fixed(k > bits_per_word,1);
      500 
      501 	     if available then return;
      502 
      503 	/* if reference is hard to load we will move it into an aligned padded temporary
      504*	   and load it from there */
      505 
      506 	     if p -> reference.hard_to_load
      507 	     then do;
      508 		if (^ arith | mod(size,bits_per_word) = 0) & (p -> reference.ref_count > 1 | for_save)
      509 		   & ^ p -> reference.aggregate
      510 		then do;
      511 
      512 		     /* We have a string with a high reference count, we will want future
      513*		        reference to the string to be made to the temporary we are using
      514*		        for the load */
      515 
      516 		     call make_n_addressable(addr(pt),1);	/* make addressable and lock regs */
      517 
      518 		     p2 = get_reference();		/* We will copy address into place holder */
      519 
      520 		     p2 -> reference = p -> reference;
      521 		     p2 -> reference.qualifier, p2 -> reference.offset, p2 -> reference.length = null;
      522 		     string(p2 -> reference.info) = "0"b;
      523 		     p2 -> reference.perm_address = "1"b;
      524 
      525 		     call save_value(p);		/* convert to temporary */
      526 
      527 		     p -> reference.value_in.storage = "1"b;
      528 		     p1 = p;
      529 		     end;
      530 
      531 		else do;
      532 
      533 		     /* Use double_temp as place to move */
      534 
      535 		     p1 = c_a(46,4);
      536 		     p2 = p;
      537 		     end;
      538 
      539 		dt = type - char_string;
      540 
      541 		call expmac$two_eis(move_cs_load_1 + 2*d + dt,p1,p2);
      542 
      543 		if for_save then go to back;
      544 
      545 		call expmac$one((lda),p1,d);
      546 		aq_length = bits_per_word * (d + 1);
      547 		go to done;
      548 		end;
      549 
      550 
      551 	     call expmac$one((lda),p,d);
      552 
      553 	     a_reg.size = size;
      554 	     a_reg.offset = cfo;
      555 	     a_reg.length = k;
      556 
      557 	     end;
      558 
      559 	end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/05/00  1826.1  load.pl1                          >udd>sm>ds>w>ml>load.pl1
78           1    10/25/79  1745.8  cgsystem.incl.pl1                 >ldd>incl>cgsystem.incl.pl1
79           2    07/21/80  1646.3  cg_reference.incl.pl1             >ldd>incl>cg_reference.incl.pl1
80           3    05/03/76  1420.4  data_types.incl.pl1               >ldd>incl>data_types.incl.pl1
81           4    11/13/79  1115.8  machine_state.incl.pl1            >ldd>incl>machine_state.incl.pl1
82           5    10/25/79  1745.8  boundary.incl.pl1                 >ldd>incl>boundary.incl.pl1
83           6    12/07/83  1801.7  symbol.incl.pl1                   >ldd>incl>symbol.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a                        11(09)        based           bit(1)                   level 4 packed packed unaligned dcl 2-3 set ref 207
                                                                                  336* 365 424
a_reg                     3            based           structure                level 2 dcl 4-6
addr                                                   builtin function         dcl 55 ref 516 516
adjust_ref_count                000022 constant        entry                    external dcl 29 ref 129 148 215 254 372
aggregate                12(19)        based           bit(1)                   level 3 packed packed unaligned dcl 2-3 set ref 508
aligned_ref              12(07)        based           bit(1)                   level 3 packed packed unaligned dcl 2-3 set ref 139
                                                                                  158 273 338 352 378 407 433 473
aq_length                       000112 automatic       fixed bin(17,0)          dcl 29 set ref 220* 224* 264* 271* 285* 292* 326
                                                                                  546*
aq_man$left_shift               000026 constant        entry                    external dcl 29 ref 284
aq_man$trim_aq                  000024 constant        entry                    external dcl 29 ref 291
arith                           000124 automatic       bit(1)                   dcl 29 set ref 106* 121* 295 357* 412* 445* 508
attributes               31            based           structure                level 2 dcl 6-3
available                       000125 automatic       bit(1)                   dcl 29 set ref 87* 357* 373* 378 395 412* 445* 484
                                                                                  501
bit_string                             constant        fixed bin(15,0)          initial dcl 3-1 ref 161 363 416
bits                     12(06)        based           structure                level 2 packed packed unaligned dcl 2-3
bits_per_two_words                     constant        fixed bin(8,0)           initial dcl 1-5 ref 292 302
bits_per_word                   002034 constant        fixed bin(8,0)           initial dcl 1-5 ref 228 232 249 251 262 262 269 271
                                                                                  284 289 315 338 367 382 382 382 450 489 490 499
                                                                                  508 546
c_a                             000014 constant        entry                    external dcl 29 ref 262 262 303 303 535
c_length                  2            based           fixed bin(24,0)          level 2 dcl 2-3 set ref 160 193 199 376 422
c_offset                  1            based           fixed bin(24,0)          level 2 dcl 2-3 set ref 249 489
cana                                   constant        fixed bin(15,0)          initial dcl 57 ref 393
cfo                             000114 automatic       fixed bin(17,0)          dcl 29 set ref 247* 249* 251 251* 251 262 262 389
                                                                                  397 484* 486* 489* 490 490* 490 492 554
cg_stat$cur_statement           000010 external static pointer                  dcl 29 set ref 112*
cg_static_$m_s_p                000050 external static pointer                  dcl 4-3 ref 4-3
char_string                            constant        fixed bin(15,0)          initial dcl 3-1 ref 104 416 539
clear_aq                               constant        fixed bin(15,0)          initial dcl 57 ref 203
complex_flt_bin_1                      constant        fixed bin(15,0)          initial dcl 3-1 ref 165 313
control                                parameter       fixed bin(17,0)          dcl 26 set ref 24 123 172 269 345 380* 401 439 450
                                                                                  462
convert_offset                  000000 constant        fixed bin(8,1)           initial array dcl 1-35 ref 249 489
convert_size                    000006 constant        fixed bin(8,0)           initial array dcl 1-5 ref 199 422
d                               000107 automatic       fixed bin(17,0)          dcl 29 set ref 269* 269* 271 276* 391 393 499* 541
                                                                                  545* 546 551*
data_type                12            based           fixed bin(5,0)           level 2 packed packed unaligned dcl 2-3 set ref 89
                                                                                  298 359 414 448 459
dt                              000110 automatic       fixed bin(17,0)          dcl 29 set ref 539* 541
error                           000012 constant        entry                    external dcl 29 ref 112
expmac                          000046 constant        entry                    external dcl 29 ref 168 262 303 393
expmac$one                      000042 constant        entry                    external dcl 29 ref 276 380 545 551
expmac$two_eis                  000040 constant        entry                    external dcl 29 ref 541
expmac$zero                     000044 constant        entry                    external dcl 29 ref 130 143 203 309
fixed                                                  builtin function         dcl 55 ref 269 382 499
for_save                        000126 automatic       bit(1)                   initial dcl 29 set ref 29* 468* 508 543
fs                              000122 automatic       bit(1)                   dcl 29 set ref 87* 162 228 266 295 338 357* 411*
                                                                                  444*
ft                              000123 automatic       bit(1)                   dcl 29 set ref 87* 139 209 275 356* 412* 445*
generate_constant               000016 constant        entry                    external dcl 29 ref 391
get_reference                   000034 constant        entry                    external dcl 29 ref 518
hard_to_load             12(23)        based           bit(1)                   level 3 packed packed unaligned dcl 2-3 set ref 492
                                                                                  506
indicators                1            based           fixed bin(17,0)          level 2 dcl 4-6 set ref 139 144* 176* 209 338* 367
info                     11            based           structure                level 2 packed packed unaligned dcl 2-3 set ref 522*
k                               000111 automatic       fixed bin(17,0)          dcl 29 set ref 220* 222 224* 264* 284 285* 289 302*
                                                                                  303* 303* 315* 316 398 497* 499 555
lda                                    constant        fixed bin(15,0)          initial dcl 57 ref 275 545 551
ldfx1                                  constant        fixed bin(15,0)          initial dcl 57 ref 166
ldfx2                                  constant        fixed bin(15,0)          initial dcl 57 ref 165
length                    6            based           pointer                  level 2 in structure "reference" packed packed
                                                                                  unaligned dcl 2-3 in procedure "load" set ref 521*
length                   17            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 4-6
                                                                                  in procedure "load" set ref 222* 224 228 232 285
                                                                                  326* 338 367 382* 398* 555*
lls                                    constant        fixed bin(15,0)          initial dcl 57 ref 262
long_op$c_or_b                  000020 constant        entry                    external dcl 29 ref 190
long_ref                 12(08)        based           bit(1)                   level 3 packed packed unaligned dcl 2-3 set ref 151
                                                                                  184 420
lrl                                    constant        fixed bin(15,0)          initial dcl 57 ref 99 117
lrs                                    constant        fixed bin(15,0)          initial dcl 57 ref 116
m_s_p                           000130 automatic       pointer                  initial dcl 4-3 set ref 139 144 174 175 176 192 193
                                                                                  209 213 217 222 222 224 228 230 232 285 326 327
                                                                                  329 331 334 335 338 338 338 367 367 367 381 382
                                                                                  397 398 424 4-3* 484 553 554 555
mac                             000116 automatic       fixed bin(15,0)          dcl 29 set ref 99* 116* 117* 303* 318*
machine_state                          based           structure                level 1 dcl 4-6
macro                           000117 automatic       fixed bin(15,0)          dcl 29 set ref 165* 166* 168* 275* 275* 276*
make_n_addressable              000032 constant        entry                    external dcl 29 ref 516
mask                            000120 automatic       bit(72)                  dcl 29 set ref 388* 389* 391*
misc_attributes          31(19)        based           structure                level 3 packed packed unaligned dcl 6-3
mod                                                    builtin function         dcl 55 ref 228 232 249 289 338 367 489 508
move_cs_load_1                         constant        fixed bin(15,0)          initial dcl 57 ref 541
n                               000104 automatic       fixed bin(17,0)          dcl 29 set ref 125* 135* 166
negate_op                       000010 constant        fixed bin(15,0)          initial array dcl 57 ref 130
null                                                   builtin function         dcl 55 ref 117 521
number                   43            based           fixed bin(17,0)          level 3 in structure "machine_state" dcl 4-6
                                                                                  in procedure "load" set ref 175*
number                   15            based           fixed bin(17,0)          level 3 in structure "machine_state" dcl 4-6
                                                                                  in procedure "load" set ref 334*
offset                    5            based           pointer                  level 2 in structure "reference" packed packed
                                                                                  unaligned dcl 2-3 in procedure "load" set ref 521*
offset                   20            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 4-6
                                                                                  in procedure "load" set ref 217 327* 331 338 367
                                                                                  381* 397* 484 554*
offset                          000115 automatic       fixed bin(8,0)           dcl 29 in procedure "load" set ref 217* 218 220 282
                                                                                  284* 484* 486* 492* 494* 497
p                               000100 automatic       pointer                  dcl 29 set ref 85* 89 112* 117 117 126 126 126 129*
                                                                                  137 139 139 139 148 148* 151 158 160 168* 174 177
                                                                                  184 187 190* 192 193 195 199 207 215* 244 246 249
                                                                                  254* 273 276* 287 298 335 336 338 350* 352 352 359
                                                                                  361 365 372* 376 378 380* 405* 407 407 414 420 422
                                                                                  424 428 433 447* 448 458* 459 467* 473 473 473*
                                                                                  483 489 492 506 508 508 520 525* 527 528 536 551*
p1                              000146 automatic       pointer                  dcl 481 set ref 528* 535* 541* 545*
p2                              000150 automatic       pointer                  dcl 481 set ref 518* 520 521 521 521 522 523 536*
                                                                                  541*
packed_ptr                             constant        fixed bin(15,0)          initial dcl 3-1 ref 97 300
padded_ref               12(06)        based           bit(1)                   level 3 packed packed unaligned dcl 2-3 set ref 287
perm_address             12(18)        based           bit(1)                   level 3 packed packed unaligned dcl 2-3 set ref 523*
pt                                     parameter       pointer                  dcl 26 set ref 24 85 345 350 401 405 439 447 453 458
                                                                                  462 467 516 516
q                               000102 automatic       pointer                  dcl 29 in procedure "load" set ref 391* 393*
q                        11(10)        based           bit(1)                   level 4 in structure "reference" packed packed
                                                                                  unaligned dcl 2-3 in procedure "load" set ref 126
                                                                                  137 177* 244 428
q_reg                    31            based           structure                level 2 dcl 4-6
qualifier                 4            based           pointer                  level 2 packed packed unaligned dcl 2-3 set ref 521*
real_fix_bin_1                         constant        fixed bin(15,0)          initial dcl 3-1 ref 100
real_fix_bin_2                         constant        fixed bin(15,0)          initial dcl 3-1 ref 93 126 300
real_fix_dec                           constant        fixed bin(15,0)          initial dcl 3-1 ref 110
real_flt_bin_1                         constant        fixed bin(15,0)          initial dcl 3-1 ref 309
real_flt_bin_2                         constant        fixed bin(15,0)          initial dcl 3-1 ref 307
ref_count                 0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 2-3 set ref 352
                                                                                  361 407 473 508
reference                              based           structure                level 1 dcl 2-3 set ref 520* 520
save_value                      000030 constant        entry                    external dcl 29 ref 473 525
set_chars                              constant        fixed bin(15,0)          initial dcl 57 ref 190
shared                    0(11)        based           bit(1)                   level 2 packed packed unaligned dcl 2-3 set ref 148
size                            000106 automatic       fixed bin(17,0)          dcl 29 in procedure "load" set ref 160* 199* 201 213
                                                                                  220 222 230 264 269 291* 302 315 329 376* 382 389
                                                                                  422* 424 431 450* 497 508 553
size                     60            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 4-6
                                                                                  in procedure "load" set ref 193*
size                     16            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 4-6
                                                                                  in procedure "load" set ref 213 222 230 329* 424
                                                                                  553*
state_man$erase_reg             000036 constant        entry                    external dcl 29 ref 260
storage                  11(23)        based           bit(1)                   level 4 packed packed unaligned dcl 2-3 set ref 126
                                                                                  139 527*
string_aq                11(12)        based           bit(1)                   level 4 packed packed unaligned dcl 2-3 set ref 187
                                                                                  195*
string_reg               57            based           structure                level 2 dcl 4-6
substr                                                 builtin function         dcl 55 set ref 389*
symbol                    3            based           pointer                  level 2 in structure "reference" packed packed
                                                                                  unaligned dcl 2-3 in procedure "load" set ref 117
                                                                                  117
symbol                                 based           structure                level 1 dcl 6-3 in procedure "load"
temp_ref                 12(11)        based           bit(1)                   level 3 packed packed unaligned dcl 2-3 set ref 126
                                                                                  139
test_lda                               constant        fixed bin(15,0)          initial dcl 57 ref 275 380
testfx1                                constant        fixed bin(15,0)          initial dcl 57 ref 143
type                            000105 automatic       fixed bin(17,0)          dcl 29 set ref 89* 91 93* 97 100* 104 110 126 130
                                                                                  143 161* 165 166 199 298* 300 300 307 309 313 359*
                                                                                  363 414* 416 416 422 448* 459* 539
units                     0(14)        based           fixed bin(3,0)           level 2 in structure "reference" packed packed
                                                                                  unaligned dcl 2-3 in procedure "load" set ref 246
                                                                                  483
units                           000113 automatic       fixed bin(17,0)          dcl 29 in procedure "load" set ref 246* 247 249 483*
                                                                                  486 489
unpack_cfl1                            constant        fixed bin(15,0)          initial dcl 57 ref 318
unpack_fl1                             constant        fixed bin(15,0)          initial dcl 57 ref 309
unpacked_ptr                           constant        fixed bin(15,0)          initial dcl 3-1 ref 91
unsigned                 31(24)        based           bit(1)                   level 4 packed packed unaligned dcl 6-3 ref 117
value_in                 11(09)        based           structure                level 3 packed packed unaligned dcl 2-3
variable                  3            based           pointer                  array level 3 in structure "machine_state" packed
                                                                                  packed unaligned dcl 4-6 in procedure "load" set
                                                                                  ref 335*
variable                 31            based           pointer                  array level 3 in structure "machine_state" packed
                                                                                  packed unaligned dcl 4-6 in procedure "load" set
                                                                                  ref 174*
variable                 57            based           pointer                  level 3 in structure "machine_state" packed packed
                                                                                  unaligned dcl 4-6 in procedure "load" set ref 192*
word_                                  constant        fixed bin(3,0)           initial dcl 5-5 ref 247 486

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
als                                    internal static fixed bin(15,0)          initial dcl 57
anaq                                   internal static fixed bin(15,0)          initial dcl 57
bit                                                    builtin function         dcl 55
bit_                                   internal static fixed bin(3,0)           initial dcl 5-5
bits_per_char                          internal static fixed bin(8,0)           initial dcl 1-5
bits_per_four_words                    internal static fixed bin(8,0)           initial dcl 1-5
bits_per_half                          internal static fixed bin(8,0)           initial dcl 1-5
bits_per_packed_digit                  internal static fixed bin(8,1)           initial dcl 1-35
bits_per_words                         internal static fixed bin(8,0)           initial array dcl 1-5
break_even_bits                        internal static fixed bin(8,0)           initial dcl 1-5
break_even_words                       internal static fixed bin(8,0)           initial dcl 1-5
character_                             internal static fixed bin(3,0)           initial dcl 5-5
chars_per_word                         internal static fixed bin(8,0)           initial dcl 1-5
complex_fix_bin_1                      internal static fixed bin(15,0)          initial dcl 3-1
complex_fix_bin_2                      internal static fixed bin(15,0)          initial dcl 3-1
complex_fix_dec                        internal static fixed bin(15,0)          initial dcl 3-1
complex_flt_bin_2                      internal static fixed bin(15,0)          initial dcl 3-1
complex_flt_dec                        internal static fixed bin(15,0)          initial dcl 3-1
default_fix_bin_p                      internal static fixed bin(8,0)           initial dcl 1-5
digit_                                 internal static fixed bin(3,0)           initial dcl 5-5
entry_variable                         internal static fixed bin(15,0)          initial dcl 3-1
ext_entry_in                           internal static fixed bin(15,0)          initial dcl 3-1
ext_entry_out                          internal static fixed bin(15,0)          initial dcl 3-1
half_                                  internal static fixed bin(3,0)           initial dcl 5-5
i                                      automatic       fixed bin(17,0)          dcl 29
ind_arithmetic                         internal static fixed bin(17,0)          initial dcl 4-68
ind_decimal_reg                        internal static fixed bin(17,0)          initial dcl 4-68
ind_invalid                            internal static fixed bin(17,0)          initial dcl 4-68
ind_known_refs                         internal static fixed bin(17,0)          initial dcl 4-68
ind_logical                            internal static fixed bin(17,0)          initial dcl 4-68
ind_string_aq                          internal static fixed bin(17,0)          initial dcl 4-68
ind_x                                  internal static fixed bin(17,0)          initial array dcl 4-68
int_entry                              internal static fixed bin(15,0)          initial dcl 3-1
int_entry_other                        internal static fixed bin(15,0)          initial dcl 3-1
label_constant                         internal static fixed bin(15,0)          initial dcl 3-1
label_size                             internal static fixed bin(8,0)           initial dcl 1-5
label_variable                         internal static fixed bin(15,0)          initial dcl 3-1
load_logical                           internal static fixed bin(15,0)          initial dcl 57
local_label_variable                   internal static fixed bin(15,0)          initial dcl 3-1
long_op                         000000 constant        entry                    external dcl 29
max_dec_scale                          internal static fixed bin(8,0)           initial dcl 1-5
max_index_register_value               internal static fixed bin(31,0)          initial dcl 1-38
max_length_p                           internal static fixed bin(8,0)           initial dcl 1-5
max_offset                             internal static fixed bin(8,0)           initial array dcl 1-5
max_p_fix_bin_1                        internal static fixed bin(8,0)           initial dcl 1-5
max_p_fix_dec                          internal static fixed bin(8,0)           initial dcl 1-5
max_p_flt_bin_1                        internal static fixed bin(8,0)           initial dcl 1-5
max_p_xreg                             internal static fixed bin(8,0)           initial dcl 1-5
max_short_size                         internal static fixed bin(8,0)           initial array dcl 1-5
min_dec_scale                          internal static fixed bin(8,0)           initial dcl 1-5
mod2_                                  internal static fixed bin(3,0)           initial dcl 5-5
mod4_                                  internal static fixed bin(3,0)           initial dcl 5-5
operator_table                         internal static fixed bin(18,0)          initial dcl 76
packed_digits_per_char                 internal static fixed bin(8,0)           initial dcl 1-5
packed_digits_per_word                 internal static fixed bin(8,0)           initial dcl 1-5
real_flt_dec                           internal static fixed bin(15,0)          initial dcl 3-1
shift                                  automatic       fixed bin(15,0)          dcl 29
stack_temp$free_temp            000000 constant        entry                    external dcl 29
units_per_word                         internal static fixed bin(8,0)           initial array dcl 1-5
xr_man$load_const               000000 constant        entry                    external dcl 29
xr_man$load_var                 000000 constant        entry                    external dcl 29

NAMES DECLARED BY EXPLICIT CONTEXT.
back                            001113 constant        label                    dcl 343 ref 543
begin                           000054 constant        label                    dcl 87 ref 352 407 469
caq                             000422 constant        label                    dcl 203 ref 431
chk                             000141 constant        label                    dcl 121 ref 94 101
done                            000756 constant        label                    dcl 295 ref 266 277 287 547
done1                           001062 constant        label                    dcl 329 ref 383 399
done2                           001324 constant        label                    dcl 397 ref 437
drop                            000257 constant        label                    dcl 148 ref 187 367 424
em                              000775 constant        label                    dcl 303 ref 319
l1                              000303 constant        label                    dcl 158 ref 139
l2                              000434 constant        label                    dcl 207 ref 162 451
l4                              000063 constant        label                    dcl 91 ref 361 363 416
l5                              000741 constant        label                    dcl 289 ref 266
l72                             000754 constant        label                    dcl 292 ref 204
lg                              000363 constant        label                    dcl 187 ref 420 460
load                            000042 constant        entry                    external dcl 24
load$for_save                   001477 constant        entry                    external dcl 462
load$for_store                  001334 constant        entry                    external dcl 401
load$for_test                   001116 constant        entry                    external dcl 345
load$long_string                001457 constant        entry                    external dcl 453
load$short_string               001425 constant        entry                    external dcl 439
mask_it                         000745 constant        label                    dcl 291 ref 228 237
setup                           001535 constant        entry                    internal dcl 479 ref 280 386 435
sh                              000711 constant        label                    dcl 282 ref 225
slide                           000530 constant        label                    dcl 246 ref 428
str1                            000643 constant        label                    dcl 269 ref 162 209 213 433
string_                         000357 constant        label                    dcl 184 ref 107
sv_value                        001514 constant        entry                    internal dcl 471 ref 151 170 232 331
thru                            000341 constant        label                    dcl 170 ref 304 310 323

NAMES DECLARED BY CONTEXT OR IMPLICATION.
divide                                                 builtin function         ref 315
string                                                 builtin function         ref 522

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2344        2416    2035        2354
Length      2740    2035        52         306     306           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
load                                156 external procedure  is an external procedure.  
sv_value                                internal procedure  shares stack frame of external procedure load.  
setup                                   internal procedure  shares stack frame of external procedure load.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
load                     000100 p                           load
                         000102 q                           load
                         000104 n                           load
                         000105 type                        load
                         000106 size                        load
                         000107 d                           load
                         000110 dt                          load
                         000111 k                           load
                         000112 aq_length                   load
                         000113 units                       load
                         000114 cfo                         load
                         000115 offset                      load
                         000116 mac                         load
                         000117 macro                       load
                         000120 mask                        load
                         000122 fs                          load
                         000123 ft                          load
                         000124 arith                       load
                         000125 available                   load
                         000126 for_save                    load
                         000130 m_s_p                       load
                         000146 p1                          setup
                         000150 p2                          setup

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_ne_as             call_ext_out_desc   call_ext_out        return_mac          mdfx1
ext_entry           trunc_fx1           scaled_mod_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_ref_count              aq_man$left_shift             aq_man$trim_aq                c_a
error                         expmac                        expmac$one                    expmac$two_eis
expmac$zero                   generate_constant             get_reference                 long_op$c_or_b
make_n_addressable            save_value                    state_man$erase_reg

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cg_stat$cur_statement         cg_static_$m_s_p




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     29 000027    4    3 000030        24 000036        85 000050        87 000054        89 000057        91 000063
     93 000066        94 000070        97 000071        99 000073       100 000075       101 000077       104 000100
    106 000102       107 000103       110 000104       112 000106       113 000123       116 000124       117 000126
    121 000141       123 000143       125 000146       126 000150       129 000165       130 000200       131 000212
    133 000213       135 000214       137 000216       139 000222       143 000241       144 000254       148 000257
    151 000275       154 000302       158 000303       160 000307       161 000311       162 000313       162 000315
    165 000316       166 000324       168 000330       170 000341       172 000342       174 000345       175 000350
    176 000352       177 000354       180 000356       184 000357       187 000363       190 000367       192 000405
    193 000410       195 000412       196 000414       199 000415       201 000421       203 000422       204 000433
    207 000434       209 000440       213 000446       215 000452       217 000465       218 000470       220 000471
    222 000474       224 000502       225 000505       228 000506       230 000515       232 000520       234 000523
    237 000524       244 000525       246 000530       247 000534       249 000540       251 000553       254 000556
    260 000571       262 000602       264 000635       266 000640       266 000642       269 000643       269 000654
    271 000655       273 000661       275 000665       275 000672       276 000674       277 000707       280 000710
    282 000711       284 000713       285 000730       286 000734       287 000735       289 000741       291 000745
    292 000754       295 000756       298 000762       300 000766       302 000772       303 000775       304 001023
    307 001024       309 001026       310 001040       313 001041       315 001043       316 001051       318 001052
    319 001054       323 001055       326 001056       327 001061       329 001062       331 001065       334 001070
    335 001073       336 001075       338 001077       343 001113       345 001114       350 001124       352 001130
    356 001140       357 001142       359 001145       361 001150       363 001155       365 001160       367 001163
    372 001175       373 001210       376 001212       378 001215       380 001222       381 001240       382 001242
    383 001251       386 001252       388 001253       389 001255       391 001262       393 001306       395 001322
    397 001324       398 001327       399 001331       401 001332       405 001342       407 001346       411 001360
    412 001362       414 001365       416 001370       420 001374       422 001377       424 001403       427 001411
    428 001412       431 001415       433 001417       435 001421       437 001422       439 001423       444 001433
    445 001435       447 001440       448 001444       450 001447       451 001453       453 001454       458 001465
    459 001471       460 001474       462 001475       467 001505       468 001511       469 001513       471 001514
    473 001515       477 001534       479 001535       483 001536       484 001542       486 001551       489 001556
    490 001571       492 001574       494 001602       497 001603       499 001606       501 001612       506 001615
    508 001621       516 001641       518 001657       520 001666       521 001673       522 001677       523 001700
    525 001702       527 001711       528 001714       529 001715       535 001716       536 001735       539 001737
    541 001742       543 001762       545 001764       546 002001       547 002005       551 002006       553 002023
    554 002026       555 002030       557 002032


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
