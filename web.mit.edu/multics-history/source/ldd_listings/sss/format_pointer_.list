	COMPILATION LISTING OF SEGMENT format_pointer_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-17_1935.68_Mon_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       13*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       14*     Added format control comment to make the source more readable.
       15*                                                   END HISTORY COMMENTS */
       16 
       17 
       18 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       19 
       20 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       21 
       22 format_pointer_:
       23   procedure ();
       24 
       25   /* *	FORMAT_POINTER_ 
       26*   * 
       27*   *	Converts a pointer value to a printable representation.
       28*   *
       29*   *	After probe_check_ptr_, sort of.
       30*   * 
       31*   *      12 Sep 83, B. Braun:
       32*   *         Changed to call amu_$get_name_for_structure when used by 
       33*   *	   analyze_multics.
       34*   *	03 Jun 83, W. Olin Sibert:
       35*   */
       36 
       37   declare P_its_ptr		    pointer parameter;
       38   declare P_packed_ptr	    unaligned pointer parameter;
       39   declare P_name_sw		    bit (1) aligned parameter;
       40   declare P_amu_info_ptr	    pointer parameter;
       41 
       42   declare packed_sw		    bit (1) aligned;
       43   declare pointer_rep	    char (256) varying;
       44   declare valid		    bit (1) aligned;
       45   declare real_segment	    bit (1) aligned;
       46   declare seg_ptr		    pointer;
       47 
       48   declare 1 alias		    aligned internal static,
       49 	 2 count		    fixed bin init (0),
       50 	 2 array		    (25),
       51 	  3 short_name	    char (32) varying,
       52 	  3 long_name	    char (60) varying;
       53 
       54   declare error_table_$invalidsegno
       55 			    fixed bin (35) external static;
       56 
       57   declare amu_$get_name_for_structure
       58 			    entry (ptr, char (*) varying)
       59 			    returns (char (*) varying),
       60 	convert_status_code_    entry (fixed bin (35),
       61 			    char (8) aligned, char (100) aligned);
       62   declare expand_pathname_	    entry (char (*), char (*), char (*),
       63 			    fixed bin (35));
       64   declare get_pdir_		    entry () returns (char (168));
       65   declare hcs_$fs_get_path_name   entry (pointer,
       66 			    char (*), fixed bin, char (*),
       67 			    fixed bin (35));
       68   declare hcs_$high_low_seg_count entry (fixed bin, fixed bin);
       69   declare hcs_$status_long	    entry (char (*), char (*),
       70 			    fixed bin (1), pointer, pointer,
       71 			    fixed bin (35));
       72   declare ioa_$rsnnl	    entry options (variable);
       73   declare ring0_get_$name	    entry (char (*), char (*), pointer,
       74 			    fixed bin (35));
       75 
       76   declare (stringsize, error)	    condition;
       77 
       78   declare (addr, after, baseno, binary, char, index, max, null, rtrim,
       79 	unspec)		    builtin;
       80 
       81   /*  */
       82 
       83 format_pointer_$its:
       84   entry (P_its_ptr, P_name_sw, P_amu_info_ptr)
       85        returns (char (256) varying);
       86 
       87   packed_sw = "0"b;
       88   call edit_its_pointer (P_its_ptr, pointer_rep, valid, real_segment);
       89   goto CONVERT_POINTER_COMMON;
       90 
       91 
       92 
       93 format_pointer_$packed:
       94   entry (P_packed_ptr, P_name_sw, P_amu_info_ptr)
       95        returns (char (256) varying);
       96 
       97   packed_sw = "1"b;
       98   call edit_packed_pointer (P_packed_ptr, pointer_rep, valid, real_segment);
       99   goto CONVERT_POINTER_COMMON;
      100 
      101 
      102 CONVERT_POINTER_COMMON:
      103   if ^valid then do;
      104       pointer_rep = pointer_rep || " [invalid]";
      105       return (pointer_rep);
      106     end;
      107 
      108   if ^real_segment
      109     then
      110          return (pointer_rep);
      111 
      112   if ^P_name_sw
      113     then
      114          return (pointer_rep);
      115 
      116   /* This should, by rights, use the amu_ name resolution facility, but there
      117*   isn't one yet, so instead it just gives up if there's an amu_info_ptr. */
      118 
      119   if P_amu_info_ptr ^= null then do;	/* used by analyze_multics */
      120       pointer_rep = amu_$get_name_for_structure (P_amu_info_ptr, pointer_rep);
      121       return (pointer_rep);
      122     end;
      123 				/* Otherwise, we determine the name in the current address space and add it */
      124 
      125   if packed_sw
      126     then /* Sinc we know it's valid now, */
      127          seg_ptr = P_packed_ptr;	/* this avoids taking a fault on the pointer */
      128     else seg_ptr = P_its_ptr;
      129 
      130   call add_segment_name (seg_ptr, pointer_rep);
      131   return (pointer_rep);
      132 
      133   /*  */
      134 
      135 edit_its_pointer:
      136   procedure (P_its_ptr, P_rep, P_valid, P_real_segment);
      137 
      138 
      139   declare P_its_ptr		    pointer parameter;
      140   declare P_rep		    char (256) varying parameter;
      141   declare P_valid		    bit (1) aligned parameter;
      142   declare P_real_segment	    bit (1) aligned parameter;
      143 
      144   declare 1 its_ptr		    aligned like its_unsigned;
      145   declare 1 itp_ptr		    aligned like itp_unsigned;
      146   declare 1 ge_ptr		    aligned,
      147 	 2 offset		    bit (18) unaligned,
      148 	 2 tally		    bit (12) unaligned,
      149 	 2 mod		    fixed bin (6) unsigned unaligned;
      150   ;
      151 
      152   /* format: off */
      153 declare   MODIFIERS (0 : 63) char (3) aligned internal static options (constant) initial
      154          ("   ", "au ", "qu ", "du ", "ic ", "al ", "ql ", "dl ",
      155           "x0 ", "x1 ", "x2 ", "x3 ", "x4 ", "x5 ", "x6 ", "x7 ",
      156 	"n* ", "au*", "qu*", "23 ", "ic*", "al*", "ql*", "27 ",
      157 	"x0*", "x1*", "x2*", "x3*", "x4*", "x5*", "x6*", "x7*",
      158 	"f1 ", "itp", "42 ", "its", "sd ", "scr", "f2 ", "f3 ",
      159 	"ci ", "i  ", "sc ", "ad ", "di ", "dic", "id ", "idc",
      160 	"*n ", "*au", "*qu", "*du", "*ic", "*al", "*ql", "*dl",
      161 	"*x0", "*x1", "*x2", "*x3", "*x4", "*x5", "*x6", "*x7");
      162 /* format: on */
      163 
      164 
      165   unspec (its_ptr) = unspec (P_its_ptr);
      166   unspec (itp_ptr) = unspec (P_its_ptr);
      167   unspec (ge_ptr) = unspec (P_its_ptr);
      168 
      169   P_real_segment = "0"b;
      170   P_rep = "";
      171 
      172   P_valid = "0"b;
      173 
      174   if (its_ptr.its_mod = ITS_MODIFIER) then do;
      175       if (its_ptr.segno = 32767) & (its_ptr.mod = ""b)
      176         then
      177 	   call ioa_$rsnnl ("null^[(^o^[^o^;^s^])^]",
      178 	        P_rep, (0), (its_ptr.offset ^= 1), its_ptr.offset,
      179 	        (its_ptr.bit_offset ^= 0), its_ptr.bit_offset);
      180 
      181         else do;
      182 	call ioa_$rsnnl ("^o|^o^[(^d)^;^s^]^[[^d]^;^s^]^[,^a^]",
      183 	     P_rep, (0), its_ptr.segno, its_ptr.offset,
      184 	     (its_ptr.bit_offset ^= 0), its_ptr.bit_offset,
      185 	     ((its_ptr.ringno ^= 0) & (its_ptr.ringno ^= 4)),
      186 	     its_ptr.ringno, (its_ptr.mod ^= ""b),
      187 	     MODIFIERS (binary (its_ptr.mod, 6)));
      188 	if (its_ptr.segno < 4093)
      189 	  then P_real_segment = "1"b;
      190         end;
      191 
      192       if (its_ptr.segno < 4095) | (its_ptr.segno = 32767)
      193         then
      194 	   if (its_ptr.bit_offset < 36)
      195 	     then
      196 		P_valid = "1"b;
      197     end;
      198 
      199   else if (its_ptr.its_mod = ITP_MODIFIER) then do;
      200       call ioa_$rsnnl ("pr^o|^o^[(^d^;^s)^]^[,^a^] (ITP)",
      201 	 P_rep, (0), itp_ptr.pr_no, itp_ptr.offset,
      202 	 (itp_ptr.bit_offset ^= 0), itp_ptr.bit_offset,
      203 	 (itp_ptr.mod ^= ""b), MODIFIERS (binary (itp_ptr.mod, 6)));
      204 
      205       if (itp_ptr.bit_offset < 36)
      206         then P_valid = "1"b;
      207     end;
      208 
      209   else do;
      210     call ioa_$rsnnl ("^o(^o)^[,^a^]",
      211          P_rep, (0), ge_ptr.offset, ge_ptr.tally,
      212          (ge_ptr.mod ^= 0), MODIFIERS (ge_ptr.mod));
      213   end;
      214   return;
      215   end edit_its_pointer;
      216 
      217   /*  */
      218 
      219 edit_packed_pointer:
      220   procedure (P_packed_ptr, P_rep, P_valid, P_real_segment);
      221 
      222 
      223   declare P_packed_ptr	    unaligned pointer parameter;
      224   declare P_rep		    char (256) varying parameter;
      225   declare P_valid		    bit (1) aligned parameter;
      226   declare P_real_segment	    bit (1) aligned parameter;
      227 
      228   declare fault_type	    fixed bin;
      229 
      230   declare 1 packed_ptr	    aligned,
      231 	 2 bit_offset	    fixed bin (6) unsigned unaligned,
      232 	 2 segno		    fixed bin (12) unsigned unaligned,
      233 	 2 offset		    fixed bin (18) unsigned unaligned;
      234 
      235   declare 1 packed_ptr_fault	    aligned,
      236 	 2 pad		    bit (9) unaligned,
      237 	 2 type		    fixed bin (9) unaligned unsigned,
      238 	 2 offset		    fixed bin (18) unsigned unaligned;
      239 
      240 
      241   unspec (packed_ptr) = unspec (P_packed_ptr);
      242   unspec (packed_ptr_fault) = unspec (P_packed_ptr);
      243 
      244   P_valid = (packed_ptr.bit_offset < 36);
      245 				/* Not much else to check here */
      246   P_real_segment = "0"b;
      247   P_rep = "";
      248 
      249   if (packed_ptr.bit_offset < 48)
      250     then
      251          fault_type = 0;
      252     else fault_type = 1 + max (3, packed_ptr_fault.type);
      253 
      254   if P_valid & (packed_ptr.segno = 4095)
      255     then
      256          call ioa_$rsnnl ("null^[(^o^[^o^;^s^])^]",
      257 	    P_rep, (0), (packed_ptr.offset ^= 1), packed_ptr.offset,
      258 	    (packed_ptr.bit_offset ^= 0), packed_ptr.bit_offset);
      259 
      260     else do;
      261       call ioa_$rsnnl (
      262 	 "^o|^o^[(^d)^;^s^]^[ (^[LOT fault^;ISOT fault^;System fault^;faulted^])^]",
      263 	 P_rep, (0), packed_ptr.segno, packed_ptr.offset,
      264 	 (packed_ptr.bit_offset ^= 0), packed_ptr.bit_offset,
      265 	 (fault_type ^= 0), fault_type);
      266       if (fault_type = 0)
      267         then
      268 	   if (packed_ptr.segno < 4093)
      269 	     then P_real_segment = "1"b;
      270     end;
      271   return;
      272   end edit_packed_pointer;
      273 
      274   /*  */
      275 
      276 add_segment_name:
      277   procedure (P_seg_ptr, P_rep);
      278 
      279 
      280   declare P_seg_ptr		    pointer;
      281   declare P_rep		    char (256) varying;
      282 
      283   declare dname		    char (168);
      284   declare ename		    char (32);
      285   declare long_info		    char (100) aligned;
      286   declare idx		    fixed bin;
      287   declare code		    fixed bin (35);
      288   declare first_stack	    fixed bin;
      289   declare last_seg		    fixed bin;
      290 
      291 
      292   call initialize_aliases ();
      293 
      294   call hcs_$high_low_seg_count (last_seg, first_stack);
      295   last_seg = last_seg + first_stack;
      296 
      297   if (binary (baseno (P_seg_ptr)) < first_stack)
      298     then /* hardcore segment */
      299          call ring0_get_$name (dname, ename, P_seg_ptr, code);
      300     else call hcs_$fs_get_path_name (P_seg_ptr, dname, (0), ename, code);
      301 
      302   if (code = error_table_$invalidsegno) then do;
      303       P_rep = P_rep || " (Invalid segment number)";
      304       return;
      305     end;
      306 
      307   if (code ^= 0) then do;		/* get a string describing error */
      308       call convert_status_code_ (code, (""), long_info);
      309       P_rep = P_rep || " (Error: ";
      310       P_rep = P_rep || rtrim (long_info);
      311       P_rep = P_rep || ")";
      312       return;
      313     end;
      314 
      315   P_rep = P_rep || "   ";		/* append the pathname */
      316 
      317   if (dname = "") then do;		/* ring zero segment */
      318       P_rep = P_rep || rtrim (ename);
      319       P_rep = P_rep || " (ring 0)";
      320       return;
      321     end;
      322 
      323   do idx = 1 to alias.count;		/* Interpret aliases */
      324     if (dname = alias.long_name (idx)) then do;
      325         P_rep = P_rep || alias.short_name (idx);
      326         P_rep = P_rep || ">";
      327         P_rep = P_rep || rtrim (ename);
      328         return;
      329       end;
      330   end;
      331 
      332   P_rep = P_rep || rtrim (dname);	/* If no alias found, then just add the path */
      333   P_rep = P_rep || ">";		/* The alias hack takes care of the ROOT */
      334   P_rep = P_rep || rtrim (ename);
      335   return;
      336   end add_segment_name;
      337 
      338   /*  */
      339 
      340 initialize_aliases:
      341   procedure ();
      342 
      343 
      344   declare pdir_name		    char (168);
      345 
      346 
      347   if (alias.count > 0)
      348     then
      349          return;			/* We've already been here */
      350 
      351   call add_alias (">", "");		/* So the ROOT doesn't come out with ">>" */
      352 
      353   pdir_name = get_pdir_ ();
      354   call add_alias (pdir_name, "[pd]");
      355   if (index (pdir_name, ">process_dir_dir>") = 1) then do;
      356       pdir_name = ">pdd>" || after (pdir_name, ">process_dir_dir>");
      357       call add_alias (pdir_name, "[pd]");
      358     end;
      359 
      360   call add_alias (">process_dir_dir>!zzzzzzzbBBBBBB", "[Inzr PD]");
      361 
      362   call add_alias (">system_control_1", ">sc1");
      363   call add_alias (">system_library_1", ">sl1");
      364   call add_alias (">system_library_standard", ">sss");
      365   call add_alias (">system_library_unbundled", ">unb");
      366   call add_alias (">system_library_tools", ">tools");
      367   call add_alias (">system_library_auth_maint", ">am");
      368   call add_alias (">user_dir_dir", ">udd");
      369   call add_alias (">process_dir_dir", ">pdd");
      370   call add_alias (">library_dir_dir", ">ldd");
      371   call add_alias (">daemon_dir_dir", ">ddd");
      372   return;
      373   end initialize_aliases;
      374 
      375   /*  */
      376 
      377 add_alias:
      378   procedure (P_long, P_short) options (non_quick);
      379 				/* Non-quick because it's used only once */
      380 
      381   declare P_long		    char (*) parameter;
      382   declare P_short		    char (*) parameter;
      383 
      384   declare 1 dir_status	    aligned like status_branch;
      385 
      386   declare dname		    char (168);
      387   declare ename		    char (32);
      388   declare idx		    fixed bin;
      389   declare code		    fixed bin (35);
      390   declare short_uid		    bit (36) aligned;
      391   declare long_uid		    bit (36) aligned;
      392 
      393 
      394   idx = alias.count + 1;		/* Next entry */
      395 
      396 (subscriptrange):			/* To detect overflows of the array */
      397 (stringsize):
      398   begin;
      399     on condition (stringsize) signal error;
      400 				/* Braindamaged default handler */
      401 
      402     alias.short_name (idx) = rtrim (P_short);
      403     alias.long_name (idx) = rtrim (P_long);
      404   end;
      405 
      406   if (char (P_short, 1) ^= ">") then do;/* don't check aliases that are not directories */
      407       alias.count = idx;		/* update the count */
      408       return;			/* all done */
      409     end;
      410 
      411   call expand_pathname_ (P_long, dname, ename, code);
      412   if (code ^= 0)
      413     then
      414          return;			/* Just punt on any errors */
      415 
      416   call hcs_$status_long (dname, ename, (0), addr (dir_status), (null ()),
      417        code);
      418   if (code ^= 0)
      419     then
      420          return;
      421 
      422   long_uid = dir_status.uid;
      423 
      424   call expand_pathname_ (P_short, dname, ename, code);
      425   if (code ^= 0)
      426     then
      427          return;
      428 
      429   call hcs_$status_long (dname, ename, (0), addr (dir_status), (null ()),
      430        code);
      431   if (code ^= 0)
      432     then
      433          return;
      434 
      435   short_uid = dir_status.uid;
      436 
      437   if (short_uid ^= long_uid)
      438     then
      439          return;
      440 
      441   alias.count = idx;
      442   return;
      443 
      444   end add_alias;
      445 
      446 
  1     1 /* BEGIN INCLUDE FILE its.incl.pl1
  1     2*   modified 27 July 79 by JRDavis to add its_unsigned
  1     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  1     4 
  1     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  1     6     2 pad1 bit (3) unaligned,
  1     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  1     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  1     9     2 pad2 bit (9) unaligned,
  1    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  1    11 
  1    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  1    13     2 pad3 bit (3) unaligned,
  1    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  1    15     2 pad4 bit (3) unaligned,
  1    16     2 mod bit (6) unaligned;				/* further modification */
  1    17 
  1    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  1    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  1    20     2 pad1 bit (27) unaligned,
  1    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  1    22 
  1    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  1    24     2 pad2 bit (3) unaligned,
  1    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  1    26     2 pad3 bit (3) unaligned,
  1    27     2 mod bit (6) unaligned;				/* further modification */
  1    28 
  1    29 
  1    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  1    31     2 pad1 bit (3) unaligned,
  1    32     2 segno fixed bin (15) unsigned unaligned,
  1    33     2 ringno fixed bin (3) unsigned unaligned,
  1    34     2 pad2 bit (9) unaligned,
  1    35     2 its_mod bit (6) unaligned,
  1    36 
  1    37     2 offset fixed bin (18) unsigned unaligned,
  1    38     2 pad3 bit (3) unaligned,
  1    39     2 bit_offset fixed bin (6) unsigned unaligned,
  1    40     2 pad4 bit (3) unaligned,
  1    41     2 mod bit (6) unaligned;
  1    42 
  1    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  1    44     2 pr_no fixed bin (3) unsigned unaligned,
  1    45     2 pad1 bit (27) unaligned,
  1    46     2 itp_mod bit (6) unaligned,
  1    47 
  1    48     2 offset fixed bin (18) unsigned unaligned,
  1    49     2 pad2 bit (3) unaligned,
  1    50     2 bit_offset fixed bin (6) unsigned unaligned,
  1    51     2 pad3 bit (3) unaligned,
  1    52     2 mod bit (6) unaligned;
  1    53 
  1    54 
  1    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  1    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  1    57 
  1    58 /* END INCLUDE FILE   its.incl.pl1 */
      447 
      448 
  2     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  2     2 
  2     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  2     4 
  2     5 /* This include file contains branch and link structures returned by
  2     6*   hcs_$status_ and hcs_$status_long. */
  2     7 
  2     8 dcl 1 status_branch aligned based (status_ptr),
  2     9     2 short aligned,
  2    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  2    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  2    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  2    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  2    14       3 dtu bit (36) unaligned,			/* date/time last used */
  2    15       3 mode bit (5) unaligned,			/* caller's effective access */
  2    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  2    17       3 pad1 bit (8) unaligned,
  2    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  2    19 
  2    20 /* Limit of information returned by hcs_$status_ */
  2    21 
  2    22     2 long aligned,
  2    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  2    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  2    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  2    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  2    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  2    28       3 pad2 bit (8) unaligned,
  2    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  2    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  2    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  2    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  2    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  2    34       3 pad3 bit (5) unaligned,
  2    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  2    36       3 uid bit (36) unaligned;			/* unique ID */
  2    37 
  2    38 dcl 1 status_link aligned based (status_ptr),
  2    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  2    40     2 nnames fixed bin (16) unaligned unsigned,
  2    41     2 names_relp bit (18) unaligned,
  2    42     2 dtem bit (36) unaligned,
  2    43     2 dtd bit (36) unaligned,
  2    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  2    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  2    46 
  2    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  2    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  2    49 						/* array of names returned */
  2    50      status_pathname character (status_link.pathname_length) aligned
  2    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  2    52 						/* link target path */
  2    53      status_area_ptr pointer,
  2    54      status_ptr pointer;
  2    55 
  2    56 dcl (Link initial (0),
  2    57      Segment initial (1),
  2    58      Directory initial (2)) fixed bin internal static options (constant);
  2    59 						/* values for type fields declared above */
  2    60 
  2    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      449 
      450 
      451   end format_pointer_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/17/00  1935.6  format_pointer_.pl1               >udd>sm>ds>w>ml>format_pointer_.pl1
447          1    11/26/79  1420.6  its.incl.pl1                      >ldd>incl>its.incl.pl1
449          2    11/22/82  1055.7  status_structures.incl.pl1        >ldd>incl>status_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ITP_MODIFIER                           constant        bit(6)                   initial packed unaligned dcl 1-56 ref 199
ITS_MODIFIER                           constant        bit(6)                   initial packed unaligned dcl 1-55 ref 174
MODIFIERS                       000000 constant        char(3)                  initial array dcl 153 set ref 182* 200* 210*
P_amu_info_ptr                         parameter       pointer                  dcl 40 set ref 83 93 119 120*
P_its_ptr                              parameter       pointer                  dcl 37 in procedure "format_pointer_" set ref 83 88*
                                                                                  128
P_its_ptr                              parameter       pointer                  dcl 139 in procedure "edit_its_pointer" ref 135 165
                                                                                  166 167
P_long                                 parameter       char                     packed unaligned dcl 381 set ref 377 403 411*
P_name_sw                              parameter       bit(1)                   dcl 39 ref 83 93 112
P_packed_ptr                           parameter       pointer                  packed unaligned dcl 223 in procedure
                                                                                  "edit_packed_pointer" ref 219 241 242
P_packed_ptr                           parameter       pointer                  packed unaligned dcl 38 in procedure
                                                                                  "format_pointer_" set ref 93 98* 125
P_real_segment                         parameter       bit(1)                   dcl 226 in procedure "edit_packed_pointer" set ref
                                                                                  219 246* 266*
P_real_segment                         parameter       bit(1)                   dcl 142 in procedure "edit_its_pointer" set ref 135
                                                                                  169* 188*
P_rep                                  parameter       varying char(256)        dcl 140 in procedure "edit_its_pointer" set ref 135
                                                                                  170* 175* 182* 200* 210*
P_rep                                  parameter       varying char(256)        dcl 224 in procedure "edit_packed_pointer" set ref
                                                                                  219 247* 254* 261*
P_rep                                  parameter       varying char(256)        dcl 281 in procedure "add_segment_name" set ref 276
                                                                                  303* 303 309* 309 310* 310 311* 311 315* 315 318*
                                                                                  318 319* 319 325* 325 326* 326 327* 327 332* 332
                                                                                  333* 333 334* 334
P_seg_ptr                              parameter       pointer                  dcl 280 set ref 276 297 297* 300*
P_short                                parameter       char                     packed unaligned dcl 382 set ref 377 402 406 424*
P_valid                                parameter       bit(1)                   dcl 225 in procedure "edit_packed_pointer" set ref
                                                                                  219 244* 254
P_valid                                parameter       bit(1)                   dcl 141 in procedure "edit_its_pointer" set ref 135
                                                                                  172* 192* 205*
addr                                                   builtin function         dcl 78 ref 416 416 429 429
after                                                  builtin function         dcl 78 ref 356
alias                           000010 internal static structure                level 1 dcl 48
amu_$get_name_for_structure     001174 constant        entry                    external dcl 57 ref 120
array                     1     000010 internal static structure                array level 2 dcl 48
baseno                                                 builtin function         dcl 78 ref 297
binary                                                 builtin function         dcl 78 ref 182 200 297
bit_offset                      000233 automatic       fixed bin(6,0)           level 2 in structure "packed_ptr" packed packed
                                                                                  unsigned unaligned dcl 230 in procedure
                                                                                  "edit_packed_pointer" set ref 244 249 254 254* 261
                                                                                  261*
bit_offset                1(21) 000216 automatic       fixed bin(6,0)           level 2 in structure "its_ptr" packed packed
                                                                                  unsigned unaligned dcl 144 in procedure
                                                                                  "edit_its_pointer" set ref 175 175* 182 182* 192
bit_offset                1(21) 000220 automatic       fixed bin(6,0)           level 2 in structure "itp_ptr" packed packed
                                                                                  unsigned unaligned dcl 145 in procedure
                                                                                  "edit_its_pointer" set ref 200 200* 205
char                                                   builtin function         dcl 78 ref 406
code                            000360 automatic       fixed bin(35,0)          dcl 287 in procedure "add_segment_name" set ref 297*
                                                                                  300* 302 307 308*
code                            000175 automatic       fixed bin(35,0)          dcl 389 in procedure "add_alias" set ref 411* 412
                                                                                  416* 418 424* 425 429* 431
convert_status_code_            001176 constant        entry                    external dcl 57 ref 308
count                           000010 internal static fixed bin(17,0)          initial level 2 dcl 48 set ref 323 347 394 407* 441*
dir_status                      000100 automatic       structure                level 1 dcl 384 set ref 416 416 429 429
dname                           000112 automatic       char(168)                packed unaligned dcl 386 in procedure "add_alias"
                                                                                  set ref 411* 416* 424* 429*
dname                           000244 automatic       char(168)                packed unaligned dcl 283 in procedure
                                                                                  "add_segment_name" set ref 297* 300* 317 324 332
ename                           000316 automatic       char(32)                 packed unaligned dcl 284 in procedure
                                                                                  "add_segment_name" set ref 297* 300* 318 327 334
ename                           000164 automatic       char(32)                 packed unaligned dcl 387 in procedure "add_alias"
                                                                                  set ref 411* 416* 424* 429*
error                           000000 stack reference condition                dcl 76 ref 399
error_table_$invalidsegno       001172 external static fixed bin(35,0)          dcl 54 ref 302
expand_pathname_                001200 constant        entry                    external dcl 62 ref 411 424
fault_type                      000232 automatic       fixed bin(17,0)          dcl 228 set ref 249* 252* 261 261* 266
first_stack                     000361 automatic       fixed bin(17,0)          dcl 288 set ref 294* 295 297
ge_ptr                          000222 automatic       structure                level 1 dcl 146 set ref 167*
get_pdir_                       001202 constant        entry                    external dcl 64 ref 353
hcs_$fs_get_path_name           001204 constant        entry                    external dcl 65 ref 300
hcs_$high_low_seg_count         001206 constant        entry                    external dcl 68 ref 294
hcs_$status_long                001210 constant        entry                    external dcl 69 ref 416 429
idx                             000174 automatic       fixed bin(17,0)          dcl 388 in procedure "add_alias" set ref 394* 402
                                                                                  403 407 441
idx                             000357 automatic       fixed bin(17,0)          dcl 286 in procedure "add_segment_name" set ref 323*
                                                                                  324 325*
index                                                  builtin function         dcl 78 ref 355
ioa_$rsnnl                      001212 constant        entry                    external dcl 72 ref 175 182 200 210 254 261
itp_ptr                         000220 automatic       structure                level 1 dcl 145 set ref 166*
itp_unsigned                           based           structure                level 1 dcl 1-43
its_mod                   0(30) 000216 automatic       bit(6)                   level 2 packed packed unaligned dcl 144 set ref 174
                                                                                  199
its_ptr                         000216 automatic       structure                level 1 dcl 144 set ref 165*
its_unsigned                           based           structure                level 1 dcl 1-30
last_seg                        000362 automatic       fixed bin(17,0)          dcl 289 set ref 294* 295* 295
long                      4     000100 automatic       structure                level 2 dcl 384
long_info                       000326 automatic       char(100)                dcl 285 set ref 308* 310
long_name                12     000010 internal static varying char(60)         array level 3 dcl 48 set ref 324 403*
long_uid                        000177 automatic       bit(36)                  dcl 391 set ref 422* 437
max                                                    builtin function         dcl 78 ref 252
mod                       0(30) 000222 automatic       fixed bin(6,0)           level 2 in structure "ge_ptr" packed packed unsigned
                                                                                  unaligned dcl 146 in procedure "edit_its_pointer"
                                                                                  set ref 210 210
mod                       1(30) 000216 automatic       bit(6)                   level 2 in structure "its_ptr" packed packed
                                                                                  unaligned dcl 144 in procedure "edit_its_pointer"
                                                                                  set ref 175 182 182
mod                       1(30) 000220 automatic       bit(6)                   level 2 in structure "itp_ptr" packed packed
                                                                                  unaligned dcl 145 in procedure "edit_its_pointer"
                                                                                  set ref 200 200
null                                                   builtin function         dcl 78 ref 119 416 429
offset                    0(18) 000233 automatic       fixed bin(18,0)          level 2 in structure "packed_ptr" packed packed
                                                                                  unsigned unaligned dcl 230 in procedure
                                                                                  "edit_packed_pointer" set ref 254 254* 261*
offset                    1     000220 automatic       fixed bin(18,0)          level 2 in structure "itp_ptr" packed packed
                                                                                  unsigned unaligned dcl 145 in procedure
                                                                                  "edit_its_pointer" set ref 200*
offset                    1     000216 automatic       fixed bin(18,0)          level 2 in structure "its_ptr" packed packed
                                                                                  unsigned unaligned dcl 144 in procedure
                                                                                  "edit_its_pointer" set ref 175 175* 182*
offset                          000222 automatic       bit(18)                  level 2 in structure "ge_ptr" packed packed
                                                                                  unaligned dcl 146 in procedure "edit_its_pointer"
                                                                                  set ref 210*
packed_ptr                      000233 automatic       structure                level 1 dcl 230 set ref 241*
packed_ptr_fault                000234 automatic       structure                level 1 dcl 235 set ref 242*
packed_sw                       000100 automatic       bit(1)                   dcl 42 set ref 87* 97* 125
pdir_name                       000372 automatic       char(168)                packed unaligned dcl 344 set ref 353* 354* 355 356*
                                                                                  356 357*
pointer_rep                     000101 automatic       varying char(256)        dcl 43 set ref 88* 98* 104* 104 105 108 112 120*
                                                                                  120* 121 130* 131
pr_no                           000220 automatic       fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 145 set
                                                                                  ref 200*
real_segment                    000203 automatic       bit(1)                   dcl 45 set ref 88* 98* 108
ring0_get_$name                 001214 constant        entry                    external dcl 73 ref 297
ringno                    0(18) 000216 automatic       fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 144 set
                                                                                  ref 182 182 182*
rtrim                                                  builtin function         dcl 78 ref 310 318 327 332 334 402 403
seg_ptr                         000204 automatic       pointer                  dcl 46 set ref 125* 128* 130*
segno                     0(06) 000233 automatic       fixed bin(12,0)          level 2 in structure "packed_ptr" packed packed
                                                                                  unsigned unaligned dcl 230 in procedure
                                                                                  "edit_packed_pointer" set ref 254 261* 266
segno                     0(03) 000216 automatic       fixed bin(15,0)          level 2 in structure "its_ptr" packed packed
                                                                                  unsigned unaligned dcl 144 in procedure
                                                                                  "edit_its_pointer" set ref 175 182* 188 192 192
short_name                1     000010 internal static varying char(32)         array level 3 dcl 48 set ref 325 402*
short_uid                       000176 automatic       bit(36)                  dcl 390 set ref 435* 437
status_branch                          based           structure                level 1 dcl 2-8
stringsize                      000000 stack reference condition                dcl 76 ref 399
tally                     0(18) 000222 automatic       bit(12)                  level 2 packed packed unaligned dcl 146 set ref 210*
type                      0(09) 000234 automatic       fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 235 set
                                                                                  ref 252
uid                      11     000100 automatic       bit(36)                  level 3 packed packed unaligned dcl 384 set ref 422
                                                                                  435
unspec                                                 builtin function         dcl 78 set ref 165* 165 166* 166 167* 167 241* 241
                                                                                  242* 242
valid                           000202 automatic       bit(1)                   dcl 44 set ref 88* 98* 102

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Directory                              internal static fixed bin(17,0)          initial dcl 2-56
Link                                   internal static fixed bin(17,0)          initial dcl 2-56
Segment                                internal static fixed bin(17,0)          initial dcl 2-56
itp                                    based           structure                level 1 dcl 1-18
its                                    based           structure                level 1 dcl 1-5
status_area_ptr                        automatic       pointer                  dcl 2-47
status_entry_names                     based           char(32)                 array dcl 2-47
status_link                            based           structure                level 1 dcl 2-38
status_pathname                        based           char                     dcl 2-47
status_ptr                             automatic       pointer                  dcl 2-47

NAMES DECLARED BY EXPLICIT CONTEXT.
CONVERT_POINTER_COMMON          000474 constant        label                    dcl 102 ref 89 99
add_alias                       002750 constant        entry                    internal dcl 377 ref 351 354 357 360 362 363 364 365
                                                                                  366 367 368 369 370 371
add_segment_name                001617 constant        entry                    internal dcl 276 ref 130
edit_its_pointer                000703 constant        entry                    internal dcl 135 ref 88
edit_packed_pointer             001364 constant        entry                    internal dcl 219 ref 98
format_pointer_                 000377 constant        entry                    external dcl 22
format_pointer_$its             000414 constant        entry                    external dcl 83
format_pointer_$packed          000446 constant        entry                    external dcl 93
initialize_aliases              002274 constant        entry                    internal dcl 340 ref 292

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3552        4770    3332        3562
Length      5224    3332      1216         220     220        1162

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
format_pointer_                     572 external procedure  is an external procedure.  
edit_its_pointer                        internal procedure  shares stack frame of external procedure format_pointer_.  
edit_packed_pointer                     internal procedure  shares stack frame of external procedure format_pointer_.  
add_segment_name                        internal procedure  shares stack frame of external procedure format_pointer_.  
initialize_aliases                      internal procedure  shares stack frame of external procedure format_pointer_.  
add_alias                           180 internal procedure  is declared options(non_quick).  
begin block on line 396              72 begin block         enables or reverts conditions.  
on unit on line 399                  70 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 alias                       format_pointer_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
add_alias                000100 dir_status                  add_alias
                         000112 dname                       add_alias
                         000164 ename                       add_alias
                         000174 idx                         add_alias
                         000175 code                        add_alias
                         000176 short_uid                   add_alias
                         000177 long_uid                    add_alias
format_pointer_          000100 packed_sw                   format_pointer_
                         000101 pointer_rep                 format_pointer_
                         000202 valid                       format_pointer_
                         000203 real_segment                format_pointer_
                         000204 seg_ptr                     format_pointer_
                         000216 its_ptr                     edit_its_pointer
                         000220 itp_ptr                     edit_its_pointer
                         000222 ge_ptr                      edit_its_pointer
                         000232 fault_type                  edit_packed_pointer
                         000233 packed_ptr                  edit_packed_pointer
                         000234 packed_ptr_fault            edit_packed_pointer
                         000244 dname                       add_segment_name
                         000316 ename                       add_segment_name
                         000326 long_info                   add_segment_name
                         000357 idx                         add_segment_name
                         000360 code                        add_segment_name
                         000361 first_stack                 add_segment_name
                         000362 last_seg                    add_segment_name
                         000372 pdir_name                   initialize_aliases

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_ne_as             alloc_char_temp     enter_begin_block   leave_begin_block   call_ext_out_desc
call_ext_out        call_int_this_desc  return_mac          bound_ck_signal     signal_op           enable_op
shorten_stack       ext_entry           int_entry           int_entry_desc      signal_stringsize   set_chars_eis
index_chars_eis     index_after_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$get_name_for_structure   convert_status_code_          expand_pathname_              get_pdir_
hcs_$fs_get_path_name         hcs_$high_low_seg_count       hcs_$status_long              ioa_$rsnnl
ring0_get_$name

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$invalidsegno




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     22 000376        83 000406        87 000422        88 000423        89 000440        93 000441        97 000454
     98 000456        99 000473       102 000474       104 000477       105 000511       108 000527       112 000550
    119 000571       120 000575       121 000630       125 000647       128 000660       130 000663       131 000665
    135 000703       165 000705       166 000711       167 000714       169 000716       170 000717       172 000721
    174 000722       175 000727       182 001026       188 001144       192 001154       197 001174       199 001175
    200 001177       205 001272       207 001302       210 001303       214 001363       219 001364       241 001366
    242 001372       244 001375       246 001402       247 001403       249 001405       252 001412       254 001422
    261 001515       266 001604       271 001616       276 001617       292 001621       294 001622       295 001633
    297 001635       300 001676       302 001730       303 001734       304 001750       307 001751       308 001753
    309 001767       310 002003       311 002027       312 002036       315 002037       317 002053       318 002057
    319 002103       320 002115       323 002116       324 002125       325 002136       326 002154       327 002163
    328 002207       330 002210       332 002212       333 002240       334 002247       335 002273       340 002274
    347 002275       351 002301       353 002317       354 002326       355 002344       356 002354       357 002405
    360 002424       362 002447       363 002473       364 002514       365 002540       366 002561       367 002605
    368 002626       369 002652       370 002676       371 002722       372 002746       377 002747       394 002770
    396 002773       399 002776       402 003016       403 003055       404 003101       406 003102       407 003114
    408 003117       411 003120       412 003146       416 003150       418 003211       422 003213       424 003215
    425 003244       429 003246       431 003307       435 003311       437 003313       441 003315       442 003320


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
