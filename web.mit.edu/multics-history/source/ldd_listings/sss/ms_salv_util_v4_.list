	COMPILATION LISTING OF SEGMENT ms_salv_util_v4_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/09/85  1111.7 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 ms_salv_util_v4_: proc (a_forward, a_salv_ptr, a_new_alloc_ptr, a_new_ht_ptr, a_block_size, a_seg_size, a_alloc_len, a_hdr_alloc_len,
       12 	     a_mseg_access_class, a_saved_messages, a_saved_blocks, a_last_saved_ms_ptr);
       13 
       14 /* Modified for version 3 message segments by J. Stern, 10/30/74 */
       15 /* Modified by J. Stern, 11/14/75 */
       16 /* Modified 3/77 by Charlie Davis for the installation of version 4 message segments */
       17 /* Modified 4/82 by E. N. Kittlitz to detect discrepancy 'twixt ms_size and total block_count */
       18 /* Modified 1984-10-19 BIM to remove bogus access class check that deleted
       19*    messages sent down. */
       20 
       21 dcl (a_saved_blocks,				/* number of saved message blocks (argument) */
       22      a_saved_messages,				/* number of saved messages (argument) */
       23      block_bit_count,				/* bit count of message portion in block */
       24      block_hdr_size,				/* words in header */
       25      block_trailer_size,				/* words in trailer */
       26      first_full_block_bit_count,			/* bits allocated to first block message portion */
       27      full_block_bit_count,				/* bits allocated to message portion */
       28      i,						/* do loop index */
       29      htx,						/* hash table index */
       30      max_message_blocks,				/* maximum blocks in a message */
       31      message_blocks,				/* number of unchecked blocks in message */
       32      saved_blocks init (0),				/* number of saved message blocks (internal) */
       33      saved_messages init (0),				/* number of saved messages (internal) */
       34      tsaved_blocks,					/* blocks saved in message */
       35      zero_words (8) init (0, 0, 0, 0, 0, 0, 0, 0)
       36      ) fixed bin;
       37 
       38 dcl (a_alloc_len,					/* length of allocation bit string */
       39      a_hdr_alloc_len,				/* the part of alloc_len devoted to the header */
       40      a_block_size,					/* block size */
       41      a_seg_size,					/* max length of message seg */
       42      alloc_len,					/* length of allocation bit string */
       43      hdr_alloc_len,
       44      backward_offset,				/* offset to backward threaded message */
       45      bit_off,					/* offset of allocation bit for block */
       46      block_ms_words,				/* allocated size for message portion */
       47      block_offset,					/* offset to message block */
       48      block_size,					/* size of message block in words */
       49      first_block_ms_words,				/* allocated size for first block message portion */
       50      forward_offset,				/* offset to forward threaded message */
       51      max_message_size,				/* maximum words in a message */
       52      message_words,					/* word count of message */
       53      ms_offset,					/* offset to first block of message */
       54      mseg_data_v4_$block_size ext,			/* default block size */
       55      mseg_data_v4_$max_message_size ext,
       56      next_block_offset,				/* offset to next message block in message */
       57      seg_size,
       58      previous_offset init (0),			/* offset to previous message */
       59      tr_offset)					/* offset from beginning of block to trailer */
       60      fixed bin (18);
       61 
       62 dcl (a_forward,					/* ON if salvage is forward (argument) */
       63      first_block,					/* ON if block is first block in message */
       64      forward)					/* ON if salvage is forward (internal) */
       65      bit (1) aligned;
       66 
       67 dcl (a_last_saved_ms_ptr,				/* pointer to last saved message (argument) */
       68      a_new_alloc_ptr,				/* pointer to new allocation bits(argument) */
       69      a_new_ht_ptr,					/* pointer to new hash table (argument) */
       70      a_salv_ptr,					/* pointer to where to begin salvaging */
       71      last_saved_ms_ptr init (null),			/* pointer to last saved message(internal) */
       72      new_alloc_ptr,					/* pointer to new allocation bits(argument) */
       73      new_ht_ptr,					/* pointer to new hash table (internal) */
       74      next_ms_ptr,					/* pointer to next message */
       75      test_block_ptr,				/* pointer to message block being tested */
       76      test_ms_ptr)					/* pointer to message being tested */
       77      ptr;
       78 
       79 dcl  ms_size fixed bin (24);				/* used to check trailer.ms_size with hdr.block_count sum */
       80 
       81 dcl  prev_ms_id bit (72) aligned;			/* previous message id */
       82 
       83 dcl (a_mseg_access_class,
       84      mseg_access_class) bit (72) aligned;		/* message segment access class */
       85 
       86 dcl 1 new_hash_table aligned based (new_ht_ptr),		/* new hash table */
       87     2 last_in_bucket (0:511) bit (18) unaligned;
       88 
       89 dcl (addr, addrel, divide, fixed, mod, null, ptr, rel, size, substr) builtin;
       90 
       91 dcl  bit_mask (alloc_len) based (new_alloc_ptr) bit (1) unaligned; /* mask for setting allocation bits */
       92 
       93 dcl  zeroes char (32) aligned based (addr (zero_words (1)));
       94 
       95 
  1     1 /* BEGIN include file mseg_hdr_v4.incl.pl1 */
  1     2 
  1     3 declare
  1     4      1 mseg_hdr_v4 aligned based,         		/* message segment header format */
  1     5      2 lock bit (36) aligned,				/* standard file system lock */
  1     6      2 mseg_pattern bit (36) aligned,			/* to identify message segments */
  1     7      2 hdr_ms_access_class bit (72) aligned,		/* access class of header message */
  1     8    2 date_time_last_salvaged fixed bin (71),		/* time message segment was last salvaged */
  1     9      2 pad (2) fixed bin,
  1    10      2 first_ms_offset bit (18) aligned,		/* offset to first logical message */
  1    11      2 last_ms_offset bit (18) aligned,			/* offset to last logical message */
  1    12      2 alloc_len fixed bin,				/* length of allocation bit string */
  1    13      2 space_left fixed bin,				/* number of empty blocks */
  1    14      2 number_of_messages fixed bin,			/* number of messages in segment */
  1    15      2 block_size fixed bin,				/* message block size */
  1    16      2 switches,
  1    17      3 mip bit (1) unaligned,				/* ON if modification is in progress */
  1    18      3 os bit (1) unaligned,				/* ON if message segment was salvaged */
  1    19      3 ms_in_hdr bit (1) unaligned,			/* ON if there is a message in the header */
  1    20      3 sip bit (1) unaligned,				/* ON if salvage is in progress */
  1    21      3 pad2 bit (32) unaligned,
  1    22      2 version_number fixed bin,
  1    23      2 hdr_ms bit (64 * 36) aligned,			/* space for header message */
  1    24      2 hash_table aligned,				/* message ID hash table */
  1    25      3 last_in_bucket (0:511) bit (18) unaligned,		/* offset of last message in this hash table bucket */
  1    26      2 alloc_bits bit (0 refer (mseg_hdr_v4.alloc_len)) aligned;/* allocation bit string */
  1    27 
  1    28 /* END include file mseg_hdr.incl.pl1 */
       96 
       97 dcl mptr pointer;
       98 
  2     1 /* BEGIN Message Block Header include file */
  2     2 
  2     3 dcl  block_ptr ptr,					/* pointer to message block */
  2     4 
  2     5      1 ms_block_hdr aligned based(block_ptr),		/* message block header structure */
  2     6       2 f_offset bit(18) unaligned,			/* offset to next block of message */
  2     7       2 first_block bit(1) unaligned,			/* ON if block is first in message */
  2     8       2 block_count bit(17) unaligned;			/* number of message bits in block */
  2     9 
  2    10 /* END Message Block Header include file */
       99 
      100 
  3     1 /* BEGIN include file ms_block_trailer.incl.pl1 */
  3     2 
  3     3 dcl  tr_ptr ptr,					/* pointer to message block trailer area */
  3     4 
  3     5      1 ms_block_trailer aligned based (tr_ptr),		/* message block trailer structure */
  3     6      2 tr_pattern bit (36) aligned,			/* for identifying beginning of trailer */
  3     7      2 f_offset bit (18) unaligned,			/* offset to next logical message */
  3     8      2 b_offset bit (18) unaligned,			/* offset to previous logical message */
  3     9      2 ring_no bit (18) unaligned,			/* validation level */
  3    10      2 back_in_bucket bit (18) unaligned,		/* offset of preceding message in same hash bucket */
  3    11      2 ms_id bit (72) aligned,			/* message id */
  3    12      2 ms_size bit (24) unaligned,			/* bit count of message */
  3    13      2 pad bit (12) unaligned,
  3    14      2 sender_id char (32) aligned,			/* id of message sender */
  3    15      2 sender_authorization bit (72) aligned,		/* access authorization of message sender */
  3    16      2 access_class bit (72) aligned;			/* access class of this message */
  3    17 
  3    18 dcl  trailer_pattern bit (36) aligned init ((36) "1"b)	/* trailer identification pattern */
  3    19      internal static;
  3    20 
  3    21 /* END include file ms_block_trailer.incl.pl1 */
      101 
      102 
      103 
      104 dcl  aim_check_$greater_or_equal ext entry
      105     (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      106 
      107 /*  */
      108 
      109 	mptr = ptr (a_salv_ptr, 0);			/* make pointer to message segment */
      110 
      111 	max_message_size = mseg_data_v4_$max_message_size;
      112 	block_size = a_block_size;
      113 	max_message_blocks = divide (max_message_size, block_size, 18, 0); /* compute max blocks in message */
      114 	block_hdr_size = size (ms_block_hdr);
      115 	block_trailer_size = size (ms_block_trailer);
      116 
      117 	forward = a_forward;			/* copy argument */
      118 	next_ms_ptr = a_salv_ptr;			/* where to begin salvaging */
      119 	seg_size = a_seg_size;
      120 	alloc_len = a_alloc_len;
      121 	hdr_alloc_len = a_hdr_alloc_len;
      122 	ms_offset = fixed (rel (next_ms_ptr), 18);	/* offset of where to begin salvaging */
      123 	call check_offset (ms_offset);
      124 	new_alloc_ptr = a_new_alloc_ptr;		/* copy argument */
      125 	new_ht_ptr = a_new_ht_ptr;
      126 	mseg_access_class = a_mseg_access_class;
      127 	tr_offset = block_size - block_trailer_size;	/* initialize trailer offset */
      128 	first_block_ms_words =			/* intialize word count of full first block */
      129 	     block_size - (block_hdr_size + block_trailer_size);
      130 	first_full_block_bit_count =			/* initialize bit count of full first block */
      131 	     first_block_ms_words * 36;
      132 	full_block_bit_count =			/* initialize bit count of full block */
      133 	     (block_size - block_hdr_size) * 36;
      134 	block_ms_words =				/* initialize word count of full block */
      135 	     block_size - block_hdr_size;
      136 	if forward then prev_ms_id = (72) "0"b;
      137 	else prev_ms_id = (72) "1"b;
      138 
      139 /*  */
      140 
      141 	begin;
      142 
      143 dcl  bit_offset (max_message_blocks) fixed bin (18);	/* array of offsets into alloc bits */
      144 
      145 CHECK_MESSAGE:
      146 
      147 	     first_block = "1"b;			/* remember this is a first block of a message */
      148 	     tsaved_blocks = 0;			/* initialize blocks saved in message */
      149 
      150 	     test_ms_ptr = next_ms_ptr;		/* set pointer to message to be tested */
      151 	     ms_offset = fixed (rel (next_ms_ptr), 18);	/* set offset of message to be tested */
      152 	     tr_ptr = addrel (test_ms_ptr, tr_offset);	/* make a pointer to the trailer */
      153 	     if tr_ptr -> ms_block_trailer.tr_pattern ^= trailer_pattern /* no trailer pattern */
      154 	     then call FIN;
      155 	     forward_offset =			/* get offset to next message */
      156 		fixed (tr_ptr -> ms_block_trailer.f_offset, 18);
      157 	     if forward_offset ^= 0
      158 	     then call check_offset (forward_offset);	/* forward offset off end of segment */
      159 	     else if mptr -> mseg_hdr_v4.last_ms_offset ^= rel (test_ms_ptr) /* header doesn't agree */
      160 	     then call FIN;			/* give up */
      161 	     backward_offset =			/* get offset to previous message */
      162 		fixed (tr_ptr -> ms_block_trailer.b_offset, 18);
      163 	     if backward_offset ^= 0
      164 	     then call check_offset (backward_offset);	/* previous offset off end of message */
      165 	     else if mptr -> mseg_hdr_v4.first_ms_offset ^= rel (test_ms_ptr) /* header doesn't agree */
      166 	     then call FIN;
      167 
      168 	     if ms_block_trailer.ms_size = "0"b		/* check for zeroing out */
      169 	     | ms_block_trailer.ms_id = "0"b
      170 	     | ms_block_trailer.sender_id = zeroes
      171 	     then call FIN;
      172 
      173 	     if ^aim_check_$greater_or_equal (mseg_access_class, ms_block_trailer.access_class)
      174 	     then call FIN;
      175 
      176 	     htx = fixed (substr (ms_block_trailer.ms_id, 64, 9));	/* get hash table index of message */
      177 	     block_offset = fixed (tr_ptr -> ms_block_trailer.back_in_bucket); 
      178 	     if block_offset ^= 0			/* not end of thread */
      179 	     then call check_offset (block_offset);	/* check the hash bucket offset */
      180 
      181 	     if (forward)				/* forward salvage */
      182 	     then do;
      183 
      184 		if previous_offset ^= 0		/* there was a previous message */
      185 		then if backward_offset ^=
      186 		     previous_offset		/* this message doesn't point to it */
      187 		     then call FIN;		/* give up */
      188 		next_ms_ptr = ptr (test_ms_ptr, forward_offset);
      189 
      190 		if substr (prev_ms_id, 19, 54) >= substr (ms_block_trailer.ms_id, 19, 54)
      191 		then do;				/* should be monotonically increasing */
      192 		     ms_block_trailer.ms_id = ""b;	/* make ms_id look bad for backward salvage too!! */
      193 		     call FIN;
      194 		end;
      195 
      196 	     end;
      197 
      198 	     else					/* backward salvage */
      199 	     do;
      200 
      201 		if previous_offset ^= 0		/* there was a previous message */
      202 		then if forward_offset ^=
      203 		     previous_offset		/* this message doesn't point to it */
      204 		     then call FIN;		/* give up */
      205 		next_ms_ptr = ptr (test_ms_ptr, backward_offset);
      206 
      207 		if substr (prev_ms_id, 19, 54) <= substr (ms_block_trailer.ms_id, 19, 54)
      208 		then call FIN;			/* should be monotonically decreasing */
      209 
      210 	     end;
      211 
      212 	     previous_offset = ms_offset;		/* remember for next message check */
      213 	     prev_ms_id = ms_block_trailer.ms_id;
      214 
      215 	     ms_size = fixed (tr_ptr -> ms_block_trailer.ms_size, 24);
      216 	     message_words =			/* calculate number of words in message */
      217 		divide (ms_size + 35, 36, 18, 0);
      218 
      219 	     if message_words <= 0			/* bad word count */
      220 	     then call FIN;			/* give up */
      221 	     if message_words > max_message_size
      222 	     then call FIN;
      223 
      224 	     if message_words <= first_block_ms_words	/* calculate blocks in message */
      225 	     then message_blocks = 1;
      226 	     else
      227 	     message_blocks =
      228 		divide (message_words-first_block_ms_words+block_ms_words-1, block_ms_words, 17, 0)+1;
      229 	     block_offset = ms_offset;
      230 
      231 	     test_block_ptr = test_ms_ptr;		/* set pointer for testing rest of block */
      232 
      233 /*  */
      234 
      235 /* check the block header */
      236 
      237 CHECK_BLOCK:
      238 
      239 /* check to see if the block has been allocated */
      240 
      241 	     bit_off = divide (block_offset, block_size, 18, 0)+1; /* calculate bit offset in alloc bits */
      242 
      243 	     do i = 1 to tsaved_blocks;		/* check against other blocks in this message */
      244 		if bit_offset (i) = bit_off		/* block is used */
      245 		then call FIN;			/* give up */
      246 	     end;
      247 
      248 	     if new_alloc_ptr -> bit_mask (bit_off) = "1"b /* block is used */
      249 	     then call FIN;
      250 
      251 	     if test_block_ptr -> ms_block_hdr.first_block ^=
      252 	     first_block				/* bad first block flag */
      253 	     then call FIN;
      254 
      255 	     block_bit_count =			/* get size of message portion in block */
      256 		fixed (test_block_ptr -> ms_block_hdr.block_count, 17);
      257 	     if block_bit_count <= 0			/* bad block bit count */
      258 	     then call FIN;			/* give up */
      259 
      260 	     ms_size = ms_size - block_bit_count;	/* decrement total size of message */
      261 	     if ms_size < 0 then call FIN;		/* disagreement between trailer and total of blocks */
      262 
      263 	     if (first_block)			/* first block of a message */
      264 	     then do;
      265 
      266 		if message_blocks ^= 1		/* another block follows */
      267 		then do;
      268 		     if block_bit_count ^=
      269 		     first_full_block_bit_count	/* error in block bit count */
      270 		     then call FIN;
      271 		end;
      272 		else				/* no blocks follow */
      273 		if block_bit_count >
      274 		first_full_block_bit_count		/* error in block bit count */
      275 		then call FIN;
      276 	     end;
      277 
      278 	     else					/* not first block in message */
      279 	     do;
      280 		if message_blocks ^= 1		/* another block follows */
      281 		then do;
      282 		     if block_bit_count ^=
      283 		     full_block_bit_count		/* error in block bit count */
      284 		     then call FIN;		/* give up */
      285 		end;
      286 		else				/* last block in message */
      287 		if block_bit_count > full_block_bit_count /* bad block bit count */
      288 		then call FIN;			/* give up */
      289 	     end;
      290 
      291 	     next_block_offset =			/* get the offset to the next message block */
      292 		fixed (test_block_ptr -> ms_block_hdr.f_offset, 18);
      293 
      294 	     bit_offset (tsaved_blocks + 1) = bit_off;	/* remember location of block */
      295 
      296 	     if message_blocks = 1			/* last block in message */
      297 	     then do;
      298 		if next_block_offset ^= 0		/* block pointer bad */
      299 		then call FIN;
      300 		else if ms_size ^= 0		/* disagreement between trailer.ms_size and sum of blocks */
      301 		then call FIN;
      302 		else				/* legitimate end of message */
      303 		do;
      304 		     saved_blocks =			/* add in saved blocks */
      305 			saved_blocks + tsaved_blocks +1;
      306 		     do i = 1 to tsaved_blocks + 1;	/* turn on the appropriate allocation bits */
      307 			new_alloc_ptr -> bit_mask (bit_offset (i)) = "1"b;
      308 		     end;
      309 		     back_in_bucket = new_hash_table.last_in_bucket (htx); /* set back ptr to previous last */
      310 		     new_hash_table.last_in_bucket (htx) = rel (test_ms_ptr); /* make this one the last in bucket */
      311 		     saved_messages =		/* add in saved message */
      312 			saved_messages + 1;
      313 		     last_saved_ms_ptr = test_ms_ptr;	/* set pointer to saved message */
      314 		     go to CHECK_MESSAGE;
      315 		end;
      316 	     end;
      317 
      318 	     else					/* not end of message */
      319 	     do;
      320 		call check_offset (next_block_offset);	/* check offset to next block */
      321 		first_block = "0"b;			/* remember next block is not a first block */
      322 		message_blocks = message_blocks - 1;	/* decrement blocks left to check */
      323 		tsaved_blocks = tsaved_blocks + 1;	/* increment temporary saved block count */
      324 		block_offset = next_block_offset;	/* reset for testing next block */
      325 		test_block_ptr =			/* make a pointer to the next block */
      326 		     ptr (test_block_ptr, next_block_offset);
      327 		go to CHECK_BLOCK;
      328 	     end;
      329 
      330 	end;					/* of BEGIN block */
      331 
      332 /*  */
      333 
      334 FIN:	procedure;
      335 	go to GIVE_UP_AND_RETURN;
      336 	end FIN;
      337 
      338 GIVE_UP_AND_RETURN:
      339 	a_saved_messages = saved_messages;		/* return appropriate values */
      340 	a_saved_blocks = saved_blocks;
      341 	a_last_saved_ms_ptr = last_saved_ms_ptr;
      342 	return;
      343 
      344 
      345 check_offset: proc (a_relp);				/* procedure to check validity of an offset */
      346 
      347 dcl (a_relp, relp) fixed bin (18);
      348 
      349 	     relp = a_relp;
      350 	     if relp + block_size > seg_size then call FIN; /* offset beyond max length of segment */
      351 	     if mod (relp, block_size) ^= 0 then call FIN; /* not offset of a block */
      352 	     relp = divide (relp, block_size, 18, 0) +1;	/* convert block offset to block number */
      353 	     if relp <= hdr_alloc_len then call FIN;	/* offset within header blocks */
      354 	     if relp > alloc_len then call FIN;	/* offset beyond last block */
      355 
      356 	end check_offset;
      357 
      358      end ms_salv_util_v4_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/06/85  1619.0  ms_salv_util_v4_.pl1              >spec>on>mseg>ms_salv_util_v4_.pl1
96           1    05/06/85  1121.9  mseg_hdr_v4.incl.pl1              >spec>on>mseg>mseg_hdr_v4.incl.pl1
99           2    05/06/85  1121.7  ms_block_hdr_v4.incl.pl1          >spec>on>mseg>ms_block_hdr_v4.incl.pl1
101          3    05/06/85  1121.7  ms_block_trailer_v4.incl.pl1      >spec>on>mseg>ms_block_trailer_v4.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_alloc_len                            parameter       fixed bin(18,0)          dcl 38 ref 11 120
a_block_size                           parameter       fixed bin(18,0)          dcl 38 ref 11 112
a_forward                              parameter       bit(1)                   dcl 62 ref 11 117
a_hdr_alloc_len                        parameter       fixed bin(18,0)          dcl 38 ref 11 121
a_last_saved_ms_ptr                    parameter       pointer                  dcl 67 set ref 11 341*
a_mseg_access_class                    parameter       bit(72)                  dcl 83 ref 11 126
a_new_alloc_ptr                        parameter       pointer                  dcl 67 ref 11 124
a_new_ht_ptr                           parameter       pointer                  dcl 67 ref 11 125
a_relp                                 parameter       fixed bin(18,0)          dcl 347 ref 345 349
a_salv_ptr                             parameter       pointer                  dcl 67 ref 11 109 118
a_saved_blocks                         parameter       fixed bin(17,0)          dcl 21 set ref 11 340*
a_saved_messages                       parameter       fixed bin(17,0)          dcl 21 set ref 11 338*
a_seg_size                             parameter       fixed bin(18,0)          dcl 38 ref 11 119
access_class             20            based           bit(72)                  level 2 dcl 3-3 set ref 173*
addr                                                   builtin function         dcl 89 ref 168
addrel                                                 builtin function         dcl 89 ref 152
aim_check_$greater_or_equal     000012 constant        entry                    external dcl 104 ref 173
alloc_len                       000124 automatic       fixed bin(18,0)          dcl 38 set ref 120* 354
b_offset                  1(18)        based           bit(18)                  level 2 packed unaligned dcl 3-3 ref 161
back_in_bucket            2(18)        based           bit(18)                  level 2 packed unaligned dcl 3-3 set ref 177 309*
backward_offset                 000126 automatic       fixed bin(18,0)          dcl 38 set ref 161* 163 163* 184 205
bit_mask                               based           bit(1)                   array unaligned dcl 91 set ref 248 307*
bit_off                         000127 automatic       fixed bin(18,0)          dcl 38 set ref 237* 244 248 294
bit_offset                      000100 automatic       fixed bin(18,0)          array dcl 143 set ref 244 294* 307
block_bit_count                 000100 automatic       fixed bin(17,0)          dcl 21 set ref 255* 257 260 268 272 282 286
block_count               0(19)        based           bit(17)                  level 2 packed unaligned dcl 2-3 ref 255
block_hdr_size                  000101 automatic       fixed bin(17,0)          dcl 21 set ref 114* 128 132 134
block_ms_words                  000130 automatic       fixed bin(18,0)          dcl 38 set ref 134* 226 226
block_offset                    000131 automatic       fixed bin(18,0)          dcl 38 set ref 177* 178 178* 229* 237 324*
block_ptr                              automatic       pointer                  dcl 2-3 ref 114
block_size                      000132 automatic       fixed bin(18,0)          dcl 38 set ref 112* 113 127 128 132 134 237 350 351
                                                                                  352
block_trailer_size              000102 automatic       fixed bin(17,0)          dcl 21 set ref 115* 127 128
divide                                                 builtin function         dcl 89 ref 113 216 226 237 352
f_offset                  1            based           bit(18)                  level 2 in structure "ms_block_trailer" packed
                                                                                  unaligned dcl 3-3 in procedure "ms_salv_util_v4_"
                                                                                  ref 155
f_offset                               based           bit(18)                  level 2 in structure "ms_block_hdr" packed unaligned
                                                                                  dcl 2-3 in procedure "ms_salv_util_v4_" ref 291
first_block                     000144 automatic       bit(1)                   dcl 62 in procedure "ms_salv_util_v4_" set ref 145*
                                                                                  251 263 321*
first_block               0(18)        based           bit(1)                   level 2 in structure "ms_block_hdr" packed unaligned
                                                                                  dcl 2-3 in procedure "ms_salv_util_v4_" ref 251
first_block_ms_words            000133 automatic       fixed bin(18,0)          dcl 38 set ref 128* 130 224 226
first_full_block_bit_count      000103 automatic       fixed bin(17,0)          dcl 21 set ref 130* 268 272
first_ms_offset          10            based           bit(18)                  level 2 dcl 1-3 ref 165
fixed                                                  builtin function         dcl 89 ref 122 151 155 161 176 177 215 255 291
forward                         000145 automatic       bit(1)                   dcl 62 set ref 117* 136 181
forward_offset                  000134 automatic       fixed bin(18,0)          dcl 38 set ref 155* 157 157* 188 201
full_block_bit_count            000104 automatic       fixed bin(17,0)          dcl 21 set ref 132* 282 286
hdr_alloc_len                   000125 automatic       fixed bin(18,0)          dcl 38 set ref 121* 353
htx                             000106 automatic       fixed bin(17,0)          dcl 21 set ref 176* 309 310
i                               000105 automatic       fixed bin(17,0)          dcl 21 set ref 243* 244* 306* 307*
last_in_bucket                         based           bit(18)                  array level 2 packed unaligned dcl 86 set ref 309
                                                                                  310*
last_ms_offset           11            based           bit(18)                  level 2 dcl 1-3 ref 159
last_saved_ms_ptr               000146 automatic       pointer                  initial dcl 67 set ref 67* 313* 341
max_message_blocks              000107 automatic       fixed bin(17,0)          dcl 21 set ref 113* 143
max_message_size                000135 automatic       fixed bin(18,0)          dcl 38 set ref 111* 113 221
message_blocks                  000110 automatic       fixed bin(17,0)          dcl 21 set ref 224* 226* 266 280 296 322* 322
message_words                   000136 automatic       fixed bin(18,0)          dcl 38 set ref 216* 219 221 224 226
mod                                                    builtin function         dcl 89 ref 351
mptr                            000170 automatic       pointer                  dcl 97 set ref 109* 159 165
ms_block_hdr                           based           structure                level 1 dcl 2-3 ref 114
ms_block_trailer                       based           structure                level 1 dcl 3-3 set ref 115
ms_id                     3            based           bit(72)                  level 2 dcl 3-3 set ref 168 176 190 192* 207 213
ms_offset                       000137 automatic       fixed bin(18,0)          dcl 38 set ref 122* 123* 151* 212 229
ms_size                         000162 automatic       fixed bin(24,0)          dcl 79 in procedure "ms_salv_util_v4_" set ref 215*
                                                                                  216 260* 260 261 300
ms_size                   5            based           bit(24)                  level 2 in structure "ms_block_trailer" packed
                                                                                  unaligned dcl 3-3 in procedure "ms_salv_util_v4_"
                                                                                  ref 168 215
mseg_access_class               000166 automatic       bit(72)                  dcl 83 set ref 126* 173*
mseg_data_v4_$max_message_size  000010 external static fixed bin(18,0)          dcl 38 ref 111
mseg_hdr_v4                            based           structure                level 1 dcl 1-3
new_alloc_ptr                   000150 automatic       pointer                  dcl 67 set ref 124* 248 307
new_hash_table                         based           structure                level 1 dcl 86
new_ht_ptr                      000152 automatic       pointer                  dcl 67 set ref 125* 309 310
next_block_offset               000140 automatic       fixed bin(18,0)          dcl 38 set ref 291* 298 320* 324 325
next_ms_ptr                     000154 automatic       pointer                  dcl 67 set ref 118* 122 150 151 188* 205*
null                                                   builtin function         dcl 89 ref 67
prev_ms_id                      000164 automatic       bit(72)                  dcl 81 set ref 136* 137* 190 207 213*
previous_offset                 000142 automatic       fixed bin(18,0)          initial dcl 38 set ref 38* 184 184 201 201 212*
ptr                                                    builtin function         dcl 89 ref 109 188 205 325
rel                                                    builtin function         dcl 89 ref 122 151 159 165 310
relp                            000100 automatic       fixed bin(18,0)          dcl 347 set ref 349* 350 351 352* 352 353 354
saved_blocks                    000111 automatic       fixed bin(17,0)          initial dcl 21 set ref 21* 304* 304 340
saved_messages                  000112 automatic       fixed bin(17,0)          initial dcl 21 set ref 21* 311* 311 338
seg_size                        000141 automatic       fixed bin(18,0)          dcl 38 set ref 119* 350
sender_id                 6            based           char(32)                 level 2 dcl 3-3 ref 168
size                                                   builtin function         dcl 89 ref 114 115
substr                                                 builtin function         dcl 89 ref 176 190 190 207 207
test_block_ptr                  000156 automatic       pointer                  dcl 67 set ref 231* 251 255 291 325* 325
test_ms_ptr                     000160 automatic       pointer                  dcl 67 set ref 150* 152 159 165 188 205 231 310 313
tr_offset                       000143 automatic       fixed bin(18,0)          dcl 38 set ref 127* 152
tr_pattern                             based           bit(36)                  level 2 dcl 3-3 ref 153
tr_ptr                          000172 automatic       pointer                  dcl 3-3 set ref 115 152* 153 155 161 168 168 168 173
                                                                                  176 177 190 192 207 213 215 309
trailer_pattern                 000010 constant        bit(36)                  initial dcl 3-18 ref 153
tsaved_blocks                   000113 automatic       fixed bin(17,0)          dcl 21 set ref 148* 243 294 304 306 323* 323
zero_words                      000114 automatic       fixed bin(17,0)          initial array dcl 21 set ref 21* 21* 21* 21* 21* 21*
                                                                                  21* 21* 168
zeroes                                 based           char(32)                 dcl 93 ref 168

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
mseg_data_v4_$block_size               external static fixed bin(18,0)          dcl 38

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_BLOCK                     000562 constant        label                    dcl 237 ref 327
CHECK_MESSAGE                   000210 constant        label                    dcl 145 ref 314
FIN                             001100 constant        entry                    internal dcl 334 ref 153 159 165 168 173 184 193 201
                                                                                  207 219 221 244 248 251 257 261 268 272 282 286
                                                                                  298 300 350 351 353 354
GIVE_UP_AND_RETURN              001067 constant        label                    dcl 338 ref 335
check_offset                    001111 constant        entry                    internal dcl 345 ref 123 157 163 178 320
ms_salv_util_v4_                000025 constant        entry                    external dcl 11

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1264        1300    1174        1274
Length      1524    1174        14         207      70           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ms_salv_util_v4_                    132 external procedure  is an external procedure.  
begin block on line 141              88 begin block         uses auto adjustable storage.  
FIN                                  64 internal procedure  is called by several nonquick procedures.  
check_offset                         65 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 141  000100 bit_offset                  begin block on line 141
check_offset             000100 relp                        check_offset
ms_salv_util_v4_         000100 block_bit_count             ms_salv_util_v4_
                         000101 block_hdr_size              ms_salv_util_v4_
                         000102 block_trailer_size          ms_salv_util_v4_
                         000103 first_full_block_bit_count  ms_salv_util_v4_
                         000104 full_block_bit_count        ms_salv_util_v4_
                         000105 i                           ms_salv_util_v4_
                         000106 htx                         ms_salv_util_v4_
                         000107 max_message_blocks          ms_salv_util_v4_
                         000110 message_blocks              ms_salv_util_v4_
                         000111 saved_blocks                ms_salv_util_v4_
                         000112 saved_messages              ms_salv_util_v4_
                         000113 tsaved_blocks               ms_salv_util_v4_
                         000114 zero_words                  ms_salv_util_v4_
                         000124 alloc_len                   ms_salv_util_v4_
                         000125 hdr_alloc_len               ms_salv_util_v4_
                         000126 backward_offset             ms_salv_util_v4_
                         000127 bit_off                     ms_salv_util_v4_
                         000130 block_ms_words              ms_salv_util_v4_
                         000131 block_offset                ms_salv_util_v4_
                         000132 block_size                  ms_salv_util_v4_
                         000133 first_block_ms_words        ms_salv_util_v4_
                         000134 forward_offset              ms_salv_util_v4_
                         000135 max_message_size            ms_salv_util_v4_
                         000136 message_words               ms_salv_util_v4_
                         000137 ms_offset                   ms_salv_util_v4_
                         000140 next_block_offset           ms_salv_util_v4_
                         000141 seg_size                    ms_salv_util_v4_
                         000142 previous_offset             ms_salv_util_v4_
                         000143 tr_offset                   ms_salv_util_v4_
                         000144 first_block                 ms_salv_util_v4_
                         000145 forward                     ms_salv_util_v4_
                         000146 last_saved_ms_ptr           ms_salv_util_v4_
                         000150 new_alloc_ptr               ms_salv_util_v4_
                         000152 new_ht_ptr                  ms_salv_util_v4_
                         000154 next_ms_ptr                 ms_salv_util_v4_
                         000156 test_block_ptr              ms_salv_util_v4_
                         000160 test_ms_ptr                 ms_salv_util_v4_
                         000162 ms_size                     ms_salv_util_v4_
                         000164 prev_ms_id                  ms_salv_util_v4_
                         000166 mseg_access_class           ms_salv_util_v4_
                         000170 mptr                        ms_salv_util_v4_
                         000172 tr_ptr                      ms_salv_util_v4_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
enter_begin         leave_begin         call_ext_out        call_int_this       call_int_other      return
tra_ext             alloc_auto_adj      mod_fx1             ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
aim_check_$greater_or_equal

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mseg_data_v4_$max_message_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000014        21 000032        38 000065        67 000066       109 000070       111 000074       112 000076
    113 000100       114 000103       115 000105       117 000107       118 000112       119 000115       120 000117
    121 000121       122 000123       123 000126       124 000134       125 000140       126 000143       127 000147
    128 000152       130 000160       132 000162       134 000166       136 000171       137 000176       141 000200
    143 000203       145 000210       148 000213       150 000214       151 000216       152 000221       153 000225
    155 000235       157 000242       159 000254       161 000265       163 000272       165 000304       168 000315
    173 000337       176 000364       177 000371       178 000374       181 000405       184 000410       188 000421
    190 000426       192 000437       193 000442       196 000447       201 000450       205 000461       207 000466
    212 000505       213 000510       215 000514       216 000517       219 000522       221 000530       224 000541
    226 000550       229 000556       231 000560       237 000562       243 000567       244 000600       246 000611
    248 000614       251 000627       255 000642       257 000646       260 000655       261 000660       263 000667
    266 000672       268 000675       271 000705       272 000706       276 000716       280 000717       282 000722
    285 000732       286 000733       291 000743       294 000747       296 000752       298 000755       300 000765
    304 000775       306 001001       307 001012       308 001020       309 001022       310 001031       311 001036
    313 001037       314 001041       316 001042       320 001043       321 001052       322 001054       323 001056
    324 001057       325 001061       327 001065       330 001066       338 001067       340 001072       341 001074
    342 001076       334 001077       335 001105       345 001110       349 001116       350 001121       351 001132
    352 001144       353 001151       354 001160       356 001171


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
