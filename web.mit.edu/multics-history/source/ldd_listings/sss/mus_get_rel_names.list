	COMPILATION LISTING OF SEGMENT mus_get_rel_names
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1349.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 mus_get_rel_names: proc (dsm_sw, rmra_ptr, fa_index, wa_ptr, fm_ptr, rns_ptr, error_code);
       19 
       20 /* DESCRIPTION:
       21*
       22*   For  a  given  file  in  a  submodel or model, return an array of relations
       23*   defined  for  that  file,  giving  the  number  of  relations, and for each
       24*   relation  giving  the  number  of  attributes,  the model name and rel_info
       25*   pointer, and the number of links it is involved in as parent and/or child.
       26*
       27*
       28*
       29*   PARAMETERS:
       30*
       31*   dsm_sw  -  -  (input) bit (1), ON => this is a submodel file, else => model
       32*   file
       33*
       34*   rmra_ptr  -  -  (input)  pointer to the resultant model file array for this
       35*   opening  of  the  database,  which  contains file names and pointers to the
       36*   resultant file_info structures
       37*
       38*   fa_index  -  -  (input)  fixed  bin,  index  into the file array giving the
       39*   desired file for which to return relation information
       40*
       41*   wa_ptr  -  -  (input)  pointer to an area in which to allocate the relation
       42*   information array to be returned
       43*
       44*   fm_ptr - - (input) pointer to the database file model for this file
       45*
       46*   rns_ptr  -  -  (output) pointer to the rel_names array structure containing
       47*   relation  model and submodel name, and it's rel_info pointer as well as the
       48*   attribute, parent link, and child link count
       49*
       50*   error_code  -  -  (output) fixed bin (35), error type encoding, 0 unless an
       51*   error occurred
       52*
       53*   sub_error_  -  -  (output)  condition, signaled upon occurrence of error to
       54*   provide more info
       55*
       56*
       57*
       58*   HISTORY:
       59*
       60*   78-08-01 Oris D. Friesen: Originally written.
       61*
       62*   79-06-01 Jim Gray : Modified as follows:
       63*   1) add sub_err_ reporting of errors
       64*   2) change from freeing to area deleting in higher routine for cleanup
       65*   3) document the program interface and logic
       66*
       67*   80-04-01 Jim Gray : Modified to add total_view bit to relation info so that
       68*   submodel permissions can be determined.
       69*
       70*   80-08-01  Lindsey Spratt: Modified to use the new submodel security system.
       71*   This  involved changing all calls to dsmd_$foo to be calls to mrds_dsm_foo,
       72*   adding  an  external  static  submodel_iocb_ptr, setting the rel_names.item
       73*   access  permission  bits, and using the relation_block structure instead of
       74*   the  mrds_dsm_relation_str  structure.  Also, added the mrds_dsm_entry_dcls
       75*   and the mrds_dsm_rel_block include files.
       76*
       77*   80-09-23 Davids: modified so that rel_names.item.r_per (i), m_perm, s_perm,
       78*   and d_perm are set to "1"b when opening is done via the model.
       79*
       80*   80-11-07  Jim Gray : Modified to set the status_perm bit from dsm_rel_flags
       81*   bit  1,  status_perm  (perviously  r_perm) had never been set from submodel
       82*   processed access permission, and was just always set to true.
       83*
       84*   80-12-30  Davids:  modified  internal  procedure  submodel_relation so that
       85*   rel_names.item.status_perm  is  always  "0"b  since  it  no  longer has any
       86*   meaning  and  append_tuple  and  delete_tuple  come  from  bits  1 and 2 of
       87*   relation_block.dsm_rel_flags.access  rather than bits 2 and 3.  when status
       88*   went away the bit positions where shifted and because of the implementation
       89*   of  compute_access  it  is  easier to change the bit position meanings than
       90*   shift them back.
       91*
       92*   81-01-12   Davids:  took  the  call  to  mrds_dsm_read_relation  which  was
       93*   incorrectly  used  to  set  up  a  mrds_dsm_relation_names  str  out of the
       94*   submodel_relation     procedure    and    instead    just    allocated    a
       95*   mrds_dsm_relation_names  str.   the  relation name is currently correct but
       96*   may  not  be  forever.   as  soon as an interface for files in submodels is
       97*   built this code should change
       98*
       99*   81-01-14 Davids: modified to use the new relation_block structure which has
      100*   individual variables for all the relation access rather than doing substr's
      101*   from a bit string.
      102*
      103*   81-01-28   Davids:  changed  drel_ptr  to  mrds_dsm_relation_names_ptr  and
      104*   nrels_alloc to mrds_dsm_relation_names_nrels_alloc to correspond to changes
      105*   in the mrds_dsm_relation_names include file.
      106*
      107*   81-05-21    Rickie    E.    Brinegar:   changed   to   use   the   modified
      108*   mrds_dsm_relation_names  include file.  The structure name was changed from
      109*   dsm_relation_names to mrds_dsm_relation_names.
      110*
      111*   81-05-29 Jim Gray : modified to use new mdbm_rel_att_array structures,
      112*   modified to remove foreign key information.
      113*
      114*
      115**/
      116 
      117 /* initialize */
      118 
      119 	error_code = 0;
      120 	rns_ptr = null;
      121 	rmri_ptr = rm_rel_array.rel_data.ri_ptr (fa_index);
      122 
      123 /* fill in the relation array information */
      124 
      125 	if dsm_sw then
      126 	     call submodel_relation ();
      127 	else call model_relation ();
      128 
      129 	return;
      130 
      131 submodel_relation: procedure ();
      132 	mrds_dsm_relation_names_nrels_alloc = 1;
      133 	allocate mrds_dsm_relation_names set (mrds_dsm_relation_names_ptr) in (work_area);
      134 	mrds_dsm_relation_names_ptr -> mrds_dsm_relation_names.relation (1) = rm_rel_array.name.submodel (fa_index);
      135 
      136 /* get space for the return structure array */
      137 
      138 	num_rels_init = mrds_dsm_relation_names.nrels;
      139 	allocate rel_names set (rns_ptr) in (work_area);
      140 	rel_names.num = num_rels_init;
      141 
      142 /* then get the dsm relation definition record for each rel. in above list --
      143*   this gives us the corresponding data model name */
      144 
      145 	do i = 1 to mrds_dsm_relation_names.nrels while (error_code = 0);
      146 
      147 	     call mrds_dsm_read_relation (mrds_dsm_relation_names.relation (i),
      148 		wa_ptr, relation_block_ptr, submodel_iocb_ptr, error_code);
      149 	     if error_code ^= 0 then
      150 		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      151 		     "Unable to get the submodel information for relation """,
      152 		     mrds_dsm_relation_names (i).relation, """.");
      153 	     else if relation_block.version ^= RELATION_BLOCK_VERSION_1
      154 	     then do;
      155 		     error_code = error_table_$unimplemented_version;
      156 		     call sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
      157 			"Expecting version ^d, actually got version ^d.",
      158 			RELATION_BLOCK_VERSION_1, relation_block.version);
      159 		end;
      160 	     else do;
      161 
      162 /* now find the corresponding rel_info structure in the file_model */
      163 
      164 		     do ri_ptr = ptr (fm_ptr, file_model.rel_ptr)
      165 			repeat ptr (fm_ptr, rel_info.fwd_thread)
      166 			while (relation_block.dm_rel_name ^=
      167 			rel_info.name);
      168 		     end;
      169 
      170 /* fill in the rel_names array information for this relation */
      171 
      172 		     rel_names.item.natts (i) = relation_block.no_rb_attributes;
      173 		     rel_names.item.sm (i) = mrds_dsm_relation_names.relation (i);
      174 		     rel_names.item.dm (i) = rel_info.name;
      175 		     rel_names.item.ri_ptr (i) = ri_ptr;
      176 		     rel_names.item.total_view (i) = (rel_info.num_attr =
      177 			relation_block.no_rb_attributes);
      178 		     rel_names.item.status_perm (i) = "0"b;
      179 		     rel_names.item.unused_perm (i) = "0"b;
      180 		     rel_names.item.append_tuple_perm (i) = relation_block.rel_access.append;
      181 		     rel_names.item.delete_tuple_perm (i) = relation_block.rel_access.delete;
      182 		     rel_names.item.pad (i) = "0"b;
      183 
      184 		end;
      185 
      186 	end;
      187 
      188      end;
      189 
      190 model_relation: procedure ();
      191 
      192 /* get the number of model relations for this file,
      193*   and then get space for the return structure array */
      194 
      195 	num_rels_init = file_model.num_rels;
      196 	allocate rel_names set (rns_ptr) in (work_area);
      197 	rel_names.num = num_rels_init;
      198 
      199 /* fill in the rel_names array for each relation in this file */
      200 
      201 	i = 1;
      202 	do ri_ptr = ptr (fm_ptr, file_model.rel_ptr)
      203 	     repeat ptr (fm_ptr, rel_info.fwd_thread)
      204 	     while (i <= rel_names.num);
      205 
      206 	     rel_names.item.natts (i) = rel_info.num_attr;
      207 	     rel_names.item.sm (i) = rel_info.name;
      208 	     rel_names.item.dm (i) = rel_info.name;
      209 	     rel_names.item.ri_ptr (i) = ri_ptr;
      210 	     rel_names.item.total_view (i) = "1"b;	/* model always complete view */
      211 	     rel_names.item.pad (i) = "0"b;
      212 	     rel_names.item.status_perm (i) = "1"b;	/* for opening via the model there */
      213 	     rel_names.item.unused_perm (i) = "0"b;	/* is complete access */
      214 	     rel_names.item.append_tuple_perm (i) = "1"b;
      215 	     rel_names.item.delete_tuple_perm (i) = "1"b;
      216 	     i = i + 1;
      217 	end;
      218 
      219      end;
      220 
      221 	declare sub_err_		 entry options (variable); /* error reporting routine */
      222 	declare caller_name		 char (20) init ("mrds_dsl_ready_file") internal static options (constant); /* name of calling routine */
      223 	declare continue		 char (1) init ("c") int static options (constant); /* don't stop after printing message */
      224 	declare info_ptr		 ptr init (null ()) int static options (constant); /* unused */
      225 	declare submodel_iocb_ptr	 ptr ext init (null);
      226 	declare return_value	 fixed bin (35) init (0) int static options (constant); /* unused */
      227 	dcl     wa_ptr		 ptr;		/* points to working area */
      228 	dcl     i			 fixed bin;	/* index variable */
      229 	dcl     dsm_sw		 bit (1) unal;	/* ON => we come from a data submodel */
      230 	dcl     fa_index		 fixed bin;	/* index into rm_file_array structure */
      231 	dcl     error_code		 fixed bin (35);
      232 
      233 	dcl     work_area		 area based (wa_ptr);
      234 
      235 	dcl     (null, ptr, addr, rel, fixed) builtin;
      236 
      237 	dcl     error_table_$unimplemented_version fixed bin (35) ext;
      238 	dcl     sys_info$max_seg_size	 ext fixed bin;
      239 
  1     1 /* BEGIN mdbm_rm_rel_array.incl.pl1 -- jaw, 8/9/78 */
  1     2 
  1     3 /* WARNING
  1     4*          If the rm_rel_array structure is changed then the mrds_data_
  1     5*          item saved_res_version MUST be incremented to invalidate all
  1     6*          existing saved resultants
  1     7**/
  1     8 
  1     9 /* HISTORY:
  1    10*
  1    11*   81-05-28 Jim Gray : added  model_name  and  file_id  as  part  of
  1    12*   combining   funtions   of   file_array  and  rel_array  into  one
  1    13*   structure. This will only allow 1 relation per file model now.
  1    14*   Also changed structure to allow more efficient searching
  1    15*   via and index builtin, rather than a programmed loop.
  1    16*   Search is now I = index(string(rm_rel_array.name), "!" || in_name)
  1    17*   with I = ((I - 1) / 33) + 1 to convert from a char to array index.
  1    18*
  1    19**/
  1    20 
  1    21 
  1    22 /* this structure is allocated in the static are of the structure
  1    23*   in  mdbm_rm_db_info.incl.pl1,  the secure portion of the database
  1    24*   resultant  model  upon  opening  the  database.  two  copies  are
  1    25*   allocated,  one for temporary relations, initially empty, and one
  1    26*   for relations known to the opener, which has a length  sufficient
  1    27*   for  all  relations known to the user, but whose names, etc. will
  1    28*   not be filled  in  until  the  file  containing  that  particular
  1    29*   relation  is readied. the rm_db_info structure contains a pointer
  1    30*   to the rel_arrays, and the array entries, when  "readied",  point
  1    31*   to  the  mdbm_rm_rel_info.incl.pl1  structures  containing  model
  1    32*   information about the relation, it's attributes, etc. */
  1    33 
  1    34 dcl 1 rm_rel_array aligned based (rmra_ptr),		/* array of open relations */
  1    35     2 num_rels fixed bin,				/* no. rels in db. */
  1    36     2 name (1:rm_num_rels_init refer (rm_rel_array.num_rels)) unal,
  1    37       3 mark char (1) unal,				/* separator character = "!" */
  1    38       3 submodel char (32) unal,			/* name of relation is submodel view, model opening => model name */
  1    39     2 rel_data (rm_num_rels_init refer (rm_rel_array.num_rels)),
  1    40       3 model_name char (30),				/* name of relation in model */
  1    41       3 ri_ptr ptr unal ;				/* pointer to rm_rel_info */
  1    42 
  1    43 dcl  rmra_ptr ptr;
  1    44 dcl  rm_num_rels_init fixed bin;
  1    45 
  1    46 /* END mdbm_rm_rel_array.incl.pl1 */
  1    47 
  1    48 
      240 
      241 
  2     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  2     6*     modified to save space occupied by model
  2     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  2     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  2     9*     the number of secondary indices in the relation - it was always zero.
  2    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  2    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  2    12*     DMS conversion.
  2    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  2    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  2    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  2    16*     for relation manager changes.
  2    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  2    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  2    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  2    20*     <rel> files are good (for rmdb)
  2    21*                                                   END HISTORY COMMENTS */
  2    22 
  2    23 
  2    24 /* each file in the database will have a model segment with the name
  2    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  2    26*   the file_model structure is allocated at the base of the segment for a given file.
  2    27*   it contains an area with which all other structures in this include file are allocated.
  2    28*   these structures contain the information about which relations, foreign keys,
  2    29*   and attributes are members of this file. all lists are singly linked lists in
  2    30*   definition order. pointers to these structures are obtained by using the "pointer"
  2    31*   builtin function with arguments of the segment base pointer, and the
  2    32*   offset (bit (18)) relative to that pointer that is actually stored in
  2    33*   the file model itself. this is because pointer segment numbers are
  2    34*   per process dependent. the major lists pointed to by the file_model structure
  2    35*   are the list of relations in this file(each with a contained attribute list),
  2    36*   and the list of foreign keys whose parent relation resides in this file
  2    37*   (along with a participating attribute sublist, and the child relation list,
  2    38*   if they are also in this file) */
  2    39 
  2    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  2    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  2    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  2    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  2    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  2    45     2 reserved bit (32) unal,				/* reserved for future flags */
  2    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  2    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  2    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  2    49     2 pad_1 fixed bin (35),				/* for future use */
  2    50     2 pad_2 fixed bin (35),
  2    51     2 ratd_len fixed bin (21),			/* length of above */
  2    52     2 mratd_len fixed bin (21),			/* length of above */
  2    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  2    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  2    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  2    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  2    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  2    58     2 block_size unal fixed bin,			/* no. pages in block */
  2    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  2    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  2    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  2    62     2 num_rels unal fixed bin,			/* number of relations in file */
  2    63     2 num_links unal fixed bin,			/* number of links in file */
  2    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  2    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  2    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  2    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  2    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  2    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  2    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  2    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  2    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  2    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  2    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  2    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  2    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  2    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  2    78     2 open_eu_err_path_ptr unal bit (18),
  2    79     2 open_eu_after_path_ptr unal bit (18),
  2    80     2 open_er_before_path_ptr unal bit (18),
  2    81     2 open_er_err_path_ptr unal bit (18),
  2    82     2 open_er_after_path_ptr unal bit (18),
  2    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  2    84     2 open_neu_err_path_ptr unal bit (18),
  2    85     2 open_neu_after_path_ptr unal bit (18),
  2    86     2 open_ner_before_path_ptr unal bit (18),
  2    87     2 open_ner_err_path_ptr unal bit (18),
  2    88     2 open_ner_after_path_ptr unal bit (18),
  2    89     2 open_pu_before_path_ptr unal bit (18),
  2    90     2 open_pu_err_path_ptr unal bit (18),
  2    91     2 open_pu_after_path_ptr unal bit (18),
  2    92     2 open_pr_before_path_ptr unal bit (18),
  2    93     2 open_pr_err_path_ptr unal bit (18),
  2    94     2 open_pr_after_path_ptr unal bit (18),
  2    95     2 open_cu_before_path_ptr unal bit (18),
  2    96     2 open_cu_err_path_ptr unal bit (18),
  2    97     2 open_cu_after_path_ptr unal bit (18),
  2    98     2 open_cr_before_path_ptr unal bit (18),
  2    99     2 open_cr_err_path_ptr unal bit (18),
  2   100     2 open_cr_after_path_ptr unal bit (18),
  2   101     2 close_before_path_ptr unal bit (18),
  2   102     2 close_err_path_ptr unal bit (18),
  2   103     2 close_after_path_ptr unal bit (18),
  2   104     2 unused_1 unal bit (18),				/* for future expansion */
  2   105     2 unused_2 unal bit (18),
  2   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  2   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  2   108 dcl  fm_ptr ptr;
  2   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  2   110 dcl  atd_ptr ptr;
  2   111 dcl  atd_len fixed bin;
  2   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  2   113     2 ncomponents fixed bin,
  2   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  2   115 dcl  cna_ptr ptr;
  2   116 dcl  ncomp_init fixed bin;
  2   117 
  2   118 /* a rel_info structure contains information describing a relation.
  2   119*   a relation may only occur in one file, thus there is one rel_info
  2   120*   per relation per database, each stored in the file_model area for
  2   121*   the file that contains it. the list of rel_info's in this file
  2   122*   form a singly linked list in definition order.
  2   123*   the rel_info itself points to a list of the attributes it contains,
  2   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  2   125 
  2   126 dcl 1 rel_info aligned based (ri_ptr),
  2   127     2 name char (32),				/* relation name */
  2   128     2 id  bit (36) aligned,				/* relation id number */
  2   129     2 hashed bit (1) unal,				/* on if hashed */
  2   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  2   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  2   132     2 system bit (1) unal,				/* on if dont care how stored */
  2   133     2 indexed bit (1) unal,				/* on if secondary index */
  2   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  2   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  2   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  2   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  2   138     2 reserved bit (27) unal,				/* for future flags */
  2   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  2   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  2   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  2   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  2   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  2   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  2   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  2   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  2   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  2   148     2 unused_3 unal fixed bin,			/* element that was never used */
  2   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  2   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  2   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  2   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  2   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  2   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  2   155     2 attr_ptr unal bit (18),				/* to attr. info */
  2   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  2   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  2   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  2   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  2   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  2   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  2   162     2 link_err_path_ptr unal bit (18),
  2   163     2 link_after_path_ptr unal bit (18),
  2   164     2 unlk_before_path_ptr unal bit (18),
  2   165     2 unlk_err_path_ptr unal bit (18),
  2   166     2 unlk_after_path_ptr unal bit (18),
  2   167     2 str_before_path_ptr unal bit (18),
  2   168     2 str_err_path_ptr unal bit (18),
  2   169     2 str_after_path_ptr unal bit (18),
  2   170     2 del_before_path_ptr unal bit (18),
  2   171     2 del_err_path_ptr unal bit (18),
  2   172     2 del_after_path_ptr unal bit (18),
  2   173     2 mod_before_path_ptr unal bit (18),
  2   174     2 mod_err_path_ptr unal bit (18),
  2   175     2 mod_after_path_ptr unal bit (18),
  2   176     2 find_before_path_ptr unal bit (18),
  2   177     2 find_err_path_ptr unal bit (18),
  2   178     2 find_after_path_ptr unal bit (18),
  2   179     2 retr_before_path_ptr unal bit (18),
  2   180     2 retr_err_path_ptr unal bit (18),
  2   181     2 retr_after_path_ptr unal bit (18),
  2   182     2 unused_1 unal bit (18),				/* for future expansion */
  2   183     2 unused_2 unal bit (18),
  2   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  2   185 dcl  ri_ptr ptr;
  2   186 
  2   187 /* a attr_info structure contains information about an attribute in a given relation.
  2   188*   since attributes may appear in more than one relation, each occurence of an attribute
  2   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  2   190*   the list is singly linked in definition order. the attr_info describes
  2   191*   the data it represents, and how that data is used during a database search. */
  2   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  2   193     2 name char (32),				/* name of attribute */
  2   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  2   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  2   196     2 link_attr bit (1) unal,				/* on if participates in link */
  2   197     2 reserved bit (33) unal,
  2   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  2   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  2   200     2 key_order unal fixed bin,			/* relative posit. in key */
  2   201     2 bit_offset fixed bin (35),			/* position in tuple */
  2   202     2 bit_length fixed bin (35),			/* length if fixed */
  2   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  2   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  2   205     2 domain_ptr unal bit (18),			/* to domain info */
  2   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  2   207     2 fwd_thread unal bit (18),			/* to next in list */
  2   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  2   209 dcl  ai_ptr ptr;
  2   210 
  2   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  2   212*   each time a foreign key definition indicates a relation as it's parent,
  2   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  2   214*   a relation can be parent and/or child in any number of foreign keys.
  2   215*   the parent_link_info structure describes the foreign key, and also points
  2   216*   to a list of the attributes that participate in this foreign key.
  2   217*   (this could be from 1 up to all attributes in the relation)
  2   218*   the attr_list structures are in a singly linked list in definition order
  2   219*   for this purpose. also pointed to is a list of child_link_info's
  2   220*   that describe the child relations in this foreign key. since foreign keys
  2   221*   may span files, not all related child_link_info's have to be in this file's
  2   222*   model area. */
  2   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  2   224     2 name char (32),				/* name of link */
  2   225     2 singular bit (1) unal,				/* on if system owned link */
  2   226     2 temp bit (1) unal,				/* on if temp. order */
  2   227     2 first bit (1) unal,				/* insertion indicators */
  2   228     2 last bit (1) unal,
  2   229     2 next bit (1) unal,
  2   230     2 prior bit (1) unal,
  2   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  2   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  2   233     2 dup_first bit (1) unal,				/* duplicates first */
  2   234     2 dup_last bit (1) unal,				/* duplicates last */
  2   235     2 indexed bit (1) unal,				/* locate parent via index */
  2   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  2   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  2   238     2 thread_27 bit (1) unal,
  2   239     2 thread_18 bit (1) unal,
  2   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  2   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  2   242     2 reserved bit (19) unal,				/* reserved for future flags */
  2   243     2 index_id aligned bit (8),			/* id of index if indexed */
  2   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  2   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  2   246     2 n_children unal fixed bin,			/* no. children in link */
  2   247     2 child_fn char (30),				/* file name for first child in list */
  2   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  2   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  2   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  2   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  2   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  2   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  2   254     2 sort_err_path_ptr unal bit (18),
  2   255     2 sort_after_path_ptr unal bit (18),
  2   256     2 srch_before_path_ptr unal bit (18),
  2   257     2 srch_err_path_ptr unal bit (18),
  2   258     2 srch_after_path_ptr unal bit (18),
  2   259     2 link_before_path_ptr unal bit (18),
  2   260     2 link_err_path_ptr unal bit (18),
  2   261     2 link_after_path_ptr unal bit (18),
  2   262     2 unlk_before_path_ptr unal bit (18),
  2   263     2 unlk_err_path_ptr unal bit (18),
  2   264     2 unlk_after_path_ptr unal bit (18),
  2   265     2 unused_1 unal bit (18),				/* for future expansion */
  2   266     2 unused_2 unal bit (18),
  2   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  2   268 dcl  pli_ptr ptr;
  2   269 
  2   270 /* a child_link_info structure is the counter part of a parent_link_info
  2   271*   for foreign key child relations. each time a relation is defined to be
  2   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  2   273*   this list is singly linked in foreign key definition order.
  2   274*   the child_link_info points to a list of participating attributes from the
  2   275*   child relation by means of a singly linked list of attr_list structures
  2   276*   in definition order. the number of attributes in the parent attr_list
  2   277*   and the child attr_list lists are the same with corresponding attr_list
  2   278*   attributes having the same domain. all child_link_infos in this file
  2   279*   are on a seperately linked list. this may not include all
  2   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  2   281*   since foreign keys may span files, and the child_link_info will
  2   282*   reside in the file containing it's associated relation_info. */
  2   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  2   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  2   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  2   286     2 fixed bit (1) unal,				/* on if membership fixed */
  2   287     2 optional bit (1) unal,				/* on if membership optional */
  2   288     2 auto bit (1) unal,				/* on if insertion automatic */
  2   289     2 manual bit (1) unal,				/* on if insertion manual */
  2   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  2   291     2 range_sel bit (1) unal,				/* on if range type selection */
  2   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  2   293     2 key_dup_last bit (1) unal,
  2   294     2 key_null bit (1) unal,				/* on if null allowed */
  2   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  2   296     2 sel_current bit (1) unal,
  2   297     2 sel_key bit (1) unal,
  2   298     2 sel_proc bit (1) unal,
  2   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  2   300     2 reserved bit (21) unal,
  2   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  2   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  2   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  2   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  2   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  2   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  2   307     2 parent_fn char (30),				/* file name for parent info */
  2   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  2   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  2   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  2   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  2   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  2   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  2   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  2   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  2   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  2   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  2   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  2   319     2 link_err_path_ptr unal bit (18),
  2   320     2 link_after_path_ptr unal bit (18),
  2   321     2 unlk_before_path_ptr unal bit (18),
  2   322     2 unlk_err_path_ptr unal bit (18),
  2   323     2 unlk_after_path_ptr unal bit (18),
  2   324     2 srch_before_path_ptr unal bit (18),
  2   325     2 srch_err_path_ptr unal bit (18),
  2   326     2 srch_after_path_ptr unal bit (18),
  2   327     2 unused_1 unal bit (18),				/* for future expansion */
  2   328     2 unused_2 unal bit (18) ;
  2   329 dcl  cli_ptr ptr;
  2   330 
  2   331 /* the attr_list structure is associated with the parent_link_info
  2   332*   and child_link_info structures to represent by means of a singly linked list
  2   333*   the participating attributes from relations in a foreign key.
  2   334*   the parent_link_info has a list for the parent relation,
  2   335*   and the child_link_info has a list for the child relation.
  2   336*   the participating attributes are a subset(not necessary proper) of
  2   337*   those attributes contained in a relation definition.
  2   338*   there are equal numbers of attr_list structures in the parent and
  2   339*   child lists of the same foreign key. the corresponding attributes in these
  2   340*   lists must have the same domain. */
  2   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  2   342     2 attr_fn char (30),				/* file name for attr. */
  2   343     2 attr_ptr unal bit (18),				/* to attr info block */
  2   344     2 fwd_thread unal bit (18);			/* to next in list */
  2   345 dcl  al_ptr ptr;
  2   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  2   347     2 ascend bit (1) unal,				/* ascending order */
  2   348     2 descend bit (1) unal,				/* descending order */
  2   349     2 reserved bit (34) unal,
  2   350     2 attr_ptr unal bit (18),				/* to attr info */
  2   351     2 fwd_thread unal bit (18);			/* to next in list */
  2   352 dcl  sk_ptr ptr;
  2   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  2   354     2 attr_ptr unal bit (18),				/* to attr info */
  2   355     2 fwd_thread unal bit (18);			/* to next in list */
  2   356 dcl  dp_ptr ptr;
  2   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  2   358     2 link_fn char (30),				/* file name for thru link */
  2   359     2 link_ptr unal bit (18),				/* to parent link info */
  2   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  2   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  2   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  2   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  2   364     2 fwd_thread unal bit (18);			/* to next in chain */
  2   365 dcl  sc_ptr ptr;
  2   366 
  2   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  2   368 
  2   369 
      242 
      243 
  3     1 /* BEGIN mdbm_rel_att_array.incl.pl1 -- odf 8/21/78 */
  3     2 /* modified by Jim Gray - - June/July 1979 to add key/varying attr counts and comments
  3     3*   Modified by Jim Gray - - April 1980, to add submodel's total_view bit to rel_names.
  3     4*   Modified by Lindsey Spratt - - August 1980, to add security permission bits to rel/att_names.
  3     5*   Modified by Jim Gray - - 80-11-06, to change s_perm = append_tuple_perm,
  3     6*   d_perm = delete_tuple_perm, r_perm = status_perm, m_perm = unused_perm.
  3     7*
  3     8*   81-01-23 Jim Gray : added bit to att_names so that the resultant can
  3     9*   be build for partial view submodels, and know whether the last varying attr
  3    10*   is a character or bit string type, for determining the bit offset of end of tuple.
  3    11*
  3    12*   81-05-28 Jim Gray : removed structures for foreign key interface.
  3    13*
  3    14*
  3    15*
  3    16*   NOTE: These structures are used as the parameters in the "mus_get_" routines
  3    17*   that are called by mu_sec_make_res, to return the users view of
  3    18*   either the model or submodel he has opened with. */
  3    19 
  3    20 dcl 1 rel_names based (rns_ptr),			/* array of relations in a file to be readied */
  3    21     2 num fixed bin,				/* nbr. of relations in this file */
  3    22     2 item (num_rels_init refer (rel_names.num)),
  3    23       3 sm char (32),				/* submodel name of relation */
  3    24       3 dm char (32),				/* data model name */
  3    25       3 natts fixed bin,				/* nbr. of attrs. in this relation */
  3    26       3 ri_ptr ptr,					/* points to rel_info in file_model */
  3    27       3 total_view bit (1) unal,			/* ON --> all attrs in model rel present */
  3    28       3 status_perm bit (1) unal,			/* ON --> opener has permission to look at relation */
  3    29       3 append_tuple_perm bit (1) unal,			/* ON --> opener has permission to store into this relation */
  3    30       3 delete_tuple_perm bit (1) unal,			/* ON --> opener has permission to delete tuples */
  3    31       3 unused_perm bit (1) unal,			/* unused perm */
  3    32       3 pad bit (31) unal ;				/* for future use */
  3    33 
  3    34 dcl 1 att_names based (ans_ptr),			/* array of attributes in a relation */
  3    35     2 num fixed bin,				/* attributes in a relation */
  3    36     2 num_key_attrs fixed bin,			/* number of key attributes in model/submodel relation */
  3    37     2 num_varying_attrs fixed bin,			/* count of varying bit/char data type attrs */
  3    38     2 last_model_attr_char_var bit (1) unal,		/* on => last attr in model view is char varying */
  3    39     2 mbz bit (35) unal,				/* for future use */
  3    40     2 item (num_atts_init refer (att_names.num)),
  3    41       3 sm char (32),				/* submodel name */
  3    42       3 dm char (32),				/* data model name */
  3    43       3 ai_ptr ptr,					/* points to attr_info in file_model */
  3    44       3 di_ptr ptr,					/* points to domain_info in file_model */
  3    45       3 rai_ptr ptr,				/* points to attr info in resultant model */
  3    46       3 r_perm bit (1) unal,				/* ON --> opener has permission to retrieve attribute */
  3    47       3 u_perm bit (1) unal,				/* ON --> opener has permission to update attribute */
  3    48       3 pad bit (34) unal;				/* future use */
  3    49 
  3    50 dcl  num_rels_init fixed bin;
  3    51 dcl  num_atts_init fixed bin;
  3    52 
  3    53 dcl  rns_ptr ptr;
  3    54 dcl  ans_ptr ptr;
  3    55 
  3    56 /* END mdbm_rel_att_array.incl.pl1 */
  3    57 
      244 
      245 
  4     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  4     2 
  4     3 /* WARNING
  4     4*          If the rm_rel_info structure is changed then the mrds_data_
  4     5*          item saved_res_version MUST be incremented to invalidate all
  4     6*          existing saved resultants
  4     7**/
  4     8 
  4     9 /* HISTORY:
  4    10*
  4    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  4    12*   attributes,   and   varying  attributes,  so  that  partial  view
  4    13*   submodels will have the  info  needed  to  properly  set  up  the
  4    14*   varying length array headers in the tuple structure.
  4    15*
  4    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  4    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  4    18*   delete_tuple_perm, and make m_perm = unused_perm.
  4    19*
  4    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  4    21*   view attribute was varying character or bit, since a partial view
  4    22*   submodel will not have this information in the resultant, and  it
  4    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  4    24*   since with exact length storage  of  varying  length  attributes,
  4    25*   each  tuple  can  be  a  different  length,  which is can only be
  4    26*   determined by examining the tuple itself.
  4    27*
  4    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  4    29*   interface  to  allow  temp  rel  population  to  be known, and to
  4    30*   provide a more efficient means of finding an approx. current perm
  4    31*   relation population.
  4    32*
  4    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  4    34*   blocked  files, foreign keys, and ids procedures. Also set number
  4    35*   of files per rel to a constant of 1.
  4    36*
  4    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  4    38*   structure so that only one structure per relation is needed.
  4    39*
  4    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  4    41*   counts.   Also  added  number  of  operations  count  since  last
  4    42*   statistics update, and a time  since  the  statistics  were  last
  4    43*   updated.
  4    44*
  4    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  4    46*   identifier so that small relations could be updated on a per S.E.
  4    47*   basis
  4    48*
  4    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  4    50*   to end of structure   TR 12205 (Suggestion).
  4    51*   
  4    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  4    53*   the DMS conversion. 
  4    54*
  4    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  4    56*   array and the niocb element for DMS conversion. Also removed the
  4    57*   number_selected array (and ri_niocbs_init) since subsets are not
  4    58*   going to be used.
  4    59*
  4    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  4    61*   so that it can be used with relation manager.  Also added
  4    62*   rm_rel_info.primary_key_index_id for relation manager.
  4    63*
  4    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  4    65*   nvar_atts, model_nvar_atts.
  4    66*
  4    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  4    68*   since the duplicate key count for each secondary index is now being
  4    69*   kept in the attr_info structure and key_count was only needed to
  4    70*   help in calculating the average selectivity of each index which
  4    71*   can now be gotten directly from each index's dup key count. Also
  4    72*   removed the file_id element since it is no longer needed for
  4    73*   anything.
  4    74*
  4    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  4    76*   was removed.
  4    77*
  4    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  4    79*   used when retrieving tuples from this relation.
  4    80*
  4    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  4    82*   for the relation. Note that this structure is part of the resultant NOT
  4    83*   part of the db.control structure. The scopes are duplicated in the resultant
  4    84*   to reduce contention for the db.control structure. Note also that the pointer
  4    85*   will always point to a scope_flags structure even if no scopes have been
  4    86*   set on the relation, the structure is allocated when the db is opened.
  4    87**/
  4    88 
  4    89 
  4    90 /* DESCRIPTION:
  4    91*
  4    92*   This structure is allocated in the area part of the structure  in
  4    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  4    94*   at open  time  for  a  database.  There  will  be  one  of  these
  4    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  4    96*   database view (there may be less than the total in  the  database
  4    97*   for  a  submodel  openings).  There  will  also  be  one for each
  4    98*   temporary relation currently defined for that opening.
  4    99*
  4   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  4   101*   all  rm_rel_info  structures  allocated. It is used for searching
  4   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  4   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  4   104*   rels.
  4   105*
  4   106*   The      rm_rel_info      structure      points      to       the
  4   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  4   108*   appearing in this view of the relation. Each  of  these  in  turn
  4   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  4   110*   info for each attr.
  4   111*
  4   112*   Most of the other information here deals with  specifics  of  the
  4   113*   relation's  logical  definition,  such as key and secondary index
  4   114*   attribute inidicators, security permissions, and  tuple  physical
  4   115*   construction details.
  4   116*
  4   117**/
  4   118 
  4   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  4   120 	     2 name	      char (32),		/* from submodel */
  4   121 	     2 model_name	      char (30),		/* from model */
  4   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  4   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  4   124 	     2 modify	      bit (1) unal,
  4   125 	     2 delete	      bit (1) unal,
  4   126 	     2 store	      bit (1) unal,
  4   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  4   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  4   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  4   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  4   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  4   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  4   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  4   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  4   135 	     2 reserved	      bit (24) unal,	/* for future use */
  4   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  4   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  4   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  4   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  4   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  4   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  4   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  4   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  4   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  4   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  4   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  4   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  4   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  4   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  4   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  4   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  4   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  4   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  4   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  4   155 
  4   156      dcl	   rmri_ptr	      ptr;
  4   157      dcl	   (nkey_attr_init,
  4   158 	   natts_init,
  4   159 	   nvar_atts_init)	      fixed bin;
  4   160 
  4   161 /* END mdbm_rm_rel_info.incl.pl1 */
  4   162 
  4   163 
      246 
      247 
  5     1 /* BEGIN INCLUDE FILE mrds_dsm_relation_names.incl.pl1 -- nsd 81/01/12 */
  5     2 
  5     3 /*
  5     4*This include file is for internal mrds use only. It  is  used  to
  5     5*return an array of submodel relation names.
  5     6*
  5     7*HISTORY
  5     8*
  5     9*81-01-12 Davids: written
  5    10*
  5    11*81-09-14 Davids: changed relation to char (32) from char (64). 64
  5    12*was  a  proposed  maximum  but  could not be implemented. Several
  5    13*modules would not compile when compiled with  -prefix  stringsize
  5    14*becuase they made assignments of the form char (32) = char (64).
  5    15**/
  5    16 
  5    17 dcl 1 mrds_dsm_relation_names based (mrds_dsm_relation_names_ptr),
  5    18     2 nrels fixed bin,
  5    19     2 relation (mrds_dsm_relation_names_nrels_alloc refer (mrds_dsm_relation_names.nrels)) char (32);
  5    20 
  5    21 dcl  mrds_dsm_relation_names_nrels_alloc fixed bin;
  5    22 
  5    23 dcl  mrds_dsm_relation_names_ptr ptr;
  5    24 
  5    25 /* END INCLUDE FILE mrds_dsm_relation_names.incl.pl1 */
  5    26 
      248 
      249 
  6     1 /*	BEGIN INCLUDE FILE		mrds_dsm_rel_block.incl.pl1
  6     2*
  6     3*   Created October, 1975 for release in MR 4.0
  6     4*
  6     5*   The relation_block contains the relation name and  the  attribute
  6     6*   names and access information
  6     7*
  6     8*   HISTORY
  6     9*
  6    10*   80-04-10 Spratt: changed to have version  number,  be  explicitly
  6    11*   .        based, use an automatic variable in the refer for num of
  6    12*   .        attributes,  add access flags for rel and attr's, remove
  6    13*   .        attr key flags. This is for the  first  Attribute  Level
  6    14*   .        Security version of MRDS.
  6    15*
  6    16*   81-01-14 Davids: increased submodel rel  and  attr  names  to  64
  6    17*   .        characters and made dsm_rel_name char  varying.  changed
  6    18*   .        access  bits  from  a  bit  string to individually named
  6    19*   .        flags.
  6    20**/
  6    21 
  6    22 dcl  relation_block_ptr ptr;
  6    23 dcl  rb_number_of_attributes fixed bin (35);
  6    24 dcl  RELATION_BLOCK_VERSION_1 fixed bin (35) internal static options (constant) init (1);
  6    25 
  6    26 dcl 1 relation_block based (relation_block_ptr),
  6    27 						/* Relation block */
  6    28     2 version fixed bin (35),
  6    29     2 dsm_rel_name char (64) varying,			/* Data submodel relation name */
  6    30     2 dm_rel_name char (32),				/* Data model relation name */
  6    31     2 rel_access unal,
  6    32       3 append bit (1),
  6    33       3 delete bit (1),
  6    34       3 null bit (1),
  6    35       3 mbz1 bit (33),
  6    36     2 no_rb_attributes fixed bin,			/* The number of attributes in this relation */
  6    37     2 attribute_info (rb_number_of_attributes refer (relation_block.no_rb_attributes)),
  6    38       3 dsm_attr_name char (64) varying,		/* Data submodel attribute name */
  6    39       3 attr_access unal,				/* Data submodel attribute flags */
  6    40         4 read bit (1),
  6    41         4 modify bit (1),
  6    42         4 null bit (1),
  6    43         4 mbz2 bit (33),				/* For future use */
  6    44       3 dm_attr_name char (32) varying,			/* Data model attribute name */
  6    45       3 dm_attr_flags,				/* Data model attribute flags */
  6    46         4 mbz3 bit (36);				/* For future use */
  6    47 
  6    48 /* 	END INCLUDE FILE 		mrds_dsm_rel_block.incl.pl1  */
  6    49 
      250 
      251 
  7     1 /* BEGIN INCLUDE FILE  -  mrds_dsm_entry_dcls.incl.pl1 */
  7     2 /* Written by Lindsey Spratt - - 80-10-24 */
  7     3 /* Modified by Jim Gray - - 80-11-13, to remove  declarations of non-existant modules */
  7     4 
  7     5 /* format: style2 */
  7     6 dcl  mrds_dsm_close entry (ptr, fixed bin (35));
  7     7 dcl  mrds_dsm_close$force entry (ptr);
  7     8 dcl  mrds_dsm_copy entry (char (*), char (*), fixed bin (35));
  7     9 dcl  mrds_dsm_set_db_path entry (ptr, char (*), fixed bin (35));
  7    10 dcl  mrds_dsm_define_temp
  7    11      entry (char (*), ptr, fixed bin (35));
  7    12 dcl  mrds_dsm_open_read entry (char (*), ptr, fixed bin (35));
  7    13 dcl  mrds_dsm_read_header entry (ptr, ptr, ptr, fixed bin (35));
  7    14 dcl  mrds_dsm_read_relation entry (char (*), ptr, ptr, ptr, fixed bin (35));
  7    15 dcl  mrds_dsm_get_relation_names
  7    16      entry (ptr, ptr, ptr, fixed bin (35));
  7    17 dcl  mrds_dsm_validate_header
  7    18      entry (ptr, fixed bin (35));
  7    19 dcl  mrds_dsm_dmdsm entry (ptr, fixed bin (35));
  7    20 dcl  mrds_dsm_valid_$validate
  7    21      entry (ptr, ptr, char (*), char (*), ptr, ptr, fixed bin (35));
  7    22 
  7    23 
  7    24 /* END INCLUDE FILE  -  mrds_dsm_entry_dcls.incl.pl1 */
      252 
      253      end mus_get_rel_names;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1145.0  mus_get_rel_names.pl1             >special_ldd>install>MR12.0-1187>mus_get_rel_names.pl1
240          1    10/14/83  1609.1  mdbm_rm_rel_array.incl.pl1        >ldd>include>mdbm_rm_rel_array.incl.pl1
242          2    10/16/86  1139.9  mdbm_file_model.incl.pl1          >special_ldd>install>MR12.0-1187>mdbm_file_model.incl.pl1
244          3    10/14/83  1608.9  mdbm_rel_att_array.incl.pl1       >ldd>include>mdbm_rel_att_array.incl.pl1
246          4    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
248          5    10/14/83  1609.0  mrds_dsm_relation_names.incl.pl1  >ldd>include>mrds_dsm_relation_names.incl.pl1
250          6    10/14/83  1608.7  mrds_dsm_rel_block.incl.pl1       >ldd>include>mrds_dsm_rel_block.incl.pl1
252          7    10/14/83  1608.7  mrds_dsm_entry_dcls.incl.pl1      >ldd>include>mrds_dsm_entry_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
RELATION_BLOCK_VERSION_1        000022 constant        fixed bin(35,0)          initial dcl 6-24 set ref 153 156*
append                   32            based           bit(1)                   level 3 packed unaligned dcl 6-26 ref 180
append_tuple_perm        26(02)        based           bit(1)                   array level 3 packed unaligned dcl 3-20 set ref 180*
                                                                                  214*
caller_name                     000003 constant        char(20)                 initial unaligned dcl 222 set ref 149* 156*
continue                        000002 constant        char(1)                  initial unaligned dcl 223 set ref 149* 156*
delete                   32(01)        based           bit(1)                   level 3 packed unaligned dcl 6-26 ref 181
delete_tuple_perm        26(03)        based           bit(1)                   array level 3 packed unaligned dcl 3-20 set ref 181*
                                                                                  215*
dm                       12            based           char(32)                 array level 3 packed unaligned dcl 3-20 set ref 174*
                                                                                  208*
dm_rel_name              22            based           char(32)                 level 2 packed unaligned dcl 6-26 ref 164
dsm_sw                                 parameter       bit(1)                   unaligned dcl 229 ref 18 125
error_code                             parameter       fixed bin(35,0)          dcl 231 set ref 18 119* 145 147* 149 149* 155* 156*
error_table_$unimplemented_version
                                000014 external static fixed bin(35,0)          dcl 237 ref 155
fa_index                               parameter       fixed bin(17,0)          dcl 230 ref 18 121 134
file_model                             based           structure                level 1 dcl 2-40
fm_ptr                                 parameter       pointer                  dcl 2-108 ref 18 164 164 168 195 202 202 217
fwd_thread               24            based           bit(18)                  level 2 packed unaligned dcl 2-126 ref 168 217
i                               000100 automatic       fixed bin(17,0)          dcl 228 set ref 145* 147 149 172 173 173 174 175 176
                                                                                  178 179 180 181 182* 201* 202 206 207 208 209 210
                                                                                  211 212 213 214 215 216* 216
info_ptr                        000000 constant        pointer                  initial dcl 224 set ref 149* 156*
item                      2            based           structure                array level 2 unaligned dcl 3-20
mrds_dsm_read_relation          000016 constant        entry                    external dcl 7-14 ref 147
mrds_dsm_relation_names                based           structure                level 1 unaligned dcl 5-17 set ref 133
mrds_dsm_relation_names_nrels_alloc
                                000110 automatic       fixed bin(17,0)          dcl 5-21 set ref 132* 133 133
mrds_dsm_relation_names_ptr     000112 automatic       pointer                  dcl 5-23 set ref 133* 134 138 145 147 149 173
name                                   based           char(32)                 level 2 in structure "rel_info" dcl 2-126
                                                                                  in procedure "mus_get_rel_names" ref 164 174 207
                                                                                  208
name                      1            based           structure                array level 2 in structure "rm_rel_array" packed
                                                                                  unaligned dcl 1-34 in procedure
                                                                                  "mus_get_rel_names"
natts                    22            based           fixed bin(17,0)          array level 3 dcl 3-20 set ref 172* 206*
no_rb_attributes         33            based           fixed bin(17,0)          level 2 dcl 6-26 ref 172 176
nrels                                  based           fixed bin(17,0)          level 2 dcl 5-17 set ref 133* 138 145
null                                                   builtin function         dcl 235 ref 120
num                                    based           fixed bin(17,0)          level 2 dcl 3-20 set ref 139* 140* 196* 197* 202
num_attr                 12            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-126 ref 176 206
num_rels                 16(18)        based           fixed bin(17,0)          level 2 in structure "file_model" packed unaligned
                                                                                  dcl 2-40 in procedure "mus_get_rel_names" ref 195
num_rels                               based           fixed bin(17,0)          level 2 in structure "rm_rel_array" dcl 1-34
                                                                                  in procedure "mus_get_rel_names" ref 121
num_rels_init                   000104 automatic       fixed bin(17,0)          dcl 3-50 set ref 138* 139 139 140 195* 196 196 197
pad                      26(05)        based           bit(31)                  array level 3 packed unaligned dcl 3-20 set ref 182*
                                                                                  211*
ptr                                                    builtin function         dcl 235 ref 164 168 202 217
rel_access               32            based           structure                level 2 packed unaligned dcl 6-26
rel_data                               based           structure                array level 2 dcl 1-34
rel_info                               based           structure                level 1 dcl 2-126
rel_names                              based           structure                level 1 unaligned dcl 3-20 set ref 139 196
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 2-40 ref 164 202
relation                  1            based           char(32)                 array level 2 packed unaligned dcl 5-17 set ref 134*
                                                                                  147* 149* 173
relation_block                         based           structure                level 1 unaligned dcl 6-26
relation_block_ptr              000114 automatic       pointer                  dcl 6-22 set ref 147* 153 156 164 172 176 180 181
return_value                    000017 constant        fixed bin(35,0)          initial dcl 226 set ref 149* 156*
ri_ptr                   24            based           pointer                  array level 3 in structure "rel_names" dcl 3-20
                                                                                  in procedure "mus_get_rel_names" set ref 175* 209*
ri_ptr                          000102 automatic       pointer                  dcl 2-185 in procedure "mus_get_rel_names" set ref
                                                                                  164* 164* 168 174 175 176 202* 206 207 208 209*
                                                                                  217*
ri_ptr                                 based           pointer                  array level 3 in structure "rm_rel_array" packed
                                                                                  unaligned dcl 1-34 in procedure
                                                                                  "mus_get_rel_names" ref 121
rm_rel_array                           based           structure                level 1 dcl 1-34
rmra_ptr                               parameter       pointer                  dcl 1-43 ref 18 121 134
rmri_ptr                        000106 automatic       pointer                  dcl 4-156 set ref 121*
rns_ptr                                parameter       pointer                  dcl 3-53 set ref 18 120* 139* 140 172 173 174 175
                                                                                  176 178 179 180 181 182 196* 197 202 206 207 208
                                                                                  209 210 211 212 213 214 215
sm                        2            based           char(32)                 array level 3 packed unaligned dcl 3-20 set ref 173*
                                                                                  207*
status_perm              26(01)        based           bit(1)                   array level 3 packed unaligned dcl 3-20 set ref 178*
                                                                                  212*
sub_err_                        000010 constant        entry                    external dcl 221 ref 149 156
submodel                  1(09)        based           char(32)                 array level 3 packed unaligned dcl 1-34 ref 134
submodel_iocb_ptr               000012 external static pointer                  initial dcl 225 set ref 147*
total_view               26            based           bit(1)                   array level 3 packed unaligned dcl 3-20 set ref 176*
                                                                                  210*
unused_perm              26(04)        based           bit(1)                   array level 3 packed unaligned dcl 3-20 set ref 179*
                                                                                  213*
version                                based           fixed bin(35,0)          level 2 dcl 6-26 set ref 153 156*
wa_ptr                                 parameter       pointer                  dcl 227 set ref 18 133 139 147* 196
work_area                              based           area(1024)               dcl 233 ref 133 139 196

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
addr                                                   builtin function         dcl 235
ai_ptr                                 automatic       pointer                  dcl 2-209
al_ptr                                 automatic       pointer                  dcl 2-345
ans_ptr                                automatic       pointer                  dcl 3-54
atd                                    based           char                     unaligned dcl 2-109
atd_len                                automatic       fixed bin(17,0)          dcl 2-111
atd_ptr                                automatic       pointer                  dcl 2-110
att_names                              based           structure                level 1 unaligned dcl 3-34
attr_info                              based           structure                level 1 dcl 2-192
attr_list                              based           structure                level 1 dcl 2-341
child_link_info                        based           structure                level 1 dcl 2-283
cli_ptr                                automatic       pointer                  dcl 2-329
cna_ptr                                automatic       pointer                  dcl 2-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 2-112
dp_ptr                                 automatic       pointer                  dcl 2-356
dup_prev                               based           structure                level 1 dcl 2-353
fixed                                                  builtin function         dcl 235
mrds_dsm_close                  000000 constant        entry                    external dcl 7-6
mrds_dsm_close$force            000000 constant        entry                    external dcl 7-7
mrds_dsm_copy                   000000 constant        entry                    external dcl 7-8
mrds_dsm_define_temp            000000 constant        entry                    external dcl 7-10
mrds_dsm_dmdsm                  000000 constant        entry                    external dcl 7-19
mrds_dsm_get_relation_names     000000 constant        entry                    external dcl 7-15
mrds_dsm_open_read              000000 constant        entry                    external dcl 7-12
mrds_dsm_read_header            000000 constant        entry                    external dcl 7-13
mrds_dsm_set_db_path            000000 constant        entry                    external dcl 7-9
mrds_dsm_valid_$validate        000000 constant        entry                    external dcl 7-20
mrds_dsm_validate_header        000000 constant        entry                    external dcl 7-17
natts_init                             automatic       fixed bin(17,0)          dcl 4-157
ncomp_init                             automatic       fixed bin(17,0)          dcl 2-116
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 4-157
num_atts_init                          automatic       fixed bin(17,0)          dcl 3-51
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 4-157
parent_link_info                       based           structure                level 1 dcl 2-223
pli_ptr                                automatic       pointer                  dcl 2-268
rb_number_of_attributes                automatic       fixed bin(35,0)          dcl 6-23
rel                                                    builtin function         dcl 235
rm_num_rels_init                       automatic       fixed bin(17,0)          dcl 1-44
rm_rel_info                            based           structure                level 1 dcl 4-119
sc_ptr                                 automatic       pointer                  dcl 2-365
select_chain                           based           structure                level 1 dcl 2-357
sk_ptr                                 automatic       pointer                  dcl 2-352
sort_key                               based           structure                level 1 dcl 2-346
sys_info$max_seg_size                  external static fixed bin(17,0)          dcl 238

NAMES DECLARED BY EXPLICIT CONTEXT.
model_relation                  000520 constant        entry                    internal dcl 190 ref 127
mus_get_rel_names               000072 constant        entry                    external dcl 18
submodel_relation               000132 constant        entry                    internal dcl 131 ref 125

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       732         752     634         742
Length      1300     634        20         312      76           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mus_get_rel_names                   159 external procedure  is an external procedure.  
submodel_relation                       internal procedure  shares stack frame of external procedure mus_get_rel_names.  
model_relation                          internal procedure  shares stack frame of external procedure mus_get_rel_names.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mus_get_rel_names        000100 i                           mus_get_rel_names
                         000102 ri_ptr                      mus_get_rel_names
                         000104 num_rels_init               mus_get_rel_names
                         000106 rmri_ptr                    mus_get_rel_names
                         000110 mrds_dsm_relation_names_nrels_alloc
                                                            mus_get_rel_names
                         000112 mrds_dsm_relation_names_ptr mus_get_rel_names
                         000114 relation_block_ptr          mus_get_rel_names

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   return_mac          ext_entry           op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
mrds_dsm_read_relation        sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unimplemented_version                          submodel_iocb_ptr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 000064       119 000077       120 000101       121 000103       125 000121       127 000130       129 000131
    131 000132       132 000133       133 000135       134 000150       138 000160       139 000162       145 000176
    147 000210       149 000245       153 000334       155 000337       156 000342       159 000406       164 000407
    168 000426       172 000436       173 000446       174 000456       175 000463       176 000464       178 000475
    179 000477       180 000501       181 000506       182 000513       186 000515       188 000517       190 000520
    195 000521       196 000530       201 000544       202 000546       206 000563       207 000572       208 000576
    209 000602       210 000603       211 000607       212 000611       213 000613       214 000615       215 000617
    216 000621       217 000622       219 000631


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
