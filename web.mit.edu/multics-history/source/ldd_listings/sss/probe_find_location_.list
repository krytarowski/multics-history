	COMPILATION LISTING OF SEGMENT probe_find_location_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/27/88  1230.2 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       16*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       17*     Added format control comment to make the source more readable.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       22 
       23 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       24 
       25 probe_find_location_:
       26   procedure
       27        (P_probe_info_ptr, P_seg_info_ptr, P_file_number, P_line,
       28        P_statement_number, P_switches, P_map_element, P_index);
       29 
       30   /* This routine is used to search the statement map for a line designated by file, line, and
       31*   stmt offset. If not found and dont_guess_sw (in P_switches) is OFF, it tries to make a guess.
       32*
       33*   Initial Version:  15 August 1974 by Jeffrey M. Broughton
       34*   Converted to probe 4.0, 05/18/79 W. Olin Sibert */
       35   /* Changed to respect position 4 of P_switches, dont_guess_sw */
       36   /* Changed to see it's in the middle of a statement 10/29/81 S. Herbst */
       37   /* Fixed to recognize when it unexpectedly re-enters part of program before desired line 10/25/82 S. Herbst */
       38   /* Fixed high guess to be last line of programn, not last stmt in map 02/10/84 S. Herbst */
       39 
       40   dcl (
       41       P_probe_info_ptr	pointer,
       42       P_seg_info_ptr	pointer,	/* to info about contianing program */
       43       P_file_number		fixed bin,/* file number of desired statement */
       44       P_line		fixed bin,/* and line number */
       45       P_statement_number,		/* and statement offset in line */
       46       P_switches		bit (36) aligned,
       47       P_map_element		pointer,	/* to map entry best fitting the above */
       48       P_index		fixed bin
       49       )			parameter;/* index of this entry */
       50 
       51   dcl switches		bit (36) unaligned;
       52   dcl want_external_sw	bit (1) unaligned defined (switches) pos (1);
       53   dcl default_external_sw	bit (1) unaligned defined (switches) pos (2);
       54   dcl default_offset_zero_sw	bit (1) unaligned defined (switches) pos (3);
       55   dcl dont_guess_sw		bit (1) unaligned defined (switches) pos (4);
       56 
       57   dcl file_entry		bit (72) aligned;
       58 				/* file number, in statement map format */
       59   dcl statement_entry	bit (72) aligned;
       60 				/* file, line, and statement numbers */
       61 
       62   dcl state		fixed bin;/* current state of scan for statement */
       63   dcl checked_sw		bit (1) aligned;
       64 				/* ON if checked_multi_line has been called */
       65 
       66   dcl this_statement	bit (72) aligned;
       67 				/* file, line, stmt. offset of current stmt. */
       68   dcl last_statement	bit (72) aligned;
       69 				/* ditto, of last stmt. in _s_a_m_e file */
       70   dcl end_statement		bit (72) aligned;
       71 				/* of statement expected to end proc */
       72   dcl low_guess		bit (72) aligned;
       73 				/* of last stmt. before one wanted */
       74   dcl high_guess		bit (72) aligned;
       75 				/* of next statement found above */
       76   dcl guess_statement	bit (72) aligned;
       77 				/* to check guess before returning it */
       78 
       79   dcl i			fixed bin;/* index in map of current stmt. being scanned */
       80   dcl highest_line		fixed bin;/* highest line number of any stmt so far */
       81   dcl highest_line_index	fixed bin;/* statement index corresponding to this line */
       82   dcl this_line		fixed bin;/*  line number of current statement */
       83 
       84   dcl last		fixed bin;/* of last stmt. in same file */
       85   dcl proc_end_stmt		fixed bin;/* of stmt. expected to end procedure */
       86   dcl low			fixed bin;/* of one for low_guess */
       87   dcl high		fixed bin;/* of one for high_guess */
       88 
       89   dcl map_size		fixed bin;/* size of this array */
       90   dcl map_ptr		pointer;
       91   dcl 1 map_array		(map_size) aligned like statement_map
       92 			based (map_ptr);
       93 				/* overlay for entire statement map */
       94 
       95   dcl 1 result_source_info	aligned like source_info;
       96 
       97   dcl probe_line_number_$proc entry (ptr, 1 aligned like source_info)
       98 			returns (char (64));
       99   dcl probe_source_segment_$get_file_ptr
      100 			entry (ptr, ptr, fixed bin) returns (ptr);
      101   dcl probe_error_$warning	entry options (variable);
      102 
      103   dcl probe_et_$stmt_guess	fixed bin (35) external static;
      104 
      105   dcl file_mask		bit (72) aligned internal static
      106 			options (constant)
      107 			initial ("000000776000000000000000"b3);
      108 				/* masks out file number of statement map */
      109   dcl statement_mask	bit (72) aligned internal static
      110 			options (constant)
      111 			initial ("000000777777777000000000"b3);
      112 				/* mask out file, line, and statement numbers */
      113 
      114   dcl (addr, bit, fixed, null, string, substr)
      115 			builtin;
      116 				/*  */
      117 
      118   /* Check that we have something to work with */
      119 
      120   probe_info_ptr = P_probe_info_ptr;
      121   switches = P_switches;
      122   map_ptr = P_seg_info_ptr -> seg_info.statement_map_ptr;
      123 
      124   if map_ptr = null
      125     then goto fail;			/* if non-null will assume that we have other info too */
      126 
      127   /* Get size of statement map for this program */
      128 
      129   map_size = P_seg_info_ptr -> seg_info.map_size;
      130 				/* get maximum index */
      131 
      132   /* Make source id for statement desired. purpose is fast comparision */
      133 
      134   file_entry = (18)"0"b || bit (fixed (P_file_number, 8, 0));
      135 				/* put file number into desired format */
      136   statement_entry = file_entry | (26)"0"b || bit (fixed (P_line, 14, 0)) ||
      137        bit (fixed (P_statement_number, 5, 0));
      138 
      139   /* Handle boundary conditions for search */
      140 
      141   low_guess, last_statement = string (map_array (1)) & statement_mask;
      142 				/* before every thing else in map */
      143   highest_line, highest_line_index, last, low = 1;
      144   high_guess, end_statement = statement_mask;
      145 				/* greater than any element of map */
      146   state = 1;			/* initially scanning before statement */
      147   checked_sw = "0"b;		/* call check_multi_line once, after line number is passed */
      148 
      149   /* Search entire map for element, but keep track of topology for guess. */
      150 
      151   do i = 1 to map_size;
      152     if (string (map_array (i)) & file_mask) = file_entry then do;
      153 				/* only look in same file as statement */
      154 
      155         this_line = fixed (map_array (i).line);
      156         if this_line > highest_line then do;
      157 	  highest_line = this_line;
      158 	  highest_line_index = i;
      159 	end;
      160 
      161         this_statement = string (map_array (i)) & statement_mask;
      162 				/* record source id of current statement */
      163         if this_statement = statement_entry then do;
      164 				/* found it, no further work needed */
      165 GOT_LINE:
      166 	  P_index = i;		/* return info */
      167 	  P_map_element = addr (map_array (i));
      168 	  return;
      169 	end;
      170         else if this_statement < last_statement
      171 	then /* have entered relocated internal procedure */
      172 	     goto before_last (state);
      173         else if this_statement > statement_entry
      174 	then /* found one after one we want */
      175 	     goto after (state);
      176         else if this_statement >= end_statement
      177 	then /* have reached end of int proc being skipped */
      178 	     goto end_proc (state);
      179         else do;
      180 	if this_statement < statement_entry then do;
      181 				/* must have re-entered part before desired stmt */
      182 	    state = 1;		/* treat this like end of internal proc */
      183 	    end_statement = statement_mask;
      184 	  end;
      185 	go to common;
      186         end;
      187 
      188         /* State 1: In a region of statements before one wanted.  Can be either main program, or
      189*   internal procedure that we are assuming contains the statement. */
      190 
      191 after (1):
      192         call check_multi_line ();
      193 
      194         /* Have been scanning region before, so we have found a gap, remember where
      195*   it is and continue looking for an internal proc containing statement. */
      196 
      197         low = last;
      198         low_guess = last_statement;	/* remember one before stmt. */
      199         if this_statement < high_guess then do;
      200 				/* and this one, if it is a better approx. */
      201 	  high = i;
      202 	  high_guess = this_statement;
      203 	end;
      204         state = 3;			/* now scanning region after */
      205         goto common;
      206 
      207 before_last (1):
      208 
      209         /* Have entered internal procedure before region before statement.  This implies
      210*   that all of procedure is before statement, so skip it, but remeber where end
      211*   caller was in case it is really the end. */
      212 
      213         proc_end_stmt = last;
      214         end_statement = last_statement; /* caller's last statement */
      215         state = 2;			/* skip state */
      216         goto common;
      217 
      218 end_proc (1):
      219 
      220         /* Should not occur. Should be caught by after or finish case. */
      221 
      222         goto finish (1);		/* really don't care */
      223 
      224         /* State 2: Skipping an internal procedure before statement. */
      225 
      226 after (2):
      227 
      228         /* Found one after the statement; this implies that we have reentered main code.
      229*   The situation is:  | main1 | proc(s) | main2 | with a source ordering of
      230*   proc(s) < main1 < stmt. < main2.  Take guess as in state 1. */
      231 
      232         low = proc_end_stmt;
      233         low_guess = end_statement;	/* stmt. before one wanted, last in caller */
      234         end_statement = statement_mask; /* reset */
      235         state = 3;			/* are in region after now */
      236         goto common;
      237 
      238 before_last (2):
      239 
      240         /* Found another internal procedure before even where we are.  Just ignore it. */
      241 
      242         goto common;
      243 
      244 end_proc (2):
      245 
      246         /* Have reached code beyond end of procedure, reenter main code sequence, and
      247*   continue scan. */
      248 
      249         end_statement = statement_mask; /* reset */
      250         state = 1;
      251         goto common;
      252 
      253         /* State 3:  Scanning statements after the desired one;  looking for internal procedures
      254*   this region that may contain the statement. */
      255 
      256 after (3):
      257 
      258         /* Nothing new, just proceed */
      259 
      260         goto common;
      261 
      262 before_last (3):
      263 
      264         /* Entering internal procedure before region being scanned.	Check if it may contain
      265*   statement. */
      266 
      267         if this_statement > high_guess
      268 	then /* proc. after statement */
      269 	     goto common;		/* cannot contain statement */
      270         else if this_statement < low_guess
      271 	then /* proc before gap where statement was to be */
      272 	     goto common;
      273 
      274         /* This procedure is in the gap, we may assume that the statement is here (for instance,
      275*   an end statement generating no code).  So continue scan for statement or another one
      276*   after. */
      277 
      278         state = 1;			/* just like the start, expect to find one before */
      279         last = low;
      280         last_statement = low_guess;	/* last one before desired one anyway */
      281         i = i - 1;			/* reprocess, this may be after */
      282         goto next;			/* have set last ourselves */
      283 
      284 end_proc (3):
      285 
      286         /* Should not happen. */
      287 
      288         goto finish (3);
      289 
      290         /* Common:  record the last statement for next time around */
      291 
      292 common:
      293         last = i;
      294         last_statement = this_statement;
      295       end;
      296 
      297 next:
      298   end;
      299 
      300   call check_multi_line ();
      301 
      302   /* All of map has been scanned.  The precise statement has not been found. So make a
      303*   guess depending on how we got here. */
      304 
      305   if dont_guess_sw
      306     then go to fail;
      307 
      308   goto finish (state);
      309 
      310 finish (1):
      311 
      312   /* We could get here if no file containing the statement was found,  If one was, then
      313*   we were scanning a region before the desired statement, so we should pick the last
      314*   statement in that region */
      315 
      316   if (last_statement & file_mask) ^= file_entry
      317     then goto fail;			/* either one found, in which case last in th
      318*						   at file, or didn't, last in file 0 */
      319 
      320   guess_statement = string (map_array (last)) & statement_mask;
      321   if guess_statement > statement_entry
      322     then P_index = last;
      323 				/* guess later in map is also later line in source */
      324     else P_index = highest_line_index;	/* else use last line in source */
      325   P_map_element = addr (map_array (highest_line_index));
      326 				/* highest_line_index in region */
      327   goto make_guess;
      328 
      329 finish (2):
      330 
      331   /* We were skipping an internal procedure before statement, so use end of caller */
      332 
      333   P_index = proc_end_stmt;
      334   P_map_element = addr (map_array (proc_end_stmt));
      335   goto make_guess;
      336 
      337 finish (3):
      338 
      339   /* In region after statement, and we have made a guess.  Statement is probably non-
      340*   executable (e.g. begin, do, end).  We have a greater interested in making a
      341*   quick begin block entry, which users may specify by line number to get a block,
      342*   work right, so guess one after recorded guess.  This is also compatable with
      343*   debug */
      344 
      345   guess_statement = string (map_array (high)) & statement_mask;
      346   if guess_statement > statement_entry
      347     then P_index = high;
      348 				/* guess later in map is also later line in source */
      349     else P_index = highest_line_index;	/* else use last line in source */
      350   P_map_element = addr (map_array (highest_line_index));
      351 				/* want one following low guess */
      352 
      353 make_guess:
      354   result_source_info.seg_info_ptr = P_seg_info_ptr;
      355   result_source_info.stmnt_map_entry_index = P_index;
      356   call probe_error_$warning (probe_info_ptr, probe_et_$stmt_guess,
      357        probe_line_number_$proc (probe_info_ptr, result_source_info));
      358   return;
      359 
      360 fail:
      361   P_index = -1;
      362   P_map_element = null;		/* nothing found */
      363   return;
      364 
      365 check_multi_line:
      366   proc;
      367 
      368   /* This procedure sees whether the previous statement spans more than one line,
      369*   and whether it includes P_line. If so, the statement is found. */
      370 
      371   dcl (j, len, line_count, prev_line, start)
      372 			fixed bin (21);
      373   dcl filep		ptr;
      374   dcl source_overlay	char (1044480 /* max chars in a segment */)
      375 			based (filep);
      376   dcl NL			char (1) int static options (constant) init ("
      377 ");
      378 
      379   if checked_sw
      380     then
      381          return;			/* already called this; must be end of program */
      382   checked_sw = "1"b;
      383 
      384   if i = 1
      385     then
      386          return;			/* first line in program */
      387 
      388   prev_line = fixed (map_array (i - 1).line);
      389   start = fixed (map_array (i - 1).start);
      390   len = fixed (map_array (i - 1).length);
      391 
      392   if start = 0
      393     then
      394          return;
      395 
      396   /* Count number of lines in prev statement */
      397 
      398   filep =
      399        probe_source_segment_$get_file_ptr (probe_info_ptr,
      400        probe_info.ptr_to_current_source, P_file_number);
      401   if filep = null
      402     then
      403          return;			/* give up */
      404 
      405   line_count = 1;
      406 
      407   do j = start to start + len - 2;	/* don't look at the end char */
      408     if substr (source_overlay, j, 1) = NL
      409       then line_count = line_count + 1;
      410   end;
      411 
      412   if prev_line + line_count > P_line then do;
      413       i = i - 1;			/* the previous line is the right one */
      414       go to GOT_LINE;
      415     end;
      416 
      417   end check_multi_line;
      418 
      419   /*  */
      420 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      421 
      422 
      423   /* ;;;;;;; */
      424 
  2     1 dcl	1 statement_map	aligned based,
  2     2 	2 location	bit(18) unaligned,
  2     3 	2 source_id	unaligned,
  2     4 	  3 file		bit(8),
  2     5 	  3 line		bit(14),
  2     6 	  3 statement	bit(5),
  2     7 	2 source_info	unaligned,
  2     8 	  3 start		bit(18),
  2     9 	  3 length	bit(9);
      425 
      426 
      427   /* ;;;;;;; */
      428 
  3     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  3     2*
  3     3*   25 June 79 JRDavis
  3     4*
  3     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  3     6*	correction per file.
  3     7**/
  3     8 
  3     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  3    10     2 language_type fixed bin,			/* language of source program */
  3    11     2 bits aligned,
  3    12       3 ignore_case bit (1) unal,
  3    13       3 bound_segment bit (1) unaligned,
  3    14       3 component bit (1) unaligned,
  3    15       3 pad bit (33) unal,
  3    16     2 names,					/* where to find it */
  3    17       3 directory_name character (168) unal,		/* what directory */
  3    18       3 entry_name character (32) unal,			/* what segment */
  3    19       3 segname character (32) unal,			/* procedure segname definition */
  3    20     2 identifier fixed bin (71),			/* time of object creation */
  3    21     2 pointers,					/* location of various parts of segment */
  3    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  3    23       3 original_source_ptr ptr unal,			/* to segment source map */
  3    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  3    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  3    26*						   bound ones, -> break_map !obsolete, I think! */
  3    27       3 chain ptr unal,				/* to entry for next component if bound */
  3    28       3 linkage_ptr ptr unal,				/* to linkage section */
  3    29     2 bounds aligned,				/* structure of bounds information */
  3    30       3 text_bounds,
  3    31         4 start fixed bin (35),
  3    32         4 end fixed bin (35),
  3    33       3 symbol_bounds,
  3    34         4 start fixed bin (35),
  3    35         4 end fixed bin (35),
  3    36     2 map_size fixed bin,				/* size of statement map */
  3    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  3    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  3    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  3    40     2 pad (1) fixed bin (35),
  3    41 
  3    42     2 nfiles fixed bin,
  3    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  3    44       3 file_pointers ptr unal,
  3    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  3    46 
  3    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  3    48 
  3    49 
  3    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      429 
      430 
      431   /* ;;;;;;; */
      432 
  4     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  4     2*
  4     3*  James R. Davis 2 July 79 */
  4     4 
  4     5 dcl 1 source_info based aligned,
  4     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  4     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  4     8       2 block_ptr ptr,				/* to runtime_block node */
  4     9       2 stack_ptr ptr,				/* to a stack frame */
  4    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  4    11       2 seg_info_ptr ptr;				/* to seg_info */
  4    12 
  4    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  4    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  4    15 
  4    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      433 
      434 
      435   /* ;;;;;;; */
      436 
  5     1 /*	BEGIN INCLUDE FILE ... runtime_symbol.incl.pl1 ... Modified 07/79 */
  5     2 
  5     3 dcl	1 runtime_symbol	aligned based,
  5     4 	2 flag		unal bit(1),	/* always "1"b for Version II */
  5     5 	2 use_digit	unal bit(1),	/* if "1"b and units are half words units are really digits */
  5     6 	2 array_units	unal bit(2),
  5     7 	2 units		unal bit(2),	/* addressing units */
  5     8 	2 type		unal bit(6),	/* data type */
  5     9 	2 level		unal bit(6),	/* structure level */
  5    10 	2 ndims		unal bit(6),	/* number of dimensions */
  5    11 	2 bits		unal,
  5    12 	  3 aligned	bit(1),
  5    13 	  3 packed	bit(1),
  5    14 	  3 simple	bit(1),
  5    15 	2 skip		unal bit(1),
  5    16 	2 scale		unal bit(8),	/* arithmetic scale factor */
  5    17 	2 name		unal bit(18),	/* rel ptr to acc name */
  5    18 	2 brother		unal bit(18),	/* rel ptr to brother entry */
  5    19 	2 father		unal bit(18),	/* rel ptr to father entry */
  5    20 	2 son		unal bit(18),	/* rel ptr to son entry */
  5    21 	2 address		unal,
  5    22 	  3 location	bit(18),		/* location in storage class */
  5    23 	  3 class		bit(4),		/* storage class */
  5    24 	  3 next		bit(14),		/* rel ptr to next of same class */
  5    25 	2 size		fixed bin(35),	/* encoded string|arith size */
  5    26 	2 offset		fixed bin(35),	/* encoded offset from address */
  5    27 	2 virtual_org	fixed bin(35),
  5    28 	2 bounds(1),
  5    29 	  3 lower		fixed bin(35),	/* encoded lower bound */
  5    30 	  3 upper		fixed bin(35),	/* encoded upper bound */
  5    31 	  3 multiplier	fixed bin(35);	/* encoded multiplier */
  5    32 
  5    33 dcl	1 runtime_bound	based,
  5    34 	2 lower		fixed bin(35),
  5    35 	2 upper		fixed bin(35),
  5    36 	2 multiplier	fixed bin(35);
  5    37 
  5    38 dcl	1 runtime_block	aligned based,
  5    39 	2 flag		unal bit(1),	/* always "1"b for Version II */
  5    40 	2 quick		unal bit(1),	/* "1"b if quick block */
  5    41 	2 fortran		unal bit(1),	/* "1"b if fortran program */
  5    42 	2 standard	unal bit(1),	/* "1"b if program has std obj segment */
  5    43 	2 owner_flag	unal bit(1),	/* "1"b if block has valid owner field */
  5    44 	2 skip		unal bit(1),
  5    45 	2 type		unal bit(6),	/* = 0 for a block node */
  5    46 	2 number		unal bit(6),	/* begin block number */
  5    47 	2 start		unal bit(18),	/* rel ptr to start of symbols */
  5    48 	2 name		unal bit(18),	/* rel ptr to name of proc */
  5    49 	2 brother		unal bit(18),	/* rel ptr to brother block */
  5    50 	2 father		unal bit(18),	/* rel ptr to father block */
  5    51 	2 son		unal bit(18),	/* rel ptr to son block */
  5    52 	2 map		unal,
  5    53 	  3 first		bit(18),		/* rel ptr to first word of map */
  5    54 	  3 last		bit(18),		/* rel ptr to last word of map */
  5    55 	2 entry_info	unal bit(18),	/* info about entry of quick block */
  5    56 	2 header		unal bit(18),	/* rel ptr to symbol header */
  5    57 	2 chain(4)	unal bit(18),	/* chain(i) is rel ptr to first symbol
  5    58*					   on start list with length >= 2**i */
  5    59 	2 token(0:5)	unal bit(18),	/* token(i) is rel ptr to first token
  5    60*					   on list with length >= 2 ** i */
  5    61 	2 owner		unal bit(18);	/* rel ptr to owner block */
  5    62 
  5    63 dcl	1 runtime_token	aligned based,
  5    64 	2 next		unal bit(18),	/* rel ptr to next token */
  5    65 	2 dcl		unal bit(18),	/* rel ptr to first dcl of this token */
  5    66 	2 name,				/* ACC */
  5    67 	  3 size		unal unsigned fixed bin (9), /* number of chars in token */
  5    68 	  3 string	unal char(n refer(runtime_token.size));
  5    69 
  5    70 dcl	1 encoded_value	aligned based,
  5    71 	2 flag		bit (2) unal,
  5    72 	2 code		bit (4) unal,
  5    73 	2 n1		bit (6) unal,
  5    74 	2 n2		bit (6) unal,
  5    75 	2 n3		bit (18) unal;
  5    76 
  5    77 /*	END INCLUDE FILE ... runtime_symbol.incl.pl1 */
      437 
      438 
      439   end;				/* probe_find_location_ external procedure */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/27/88  1224.9  probe_find_location_.pl1          >spec>install>MR12.2-1194>probe_find_location_.pl1
421          1    10/27/88  1223.7  probe_info.incl.pl1               >spec>install>MR12.2-1194>probe_info.incl.pl1
425          2    05/06/74  1751.6  statement_map.incl.pl1            >ldd>include>statement_map.incl.pl1
429          3    11/02/83  1845.0  probe_seg_info.incl.pl1           >ldd>include>probe_seg_info.incl.pl1
433          4    11/26/79  1320.6  probe_source_info.incl.pl1        >ldd>include>probe_source_info.incl.pl1
437          5    11/26/79  1320.6  runtime_symbol.incl.pl1           >ldd>include>runtime_symbol.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NL                              000610 constant        char(1)                  initial packed unaligned dcl 376 ref 408
P_file_number                          parameter       fixed bin(17,0)          dcl 40 set ref 25 134 398*
P_index                                parameter       fixed bin(17,0)          dcl 40 set ref 25 165* 321* 324* 329* 346* 349* 355
                                                                                  360*
P_line                                 parameter       fixed bin(17,0)          dcl 40 ref 25 136 412
P_map_element                          parameter       pointer                  dcl 40 set ref 25 167* 325* 334* 350* 362*
P_probe_info_ptr                       parameter       pointer                  dcl 40 ref 25 120
P_seg_info_ptr                         parameter       pointer                  dcl 40 ref 25 122 129 353
P_statement_number                     parameter       fixed bin(17,0)          dcl 40 ref 25 136
P_switches                             parameter       bit(36)                  dcl 40 ref 25 121
addr                                                   builtin function         dcl 114 ref 167 325 334 350
bit                                                    builtin function         dcl 114 ref 134 136 136
checked_sw                      000107 automatic       bit(1)                   dcl 63 set ref 147* 379 382*
dont_guess_sw                          defined         bit(1)                   packed unaligned dcl 55 ref 305
end_statement                   000114 automatic       bit(72)                  dcl 70 set ref 144* 176 183* 214* 233 234* 244*
file_entry                      000102 automatic       bit(72)                  dcl 57 set ref 134* 136 152 310
file_mask                       000016 constant        bit(72)                  initial dcl 105 ref 152 310
filep                           000174 automatic       pointer                  dcl 373 set ref 398* 401 408
fixed                                                  builtin function         dcl 114 ref 134 136 136 155 388 389 390
guess_statement                 000122 automatic       bit(72)                  dcl 76 set ref 320* 321 337* 346
high                            000133 automatic       fixed bin(17,0)          dcl 87 set ref 201* 337 346
high_guess                      000120 automatic       bit(72)                  dcl 74 set ref 144* 199 202* 262
highest_line                    000125 automatic       fixed bin(17,0)          dcl 80 set ref 143* 156 157*
highest_line_index              000126 automatic       fixed bin(17,0)          dcl 81 set ref 143* 158* 324 325 349 350
i                               000124 automatic       fixed bin(17,0)          dcl 79 set ref 151* 152 155 158 161 165 167 201 281*
                                                                                  281 292* 384 388 389 390 413* 413
j                               000166 automatic       fixed bin(21,0)          dcl 371 set ref 407* 408*
last                            000130 automatic       fixed bin(17,0)          dcl 84 set ref 143* 197 207 279* 292* 320 321
last_statement                  000112 automatic       bit(72)                  dcl 68 set ref 141* 170 198 214 280* 294* 310
len                             000167 automatic       fixed bin(21,0)          dcl 371 set ref 390* 407
length                    1(27)        based           bit(9)                   array level 3 packed packed unaligned dcl 91 set ref
                                                                                  390
line                      0(26)        based           bit(14)                  array level 3 packed packed unaligned dcl 91 set ref
                                                                                  155 388
line_count                      000170 automatic       fixed bin(21,0)          dcl 371 set ref 405* 408* 408 412
low                             000132 automatic       fixed bin(17,0)          dcl 86 set ref 143* 197* 226* 279
low_guess                       000116 automatic       bit(72)                  dcl 72 set ref 141* 198* 233* 270 280
map_array                              based           structure                array level 1 dcl 91 set ref 141 152 161 167 320 325
                                                                                  334 337 350
map_ptr                         000136 automatic       pointer                  dcl 90 set ref 122* 124 141 152 155 161 167 320 325
                                                                                  334 337 350 388 389 390
map_size                110            based           fixed bin(17,0)          level 2 in structure "seg_info" dcl 3-9 in procedure
                                                                                  "probe_find_location_" ref 129
map_size                        000134 automatic       fixed bin(17,0)          dcl 89 in procedure "probe_find_location_" set ref
                                                                                  129* 151
null                                                   builtin function         dcl 114 ref 124 362 401
pointers                 76            based           structure                level 2 dcl 3-9
prev_line                       000171 automatic       fixed bin(21,0)          dcl 371 set ref 388* 412
probe_error_$warning            000014 constant        entry                    external dcl 101 ref 356
probe_et_$stmt_guess            000016 external static fixed bin(35,0)          dcl 103 set ref 356*
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000154 automatic       pointer                  dcl 1-86 set ref 120* 356* 356* 356* 398* 398
probe_line_number_$proc         000010 constant        entry                    external dcl 97 ref 356 356
probe_source_segment_$get_file_ptr
                                000012 constant        entry                    external dcl 99 ref 398
proc_end_stmt                   000131 automatic       fixed bin(17,0)          dcl 85 set ref 207* 226 329 334
ptr_to_current_source
                          4            based           pointer                  level 2 dcl 1-18 set ref 398*
result_source_info              000140 automatic       structure                level 1 dcl 95 set ref 356* 356*
seg_info                               based           structure                level 1 dcl 3-9
seg_info_ptr             12     000140 automatic       pointer                  level 2 dcl 95 set ref 353*
source_id                 0(18)        based           structure                array level 2 packed packed unaligned dcl 91
source_info               1(09)        based           structure                array level 2 in structure "map_array" packed packed
                                                                                  unaligned dcl 91 in procedure
                                                                                  "probe_find_location_"
source_info                            based           structure                level 1 dcl 4-5 in procedure "probe_find_location_"
source_overlay                         based           char(1044480)            packed unaligned dcl 374 ref 408
start                           000172 automatic       fixed bin(21,0)          dcl 371 in procedure "check_multi_line" set ref 389*
                                                                                  392 407 407
start                     1(09)        based           bit(18)                  array level 3 in structure "map_array" packed packed
                                                                                  unaligned dcl 91 in procedure
                                                                                  "probe_find_location_" set ref 389
state                           000106 automatic       fixed bin(17,0)          dcl 62 set ref 146* 170 173 176 182* 204* 215* 235*
                                                                                  250* 278* 308
statement_entry                 000104 automatic       bit(72)                  dcl 59 set ref 136* 163 173 180 321 346
statement_map                          based           structure                level 1 dcl 2-1
statement_map_ptr       100            based           pointer                  level 3 packed packed unaligned dcl 3-9 ref 122
statement_mask                  000014 constant        bit(72)                  initial dcl 109 ref 141 144 161 183 234 244 320 337
stmnt_map_entry_index           000140 automatic       fixed bin(17,0)          level 2 dcl 95 set ref 355*
string                                                 builtin function         dcl 114 ref 141 152 161 320 337
substr                                                 builtin function         dcl 114 ref 408
switches                        000100 automatic       bit(36)                  packed unaligned dcl 51 set ref 121* 305 305
this_line                       000127 automatic       fixed bin(17,0)          dcl 82 set ref 155* 156 157
this_statement                  000110 automatic       bit(72)                  dcl 66 set ref 161* 163 170 173 176 180 199 202 262
                                                                                  270 294

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
current_source                         based           structure                level 1 dcl 4-13
default_external_sw                    defined         bit(1)                   packed unaligned dcl 53
default_offset_zero_sw                 defined         bit(1)                   packed unaligned dcl 54
encoded_value                          based           structure                level 1 dcl 5-70
expression_area                        based           area(1024)               dcl 1-95
initial_source                         based           structure                level 1 dcl 4-14
probe_area                             based           area(1024)               dcl 1-93
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
runtime_block                          based           structure                level 1 dcl 5-38
runtime_bound                          based           structure                level 1 unaligned dcl 5-33
runtime_symbol                         based           structure                level 1 dcl 5-3
runtime_token                          based           structure                level 1 dcl 5-63
scratch_area                           based           area(1024)               dcl 1-92
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 3-47
want_external_sw                       defined         bit(1)                   packed unaligned dcl 52
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
GOT_LINE                        000174 constant        label                    dcl 165 ref 414
after                           000000 constant        label                    array(3) dcl 191 ref 173
before_last                     000003 constant        label                    array(3) dcl 207 ref 170
check_multi_line                000472 constant        entry                    internal dcl 365 ref 191 300
common                          000316 constant        label                    dcl 292 ref 185 205 216 236 238 251 256 262 270
end_proc                        000006 constant        label                    array(3) dcl 218 ref 176
fail                            000464 constant        label                    dcl 360 ref 124 305 310
finish                          000011 constant        label                    array(3) dcl 310 ref 218 284 308
make_guess                      000421 constant        label                    dcl 353 ref 327 335
next                            000322 constant        label                    dcl 297 ref 282
probe_find_location_            000037 constant        entry                    external dcl 25

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       712         732     611         722
Length      1216     611        20         250     100           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_find_location_                180 external procedure  is an external procedure.  
check_multi_line                        internal procedure  shares stack frame of external procedure probe_find_location_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_find_location_     000100 switches                    probe_find_location_
                         000102 file_entry                  probe_find_location_
                         000104 statement_entry             probe_find_location_
                         000106 state                       probe_find_location_
                         000107 checked_sw                  probe_find_location_
                         000110 this_statement              probe_find_location_
                         000112 last_statement              probe_find_location_
                         000114 end_statement               probe_find_location_
                         000116 low_guess                   probe_find_location_
                         000120 high_guess                  probe_find_location_
                         000122 guess_statement             probe_find_location_
                         000124 i                           probe_find_location_
                         000125 highest_line                probe_find_location_
                         000126 highest_line_index          probe_find_location_
                         000127 this_line                   probe_find_location_
                         000130 last                        probe_find_location_
                         000131 proc_end_stmt               probe_find_location_
                         000132 low                         probe_find_location_
                         000133 high                        probe_find_location_
                         000134 map_size                    probe_find_location_
                         000136 map_ptr                     probe_find_location_
                         000140 result_source_info          probe_find_location_
                         000154 probe_info_ptr              probe_find_location_
                         000166 j                           check_multi_line
                         000167 len                         check_multi_line
                         000170 line_count                  check_multi_line
                         000171 prev_line                   check_multi_line
                         000172 start                       check_multi_line
                         000174 filep                       check_multi_line

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
probe_error_$warning          probe_line_number_$proc       probe_source_segment_$get_file_ptr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
probe_et_$stmt_guess




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000030       120 000044       121 000050       122 000052       124 000056       129 000062       134 000064
    136 000073       141 000113       143 000120       144 000125       146 000130       147 000132       151 000133
    152 000143       155 000153       156 000161       157 000163       158 000164       161 000166       163 000172
    165 000174       167 000177       168 000203       170 000204       173 000210       176 000215       180 000221
    182 000223       183 000225       185 000227       191 000230       197 000231       198 000233       199 000235
    201 000240       202 000242       204 000244       205 000246       207 000247       214 000251       215 000253
    216 000255       218 000256       226 000257       233 000261       234 000263       235 000265       236 000267
    238 000270       244 000271       250 000273       251 000275       256 000276       262 000277       270 000302
    278 000304       279 000306       280 000310       281 000312       282 000314       284 000315       292 000316
    294 000320       297 000322       300 000324       305 000325       308 000330       310 000332       320 000336
    321 000345       324 000354       325 000357       327 000363       329 000364       334 000367       335 000373
    337 000374       346 000403       349 000412       350 000415       353 000421       355 000425       356 000427
    358 000463       360 000464       362 000467       363 000471       365 000472       379 000473       382 000476
    384 000500       388 000504       389 000515       390 000521       392 000524       398 000527       401 000546
    405 000553       407 000555       408 000567       410 000575       412 000577       413 000604       414 000606
    417 000607


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
