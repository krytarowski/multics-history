	COMPILATION LISTING OF SEGMENT cm_replace_buffered_ci
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/03/85  1640.2 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*         This module implements collection_manager_$replace_ci_buffer.
       11*
       12*         Puts  the  entire  collection_manager_-addressable  portion  of  the
       13*     specified control interval.   The  caller  supplies  a buffer previously
       14*     set up by cm_$setup_buffered_ci, and may use this control interval buffer
       15*     in subsequent calls to collection_manager_$get_element_buffered.
       16**/
       17 
       18 /* HISTORY:
       19*
       20*Written by Matthew Pierret, 01/10/82.
       21*Modified:
       22*01/27/82 by Matthew Pierret: To use dm_error_$unimplemented_ci_version instead
       23*            of error_table_$unimplemented_version.
       24*01/24/84 by Matthew Pierret:  Added debugging entries for displaying previous
       25*            and next control interval ids to help keep track of modifications
       26*            of the control interval thread.
       27*04/13/84 by Matthew Pierret:  Changed variable names p_control_interval_ptr
       28*            and p_control_interval_length_in_bits to p_ci_buffer_ptr and
       29*            p_ci_buffer_length to conform to documentation.  Also changed to
       30*            copy p_ci_buffer_ptr into a local automatic variable.
       31*10/08/84 by Matthew Pierret:  Added ERROR_RETURN. Removed unused variables,
       32*            unneccessary call-by-values.  Changed to use 
       33*            file_manager_$simple_put. Changed to use new sub_err_ flags.
       34**/
       35 
       36 /* format: style2,ind3 */
       37 
       38 cm_replace_buffered_ci:
       39    proc (p_file_opening_id, p_collection_id, p_control_interval_number, p_ci_buffer_ptr, p_ci_buffer_length_in_bits,
       40         p_code);
       41 
       42 
       43 /* START OF DECLARATIONS */
       44 /* Parameter */
       45 
       46       dcl	    p_file_opening_id      bit (36) aligned parameter;
       47       dcl	    p_collection_id	       bit (36) aligned parameter;
       48       dcl	    p_control_interval_number
       49 			       fixed bin (24) unsigned parameter;
       50       dcl	    p_ci_buffer_ptr	       ptr parameter;
       51       dcl	    p_ci_buffer_length_in_bits
       52 			       fixed bin (35) parameter;
       53       dcl	    p_code	       fixed bin (35) parameter;
       54 
       55 /* Automatic */
       56 
       57       dcl	    code		       fixed bin (35);
       58       dcl	    ci_buffer_length_in_bits
       59 			       fixed bin (35);
       60       dcl	    ci_buffer_ptr	       ptr;
       61       dcl	    1 existing_bci_header  aligned like bci_header;
       62 
       63 /* Based */
       64 /* Builtin */
       65 
       66       dcl	    (addr, null)	       builtin;
       67 
       68 /* Constant */
       69 
       70       dcl	    myname	       init ("cm_replace_buffered_ci") char (32) varying internal static options (constant);
       71       dcl	    BITS_PER_WORD	       init (9) fixed bin internal static options (constant);
       72       dcl	    START_OF_CI_OFFSET     init (0) fixed bin (21) internal static options (constant);
       73 
       74 /* Entry */
       75 
       76       dcl	    file_manager_$simple_put
       77 			       entry (bit (36) aligned, fixed bin (27), fixed bin (21), ptr, fixed bin (21),
       78 			       fixed bin (35));
       79       dcl	    ioa_		       entry () options (variable);
       80       dcl	    cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
       81       dcl	    sub_err_	       entry () options (variable);
       82 
       83 /* External */
       84 
       85       dcl	    (
       86 	    dm_error_$ci_not_in_collection,
       87 	    dm_error_$ci_buffer_too_small,
       88 	    dm_error_$unimplemented_ci_version
       89 	    )		       fixed bin (35) ext;
       90 
       91 /* Static */
       92 
       93       dcl	    static_trace_thread_switch
       94 			       init ("0"b) bit (1) aligned internal static;
       95 
       96 /* END OF DECLARATIONS */
       97 
       98       p_code, code = 0;
       99       ci_buffer_length_in_bits = p_ci_buffer_length_in_bits;
      100       ci_buffer_ptr = p_ci_buffer_ptr;
      101 
      102       call CHECK_CI_VERSION (ci_buffer_ptr -> bci_header.layout_type);
      103 
      104       if ci_buffer_ptr -> bci_header.collection_id ^= p_collection_id
      105       then call ERROR_RETURN (dm_error_$ci_not_in_collection);
      106 
      107       if ci_buffer_length_in_bits < CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES * BITS_PER_WORD
      108       then call ERROR_RETURN (dm_error_$ci_buffer_too_small);
      109 
      110 /* If tracing ci thread modifications, compare next and previous with existing
      111*   control header to see if anythng has changed. */
      112 
      113       if static_trace_thread_switch
      114       then
      115          do;
      116 	  call cm_get_bci_header (p_file_opening_id, p_control_interval_number, addr (existing_bci_header), code);
      117 	  if code ^= 0
      118 	  then call ERROR_RETURN (code);
      119 	  else call CHECK_CI_VERSION (existing_bci_header.layout_type);
      120 	  if existing_bci_header.previous_control_interval ^= ci_buffer_ptr -> bci_header.previous_control_interval
      121 	  then call ioa_ (
      122 		  "Buffered control interval ^d changed during replacement.^/^8xPrevious control interval changed from ^d to ^d."
      123 		  , p_control_interval_number, existing_bci_header.previous_control_interval,
      124 		  ci_buffer_ptr -> bci_header.previous_control_interval);
      125 	  if existing_bci_header.next_control_interval ^= ci_buffer_ptr -> bci_header.next_control_interval
      126 	  then call ioa_ (
      127 		  "Buffered control interval ^d changed during replacement.^/^8xNext control interval changed from ^d to ^d."
      128 		  , p_control_interval_number, existing_bci_header.next_control_interval,
      129 		  ci_buffer_ptr -> bci_header.next_control_interval);
      130          end;
      131 
      132 /* Replace buffered control interval. */
      133 
      134       call file_manager_$simple_put (p_file_opening_id, (p_control_interval_number), START_OF_CI_OFFSET, ci_buffer_ptr,
      135 	 (CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES), code);
      136       if code ^= 0
      137       then call ERROR_RETURN (code);
      138       else
      139 MAIN_RETURN:
      140          return;
      141 
      142 ERROR_RETURN:
      143    proc (er_p_code);
      144 
      145       dcl	    er_p_code	       fixed bin (35);
      146 
      147       p_code = er_p_code;
      148       go to MAIN_RETURN;
      149 
      150    end ERROR_RETURN;
      151 
      152 trace_thread_modifications_on:
      153    entry ();
      154       static_trace_thread_switch = "1"b;
      155       return;
      156 
      157 trace_thread_modifications_off:
      158    entry ();
      159       static_trace_thread_switch = "0"b;
      160       return;
      161 
      162 CHECK_CI_VERSION:
      163    proc (ccv_p_given_version);
      164 
      165       dcl	    ccv_p_given_version    char (4) aligned;
      166 
      167       if ccv_p_given_version ^= BASIC_CI_LAYOUT_1
      168       then call sub_err_ (dm_error_$unimplemented_ci_version, myname, ACTION_CANT_RESTART, null, 0,
      169 	      "^/Expected version ^4a control interval; received ^4a.", BASIC_CI_LAYOUT_1, ccv_p_given_version);
      170       else return;
      171 
      172    end CHECK_CI_VERSION;
      173 
  1     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        The collection_manager_ manages the structure of the addressable
  1     6*   portion of a control interval.  The addressable portion is that portion of
  1     7*   a control interval which the file_manager_ will allow the
  1     8*   collection_manager_ to address.  In this description control interval will
  1     9*   be used to mean the addressable portion of a control interval.
  1    10*   
  1    11*        A control interval is divided into four parts: the header, the datum
  1    12*   position table (also known as the slot table or slots), un-used space and
  1    13*   used space.  The beginning of the header is at offset 0, and the end of the
  1    14*   used space is at the end of the control interval (curently offset 4072).
  1    15*   Pictoriarly, a control interval is structured as follows:
  1    16*   
  1    17*   ----------------------------------------------------------------------
  1    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  1    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  1    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  1    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  1    22*   ----------------------------------------------------------------------
  1    23*                                           ^ ^    ^      ^    ^  ^   ^
  1    24*                                           | |    |      |    |  |   |
  1    25*                                           | |...........|.......|...|
  1    26*                        start of used space|      |           |      |
  1    27*                                                  |           |  each|
  1    28*                                          scattered free space|  is a used
  1    29*                                                                 datum
  1    30*   
  1    31*      The basic_control_interval structure describes the header
  1    32*   (basic_control_interval.header, bci_header) and the slots
  1    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  1    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  1    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  1    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  1    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  1    38**/
  1    39 
  1    40 /* HISTORY:
  1    41*Written by Matthew Pierret, 02/07/82.
  1    42*Modified:
  1    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  1    44*            and its sub-structures.
  1    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  1    46*            basic_ci_header to bci_header. Added previous_control_interval.
  1    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  1    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  1    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  1    50*            is not used.
  1    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  1    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  1    53**/
  1    54 
  1    55 /* format: style2 */
  1    56      dcl	   1 basic_control_interval
  1    57 			      aligned based (basic_control_interval_ptr),
  1    58 	     2 header	      like bci_header,
  1    59 	     2 datum_position_table
  1    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  1    61 
  1    62 
  1    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  1    64 	     2 layout_type	      char (4) aligned,
  1    65 	     2 collection_id      bit (36) aligned,
  1    66 	     2 next_control_interval
  1    67 			      fixed bin (24) uns unal,
  1    68 	     2 previous_control_interval
  1    69 			      fixed bin (24) uns unal,
  1    70 	     2 flags	      unal,
  1    71 	       3 continuation_datum_is_present
  1    72 			      bit (1) unal,
  1    73 	       3 free_slot_is_present
  1    74 			      bit (1) unal,
  1    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  1    76 	     2 scattered_free_space
  1    77 			      fixed bin (17) unal,
  1    78 	     2 start_of_used_space
  1    79 			      fixed bin (17) unal,
  1    80 	     2 number_of_datums   fixed bin (17) unal;
  1    81 
  1    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  1    83 	     2 flags	      unal,
  1    84 	       3 special_format_datum
  1    85 			      bit (1) unal,		/* reserved */
  1    86 	       3 is_continued     bit (1) unal,
  1    87 	       3 is_continuation  bit (1) unal,
  1    88 	       3 mbz	      bit (1) unal,		/* reserved */
  1    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  1    90 	     2 length_in_bits     fixed bin (17) uns unal;
  1    91 
  1    92      dcl	   basic_control_interval_ptr
  1    93 			      ptr;
  1    94      dcl	   bci_header_ptr	      ptr;
  1    95      dcl	   datum_slot_ptr	      ptr;
  1    96 
  1    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  1    98 
  1    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      174 
      175 
  2     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*   Contains constants useful in describing parts of a basic control interval.
  2     6**/
  2     7 
  2     8 /* HISTORY:
  2     9*Written by Matthew Pierret, 09/20/84.
  2    10*Modified:
  2    11**/
  2    12 
  2    13      dcl	   FREE_SLOT	      init (0) fixed bin (15) uns internal static options (constant);
  2    14      dcl	   BCI_HEADER_LENGTH_IN_BYTES
  2    15 			      init (20) fixed bin internal static options (constant);
  2    16      dcl	   DATUM_POSITION_TABLE_OFFSET_IN_BYTES
  2    17 			      init (20) fixed bin internal static options (constant);
  2    18 
  2    19 
  2    20 /* END INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
      176 
      177 
  3     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*       This include file contains constants which are the length in bytes
  3     5*   of the addressable portion of a control interval.  The addressable portion
  3     6*   is that part of the control interval which callers of file_manager_
  3     7*   may access, specifically, everything between the end of the control
  3     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
  3     9*   Control interval 0 is slightly different, as it also contains an 
  3    10*   unaddressable portion in which it maintains the file attributes.  For
  3    11*   control interval 0 the addressable portion is everything between the end
  3    12*   of the control interval header and the beginning of the file attributes.
  3    13**/
  3    14 
  3    15 /* HISTORY:
  3    16*Written by Matthew Pierret, 11/02/84.
  3    17*Modified:
  3    18**/
  3    19 
  3    20 /* format: style2,ind3 */
  3    21 
  3    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
  3    23 			      fixed bin (17) init (4072) int static options (constant);
  3    24 
  3    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
  3    26 			      fixed bin (17) init (3176) int static options (constant);
  3    27 
  3    28 
  3    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
  3    30 
  3    31      dcl	   CI_0_ADDRESSABLE_LENGTH
  3    32 			      fixed bin (17) init (3176) int static options (constant);
  3    33 
  3    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
      178 
      179 
  4     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  4     2 /* format: style3 */
  4     3 
  4     4 /* These constants are to be used for the flags argument of sub_err_ */
  4     5 /* They are just "string (condition_info_header.action_flags)" */
  4     6 
  4     7 declare	(
  4     8 	ACTION_CAN_RESTART	init (""b),
  4     9 	ACTION_CANT_RESTART init ("1"b),
  4    10 	ACTION_DEFAULT_RESTART
  4    11 			init ("01"b),
  4    12 	ACTION_QUIET_RESTART
  4    13 			init ("001"b),
  4    14 	ACTION_SUPPORT_SIGNAL
  4    15 			init ("0001"b)
  4    16 	)		bit (36) aligned internal static options (constant);
  4    17 
  4    18 /* End include file */
      180 
      181 
      182    end cm_replace_buffered_ci;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/03/85  1149.3  cm_replace_buffered_ci.pl1        >spec>temp>famis1>cm_replace_buffered_ci.pl1
174          1    01/03/85  1003.0  dm_cm_basic_ci.incl.pl1           >spec>temp>famis1>dm_cm_basic_ci.incl.pl1
176          2    01/03/85  1003.0  dm_cm_basic_ci_const.incl.pl1     >spec>temp>famis1>dm_cm_basic_ci_const.incl.pl1
178          3    01/03/85  1005.2  dm_ci_lengths.incl.pl1            >spec>temp>famis1>dm_ci_lengths.incl.pl1
180          4    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000016 constant        bit(36)                  initial dcl 4-7 set ref 167*
BASIC_CI_LAYOUT_1               000000 constant        char(4)                  initial dcl 1-97 set ref 167 167*
BITS_PER_WORD                          constant        fixed bin(17,0)          initial dcl 71 ref 107
CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
                                       constant        fixed bin(17,0)          initial dcl 3-22 ref 107 134
START_OF_CI_OFFSET              000022 constant        fixed bin(21,0)          initial dcl 72 set ref 134*
addr                                                   builtin function         dcl 66 ref 116 116
bci_header                             based           structure                level 1 dcl 1-63
ccv_p_given_version                    parameter       char(4)                  dcl 165 set ref 162 167 167*
ci_buffer_length_in_bits        000101 automatic       fixed bin(35,0)          dcl 58 set ref 99* 107
ci_buffer_ptr                   000102 automatic       pointer                  dcl 60 set ref 100* 102 104 120 120 125 125 134*
cm_get_bci_header               000016 constant        entry                    external dcl 80 ref 116
code                            000100 automatic       fixed bin(35,0)          dcl 57 set ref 98* 116* 117 117* 134* 136 136*
collection_id             1            based           bit(36)                  level 2 dcl 1-63 ref 104
datum_slot                             based           structure                level 1 dcl 1-82
dm_error_$ci_buffer_too_small   000024 external static fixed bin(35,0)          dcl 85 set ref 107*
dm_error_$ci_not_in_collection  000022 external static fixed bin(35,0)          dcl 85 set ref 104*
dm_error_$unimplemented_ci_version
                                000026 external static fixed bin(35,0)          dcl 85 set ref 167*
er_p_code                              parameter       fixed bin(35,0)          dcl 145 ref 142 147
existing_bci_header             000104 automatic       structure                level 1 dcl 61 set ref 116 116
file_manager_$simple_put        000012 constant        entry                    external dcl 76 ref 134
ioa_                            000014 constant        entry                    external dcl 79 ref 120 125
layout_type                     000104 automatic       char(4)                  level 2 in structure "existing_bci_header" dcl 61
                                                                                  in procedure "cm_replace_buffered_ci" set ref 119*
layout_type                            based           char(4)                  level 2 in structure "bci_header" dcl 1-63
                                                                                  in procedure "cm_replace_buffered_ci" set ref 102*
myname                          000001 constant        varying char(32)         initial dcl 70 set ref 167*
next_control_interval
                          2            based           fixed bin(24,0)          level 2 in structure "bci_header" packed unsigned
                                                                                  unaligned dcl 1-63 in procedure
                                                                                  "cm_replace_buffered_ci" set ref 125 125*
next_control_interval
                          2     000104 automatic       fixed bin(24,0)          level 2 in structure "existing_bci_header" packed
                                                                                  unsigned unaligned dcl 61 in procedure
                                                                                  "cm_replace_buffered_ci" set ref 125 125*
null                                                   builtin function         dcl 66 ref 167 167
p_ci_buffer_length_in_bits             parameter       fixed bin(35,0)          dcl 51 ref 38 99
p_ci_buffer_ptr                        parameter       pointer                  dcl 50 ref 38 100
p_code                                 parameter       fixed bin(35,0)          dcl 53 set ref 38 98* 147*
p_collection_id                        parameter       bit(36)                  dcl 47 ref 38 104
p_control_interval_number              parameter       fixed bin(24,0)          unsigned dcl 48 set ref 38 116* 120* 125* 134
p_file_opening_id                      parameter       bit(36)                  dcl 46 set ref 38 116* 134*
previous_control_interval
                          2(24) 000104 automatic       fixed bin(24,0)          level 2 in structure "existing_bci_header" packed
                                                                                  unsigned unaligned dcl 61 in procedure
                                                                                  "cm_replace_buffered_ci" set ref 120 120*
previous_control_interval
                          2(24)        based           fixed bin(24,0)          level 2 in structure "bci_header" packed unsigned
                                                                                  unaligned dcl 1-63 in procedure
                                                                                  "cm_replace_buffered_ci" set ref 120 120*
static_trace_thread_switch      000010 internal static bit(1)                   initial dcl 93 set ref 113 154* 159*
sub_err_                        000020 constant        entry                    external dcl 81 ref 167

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 4-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 4-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 4-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 4-7
BCI_HEADER_LENGTH_IN_BYTES             internal static fixed bin(17,0)          initial dcl 2-14
CI_0_ADDRESSABLE_LENGTH                internal static fixed bin(17,0)          initial dcl 3-31
CI_ADDRESSABLE_LENGTH                  internal static fixed bin(17,0)          initial dcl 3-29
CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 3-25
DATUM_POSITION_TABLE_OFFSET_IN_BYTES   internal static fixed bin(17,0)          initial dcl 2-16
FREE_SLOT                              internal static fixed bin(15,0)          initial unsigned dcl 2-13
basic_control_interval                 based           structure                level 1 dcl 1-56
basic_control_interval_ptr             automatic       pointer                  dcl 1-92
bci_header_ptr                         automatic       pointer                  dcl 1-94
datum_slot_ptr                         automatic       pointer                  dcl 1-95

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_CI_VERSION                000443 constant        entry                    internal dcl 162 ref 102 119
ERROR_RETURN                    000435 constant        entry                    internal dcl 142 ref 104 107 117 136
MAIN_RETURN                     000410 constant        label                    dcl 138 ref 148
cm_replace_buffered_ci          000145 constant        entry                    external dcl 38
trace_thread_modifications_off  000425 constant        entry                    external dcl 157
trace_thread_modifications_on   000413 constant        entry                    external dcl 152

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       706         736     536         716
Length      1220     536        30         245     150           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_replace_buffered_ci              204 external procedure  is an external procedure.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure cm_replace_buffered_ci.  
CHECK_CI_VERSION                        internal procedure  shares stack frame of external procedure cm_replace_buffered_ci.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 static_trace_thread_switch  cm_replace_buffered_ci

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_replace_buffered_ci   000100 code                        cm_replace_buffered_ci
                         000101 ci_buffer_length_in_bits    cm_replace_buffered_ci
                         000102 ci_buffer_ptr               cm_replace_buffered_ci
                         000104 existing_bci_header         cm_replace_buffered_ci

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_get_bci_header             file_manager_$simple_put      ioa_                          sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$ci_buffer_too_small dm_error_$ci_not_in_collection
dm_error_$unimplemented_ci_version


CONSTANTS
000526  aa     000002000000
000527  aa     000000000000
000530  aa     600000000041
000531  aa     000104000000

000532  aa     000002000000
000533  aa     000000000000
000534  aa     600000000041
000535  aa     000100000000

000000  aa  142 143 151 061	bci1

000001  aa     000000000026
000002  aa  143 155 137 162	cm_r
000003  aa  145 160 154 141	epla
000004  aa  143 145 137 142	ce_b
000005  aa  165 146 146 145	uffe
000006  aa  162 145 144 137	red_
000007  aa  143 151 040 040	ci  
000010  aa  040 040 040 040	    
000011  aa  040 040 040 040	    

000012  aa     524000000066

000013  aa     404000000005

000014  aa     530000000040

000015  aa     524000000004

000016  aa     400000000000

000017  aa     524000000151

000020  aa     606000000030

000021  aa     524000000155

000022  aa     000000000000

000023  aa     404000000043

000024  aa     464000000000

000025  aa     604000000030

000026  aa     514000000044

000030  aa     077777000043
000031  aa     000001000000

000032  aa  136 057 105 170	^/Ex
000033  aa  160 145 143 164	pect
000034  aa  145 144 040 166	ed v
000035  aa  145 162 163 151	ersi
000036  aa  157 156 040 136	on ^
000037  aa  064 141 040 143	4a c
000040  aa  157 156 164 162	ontr
000041  aa  157 154 040 151	ol i
000042  aa  156 164 145 162	nter
000043  aa  166 141 154 073	val;
000044  aa  040 162 145 143	 rec
000045  aa  145 151 166 145	eive
000046  aa  144 040 136 064	d ^4
000047  aa  141 056 000 000	a.

000050  aa  102 165 146 146	Buff
000051  aa  145 162 145 144	ered
000052  aa  040 143 157 156	 con
000053  aa  164 162 157 154	trol
000054  aa  040 151 156 164	 int
000055  aa  145 162 166 141	erva
000056  aa  154 040 136 144	l ^d
000057  aa  040 143 150 141	 cha
000060  aa  156 147 145 144	nged
000061  aa  040 144 165 162	 dur
000062  aa  151 156 147 040	ing 
000063  aa  162 145 160 154	repl
000064  aa  141 143 145 155	acem
000065  aa  145 156 164 056	ent.
000066  aa  136 057 136 070	^/^8
000067  aa  170 116 145 170	xNex
000070  aa  164 040 143 157	t co
000071  aa  156 164 162 157	ntro
000072  aa  154 040 151 156	l in
000073  aa  164 145 162 166	terv
000074  aa  141 154 040 143	al c
000075  aa  150 141 156 147	hang
000076  aa  145 144 040 146	ed f
000077  aa  162 157 155 040	rom 
000100  aa  136 144 040 164	^d t
000101  aa  157 040 136 144	o ^d
000102  aa  056 000 000 000	.

000103  aa  102 165 146 146	Buff
000104  aa  145 162 145 144	ered
000105  aa  040 143 157 156	 con
000106  aa  164 162 157 154	trol
000107  aa  040 151 156 164	 int
000110  aa  145 162 166 141	erva
000111  aa  154 040 136 144	l ^d
000112  aa  040 143 150 141	 cha
000113  aa  156 147 145 144	nged
000114  aa  040 144 165 162	 dur
000115  aa  151 156 147 040	ing 
000116  aa  162 145 160 154	repl
000117  aa  141 143 145 155	acem
000120  aa  145 156 164 056	ent.
000121  aa  136 057 136 070	^/^8
000122  aa  170 120 162 145	xPre
000123  aa  166 151 157 165	viou
000124  aa  163 040 143 157	s co
000125  aa  156 164 162 157	ntro
000126  aa  154 040 151 156	l in
000127  aa  164 145 162 166	terv
000130  aa  141 154 040 143	al c
000131  aa  150 141 156 147	hang
000132  aa  145 144 040 146	ed f
000133  aa  162 157 155 040	rom 
000134  aa  136 144 040 164	^d t
000135  aa  157 040 136 144	o ^d
000136  aa  056 000 000 000	.

BEGIN PROCEDURE cm_replace_buffered_ci
ENTRY TO cm_replace_buffered_ci                             STATEMENT 1 ON LINE 38
cm_replace_buffered_ci:
   proc (p_file_opening_id, p_collection_id, p_control_interval_number, p_ci_buffer_ptr, p_ci_buffer_length_in_bits,
        p_code);

000137  at     000006000026
000140  tt     000026000025
000141  tt     000024000023
000142  ta     000023000000
000143  ta     000137000000
000144  da     000116300000
000145  aa   000320 6270 00	eax7 	208
000146  aa  7 00034 3521 20	epp2 	pr7|28,*
000147  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000150  aa     000014000000
000151  aa     000000000000
						STATEMENT 1 ON LINE 98
      p_code, code = 0;

000152  aa  6 00032 3735 20	epp7 	pr6|26,*
000153  aa  7 00014 4501 20	stz  	pr7|12,*		p_code
000154  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 99
      ci_buffer_length_in_bits = p_ci_buffer_length_in_bits;

000155  aa  7 00012 2361 20	ldq  	pr7|10,*		p_ci_buffer_length_in_bits
000156  aa  6 00101 7561 00	stq  	pr6|65		ci_buffer_length_in_bits
						STATEMENT 1 ON LINE 100
      ci_buffer_ptr = p_ci_buffer_ptr;

000157  aa  7 00010 3715 20	epp5 	pr7|8,*		p_ci_buffer_ptr
000160  aa  5 00000 3715 20	epp5 	pr5|0,*		p_ci_buffer_ptr
000161  aa  6 00102 6515 00	spri5	pr6|66		ci_buffer_ptr
						STATEMENT 1 ON LINE 102
      call CHECK_CI_VERSION (ci_buffer_ptr -> bci_header.layout_type);

000162  aa  5 00000 3521 00	epp2 	pr5|0		bci_header.layout_type
000163  aa  6 00130 2521 00	spri2	pr6|88
000164  aa  6 00126 3521 00	epp2 	pr6|86
000165  aa   004000 4310 07	fld  	2048,dl
000166  aa  2 00000 7571 00	staq 	pr2|0
000167  aa   000254 6700 04	tsp4 	172,ic		000443
						STATEMENT 1 ON LINE 104
      if ci_buffer_ptr -> bci_header.collection_id ^= p_collection_id
      then call ERROR_RETURN (dm_error_$ci_not_in_collection);

000170  aa  6 00102 3735 20	epp7 	pr6|66,*		ci_buffer_ptr
000171  aa  7 00001 2351 00	lda  	pr7|1		bci_header.collection_id
000172  aa  6 00032 3715 20	epp5 	pr6|26,*
000173  aa  5 00004 1151 20	cmpa 	pr5|4,*		p_collection_id
000174  aa   000010 6000 04	tze  	8,ic		000204
000175  aa  6 00044 3701 20	epp4 	pr6|36,*
000176  la  4 00022 3521 20	epp2 	pr4|18,*		dm_error_$ci_not_in_collection
000177  aa  6 00130 2521 00	spri2	pr6|88
000200  aa  6 00126 3521 00	epp2 	pr6|86
000201  aa   004000 4310 07	fld  	2048,dl
000202  aa  2 00000 7571 00	staq 	pr2|0
000203  aa   000232 6700 04	tsp4 	154,ic		000435
						STATEMENT 1 ON LINE 107
      if ci_buffer_length_in_bits < CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES * BITS_PER_WORD
      then call ERROR_RETURN (dm_error_$ci_buffer_too_small);

000204  aa   107450 2360 07	ldq  	36648,dl
000205  aa  6 00101 1161 00	cmpq 	pr6|65		ci_buffer_length_in_bits
000206  aa   000010 6044 04	tmoz 	8,ic		000216
000207  aa  6 00044 3701 20	epp4 	pr6|36,*
000210  la  4 00024 3521 20	epp2 	pr4|20,*		dm_error_$ci_buffer_too_small
000211  aa  6 00130 2521 00	spri2	pr6|88
000212  aa  6 00126 3521 00	epp2 	pr6|86
000213  aa   004000 4310 07	fld  	2048,dl
000214  aa  2 00000 7571 00	staq 	pr2|0
000215  aa   000220 6700 04	tsp4 	144,ic		000435
						STATEMENT 1 ON LINE 113
      if static_trace_thread_switch
      then
         do;

000216  aa  6 00044 3701 20	epp4 	pr6|36,*
000217  ia  4 00010 2351 00	lda  	pr4|8		static_trace_thread_switch
000220  aa   000135 6000 04	tze  	93,ic		000355
						STATEMENT 1 ON LINE 116
	  call cm_get_bci_header (p_file_opening_id, p_control_interval_number, addr (existing_bci_header), code);

000221  aa  6 00104 3735 00	epp7 	pr6|68		existing_bci_header
000222  aa  6 00134 6535 00	spri7	pr6|92
000223  aa  6 00032 3715 20	epp5 	pr6|26,*
000224  aa  5 00002 3521 20	epp2 	pr5|2,*		p_file_opening_id
000225  aa  6 00140 2521 00	spri2	pr6|96
000226  aa  5 00006 3521 20	epp2 	pr5|6,*		p_control_interval_number
000227  aa  6 00142 2521 00	spri2	pr6|98
000230  aa  6 00134 3521 00	epp2 	pr6|92
000231  aa  6 00144 2521 00	spri2	pr6|100
000232  aa  6 00100 3521 00	epp2 	pr6|64		code
000233  aa  6 00146 2521 00	spri2	pr6|102
000234  aa  6 00136 6211 00	eax1 	pr6|94
000235  aa   020000 4310 07	fld  	8192,dl
000236  la  4 00016 3521 20	epp2 	pr4|14,*		cm_get_bci_header
000237  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 117
	  if code ^= 0
	  then call ERROR_RETURN (code);

000240  aa  6 00100 2361 00	ldq  	pr6|64		code
000241  aa   000004 6000 04	tze  	4,ic		000245
000242  aa   000270 3520 04	epp2 	184,ic		000532 = 000002000000
000243  aa   000172 6700 04	tsp4 	122,ic		000435
000244  aa   000003 7100 04	tra  	3,ic		000247
						STATEMENT 1 ON LINE 119
	  else call CHECK_CI_VERSION (existing_bci_header.layout_type);

000245  aa   000261 3520 04	epp2 	177,ic		000526 = 000002000000
000246  aa   000175 6700 04	tsp4 	125,ic		000443
						STATEMENT 1 ON LINE 120
	  if existing_bci_header.previous_control_interval ^= ci_buffer_ptr -> bci_header.previous_control_interval
	  then call ioa_ (
		  "Buffered control interval ^d changed during replacement.^/^8xPrevious control interval changed from ^d to ^d."
		  , p_control_interval_number, existing_bci_header.previous_control_interval,
		  ci_buffer_ptr -> bci_header.previous_control_interval);

000247  aa  6 00102 3735 20	epp7 	pr6|66,*		ci_buffer_ptr
000250  aa  7 00002 2351 00	lda  	pr7|2		bci_header.previous_control_interval
000251  aa  7 00003 2361 00	ldq  	pr7|3		bci_header.previous_control_interval
000252  aa   000030 7370 00	lls  	24
000253  aa   000060 7730 00	lrl  	48
000254  aa  6 00150 7561 00	stq  	pr6|104		bci_header.previous_control_interval
000255  aa  6 00106 2371 00	ldaq 	pr6|70		existing_bci_header.previous_control_interval
000256  aa   000030 7370 00	lls  	24
000257  aa   000060 7730 00	lrl  	48
000260  aa  6 00150 1161 00	cmpq 	pr6|104		bci_header.previous_control_interval
000261  aa   000034 6000 04	tze  	28,ic		000315
000262  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000263  aa   777621 00 0160	desc9a	-111,112		000103 = 102165146146
000264  aa  6 00152 00 0160	desc9a	pr6|106,112
000265  aa  6 00152 3521 00	epp2 	pr6|106
000266  aa  6 00210 2521 00	spri2	pr6|136
000267  aa  6 00032 3715 20	epp5 	pr6|26,*
000270  aa  5 00006 3521 20	epp2 	pr5|6,*		p_control_interval_number
000271  aa  6 00212 2521 00	spri2	pr6|138
000272  aa   000030 7270 07	lxl7 	24,dl
000273  aa  6 00106 3521 00	epp2 	pr6|70		existing_bci_header.previous_control_interval
000274  aa  2 00000 5035 17	abd  	pr2|0,7
000275  aa  6 00214 2521 00	spri2	pr6|140
000276  aa  7 00002 3521 00	epp2 	pr7|2		bci_header.previous_control_interval
000277  aa  2 00000 5035 17	abd  	pr2|0,7
000300  aa  6 00216 2521 00	spri2	pr6|142
000301  aa   777520 3520 04	epp2 	-176,ic		000021 = 524000000155
000302  aa  6 00220 2521 00	spri2	pr6|144
000303  aa   777522 3520 04	epp2 	-174,ic		000025 = 604000000030
000304  aa  6 00222 2521 00	spri2	pr6|146
000305  aa   777513 3520 04	epp2 	-181,ic		000020 = 606000000030
000306  aa  6 00224 2521 00	spri2	pr6|148
000307  aa  6 00226 2521 00	spri2	pr6|150
000310  aa  6 00206 6211 00	eax1 	pr6|134
000311  aa   020000 4310 07	fld  	8192,dl
000312  aa  6 00044 3701 20	epp4 	pr6|36,*
000313  la  4 00014 3521 20	epp2 	pr4|12,*		ioa_
000314  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 125
	  if existing_bci_header.next_control_interval ^= ci_buffer_ptr -> bci_header.next_control_interval
	  then call ioa_ (
		  "Buffered control interval ^d changed during replacement.^/^8xNext control interval changed from ^d to ^d."
		  , p_control_interval_number, existing_bci_header.next_control_interval,
		  ci_buffer_ptr -> bci_header.next_control_interval);

000315  aa  6 00102 3735 20	epp7 	pr6|66,*		ci_buffer_ptr
000316  aa  7 00002 2351 00	lda  	pr7|2		bci_header.next_control_interval
000317  aa   000060 7730 00	lrl  	48
000320  aa  6 00151 7561 00	stq  	pr6|105		bci_header.next_control_interval
000321  aa  6 00106 2351 00	lda  	pr6|70		existing_bci_header.next_control_interval
000322  aa   000060 7730 00	lrl  	48
000323  aa  6 00151 1161 00	cmpq 	pr6|105		bci_header.next_control_interval
000324  aa   000031 6000 04	tze  	25,ic		000355
000325  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000326  aa   777523 00 0154	desc9a	-173,108		000050 = 102165146146
000327  aa  6 00152 00 0154	desc9a	pr6|106,108
000330  aa  6 00152 3521 00	epp2 	pr6|106
000331  aa  6 00210 2521 00	spri2	pr6|136
000332  aa  6 00032 3715 20	epp5 	pr6|26,*
000333  aa  5 00006 3521 20	epp2 	pr5|6,*		p_control_interval_number
000334  aa  6 00212 2521 00	spri2	pr6|138
000335  aa  6 00106 3521 00	epp2 	pr6|70		existing_bci_header.next_control_interval
000336  aa  6 00214 2521 00	spri2	pr6|140
000337  aa  7 00002 3521 00	epp2 	pr7|2		bci_header.next_control_interval
000340  aa  6 00216 2521 00	spri2	pr6|142
000341  aa   777456 3520 04	epp2 	-210,ic		000017 = 524000000151
000342  aa  6 00220 2521 00	spri2	pr6|144
000343  aa   777462 3520 04	epp2 	-206,ic		000025 = 604000000030
000344  aa  6 00222 2521 00	spri2	pr6|146
000345  aa   777453 3520 04	epp2 	-213,ic		000020 = 606000000030
000346  aa  6 00224 2521 00	spri2	pr6|148
000347  aa  6 00226 2521 00	spri2	pr6|150
000350  aa  6 00206 6211 00	eax1 	pr6|134
000351  aa   020000 4310 07	fld  	8192,dl
000352  aa  6 00044 3701 20	epp4 	pr6|36,*
000353  la  4 00014 3521 20	epp2 	pr4|12,*		ioa_
000354  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 130
         end;

						STATEMENT 1 ON LINE 134
      call file_manager_$simple_put (p_file_opening_id, (p_control_interval_number), START_OF_CI_OFFSET, ci_buffer_ptr,
	 (CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES), code);

000355  aa  6 00032 3735 20	epp7 	pr6|26,*
000356  aa  7 00006 2361 20	ldq  	pr7|6,*		p_control_interval_number
000357  aa  6 00151 7561 00	stq  	pr6|105
000360  aa   007750 2360 07	ldq  	4072,dl
000361  aa  6 00150 7561 00	stq  	pr6|104
000362  aa  7 00002 3521 20	epp2 	pr7|2,*		p_file_opening_id
000363  aa  6 00210 2521 00	spri2	pr6|136
000364  aa  6 00151 3521 00	epp2 	pr6|105
000365  aa  6 00212 2521 00	spri2	pr6|138
000366  aa   777434 3520 04	epp2 	-228,ic		000022 = 000000000000
000367  aa  6 00214 2521 00	spri2	pr6|140
000370  aa  6 00102 3521 00	epp2 	pr6|66		ci_buffer_ptr
000371  aa  6 00216 2521 00	spri2	pr6|142
000372  aa  6 00150 3521 00	epp2 	pr6|104
000373  aa  6 00220 2521 00	spri2	pr6|144
000374  aa  6 00100 3521 00	epp2 	pr6|64		code
000375  aa  6 00222 2521 00	spri2	pr6|146
000376  aa  6 00206 6211 00	eax1 	pr6|134
000377  aa   030000 4310 07	fld  	12288,dl
000400  aa  6 00044 3701 20	epp4 	pr6|36,*
000401  la  4 00012 3521 20	epp2 	pr4|10,*		file_manager_$simple_put
000402  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 136
      if code ^= 0
      then call ERROR_RETURN (code);

000403  aa  6 00100 2361 00	ldq  	pr6|64		code
000404  aa   000004 6000 04	tze  	4,ic		000410
000405  aa   000125 3520 04	epp2 	85,ic		000532 = 000002000000
000406  aa   000027 6700 04	tsp4 	23,ic		000435
000407  aa   000011 7100 04	tra  	9,ic		000420
						STATEMENT 1 ON LINE 138
      else
MAIN_RETURN:
         return;

000410  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 152
trace_thread_modifications_on:
   entry ();

000411  aa   000007 7100 04	tra  	7,ic		000420
ENTRY TO trace_thread_modifications_on                      STATEMENT 1 ON LINE 152
trace_thread_modifications_on:
   entry ();

000412  da     000131200000
000413  aa   000320 6270 00	eax7 	208
000414  aa  7 00034 3521 20	epp2 	pr7|28,*
000415  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000416  aa     000000000000
000417  aa     000000000000
						STATEMENT 1 ON LINE 154
      static_trace_thread_switch = "1"b;

000420  aa   400000 2350 03	lda  	131072,du
000421  aa  6 00044 3701 20	epp4 	pr6|36,*
000422  ia  4 00010 7551 00	sta  	pr4|8		static_trace_thread_switch
						STATEMENT 1 ON LINE 155
      return;

000423  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO trace_thread_modifications_off                     STATEMENT 1 ON LINE 157
trace_thread_modifications_off:
   entry ();

000424  da     000144200000
000425  aa   000320 6270 00	eax7 	208
000426  aa  7 00034 3521 20	epp2 	pr7|28,*
000427  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000430  aa     000000000000
000431  aa     000000000000
						STATEMENT 1 ON LINE 159
      static_trace_thread_switch = "0"b;

000432  aa  6 00044 3701 20	epp4 	pr6|36,*
000433  ia  4 00010 4501 00	stz  	pr4|8		static_trace_thread_switch
						STATEMENT 1 ON LINE 160
      return;

000434  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 182
   end cm_replace_buffered_ci;

BEGIN PROCEDURE ERROR_RETURN
ENTRY TO ERROR_RETURN                                       STATEMENT 1 ON LINE 142
ERROR_RETURN:
   proc (er_p_code);

000435  aa  6 00112 6501 00	spri4	pr6|74
000436  aa  6 00114 2521 00	spri2	pr6|76
						STATEMENT 1 ON LINE 147
      p_code = er_p_code;

000437  aa  2 00002 2361 20	ldq  	pr2|2,*		er_p_code
000440  aa  6 00032 3735 20	epp7 	pr6|26,*
000441  aa  7 00014 7561 20	stq  	pr7|12,*		p_code
						STATEMENT 1 ON LINE 148
      go to MAIN_RETURN;

000442  aa   777746 7100 04	tra  	-26,ic		000410
						STATEMENT 1 ON LINE 150
   end ERROR_RETURN;

  END PROCEDURE ERROR_RETURN
BEGIN PROCEDURE CHECK_CI_VERSION
ENTRY TO CHECK_CI_VERSION                                   STATEMENT 1 ON LINE 162
CHECK_CI_VERSION:
   proc (ccv_p_given_version);

000443  aa  6 00120 6501 00	spri4	pr6|80
000444  aa  6 00122 2521 00	spri2	pr6|82
						STATEMENT 1 ON LINE 167
      if ccv_p_given_version ^= BASIC_CI_LAYOUT_1
      then call sub_err_ (dm_error_$unimplemented_ci_version, myname, ACTION_CANT_RESTART, null, 0,
	      "^/Expected version ^4a control interval; received ^4a.", BASIC_CI_LAYOUT_1, ccv_p_given_version);

000445  aa  2 00002 2351 20	lda  	pr2|2,*		ccv_p_given_version
000446  aa   777332 1150 04	cmpa 	-294,ic		000000 = 142143151061
000447  aa   000055 6000 04	tze  	45,ic		000524
000450  aa   777360 3734 24	epp7 	-272,ic*
000451  aa  6 00230 6535 00	spri7	pr6|152
000452  aa  6 00232 4501 00	stz  	pr6|154
000453  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000454  aa   777357 00 0070	desc9a	-273,56		000032 = 136057105170
000455  aa  6 00234 00 0070	desc9a	pr6|156,56
000456  aa  6 00044 3701 20	epp4 	pr6|36,*
000457  la  4 00026 3521 20	epp2 	pr4|22,*		dm_error_$unimplemented_ci_version
000460  aa  6 00254 2521 00	spri2	pr6|172
000461  aa   777321 3520 04	epp2 	-303,ic		000002 = 143155137162
000462  aa  6 00256 2521 00	spri2	pr6|174
000463  aa   777333 3520 04	epp2 	-293,ic		000016 = 400000000000
000464  aa  6 00260 2521 00	spri2	pr6|176
000465  aa  6 00230 3521 00	epp2 	pr6|152
000466  aa  6 00262 2521 00	spri2	pr6|178
000467  aa  6 00232 3521 00	epp2 	pr6|154
000470  aa  6 00264 2521 00	spri2	pr6|180
000471  aa  6 00234 3521 00	epp2 	pr6|156
000472  aa  6 00266 2521 00	spri2	pr6|182
000473  aa   777305 3520 04	epp2 	-315,ic		000000 = 142143151061
000474  aa  6 00270 2521 00	spri2	pr6|184
000475  aa  6 00122 3715 20	epp5 	pr6|82,*
000476  aa  5 00002 3521 20	epp2 	pr5|2,*		ccv_p_given_version
000477  aa  6 00272 2521 00	spri2	pr6|186
000500  aa   777323 3520 04	epp2 	-301,ic		000023 = 404000000043
000501  aa  6 00274 2521 00	spri2	pr6|188
000502  aa   777312 3520 04	epp2 	-310,ic		000014 = 530000000040
000503  aa  6 00276 2521 00	spri2	pr6|190
000504  aa   777322 3520 04	epp2 	-302,ic		000026 = 514000000044
000505  aa  6 00300 2521 00	spri2	pr6|192
000506  aa   777316 3520 04	epp2 	-306,ic		000024 = 464000000000
000507  aa  6 00302 2521 00	spri2	pr6|194
000510  aa   777303 3520 04	epp2 	-317,ic		000013 = 404000000005
000511  aa  6 00304 2521 00	spri2	pr6|196
000512  aa   777300 3520 04	epp2 	-320,ic		000012 = 524000000066
000513  aa  6 00306 2521 00	spri2	pr6|198
000514  aa   777301 3520 04	epp2 	-319,ic		000015 = 524000000004
000515  aa  6 00310 2521 00	spri2	pr6|200
000516  aa  6 00312 2521 00	spri2	pr6|202
000517  aa  6 00252 6211 00	eax1 	pr6|170
000520  aa   040000 4310 07	fld  	16384,dl
000521  la  4 00020 3521 20	epp2 	pr4|16,*		sub_err_
000522  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
000523  aa   000002 7100 04	tra  	2,ic		000525
						STATEMENT 1 ON LINE 170
      else return;

000524  aa  6 00120 6101 00	rtcd 	pr6|80
						STATEMENT 1 ON LINE 172
   end CHECK_CI_VERSION;

000525  aa  6 00120 6101 00	rtcd 	pr6|80
  END PROCEDURE CHECK_CI_VERSION
  END PROCEDURE cm_replace_buffered_ci


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
