	COMPILATION LISTING OF SEGMENT mu_build_tuple
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/18/85  1038.0 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 
       10 
       11 /* ******************************************************
       12*   *                                                    *
       13*   *                                                    *
       14*   * Copyright (c) 1972 by Massachusetts Institute of   *
       15*   * Technology and Honeywell Information Systems, Inc. *
       16*   *                                                    *
       17*   *                                                    *
       18*   ****************************************************** */
       19 
       20 mu_build_tuple:
       21      proc (rmri_ptr, area_ptr, vector_ptr, ml_ptr, mod_flag, code);
       22 
       23 /* NOTES:
       24*
       25*		      BEGIN_DESCRIPTION
       26*
       27*   This  procedure  inserts user values into the supplied tuple.  Encoding and
       28*   domain  integrity  checking are performed if specified.
       29*
       30*		       END_DESCRIPTION
       31*
       32*
       33*   HISTORY:
       34*
       35*   78-07-01 J. A. Weeldreyer : Initially written.
       36*
       37*   79-05-19  Al  Kepner:  Modified  to  provide  a  handler for the conversion
       38*   condition.
       39*
       40*   79-06-09   Al   Kepner:  Modified  to  align  varying  attributes  on  word
       41*   boundaries.
       42*
       43*   79-11-16  Davids:  Corrected  calculation of offset in the tuple of varying
       44*   strings  which  always assumed that the lengths were bit when they may have
       45*   been character.  This could result in losing characters.
       46*
       47*   79-12-12  Mary  Ward: Modified to correctly initialize icode and to provide
       48*   some  measure  of  integrity checking on the data returned from user encode
       49*   and check procedures.
       50*
       51*   80-02-01 Jim Gray : Modified to add area_ptr parameter.
       52*
       53*   80-02-02  Jim Gray : Modified to change the check_proc accept_flag to fixed
       54*   bin(35), to comply with cobol interface capability.
       55*
       56*
       57*   80-05-07 Davids: modified assignments of tuple_num_atts and tuple_nvar_atts
       58*   to  take  values from rm_rel_info.model_num_attr and model_nvar_atts rather
       59*   than  rm_rel_info.num_attr  and  nvar_atts.  This was to fix a problem with
       60*   submodels were the submodel view did not contain a varying string attribute
       61*   and the model did.
       62*
       63*   80-09-18  Jim  Gray  :  Modified  to correct problem with modifying varying
       64*   character string attributes.  The routine shift_attr was not converting the
       65*   shift  length  to bit from char before shifting attributes to make room for
       66*   the modified attribute value.
       67*
       68*   80-09-18  Jim  Gray  :  Modified to make sure that padding space in aligned
       69*   data  types  was  always  handled  the same, regardless of who, or how this
       70*   module  was  called.  This was a critical bug because it caused compares to
       71*   fail  where  they should have suceeded, and requires the user to reload his
       72*   database, using the new version of this routine.
       73*
       74*   80-09-19  Jim  Gray  :  Modified  to  make  padding  fix work for only byte
       75*   oriented  data  (i.e.   strings  types  like  bit or char, and decimal data
       76*   types) since binary arith types which are handled by word oriented hardware
       77*   instructions  will  be  right justified, and not contain garbage in padding
       78*   space.   Also  complex  types (binary) have there padding split between the
       79*   real and imag parts.  (this all apllies to aligned data only)
       80*
       81*   80-12-08 Davids: modified so that the pointer passed to Check_out points to
       82*   the  begining  of  the  variable  in  all  cases.   It used to point to the
       83*   begining  of  the  character  string  instead  of the length word in varing
       84*   string  types.  This was because the pointer is used in a gen_call in which
       85*   case  it  must  point  to  the characters not the length - but it was never
       86*   changed back.  This was done in response to TR8572.
       87*
       88*   81-01-17 Jim Gray : made same changes as made to mus_mod_ubtup for TR 8670,
       89*   see that module for details.
       90*
       91*   81-01-23 Jim Gray : corrected problem with modifying a varying attribute in
       92*   the  case  that  the  new  size was smaller than the old size.  the routine
       93*   shift_insert  was  causing attributes to the left of the modified attribute
       94*   to  be  moved, when for either positive or negative shifts, only attributes
       95*   to the right of the modified attribute in the tuple have to be moved.
       96*
       97*   81-02-17  Jim  Gray  :  change A, for TR 9133, changed if statement in case
       98*   where  a  new  tuple  with varying attrs is being built, and the attr being
       99*   added to the tuple is the last varying attr so far, but of a different type
      100*   (char versus bit) from that of the previous varying attr.  Previously a bit
      101*   varying following a char varying caused the char varying to be overwritten,
      102*   because  the char length was not multiplied by 9 to get a bit length.  Note
      103*   that  for  dsl_$store  calls,  the  attrs will always be in order, thus the
      104*   current  attr  is  the last one defined so far, only temp rel will possibly
      105*   have the attrs differ from definition order.
      106*
      107*   81-02-17  Jim Gray : change B, corrected second parameter to compute shift,
      108*   to correctly be a bit rather than char length.  The effect previously, when
      109*   the count field of the varying attr was passed was to either undershift for
      110*   negative  shift_delta,  or overshift for positive shift_delta.  Thus either
      111*   space  was  not recovered, or space was used when not needed.  This was for
      112*   TR 9136, the shift_len part of that TR fix was done 80-09-19.
      113*
      114*   81-02-17  Jim Gray : change C, for TR 9138, pointing out problem with doing
      115*   in  place  moves  of tuple data during a modify, that can cause part of the
      116*   string  to  overwrite  itself.   The temp_string is placed on the stack for
      117*   this case, since only one attr is done at a time, and the largest attr is <
      118*   1300  words.  Note that to make this fail previously required at least a 16
      119*   character string, since the hardware works on double word pairs (i.e.  four
      120*   words).
      121*
      122*   81-05-06   Rickie  E.   Brinegar:  Changed  the  use  of  cu_$gen_call  for
      123*   check_procs and encode_procs to cu_$generate_call.  This was done to permit
      124*   check_procs and encode_procs to be written in other than pl1.
      125*
      126*   81-05-23 Jim Gray : commented out references to threads in the tuple structure,
      127*   as part of removing unused parts in the include file.
      128*
      129*   81-06-01 Jim Gray : changed to use new version of resultant.
      130*
      131*   81-08-11 Jim Gray : fixed trashed tuple problem that occurs  when
      132*   a submodel re-orders the relation from (kh* ht* indx data) to (kh
      133*   data indx kt) with all attributes varying strings  and  the  data
      134*   values  are "kh1", "data1", "indx1", "kt1" for a store operation.
      135*   The problem was that when moving attributes that are to appear to
      136*   the  right of the current attr (say indx which arrives 3rd in the
      137*   move list), the length of the current attribute being replaced is
      138*   really  -36 not 0, so that the not yet existing attrs count field
      139*   is considered for the length of the move for attrs to the right.
      140*
      141*   81-10-22 Davids: Have converted references of the form:
      142*   .          ptr = addr (bit_array (large_offset))
      143*   .	              to
      144*   .          ptr = add_bit_offset (bit_array_ptr, large_offset - 1)
      145*   This gets around a pl1 bug (tr11784) that causes the first method
      146*   to  produce  the  wrong  value  when  the code is compiled with a
      147*   subscriptrange condition. The "-1" is needed because  bit_array's
      148*   first element is 1 not 0.
      149*
      150*   82-09-14 Mike Kubicar : Converted to use the vector structure.
      151*
      152*   83-03-28 Davids: Modified so the general and simple typed_vectors
      153*   only have the type and number_of_dimensions elements set correctly.
      154*   The value_ptr and identifier (general vector only) elements are
      155*   left un-initialized. This was done to improve the performance
      156*   of this module which was terrible before the change. 
      157**/
      158 
      159 	wa_ptr = area_ptr;				/* initialize */
      160 	icode = 0;
      161 	ub_alloc = "0"b;
      162 	on conversion go to conversion_error;
      163 
      164 	if mod_flag then do;
      165 		general_typed_vector_ptr = vector_ptr;
      166 		general_typed_vector.type = GENERAL_TYPED_VECTOR_TYPE;
      167 		general_typed_vector.number_of_dimensions = move_list.nitems;
      168 	     end;
      169 	else do;
      170 		simple_typed_vector_ptr = vector_ptr;
      171 		simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
      172 		simple_typed_vector.number_of_dimensions = move_list.nitems;
      173 	     end;
      174 
      175 	do i = 1 to move_list.nitems;			/* beginning of attribute value insertion loop */
      176 
      177 	     rai_ptr = rm_rel_info.attr_ptrs (move_list.item.attr_index (i));
      178 						/* pick up info ptrs */
      179 	     rdi_ptr = rm_attr_info.domain_ptr;
      180 
      181 	     if rm_domain_info.encd_proc then do;	/* if value must be encoded */
      182 		     allocate value_for_db in (work_area) set (db_val_ptr);
      183 
      184 		     value_for_db = "0"b;		/* clear space */
      185 
      186 		     if move_list.item.user_desc_ptr (i) -> bit36 ^= /* if must convert prior to encoding */
      187 			rm_domain_info.user_desc then do;
      188 
      189 			     if rm_domain_info.user_bit_len > 2376 then do;
      190 						/* if long, alloc. space */
      191 				     allocate value_for_user in (work_area) set (user_val_ptr);
      192 				     ub_alloc = "1"b;
      193 				end;
      194 			     else user_val_ptr = addr (wksp); /* else use stack */
      195 
      196 			     value_for_user = "0"b;	/* clear area */
      197 
      198 			     call
      199 				mu_convert (move_list.item.user_ptr (i),
      200 				move_list.item.user_desc_ptr (i), user_val_ptr,
      201 				addr (rm_domain_info.user_desc), icode);
      202 			     if icode ^= 0 then
      203 				call error (icode);
      204 
      205 			     encode_list.uv_ptr = user_val_ptr; /* put ptr in arg list */
      206 			end;			/* if needed to convert */
      207 		     else encode_list.uv_ptr = move_list.item.user_ptr (i);
      208 						/* if no need to convert */
      209 
      210 		     user_descriptor = rm_domain_info.user_desc; /* get descriptor for encode input */
      211 		     encode_list.ud_ptr = addr (user_descriptor); /* put addr in arg list */
      212 
      213 		     if encode_list.ud_ptr -> descriptor.type = VAR_CHAR
      214 			/* if varying, reset arg ptr */
      215 			| encode_list.ud_ptr -> descriptor.type = VAR_BIT then
      216 			/* to point to string, not length */
      217 			encode_list.uv_ptr =
      218 			     addr (encode_list.uv_ptr -> varying.string);
      219 
      220 		     encode_list.dbv_ptr = db_val_ptr;	/* will be output from encode */
      221 		     db_descriptor = rm_domain_info.db_desc; /* move descriptor into local storage */
      222 		     encode_list.dbd_ptr = addr (db_descriptor); /* and put in arg list */
      223 
      224 		     if encode_list.dbd_ptr -> descriptor.type = VAR_CHAR
      225 			| encode_list.dbd_ptr -> descriptor.type = VAR_BIT then
      226 			encode_list.dbv_ptr =
      227 			     addr (encode_list.dbv_ptr -> varying.string);
      228 
      229 		     encode_list.code_ptr = addr (icode); /* move return code info into arg list */
      230 		     encode_list.coded_ptr = addr (FB35_DESC);
      231 
      232 /* 81-05-06 Rickie E. Brinegar: Start changed code ************************* */
      233 
      234 		     call cu_$generate_call /* call user's encode proc with three arguments */
      235 			(rm_domain_info.encd_proc_entry, addr (encode_list));
      236 						/* call encode_proc(val_for_user,val_for_db,icode) */
      237 
      238 /* 81-05-06 Rickie E. Brinegar: End changed code *************************** */
      239 
      240 		     if icode ^= 0 then
      241 			call error (icode);
      242 
      243 		     if encode_list.dbd_ptr -> descriptor.type = VAR_CHAR
      244 			/* move the pointer back to the length word */
      245 			| encode_list.dbd_ptr -> descriptor.type = VAR_BIT
      246 						/* this should be ok because varing */
      247 		     then encode_list.dbv_ptr = addrel (encode_list.dbv_ptr, -1);
      248 						/* strings aligned so no bit offset */
      249 
      250 		     call Check_out (encode_list.dbd_ptr, encode_list.dbv_ptr, icode);
      251 						/* make sure no hanky-panky */
      252 		     if icode ^= 0 then
      253 			call error (icode);		/* some sort of trouble */
      254 
      255 		     if ub_alloc then do;		/* finished with user bit string */
      256 			     ub_alloc = "0"b;
      257 			end;
      258 
      259 		end;				/* if encoding */
      260 
      261 	     else do;				/* if not encoding */
      262 
      263 		     if move_list.item.user_desc_ptr (i) -> bit36 ^= /* if must convert */
      264 			rm_domain_info.db_desc then do;
      265 
      266 			     allocate value_for_db in (work_area);
      267 
      268 			     value_for_db = "0"b;	/* clear space */
      269 
      270 			     call
      271 				mu_convert (move_list.item.user_ptr (i),
      272 				move_list.item.user_desc_ptr (i), db_val_ptr,
      273 				addr (rm_domain_info.db_desc), icode);
      274 			     if icode ^= 0 then
      275 				call error (icode);
      276 			end;			/* if converting */
      277 
      278 		     else /* if no conversion required */
      279 			db_val_ptr = move_list.item.user_ptr (i); /* point to user value as given */
      280 		end;				/* if not encoding */
      281 
      282 	     if rm_domain_info.ck_proc then do;		/* if there is domain integ. check proc. */
      283 
      284 		     check_list.val_ptr = db_val_ptr;	/* set up arg list */
      285 
      286 		     db_descriptor = rm_domain_info.db_desc; /* move descriptor into stack */
      287 		     check_list.vd_ptr = addr (db_descriptor); /* and pass to arg list */
      288 
      289 		     if check_list.vd_ptr -> descriptor.type = VAR_CHAR
      290 			| check_list.vd_ptr -> descriptor.type = VAR_BIT then
      291 			check_list.val_ptr =
      292 			     addr (check_list.val_ptr -> varying.string);
      293 
      294 		     accept_flag = 0;
      295 		     check_list.af_ptr = addr (accept_flag); /* move return val stuff into arg list */
      296 		     check_list.afd_ptr = addr (FB35_DESC);
      297 
      298 /* 81-05-06 Rickie E. Brinegar: Start changed code ************************* */
      299 
      300 		     call
      301 			cu_$generate_call (rm_domain_info.ck_proc_entry,
      302 			addr (check_list));		/* check_proc(val_for_db, accept_flag); */
      303 
      304 /* 81-05-06 Rickie E. Brinegar: End changed code *************************** */
      305 
      306 		     if accept_flag = 0 then /* was not acceptable */
      307 			call error (mdbm_error_$dom_integ);
      308 
      309 		     if check_list.vd_ptr -> descriptor.type = VAR_CHAR
      310 			/* move the pointer back to the length word */
      311 			| check_list.vd_ptr -> descriptor.type = VAR_BIT
      312 						/* this should be ok because varing */
      313 		     then check_list.val_ptr = addrel (check_list.val_ptr, -1);
      314 						/* strings aligned so no bit offset */
      315 		     call Check_out (check_list.vd_ptr, check_list.val_ptr, icode);
      316 						/* make sure no hanky-panky */
      317 		     if icode ^= 0 then
      318 			call error (icode);
      319 		end;				/* checking domain via proc. */
      320 
      321 /* When boolean integrity checking is implemented, it should be inserted here */
      322 
      323 
      324 	     if mod_flag then do;
      325 		     general_typed_vector.dimension (i).identifier =
      326 			rm_attr_info.model_defn_order;
      327 		     general_typed_vector.dimension (i).value_ptr =
      328 			db_val_ptr;
      329 		end;
      330 	     else simple_typed_vector.dimension (rm_attr_info.model_defn_order)
      331 		     .value_ptr = db_val_ptr;
      332 
      333 	end;					/* attribute value insertion loop */
      334 
      335 	code = 0;
      336 
      337 exit:
      338 	return;
      339 
      340 conversion_error:
      341 	;
      342 	code = mdbm_error_$conversion_condition;
      343 	go to exit;
      344 
      345 Check_out:
      346      procedure (user_desc_ptr, user_data_ptr, code);
      347 
      348 /* This procedure makes a few simple test to determine if data returned
      349*   from a user's encode/check procedure is what it claims to be.  Four checks
      350*   are made:
      351*   1) The descriptor is compared to the original descriptor.  A difference
      352*   is deemed to be the result of deliberate misrepresentation and cause an error
      353*   to be returned indicating an inconsistent database.
      354*   2) Decimal data is checked for validity.  If invalidly formatted decimal
      355*   data gets into the database, it can cause problems later.  Checking it now is
      356*   easy.
      357*   3) Varying strings are checked to make sure that they aren't too long.
      358*   4) Character data is verified to contain legitimate ascii data. */
      359 
      360 	dcl     (
      361 	        user_desc_ptr,			/* points to returned user_descriptor */
      362 	        user_data_ptr
      363 	        )			 ptr;		/* points to returned user data */
      364 	dcl     code		 fixed bin (35);	/* will be returned as non-zero if some problem with data */
      365 
      366 	dcl     (dtype, dprec)	 fixed bin;
      367 	dcl     (char_len, OK_char)	 fixed bin (21);
      368 	dcl     OK_dec		 bit (1);
      369 
      370 	dcl     var_char_str	 char (char_len) varying based;
      371 	dcl     char_str		 char (char_len) based;
      372 	dcl     length		 fixed bin (35) based unaligned;
      373 
      374 	dcl     1 arithmetic_desc	 aligned based,
      375 		2 fill		 bit (12) unaligned,
      376 		(
      377 		2 scale		 fixed bin (12),	/* for arithmetic data types */
      378 		2 precision	 fixed bin (12)
      379 		) /* size is divided into scale & precision */
      380 				 unsigned unaligned;
      381 
      382 	dcl     desc_overlay	 bit (36) based;	/* used for comparison purposes */
      383 
      384 	code = 0;					/* init */
      385 
      386 	if user_desc_ptr -> desc_overlay ^= rm_domain_info.db_desc then
      387 	     code = mdbm_error_$incons_db;		/* this is verboten */
      388 
      389 	else do;					/* user meant well, but double check anyway */
      390 		dtype = user_desc_ptr -> descriptor.type; /* get type into convenient location */
      391 
      392 		if (dtype >= FIXED_DEC & dtype <= CMPLX_FLT_DEC) /* standard decimal data types */
      393 		     | (dtype >= PACKED_FIXED_DEC & dtype <= PACKED_CMPLX_FLT_DEC)
      394 						/* packed decimal data types */
      395 		then do;				/* verify that it really is decimal data */
      396 			dprec = user_desc_ptr -> arithmetic_desc.precision;
      397 						/* get precision for call */
      398 			OK_dec = valid_decimal_ (dtype, user_data_ptr, dprec);
      399 						/* check it out */
      400 			if ^OK_dec then
      401 			     code = error_table_$improper_data_format; /* never make it */
      402 		     end;
      403 
      404 		else if dtype = VAR_BIT then do;	/* varying bit string */
      405 			if user_data_ptr -> length > rm_attr_info.bit_length then
      406 			     code = error_table_$improper_data_format; /* too long */
      407 		     end;
      408 
      409 		else if dtype = CHAR | dtype = VAR_CHAR then do; /* character string */
      410 			OK_char = 0;		/* assume the best */
      411 			if dtype = VAR_CHAR then do;	/* varying string */
      412 				char_len = user_data_ptr -> length; /* get length out of string */
      413 				if (char_len * 9) > rm_attr_info.bit_length then
      414 				     OK_char = 1;
      415 				else OK_char =
      416 					verify (user_data_ptr -> var_char_str, collate ());
      417 			     end;
      418 			else do;
      419 				char_len = user_desc_ptr -> descriptor.size;
      420 				OK_char = verify (user_data_ptr -> char_str, collate ());
      421 			     end;
      422 			if OK_char ^= 0 then
      423 			     code = error_table_$improper_data_format;
      424 		     end;
      425 	     end;
      426 
      427      end Check_out;
      428 
      429 error:
      430      proc (cd);
      431 
      432 /* Error procedure */
      433 
      434 	dcl     cd		 fixed bin (35);
      435 
      436 	code = cd;
      437 	go to exit;
      438 
      439      end error;
      440 
  1     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  1     2 
  1     3 /* WARNING
  1     4*          If the rm_rel_info structure is changed then the mrds_data_
  1     5*          item saved_res_version MUST be incremented to invalidate all
  1     6*          existing saved resultants
  1     7**/
  1     8 
  1     9 /* HISTORY:
  1    10*
  1    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  1    12*   attributes,   and   varying  attributes,  so  that  partial  view
  1    13*   submodels will have the  info  needed  to  properly  set  up  the
  1    14*   varying length array headers in the tuple structure.
  1    15*
  1    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  1    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  1    18*   delete_tuple_perm, and make m_perm = unused_perm.
  1    19*
  1    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  1    21*   view attribute was varying character or bit, since a partial view
  1    22*   submodel will not have this information in the resultant, and  it
  1    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  1    24*   since with exact length storage  of  varying  length  attributes,
  1    25*   each  tuple  can  be  a  different  length,  which is can only be
  1    26*   determined by examining the tuple itself.
  1    27*
  1    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  1    29*   interface  to  allow  temp  rel  population  to  be known, and to
  1    30*   provide a more efficient means of finding an approx. current perm
  1    31*   relation population.
  1    32*
  1    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  1    34*   blocked  files, foreign keys, and ids procedures. Also set number
  1    35*   of files per rel to a constant of 1.
  1    36*
  1    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  1    38*   structure so that only one structure per relation is needed.
  1    39*
  1    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  1    41*   counts.   Also  added  number  of  operations  count  since  last
  1    42*   statistics update, and a time  since  the  statistics  were  last
  1    43*   updated.
  1    44*
  1    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  1    46*   identifier so that small relations could be updated on a per S.E.
  1    47*   basis
  1    48*
  1    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  1    50*   to end of structure   TR 12205 (Suggestion).
  1    51*   
  1    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  1    53*   the DMS conversion. 
  1    54*
  1    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  1    56*   array and the niocb element for DMS conversion. Also removed the
  1    57*   number_selected array (and ri_niocbs_init) since subsets are not
  1    58*   going to be used.
  1    59*
  1    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  1    61*   so that it can be used with relation manager.  Also added
  1    62*   rm_rel_info.primary_key_index_id for relation manager.
  1    63*
  1    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  1    65*   nvar_atts, model_nvar_atts.
  1    66*
  1    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  1    68*   since the duplicate key count for each secondary index is now being
  1    69*   kept in the attr_info structure and key_count was only needed to
  1    70*   help in calculating the average selectivity of each index which
  1    71*   can now be gotten directly from each index's dup key count. Also
  1    72*   removed the file_id element since it is no longer needed for
  1    73*   anything.
  1    74*
  1    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  1    76*   was removed.
  1    77*
  1    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  1    79*   used when retrieving tuples from this relation.
  1    80*
  1    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  1    82*   for the relation. Note that this structure is part of the resultant NOT
  1    83*   part of the db.control structure. The scopes are duplicated in the resultant
  1    84*   to reduce contention for the db.control structure. Note also that the pointer
  1    85*   will always point to a scope_flags structure even if no scopes have been
  1    86*   set on the relation, the structure is allocated when the db is opened.
  1    87**/
  1    88 
  1    89 
  1    90 /* DESCRIPTION:
  1    91*
  1    92*   This structure is allocated in the area part of the structure  in
  1    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  1    94*   at open  time  for  a  database.  There  will  be  one  of  these
  1    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  1    96*   database view (there may be less than the total in  the  database
  1    97*   for  a  submodel  openings).  There  will  also  be  one for each
  1    98*   temporary relation currently defined for that opening.
  1    99*
  1   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  1   101*   all  rm_rel_info  structures  allocated. It is used for searching
  1   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  1   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  1   104*   rels.
  1   105*
  1   106*   The      rm_rel_info      structure      points      to       the
  1   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  1   108*   appearing in this view of the relation. Each  of  these  in  turn
  1   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  1   110*   info for each attr.
  1   111*
  1   112*   Most of the other information here deals with  specifics  of  the
  1   113*   relation's  logical  definition,  such as key and secondary index
  1   114*   attribute inidicators, security permissions, and  tuple  physical
  1   115*   construction details.
  1   116*
  1   117**/
  1   118 
  1   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  1   120 	     2 name	      char (32),		/* from submodel */
  1   121 	     2 model_name	      char (30),		/* from model */
  1   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  1   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  1   124 	     2 modify	      bit (1) unal,
  1   125 	     2 delete	      bit (1) unal,
  1   126 	     2 store	      bit (1) unal,
  1   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  1   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  1   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  1   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  1   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  1   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  1   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  1   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  1   135 	     2 reserved	      bit (24) unal,	/* for future use */
  1   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  1   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  1   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  1   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  1   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  1   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  1   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  1   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  1   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  1   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  1   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  1   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  1   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  1   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  1   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  1   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  1   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  1   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  1   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  1   155 
  1   156      dcl	   rmri_ptr	      ptr;
  1   157      dcl	   (nkey_attr_init,
  1   158 	   natts_init,
  1   159 	   nvar_atts_init)	      fixed bin;
  1   160 
  1   161 /* END mdbm_rm_rel_info.incl.pl1 */
  1   162 
  1   163 
      441 
      442 
  2     1 /* BEGIN mdbm_rm_domain_info.incl.pl1 -- jaw, 9/26/78 */
  2     2 
  2     3 /* WARNING
  2     4*          If the rm_domain_info structure is changed then the mrds_data_
  2     5*          item saved_res_version MUST be incremented to invalidate all
  2     6*          existing saved resultants
  2     7**/
  2     8 
  2     9 /* DESCRIPTION:
  2    10*
  2    11*   This  structure  is  allocated  in  the  mdbm_rm_db_info.incl.pl1
  2    12*   static  area,  once per attribute used in a relation in a readied
  2    13*   file. it is pointed to by the mdbm_rm_attr_info.incl.pl1, and may
  2    14*   point  to  mdbm_rm_ck_and_group.incl.pl1  if  a  "-check"  option
  2    15*   boolean expression was declared for this domain. it contains  the
  2    16*   descriptor  for  this domain data type, and other resultant model
  2    17*   information.
  2    18*
  2    19*
  2    20*   HISTORY:
  2    21*
  2    22*   81-05-06  Rickie  E.  Brinegar:  Modified  ck_proc,  encode_proc,
  2    23*   decode_proc to be entry variables instead of entry pointers. This
  2    24*   allows these programs to be written in languages other than pl1.
  2    25*
  2    26*   81-05-28 Jim Gray : removed unused procedure points,  and  unused
  2    27*   check  stack  structure  elements.  Also made the descriptors bit
  2    28*   (36) in this structure, rather than pointers to  the  descriptors
  2    29*   elsewhere.  Also  removed un-needed redundant assign_ parameters,
  2    30*   that are actually available in the descriptors.
  2    31*
  2    32*
  2    33**/
  2    34 
  2    35 dcl 1 rm_domain_info aligned based (rdi_ptr),		/* domain information */
  2    36     2 name char (32),				/* domain name */
  2    37     2 db_desc bit (36),				/*  to desc. for db. */
  2    38     2 user_desc bit (36),				/* desc for user visible data */
  2    39     2 user_bit_len fixed bin,				/* storage length of users data */
  2    40     2 ck_proc_entry entry variable,			/* to check proc. entry */
  2    41     2 encd_proc_entry entry variable,			/* to encode proc entry */
  2    42     2 decd_proc_entry entry variable,			/* to decode proc entry */
  2    43     2 ck_proc bit (1) unal,				/* Is there a check proc */
  2    44     2 encd_proc bit (1) unal,				/* Is there an encode proc */
  2    45     2 decd_proc bit (1) unal,				/* Is there a decode proc */
  2    46     2 pad bit (33) unal,
  2    47     2 next_domain_ptr ptr ;				/* to next domain, in list of all domains */
  2    48 						/* to check stack and groups */
  2    49 
  2    50 
  2    51 dcl  rdi_ptr ptr int automatic init (null ());
  2    52 
  2    53 /* END mdbm_rm_domain_info.incl.pl1 */
  2    54 
  2    55 
      443 
      444 
  3     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
  3     2 
  3     3 /* WARNING
  3     4*          If the rm_attr_info structure is changed then the mrds_data_
  3     5*          item saved_res_version MUST be incremented to invalidate all
  3     6*          existing saved resultants
  3     7**/
  3     8 
  3     9 /*
  3    10*
  3    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
  3    12*   that rm_rel_info does not have to be checked
  3    13*
  3    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  3    15*   foreign keys.
  3    16*
  3    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
  3    18*   conversion.
  3    19*
  3    20*   82-09-15 Davids: added the number_of_dups field.
  3    21*
  3    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
  3    23*   aligned.  This is to conform with the new definition in the database
  3    24*   model.  Also removed the now useless field varying.
  3    25*
  3    26*   82-11-05 Davids: added the field model_defn_order and clarified the
  3    27*   comment for the field defn_order.
  3    28*
  3    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
  3    30*   that's what relation manager returns.
  3    31*
  3    32**/
  3    33 
  3    34 
  3    35 /*
  3    36*   this   structure   is   allocated   in   the   static   area   of
  3    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
  3    38*   a     readied     file.      it     in     turn     points     to
  3    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
  3    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
  3    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
  3    42*   position  within  a  tuple as stored in the data file are kept in
  3    43*   this resultant model of the attribute.
  3    44* */
  3    45 
  3    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
  3    47     2 name char (32),				/* from submodel */
  3    48     2 model_name char (32),				/* from model */
  3    49     2 key_attr bit (1) unal,				/* if key attribute */
  3    50     2 index_attr bit (1) unal,			/* if secondary index */
  3    51     2 read_perm bit (1) unal,				/* user has retr. permission */
  3    52     2 modify_perm bit (1) unal,			/* user has modify permission */
  3    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
  3    54     2 reserved bit (30) unal,				/* for future use */
  3    55     2 index_id bit (36) aligned,			/* index id if index_attr */
  3    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
  3    57     2 key_order fixed bin,				/* relative order defined in prim. key */
  3    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
  3    59     2 domain_ptr ptr,				/* to domain info */
  3    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
  3    61*                                                               be the number of duplicate values, exact
  3    62*                                                               for a page_file database, an estimate for a vfile type */
  3    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
  3    64 
  3    65 dcl  rai_ptr ptr int automatic init (null ());
  3    66 
  3    67 /* END mdbm_rm_attr_info.incl.pl1 */
  3    68 
  3    69 
      445 
      446 
  4     1 /* BEGIN mdbm_move_list.incl.pl1 -- jaw, 7/13/78 */
  4     2 
  4     3 /* HISTORY:
  4     4*
  4     5*   81-06-01 Jim Gray : removed assn type and len elements,
  4     6*   now that mu_convert is used.
  4     7*
  4     8**/
  4     9 
  4    10 
  4    11 dcl 1 move_list aligned based (ml_ptr),			/* info for moving data in and out of tuple */
  4    12     2 nitems fixed bin,				/* number of items */
  4    13     2 item (ml_nitems_init refer (move_list.nitems)),
  4    14       3 attr_index fixed bin,				/* index to attr info in rel_info */
  4    15       3 user_ptr ptr,				/* pointer to user data value */
  4    16       3 user_desc_ptr ptr;				/* pointer to descriptor for user */
  4    17 
  4    18 dcl  ml_ptr ptr;
  4    19 dcl  ml_nitems_init fixed bin;
  4    20 
  4    21 /* END mdbm_move_list.incl.pl1 */
  4    22 
      447 
      448 
  5     1 /* ***********************************************************
  5     2*   *                                                         *
  5     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  5     4*   *                                                         *
  5     5*   *********************************************************** */
  5     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  5     7 
  5     8 /* Written by Lindsey Spratt, 04/02/82.
  5     9*Modified:
  5    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  5    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  5    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  5    13*	  type.
  5    14**/
  5    15 
  5    16 /* format: style2,ind3 */
  5    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  5    18 	     2 type	      fixed bin (17) unal,
  5    19 	     2 number_of_dimensions
  5    20 			      fixed bin (17) unal,
  5    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  5    22 	       3 value_ptr	      ptr unaligned;
  5    23 
  5    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  5    25 	     2 type	      fixed bin (17) unal,
  5    26 	     2 number_of_dimensions
  5    27 			      fixed bin (17) unal,
  5    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  5    29 	       3 identifier	      fixed bin (17) unal,
  5    30 	       3 pad	      bit (18) unal,
  5    31 	       3 value_ptr	      ptr unal;
  5    32 
  5    33      dcl	   simple_typed_vector_ptr
  5    34 			      ptr;
  5    35      dcl	   stv_number_of_dimensions
  5    36 			      fixed bin (17);
  5    37 
  5    38      dcl	   general_typed_vector_ptr
  5    39 			      ptr;
  5    40      dcl	   gtv_number_of_dimensions
  5    41 			      fixed bin (17);
  5    42 
  5    43      dcl	   (
  5    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  5    45 			      init (1),		/* value_ptr was aligned. */
  5    46 	   GENERAL_TYPED_VECTOR_TYPE
  5    47 			      init (2),
  5    48 	   SIMPLE_TYPED_VECTOR_TYPE
  5    49 			      init (3)
  5    50 	   )		      fixed bin (17) internal static options (constant);
  5    51 
  5    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      449 
      450 
      451 	dcl     (
      452 	        wa_ptr,				/* pointer to work area */
      453 	        db_val_ptr,				/* pointer to converted value, ready for tuple */
      454 	        vector_ptr,				/* pointer to vector */
      455 	        user_val_ptr
      456 	        )			 ptr;		/* pointer to converted value, prior to encoding */
      457 	dcl     wksp		 (33) fixed bin (71);
      458 
      459 	dcl     (
      460 	        mod_flag,				/* Input: on indicats modify rather than store */
      461 	        ub_alloc
      462 	        )			 bit (1) aligned;
      463 
      464 	dcl     i			 fixed bin;	/* internal indexes */
      465 
      466 	dcl     (
      467 	        code,				/* Output: status code */
      468 	        icode				/* internal status code */
      469 	        )			 fixed bin (35);
      470 
      471 	dcl     accept_flag		 fixed bin (35);
      472 	dcl     db_descriptor	 bit (36) aligned;	/* temporary for database definition descriptor */
      473 	dcl     user_descriptor	 bit (36) aligned;	/* temprorary for user proc descriptor */
      474 
      475 	dcl     work_area		 area (sys_info$max_seg_size) based (wa_ptr); /* working area */
      476 	dcl     value_for_db	 bit (rm_attr_info.bit_length) based (db_val_ptr);
      477 						/* converted value, ready for tuple */
      478 	dcl     value_for_user	 bit (rm_domain_info.user_bit_len) based (user_val_ptr);
      479 						/* converted val., ready for encoding */
      480 	dcl     bit36		 bit (36) based;	/* templates */
      481 	dcl     1 varying		 based unaligned,	/* description of varying string - used for arg list building */
      482 		2 length		 fixed bin (35),	/* length portion of varying string */
      483 		2 string		 char (0);	/* string portion of varying string */
      484 
      485 	dcl     1 descriptor	 aligned based,
      486 	        (
      487 		2 flag		 bit (1),
      488 		2 type		 fixed bin (6) unsigned, /* data type */
      489 		2 packed		 bit (1),		/* ON = unaligned */
      490 		2 number_dims	 fixed bin (4) unsigned, /* non-zero for arrays */
      491 		2 size		 fixed bin (24) unsigned
      492 		)		 unaligned,	/* size of data */
      493 		2 array_info	 (0 refer (descriptor.number_dims)),
      494 		  3 lower_bound	 fixed bin (35),
      495 		  3 upper_bound	 fixed bin (35),
      496 		  3 multiplier	 fixed bin (35);
      497 
      498 	dcl     1 encode_list	 aligned,		/* arg list for encode proc. */
      499 		2 nargs		 fixed bin (17) unal init (6),
      500 		2 code		 fixed bin (17) unal init (4),
      501 		2 ndescs		 fixed bin (17) unal init (6),
      502 		2 pad		 fixed bin (17) unal init (0),
      503 		2 uv_ptr		 ptr,
      504 		2 dbv_ptr		 ptr,
      505 		2 code_ptr	 ptr,
      506 		2 ud_ptr		 ptr,
      507 		2 dbd_ptr		 ptr,
      508 		2 coded_ptr	 ptr;
      509 
      510 	dcl     1 check_list	 aligned,		/* arg list for integ. check proc. */
      511 		2 nargs		 fixed bin (17) unal init (4),
      512 		2 code		 fixed bin (17) unal init (4),
      513 		2 ndescs		 fixed bin (17) unal init (4),
      514 		2 pad		 fixed bin (17) unal init (0),
      515 		2 val_ptr		 ptr,
      516 		2 af_ptr		 ptr,
      517 		2 vd_ptr		 ptr,
      518 		2 afd_ptr		 ptr;
      519 
      520 	dcl     FB35_DESC		 bit (36) aligned int static options (constant)
      521 				 init ("100000100000000000000000000000100011"b);
      522 	dcl /* interesting data types */
      523 	        (
      524 	        FIXED_DEC		 init (9),
      525 	        CMPLX_FLT_DEC	 init (12),
      526 	        VAR_BIT		 init (20),
      527 	        CHAR		 init (21),
      528 	        VAR_CHAR		 init (22),
      529 	        PACKED_FIXED_DEC	 init (41),
      530 	        PACKED_CMPLX_FLT_DEC	 init (46)
      531 	        )			 unsigned binary (6) static options (constant);
      532 
      533 	dcl     (
      534 	        sys_info$max_seg_size,
      535 	        mdbm_error_$dom_integ
      536 	        )			 ext fixed bin (35);
      537 	dcl     mdbm_error_$incons_db	 external fixed bin (35);
      538 	dcl     error_table_$improper_data_format external fixed bin (35);
      539 	dcl     mdbm_error_$conversion_condition ext fixed bin (35);
      540 
      541 	dcl     conversion		 condition;
      542 
      543 	dcl     (addr, addrel, collate, verify, null) builtin;
      544 
      545 	dcl     mu_convert		 entry (ptr, ptr, ptr, ptr, fixed bin (35));
      546 	dcl     cu_$generate_call	 entry (entry, ptr);
      547 	dcl     valid_decimal_	 entry (fixed bin, ptr, fixed bin) returns (bit (1));
      548 	declare area_ptr		 ptr;
      549      end mu_build_tuple;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/85  0908.0  mu_build_tuple.pl1                >special_ldd>online>mrds.pbf-04/18/85>mu_build_tuple.pl1
441          1    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
443          2    10/14/83  1609.1  mdbm_rm_domain_info.incl.pl1      >ldd>include>mdbm_rm_domain_info.incl.pl1
445          3    10/14/83  1609.1  mdbm_rm_attr_info.incl.pl1        >ldd>include>mdbm_rm_attr_info.incl.pl1
447          4    10/14/83  1608.9  mdbm_move_list.incl.pl1           >ldd>include>mdbm_move_list.incl.pl1
449          5    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CHAR                                   constant        fixed bin(6,0)           initial unsigned dcl 522 ref 409
CMPLX_FLT_DEC                          constant        fixed bin(6,0)           initial unsigned dcl 522 ref 392
FB35_DESC                       000001 constant        bit(36)                  initial dcl 520 set ref 230 296
FIXED_DEC                              constant        fixed bin(6,0)           initial unsigned dcl 522 ref 392
GENERAL_TYPED_VECTOR_TYPE              constant        fixed bin(17,0)          initial dcl 5-43 ref 166
OK_char                         000277 automatic       fixed bin(21,0)          dcl 367 set ref 410* 413* 415* 420* 422
OK_dec                          000300 automatic       bit(1)                   unaligned dcl 368 set ref 398* 400
PACKED_CMPLX_FLT_DEC                   constant        fixed bin(6,0)           initial unsigned dcl 522 ref 392
PACKED_FIXED_DEC                       constant        fixed bin(6,0)           initial unsigned dcl 522 ref 392
SIMPLE_TYPED_VECTOR_TYPE               constant        fixed bin(17,0)          initial dcl 5-43 ref 171
VAR_BIT                                constant        fixed bin(6,0)           initial unsigned dcl 522 ref 213 224 243 289 309 404
VAR_CHAR                               constant        fixed bin(6,0)           initial unsigned dcl 522 ref 213 224 243 289 309 409
                                                                                  411
accept_flag                     000223 automatic       fixed bin(35,0)          dcl 471 set ref 294* 295 306
addr                                                   builtin function         dcl 543 ref 194 198 198 211 213 222 224 229 230 234
                                                                                  234 270 270 287 289 295 296 300 300
addrel                                                 builtin function         dcl 543 ref 243 309
af_ptr                    4     000244 automatic       pointer                  level 2 dcl 510 set ref 295*
afd_ptr                  10     000244 automatic       pointer                  level 2 dcl 510 set ref 296*
area_ptr                               parameter       pointer                  dcl 548 ref 20 159
arithmetic_desc                        based           structure                level 1 dcl 374
attr_index                2            based           fixed bin(17,0)          array level 3 dcl 4-11 ref 177
attr_ptrs                              based           pointer                  array level 2 dcl 1-119 ref 177
bit36                                  based           bit(36)                  unaligned dcl 480 ref 186 263
bit_length               24            based           fixed bin(35,0)          level 2 dcl 3-46 ref 182 182 184 266 266 268 405 413
cd                                     parameter       fixed bin(35,0)          dcl 434 ref 429 436
char_len                        000276 automatic       fixed bin(21,0)          dcl 367 set ref 412* 413 419* 420
char_str                               based           char                     unaligned dcl 371 ref 420
check_list                      000244 automatic       structure                level 1 dcl 510 set ref 300 300
ck_proc                  30            based           bit(1)                   level 2 packed unaligned dcl 2-35 ref 282
ck_proc_entry            14            based           entry variable           level 2 dcl 2-35 set ref 300*
code                                   parameter       fixed bin(35,0)          dcl 466 in procedure "mu_build_tuple" set ref 20
                                                                                  335* 342* 436*
code                      0(18) 000244 automatic       fixed bin(17,0)          initial level 2 in structure "check_list" packed
                                                                                  unaligned dcl 510 in procedure "mu_build_tuple"
                                                                                  set ref 510*
code                      0(18) 000226 automatic       fixed bin(17,0)          initial level 2 in structure "encode_list" packed
                                                                                  unaligned dcl 498 in procedure "mu_build_tuple"
                                                                                  set ref 498*
code                                   parameter       fixed bin(35,0)          dcl 364 in procedure "Check_out" set ref 345 384*
                                                                                  386* 400* 405* 422*
code_ptr                  6     000226 automatic       pointer                  level 2 dcl 498 set ref 229*
coded_ptr                14     000226 automatic       pointer                  level 2 dcl 498 set ref 230*
collate                                                builtin function         dcl 543 ref 415 420
conversion                      000256 stack reference condition                dcl 541 ref 162
cu_$generate_call               000022 constant        entry                    external dcl 546 ref 234 300
db_desc                  10            based           bit(36)                  level 2 dcl 2-35 set ref 221 263 270 270 286 386
db_descriptor                   000224 automatic       bit(36)                  dcl 472 set ref 221* 222 286* 287
db_val_ptr                      000112 automatic       pointer                  dcl 451 set ref 182* 184 220 266* 268 270* 278* 284
                                                                                  327 330
dbd_ptr                  12     000226 automatic       pointer                  level 2 dcl 498 set ref 222* 224 224 243 243 250*
dbv_ptr                   4     000226 automatic       pointer                  level 2 dcl 498 set ref 220* 224* 224 243* 243 250*
desc_overlay                           based           bit(36)                  unaligned dcl 382 ref 386
descriptor                             based           structure                level 1 dcl 485
dimension                 1            based           structure                array level 2 in structure "simple_typed_vector"
                                                                                  packed unaligned dcl 5-17 in procedure
                                                                                  "mu_build_tuple"
dimension                 1            based           structure                array level 2 in structure "general_typed_vector"
                                                                                  packed unaligned dcl 5-24 in procedure
                                                                                  "mu_build_tuple"
domain_ptr               26            based           pointer                  level 2 dcl 3-46 ref 179
dprec                           000275 automatic       fixed bin(17,0)          dcl 366 set ref 396* 398*
dtype                           000274 automatic       fixed bin(17,0)          dcl 366 set ref 390* 392 392 392 392 398* 404 409
                                                                                  409 411
encd_proc                30(01)        based           bit(1)                   level 2 packed unaligned dcl 2-35 ref 181
encd_proc_entry          20            based           entry variable           level 2 dcl 2-35 set ref 234*
encode_list                     000226 automatic       structure                level 1 dcl 498 set ref 234 234
error_table_$improper_data_format
                                000014 external static fixed bin(35,0)          dcl 538 ref 400 405 422
general_typed_vector                   based           structure                level 1 packed unaligned dcl 5-24
general_typed_vector_ptr        000106 automatic       pointer                  dcl 5-38 set ref 165* 166 167 325 327
i                               000221 automatic       fixed bin(17,0)          dcl 464 set ref 175* 177 186 198 198 207 263 270 270
                                                                                  278 325 327*
icode                           000222 automatic       fixed bin(35,0)          dcl 466 set ref 160* 198* 202 202* 229 240 240* 250*
                                                                                  252 252* 270* 274 274* 315* 317 317*
identifier                1            based           fixed bin(17,0)          array level 3 packed unaligned dcl 5-24 set ref 325*
item                      2            based           structure                array level 2 dcl 4-11
length                                 based           fixed bin(35,0)          unaligned dcl 372 ref 405 412
mdbm_error_$conversion_condition
                                000016 external static fixed bin(35,0)          dcl 539 ref 342
mdbm_error_$dom_integ           000010 external static fixed bin(35,0)          dcl 533 set ref 306*
mdbm_error_$incons_db           000012 external static fixed bin(35,0)          dcl 537 ref 386
ml_ptr                                 parameter       pointer                  dcl 4-18 ref 20 167 172 175 177 186 198 198 207 263
                                                                                  270 270 278
mod_flag                               parameter       bit(1)                   dcl 459 ref 20 164 324
model_defn_order         31            based           fixed bin(17,0)          level 2 dcl 3-46 ref 325 330
move_list                              based           structure                level 1 dcl 4-11
mu_convert                      000020 constant        entry                    external dcl 545 ref 198 270
nargs                           000244 automatic       fixed bin(17,0)          initial level 2 in structure "check_list" packed
                                                                                  unaligned dcl 510 in procedure "mu_build_tuple"
                                                                                  set ref 510*
nargs                           000226 automatic       fixed bin(17,0)          initial level 2 in structure "encode_list" packed
                                                                                  unaligned dcl 498 in procedure "mu_build_tuple"
                                                                                  set ref 498*
ndescs                    1     000244 automatic       fixed bin(17,0)          initial level 2 in structure "check_list" packed
                                                                                  unaligned dcl 510 in procedure "mu_build_tuple"
                                                                                  set ref 510*
ndescs                    1     000226 automatic       fixed bin(17,0)          initial level 2 in structure "encode_list" packed
                                                                                  unaligned dcl 498 in procedure "mu_build_tuple"
                                                                                  set ref 498*
nitems                                 based           fixed bin(17,0)          level 2 dcl 4-11 ref 167 172 175
nkey_attr                24            based           fixed bin(17,0)          level 2 dcl 1-119 ref 177
null                                                   builtin function         dcl 543 ref 2-51 3-65
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  unaligned dcl 5-17 in procedure "mu_build_tuple"
                                                                                  set ref 172*
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "general_typed_vector" packed
                                                                                  unaligned dcl 5-24 in procedure "mu_build_tuple"
                                                                                  set ref 167*
pad                       1(18) 000226 automatic       fixed bin(17,0)          initial level 2 in structure "encode_list" packed
                                                                                  unaligned dcl 498 in procedure "mu_build_tuple"
                                                                                  set ref 498*
pad                       1(18) 000244 automatic       fixed bin(17,0)          initial level 2 in structure "check_list" packed
                                                                                  unaligned dcl 510 in procedure "mu_build_tuple"
                                                                                  set ref 510*
precision                 0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 374 ref 396
rai_ptr                         000102 automatic       pointer                  initial dcl 3-65 set ref 177* 179 182 182 184 266
                                                                                  266 268 325 330 3-65* 405 413
rdi_ptr                         000100 automatic       pointer                  initial dcl 2-51 set ref 179* 181 186 189 191 191
                                                                                  196 198 198 210 221 234 263 270 270 282 286 300
                                                                                  2-51* 386
rm_attr_info                           based           structure                level 1 dcl 3-46
rm_domain_info                         based           structure                level 1 dcl 2-35
rm_rel_info                            based           structure                level 1 dcl 1-119
rmri_ptr                               parameter       pointer                  dcl 1-156 ref 20 177
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 5-17
simple_typed_vector_ptr         000104 automatic       pointer                  dcl 5-33 set ref 170* 171 172 330
size                      0(12)        based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 485 ref 419
string                    1            based           char                     level 2 packed unaligned dcl 481 set ref 213 224 289
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "descriptor" packed unsigned
                                                                                  unaligned dcl 485 in procedure "mu_build_tuple"
                                                                                  ref 213 213 224 224 243 243 289 289 309 309 390
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  unaligned dcl 5-17 in procedure "mu_build_tuple"
                                                                                  set ref 171*
type                                   based           fixed bin(17,0)          level 2 in structure "general_typed_vector" packed
                                                                                  unaligned dcl 5-24 in procedure "mu_build_tuple"
                                                                                  set ref 166*
ub_alloc                        000220 automatic       bit(1)                   dcl 459 set ref 161* 192* 255 256*
ud_ptr                   10     000226 automatic       pointer                  level 2 dcl 498 set ref 211* 213 213
user_bit_len             12            based           fixed bin(17,0)          level 2 dcl 2-35 ref 189 191 191 196
user_data_ptr                          parameter       pointer                  dcl 360 set ref 345 398* 405 412 415 420
user_desc                11            based           bit(36)                  level 2 dcl 2-35 set ref 186 198 198 210
user_desc_ptr             6            based           pointer                  array level 3 in structure "move_list" dcl 4-11
                                                                                  in procedure "mu_build_tuple" set ref 186 198* 263
                                                                                  270*
user_desc_ptr                          parameter       pointer                  dcl 360 in procedure "Check_out" ref 345 386 390 396
                                                                                  419
user_descriptor                 000225 automatic       bit(36)                  dcl 473 set ref 210* 211
user_ptr                  4            based           pointer                  array level 3 dcl 4-11 set ref 198* 207 270* 278
user_val_ptr                    000114 automatic       pointer                  dcl 451 set ref 191* 194* 196 198* 205
uv_ptr                    2     000226 automatic       pointer                  level 2 dcl 498 set ref 205* 207* 213* 213
val_ptr                   2     000244 automatic       pointer                  level 2 dcl 510 set ref 284* 289* 289 309* 309 315*
valid_decimal_                  000024 constant        entry                    external dcl 547 ref 398
value_for_db                           based           bit                      unaligned dcl 476 set ref 182 184* 266 268*
value_for_user                         based           bit                      unaligned dcl 478 set ref 191 196*
value_ptr                 1            based           pointer                  array level 3 in structure "simple_typed_vector"
                                                                                  packed unaligned dcl 5-17 in procedure
                                                                                  "mu_build_tuple" set ref 330*
value_ptr                 2            based           pointer                  array level 3 in structure "general_typed_vector"
                                                                                  packed unaligned dcl 5-24 in procedure
                                                                                  "mu_build_tuple" set ref 327*
var_char_str                           based           varying char             dcl 370 ref 415
varying                                based           structure                level 1 packed unaligned dcl 481
vd_ptr                    6     000244 automatic       pointer                  level 2 dcl 510 set ref 287* 289 289 309 309 315*
vector_ptr                             parameter       pointer                  dcl 451 ref 20 165 170
verify                                                 builtin function         dcl 543 ref 415 420
wa_ptr                          000110 automatic       pointer                  dcl 451 set ref 159* 182 191 266
wksp                            000116 automatic       fixed bin(71,0)          array dcl 457 set ref 194
work_area                              based           area                     dcl 475 ref 182 191 266

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 5-43
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 5-40
ml_nitems_init                         automatic       fixed bin(17,0)          dcl 4-19
natts_init                             automatic       fixed bin(17,0)          dcl 1-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 1-157
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 1-157
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 5-35
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 533

NAMES DECLARED BY EXPLICIT CONTEXT.
Check_out                       000712 constant        entry                    internal dcl 345 ref 250 315
conversion_error                000704 constant        label                    dcl 340 set ref 162
error                           001103 constant        entry                    internal dcl 429 ref 202 240 252 274 306 317
exit                            000703 constant        label                    dcl 337 set ref 343 437
mu_build_tuple                  000057 constant        entry                    external dcl 20

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1466        1514    1340        1476
Length      2010    1340        26         257     126           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mu_build_tuple                      226 external procedure  is an external procedure.  
on unit on line 162                  64 on unit               
Check_out                               internal procedure  shares stack frame of external procedure mu_build_tuple.  
error                                   internal procedure  shares stack frame of external procedure mu_build_tuple.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mu_build_tuple           000100 rdi_ptr                     mu_build_tuple
                         000102 rai_ptr                     mu_build_tuple
                         000104 simple_typed_vector_ptr     mu_build_tuple
                         000106 general_typed_vector_ptr    mu_build_tuple
                         000110 wa_ptr                      mu_build_tuple
                         000112 db_val_ptr                  mu_build_tuple
                         000114 user_val_ptr                mu_build_tuple
                         000116 wksp                        mu_build_tuple
                         000220 ub_alloc                    mu_build_tuple
                         000221 i                           mu_build_tuple
                         000222 icode                       mu_build_tuple
                         000223 accept_flag                 mu_build_tuple
                         000224 db_descriptor               mu_build_tuple
                         000225 user_descriptor             mu_build_tuple
                         000226 encode_list                 mu_build_tuple
                         000244 check_list                  mu_build_tuple
                         000274 dtype                       Check_out
                         000275 dprec                       Check_out
                         000276 char_len                    Check_out
                         000277 OK_char                     Check_out
                         000300 OK_dec                      Check_out

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              tra_ext             enable              ext_entry           int_entry
alloc_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$generate_call             mu_convert                    valid_decimal_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$improper_data_format                           mdbm_error_$conversion_condition
mdbm_error_$dom_integ         mdbm_error_$incons_db




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000051    2   51 000064    3   65 000066       498 000067       510 000077       159 000107       160 000113
    161 000114       162 000115       164 000134       165 000140       166 000143       167 000146       168 000155
    170 000156       171 000161       172 000164       175 000173       177 000203       179 000223       181 000225
    182 000230       184 000240       186 000245       189 000261       191 000264       192 000274       193 000276
    194 000277       196 000301       198 000307       202 000335       205 000341       206 000343       207 000344
    210 000347       211 000352       213 000354       220 000367       221 000371       222 000373       224 000375
    229 000410       230 000412       234 000414       240 000427       243 000433       250 000446       252 000450
    255 000454       256 000456       259 000457       263 000460       266 000466       268 000476       270 000503
    274 000532       276 000536       278 000537       282 000541       284 000545       286 000547       287 000551
    289 000553       294 000566       295 000567       296 000571       300 000573       306 000606       309 000617
    315 000632       317 000634       324 000640       325 000644       327 000660       329 000666       330 000667
    333 000677       335 000701       337 000703       340 000704       342 000705       343 000711       345 000712
    384 000714       386 000715       390 000730       392 000734       396 000744       398 000747       400 000765
    402 000774       404 000775       405 000777       407 001014       409 001015       410 001021       411 001022
    412 001024       413 001034       415 001043       417 001056       419 001057       420 001062       422 001076
    427 001102       429 001103       436 001105       437 001110


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
