	COMPILATION LISTING OF SEGMENT ext_link_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/20/86  1219.5 mst Thu
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1978 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        * Copyright (c) 1972 by Massachusetts Institute of        *
        9*        * Technology and Honeywell Information Systems, Inc.      *
       10*        *                                                         *
       11*        *********************************************************** */
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
       17*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
       18*     Improved documentation, changed errname to use the caller-supplied name
       19*     instead of "binder_", and modified to store relocation address in the
       20*     link_regeneration_table and just return relocated address on subsequent
       21*     references.
       22*                                                   END HISTORY COMMENTS */
       23 
       24 /**********************************************************************/
       25 /*							*/
       26 /*	Name:	ext_link_					*/
       27 /*	Input:	argument_pointer				*/
       28 /*	Function:	given an external_ref structure (pointed to by	*/
       29 /*		argument_pointer) defining a link in the current	*/
       30 /*		input component, create a corresponding external	*/
       31 /*		link in the new object segments linkage section.	*/
       32 /*	Output:	none.					*/
       33 /*							*/
       34 /*	Notes:	External links are created by the following	*/
       35 /*		process:					*/
       36 /*		  - if the link is type-6 or *system, then find	*/
       37 /*		    or create an init_map entry matching the	*/
       38 /*		    initialization info for the link.		*/
       39 /*		  - if the link is a trap-before-call link, then	*/
       40 /*		    recursively generate the trap link, and the	*/
       41 /*		    arg_link (if present)			*/
       42 /*		  - try to find the segname, and entryname in the	*/
       43 /*		    stringmap				*/
       44 /*		  - scan the link_map for another link to the	*/
       45 /*		    target.				*/
       46 /*		  - if the link is a type-6 or *system link, and	*/
       47 /*		    the init-info does not match then we must	*/
       48 /*		    select one of the init info's or combine them	*/
       49 /*		    The following algorithm is used to select	*/
       50 /*		    the initialization info:			*/
       51 /*		     If one links has an area initialization	*/
       52 /*		     and the other does not, then abort with a	*/
       53 /*		     fatal error.  This cannot be resolved.	*/
       54 /*							*/
       55 /*		     Initializations same size		*/
       56 /*							*/
       57 /*		     no new initialization			*/
       58 /*		     1 was init before	use old		*/
       59 /*		     2 was not init before	use old		*/
       60 /*							*/
       61 /*		     new initialization			*/
       62 /*		     3 was init before	use old; print msg	*/
       63 /*		     4 was not init before	use new		*/
       64 /*							*/
       65 /*		     New initialization smaller		*/
       66 /*							*/
       67 /*		     no new initialization			*/
       68 /*		     5 was init before	use old		*/
       69 /*		     6 was not init before	use old		*/
       70 /*							*/
       71 /*		     new initialization			*/
       72 /*		     7 was init before	use old; print msg	*/
       73 /*		     8 was not init before	*use new with	*/
       74 /*					 larger size	*/
       75 /*							*/
       76 /*		     New initialization larger		*/
       77 /*							*/
       78 /*		     no new initialization			*/
       79 /*		     9 was init before	*use old with	*/
       80 /*					 larger size	*/
       81 /*		     10 was not init before	use new		*/
       82 /*							*/
       83 /*		     new initialization			*/
       84 /*		     11 was init before	use new; print msg	*/
       85 /*		     12 was not init before	use new		*/
       86 /*							*/
       87 /*		     * using a given init info template with a	*/
       88 /*		       larger size means that it must be extended	*/
       89 /*		       with zeros				*/
       90 /*							*/
       91 /*		  - if an existing link is found and can be used	*/
       92 /*		    relocate the referencing halfword and return	*/
       93 /*		  - generate a new expression word in the	*/
       94 /*		    definition section			*/
       95 /*		  - generate a new type pair if the existing one	*/
       96 /*		    could not be used			*/
       97 /*		  - if the segname or entryname were not found in	*/
       98 /*		    the stringmap, then add them		*/
       99 /*		  - generate a new link in the linkage section	*/
      100 /*		    and a new link_map entry.			*/
      101 /*		  - relocate the referencing halfword and return	*/
      102 /*							*/
      103 /*	A note on error handling:				*/
      104 /*	bx_$fatal_error is set when the error is fatal (i.e. there	*/
      105 /*	should be no bound segment) but it is useful to continue	*/
      106 /*	and possibly generate more messages for the user.		*/
      107 /*	fatal_binder_error is signaled when the error is so severe	*/
      108 /*	that the binder cannot reasonably continue (as when it runs	*/
      109 /*	out of room).  (It is possible that a different		*/
      110 /*	implementation could avoid having to abort.)		*/
      111 /*							*/
      112 /**********************************************************************/
      113 
      114 /* Designed and initially coded by Michael J. Spier, October 6, 1970	*/
      115 /* modified 75.06.20 by M. Weaver to fix type 6 link initialization */
      116 /* modified July 1975 for separate static */
      117 /* modified October 1976 to regenerate *system */
      118 /* modified January 1977 by M. Weaver to use largest init sizes and convert some type 6 links to *system */
      119 /*  modified March 18, 1977 by M. Weaver to handle 0 trap ptr for *system links  */
      120 /* modified October 21, 1977 by M. Weaver to add non-relocation mode */
      121 /* modified December 6, 1977 by M. Weaver to allow larger external variable init sizes */
      122 /* modified Sept 1978 by David Spector for hash-coding strm */
      123 /* Modified 01/15/81, W. Olin Sibert, to remove ribbon shifts. */
      124 /* modified March 1, 1983 by M. Weaver to use standard include files and allocate init structures during finish */
      125 /* modified December 29, 1983 by M. Weaver to not relocate n for *text|offsetname+n */
      126 
      127 /* format: style3,^indnoniterdo */
      128 ext_link_:
      129      procedure (argument_pointer);
      130 
      131 declare	argument_pointer	pointer;
      132 
      133 
      134 /* DECLARATION OF EXTERNAL SYMBOLS */
      135 
      136 declare	decode_link_	external entry (pointer) returns (bit (1) aligned);
      137 declare	ext_link_$gen_trap	external entry (pointer) returns (fixed bin (18) unsigned aligned);
      138 declare	com_err_		external entry options (variable);
      139 declare	ioa_		entry options (variable);
      140 declare	temp_mgr_$allocate	external entry (fixed bin);
      141 declare	temp_mgr_$reserve	external entry (pointer);
      142 declare	strm_hash_$lookup	external entry (char (*), fixed bin (17));
      143 declare	strm_hash_$make_entry
      144 			external entry (char (*) aligned, fixed bin (17));
      145 
      146 /* DECLARATION OF INTERNAL STATIC VARIABLES */
      147 
      148 declare	(linkbase, defbase, tblp, newlinkp, init_map_ptr)
      149 			pointer internal static;
      150 declare	(n_tbls, nlinks, init_map_lng)
      151 			fixed bin internal static;
      152 declare	null_acc_offset	fixed bin (18) unsigned aligned internal static;
      153 declare	errname		char (16) aligned internal static;
      154 declare	wsegname		char (33) aligned internal static;
      155 declare	wentryname	char (257) aligned internal static;
      156 declare	ext_lng		fixed bin (18) internal static;
      157 declare	linklimit		fixed bin internal static;	/* number of links generated */
      158 
      159 /* DECLARATION OF AUTOMATIC STORAGE VARIABLES */
      160 
      161 declare	(i, def_growth, map_lng, linkmapx, mapx, extension_size, new_init_map_index, strm_index, new_init_type,
      162 	existing_init_type) fixed bin (17);
      163 declare	(val, step, xoffset, class, name_offset)
      164 			fixed bin (18);
      165 declare	lrt_index		fixed bin;
      166 declare	real_init_size	fixed bin (35);
      167 declare	scratch		(100) fixed bin;
      168 declare	(p, ap, link_ptr, old_trap, extp, new_ptr)
      169 			ptr;
      170 declare	(orig_init_info_ptr, cur_init_info_ptr, init_entry_ptr)
      171 			ptr;
      172 declare	new_link_modifier	bit (6) aligned;
      173 declare	(segname_found, entryname_found, typepair_found, trap_sw, convert, new_has_init_template, init_before)
      174 			bit (1) aligned;
      175 declare	new_ename		char (256) varying;
      176 
      177 declare	1 new_exp_word	aligned like exp_word;
      178 
      179 declare	1 new_type_pair	aligned like type_pair;
      180 
      181 declare	1 new_trap_pair	aligned like link_trap_pair;
      182 
      183 declare	1 new		aligned,
      184 	  2 (smaller, equal, larger)
      185 			bit (1) aligned;
      186 
      187 /* DECLARATION OF BUILTIN FUNCTIONS */
      188 
      189 declare	(addr, addrel, bin, bit, currentsize, divide, fixed, index, length, mod, null, size, sign, string, substr,
      190 	unspec, wordno)	builtin;
      191 
      192 declare	fatal_binder_error	condition;
      193 
      194 /* DECLARATION OF BASED STRUCTURES */
      195 
      196 declare	1 linkmap		(10000) aligned based (newlinkp),
      197 	  2 type_ptr	ptr,			/* ptr to link's generated type pair */
      198 	  2 linkaddr	fixed bin (18) unsigned unaligned,
      199 	  2 init_map_index	fixed bin unaligned,
      200 	  2 init_source	char (32) aligned,		/* origin of init info */
      201 	  2 has_init_template
      202 			bit (1) unaligned,		/* "1"b -> has an associated */
      203 						/* initialization template */
      204 	  2 diff_init_size	bit (1) unaligned,		/* >1 size of init info specified for link */
      205 	  2 print_msg	bit (1) unaligned,		/* >1 init template specified for link */
      206 	  2 incompatible_init_types
      207 			bit (1) unaligned;		/* ext var both area and other init type */
      208 
      209 declare	1 init_map	(5000) aligned based (init_map_ptr),
      210 	  2 init_ptr	ptr,			/* ptr to original initialization info */
      211 	  2 new_init_ptr	ptr,			/* ptr to regenerated initialization info */
      212 	  2 template_size	fixed bin (35),		/* expanded size of template */
      213 	  2 total_init_size fixed bin (35),		/* size of variable incl extension */
      214 	  2 reference_count fixed bin unaligned,	/* # of links that reference this entry */
      215 	  2 init_type	fixed bin unaligned;	/* type of init info */
      216 
      217 declare	1 tbl_map		based (tblp) aligned,	/* newly generated trap_pair map */
      218 	  2 tbl_offset	(1000) fixed bin (18) unsigned unaligned;
      219 
      220 declare	init_size_compares	(-1:1) bit (1) aligned based (addr (new));
      221 
      222 declare	copy_save		(ext_lng) fixed bin based (p);
      223 
      224 declare	1 word		aligned based,
      225 	  2 left_half	bit (18) unaligned,
      226 	  2 right_half	bit (18) unaligned;
      227 
      228 declare	1 ext		aligned based (ap) like external_ref;
      229 
      230 	trap_sw = "0"b;				/* indicate that this is a regular link */
      231 
      232 start:
      233 	def_growth = 0;
      234 	ctp = bx_$ctp;
      235 	strmp = bx_$strmp;
      236 	ap = argument_pointer;			/* copy argument into our stack frame */
      237 	ctep = ext.compent_ptr;
      238 	val = 0;
      239 
      240 	lrtp = comp.clrtp;
      241 	lrt_index = ((ext.loffset - lrt.start_offset) * 0.5) + 1;
      242 	if (lrt.regenerated (lrt_index) ^= UNRESOLVED) & (lrt.regenerated (lrt_index) ^= INTERNALLY_RESOLVED)
      243 	then do;
      244 	     step = fixed (lrt.regenerated (lrt_index), 18);
      245 	     goto adjust_text;
      246 	end;
      247 
      248 	new_link_modifier = ext.link_tm || ext.link_td;	/* this program doesn't need them separated */
      249 
      250 	segname_found, entryname_found, typepair_found = "0"b;
      251 
      252 	map_lng = strm.nstr;
      253 	new_init_map_index = 0;
      254 	old_trap = null;
      255 	new_has_init_template = "0"b;
      256 
      257 	unspec (new_exp_word) = "0"b;
      258 	unspec (new_trap_pair) = "0"b;
      259 
      260 	new_type_pair.type = bin (ext.type, 18);	/* copy type/trap values into new type pair */
      261 	new_type_pair.trap_relp,			/* this field does not get filled in */
      262 	     new_type_pair.segname_relp, new_type_pair.offsetname_relp = 0;
      263 
      264 	class = bin (ext.code15, 18);			/* use class instead of segname for types 1 & 5 */
      265 
      266 	if new_type_pair.type = LINK_REFNAME_BASE
      267 	then do;
      268 	     new_type_pair.offsetname_relp = null_acc_offset;
      269 						/* use null acc offset to compare with type 6 */
      270 	     entryname_found = "1"b;			/* we know it's allocated */
      271 	end;
      272 
      273 	if ^trap_sw				/* normal ext_link_ entry (not gen_trap entry) */
      274 	then do;					/* format name for possible error message */
      275 	     wsegname = substr (ext.segname, 2, ext.slng - 1);
      276 	     i = ext.elng;
      277 	     wentryname = substr (ext.entryname, 1, i);
      278 	     if wsegname = "*system"
      279 	     then substr (wentryname, 1, 1) = "|";
      280 	     else if i > 0
      281 	     then substr (wentryname, 1, 1) = "$";
      282 	     else do;
      283 		i = 2;
      284 		wentryname = "|0";
      285 	     end;
      286 	end;
      287 
      288 	if ext.trap
      289 	then if (new_type_pair.type = LINK_CREATE_IF_NOT_FOUND)
      290 		| ((new_type_pair.type = LINK_SELF_OFFSETNAME) & (class = SECTION_SYSTEM))
      291 	     then do;				/* have create-if-not-found or *system link */
      292 						/* find/create an init map entry for this */
      293 		orig_init_info_ptr = addrel (comp.cdefp, ext.trap);
      294 		call find_init_map_entry ();
      295 		new_has_init_template = (init_map (new_init_map_index).template_size > 0);
      296 	     end;
      297 
      298 	     else do;				/* have trap before link */
      299 		addr (scratch) -> copy_save = ap -> copy_save;
      300 						/* save input structure */
      301 		ext.offset = ext.loffset;		/* change input struc to process trap links */
      302 		ext.section = "link";
      303 		ext.relinfo = " ";
      304 		old_trap = addrel (comp.cdefp, ext.trap);
      305 		ext.loffset = old_trap -> link_trap_pair.call_relp;
      306 		if decode_link_ (ap)
      307 		then go to trap_error;
      308 
      309 
      310 		new_trap_pair.call_relp = ext_link_$gen_trap (ap);
      311 						/* will need to recreate link */
      312 
      313 		ext.loffset = old_trap -> link_trap_pair.info_relp;
      314 						/* will look at arg link now */
      315 		if ext.loffset > 0
      316 		then do;				/* process arg link */
      317 		     if decode_link_ (ap) = "1"b
      318 		     then go to trap_error;
      319 		     new_trap_pair.info_relp = ext_link_$gen_trap (ap);
      320 		end;
      321 		else new_trap_pair.info_relp = 0;
      322 
      323 		do i = 1 to n_tbls;			/* scan trap before link trap pair map */
      324 		     if unspec (new_trap_pair) = unspec (addrel (defbase, tbl_offset (i)) -> link_trap_pair)
      325 		     then do;
      326 			new_type_pair.trap_relp = tbl_offset (i);
      327 						/* put rel ptr into new link's trap field */
      328 			go to restore_ext;
      329 		     end;
      330 		end;				/* of searching table */
      331 
      332 		n_tbls = i;			/* increment size of map */
      333 		tbl_offset (i), new_type_pair.trap_relp = bx_$curdeflng;
      334 		bx_$curdeflng = bx_$curdeflng + 1;	/* update def section size */
      335 		addrel (defbase, tbl_offset (i)) -> link_trap_pair = new_trap_pair;
      336 						/* copy trap pair */
      337 restore_ext:
      338 		ap -> copy_save = addr (scratch) -> copy_save;
      339 						/* restore input struc */
      340 	     end;					/* of trap decoding processing */
      341 
      342 /* scan current portion of new linkage section to see if such ext link already exists */
      343 
      344 	def_growth = 0;
      345 	new_exp_word.expression = bin (ext.expr, 17);
      346 
      347 	if new_type_pair.type = LINK_SELF_BASE | new_type_pair.type = LINK_SELF_OFFSETNAME
      348 	then do;					/* type 1 & type 5 links don't have symbolic segnames */
      349 	     new_type_pair.segname_relp = class;	/* retrieve segbase code */
      350 	     segname_found = "1"b;			/* we know the "segment name" */
      351 	     if bx_$bound_sep_stat ^= 1
      352 	     then if class = SECTION_STATIC		/* link to *static */
      353 		then new_type_pair.segname_relp = SECTION_LINK;
      354 						/* will be no sep static; convert to *link */
      355 	     if new_type_pair.type = LINK_SELF_BASE
      356 	     then do;				/* there is no entryname symbol */
      357 		entryname_found = "1"b;
      358 		if class = SECTION_TEXT
      359 		then new_exp_word.expression = new_exp_word.expression + comp.crelt;
      360 		if class = SECTION_STATIC
      361 		then do;				/* link to static; seg relp may have been changed */
      362 		     if wsegname = "*static"
      363 		     then do;			/* link to static of referencing component */
      364 			if bx_$bound_sep_stat = 1
      365 			then i = 0;
      366 			else i = 8;
      367 			new_exp_word.expression = new_exp_word.expression + comp.creli + i;
      368 		     end;
      369 		end;				/* Otherwise link to static of another component;
      370*					   	   relocation of expression already done by int_link_;
      371*						   ext.segname = original segname, etc. */
      372 		go to lookup_links;
      373 	     end;
      374 	end;
      375 
      376 /* Lookup stringmap table for segname and entryname (avoid extra strings) */
      377 
      378 	if ^segname_found
      379 	then do;
      380 	     call strm_hash_$lookup (substr (ext.segname, 1, ext.slng), strm_index);
      381 	     if strm_index ^= 0
      382 	     then do;				/* segname found in stringmap */
      383 		new_type_pair.segname_relp = bin (strm.entry (strm_index).map, 18);
      384 		segname_found = "1"b;
      385 	     end;
      386 	end;
      387 	if ^entryname_found
      388 	then do;
      389 	     call strm_hash_$lookup (substr (ext.entryname, 1, ext.elng), strm_index);
      390 	     if strm_index ^= 0
      391 	     then do;				/* entryname found in stringmap */
      392 		new_type_pair.offsetname_relp = bin (strm.entry (strm_index).map, 18);
      393 		entryname_found = "1"b;
      394 	     end;
      395 	end;
      396 
      397 lookup_links:
      398 	do linkmapx = 1 to nlinks;			/* scan all newly generated links */
      399 	     step = linkmap (linkmapx).linkaddr;	/* get rel pointer to link */
      400 	     link_ptr = addrel (linkbase, step);	/* and ITS pointer to it */
      401 	     if link_ptr -> object_link.modifier ^= new_link_modifier
      402 	     then go to advance;
      403 	     exp_ptr = addrel (defbase, link_ptr -> object_link.expression_relp);
      404 	     if ^typepair_found
      405 	     then do;
      406 		new_exp_word.type_relp = exp_ptr -> exp_word.type_relp;
      407 						/* fill in in case this type pair fits */
      408 		type_ptr = linkmap (linkmapx).type_ptr;
      409 	     end;
      410 	     else go to use_typepair;
      411 
      412 	     if segname_found & entryname_found
      413 	     then do;				/* see if this type pair may be reused */
      414 		if unspec (new_type_pair) ^= unspec (type_ptr -> type_pair)
      415 		then go to advance;			/* type pairs do not match */
      416 						/* but not comparing init info offsets here */
      417 		if new_init_map_index = linkmap (linkmapx).init_map_index
      418 		then go to use_typepair;		/* init info also matches */
      419 
      420 /* now see if the init info can be made to match */
      421 
      422 		if (new_type_pair.type ^= LINK_CREATE_IF_NOT_FOUND)
      423 		     & ^((new_type_pair.type = LINK_SELF_OFFSETNAME) & (class = SECTION_SYSTEM))
      424 		then go to advance;			/* diff trap-before-links or 1 trap and 1 not */
      425 
      426 /* At this point we know we have a reference to a variable and we can't
      427*   have 2 links to the same variable.  We must use the existing link and
      428*   either choose one of the init infos or combine them. */
      429 
      430 /* Assume that ALL such links have initialization info. */
      431 
      432 /* We can't combine the links if one is for an area and the other is not */
      433 
      434 		existing_init_type = init_map (linkmap (linkmapx).init_map_index).init_ptr -> link_init.type;
      435 		if linkmap (linkmapx).incompatible_init_types
      436 		then return;			/* don't print redundant messages */
      437 		if ((new_init_type = INIT_DEFINE_AREA) & (existing_init_type ^= INIT_DEFINE_AREA))
      438 		     | ((existing_init_type = INIT_DEFINE_AREA) & (new_init_type ^= INIT_DEFINE_AREA))
      439 		then do;
      440 		     call com_err_ (0, errname,
      441 			"External variable ^[^a^a^;^2s^]^a has incompatible initialization types.",
      442 			wsegname ^= "*system", wsegname, substr (wentryname, 1, 1), substr (wentryname, 2));
      443 		     bx_$fatal_error = 1;
      444 		     linkmap (linkmapx).incompatible_init_types = "1"b;
      445 		     return;			/* we will bomb anyway */
      446 		end;
      447 
      448 /* now we find out how the two initializations compare */
      449 
      450 		string (new) = "0"b;
      451 		real_init_size = init_map (linkmap (linkmapx).init_map_index).total_init_size;
      452 		if real_init_size = 0		/* no template */
      453 		then real_init_size = init_map (linkmap (linkmapx).init_map_index).init_ptr -> link_init.n_words;
      454 		init_size_compares (
      455 		     sign (init_map (new_init_map_index).init_ptr -> link_init.n_words - real_init_size)) = "1"b;
      456 						/* compare new and previous init sizes and set
      457*						   appropriate flag via based array */
      458 		if linkmap (linkmapx).has_init_template
      459 		then init_before = "1"b;
      460 		else init_before = "0"b;
      461 		if ^new.equal
      462 		then do;				/* print warning first time around */
      463 		     if ^linkmap (linkmapx).diff_init_size
      464 		     then do;
      465 			if bx_$brief ^= 1
      466 			then call ioa_ (
      467 				"Warning: external variable ^[^a^a^;^2s^]^a has different sizes;^/^-the largest will be used.",
      468 				wsegname ^= "*system", wsegname, substr (wentryname, 1, 1),
      469 				substr (wentryname, 2));
      470 			linkmap (linkmapx).diff_init_size = "1"b;
      471 		     end;
      472 		end;
      473 
      474 /* cases 1, 2, 5, 6 just go to use_typepair */
      475 
      476 		if new_has_init_template & init_before
      477 		then if init_map (new_init_map_index).init_ptr
      478 			^= init_map (linkmap (linkmapx).init_map_index).init_ptr
      479 						/* make sure it's not the same template */
      480 		     then do;			/* cases 3, 7, 11 */
      481 			linkmap (linkmapx).print_msg = "1"b;
      482 			if new.equal
      483 			then if init_map (linkmap (linkmapx).init_map_index).total_init_size
      484 				> init_map (linkmap (linkmapx).init_map_index).template_size
      485 			     then call replace_init_info;
      486 						/* if old was extended, new is probably better */
      487 		     end;
      488 
      489 		if (new_has_init_template & ((new.equal & ^init_before) | (new.larger & init_before)))
      490 		     | (new.larger & ^init_before)	/* cases 4, 10, 11, 12 */
      491 		then call replace_init_info;
      492 
      493 		else if new.smaller & new_has_init_template & ^init_before
      494 		then do;				/* case 8 */
      495 						/* use new init template but extend it to length of old */
      496 		     call extend_template ((new_init_map_index),
      497 			init_map (linkmap (linkmapx).init_map_index).init_ptr -> link_init.n_words);
      498 		     call replace_init_info;
      499 		end;
      500 
      501 		else if new.larger & ^new_has_init_template & init_before
      502 		then do;				/* case 9 */
      503 						/* use old template extended to new size */
      504 		     call extend_template (linkmap (linkmapx).init_map_index,
      505 			init_map (new_init_map_index).init_ptr -> link_init.n_words);
      506 		     call change_init_map_index;
      507 		end;
      508 
      509 use_typepair:
      510 		typepair_found = "1"b;
      511 		if unspec (new_exp_word) = unspec (exp_ptr -> exp_word)
      512 		then goto adjust_text;		/* expression words must also match for actual link to be used */
      513 	     end;
      514 advance:
      515 	end;					/* end of loop for looking at linkmap */
      516 
      517 generate_definition:				/* generate expression word and type pair, if necessary */
      518 	def_growth = 1;				/* def section will grow by one expression word */
      519 	xoffset = bx_$curdeflng;			/* offset of expression word */
      520 	exp_ptr = addrel (defbase, xoffset);
      521 	if ^typepair_found				/* we have to generate a type pair */
      522 	then new_exp_word.type_relp = xoffset + 1;	/* thread to type pair to be created */
      523 	exp_ptr -> exp_word = new_exp_word;		/* put expression word into definition section */
      524 
      525 	if typepair_found
      526 	then go to generate_link;
      527 
      528 	type_ptr = addrel (exp_ptr, 1);		/* ptr to type pair to be generated */
      529 	type_ptr -> type_pair = new_type_pair;		/* copy type pair into new definition section */
      530 	def_growth = def_growth + 2;			/* remember def section grew by 2 words */
      531 	if new_init_map_index > 0			/* references are made by type pairs */
      532 	then init_map (new_init_map_index).reference_count = init_map (new_init_map_index).reference_count + 1;
      533 
      534 	if ^segname_found
      535 	then do;					/* we have to generate an ACC string for the segname */
      536 	     call add_name (addr (ext.segname), ext.slng);
      537 	     type_ptr -> type_pair.segname_relp = name_offset;
      538 	end;
      539 
      540 	if ^entryname_found
      541 	then do;
      542 	     if substr (ext.entryname, 1, 33) = ext.segname
      543 	     then type_ptr -> type_pair.offsetname_relp = type_ptr -> type_pair.segname_relp;
      544 	     else do;				/* must generate an ACC string for the entryname */
      545 		call add_name (addr (ext.entryname), ext.elng);
      546 		type_ptr -> type_pair.offsetname_relp = name_offset;
      547 	     end;
      548 	end;
      549 
      550 /* now update official stringmap length */
      551 
      552 	strm.nstr = map_lng;
      553 	if strm.nstr > strm.max_size
      554 	then do;
      555 	     call com_err_ (0, errname, "Stringmap table overflow; please notify maintenance.");
      556 	     strm.nstr = 0;
      557 	     bx_$fatal_error = 1;
      558 	end;
      559 
      560 generate_link:					/* regenerate link itself */
      561 	step = bx_$tlinklng;			/* location where new link will be generated */
      562 
      563 	linkmapx, nlinks = nlinks + 1;		/* increment table size */
      564 	if nlinks > linklimit
      565 	then do;					/* table overflow */
      566 	     call com_err_ (0, errname,
      567 		"Linktable overflow while adding link to ^a^a^/^-for component ^a.^/^-You have room for only ^d links^/^-after your ^d words of internal static.^/^-Consider using separate static (pl1 or alm) or large arrays (fortran)^/^-to make more room for links.",
      568 		wsegname, wentryname, ext.compent_ptr -> comp.filename, linklimit, bx_$tintlng);
      569 	     signal fatal_binder_error;		/* stop now; don't prolong the agony */
      570 	end;
      571 	linkmap (nlinks).type_ptr = type_ptr;		/* remembering this will make patching easier */
      572 	linkmap (nlinks).linkaddr = step;		/* remember where link is */
      573 	linkmap (nlinks).init_source = comp.filename;	/* and origin of init structure */
      574 	linkmap (nlinks).init_map_index = new_init_map_index;
      575 	linkmap (nlinks).has_init_template = new_has_init_template;
      576 	linkmap (nlinks).diff_init_size = "0"b;
      577 	linkmap (nlinks).print_msg = "0"b;
      578 
      579 	link_ptr = addrel (linkbase, step);		/* get pointer to new link */
      580 	bx_$tlinklng = step + 2;			/* and adjust new length of linkage section */
      581 	link_ptr -> object_link.header_relp = -step;	/* backpointer to head of linkage section */
      582 	link_ptr -> object_link.tag = "46"b3;		/* add fault tag 2 code */
      583 	link_ptr -> object_link.expression_relp = xoffset;/* ptr to expression word in def section */
      584 	link_ptr -> object_link.modifier = new_link_modifier;
      585 						/* restore modifiers of original link */
      586 
      587 adjust_text:
      588 	bx_$curdeflng = bx_$curdeflng + def_growth;	/* adjust def section length if necessary */
      589 	if ^ext.dont_relocate
      590 	then do;					/* sometimes we regenerate links that aren't referenced */
      591 	     if trap_sw
      592 	     then trap_offset = step;			/* return rel ptr to trap fault */
      593 	     else if ext.relinfo = "lnk18   "
      594 	     then do;
      595 		if ext.side = "lhe"
      596 		then ext.ref_ptr -> word.left_half = bit (bin (step, 18), 18);
      597 		else ext.ref_ptr -> word.right_half = bit (bin (step, 18), 18);
      598 	     end;
      599 	     else substr (ext.ref_ptr -> word.left_half, 4, 15) = bit (bin (step, 15), 15);
      600 						/* put in textsection rel ptr to linkage */
      601 	end;
      602 
      603 	lrt.regenerated (lrt_index) = bit (bin (step, 18), 18);
      604 
      605 	return;
      606 
      607 trap_error:
      608 	ap -> copy_save = addr (scratch) -> copy_save;	/* restore original link information */
      609 	call com_err_ (0, errname, "cannot process trap before link for ^a^a referenced by ^a|^o of ^a", wsegname,
      610 	     wentryname, ext.section, ext.offset, comp.filename);
      611 	bx_$fatal_error = 1;
      612 	return;
      613 
      614 
      615 
      616 gen_trap:
      617      entry (argument_pointer, trap_offset);
      618 
      619 /**********************************************************************/
      620 /*							*/
      621 /*	Name:	ext_link_$gen_trap				*/
      622 /*	Input:	argument_pointer				*/
      623 /*	Function:	This entry point generates a link in essentially	*/
      624 /*		the same manner as ext_link_ except that it	*/
      625 /*		returns a relptr to the trap link relative to the	*/
      626 /*		base of the linkage section.			*/
      627 /*	Output:	trap_offset				*/
      628 /*							*/
      629 /**********************************************************************/
      630 
      631 declare	trap_offset	fixed bin (18) unsigned aligned;
      632 
      633 	trap_sw = "1"b;				/* indicate this is a trap before link */
      634 	trap_offset = 0;				/* preset return argument */
      635 	go to start;
      636 
      637 init:
      638      entry;
      639 
      640 /**********************************************************************/
      641 /*							*/
      642 /*	Name:	ext_link_$init				*/
      643 /*	Input:	none					*/
      644 /*	Function:	allocates static tables for use by ext_link_ and	*/
      645 /*		initializes various static lengths		*/
      646 /*	Output:	none					*/
      647 /*							*/
      648 /**********************************************************************/
      649 
      650 	linkbase = bx_$tlinkp;			/* beginning of linkage section */
      651 	if mod (bx_$tlinklng, 2) = 1
      652 	then bx_$tlinklng = bx_$tlinklng + 1;		/* make links start on even location */
      653 
      654 	tblp = bx_$freep;				/* pointer to map of trap-pairs */
      655 	linklimit = divide ((bx_$maxlinklng - bx_$tlinklng), 2, 17, 0);
      656 						/* get max no of links */
      657 
      658 	call temp_mgr_$reserve (addrel (tblp, linklimit));/* reserve map */
      659 	n_tbls = 0;				/* indicate no trap-pairs yet */
      660 
      661 	i = linklimit * 7;				/* get max size of init map */
      662 	call temp_mgr_$allocate (i);			/* make sure that there is enough room */
      663 	init_map_ptr = bx_$freep;			/* pointer to init info map */
      664 	call temp_mgr_$reserve (addrel (init_map_ptr, i));/* reserve init info map */
      665 	i = linklimit * 12;				/* get max size of link map */
      666 	call temp_mgr_$allocate (i);			/* make sure that there is enough room */
      667 	init_map_lng = 0;				/* reset length of init map */
      668 
      669 	newlinkp = bx_$freep;			/* make new link table */
      670 	call temp_mgr_$reserve (addrel (newlinkp, i));
      671 	nlinks = 0;				/* preset table size */
      672 
      673 	if bx_$debug = 1
      674 	then errname = "ext_link_";
      675 	else errname = bx_$caller;
      676 	defbase = bx_$tdefp;			/* beginning of definition section */
      677 
      678 	null_acc_offset = bx_$curdeflng - 1;		/* all zero word set in make_defs_$open_section */
      679 						/* compute the size of the external reference structure 'ext'  */
      680 
      681 	ap = addr (scratch);
      682 	ext_lng = size (ext);
      683 	return;
      684 
      685 finish:
      686      entry;
      687 
      688 /**********************************************************************/
      689 /*							*/
      690 /*	Name:	ext_link_$finish				*/
      691 /*	Input:	none					*/
      692 /*	Function:	allocates the initialization structures in the	*/
      693 /*		bound segment and patches the initialization	*/
      694 /*		info relptrs back into the links.  If the init	*/
      695 /*		info for a copy_info initialization has been	*/
      696 /*		extended, and the extension is longer than an	*/
      697 /*		arbitrary size (50 words), the copy_info is	*/
      698 /*		converted to a list_template containing a single	*/
      699 /*		copy of the existing info and a repeated zero	*/
      700 /*		Messages are also printed for links which had	*/
      701 /*		multiple initializations specified.		*/
      702 /*	Output:	none					*/
      703 /*							*/
      704 /**********************************************************************/
      705 
      706 declare	n_bad_links	fixed bin;
      707 
      708 /* print all multiple initialization messages */
      709 
      710 	do i = 1 to nlinks;
      711 	     if linkmap (i).print_msg
      712 	     then do;
      713 		type_ptr = linkmap (i).type_ptr;
      714 		if type_ptr -> type_pair.type = LINK_SELF_OFFSETNAME
      715 		then wsegname = "";			/* no segname; don't print *system */
      716 		else wsegname = addrel (defbase, type_ptr -> type_pair.segname_relp) -> acc_string.string || "$";
      717 
      718 		call com_err_ (0, errname,
      719 		     "Multiple initializations specified for external variable ^a^a;^/^-the one in ^a will be used.",
      720 		     wsegname, addrel (defbase, type_ptr -> type_pair.offsetname_relp) -> acc_string.string,
      721 		     linkmap (i).init_source);
      722 	     end;
      723 	end;
      724 
      725 /* Now allocate all init info structures that the links in the bound segment reference. */
      726 
      727 	link_init_n_bits_in_datum = 0;
      728 	do mapx = 1 to init_map_lng;
      729 	     if init_map (mapx).reference_count > 0
      730 	     then do;				/* copy into bound segment */
      731 		init_map (mapx).new_init_ptr, cur_init_info_ptr = addrel (defbase, bx_$curdeflng);
      732 		extension_size = init_map (mapx).total_init_size - init_map (mapx).template_size;
      733 
      734 		if init_map (mapx).init_type = INIT_COPY_INFO
      735 		then do;
      736 		     if extension_size <= 50		/* arbitrary limit */
      737 		     then do;
      738 			cur_init_info_ptr -> link_init_copy_info = init_map (mapx).init_ptr -> link_init_copy_info;
      739 			if extension_size > 0
      740 			then cur_init_info_ptr -> link_init_copy_info.header.n_words =
      741 				init_map (mapx).total_init_size;
      742 			bx_$curdeflng = bx_$curdeflng + currentsize (cur_init_info_ptr -> link_init_copy_info);
      743 		     end;				/* of no or small extension */
      744 		     else do;			/* convert to list template */
      745 			cur_init_info_ptr -> link_init_list_template.header.type = INIT_LIST_TEMPLATE;
      746 			cur_init_info_ptr -> link_init_list_template.n_words_in_list =
      747 			     init_map (mapx).init_ptr -> link_init_copy_info.header.n_words
      748 			     + size (list_template_entry) + 1;
      749 			init_entry_ptr = addr (cur_init_info_ptr -> link_init_list_template.template);
      750 			init_entry_ptr -> list_template_entry.n_bits =
      751 			     init_map (mapx).init_ptr -> link_init_copy_info.n_words * 36;
      752 			init_entry_ptr -> list_template_entry.repeat = 1;
      753 			init_entry_ptr -> list_template_entry.datum =
      754 			     unspec (init_map (mapx).init_ptr -> link_init_copy_info.initial_data);
      755 
      756 
      757 			init_entry_ptr =
      758 			     addrel (init_entry_ptr, currentsize (init_entry_ptr -> list_template_entry));
      759 			call add_extension;
      760 			bx_$curdeflng = bx_$curdeflng + currentsize (cur_init_info_ptr -> link_init_list_template);
      761 		     end;				/* of conversion to list */
      762 
      763 		end;				/* of init_copy_info case */
      764 
      765 		else if init_map (mapx).init_type = INIT_LIST_TEMPLATE
      766 		then do;
      767 		     cur_init_info_ptr -> link_init_list_template =
      768 			init_map (mapx).init_ptr -> link_init_list_template;
      769 		     if extension_size > 0
      770 		     then do;			/* 0 repeat entry starts where last word now is */
      771 			init_entry_ptr =
      772 			     addrel (cur_init_info_ptr,
      773 			     currentsize (cur_init_info_ptr -> link_init_list_template) - 1);
      774 			call add_extension;
      775 		     end;
      776 		     bx_$curdeflng = bx_$curdeflng + currentsize (cur_init_info_ptr -> link_init_list_template);
      777 		end;				/* of init_list template case */
      778 
      779 		else do;				/* no template; just header */
      780 		     cur_init_info_ptr -> link_init = init_map (mapx).init_ptr -> link_init;
      781 		     if extension_size > 0
      782 		     then cur_init_info_ptr -> link_init.n_words = init_map (mapx).total_init_size;
      783 		     bx_$curdeflng = bx_$curdeflng + size (link_init);
      784 		end;
      785 	     end;
      786 	end;					/* of copying init_info into bound segment */
      787 
      788 /* Now update the links that have init info */
      789 
      790 	n_bad_links = 0;
      791 	xoffset = wordno (defbase);
      792 	do mapx = 1 to nlinks;
      793 	     if linkmap (mapx).init_map_index > 0
      794 	     then do;				/* have init info to fill in */
      795 		new_ptr = init_map (linkmap (mapx).init_map_index).new_init_ptr;
      796 		if new_ptr ^= null
      797 		then linkmap (mapx).type_ptr -> type_pair.trap_relp = wordno (new_ptr) - xoffset;
      798 		else do;				/* indicates bug in this program */
      799 		     n_bad_links = n_bad_links + 1;
      800 		     call com_err_ (0, errname,
      801 			"Link to external variable ^a has missing initialization information.^/^-Notify maintenance personnel.",
      802 			addrel (defbase, linkmap (mapx).type_ptr -> type_pair.offsetname_relp) -> acc_string.string)
      803 			;			/* segname is usually meaningless in this case */
      804 		end;
      805 	     end;
      806 	end;
      807 
      808 	if n_bad_links > 0
      809 	then bx_$fatal_error = 1;
      810 
      811 	return;
      812 
      813 find_init_map_entry:
      814      proc;
      815 
      816 /**********************************************************************/
      817 /*							*/
      818 /*	Name:	find_init_map_entry				*/
      819 /*	Input:	orig_init_info_ptr, new_type_pair, wsegname,	*/
      820 /*		external_ref (pointed to by ap)		*/
      821 /*	Function:	finds or creates an init_map entry for a given	*/
      822 /*		link.  Certain type-6 (create-if-not-found) links	*/
      823 /*		are first converted into *system links.  If an	*/
      824 /*		init_map entry is found that matches, it's	*/
      825 /*		reference count is incremented and it is used.	*/
      826 /*		otherwise an new entry is created.		*/
      827 /*	Output:	new_init_map_index				*/
      828 /*							*/
      829 /**********************************************************************/
      830 
      831 	convert = "0"b;
      832 	if new_type_pair.type = LINK_CREATE_IF_NOT_FOUND
      833 	then do;					/* see if it needs to be converted */
      834 	     extp = ap;				/* normal, non trap case */
      835 	     if wsegname = "stat_"
      836 	     then do;
      837 		convert = "1"b;
      838 		new_ename = addr (ext.entryname) -> acc_string.string;
      839 	     end;
      840 	     else if ext.elng = 1
      841 	     then do;				/* null entryname */
      842 		i = index (ext.segname, ".com");
      843 		if (i > 0) & (i = (ext.slng - 3))
      844 		then do;
      845 		     new_ename = substr (ext.segname, 2, i - 2);
      846 		     if new_ename = "b_"
      847 		     then new_ename = "blnk*com";
      848 		     convert = "1"b;
      849 		end;
      850 		else do;
      851 		     new_type_pair.offsetname_relp = null_acc_offset;
      852 						/* set to point to all zero word */
      853 		     entryname_found = "1"b;
      854 		end;
      855 	     end;
      856 	     else if wsegname = "cobol_fsb_"
      857 	     then do;
      858 		new_ename = "cobol_fsb_" || addr (ext.entryname) -> acc_string.string;
      859 		convert = "1"b;
      860 	     end;
      861 	end;
      862 
      863 	if convert
      864 	then do;					/* diddle info to make it look like *system link */
      865 	     extp -> ext.code15 = bit (bin (LINK_SELF_OFFSETNAME, 18), 18);
      866 	     new_type_pair.type = LINK_SELF_OFFSETNAME;
      867 	     class = SECTION_SYSTEM;
      868 	     wsegname = "*system";
      869 	     addr (extp -> ext.segname) -> acc_string.count = length ("*system");
      870 	     addr (extp -> ext.segname) -> acc_string.string = "*system";
      871 	     extp -> ext.slng = length ("*system") + 1;
      872 	     wentryname = "|" || new_ename;
      873 	     addr (extp -> ext.entryname) -> acc_string.count = length (new_ename);
      874 	     addr (extp -> ext.entryname) -> acc_string.string = new_ename;
      875 	     extp -> ext.elng = length (new_ename) + 1;
      876 	end;
      877 
      878 /* See if an identical init structure is already in our map */
      879 
      880 	new_init_type = orig_init_info_ptr -> link_init.type;
      881 
      882 	do new_init_map_index = 1 to init_map_lng;
      883 	     cur_init_info_ptr = init_map (new_init_map_index).init_ptr;
      884 						/* get ptr to current entry's init info */
      885 	     if unspec (orig_init_info_ptr -> link_init) = unspec (cur_init_info_ptr -> link_init)
      886 	     then do;				/* so far, init headers match */
      887 		if new_init_type = INIT_COPY_INFO
      888 		then if unspec (orig_init_info_ptr -> link_init_copy_info.initial_data)
      889 			= unspec (cur_init_info_ptr -> link_init_copy_info.initial_data)
      890 		     then return;
      891 		     else ;			/* templates don't match; continue */
      892 		else if new_init_type = INIT_LIST_TEMPLATE
      893 		then if unspec (orig_init_info_ptr -> link_init_list_template.template)
      894 			= unspec (cur_init_info_ptr -> link_init_list_template.template)
      895 		     then return;
      896 		     else ;			/* templates don't match; continue */
      897 		else return;			/* no templates to match in these cases */
      898 	     end;					/* of = headers part */
      899 	end;					/* of comparison loop */
      900 
      901 /* if we get here a match was not found, so we have to add an init_map entry */
      902 
      903 	init_map_lng = init_map_lng + 1;		/* new_init_map_index should already be = to this */
      904 	init_map (init_map_lng).init_ptr = orig_init_info_ptr;
      905 	init_map (init_map_lng).reference_count = 0;
      906 	init_map (init_map_lng).init_type = new_init_type;
      907 	init_map (init_map_lng).new_init_ptr = null;
      908 
      909 /* now set template size */
      910 
      911 	if (new_init_type = INIT_COPY_INFO) | (new_init_type = INIT_LIST_TEMPLATE)
      912 	then init_map (init_map_lng).template_size = orig_init_info_ptr -> link_init_copy_info.header.n_words;
      913 
      914 	else init_map (init_map_lng).template_size = 0;
      915 
      916 	init_map (init_map_lng).total_init_size = init_map (init_map_lng).template_size;
      917 						/* equality indicates not extended */
      918 
      919 	return;
      920      end;
      921 
      922 replace_init_info:
      923      proc;
      924 
      925 /**********************************************************************/
      926 /*							*/
      927 /*	Name:	replace_init_info				*/
      928 /*	Input:	new_has_init_info, linkmapx, new_init_map_index	*/
      929 /*	Function:	Changes the init_map index in the link specified	*/
      930 /*		by linkmapx to use the initialization info	*/
      931 /*		referred to by new_init_map_index.		*/
      932 /*	Output:	none					*/
      933 /*							*/
      934 /**********************************************************************/
      935 
      936 	linkmap (linkmapx).init_source = comp.filename;
      937 	linkmap (linkmapx).has_init_template = new_has_init_template;
      938 	call change_init_map_index;
      939 
      940 	return;
      941 
      942      end;
      943 
      944 
      945 
      946 
      947 
      948 change_init_map_index:
      949      proc;
      950 
      951 /**********************************************************************/
      952 /*							*/
      953 /*	Name:	change_init_map_index			*/
      954 /*	Input:	linkmapx, new_init_map_index			*/
      955 /*	Function:	replaces the init_map entry for the specified	*/
      956 /*		link and adjusts the reference counts in the	*/
      957 /*		init_map entries				*/
      958 /*	Output:	none					*/
      959 /*							*/
      960 /*	Notes:	this procedure is logically a part of		*/
      961 /*		replace_init_info but must sometimes be called	*/
      962 /*		separately				*/
      963 /*							*/
      964 /**********************************************************************/
      965 
      966 	init_map (linkmap (linkmapx).init_map_index).reference_count =
      967 	     init_map (linkmap (linkmapx).init_map_index).reference_count - 1;
      968 
      969 	init_map (new_init_map_index).reference_count = init_map (new_init_map_index).reference_count + 1;
      970 
      971 	linkmap (linkmapx).init_map_index = new_init_map_index;
      972 
      973 	return;
      974 
      975      end;
      976 
      977 extend_template:
      978      proc (cur_init_map_index, target_size);
      979 
      980 /**********************************************************************/
      981 /*							*/
      982 /*	Name:	extend_template				*/
      983 /*	Input:	cur_init_map_index, target_size		*/
      984 /*	Function:	extends the specified init_map entry to the size	*/
      985 /*		indicated by target size.  This is done by first	*/
      986 /*		attempting to find an existing init_map entry	*/
      987 /*		that matches the requirements, or by creating one	*/
      988 /*		if no matching init_info already exists.	*/
      989 /*	Output:	new_init_map_index				*/
      990 /*							*/
      991 /**********************************************************************/
      992 
      993 declare	cur_init_map_index	fixed bin unal;
      994 declare	target_size	fixed bin (35);
      995 
      996 /* first try to match an existing template  */
      997 
      998 	do mapx = 1 to init_map_lng;
      999 	     if init_map (mapx).total_init_size = target_size
     1000 	     then if init_map (mapx).init_ptr = init_map (cur_init_map_index).init_ptr
     1001 						/* the unextended templates must match;
     1002*						   the init_map has no duplicates;
     1003*						   so if they match, they are the same */
     1004 		then do;
     1005 		     new_init_map_index = mapx;
     1006 		     return;
     1007 		end;
     1008 	end;					/* of mapx loop */
     1009 
     1010 /* Did not find match.  Must create a new init_map entry for the extension. */
     1011 
     1012 	init_map_lng = init_map_lng + 1;
     1013 
     1014 /* copy whole entry, then update */
     1015 
     1016 	init_map (init_map_lng) = init_map (cur_init_map_index);
     1017 	init_map (init_map_lng).total_init_size = target_size;
     1018 	init_map (init_map_lng).reference_count = 0;	/* this will be updated later */
     1019 
     1020 	new_init_map_index = init_map_lng;
     1021 
     1022 	return;
     1023 
     1024      end;
     1025 
     1026 add_name:
     1027      proc (new_name_ptr, name_length);
     1028 
     1029 /**********************************************************************/
     1030 /*							*/
     1031 /*	Name:	add_name					*/
     1032 /*	Input:	new_name_ptr, name_length			*/
     1033 /*	Function:	adds a new name to the definition section and to	*/
     1034 /*		the string map.				*/
     1035 /*	Output:	none					*/
     1036 /*							*/
     1037 /**********************************************************************/
     1038 
     1039 declare	new_name_ptr	ptr;			/* to an ACC string */
     1040 declare	name_length	fixed bin;
     1041 declare	new_name		char (name_length) aligned based;
     1042 
     1043 	name_offset = xoffset + def_growth;
     1044 	addrel (defbase, name_offset) -> new_name = new_name_ptr -> new_name;
     1045 	def_growth = def_growth + divide (name_length + 3, 4, 17, 0);
     1046 
     1047 	map_lng = map_lng + 1;
     1048 	strm.entry (map_lng).map = bit (name_offset, 18);
     1049 	call strm_hash_$make_entry (new_name_ptr -> new_name, map_lng);
     1050 
     1051 	return;
     1052 
     1053      end;
     1054 
     1055 
     1056 add_extension:
     1057      proc;
     1058 
     1059 /**********************************************************************/
     1060 /*							*/
     1061 /*	Name:	add_extension				*/
     1062 /*	Input:	init_entry_ptr, extension_size		*/
     1063 /*	Function:	adds a list_template entry to the list template	*/
     1064 /*		initialization to add <extension_size> zero words	*/
     1065 /*		to the end of the initialization		*/
     1066 /*	Output:	none					*/
     1067 /*							*/
     1068 /**********************************************************************/
     1069 
     1070 /* add the extension to skip the required number of bits	*/
     1071 
     1072 	init_entry_ptr -> list_template_entry.n_bits = extension_size * 36;
     1073 	init_entry_ptr -> list_template_entry.repeat = 0;
     1074 
     1075 /* append the end-of-list-template marker (n_bits = 0)	*/
     1076 
     1077 	addrel (init_entry_ptr, size (list_template_entry)) -> list_template_entry.n_bits = 0;
     1078 
     1079 /* adjust the length of the template	*/
     1080 
     1081 	cur_init_info_ptr -> link_init_list_template.n_words_in_list =
     1082 	     cur_init_info_ptr -> link_init_list_template.n_words_in_list + size (list_template_entry);
     1083 	cur_init_info_ptr -> link_init_list_template.header.n_words = init_map (mapx).total_init_size;
     1084 
     1085 
     1086 	return;
     1087 
     1088      end;
     1089 
  1     1 
  1     2 	/* the following is include file extref.incl.pl1  */
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  1     7*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  1     8*     changed to be a complete structure rather than a starting with a level 2
  1     9*     variable.
  1    10*                                                   END HISTORY COMMENTS */
  1    11 
  1    12 declare	1 external_ref aligned based,
  1    13 	2 compent_ptr pointer,		/* pointer to referencing component's entry */
  1    14 	2 ref_ptr pointer,			/* pointer to referencing textword */
  1    15 	2 offset fixed bin(18),		/* offset of referencing instruction in text */
  1    16 	2 side char(3) aligned,		/* 'rhe' or 'lhe' for referencing halfword */
  1    17 	2 relinfo char(8) aligned,		/* symbolic relocation information */
  1    18 	2 section char(4) aligned,		/* referencing section of object */
  1    19 	2 loffset fixed bin,		/* link's offset in linkage section */
  1    20 	2 segname char(33) aligned,		/* segname part of external name */
  1    21 	2 slng fixed bin,			/* length of preceeding ACC string (incl count) */
  1    22 	2 entryname char(257) aligned,		/* entry part of external name */
  1    23 	2 elng fixed bin,			/* length of preceeding ACC string (incl count) */
  1    24 	2 type bit(18) unaligned,		/* type of link */
  1    25 	2 trap bit(18) unaligned,		/* trap before link if non-zero */
  1    26 	2 expr bit(18) unaligned,		/* the expression value */
  1    27 	2 code15 bit(18) unaligned,		/* if type of link is 1 or 5, this is the segbase code */
  1    28 	2 dont_prelink bit(1) unaligned,	/* if = "1" then dont snap internal link */
  1    29 	2 link_tm bit(2) unaligned,		/* the original link's TM modifier */
  1    30 	2 link_td bit(4) unaligned,		/* the original link's TD modifier */
  1    31 	2 dont_relocate bit (1) unaligned,	/* "1"b -> no referencing instruction */
  1    32 	2 padding(2) fixed bin;		/* to isolate from other variables */
     1090 
     1091 
  2     1 /****  START OF:	bindext.incl.pl1			 *  *  *  *  *  */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-06-14,Elhard), approve(86-06-14,MCR7198),
  2     6*     audit(86-06-30,Weaver):
  2     7*     Added declarations for bx_$caller and bx_$temp_bsegp.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 /* DECLARATION OF BINDER'S MAIN DATABASE */
  2    11 
  2    12 /* include file bindext.incl.pl1 */
  2    13 
  2    14 /* Modified Sept 1978 by David Spector for using "get_temp_segment_" in temp_mgr_ */
  2    15 /* Modified Dec 1978 by David Spector for making repatch table automatically extensible */
  2    16 /* Modified 01/15/81 W. Olin Sibert for new options */
  2    17 
  2    18 declare  bx_$vers_name char (168) aligned external;	/* ASCII version name, in ACC form */
  2    19 declare  bx_$vers_number fixed bin external;		/* integer part of version number */
  2    20 declare  bx_$size fixed bin external;			/* size of main data base, for resetting */
  2    21 declare  bx_$snt_limit fixed bin external;		/* preset limit for segname table */
  2    22 declare  bx_$oddname_limit fixed bin external;		/* preset limit for oddname table */
  2    23 declare  bx_$stringmap_limit fixed bin external;		/* preset limit for stringmap table */
  2    24 declare  bx_$addname_limit fixed bin external;		/* preset limit for addname table */
  2    25 declare  bx_$area_begin fixed bin (18) external;		/* beginning of main data base */
  2    26 declare  bx_$ctp pointer external;			/* pointer to component table */
  2    27 declare  bx_$freep pointer external;			/* pointer to beginning of free area */
  2    28 declare  bx_$isp pointer external;			/* pointer to first insym table */
  2    29 declare  bx_$inpp pointer external;			/* pointer to binder's input structure */
  2    30 declare  bx_$bsegp pointer external;			/* pointer to base of new object segment */
  2    31 declare  bx_$temp pointer external;			/* pointer to threaded list of temp segments */
  2    32 declare  bx_$optp pointer external;			/* pointer to options table */
  2    33 declare  bx_$odnp pointer external;			/* pointer to oddname table */
  2    34 declare  bx_$first_rptp pointer external;		/* pointer to first chunk of repatch table */
  2    35 declare  bx_$last_rptp pointer external;		/* pointer to current chunk of threaded repatch table */
  2    36 declare  bx_$adnp pointer external;			/* pointer to addname table */
  2    37 declare  bx_$bindmap_def pointer external;		/* pointer to new object's "bind_map" definition */
  2    38 declare  bx_$bdefp pointer external;			/* pointer to new object's definition section */
  2    39 declare  bx_$bstatp pointer external;			/* pointer to new object's static section */
  2    40 declare  bx_$blnkp pointer external;			/* pointer to new object's linkage section */
  2    41 declare  bx_$bsymp pointer external;			/* pointer to new object's symbol section */
  2    42 declare  bx_$sntp pointer external;			/* pointer to segname table */
  2    43 declare  bx_$tdefp pointer external;			/* pointer to temporary new definition section */
  2    44 declare  bx_$tintp pointer external;			/* pointer to temporary new internal static */
  2    45 declare  bx_$tlinkp pointer external;			/* pointer to temporary new linkage section */
  2    46 declare  bx_$strmp pointer external;			/*  pointer to stringmap table */
  2    47 declare  bx_$n_firstrefs fixed bin external;		/* count of components with firstref traps */
  2    48 declare  bx_$bound_segname char (32) aligned external;	/* name of new bound object */
  2    49 declare  bx_$fatal_error fixed bin external;		/* 1 -> fatal error was detected */
  2    50 declare  bx_$bseg_acinfop pointer external;		/* new object's acinfop for "tssi_" */
  2    51 declare  bx_$bseg_bitcount fixed bin (24) external;	/* new object's bitcount */
  2    52 declare  bx_$o_lng fixed bin (19) external;		/* length of new bound object */
  2    53 declare  bx_$t_lng fixed bin (18) external;		/* length of new text section */
  2    54 declare  bx_$d_lng fixed bin (18) external;		/* length of new definition section */
  2    55 declare  bx_$i_lng fixed bin external;			/* length of new static section */
  2    56 declare  bx_$l_lng fixed bin external;			/* length of new linkage section */
  2    57 declare  bx_$s_lng fixed bin (18) external;		/* length of new symbol section */
  2    58 declare  bx_$addname fixed bin external;		/* 1 -> addname option specified */
  2    59 declare  bx_$debug fixed bin external;			/* 1 -> debug option was specified */
  2    60 declare  bx_$brief fixed bin external;			/* 1 -> brief option was specified */
  2    61 declare  bx_$force_order fixed bin external;		/* 1 -> -force_order specified on command line */
  2    62 declare  bx_$has_sep_stat fixed bin external;		/* 1 -> a comp has nonzero sep static */
  2    63 declare  bx_$has_comb_stat fixed bin external;		/* 1 -> a comp has nonzero combined static */
  2    64 declare  bx_$bound_sep_stat fixed bin external;		/* 1 -> bound segment has separate static */
  2    65 declare  bx_$perprocess_static fixed bin external;	/* 1 -> bound segment has perprocess static switch on */
  2    66 declare  bx_$standard fixed bin external;		/* 1 -> bound seg is in standard format */
  2    67 declare  bx_$bproc fixed bin external;			/* 1 -> at least one component is a procedure */
  2    68 declare  bx_$textlng fixed bin (18) external;		/* length of new pure text portion */
  2    69 declare  bx_$curdeflng fixed bin (18) external;		/* current length of new definition section */
  2    70 declare  bx_$tintlng fixed bin external;		/* current length of new internal static */
  2    71 declare  bx_$maxlinklng fixed bin external;		/* maximum size linkage section may attain */
  2    72 declare  bx_$maxdeflng fixed bin (18) external;		/* maximum size definition section may attain */
  2    73 declare  bx_$tlinklng fixed bin external;		/* current size of linkage section */
  2    74 declare  bx_$ncomp fixed bin external;			/* number of component objects to be bound */
  2    75 declare  bx_$v_lng fixed bin external;			/* length of version name string */
  2    76 declare  bx_$n_lng fixed bin external;			/* length of bound segment name string */
  2    77 declare  bx_$nsymdefs fixed bin external;		/* count of non-null symbol definitions */
  2    78 declare  bx_$nsegdefs fixed bin external;		/* count of non-null segment name definitions */
  2    79 declare  bx_$temp_bsegp ptr external;			/* pointer to the temporary bound seg in the process dir */
  2    80 declare  bx_$caller char (32) aligned external;		/* name of the caller of bind_ for error messages */
  2    81 
  2    82 /****  END OF:	bindext.incl.pl1			 *  *  *  *  *  */
     1092 
     1093 
  3     1 	/* Include file comptbl.incl.pl1 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  3     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  3     7*     added link_regeneration_table pointer (clrtp) to component structure.
  3     8*                                                   END HISTORY COMMENTS */
  3     9 
  3    10 declare	(ctp, ctep) pointer;
  3    11 
  3    12 declare	comp_tbl(1000) pointer based(ctp);
  3    13 
  3    14 
  3    15 
  3    16 declare	1 comp aligned based(ctep),		/* declaration of a component entry */
  3    17 	2 filename char(32) aligned,		/* object segment's file name */
  3    18 	2 compiler char(8) aligned,		/* name of compiler which produced this object */
  3    19 	2 format char(8) aligned,		/* format of object code (PL/1, ALM etc.)  */
  3    20 
  3    21 	2 ctxtp pointer,			/* pointer to base of text section */
  3    22 	2 cdefp pointer,			/* pointer to definitions */
  3    23 	2 cstatp pointer,			/* pointer to static section */
  3    24 	2 clnkp pointer,			/* pointer to head of linkage section */
  3    25 	2 csymp pointer,			/* pointer to symbol table */
  3    26 	2 cfrtp pointer,			/* pointer to first ref trap array */
  3    27 	2 crltp pointer,			/* pointer to rel-text */
  3    28 	2 crllp pointer,			/* pointer to rel-link */
  3    29 	2 crlsp pointer,			/* pointer to rel-symb */
  3    30 	2 insymentp pointer,		/* pointer to this component's insym table entry */
  3    31 	2 clrtp pointer,			/* pointer to link_regeneration_table */
  3    32 	2 unused_1 pointer,			/* reserve */
  3    33 	2 unused_2 pointer,			/* reserve */
  3    34 	2 unused_3 fixed bin,		/* reserve */
  3    35 	2 cindex fixed bin,			/* this entry's index in table */
  3    36 	2 standard_object fixed bin,		/* 1 -> this object has standard format */
  3    37 	2 defthread fixed bin,		/* beginning of comp's definition block */
  3    38 	2 fn_lng fixed bin,			/* length of filename string */
  3    39 	2 ignore fixed bin,			/* 1->ignore erroneous entry */
  3    40 	2 io_table fixed bin,		/* 1 -> symbol table needed for io */
  3    41 	2 table_deleted fixed bin,		/* 1 -> symbol table is being deleted */
  3    42 	2 separate_static fixed bin,		/* 1 -> component has nonzero separate static */
  3    43          (2 defblockp,			/* rel pointer to component's definition block */
  3    44 	2 current_def) bit(18) unaligned,	/* rel pointer to component's current def */
  3    45 	2 cbitcount fixed bin(24),		/* bitcount of component segment */
  3    46 	2 clngt fixed bin(18),		/* length of pure text section */
  3    47 	2 cpadt fixed bin,			/* number of added padwords for text */
  3    48 	2 clngd fixed bin(18),		/* length of definition section */
  3    49 	2 clngi fixed bin,			/* length of internal static */
  3    50 	2 cpadi fixed bin,			/* number of added padwords for internal static  */
  3    51 	2 clngs fixed bin(18),		/* length of original symbol table */
  3    52 	2 clngns fixed bin(18),		/* length of new symb section stripped of relbits */
  3    53 	2 clngss fixed bin(18),		/* length of symbol section minus relbits and table */
  3    54 	2 cpads fixed bin,			/* padding length if section length is odd */
  3    55 	2 n_sym_blks fixed bin,		/* number of symbol blocks */
  3    56 
  3    57 	2 crelt fixed bin,			/* relocation value for text */
  3    58 	2 creli fixed bin,			/* relocation value for internal static */
  3    59 	2 crels fixed bin,			/* relocation value for symbol section */
  3    60 	2 last_item fixed bin;		/*** MUST ALWAYS BE LAST IN STRUCTURE ***/
  3    61  
  3    62 
  3    63 
     1094 
     1095 
  4     1 	/* Include file bndtbl.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  4     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  4     7*     Added link_regeneration_table and eliminated the use of "p" as a pointer
  4     8*     to base structures on..
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 	/* DIVERSE BINDER TABLES */
  4    12 
  4    13 	/* Modified Oct 1978 by David Spector for hash coding snt and strm */
  4    14 	/* Modified Dec 1978 by David Spector for making repatch table
  4    15*	   automatically extensible */
  4    16 	
  4    17 declare	(sntp, adnp, odnp, rptp, rptep, strmp, lrtp) pointer;
  4    18 
  4    19 	/* The SEGNAME table  -  segnames and synonyms of all components */
  4    20 
  4    21 declare	1 snt aligned based(sntp),
  4    22 	2 hash_table (0:210) unaligned ptr,	/* prime length */
  4    23 	2 max_size fixed bin,		/* size limit of allocated segname table */
  4    24 	2 n_names fixed bin,		/* number of segname-table entries used */
  4    25 	2 entry(1000) like seg;
  4    26 
  4    27 	/* declaration of a SEGNAME entry */
  4    28 
  4    29 declare	1 seg aligned based,		/* redeclaration of a single segname */
  4    30 	  2 name char(33) aligned,		/* segname in ACC string format */
  4    31 	  2 lng fixed bin,			/* length of segname, incl ACC count */
  4    32 	  2 addname fixed bin,		/* 1-> add name to bound segment */
  4    33 	  2 defrel bit(18),			/* offset in defs of new definition */
  4    34 	  2 comp pointer,			/* pointer to associated component table */
  4    35 	  2 hash_thread ptr;		/* thread to next "seg" in bucket */
  4    36 
  4    37 
  4    38 	/* the ADDNAME table  - list of names specified by "Addname" statement */
  4    39 
  4    40 declare	1 an aligned based(adnp),
  4    41 	2 max_size fixed bin,		/* size limit of addname table */
  4    42 	2 n_an fixed bin,			/* number of names to add */
  4    43 	2 syn(1000) char(32) aligned;		/* contains the names to be added */
  4    44 
  4    45 
  4    46 	/* The ODDNAME table  -  scratchpad memory to suppress redundant error messages */
  4    47 
  4    48 declare	1 od aligned based(odnp),
  4    49 	2 max_size fixed bin,		/* max size of table */
  4    50 	2 n_odds fixed bin,			/* current size of table */
  4    51 	2 entry(1000),
  4    52 	  3 name char(289) aligned;
  4    53 
  4    54 
  4    55 	/* The REPATCH table  -  of halfwords to be relocated at a later time */
  4    56 
  4    57 declare	1 rpt aligned based(rptp),
  4    58 	2 thread unaligned ptr,			/* To next rpt (null at end) */
  4    59 	2 npt fixed bin,
  4    60 	2 entry(1000) like rpte aligned;
  4    61 
  4    62 
  4    63 declare	1 rpte aligned based(rptep),		/* declaration of single repatch table entry */
  4    64 	2 poffset bit(18) unaligned,		/* offset into text of word to be patched */
  4    65 	2 pexpr bit(18) unaligned,		/* value to add to patched halfword */
  4    66 	2 halfword char(3) aligned,		/* designates wordhalf to be patched */
  4    67 	2 pbase char(1) unaligned,		/* section designator of word to be patched */
  4    68 	2 code char(1) unaligned;		/* code of section base to be used as patch value */
  4    69 
  4    70 
  4    71 	/* The STRINGMAP table - to avoid redundant strings in definition section */
  4    72 
  4    73 declare	1 strm aligned based(strmp),
  4    74 	2 hash_table (0:862) fixed bin(17),	/* prime length */
  4    75 	2 max_size fixed bin,
  4    76 	2 nstr fixed bin,
  4    77 	2 entry(2048) unaligned,
  4    78 	  3 map bit(18),			/* rel pointer to string in def section */
  4    79 	  3 hash_thread fixed bin(17);	/* index of next strm.entry in hash bucket */
  4    80 
  4    81 	/* The LINK_REGENERATION table - to flag links which have and  */
  4    82 	/* have not been regenerated to insure generation of all links */
  4    83 	
  4    84 declare	1 lrt		aligned based (lrtp),
  4    85 	  2 count		fixed bin,
  4    86 	  2 start_offset	fixed bin (18) unsigned,
  4    87 	  2 regenerated (0 refer (lrt.count))
  4    88 			bit (18) unaligned;
  4    89 
  4    90 declare	UNRESOLVED	bit (18) static options (constant) init ("000000"b3);
  4    91 declare	INTERNALLY_RESOLVED	bit (18) static options (constant) init ("777777"b3);
     1096 
     1097 
  5     1 /* Begin include file definition_dcls.incl.pl1 BIM 1981 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  5     6*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  5     7*     Modified to add indirect bit to definition flags, add msf_map_relp to the
  5     8*     definition header, declare the msf_map, and add structures and constants
  5     9*     for deferred initialization.
  5    10*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420),
  5    11*     audit(86-08-05,Schroth), install(86-11-20,MR12.0-1222):
  5    12*     added the structures for pointer initialization. pointer_init_template.
  5    13*     changed list_template_entry
  5    14*                                                   END HISTORY COMMENTS */
  5    15 
  5    16 
  5    17 /* Modified:  */
  5    18 /*   13 Dec 1982 by Lee A. Newcomb to put definition_header.hash_table_relp */
  5    19 /*	after unused half-word instead of before it. */
  5    20 /*   1 March 1983 by M. Weaver to add list template init type */
  5    21 
  5    22 /* format: style3,idind25 */
  5    23 /* everything for the definition section */
  5    24 
  5    25 declare	(
  5    26 	CLASS_TEXT	     init (0),		/* text section definition */
  5    27 	CLASS_LINKAGE	     init (1),		/* linkage section definition */
  5    28 	CLASS_SYMBOL	     init (2),		/* symbol section definition */
  5    29 	CLASS_SEGNAME	     init (3),		/* segment name definition */
  5    30 	CLASS_STATIC	     init (4),		/* static section definition */
  5    31 	CLASS_SYSTEM	     init (5),		/* valid only in self links, not def class */
  5    32 	CLASS_HEAP	     init (6)		/* valid only in self links, not def class */
  5    33 	)		     fixed bin (3) unsigned internal static options (constant);
  5    34 
  5    35 declare	CLASS_NAMES	     (0:6) character (12) internal static options (constant)
  5    36 			     init ("text", "linkage", "symbol", "segname", "static", "system", "heap");
  5    37 
  5    38 declare	SYMBOLIC_SECTION_NAMES   (0:6) character (8)
  5    39 			     init ("*text", "*link", "*symbol", *, "*static", "*system", "*heap") internal static
  5    40 			     options (constant);
  5    41 
  5    42 declare	1 definition_flags	     unaligned based,
  5    43 	  2 new		     bit (1),		/* should be "1"b */
  5    44 	  2 ignore	     bit (1),		/* cannot snap link to this */
  5    45 	  2 entry		     bit (1),		/* can tra here */
  5    46 	  2 retain	     bit (1),		/* binder respects this */
  5    47 	  2 argcount	     bit (1),		/* OBSOLETE */
  5    48 	  2 descriptors	     bit (1),		/* OBSOLETE */
  5    49 	  2 indirect	     bit (1),		/* target is a pointer to actual target */
  5    50 	  2 unused	     bit (8);		/* Must be zero */
  5    51 
  5    52 
  5    53 
  5    54 
  5    55 /* Header of the definition section */
  5    56 
  5    57 declare	def_header_ptr	     pointer;
  5    58 declare	1 definition_header	     aligned based (def_header_ptr),
  5    59 	  2 def_list_relp	     fixed bin (18) unsigned unaligned,
  5    60 						/* first definition, reloc def18 */
  5    61 	  2 msf_map_relp	     fixed bin (18) unsigned unaligned,
  5    62 						/* msf_map if any, or 0 if none.  reloc def18 unless none */
  5    63 	  2 hash_table_relp	     fixed bin (18) unsigned unaligned,
  5    64 						/* def hash table, if any, or 0 if none. reloc def18 unless none */
  5    65 	  2 flags		     unaligned like definition_flags;
  5    66 						/* both new and ignore must be "1"b here */
  5    67 
  5    68 /* A non class=3 definition. See segname_definition below for class=3 */
  5    69 
  5    70 
  5    71 declare	def_ptr		     pointer;
  5    72 declare	1 definition	     aligned based (def_ptr),
  5    73 	  2 forward_relp	     unal fixed bin (18) unsigned,
  5    74 						/* offset of next def */
  5    75 	  2 backward_relp	     unal fixed bin (18) unsigned,
  5    76 						/* offset of previous def */
  5    77 	  2 thing_relp	     unal fixed bin (18) unsigned,
  5    78 						/* offset in section specified by class of thing this defines */
  5    79 	  2 flags		     unaligned like definition_flags,
  5    80 	  2 class		     unal fixed bin (3) unsigned,
  5    81 						/* Type of definition */
  5    82 	  2 name_relp	     unal fixed bin (18) unsigned,
  5    83 						/* offset of ACC for symbol */
  5    84 	  2 segname_relp	     unal fixed bin (18) unsigned;
  5    85 						/* offset of segname def to which this belongs */
  5    86 
  5    87 /* Class=3, segname definition */
  5    88 
  5    89 declare	segname_ptr	     pointer;
  5    90 declare	1 segname_definition     aligned based (segname_ptr),
  5    91 	  2 forward_relp	     unal fixed bin (18) unsigned,
  5    92 						/* offset of next def */
  5    93 	  2 backward_relp	     unal fixed bin (18) unsigned,
  5    94 						/* offset of previous def */
  5    95 	  2 next_segname_relp    unal fixed bin (18) unsigned,
  5    96 						/* offset of next segname def */
  5    97 	  2 flags		     unaligned like definition_flags,
  5    98 	  2 class		     unal fixed bin (3) unsigned,
  5    99 						/* 3 for segname */
  5   100 	  2 name_relp	     unal fixed bin (18) unsigned,
  5   101 						/* offset of ACC for symbol */
  5   102 	  2 first_relp	     unal fixed bin (18) unsigned;
  5   103 						/* see following : */
  5   104 
  5   105 /* Definition blocks are chained off of segname definitions.
  5   106*   segname_definition.first_relp is one of three things:
  5   107*    (1) the def section offset of the first ordinary (class^=3) definition
  5   108*      belonging to this segname block. In the case where there are more than
  5   109*      one segname's on a block, all their first_relp will point
  5   110*      to the same place.
  5   111*
  5   112*    (2) if there are no ordinary definitions associated with this segname,
  5   113*      then it is the def section offset of the next segname. 
  5   114*
  5   115*    (3) if there are no ordinary definitions in the block, and it
  5   116*      is the last block, then it points to a word containing 0.
  5   117*
  5   118* Thus the end of a list of synonym segnames can be detected by forward_relp
  5   119*   pointing to a class=3 definition whose first_relp is not the same as
  5   120*   the current definitions first_relp.
  5   121**/
  5   122 
  5   123 /* All the definitions are linked through the forward and
  5   124*   backward thread variables. The end of the chain can is indicated
  5   125*   by forward pointing to a zero word. */
  5   126 
  5   127 
  5   128 declare	exp_ptr		     pointer;
  5   129 declare	1 exp_word	     based (exp_ptr) aligned, /* expression word in link definition */
  5   130 	  2 type_relp	     fixed bin (18) unsigned unal,
  5   131 						/* pointer (rel to defs) of type pair structure */
  5   132 	  2 expression	     fixed bin (17) unal;	/* constant expression to be added in when snapping link */
  5   133 
  5   134 declare	(
  5   135 	LINK_SELF_BASE	     init (1),		/* *section|0+expression,modifier */
  5   136 						/* which section determined by segname_relp */
  5   137 	LINK_OBSOLETE_2	     init (2),		/* not used */
  5   138 	LINK_REFNAME_BASE	     init (3),		/* refname|0+expression,modifier */
  5   139 	LINK_REFNAME_OFFSETNAME  init (4),		/* refname|offsetname+expression,modifier */
  5   140 	LINK_SELF_OFFSETNAME     init (5),		/* *section|offsetname+expression,modifier */
  5   141 	LINK_CREATE_IF_NOT_FOUND init (6),		/* OBSOLETE: like LINK_REFNAME_OFFSETNAME except that it will create instead of taking linkage_error */
  5   142 	SECTION_TEXT	     init (0),		/* *text */
  5   143 	SECTION_LINK	     init (1),		/* *link */
  5   144 	SECTION_SYMBOL	     init (2),		/* *symbol */
  5   145 	SECTION_UNUSED	     init (3),		/* reserved */
  5   146 	SECTION_STATIC	     init (4),		/* *static */
  5   147 	SECTION_SYSTEM	     init (5),		/* *system */
  5   148 	SECTION_HEAP	     init (6)		/* *heap */
  5   149 	)		     fixed bin (18) unsigned unaligned internal static options (constant);
  5   150 
  5   151 /* use CLASS_NAMES for section names */
  5   152 
  5   153 declare	LINK_TYPE_NAMES	     (1:6)
  5   154 			     init ("absolute in section", "unused", "absolute off of refname",
  5   155 			     "symbolic off of refname", "symbolic in section", "symbolic off of refname; create")
  5   156 			     character (32) varying internal static options (constant);
  5   157 
  5   158 
  5   159 declare	type_ptr		     pointer;
  5   160 declare	1 type_pair	     based (type_ptr) aligned,/* type pair in link definition */
  5   161 	  2 type		     fixed bin (18) unsigned unal,
  5   162 						/* see above */
  5   163 	  2 trap_relp	     fixed bin (18) unsigned unal,
  5   164 						/* pointer (rel to defs) to the trap word */
  5   165 						/* unless LINK_SELF_OFFSETNAME off of *system or create link */
  5   166 	  2 segname_relp	     fixed bin (18) unsigned unal,
  5   167 						/* pointer (rel to defs) to ACC reference name for segment referenced, 
  5   168* /*or section code for SELF links */
  5   169 	  2 offsetname_relp	     fixed bin (18) unsigned unal;
  5   170 						/* for OFFSETNAME links, ACC string of name of location. */
  5   171 						/* for others, must be ZERO */
  5   172 
  5   173 
  5   174 /* Link Trap Pair */
  5   175 
  5   176 declare	link_trap_ptr	     pointer;
  5   177 declare	1 link_trap_pair	     aligned based (link_trap_ptr),
  5   178 	  2 call_relp	     fixed bin (18) unsigned unaligned,
  5   179 						/* LINK18, link to thing to call */
  5   180 	  2 info_relp	     fixed bin (18) unsigned unaligned;
  5   181 						/* LINK18, link to argument list */
  5   182 
  5   183 
  5   184 /* initialization info for *system or *heap link */
  5   185 
  5   186 
  5   187 /* NOTE --------------------------------------------------
  5   188*   the following structures defining initialization information are also
  5   189*   defined in fortran_storage.incl.pl1  system_link_init_info.incl.pl1
  5   190*   and should be kept equivalent
  5   191*   -------------------------------------------------------
  5   192**/
  5   193 
  5   194 declare	(
  5   195 	INIT_NO_INIT	     init (0),
  5   196 	INIT_COPY_INFO	     init (3),
  5   197 	INIT_DEFINE_AREA	     init (4),
  5   198 	INIT_LIST_TEMPLATE	     init (5),
  5   199 	INIT_DEFERRED	     init (6)
  5   200 	)		     fixed bin internal static options (constant);
  5   201 
  5   202 /* for type = 0 or 4 */
  5   203 
  5   204 declare	link_init_ptr	     pointer;
  5   205 declare	1 link_init	     aligned based (link_init_ptr),
  5   206 	  2 n_words	     fixed bin (35),	/* number to invent */
  5   207 	  2 type		     fixed bin;		/* see types above */
  5   208 
  5   209 /* for type=3, there is data to copy */
  5   210 
  5   211 declare	1 link_init_copy_info    aligned based (link_init_ptr),
  5   212 	  2 header	     aligned like link_init,
  5   213 	  2 initial_data	     (link_init_n_words refer (link_init_copy_info.header.n_words)) bit (36) aligned;
  5   214 
  5   215 declare	link_init_n_words	     fixed bin;
  5   216 
  5   217 /* for type = 5, there is a list template to copy */
  5   218 
  5   219 declare	1 link_init_list_template
  5   220 			     aligned based (link_init_ptr),
  5   221 	  2 header	     aligned like link_init,
  5   222 	  2 pad		     bit (18) unaligned,
  5   223 	  2 n_words_in_list	     fixed bin (18) unsigned unaligned,
  5   224 	  2 template	     (link_init_n_words_in_list refer (link_init_list_template.n_words_in_list));
  5   225 
  5   226 declare	link_init_n_words_in_list
  5   227 			     fixed bin;
  5   228 
  5   229 /* A list template consists of a series of entries with the following
  5   230*   description, concatenated together.  n_bits and datum are bit items,
  5   231*   to permit a wide range of inputs.
  5   232*
  5   233*   1.  A 'repeat' of '0' signifies skipping of 'n_bits' bits.
  5   234*   2.  A 'n_bits' of '0' signifies the last item of the list.
  5   235*
  5   236*   COMMON, VLA's, and LA's are presumed to start at the base pointer
  5   237*   of their particular storage section. */
  5   238 
  5   239 declare	1 list_template_entry    aligned based,
  5   240 	  2 n_bits	     fixed bin (35) aligned,	/* size of datum */
  5   241 	  2 mbz		     bit (3) unaligned,	/* future expansion */
  5   242 	  2 init_type	     fixed bin (3) unsigned unaligned, /* 0 normal init, 1 ptr init, 2 packed ptr init */
  5   243 	  2 repeat	     fixed bin (30) unsigned unaligned,
  5   244 						/* number of times to repeat datum */
  5   245 	  2 datum		     bit (link_init_n_bits_in_datum refer (list_template_entry.n_bits));
  5   246 
  5   247 
  5   248 /* the pointer_init_template represents the initialization information
  5   249*   for ITS and packed pointers.  Both pointer types require the entire
  5   250*   72 bit structure.
  5   251**/
  5   252 
  5   253 dcl       1 pointer_init_template  based,
  5   254 	  2 ptr_type	     fixed bin (18) unsigned unaligned,  /* 0 text section, 1 linkage section, 2 static section */
  5   255 	  2 section_offset	     fixed bin (18) unsigned unaligned,  /* offset to item in specified section */
  5   256 	  2 word_offset	     fixed bin (18) unsigned unaligned,  /* offset from section item to target in words */
  5   257 	  2 mbz		     bit (12) unaligned,
  5   258 	  2 bit_offset	     fixed bin (6) unsigned unaligned;   /* offset from section item|word offset to target in bits */
  5   259 
  5   260 
  5   261 declare	link_init_n_bits_in_datum
  5   262 			     fixed bin (35);
  5   263 
  5   264 /* for type = 6, the init_info resides in another MSF component */
  5   265 /* target_relp is a linkage section offset to a partial link to */
  5   266 /* the base of the linkage section of the component containing  */
  5   267 /* the actual init_info. link_relp is the offset of the actual  */
  5   268 /* link within that linkage section.			    */
  5   269 
  5   270 declare	1 link_init_deferred     aligned based (link_init_ptr),
  5   271 	  2 header	     aligned like link_init,
  5   272 	  2 target_relp	     fixed bin (18) unsigned unaligned,
  5   273 	  2 link_relp	     fixed bin (18) unsigned unaligned;
  5   274 
  5   275 /* Definition section hash table */
  5   276 
  5   277 declare	def_ht_ptr	     pointer;
  5   278 declare	1 definition_ht	     aligned based (def_ht_ptr),
  5   279 	  2 n_entries	     fixed bin,
  5   280 	  2 table		     (def_ht_n_entries refer (definition_ht.n_entries)) aligned,
  5   281 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  5   282 	    3 unused	     bit (18) unaligned;
  5   283 
  5   284 declare	def_ht_n_entries	     fixed bin;
  5   285 
  5   286 
  5   287 /* Component name ht */
  5   288 declare	comp_ht_ptr	     pointer;
  5   289 declare	1 component_ht	     aligned based (comp_ht_ptr),
  5   290 	  2 n_entries	     fixed bin,
  5   291 	  2 table		     (comp_ht_n_entries refer (component_ht.n_entries)) aligned,
  5   292 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  5   293 						/* hashed segname */
  5   294 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  5   295 						/* first segname def of block containing def_relp */
  5   296 
  5   297 declare	comp_ht_n_entries	     fixed bin;
  5   298 
  5   299 /* Duplicate name table */
  5   300 
  5   301 declare	dup_table_ptr	     pointer;
  5   302 declare	1 duplicate_table	     aligned based (dup_table_ptr),
  5   303 	  2 mbz		     bit (18) unaligned,	/* to tell it from a definition */
  5   304 	  2 n_names	     fixed bin (18) unsigned unaligned,
  5   305 						/* n in table */
  5   306 	  2 table		     (dup_table_n_names refer (duplicate_table.n_names)) aligned,
  5   307 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  5   308 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  5   309 
  5   310 declare	dup_table_n_names	     fixed bin;
  5   311 
  5   312 /* The msf_map is found in the definition section of an	*/
  5   313 /* object MSF component.  It is used by the linker to	*/
  5   314 /* determine whether a segment is a component of an object	*/
  5   315 /* MSF or a standard single-segment object.		*/
  5   316   
  5   317   dcl msf_map_ptr		ptr;
  5   318   dcl 01 msf_map		aligned based (msf_map_ptr),
  5   319        02 version		char (8),
  5   320        02 component_count	fixed bin (15) unsigned,
  5   321        02 my_component	fixed bin (15) unsigned;
  5   322   
  5   323   dcl msf_map_version_1	char (8) static options (constant)
  5   324 			     init ("msfmp1.0");
  5   325   
  5   326 declare	acc_string_ptr	     pointer;
  5   327 declare	1 acc_string	     aligned based (acc_string_ptr),
  5   328 	  2 count		     fixed bin (9) unsigned unaligned,
  5   329 	  2 string	     character (max (3, acc_string_length) refer (acc_string.count)) unaligned,
  5   330 	  2 mbz		     bit (0) aligned;	/* this causes the statement */
  5   331 						/* unspec (acc_string) = ""b to zero out */
  5   332 						/* the last word, if the string is not of length 0mod4 */
  5   333 
  5   334 declare	acc_string_length	     fixed bin (21);
  5   335 
  5   336 
  5   337 /* end include file definitions_dcls.incl.pl1 */
     1098 
     1099 
  6     1 /* BEGIN INCLUDE FILE object_link_dcls.incl.pl1 BIM 1981 from linkdcl */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  6     6*     audit(86-11-18,Schroth), install(86-11-20,MR12.0-1222):
  6     7*     Modified to add partial_link structure for an object MSF partially snapped
  6     8*     link.
  6     9*  2) change(86-11-13,DGHowe), approve(86-11-13,MCR7391), audit(86-11-13,Zwick),
  6    10*     install(86-11-20,MR12.0-1222):
  6    11*     Added a declaration of FAULT_TAG_1, FAULT_TAG_2 and FAULT_TAG_3.
  6    12*                                                   END HISTORY COMMENTS */
  6    13 
  6    14 
  6    15 /* format: style3 */
  6    16 /* everything you ever wanted in a linkage section */
  6    17 
  6    18 /*
  6    19* Last Modified (Date and Reason):
  6    20*  15 Nov 1971 by C Garman 
  6    21*   6/75 by M.Weaver to add virgin_linkage_header declaration
  6    22*   6/75 by S.Webber to comment existing structures better
  6    23*   9/77 by M. Weaver to add run_depth to link
  6    24*   7/81 by B. Margulies for firstref structure, unsigned fixed bins.
  6    25*   3/83 by M. Weaver to add flags overlaying def_ptr
  6    26**/
  6    27 
  6    28 declare	1 object_link	based aligned,		/* link pair in linkage section */
  6    29 	  2 header_relp	fixed bin (17) unal,	/* rel pointer to beginning of linkage, always negative */
  6    30 	  2 ringno	fixed bin (3) unsigned unal,	/* MBZ */
  6    31 	  2 mbz		bit (6) unal,
  6    32 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  6    33 	  2 tag		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  6    34 	  2 expression_relp fixed bin (18) unsigned unal, /* pointer (rel to defs) of expression word */
  6    35 	  2 mbz2		bit (12) unal,
  6    36 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  6    37 
  6    38 declare	1 partial_link	based aligned,		/* partially snapped link */
  6    39 	  2 type		fixed bin (3) unsigned unal,	/* target section of link */
  6    40 	  2 component	fixed bin (15) unsigned unal,	/* target component index */
  6    41 	  2 mbz1		bit (12) unal,
  6    42 	  2 tag		bit (6) unal,		/* fault tag 3 47(8), ITS 43(8) if snapped */
  6    43 	  
  6    44 	  2 offset	fixed bin (18) unsigned unal,	/* word offset of link */
  6    45 	  2 mbz2		bit (3) unal,
  6    46 	  2 bit_offset	fixed bin (6) unsigned unal,	/* bit offset (in practice, always 0) */
  6    47 	  2 mbz3		bit (3) unal,
  6    48 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  6    49 
  6    50 declare	1 linkage_header	based aligned,		/* linkage block header */
  6    51 	  2 def_ptr	ptr,			/* pointer to definition section */
  6    52 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  6    53 	  2 original_linkage_ptr
  6    54 			ptr unal,			/* pointer to linkage section in object segment */
  6    55 	  2 unused	bit (72),
  6    56 	  2 stats,
  6    57 	    3 begin_links	fixed bin (18) unsigned unal, /* offset (rel to this section) of first link */
  6    58 	    3 block_length	fixed bin (18) unsigned unal, /* number of words in this linkage section */
  6    59 	    3 segment_number
  6    60 			fixed bin (18) unsigned unal, /* text segment number associated with this section */
  6    61 	    3 static_length fixed bin (18) unsigned unal; /* number of words of static for this segment */
  6    62 
  6    63 declare	1 linkage_header_flags
  6    64 			aligned based,		/* overlay of def_ptr for flags */
  6    65 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  6    66 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  6    67 	  2 perprocess_static
  6    68 			bit (1) unaligned,		/* 1 copy of static section is shared among all tasks/run units */
  6    69 	  2 pad2		bit (6) unaligned;
  6    70 
  6    71 declare	1 virgin_linkage_header
  6    72 			aligned based,		/* template for linkage header in object segment */
  6    73 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  6    74 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  6    75 	  2 def_offset	fixed bin (18) unsigned unaligned,
  6    76 						/* offset of definition section */
  6    77 	  2 first_ref_relp	fixed bin (18) unsigned unaligned,
  6    78 						/* offset of trap-at-first-reference offset array */
  6    79 	  2 filled_in_later bit (144),
  6    80 	  2 link_begin	fixed bin (18) unsigned unaligned,
  6    81 						/* offset of first link */
  6    82 	  2 linkage_section_lng
  6    83 			fixed bin (18) unsigned unaligned,
  6    84 						/* length of linkage section */
  6    85 	  2 segno_pad	fixed bin (18) unsigned unaligned,
  6    86 						/* will be segment number of copied linkage */
  6    87 	  2 static_length	fixed bin (18) unsigned unaligned;
  6    88 						/* length of static section */
  6    89 
  6    90 declare	1 fr_traps	based aligned,		/* First Reference Trap Procedures */
  6    91 	  2 decl_vers	fixed bin,		/* version of this struc, value=1, ABS reloc */
  6    92 	  2 n_traps	fixed bin,		/* number of traps on this segment, ABS */
  6    93 	  2 trap_array	(n_fr_traps refer (fr_traps.n_traps)) aligned,
  6    94 	    3 call_relp	fixed bin (18) unsigned unaligned,
  6    95 						/* LINK18, offset of link defining procedure to call */
  6    96 	    3 info_relp	fixed bin (18) unsigned unaligned;
  6    97 						/* LINK18, offser of link defining argument list for trap proc */
  6    98 
  6    99 declare	FR_TRAPS_VERSION_1	init (1) fixed bin internal static options (constant);
  6   100 declare   FAULT_TAG_1	bit(6) unaligned init ("40"b3) static options (constant);
  6   101 declare   FAULT_TAG_2	bit(6) unaligned init ("46"b3) static options (constant);
  6   102 declare   FAULT_TAG_3	bit(6) unaligned init ("47"b3) static options (constant);
  6   103 
  6   104 /* END INCLUDE FILE object_link_dcls.incl.pl1 */
     1100 
     1101 
     1102 
     1103 
     1104      end;						/* of ext_link_ */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/20/86  1142.2  ext_link_.pl1                     >special_ldd>install>MR12.0-1222>ext_link_.pl1
1090         1    07/16/86  1222.1  extref.incl.pl1                   >ldd>include>extref.incl.pl1
1092         2    07/16/86  1222.1  bindext.incl.pl1                  >ldd>include>bindext.incl.pl1
1094         3    07/16/86  1222.1  comptbl.incl.pl1                  >ldd>include>comptbl.incl.pl1
1096         4    07/16/86  1222.1  bndtbl.incl.pl1                   >ldd>include>bndtbl.incl.pl1
1098         5    11/20/86  1035.3  definition_dcls.incl.pl1          >special_ldd>install>MR12.0-1222>definition_dcls.incl.pl1
1100         6    11/20/86  1035.4  object_link_dcls.incl.pl1         >special_ldd>install>MR12.0-1222>object_link_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
INIT_COPY_INFO                         constant        fixed bin(17,0)          initial dcl 5-194 ref 734 887 911
INIT_DEFINE_AREA                       constant        fixed bin(17,0)          initial dcl 5-194 ref 437 437 437 437
INIT_LIST_TEMPLATE                     constant        fixed bin(17,0)          initial dcl 5-194 ref 745 765 892 911
INTERNALLY_RESOLVED                    constant        bit(18)                  initial unaligned dcl 4-91 ref 242
LINK_CREATE_IF_NOT_FOUND               constant        fixed bin(18,0)          initial unsigned unaligned dcl 5-134 ref 288 422 832
LINK_REFNAME_BASE                      constant        fixed bin(18,0)          initial unsigned unaligned dcl 5-134 ref 266
LINK_SELF_BASE                         constant        fixed bin(18,0)          initial unsigned unaligned dcl 5-134 ref 347 355
LINK_SELF_OFFSETNAME                   constant        fixed bin(18,0)          initial unsigned unaligned dcl 5-134 ref 288 347 422
                                                                                  714 865 866
SECTION_LINK                           constant        fixed bin(18,0)          initial unsigned unaligned dcl 5-134 ref 351
SECTION_STATIC                         constant        fixed bin(18,0)          initial unsigned unaligned dcl 5-134 ref 351 360
SECTION_SYSTEM                         constant        fixed bin(18,0)          initial unsigned unaligned dcl 5-134 ref 288 422 867
SECTION_TEXT                           constant        fixed bin(18,0)          initial unsigned unaligned dcl 5-134 ref 358
UNRESOLVED                             constant        bit(18)                  initial unaligned dcl 4-90 ref 242
acc_string                             based           structure                level 1 dcl 5-327
addr                                                   builtin function         dcl 189 ref 299 337 454 536 536 545 545 607 681 749
                                                                                  838 858 869 870 873 874
addrel                                                 builtin function         dcl 189 ref 293 304 324 335 400 403 520 528 579 658
                                                                                  658 664 664 670 670 716 718 731 757 771 800 1044
                                                                                  1077
ap                              000266 automatic       pointer                  dcl 168 set ref 236* 237 241 248 248 260 264 275 275
                                                                                  276 277 288 293 299 301 301 302 303 304 305 306*
                                                                                  310* 313 315 317* 319* 337 345 380 380 380 380 389
                                                                                  389 389 389 536 536 536 542 542 545 545 545 566
                                                                                  589 593 595 595 597 599 607 609 609 681* 682 834
                                                                                  838 840 842 843 845 858
argument_pointer                       parameter       pointer                  dcl 131 ref 128 236 616
bin                                                    builtin function         dcl 189 ref 260 264 345 383 392 595 597 599 603 865
bit                                                    builtin function         dcl 189 ref 595 597 599 603 865 1048
bx_$bound_sep_stat              000206 external static fixed bin(17,0)          dcl 2-64 ref 351 364
bx_$brief                       000204 external static fixed bin(17,0)          dcl 2-60 ref 465
bx_$caller                      000220 external static char(32)                 dcl 2-80 ref 675
bx_$ctp                         000166 external static pointer                  dcl 2-26 ref 234
bx_$curdeflng                   000210 external static fixed bin(18,0)          dcl 2-69 set ref 333 334* 334 519 587* 587 678 731
                                                                                  742* 742 760* 760 776* 776 783* 783
bx_$debug                       000202 external static fixed bin(17,0)          dcl 2-59 ref 673
bx_$fatal_error                 000200 external static fixed bin(17,0)          dcl 2-49 set ref 443* 557* 611* 808*
bx_$freep                       000170 external static pointer                  dcl 2-27 ref 654 663 669
bx_$maxlinklng                  000214 external static fixed bin(17,0)          dcl 2-71 ref 655
bx_$strmp                       000176 external static pointer                  dcl 2-46 ref 235
bx_$tdefp                       000172 external static pointer                  dcl 2-43 ref 676
bx_$tintlng                     000212 external static fixed bin(17,0)          dcl 2-70 set ref 566*
bx_$tlinklng                    000216 external static fixed bin(17,0)          dcl 2-73 set ref 560 580* 651 651* 651 655
bx_$tlinkp                      000174 external static pointer                  dcl 2-45 ref 650
call_relp                              based           fixed bin(18,0)          level 2 in structure "link_trap_pair" packed
                                                                                  unsigned unaligned dcl 5-177 in procedure
                                                                                  "ext_link_" set ref 305
call_relp                       000422 automatic       fixed bin(18,0)          level 2 in structure "new_trap_pair" packed unsigned
                                                                                  unaligned dcl 181 in procedure "ext_link_" set ref
                                                                                  310*
cdefp                    16            based           pointer                  level 2 dcl 3-16 ref 293 304
class                           000115 automatic       fixed bin(18,0)          dcl 163 set ref 264* 288 349 351 358 360 422 867*
clrtp                    40            based           pointer                  level 2 dcl 3-16 ref 240
code15                  127(18)        based           bit(18)                  level 2 packed unaligned dcl 228 set ref 264 865*
com_err_                        000152 constant        entry                    external dcl 138 ref 440 555 566 609 718 800
comp                                   based           structure                level 1 dcl 3-16
compent_ptr                            based           pointer                  level 2 dcl 228 ref 237 566
convert                         000313 automatic       bit(1)                   dcl 173 set ref 831* 837* 848* 859* 863
copy_save                              based           fixed bin(17,0)          array dcl 222 set ref 299* 299 337* 337 607* 607
count                                  based           fixed bin(9,0)           level 2 packed unsigned unaligned dcl 5-327 set ref
                                                                                  716 718 718 800 800 838 858 869* 870 873* 874
creli                    74            based           fixed bin(17,0)          level 2 dcl 3-16 ref 367
crelt                    73            based           fixed bin(17,0)          level 2 dcl 3-16 ref 358
ctep                            000440 automatic       pointer                  dcl 3-10 set ref 237* 240 293 304 358 367 573 609
                                                                                  936
ctp                             000436 automatic       pointer                  dcl 3-10 set ref 234*
cur_init_info_ptr               000302 automatic       pointer                  dcl 170 set ref 731* 738 739 742 745 746 749 760 767
                                                                                  771 771 776 780 781 883* 885 887 892 1081 1081
                                                                                  1083
cur_init_map_index                     parameter       fixed bin(17,0)          unaligned dcl 993 ref 977 999 1016
currentsize                                            builtin function         dcl 189 ref 742 757 760 771 776
datum                     2            based           bit                      level 2 dcl 5-239 set ref 753*
decode_link_                    000146 constant        entry                    external dcl 136 ref 306 317
def_growth                      000101 automatic       fixed bin(17,0)          dcl 161 set ref 232* 344* 517* 530* 530 587 1043
                                                                                  1045* 1045
defbase                         000012 internal static pointer                  dcl 148 set ref 324 335 403 520 676* 716 718 731 791
                                                                                  800 1044
definition_flags                       based           structure                level 1 packed unaligned dcl 5-42
diff_init_size           13(01)        based           bit(1)                   array level 2 packed unaligned dcl 196 set ref 463
                                                                                  470* 576*
divide                                                 builtin function         dcl 189 ref 655 1045
dont_relocate           130(07)        based           bit(1)                   level 2 packed unaligned dcl 228 ref 589
elng                    125            based           fixed bin(17,0)          level 2 dcl 228 set ref 276 389 389 545* 840 875*
entry                  1541            based           structure                array level 2 packed unaligned dcl 4-73
entryname                24            based           char(257)                level 2 dcl 228 set ref 277 389 389 542 545 545 838
                                                                                  858 873 874
entryname_found                 000310 automatic       bit(1)                   dcl 173 set ref 250* 270* 357* 387 393* 412 540 853*
equal                     1     000423 automatic       bit(1)                   level 2 dcl 183 set ref 461 482 489
errname                         000026 internal static char(16)                 dcl 153 set ref 440* 555* 566* 609* 673* 675* 718*
                                                                                  800*
existing_init_type              000111 automatic       fixed bin(17,0)          dcl 161 set ref 434* 437 437
exp_ptr                         000446 automatic       pointer                  dcl 5-128 set ref 403* 406 511 520* 523 528
exp_word                               based           structure                level 1 dcl 5-129 set ref 511 523*
expr                    127            based           bit(18)                  level 2 packed unaligned dcl 228 ref 345
expression                0(18) 000417 automatic       fixed bin(17,0)          level 2 packed unaligned dcl 177 set ref 345* 358*
                                                                                  358 367* 367
expression_relp           1            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 6-28 set ref
                                                                                  403 583*
ext                                    based           structure                level 1 dcl 228 set ref 682
ext_link_$gen_trap              000150 constant        entry                    external dcl 137 ref 310 319
ext_lng                         000144 internal static fixed bin(18,0)          dcl 156 set ref 299 337 607 682*
extension_size                  000105 automatic       fixed bin(17,0)          dcl 161 set ref 732* 736 739 769 781 1072
external_ref                           based           structure                level 1 dcl 1-12
extp                            000274 automatic       pointer                  dcl 168 set ref 834* 865 869 870 871 873 874 875
fatal_binder_error              000426 stack reference condition                dcl 192 ref 569
filename                               based           char(32)                 level 2 dcl 3-16 set ref 566* 573 609* 936
fixed                                                  builtin function         dcl 189 ref 244
has_init_template        13            based           bit(1)                   array level 2 packed unaligned dcl 196 set ref 458
                                                                                  575* 937*
header                                 based           structure                level 2 in structure "link_init_copy_info" dcl 5-211
                                                                                  in procedure "ext_link_"
header                                 based           structure                level 2 in structure "link_init_list_template"
                                                                                  dcl 5-219 in procedure "ext_link_"
header_relp                            based           fixed bin(17,0)          level 2 packed unaligned dcl 6-28 set ref 581*
i                               000100 automatic       fixed bin(17,0)          dcl 161 set ref 276* 277 280 283* 323* 324 326* 332
                                                                                  333 335 364* 366* 367 661* 662* 664 664 665* 666*
                                                                                  670 670 710* 711 713 718* 842* 843 843 845
incompatible_init_types
                         13(03)        based           bit(1)                   array level 2 packed unaligned dcl 196 set ref 435
                                                                                  444*
index                                                  builtin function         dcl 189 ref 842
info_relp                 0(18)        based           fixed bin(18,0)          level 2 in structure "link_trap_pair" packed
                                                                                  unsigned unaligned dcl 5-177 in procedure
                                                                                  "ext_link_" set ref 313
info_relp                 0(18) 000422 automatic       fixed bin(18,0)          level 2 in structure "new_trap_pair" packed unsigned
                                                                                  unaligned dcl 181 in procedure "ext_link_" set ref
                                                                                  319* 321*
init_before                     000315 automatic       bit(1)                   dcl 173 set ref 458* 460* 476 489 489 489 493 501
init_entry_ptr                  000304 automatic       pointer                  dcl 170 set ref 749* 750 752 753 757* 757 757 771*
                                                                                  1072 1073 1077
init_map                               based           structure                array level 1 dcl 209 set ref 1016* 1016
init_map_index            2(18)        based           fixed bin(17,0)          array level 2 packed unaligned dcl 196 set ref 417
                                                                                  434 451 452 476 482 482 496 504* 574* 793 795 966
                                                                                  966 971*
init_map_lng                    000024 internal static fixed bin(17,0)          dcl 150 set ref 667* 728 882 903* 903 904 905 906
                                                                                  907 911 914 916 916 998 1012* 1012 1016 1017 1018
                                                                                  1020
init_map_ptr                    000020 internal static pointer                  dcl 148 set ref 295 434 451 452 454 476 476 482 482
                                                                                  496 504 531 531 663* 664 664 729 731 732 732 734
                                                                                  738 739 746 750 753 765 767 780 781 795 883 904
                                                                                  905 906 907 911 914 916 916 966 966 969 969 999
                                                                                  999 999 1016 1016 1017 1018 1083
init_ptr                               based           pointer                  array level 2 dcl 209 set ref 434 452 454 476 476
                                                                                  496 504 738 746 750 753 767 780 883 904* 999 999
init_size_compares                     based           bit(1)                   array dcl 220 set ref 454*
init_source               3            based           char(32)                 array level 2 dcl 196 set ref 573* 718* 936*
init_type                 6(18)        based           fixed bin(17,0)          array level 2 packed unaligned dcl 209 set ref 734
                                                                                  765 906*
initial_data              2            based           bit(36)                  array level 2 dcl 5-211 set ref 753 887 887
ioa_                            000154 constant        entry                    external dcl 139 ref 465
larger                    2     000423 automatic       bit(1)                   level 2 dcl 183 set ref 489 489 501
left_half                              based           bit(18)                  level 2 packed unaligned dcl 224 set ref 595* 599*
length                                                 builtin function         dcl 189 ref 869 871 873 875
link_init                              based           structure                level 1 dcl 5-205 set ref 780* 780 783 885 885
link_init_copy_info                    based           structure                level 1 dcl 5-211 set ref 738* 738 742
link_init_list_template                based           structure                level 1 dcl 5-219 set ref 760 767* 767 771 776
link_init_n_bits_in_datum       000452 automatic       fixed bin(35,0)          dcl 5-261 set ref 727* 746 1077 1081
link_init_ptr                          automatic       pointer                  dcl 5-204 ref 783
link_ptr                        000270 automatic       pointer                  dcl 168 set ref 400* 401 403 579* 581 582 583 584
link_td                 130(03)        based           bit(4)                   level 2 packed unaligned dcl 228 ref 248
link_tm                 130(01)        based           bit(2)                   level 2 packed unaligned dcl 228 ref 248
link_trap_pair                         based           structure                level 1 dcl 5-177 set ref 324 335*
linkaddr                  2            based           fixed bin(18,0)          array level 2 packed unsigned unaligned dcl 196 set
                                                                                  ref 399 572*
linkbase                        000010 internal static pointer                  dcl 148 set ref 400 579 650*
linklimit                       000145 internal static fixed bin(17,0)          dcl 157 set ref 564 566* 655* 658 658 661 665
linkmap                                based           structure                array level 1 dcl 196
linkmapx                        000103 automatic       fixed bin(17,0)          dcl 161 set ref 397* 399 408 417 434 435 444 451 452
                                                                                  458 463 470 476 481 482 482 496 504* 563* 936 937
                                                                                  966 966 971
list_template_entry                    based           structure                level 1 dcl 5-239 set ref 746 757 1077 1081
loffset                  11            based           fixed bin(17,0)          level 2 dcl 228 set ref 241 301 305* 313* 315
lrt                                    based           structure                level 1 dcl 4-84
lrt_index                       000117 automatic       fixed bin(17,0)          dcl 165 set ref 241* 242 242 244 603
lrtp                            000444 automatic       pointer                  dcl 4-17 set ref 240* 241 242 242 244 603
map                    1541            based           bit(18)                  array level 3 packed unaligned dcl 4-73 set ref 383
                                                                                  392 1048*
map_lng                         000102 automatic       fixed bin(17,0)          dcl 161 set ref 252* 552 1047* 1047 1048 1049*
mapx                            000104 automatic       fixed bin(17,0)          dcl 161 set ref 728* 729 731 732 732 734 738 739 746
                                                                                  750 753 765 767 780 781* 792* 793 795 796 800*
                                                                                  998* 999 999 1005* 1083
max_size               1537            based           fixed bin(17,0)          level 2 dcl 4-73 ref 553
mod                                                    builtin function         dcl 189 ref 651
modifier                  1(30)        based           bit(6)                   level 2 packed unaligned dcl 6-28 set ref 401 584*
n_bad_links                     000434 automatic       fixed bin(17,0)          dcl 706 set ref 790* 799* 799 808
n_bits                                 based           fixed bin(35,0)          level 2 dcl 5-239 set ref 750* 753 757 1072* 1077*
n_tbls                          000022 internal static fixed bin(17,0)          dcl 150 set ref 323 332* 659*
n_words                                based           fixed bin(35,0)          level 2 in structure "link_init" dcl 5-205
                                                                                  in procedure "ext_link_" set ref 452 454 496* 504*
                                                                                  781*
n_words                                based           fixed bin(35,0)          level 3 in structure "link_init_copy_info" dcl 5-211
                                                                                  in procedure "ext_link_" set ref 738 739* 742 746
                                                                                  750 753 887 887 911
n_words                                based           fixed bin(35,0)          level 3 in structure "link_init_list_template"
                                                                                  dcl 5-219 in procedure "ext_link_" set ref 1083*
n_words_in_list           2(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 5-219 set ref
                                                                                  746* 760 767 771 776 892 892 1081* 1081
name_length                            parameter       fixed bin(17,0)          dcl 1040 ref 1026 1044 1044 1045 1049 1049
name_offset                     000116 automatic       fixed bin(18,0)          dcl 163 set ref 537 546 1043* 1044 1048
new                             000423 automatic       structure                level 1 dcl 183 set ref 450* 454
new_ename                       000316 automatic       varying char(256)        dcl 175 set ref 838* 845* 846 846* 858* 872 873 874
                                                                                  875
new_exp_word                    000417 automatic       structure                level 1 dcl 177 set ref 257* 511 523
new_has_init_template           000314 automatic       bit(1)                   dcl 173 set ref 255* 295* 476 489 493 501 575 937
new_init_map_index              000106 automatic       fixed bin(17,0)          dcl 161 set ref 253* 295 417 454 476 496 504 531 531
                                                                                  531 574 882* 883* 969 969 971 1005* 1020*
new_init_ptr              2            based           pointer                  array level 2 dcl 209 set ref 731* 795 907*
new_init_type                   000110 automatic       fixed bin(17,0)          dcl 161 set ref 437 437 880* 887 892 906 911 911
new_link_modifier               000306 automatic       bit(6)                   dcl 172 set ref 248* 401 584
new_name                               based           char                     dcl 1041 set ref 1044* 1044 1049*
new_name_ptr                           parameter       pointer                  dcl 1039 ref 1026 1044 1049
new_ptr                         000276 automatic       pointer                  dcl 168 set ref 795* 796 796
new_trap_pair                   000422 automatic       structure                level 1 dcl 181 set ref 258* 324 335
new_type_pair                   000420 automatic       structure                level 1 dcl 179 set ref 414 529
newlinkp                        000016 internal static pointer                  dcl 148 set ref 399 408 417 434 435 444 451 452 458
                                                                                  463 470 476 481 482 482 496 504 571 572 573 574
                                                                                  575 576 577 669* 670 670 711 713 718 793 795 796
                                                                                  800 936 937 966 966 971
nlinks                          000023 internal static fixed bin(17,0)          dcl 150 set ref 397 563 563* 564 571 572 573 574 575
                                                                                  576 577 671* 710 792
nstr                   1540            based           fixed bin(17,0)          level 2 dcl 4-73 set ref 252 552* 553 556*
null                                                   builtin function         dcl 189 ref 254 796 907
null_acc_offset                 000025 internal static fixed bin(18,0)          unsigned dcl 152 set ref 268 678* 851
object_link                            based           structure                level 1 dcl 6-28
offset                    4            based           fixed bin(18,0)          level 2 dcl 228 set ref 301* 609*
offsetname_relp           1(18)        based           fixed bin(18,0)          level 2 in structure "type_pair" packed unsigned
                                                                                  unaligned dcl 5-160 in procedure "ext_link_" set
                                                                                  ref 542* 546* 718 800
offsetname_relp           1(18) 000420 automatic       fixed bin(18,0)          level 2 in structure "new_type_pair" packed unsigned
                                                                                  unaligned dcl 179 in procedure "ext_link_" set ref
                                                                                  261* 268* 392* 851*
old_trap                        000272 automatic       pointer                  dcl 168 set ref 254* 304* 305 313
orig_init_info_ptr              000300 automatic       pointer                  dcl 170 set ref 293* 880 885 887 892 904 911
print_msg                13(02)        based           bit(1)                   array level 2 packed unaligned dcl 196 set ref 481*
                                                                                  577* 711
real_init_size                  000120 automatic       fixed bin(35,0)          dcl 166 set ref 451* 452 452* 454
ref_ptr                   2            based           pointer                  level 2 dcl 228 ref 595 597 599
reference_count           6            based           fixed bin(17,0)          array level 2 packed unaligned dcl 209 set ref 531*
                                                                                  531 729 905* 966* 966 969* 969 1018*
regenerated               2            based           bit(18)                  array level 2 packed unaligned dcl 4-84 set ref 242
                                                                                  242 244 603*
relinfo                   6            based           char(8)                  level 2 dcl 228 set ref 303* 593
repeat                    1(06)        based           fixed bin(30,0)          level 2 packed unsigned unaligned dcl 5-239 set ref
                                                                                  752* 1073*
right_half                0(18)        based           bit(18)                  level 2 packed unaligned dcl 224 set ref 597*
rpte                                   based           structure                level 1 dcl 4-63
scratch                         000121 automatic       fixed bin(17,0)          array dcl 167 set ref 299 337 607 681
section                  10            based           char(4)                  level 2 dcl 228 set ref 302* 609*
seg                                    based           structure                level 1 dcl 4-29
segname                  12            based           char(33)                 level 2 dcl 228 set ref 275 380 380 536 536 542 842
                                                                                  845 869 870
segname_found                   000307 automatic       bit(1)                   dcl 173 set ref 250* 350* 378 384* 412 534
segname_relp              1            based           fixed bin(18,0)          level 2 in structure "type_pair" packed unsigned
                                                                                  unaligned dcl 5-160 in procedure "ext_link_" set
                                                                                  ref 537* 542 716
segname_relp              1     000420 automatic       fixed bin(18,0)          level 2 in structure "new_type_pair" packed unsigned
                                                                                  unaligned dcl 179 in procedure "ext_link_" set ref
                                                                                  261* 349* 351* 383*
side                      5            based           char(3)                  level 2 dcl 228 ref 595
sign                                                   builtin function         dcl 189 ref 454
size                                                   builtin function         dcl 189 ref 682 746 783 1077 1081
slng                     23            based           fixed bin(17,0)          level 2 dcl 228 set ref 275 380 380 536* 843 871*
smaller                         000423 automatic       bit(1)                   level 2 dcl 183 set ref 493
start_offset              1            based           fixed bin(18,0)          level 2 unsigned dcl 4-84 ref 241
step                            000113 automatic       fixed bin(18,0)          dcl 163 set ref 244* 399* 400 560* 572 579 580 581
                                                                                  591 595 597 599 603
string                                                 builtin function         dcl 189 in procedure "ext_link_" set ref 450*
string                    0(09)        based           char                     level 2 in structure "acc_string" packed unaligned
                                                                                  dcl 5-327 in procedure "ext_link_" set ref 716
                                                                                  718* 800* 838 858 870* 874*
strm                                   based           structure                level 1 dcl 4-73
strm_hash_$lookup               000162 constant        entry                    external dcl 142 ref 380 389
strm_hash_$make_entry           000164 constant        entry                    external dcl 143 ref 1049
strm_index                      000107 automatic       fixed bin(17,0)          dcl 161 set ref 380* 381 383 389* 390 392
strmp                           000442 automatic       pointer                  dcl 4-17 set ref 235* 252 383 392 552 553 553 556
                                                                                  1048
substr                                                 builtin function         dcl 189 set ref 275 277 278* 280* 380 380 389 389
                                                                                  440 440 440 440 465 465 465 465 542 599* 845
tag                       0(30)        based           bit(6)                   level 2 packed unaligned dcl 6-28 set ref 582*
target_size                            parameter       fixed bin(35,0)          dcl 994 ref 977 999 1017
tbl_map                                based           structure                level 1 dcl 217
tbl_offset                             based           fixed bin(18,0)          array level 2 packed unsigned unaligned dcl 217 set
                                                                                  ref 324 326 333* 335
tblp                            000014 internal static pointer                  dcl 148 set ref 324 326 333 335 654* 658 658
temp_mgr_$allocate              000156 constant        entry                    external dcl 140 ref 662 666
temp_mgr_$reserve               000160 constant        entry                    external dcl 141 ref 658 664 670
template                  3            based           fixed bin(17,0)          array level 2 dcl 5-219 set ref 749 892 892
template_size             4            based           fixed bin(35,0)          array level 2 dcl 209 set ref 295 482 732 911* 914*
                                                                                  916
total_init_size           5            based           fixed bin(35,0)          array level 2 dcl 209 set ref 451 482 732 739 781
                                                                                  916* 999 1017* 1083
trap                    126(18)        based           bit(18)                  level 2 packed unaligned dcl 228 ref 288 293 304
trap_offset                            parameter       fixed bin(18,0)          unsigned dcl 631 set ref 591* 616 634*
trap_relp                 0(18) 000420 automatic       fixed bin(18,0)          level 2 in structure "new_type_pair" packed unsigned
                                                                                  unaligned dcl 179 in procedure "ext_link_" set ref
                                                                                  261* 326* 333*
trap_relp                 0(18)        based           fixed bin(18,0)          level 2 in structure "type_pair" packed unsigned
                                                                                  unaligned dcl 5-160 in procedure "ext_link_" set
                                                                                  ref 796*
trap_sw                         000312 automatic       bit(1)                   dcl 173 set ref 230* 273 591 633*
type                      1            based           fixed bin(17,0)          level 3 in structure "link_init_list_template"
                                                                                  dcl 5-219 in procedure "ext_link_" set ref 745*
type                                   based           fixed bin(18,0)          level 2 in structure "type_pair" packed unsigned
                                                                                  unaligned dcl 5-160 in procedure "ext_link_" set
                                                                                  ref 714
type                      1            based           fixed bin(17,0)          level 2 in structure "link_init" dcl 5-205
                                                                                  in procedure "ext_link_" set ref 434 880
type                            000420 automatic       fixed bin(18,0)          level 2 in structure "new_type_pair" packed unsigned
                                                                                  unaligned dcl 179 in procedure "ext_link_" set ref
                                                                                  260* 266 288 288 347 347 355 422 422 832 866*
type                    126            based           bit(18)                  level 2 in structure "ext" packed unaligned dcl 228
                                                                                  in procedure "ext_link_" ref 260
type_pair                              based           structure                level 1 dcl 5-160 set ref 414 529*
type_ptr                               based           pointer                  array level 2 in structure "linkmap" dcl 196
                                                                                  in procedure "ext_link_" set ref 408 571* 713 796
                                                                                  800
type_ptr                        000450 automatic       pointer                  dcl 5-159 in procedure "ext_link_" set ref 408* 414
                                                                                  528* 529 537 542 542 546 571 713* 714 716 718
type_relp                              based           fixed bin(18,0)          level 2 in structure "exp_word" packed unsigned
                                                                                  unaligned dcl 5-129 in procedure "ext_link_" set
                                                                                  ref 406
type_relp                       000417 automatic       fixed bin(18,0)          level 2 in structure "new_exp_word" packed unsigned
                                                                                  unaligned dcl 177 in procedure "ext_link_" set ref
                                                                                  406* 521*
typepair_found                  000311 automatic       bit(1)                   dcl 173 set ref 250* 404 509* 521 525
unspec                                                 builtin function         dcl 189 set ref 257* 258* 324 324 414 414 511 511
                                                                                  753 885 885 887 887 892 892
val                             000112 automatic       fixed bin(18,0)          dcl 163 set ref 238*
wentryname                      000043 internal static char(257)                dcl 155 set ref 277* 278* 280* 284* 440 440 440 440
                                                                                  465 465 465 465 566* 609* 872*
word                                   based           structure                level 1 dcl 224
wordno                                                 builtin function         dcl 189 ref 791 796
wsegname                        000032 internal static char(33)                 dcl 154 set ref 275* 278 362 440 440* 465 465* 566*
                                                                                  609* 714* 716* 718* 835 856 868*
xoffset                         000114 automatic       fixed bin(18,0)          dcl 163 set ref 519* 520 521 583 791* 796 1043

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CLASS_HEAP                             internal static fixed bin(3,0)           initial unsigned dcl 5-25
CLASS_LINKAGE                          internal static fixed bin(3,0)           initial unsigned dcl 5-25
CLASS_NAMES                            internal static char(12)                 initial array unaligned dcl 5-35
CLASS_SEGNAME                          internal static fixed bin(3,0)           initial unsigned dcl 5-25
CLASS_STATIC                           internal static fixed bin(3,0)           initial unsigned dcl 5-25
CLASS_SYMBOL                           internal static fixed bin(3,0)           initial unsigned dcl 5-25
CLASS_SYSTEM                           internal static fixed bin(3,0)           initial unsigned dcl 5-25
CLASS_TEXT                             internal static fixed bin(3,0)           initial unsigned dcl 5-25
FAULT_TAG_1                            internal static bit(6)                   initial unaligned dcl 6-100
FAULT_TAG_2                            internal static bit(6)                   initial unaligned dcl 6-101
FAULT_TAG_3                            internal static bit(6)                   initial unaligned dcl 6-102
FR_TRAPS_VERSION_1                     internal static fixed bin(17,0)          initial dcl 6-99
INIT_DEFERRED                          internal static fixed bin(17,0)          initial dcl 5-194
INIT_NO_INIT                           internal static fixed bin(17,0)          initial dcl 5-194
LINK_OBSOLETE_2                        internal static fixed bin(18,0)          initial unsigned unaligned dcl 5-134
LINK_REFNAME_OFFSETNAME                internal static fixed bin(18,0)          initial unsigned unaligned dcl 5-134
LINK_TYPE_NAMES                        internal static varying char(32)         initial array dcl 5-153
SECTION_HEAP                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 5-134
SECTION_SYMBOL                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 5-134
SECTION_UNUSED                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 5-134
SYMBOLIC_SECTION_NAMES                 internal static char(8)                  initial array unaligned dcl 5-38
acc_string_length                      automatic       fixed bin(21,0)          dcl 5-334
acc_string_ptr                         automatic       pointer                  dcl 5-326
adnp                                   automatic       pointer                  dcl 4-17
an                                     based           structure                level 1 dcl 4-40
bx_$addname                            external static fixed bin(17,0)          dcl 2-58
bx_$addname_limit                      external static fixed bin(17,0)          dcl 2-24
bx_$adnp                               external static pointer                  dcl 2-36
bx_$area_begin                         external static fixed bin(18,0)          dcl 2-25
bx_$bdefp                              external static pointer                  dcl 2-38
bx_$bindmap_def                        external static pointer                  dcl 2-37
bx_$blnkp                              external static pointer                  dcl 2-40
bx_$bound_segname                      external static char(32)                 dcl 2-48
bx_$bproc                              external static fixed bin(17,0)          dcl 2-67
bx_$bseg_acinfop                       external static pointer                  dcl 2-50
bx_$bseg_bitcount                      external static fixed bin(24,0)          dcl 2-51
bx_$bsegp                              external static pointer                  dcl 2-30
bx_$bstatp                             external static pointer                  dcl 2-39
bx_$bsymp                              external static pointer                  dcl 2-41
bx_$d_lng                              external static fixed bin(18,0)          dcl 2-54
bx_$first_rptp                         external static pointer                  dcl 2-34
bx_$force_order                        external static fixed bin(17,0)          dcl 2-61
bx_$has_comb_stat                      external static fixed bin(17,0)          dcl 2-63
bx_$has_sep_stat                       external static fixed bin(17,0)          dcl 2-62
bx_$i_lng                              external static fixed bin(17,0)          dcl 2-55
bx_$inpp                               external static pointer                  dcl 2-29
bx_$isp                                external static pointer                  dcl 2-28
bx_$l_lng                              external static fixed bin(17,0)          dcl 2-56
bx_$last_rptp                          external static pointer                  dcl 2-35
bx_$maxdeflng                          external static fixed bin(18,0)          dcl 2-72
bx_$n_firstrefs                        external static fixed bin(17,0)          dcl 2-47
bx_$n_lng                              external static fixed bin(17,0)          dcl 2-76
bx_$ncomp                              external static fixed bin(17,0)          dcl 2-74
bx_$nsegdefs                           external static fixed bin(17,0)          dcl 2-78
bx_$nsymdefs                           external static fixed bin(17,0)          dcl 2-77
bx_$o_lng                              external static fixed bin(19,0)          dcl 2-52
bx_$oddname_limit                      external static fixed bin(17,0)          dcl 2-22
bx_$odnp                               external static pointer                  dcl 2-33
bx_$optp                               external static pointer                  dcl 2-32
bx_$perprocess_static                  external static fixed bin(17,0)          dcl 2-65
bx_$s_lng                              external static fixed bin(18,0)          dcl 2-57
bx_$size                               external static fixed bin(17,0)          dcl 2-20
bx_$snt_limit                          external static fixed bin(17,0)          dcl 2-21
bx_$sntp                               external static pointer                  dcl 2-42
bx_$standard                           external static fixed bin(17,0)          dcl 2-66
bx_$stringmap_limit                    external static fixed bin(17,0)          dcl 2-23
bx_$t_lng                              external static fixed bin(18,0)          dcl 2-53
bx_$temp                               external static pointer                  dcl 2-31
bx_$temp_bsegp                         external static pointer                  dcl 2-79
bx_$textlng                            external static fixed bin(18,0)          dcl 2-68
bx_$tintp                              external static pointer                  dcl 2-44
bx_$v_lng                              external static fixed bin(17,0)          dcl 2-75
bx_$vers_name                          external static char(168)                dcl 2-18
bx_$vers_number                        external static fixed bin(17,0)          dcl 2-19
comp_ht_n_entries                      automatic       fixed bin(17,0)          dcl 5-297
comp_ht_ptr                            automatic       pointer                  dcl 5-288
comp_tbl                               based           pointer                  array dcl 3-12
component_ht                           based           structure                level 1 dcl 5-289
def_header_ptr                         automatic       pointer                  dcl 5-57
def_ht_n_entries                       automatic       fixed bin(17,0)          dcl 5-284
def_ht_ptr                             automatic       pointer                  dcl 5-277
def_ptr                                automatic       pointer                  dcl 5-71
definition                             based           structure                level 1 dcl 5-72
definition_header                      based           structure                level 1 dcl 5-58
definition_ht                          based           structure                level 1 dcl 5-278
dup_table_n_names                      automatic       fixed bin(17,0)          dcl 5-310
dup_table_ptr                          automatic       pointer                  dcl 5-301
duplicate_table                        based           structure                level 1 dcl 5-302
fr_traps                               based           structure                level 1 dcl 6-90
link_init_deferred                     based           structure                level 1 dcl 5-270
link_init_n_words                      automatic       fixed bin(17,0)          dcl 5-215
link_init_n_words_in_list              automatic       fixed bin(17,0)          dcl 5-226
link_trap_ptr                          automatic       pointer                  dcl 5-176
linkage_header                         based           structure                level 1 dcl 6-50
linkage_header_flags                   based           structure                level 1 dcl 6-63
msf_map                                based           structure                level 1 dcl 5-318
msf_map_ptr                            automatic       pointer                  dcl 5-317
msf_map_version_1                      internal static char(8)                  initial unaligned dcl 5-323
od                                     based           structure                level 1 dcl 4-48
odnp                                   automatic       pointer                  dcl 4-17
p                                      automatic       pointer                  dcl 168
partial_link                           based           structure                level 1 dcl 6-38
pointer_init_template                  based           structure                level 1 packed unaligned dcl 5-253
rpt                                    based           structure                level 1 dcl 4-57
rptep                                  automatic       pointer                  dcl 4-17
rptp                                   automatic       pointer                  dcl 4-17
segname_definition                     based           structure                level 1 dcl 5-90
segname_ptr                            automatic       pointer                  dcl 5-89
snt                                    based           structure                level 1 dcl 4-21
sntp                                   automatic       pointer                  dcl 4-17
virgin_linkage_header                  based           structure                level 1 dcl 6-71

NAMES DECLARED BY EXPLICIT CONTEXT.
add_extension                   004111 constant        entry                    internal dcl 1056 ref 759 774
add_name                        004036 constant        entry                    internal dcl 1026 ref 536 545
adjust_text                     002234 constant        label                    dcl 587 ref 245 511
advance                         001714 constant        label                    dcl 514 ref 401 414 422
change_init_map_index           003676 constant        entry                    internal dcl 948 ref 506 938
ext_link_                       000357 constant        entry                    external dcl 128
extend_template                 003735 constant        entry                    internal dcl 977 ref 496 504
find_init_map_entry             003277 constant        entry                    internal dcl 813 ref 294
finish                          002601 constant        entry                    external dcl 685
gen_trap                        002411 constant        entry                    external dcl 616
generate_definition             001716 constant        label                    dcl 517
generate_link                   002074 constant        label                    dcl 560 ref 525
init                            002424 constant        entry                    external dcl 637
lookup_links                    001215 constant        label                    dcl 397 ref 372
replace_init_info               003655 constant        entry                    internal dcl 922 ref 482 489 498
restore_ext                     001004 constant        label                    dcl 337 ref 328
start                           000365 constant        label                    dcl 232 set ref 635
trap_error                      002322 constant        label                    dcl 607 set ref 306 317
use_typepair                    001707 constant        label                    dcl 509 ref 404 417

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4416        4640    4154        4426
Length      5266    4154       222         411     241         136

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ext_link_                           553 external procedure  is an external procedure.  
find_init_map_entry                     internal procedure  shares stack frame of external procedure ext_link_.  
replace_init_info                       internal procedure  shares stack frame of external procedure ext_link_.  
change_init_map_index                   internal procedure  shares stack frame of external procedure ext_link_.  
extend_template                         internal procedure  shares stack frame of external procedure ext_link_.  
add_name                                internal procedure  shares stack frame of external procedure ext_link_.  
add_extension                           internal procedure  shares stack frame of external procedure ext_link_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 linkbase                    ext_link_
000012 defbase                     ext_link_
000014 tblp                        ext_link_
000016 newlinkp                    ext_link_
000020 init_map_ptr                ext_link_
000022 n_tbls                      ext_link_
000023 nlinks                      ext_link_
000024 init_map_lng                ext_link_
000025 null_acc_offset             ext_link_
000026 errname                     ext_link_
000032 wsegname                    ext_link_
000043 wentryname                  ext_link_
000144 ext_lng                     ext_link_
000145 linklimit                   ext_link_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ext_link_                000100 i                           ext_link_
                         000101 def_growth                  ext_link_
                         000102 map_lng                     ext_link_
                         000103 linkmapx                    ext_link_
                         000104 mapx                        ext_link_
                         000105 extension_size              ext_link_
                         000106 new_init_map_index          ext_link_
                         000107 strm_index                  ext_link_
                         000110 new_init_type               ext_link_
                         000111 existing_init_type          ext_link_
                         000112 val                         ext_link_
                         000113 step                        ext_link_
                         000114 xoffset                     ext_link_
                         000115 class                       ext_link_
                         000116 name_offset                 ext_link_
                         000117 lrt_index                   ext_link_
                         000120 real_init_size              ext_link_
                         000121 scratch                     ext_link_
                         000266 ap                          ext_link_
                         000270 link_ptr                    ext_link_
                         000272 old_trap                    ext_link_
                         000274 extp                        ext_link_
                         000276 new_ptr                     ext_link_
                         000300 orig_init_info_ptr          ext_link_
                         000302 cur_init_info_ptr           ext_link_
                         000304 init_entry_ptr              ext_link_
                         000306 new_link_modifier           ext_link_
                         000307 segname_found               ext_link_
                         000310 entryname_found             ext_link_
                         000311 typepair_found              ext_link_
                         000312 trap_sw                     ext_link_
                         000313 convert                     ext_link_
                         000314 new_has_init_template       ext_link_
                         000315 init_before                 ext_link_
                         000316 new_ename                   ext_link_
                         000417 new_exp_word                ext_link_
                         000420 new_type_pair               ext_link_
                         000422 new_trap_pair               ext_link_
                         000423 new                         ext_link_
                         000434 n_bad_links                 ext_link_
                         000436 ctp                         ext_link_
                         000440 ctep                        ext_link_
                         000442 strmp                       ext_link_
                         000444 lrtp                        ext_link_
                         000446 exp_ptr                     ext_link_
                         000450 type_ptr                    ext_link_
                         000452 link_init_n_bits_in_datum   ext_link_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac
sign_mac            mdfx1               signal_op           shorten_stack       ext_entry           trunc_fx1
set_chars_eis       index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      decode_link_                  ext_link_$gen_trap            ioa_
strm_hash_$lookup             strm_hash_$make_entry         temp_mgr_$allocate            temp_mgr_$reserve

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bx_$bound_sep_stat            bx_$brief                     bx_$caller                    bx_$ctp
bx_$curdeflng                 bx_$debug                     bx_$fatal_error               bx_$freep
bx_$maxlinklng                bx_$strmp                     bx_$tdefp                     bx_$tintlng
bx_$tlinklng                  bx_$tlinkp


CONSTANTS
004145  aa     677777777777

004146  aa     577777777777

000000  aa     404000000043

000001  aa     406000000021

004147  aa  142 137 000 000	b_

000002  aa  056 143 157 155	.com

000003  aa     524000000145

000004  aa     526000000000

000005  aa     524000000135

000006  aa     404000000022

000007  aa     524000000004

000010  aa     524000000102

000011  aa  154 150 145 000	lhe

000012  aa     524000000040

000013  aa     524000000401

000014  aa     524000000370

000015  aa     524000000064

000016  aa     524000000134

000017  aa     524000000400

000020  aa     524000000001

000021  aa     524000000041

000022  aa     524000000110

000023  aa     524000000020

000024  aa     404000000005

000025  aa     404000000021

000026  aa     524000000000

000027  aa  154 151 156 153	link

004150  aa  174 060 000 000	|0

004151  aa  044 000 000 000	$

004152  aa  174 000 000 000	|

004153  aa     000000000002

000030  aa     604000000022

000031  aa     514000000001

000032  aa     464000000000

000034  aa  142 154 156 153	blnk
000035  aa  052 143 157 155	*com

000036  aa  163 164 141 164	stat
000037  aa  137 000 000 000	_

000040  aa  154 156 153 061	lnk1
000041  aa  070 040 040 040	8   

000042  aa  052 163 164 141	*sta
000043  aa  164 151 143 000	tic

000044  aa  040 040 040 040	    
000045  aa  040 040 040 040	    

000046  aa  052 163 171 163	*sys
000047  aa  164 145 155 000	tem

000050  aa     077777000043
000051  aa     000001000000

000052  aa  143 157 142 157	cobo
000053  aa  154 137 146 163	l_fs
000054  aa  142 137 000 000	b_

000055  aa  145 170 164 137	ext_
000056  aa  154 151 156 153	link
000057  aa  137 000 000 000	_

000060  aa  146 141 164 141	fata
000061  aa  154 137 142 151	l_bi
000062  aa  156 144 145 162	nder
000063  aa  137 145 162 162	_err
000064  aa  157 162 000 000	or

000065  aa  123 164 162 151	Stri
000066  aa  156 147 155 141	ngma
000067  aa  160 040 164 141	p ta
000070  aa  142 154 145 040	ble 
000071  aa  157 166 145 162	over
000072  aa  146 154 157 167	flow
000073  aa  073 040 160 154	; pl
000074  aa  145 141 163 145	ease
000075  aa  040 156 157 164	 not
000076  aa  151 146 171 040	ify 
000077  aa  155 141 151 156	main
000100  aa  164 145 156 141	tena
000101  aa  156 143 145 056	nce.

000102  aa  143 141 156 156	cann
000103  aa  157 164 040 160	ot p
000104  aa  162 157 143 145	roce
000105  aa  163 163 040 164	ss t
000106  aa  162 141 160 040	rap 
000107  aa  142 145 146 157	befo
000110  aa  162 145 040 154	re l
000111  aa  151 156 153 040	ink 
000112  aa  146 157 162 040	for 
000113  aa  136 141 136 141	^a^a
000114  aa  040 162 145 146	 ref
000115  aa  145 162 145 156	eren
000116  aa  143 145 144 040	ced 
000117  aa  142 171 040 136	by ^
000120  aa  141 174 136 157	a|^o
000121  aa  040 157 146 040	 of 
000122  aa  136 141 000 000	^a

000123  aa  105 170 164 145	Exte
000124  aa  162 156 141 154	rnal
000125  aa  040 166 141 162	 var
000126  aa  151 141 142 154	iabl
000127  aa  145 040 136 133	e ^[
000130  aa  136 141 136 141	^a^a
000131  aa  136 073 136 062	^;^2
000132  aa  163 136 135 136	s^]^
000133  aa  141 040 150 141	a ha
000134  aa  163 040 151 156	s in
000135  aa  143 157 155 160	comp
000136  aa  141 164 151 142	atib
000137  aa  154 145 040 151	le i
000140  aa  156 151 164 151	niti
000141  aa  141 154 151 172	aliz
000142  aa  141 164 151 157	atio
000143  aa  156 040 164 171	n ty
000144  aa  160 145 163 056	pes.

000145  aa  127 141 162 156	Warn
000146  aa  151 156 147 072	ing:
000147  aa  040 145 170 164	 ext
000150  aa  145 162 156 141	erna
000151  aa  154 040 166 141	l va
000152  aa  162 151 141 142	riab
000153  aa  154 145 040 136	le ^
000154  aa  133 136 141 136	[^a^
000155  aa  141 136 073 136	a^;^
000156  aa  062 163 136 135	2s^]
000157  aa  136 141 040 150	^a h
000160  aa  141 163 040 144	as d
000161  aa  151 146 146 145	iffe
000162  aa  162 145 156 164	rent
000163  aa  040 163 151 172	 siz
000164  aa  145 163 073 136	es;^
000165  aa  057 136 055 164	/^-t
000166  aa  150 145 040 154	he l
000167  aa  141 162 147 145	arge
000170  aa  163 164 040 167	st w
000171  aa  151 154 154 040	ill 
000172  aa  142 145 040 165	be u
000173  aa  163 145 144 056	sed.

000174  aa  115 165 154 164	Mult
000175  aa  151 160 154 145	iple
000176  aa  040 151 156 151	 ini
000177  aa  164 151 141 154	tial
000200  aa  151 172 141 164	izat
000201  aa  151 157 156 163	ions
000202  aa  040 163 160 145	 spe
000203  aa  143 151 146 151	cifi
000204  aa  145 144 040 146	ed f
000205  aa  157 162 040 145	or e
000206  aa  170 164 145 162	xter
000207  aa  156 141 154 040	nal 
000210  aa  166 141 162 151	vari
000211  aa  141 142 154 145	able
000212  aa  040 136 141 136	 ^a^
000213  aa  141 073 136 057	a;^/
000214  aa  136 055 164 150	^-th
000215  aa  145 040 157 156	e on
000216  aa  145 040 151 156	e in
000217  aa  040 136 141 040	 ^a 
000220  aa  167 151 154 154	will
000221  aa  040 142 145 040	 be 
000222  aa  165 163 145 144	used
000223  aa  056 000 000 000	.

000224  aa  114 151 156 153	Link
000225  aa  040 164 157 040	 to 
000226  aa  145 170 164 145	exte
000227  aa  162 156 141 154	rnal
000230  aa  040 166 141 162	 var
000231  aa  151 141 142 154	iabl
000232  aa  145 040 136 141	e ^a
000233  aa  040 150 141 163	 has
000234  aa  040 155 151 163	 mis
000235  aa  163 151 156 147	sing
000236  aa  040 151 156 151	 ini
000237  aa  164 151 141 154	tial
000240  aa  151 172 141 164	izat
000241  aa  151 157 156 040	ion 
000242  aa  151 156 146 157	info
000243  aa  162 155 141 164	rmat
000244  aa  151 157 156 056	ion.
000245  aa  136 057 136 055	^/^-
000246  aa  116 157 164 151	Noti
000247  aa  146 171 040 155	fy m
000250  aa  141 151 156 164	aint
000251  aa  145 156 141 156	enan
000252  aa  143 145 040 160	ce p
000253  aa  145 162 163 157	erso
000254  aa  156 156 145 154	nnel
000255  aa  056 000 000 000	.

000256  aa  114 151 156 153	Link
000257  aa  164 141 142 154	tabl
000260  aa  145 040 157 166	e ov
000261  aa  145 162 146 154	erfl
000262  aa  157 167 040 167	ow w
000263  aa  150 151 154 145	hile
000264  aa  040 141 144 144	 add
000265  aa  151 156 147 040	ing 
000266  aa  154 151 156 153	link
000267  aa  040 164 157 040	 to 
000270  aa  136 141 136 141	^a^a
000271  aa  136 057 136 055	^/^-
000272  aa  146 157 162 040	for 
000273  aa  143 157 155 160	comp
000274  aa  157 156 145 156	onen
000275  aa  164 040 136 141	t ^a
000276  aa  056 136 057 136	.^/^
000277  aa  055 131 157 165	-You
000300  aa  040 150 141 166	 hav
000301  aa  145 040 162 157	e ro
000302  aa  157 155 040 146	om f
000303  aa  157 162 040 157	or o
000304  aa  156 154 171 040	nly 
000305  aa  136 144 040 154	^d l
000306  aa  151 156 153 163	inks
000307  aa  136 057 136 055	^/^-
000310  aa  141 146 164 145	afte
000311  aa  162 040 171 157	r yo
000312  aa  165 162 040 136	ur ^
000313  aa  144 040 167 157	d wo
000314  aa  162 144 163 040	rds 
000315  aa  157 146 040 151	of i
000316  aa  156 164 145 162	nter
000317  aa  156 141 154 040	nal 
000320  aa  163 164 141 164	stat
000321  aa  151 143 056 136	ic.^
000322  aa  057 136 055 103	/^-C
000323  aa  157 156 163 151	onsi
000324  aa  144 145 162 040	der 
000325  aa  165 163 151 156	usin
000326  aa  147 040 163 145	g se
000327  aa  160 141 162 141	para
000330  aa  164 145 040 163	te s
000331  aa  164 141 164 151	tati
000332  aa  143 040 050 160	c (p
000333  aa  154 061 040 157	l1 o
000334  aa  162 040 141 154	r al
000335  aa  155 051 040 157	m) o
000336  aa  162 040 154 141	r la
000337  aa  162 147 145 040	rge 
000340  aa  141 162 162 141	arra
000341  aa  171 163 040 050	ys (
000342  aa  146 157 162 164	fort
000343  aa  162 141 156 051	ran)
000344  aa  136 057 136 055	^/^-
000345  aa  164 157 040 155	to m
000346  aa  141 153 145 040	ake 
000347  aa  155 157 162 145	more
000350  aa  040 162 157 157	 roo
000351  aa  155 040 146 157	m fo
000352  aa  162 040 154 151	r li
000353  aa  156 153 163 056	nks.

BEGIN PROCEDURE ext_link_
ENTRY TO ext_link_                                          STATEMENT 1 ON LINE 128
ext_link_:
     procedure (argument_pointer);

000354  at     000001000032
000355  ta     000354000000
000356  da     000220300000
000357  aa   001060 6270 00	eax7 	560
000360  aa  7 00034 3521 20	epp2 	pr7|28,*
000361  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000362  aa     000002000000
000363  aa     000000000000
						STATEMENT 1 ON LINE 230
	trap_sw = "0"b;

000364  aa  6 00312 4501 00	stz  	pr6|202		trap_sw
						STATEMENT 1 ON LINE 232
start:
	def_growth = 0;

000365  aa  6 00101 4501 00	stz  	pr6|65		def_growth
						STATEMENT 1 ON LINE 234
	ctp = bx_$ctp;

000366  aa  6 00044 3701 20	epp4 	pr6|36,*
000367  la  4 00166 3735 20	epp7 	pr4|118,*		bx_$ctp
000370  aa  7 00000 3735 20	epp7 	pr7|0,*		bx_$ctp
000371  aa  6 00436 6535 00	spri7	pr6|286		ctp
						STATEMENT 1 ON LINE 235
	strmp = bx_$strmp;

000372  la  4 00176 3715 20	epp5 	pr4|126,*		bx_$strmp
000373  aa  5 00000 3715 20	epp5 	pr5|0,*		bx_$strmp
000374  aa  6 00442 6515 00	spri5	pr6|290		strmp
						STATEMENT 1 ON LINE 236
	ap = argument_pointer;

000375  aa  6 00032 3535 20	epp3 	pr6|26,*
000376  aa  3 00002 3515 20	epp1 	pr3|2,*		argument_pointer
000377  aa  1 00000 3515 20	epp1 	pr1|0,*		argument_pointer
000400  aa  6 00266 2515 00	spri1	pr6|182		ap
						STATEMENT 1 ON LINE 237
	ctep = ext.compent_ptr;

000401  aa  1 00000 3735 20	epp7 	pr1|0,*		ext.compent_ptr
000402  aa  6 00440 6535 00	spri7	pr6|288		ctep
						STATEMENT 1 ON LINE 238
	val = 0;

000403  aa  6 00112 4501 00	stz  	pr6|74		val
						STATEMENT 1 ON LINE 240
	lrtp = comp.clrtp;

000404  aa  7 00040 3715 20	epp5 	pr7|32,*		comp.clrtp
000405  aa  6 00444 6515 00	spri5	pr6|292		lrtp
						STATEMENT 1 ON LINE 241
	lrt_index = ((ext.loffset - lrt.start_offset) * 0.5) + 1;

000406  aa   000001 2360 07	ldq  	1,dl
000407  aa   000004 7360 00	qls  	4
000410  aa  6 00530 7561 00	stq  	pr6|344
000411  aa  1 00011 2361 00	ldq  	pr1|9		ext.loffset
000412  aa  5 00001 1761 00	sbq  	pr5|1		lrt.start_offset
000413  aa   000003 7360 00	qls  	3
000414  aa  6 00530 0761 00	adq  	pr6|344
000415  aa   000004 7220 07	lxl2 	4,dl
000416  aa  0 01114 7001 00	tsx0 	pr0|588		trunc_fx1
000417  aa  6 00117 7561 00	stq  	pr6|79		lrt_index
						STATEMENT 1 ON LINE 242
	if (lrt.regenerated (lrt_index) ^= UNRESOLVED) & (lrt.regenerated (lrt_index) ^= INTERNALLY_RESOLVED)
	then do;

000420  aa   000022 4020 07	mpy  	18,dl
000421  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
000422  aa  5 00001 40 0022	descb	pr5|1(18),18	lrt.regenerated
000423  aa  6 00530 00 0044	descb	pr6|344,36	lrt.regenerated
000424  aa  6 00530 2351 00	lda  	pr6|344		lrt.regenerated
000425  aa   000006 6000 04	tze  	6,ic		000433
000426  aa   777777 1150 03	cmpa 	262143,du
000427  aa   000004 6000 04	tze  	4,ic		000433
						STATEMENT 1 ON LINE 244
	     step = fixed (lrt.regenerated (lrt_index), 18);

000430  aa   000066 7730 00	lrl  	54
000431  aa  6 00113 7561 00	stq  	pr6|75		step
						STATEMENT 1 ON LINE 245
	     goto adjust_text;

000432  aa   001602 7100 04	tra  	898,ic		002234
						STATEMENT 1 ON LINE 246
	end;

						STATEMENT 1 ON LINE 248
	new_link_modifier = ext.link_tm || ext.link_td;

000433  aa  1 00130 2351 00	lda  	pr1|88		ext.link_tm
000434  aa   000001 7350 00	als  	1
000435  aa  0 00004 3771 00	anaq 	pr0|4		= 600000000000 000000000000
000436  aa  6 00530 7551 00	sta  	pr6|344		ext.link_tm
000437  aa  1 00130 2351 00	lda  	pr1|88		ext.link_td
000440  aa   000003 7350 00	als  	3
000441  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
000442  aa   000002 7710 00	arl  	2
000443  aa  6 00530 2751 00	ora  	pr6|344		ext.link_tm
000444  aa  6 00306 7551 00	sta  	pr6|198		new_link_modifier
						STATEMENT 1 ON LINE 250
	segname_found, entryname_found, typepair_found = "0"b;

000445  aa  6 00307 4501 00	stz  	pr6|199		segname_found
000446  aa  6 00310 4501 00	stz  	pr6|200		entryname_found
000447  aa  6 00311 4501 00	stz  	pr6|201		typepair_found
						STATEMENT 1 ON LINE 252
	map_lng = strm.nstr;

000450  aa  6 00442 3735 20	epp7 	pr6|290,*		strmp
000451  aa  7 01540 2361 00	ldq  	pr7|864		strm.nstr
000452  aa  6 00102 7561 00	stq  	pr6|66		map_lng
						STATEMENT 1 ON LINE 253
	new_init_map_index = 0;

000453  aa  6 00106 4501 00	stz  	pr6|70		new_init_map_index
						STATEMENT 1 ON LINE 254
	old_trap = null;

000454  aa   777374 2370 04	ldaq 	-260,ic		000050 = 077777000043 000001000000
000455  aa  6 00272 7571 00	staq 	pr6|186		old_trap
						STATEMENT 1 ON LINE 255
	new_has_init_template = "0"b;

000456  aa  6 00314 4501 00	stz  	pr6|204		new_has_init_template
						STATEMENT 1 ON LINE 257
	unspec (new_exp_word) = "0"b;

000457  aa  6 00417 4501 00	stz  	pr6|271
						STATEMENT 1 ON LINE 258
	unspec (new_trap_pair) = "0"b;

000460  aa  6 00422 4501 00	stz  	pr6|274
						STATEMENT 1 ON LINE 260
	new_type_pair.type = bin (ext.type, 18);

000461  aa  1 00126 2351 00	lda  	pr1|86		ext.type
000462  aa   000066 7730 00	lrl  	54
000463  aa   000066 7370 00	lls  	54
000464  aa  6 00420 5511 60	stba 	pr6|272,60	new_type_pair.type
						STATEMENT 1 ON LINE 261
	new_type_pair.trap_relp,			/* this field does not get filled in */
	     new_type_pair.segname_relp, new_type_pair.offsetname_relp = 0;

000465  aa   000000 2350 03	lda  	0,du
000466  aa  6 00420 5511 14	stba 	pr6|272,14	new_type_pair.trap_relp
000467  aa   000022 7350 00	als  	18
000470  aa  6 00421 5511 60	stba 	pr6|273,60	new_type_pair.segname_relp
000471  aa   000022 7710 00	arl  	18
000472  aa  6 00421 5511 14	stba 	pr6|273,14	new_type_pair.offsetname_relp
						STATEMENT 1 ON LINE 264
	class = bin (ext.code15, 18);

000473  aa  1 00127 2361 00	ldq  	pr1|87		ext.code15
000474  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000475  aa  6 00115 7561 00	stq  	pr6|77		class
						STATEMENT 1 ON LINE 266
	if new_type_pair.type = LINK_REFNAME_BASE
	then do;

000476  aa  6 00420 2351 00	lda  	pr6|272		new_type_pair.type
000477  aa   000066 7730 00	lrl  	54
000500  aa  6 00530 7561 00	stq  	pr6|344		new_type_pair.type
000501  aa   000003 2350 03	lda  	3,du
000502  aa   000066 7730 00	lrl  	54
000503  aa  6 00530 1161 00	cmpq 	pr6|344		new_type_pair.type
000504  aa   000005 6010 04	tnz  	5,ic		000511
						STATEMENT 1 ON LINE 268
	     new_type_pair.offsetname_relp = null_acc_offset;

000505  ia  4 00025 2361 00	ldq  	pr4|21		null_acc_offset
000506  aa  6 00421 5521 14	stbq 	pr6|273,14	new_type_pair.offsetname_relp
						STATEMENT 1 ON LINE 270
	     entryname_found = "1"b;

000507  aa   400000 2350 03	lda  	131072,du
000510  aa  6 00310 7551 00	sta  	pr6|200		entryname_found
						STATEMENT 1 ON LINE 271
	end;

						STATEMENT 1 ON LINE 273
	if ^trap_sw				/* normal ext_link_ entry (not gen_trap entry) */
	then do;

000511  aa  6 00312 2351 00	lda  	pr6|202		trap_sw
000512  aa   000034 6010 04	tnz  	28,ic		000546
						STATEMENT 1 ON LINE 275
	     wsegname = substr (ext.segname, 2, ext.slng - 1);

000513  aa  1 00023 2361 00	ldq  	pr1|19		ext.slng
000514  aa   000001 1760 07	sbq  	1,dl
000515  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000516  aa  1 00012 20 0006	desc9a	pr1|10(1),ql	ext.segname
000517  ia  4 00032 00 0041	desc9a	pr4|26,33		wsegname
						STATEMENT 1 ON LINE 276
	     i = ext.elng;

000520  aa  1 00125 2361 00	ldq  	pr1|85		ext.elng
000521  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 277
	     wentryname = substr (ext.entryname, 1, i);

000522  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000523  aa  1 00024 00 0006	desc9a	pr1|20,ql		ext.entryname
000524  ia  4 00043 00 0401	desc9a	pr4|35,257	wentryname
						STATEMENT 1 ON LINE 278
	     if wsegname = "*system"
	     then substr (wentryname, 1, 1) = "|";

000525  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000526  ia  4 00032 00 0041	desc9a	pr4|26,33		wsegname
000527  aa   777321 00 0007	desc9a	-303,7		000046 = 052163171163
000530  aa   000004 6010 04	tnz  	4,ic		000534
000531  aa   174000 2350 03	lda  	63488,du
000532  ia  4 00043 5511 40	stba 	pr4|35,40		wentryname
000533  aa   000013 7100 04	tra  	11,ic		000546
						STATEMENT 1 ON LINE 280
	     else if i > 0
	     then substr (wentryname, 1, 1) = "$";

000534  aa  6 00100 2361 00	ldq  	pr6|64		i
000535  aa   000004 6044 04	tmoz 	4,ic		000541
000536  aa   044000 2350 03	lda  	18432,du
000537  ia  4 00043 5511 40	stba 	pr4|35,40		wentryname
000540  aa   000006 7100 04	tra  	6,ic		000546
						STATEMENT 1 ON LINE 282
	     else do;

						STATEMENT 1 ON LINE 283
		i = 2;

000541  aa   000002 2360 07	ldq  	2,dl
000542  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 284
		wentryname = "|0";

000543  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000544  aa   003405 00 0002	desc9a	1797,2		004150 = 174060000000
000545  ia  4 00043 00 0401	desc9a	pr4|35,257	wentryname
						STATEMENT 1 ON LINE 285
	     end;

						STATEMENT 1 ON LINE 286
	end;

						STATEMENT 1 ON LINE 288
	if ext.trap
	then if (new_type_pair.type = LINK_CREATE_IF_NOT_FOUND)
		| ((new_type_pair.type = LINK_SELF_OFFSETNAME) & (class = SECTION_SYSTEM))
	     then do;

000546  aa  1 00126 2351 00	lda  	pr1|86		ext.trap
000547  aa   000022 7350 00	als  	18
000550  aa   000242 6000 04	tze  	162,ic		001012
000551  aa  6 00531 7551 00	sta  	pr6|345		ext.trap
000552  aa   000006 2350 03	lda  	6,du
000553  aa   000066 7730 00	lrl  	54
000554  aa  6 00530 1161 00	cmpq 	pr6|344		new_type_pair.type
000555  aa   000011 6000 04	tze  	9,ic		000566
000556  aa   000005 2350 03	lda  	5,du
000557  aa   000066 7730 00	lrl  	54
000560  aa  6 00530 1161 00	cmpq 	pr6|344		new_type_pair.type
000561  aa   000023 6010 04	tnz  	19,ic		000604
000562  aa   000005 2350 03	lda  	5,du
000563  aa   000066 7730 00	lrl  	54
000564  aa  6 00115 1161 00	cmpq 	pr6|77		class
000565  aa   000017 6010 04	tnz  	15,ic		000604
						STATEMENT 1 ON LINE 293
		orig_init_info_ptr = addrel (comp.cdefp, ext.trap);

000566  aa  6 00531 2351 00	lda  	pr6|345		ext.trap
000567  aa  6 00440 3715 20	epp5 	pr6|288,*		ctep
000570  aa  5 00016 3521 61	epp2 	pr5|14,*au	comp.cdefp
000571  aa   000000 0520 03	adwp2	0,du
000572  aa  6 00300 2521 00	spri2	pr6|192		orig_init_info_ptr
						STATEMENT 1 ON LINE 294
		call find_init_map_entry ();

000573  aa   002504 6700 04	tsp4 	1348,ic		003277
						STATEMENT 1 ON LINE 295
		new_has_init_template = (init_map (new_init_map_index).template_size > 0);

000574  aa  6 00106 2361 00	ldq  	pr6|70		new_init_map_index
000575  aa   000003 7360 00	qls  	3
000576  aa  6 00044 3701 20	epp4 	pr6|36,*
000577  ia  4 00020 3735 20	epp7 	pr4|16,*		init_map_ptr
000600  aa  7 77774 2361 06	ldq  	pr7|-4,ql		init_map.template_size
000601  aa  0 00503 7001 00	tsx0 	pr0|323		r_g_a
000602  aa  6 00314 7551 00	sta  	pr6|204		new_has_init_template
						STATEMENT 1 ON LINE 296
	     end;

000603  aa   000207 7100 04	tra  	135,ic		001012
						STATEMENT 1 ON LINE 298
	     else do;

						STATEMENT 1 ON LINE 299
		addr (scratch) -> copy_save = ap -> copy_save;

000604  ia  4 00144 2361 00	ldq  	pr4|100		ext_lng
000605  aa   000002 7360 00	qls  	2
000606  aa  000 140 100 540	mlr  	(pr,rl),(pr,rl),fill(000)
000607  aa  1 00000 00 0006	desc9a	pr1|0,ql		copy_save
000610  aa  6 00121 00 0006	desc9a	pr6|81,ql		copy_save
						STATEMENT 1 ON LINE 301
		ext.offset = ext.loffset;

000611  aa  1 00011 2361 00	ldq  	pr1|9		ext.loffset
000612  aa  1 00004 7561 00	stq  	pr1|4		ext.offset
						STATEMENT 1 ON LINE 302
		ext.section = "link";

000613  aa   777214 2350 04	lda  	-372,ic		000027 = 154151156153
000614  aa  1 00010 7551 00	sta  	pr1|8		ext.section
						STATEMENT 1 ON LINE 303
		ext.relinfo = " ";

000615  aa   777227 2370 04	ldaq 	-361,ic		000044 = 040040040040 040040040040
000616  aa  1 00006 7551 00	sta  	pr1|6		ext.relinfo
000617  aa  1 00007 7561 00	stq  	pr1|7		ext.relinfo
						STATEMENT 1 ON LINE 304
		old_trap = addrel (comp.cdefp, ext.trap);

000620  aa  6 00531 2351 00	lda  	pr6|345		ext.trap
000621  aa  6 00440 3715 20	epp5 	pr6|288,*		ctep
000622  aa  5 00016 3521 61	epp2 	pr5|14,*au	comp.cdefp
000623  aa   000000 0520 03	adwp2	0,du
000624  aa  6 00272 2521 00	spri2	pr6|186		old_trap
						STATEMENT 1 ON LINE 305
		ext.loffset = old_trap -> link_trap_pair.call_relp;

000625  aa  2 00000 2351 00	lda  	pr2|0		link_trap_pair.call_relp
000626  aa   000066 7730 00	lrl  	54
000627  aa  1 00011 7561 00	stq  	pr1|9		ext.loffset
						STATEMENT 1 ON LINE 306
		if decode_link_ (ap)
		then go to trap_error;

000630  aa  6 00266 3521 00	epp2 	pr6|182		ap
000631  aa  6 00534 2521 00	spri2	pr6|348
000632  aa  6 00531 3521 00	epp2 	pr6|345
000633  aa  6 00536 2521 00	spri2	pr6|350
000634  aa  6 00532 6211 00	eax1 	pr6|346
000635  aa   010000 4310 07	fld  	4096,dl
000636  la  4 00146 3521 20	epp2 	pr4|102,*		decode_link_
000637  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000640  aa  6 00531 2351 00	lda  	pr6|345
000641  aa   400000 3150 03	cana 	131072,du
000642  aa   001460 6010 04	tnz  	816,ic		002322
						STATEMENT 1 ON LINE 310
		new_trap_pair.call_relp = ext_link_$gen_trap (ap);

000643  aa  6 00266 3521 00	epp2 	pr6|182		ap
000644  aa  6 00534 2521 00	spri2	pr6|348
000645  aa  6 00531 3521 00	epp2 	pr6|345
000646  aa  6 00536 2521 00	spri2	pr6|350
000647  aa  6 00532 6211 00	eax1 	pr6|346
000650  aa   010000 4310 07	fld  	4096,dl
000651  aa  6 00044 3701 20	epp4 	pr6|36,*
000652  la  4 00150 3521 20	epp2 	pr4|104,*		ext_link_$gen_trap
000653  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000654  aa  6 00531 2361 00	ldq  	pr6|345
000655  aa   000066 7370 00	lls  	54
000656  aa  6 00422 5511 60	stba 	pr6|274,60	new_trap_pair.call_relp
						STATEMENT 1 ON LINE 313
		ext.loffset = old_trap -> link_trap_pair.info_relp;

000657  aa  6 00272 2361 20	ldq  	pr6|186,*		link_trap_pair.info_relp
000660  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000661  aa  6 00266 3735 20	epp7 	pr6|182,*		ap
000662  aa  7 00011 7561 00	stq  	pr7|9		ext.loffset
						STATEMENT 1 ON LINE 315
		if ext.loffset > 0
		then do;

000663  aa   000032 6044 04	tmoz 	26,ic		000715
						STATEMENT 1 ON LINE 317
		     if decode_link_ (ap) = "1"b
		     then go to trap_error;

000664  aa  6 00266 3521 00	epp2 	pr6|182		ap
000665  aa  6 00534 2521 00	spri2	pr6|348
000666  aa  6 00531 3521 00	epp2 	pr6|345
000667  aa  6 00536 2521 00	spri2	pr6|350
000670  aa  6 00532 6211 00	eax1 	pr6|346
000671  aa   010000 4310 07	fld  	4096,dl
000672  aa  6 00044 3701 20	epp4 	pr6|36,*
000673  la  4 00146 3521 20	epp2 	pr4|102,*		decode_link_
000674  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000675  aa  6 00531 2351 00	lda  	pr6|345
000676  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000677  aa   400000 1150 03	cmpa 	131072,du
000700  aa   001422 6000 04	tze  	786,ic		002322
						STATEMENT 1 ON LINE 319
		     new_trap_pair.info_relp = ext_link_$gen_trap (ap);

000701  aa  6 00266 3521 00	epp2 	pr6|182		ap
000702  aa  6 00534 2521 00	spri2	pr6|348
000703  aa  6 00531 3521 00	epp2 	pr6|345
000704  aa  6 00536 2521 00	spri2	pr6|350
000705  aa  6 00532 6211 00	eax1 	pr6|346
000706  aa   010000 4310 07	fld  	4096,dl
000707  aa  6 00044 3701 20	epp4 	pr6|36,*
000710  la  4 00150 3521 20	epp2 	pr4|104,*		ext_link_$gen_trap
000711  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000712  aa  6 00531 2361 00	ldq  	pr6|345
000713  aa  6 00422 5521 14	stbq 	pr6|274,14	new_trap_pair.info_relp
						STATEMENT 1 ON LINE 320
		end;

000714  aa   000003 7100 04	tra  	3,ic		000717
						STATEMENT 1 ON LINE 321
		else new_trap_pair.info_relp = 0;

000715  aa   000000 2350 03	lda  	0,du
000716  aa  6 00422 5511 14	stba 	pr6|274,14	new_trap_pair.info_relp
						STATEMENT 1 ON LINE 323
		do i = 1 to n_tbls;

000717  aa  6 00044 3701 20	epp4 	pr6|36,*
000720  ia  4 00022 2361 00	ldq  	pr4|18		n_tbls
000721  aa  6 00453 7561 00	stq  	pr6|299
000722  aa   000001 2360 07	ldq  	1,dl
000723  aa  6 00100 7561 00	stq  	pr6|64		i
000724  aa  6 00100 2361 00	ldq  	pr6|64		i
000725  aa  6 00453 1161 00	cmpq 	pr6|299
000726  aa   000024 6054 04	tpnz 	20,ic		000752
						STATEMENT 1 ON LINE 324
		     if unspec (new_trap_pair) = unspec (addrel (defbase, tbl_offset (i)) -> link_trap_pair)
		     then do;

000727  aa   000022 4020 07	mpy  	18,dl
000730  aa  6 00044 3701 20	epp4 	pr6|36,*
000731  ia  4 00014 3735 20	epp7 	pr4|12,*		tblp
000732  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
000733  aa  7 77777 40 0022	descb	pr7|-1(18),18	tbl_map.tbl_offset
000734  aa  6 00056 00 0044	descb	pr6|46,36
000735  aa  6 00056 2351 00	lda  	pr6|46
000736  aa  6 00531 7561 00	stq  	pr6|345
000737  aa   000066 7730 00	lrl  	54
000740  aa  6 00531 7561 00	stq  	pr6|345		tbl_map.tbl_offset
000741  ia  4 00012 3521 66	epp2 	pr4|10,*ql	defbase
000742  aa   000000 0520 03	adwp2	0,du
000743  aa  6 00422 2351 00	lda  	pr6|274
000744  aa  2 00000 1151 00	cmpa 	pr2|0
000745  aa   000003 6010 04	tnz  	3,ic		000750
						STATEMENT 1 ON LINE 326
			new_type_pair.trap_relp = tbl_offset (i);

000746  aa  6 00420 5521 14	stbq 	pr6|272,14	new_type_pair.trap_relp
						STATEMENT 1 ON LINE 328
			go to restore_ext;

000747  aa   000035 7100 04	tra  	29,ic		001004
						STATEMENT 1 ON LINE 329
		     end;

						STATEMENT 1 ON LINE 330
		end;

000750  aa  6 00100 0541 00	aos  	pr6|64		i
000751  aa   777753 7100 04	tra  	-21,ic		000724
						STATEMENT 1 ON LINE 332
		n_tbls = i;

000752  aa  6 00044 3701 20	epp4 	pr6|36,*
000753  ia  4 00022 7561 00	stq  	pr4|18		n_tbls
						STATEMENT 1 ON LINE 333
		tbl_offset (i), new_type_pair.trap_relp = bx_$curdeflng;

000754  la  4 00210 2361 20	ldq  	pr4|136,*		bx_$curdeflng
000755  aa  6 00531 7561 00	stq  	pr6|345
000756  aa  6 00100 2361 00	ldq  	pr6|64		i
000757  aa   000022 4020 07	mpy  	18,dl
000760  aa   000000 6270 06	eax7 	0,ql
000761  aa  6 00531 2361 00	ldq  	pr6|345
000762  aa   000066 7370 00	lls  	54
000763  aa  6 00056 7551 00	sta  	pr6|46
000764  ia  4 00014 3735 20	epp7 	pr4|12,*		tblp
000765  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
000766  aa  6 00056 00 0022	descb	pr6|46,18
000767  aa  7 77777 40 0022	descb	pr7|-1(18),18	tbl_map.tbl_offset
000770  aa  6 00531 2361 00	ldq  	pr6|345
000771  aa  6 00420 5521 14	stbq 	pr6|272,14	new_type_pair.trap_relp
						STATEMENT 1 ON LINE 334
		bx_$curdeflng = bx_$curdeflng + 1;

000772  la  4 00210 0541 20	aos  	pr4|136,*		bx_$curdeflng
						STATEMENT 1 ON LINE 335
		addrel (defbase, tbl_offset (i)) -> link_trap_pair = new_trap_pair;

000773  aa  003 100 060 517	csl  	(pr,x7),(pr),fill(0),bool(move)
000774  aa  7 77777 40 0022	descb	pr7|-1(18),18	tbl_map.tbl_offset
000775  aa  6 00056 00 0044	descb	pr6|46,36
000776  aa  6 00056 2351 00	lda  	pr6|46
000777  aa   000066 7730 00	lrl  	54
001000  ia  4 00012 3521 66	epp2 	pr4|10,*ql	defbase
001001  aa   000000 0520 03	adwp2	0,du
001002  aa  6 00422 2351 00	lda  	pr6|274		new_trap_pair
001003  aa  2 00000 7551 00	sta  	pr2|0		link_trap_pair
						STATEMENT 1 ON LINE 337
restore_ext:
		ap -> copy_save = addr (scratch) -> copy_save;

001004  ia  4 00144 2361 00	ldq  	pr4|100		ext_lng
001005  aa   000002 7360 00	qls  	2
001006  aa  6 00266 3715 20	epp5 	pr6|182,*		ap
001007  aa  000 140 100 540	mlr  	(pr,rl),(pr,rl),fill(000)
001010  aa  6 00121 00 0006	desc9a	pr6|81,ql		copy_save
001011  aa  5 00000 00 0006	desc9a	pr5|0,ql		copy_save
						STATEMENT 1 ON LINE 340
	     end;

						STATEMENT 1 ON LINE 344
	def_growth = 0;

001012  aa  6 00101 4501 00	stz  	pr6|65		def_growth
						STATEMENT 1 ON LINE 345
	new_exp_word.expression = bin (ext.expr, 17);

001013  aa  6 00266 3735 20	epp7 	pr6|182,*		ap
001014  aa  7 00127 2351 00	lda  	pr7|87		ext.expr
001015  aa   000066 7730 00	lrl  	54
001016  aa  6 00417 5521 14	stbq 	pr6|271,14	new_exp_word.expression
						STATEMENT 1 ON LINE 347
	if new_type_pair.type = LINK_SELF_BASE | new_type_pair.type = LINK_SELF_OFFSETNAME
	then do;

001017  aa  6 00420 2351 00	lda  	pr6|272		new_type_pair.type
001020  aa   000066 7730 00	lrl  	54
001021  aa  6 00531 7561 00	stq  	pr6|345		new_type_pair.type
001022  aa   000001 2350 03	lda  	1,du
001023  aa   000066 7730 00	lrl  	54
001024  aa  6 00531 1161 00	cmpq 	pr6|345		new_type_pair.type
001025  aa   000005 6000 04	tze  	5,ic		001032
001026  aa   000005 2350 03	lda  	5,du
001027  aa   000066 7730 00	lrl  	54
001030  aa  6 00531 1161 00	cmpq 	pr6|345		new_type_pair.type
001031  aa   000065 6010 04	tnz  	53,ic		001116
						STATEMENT 1 ON LINE 349
	     new_type_pair.segname_relp = class;

001032  aa  6 00115 2361 00	ldq  	pr6|77		class
001033  aa   000066 7370 00	lls  	54
001034  aa  6 00421 5511 60	stba 	pr6|273,60	new_type_pair.segname_relp
						STATEMENT 1 ON LINE 350
	     segname_found = "1"b;

001035  aa   400000 2350 03	lda  	131072,du
001036  aa  6 00307 7551 00	sta  	pr6|199		segname_found
						STATEMENT 1 ON LINE 351
	     if bx_$bound_sep_stat ^= 1
	     then if class = SECTION_STATIC		/* link to *static */
		then new_type_pair.segname_relp = SECTION_LINK;

001037  la  4 00206 2361 20	ldq  	pr4|134,*		bx_$bound_sep_stat
001040  aa   000001 1160 07	cmpq 	1,dl
001041  aa   000007 6000 04	tze  	7,ic		001050
001042  aa   000004 2350 03	lda  	4,du
001043  aa   000066 7730 00	lrl  	54
001044  aa  6 00115 1161 00	cmpq 	pr6|77		class
001045  aa   000003 6010 04	tnz  	3,ic		001050
001046  aa   000001 2350 03	lda  	1,du
001047  aa  6 00421 5511 60	stba 	pr6|273,60	new_type_pair.segname_relp
						STATEMENT 1 ON LINE 355
	     if new_type_pair.type = LINK_SELF_BASE
	     then do;

001050  aa   000001 2350 03	lda  	1,du
001051  aa   000066 7730 00	lrl  	54
001052  aa  6 00531 1161 00	cmpq 	pr6|345		new_type_pair.type
001053  aa   000043 6010 04	tnz  	35,ic		001116
						STATEMENT 1 ON LINE 357
		entryname_found = "1"b;

001054  aa   400000 2350 03	lda  	131072,du
001055  aa  6 00310 7551 00	sta  	pr6|200		entryname_found
						STATEMENT 1 ON LINE 358
		if class = SECTION_TEXT
		then new_exp_word.expression = new_exp_word.expression + comp.crelt;

001056  aa   000000 4310 07	fld  	0,dl
001057  aa  6 00115 1161 00	cmpq 	pr6|77		class
001060  aa   000007 6010 04	tnz  	7,ic		001067
001061  aa  6 00417 2351 00	lda  	pr6|271		new_exp_word.expression
001062  aa   000022 7350 00	als  	18
001063  aa   000066 7330 00	lrs  	54
001064  aa  6 00440 3715 20	epp5 	pr6|288,*		ctep
001065  aa  5 00073 0761 00	adq  	pr5|59		comp.crelt
001066  aa  6 00417 5521 14	stbq 	pr6|271,14	new_exp_word.expression
						STATEMENT 1 ON LINE 360
		if class = SECTION_STATIC
		then do;

001067  aa   000004 2350 03	lda  	4,du
001070  aa   000066 7730 00	lrl  	54
001071  aa  6 00115 1161 00	cmpq 	pr6|77		class
001072  aa   000123 6010 04	tnz  	83,ic		001215
						STATEMENT 1 ON LINE 362
		     if wsegname = "*static"
		     then do;

001073  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
001074  ia  4 00032 00 0041	desc9a	pr4|26,33		wsegname
001075  aa   776747 00 0007	desc9a	-537,7		000042 = 052163164141
001076  aa   000117 6010 04	tnz  	79,ic		001215
						STATEMENT 1 ON LINE 364
			if bx_$bound_sep_stat = 1
			then i = 0;

001077  la  4 00206 2361 20	ldq  	pr4|134,*		bx_$bound_sep_stat
001100  aa   000001 1160 07	cmpq 	1,dl
001101  aa   000003 6010 04	tnz  	3,ic		001104
001102  aa  6 00100 4501 00	stz  	pr6|64		i
001103  aa   000003 7100 04	tra  	3,ic		001106
						STATEMENT 1 ON LINE 366
			else i = 8;

001104  aa   000010 2360 07	ldq  	8,dl
001105  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 367
			new_exp_word.expression = new_exp_word.expression + comp.creli + i;

001106  aa  6 00417 2351 00	lda  	pr6|271		new_exp_word.expression
001107  aa   000022 7350 00	als  	18
001110  aa   000066 7330 00	lrs  	54
001111  aa  6 00440 3715 20	epp5 	pr6|288,*		ctep
001112  aa  5 00074 0761 00	adq  	pr5|60		comp.creli
001113  aa  6 00100 0761 00	adq  	pr6|64		i
001114  aa  6 00417 5521 14	stbq 	pr6|271,14	new_exp_word.expression
						STATEMENT 1 ON LINE 368
		     end;

						STATEMENT 1 ON LINE 369
		end;

						STATEMENT 1 ON LINE 372
		go to lookup_links;

001115  aa   000100 7100 04	tra  	64,ic		001215
						STATEMENT 1 ON LINE 373
	     end;

						STATEMENT 1 ON LINE 374
	end;

						STATEMENT 1 ON LINE 378
	if ^segname_found
	then do;

001116  aa  6 00307 2351 00	lda  	pr6|199		segname_found
001117  aa   000036 6010 04	tnz  	30,ic		001155
						STATEMENT 1 ON LINE 380
	     call strm_hash_$lookup (substr (ext.segname, 1, ext.slng), strm_index);

001120  aa  7 00023 2361 00	ldq  	pr7|19		ext.slng
001121  aa   524000 2760 03	orq  	174080,du
001122  aa  6 00531 7561 00	stq  	pr6|345
001123  aa  7 00023 2361 00	ldq  	pr7|19		ext.slng
001124  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
001125  aa  6 00544 2521 00	spri2	pr6|356
001126  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001127  aa  7 00012 00 0006	desc9a	pr7|10,ql		ext.segname
001130  aa  2 00000 00 0006	desc9a	pr2|0,ql
001131  aa  6 00107 3521 00	epp2 	pr6|71		strm_index
001132  aa  6 00546 2521 00	spri2	pr6|358
001133  aa  6 00531 3521 00	epp2 	pr6|345
001134  aa  6 00550 2521 00	spri2	pr6|360
001135  aa   776670 3520 04	epp2 	-584,ic		000025 = 404000000021
001136  aa  6 00552 2521 00	spri2	pr6|362
001137  aa  6 00542 6211 00	eax1 	pr6|354
001140  aa   010000 4310 07	fld  	4096,dl
001141  la  4 00162 3521 20	epp2 	pr4|114,*		strm_hash_$lookup
001142  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 381
	     if strm_index ^= 0
	     then do;

001143  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
001144  aa  6 00107 2361 00	ldq  	pr6|71		strm_index
001145  aa   000010 6000 04	tze  	8,ic		001155
						STATEMENT 1 ON LINE 383
		new_type_pair.segname_relp = bin (strm.entry (strm_index).map, 18);

001146  aa  6 00442 3735 20	epp7 	pr6|290,*		strmp
001147  aa  7 01540 2351 06	lda  	pr7|864,ql	strm.map
001150  aa   000066 7730 00	lrl  	54
001151  aa   000066 7370 00	lls  	54
001152  aa  6 00421 5511 60	stba 	pr6|273,60	new_type_pair.segname_relp
						STATEMENT 1 ON LINE 384
		segname_found = "1"b;

001153  aa   400000 2350 03	lda  	131072,du
001154  aa  6 00307 7551 00	sta  	pr6|199		segname_found
						STATEMENT 1 ON LINE 385
	     end;

						STATEMENT 1 ON LINE 386
	end;

						STATEMENT 1 ON LINE 387
	if ^entryname_found
	then do;

001155  aa  6 00310 2351 00	lda  	pr6|200		entryname_found
001156  aa   000037 6010 04	tnz  	31,ic		001215
						STATEMENT 1 ON LINE 389
	     call strm_hash_$lookup (substr (ext.entryname, 1, ext.elng), strm_index);

001157  aa  6 00266 3735 20	epp7 	pr6|182,*		ap
001160  aa  7 00125 2361 00	ldq  	pr7|85		ext.elng
001161  aa   524000 2760 03	orq  	174080,du
001162  aa  6 00531 7561 00	stq  	pr6|345
001163  aa  7 00125 2361 00	ldq  	pr7|85		ext.elng
001164  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
001165  aa  6 00544 2521 00	spri2	pr6|356
001166  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001167  aa  7 00024 00 0006	desc9a	pr7|20,ql		ext.entryname
001170  aa  2 00000 00 0006	desc9a	pr2|0,ql
001171  aa  6 00107 3521 00	epp2 	pr6|71		strm_index
001172  aa  6 00546 2521 00	spri2	pr6|358
001173  aa  6 00531 3521 00	epp2 	pr6|345
001174  aa  6 00550 2521 00	spri2	pr6|360
001175  aa   776630 3520 04	epp2 	-616,ic		000025 = 404000000021
001176  aa  6 00552 2521 00	spri2	pr6|362
001177  aa  6 00542 6211 00	eax1 	pr6|354
001200  aa   010000 4310 07	fld  	4096,dl
001201  aa  6 00044 3701 20	epp4 	pr6|36,*
001202  la  4 00162 3521 20	epp2 	pr4|114,*		strm_hash_$lookup
001203  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 390
	     if strm_index ^= 0
	     then do;

001204  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
001205  aa  6 00107 2361 00	ldq  	pr6|71		strm_index
001206  aa   000007 6000 04	tze  	7,ic		001215
						STATEMENT 1 ON LINE 392
		new_type_pair.offsetname_relp = bin (strm.entry (strm_index).map, 18);

001207  aa  6 00442 3735 20	epp7 	pr6|290,*		strmp
001210  aa  7 01540 2351 06	lda  	pr7|864,ql	strm.map
001211  aa   000066 7730 00	lrl  	54
001212  aa  6 00421 5521 14	stbq 	pr6|273,14	new_type_pair.offsetname_relp
						STATEMENT 1 ON LINE 393
		entryname_found = "1"b;

001213  aa   400000 2350 03	lda  	131072,du
001214  aa  6 00310 7551 00	sta  	pr6|200		entryname_found
						STATEMENT 1 ON LINE 394
	     end;

						STATEMENT 1 ON LINE 395
	end;

						STATEMENT 1 ON LINE 397
lookup_links:
	do linkmapx = 1 to nlinks;

001215  aa  6 00044 3701 20	epp4 	pr6|36,*
001216  ia  4 00023 2361 00	ldq  	pr4|19		nlinks
001217  aa  6 00454 7561 00	stq  	pr6|300
001220  aa   000001 2360 07	ldq  	1,dl
001221  aa  6 00103 7561 00	stq  	pr6|67		linkmapx
001222  aa  6 00103 2361 00	ldq  	pr6|67		linkmapx
001223  aa  6 00454 1161 00	cmpq 	pr6|300
001224  aa   000472 6054 04	tpnz 	314,ic		001716
						STATEMENT 1 ON LINE 399
	     step = linkmap (linkmapx).linkaddr;

001225  aa   000014 4020 07	mpy  	12,dl
001226  aa  6 00044 3701 20	epp4 	pr6|36,*
001227  ia  4 00016 3735 20	epp7 	pr4|14,*		newlinkp
001230  aa  7 77766 2351 06	lda  	pr7|-10,ql	linkmap.linkaddr
001231  aa  6 00531 7561 00	stq  	pr6|345
001232  aa   000066 7730 00	lrl  	54
001233  aa  6 00113 7561 00	stq  	pr6|75		step
						STATEMENT 1 ON LINE 400
	     link_ptr = addrel (linkbase, step);

001234  ia  4 00010 3521 66	epp2 	pr4|8,*ql		linkbase
001235  aa   000000 0520 03	adwp2	0,du
001236  aa  6 00270 2521 00	spri2	pr6|184		link_ptr
						STATEMENT 1 ON LINE 401
	     if link_ptr -> object_link.modifier ^= new_link_modifier
	     then go to advance;

001237  aa  2 00001 2351 00	lda  	pr2|1		object_link.modifier
001240  aa   000036 7350 00	als  	30
001241  aa  6 00306 1151 00	cmpa 	pr6|198		new_link_modifier
001242  aa   000452 6010 04	tnz  	298,ic		001714
						STATEMENT 1 ON LINE 403
	     exp_ptr = addrel (defbase, link_ptr -> object_link.expression_relp);

001243  aa  2 00001 2351 00	lda  	pr2|1		object_link.expression_relp
001244  aa   000066 7730 00	lrl  	54
001245  ia  4 00012 3515 66	epp1 	pr4|10,*ql	defbase
001246  aa   000000 0510 03	adwp1	0,du
001247  aa  6 00446 2515 00	spri1	pr6|294		exp_ptr
						STATEMENT 1 ON LINE 404
	     if ^typepair_found
	     then do;

001250  aa  6 00311 2351 00	lda  	pr6|201		typepair_found
001251  aa   000436 6010 04	tnz  	286,ic		001707
						STATEMENT 1 ON LINE 406
		new_exp_word.type_relp = exp_ptr -> exp_word.type_relp;

001252  aa  1 00000 2351 00	lda  	pr1|0		exp_word.type_relp
001253  aa  6 00417 5511 60	stba 	pr6|271,60	new_exp_word.type_relp
						STATEMENT 1 ON LINE 408
		type_ptr = linkmap (linkmapx).type_ptr;

001254  aa  6 00531 7271 00	lxl7 	pr6|345
001255  aa  7 77764 3715 37	epp5 	pr7|-12,7*	linkmap.type_ptr
001256  aa  6 00450 6515 00	spri5	pr6|296		type_ptr
						STATEMENT 1 ON LINE 409
	     end;

						STATEMENT 1 ON LINE 412
	     if segname_found & entryname_found
	     then do;

001257  aa  6 00307 2351 00	lda  	pr6|199		segname_found
001260  aa   000434 6000 04	tze  	284,ic		001714
001261  aa  6 00310 2351 00	lda  	pr6|200		entryname_found
001262  aa   000432 6000 04	tze  	282,ic		001714
						STATEMENT 1 ON LINE 414
		if unspec (new_type_pair) ^= unspec (type_ptr -> type_pair)
		then go to advance;

001263  aa  6 00420 2371 00	ldaq 	pr6|272
001264  aa  5 00000 1151 00	cmpa 	pr5|0
001265  aa   000002 6010 04	tnz  	2,ic		001267
001266  aa  5 00001 1161 00	cmpq 	pr5|1
001267  aa   000425 6010 04	tnz  	277,ic		001714
						STATEMENT 1 ON LINE 417
		if new_init_map_index = linkmap (linkmapx).init_map_index
		then go to use_typepair;

001270  aa  7 77766 2351 17	lda  	pr7|-10,7		linkmap.init_map_index
001271  aa   000022 7350 00	als  	18
001272  aa   000066 7330 00	lrs  	54
001273  aa  6 00106 1161 00	cmpq 	pr6|70		new_init_map_index
001274  aa   000413 6000 04	tze  	267,ic		001707
						STATEMENT 1 ON LINE 422
		if (new_type_pair.type ^= LINK_CREATE_IF_NOT_FOUND)
		     & ^((new_type_pair.type = LINK_SELF_OFFSETNAME) & (class = SECTION_SYSTEM))
		then go to advance;

001275  aa  6 00420 2351 00	lda  	pr6|272		new_type_pair.type
001276  aa  6 00530 7561 00	stq  	pr6|344		linkmap.init_map_index
001277  aa   000066 7730 00	lrl  	54
001300  aa   000006 2350 03	lda  	6,du
001301  aa  6 00554 7561 00	stq  	pr6|364		new_type_pair.type
001302  aa   000066 7730 00	lrl  	54
001303  aa  6 00554 1161 00	cmpq 	pr6|364		new_type_pair.type
001304  aa   000011 6000 04	tze  	9,ic		001315
001305  aa   000005 2350 03	lda  	5,du
001306  aa   000066 7730 00	lrl  	54
001307  aa  6 00554 1161 00	cmpq 	pr6|364		new_type_pair.type
001310  aa   000404 6010 04	tnz  	260,ic		001714
001311  aa   000005 2350 03	lda  	5,du
001312  aa   000066 7730 00	lrl  	54
001313  aa  6 00115 1161 00	cmpq 	pr6|77		class
001314  aa   000400 6010 04	tnz  	256,ic		001714
						STATEMENT 1 ON LINE 434
		existing_init_type = init_map (linkmap (linkmapx).init_map_index).init_ptr -> link_init.type;

001315  aa  6 00530 2361 00	ldq  	pr6|344		linkmap.init_map_index
001316  aa   000003 7360 00	qls  	3
001317  ia  4 00020 3535 20	epp3 	pr4|16,*		init_map_ptr
001320  aa  3 77770 3515 26	epp1 	pr3|-8,ql*	init_map.init_ptr
001321  aa  6 00530 7561 00	stq  	pr6|344
001322  aa  1 00001 2361 00	ldq  	pr1|1		link_init.type
001323  aa  6 00111 7561 00	stq  	pr6|73		existing_init_type
						STATEMENT 1 ON LINE 435
		if linkmap (linkmapx).incompatible_init_types
		then return;

001324  aa  7 77777 2351 17	lda  	pr7|-1,7		linkmap.incompatible_init_types
001325  aa   040000 3150 03	cana 	16384,du
001326  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 437
		if ((new_init_type = INIT_DEFINE_AREA) & (existing_init_type ^= INIT_DEFINE_AREA))
		     | ((existing_init_type = INIT_DEFINE_AREA) & (new_init_type ^= INIT_DEFINE_AREA))
		then do;

001327  aa  6 00110 2361 00	ldq  	pr6|72		new_init_type
001330  aa   000004 1160 07	cmpq 	4,dl
001331  aa   000004 6010 04	tnz  	4,ic		001335
001332  aa  6 00111 2361 00	ldq  	pr6|73		existing_init_type
001333  aa   000004 1160 07	cmpq 	4,dl
001334  aa   000007 6010 04	tnz  	7,ic		001343
001335  aa  6 00111 2361 00	ldq  	pr6|73		existing_init_type
001336  aa   000004 1160 07	cmpq 	4,dl
001337  aa   000073 6010 04	tnz  	59,ic		001432
001340  aa  6 00110 2361 00	ldq  	pr6|72		new_init_type
001341  aa   000004 1160 07	cmpq 	4,dl
001342  aa   000070 6000 04	tze  	56,ic		001432
						STATEMENT 1 ON LINE 440
		     call com_err_ (0, errname,
			"External variable ^[^a^a^;^2s^]^a has incompatible initialization types.",
			wsegname ^= "*system", wsegname, substr (wentryname, 1, 1), substr (wentryname, 2));

001343  aa  6 00554 4501 00	stz  	pr6|364
001344  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001345  aa   776557 00 0110	desc9a	-657,72		000123 = 105170164145
001346  aa  6 00556 00 0110	desc9a	pr6|366,72
001347  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
001350  ia  4 00032 00 0041	desc9a	pr4|26,33		wsegname
001351  aa   776477 00 0007	desc9a	-705,7		000046 = 052163171163
001352  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
001353  aa  6 00555 7551 00	sta  	pr6|365
001354  ia  4 00043 2351 00	lda  	pr4|35		wentryname
001355  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001356  aa  6 00600 7551 00	sta  	pr6|384
001357  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
001360  ia  4 00043 20 0400	desc9a	pr4|35(1),256	wentryname
001361  aa  6 00602 00 0400	desc9a	pr6|386,256
001362  aa  6 00554 3521 00	epp2 	pr6|364
001363  aa  6 00704 2521 00	spri2	pr6|452
001364  ia  4 00026 3521 00	epp2 	pr4|22		errname
001365  aa  6 00706 2521 00	spri2	pr6|454
001366  aa  6 00556 3521 00	epp2 	pr6|366
001367  aa  6 00710 2521 00	spri2	pr6|456
001370  aa  6 00555 3521 00	epp2 	pr6|365
001371  aa  6 00712 2521 00	spri2	pr6|458
001372  ia  4 00032 3521 00	epp2 	pr4|26		wsegname
001373  aa  6 00714 2521 00	spri2	pr6|460
001374  aa  6 00600 3521 00	epp2 	pr6|384
001375  aa  6 00716 2521 00	spri2	pr6|462
001376  aa  6 00602 3521 00	epp2 	pr6|386
001377  aa  6 00720 2521 00	spri2	pr6|464
001400  aa   776424 3520 04	epp2 	-748,ic		000024 = 404000000005
001401  aa  6 00722 2521 00	spri2	pr6|466
001402  aa   776421 3520 04	epp2 	-751,ic		000023 = 524000000020
001403  aa  6 00724 2521 00	spri2	pr6|468
001404  aa   776416 3520 04	epp2 	-754,ic		000022 = 524000000110
001405  aa  6 00726 2521 00	spri2	pr6|470
001406  aa   776423 3520 04	epp2 	-749,ic		000031 = 514000000001
001407  aa  6 00730 2521 00	spri2	pr6|472
001410  aa   776411 3520 04	epp2 	-759,ic		000021 = 524000000041
001411  aa  6 00732 2521 00	spri2	pr6|474
001412  aa   776406 3520 04	epp2 	-762,ic		000020 = 524000000001
001413  aa  6 00734 2521 00	spri2	pr6|476
001414  aa   776403 3520 04	epp2 	-765,ic		000017 = 524000000400
001415  aa  6 00736 2521 00	spri2	pr6|478
001416  aa  6 00702 6211 00	eax1 	pr6|450
001417  aa   034000 4310 07	fld  	14336,dl
001420  la  4 00152 3521 20	epp2 	pr4|106,*		com_err_
001421  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 443
		     bx_$fatal_error = 1;

001422  aa   000001 2360 07	ldq  	1,dl
001423  aa  6 00044 3701 20	epp4 	pr6|36,*
001424  la  4 00200 7561 20	stq  	pr4|128,*		bx_$fatal_error
						STATEMENT 1 ON LINE 444
		     linkmap (linkmapx).incompatible_init_types = "1"b;

001425  aa   040000 2350 03	lda  	16384,du
001426  aa  6 00531 7271 00	lxl7 	pr6|345
001427  ia  4 00016 3735 20	epp7 	pr4|14,*		newlinkp
001430  aa  7 77777 2551 17	orsa 	pr7|-1,7		linkmap.incompatible_init_types
						STATEMENT 1 ON LINE 445
		     return;

001431  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 446
		end;

						STATEMENT 1 ON LINE 450
		string (new) = "0"b;

001432  aa  000 100 100 400	mlr  	(),(pr),fill(000)
001433  aa   000000 00 0000	desc9a	0,0
001434  aa  6 00423 00 0014	desc9a	pr6|275,12
						STATEMENT 1 ON LINE 451
		real_init_size = init_map (linkmap (linkmapx).init_map_index).total_init_size;

001435  aa  6 00530 7261 00	lxl6 	pr6|344
001436  aa  3 77775 2361 16	ldq  	pr3|-3,6		init_map.total_init_size
001437  aa  6 00120 7561 00	stq  	pr6|80		real_init_size
						STATEMENT 1 ON LINE 452
		if real_init_size = 0		/* no template */
		then real_init_size = init_map (linkmap (linkmapx).init_map_index).init_ptr -> link_init.n_words;

001440  aa   000003 6010 04	tnz  	3,ic		001443
001441  aa  1 00000 2361 00	ldq  	pr1|0		link_init.n_words
001442  aa  6 00120 7561 00	stq  	pr6|80		real_init_size
						STATEMENT 1 ON LINE 454
		init_size_compares (
		     sign (init_map (new_init_map_index).init_ptr -> link_init.n_words - real_init_size)) = "1"b;

001443  aa  6 00106 2361 00	ldq  	pr6|70		new_init_map_index
001444  aa   000003 7360 00	qls  	3
001445  aa  6 00530 7561 00	stq  	pr6|344
001446  aa  3 77770 3361 26	lcq  	pr3|-8,ql*	link_init.n_words
001447  aa   000044 7770 00	llr  	36
001450  aa   000044 7330 00	lrs  	36
001451  aa  6 00120 0331 00	adl  	pr6|80		real_init_size
001452  aa   000000 5330 00	negl 	0
001453  aa  0 00664 7001 00	tsx0 	pr0|436		sign_mac
001454  aa   400000 2350 03	lda  	131072,du
001455  aa  6 00424 7551 06	sta  	pr6|276,ql	init_size_compares
						STATEMENT 1 ON LINE 458
		if linkmap (linkmapx).has_init_template
		then init_before = "1"b;

001456  aa  7 77777 2351 17	lda  	pr7|-1,7		linkmap.has_init_template
001457  aa   400000 3150 03	cana 	131072,du
001460  aa   000004 6000 04	tze  	4,ic		001464
001461  aa   400000 2350 03	lda  	131072,du
001462  aa  6 00315 7551 00	sta  	pr6|205		init_before
001463  aa   000002 7100 04	tra  	2,ic		001465
						STATEMENT 1 ON LINE 460
		else init_before = "0"b;

001464  aa  6 00315 4501 00	stz  	pr6|205		init_before
						STATEMENT 1 ON LINE 461
		if ^new.equal
		then do;

001465  aa  6 00424 2351 00	lda  	pr6|276		new.equal
001466  aa   000062 6010 04	tnz  	50,ic		001550
						STATEMENT 1 ON LINE 463
		     if ^linkmap (linkmapx).diff_init_size
		     then do;

001467  aa  7 77777 2351 17	lda  	pr7|-1,7		linkmap.diff_init_size
001470  aa   200000 3150 03	cana 	65536,du
001471  aa   000057 6010 04	tnz  	47,ic		001550
						STATEMENT 1 ON LINE 465
			if bx_$brief ^= 1
			then call ioa_ (
				"Warning: external variable ^[^a^a^;^2s^]^a has different sizes;^/^-the largest will be used.",
				wsegname ^= "*system", wsegname, substr (wentryname, 1, 1),
				substr (wentryname, 2));

001472  la  4 00204 2361 20	ldq  	pr4|132,*		bx_$brief
001473  aa   000001 1160 07	cmpq 	1,dl
001474  aa   000047 6000 04	tze  	39,ic		001543
001475  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001476  aa   776450 00 0134	desc9a	-728,92		000145 = 127141162156
001477  aa  6 00702 00 0134	desc9a	pr6|450,92
001500  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
001501  ia  4 00032 00 0041	desc9a	pr4|26,33		wsegname
001502  aa   776346 00 0007	desc9a	-794,7		000046 = 052163171163
001503  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
001504  aa  6 00600 7551 00	sta  	pr6|384
001505  ia  4 00043 2351 00	lda  	pr4|35		wentryname
001506  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001507  aa  6 00555 7551 00	sta  	pr6|365
001510  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
001511  ia  4 00043 20 0400	desc9a	pr4|35(1),256	wentryname
001512  aa  6 00602 00 0400	desc9a	pr6|386,256
001513  aa  6 00702 3521 00	epp2 	pr6|450
001514  aa  6 00742 2521 00	spri2	pr6|482
001515  aa  6 00600 3521 00	epp2 	pr6|384
001516  aa  6 00744 2521 00	spri2	pr6|484
001517  ia  4 00032 3521 00	epp2 	pr4|26		wsegname
001520  aa  6 00746 2521 00	spri2	pr6|486
001521  aa  6 00555 3521 00	epp2 	pr6|365
001522  aa  6 00750 2521 00	spri2	pr6|488
001523  aa  6 00602 3521 00	epp2 	pr6|386
001524  aa  6 00752 2521 00	spri2	pr6|490
001525  aa   776271 3520 04	epp2 	-839,ic		000016 = 524000000134
001526  aa  6 00754 2521 00	spri2	pr6|492
001527  aa   776302 3520 04	epp2 	-830,ic		000031 = 514000000001
001530  aa  6 00756 2521 00	spri2	pr6|494
001531  aa   776270 3520 04	epp2 	-840,ic		000021 = 524000000041
001532  aa  6 00760 2521 00	spri2	pr6|496
001533  aa   776265 3520 04	epp2 	-843,ic		000020 = 524000000001
001534  aa  6 00762 2521 00	spri2	pr6|498
001535  aa   776262 3520 04	epp2 	-846,ic		000017 = 524000000400
001536  aa  6 00764 2521 00	spri2	pr6|500
001537  aa  6 00740 6211 00	eax1 	pr6|480
001540  aa   024000 4310 07	fld  	10240,dl
001541  la  4 00154 3521 20	epp2 	pr4|108,*		ioa_
001542  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 470
			linkmap (linkmapx).diff_init_size = "1"b;

001543  aa   200000 2350 03	lda  	65536,du
001544  aa  6 00044 3701 20	epp4 	pr6|36,*
001545  aa  6 00531 7271 00	lxl7 	pr6|345
001546  ia  4 00016 3735 20	epp7 	pr4|14,*		newlinkp
001547  aa  7 77777 2551 17	orsa 	pr7|-1,7		linkmap.diff_init_size
						STATEMENT 1 ON LINE 471
		     end;

						STATEMENT 1 ON LINE 472
		end;

						STATEMENT 1 ON LINE 476
		if new_has_init_template & init_before
		then if init_map (new_init_map_index).init_ptr
			^= init_map (linkmap (linkmapx).init_map_index).init_ptr
						/* make sure it's not the same template */
		     then do;

001550  aa  6 00314 2351 00	lda  	pr6|204		new_has_init_template
001551  aa   000026 6000 04	tze  	22,ic		001577
001552  aa  6 00315 2351 00	lda  	pr6|205		init_before
001553  aa   000024 6000 04	tze  	20,ic		001577
001554  aa  7 77766 2351 17	lda  	pr7|-10,7		linkmap.init_map_index
001555  aa   000022 7350 00	als  	18
001556  aa   000066 7330 00	lrs  	54
001557  aa   000003 7360 00	qls  	3
001560  aa  6 00530 7261 00	lxl6 	pr6|344
001561  ia  4 00020 3715 20	epp5 	pr4|16,*		init_map_ptr
001562  aa   000000 6250 06	eax5 	0,ql
001563  aa  5 77770 2371 16	ldaq 	pr5|-8,6		init_map.init_ptr
001564  aa  5 77770 6771 15	eraq 	pr5|-8,5		init_map.init_ptr
001565  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001566  aa   000011 6000 04	tze  	9,ic		001577
						STATEMENT 1 ON LINE 481
			linkmap (linkmapx).print_msg = "1"b;

001567  aa   100000 2350 03	lda  	32768,du
001570  aa  7 77777 2551 17	orsa 	pr7|-1,7		linkmap.print_msg
						STATEMENT 1 ON LINE 482
			if new.equal
			then if init_map (linkmap (linkmapx).init_map_index).total_init_size
				> init_map (linkmap (linkmapx).init_map_index).template_size
			     then call replace_init_info;

001571  aa  6 00424 2351 00	lda  	pr6|276		new.equal
001572  aa   000005 6000 04	tze  	5,ic		001577
001573  aa  5 77775 2361 15	ldq  	pr5|-3,5		init_map.total_init_size
001574  aa  5 77774 1161 15	cmpq 	pr5|-4,5		init_map.template_size
001575  aa   000002 6044 04	tmoz 	2,ic		001577
001576  aa   002057 6700 04	tsp4 	1071,ic		003655
						STATEMENT 1 ON LINE 487
		     end;

						STATEMENT 1 ON LINE 489
		if (new_has_init_template & ((new.equal & ^init_before) | (new.larger & init_before)))
		     | (new.larger & ^init_before)	/* cases 4, 10, 11, 12 */
		then call replace_init_info;

001577  aa  6 00315 2351 00	lda  	pr6|205		init_before
001600  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
001601  aa  6 00531 7551 00	sta  	pr6|345
001602  aa  6 00314 2351 00	lda  	pr6|204		new_has_init_template
001603  aa   000011 6000 04	tze  	9,ic		001614
001604  aa  6 00531 2351 00	lda  	pr6|345
001605  aa   000003 6000 04	tze  	3,ic		001610
001606  aa  6 00424 2351 00	lda  	pr6|276		new.equal
001607  aa   000011 6010 04	tnz  	9,ic		001620
001610  aa  6 00425 2351 00	lda  	pr6|277		new.larger
001611  aa   000003 6000 04	tze  	3,ic		001614
001612  aa  6 00315 2351 00	lda  	pr6|205		init_before
001613  aa   000005 6010 04	tnz  	5,ic		001620
001614  aa  6 00531 2351 00	lda  	pr6|345
001615  aa   000005 6000 04	tze  	5,ic		001622
001616  aa  6 00425 2351 00	lda  	pr6|277		new.larger
001617  aa   000003 6000 04	tze  	3,ic		001622
001620  aa   002035 6700 04	tsp4 	1053,ic		003655
001621  aa   000066 7100 04	tra  	54,ic		001707
						STATEMENT 1 ON LINE 493
		else if new.smaller & new_has_init_template & ^init_before
		then do;

001622  aa  6 00423 2351 00	lda  	pr6|275		new.smaller
001623  aa   000033 6000 04	tze  	27,ic		001656
001624  aa  6 00314 2351 00	lda  	pr6|204		new_has_init_template
001625  aa   000031 6000 04	tze  	25,ic		001656
001626  aa  6 00531 2351 00	lda  	pr6|345
001627  aa   000027 6000 04	tze  	23,ic		001656
						STATEMENT 1 ON LINE 496
		     call extend_template ((new_init_map_index),
			init_map (linkmap (linkmapx).init_map_index).init_ptr -> link_init.n_words);

001630  aa  6 00106 2361 00	ldq  	pr6|70		new_init_map_index
001631  aa   000066 7370 00	lls  	54
001632  aa  6 00531 5511 60	stba 	pr6|345,60
001633  aa  6 00103 2361 00	ldq  	pr6|67		linkmapx
001634  aa   000014 4020 07	mpy  	12,dl
001635  aa  6 00044 3701 20	epp4 	pr6|36,*
001636  ia  4 00016 3735 20	epp7 	pr4|14,*		newlinkp
001637  aa  7 77766 2351 06	lda  	pr7|-10,ql	linkmap.init_map_index
001640  aa   000022 7350 00	als  	18
001641  aa   000066 7330 00	lrs  	54
001642  aa   000003 7360 00	qls  	3
001643  aa  6 00531 3521 00	epp2 	pr6|345
001644  aa  6 00544 2521 00	spri2	pr6|356
001645  ia  4 00020 3715 20	epp5 	pr4|16,*		init_map_ptr
001646  aa  5 77770 3521 26	epp2 	pr5|-8,ql*	link_init.n_words
001647  aa  6 00546 2521 00	spri2	pr6|358
001650  aa  6 00542 3521 00	epp2 	pr6|354
001651  aa   010000 4310 07	fld  	4096,dl
001652  aa  2 00000 7571 00	staq 	pr2|0
001653  aa   002062 6700 04	tsp4 	1074,ic		003735
						STATEMENT 1 ON LINE 498
		     call replace_init_info;

001654  aa   002001 6700 04	tsp4 	1025,ic		003655
						STATEMENT 1 ON LINE 499
		end;

001655  aa   000032 7100 04	tra  	26,ic		001707
						STATEMENT 1 ON LINE 501
		else if new.larger & ^new_has_init_template & init_before
		then do;

001656  aa  6 00425 2351 00	lda  	pr6|277		new.larger
001657  aa   000030 6000 04	tze  	24,ic		001707
001660  aa  6 00314 2351 00	lda  	pr6|204		new_has_init_template
001661  aa   000026 6010 04	tnz  	22,ic		001707
001662  aa  6 00315 2351 00	lda  	pr6|205		init_before
001663  aa   000024 6000 04	tze  	20,ic		001707
						STATEMENT 1 ON LINE 504
		     call extend_template (linkmap (linkmapx).init_map_index,
			init_map (new_init_map_index).init_ptr -> link_init.n_words);

001664  aa  6 00103 2361 00	ldq  	pr6|67		linkmapx
001665  aa   000014 4020 07	mpy  	12,dl
001666  aa   000000 6270 06	eax7 	0,ql
001667  aa  6 00106 2361 00	ldq  	pr6|70		new_init_map_index
001670  aa   000003 7360 00	qls  	3
001671  aa  6 00044 3701 20	epp4 	pr6|36,*
001672  ia  4 00016 3735 20	epp7 	pr4|14,*		newlinkp
001673  aa  7 77766 3521 17	epp2 	pr7|-10,7		linkmap.init_map_index
001674  aa   000022 7260 07	lxl6 	18,dl
001675  aa  2 00000 5035 16	abd  	pr2|0,6
001676  aa  6 00544 2521 00	spri2	pr6|356
001677  ia  4 00020 3715 20	epp5 	pr4|16,*		init_map_ptr
001700  aa  5 77770 3521 26	epp2 	pr5|-8,ql*	link_init.n_words
001701  aa  6 00546 2521 00	spri2	pr6|358
001702  aa  6 00542 3521 00	epp2 	pr6|354
001703  aa   010000 4310 07	fld  	4096,dl
001704  aa  2 00000 7571 00	staq 	pr2|0
001705  aa   002030 6700 04	tsp4 	1048,ic		003735
						STATEMENT 1 ON LINE 506
		     call change_init_map_index;

001706  aa   001770 6700 04	tsp4 	1016,ic		003676
						STATEMENT 1 ON LINE 507
		end;

						STATEMENT 1 ON LINE 509
use_typepair:
		typepair_found = "1"b;

001707  aa   400000 2350 03	lda  	131072,du
001710  aa  6 00311 7551 00	sta  	pr6|201		typepair_found
						STATEMENT 1 ON LINE 511
		if unspec (new_exp_word) = unspec (exp_ptr -> exp_word)
		then goto adjust_text;

001711  aa  6 00417 2351 00	lda  	pr6|271
001712  aa  6 00446 1151 20	cmpa 	pr6|294,*
001713  aa   000321 6000 04	tze  	209,ic		002234
						STATEMENT 1 ON LINE 513
	     end;

						STATEMENT 1 ON LINE 514
advance:
	end;

001714  aa  6 00103 0541 00	aos  	pr6|67		linkmapx
001715  aa   777305 7100 04	tra  	-315,ic		001222
						STATEMENT 1 ON LINE 517
generate_definition:				/* generate expression word and type pair, if necessary */
	def_growth = 1;

001716  aa   000001 2360 07	ldq  	1,dl
001717  aa  6 00101 7561 00	stq  	pr6|65		def_growth
						STATEMENT 1 ON LINE 519
	xoffset = bx_$curdeflng;

001720  aa  6 00044 3701 20	epp4 	pr6|36,*
001721  la  4 00210 2361 20	ldq  	pr4|136,*		bx_$curdeflng
001722  aa  6 00114 7561 00	stq  	pr6|76		xoffset
						STATEMENT 1 ON LINE 520
	exp_ptr = addrel (defbase, xoffset);

001723  ia  4 00012 3521 66	epp2 	pr4|10,*ql	defbase
001724  aa   000000 0520 03	adwp2	0,du
001725  aa  6 00446 2521 00	spri2	pr6|294		exp_ptr
						STATEMENT 1 ON LINE 521
	if ^typepair_found				/* we have to generate a type pair */
	then new_exp_word.type_relp = xoffset + 1;

001726  aa  6 00311 2351 00	lda  	pr6|201		typepair_found
001727  aa   000004 6010 04	tnz  	4,ic		001733
001730  aa   000001 0760 07	adq  	1,dl
001731  aa   000066 7370 00	lls  	54
001732  aa  6 00417 5511 60	stba 	pr6|271,60	new_exp_word.type_relp
						STATEMENT 1 ON LINE 523
	exp_ptr -> exp_word = new_exp_word;

001733  aa  6 00417 2351 00	lda  	pr6|271		new_exp_word
001734  aa  2 00000 7551 00	sta  	pr2|0		exp_word
						STATEMENT 1 ON LINE 525
	if typepair_found
	then go to generate_link;

001735  aa  6 00311 2351 00	lda  	pr6|201		typepair_found
001736  aa   000136 6010 04	tnz  	94,ic		002074
						STATEMENT 1 ON LINE 528
	type_ptr = addrel (exp_ptr, 1);

001737  aa  2 00000 3515 00	epp1 	pr2|0
001740  aa   000001 0510 03	adwp1	1,du
001741  aa  6 00450 2515 00	spri1	pr6|296		type_ptr
						STATEMENT 1 ON LINE 529
	type_ptr -> type_pair = new_type_pair;

001742  aa  6 00420 2371 00	ldaq 	pr6|272		new_type_pair
001743  aa  1 00000 7551 00	sta  	pr1|0		type_pair
001744  aa  1 00001 7561 00	stq  	pr1|1		type_pair
						STATEMENT 1 ON LINE 530
	def_growth = def_growth + 2;

001745  aa   000002 2360 07	ldq  	2,dl
001746  aa  6 00101 0561 00	asq  	pr6|65		def_growth
						STATEMENT 1 ON LINE 531
	if new_init_map_index > 0			/* references are made by type pairs */
	then init_map (new_init_map_index).reference_count = init_map (new_init_map_index).reference_count + 1;

001747  aa  6 00106 2361 00	ldq  	pr6|70		new_init_map_index
001750  aa   000012 6044 04	tmoz 	10,ic		001762
001751  aa   000003 7360 00	qls  	3
001752  ia  4 00020 3735 20	epp7 	pr4|16,*		init_map_ptr
001753  aa  7 77776 2351 06	lda  	pr7|-2,ql		init_map.reference_count
001754  aa   000000 6270 06	eax7 	0,ql
001755  aa   000066 7330 00	lrs  	54
001756  aa   000001 0760 07	adq  	1,dl
001757  aa   000066 7370 00	lls  	54
001760  aa  7 77776 3715 17	epp5 	pr7|-2,7		init_map.reference_count
001761  aa  5 00000 5511 60	stba 	pr5|0,60		init_map.reference_count
						STATEMENT 1 ON LINE 534
	if ^segname_found
	then do;

001762  aa  6 00307 2351 00	lda  	pr6|199		segname_found
001763  aa   000021 6010 04	tnz  	17,ic		002004
						STATEMENT 1 ON LINE 536
	     call add_name (addr (ext.segname), ext.slng);

001764  aa  6 00266 3735 20	epp7 	pr6|182,*		ap
001765  aa  7 00012 3735 00	epp7 	pr7|10		ext.segname
001766  aa  6 00540 6535 00	spri7	pr6|352
001767  aa  6 00540 3521 00	epp2 	pr6|352
001770  aa  6 00544 2521 00	spri2	pr6|356
001771  aa  6 00266 3715 20	epp5 	pr6|182,*		ap
001772  aa  5 00023 3521 00	epp2 	pr5|19		ext.slng
001773  aa  6 00546 2521 00	spri2	pr6|358
001774  aa  6 00542 3521 00	epp2 	pr6|354
001775  aa   010000 4310 07	fld  	4096,dl
001776  aa  2 00000 7571 00	staq 	pr2|0
001777  aa   002037 6700 04	tsp4 	1055,ic		004036
						STATEMENT 1 ON LINE 537
	     type_ptr -> type_pair.segname_relp = name_offset;

002000  aa  6 00116 2361 00	ldq  	pr6|78		name_offset
002001  aa   000066 7370 00	lls  	54
002002  aa  6 00450 3735 20	epp7 	pr6|296,*		type_ptr
002003  aa  7 00001 5511 60	stba 	pr7|1,60		type_pair.segname_relp
						STATEMENT 1 ON LINE 538
	end;

						STATEMENT 1 ON LINE 540
	if ^entryname_found
	then do;

002004  aa  6 00310 2351 00	lda  	pr6|200		entryname_found
002005  aa   000030 6010 04	tnz  	24,ic		002035
						STATEMENT 1 ON LINE 542
	     if substr (ext.entryname, 1, 33) = ext.segname
	     then type_ptr -> type_pair.offsetname_relp = type_ptr -> type_pair.segname_relp;

002006  aa  6 00266 3735 20	epp7 	pr6|182,*		ap
002007  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
002010  aa  7 00024 00 0041	desc9a	pr7|20,33		ext.entryname
002011  aa  7 00012 00 0041	desc9a	pr7|10,33		ext.segname
002012  aa   000006 6010 04	tnz  	6,ic		002020
002013  aa  6 00450 3715 20	epp5 	pr6|296,*		type_ptr
002014  aa  5 00001 2351 00	lda  	pr5|1		type_pair.segname_relp
002015  aa   000022 7710 00	arl  	18
002016  aa  5 00001 5511 14	stba 	pr5|1,14		type_pair.offsetname_relp
002017  aa   000016 7100 04	tra  	14,ic		002035
						STATEMENT 1 ON LINE 544
	     else do;

						STATEMENT 1 ON LINE 545
		call add_name (addr (ext.entryname), ext.elng);

002020  aa  7 00024 3715 00	epp5 	pr7|20		ext.entryname
002021  aa  6 00540 6515 00	spri5	pr6|352
002022  aa  6 00540 3521 00	epp2 	pr6|352
002023  aa  6 00544 2521 00	spri2	pr6|356
002024  aa  7 00125 3521 00	epp2 	pr7|85		ext.elng
002025  aa  6 00546 2521 00	spri2	pr6|358
002026  aa  6 00542 3521 00	epp2 	pr6|354
002027  aa   010000 4310 07	fld  	4096,dl
002030  aa  2 00000 7571 00	staq 	pr2|0
002031  aa   002005 6700 04	tsp4 	1029,ic		004036
						STATEMENT 1 ON LINE 546
		type_ptr -> type_pair.offsetname_relp = name_offset;

002032  aa  6 00116 2361 00	ldq  	pr6|78		name_offset
002033  aa  6 00450 3735 20	epp7 	pr6|296,*		type_ptr
002034  aa  7 00001 5521 14	stbq 	pr7|1,14		type_pair.offsetname_relp
						STATEMENT 1 ON LINE 547
	     end;

						STATEMENT 1 ON LINE 548
	end;

						STATEMENT 1 ON LINE 552
	strm.nstr = map_lng;

002035  aa  6 00102 2361 00	ldq  	pr6|66		map_lng
002036  aa  6 00442 3735 20	epp7 	pr6|290,*		strmp
002037  aa  7 01540 7561 00	stq  	pr7|864		strm.nstr
						STATEMENT 1 ON LINE 553
	if strm.nstr > strm.max_size
	then do;

002040  aa  7 01537 1161 00	cmpq 	pr7|863		strm.max_size
002041  aa   000033 6044 04	tmoz 	27,ic		002074
						STATEMENT 1 ON LINE 555
	     call com_err_ (0, errname, "Stringmap table overflow; please notify maintenance.");

002042  aa  6 00531 4501 00	stz  	pr6|345
002043  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002044  aa   776022 00 0064	desc9a	-1006,52		000065 = 123164162151
002045  aa  6 00556 00 0064	desc9a	pr6|366,52
002046  aa  6 00531 3521 00	epp2 	pr6|345
002047  aa  6 00742 2521 00	spri2	pr6|482
002050  aa  6 00044 3701 20	epp4 	pr6|36,*
002051  ia  4 00026 3521 00	epp2 	pr4|22		errname
002052  aa  6 00744 2521 00	spri2	pr6|484
002053  aa  6 00556 3521 00	epp2 	pr6|366
002054  aa  6 00746 2521 00	spri2	pr6|486
002055  aa   775747 3520 04	epp2 	-1049,ic		000024 = 404000000005
002056  aa  6 00750 2521 00	spri2	pr6|488
002057  aa   775744 3520 04	epp2 	-1052,ic		000023 = 524000000020
002060  aa  6 00752 2521 00	spri2	pr6|490
002061  aa   775734 3520 04	epp2 	-1060,ic		000015 = 524000000064
002062  aa  6 00754 2521 00	spri2	pr6|492
002063  aa  6 00740 6211 00	eax1 	pr6|480
002064  aa   014000 4310 07	fld  	6144,dl
002065  la  4 00152 3521 20	epp2 	pr4|106,*		com_err_
002066  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 556
	     strm.nstr = 0;

002067  aa  6 00442 3735 20	epp7 	pr6|290,*		strmp
002070  aa  7 01540 4501 00	stz  	pr7|864		strm.nstr
						STATEMENT 1 ON LINE 557
	     bx_$fatal_error = 1;

002071  aa   000001 2360 07	ldq  	1,dl
002072  aa  6 00044 3701 20	epp4 	pr6|36,*
002073  la  4 00200 7561 20	stq  	pr4|128,*		bx_$fatal_error
						STATEMENT 1 ON LINE 558
	end;

						STATEMENT 1 ON LINE 560
generate_link:					/* regenerate link itself */
	step = bx_$tlinklng;

002074  aa  6 00044 3701 20	epp4 	pr6|36,*
002075  la  4 00216 2361 20	ldq  	pr4|142,*		bx_$tlinklng
002076  aa  6 00113 7561 00	stq  	pr6|75		step
						STATEMENT 1 ON LINE 563
	linkmapx, nlinks = nlinks + 1;

002077  ia  4 00023 2361 00	ldq  	pr4|19		nlinks
002100  aa   000001 0760 07	adq  	1,dl
002101  aa  6 00103 7561 00	stq  	pr6|67		linkmapx
002102  ia  4 00023 7561 00	stq  	pr4|19		nlinks
						STATEMENT 1 ON LINE 564
	if nlinks > linklimit
	then do;

002103  ia  4 00145 1161 00	cmpq 	pr4|101		linklimit
002104  aa   000054 6044 04	tmoz 	44,ic		002160
						STATEMENT 1 ON LINE 566
	     call com_err_ (0, errname,
		"Linktable overflow while adding link to ^a^a^/^-for component ^a.^/^-You have room for only ^d links^/^-after your ^d words of internal static.^/^-Consider using separate static (pl1 or alm) or large arrays (fortran)^/^-to make more room for links.",
		wsegname, wentryname, ext.compent_ptr -> comp.filename, linklimit, bx_$tintlng);

002105  aa  6 00531 4501 00	stz  	pr6|345
002106  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002107  aa   776150 00 0370	desc9a	-920,248		000256 = 114151156153
002110  aa  6 00602 00 0370	desc9a	pr6|386,248
002111  aa  6 00531 3521 00	epp2 	pr6|345
002112  aa  6 00770 2521 00	spri2	pr6|504
002113  ia  4 00026 3521 00	epp2 	pr4|22		errname
002114  aa  6 00772 2521 00	spri2	pr6|506
002115  aa  6 00602 3521 00	epp2 	pr6|386
002116  aa  6 00774 2521 00	spri2	pr6|508
002117  ia  4 00032 3521 00	epp2 	pr4|26		wsegname
002120  aa  6 00776 2521 00	spri2	pr6|510
002121  ia  4 00043 3521 00	epp2 	pr4|35		wentryname
002122  aa  6 01000 2521 00	spri2	pr6|512
002123  aa  6 00266 3735 20	epp7 	pr6|182,*		ext.compent_ptr
002124  aa  7 00000 3521 20	epp2 	pr7|0,*		comp.filename
002125  aa  6 01002 2521 00	spri2	pr6|514
002126  ia  4 00145 3521 00	epp2 	pr4|101		linklimit
002127  aa  6 01004 2521 00	spri2	pr6|516
002130  la  4 00212 3521 20	epp2 	pr4|138,*		bx_$tintlng
002131  aa  6 01006 2521 00	spri2	pr6|518
002132  aa   775672 3520 04	epp2 	-1094,ic		000024 = 404000000005
002133  aa  6 01010 2521 00	spri2	pr6|520
002134  aa   775667 3520 04	epp2 	-1097,ic		000023 = 524000000020
002135  aa  6 01012 2521 00	spri2	pr6|522
002136  aa   775656 3520 04	epp2 	-1106,ic		000014 = 524000000370
002137  aa  6 01014 2521 00	spri2	pr6|524
002140  aa   775661 3520 04	epp2 	-1103,ic		000021 = 524000000041
002141  aa  6 01016 2521 00	spri2	pr6|526
002142  aa   775651 3520 04	epp2 	-1111,ic		000013 = 524000000401
002143  aa  6 01020 2521 00	spri2	pr6|528
002144  aa   775646 3520 04	epp2 	-1114,ic		000012 = 524000000040
002145  aa  6 01022 2521 00	spri2	pr6|530
002146  aa   775657 3520 04	epp2 	-1105,ic		000025 = 404000000021
002147  aa  6 01024 2521 00	spri2	pr6|532
002150  aa  6 01026 2521 00	spri2	pr6|534
002151  aa  6 00766 6211 00	eax1 	pr6|502
002152  aa   040000 4310 07	fld  	16384,dl
002153  la  4 00152 3521 20	epp2 	pr4|106,*		com_err_
002154  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 569
	     signal fatal_binder_error;

002155  aa   000022 7260 07	lxl6 	18,dl
002156  aa   775702 3520 04	epp2 	-1086,ic		000060 = 146141164141
002157  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
						STATEMENT 1 ON LINE 570
	end;

						STATEMENT 1 ON LINE 571
	linkmap (nlinks).type_ptr = type_ptr;

002160  aa  6 00044 3701 20	epp4 	pr6|36,*
002161  ia  4 00023 2361 00	ldq  	pr4|19		nlinks
002162  aa   000014 4020 07	mpy  	12,dl
002163  aa  6 00450 3735 20	epp7 	pr6|296,*		type_ptr
002164  ia  4 00016 3715 20	epp5 	pr4|14,*		newlinkp
002165  aa  5 77764 6535 06	spri7	pr5|-12,ql	linkmap.type_ptr
						STATEMENT 1 ON LINE 572
	linkmap (nlinks).linkaddr = step;

002166  aa   000000 6270 06	eax7 	0,ql
002167  aa  6 00113 2361 00	ldq  	pr6|75		step
002170  aa   000066 7370 00	lls  	54
002171  aa  5 77766 3535 17	epp3 	pr5|-10,7		linkmap.linkaddr
002172  aa  3 00000 5511 60	stba 	pr3|0,60		linkmap.linkaddr
						STATEMENT 1 ON LINE 573
	linkmap (nlinks).init_source = comp.filename;

002173  aa  5 77767 3515 17	epp1 	pr5|-9,7		linkmap.init_source
002174  aa  6 00440 3535 20	epp3 	pr6|288,*		ctep
002175  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002176  aa  3 00000 00 0040	desc9a	pr3|0,32		comp.filename
002177  aa  1 00000 00 0040	desc9a	pr1|0,32		linkmap.init_source
						STATEMENT 1 ON LINE 574
	linkmap (nlinks).init_map_index = new_init_map_index;

002200  aa  6 00106 2361 00	ldq  	pr6|70		new_init_map_index
002201  aa  5 77766 3515 17	epp1 	pr5|-10,7		linkmap.init_map_index
002202  aa  1 00000 5521 14	stbq 	pr1|0,14		linkmap.init_map_index
						STATEMENT 1 ON LINE 575
	linkmap (nlinks).has_init_template = new_has_init_template;

002203  aa  6 00314 2351 00	lda  	pr6|204		new_has_init_template
002204  aa  5 77777 6751 17	era  	pr5|-1,7		linkmap.has_init_template
002205  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
002206  aa  5 77777 6551 17	ersa 	pr5|-1,7		linkmap.has_init_template
						STATEMENT 1 ON LINE 576
	linkmap (nlinks).diff_init_size = "0"b;

002207  aa   001737 2350 04	lda  	991,ic		004146 = 577777777777
002210  aa  5 77777 3551 17	ansa 	pr5|-1,7		linkmap.diff_init_size
						STATEMENT 1 ON LINE 577
	linkmap (nlinks).print_msg = "0"b;

002211  aa   001734 2350 04	lda  	988,ic		004145 = 677777777777
002212  aa  5 77777 3551 17	ansa 	pr5|-1,7		linkmap.print_msg
						STATEMENT 1 ON LINE 579
	link_ptr = addrel (linkbase, step);

002213  aa  6 00113 2361 00	ldq  	pr6|75		step
002214  ia  4 00010 3521 66	epp2 	pr4|8,*ql		linkbase
002215  aa   000000 0520 03	adwp2	0,du
002216  aa  6 00270 2521 00	spri2	pr6|184		link_ptr
						STATEMENT 1 ON LINE 580
	bx_$tlinklng = step + 2;

002217  aa   000002 0760 07	adq  	2,dl
002220  la  4 00216 7561 20	stq  	pr4|142,*		bx_$tlinklng
						STATEMENT 1 ON LINE 581
	link_ptr -> object_link.header_relp = -step;

002221  aa  6 00113 3361 00	lcq  	pr6|75		step
002222  aa   000066 7370 00	lls  	54
002223  aa  2 00000 5511 60	stba 	pr2|0,60		object_link.header_relp
						STATEMENT 1 ON LINE 582
	link_ptr -> object_link.tag = "46"b3;

002224  aa   000046 2350 07	lda  	38,dl
002225  aa  2 00000 7511 01	stca 	pr2|0,01		object_link.tag
						STATEMENT 1 ON LINE 583
	link_ptr -> object_link.expression_relp = xoffset;

002226  aa  6 00114 2361 00	ldq  	pr6|76		xoffset
002227  aa   000066 7370 00	lls  	54
002230  aa  2 00001 5511 60	stba 	pr2|1,60		object_link.expression_relp
						STATEMENT 1 ON LINE 584
	link_ptr -> object_link.modifier = new_link_modifier;

002231  aa  6 00306 2351 00	lda  	pr6|198		new_link_modifier
002232  aa   000036 7710 00	arl  	30
002233  aa  2 00001 7511 01	stca 	pr2|1,01		object_link.modifier
						STATEMENT 1 ON LINE 587
adjust_text:
	bx_$curdeflng = bx_$curdeflng + def_growth;

002234  aa  6 00101 2361 00	ldq  	pr6|65		def_growth
002235  aa  6 00044 3701 20	epp4 	pr6|36,*
002236  la  4 00210 0561 20	asq  	pr4|136,*		bx_$curdeflng
						STATEMENT 1 ON LINE 589
	if ^ext.dont_relocate
	then do;

002237  aa  6 00266 3735 20	epp7 	pr6|182,*		ap
002240  aa  7 00130 2351 00	lda  	pr7|88		ext.dont_relocate
002241  aa   002000 3150 03	cana 	1024,du
002242  aa   000044 6010 04	tnz  	36,ic		002306
						STATEMENT 1 ON LINE 591
	     if trap_sw
	     then trap_offset = step;

002243  aa  6 00312 2351 00	lda  	pr6|202		trap_sw
002244  aa   000005 6000 04	tze  	5,ic		002251
002245  aa  6 00113 2361 00	ldq  	pr6|75		step
002246  aa  6 00032 3715 20	epp5 	pr6|26,*
002247  aa  5 00004 7561 20	stq  	pr5|4,*		trap_offset
002250  aa   000036 7100 04	tra  	30,ic		002306
						STATEMENT 1 ON LINE 593
	     else if ext.relinfo = "lnk18   "
	     then do;

002251  aa  7 00006 2351 00	lda  	pr7|6		ext.relinfo
002252  aa  7 00007 2361 00	ldq  	pr7|7		ext.relinfo
002253  aa   775565 1170 04	cmpaq	-1163,ic		000040 = 154156153061 070040040040
002254  aa   000022 6010 04	tnz  	18,ic		002276
						STATEMENT 1 ON LINE 595
		if ext.side = "lhe"
		then ext.ref_ptr -> word.left_half = bit (bin (step, 18), 18);

002255  aa  7 00005 2351 00	lda  	pr7|5		ext.side
002256  aa   775533 1150 04	cmpa 	-1189,ic		000011 = 154150145000
002257  aa   000010 6010 04	tnz  	8,ic		002267
002260  aa  6 00113 2351 00	lda  	pr6|75		step
002261  aa   000002 6050 04	tpl  	2,ic		002263
002262  aa   000000 5310 00	neg  	0
002263  aa   000022 7350 00	als  	18
002264  aa  7 00002 3715 20	epp5 	pr7|2,*		word.left_half
002265  aa  5 00000 5511 60	stba 	pr5|0,60		word.left_half
002266  aa   000020 7100 04	tra  	16,ic		002306
						STATEMENT 1 ON LINE 597
		else ext.ref_ptr -> word.right_half = bit (bin (step, 18), 18);

002267  aa  6 00113 2351 00	lda  	pr6|75		step
002270  aa   000002 6050 04	tpl  	2,ic		002272
002271  aa   000000 5310 00	neg  	0
002272  aa  0 00264 3771 00	anaq 	pr0|180		= 000000777777 777777777777
002273  aa  7 00002 3715 20	epp5 	pr7|2,*		word.right_half
002274  aa  5 00000 5511 14	stba 	pr5|0,14		word.right_half
						STATEMENT 1 ON LINE 598
	     end;

002275  aa   000011 7100 04	tra  	9,ic		002306
						STATEMENT 1 ON LINE 599
	     else substr (ext.ref_ptr -> word.left_half, 4, 15) = bit (bin (step, 15), 15);

002276  aa  6 00113 2351 00	lda  	pr6|75		step
002277  aa   000002 6050 04	tpl  	2,ic		002301
002300  aa   000000 5310 00	neg  	0
002301  aa   000025 7350 00	als  	21
002302  aa   000003 7710 00	arl  	3
002303  aa  7 00002 6751 20	era  	pr7|2,*		word.left_half
002304  aa   077777 3750 03	ana  	32767,du
002305  aa  7 00002 6551 20	ersa 	pr7|2,*		word.left_half
						STATEMENT 1 ON LINE 601
	end;

						STATEMENT 1 ON LINE 603
	lrt.regenerated (lrt_index) = bit (bin (step, 18), 18);

002306  aa  6 00117 2361 00	ldq  	pr6|79		lrt_index
002307  aa   000022 4020 07	mpy  	18,dl
002310  aa  6 00113 2351 00	lda  	pr6|75		step
002311  aa   000002 6050 04	tpl  	2,ic		002313
002312  aa   000000 5310 00	neg  	0
002313  aa   000022 7350 00	als  	18
002314  aa  6 00056 7551 00	sta  	pr6|46
002315  aa  6 00444 3715 20	epp5 	pr6|292,*		lrtp
002316  aa  003 106 060 500	csl  	(pr),(pr,ql),fill(0),bool(move)
002317  aa  6 00056 00 0022	descb	pr6|46,18
002320  aa  5 00001 40 0022	descb	pr5|1(18),18	lrt.regenerated
						STATEMENT 1 ON LINE 605
	return;

002321  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 607
trap_error:
	ap -> copy_save = addr (scratch) -> copy_save;

002322  aa  6 00044 3701 20	epp4 	pr6|36,*
002323  ia  4 00144 2361 00	ldq  	pr4|100		ext_lng
002324  aa   000002 7360 00	qls  	2
002325  aa  6 00266 3735 20	epp7 	pr6|182,*		ap
002326  aa  000 140 100 540	mlr  	(pr,rl),(pr,rl),fill(000)
002327  aa  6 00121 00 0006	desc9a	pr6|81,ql		copy_save
002330  aa  7 00000 00 0006	desc9a	pr7|0,ql		copy_save
						STATEMENT 1 ON LINE 609
	call com_err_ (0, errname, "cannot process trap before link for ^a^a referenced by ^a|^o of ^a", wsegname,
	     wentryname, ext.section, ext.offset, comp.filename);

002331  aa  6 00531 4501 00	stz  	pr6|345
002332  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002333  aa   775550 00 0104	desc9a	-1176,68		000102 = 143141156156
002334  aa  6 00556 00 0104	desc9a	pr6|366,68
002335  aa  6 00531 3521 00	epp2 	pr6|345
002336  aa  6 00770 2521 00	spri2	pr6|504
002337  ia  4 00026 3521 00	epp2 	pr4|22		errname
002340  aa  6 00772 2521 00	spri2	pr6|506
002341  aa  6 00556 3521 00	epp2 	pr6|366
002342  aa  6 00774 2521 00	spri2	pr6|508
002343  ia  4 00032 3521 00	epp2 	pr4|26		wsegname
002344  aa  6 00776 2521 00	spri2	pr6|510
002345  ia  4 00043 3521 00	epp2 	pr4|35		wentryname
002346  aa  6 01000 2521 00	spri2	pr6|512
002347  aa  7 00010 3521 00	epp2 	pr7|8		ext.section
002350  aa  6 01002 2521 00	spri2	pr6|514
002351  aa  7 00004 3521 00	epp2 	pr7|4		ext.offset
002352  aa  6 01004 2521 00	spri2	pr6|516
002353  aa  6 00440 3521 20	epp2 	pr6|288,*		comp.filename
002354  aa  6 01006 2521 00	spri2	pr6|518
002355  aa   775447 3520 04	epp2 	-1241,ic		000024 = 404000000005
002356  aa  6 01010 2521 00	spri2	pr6|520
002357  aa   775444 3520 04	epp2 	-1244,ic		000023 = 524000000020
002360  aa  6 01012 2521 00	spri2	pr6|522
002361  aa   775427 3520 04	epp2 	-1257,ic		000010 = 524000000102
002362  aa  6 01014 2521 00	spri2	pr6|524
002363  aa   775436 3520 04	epp2 	-1250,ic		000021 = 524000000041
002364  aa  6 01016 2521 00	spri2	pr6|526
002365  aa   775426 3520 04	epp2 	-1258,ic		000013 = 524000000401
002366  aa  6 01020 2521 00	spri2	pr6|528
002367  aa   775420 3520 04	epp2 	-1264,ic		000007 = 524000000004
002370  aa  6 01022 2521 00	spri2	pr6|530
002371  aa   775415 3520 04	epp2 	-1267,ic		000006 = 404000000022
002372  aa  6 01024 2521 00	spri2	pr6|532
002373  aa   775417 3520 04	epp2 	-1265,ic		000012 = 524000000040
002374  aa  6 01026 2521 00	spri2	pr6|534
002375  aa  6 00766 6211 00	eax1 	pr6|502
002376  aa   040000 4310 07	fld  	16384,dl
002377  la  4 00152 3521 20	epp2 	pr4|106,*		com_err_
002400  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 611
	bx_$fatal_error = 1;

002401  aa   000001 2360 07	ldq  	1,dl
002402  aa  6 00044 3701 20	epp4 	pr6|36,*
002403  la  4 00200 7561 20	stq  	pr4|128,*		bx_$fatal_error
						STATEMENT 1 ON LINE 612
	return;

002404  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO gen_trap                                           STATEMENT 1 ON LINE 616
gen_trap:
     entry (argument_pointer, trap_offset);

002405  at     000002000032
002406  ta     000030000000
002407  ta     002405000000
002410  da     000223300000
002411  aa   001060 6270 00	eax7 	560
002412  aa  7 00034 3521 20	epp2 	pr7|28,*
002413  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002414  aa     000004000000
002415  aa     000000000000
						STATEMENT 1 ON LINE 633
	trap_sw = "1"b;

002416  aa   400000 2350 03	lda  	131072,du
002417  aa  6 00312 7551 00	sta  	pr6|202		trap_sw
						STATEMENT 1 ON LINE 634
	trap_offset = 0;

002420  aa  6 00032 3735 20	epp7 	pr6|26,*
002421  aa  7 00004 4501 20	stz  	pr7|4,*		trap_offset
						STATEMENT 1 ON LINE 635
	go to start;

002422  aa   775743 7100 04	tra  	-1053,ic		000365
ENTRY TO init                                               STATEMENT 1 ON LINE 637
init:
     entry;

002423  da     000230200000
002424  aa   001060 6270 00	eax7 	560
002425  aa  7 00034 3521 20	epp2 	pr7|28,*
002426  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002427  aa     000000000000
002430  aa     000000000000
						STATEMENT 1 ON LINE 650
	linkbase = bx_$tlinkp;

002431  aa  6 00044 3701 20	epp4 	pr6|36,*
002432  la  4 00174 3735 20	epp7 	pr4|124,*		bx_$tlinkp
002433  aa  7 00000 3735 20	epp7 	pr7|0,*		bx_$tlinkp
002434  ia  4 00010 6535 00	spri7	pr4|8		linkbase
						STATEMENT 1 ON LINE 651
	if mod (bx_$tlinklng, 2) = 1
	then bx_$tlinklng = bx_$tlinklng + 1;

002435  la  4 00216 2361 20	ldq  	pr4|142,*		bx_$tlinklng
002436  aa   001515 3520 04	epp2 	845,ic		004153 = 000000000002
002437  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
002440  aa   000001 1160 07	cmpq 	1,dl
002441  aa   000002 6010 04	tnz  	2,ic		002443
002442  la  4 00216 0541 20	aos  	pr4|142,*		bx_$tlinklng
						STATEMENT 1 ON LINE 654
	tblp = bx_$freep;

002443  la  4 00170 3715 20	epp5 	pr4|120,*		bx_$freep
002444  aa  5 00000 3715 20	epp5 	pr5|0,*		bx_$freep
002445  ia  4 00014 6515 00	spri5	pr4|12		tblp
						STATEMENT 1 ON LINE 655
	linklimit = divide ((bx_$maxlinklng - bx_$tlinklng), 2, 17, 0);

002446  la  4 00214 2361 20	ldq  	pr4|140,*		bx_$maxlinklng
002447  la  4 00216 1761 20	sbq  	pr4|142,*		bx_$tlinklng
002450  aa  2 00000 5061 00	div  	pr2|0
002451  ia  4 00145 7561 00	stq  	pr4|101		linklimit
						STATEMENT 1 ON LINE 658
	call temp_mgr_$reserve (addrel (tblp, linklimit));

002452  ia  4 00014 3515 66	epp1 	pr4|12,*ql	tblp
002453  aa   000000 0510 03	adwp1	0,du
002454  aa  6 00540 2515 00	spri1	pr6|352
002455  aa  6 00540 3521 00	epp2 	pr6|352
002456  aa  6 00534 2521 00	spri2	pr6|348
002457  aa  6 00532 6211 00	eax1 	pr6|346
002460  aa   004000 4310 07	fld  	2048,dl
002461  la  4 00160 3521 20	epp2 	pr4|112,*		temp_mgr_$reserve
002462  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 659
	n_tbls = 0;

002463  aa  6 00044 3701 20	epp4 	pr6|36,*
002464  ia  4 00022 4501 00	stz  	pr4|18		n_tbls
						STATEMENT 1 ON LINE 661
	i = linklimit * 7;

002465  ia  4 00145 2361 00	ldq  	pr4|101		linklimit
002466  aa   000007 4020 07	mpy  	7,dl
002467  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 662
	call temp_mgr_$allocate (i);

002470  aa  6 00100 3521 00	epp2 	pr6|64		i
002471  aa  6 00534 2521 00	spri2	pr6|348
002472  aa  6 00532 6211 00	eax1 	pr6|346
002473  aa   004000 4310 07	fld  	2048,dl
002474  la  4 00156 3521 20	epp2 	pr4|110,*		temp_mgr_$allocate
002475  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 663
	init_map_ptr = bx_$freep;

002476  aa  6 00044 3701 20	epp4 	pr6|36,*
002477  la  4 00170 3735 20	epp7 	pr4|120,*		bx_$freep
002500  aa  7 00000 3735 20	epp7 	pr7|0,*		bx_$freep
002501  ia  4 00020 6535 00	spri7	pr4|16		init_map_ptr
						STATEMENT 1 ON LINE 664
	call temp_mgr_$reserve (addrel (init_map_ptr, i));

002502  aa  6 00100 2361 00	ldq  	pr6|64		i
002503  ia  4 00020 3521 66	epp2 	pr4|16,*ql	init_map_ptr
002504  aa   000000 0520 03	adwp2	0,du
002505  aa  6 00540 2521 00	spri2	pr6|352
002506  aa  6 00540 3521 00	epp2 	pr6|352
002507  aa  6 00534 2521 00	spri2	pr6|348
002510  aa  6 00532 6211 00	eax1 	pr6|346
002511  aa   004000 4310 07	fld  	2048,dl
002512  la  4 00160 3521 20	epp2 	pr4|112,*		temp_mgr_$reserve
002513  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 665
	i = linklimit * 12;

002514  aa  6 00044 3701 20	epp4 	pr6|36,*
002515  ia  4 00145 2361 00	ldq  	pr4|101		linklimit
002516  aa   000014 4020 07	mpy  	12,dl
002517  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 666
	call temp_mgr_$allocate (i);

002520  aa  6 00100 3521 00	epp2 	pr6|64		i
002521  aa  6 00534 2521 00	spri2	pr6|348
002522  aa  6 00532 6211 00	eax1 	pr6|346
002523  aa   004000 4310 07	fld  	2048,dl
002524  la  4 00156 3521 20	epp2 	pr4|110,*		temp_mgr_$allocate
002525  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 667
	init_map_lng = 0;

002526  aa  6 00044 3701 20	epp4 	pr6|36,*
002527  ia  4 00024 4501 00	stz  	pr4|20		init_map_lng
						STATEMENT 1 ON LINE 669
	newlinkp = bx_$freep;

002530  la  4 00170 3735 20	epp7 	pr4|120,*		bx_$freep
002531  aa  7 00000 3735 20	epp7 	pr7|0,*		bx_$freep
002532  ia  4 00016 6535 00	spri7	pr4|14		newlinkp
						STATEMENT 1 ON LINE 670
	call temp_mgr_$reserve (addrel (newlinkp, i));

002533  aa  6 00100 2361 00	ldq  	pr6|64		i
002534  ia  4 00016 3521 66	epp2 	pr4|14,*ql	newlinkp
002535  aa   000000 0520 03	adwp2	0,du
002536  aa  6 00540 2521 00	spri2	pr6|352
002537  aa  6 00540 3521 00	epp2 	pr6|352
002540  aa  6 00534 2521 00	spri2	pr6|348
002541  aa  6 00532 6211 00	eax1 	pr6|346
002542  aa   004000 4310 07	fld  	2048,dl
002543  la  4 00160 3521 20	epp2 	pr4|112,*		temp_mgr_$reserve
002544  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 671
	nlinks = 0;

002545  aa  6 00044 3701 20	epp4 	pr6|36,*
002546  ia  4 00023 4501 00	stz  	pr4|19		nlinks
						STATEMENT 1 ON LINE 673
	if bx_$debug = 1
	then errname = "ext_link_";

002547  la  4 00202 2361 20	ldq  	pr4|130,*		bx_$debug
002550  aa   000001 1160 07	cmpq 	1,dl
002551  aa   000005 6010 04	tnz  	5,ic		002556
002552  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
002553  aa   775303 00 0011	desc9a	-1341,9		000055 = 145170164137
002554  ia  4 00026 00 0020	desc9a	pr4|22,16		errname
002555  aa   000010 7100 04	tra  	8,ic		002565
						STATEMENT 1 ON LINE 675
	else errname = bx_$caller;

002556  la  4 00220 3735 20	epp7 	pr4|144,*		bx_$caller
002557  aa  7 00000 2351 00	lda  	pr7|0		bx_$caller
002560  aa  7 00001 2361 00	ldq  	pr7|1		bx_$caller
002561  ia  4 00026 7571 00	staq 	pr4|22		errname
002562  aa  7 00002 2351 00	lda  	pr7|2		bx_$caller
002563  aa  7 00003 2361 00	ldq  	pr7|3		bx_$caller
002564  ia  4 00030 7571 00	staq 	pr4|24		errname
						STATEMENT 1 ON LINE 676
	defbase = bx_$tdefp;

002565  la  4 00172 3735 20	epp7 	pr4|122,*		bx_$tdefp
002566  aa  7 00000 3735 20	epp7 	pr7|0,*		bx_$tdefp
002567  ia  4 00012 6535 00	spri7	pr4|10		defbase
						STATEMENT 1 ON LINE 678
	null_acc_offset = bx_$curdeflng - 1;

002570  la  4 00210 2361 20	ldq  	pr4|136,*		bx_$curdeflng
002571  aa   000001 1760 07	sbq  	1,dl
002572  ia  4 00025 7561 00	stq  	pr4|21		null_acc_offset
						STATEMENT 1 ON LINE 681
	ap = addr (scratch);

002573  aa  6 00121 3715 00	epp5 	pr6|81		scratch
002574  aa  6 00266 6515 00	spri5	pr6|182		ap
						STATEMENT 1 ON LINE 682
	ext_lng = size (ext);

002575  aa   000133 2360 07	ldq  	91,dl
002576  ia  4 00144 7561 00	stq  	pr4|100		ext_lng
						STATEMENT 1 ON LINE 683
	return;

002577  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO finish                                             STATEMENT 1 ON LINE 685
finish:
     entry;

002600  da     000235200000
002601  aa   001060 6270 00	eax7 	560
002602  aa  7 00034 3521 20	epp2 	pr7|28,*
002603  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002604  aa     000000000000
002605  aa     000000000000
						STATEMENT 1 ON LINE 710
	do i = 1 to nlinks;

002606  aa  6 00044 3701 20	epp4 	pr6|36,*
002607  ia  4 00023 2361 00	ldq  	pr4|19		nlinks
002610  aa  6 00455 7561 00	stq  	pr6|301
002611  aa   000001 2360 07	ldq  	1,dl
002612  aa  6 00100 7561 00	stq  	pr6|64		i
002613  aa   000000 0110 03	nop  	0,du
002614  aa  6 00100 2361 00	ldq  	pr6|64		i
002615  aa  6 00455 1161 00	cmpq 	pr6|301
002616  aa   000131 6054 04	tpnz 	89,ic		002747
						STATEMENT 1 ON LINE 711
	     if linkmap (i).print_msg
	     then do;

002617  aa   000014 4020 07	mpy  	12,dl
002620  aa  6 00044 3701 20	epp4 	pr6|36,*
002621  ia  4 00016 3735 20	epp7 	pr4|14,*		newlinkp
002622  aa  7 77777 2351 06	lda  	pr7|-1,ql		linkmap.print_msg
002623  aa   100000 3150 03	cana 	32768,du
002624  aa  6 00531 7561 00	stq  	pr6|345
002625  aa   000120 6000 04	tze  	80,ic		002745
						STATEMENT 1 ON LINE 713
		type_ptr = linkmap (i).type_ptr;

002626  aa  7 77764 3715 26	epp5 	pr7|-12,ql*	linkmap.type_ptr
002627  aa  6 00450 6515 00	spri5	pr6|296		type_ptr
						STATEMENT 1 ON LINE 714
		if type_ptr -> type_pair.type = LINK_SELF_OFFSETNAME
		then wsegname = "";

002630  aa   000005 2350 03	lda  	5,du
002631  aa   000066 7730 00	lrl  	54
002632  aa  6 00555 7561 00	stq  	pr6|365		LINK_SELF_OFFSETNAME
002633  aa  5 00000 2351 00	lda  	pr5|0		type_pair.type
002634  aa   000066 7730 00	lrl  	54
002635  aa  6 00555 1161 00	cmpq 	pr6|365		LINK_SELF_OFFSETNAME
002636  aa   000005 6010 04	tnz  	5,ic		002643
002637  aa  040 100 100 400	mlr  	(),(pr),fill(040)
002640  aa   000000 00 0000	desc9a	0,0
002641  ia  4 00032 00 0041	desc9a	pr4|26,33		wsegname
002642  aa   000025 7100 04	tra  	21,ic		002667
						STATEMENT 1 ON LINE 716
		else wsegname = addrel (defbase, type_ptr -> type_pair.segname_relp) -> acc_string.string || "$";

002643  aa  5 00001 2351 00	lda  	pr5|1		type_pair.segname_relp
002644  aa   000066 7730 00	lrl  	54
002645  ia  4 00012 3521 66	epp2 	pr4|10,*ql	defbase
002646  aa   000000 0520 03	adwp2	0,du
002647  aa  2 00000 2351 00	lda  	pr2|0		acc_string.count
002650  aa   000077 7730 00	lrl  	63
002651  aa   000000 6270 06	eax7 	0,ql
002652  aa   000001 0760 07	adq  	1,dl
002653  aa  6 00540 2521 00	spri2	pr6|352
002654  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
002655  aa  6 00540 3535 20	epp3 	pr6|352,*
002656  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
002657  aa  3 00000 20 0017	desc9a	pr3|0(1),x7	acc_string.string
002660  aa  2 00000 00 0017	desc9a	pr2|0,x7
002661  aa  040 117 100 404	mlr  	(ic),(pr,x7),fill(040)
002662  aa   001270 00 0001	desc9a	696,1		004151 = 044000000000
002663  aa  2 00000 00 0001	desc9a	pr2|0,1
002664  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002665  aa  2 00000 00 0006	desc9a	pr2|0,ql
002666  ia  4 00032 00 0041	desc9a	pr4|26,33		wsegname
						STATEMENT 1 ON LINE 718
		call com_err_ (0, errname,
		     "Multiple initializations specified for external variable ^a^a;^/^-the one in ^a will be used.",
		     wsegname, addrel (defbase, type_ptr -> type_pair.offsetname_relp) -> acc_string.string,
		     linkmap (i).init_source);

002667  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002670  aa  5 00001 2361 00	ldq  	pr5|1		type_pair.offsetname_relp
002671  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
002672  ia  4 00012 3521 66	epp2 	pr4|10,*ql	defbase
002673  aa   000000 0520 03	adwp2	0,du
002674  aa  2 00000 2351 00	lda  	pr2|0		acc_string.count
002675  aa   000077 7730 00	lrl  	63
002676  aa  6 00530 7561 00	stq  	pr6|344
002677  aa   526000 2760 03	orq  	175104,du
002700  aa  6 00555 7561 00	stq  	pr6|365
002701  aa  6 00600 4501 00	stz  	pr6|384
002702  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002703  aa   775272 00 0140	desc9a	-1350,96		000174 = 115165154164
002704  aa  6 00702 00 0140	desc9a	pr6|450,96
002705  aa  6 00540 2521 00	spri2	pr6|352
002706  aa  6 00600 3521 00	epp2 	pr6|384
002707  aa  6 00770 2521 00	spri2	pr6|504
002710  ia  4 00026 3521 00	epp2 	pr4|22		errname
002711  aa  6 00772 2521 00	spri2	pr6|506
002712  aa  6 00702 3521 00	epp2 	pr6|450
002713  aa  6 00774 2521 00	spri2	pr6|508
002714  ia  4 00032 3521 00	epp2 	pr4|26		wsegname
002715  aa  6 00776 2521 00	spri2	pr6|510
002716  aa   000001 7270 07	lxl7 	1,dl
002717  aa  6 00540 3521 20	epp2 	pr6|352,*		acc_string.string
002720  aa  2 00000 5005 17	a9bd 	pr2|0,7
002721  aa  6 01000 2521 00	spri2	pr6|512
002722  aa  6 00531 7261 00	lxl6 	pr6|345
002723  aa  7 77767 3521 16	epp2 	pr7|-9,6		linkmap.init_source
002724  aa  6 01002 2521 00	spri2	pr6|514
002725  aa   775077 3520 04	epp2 	-1473,ic		000024 = 404000000005
002726  aa  6 01004 2521 00	spri2	pr6|516
002727  aa   775074 3520 04	epp2 	-1476,ic		000023 = 524000000020
002730  aa  6 01006 2521 00	spri2	pr6|518
002731  aa   775054 3520 04	epp2 	-1492,ic		000005 = 524000000135
002732  aa  6 01010 2521 00	spri2	pr6|520
002733  aa   775066 3520 04	epp2 	-1482,ic		000021 = 524000000041
002734  aa  6 01012 2521 00	spri2	pr6|522
002735  aa  6 00555 3521 00	epp2 	pr6|365
002736  aa  6 01014 2521 00	spri2	pr6|524
002737  aa   775053 3520 04	epp2 	-1493,ic		000012 = 524000000040
002740  aa  6 01016 2521 00	spri2	pr6|526
002741  aa  6 00766 6211 00	eax1 	pr6|502
002742  aa   030000 4310 07	fld  	12288,dl
002743  la  4 00152 3521 20	epp2 	pr4|106,*		com_err_
002744  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 722
	     end;

						STATEMENT 1 ON LINE 723
	end;

002745  aa  6 00100 0541 00	aos  	pr6|64		i
002746  aa   777646 7100 04	tra  	-90,ic		002614
						STATEMENT 1 ON LINE 727
	link_init_n_bits_in_datum = 0;

002747  aa  6 00452 4501 00	stz  	pr6|298		link_init_n_bits_in_datum
						STATEMENT 1 ON LINE 728
	do mapx = 1 to init_map_lng;

002750  aa  6 00044 3701 20	epp4 	pr6|36,*
002751  ia  4 00024 2361 00	ldq  	pr4|20		init_map_lng
002752  aa  6 00456 7561 00	stq  	pr6|302
002753  aa   000001 2360 07	ldq  	1,dl
002754  aa  6 00104 7561 00	stq  	pr6|68		mapx
002755  aa   000000 0110 03	nop  	0,du
002756  aa  6 00104 2361 00	ldq  	pr6|68		mapx
002757  aa  6 00456 1161 00	cmpq 	pr6|302
002760  aa   000175 6054 04	tpnz 	125,ic		003155
						STATEMENT 1 ON LINE 729
	     if init_map (mapx).reference_count > 0
	     then do;

002761  aa   000003 7360 00	qls  	3
002762  aa  6 00044 3701 20	epp4 	pr6|36,*
002763  ia  4 00020 3735 20	epp7 	pr4|16,*		init_map_ptr
002764  aa  7 77776 2351 06	lda  	pr7|-2,ql		init_map.reference_count
002765  aa  6 00555 7561 00	stq  	pr6|365
002766  aa   000066 7330 00	lrs  	54
002767  aa   000164 6044 04	tmoz 	116,ic		003153
						STATEMENT 1 ON LINE 731
		init_map (mapx).new_init_ptr, cur_init_info_ptr = addrel (defbase, bx_$curdeflng);

002770  la  4 00210 2361 20	ldq  	pr4|136,*		bx_$curdeflng
002771  ia  4 00012 3521 66	epp2 	pr4|10,*ql	defbase
002772  aa   000000 0520 03	adwp2	0,du
002773  aa  6 00540 2521 00	spri2	pr6|352
002774  aa  6 00555 7271 00	lxl7 	pr6|365
002775  aa  7 77772 2521 17	spri2	pr7|-6,7		init_map.new_init_ptr
002776  aa  6 00302 2521 00	spri2	pr6|194		cur_init_info_ptr
						STATEMENT 1 ON LINE 732
		extension_size = init_map (mapx).total_init_size - init_map (mapx).template_size;

002777  aa  7 77775 3361 17	lcq  	pr7|-3,7		init_map.total_init_size
003000  aa   000044 7770 00	llr  	36
003001  aa   000044 7330 00	lrs  	36
003002  aa  7 77774 0331 17	adl  	pr7|-4,7		init_map.template_size
003003  aa   000000 5330 00	negl 	0
003004  aa  6 00105 7561 00	stq  	pr6|69		extension_size
						STATEMENT 1 ON LINE 734
		if init_map (mapx).init_type = INIT_COPY_INFO
		then do;

003005  aa  7 77776 2351 17	lda  	pr7|-2,7		init_map.init_type
003006  aa   000022 7350 00	als  	18
003007  aa   000066 7330 00	lrs  	54
003010  aa  6 00600 7561 00	stq  	pr6|384		init_map.init_type
003011  aa   000003 1160 07	cmpq 	3,dl
003012  aa   000074 6010 04	tnz  	60,ic		003106
						STATEMENT 1 ON LINE 736
		     if extension_size <= 50		/* arbitrary limit */
		     then do;

003013  aa  6 00105 2361 00	ldq  	pr6|69		extension_size
003014  aa   000062 1160 07	cmpq 	50,dl
003015  aa   000022 6054 04	tpnz 	18,ic		003037
						STATEMENT 1 ON LINE 738
			cur_init_info_ptr -> link_init_copy_info = init_map (mapx).init_ptr -> link_init_copy_info;

003016  aa  7 77770 2351 37	lda  	pr7|-8,7*		link_init_copy_info.n_words
003017  aa   000044 7330 00	lrs  	36
003020  aa   000002 0330 07	adl  	2,dl
003021  aa   000002 7360 00	qls  	2
003022  aa  7 77770 3715 37	epp5 	pr7|-8,7*		init_map.init_ptr
003023  aa  000 140 100 540	mlr  	(pr,rl),(pr,rl),fill(000)
003024  aa  5 00000 00 0006	desc9a	pr5|0,ql		link_init_copy_info
003025  aa  2 00000 00 0006	desc9a	pr2|0,ql		link_init_copy_info
						STATEMENT 1 ON LINE 739
			if extension_size > 0
			then cur_init_info_ptr -> link_init_copy_info.header.n_words =
				init_map (mapx).total_init_size;

003026  aa  6 00105 2361 00	ldq  	pr6|69		extension_size
003027  aa   000003 6044 04	tmoz 	3,ic		003032
003030  aa  7 77775 2361 17	ldq  	pr7|-3,7		init_map.total_init_size
003031  aa  2 00000 7561 00	stq  	pr2|0		link_init_copy_info.n_words
						STATEMENT 1 ON LINE 742
			bx_$curdeflng = bx_$curdeflng + currentsize (cur_init_info_ptr -> link_init_copy_info);

003032  aa  2 00000 2351 00	lda  	pr2|0		link_init_copy_info.n_words
003033  aa   000044 7330 00	lrs  	36
003034  aa   000002 0330 07	adl  	2,dl
003035  la  4 00210 0561 20	asq  	pr4|136,*		bx_$curdeflng
						STATEMENT 1 ON LINE 743
		     end;

003036  aa   000115 7100 04	tra  	77,ic		003153
						STATEMENT 1 ON LINE 744
		     else do;

						STATEMENT 1 ON LINE 745
			cur_init_info_ptr -> link_init_list_template.header.type = INIT_LIST_TEMPLATE;

003037  aa   000005 2360 07	ldq  	5,dl
003040  aa  2 00001 7561 00	stq  	pr2|1		link_init_list_template.type
						STATEMENT 1 ON LINE 746
			cur_init_info_ptr -> link_init_list_template.n_words_in_list =
			     init_map (mapx).init_ptr -> link_init_copy_info.header.n_words
			     + size (list_template_entry) + 1;

003041  aa  6 00452 2361 00	ldq  	pr6|298		link_init_n_bits_in_datum
003042  aa   000043 0760 07	adq  	35,dl
003043  aa   000044 5060 07	div  	36,dl
003044  aa   000002 0760 07	adq  	2,dl
003045  aa   000044 7770 00	llr  	36
003046  aa   000044 7330 00	lrs  	36
003047  aa  7 77770 0331 37	adl  	pr7|-8,7*		link_init_copy_info.n_words
003050  aa   000001 0330 07	adl  	1,dl
003051  aa  2 00002 5521 14	stbq 	pr2|2,14		link_init_list_template.n_words_in_list
						STATEMENT 1 ON LINE 749
			init_entry_ptr = addr (cur_init_info_ptr -> link_init_list_template.template);

003052  aa  2 00003 3715 00	epp5 	pr2|3		link_init_list_template.template
003053  aa  6 00304 6515 00	spri5	pr6|196		init_entry_ptr
						STATEMENT 1 ON LINE 750
			init_entry_ptr -> list_template_entry.n_bits =
			     init_map (mapx).init_ptr -> link_init_copy_info.n_words * 36;

003054  aa  7 77770 2361 37	ldq  	pr7|-8,7*		link_init_copy_info.n_words
003055  aa   000044 4020 07	mpy  	36,dl
003056  aa  5 00000 7561 00	stq  	pr5|0		list_template_entry.n_bits
						STATEMENT 1 ON LINE 752
			init_entry_ptr -> list_template_entry.repeat = 1;

003057  aa   000001 2350 07	lda  	1,dl
003060  aa  5 00001 7511 37	stca 	pr5|1,37		list_template_entry.repeat
						STATEMENT 1 ON LINE 753
			init_entry_ptr -> list_template_entry.datum =
			     unspec (init_map (mapx).init_ptr -> link_init_copy_info.initial_data);

003061  aa  7 77770 2361 37	ldq  	pr7|-8,7*		link_init_copy_info.n_words
003062  aa   000044 4020 07	mpy  	36,dl
003063  aa  7 77770 3535 37	epp3 	pr7|-8,7*		init_map.init_ptr
003064  aa  5 00000 2351 00	lda  	pr5|0		list_template_entry.n_bits
003065  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
003066  aa  3 00002 00 0006	descb	pr3|2,ql
003067  aa  5 00002 00 0005	descb	pr5|2,al		list_template_entry.datum
						STATEMENT 1 ON LINE 757
			init_entry_ptr =
			     addrel (init_entry_ptr, currentsize (init_entry_ptr -> list_template_entry));

003070  aa  5 00000 2361 00	ldq  	pr5|0		list_template_entry.n_bits
003071  aa   000043 0760 07	adq  	35,dl
003072  aa   000044 5060 07	div  	36,dl
003073  aa   000002 0760 07	adq  	2,dl
003074  aa  5 00000 5075 06	awd  	pr5|0,ql
003075  aa  6 00304 6515 00	spri5	pr6|196		init_entry_ptr
						STATEMENT 1 ON LINE 759
			call add_extension;

003076  aa   001013 6700 04	tsp4 	523,ic		004111
						STATEMENT 1 ON LINE 760
			bx_$curdeflng = bx_$curdeflng + currentsize (cur_init_info_ptr -> link_init_list_template);

003077  aa  6 00302 3735 20	epp7 	pr6|194,*		cur_init_info_ptr
003100  aa  7 00002 2361 00	ldq  	pr7|2		link_init_list_template.n_words_in_list
003101  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
003102  aa   000003 0760 07	adq  	3,dl
003103  aa  6 00044 3701 20	epp4 	pr6|36,*
003104  la  4 00210 0561 20	asq  	pr4|136,*		bx_$curdeflng
						STATEMENT 1 ON LINE 761
		     end;

						STATEMENT 1 ON LINE 763
		end;

003105  aa   000046 7100 04	tra  	38,ic		003153
						STATEMENT 1 ON LINE 765
		else if init_map (mapx).init_type = INIT_LIST_TEMPLATE
		then do;

003106  aa   000005 1160 07	cmpq 	5,dl
003107  aa   000031 6010 04	tnz  	25,ic		003140
						STATEMENT 1 ON LINE 767
		     cur_init_info_ptr -> link_init_list_template =
			init_map (mapx).init_ptr -> link_init_list_template;

003110  aa  7 77770 3715 37	epp5 	pr7|-8,7*		init_map.init_ptr
003111  aa  5 00002 2361 00	ldq  	pr5|2		link_init_list_template.n_words_in_list
003112  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
003113  aa   000003 0760 07	adq  	3,dl
003114  aa   000002 7360 00	qls  	2
003115  aa  000 140 100 540	mlr  	(pr,rl),(pr,rl),fill(000)
003116  aa  5 00000 00 0006	desc9a	pr5|0,ql		link_init_list_template
003117  aa  2 00000 00 0006	desc9a	pr2|0,ql		link_init_list_template
						STATEMENT 1 ON LINE 769
		     if extension_size > 0
		     then do;

003120  aa  6 00105 2361 00	ldq  	pr6|69		extension_size
003121  aa   000010 6044 04	tmoz 	8,ic		003131
						STATEMENT 1 ON LINE 771
			init_entry_ptr =
			     addrel (cur_init_info_ptr,
			     currentsize (cur_init_info_ptr -> link_init_list_template) - 1);

003122  aa  2 00002 2361 00	ldq  	pr2|2		link_init_list_template.n_words_in_list
003123  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
003124  aa   000002 0760 07	adq  	2,dl
003125  aa  2 00000 3515 06	epp1 	pr2|0,ql
003126  aa   000000 0510 03	adwp1	0,du
003127  aa  6 00304 2515 00	spri1	pr6|196		init_entry_ptr
						STATEMENT 1 ON LINE 774
			call add_extension;

003130  aa   000761 6700 04	tsp4 	497,ic		004111
						STATEMENT 1 ON LINE 775
		     end;

						STATEMENT 1 ON LINE 776
		     bx_$curdeflng = bx_$curdeflng + currentsize (cur_init_info_ptr -> link_init_list_template);

003131  aa  6 00302 3735 20	epp7 	pr6|194,*		cur_init_info_ptr
003132  aa  7 00002 2361 00	ldq  	pr7|2		link_init_list_template.n_words_in_list
003133  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
003134  aa   000003 0760 07	adq  	3,dl
003135  aa  6 00044 3701 20	epp4 	pr6|36,*
003136  la  4 00210 0561 20	asq  	pr4|136,*		bx_$curdeflng
						STATEMENT 1 ON LINE 777
		end;

003137  aa   000014 7100 04	tra  	12,ic		003153
						STATEMENT 1 ON LINE 779
		else do;

						STATEMENT 1 ON LINE 780
		     cur_init_info_ptr -> link_init = init_map (mapx).init_ptr -> link_init;

003140  aa  7 77770 3715 37	epp5 	pr7|-8,7*		init_map.init_ptr
003141  aa  5 00000 2351 00	lda  	pr5|0		link_init
003142  aa  5 00001 2361 00	ldq  	pr5|1		link_init
003143  aa  2 00000 7551 00	sta  	pr2|0		link_init
003144  aa  2 00001 7561 00	stq  	pr2|1		link_init
						STATEMENT 1 ON LINE 781
		     if extension_size > 0
		     then cur_init_info_ptr -> link_init.n_words = init_map (mapx).total_init_size;

003145  aa  6 00105 2361 00	ldq  	pr6|69		extension_size
003146  aa   000003 6044 04	tmoz 	3,ic		003151
003147  aa  7 77775 2361 17	ldq  	pr7|-3,7		init_map.total_init_size
003150  aa  2 00000 7561 00	stq  	pr2|0		link_init.n_words
						STATEMENT 1 ON LINE 783
		     bx_$curdeflng = bx_$curdeflng + size (link_init);

003151  aa   000002 2360 07	ldq  	2,dl
003152  la  4 00210 0561 20	asq  	pr4|136,*		bx_$curdeflng
						STATEMENT 1 ON LINE 784
		end;

						STATEMENT 1 ON LINE 785
	     end;

						STATEMENT 1 ON LINE 786
	end;

003153  aa  6 00104 0541 00	aos  	pr6|68		mapx
003154  aa   777602 7100 04	tra  	-126,ic		002756
						STATEMENT 1 ON LINE 790
	n_bad_links = 0;

003155  aa  6 00434 4501 00	stz  	pr6|284		n_bad_links
						STATEMENT 1 ON LINE 791
	xoffset = wordno (defbase);

003156  aa  6 00044 3701 20	epp4 	pr6|36,*
003157  ia  4 00012 6361 20	eaq  	pr4|10,*		defbase
003160  aa   000022 7720 00	qrl  	18
003161  aa  6 00114 7561 00	stq  	pr6|76		xoffset
						STATEMENT 1 ON LINE 792
	do mapx = 1 to nlinks;

003162  ia  4 00023 2361 00	ldq  	pr4|19		nlinks
003163  aa  6 00457 7561 00	stq  	pr6|303
003164  aa   000001 2360 07	ldq  	1,dl
003165  aa  6 00104 7561 00	stq  	pr6|68		mapx
003166  aa  6 00104 2361 00	ldq  	pr6|68		mapx
003167  aa  6 00457 1161 00	cmpq 	pr6|303
003170  aa   000101 6054 04	tpnz 	65,ic		003271
						STATEMENT 1 ON LINE 793
	     if linkmap (mapx).init_map_index > 0
	     then do;

003171  aa   000014 4020 07	mpy  	12,dl
003172  aa  6 00044 3701 20	epp4 	pr6|36,*
003173  ia  4 00016 3735 20	epp7 	pr4|14,*		newlinkp
003174  aa  7 77766 2351 06	lda  	pr7|-10,ql	linkmap.init_map_index
003175  aa   000022 7350 00	als  	18
003176  aa  6 00555 7561 00	stq  	pr6|365
003177  aa   000066 7330 00	lrs  	54
003200  aa   000067 6044 04	tmoz 	55,ic		003267
						STATEMENT 1 ON LINE 795
		new_ptr = init_map (linkmap (mapx).init_map_index).new_init_ptr;

003201  aa   000003 7360 00	qls  	3
003202  ia  4 00020 3715 20	epp5 	pr4|16,*		init_map_ptr
003203  aa  5 77772 3715 26	epp5 	pr5|-6,ql*	init_map.new_init_ptr
003204  aa  6 00276 6515 00	spri5	pr6|190		new_ptr
						STATEMENT 1 ON LINE 796
		if new_ptr ^= null
		then linkmap (mapx).type_ptr -> type_pair.trap_relp = wordno (new_ptr) - xoffset;

003205  aa  6 00276 2371 00	ldaq 	pr6|190		new_ptr
003206  aa   774642 6770 04	eraq 	-1630,ic		000050 = 077777000043 000001000000
003207  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003210  aa   000010 6000 04	tze  	8,ic		003220
003211  aa  5 00000 6361 00	eaq  	pr5|0		new_ptr
003212  aa   000022 7720 00	qrl  	18
003213  aa  6 00114 1761 00	sbq  	pr6|76		xoffset
003214  aa  6 00555 7271 00	lxl7 	pr6|365
003215  aa  7 77764 3535 37	epp3 	pr7|-12,7*	type_pair.trap_relp
003216  aa  3 00000 5521 14	stbq 	pr3|0,14		type_pair.trap_relp
003217  aa   000050 7100 04	tra  	40,ic		003267
						STATEMENT 1 ON LINE 798
		else do;

						STATEMENT 1 ON LINE 799
		     n_bad_links = n_bad_links + 1;

003220  aa  6 00434 0541 00	aos  	pr6|284		n_bad_links
						STATEMENT 1 ON LINE 800
		     call com_err_ (0, errname,
			"Link to external variable ^a has missing initialization information.^/^-Notify maintenance personnel.",
			addrel (defbase, linkmap (mapx).type_ptr -> type_pair.offsetname_relp) -> acc_string.string)
			;

003221  aa  6 00555 7271 00	lxl7 	pr6|365
003222  aa  7 77764 3535 37	epp3 	pr7|-12,7*	linkmap.type_ptr
003223  aa  3 00001 2361 00	ldq  	pr3|1		type_pair.offsetname_relp
003224  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
003225  ia  4 00012 3521 66	epp2 	pr4|10,*ql	defbase
003226  aa   000000 0520 03	adwp2	0,du
003227  aa  2 00000 2351 00	lda  	pr2|0		acc_string.count
003230  aa   000077 7730 00	lrl  	63
003231  aa  6 00555 7561 00	stq  	pr6|365
003232  aa   526000 2760 03	orq  	175104,du
003233  aa  6 00600 7561 00	stq  	pr6|384
003234  aa  6 00531 4501 00	stz  	pr6|345
003235  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003236  aa   774767 00 0150	desc9a	-1545,104		000224 = 114151156153
003237  aa  6 00702 00 0150	desc9a	pr6|450,104
003240  aa  6 00540 2521 00	spri2	pr6|352
003241  aa  6 00531 3521 00	epp2 	pr6|345
003242  aa  6 00560 2521 00	spri2	pr6|368
003243  ia  4 00026 3521 00	epp2 	pr4|22		errname
003244  aa  6 00562 2521 00	spri2	pr6|370
003245  aa  6 00702 3521 00	epp2 	pr6|450
003246  aa  6 00564 2521 00	spri2	pr6|372
003247  aa   000001 7260 07	lxl6 	1,dl
003250  aa  6 00540 3521 20	epp2 	pr6|352,*		acc_string.string
003251  aa  2 00000 5005 16	a9bd 	pr2|0,6
003252  aa  6 00566 2521 00	spri2	pr6|374
003253  aa   774551 3520 04	epp2 	-1687,ic		000024 = 404000000005
003254  aa  6 00570 2521 00	spri2	pr6|376
003255  aa   774546 3520 04	epp2 	-1690,ic		000023 = 524000000020
003256  aa  6 00572 2521 00	spri2	pr6|378
003257  aa   774524 3520 04	epp2 	-1708,ic		000003 = 524000000145
003260  aa  6 00574 2521 00	spri2	pr6|380
003261  aa  6 00600 3521 00	epp2 	pr6|384
003262  aa  6 00576 2521 00	spri2	pr6|382
003263  aa  6 00556 6211 00	eax1 	pr6|366
003264  aa   020000 4310 07	fld  	8192,dl
003265  la  4 00152 3521 20	epp2 	pr4|106,*		com_err_
003266  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 804
		end;

						STATEMENT 1 ON LINE 805
	     end;

						STATEMENT 1 ON LINE 806
	end;

003267  aa  6 00104 0541 00	aos  	pr6|68		mapx
003270  aa   777676 7100 04	tra  	-66,ic		003166
						STATEMENT 1 ON LINE 808
	if n_bad_links > 0
	then bx_$fatal_error = 1;

003271  aa  6 00434 2361 00	ldq  	pr6|284		n_bad_links
003272  aa   000004 6044 04	tmoz 	4,ic		003276
003273  aa   000001 2360 07	ldq  	1,dl
003274  aa  6 00044 3701 20	epp4 	pr6|36,*
003275  la  4 00200 7561 20	stq  	pr4|128,*		bx_$fatal_error
						STATEMENT 1 ON LINE 811
	return;

003276  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1104
     end;

BEGIN PROCEDURE find_init_map_entry
ENTRY TO find_init_map_entry                                STATEMENT 1 ON LINE 813
find_init_map_entry:
     proc;

003277  aa  6 00460 6501 00	spri4	pr6|304
						STATEMENT 1 ON LINE 831
	convert = "0"b;

003300  aa  6 00313 4501 00	stz  	pr6|203		convert
						STATEMENT 1 ON LINE 832
	if new_type_pair.type = LINK_CREATE_IF_NOT_FOUND
	then do;

003301  aa   000006 2350 03	lda  	6,du
003302  aa   000066 7730 00	lrl  	54
003303  aa  6 01030 7561 00	stq  	pr6|536		LINK_CREATE_IF_NOT_FOUND
003304  aa  6 00420 2351 00	lda  	pr6|272		new_type_pair.type
003305  aa   000066 7730 00	lrl  	54
003306  aa  6 01030 1161 00	cmpq 	pr6|536		LINK_CREATE_IF_NOT_FOUND
003307  aa   000127 6010 04	tnz  	87,ic		003436
						STATEMENT 1 ON LINE 834
	     extp = ap;

003310  aa  6 00266 3735 20	epp7 	pr6|182,*		ap
003311  aa  6 00274 6535 00	spri7	pr6|188		extp
						STATEMENT 1 ON LINE 835
	     if wsegname = "stat_"
	     then do;

003312  aa  6 00044 3701 20	epp4 	pr6|36,*
003313  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003314  ia  4 00032 00 0041	desc9a	pr4|26,33		wsegname
003315  aa   774523 00 0005	desc9a	-1709,5		000036 = 163164141164
003316  aa   000015 6010 04	tnz  	13,ic		003333
						STATEMENT 1 ON LINE 837
		convert = "1"b;

003317  aa   400000 2350 03	lda  	131072,du
003320  aa  6 00313 7551 00	sta  	pr6|203		convert
						STATEMENT 1 ON LINE 838
		new_ename = addr (ext.entryname) -> acc_string.string;

003321  aa  7 00024 2351 00	lda  	pr7|20		acc_string.count
003322  aa   000077 7730 00	lrl  	63
003323  aa   000400 1160 07	cmpq 	256,dl
003324  aa   000002 6040 04	tmi  	2,ic		003326
003325  aa   000400 2360 07	ldq  	256,dl
003326  aa  6 00316 7561 00	stq  	pr6|206		new_ename
003327  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
003330  aa  7 00024 20 0006	desc9a	pr7|20(1),ql	acc_string.string
003331  aa  6 00317 00 0006	desc9a	pr6|207,ql	new_ename
						STATEMENT 1 ON LINE 839
	     end;

003332  aa   000104 7100 04	tra  	68,ic		003436
						STATEMENT 1 ON LINE 840
	     else if ext.elng = 1
	     then do;

003333  aa  7 00125 2361 00	ldq  	pr7|85		ext.elng
003334  aa   000001 1160 07	cmpq 	1,dl
003335  aa   000050 6010 04	tnz  	40,ic		003405
						STATEMENT 1 ON LINE 842
		i = index (ext.segname, ".com");

003336  aa   000041 2360 07	ldq  	33,dl
003337  aa  7 00012 3521 00	epp2 	pr7|10		ext.segname
003340  aa  0 01227 7001 00	tsx0 	pr0|663		set_chars_eis
003341  aa   000004 2360 07	ldq  	4,dl
003342  aa   774440 3520 04	epp2 	-1760,ic		000002 = 056143157155
003343  aa  0 01231 7001 00	tsx0 	pr0|665		index_chars_eis
003344  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 843
		if (i > 0) & (i = (ext.slng - 3))
		then do;

003345  aa   000033 6044 04	tmoz 	27,ic		003400
003346  aa  7 00023 2361 00	ldq  	pr7|19		ext.slng
003347  aa   000003 1760 07	sbq  	3,dl
003350  aa  6 00100 1161 00	cmpq 	pr6|64		i
003351  aa   000027 6010 04	tnz  	23,ic		003400
						STATEMENT 1 ON LINE 845
		     new_ename = substr (ext.segname, 2, i - 2);

003352  aa  6 00100 2361 00	ldq  	pr6|64		i
003353  aa   000002 1760 07	sbq  	2,dl
003354  aa   000400 1160 07	cmpq 	256,dl
003355  aa   000002 6040 04	tmi  	2,ic		003357
003356  aa   000400 2360 07	ldq  	256,dl
003357  aa  6 00316 7561 00	stq  	pr6|206		new_ename
003360  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
003361  aa  7 00012 20 0006	desc9a	pr7|10(1),ql	ext.segname
003362  aa  6 00317 00 0006	desc9a	pr6|207,ql	new_ename
						STATEMENT 1 ON LINE 846
		     if new_ename = "b_"
		     then new_ename = "blnk*com";

003363  aa  6 00316 7271 00	lxl7 	pr6|206		new_ename
003364  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
003365  aa  6 00317 00 0017	desc9a	pr6|207,x7	new_ename
003366  aa   000563 00 0002	desc9a	371,2		004147 = 142137000000
003367  aa   000006 6010 04	tnz  	6,ic		003375
003370  aa   774444 2370 04	ldaq 	-1756,ic		000034 = 142154156153 052143157155
003371  aa  6 00317 7551 00	sta  	pr6|207		new_ename
003372  aa  6 00320 7561 00	stq  	pr6|208		new_ename
003373  aa   000010 2360 07	ldq  	8,dl
003374  aa  6 00316 7561 00	stq  	pr6|206		new_ename
						STATEMENT 1 ON LINE 848
		     convert = "1"b;

003375  aa   400000 2350 03	lda  	131072,du
003376  aa  6 00313 7551 00	sta  	pr6|203		convert
						STATEMENT 1 ON LINE 849
		end;

003377  aa   000037 7100 04	tra  	31,ic		003436
						STATEMENT 1 ON LINE 850
		else do;

						STATEMENT 1 ON LINE 851
		     new_type_pair.offsetname_relp = null_acc_offset;

003400  ia  4 00025 2361 00	ldq  	pr4|21		null_acc_offset
003401  aa  6 00421 5521 14	stbq 	pr6|273,14	new_type_pair.offsetname_relp
						STATEMENT 1 ON LINE 853
		     entryname_found = "1"b;

003402  aa   400000 2350 03	lda  	131072,du
003403  aa  6 00310 7551 00	sta  	pr6|200		entryname_found
						STATEMENT 1 ON LINE 854
		end;

						STATEMENT 1 ON LINE 855
	     end;

003404  aa   000032 7100 04	tra  	26,ic		003436
						STATEMENT 1 ON LINE 856
	     else if wsegname = "cobol_fsb_"
	     then do;

003405  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003406  ia  4 00032 00 0041	desc9a	pr4|26,33		wsegname
003407  aa   774445 00 0012	desc9a	-1755,10		000052 = 143157142157
003410  aa   000026 6010 04	tnz  	22,ic		003436
						STATEMENT 1 ON LINE 858
		new_ename = "cobol_fsb_" || addr (ext.entryname) -> acc_string.string;

003411  aa  7 00024 2351 00	lda  	pr7|20		acc_string.count
003412  aa   000077 7730 00	lrl  	63
003413  aa   000000 6270 06	eax7 	0,ql
003414  aa   000012 0760 07	adq  	10,dl
003415  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
003416  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003417  aa   774434 00 0012	desc9a	-1764,10		000052 = 143157142157
003420  aa  2 00000 00 0012	desc9a	pr2|0,10
003421  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
003422  aa  7 00024 20 0017	desc9a	pr7|20(1),x7	acc_string.string
003423  aa  2 00002 40 0017	desc9a	pr2|2(2),x7
003424  aa   000400 1160 07	cmpq 	256,dl
003425  aa   000002 6040 04	tmi  	2,ic		003427
003426  aa   000400 2360 07	ldq  	256,dl
003427  aa  6 00316 7561 00	stq  	pr6|206		new_ename
003430  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
003431  aa  2 00000 00 0006	desc9a	pr2|0,ql
003432  aa  6 00317 00 0006	desc9a	pr6|207,ql	new_ename
						STATEMENT 1 ON LINE 859
		convert = "1"b;

003433  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
003434  aa   400000 2350 03	lda  	131072,du
003435  aa  6 00313 7551 00	sta  	pr6|203		convert
						STATEMENT 1 ON LINE 860
	     end;

						STATEMENT 1 ON LINE 861
	end;

						STATEMENT 1 ON LINE 863
	if convert
	then do;

003436  aa  6 00313 2351 00	lda  	pr6|203		convert
003437  aa   000066 6000 04	tze  	54,ic		003525
						STATEMENT 1 ON LINE 865
	     extp -> ext.code15 = bit (bin (LINK_SELF_OFFSETNAME, 18), 18);

003440  aa   000005 2350 03	lda  	5,du
003441  aa   000066 7730 00	lrl  	54
003442  aa   000003 6050 04	tpl  	3,ic		003445
003443  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
003444  aa   000001 0760 07	adq  	1,dl
003445  aa   000066 7370 00	lls  	54
003446  aa   000022 7730 00	lrl  	18
003447  aa  6 00274 3735 20	epp7 	pr6|188,*		extp
003450  aa  7 00127 5511 14	stba 	pr7|87,14		ext.code15
						STATEMENT 1 ON LINE 866
	     new_type_pair.type = LINK_SELF_OFFSETNAME;

003451  aa   000005 2350 03	lda  	5,du
003452  aa  6 00420 5511 60	stba 	pr6|272,60	new_type_pair.type
						STATEMENT 1 ON LINE 867
	     class = SECTION_SYSTEM;

003453  aa   000005 2350 03	lda  	5,du
003454  aa   000066 7730 00	lrl  	54
003455  aa  6 00115 7561 00	stq  	pr6|77		class
						STATEMENT 1 ON LINE 868
	     wsegname = "*system";

003456  aa  6 00044 3701 20	epp4 	pr6|36,*
003457  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003460  aa   774367 00 0007	desc9a	-1801,7		000046 = 052163171163
003461  ia  4 00032 00 0041	desc9a	pr4|26,33		wsegname
						STATEMENT 1 ON LINE 869
	     addr (extp -> ext.segname) -> acc_string.count = length ("*system");

003462  aa   007000 2350 03	lda  	3584,du
003463  aa  7 00012 5511 40	stba 	pr7|10,40		acc_string.count
						STATEMENT 1 ON LINE 870
	     addr (extp -> ext.segname) -> acc_string.string = "*system";

003464  aa  7 00012 2351 00	lda  	pr7|10		acc_string.count
003465  aa   000077 7730 00	lrl  	63
003466  aa  040 140 100 404	mlr  	(ic),(pr,rl),fill(040)
003467  aa   774360 00 0007	desc9a	-1808,7		000046 = 052163171163
003470  aa  7 00012 20 0006	desc9a	pr7|10(1),ql	acc_string.string
						STATEMENT 1 ON LINE 871
	     extp -> ext.slng = length ("*system") + 1;

003471  aa   000010 2360 07	ldq  	8,dl
003472  aa  7 00023 7561 00	stq  	pr7|19		ext.slng
						STATEMENT 1 ON LINE 872
	     wentryname = "|" || new_ename;

003473  aa   000001 2360 07	ldq  	1,dl
003474  aa  6 00316 0761 00	adq  	pr6|206		new_ename
003475  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
003476  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003477  aa   000454 00 0001	desc9a	300,1		004152 = 174000000000
003500  aa  2 00000 00 0001	desc9a	pr2|0,1
003501  aa  6 00316 7271 00	lxl7 	pr6|206		new_ename
003502  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
003503  aa  6 00317 00 0017	desc9a	pr6|207,x7	new_ename
003504  aa  2 00000 20 0017	desc9a	pr2|0(1),x7
003505  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
003506  aa  2 00000 00 0006	desc9a	pr2|0,ql
003507  ia  4 00043 00 0401	desc9a	pr4|35,257	wentryname
						STATEMENT 1 ON LINE 873
	     addr (extp -> ext.entryname) -> acc_string.count = length (new_ename);

003510  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
003511  aa  6 00316 2361 00	ldq  	pr6|206		new_ename
003512  aa   000077 7370 00	lls  	63
003513  aa  7 00024 5511 40	stba 	pr7|20,40		acc_string.count
						STATEMENT 1 ON LINE 874
	     addr (extp -> ext.entryname) -> acc_string.string = new_ename;

003514  aa  7 00024 2351 00	lda  	pr7|20		acc_string.count
003515  aa   000077 7730 00	lrl  	63
003516  aa  6 00316 7271 00	lxl7 	pr6|206		new_ename
003517  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
003520  aa  6 00317 00 0017	desc9a	pr6|207,x7	new_ename
003521  aa  7 00024 20 0006	desc9a	pr7|20(1),ql	acc_string.string
						STATEMENT 1 ON LINE 875
	     extp -> ext.elng = length (new_ename) + 1;

003522  aa  6 00316 2361 00	ldq  	pr6|206		new_ename
003523  aa   000001 0760 07	adq  	1,dl
003524  aa  7 00125 7561 00	stq  	pr7|85		ext.elng
						STATEMENT 1 ON LINE 876
	end;

						STATEMENT 1 ON LINE 880
	new_init_type = orig_init_info_ptr -> link_init.type;

003525  aa  6 00300 3735 20	epp7 	pr6|192,*		orig_init_info_ptr
003526  aa  7 00001 2361 00	ldq  	pr7|1		link_init.type
003527  aa  6 00110 7561 00	stq  	pr6|72		new_init_type
						STATEMENT 1 ON LINE 882
	do new_init_map_index = 1 to init_map_lng;

003530  aa  6 00044 3701 20	epp4 	pr6|36,*
003531  ia  4 00024 2361 00	ldq  	pr4|20		init_map_lng
003532  aa  6 00466 7561 00	stq  	pr6|310
003533  aa   000001 2360 07	ldq  	1,dl
003534  aa  6 00106 7561 00	stq  	pr6|70		new_init_map_index
003535  aa   000000 0110 03	nop  	0,du
003536  aa  6 00106 2361 00	ldq  	pr6|70		new_init_map_index
003537  aa  6 00466 1161 00	cmpq 	pr6|310
003540  aa   000060 6054 04	tpnz 	48,ic		003620
						STATEMENT 1 ON LINE 883
	     cur_init_info_ptr = init_map (new_init_map_index).init_ptr;

003541  aa   000003 7360 00	qls  	3
003542  aa  6 00044 3701 20	epp4 	pr6|36,*
003543  ia  4 00020 3735 20	epp7 	pr4|16,*		init_map_ptr
003544  aa  7 77770 3735 26	epp7 	pr7|-8,ql*	init_map.init_ptr
003545  aa  6 00302 6535 00	spri7	pr6|194		cur_init_info_ptr
						STATEMENT 1 ON LINE 885
	     if unspec (orig_init_info_ptr -> link_init) = unspec (cur_init_info_ptr -> link_init)
	     then do;

003546  aa  6 00300 3715 20	epp5 	pr6|192,*		orig_init_info_ptr
003547  aa  5 00000 2351 00	lda  	pr5|0
003550  aa  5 00001 2361 00	ldq  	pr5|1
003551  aa  7 00000 1151 00	cmpa 	pr7|0
003552  aa   000002 6010 04	tnz  	2,ic		003554
003553  aa  7 00001 1161 00	cmpq 	pr7|1
003554  aa   000042 6010 04	tnz  	34,ic		003616
						STATEMENT 1 ON LINE 887
		if new_init_type = INIT_COPY_INFO
		then if unspec (orig_init_info_ptr -> link_init_copy_info.initial_data)
			= unspec (cur_init_info_ptr -> link_init_copy_info.initial_data)
		     then return;

003555  aa  6 00110 2361 00	ldq  	pr6|72		new_init_type
003556  aa   000003 1160 07	cmpq 	3,dl
003557  aa   000015 6010 04	tnz  	13,ic		003574
003560  aa  5 00000 2361 00	ldq  	pr5|0		link_init_copy_info.n_words
003561  aa   000044 4020 07	mpy  	36,dl
003562  aa  6 01030 7561 00	stq  	pr6|536
003563  aa  7 00000 2361 00	ldq  	pr7|0		link_init_copy_info.n_words
003564  aa   000044 4020 07	mpy  	36,dl
003565  aa  6 01030 2351 00	lda  	pr6|536
003566  aa  000 140 066 540	cmpb 	(pr,rl),(pr,rl),fill(0)
003567  aa  5 00002 00 0005	descb	pr5|2,al
003570  aa  7 00002 00 0006	descb	pr7|2,ql
003571  aa   000025 6010 04	tnz  	21,ic		003616
003572  aa  6 00460 6101 00	rtcd 	pr6|304
						STATEMENT 1 ON LINE 891
		     else ;

003573  aa   000023 7100 04	tra  	19,ic		003616
						STATEMENT 1 ON LINE 892
		else if new_init_type = INIT_LIST_TEMPLATE
		then if unspec (orig_init_info_ptr -> link_init_list_template.template)
			= unspec (cur_init_info_ptr -> link_init_list_template.template)
		     then return;

003574  aa   000005 1160 07	cmpq 	5,dl
003575  aa   000020 6010 04	tnz  	16,ic		003615
003576  aa  5 00002 2361 00	ldq  	pr5|2		link_init_list_template.n_words_in_list
003577  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
003600  aa   000044 4020 07	mpy  	36,dl
003601  aa  7 00002 2351 00	lda  	pr7|2		link_init_list_template.n_words_in_list
003602  aa   000022 7350 00	als  	18
003603  aa  6 01030 7561 00	stq  	pr6|536
003604  aa   000066 7730 00	lrl  	54
003605  aa   000044 4020 07	mpy  	36,dl
003606  aa  6 01030 2351 00	lda  	pr6|536
003607  aa  000 140 066 540	cmpb 	(pr,rl),(pr,rl),fill(0)
003610  aa  5 00003 00 0005	descb	pr5|3,al
003611  aa  7 00003 00 0006	descb	pr7|3,ql
003612  aa   000004 6010 04	tnz  	4,ic		003616
003613  aa  6 00460 6101 00	rtcd 	pr6|304
						STATEMENT 1 ON LINE 896
		     else ;

003614  aa   000002 7100 04	tra  	2,ic		003616
						STATEMENT 1 ON LINE 897
		else return;

003615  aa  6 00460 6101 00	rtcd 	pr6|304
						STATEMENT 1 ON LINE 898
	     end;

						STATEMENT 1 ON LINE 899
	end;

003616  aa  6 00106 0541 00	aos  	pr6|70		new_init_map_index
003617  aa   777717 7100 04	tra  	-49,ic		003536
						STATEMENT 1 ON LINE 903
	init_map_lng = init_map_lng + 1;

003620  aa  6 00044 3701 20	epp4 	pr6|36,*
003621  ia  4 00024 0541 00	aos  	pr4|20		init_map_lng
						STATEMENT 1 ON LINE 904
	init_map (init_map_lng).init_ptr = orig_init_info_ptr;

003622  ia  4 00024 2361 00	ldq  	pr4|20		init_map_lng
003623  aa   000003 7360 00	qls  	3
003624  aa  6 00300 3735 20	epp7 	pr6|192,*		orig_init_info_ptr
003625  ia  4 00020 3715 20	epp5 	pr4|16,*		init_map_ptr
003626  aa  5 77770 6535 06	spri7	pr5|-8,ql		init_map.init_ptr
						STATEMENT 1 ON LINE 905
	init_map (init_map_lng).reference_count = 0;

003627  aa   000000 2350 07	lda  	0,dl
003630  aa  5 77776 3535 06	epp3 	pr5|-2,ql		init_map.reference_count
003631  aa  3 00000 5511 60	stba 	pr3|0,60		init_map.reference_count
						STATEMENT 1 ON LINE 906
	init_map (init_map_lng).init_type = new_init_type;

003632  aa   000000 6270 06	eax7 	0,ql
003633  aa  6 00110 2361 00	ldq  	pr6|72		new_init_type
003634  aa  5 77776 3515 17	epp1 	pr5|-2,7		init_map.init_type
003635  aa  1 00000 5521 14	stbq 	pr1|0,14		init_map.init_type
						STATEMENT 1 ON LINE 907
	init_map (init_map_lng).new_init_ptr = null;

003636  aa   774212 2370 04	ldaq 	-1910,ic		000050 = 077777000043 000001000000
003637  aa  5 77772 7571 17	staq 	pr5|-6,7		init_map.new_init_ptr
						STATEMENT 1 ON LINE 911
	if (new_init_type = INIT_COPY_INFO) | (new_init_type = INIT_LIST_TEMPLATE)
	then init_map (init_map_lng).template_size = orig_init_info_ptr -> link_init_copy_info.header.n_words;

003640  aa  6 00110 2361 00	ldq  	pr6|72		new_init_type
003641  aa   000003 1160 07	cmpq 	3,dl
003642  aa  6 01030 7471 00	stx7 	pr6|536
003643  aa   000003 6000 04	tze  	3,ic		003646
003644  aa   000005 1160 07	cmpq 	5,dl
003645  aa   000004 6010 04	tnz  	4,ic		003651
003646  aa  7 00000 2361 00	ldq  	pr7|0		link_init_copy_info.n_words
003647  aa  5 77774 7561 17	stq  	pr5|-4,7		init_map.template_size
003650  aa   000002 7100 04	tra  	2,ic		003652
						STATEMENT 1 ON LINE 914
	else init_map (init_map_lng).template_size = 0;

003651  aa  5 77774 4501 17	stz  	pr5|-4,7		init_map.template_size
						STATEMENT 1 ON LINE 916
	init_map (init_map_lng).total_init_size = init_map (init_map_lng).template_size;

003652  aa  5 77774 2361 17	ldq  	pr5|-4,7		init_map.template_size
003653  aa  5 77775 7561 17	stq  	pr5|-3,7		init_map.total_init_size
						STATEMENT 1 ON LINE 919
	return;

003654  aa  6 00460 6101 00	rtcd 	pr6|304
						STATEMENT 1 ON LINE 920
     end;

  END PROCEDURE find_init_map_entry
BEGIN PROCEDURE replace_init_info
ENTRY TO replace_init_info                                  STATEMENT 1 ON LINE 922
replace_init_info:
     proc;

003655  aa  6 00470 6501 00	spri4	pr6|312
						STATEMENT 1 ON LINE 936
	linkmap (linkmapx).init_source = comp.filename;

003656  aa  6 00103 2361 00	ldq  	pr6|67		linkmapx
003657  aa   000014 4020 07	mpy  	12,dl
003660  aa  6 00044 3701 20	epp4 	pr6|36,*
003661  ia  4 00016 3735 20	epp7 	pr4|14,*		newlinkp
003662  aa  7 77767 3735 06	epp7 	pr7|-9,ql		linkmap.init_source
003663  aa  6 00440 3715 20	epp5 	pr6|288,*		ctep
003664  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
003665  aa  5 00000 00 0040	desc9a	pr5|0,32		comp.filename
003666  aa  7 00000 00 0040	desc9a	pr7|0,32		linkmap.init_source
						STATEMENT 1 ON LINE 937
	linkmap (linkmapx).has_init_template = new_has_init_template;

003667  aa  6 00314 2351 00	lda  	pr6|204		new_has_init_template
003670  ia  4 00016 3535 20	epp3 	pr4|14,*		newlinkp
003671  aa  3 77777 6751 06	era  	pr3|-1,ql		linkmap.has_init_template
003672  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
003673  aa  3 77777 6551 06	ersa 	pr3|-1,ql		linkmap.has_init_template
						STATEMENT 1 ON LINE 938
	call change_init_map_index;

003674  aa   000002 6700 04	tsp4 	2,ic		003676
						STATEMENT 1 ON LINE 940
	return;

003675  aa  6 00470 6101 00	rtcd 	pr6|312
						STATEMENT 1 ON LINE 942
     end;

  END PROCEDURE replace_init_info
BEGIN PROCEDURE change_init_map_index
ENTRY TO change_init_map_index                              STATEMENT 1 ON LINE 948
change_init_map_index:
     proc;

003676  aa  6 00476 6501 00	spri4	pr6|318
						STATEMENT 1 ON LINE 966
	init_map (linkmap (linkmapx).init_map_index).reference_count =
	     init_map (linkmap (linkmapx).init_map_index).reference_count - 1;

003677  aa  6 00103 2361 00	ldq  	pr6|67		linkmapx
003700  aa   000014 4020 07	mpy  	12,dl
003701  aa  6 00044 3701 20	epp4 	pr6|36,*
003702  ia  4 00016 3735 20	epp7 	pr4|14,*		newlinkp
003703  aa  7 77766 2351 06	lda  	pr7|-10,ql	linkmap.init_map_index
003704  aa   000022 7350 00	als  	18
003705  aa   000000 6250 06	eax5 	0,ql
003706  aa   000066 7330 00	lrs  	54
003707  aa   000003 7360 00	qls  	3
003710  ia  4 00020 3715 20	epp5 	pr4|16,*		init_map_ptr
003711  aa  5 77776 2351 06	lda  	pr5|-2,ql		init_map.reference_count
003712  aa   000000 6270 06	eax7 	0,ql
003713  aa   000066 7330 00	lrs  	54
003714  aa   000001 1760 07	sbq  	1,dl
003715  aa   000066 7370 00	lls  	54
003716  aa  5 77776 3535 17	epp3 	pr5|-2,7		init_map.reference_count
003717  aa  3 00000 5511 60	stba 	pr3|0,60		init_map.reference_count
						STATEMENT 1 ON LINE 969
	init_map (new_init_map_index).reference_count = init_map (new_init_map_index).reference_count + 1;

003720  aa  6 00106 2361 00	ldq  	pr6|70		new_init_map_index
003721  aa   000003 7360 00	qls  	3
003722  aa  5 77776 2351 06	lda  	pr5|-2,ql		init_map.reference_count
003723  aa   000000 6260 06	eax6 	0,ql
003724  aa   000066 7330 00	lrs  	54
003725  aa   000001 0760 07	adq  	1,dl
003726  aa   000066 7370 00	lls  	54
003727  aa  5 77776 3515 16	epp1 	pr5|-2,6		init_map.reference_count
003730  aa  1 00000 5511 60	stba 	pr1|0,60		init_map.reference_count
						STATEMENT 1 ON LINE 971
	linkmap (linkmapx).init_map_index = new_init_map_index;

003731  aa  6 00106 2361 00	ldq  	pr6|70		new_init_map_index
003732  aa  7 77766 3535 15	epp3 	pr7|-10,5		linkmap.init_map_index
003733  aa  3 00000 5521 14	stbq 	pr3|0,14		linkmap.init_map_index
						STATEMENT 1 ON LINE 973
	return;

003734  aa  6 00476 6101 00	rtcd 	pr6|318
						STATEMENT 1 ON LINE 975
     end;

  END PROCEDURE change_init_map_index
BEGIN PROCEDURE extend_template
ENTRY TO extend_template                                    STATEMENT 1 ON LINE 977
extend_template:
     proc (cur_init_map_index, target_size);

003735  aa  6 00504 6501 00	spri4	pr6|324
003736  aa  6 00506 2521 00	spri2	pr6|326
						STATEMENT 1 ON LINE 998
	do mapx = 1 to init_map_lng;

003737  aa  6 00044 3701 20	epp4 	pr6|36,*
003740  ia  4 00024 2361 00	ldq  	pr4|20		init_map_lng
003741  aa  6 00512 7561 00	stq  	pr6|330
003742  aa   000001 2360 07	ldq  	1,dl
003743  aa  6 00104 7561 00	stq  	pr6|68		mapx
003744  aa  6 00104 2361 00	ldq  	pr6|68		mapx
003745  aa  6 00512 1161 00	cmpq 	pr6|330
003746  aa   000033 6054 04	tpnz 	27,ic		004001
						STATEMENT 1 ON LINE 999
	     if init_map (mapx).total_init_size = target_size
	     then if init_map (mapx).init_ptr = init_map (cur_init_map_index).init_ptr
						/* the unextended templates must match;
						   the init_map has no duplicates;
						   so if they match, they are the same */
		then do;

003747  aa   000003 7360 00	qls  	3
003750  aa  6 00044 3701 20	epp4 	pr6|36,*
003751  ia  4 00020 3735 20	epp7 	pr4|16,*		init_map_ptr
003752  aa  6 01033 7561 00	stq  	pr6|539
003753  aa  7 77775 2361 06	ldq  	pr7|-3,ql		init_map.total_init_size
003754  aa  6 00506 3715 20	epp5 	pr6|326,*
003755  aa  5 00004 1161 20	cmpq 	pr5|4,*		target_size
003756  aa   000021 6010 04	tnz  	17,ic		003777
003757  aa  5 00002 3535 20	epp3 	pr5|2,*
003760  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003761  aa  3 00000 00 0022	descb	pr3|0,18		cur_init_map_index
003762  aa  6 00056 00 0044	descb	pr6|46,36
003763  aa  6 00056 2351 00	lda  	pr6|46
003764  aa   000066 7330 00	lrs  	54
003765  aa   000003 7360 00	qls  	3
003766  aa  6 01033 7271 00	lxl7 	pr6|539
003767  aa   000000 6260 06	eax6 	0,ql
003770  aa  7 77770 2371 17	ldaq 	pr7|-8,7		init_map.init_ptr
003771  aa  7 77770 6771 16	eraq 	pr7|-8,6		init_map.init_ptr
003772  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003773  aa   000004 6010 04	tnz  	4,ic		003777
						STATEMENT 1 ON LINE 1005
		     new_init_map_index = mapx;

003774  aa  6 00104 2361 00	ldq  	pr6|68		mapx
003775  aa  6 00106 7561 00	stq  	pr6|70		new_init_map_index
						STATEMENT 1 ON LINE 1006
		     return;

003776  aa  6 00504 6101 00	rtcd 	pr6|324
						STATEMENT 1 ON LINE 1007
		end;

						STATEMENT 1 ON LINE 1008
	end;

003777  aa  6 00104 0541 00	aos  	pr6|68		mapx
004000  aa   777744 7100 04	tra  	-28,ic		003744
						STATEMENT 1 ON LINE 1012
	init_map_lng = init_map_lng + 1;

004001  aa  6 00044 3701 20	epp4 	pr6|36,*
004002  ia  4 00024 0541 00	aos  	pr4|20		init_map_lng
						STATEMENT 1 ON LINE 1016
	init_map (init_map_lng) = init_map (cur_init_map_index);

004003  ia  4 00024 2361 00	ldq  	pr4|20		init_map_lng
004004  aa   000003 7360 00	qls  	3
004005  aa  6 00506 3735 20	epp7 	pr6|326,*
004006  aa  7 00002 3715 20	epp5 	pr7|2,*
004007  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
004010  aa  5 00000 00 0022	descb	pr5|0,18		cur_init_map_index
004011  aa  6 00056 00 0044	descb	pr6|46,36
004012  aa  6 00056 2351 00	lda  	pr6|46
004013  aa   000000 6270 06	eax7 	0,ql
004014  aa   000066 7330 00	lrs  	54
004015  aa   000003 7360 00	qls  	3
004016  ia  4 00020 3535 20	epp3 	pr4|16,*		init_map_ptr
004017  aa  3 77770 3535 17	epp3 	pr3|-8,7		init_map
004020  ia  4 00020 3515 20	epp1 	pr4|16,*		init_map_ptr
004021  aa  1 77770 3515 06	epp1 	pr1|-8,ql		init_map
004022  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
004023  aa  1 00000 00 0040	desc9a	pr1|0,32		init_map
004024  aa  3 00000 00 0040	desc9a	pr3|0,32		init_map
						STATEMENT 1 ON LINE 1017
	init_map (init_map_lng).total_init_size = target_size;

004025  aa  7 00004 2361 20	ldq  	pr7|4,*		target_size
004026  ia  4 00020 3535 20	epp3 	pr4|16,*		init_map_ptr
004027  aa  3 77775 7561 17	stq  	pr3|-3,7		init_map.total_init_size
						STATEMENT 1 ON LINE 1018
	init_map (init_map_lng).reference_count = 0;

004030  aa   000000 2350 07	lda  	0,dl
004031  aa  3 77776 3515 17	epp1 	pr3|-2,7		init_map.reference_count
004032  aa  1 00000 5511 60	stba 	pr1|0,60		init_map.reference_count
						STATEMENT 1 ON LINE 1020
	new_init_map_index = init_map_lng;

004033  ia  4 00024 2361 00	ldq  	pr4|20		init_map_lng
004034  aa  6 00106 7561 00	stq  	pr6|70		new_init_map_index
						STATEMENT 1 ON LINE 1022
	return;

004035  aa  6 00504 6101 00	rtcd 	pr6|324
						STATEMENT 1 ON LINE 1024
     end;

  END PROCEDURE extend_template
BEGIN PROCEDURE add_name
ENTRY TO add_name                                           STATEMENT 1 ON LINE 1026
add_name:
     proc (new_name_ptr, name_length);

004036  aa  6 00514 6501 00	spri4	pr6|332
004037  aa  6 00516 2521 00	spri2	pr6|334
						STATEMENT 1 ON LINE 1043
	name_offset = xoffset + def_growth;

004040  aa  6 00114 2361 00	ldq  	pr6|76		xoffset
004041  aa  6 00101 0761 00	adq  	pr6|65		def_growth
004042  aa  6 00116 7561 00	stq  	pr6|78		name_offset
						STATEMENT 1 ON LINE 1044
	addrel (defbase, name_offset) -> new_name = new_name_ptr -> new_name;

004043  aa  6 00044 3701 20	epp4 	pr6|36,*
004044  ia  4 00012 3515 66	epp1 	pr4|10,*ql	defbase
004045  aa   000000 0510 03	adwp1	0,du
004046  aa  2 00002 3735 20	epp7 	pr2|2,*		new_name_ptr
004047  aa  7 00000 3735 20	epp7 	pr7|0,*		new_name_ptr
004050  aa  2 00004 7271 20	lxl7 	pr2|4,*		name_length
004051  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
004052  aa  7 00000 00 0017	desc9a	pr7|0,x7		new_name
004053  aa  1 00000 00 0017	desc9a	pr1|0,x7		new_name
						STATEMENT 1 ON LINE 1045
	def_growth = def_growth + divide (name_length + 3, 4, 17, 0);

004054  aa  2 00004 2361 20	ldq  	pr2|4,*		name_length
004055  aa   000003 0760 07	adq  	3,dl
004056  aa   000004 5060 07	div  	4,dl
004057  aa  6 00101 0561 00	asq  	pr6|65		def_growth
						STATEMENT 1 ON LINE 1047
	map_lng = map_lng + 1;

004060  aa  6 00102 0541 00	aos  	pr6|66		map_lng
						STATEMENT 1 ON LINE 1048
	strm.entry (map_lng).map = bit (name_offset, 18);

004061  aa  6 00116 2351 00	lda  	pr6|78		name_offset
004062  aa   000002 6050 04	tpl  	2,ic		004064
004063  aa   000000 5310 00	neg  	0
004064  aa   000022 7350 00	als  	18
004065  aa  6 00102 7261 00	lxl6 	pr6|66		map_lng
004066  aa  6 00442 3715 20	epp5 	pr6|290,*		strmp
004067  aa  5 01540 3535 16	epp3 	pr5|864,6		strm.map
004070  aa  3 00000 5511 60	stba 	pr3|0,60		strm.map
						STATEMENT 1 ON LINE 1049
	call strm_hash_$make_entry (new_name_ptr -> new_name, map_lng);

004071  aa  2 00004 2361 20	ldq  	pr2|4,*		name_length
004072  aa   524000 2760 03	orq  	174080,du
004073  aa  6 01035 7561 00	stq  	pr6|541
004074  aa  7 00000 3521 00	epp2 	pr7|0		new_name
004075  aa  6 01040 2521 00	spri2	pr6|544
004076  aa  6 00102 3521 00	epp2 	pr6|66		map_lng
004077  aa  6 01042 2521 00	spri2	pr6|546
004100  aa  6 01035 3521 00	epp2 	pr6|541
004101  aa  6 01044 2521 00	spri2	pr6|548
004102  aa   773723 3520 04	epp2 	-2093,ic		000025 = 404000000021
004103  aa  6 01046 2521 00	spri2	pr6|550
004104  aa  6 01036 6211 00	eax1 	pr6|542
004105  aa   010000 4310 07	fld  	4096,dl
004106  la  4 00164 3521 20	epp2 	pr4|116,*		strm_hash_$make_entry
004107  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1051
	return;

004110  aa  6 00514 6101 00	rtcd 	pr6|332
						STATEMENT 1 ON LINE 1053
     end;

  END PROCEDURE add_name
BEGIN PROCEDURE add_extension
ENTRY TO add_extension                                      STATEMENT 1 ON LINE 1056
add_extension:
     proc;

004111  aa  6 00522 6501 00	spri4	pr6|338
						STATEMENT 1 ON LINE 1072
	init_entry_ptr -> list_template_entry.n_bits = extension_size * 36;

004112  aa  6 00105 2361 00	ldq  	pr6|69		extension_size
004113  aa   000044 4020 07	mpy  	36,dl
004114  aa  6 00304 7561 20	stq  	pr6|196,*		list_template_entry.n_bits
						STATEMENT 1 ON LINE 1073
	init_entry_ptr -> list_template_entry.repeat = 0;

004115  aa   000000 2350 03	lda  	0,du
004116  aa  6 00304 3735 20	epp7 	pr6|196,*		init_entry_ptr
004117  aa  7 00001 7511 37	stca 	pr7|1,37		list_template_entry.repeat
						STATEMENT 1 ON LINE 1077
	addrel (init_entry_ptr, size (list_template_entry)) -> list_template_entry.n_bits = 0;

004120  aa  6 00452 2361 00	ldq  	pr6|298		link_init_n_bits_in_datum
004121  aa   000043 0760 07	adq  	35,dl
004122  aa   000044 5060 07	div  	36,dl
004123  aa   000002 0760 07	adq  	2,dl
004124  aa  7 00000 3521 06	epp2 	pr7|0,ql
004125  aa   000000 0520 03	adwp2	0,du
004126  aa  2 00000 4501 00	stz  	pr2|0		list_template_entry.n_bits
						STATEMENT 1 ON LINE 1081
	cur_init_info_ptr -> link_init_list_template.n_words_in_list =
	     cur_init_info_ptr -> link_init_list_template.n_words_in_list + size (list_template_entry);

004127  aa  6 00302 3715 20	epp5 	pr6|194,*		cur_init_info_ptr
004130  aa  5 00002 2351 00	lda  	pr5|2		link_init_list_template.n_words_in_list
004131  aa   000022 7350 00	als  	18
004132  aa  6 01050 7561 00	stq  	pr6|552
004133  aa   000066 7730 00	lrl  	54
004134  aa  6 01050 0761 00	adq  	pr6|552
004135  aa  5 00002 5521 14	stbq 	pr5|2,14		link_init_list_template.n_words_in_list
						STATEMENT 1 ON LINE 1083
	cur_init_info_ptr -> link_init_list_template.header.n_words = init_map (mapx).total_init_size;

004136  aa  6 00104 2361 00	ldq  	pr6|68		mapx
004137  aa   000003 7360 00	qls  	3
004140  aa  6 00044 3701 20	epp4 	pr6|36,*
004141  ia  4 00020 3535 20	epp3 	pr4|16,*		init_map_ptr
004142  aa  3 77775 2361 06	ldq  	pr3|-3,ql		init_map.total_init_size
004143  aa  5 00000 7561 00	stq  	pr5|0		link_init_list_template.n_words
						STATEMENT 1 ON LINE 1086
	return;

004144  aa  6 00522 6101 00	rtcd 	pr6|338
						STATEMENT 1 ON LINE 1088
     end;

  END PROCEDURE add_extension
  END PROCEDURE ext_link_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
