	COMPILATION LISTING OF SEGMENT ta_reconstruct_table_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/17/85  0945.6 mst Tue
	    Options: optimize map single_symbol_list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(85-09-27,Spitzer), approve(85-09-27,MCR7212),
        9*     audit(85-10-11,Blair), install(85-12-16,MR12.0-1001):
       10*     Initial coding.
       11*                                                   END HISTORY COMMENTS */
       12 
       13 
       14 /* format: ^inddcls,^indattr,indnoniterend,^indnoniterdo,indend,tree,^case,insnl,comcol61,dclind5,declareind5,delnl */
       15 
       16 ta_reconstruct_table_:
       17      proc (Ptable_ptr, arg_array, table_name, code);
       18 
       19 /*
       20*This procedure implements the reconstruct key of tape_archive.
       21*Usage:  ta reconstruct <table_name> {volume_id_list} {-control_args}
       22*     volume_id_list = up to 8 tape names
       23*     -force, -fc
       24*     -long, -lg
       25*     -density N, -den N
       26*     -retain {all|none}
       27*     -io_module tape_ansi_|tape_ibm_, -iom tape_ansi_|tape_ibm_
       28*     -volume_type ansi|ibm, -vt ansi|ibm
       29**/
       30 
       31 /* Written 85-2-19 by Charlie Spitzer. */
       32 
       33 	table_ptr = Ptable_ptr;
       34 
       35 	n_volids = 0;
       36 	density = 0;
       37 	retain_sw = "0"b;
       38 	io_module = "";
       39 	volume_type = "";
       40 	volid (*) = "";
       41 	nargs = dim (arg_array, 1);
       42 	force_sw, long_sw = "0"b;
       43 
       44 	do i = 1 to nargs;
       45 	     arg = arg_array (i);
       46 	     if substr (arg, 1, 1) = "-"
       47 	     then if /* case */ arg = "-io_module" | arg = "-iom"
       48 		then if i = nargs
       49 		     then do;
       50 missing_arg:
       51 			call com_err_ (error_table_$noarg, myname, "After ^a.", arg);
       52 			return;
       53 			end;
       54 		     else do;
       55 			i = i + 1;
       56 			io_module = arg_array (i);
       57 			if io_module ^= "tape_ansi_" & io_module ^= "tape_ibm_"
       58 			then do;
       59 			     call com_err_ (error_table_$bad_arg, myname, "I/O module ^a not supported.", io_module)
       60 				;
       61 			     return;
       62 			     end;
       63 			end;
       64 		else if arg = "-volume_type" | arg = "-vt"
       65 		then if i = nargs
       66 		     then goto missing_arg;
       67 		     else do;
       68 			i = i + 1;
       69 			volume_type = arg_array (i);
       70 			if volume_type ^= "ansi" & volume_type ^= "ibm"
       71 			then do;
       72 			     call com_err_ (error_table_$bad_arg, myname, "Volume type ^a not supported.",
       73 				io_module);
       74 			     return;
       75 			     end;
       76 			end;
       77 		else if arg = "-retain"
       78 		then if i = nargs
       79 		     then retain_sw = "0"b;
       80 		     else if substr (arg_array (i + 1), 1, 1) = "-"
       81 		     then retain_sw = "0"b;
       82 		     else do;
       83 			i = i + 1;
       84 			if arg_array (i) = "all"
       85 			then retain_sw = "1"b;
       86 			else if arg_array (i) = "none"
       87 			     then retain_sw = "0"b;
       88 			     else do;
       89 bad_argument:
       90 				call com_err_ (error_table_$bad_arg, myname, "^a", arg_array (i));
       91 				return;
       92 				end;
       93 			end;
       94 		else if arg = "-density" | arg = "-den"
       95 		then if i = nargs
       96 		     then goto missing_arg;
       97 		     else do;
       98 			i = i + 1;
       99 			density = cv_dec_check_ (arg_array (i), code);
      100 			if code ^= 0
      101 			then do;
      102 			     call com_err_ (0, myname, "^a is not a valid density.", arg_array (i));
      103 			     return;
      104 			     end;
      105 			end;
      106 		else if arg = "-force" | arg = "-fc"
      107 		then force_sw = "1"b;
      108 		else if arg = "-long" | arg = "-lg"
      109 		then long_sw = "1"b;
      110 		else do;
      111 		     call com_err_ (error_table_$badopt, myname, "^a", arg);
      112 		     return;
      113 		     end;
      114 	     else if n_volids = hbound (volid, 1)
      115 		then do;
      116 		     call com_err_ (error_table_$too_many_args, myname, "Only ^d volume ids allowed.", n_volids);
      117 		     return;
      118 		     end;
      119 		else do;
      120 		     n_volids = n_volids + 1;
      121 		     volid (n_volids) = arg;
      122 		     end;
      123 	     end;
      124 
      125 	if io_module ^= ""
      126 	then if volume_type ^= ""
      127 	     then if (io_module = "tape_ansi_" & volume_type = "ansi") | (io_module = "tape_ibm_" & volume_type = "ibm")
      128 		then ;				/* ok */
      129 		else do;
      130 		     call com_err_ (error_table_$inconsistent, myname, "io_module = ^a and volume_type = ^a.",
      131 			io_module, volume_type);
      132 		     return;
      133 		     end;
      134 	     else if io_module = "tape_ansi_"
      135 		then volume_type = "ansi";
      136 		else volume_type = "ibm";
      137 	else if volume_type ^= ""
      138 	     then if volume_type = "ansi"
      139 		then io_module = "tape_ansi_";
      140 		else io_module = "tape_ibm_";
      141 	     else do;				/* default them */
      142 		volume_type = "ansi";
      143 		io_module = "tape_ansi_";
      144 		end;
      145 
      146 	query_info.version = query_info_version_5;
      147 	if ^force_sw
      148 	     & (tape_archive_table.tape_info.n_volumes_in_set (1) + tape_archive_table.tape_info.n_volumes_in_set (2))
      149 	     ^= 0
      150 	then do;					/* there appears to be some data in the table already */
      151 	     query_info.yes_or_no_sw = "1"b;
      152 	     call command_query_ (addr (query_info), answer, myname, "^a^/^14x^a^/^14x^a?  ",
      153 		"Reconstructing the table from the tape volume will destroy all",
      154 		"information in the table before reading the tape volume.", "Do you wish to proceed");
      155 	     if answer = "no"
      156 	     then return;
      157 	     end;
      158 
      159 	if n_volids = 0
      160 	then do;
      161 	     query_info.yes_or_no_sw = "0"b;
      162 	     call command_query_ (addr (query_info), answer, myname, "Enter volume name of first volume:  ");
      163 	     n_volids = 1;
      164 	     volid (1) = answer;
      165 	     end;
      166 
      167 	do i = 1 to n_volids;
      168 	     call resource_info_$canonicalize_name ("tape_vol", (volid (i)), volid (i), code);
      169 	     if code ^= 0
      170 	     then do;
      171 		call com_err_ (code, myname, "Canonicalizing volume ^a.", volid (i));
      172 		return;
      173 		end;
      174 	     end;
      175 
      176 	call iox_$find_iocb ("ta_tape_input_", tape_input_switch, code);
      177 	if code ^= 0
      178 	then do;
      179 	     call com_err_ (code, myname, "Finding tape input switch.");
      180 	     goto DONE;
      181 	     end;
      182 
      183 	if density = 0
      184 	then density = Default_density;
      185 
      186 	temp_ptrs (*) = null;
      187 	on cleanup call cleaner;
      188 
      189 	call get_temp_segments_ (myname, temp_ptrs, code);
      190 	if code ^= 0
      191 	then do;
      192 	     call com_err_ (code, myname, "Unable to get temporary segments.");
      193 	     goto DONE;
      194 	     end;
      195 	temp_table_ptr = temp_ptrs (1);
      196 	attribute_seg_ptr = temp_ptrs (2);
      197 	data_seg_ptr = temp_ptrs (3);
      198 
      199 	call ta_table_mgr_$lock_and_copy (table_ptr, temp_table_ptr, table_name, Modify, code);
      200 	if code ^= 0
      201 	then do;
      202 	     call com_err_ (code, myname, "Unable to lock the table.");
      203 	     goto DONE;
      204 	     end;
      205 
      206 	current_time = substr (bit (clock ()), 20, 36);
      207 	table_ptr = temp_table_ptr;			/* operate on the temp segment */
      208 
      209 /* Mount the volume */
      210 	call ioa_$rsnnl ("^a^v( ^a^) -density ^d -volume_type ^a", attach_description, 0,
      211 	     TAPE_ARCHIVE_IO_MODULE, hbound (volid, 1), volid (*), density, volume_type);
      212 
      213 	call iox_$attach_ptr (tape_input_switch, attach_description, codeptr (ta_reconstruct_table_), code);
      214 	if code ^= 0
      215 	then if code = error_table_$not_detached
      216 	     then ;				/* ok */
      217 	     else do;
      218 		call com_err_ (code, myname, "Attaching tape with attach description ""^a"".", attach_description);
      219 		goto DONE;
      220 		end;
      221 
      222 	open_description = "-mode binary -block 8192 -number 1";
      223 	call iox_$open_file (tape_input_switch, Sequential_input, open_description, ""b, code);
      224 	if code ^= 0
      225 	then do;
      226 	     call com_err_ (code, myname, "Opening tape with open description ""^a"".", open_description);
      227 	     goto DONE;
      228 	     end;
      229 	open_description = "-mode binary -block 8192";
      230 
      231 /* Start filling in the pieces of the table that we know */
      232 
      233 /* tape_archive_table.nonvolatile_part */
      234 	tape_archive_table.io_module_name = io_module;
      235 	tape_archive_table.table_is_consistent = "0"b;
      236 
      237 /* tape_archive_table.volatile_part */
      238 	unspec (tape_archive_table.volatile_part) = "0"b;
      239 
      240 	tape_archive_table.incomplete_write_op_last = "1"b;
      241 	tape_archive_table.tape_info.density (1) = density;
      242 	tape_archive_table.tape_info.density (2) = Default_density;
      243 	tape_archive_table.tape_info.active_set = 1;
      244 	tape_archive_table.n_volumes_in_set (1) = n_volids;
      245 	tape_archive_table.volume_set (1).volume_id (*) = volid (*);
      246 	tape_archive_table.volume_set (2).volume_id (*) = "";
      247 
      248 	max_chars_in_seg = sys_info$max_seg_size * 4;
      249 	fst_ptr = addr (automatic_fst);
      250 	mtape_fst.version = fst_version_1;
      251 	table_number = 0;
      252 
      253 /* Read all the files on the tape */
      254 	do while (code = 0);
      255 	     call iox_$control (tape_input_switch, "file_status", fst_ptr, code);
      256 	     if code = 0
      257 	     then do;
      258 check_file_name:
      259 		attribute_file_name = mtape_fst.f_stat.file_id;
      260 		if substr (attribute_file_name, 1, length (ATTRIBUTE_FILE_PREFIX)) = ATTRIBUTE_FILE_PREFIX
      261 		then do;				/* found an attribute file */
      262 		     call iox_$read_record (tape_input_switch, attribute_seg_ptr, max_chars_in_seg, n_chars_read,
      263 			code);
      264 		     if code = error_table_$short_record
      265 		     then code = 0;
      266 		     if code = 0
      267 		     then do;
      268 			attribute_file_number =
      269 			     fixed (substr (attribute_file_name, length (ATTRIBUTE_FILE_PREFIX) + 1, 4));
      270 			call iox_$close (tape_input_switch, code);
      271 			call iox_$open_file (tape_input_switch, Sequential_input, open_description, ""b, code);
      272 			if code = 0
      273 			then do;
      274 			     call iox_$control (tape_input_switch, "file_status", fst_ptr, code);
      275 			     if code = 0
      276 			     then do;
      277 				data_file_name = mtape_fst.f_stat.file_id;
      278 				data_file_number =
      279 				     fixed (substr (data_file_name, length (ATTRIBUTE_FILE_PREFIX) + 1, 4));
      280 				if data_file_number = attribute_file_number + 1
      281 				then call process_file;
      282 				else do;
      283 				     call com_err_ (error_table_$no_file, myname,
      284 					"Could not locate the data file for attribute file ^d, skipping to next file."
      285 					, attribute_file_number);
      286 				     goto check_file_name;
      287 				     end;
      288 				end;
      289 			     end;
      290 			end;
      291 		     end;
      292 		else if substr (attribute_file_name, 1, length (TABLE_FILE_PREFIX)) = TABLE_FILE_PREFIX
      293 		     then call process_table;
      294 		     else call com_err_ (0, myname, "Found file named ^a, skipping to next file.",
      295 			     attribute_file_name);
      296 
      297 		if code = 0
      298 		then do;
      299 		     call iox_$close (tape_input_switch, code);
      300 		     if code = 0
      301 		     then call iox_$open_file (tape_input_switch, Sequential_input, open_description, "0"b, code);
      302 		     end;
      303 
      304 		end;
      305 	     end;					/* do while */
      306 
      307 	if code ^= error_table_$no_file
      308 	then call com_err_ (code, myname, "Reading the tape searching for files.");
      309 
      310 	tape_archive_table.table_is_consistent = "1"b;
      311 
      312 	call ta_table_mgr_$copy_and_unlock (table_ptr, Ptable_ptr, code);
      313 	if code ^= 0
      314 	then call com_err_ (code, myname, "Unable to unlock the table.");
      315 
      316 	table_ptr = Ptable_ptr;
      317 	call hcs_$truncate_seg (table_ptr, currentsize (tape_archive_table) + 1, (0));
      318 	call hcs_$set_bc_seg (table_ptr, currentsize (tape_archive_table) * 4, (0));
      319 	call hcs_$set_safety_sw_seg (table_ptr, "1"b, (0));
      320 
      321 DONE:
      322 	call cleaner;
      323 	return;
      324 
      325 /* We have successfully read in the attribute file and the tape is positioned
      326*at the beginning of the data file. We need to parse the attribute file and fill
      327*in the tape_archive_table.component section */
      328 
      329 process_file:
      330      proc;
      331 
      332 dcl  binary_segment bit (1) aligned;
      333 
      334 	if long_sw
      335 	then call com_err_$suppress_name (0, myname, "Processing file ^a.", ta_attributes.names (1));
      336 
      337 	tape_archive_table.n_components, tape_archive_table.n_component_slots = tape_archive_table.n_components + 1;
      338 	component_ptr = addr (tape_archive_table.component_table (tape_archive_table.n_components));
      339 
      340 	component.safety_switch = ta_attributes.safety_switch;
      341 	component.pad = ""b;
      342 	component.tape_file_name = data_file_name;
      343 	component.entry_name = ta_attributes.names (1);
      344 	component.date_time_archived = current_time;	/* not in table, use now */
      345 	component.date_time_branch_modified = ta_attributes.dtem;
      346 	component.date_time_dumped = ta_attributes.dtd;
      347 	component.bitcount_author = "???";		/* ??? not in table */
      348 	component.attribute_file_no = attribute_file_number;
      349 	component.uid = ta_attributes.uid;
      350 	component.future_expansion (*) = ""b;
      351 
      352 	component.previous_instance_backchain = 0;
      353 	component.associated_request_index = 0;
      354 	component.date_time_deleted = ""b;
      355 	component.future_expansion (*) = ""b;
      356 
      357 	component.file_length = 0;
      358 	component.n_tape_records = 0;
      359 	component.no_final_newline = "0"b;
      360 	binary_segment = "0"b;
      361 
      362 /*
      363*read the data file to see how long it is, the recording mode, and if we
      364*can read the entire file
      365**/
      366 	call iox_$read_record (tape_input_switch, data_seg_ptr, max_chars_in_seg, n_chars_read, code);
      367 	do while (code = 0);
      368 	     component.no_final_newline = (substr (data_seg, n_chars_read, 1) = NL);
      369 	     component.n_tape_records = component.n_tape_records + divide (n_chars_read + 8191, 8192, 35, 0);
      370 	     component.file_length = component.file_length + n_chars_read;
      371 	     if ^binary_segment
      372 	     then binary_segment = (verify (substr (data_seg, 1, n_chars_read), collate ()) > 0);
      373 
      374 	     call iox_$read_record (tape_input_switch, data_seg_ptr, max_chars_in_seg, n_chars_read, code);
      375 	     if code = error_table_$short_record
      376 	     then code = 0;
      377 	     end;
      378 	if code ^= error_table_$end_of_info
      379 	then do;
      380 	     call com_err_ (code, myname, "Reading data file ^a.", ta_attributes.names (1));
      381 	     return;
      382 	     end;
      383 	else code = 0;
      384 
      385 	component.file_length = divide (component.file_length + 4095, 4096, 35, 0);
      386 						/* length in Multics records */
      387 
      388 	tape_archive_table.total_records = tape_archive_table.total_records + component.file_length;
      389 	tape_archive_table.last_tape_file_no = tape_archive_table.last_tape_file_no + 1;
      390 
      391 	if binary_segment
      392 	then component.recording_mode = "binary";
      393 	else if volume_type = "ibm"
      394 	     then component.recording_mode = "ebcdic";
      395 	     else component.recording_mode = "ascii";
      396 
      397 	component.valid = "1"b;
      398 
      399 	return;
      400      end process_file;
      401 
      402 process_table:
      403      proc;
      404 
      405 dcl  done bit (1) aligned;
      406 dcl  first_found fixed bin;
      407 dcl  new_component_ptr ptr;
      408 dcl  (i,j) fixed bin;
      409 
      410 	table_number = fixed (substr (attribute_file_name, length (TABLE_FILE_PREFIX)+1, 4));
      411 	if long_sw
      412 	then call com_err_$suppress_name (0, myname, "Processing table ^i", table_number);
      413 
      414 	call iox_$read_record (tape_input_switch, data_seg_ptr, max_chars_in_seg, n_chars_read, code);
      415 	if code ^= 0
      416 	then if code ^= error_table_$short_record
      417 	     then do;
      418 		call com_err_ (code, myname, "Reading table ^i.", table_number);
      419 		return;
      420 		end;
      421 	     else code = 0;
      422 
      423 	if data_seg_ptr -> tape_archive_table.version_number ^= tape_archive_version_4
      424 	then do;
      425 	     call com_err_ (error_table_$unimplemented_version, myname,
      426 		"Found table version ^i, expecting version ^i. Skipping to next file.",
      427 		data_seg_ptr -> tape_archive_table.version_number, tape_archive_version_4);
      428 	     return;
      429 	     end;
      430 
      431 /* Loop through all entries in the table. If an entry in the table matches
      432*what we read in recently, use the information from the read-in table to update
      433*the information in the table we are building, as not all the component
      434*information is stored in the attribute files. Logically deleted files will come
      435*back, as will files that are replaced by ones further down the tape. The user
      436*will have to clean this up, as we have no idea from mtape_ whether any portions
      437*of the tape were skipped, thus loosing the backchain indices in the table. */
      438 
      439 	first_found = 1;
      440 	do i = 1 to data_seg_ptr -> tape_archive_table.n_component_slots;
      441 	     new_component_ptr = addr (data_seg_ptr -> tape_archive_table.component_table (i));
      442 	     if new_component_ptr -> component.valid
      443 	     then do;
      444 		done = "0"b;
      445 		do j = first_found to tape_archive_table.n_component_slots while (^done);
      446 		     component_ptr = addr (tape_archive_table.component_table (j));
      447 		     if component.valid
      448 		     then if new_component_ptr -> component.tape_file_name = component.tape_file_name
      449 			then do;			/* same file, use data not found on tape */
      450 			     component.bitcount_author = new_component_ptr -> component.bitcount_author;
      451 			     component.date_time_archived = new_component_ptr -> component.date_time_archived;
      452 			     first_found = j + 1;	/* for next time through loop */
      453 			     done = "1"b;
      454 			     end;
      455 		     end;				/* do j */
      456 		end;
      457 	     end;					/* do i */
      458 
      459 	tape_archive_table.last_table_no = table_number;
      460 	tape_archive_table.date_time_tape_modified = data_seg_ptr -> tape_archive_table.date_time_tape_modified;
      461 	tape_archive_table.date_time_last_compacted = data_seg_ptr -> tape_archive_table.date_time_last_compacted;
      462 
      463 	return;
      464      end process_table;
      465 
      466 cleaner:
      467      proc;
      468 
      469 	if temp_ptrs (1) ^= null
      470 	then call release_temp_segments_ (myname, temp_ptrs, (0));
      471 
      472 	if tape_input_switch ^= null
      473 	then do;
      474 	     call iox_$close (tape_input_switch, (0));
      475 	     if retain_sw
      476 	     then do;
      477 		tape_archive_table.mount_lock = get_lock_id_ ();
      478 		tape_archive_table.highest_mount_type = Read;
      479 		end;
      480 	     else call iox_$detach_iocb (tape_input_switch, (0));
      481 	     tape_input_switch = null;
      482 	     end;
      483 
      484 	call ta_table_mgr_$unlock (Ptable_ptr, (0));
      485 
      486 	return;
      487      end cleaner;
      488 
  1     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  1     2 
  1     3 /* Written 05/04/78 by C. D. Tavares */
  1     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  1     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  1     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  1     7 
  1     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  1     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  1    10      iox_$close entry (pointer, fixed bin (35)),
  1    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  1    12      iox_$delete_record entry (pointer, fixed bin (35)),
  1    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  1    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  1    15      iox_$err_not_attached entry options (variable),
  1    16      iox_$err_not_closed entry options (variable),
  1    17      iox_$err_no_operation entry options (variable),
  1    18      iox_$err_not_open entry options (variable),
  1    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  1    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  1    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  1    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  1    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  1    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  1    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  1    28      iox_$propagate entry (pointer),
  1    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  1    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  1    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  1    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  1    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  1    40 
  1    41 dcl (iox_$user_output,
  1    42      iox_$user_input,
  1    43      iox_$user_io,
  1    44      iox_$error_output) external static pointer;
  1    45 
  1    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      489 
  2     1 /* Begin include file ..... iox_modes.incl.pl1 */
  2     2 
  2     3 /* Written by C. D. Tavares, 03/17/75 */
  2     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  2     5 
  2     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  2     7     ("stream_input", "stream_output", "stream_input_output",
  2     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  2     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  2    10      "direct_input", "direct_output", "direct_update");
  2    11 
  2    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  2    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  2    14 
  2    15 dcl (Stream_input initial (1),
  2    16      Stream_output initial (2),
  2    17      Stream_input_output initial (3),
  2    18      Sequential_input initial (4),
  2    19      Sequential_output initial (5),
  2    20      Sequential_input_output initial (6),
  2    21      Sequential_update initial (7),
  2    22      Keyed_sequential_input initial (8),
  2    23      Keyed_sequential_output initial (9),
  2    24      Keyed_sequential_update initial (10),
  2    25      Direct_input initial (11),
  2    26      Direct_output initial (12),
  2    27      Direct_update initial (13)) fixed bin int static options (constant);
  2    28 
  2    29 /* End include file ..... iox_modes.incl.pl1 */
      490 
  3     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  3     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  3     3 /*	version number changed to 4, 08/10/78 WOS */
  3     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  3     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  3     6 
  3     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  3     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  3     9     2 switches aligned,                                     /* various bit switch values */
  3    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  3    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  3    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  3    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  3    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  3    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  3    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  3    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  3    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  3    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  3    20 
  3    21 /*  Limit of data defined for version 2 */
  3    22 
  3    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  3    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  3    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  3    26 						/* minimum of 30 seconds required for repeat */
  3    27 						/* otherwise, no repeat will occur */
  3    28 /* Limit of data defined for version 4 */
  3    29 
  3    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  3    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  3    32 
  3    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  3    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  3    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  3    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  3    37 
  3    38 /*	END INCLUDE FILE query_info.incl.pl1 */
      491 
  4     1 /* BEGIN INCLUDE FILE mtape_file_status.incl.pl1. Created 02/02/83 by J. A. Bush */
  4     2 /* format: style4 */
  4     3 /* This include file defines the structures returned by the "file_status" ("fst"),
  4     4*   and the "file_set_status" ("fsst") control operations */
  4     5 
  4     6 dcl  fst_ptr ptr;					/* Pointer to the file_status info structure */
  4     7 dcl  fsst_ptr ptr;					/* Pointer to the file_set_status info structure */
  4     8 dcl  f_statp ptr;					/* Pointer to file_status structure */
  4     9 
  4    10 dcl  fst_version_1 char (8) int static options (constant) init ("fstv0001");
  4    11 dcl  fsst_version_1 char (8) int static options (constant) init ("fsstv001");
  4    12 
  4    13 dcl  mtape_fsst_nfiles fixed bin;			/* Set this variable before allocating mtape_fsst structure */
  4    14 
  4    15 dcl  1 mtape_fst aligned based (fst_ptr),		/* "file_status" info structure */
  4    16        2 version char (8),				/* Current version */
  4    17        2 file_type fixed bin,				/* Use rcp_volume_formats.incl.pl1 for decode */
  4    18        2 f_stat like file_status;			/* See file_status structure below */
  4    19 
  4    20 dcl  1 mtape_fsst aligned based (fsst_ptr),		/* "file_set_status" info structure */
  4    21        2 version char (8),				/* Current version */
  4    22        2 file_set_id char (32),			/* File set identifier */
  4    23        2 file_type fixed bin,				/* Use rcp_volume_formats.incl.pl1 for decode */
  4    24        2 nfiles fixed bin,				/* # of files in file set */
  4    25        2 fs_stat (mtape_fsst_nfiles refer (mtape_fsst.nfiles)) like file_status; /* See file_status structure below */
  4    26 
  4    27 dcl  1 file_status based (f_statp) aligned,		/* file status info template */
  4    28        2 file_state fixed bin,			/* 0 => Never opened; 1 => File not currently open;
  4    29*						   2 => File open; 3 => File open & locked for error */
  4    30        2 error_code fixed bin (35),			/* Error code if file_state = 3 */
  4    31        2 file_id char (32),				/* File name or identifier */
  4    32        2 file_seq fixed bin,				/* File sequence number */
  4    33        2 begin_vol_index fixed bin,			/* Index to volume file begins on */
  4    34        2 end_vol_index fixed bin,			/* Index to volume file ends on */
  4    35        2 file_sections fixed bin,			/* Number of file sections within file */
  4    36        2 generation fixed bin,			/* File generation number */
  4    37        2 gen_version fixed bin,			/* File generation version number */
  4    38        2 creation char (6),				/* File creation date (" yyddd") */
  4    39        2 expiration char (6),				/* File expiration date (" yyddd") */
  4    40        2 file_format char (3),			/* File/block format, PFM dependent */
  4    41        2 block_len fixed bin,				/* Maximum block length (in 9 bit bytes) */
  4    42        2 reclen fixed bin (21),			/* Maximum record length (in 9 bit bytes) */
  4    43        2 recording_mode char (6),			/* ASCII, EBCDIC, BCD, etc */
  4    44        2 block_count fixed bin (35),			/* # of blocks in this file */
  4    45        2 read_errors fixed bin (35),			/* # of read errors encountered reading this file */
  4    46        2 write_errors fixed bin (35);			/* # of write errors encountered writing this file */
  4    47 
  4    48 /* END INCLUDE FILE mtape_file_status.incl.pl1 */
      492 
  5     1 /* --------------- BEGIN include file tape_archive_attributes.incl.pl1 --------------- */
  5     2 
  5     3 dcl 1 ta_attributes aligned based (attribute_seg_ptr),
  5     4     2 version_no fixed bin,
  5     5     2 own_length_in_chars fixed bin (21),
  5     6     2 branch like status_branch aligned,
  5     7     2 safety_switch bit (1) aligned,
  5     8     2 entrypt_is_bounded bit (1) aligned,
  5     9     2 entrypt_bound bit (14) aligned,
  5    10     2 max_length fixed bin (19),
  5    11     2 future_expansion (22) bit (36) aligned,
  5    12     2 acl_count fixed bin,
  5    13     2 n_components fixed bin,
  5    14     2 names (binary (ta_attributes.nnames)) char (32) unaligned,
  5    15     2 acl_list (ta_attributes.acl_count) aligned,
  5    16       3 username char (32),
  5    17       3 modes bit (36),
  5    18       3 pad bit (72),
  5    19     2 component_bc (0:ta_attributes.n_components-1) fixed bin (24);
  5    20 
  6     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  6     2 
  6     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  6     4 
  6     5 /* This include file contains branch and link structures returned by
  6     6*   hcs_$status_ and hcs_$status_long. */
  6     7 
  6     8 dcl 1 status_branch aligned based (status_ptr),
  6     9     2 short aligned,
  6    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  6    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  6    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  6    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  6    14       3 dtu bit (36) unaligned,			/* date/time last used */
  6    15       3 mode bit (5) unaligned,			/* caller's effective access */
  6    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  6    17       3 pad1 bit (8) unaligned,
  6    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  6    19 
  6    20 /* Limit of information returned by hcs_$status_ */
  6    21 
  6    22     2 long aligned,
  6    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  6    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  6    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  6    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  6    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  6    28       3 pad2 bit (8) unaligned,
  6    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  6    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  6    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  6    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  6    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  6    34       3 pad3 bit (5) unaligned,
  6    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  6    36       3 uid bit (36) unaligned;			/* unique ID */
  6    37 
  6    38 dcl 1 status_link aligned based (status_ptr),
  6    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  6    40     2 nnames fixed bin (16) unaligned unsigned,
  6    41     2 names_relp bit (18) unaligned,
  6    42     2 dtem bit (36) unaligned,
  6    43     2 dtd bit (36) unaligned,
  6    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  6    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  6    46 
  6    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  6    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  6    49 						/* array of names returned */
  6    50      status_pathname character (status_link.pathname_length) aligned
  6    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  6    52 						/* link target path */
  6    53      status_area_ptr pointer,
  6    54      status_ptr pointer;
  6    55 
  6    56 dcl (Link initial (0),
  6    57      Segment initial (1),
  6    58      Directory initial (2)) fixed bin internal static options (constant);
  6    59 						/* values for type fields declared above */
  6    60 
  6    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
  5    21 
  5    22 
  5    23 /* ---------------- END include file tape_archive_attributes.incl.pl1 ---------------- */
      493 
  7     1 /* ---------- BEGIN include file tape_archive_table_dcl.incl.pl1 ---------- */
  7     2 
  7     3 /* Version 2 lengthened volume names from 6 to 32 characters */
  7     4 /* Version 3 introduced density field, workspace strategy for updates, */
  7     5 /* and the mount lock, which is less of a lock than a retain indicator. */
  7     6 /* Version 4 expanded density field to an array for independent volume set */
  7     7 /* densities and added uid fields for table deletion checking. */
  7     8 /* Modified 09/21/80 by C. D. Tavares for version 3 */
  7     9 /* Modified 12/9/81 by CDT to add highest_mount_type field */
  7    10 /* Last modified 83-03-16 by S. G. Harris (UNCA) for version 4. */
  7    11 /* Modified 09/16/83 by S. Krupp to add the TAPE_ARCHIVE_IO_MODULE
  7    12*   declaration for conversion to the mtape_ I/O module. */
  7    13 
  7    14 dcl 1 tape_archive_table aligned based (table_ptr),	/* online segment for tape_archive command */
  7    15     2 nonvolatile_part aligned,			/* temp table moving doesn't touch these */
  7    16       3 version_number fixed bin,			/* of table */
  7    17       3 magic_constant char (8),			/* "ta table" */
  7    18       3 compaction_warning_threshold float bin,		/* when to suggest compaction to user */
  7    19       3 auto_compaction_threshold float bin,		/* when to compact when user doesn't take hint */
  7    20       3 table_is_consistent bit (1) unaligned,		/* update in progress indicator */
  7    21       3 lock bit (36),				/* allows shared tape archives */
  7    22       3 lock_reason fixed bin,			/* reason seg already locked, for failure msg */
  7    23       3 locker_id char (32),				/* userid of locking process, for failure msg */
  7    24       3 io_module_name char (32),			/* tape_ansi_ or tape_ibm_ */
  7    25       3 recovery_info_offset bit (18) aligned,		/* holds address of workspace for table updates */
  7    26       3 perm_table_uid bit (36),			/* used to prevent table deletion */
  7    27       3 future_expansion (6) bit (36),			/* ... */
  7    28     2 volatile_part aligned,				/* these can get altered due to temp table moves */
  7    29       3 n_components fixed bin,			/* number valid (undeleted) components in archive */
  7    30       3 n_component_slots fixed bin,			/* number of used component slots in table */
  7    31       3 n_queued_requests fixed bin,			/* number requests to be performed next mount */
  7    32       3 n_request_slots fixed bin,			/* number of used request slots in table */
  7    33       3 next_mount_type fixed bin,			/* read only, write, or compact */
  7    34       3 date_time_tape_modified bit (36),		/* last time tape written on */
  7    35       3 date_time_last_compacted bit (36),		/* last time tape compacted */
  7    36       3 total_records fixed bin (35),			/* data out on tape, in Multics records */
  7    37       3 dead_records fixed bin (35),			/* records wasted (deletions, replacements) */
  7    38       3 incomplete_write_op_last bit (1),		/* ON if determined that user or sys crashed while writing tape */
  7    39       3 last_tape_file_no fixed bin,			/* number of last file existing on volume set */
  7    40       3 last_table_no fixed bin,			/* number of copies of online table on this volume set */
  7    41       3 mount_lock bit (36) aligned,			/* set to lock_id while volume set mounted */
  7    42       3 highest_mount_type fixed bin,			/* max of next_mount_type since retained */
  7    43       3 future_expansion (6) bit (36),			/* ... */
  7    44       3 tape_info aligned,
  7    45         4 density (2) fixed bin (17) unal,		/* post version 3 volume set densities */
  7    46         4 active_set fixed bin,			/* which of the two is most current */
  7    47         4 n_volumes_in_set (2) fixed bin,		/* how many reels comprise volume set */
  7    48         4 volume_set (2) aligned,
  7    49 	5 volume_id (8) char (168),			/* physical reel and slot info */
  7    50       3 component_table (0 refer (tape_archive_table.n_component_slots)) aligned like component,
  7    51       3 request_queue (0 refer (tape_archive_table.n_request_slots)) aligned like request;
  7    52 
  7    53 dcl 1 component aligned based (component_ptr),		/* format of one component entry */
  7    54     2 entry_status_descriptor like entry_status_descriptor aligned,
  7    55     2 previous_instance_backchain fixed bin,		/* index of file it replaced, if any */
  7    56     2 associated_request_index fixed bin,		/* if extract pending, index of request with dirpath */
  7    57     2 date_time_deleted bit (36) aligned,		/* if logically deleted, when. */
  7    58     2 future_expansion (5) bit (36) aligned;		/* ... */
  7    59 
  7    60 dcl 1 request aligned based (request_ptr),		/* format of a queued request */
  7    61     2 entry_status_descriptor like entry_status_descriptor aligned,
  7    62     2 directory_name char (168) unaligned,		/* in Multics file system */
  7    63     2 requested_ops unaligned,
  7    64       3 append bit (1) unaligned,			/* add to tape */
  7    65       3 replace bit (1) unaligned,			/* replace to tape */
  7    66       3 extract bit (1) unaligned,			/* extract from tape */
  7    67       3 delete bit (1) unaligned,			/* delete from tape or file system */
  7    68       3 force bit (1) unaligned,			/* forcibly do any of the above */
  7    69       3 single_name bit (1) unaligned,			/* append/extract with only given name */
  7    70       3 future_expansion bit (30) unaligned,
  7    71     2 existing_reference fixed bin,			/* index of component block, if exists (e.g. read) */
  7    72     2 future_expansion (4) bit (36) aligned;
  7    73 
  7    74 dcl 1 entry_status_descriptor aligned based,
  7    75     2 valid bit (1) unaligned,			/* an undeleted component or request if on */
  7    76     2 no_final_newline bit (1) unaligned,		/* ON if last char in file was not newline */
  7    77     2 safety_switch bit (1) unaligned,			/* reflects safety switch of file while online */
  7    78     2 pad bit (33) unaligned,
  7    79     2 file_info aligned,				/* main tape file for this entry */
  7    80       3 tape_file_name char (17),
  7    81       3 entry_name char (32) unaligned,			/* for Multics file system */
  7    82       3 date_time_archived bit (36),			/* when it was put on tape */
  7    83       3 recording_mode char (8) aligned,		/* "ascii", "binary", "ebcdic", etc. */
  7    84       3 date_time_branch_modified bit (36),		/* last modified while in file system */
  7    85       3 date_time_dumped bit (36),			/* by backup facility */
  7    86       3 bitcount_author char (32),			/* last person who modified it while online */
  7    87       3 file_length fixed bin (35),			/* in Multics pages */
  7    88       3 attribute_file_no fixed bin,			/* file number of attribute file on tape */
  7    89       3 n_tape_records fixed bin (35),			/* number of logical records on tape for this file */
  7    90     2 uid bit (36) aligned,				/* used to prevent table deletion */
  7    91     2 future_expansion bit (36) aligned;
  7    92 
  7    93 dcl 1 workspace based (workspace_ptr) aligned,		/* to prevent update inconsistencies */
  7    94     2 workspace_id char (8),				/* "wrkspace" */
  7    95     2 component_no fixed bin,
  7    96     2 request_no fixed bin,
  7    97     2 n_queued_requests fixed bin,
  7    98     2 dead_records fixed bin,
  7    99     2 total_records fixed bin,
  7   100     2 n_components fixed bin,
  7   101     2 n_request_slots fixed bin,
  7   102     2 next_mount_type fixed bin,
  7   103     2 future_expansion (70) fixed bin (35),
  7   104     2 tape_info_copy aligned like tape_archive_table.tape_info,
  7   105     2 future_expansion2 (16) fixed bin (35),
  7   106     2 component_copy like component aligned,
  7   107     2 future_expansion3 (16) fixed bin (35),
  7   108     2 request_copy like request aligned;
  7   109 
  7   110 dcl 1 based_tape_info based (tape_info_ptr) like tape_archive_table.tape_info aligned;
  7   111 
  7   112 dcl (table_ptr, component_ptr, request_ptr, workspace_ptr, tape_info_ptr) pointer;
  7   113 
  7   114 dcl ((None initial (0),				/* next scheduled processing flags */
  7   115      Delete initial (1),
  7   116      Read initial (2),
  7   117      Write initial (3),
  7   118      Compact initial (4),
  7   119 
  7   120      Examine initial (1),				/* current lock reason flags */
  7   121      Modify initial (2),
  7   122      Process_tape initial (3),
  7   123 
  7   124      Deletion initial (1),				/* pending_operation flags */
  7   125      Extraction initial (2),
  7   126      Replacement initial (3),
  7   127      Cancellation initial (4),
  7   128      Deletion_cancellation initial (5),
  7   129      Volume_alteration initial (6),
  7   130      Table_creation initial (7),
  7   131      Table_copy initial (8),
  7   132 
  7   133      Default_density initial (1600),
  7   134 
  7   135      tape_archive_version_4 initial (4)) fixed bin,
  7   136 
  7   137      TAPE_ARCHIVE_IO_MODULE char(6) init("mtape_"),
  7   138 
  7   139      Lock_reasons (0:3) char (24) initial
  7   140     ("no discernable reason", "table examination", "table modification", "tape processing"),
  7   141 
  7   142      Magic_constant char (8) initial ("ta table"),
  7   143      Magic_workspace_constant char (8) initial ("wrkspace")) static options (constant);
  7   144 
  7   145 /* ---------------- END include file tape_archive_table_dcl.incl.pl1 ---------------- */
      494 
      495 
      496 /* Arguments */
      497 
      498 dcl  arg_array (*) char (168) parameter;
      499 dcl  code fixed bin (35) parameter;
      500 dcl  max_chars_in_seg fixed bin (21);
      501 dcl  Ptable_ptr ptr parameter;
      502 dcl  table_name char (*) parameter;
      503 
      504 /* Automatic */
      505 
      506 dcl  answer char (32) varying;
      507 dcl  arg char (168);
      508 dcl  attach_description char (256);
      509 dcl  attribute_file_name char (32);
      510 dcl  attribute_file_number fixed bin;
      511 dcl  attribute_seg_ptr ptr;
      512 dcl  1 automatic_fst aligned like mtape_fst;
      513 dcl  current_time bit (36);
      514 dcl  data_file_name char (32);
      515 dcl  data_file_number fixed bin;
      516 dcl  data_seg_ptr ptr;
      517 dcl  density fixed bin;
      518 dcl  force_sw bit (1) aligned;
      519 dcl  i fixed bin;
      520 dcl  io_module char (10);
      521 dcl  long_sw bit (1) aligned;
      522 dcl  n_chars_read fixed bin (21);
      523 dcl  n_volids fixed bin;
      524 dcl  nargs fixed bin;
      525 dcl  open_description char (168);
      526 dcl  retain_sw bit (1) aligned;
      527 dcl  table_number fixed bin;
      528 dcl  tape_input_switch ptr;
      529 dcl  temp_ptrs (3) ptr;
      530 dcl  temp_table_ptr ptr;
      531 dcl  volid (8) char (32);
      532 dcl  volume_type char (4);
      533 
      534 /* Based */
      535 
      536 dcl  data_seg char (max_chars_in_seg) based (data_seg_ptr);
      537 
      538 /* Builtins */
      539 
      540 dcl  addr builtin;
      541 dcl  binary builtin;
      542 dcl  bit builtin;
      543 dcl  clock builtin;
      544 dcl  codeptr builtin;
      545 dcl  collate builtin;
      546 dcl  currentsize builtin;
      547 dcl  dim builtin;
      548 dcl  divide builtin;
      549 dcl  fixed builtin;
      550 dcl  hbound builtin;
      551 dcl  length builtin;
      552 dcl  null builtin;
      553 dcl  substr builtin;
      554 dcl  unspec builtin;
      555 dcl  verify builtin;
      556 
      557 /* Conditions */
      558 
      559 dcl  cleanup condition;
      560 
      561 /* Static */
      562 
      563 dcl  ATTRIBUTE_FILE_PREFIX char (13) int static options (constant) init ("ATTRIBUTEFILE");
      564 dcl  error_table_$bad_arg fixed bin (35) ext static;
      565 dcl  error_table_$badopt fixed bin (35) ext static;
      566 dcl  error_table_$end_of_info fixed bin (35) ext static;
      567 dcl  error_table_$inconsistent fixed bin (35) ext static;
      568 dcl  error_table_$no_file fixed bin (35) ext static;
      569 dcl  error_table_$noarg fixed bin (35) ext static;
      570 dcl  error_table_$not_detached fixed bin (35) ext static;
      571 dcl  error_table_$short_record fixed bin (35) ext static;
      572 dcl  error_table_$too_many_args fixed bin (35) ext static;
      573 dcl  error_table_$unimplemented_version fixed bin (35) ext static;
      574 dcl  myname char (32) int static options (constant) init ("tape_archive");
      575 dcl  NL char (1) int static options (constant) init ("
      576 ");
      577 dcl  sys_info$max_seg_size fixed bin (35) ext static;
      578 dcl  TABLE_FILE_PREFIX char (13) int static options (constant) init ("ONLINE-TABLE-");
      579 
      580 /* Entries */
      581 
      582 dcl  com_err_ ext entry options (variable);
      583 dcl  com_err_$suppress_name entry () options (variable);
      584 dcl  command_query_ entry () options (variable);
      585 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
      586 dcl  get_lock_id_ entry () returns (bit (36) aligned);
      587 dcl  get_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
      588 dcl  hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35));
      589 dcl  hcs_$set_safety_sw_seg entry (ptr, bit (1), fixed bin (35));
      590 dcl  hcs_$truncate_seg entry (ptr, fixed bin (19), fixed bin (35));
      591 dcl  ioa_$rsnnl entry () options (variable);
      592 dcl  release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
      593 dcl  resource_info_$canonicalize_name entry (char (*), char (*), char (*), fixed bin (35));
      594 dcl  ta_table_mgr_$copy_and_unlock entry (ptr, ptr, fixed bin (35));
      595 dcl  ta_table_mgr_$lock_and_copy entry (ptr, ptr, char (*), fixed bin, fixed bin (35));
      596 dcl  ta_table_mgr_$unlock entry (ptr, fixed bin (35));
      597 
      598      end ta_reconstruct_table_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/16/85  1652.9  ta_reconstruct_table_.pl1         >spec>install>1001>ta_reconstruct_table_.pl1
489          1    05/23/83  0916.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
490          2    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
491          3    03/11/83  1204.3  query_info_.incl.pl1              >ldd>include>query_info.incl.pl1
492          4    02/16/84  1452.3  mtape_file_status.incl.pl1        >ldd>include>mtape_file_status.incl.pl1
493          5    01/15/79  2202.8  tape_archive_attributes.incl.pl1  >ldd>include>tape_archive_attributes.incl.pl1
5-21         6    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
494          7    02/16/84  1452.4  tape_archive_table_dcl.incl.pl1   >ldd>include>tape_archive_table_dcl.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

ATTRIBUTE_FILE_PREFIX           000014 constant        char(13)                 initial unaligned dcl 563 ref 260 260 268 278
Cancellation                           internal static fixed bin(17,0)          initial dcl 7-114
Compact                                internal static fixed bin(17,0)          initial dcl 7-114
DONE                            003603 constant        label                    dcl 321 ref 180 193 203 219 227
Default_density                        constant        fixed bin(17,0)          initial dcl 7-114 ref 183 242
Delete                                 internal static fixed bin(17,0)          initial dcl 7-114
Deletion                               internal static fixed bin(17,0)          initial dcl 7-114
Deletion_cancellation                  internal static fixed bin(17,0)          initial dcl 7-114
Direct_input                           internal static fixed bin(17,0)          initial dcl 2-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 2-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 2-15
Directory                              internal static fixed bin(17,0)          initial dcl 6-56
Examine                                internal static fixed bin(17,0)          initial dcl 7-114
Extraction                             internal static fixed bin(17,0)          initial dcl 7-114
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 2-15
Link                                   internal static fixed bin(17,0)          initial dcl 6-56
Lock_reasons                           internal static char(24)                 initial array unaligned dcl 7-114
Magic_constant                         internal static char(8)                  initial unaligned dcl 7-114
Magic_workspace_constant               internal static char(8)                  initial unaligned dcl 7-114
Modify                          000111 constant        fixed bin(17,0)          initial dcl 7-114 set ref 199*
NL                              005012 constant        char(1)                  initial unaligned dcl 575 ref 368
None                                   internal static fixed bin(17,0)          initial dcl 7-114
Process_tape                           internal static fixed bin(17,0)          initial dcl 7-114
Ptable_ptr                             parameter       pointer                  dcl 501 set ref 16 33 312* 316 484*
Read                                   constant        fixed bin(17,0)          initial dcl 7-114 ref 478
Replacement                            internal static fixed bin(17,0)          initial dcl 7-114
Segment                                internal static fixed bin(17,0)          initial dcl 6-56
Sequential_input                000110 constant        fixed bin(17,0)          initial dcl 2-15 set ref 223* 271* 300*
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 2-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 2-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 2-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 2-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 2-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 2-15
TABLE_FILE_PREFIX               000000 constant        char(13)                 initial unaligned dcl 578 ref 292 292 410
TAPE_ARCHIVE_IO_MODULE          000020 constant        char(6)                  initial unaligned dcl 7-114 set ref 210*
Table_copy                             internal static fixed bin(17,0)          initial dcl 7-114
Table_creation                         internal static fixed bin(17,0)          initial dcl 7-114
Volume_alteration                      internal static fixed bin(17,0)          initial dcl 7-114
Write                                  internal static fixed bin(17,0)          initial dcl 7-114
active_set               65            based           fixed bin(17,0)          level 4 dcl 7-14 set ref 243*
addr                                                   builtin function         dcl 540 ref 152 152 162 162 249 338 441 446
answer                          000125 automatic       varying char(32)         dcl 506 set ref 152* 155 162* 164
answer_iocbp              6     000100 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
arg                             000136 automatic       char(168)                unaligned dcl 507 set ref 45* 46 46 46 50* 64 64 77
                                                                                  94 94 106 106 108 108 111* 121
arg_array                              parameter       char(168)                array unaligned dcl 498 set ref 16 41 45 56 69 80 84
                                                                                  86 89* 99* 102*
associated_request_index
                         41            based           fixed bin(17,0)          level 2 dcl 7-53 set ref 353*
attach_description              000210 automatic       char(256)                unaligned dcl 508 set ref 210* 213* 218*
attribute_file_name             000310 automatic       char(32)                 unaligned dcl 509 set ref 258* 260 268 292 294* 410
attribute_file_no        34            based           fixed bin(17,0)          level 4 dcl 7-53 set ref 348*
attribute_file_number           000320 automatic       fixed bin(17,0)          dcl 510 set ref 268* 280 283* 348
attribute_seg_ptr               000322 automatic       pointer                  dcl 511 set ref 196* 262* 334 340 343 345 346 349
                                                                                  380
automatic_fst                   000324 automatic       structure                level 1 dcl 512 set ref 249
bad_argument                    001243 constant        label                    dcl 89
based_tape_info                        based           structure                level 1 dcl 7-110
binary                                                 builtin function         dcl 541
binary_segment                  000622 automatic       bit(1)                   dcl 332 set ref 360* 371 371* 391
bit                                                    builtin function         dcl 542 ref 206
bitcount_author          23            based           char(32)                 level 4 dcl 7-53 set ref 347* 450* 450
branch                    2            based           structure                level 2 dcl 5-3
check_file_name                 003036 constant        label                    dcl 258 ref 286
cleaner                         004461 constant        entry                    internal dcl 466 ref 187 321
cleanup                         000602 stack reference condition                dcl 559 ref 187
clock                                                  builtin function         dcl 543 ref 206
code                                   parameter       fixed bin(35,0)          dcl 499 set ref 16 99* 100 168* 169 171* 176* 177
                                                                                  179* 189* 190 192* 199* 200 202* 213* 214 214 218*
                                                                                  223* 224 226* 254 255* 256 262* 264 264* 266 270*
                                                                                  271* 272 274* 275 297 299* 300 300* 307 307* 312*
                                                                                  313 313* 366* 367 374* 375 375* 378 380* 383* 414*
                                                                                  415 415 418* 421*
codeptr                                                builtin function         dcl 544 ref 213 213
collate                                                builtin function         dcl 545 ref 371
com_err_                        000054 constant        entry                    external dcl 582 ref 50 59 72 89 102 111 116 130 171
                                                                                  179 192 202 218 226 283 294 307 313 380 418 425
com_err_$suppress_name          000056 constant        entry                    external dcl 583 ref 334 411
command_query_                  000060 constant        entry                    external dcl 584 ref 152 162
component                              based           structure                level 1 dcl 7-53
component_ptr                   000122 automatic       pointer                  dcl 7-112 set ref 338* 340 341 342 343 344 345 346
                                                                                  347 348 349 350 352 353 354 355 357 358 359 368
                                                                                  369 369 370 370 385 385 388 391 393 395 397 446*
                                                                                  447 447 450 451
component_table        1330            based           structure                array level 3 dcl 7-14 set ref 338 441 446
cp_escape_control         1(02) 000100 automatic       bit(2)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
current_time                    000363 automatic       bit(36)                  unaligned dcl 513 set ref 206* 344
currentsize                                            builtin function         dcl 546 ref 317 318
cv_dec_check_                   000062 constant        entry                    external dcl 585 ref 99
data_file_name                  000364 automatic       char(32)                 unaligned dcl 514 set ref 277* 278 342
data_file_number                000374 automatic       fixed bin(17,0)          dcl 515 set ref 278* 280
data_seg                               based           char                     unaligned dcl 536 ref 368 371
data_seg_ptr                    000376 automatic       pointer                  dcl 516 set ref 197* 366* 368 371 374* 414* 423 425
                                                                                  440 441 460 461
date_time_archived       16            based           bit(36)                  level 4 dcl 7-53 set ref 344* 451* 451
date_time_branch_modified
                         21            based           bit(36)                  level 4 dcl 7-53 set ref 345*
date_time_deleted        42            based           bit(36)                  level 2 dcl 7-53 set ref 354*
date_time_dumped         22            based           bit(36)                  level 4 dcl 7-53 set ref 346*
date_time_last_compacted
                         46            based           bit(36)                  level 3 dcl 7-14 set ref 461* 461
date_time_tape_modified
                         45            based           bit(36)                  level 3 dcl 7-14 set ref 460* 460
density                  64            based           fixed bin(17,0)          array level 4 in structure "tape_archive_table"
                                                                                  packed unaligned dcl 7-14 in procedure
                                                                                  "ta_reconstruct_table_" set ref 241* 242*
density                         000400 automatic       fixed bin(17,0)          dcl 517 in procedure "ta_reconstruct_table_" set ref
                                                                                  36* 99* 183 183* 210* 241
dim                                                    builtin function         dcl 547 ref 41
divide                                                 builtin function         dcl 548 ref 369 385
done                            000632 automatic       bit(1)                   dcl 405 set ref 444* 445 453*
dtd                       6            based           bit(36)                  level 4 packed unaligned dcl 5-3 ref 346
dtem                      7            based           bit(36)                  level 4 packed unaligned dcl 5-3 ref 345
entry_name                6            based           char(32)                 level 4 packed unaligned dcl 7-53 set ref 343*
entry_status_descriptor                based           structure                level 2 in structure "component" dcl 7-53
                                                                                  in procedure "ta_reconstruct_table_"
entry_status_descriptor                based           structure                level 1 dcl 7-74 in procedure
                                                                                  "ta_reconstruct_table_"
error_table_$bad_arg            000026 external static fixed bin(35,0)          dcl 564 set ref 59* 72* 89*
error_table_$badopt             000030 external static fixed bin(35,0)          dcl 565 set ref 111*
error_table_$end_of_info        000032 external static fixed bin(35,0)          dcl 566 ref 378
error_table_$inconsistent       000034 external static fixed bin(35,0)          dcl 567 set ref 130*
error_table_$no_file            000036 external static fixed bin(35,0)          dcl 568 set ref 283* 307
error_table_$noarg              000040 external static fixed bin(35,0)          dcl 569 set ref 50*
error_table_$not_detached       000042 external static fixed bin(35,0)          dcl 570 ref 214
error_table_$short_record       000044 external static fixed bin(35,0)          dcl 571 ref 264 375 415
error_table_$too_many_args      000046 external static fixed bin(35,0)          dcl 572 set ref 116*
error_table_$unimplemented_version
                                000050 external static fixed bin(35,0)          dcl 573 set ref 425*
explanation_len          14     000100 automatic       fixed bin(21,0)          initial level 2 dcl 3-7 set ref 3-7*
explanation_ptr          12     000100 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
f_stat                    3            based           structure                level 2 dcl 4-15
f_statp                                automatic       pointer                  dcl 4-8
file_id                   5            based           char(32)                 level 3 dcl 4-15 ref 258 277
file_info                 1            based           structure                level 3 dcl 7-53
file_length              33            based           fixed bin(35,0)          level 4 dcl 7-53 set ref 357* 370* 370 385* 385 388
file_status                            based           structure                level 1 dcl 4-27
first_found                     000633 automatic       fixed bin(17,0)          dcl 406 set ref 439* 445 452*
fixed                                                  builtin function         dcl 549 ref 268 278 410
force_sw                        000401 automatic       bit(1)                   dcl 518 set ref 42* 106* 147
fsst_ptr                               automatic       pointer                  dcl 4-7
fsst_version_1                         internal static char(8)                  initial unaligned dcl 4-11
fst_ptr                         000116 automatic       pointer                  dcl 4-6 set ref 249* 250 255* 258 274* 277
fst_version_1                   000022 constant        char(8)                  initial unaligned dcl 4-10 ref 250
future_expansion         43            based           bit(36)                  array level 2 dcl 7-53 set ref 350* 355*
get_lock_id_                    000064 constant        entry                    external dcl 586 ref 477
get_temp_segments_              000066 constant        entry                    external dcl 587 ref 189
hbound                                                 builtin function         dcl 550 ref 114 210 210
hcs_$set_bc_seg                 000070 constant        entry                    external dcl 588 ref 318
hcs_$set_safety_sw_seg          000072 constant        entry                    external dcl 589 ref 319
hcs_$truncate_seg               000074 constant        entry                    external dcl 590 ref 317
highest_mount_type       55            based           fixed bin(17,0)          level 3 dcl 7-14 set ref 478*
i                               000636 automatic       fixed bin(17,0)          dcl 408 in procedure "process_table" set ref 440*
                                                                                  441*
i                               000402 automatic       fixed bin(17,0)          dcl 519 in procedure "ta_reconstruct_table_" set ref
                                                                                  44* 45 46 55* 55 56 64 68* 68 69 77 80 83* 83 84
                                                                                  86 89 94 98* 98 99 102* 167* 168 168 171*
incomplete_write_op_last
                         51            based           bit(1)                   level 3 dcl 7-14 set ref 240*
io_module                       000403 automatic       char(10)                 unaligned dcl 520 set ref 38* 56* 57 57 59* 72* 125
                                                                                  125 125 130* 134 137* 140* 143* 234
io_module_name           20            based           char(32)                 level 3 dcl 7-14 set ref 234*
ioa_$rsnnl                      000076 constant        entry                    external dcl 591 ref 210
iox_$attach_loud                000000 constant        entry                    external dcl 1-8
iox_$attach_name                000000 constant        entry                    external dcl 1-8
iox_$attach_ptr                 000010 constant        entry                    external dcl 1-8 ref 213
iox_$close                      000012 constant        entry                    external dcl 1-8 ref 270 299 474
iox_$close_file                 000000 constant        entry                    external dcl 1-8
iox_$control                    000014 constant        entry                    external dcl 1-8 ref 255 274
iox_$delete_record              000000 constant        entry                    external dcl 1-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 1-8
iox_$detach                     000000 constant        entry                    external dcl 1-8
iox_$detach_iocb                000016 constant        entry                    external dcl 1-8 ref 480
iox_$err_no_operation           000000 constant        entry                    external dcl 1-8
iox_$err_not_attached           000000 constant        entry                    external dcl 1-8
iox_$err_not_closed             000000 constant        entry                    external dcl 1-8
iox_$err_not_open               000000 constant        entry                    external dcl 1-8
iox_$error_output                      external static pointer                  dcl 1-41
iox_$find_iocb                  000020 constant        entry                    external dcl 1-8 ref 176
iox_$find_iocb_n                000000 constant        entry                    external dcl 1-8
iox_$get_chars                  000000 constant        entry                    external dcl 1-8
iox_$get_line                   000000 constant        entry                    external dcl 1-8
iox_$look_iocb                  000000 constant        entry                    external dcl 1-8
iox_$modes                      000000 constant        entry                    external dcl 1-8
iox_$move_attach                000000 constant        entry                    external dcl 1-8
iox_$open                       000000 constant        entry                    external dcl 1-8
iox_$open_file                  000024 constant        entry                    external dcl 1-8 ref 223 271 300
iox_$position                   000000 constant        entry                    external dcl 1-8
iox_$propagate                  000000 constant        entry                    external dcl 1-8
iox_$put_chars                  000000 constant        entry                    external dcl 1-8
iox_$read_key                   000000 constant        entry                    external dcl 1-8
iox_$read_length                000000 constant        entry                    external dcl 1-8
iox_$read_record                000022 constant        entry                    external dcl 1-8 ref 262 366 374 414
iox_$rewrite_record             000000 constant        entry                    external dcl 1-8
iox_$seek_key                   000000 constant        entry                    external dcl 1-8
iox_$user_input                        external static pointer                  dcl 1-41
iox_$user_io                           external static pointer                  dcl 1-41
iox_$user_output                       external static pointer                  dcl 1-41
iox_$write_record               000000 constant        entry                    external dcl 1-8
iox_modes                              internal static char(24)                 initial array dcl 2-6
j                               000637 automatic       fixed bin(17,0)          dcl 408 set ref 445* 446 452*
last_table_no            53            based           fixed bin(17,0)          level 3 dcl 7-14 set ref 459*
last_tape_file_no        52            based           fixed bin(17,0)          level 3 dcl 7-14 set ref 389* 389
length                                                 builtin function         dcl 551 ref 260 268 278 292 410
literal_sw                1(05) 000100 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
long                      6            based           structure                level 3 dcl 5-3
long_sw                         000406 automatic       bit(1)                   dcl 521 set ref 42* 108* 334 411
max_chars_in_seg                000124 automatic       fixed bin(21,0)          dcl 500 set ref 248* 262* 366* 368 371 374* 414*
missing_arg                     001004 constant        label                    dcl 50 ref 64 94
mount_lock               54            based           bit(36)                  level 3 dcl 7-14 set ref 477*
mtape_fsst                             based           structure                level 1 dcl 4-20
mtape_fsst_nfiles                      automatic       fixed bin(17,0)          dcl 4-13
mtape_fst                              based           structure                level 1 dcl 4-15
myname                          000004 constant        char(32)                 initial unaligned dcl 574 set ref 50* 59* 72* 89*
                                                                                  102* 111* 116* 130* 152* 162* 171* 179* 189* 192*
                                                                                  202* 218* 226* 283* 294* 307* 313* 334* 380* 411*
                                                                                  418* 425* 469*
n_chars_read                    000407 automatic       fixed bin(21,0)          dcl 522 set ref 262* 366* 368 369 370 371 374* 414*
n_component_slots        41            based           fixed bin(17,0)          level 3 dcl 7-14 set ref 238 317 318 337* 440 445
n_components             40            based           fixed bin(17,0)          level 3 dcl 7-14 set ref 337 337* 338
n_request_slots          43            based           fixed bin(17,0)          level 3 dcl 7-14 set ref 238 317 318
n_tape_records           35            based           fixed bin(35,0)          level 4 dcl 7-53 set ref 358* 369* 369
n_volids                        000410 automatic       fixed bin(17,0)          dcl 523 set ref 35* 114 116* 120* 120 121 159 163*
                                                                                  167 244
n_volumes_in_set         66            based           fixed bin(17,0)          array level 4 dcl 7-14 set ref 147 147 244*
names                    50            based           char(32)                 array level 2 packed unaligned dcl 5-3 set ref 334*
                                                                                  343 380*
nargs                           000411 automatic       fixed bin(17,0)          dcl 524 set ref 41* 44 46 64 77 94
new_component_ptr               000634 automatic       pointer                  dcl 407 set ref 441* 442 447 450 451
no_final_newline          0(01)        based           bit(1)                   level 3 packed unaligned dcl 7-53 set ref 359* 368*
nonvolatile_part                       based           structure                level 2 dcl 7-14
null                                                   builtin function         dcl 552 ref 186 3-7 3-7 3-7 469 472 481
open_description                000412 automatic       char(168)                unaligned dcl 525 set ref 222* 223* 226* 229* 271*
                                                                                  300*
pad                       0(03)        based           bit(33)                  level 3 packed unaligned dcl 7-53 set ref 341*
padding                   1(07) 000100 automatic       bit(29)                  initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
previous_instance_backchain
                         40            based           fixed bin(17,0)          level 2 dcl 7-53 set ref 352*
process_file                    003610 constant        entry                    internal dcl 329 ref 280
process_table                   004167 constant        entry                    internal dcl 402 ref 292
prompt_after_explanation
                          1(06) 000100 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
query_code                3     000100 automatic       fixed bin(35,0)          initial level 2 dcl 3-7 set ref 3-7*
query_info                      000100 automatic       structure                level 1 dcl 3-7 set ref 152 152 162 162
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 3-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 3-34
query_info_version_5                   constant        fixed bin(17,0)          initial dcl 3-35 ref 146
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 3-36
question_iocbp            4     000100 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
recording_mode           17            based           char(8)                  level 4 dcl 7-53 set ref 391* 393* 395*
release_temp_segments_          000100 constant        entry                    external dcl 592 ref 469
repeat_time              10     000100 automatic       fixed bin(71,0)          initial level 2 dcl 3-7 set ref 3-7*
request                                based           structure                level 1 dcl 7-60
request_ptr                            automatic       pointer                  dcl 7-112
resource_info_$canonicalize_name
                                000102 constant        entry                    external dcl 593 ref 168
retain_sw                       000464 automatic       bit(1)                   dcl 526 set ref 37* 77* 80* 84* 86* 475
safety_switch             0(02)        based           bit(1)                   level 3 in structure "component" packed unaligned
                                                                                  dcl 7-53 in procedure "ta_reconstruct_table_" set
                                                                                  ref 340*
safety_switch            14            based           bit(1)                   level 2 in structure "ta_attributes" dcl 5-3
                                                                                  in procedure "ta_reconstruct_table_" ref 340
short_iox_modes                        internal static char(4)                  initial array dcl 2-12
status_area_ptr                        automatic       pointer                  dcl 6-47
status_branch                          based           structure                level 1 dcl 6-8
status_code               2     000100 automatic       fixed bin(35,0)          initial level 2 dcl 3-7 set ref 3-7*
status_entry_names                     based           char(32)                 array dcl 6-47
status_link                            based           structure                level 1 dcl 6-38
status_pathname                        based           char                     dcl 6-47
status_ptr                             automatic       pointer                  dcl 6-47
substr                                                 builtin function         dcl 553 ref 46 80 206 260 268 278 292 368 371 410
suppress_name_sw          1(01) 000100 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
suppress_spacing          1(04) 000100 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
switches                  1     000100 automatic       structure                level 2 dcl 3-7
sys_info$max_seg_size           000052 external static fixed bin(35,0)          dcl 577 ref 248
ta_attributes                          based           structure                level 1 dcl 5-3
ta_reconstruct_table_           000633 constant        entry                    external dcl 16 ref 213 213
ta_table_mgr_$copy_and_unlock   000104 constant        entry                    external dcl 594 ref 312
ta_table_mgr_$lock_and_copy     000106 constant        entry                    external dcl 595 ref 199
ta_table_mgr_$unlock            000110 constant        entry                    external dcl 596 ref 484
table_is_consistent       5            based           bit(1)                   level 3 packed unaligned dcl 7-14 set ref 235* 310*
table_name                             parameter       char                     unaligned dcl 502 set ref 16 199*
table_number                    000465 automatic       fixed bin(17,0)          dcl 527 set ref 251* 410* 411* 418* 459
table_ptr                       000120 automatic       pointer                  dcl 7-112 set ref 33* 147 147 199* 207* 234 235 238
                                                                                  240 241 242 243 244 245 246 310 312* 316* 317* 317
                                                                                  318* 318 319* 337 337 337 338 338 388 388 389 389
                                                                                  445 446 459 460 461 477 478
tape_archive_table                     based           structure                level 1 dcl 7-14 set ref 317 318
tape_archive_version_4          000110 constant        fixed bin(17,0)          initial dcl 7-114 set ref 423 425*
tape_file_name            1            based           char(17)                 level 4 dcl 7-53 set ref 342* 447 447
tape_info                64            based           structure                level 3 dcl 7-14
tape_info_ptr                          automatic       pointer                  dcl 7-112
tape_input_switch               000466 automatic       pointer                  dcl 528 set ref 176* 213* 223* 255* 262* 270* 271*
                                                                                  274* 299* 300* 366* 374* 414* 472 474* 480* 481*
temp_ptrs                       000470 automatic       pointer                  array dcl 529 set ref 186* 189* 195 196 197 469 469*
temp_table_ptr                  000476 automatic       pointer                  dcl 530 set ref 195* 199* 207
total_records            47            based           fixed bin(35,0)          level 3 dcl 7-14 set ref 388* 388
uid                      36            based           bit(36)                  level 3 in structure "component" dcl 7-53
                                                                                  in procedure "ta_reconstruct_table_" set ref 349*
uid                      13            based           bit(36)                  level 4 in structure "ta_attributes" packed
                                                                                  unaligned dcl 5-3 in procedure
                                                                                  "ta_reconstruct_table_" ref 349
unspec                                                 builtin function         dcl 554 set ref 238*
valid                                  based           bit(1)                   level 3 packed unaligned dcl 7-53 set ref 397* 442
                                                                                  447
verify                                                 builtin function         dcl 555 ref 371
version                                based           char(8)                  level 2 in structure "mtape_fst" dcl 4-15
                                                                                  in procedure "ta_reconstruct_table_" set ref 250*
version                         000100 automatic       fixed bin(17,0)          level 2 in structure "query_info" dcl 3-7
                                                                                  in procedure "ta_reconstruct_table_" set ref 146*
version_number                         based           fixed bin(17,0)          level 3 dcl 7-14 set ref 423 425*
volatile_part            40            based           structure                level 2 dcl 7-14 set ref 238*
volid                           000500 automatic       char(32)                 array unaligned dcl 531 set ref 40* 114 121* 164*
                                                                                  168 168* 171* 210 210 210* 245
volume_id                70            based           char(168)                array level 5 dcl 7-14 set ref 245* 246*
volume_set               70            based           structure                array level 4 dcl 7-14
volume_type                     000600 automatic       char(4)                  unaligned dcl 532 set ref 39* 69* 70 70 125 125 125
                                                                                  130* 134* 136* 137 137 142* 210* 393
workspace                              based           structure                level 1 dcl 7-93
workspace_ptr                          automatic       pointer                  dcl 7-112
yes_or_no_sw              1     000100 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  151* 161* 3-7*

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5434        5546    5016        5444
Length      6172    5016       112         410     415           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ta_reconstruct_table_               954 external procedure  is an external procedure.  
on unit on line 187                  64 on unit               
process_file                            internal procedure  shares stack frame of external procedure ta_reconstruct_table_.  
process_table                           internal procedure  shares stack frame of external procedure ta_reconstruct_table_.  
cleaner                              80 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ta_reconstruct_table_    000100 query_info                  ta_reconstruct_table_
                         000116 fst_ptr                     ta_reconstruct_table_
                         000120 table_ptr                   ta_reconstruct_table_
                         000122 component_ptr               ta_reconstruct_table_
                         000124 max_chars_in_seg            ta_reconstruct_table_
                         000125 answer                      ta_reconstruct_table_
                         000136 arg                         ta_reconstruct_table_
                         000210 attach_description          ta_reconstruct_table_
                         000310 attribute_file_name         ta_reconstruct_table_
                         000320 attribute_file_number       ta_reconstruct_table_
                         000322 attribute_seg_ptr           ta_reconstruct_table_
                         000324 automatic_fst               ta_reconstruct_table_
                         000363 current_time                ta_reconstruct_table_
                         000364 data_file_name              ta_reconstruct_table_
                         000374 data_file_number            ta_reconstruct_table_
                         000376 data_seg_ptr                ta_reconstruct_table_
                         000400 density                     ta_reconstruct_table_
                         000401 force_sw                    ta_reconstruct_table_
                         000402 i                           ta_reconstruct_table_
                         000403 io_module                   ta_reconstruct_table_
                         000406 long_sw                     ta_reconstruct_table_
                         000407 n_chars_read                ta_reconstruct_table_
                         000410 n_volids                    ta_reconstruct_table_
                         000411 nargs                       ta_reconstruct_table_
                         000412 open_description            ta_reconstruct_table_
                         000464 retain_sw                   ta_reconstruct_table_
                         000465 table_number                ta_reconstruct_table_
                         000466 tape_input_switch           ta_reconstruct_table_
                         000470 temp_ptrs                   ta_reconstruct_table_
                         000476 temp_table_ptr              ta_reconstruct_table_
                         000500 volid                       ta_reconstruct_table_
                         000600 volume_type                 ta_reconstruct_table_
                         000622 binary_segment              process_file
                         000632 done                        process_table
                         000633 first_found                 process_table
                         000634 new_component_ptr           process_table
                         000636 i                           process_table
                         000637 j                           process_table

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              enable              ext_entry_desc      int_entry           any_to_any_tr       divide_fx3
clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      com_err_$suppress_name        command_query_                cv_dec_check_
get_lock_id_                  get_temp_segments_            hcs_$set_bc_seg               hcs_$set_safety_sw_seg
hcs_$truncate_seg             ioa_$rsnnl                    iox_$attach_ptr               iox_$close
iox_$control                  iox_$detach_iocb              iox_$find_iocb                iox_$open_file
iox_$read_record              release_temp_segments_        resource_info_$canonicalize_name
ta_table_mgr_$copy_and_unlock ta_table_mgr_$lock_and_copy   ta_table_mgr_$unlock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$badopt           error_table_$end_of_info      error_table_$inconsistent
error_table_$no_file          error_table_$noarg            error_table_$not_detached     error_table_$short_record
error_table_$too_many_args    error_table_$unimplemented_version                          sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 000626    3    7 000646        33 000676        35 000702        36 000703        37 000704        38 000705
     39 000710        40 000712        41 000726        42 000736        44 000740        45 000747        46 000765
     50 001004        52 001035        55 001036        56 001037        57 001046        59 001056        61 001106
     63 001107        64 001110        68 001123        69 001124        70 001133        72 001143        74 001173
     76 001174        77 001175        80 001206        83 001220        84 001221        86 001235        89 001243
     91 001276        93 001277        94 001300        98 001313        99 001314       100 001345       102 001350
    103 001415       105 001416       106 001417       108 001432       111 001445       112 001474       113 001475
    114 001476       116 001501       117 001531       120 001532       121 001533       123 001541       125 001543
    130 001575       132 001631       133 001632       134 001633       136 001642       137 001645       140 001661
    142 001665       143 001667       146 001672       147 001674       151 001702       152 001704       155 001763
    159 001770       161 001772       162 001774       163 002026       164 002030       167 002034       168 002043
    169 002101       171 002104       172 002136       174 002137       176 002141       177 002167       179 002172
    180 002216       183 002217       186 002223       187 002237       189 002261       190 002303       192 002306
    193 002332       195 002333       196 002335       197 002337       199 002341       200 002372       202 002375
    203 002421       206 002422       207 002431       210 002433       213 002506       214 002535       218 002544
    219 002573       222 002574       223 002577       224 002632       226 002635       227 002665       229 002666
    234 002671       235 002675       238 002676       240 002713       241 002715       242 002720       243 002722
    244 002724       245 002726       246 002747       248 002765       249 002771       250 002773       251 002776
    254 002777       255 003003       256 003033       258 003036       260 003042       262 003046       264 003066
    266 003074       268 003076       270 003113       271 003125       272 003161       274 003164       275 003214
    277 003217       278 003223       280 003240       283 003246       286 003276       291 003277       292 003300
    294 003306       297 003336       299 003341       300 003352       305 003410       307 003411       310 003437
    312 003442       313 003456       316 003505       317 003511       318 003536       319 003565       321 003603
    323 003607       329 003610       334 003611       337 003652       338 003657       340 003663       341 003671
    342 003673       343 003676       344 003701       345 003703       346 003705       347 003707       348 003712
    349 003714       350 003716       352 003727       353 003730       354 003731       355 003732       357 003743
    358 003744       359 003745       360 003747       366 003750       367 003770       368 003773       369 004005
    370 004015       371 004021       374 004037       375 004056       377 004064       378 004065       380 004070
    381 004122       383 004123       385 004124       388 004134       389 004141       391 004142       393 004150
    395 004161       397 004164       399 004166       402 004167       410 004170       411 004205       414 004240
    415 004260       418 004266       419 004320       421 004321       423 004322       425 004325       428 004360
    439 004361       440 004363       441 004373       442 004377       444 004402       445 004403       446 004415
    447 004421       450 004431       451 004434       452 004436       453 004441       455 004443       457 004445
    459 004447       460 004452       461 004455       463 004457       466 004460       469 004466       472 004514
    474 004521       475 004533       477 004536       478 004546       479 004552       480 004553       481 004565
    484 004570       486 004603


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
