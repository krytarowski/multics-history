	COMPILATION LISTING OF SEGMENT cm_get_header
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0952.9 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*        This module implements collection_manager_$get_header.  It returns
       11*   to the caller the caller-defined collection header of the specified
       12*   collection (p_collection_id).  The header is returned in the specified
       13*   buffer (p_buffer_ptr, p_buffer_length) if it will fit, or in a newly
       14*   allocated buffer in the specified area (p_area_ptr).
       15**/
       16 
       17 /* HISTORY:
       18*Written by Matthew Pierret, 04/01/82.
       19*Modified:
       20*04/13/82 by Lindsey Spratt: Fixed to set the collmgr_header_ptr. Previously,
       21*	  the collmgr_header_buffer_ptr was being set, but not the
       22*	  collmgr_header_ptr.  The collmgr_header_buffer_ptr is no longer
       23*	  used.
       24*05/20/82 by Matthew Pierret: Changed to use collection_header instead of 
       25*            collmgr_header.collection (), and to call cm_get_collection_header.
       26*08/04/82 by Matthew Pierret: Changed to use bit(36)aligned collection id.
       27*11/04/82 by Matthew Pierret:  Changed to use opening info (cm_info) and
       28*            upgraded to COLLECTION_HEADER_VERSION_2.
       29*01/27/83 by Matthew Pierret:  Upgraded to CM_INFO_VERSION_2. Changed to report
       30*            certain errors attempting to get the header via sub_err_. These
       31*            errors indicate an internal inconsistency.
       32*10/02/84 by Matthew Pierret:  Removed error_table_$unimplemented_version,
       33*               added addr.  Added DESCRIPTION.
       34*12/03/84 by Matthew Pierret:  Changed to use dm_hdr_collection_id.incl.pl1 
       35*            instead of the obsolete cm_cm_header.incl.pl1.
       36**/
       37 
       38 /* format: style2,ind3 */
       39 
       40 cm_get_header:
       41    proc (p_file_opening_id, p_collection_id, p_buffer_ptr, p_buffer_length, p_area_ptr, p_new_buffer_was_allocated,
       42         p_header_ptr, p_header_length, p_code);
       43 
       44 
       45 /* START OF DECLARATIONS */
       46 /* Parameter */
       47 
       48       dcl	    p_file_opening_id      bit (36) aligned;
       49       dcl	    p_collection_id	       bit (36) aligned;
       50       dcl	    p_buffer_ptr	       ptr;
       51       dcl	    p_buffer_length	       fixed bin (17);
       52       dcl	    p_area_ptr	       ptr;
       53       dcl	    p_new_buffer_was_allocated
       54 			       bit (1) aligned;
       55       dcl	    p_header_ptr	       ptr;
       56       dcl	    p_header_length	       fixed bin (35);
       57       dcl	    p_code	       fixed bin (35);
       58 
       59 /* Automatic */
       60 /* Based */
       61 /* Builtin */
       62 
       63       dcl	    (addr, null)	       builtin;
       64 
       65 /* Controlled */
       66 /* Constant */
       67 
       68       dcl	    myname	       init ("cm_get_header") char (32) varying int static options (constant);
       69       dcl	    UNINITIALIZED_ELEMENT_ID
       70 			       bit (36) aligned init ("0"b) int static options (constant);
       71 
       72 /* Entry */
       73 
       74       dcl	    sub_err_	       entry () options (variable);
       75 
       76 /* External */
       77 
       78       dcl	    (
       79 	    dm_error_$no_header_record,
       80 	    dm_error_$ci_not_allocated,
       81 	    dm_error_$ci_not_in_collection,
       82 	    dm_error_$no_element
       83 	    )		       ext fixed bin (35);
       84 
       85 /* END OF DECLARATIONS */
       86 
       87       p_code = 0;
       88       p_new_buffer_was_allocated = "0"b;
       89 
       90       call cm_opening_info$get (p_file_opening_id, p_collection_id, cm_info_ptr, p_code);
       91       if p_code ^= 0
       92       then return;
       93 
       94       call CHECK_VERSION ("cm_info", cm_info.version, CM_INFO_VERSION_2);
       95 
       96       collection_header_ptr = cm_info.header_ptr;
       97 
       98       call CHECK_VERSION ("collection_header", collection_header.version, COLLECTION_HEADER_VERSION_2);
       99 
      100 
      101       if collection_header.header_record_element_id = UNINITIALIZED_ELEMENT_ID
      102       then
      103          do;
      104 	  p_code = dm_error_$no_header_record;
      105 	  return;
      106          end;
      107 
      108       element_id_string = collection_header.header_record_element_id;
      109       call cm_get_element (cm_info.file_oid, HEADER_COLLECTION_ID, element_id_string, 0, p_buffer_ptr, (p_buffer_length),
      110 	 p_area_ptr, p_new_buffer_was_allocated, p_header_ptr, p_header_length, p_code);
      111 
      112       if p_code ^= 0
      113       then if p_code = dm_error_$no_element | p_code = dm_error_$ci_not_allocated
      114 	      | p_code = dm_error_$ci_not_in_collection
      115 	 then call sub_err_ (p_code, myname, ACTION_CANT_RESTART, null, 0,
      116 		 "^/An internal inconsistency was encountered attempting to get the user header^/for collection ^3bo at control interval ^d, slot ^d."
      117 		 , p_collection_id, element_id.control_interval_id, element_id.index);
      118 
      119       return;
      120 
      121 
      122 CHECK_VERSION:
      123    proc (p_structure_name, p_given_version, p_correct_version);
      124 
      125       dcl	    p_structure_name       char (*);
      126       dcl	    p_given_version	       char (8) aligned;
      127       dcl	    p_correct_version      char (8) aligned;
      128       dcl	    error_table_$unimplemented_version
      129 			       ext fixed bin (35);
      130 
      131       if p_given_version ^= p_correct_version
      132       then call sub_err_ (error_table_$unimplemented_version, myname, "s", null, 0,
      133 	      "^/Expected version ""^8a"" of ^a structure; received ""^8a"".", p_correct_version, p_structure_name,
      134 	      p_given_version);
      135 
      136       return;
      137 
      138    end CHECK_VERSION;
      139 
  1     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*        The cm_info structure is used to hold per-process opening information
  1     5*   about a collection.  It is generally allocated in the process' DM free
  1     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  1     7*   is used to provide access the cm_info structure, keeping it in a hash
  1     8*   table keyed on file opening id and collection id combined.
  1     9*        Currently cm_info is never freed until the process terminates.  Each
  1    10*   time a new transaction is started, detected when the current transaction
  1    11*   id of a process differs from cm_info.current_transaction_id, the information
  1    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  1    13*   demand, as most modules do not need the information in the storage record.
  1    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  1    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  1    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  1    17*   requested, it is placed at the location pointed to by
  1    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  1    19**/
  1    20 
  1    21 /* HISTORY:
  1    22*Written by Matthew Pierret, 10/27/82. 
  1    23*Modified:
  1    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  1    25*            storage_record_buffer_ptr. This points to the storage_record.
  1    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  1    27*            but storage_record_buffer_ptr continues to point at where the
  1    28*            storage_record was. When the storge_record is again requested,
  1    29*            it is put back in the same place rather than allocating a new
  1    30*            storage_record.
  1    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  1    32*            init clause from the version component.
  1    33**/
  1    34 
  1    35 /* format: style2,ind3,ll79 */
  1    36 
  1    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  1    38 	     2 version	      char (8),
  1    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  1    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  1    41 	     2 collection_id      bit (36) aligned init ("0"b),
  1    42 	     2 header_ptr	      ptr init (null),
  1    43 	     2 storage_record_ptr ptr init (null),
  1    44 	     2 storage_record_buffer_ptr
  1    45 			      ptr init (null);
  1    46 
  1    47      dcl	   cm_info_ptr	      ptr init (null);
  1    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  1    49 			      internal static options (constant);
  1    50 
  1    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      140 
      141 
  2     1 /* BEGIN INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*       Associated with each collection is the following collection_header
  2     5*   structure stored as an element in the Header Collection of the file.
  2     6*   The identifier of this element is also the idenfifier of the collection.
  2     7*   Even the Header Collection has a collection_header stored in the Header
  2     8*   Collection itself in the element identified by the constant
  2     9*   HEADER_COLLECTION_HEADER_ELEMENT_ID declared in dm_cm_hdr_col_ids.incl.pl1.
  2    10*   The information in collection_header is expected to be stable information.
  2    11*   The structure elements are described as follows:
  2    12*   
  2    13*   version is a character string version equal to COLLECTION_HEADER_VERSION_2.
  2    14*   
  2    15*   flags.fixed_size_elements indicates, if on that all elements in the
  2    16*   collection are of a fixed length.
  2    17*   
  2    18*   flags.thread_elements indicates that elements in a collection are to be
  2    19*   threaded in a linked list.  This is currrently unupported.
  2    20*   
  2    21*   flags.thread_control_intervals indicates, if on, that control intervals in
  2    22*   a collection are to be threaded in a linked list.  This is only useful if
  2    23*   the control interval storage method is blocked.
  2    24*   
  2    25*   flags.must_be_zero1 is reserved for future use and must be "0"b.
  2    26*   
  2    27*   control_interval_storage_method is the method of storage management of
  2    28*   control intervals for this collection, either
  2    29*   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD (not yet supported) or
  2    30*   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, declared in
  2    31*   dm_cism_info.incl.pl1.
  2    32*   
  2    33*   element_storage_method is the method of storage management of elements in
  2    34*   this collection, either BASIC_ELEMENT_STORAGE_METHOD or
  2    35*   ORDERED_ELEMENT_STORAGE_METHOD, declared in dm_esm_info.incl.pl1.
  2    36*   
  2    37*   maximum_element_size is the maximum size of an element in bits in this
  2    38*   collection.
  2    39*   
  2    40*   header_record_element_id is the identifier of an element containing a
  2    41*   caller-defined header for this collection.  If equal to "0"b, no
  2    42*   caller-defined header yet exists.  The put_header collection_manager_
  2    43*   operation stores such a header.
  2    44*   
  2    45*   storage_record_element_id is the identifier of the element containing the
  2    46*   storage_record for this collection.  The storage_record contains
  2    47*   information expected to be dynamic, such as the identifier of the last
  2    48*   control interval of the collection.  Its format is also dependent upon the
  2    49*   storage methods in effect for this collection.  storage_record structures
  2    50*   are declared in dm_cm_storage_record.incl.pl1.
  2    51*
  2    52**/
  2    53 
  2    54 /* HISTORY:
  2    55*Written by Matthew Pierret, 04/01/82.
  2    56*Modified:
  2    57*07/01/82 by Matthew Pierret: Changed to version A, added storage_record_area.
  2    58*10/29/82 by Matthew Pierret: Changed to version 2 ("col_hdr2"), separated
  2    59*            storage_record_area out, leaving storage_record_element_id behind.
  2    60*09/18/84 by Matthew Pierret: Added DESCRIPTION section.
  2    61**/
  2    62 
  2    63 /* format: style2,ind3,ll79 */
  2    64 
  2    65      dcl	   1 collection_header    aligned based (collection_header_ptr),
  2    66 	     2 version	      char (8),
  2    67 	     2 flags	      unaligned,
  2    68 	       3 fixed_size_elements
  2    69 			      bit (1),
  2    70 	       3 thread_elements  bit (1),
  2    71 	       3 thread_control_intervals
  2    72 			      bit (1),
  2    73 	       3 must_be_zero1    bit (15),
  2    74 	     2 control_interval_storage_method
  2    75 			      fixed bin (17) unal,
  2    76 	     2 element_storage_method
  2    77 			      fixed bin (17),
  2    78 	     2 maximum_element_size
  2    79 			      fixed bin (35),
  2    80 	     2 header_record_element_id
  2    81 			      bit (36) aligned,
  2    82 	     2 storage_record_element_id
  2    83 			      bit (36) aligned;
  2    84 
  2    85      dcl	   collection_header_ptr  ptr;
  2    86      dcl	   COLLECTION_HEADER_VERSION_2
  2    87 			      init ("col_hdr2") char (8) aligned
  2    88 			      int static options (constant);
  2    89 
  2    90 /* END INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
      142 
      143 
  3     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*        Contains the declaration of an element identifier.  Element
  3     6*   identifiers consist of two parts, the id (number) of the control interval
  3     7*   in which the element resides, and the index into the slot table of
  3     8*   the element in the control interval.  The declaration of the element_id 
  3     9*   structure reflects this division of the element identifier.  The structure 
  3    10*   is based on the automatic bit string element_id_string because programs
  3    11*   generally pass bit strings (element_id_string) to each other, then 
  3    12*   interpret the bit string by overlaying the element_id structure ony if
  3    13*   it is necessary to access the parts of the id.  Basing element_id on
  3    14*   addr(element_id_string) instead of on a pointer removes the necessity
  3    15*   for always setting that pointer explicitly and guarantees that changes
  3    16*   made to the string or structure do not get inconsistent.
  3    17*
  3    18*   Changes made to element_id must also be made to datum_id, declared in 
  3    19*   dm_cm_datum.incl.pl1.
  3    20**/
  3    21 
  3    22 /* HISTORY:
  3    23*Written by Matthew Pierret, 04/01/82.
  3    24*Modified:
  3    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  3    26**/
  3    27 
  3    28 /* format: style2,ind3,ll79 */
  3    29 
  3    30      dcl	   element_id_string      bit (36) aligned;
  3    31 
  3    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  3    33 	     2 control_interval_id
  3    34 			      fixed bin (24) unal unsigned,
  3    35 	     2 index	      fixed bin (12) unal unsigned;
  3    36 
  3    37 
  3    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      144 
      145 
  4     1 /* BEGIN INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        Contains the identifier of the Header Collection for a file
  4     6*   managed by the collection_manager_.  This is used by callers of 
  4     7*   collection_manager who wish to maintain their own file header or who wish
  4     8*   to maintain their own collection header information beyond the caller
  4     9*   collection header provided by colleciton_manager_$(get put)_header.
  4    10**/
  4    11 
  4    12 /* HISTORY:
  4    13*Written by Matthew Pierret, 09/24/84.
  4    14*Modified:
  4    15**/
  4    16 
  4    17 /* format: style2,ind3,ll79 */
  4    18 
  4    19      dcl	   HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36)
  4    20 			      aligned internal static options (constant);
  4    21 
  4    22 /* END INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
      146 
      147 
  5     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*   Contains entry declarations of internally available collection_manager_
  5     6*   entries.  Entries which are only available via the collection_manager_
  5     7*   transfer vector are not included here, but are declared instead in 
  5     8*   dm_collmgr_entry_dcls.incl.pl1.
  5     9**/
  5    10 
  5    11 /* HISTORY:
  5    12*Written by Mathew Pierret, 04/01/82.
  5    13*Modified:
  5    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
  5    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
  5    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
  5    17*            Added cm_get_element$info*, $header*.  The former is used when
  5    18*            the caller has a cm_info structure already; the latter is used to
  5    19*            get collection headers.
  5    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
  5    21*            Added cm_allocate_element$info.
  5    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
  5    23*            calling sequence for returning free space.
  5    24*            Added cm_free_cn_datum("" $header).
  5    25*01/07/83 by Matthew Pierret:  Added:
  5    26*            cm_allocate_element$buffered("" _info);
  5    27*            cm_put_element$buffered("" _info);
  5    28*            cm_put_datum_in_place$buffered("" _continued);
  5    29*            cm_put_datum_in_pool$buffered("" _continued);
  5    30*            cm_compact$buffered.
  5    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
  5    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
  5    33*            Added cm_opening_info$get_storage_record.
  5    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
  5    35*            id of the previous datum.
  5    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
  5    37*            which is for the number of slots after allocation.
  5    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
  5    39*            header header_return_slot).
  5    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
  5    41*            Added cm_get_element$bypass_info.
  5    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
  5    43*            cm_free_opening_info.
  5    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
  5    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
  5    46*            $does_replacement_fit to cm_determine_free_space.  These entries
  5    47*            return flags indicating if a datum fits in the ci and the pool.
  5    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
  5    49*            returned the new value of bci_header.free_slot_is_present.
  5    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
  5    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
  5    52*            entries.  Changed cm_get_element_$bypass_info       @                        Å‹‹q€Ó2Æ‡˝∞°        ï  r  <   ∂ ƒ ∂ †      H @                                                                                                   = L          ˇˇˇˇ  Y                                                Å=2“     z  ôˇ    ⁄       &   H   Ç               &  L                          í»    \             ™    ö‡  d z    Ë        –¢  T  &ä        D           .                    Å‹‹q Ë    &Å‹‹zADèŸ    z z ∂ ƒz          r "    dm_system_log.19900826.114257       Å‹‹zAKûc    €	á˜ ƒ              í   Æ “ ∂ ƒz             Å‹‹q     “ Æ     †*@          Å‹‹z       ƒ         SysDaemon                           Å‹‹q ò     ∂ ƒ*@          Å‹‹z             H    Data_Management                     Å‹‹q †       H    Daemon                              Å‹‹q   ò      *@          Å‹‹z            ˛ 5  dm_system_log.19950225.225309       ¢ÕÃ & r  &É] H]      ∂ ƒz          Ë $    dm_system_log.19920730.081721       É] H4Ê@    ¬üzåà              í     ∂ ƒz             Å‹‹q           †*@          É]           ∂ ƒ*@          É]              *@          É]      d Ë  &ë&Hªù¢    . . ∂ ƒz          & ;    dm_system_log.19920831.194436       ë&HºÍí    ¬üzå»              í   T \ ∂ ƒz             Å‹‹q     \ T     †*@          ë&     L     ∂ ƒ*@          ë&       L      *@          ë&     ¢ &  &ëw5
Ij–[    l l ∂ ƒz          d 0    dm_system_log.19921005.114611       ëw5
Iqª    €	Õt              í   í ö ∂ ƒz             Å‹‹q     ö í     †*@          ëw5
     ä     ∂ ƒ*@          ëw5
       ä      *@          ëw5
     ‡ d  &íØ∫‘I#î$    ™ ™ ∂ ƒz          ¢     dm_system_log.19921111.064925       íØ∫‘I+$î    €Ó2Æú              í   – ÿ ∂ ƒz             Å‹‹q     ÿ –     †*@          íØ∫‘     »     ∂ ƒ*@          íØ∫‘       »      *@          íØ∫‘     ¢  &ìFt≥IŸáÊ    Ë Ë ∂ ƒz          ‡ %    dm_system_log.19921217.111511       ìFt≥I€'?    €Ó2Æ—              í   ∂ ƒz             Å‹‹q         †*@          ìFt≥         ∂ ƒ*@          ìFt≥            *@          ìFt≥    \ ‡  &ì´íRJ~©   && ∂ ƒz          /    dm_system_log.19930119.070509       ì´íRJÅ•<    ¬üzå ê              í  LT ∂ ƒz             Å‹‹q    TL     †*@          ì´íR    D     ∂ ƒ*@          ì´íR      D      *@          ì´íR    ö  &îøÖ0JKV   dd ∂ ƒz         \ !    dm_system_log.19930228.235209       îøÖ0JOE    €Ó2Æ
	              í  äí ∂ ƒz             Å‹‹q    íä     †*@          îøÖ0    Ç     ∂ ƒ*@          îøÖ0      Ç      *@          îøÖ0    ÿ\  &ïgO,K)©Y   ¢¢ ∂ ƒz         ö +    dm_system_log.19930414.050735       ïgO,K,r    €Ó2Æ
              í  »– ∂ ƒz             Å‹‹q    –»     †*@          ïgO,    ¿     ∂ ƒ*@          ïgO,      ¿      *@          ïgO,    ö  &ñRKõKL#'   ‡‡ ∂ ƒz         ÿ     dm_system_log.19930611.022611       ñRKõKP»    ‡˝∞Ñ ¨              í   ∂ ƒz             Å‹‹q         †*@          ñRKõ    ˛     ∂ ƒ*@          ñRKõ      ˛      *@          ñRKõ    Tÿ  &ó@ãÎLaú8    ∂ ƒz              dm_system_log.19930805.032010       ó@ãÎLeÈ    €Ó2Æ              í  DL ∂ ƒz             Å‹‹q    LD     †*@          ó@ãÎ    <     ∂ ƒ*@          ó@ãÎ      <      *@          ó@ãÎ    í  &òyiL«◊Ó   \\ ∂ ƒz         T   dm_system_log.19931015.082010       òyiL Ó    €	ÕÒ              í  Çä ∂ ƒz             Å‹‹q    äÇ     †*@          òyi    z     ∂ ƒ*@          òyi      z      *@          òyi    –T  &ô3ÌöM}2   öö ∂ ƒz         í     dm_system_log.19931120.130006       ô3ÌöMâ3µ    €Ó2ÆÚ              í  ¿» ∂ ƒz             Å‹‹q    »¿     †*@          ô3Ìö    ∏     ∂ ƒ*@          ô3Ìö      ∏      *@          ô3Ìö    í  &öŸﬂ<M'§´   ÿÿ ∂ ƒz         – 0 l  dm_system_log.19931224.074109       öŸﬂ<M\t4    €	á˜é              í  ˛ ∂ ƒz             Å‹‹q    ˛     †*@          öŸﬂ<    ˆ     fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
  5   116 			      bit (1) aligned, fixed bin (35));
  5   117 
  5   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
  5   119      dcl	   cm_free_ci$raw_return_prev_next
  5   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
  5   121 			      fixed bin (24) uns, fixed bin (35));
  5   122      dcl	   cm_free_ci$trace_thread_modifications_on
  5   123 			      entry ();
  5   124      dcl	   cm_free_ci$trace_thread_modifications_off
  5   125 			      entry ();
  5   126 
  5   127 
  5   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  5   129 
  5   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  5   131      dcl	   cm_get_bci_header$exclusive
  5   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  5   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  5   134 
  5   135 /**** Not yet used ********************************************************
  5   136*     dcl	   cm_get_bci_header$slot_exclusive
  5   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  5   138*************************************************************************** */
  5   139 
  5   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  5   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  5   142      dcl	   cm_get_element$exclusive
  5   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  5   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  5   145 
  5   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  5   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  5   148 			      fixed bin (35), fixed bin (35));
  5   149 
  5   150 /**** Not yet used ********************************************************
  5   151*     dcl	   cm_get_element_portion$exclusive
  5   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  5   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  5   154*			      fixed bin (35), fixed bin (35));
  5   155*************************************************************************** */
  5   156 
  5   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  5   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  5   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  5   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  5   161 
  5   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   163 			      fixed bin (35), fixed bin (35));
  5   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   165 			      fixed bin (35), fixed bin (35));
  5   166 
  5   167 /******* Not yet used *****************************************************
  5   168*     dcl	   cm_modify$buffered_info
  5   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  5   170*			      fixed bin (35));
  5   171*****************************************************************************/
  5   172 
  5   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  5   174      dcl	   cm_modify$unprotected_info
  5   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  5   176 
  5   177 
  5   178 /******* Not yet used *****************************************************
  5   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
  5   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
  5   181*****************************************************************************/
  5   182 
  5   183 
  5   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  5   185      dcl	   cm_opening_info$get_storage_record
  5   186 			      entry (ptr, fixed bin (35));
  5   187      dcl	   cm_opening_info$full_get
  5   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  5   189      dcl	   cm_opening_info$opening_table_ptr
  5   190 			      entry () returns (ptr);
  5   191 
  5   192      dcl	   cm_postcommit_increment
  5   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  5   194 
  5   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   196 			      fixed bin (35), fixed bin (35));
  5   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   198 			      fixed bin (35), fixed bin (35));
  5   199 
  5   200 /******* Not yet used *****************************************************
  5   201*     dcl	   cm_put$buffered_info
  5   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  5   203*			      fixed bin (35));
  5   204*****************************************************************************/
  5   205 
  5   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  5   207 
  5   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  5   209 			      fixed bin (35));
  5   210 
  5   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
  5   212 
  5   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  5   214 			      fixed bin (35));
  5   215      dcl	   cm_put_datum_in_place$buffered
  5   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  5   217      dcl	   cm_put_datum_in_place$buffered_continued
  5   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  5   219 			      fixed bin (35));
  5   220      dcl	   cm_put_datum_in_place$continued
  5   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  5   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  5   223 
  5   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  5   225 			      fixed bin (35));
  5   226      dcl	   cm_put_datum_in_pool$buffered
  5   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  5   228      dcl	   cm_put_datum_in_pool$buffered_continued
  5   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  5   230 			      fixed bin (35));
  5   231      dcl	   cm_put_datum_in_pool$continued
  5   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  5   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  5   234 
  5   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  5   236 			      fixed bin (35));
  5   237      dcl	   cm_put_ordered_element$buffered
  5   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  5   239 			      fixed bin (35));
  5   240 
  5   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
  5   242 
  5   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
  5   244 			      fixed bin (35));
  5   245 
  5   246 
  5   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
  5   248 			      entry ();
  5   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
  5   250 			      entry ();
  5   251 
  5   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      148 
      149 
  6     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  6     2 /* format: style3 */
  6     3 
  6     4 /* These constants are to be used for the flags argument of sub_err_ */
  6     5 /* They are just "string (condition_info_header.action_flags)" */
  6     6 
  6     7 declare	(
  6     8 	ACTION_CAN_RESTART	init (""b),
  6     9 	ACTION_CANT_RESTART init ("1"b),
  6    10 	ACTION_DEFAULT_RESTART
  6    11 			init ("01"b),
  6    12 	ACTION_QUIET_RESTART
  6    13 			init ("001"b),
  6    14 	ACTION_SUPPORT_SIGNAL
  6    15 			init ("0001"b)
  6    16 	)		bit (36) aligned internal static options (constant);
  6    17 
  6    18 /* End include file */
      150 
      151 
      152    end cm_get_header;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0911.8  cm_get_header.pl1                 >spec>on>7192.pbf-04/04/85>cm_get_header.pl1
140          1    01/07/85  0858.4  dm_cm_info.incl.pl1               >ldd>include>dm_cm_info.incl.pl1
142          2    01/07/85  0858.2  dm_cm_collection_header.incl.pl1  >ldd>include>dm_cm_collection_header.incl.pl1
144          3    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
146          4    01/07/85  0858.8  dm_hdr_collection_id.incl.pl1     >ldd>include>dm_hdr_collection_id.incl.pl1
148          5    04/04/85  0819.0  dm_cm_entry_dcls.incl.pl1         >spec>on>7192.pbf-04/04/85>dm_cm_entry_dcls.incl.pl1
150          6    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000000 constant        bit(36)                  initial dcl 6-7 set ref 112*
CM_INFO_VERSION_2               000004 constant        char(8)                  initial dcl 1-48 set ref 94*
COLLECTION_HEADER_VERSION_2     000002 constant        char(8)                  initial dcl 2-86 set ref 98*
HEADER_COLLECTION_ID            000036 constant        bit(36)                  initial dcl 4-19 set ref 109*
UNINITIALIZED_ELEMENT_ID               constant        bit(36)                  initial dcl 69 ref 101
addr                                                   builtin function         dcl 63 ref 112 112
cm_get_element                  000022 constant        entry                    external dcl 5-140 ref 109
cm_info                                based           structure                level 1 dcl 1-37
cm_info_ptr                     000100 automatic       pointer                  initial dcl 1-47 set ref 90* 94 96 109 1-47*
cm_opening_info$get             000024 constant        entry                    external dcl 5-184 ref 90
collection_header                      based           structure                level 1 dcl 2-65
collection_header_ptr           000102 automatic       pointer                  dcl 2-85 set ref 96* 98 101 108
control_interval_id                    based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 3-32 set ref
                                                                                  112*
dm_error_$ci_not_allocated      000014 external static fixed bin(35,0)          dcl 78 ref 112
dm_error_$ci_not_in_collection  000016 external static fixed bin(35,0)          dcl 78 ref 112
dm_error_$no_element            000020 external static fixed bin(35,0)          dcl 78 ref 112
dm_error_$no_header_record      000012 external static fixed bin(35,0)          dcl 78 ref 104
element_id                             based           structure                level 1 dcl 3-32
element_id_string               000104 automatic       bit(36)                  dcl 3-30 set ref 108* 109* 112 112
error_table_$unimplemented_version
                                000026 external static fixed bin(35,0)          dcl 128 set ref 131*
file_oid                  3            based           bit(36)                  initial level 2 dcl 1-37 set ref 109*
header_ptr                6            based           pointer                  initial level 2 dcl 1-37 ref 96
header_record_element_id
                          5            based           bit(36)                  level 2 dcl 2-65 ref 101 108
index                     0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 3-32 set ref
                                                                                  112*
myname                          000006 constant        varying char(32)         initial dcl 68 set ref 112* 131*
null                                                   builtin function         dcl 63 ref 112 112 1-47 131 131
p_area_ptr                             parameter       pointer                  dcl 52 set ref 40 109*
p_buffer_length                        parameter       fixed bin(17,0)          dcl 51 ref 40 109
p_buffer_ptr                           parameter       pointer                  dcl 50 set ref 40 109*
p_code                                 parameter       fixed bin(35,0)          dcl 57 set ref 40 87* 90* 91 104* 109* 112 112 112
                                                                                  112 112*
p_collection_id                        parameter       bit(36)                  dcl 49 set ref 40 90* 112*
p_correct_version                      parameter       char(8)                  dcl 127 set ref 122 131 131*
p_file_opening_id                      parameter       bit(36)                  dcl 48 set ref 40 90*
p_given_version                        parameter       char(8)                  dcl 126 set ref 122 131 131*
p_header_length                        parameter       fixed bin(35,0)          dcl 56 set ref 40 109*
p_header_ptr                           parameter       pointer                  dcl 55 set ref 40 109*
p_new_buffer_was_allocated             parameter       bit(1)                   dcl 53 set ref 40 88* 109*
p_structure_name                       parameter       char                     unaligned dcl 125 set ref 122 131*
sub_err_                        000010 constant        entry                    external dcl 74 ref 112 131
version                                based           char(8)                  level 2 in structure "collection_header" dcl 2-65
                                                                                  in procedure "cm_get_header" set ref 98*
version                                based           char(8)                  level 2 in structure "cm_info" dcl 1-37 in procedure
                                                                                  "cm_get_header" set ref 94*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 6-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 6-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 6-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 6-7
cm_allocate_ci                  000000 constant        entry                    external dcl 5-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 5-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 5-77
cm_compact                      000000 constant        entry                    external dcl 5-81
cm_compact$buffered             000000 constant        entry                    external dcl 5-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 5-84
cm_compact$replacement          000000 constant        entry                    external dcl 5-83
cm_delete                       000000 constant        entry                    external dcl 5-92
cm_delete$info                  000000 constant        entry                    external dcl 5-94
cm_delete_cn_datum              000000 constant        entry                    external dcl 5-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 5-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 5-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 5-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 5-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 5-111
cm_find_free_slot               000000 constant        entry                    external dcl 5-115
cm_free_ci$info                 000000 constant        entry                    external dcl 5-118
cm_free_ci$raw_return_prev_next 000000 constant        entry                    external dcl 5-119
cm_free_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 5-124
cm_free_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 5-122
cm_free_opening_info            000000 constant        entry                    external dcl 5-128
cm_get_bci_header               000000 constant        entry                    external dcl 5-130
cm_get_bci_header$exclusive     000000 constant        entry                    external dcl 5-131
cm_get_bci_header$slot          000000 constant        entry                    external dcl 5-133
cm_get_element$exclusive        000000 constant        entry                    external dcl 5-142
cm_get_element_portion          000000 constant        entry                    external dcl 5-146
cm_get_id$id                    000000 constant        entry                    external dcl 5-157
cm_get_id$ptr                   000000 constant        entry                    external dcl 5-159
cm_modify                       000000 constant        entry                    external dcl 5-162
cm_modify$buffered              000000 constant        entry                    external dcl 5-164
cm_modify$info                  000000 constant        entry                    external dcl 5-173
cm_modify$unprotected_info      000000 constant        entry                    external dcl 5-174
cm_opening_info$full_get        000000 constant        entry                    external dcl 5-187
cm_opening_info$get_storage_record
                                000000 constant        entry                    external dcl 5-185
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 5-189
cm_postcommit_increment         000000 constant        entry                    external dcl 5-192
cm_put                          000000 constant        entry                    external dcl 5-195
cm_put$buffered                 000000 constant        entry                    external dcl 5-197
cm_put$info                     000000 constant        entry                    external dcl 5-206
cm_put_basic_element            000000 constant        entry                    external dcl 5-208
cm_put_cn_datum                 000000 constant        entry                    external dcl 5-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 5-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 5-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 5-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 5-220
cm_put_datum_in_pool            000000 constant        entry                    external dcl 5-224
cm_put_datum_in_pool$buffered   000000 constant        entry                    external dcl 5-226
cm_put_datum_in_pool$buffered_continued
                                000000 constant        entry                    external dcl 5-228
cm_put_datum_in_pool$continued  000000 constant        entry                    external dcl 5-231
cm_put_ordered_element          000000 constant        entry                    external dcl 5-235
cm_put_ordered_element$buffered 000000 constant        entry                    external dcl 5-237
cm_put_overlength_tail          000000 constant        entry                    external dcl 5-241
cm_recursive_modify             000000 constant        entry                    external dcl 5-243
cm_replace_buffered_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 5-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 5-247

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000405 constant        entry                    internal dcl 122 ref 94 98
cm_get_header                   000140 constant        entry                    external dcl 40

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       642         672     511         652
Length      1202     511        30         273     131           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_get_header                       262 external procedure  is an external procedure.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure cm_get_header.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_get_header            000100 cm_info_ptr                 cm_get_header
                         000102 collection_header_ptr       cm_get_header
                         000104 element_id_string           cm_get_header

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_get_element                cm_opening_info$get           sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$ci_not_allocated    dm_error_$ci_not_in_collection                              dm_error_$no_element
dm_error_$no_header_record    error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     40 000131    1   47 000145        87 000147        88 000151        90 000152        91 000166        94 000171
     96 000212        98 000215       101 000242       104 000245       105 000251       108 000252       109 000253
    112 000313       119 000404       122 000405       131 000416       136 000510


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
