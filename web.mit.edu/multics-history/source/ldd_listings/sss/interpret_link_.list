	COMPILATION LISTING OF SEGMENT interpret_link_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/20/86  1200.4 mst Thu
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396), audit(86-11-12,Zwick),
       15*     install(86-11-20,MR12.0-1222):
       16*     add an understanding of heap links
       17*                                                   END HISTORY COMMENTS */
       18 
       19 
       20 /* Procedure to decode a given link and return to the caller a symbolic and
       21*   directly printable interpretation of it.
       22*
       23*   Initially designed and coded by Michael J. Spier, March 2, 1971
       24*   Modified by Richard A. Barnes, October 14, 1974 for interpret_link_$tptr	*/
       25 /* Modified 5/26/75 by M. Weaver  to add *static segref code */
       26 /* modified 9/19/75 by M. Weaver to use standard include files */
       27 /* modified 1/30/76 by S. Webber to handle *system links */
       28 /* modified 12/76 by M. Weaver to  be compatible with new stack_header include file */
       29 /* modified 10/77 by R. Barnes to print out more link info */
       30 /* modified 8/82 BIM for better include files, entrypoint for checker */
       31 /* Changed to use interpret_link_info.incl.pl1 05/12/83 S. Herbst */
       32 
       33 interpret_link_: procedure (A_structure_ptr, A_link_ptr, A_code);
       34 
       35 /* PARAMETERS */
       36 
       37 declare (A_structure_ptr, A_link_ptr, text_ptr) pointer, A_code fixed bin (35);
       38 
       39 
       40 /* DECLARATION OF EXTERNAL SYMBOLS */
       41 
       42 declare  error_table_$no_defs fixed bin (35) external;
       43 declare  error_table_$bad_link_type fixed bin (35) external;
       44 declare  error_table_$no_linkage fixed bin (35) external;
       45 
       46 /* ENTRIES */
       47 
       48 declare  ioa_$rsnnl external entry options (variable);
       49 
       50 /* DECLARATION OF INTERNAL STATIC VARIABLES */
       51 
       52 
       53 declare  symbolic_modifier (0:63) char (4) aligned internal static
       54          initial ("    ", ",au ", ",qu ", ",du ", ",ic ", ",al ", ",ql ", ",dl ",
       55          ",x0 ", ",x1 ", ",x2 ", ",x3 ", ",x4 ", ",x5 ", ",x6 ", ",x7 ",
       56          ",*  ", ",au*", ",qu*", ",du*", ",ic*", ",al*", ",ql*", ",dl*",
       57          ",x0*", ",x1*", ",x2*", ",x3*", ",x4*", ",x5*", ",x6*", ",x7*",
       58          ",f1 ", ",itp", ",???", ",its", ",sd ", ",scr", ",f2 ", ",f3 ",
       59          ",ci ", ",*  ", ",sc ", ",ad ", ",di ", ",dic", ",id ", ",idc",
       60          ",*  ", ",*au", ",*qu", ",*du", ",*ic", ",*al", ",*ql", ",*dl",
       61          ",*x0", ",*x1", ",*x2", ",*x3", ",*x4", ",*x5", ",*x6", ",*x7");
       62 
       63 /* DECLARATION OF AUTOMATIC STORAGE VARIABLES */
       64 
       65 declare 1 auto_interpret_link_info aligned like interpret_link_info;
       66 
       67 declare 1 old_interpret_link_info aligned based,
       68 	2 segment_name char (32) aligned,
       69 	2 entry_point_name char (33) aligned,
       70 	2 expression char (8) aligned,
       71 	2 modifier char (4) aligned,
       72 	2 trap char (32) aligned;
       73 
       74 declare (defbase, ili_ptr, lhp, linkp, original_lp, p, tpp, xp) pointer;
       75 declare (have_textp, old_version_sw) bit (1) aligned;
       76 declare (i, j, lng, type, offset, class) fixed bin;
       77 declare  link_segment_no bit (18) aligned;
       78 declare  modx fixed bin;
       79 declare  segno fixed bin (18);
       80 declare  searching bit (1) aligned;
       81 declare  reloffset fixed bin (18);
       82 declare  sign char (1) aligned;
       83 
       84 /* DECLARATION OF BUILTIN FUNCTIONS */
       85 
       86 declare (addr, addrel, baseno, bin, ptr, rel, substr) builtin;
       87 
       88 /* DECLARATION OF BASED STRUCTURES */
       89 
       90 declare 1 b1 aligned based (p),
       91         2 lhe18 fixed bin (18) unsigned unaligned,
       92         2 rhe18 fixed bin (18) unsigned unaligned;
       93 
       94 declare 1 b7 aligned based (p),
       95         2 nwords fixed bin,
       96         2 dA_code fixed bin;
       97 
       98 declare  based_ptr pointer based (lhp);
       99 
      100 /*  */
      101 
      102 	have_textp = "0"b;
      103 	go to join;
      104 
      105 interpret_link_$tptr: entry (A_structure_ptr, A_link_ptr, text_ptr, A_code);
      106 
      107 	have_textp = "1"b;
      108 
      109 join:
      110 	A_code = 0;
      111 	if A_structure_ptr -> interpret_link_info.version = INTERPRET_LINK_INFO_VERSION_1 then do;
      112 	     old_version_sw = "0"b;
      113 	     ili_ptr = A_structure_ptr;		/* can put it right into caller's structure */
      114 	end;
      115 	else do;
      116 	     old_version_sw = "1"b;
      117 	     ili_ptr = addr (auto_interpret_link_info);
      118 	end;
      119 
      120 	ili_ptr -> interpret_link_info.segment_name,
      121 	     ili_ptr -> interpret_link_info.entry_point_name,
      122 	     ili_ptr -> interpret_link_info.expression,
      123 	     ili_ptr -> interpret_link_info.modifier,
      124 	     ili_ptr -> interpret_link_info.trap = "";
      125 
      126 	linkp = A_link_ptr;				/* copy argument for efficiency */
      127 
      128 	if linkp -> object_link.tag = ITS_MODIFIER then do;
      129 						/* we have a snapped link, we must find unsnapped version */
      130 	     sb = ptr (addr (p), 0);			/* get ptr to stack header */
      131 	     lotp = sb -> stack_header.lot_ptr;		/* get ptr to lot from stack header */
      132 	     offset = bin (rel (linkp), 18);		/* get offset of snapped link in linkage segment */
      133 	     link_segment_no = baseno (linkp);		/* get segment number of linkage segment */
      134 	     searching = "1"b;
      135 	     do segno = 80 to sb -> stack_header.cur_lot_size while (searching); /* scan the lot */
      136 		lhp = lot (segno).lp;
      137 		if baseno (lhp) = link_segment_no then do;
      138 		     reloffset = offset - bin (rel (lhp), 18);
      139 						/* get offset into linkage section */
      140 		     if reloffset >= lhp -> linkage_header.begin_links then
      141 						/* might be in this section */
      142 			if reloffset < lhp -> linkage_header.block_length then do;
      143 						/* we found the right linkage section */
      144 			     if lhp -> linkage_header.unused then original_lp = addr (lhp -> linkage_header.unused) -> based_ptr;
      145 			     else original_lp = lhp -> linkage_header.original_linkage_ptr;
      146 						/* get pointer to virgin section */
      147 			     linkp = addrel (original_lp, reloffset); /* get pointer to unsnapped link */
      148 			     if linkp -> object_link.tag = FAULT_TAG_2 then
      149 				goto start;
      150 			     searching = "0"b;	/* stop the search */
      151 			end;
      152 		end;
      153 	     end;
      154 
      155 	     A_code = error_table_$no_linkage;
      156 	     return;
      157 	end;
      158 
      159 	else if linkp -> object_link.tag = FAULT_TAG_2 then
      160 						/* its unsnapped, no problem */
      161 	     lhp = addrel (linkp, linkp -> object_link.header_relp);
      162 						/* pointer to linkage block header */
      163 
      164 	else do;
      165 	     A_code = error_table_$bad_link_type;
      166 	     return;
      167 	end;
      168 
      169 start:
      170 
      171 	if lhp -> its.its_mod = ITS_MODIFIER		/* linkage header begins with pointer */
      172 	then defbase = lhp -> linkage_header.def_ptr;	/* we have pointer to definition section */
      173 	else do;					/* virgin linkage section, locate defs */
      174 	     if lhp -> virgin_linkage_header.defs_in_link = "0"b
      175 						/* defs in text */
      176 	     then if have_textp
      177 		then defbase = addrel (text_ptr, lhp -> virgin_linkage_header.def_offset);
      178 		else defbase = ptr (lhp, lhp -> virgin_linkage_header.def_offset);
      179 	     else if lhp -> virgin_linkage_header.defs_in_link = "010000"b
      180 						/* defs in linkage */
      181 	     then defbase = addrel (lhp, lhp -> virgin_linkage_header.def_offset);
      182 	     else do;
      183 		A_code = error_table_$no_defs;	/* cannot locate defs */
      184 		return;
      185 	     end;
      186 	end;
      187 
      188 	xp = addrel (defbase, linkp -> object_link.expression_relp);	/* pointer to link's expression word */
      189 
      190 	modx = bin (linkp -> object_link.modifier, 6);	/* get the modifier */
      191 	go to EXPRESSION_JOIN;
      192 
      193 given_exp: entry (A_structure_ptr, Exp_relp, Modifier, Def_section_ptr, A_code);
      194 
      195 declare Exp_relp fixed bin (18);
      196 declare Def_section_ptr pointer;
      197 declare Modifier bit (6) unaligned;
      198 
      199 	A_code = 0;
      200 	if A_structure_ptr -> interpret_link_info.version = INTERPRET_LINK_INFO_VERSION_1 then do;
      201 	     old_version_sw = "0"b;
      202 	     ili_ptr = A_structure_ptr;		/* can put it directly into caller's structure */
      203 	end;
      204 	else do;
      205 	     old_version_sw = "1"b;
      206 	     ili_ptr = addr (auto_interpret_link_info);
      207 	end;
      208 
      209 	xp = addrel (Def_section_ptr, Exp_relp);
      210 	modx = bin (Modifier, 6);
      211 	defbase = Def_section_ptr;
      212 	ili_ptr -> interpret_link_info.segment_name,
      213 	     ili_ptr -> interpret_link_info.entry_point_name,
      214 	     ili_ptr -> interpret_link_info.expression,
      215 	     ili_ptr -> interpret_link_info.modifier,
      216 	     ili_ptr -> interpret_link_info.trap = "";
      217 
      218 EXPRESSION_JOIN:
      219 
      220 	if xp -> exp_word.expression ^= 0 then do;	/* there is an xp -> exp_word.expression */
      221 	     sign = "+";				/* assume its positive */
      222 	     i = xp -> exp_word.expression;		/* convert value to fixed bin */
      223 	     if i < 0 then do;			/* display negative value as minus sign	& 	*/
      224 	          i = -i;				/*   positive octal value.			*/
      225 		sign = "-";
      226 	     end;
      227 	     call ioa_$rsnnl ("^a^o", ili_ptr -> interpret_link_info.expression, lng, sign, i);
      228 	end;
      229 	tpp = addrel (defbase, xp -> exp_word.type_relp);	/* pointer to type-pair  */
      230 
      231 	type = tpp -> type_pair.type;			/* get type of link */
      232 	if (type = LINK_SELF_BASE) |
      233 	   (type = LINK_SELF_OFFSETNAME) then do;	/* self relative links */
      234 	     class = tpp -> type_pair.segname_relp;	/* get segref A_code */
      235 	     if (class >= CLASS_TEXT) &
      236 	        (class <= CLASS_HEAP) then
      237 		ili_ptr -> interpret_link_info.segment_name = 
      238 			 SYMBOLIC_SECTION_NAMES (class);
      239 	     else do;
      240 		A_code = error_table_$bad_link_type;
      241 		return;
      242 	     end;
      243 	end;
      244 	else do;					/* links with symbolic segname */
      245 	     p = addrel (defbase, tpp -> type_pair.segname_relp);
      246 						/* pointer to segname ACC string */
      247 	     ili_ptr -> interpret_link_info.segment_name =
      248 	          p -> acc_string.string;
      249 	end;
      250 
      251 	if (type = LINK_SELF_BASE) |
      252 	   (type = LINK_REFNAME_BASE) then
      253 	     substr (ili_ptr -> interpret_link_info.entry_point_name, 1, 2) = "|0";
      254 	else do;
      255 	     p = addrel (defbase, tpp -> type_pair.offsetname_relp);
      256 						/* pointer to entryname ACC string */
      257 	     substr (ili_ptr -> interpret_link_info.entry_point_name, 1, 1) = "$";
      258 	     substr (ili_ptr -> interpret_link_info.entry_point_name, 2) = 
      259 		p -> acc_string.string;
      260 	end;
      261 
      262 	ili_ptr -> interpret_link_info.modifier = symbolic_modifier (modx);
      263 						/* and convert to symbolic */
      264 
      265 	if tpp -> type_pair.trap_relp ^= 0 then		/* there is a trap before link */
      266 	     do;
      267 	     p = addrel (defbase, tpp -> type_pair.trap_relp);
      268 						/* pointer to trap-pair */
      269 	     if (type = LINK_CREATE_IF_NOT_FOUND) | 
      270 	        (type = LINK_SELF_OFFSETNAME & class = CLASS_SYSTEM) |
      271 	        (type = LINK_SELF_OFFSETNAME & class = CLASS_HEAP) then do; /* create if not found, or *system or *heap */
      272 		     call ioa_$rsnnl ("	Init -> def|^o, length = ^d", ili_ptr -> interpret_link_info.trap,
      273 		     lng, tpp -> type_pair.trap_relp, p -> nwords);
      274 	     end;
      275 	     else do;				/* have real trap before link */
      276 		i = p -> lhe18;			/* offset of call link */
      277 		j = p -> rhe18;			/* offset of arg link */
      278 		call ioa_$rsnnl ("	Trap: call ^o, arg ^o", ili_ptr -> interpret_link_info.trap, lng, i, j);
      279 	     end;
      280 	end;
      281 
      282 	if old_version_sw then do;
      283 	     A_structure_ptr -> old_interpret_link_info.segment_name = ili_ptr -> interpret_link_info.segment_name;
      284 	     A_structure_ptr -> old_interpret_link_info.entry_point_name =
      285 		substr(ili_ptr -> interpret_link_info.entry_point_name,1,33);
      286 	     A_structure_ptr -> old_interpret_link_info.expression = ili_ptr -> interpret_link_info.expression;
      287 	     A_structure_ptr -> old_interpret_link_info.modifier = ili_ptr -> interpret_link_info.modifier;
      288 	     A_structure_ptr -> old_interpret_link_info.trap = 
      289 		substr(ili_ptr -> interpret_link_info.trap,1,32);
      290 	end;
      291 
      292 	return;
      293 
      294 
      295 /* Include Files */
  1     1 /*  BEGIN INCLUDE FILE interpret_link_info.incl.pl1  */
  1     2 
  1     3 /* Written 05/12/83 by S. Herbst */
  1     4 
  1     5 dcl 1 interpret_link_info aligned based (interpret_link_info_ptr),
  1     6    2 version char (8),
  1     7    2 segment_name char (32) aligned,
  1     8    2 entry_point_name char (260) aligned,
  1     9    2 expression char (8) aligned,
  1    10    2 modifier char (4) aligned,
  1    11    2 trap char (48) aligned;
  1    12 
  1    13 dcl INTERPRET_LINK_INFO_VERSION_1 char (8) int static options (constant) init ("ILI 1.0");
  1    14 
  1    15 dcl interpret_link_info_ptr ptr;
  1    16 
  1    17 /* END INCLUDE FILE interpret_link_info.incl.pl1  */
      296 
      297 
  2     1 /* BEGIN INCLUDE FILE --  lot.incl.pl1   S.Webber 9/74, Modified by R. Bratt 04/76, modified by M. Weaver 7/76 */
  2     2 /* modified by M. Weaver 3/77 */
  2     3 
  2     4 dcl  lotp ptr;
  2     5 
  2     6 dcl 1 lot based (lotp) aligned,
  2     7     2 lp (0:9999) ptr unaligned;			/* array of packed pointers to linkage sections */
  2     8 
  2     9 dcl lot_fault bit (36) aligned static options (constant) init ("111000000000000000000000000000000000"b);
  2    10 						/* lot fault has fault code = 0 and offset = 0 */
  2    11 
  2    12 dcl  isotp ptr;
  2    13 dcl 1 isot based (isotp) aligned,
  2    14     2 isp (0:9999) ptr unaligned;
  2    15 
  2    16 dcl 1 isot1 (0 :9999) aligned based,
  2    17     2 flags unaligned,
  2    18       3 fault bit (2) unaligned,
  2    19       3 system bit (1) unaligned,
  2    20       3 mbz bit (6) unaligned,
  2    21     2 fault_code fixed bin (8) unaligned,
  2    22     2 static_offset bit (18) unaligned;
  2    23 
  2    24 
  2    25 /* END INCLUDE FILE  lot.incl.pl1 */
      298 
      299 
  3     1 /* Begin include file definition_dcls.incl.pl1 BIM 1981 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  3     6*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  3     7*     Modified to add indirect bit to definition flags, add msf_map_relp to the
  3     8*     definition header, declare the msf_map, and add structures and constants
  3     9*     for deferred initialization.
  3    10*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420),
  3    11*     audit(86-08-05,Schroth), install(86-11-20,MR12.0-1222):
  3    12*     added the structures for pointer initialization. pointer_init_template.
  3    13*     changed list_template_entry
  3    14*                                                   END HISTORY COMMENTS */
  3    15 
  3    16 
  3    17 /* Modified:  */
  3    18 /*   13 Dec 1982 by Lee A. Newcomb to put definition_header.hash_table_relp */
  3    19 /*	after unused half-word instead of before it. */
  3    20 /*   1 March 1983 by M. Weaver to add list template init type */
  3    21 
  3    22 /* format: style3,idind25 */
  3    23 /* everything for the definition section */
  3    24 
  3    25 declare	(
  3    26 	CLASS_TEXT	     init (0),		/* text section definition */
  3    27 	CLASS_LINKAGE	     init (1),		/* linkage section definition */
  3    28 	CLASS_SYMBOL	     init (2),		/* symbol section definition */
  3    29 	CLASS_SEGNAME	     init (3),		/* segment name definition */
  3    30 	CLASS_STATIC	     init (4),		/* static section definition */
  3    31 	CLASS_SYSTEM	     init (5),		/* valid only in self links, not def class */
  3    32 	CLASS_HEAP	     init (6)		/* valid only in self links, not def class */
  3    33 	)		     fixed bin (3) unsigned internal static options (constant);
  3    34 
  3    35 declare	CLASS_NAMES	     (0:6) character (12) internal static options (constant)
  3    36 			     init ("text", "linkage", "symbol", "segname", "static", "system", "heap");
  3    37 
  3    38 declare	SYMBOLIC_SECTION_NAMES   (0:6) character (8)
  3    39 			     init ("*text", "*link", "*symbol", *, "*static", "*system", "*heap") internal static
  3    40 			     options (constant);
  3    41 
  3    42 declare	1 definition_flags	     unaligned based,
  3    43 	  2 new		     bit (1),		/* should be "1"b */
  3    44 	  2 ignore	     bit (1),		/* cannot snap link to this */
  3    45 	  2 entry		     bit (1),		/* can tra here */
  3    46 	  2 retain	     bit (1),		/* binder respects this */
  3    47 	  2 argcount	     bit (1),		/* OBSOLETE */
  3    48 	  2 descriptors	     bit (1),		/* OBSOLETE */
  3    49 	  2 indirect	     bit (1),		/* target is a pointer to actual target */
  3    50 	  2 unused	     bit (8);		/* Must be zero */
  3    51 
  3    52 
  3    53 
  3    54 
  3    55 /* Header of the definition section */
  3    56 
  3    57 declare	def_header_ptr	     pointer;
  3    58 declare	1 definition_header	     aligned based (def_header_ptr),
  3    59 	  2 def_list_relp	     fixed bin (18) unsigned unaligned,
  3    60 						/* first definition, reloc def18 */
  3    61 	  2 msf_map_relp	     fixed bin (18) unsigned unaligned,
  3    62 						/* msf_map if any, or 0 if none.  reloc def18 unless none */
  3    63 	  2 hash_table_relp	     fixed bin (18) unsigned unaligned,
  3    64 						/* def hash table, if any, or 0 if none. reloc def18 unless none */
  3    65 	  2 flags		     unaligned like definition_flags;
  3    66 						/* both new and ignore must be "1"b here */
  3    67 
  3    68 /* A non class=3 definition. See segname_definition below for class=3 */
  3    69 
  3    70 
  3    71 declare	def_ptr		     pointer;
  3    72 declare	1 definition	     aligned based (def_ptr),
  3    73 	  2 forward_relp	     unal fixed bin (18) unsigned,
  3    74 						/* offset of next def */
  3    75 	  2 backward_relp	     unal fixed bin (18) unsigned,
  3    76 						/* offset of previous def */
  3    77 	  2 thing_relp	     unal fixed bin (18) unsigned,
  3    78 						/* offset in section specified by class of thing this defines */
  3    79 	  2 flags		     unaligned like definition_flags,
  3    80 	  2 class		     unal fixed bin (3) unsigned,
  3    81 						/* Type of definition */
  3    82 	  2 name_relp	     unal fixed bin (18) unsigned,
  3    83 						/* offset of ACC for symbol */
  3    84 	  2 segname_relp	     unal fixed bin (18) unsigned;
  3    85 						/* offset of segname def to which this belongs */
  3    86 
  3    87 /* Class=3, segname definition */
  3    88 
  3    89 declare	segname_ptr	     pointer;
  3    90 declare	1 segname_definition     aligned based (segname_ptr),
  3    91 	  2 forward_relp	     unal fixed bin (18) unsigned,
  3    92 						/* offset of next def */
  3    93 	  2 backward_relp	     unal fixed bin (18) unsigned,
  3    94 						/* offset of previous def */
  3    95 	  2 next_segname_relp    unal fixed bin (18) unsigned,
  3    96 						/* offset of next segname def */
  3    97 	  2 flags		     unaligned like definition_flags,
  3    98 	  2 class		     unal fixed bin (3) unsigned,
  3    99 						/* 3 for segname */
  3   100 	  2 name_relp	     unal fixed bin (18) unsigned,
  3   101 						/* offset of ACC for symbol */
  3   102 	  2 first_relp	     unal fixed bin (18) unsigned;
  3   103 						/* see following : */
  3   104 
  3   105 /* Definition blocks are chained off of segname definitions.
  3   106*   segname_definition.first_relp is one of three things:
  3   107*    (1) the def section offset of the first ordinary (class^=3) definition
  3   108*      belonging to this segname block. In the case where there are more than
  3   109*      one segname's on a block, all their first_relp will point
  3   110*      to the same place.
  3   111*
  3   112*    (2) if there are no ordinary definitions associated with this segname,
  3   113*      then it is the def section offset of the next segname. 
  3   114*
  3   115*    (3) if there are no ordinary definitions in the block, and it
  3   116*      is the last block, then it points to a word containing 0.
  3   117*
  3   118* Thus the end of a list of synonym segnames can be detected by forward_relp
  3   119*   pointing to a class=3 definition whose first_relp is not the same as
  3   120*   the current definitions first_relp.
  3   121**/
  3   122 
  3   123 /* All the definitions are linked through the forward and
  3   124*   backward thread variables. The end of the chain can is indicated
  3   125*   by forward pointing to a zero word. */
  3   126 
  3   127 
  3   128 declare	exp_ptr		     pointer;
  3   129 declare	1 exp_word	     based (exp_ptr) aligned, /* expression word in link definition */
  3   130 	  2 type_relp	     fixed bin (18) unsigned unal,
  3   131 						/* pointer (rel to defs) of type pair structure */
  3   132 	  2 expression	     fixed bin (17) unal;	/* constant expression to be added in when snapping link */
  3   133 
  3   134 declare	(
  3   135 	LINK_SELF_BASE	     init (1),		/* *section|0+expression,modifier */
  3   136 						/* which section determined by segname_relp */
  3   137 	LINK_OBSOLETE_2	     init (2),		/* not used */
  3   138 	LINK_REFNAME_BASE	     init (3),		/* refname|0+expression,modifier */
  3   139 	LINK_REFNAME_OFFSETNAME  init (4),		/* refname|offsetname+expression,modifier */
  3   140 	LINK_SELF_OFFSETNAME     init (5),		/* *section|offsetname+expression,modifier */
  3   141 	LINK_CREATE_IF_NOT_FOUND init (6),		/* OBSOLETE: like LINK_REFNAME_OFFSETNAME except that it will create instead of taking linkage_error */
  3   142 	SECTION_TEXT	     init (0),		/* *text */
  3   143 	SECTION_LINK	     init (1),		/* *link */
  3   144 	SECTION_SYMBOL	     init (2),		/* *symbol */
  3   145 	SECTION_UNUSED	     init (3),		/* reserved */
  3   146 	SECTION_STATIC	     init (4),		/* *static */
  3   147 	SECTION_SYSTEM	     init (5),		/* *system */
  3   148 	SECTION_HEAP	     init (6)		/* *heap */
  3   149 	)		     fixed bin (18) unsigned unaligned internal static options (constant);
  3   150 
  3   151 /* use CLASS_NAMES for section names */
  3   152 
  3   153 declare	LINK_TYPE_NAMES	     (1:6)
  3   154 			     init ("absolute in section", "unused", "absolute off of refname",
  3   155 			     "symbolic off of refname", "symbolic in section", "symbolic off of refname; create")
  3   156 			     character (32) varying internal static options (constant);
  3   157 
  3   158 
  3   159 declare	type_ptr		     pointer;
  3   160 declare	1 type_pair	     based (type_ptr) aligned,/* type pair in link definition */
  3   161 	  2 type		     fixed bin (18) unsigned unal,
  3   162 						/* see above */
  3   163 	  2 trap_relp	     fixed bin (18) unsigned unal,
  3   164 						/* pointer (rel to defs) to the trap word */
  3   165 						/* unless LINK_SELF_OFFSETNAME off of *system or create link */
  3   166 	  2 segname_relp	     fixed bin (18) unsigned unal,
  3   167 						/* pointer (rel to defs) to ACC reference name for segment referenced, 
  3   168* /*or section code for SELF links */
  3   169 	  2 offsetname_relp	     fixed bin (18) unsigned unal;
  3   170 						/* for OFFSETNAME links, ACC string of name of location. */
  3   171 						/* for others, must be ZERO */
  3   172 
  3   173 
  3   174 /* Link Trap Pair */
  3   175 
  3   176 declare	link_trap_ptr	     pointer;
  3   177 declare	1 link_trap_pair	     aligned based (link_trap_ptr),
  3   178 	  2 call_relp	     fixed bin (18) unsigned unaligned,
  3   179 						/* LINK18, link to thing to call */
  3   180 	  2 info_relp	     fixed bin (18) unsigned unaligned;
  3   181 						/* LINK18, link to argument list */
  3   182 
  3   183 
  3   184 /* initialization info for *system or *heap link */
  3   185 
  3   186 
  3   187 /* NOTE --------------------------------------------------
  3   188*   the following structures defining initialization information are also
  3   189*   defined in fortran_storage.incl.pl1  system_link_init_info.incl.pl1
  3   190*   and should be kept equivalent
  3   191*   -------------------------------------------------------
  3   192**/
  3   193 
  3   194 declare	(
  3   195 	INIT_NO_INIT	     init (0),
  3   196 	INIT_COPY_INFO	     init (3),
  3   197 	INIT_DEFINE_AREA	     init (4),
  3   198 	INIT_LIST_TEMPLATE	     init (5),
  3   199 	INIT_DEFERRED	     init (6)
  3   200 	)		     fixed bin internal static options (constant);
  3   201 
  3   202 /* for type = 0 or 4 */
  3   203 
  3   204 declare	link_init_ptr	     pointer;
  3   205 declare	1 link_init	     aligned based (link_init_ptr),
  3   206 	  2 n_words	     fixed bin (35),	/* number to invent */
  3   207 	  2 type		     fixed bin;		/* see types above */
  3   208 
  3   209 /* for type=3, there is data to copy */
  3   210 
  3   211 declare	1 link_init_copy_info    aligned based (link_init_ptr),
  3   212 	  2 header	     aligned like link_init,
  3   213 	  2 initial_data	     (link_init_n_words refer (link_init_copy_info.header.n_words)) bit (36) aligned;
  3   214 
  3   215 declare	link_init_n_words	     fixed bin;
  3   216 
  3   217 /* for type = 5, there is a list template to copy */
  3   218 
  3   219 declare	1 link_init_list_template
  3   220 			     aligned based (link_init_ptr),
  3   221 	  2 header	     aligned like link_init,
  3   222 	  2 pad		     bit (18) unaligned,
  3   223 	  2 n_words_in_list	     fixed bin (18) unsigned unaligned,
  3   224 	  2 template	     (link_init_n_words_in_list refer (link_init_list_template.n_words_in_list));
  3   225 
  3   226 declare	link_init_n_words_in_list
  3   227 			     fixed bin;
  3   228 
  3   229 /* A list template consists of a series of entries with the following
  3   230*   description, concatenated together.  n_bits and datum are bit items,
  3   231*   to permit a wide range of inputs.
  3   232*
  3   233*   1.  A 'repeat' of '0' signifies skipping of 'n_bits' bits.
  3   234*   2.  A 'n_bits' of '0' signifies the last item of the list.
  3   235*
  3   236*   COMMON, VLA's, and LA's are presumed to start at the base pointer
  3   237*   of their particular storage section. */
  3   238 
  3   239 declare	1 list_template_entry    aligned based,
  3   240 	  2 n_bits	     fixed bin (35) aligned,	/* size of datum */
  3   241 	  2 mbz		     bit (3) unaligned,	/* future expansion */
  3   242 	  2 init_type	     fixed bin (3) unsigned unaligned, /* 0 normal init, 1 ptr init, 2 packed ptr init */
  3   243 	  2 repeat	     fixed bin (30) unsigned unaligned,
  3   244 						/* number of times to repeat datum */
  3   245 	  2 datum		     bit (link_init_n_bits_in_datum refer (list_template_entry.n_bits));
  3   246 
  3   247 
  3   248 /* the pointer_init_template represents the initialization information
  3   249*   for ITS and packed pointers.  Both pointer types require the entire
  3   250*   72 bit structure.
  3   251**/
  3   252 
  3   253 dcl       1 pointer_init_template  based,
  3   254 	  2 ptr_type	     fixed bin (18) unsigned unaligned,  /* 0 text section, 1 linkage section, 2 static section */
  3   255 	  2 section_offset	     fixed bin (18) unsigned unaligned,  /* offset to item in specified section */
  3   256 	  2 word_offset	     fixed bin (18) unsigned unaligned,  /* offset from section item to target in words */
  3   257 	  2 mbz		     bit (12) unaligned,
  3   258 	  2 bit_offset	     fixed bin (6) unsigned unaligned;   /* offset from section item|word offset to target in bits */
  3   259 
  3   260 
  3   261 declare	link_init_n_bits_in_datum
  3   262 			     fixed bin (35);
  3   263 
  3   264 /* for type = 6, the init_info resides in another MSF component */
  3   265 /* target_relp is a linkage section offset to a partial link to */
  3   266 /* the base of the linkage section of the component containing  */
  3   267 /* the actual init_info. link_relp is the offset of the actual  */
  3   268 /* link within that linkage section.			    */
  3   269 
  3   270 declare	1 link_init_deferred     aligned based (link_init_ptr),
  3   271 	  2 header	     aligned like link_init,
  3   272 	  2 target_relp	     fixed bin (18) unsigned unaligned,
  3   273 	  2 link_relp	     fixed bin (18) unsigned unaligned;
  3   274 
  3   275 /* Definition section hash table */
  3   276 
  3   277 declare	def_ht_ptr	     pointer;
  3   278 declare	1 definition_ht	     aligned based (def_ht_ptr),
  3   279 	  2 n_entries	     fixed bin,
  3   280 	  2 table		     (def_ht_n_entries refer (definition_ht.n_entries)) aligned,
  3   281 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  3   282 	    3 unused	     bit (18) unaligned;
  3   283 
  3   284 declare	def_ht_n_entries	     fixed bin;
  3   285 
  3   286 
  3   287 /* Component name ht */
  3   288 declare	comp_ht_ptr	     pointer;
  3   289 declare	1 component_ht	     aligned based (comp_ht_ptr),
  3   290 	  2 n_entries	     fixed bin,
  3   291 	  2 table		     (comp_ht_n_entries refer (component_ht.n_entries)) aligned,
  3   292 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  3   293 						/* hashed segname */
  3   294 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  3   295 						/* first segname def of block containing def_relp */
  3   296 
  3   297 declare	comp_ht_n_entries	     fixed bin;
  3   298 
  3   299 /* Duplicate name table */
  3   300 
  3   301 declare	dup_table_ptr	     pointer;
  3   302 declare	1 duplicate_table	     aligned based (dup_table_ptr),
  3   303 	  2 mbz		     bit (18) unaligned,	/* to tell it from a definition */
  3   304 	  2 n_names	     fixed bin (18) unsigned unaligned,
  3   305 						/* n in table */
  3   306 	  2 table		     (dup_table_n_names refer (duplicate_table.n_names)) aligned,
  3   307 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  3   308 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  3   309 
  3   310 declare	dup_table_n_names	     fixed bin;
  3   311 
  3   312 /* The msf_map is found in the definition section of an	*/
  3   313 /* object MSF component.  It is used by the linker to	*/
  3   314 /* determine whether a segment is a component of an object	*/
  3   315 /* MSF or a standard single-segment object.		*/
  3   316   
  3   317   dcl msf_map_ptr		ptr;
  3   318   dcl 01 msf_map		aligned based (msf_map_ptr),
  3   319        02 version		char (8),
  3   320        02 component_count	fixed bin (15) unsigned,
  3   321        02 my_component	fixed bin (15) unsigned;
  3   322   
  3   323   dcl msf_map_version_1	char (8) static options (constant)
  3   324 			     init ("msfmp1.0");
  3   325   
  3   326 declare	acc_string_ptr	     pointer;
  3   327 declare	1 acc_string	     aligned based (acc_string_ptr),
  3   328 	  2 count		     fixed bin (9) unsigned unaligned,
  3   329 	  2 string	     character (max (3, acc_string_length) refer (acc_string.count)) unaligned,
  3   330 	  2 mbz		     bit (0) aligned;	/* this causes the statement */
  3   331 						/* unspec (acc_string) = ""b to zero out */
  3   332 						/* the last word, if the string is not of length 0mod4 */
  3   333 
  3   334 declare	acc_string_length	     fixed bin (21);
  3   335 
  3   336 
  3   337 /* end include file definitions_dcls.incl.pl1 */
      300 
      301 
  4     1 /* BEGIN INCLUDE FILE object_link_dcls.incl.pl1 BIM 1981 from linkdcl */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  4     6*     audit(86-11-18,Schroth), install(86-11-20,MR12.0-1222):
  4     7*     Modified to add partial_link structure for an object MSF partially snapped
  4     8*     link.
  4     9*  2) change(86-11-13,DGHowe), approve(86-11-13,MCR7391), audit(86-11-13,Zwick),
  4    10*     install(86-11-20,MR12.0-1222):
  4    11*     Added a declaration of FAULT_TAG_1, FAULT_TAG_2 and FAULT_TAG_3.
  4    12*                                                   END HISTORY COMMENTS */
  4    13 
  4    14 
  4    15 /* format: style3 */
  4    16 /* everything you ever wanted in a linkage section */
  4    17 
  4    18 /*
  4    19* Last Modified (Date and Reason):
  4    20*  15 Nov 1971 by C Garman 
  4    21*   6/75 by M.Weaver to add virgin_linkage_header declaration
  4    22*   6/75 by S.Webber to comment existing structures better
  4    23*   9/77 by M. Weaver to add run_depth to link
  4    24*   7/81 by B. Margulies for firstref structure, unsigned fixed bins.
  4    25*   3/83 by M. Weaver to add flags overlaying def_ptr
  4    26**/
  4    27 
  4    28 declare	1 object_link	based aligned,		/* link pair in linkage section */
  4    29 	  2 header_relp	fixed bin (17) unal,	/* rel pointer to beginning of linkage, always negative */
  4    30 	  2 ringno	fixed bin (3) unsigned unal,	/* MBZ */
  4    31 	  2 mbz		bit (6) unal,
  4    32 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  4    33 	  2 tag		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  4    34 	  2 expression_relp fixed bin (18) unsigned unal, /* pointer (rel to defs) of expression word */
  4    35 	  2 mbz2		bit (12) unal,
  4    36 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  4    37 
  4    38 declare	1 partial_link	based aligned,		/* partially snapped link */
  4    39 	  2 type		fixed bin (3) unsigned unal,	/* target section of link */
  4    40 	  2 component	fixed bin (15) unsigned unal,	/* target component index */
  4    41 	  2 mbz1		bit (12) unal,
  4    42 	  2 tag		bit (6) unal,		/* fault tag 3 47(8), ITS 43(8) if snapped */
  4    43 	  
  4    44 	  2 offset	fixed bin (18) unsigned unal,	/* word offset of link */
  4    45 	  2 mbz2		bit (3) unal,
  4    46 	  2 bit_offset	fixed bin (6) unsigned unal,	/* bit offset (in practice, always 0) */
  4    47 	  2 mbz3		bit (3) unal,
  4    48 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  4    49 
  4    50 declare	1 linkage_header	based aligned,		/* linkage block header */
  4    51 	  2 def_ptr	ptr,			/* pointer to definition section */
  4    52 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  4    53 	  2 original_linkage_ptr
  4    54 			ptr unal,			/* pointer to linkage section in object segment */
  4    55 	  2 unused	bit (72),
  4    56 	  2 stats,
  4    57 	    3 begin_links	fixed bin (18) unsigned unal, /* offset (rel to this section) of first link */
  4    58 	    3 block_length	fixed bin (18) unsigned unal, /* number of words in this linkage section */
  4    59 	    3 segment_number
  4    60 			fixed bin (18) unsigned unal, /* text segment number associated with this section */
  4    61 	    3 static_length fixed bin (18) unsigned unal; /* number of words of static for this segment */
  4    62 
  4    63 declare	1 linkage_header_flags
  4    64 			aligned based,		/* overlay of def_ptr for flags */
  4    65 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  4    66 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  4    67 	  2 perprocess_static
  4    68 			bit (1) unaligned,		/* 1 copy of static section is shared among all tasks/run units */
  4    69 	  2 pad2		bit (6) unaligned;
  4    70 
  4    71 declare	1 virgin_linkage_header
  4    72 			aligned based,		/* template for linkage header in object segment */
  4    73 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  4    74 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  4    75 	  2 def_offset	fixed bin (18) unsigned unaligned,
  4    76 						/* offset of definition section */
  4    77 	  2 first_ref_relp	fixed bin (18) unsigned unaligned,
  4    78 						/* offset of trap-at-first-reference offset array */
  4    79 	  2 filled_in_later bit (144),
  4    80 	  2 link_begin	fixed bin (18) unsigned unaligned,
  4    81 						/* offset of first link */
  4    82 	  2 linkage_section_lng
  4    83 			fixed bin (18) unsigned unaligned,
  4    84 						/* length of linkage section */
  4    85 	  2 segno_pad	fixed bin (18) unsigned unaligned,
  4    86 						/* will be segment number of copied linkage */
  4    87 	  2 static_length	fixed bin (18) unsigned unaligned;
  4    88 						/* length of static section */
  4    89 
  4    90 declare	1 fr_traps	based aligned,		/* First Reference Trap Procedures */
  4    91 	  2 decl_vers	fixed bin,		/* version of this struc, value=1, ABS reloc */
  4    92 	  2 n_traps	fixed bin,		/* number of traps on this segment, ABS */
  4    93 	  2 trap_array	(n_fr_traps refer (fr_traps.n_traps)) aligned,
  4    94 	    3 call_relp	fixed bin (18) unsigned unaligned,
  4    95 						/* LINK18, offset of link defining procedure to call */
  4    96 	    3 info_relp	fixed bin (18) unsigned unaligned;
  4    97 						/* LINK18, offser of link defining argument list for trap proc */
  4    98 
  4    99 declare	FR_TRAPS_VERSION_1	init (1) fixed bin internal static options (constant);
  4   100 declare   FAULT_TAG_1	bit(6) unaligned init ("40"b3) static options (constant);
  4   101 declare   FAULT_TAG_2	bit(6) unaligned init ("46"b3) static options (constant);
  4   102 declare   FAULT_TAG_3	bit(6) unaligned init ("47"b3) static options (constant);
  4   103 
  4   104 /* END INCLUDE FILE object_link_dcls.incl.pl1 */
      302 
      303 
  5     1 /* BEGIN INCLUDE FILE its.incl.pl1
  5     2*   modified 27 July 79 by JRDavis to add its_unsigned
  5     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  5     4 
  5     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  5     6     2 pad1 bit (3) unaligned,
  5     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  5     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  5     9     2 pad2 bit (9) unaligned,
  5    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  5    11 
  5    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  5    13     2 pad3 bit (3) unaligned,
  5    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  5    15     2 pad4 bit (3) unaligned,
  5    16     2 mod bit (6) unaligned;				/* further modification */
  5    17 
  5    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  5    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  5    20     2 pad1 bit (27) unaligned,
  5    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  5    22 
  5    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  5    24     2 pad2 bit (3) unaligned,
  5    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  5    26     2 pad3 bit (3) unaligned,
  5    27     2 mod bit (6) unaligned;				/* further modification */
  5    28 
  5    29 
  5    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  5    31     2 pad1 bit (3) unaligned,
  5    32     2 segno fixed bin (15) unsigned unaligned,
  5    33     2 ringno fixed bin (3) unsigned unaligned,
  5    34     2 pad2 bit (9) unaligned,
  5    35     2 its_mod bit (6) unaligned,
  5    36 
  5    37     2 offset fixed bin (18) unsigned unaligned,
  5    38     2 pad3 bit (3) unaligned,
  5    39     2 bit_offset fixed bin (6) unsigned unaligned,
  5    40     2 pad4 bit (3) unaligned,
  5    41     2 mod bit (6) unaligned;
  5    42 
  5    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  5    44     2 pr_no fixed bin (3) unsigned unaligned,
  5    45     2 pad1 bit (27) unaligned,
  5    46     2 itp_mod bit (6) unaligned,
  5    47 
  5    48     2 offset fixed bin (18) unsigned unaligned,
  5    49     2 pad2 bit (3) unaligned,
  5    50     2 bit_offset fixed bin (6) unsigned unaligned,
  5    51     2 pad3 bit (3) unaligned,
  5    52     2 mod bit (6) unaligned;
  5    53 
  5    54 
  5    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  5    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  5    57 
  5    58 /* END INCLUDE FILE   its.incl.pl1 */
      304 
      305 
  6     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  6     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  6     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  6     4 /*	Modified April 1983 by C. Hornig for tasking */
  6     5 
  6     6 /****^  HISTORY COMMENTS:
  6     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  6     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  6     9*     added the heap_header_ptr definition.
  6    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  6    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  6    12*     Modified to support control point management.  These changes were actually
  6    13*     made in February 1985 by G. Palter.
  6    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  6    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  6    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  6    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  6    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  6    19*     (ITS pair).
  6    20*                                                   END HISTORY COMMENTS */
  6    21 
  6    22 /* format: style2 */
  6    23 
  6    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  6    25 
  6    26      dcl	   1 stack_header	      based (sb) aligned,
  6    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  6    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  6    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  6    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  6    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  6    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  6    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  6    34 	     2 pad4	      bit (2) unal,
  6    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  6    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  6    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  6    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  6    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  6    40 	     2 null_ptr	      ptr,		/*  (16)  */
  6    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  6    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  6    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  6    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  6    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  6    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  6    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  6    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  6    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  6    50 	     2 return_no_pop_op_ptr
  6    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  6    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  6    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  6    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  6    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  6    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  6    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  6    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  6    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  6    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  6    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  6    62 	     2 trace,
  6    63 	       3 frames,
  6    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  6    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  6    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  6    67 	     2 pad2	      bit (36),		/*  (61) */
  6    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  6    69 
  6    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  6    71 
  6    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  6    73 						/* (551) octal */
  6    74 
  6    75 
  6    76 /*	The following constants are offsets within this transfer vector table.  */
  6    77 
  6    78      dcl	   (
  6    79 	   call_offset	      fixed bin init (271),
  6    80 	   push_offset	      fixed bin init (272),
  6    81 	   return_offset	      fixed bin init (273),
  6    82 	   return_no_pop_offset   fixed bin init (274),
  6    83 	   entry_offset	      fixed bin init (275)
  6    84 	   )		      internal static;
  6    85 
  6    86 
  6    87 
  6    88 
  6    89 
  6    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  6    91*	move the whole stack header should use this overlay.
  6    92**/
  6    93 
  6    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  6    95 
  6    96 
  6    97 
  6    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      306 
      307      end interpret_link_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/20/86  1148.9  interpret_link_.pl1               >special_ldd>install>MR12.0-1222>interpret_link_.pl1
296          1    06/06/83  0917.4  interpret_link_info.incl.pl1      >ldd>include>interpret_link_info.incl.pl1
298          2    08/05/77  1022.4  lot.incl.pl1                      >ldd>include>lot.incl.pl1
300          3    11/20/86  1035.3  definition_dcls.incl.pl1          >special_ldd>install>MR12.0-1222>definition_dcls.incl.pl1
302          4    11/20/86  1035.4  object_link_dcls.incl.pl1         >special_ldd>install>MR12.0-1222>object_link_dcls.incl.pl1
304          5    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
306          6    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A_code                                 parameter       fixed bin(35,0)          dcl 37 set ref 33 105 109* 155* 165* 183* 193 199*
                                                                                  240*
A_link_ptr                             parameter       pointer                  dcl 37 ref 33 105 126
A_structure_ptr                        parameter       pointer                  dcl 37 ref 33 105 111 113 193 200 202 283 284 286
                                                                                  287 288
CLASS_HEAP                             constant        fixed bin(3,0)           initial unsigned dcl 3-25 ref 235 269
CLASS_SYSTEM                           constant        fixed bin(3,0)           initial unsigned dcl 3-25 ref 269
CLASS_TEXT                             constant        fixed bin(3,0)           initial unsigned dcl 3-25 ref 235
Def_section_ptr                        parameter       pointer                  dcl 196 ref 193 209 211
Exp_relp                               parameter       fixed bin(18,0)          dcl 195 ref 193 209
FAULT_TAG_2                            constant        bit(6)                   initial unaligned dcl 4-101 ref 148 159
INTERPRET_LINK_INFO_VERSION_1   000016 constant        char(8)                  initial unaligned dcl 1-13 ref 111 200
ITS_MODIFIER                           constant        bit(6)                   initial unaligned dcl 5-55 ref 128 169
LINK_CREATE_IF_NOT_FOUND               constant        fixed bin(18,0)          initial unsigned unaligned dcl 3-134 ref 269
LINK_REFNAME_BASE                      constant        fixed bin(18,0)          initial unsigned unaligned dcl 3-134 ref 251
LINK_SELF_BASE                         constant        fixed bin(18,0)          initial unsigned unaligned dcl 3-134 ref 232 251
LINK_SELF_OFFSETNAME                   constant        fixed bin(18,0)          initial unsigned unaligned dcl 3-134 ref 232 269 269
Modifier                               parameter       bit(6)                   unaligned dcl 197 ref 193 210
SYMBOLIC_SECTION_NAMES          000000 constant        char(8)                  initial array unaligned dcl 3-38 ref 235
acc_string                             based           structure                level 1 dcl 3-327
addr                                                   builtin function         dcl 86 ref 117 130 144 206
addrel                                                 builtin function         dcl 86 ref 147 159 174 179 188 209 229 245 255 267
auto_interpret_link_info        000100 automatic       structure                level 1 dcl 65 set ref 117 206
b1                                     based           structure                level 1 dcl 90
b7                                     based           structure                level 1 dcl 94
based_ptr                              based           pointer                  dcl 98 ref 144
baseno                                                 builtin function         dcl 86 ref 133 137
begin_links               6            based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 4-50 ref 140
bin                                                    builtin function         dcl 86 ref 132 138 190 210
block_length              6(18)        based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 4-50 ref 140
class                           000261 automatic       fixed bin(17,0)          dcl 76 set ref 234* 235 235 235 269 269
count                                  based           fixed bin(9,0)           level 2 packed unsigned unaligned dcl 3-327 ref 247
                                                                                  258
cur_lot_size             13            based           fixed bin(17,0)          level 2 packed unaligned dcl 6-26 ref 135
def_offset                1            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 4-71 ref 174
                                                                                  178 179
def_ptr                                based           pointer                  level 2 dcl 4-50 ref 169
defbase                         000232 automatic       pointer                  dcl 74 set ref 169* 174* 178* 179* 188 211* 229 245
                                                                                  255 267
definition_flags                       based           structure                level 1 packed unaligned dcl 3-42
defs_in_link              0(30)        based           bit(6)                   level 2 packed unaligned dcl 4-71 ref 174 179
entry_point_name         10            based           char(33)                 level 2 in structure "old_interpret_link_info"
                                                                                  dcl 67 in procedure "interpret_link_" set ref 284*
entry_point_name         12            based           char(260)                level 2 in structure "interpret_link_info" dcl 1-5
                                                                                  in procedure "interpret_link_" set ref 120* 212*
                                                                                  251* 257* 258* 284
error_table_$bad_link_type      000012 external static fixed bin(35,0)          dcl 43 ref 165 240
error_table_$no_defs            000010 external static fixed bin(35,0)          dcl 42 ref 183
error_table_$no_linkage         000014 external static fixed bin(35,0)          dcl 44 ref 155
exp_word                               based           structure                level 1 dcl 3-129
expression              113            based           char(8)                  level 2 in structure "interpret_link_info" dcl 1-5
                                                                                  in procedure "interpret_link_" set ref 120* 212*
                                                                                  227* 286
expression               21            based           char(8)                  level 2 in structure "old_interpret_link_info"
                                                                                  dcl 67 in procedure "interpret_link_" set ref 286*
expression                0(18)        based           fixed bin(17,0)          level 2 in structure "exp_word" packed unaligned
                                                                                  dcl 3-129 in procedure "interpret_link_" ref 218
                                                                                  222
expression_relp           1            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 4-28 ref 188
have_textp                      000252 automatic       bit(1)                   dcl 75 set ref 102* 107* 174
header_relp                            based           fixed bin(17,0)          level 2 packed unaligned dcl 4-28 ref 159
i                               000254 automatic       fixed bin(17,0)          dcl 76 set ref 222* 223 224* 224 227* 276* 278*
ili_ptr                         000234 automatic       pointer                  dcl 74 set ref 113* 117* 120 120 120 120 120 202*
                                                                                  206* 212 212 212 212 212 227 235 247 251 257 258
                                                                                  262 272 278 283 284 286 287 288
interpret_link_info                    based           structure                level 1 dcl 1-5
ioa_$rsnnl                      000016 constant        entry                    external dcl 48 ref 227 272 278
its                                    based           structure                level 1 dcl 5-5
its_mod                   0(30)        based           bit(6)                   level 2 packed unaligned dcl 5-5 ref 169
j                               000255 automatic       fixed bin(17,0)          dcl 76 set ref 277* 278*
lhe18                                  based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 90 ref 276
lhp                             000236 automatic       pointer                  dcl 74 set ref 136* 137 138 140 140 144 144 145 159*
                                                                                  169 169 174 174 178 178 179 179 179
link_init                              based           structure                level 1 dcl 3-205
link_segment_no                 000262 automatic       bit(18)                  dcl 77 set ref 133* 137
linkage_header                         based           structure                level 1 dcl 4-50
linkp                           000240 automatic       pointer                  dcl 74 set ref 126* 128 132 133 147* 148 159 159 159
                                                                                  188 190
lng                             000256 automatic       fixed bin(17,0)          dcl 76 set ref 227* 272* 278*
lot                                    based           structure                level 1 dcl 2-6
lot_ptr                  26            based           pointer                  level 2 dcl 6-26 ref 131
lotp                            000270 automatic       pointer                  dcl 2-4 set ref 131* 136
lp                                     based           pointer                  array level 2 packed unaligned dcl 2-6 ref 136
modifier                115            based           char(4)                  level 2 in structure "interpret_link_info" dcl 1-5
                                                                                  in procedure "interpret_link_" set ref 120* 212*
                                                                                  262* 287
modifier                 23            based           char(4)                  level 2 in structure "old_interpret_link_info"
                                                                                  dcl 67 in procedure "interpret_link_" set ref 287*
modifier                  1(30)        based           bit(6)                   level 2 in structure "object_link" packed unaligned
                                                                                  dcl 4-28 in procedure "interpret_link_" ref 190
modx                            000263 automatic       fixed bin(17,0)          dcl 78 set ref 190* 210* 262
nwords                                 based           fixed bin(17,0)          level 2 dcl 94 set ref 272*
object_link                            based           structure                level 1 dcl 4-28
offset                          000260 automatic       fixed bin(17,0)          dcl 76 set ref 132* 138
offsetname_relp           1(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 3-160 ref 255
old_interpret_link_info                based           structure                level 1 dcl 67
old_version_sw                  000253 automatic       bit(1)                   dcl 75 set ref 112* 116* 201* 205* 282
original_linkage_ptr      3            based           pointer                  level 2 packed unaligned dcl 4-50 ref 145
original_lp                     000242 automatic       pointer                  dcl 74 set ref 144* 145* 147
p                               000244 automatic       pointer                  dcl 74 set ref 130 245* 247 255* 258 267* 272 276
                                                                                  277
ptr                                                    builtin function         dcl 86 ref 130 178
rel                                                    builtin function         dcl 86 ref 132 138
reloffset                       000266 automatic       fixed bin(18,0)          dcl 81 set ref 138* 140 140 147
rhe18                     0(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 90 ref 277
sb                              000272 automatic       pointer                  dcl 6-24 set ref 130* 131 135
searching                       000265 automatic       bit(1)                   dcl 80 set ref 134* 135 150*
segment_name              2            based           char(32)                 level 2 in structure "interpret_link_info" dcl 1-5
                                                                                  in procedure "interpret_link_" set ref 120* 212*
                                                                                  235* 247* 283
segment_name                           based           char(32)                 level 2 in structure "old_interpret_link_info"
                                                                                  dcl 67 in procedure "interpret_link_" set ref 283*
segname_relp              1            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 3-160 ref 234
                                                                                  245
segno                           000264 automatic       fixed bin(18,0)          dcl 79 set ref 135* 136*
sign                            000267 automatic       char(1)                  dcl 82 set ref 221* 225* 227*
stack_header                           based           structure                level 1 dcl 6-26
stats                     6            based           structure                level 2 dcl 4-50
string                    0(09)        based           char                     level 2 packed unaligned dcl 3-327 ref 247 258
substr                                                 builtin function         dcl 86 set ref 251* 257* 258* 284 288
symbolic_modifier               000020 constant        char(4)                  initial array dcl 53 ref 262
tag                       0(30)        based           bit(6)                   level 2 packed unaligned dcl 4-28 ref 128 148 159
text_ptr                               parameter       pointer                  dcl 37 ref 105 174
tpp                             000246 automatic       pointer                  dcl 74 set ref 229* 231 234 245 255 265 267 272
trap                     24            based           char(32)                 level 2 in structure "old_interpret_link_info"
                                                                                  dcl 67 in procedure "interpret_link_" set ref 288*
trap                    116            based           char(48)                 level 2 in structure "interpret_link_info" dcl 1-5
                                                                                  in procedure "interpret_link_" set ref 120* 212*
                                                                                  272* 278* 288
trap_relp                 0(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 3-160 set ref
                                                                                  265 267 272*
type                                   based           fixed bin(18,0)          level 2 in structure "type_pair" packed unsigned
                                                                                  unaligned dcl 3-160 in procedure "interpret_link_"
                                                                                  ref 231
type                            000257 automatic       fixed bin(17,0)          dcl 76 in procedure "interpret_link_" set ref 231*
                                                                                  232 232 251 251 269 269 269
type_pair                              based           structure                level 1 dcl 3-160
type_relp                              based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 3-129 ref 229
unused                    4            based           bit(72)                  level 2 dcl 4-50 set ref 144 144
version                                based           char(8)                  level 2 dcl 1-5 ref 111 200
virgin_linkage_header                  based           structure                level 1 dcl 4-71
xp                              000250 automatic       pointer                  dcl 74 set ref 188* 209* 218 222 229

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CLASS_LINKAGE                          internal static fixed bin(3,0)           initial unsigned dcl 3-25
CLASS_NAMES                            internal static char(12)                 initial array unaligned dcl 3-35
CLASS_SEGNAME                          internal static fixed bin(3,0)           initial unsigned dcl 3-25
CLASS_STATIC                           internal static fixed bin(3,0)           initial unsigned dcl 3-25
CLASS_SYMBOL                           internal static fixed bin(3,0)           initial unsigned dcl 3-25
FAULT_TAG_1                            internal static bit(6)                   initial unaligned dcl 4-100
FAULT_TAG_3                            internal static bit(6)                   initial unaligned dcl 4-102
FR_TRAPS_VERSION_1                     internal static fixed bin(17,0)          initial dcl 4-99
INIT_COPY_INFO                         internal static fixed bin(17,0)          initial dcl 3-194
INIT_DEFERRED                          internal static fixed bin(17,0)          initial dcl 3-194
INIT_DEFINE_AREA                       internal static fixed bin(17,0)          initial dcl 3-194
INIT_LIST_TEMPLATE                     internal static fixed bin(17,0)          initial dcl 3-194
INIT_NO_INIT                           internal static fixed bin(17,0)          initial dcl 3-194
ITP_MODIFIER                           internal static bit(6)                   initial unaligned dcl 5-56
LINK_OBSOLETE_2                        internal static fixed bin(18,0)          initial unsigned unaligned dcl 3-134
LINK_REFNAME_OFFSETNAME                internal static fixed bin(18,0)          initial unsigned unaligned dcl 3-134
LINK_TYPE_NAMES                        internal static varying char(32)         initial array dcl 3-153
SECTION_HEAP                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 3-134
SECTION_LINK                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 3-134
SECTION_STATIC                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 3-134
SECTION_SYMBOL                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 3-134
SECTION_SYSTEM                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 3-134
SECTION_TEXT                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 3-134
SECTION_UNUSED                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 3-134
acc_string_length                      automatic       fixed bin(21,0)          dcl 3-334
acc_string_ptr                         automatic       pointer                  dcl 3-326
call_offset                            internal static fixed bin(17,0)          initial dcl 6-78
comp_ht_n_entries                      automatic       fixed bin(17,0)          dcl 3-297
comp_ht_ptr                            automatic       pointer                  dcl 3-288
component_ht                           based           structure                level 1 dcl 3-289
def_header_ptr                         automatic       pointer                  dcl 3-57
def_ht_n_entries                       automatic       fixed bin(17,0)          dcl 3-284
def_ht_ptr                             automatic       pointer                  dcl 3-277
def_ptr                                automatic       pointer                  dcl 3-71
definition                             based           structure                level 1 dcl 3-72
definition_header                      based           structure                level 1 dcl 3-58
definition_ht                          based           structure                level 1 dcl 3-278
dup_table_n_names                      automatic       fixed bin(17,0)          dcl 3-310
dup_table_ptr                          automatic       pointer                  dcl 3-301
duplicate_table                        based           structure                level 1 dcl 3-302
entry_offset                           internal static fixed bin(17,0)          initial dcl 6-78
exp_ptr                                automatic       pointer                  dcl 3-128
fr_traps                               based           structure                level 1 dcl 4-90
interpret_link_info_ptr                automatic       pointer                  dcl 1-15
isot                                   based           structure                level 1 dcl 2-13
isot1                                  based           structure                array level 1 dcl 2-16
isotp                                  automatic       pointer                  dcl 2-12
itp                                    based           structure                level 1 dcl 5-18
itp_unsigned                           based           structure                level 1 dcl 5-43
its_unsigned                           based           structure                level 1 dcl 5-30
link_init_copy_info                    based           structure                level 1 dcl 3-211
link_init_deferred                     based           structure                level 1 dcl 3-270
link_init_list_template                based           structure                level 1 dcl 3-219
link_init_n_bits_in_datum              automatic       fixed bin(35,0)          dcl 3-261
link_init_n_words                      automatic       fixed bin(17,0)          dcl 3-215
link_init_n_words_in_list              automatic       fixed bin(17,0)          dcl 3-226
link_init_ptr                          automatic       pointer                  dcl 3-204
link_trap_pair                         based           structure                level 1 dcl 3-177
link_trap_ptr                          automatic       pointer                  dcl 3-176
linkage_header_flags                   based           structure                level 1 dcl 4-63
list_template_entry                    based           structure                level 1 dcl 3-239
lot_fault                              internal static bit(36)                  initial dcl 2-9
msf_map                                based           structure                level 1 dcl 3-318
msf_map_ptr                            automatic       pointer                  dcl 3-317
msf_map_version_1                      internal static char(8)                  initial unaligned dcl 3-323
partial_link                           based           structure                level 1 dcl 4-38
pointer_init_template                  based           structure                level 1 packed unaligned dcl 3-253
push_offset                            internal static fixed bin(17,0)          initial dcl 6-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 6-78
return_offset                          internal static fixed bin(17,0)          initial dcl 6-78
segname_definition                     based           structure                level 1 dcl 3-90
segname_ptr                            automatic       pointer                  dcl 3-89
stack_header_overlay                   based           fixed bin(17,0)          array dcl 6-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 6-72
type_ptr                               automatic       pointer                  dcl 3-159

NAMES DECLARED BY EXPLICIT CONTEXT.
EXPRESSION_JOIN                 000557 constant        label                    dcl 218 ref 191
given_exp                       000472 constant        entry                    external dcl 193
interpret_link_                 000161 constant        entry                    external dcl 33
interpret_link_$tptr            000200 constant        entry                    external dcl 105
join                            000212 constant        label                    dcl 109 ref 103
start                           000400 constant        label                    dcl 169 ref 148

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1226        1246    1120        1236
Length      1562    1120        20         277     106           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
interpret_link_                     258 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
interpret_link_          000100 auto_interpret_link_info    interpret_link_
                         000232 defbase                     interpret_link_
                         000234 ili_ptr                     interpret_link_
                         000236 lhp                         interpret_link_
                         000240 linkp                       interpret_link_
                         000242 original_lp                 interpret_link_
                         000244 p                           interpret_link_
                         000246 tpp                         interpret_link_
                         000250 xp                          interpret_link_
                         000252 have_textp                  interpret_link_
                         000253 old_version_sw              interpret_link_
                         000254 i                           interpret_link_
                         000255 j                           interpret_link_
                         000256 lng                         interpret_link_
                         000257 type                        interpret_link_
                         000260 offset                      interpret_link_
                         000261 class                       interpret_link_
                         000262 link_segment_no             interpret_link_
                         000263 modx                        interpret_link_
                         000264 segno                       interpret_link_
                         000265 searching                   interpret_link_
                         000266 reloffset                   interpret_link_
                         000267 sign                        interpret_link_
                         000270 lotp                        interpret_link_
                         000272 sb                          interpret_link_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$rsnnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_link_type    error_table_$no_defs          error_table_$no_linkage


CONSTANTS
000000  aa  052 164 145 170	*tex
000001  aa  164 040 040 040	t   
000002  aa  052 154 151 156	*lin
000003  aa  153 040 040 040	k   
000004  aa  052 163 171 155	*sym
000005  aa  142 157 154 040	bol 
000006  aa  000 000 000 000	    
000007  aa  000 000 000 000	    
000010  aa  052 163 164 141	*sta
000011  aa  164 151 143 040	tic 
000012  aa  052 163 171 163	*sys
000013  aa  164 145 155 040	tem 
000014  aa  052 150 145 141	*hea
000015  aa  160 040 040 040	p   

000016  aa  111 114 111 040	ILI 
000017  aa  061 056 060 040	1.0 

000020  aa  040 040 040 040	    
000021  aa  054 141 165 040	,au 
000022  aa  054 161 165 040	,qu 
000023  aa  054 144 165 040	,du 
000024  aa  054 151 143 040	,ic 
000025  aa  054 141 154 040	,al 
000026  aa  054 161 154 040	,ql 
000027  aa  054 144 154 040	,dl 
000030  aa  054 170 060 040	,x0 
000031  aa  054 170 061 040	,x1 
000032  aa  054 170 062 040	,x2 
000033  aa  054 170 063 040	,x3 
000034  aa  054 170 064 040	,x4 
000035  aa  054 170 065 040	,x5 
000036  aa  054 170 066 040	,x6 
000037  aa  054 170 067 040	,x7 
000040  aa  054 052 040 040	,*  
000041  aa  054 141 165 052	,au*
000042  aa  054 161 165 052	,qu*
000043  aa  054 144 165 052	,du*
000044  aa  054 151 143 052	,ic*
000045  aa  054 141 154 052	,al*
000046  aa  054 161 154 052	,ql*
000047  aa  054 144 154 052	,dl*
000050  aa  054 170 060 052	,x0*
000051  aa  054 170 061 052	,x1*
000052  aa  054 170 062 052	,x2*
000053  aa  054 170 063 052	,x3*
000054  aa  054 170 064 052	,x4*
000055  aa  054 170 065 052	,x5*
000056  aa  054 170 066 052	,x6*
000057  aa  054 170 067 052	,x7*
000060  aa  054 146 061 040	,f1 
000061  aa  054 151 164 160	,itp
000062  aa  054 077 077 077	,???
000063  aa  054 151 164 163	,its
000064  aa  054 163 144 040	,sd 
000065  aa  054 163 143 162	,scr
000066  aa  054 146 062 040	,f2 
000067  aa  054 146 063 040	,f3 
000070  aa  054 143 151 040	,ci 
000071  aa  054 052 040 040	,*  
000072  aa  054 163 143 040	,sc 
000073  aa  054 141 144 040	,ad 
000074  aa  054 144 151 040	,di 
000075  aa  054 144 151 143	,dic
000076  aa  054 151 144 040	,id 
000077  aa  054 151 144 143	,idc
000100  aa  054 052 040 040	,*  
000101  aa  054 052 141 165	,*au
000102  aa  054 052 161 165	,*qu
000103  aa  054 052 144 165	,*du
000104  aa  054 052 151 143	,*ic
000105  aa  054 052 141 154	,*al
000106  aa  054 052 161 154	,*ql
000107  aa  054 052 144 154	,*dl
000110  aa  054 052 170 060	,*x0
000111  aa  054 052 170 061	,*x1
000112  aa  054 052 170 062	,*x2
000113  aa  054 052 170 063	,*x3
000114  aa  054 052 170 064	,*x4
000115  aa  054 052 170 065	,*x5
000116  aa  054 052 170 066	,*x6
000117  aa  054 052 170 067	,*x7

000120  aa     524000000026

000121  aa     606000000022

000122  aa     524000000060

000123  aa     524000000034

000124  aa     524000000001

000125  aa     404000000021

000126  aa     524000000010

000127  aa     524000000004

000130  aa  136 141 136 157	^a^o

000131  aa     516000000006

000132  aa     404000000022

000133  aa     404000000043

000134  aa     464000000000

000136  aa  040 040 040 040	    
000137  aa  040 040 040 040	    

000140  aa  011 124 162 141		Tra
000141  aa  160 072 040 143	p: c
000142  aa  141 154 154 040	all 
000143  aa  136 157 054 040	^o, 
000144  aa  141 162 147 040	arg 
000145  aa  136 157 000 000	^o

000146  aa  011 111 156 151		Ini
000147  aa  164 040 055 076	t ->
000150  aa  040 144 145 146	 def
000151  aa  174 136 157 054	|^o,
000152  aa  040 154 145 156	 len
000153  aa  147 164 150 040	gth 
000154  aa  075 040 136 144	= ^d

BEGIN PROCEDURE interpret_link_
ENTRY TO interpret_link_                                    STATEMENT 1 ON LINE 33
interpret_link_: procedure (A_structure_ptr, A_link_ptr, A_code);

000155  at     000003000134
000156  tt     000134000133
000157  ta     000155000000
000160  da     000056300000
000161  aa   000420 6270 00	eax7 	272
000162  aa  7 00034 3521 20	epp2 	pr7|28,*
000163  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000164  aa     000006000000
000165  aa     000000000000
000166  aa  6 00032 3735 20	epp7 	pr6|26,*
000167  aa  7 00006 3715 20	epp5 	pr7|6,*
000170  aa  6 00274 6515 00	spri5	pr6|188
						STATEMENT 1 ON LINE 102
	have_textp = "0"b;

000171  aa  6 00252 4501 00	stz  	pr6|170		have_textp
						STATEMENT 1 ON LINE 103
	go to join;

000172  aa   000020 7100 04	tra  	16,ic		000212
ENTRY TO interpret_link_$tptr                               STATEMENT 1 ON LINE 105
interpret_link_$tptr: entry (A_structure_ptr, A_link_ptr, text_ptr, A_code);

000173  at     000004000134
000174  tt     000134000134
000175  ta     000133000000
000176  ta     000173000000
000177  da     000074300000
000200  aa   000420 6270 00	eax7 	272
000201  aa  7 00034 3521 20	epp2 	pr7|28,*
000202  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000203  aa     000010000000
000204  aa     000000000000
000205  aa  6 00032 3735 20	epp7 	pr6|26,*
000206  aa  7 00010 3715 20	epp5 	pr7|8,*
000207  aa  6 00274 6515 00	spri5	pr6|188
						STATEMENT 1 ON LINE 107
	have_textp = "1"b;

000210  aa   400000 2350 03	lda  	131072,du
000211  aa  6 00252 7551 00	sta  	pr6|170		have_textp
						STATEMENT 1 ON LINE 109
join:
	A_code = 0;

000212  aa  6 00274 4501 20	stz  	pr6|188,*		A_code
						STATEMENT 1 ON LINE 111
	if A_structure_ptr -> interpret_link_info.version = INTERPRET_LINK_INFO_VERSION_1 then do;

000213  aa  6 00032 3735 20	epp7 	pr6|26,*
000214  aa  7 00002 3715 20	epp5 	pr7|2,*		A_structure_ptr
000215  aa  5 00000 3715 20	epp5 	pr5|0,*		A_structure_ptr
000216  aa  5 00000 2351 00	lda  	pr5|0		interpret_link_info.version
000217  aa  5 00001 2361 00	ldq  	pr5|1		interpret_link_info.version
000220  aa   777576 1170 04	cmpaq	-130,ic		000016 = 111114111040 061056060040
000221  aa   000004 6010 04	tnz  	4,ic		000225
						STATEMENT 1 ON LINE 112
	     old_version_sw = "0"b;

000222  aa  6 00253 4501 00	stz  	pr6|171		old_version_sw
						STATEMENT 1 ON LINE 113
	     ili_ptr = A_structure_ptr;

000223  aa  6 00234 6515 00	spri5	pr6|156		ili_ptr
						STATEMENT 1 ON LINE 114
	end;

000224  aa   000005 7100 04	tra  	5,ic		000231
						STATEMENT 1 ON LINE 115
	else do;

						STATEMENT 1 ON LINE 116
	     old_version_sw = "1"b;

000225  aa   400000 2350 03	lda  	131072,du
000226  aa  6 00253 7551 00	sta  	pr6|171		old_version_sw
						STATEMENT 1 ON LINE 117
	     ili_ptr = addr (auto_interpret_link_info);

000227  aa  6 00100 3535 00	epp3 	pr6|64		auto_interpret_link_info
000230  aa  6 00234 2535 00	spri3	pr6|156		ili_ptr
						STATEMENT 1 ON LINE 118
	end;

						STATEMENT 1 ON LINE 120
	ili_ptr -> interpret_link_info.segment_name,
	     ili_ptr -> interpret_link_info.entry_point_name,
	     ili_ptr -> interpret_link_info.expression,
	     ili_ptr -> interpret_link_info.modifier,
	     ili_ptr -> interpret_link_info.trap = "";

000231  aa  6 00234 3715 20	epp5 	pr6|156,*		ili_ptr
000232  aa  040 100 100 400	mlr  	(),(pr),fill(040)
000233  aa   000000 00 0000	desc9a	0,0
000234  aa  5 00002 00 0040	desc9a	pr5|2,32		interpret_link_info.segment_name
000235  aa  040 100 100 400	mlr  	(),(pr),fill(040)
000236  aa   000000 00 0000	desc9a	0,0
000237  aa  5 00012 00 0404	desc9a	pr5|10,260	interpret_link_info.entry_point_name
000240  aa   777676 2370 04	ldaq 	-66,ic		000136 = 040040040040 040040040040
000241  aa  5 00113 7551 00	sta  	pr5|75		interpret_link_info.expression
000242  aa  5 00114 7561 00	stq  	pr5|76		interpret_link_info.expression
000243  aa   777673 2350 04	lda  	-69,ic		000136 = 040040040040
000244  aa  5 00115 7551 00	sta  	pr5|77		interpret_link_info.modifier
000245  aa  040 100 100 400	mlr  	(),(pr),fill(040)
000246  aa   000000 00 0000	desc9a	0,0
000247  aa  5 00116 00 0060	desc9a	pr5|78,48		interpret_link_info.trap
						STATEMENT 1 ON LINE 126
	linkp = A_link_ptr;

000250  aa  7 00004 3535 20	epp3 	pr7|4,*		A_link_ptr
000251  aa  3 00000 3535 20	epp3 	pr3|0,*		A_link_ptr
000252  aa  6 00240 2535 00	spri3	pr6|160		linkp
						STATEMENT 1 ON LINE 128
	if linkp -> object_link.tag = ITS_MODIFIER then do;

000253  aa  3 00000 2351 00	lda  	pr3|0		object_link.tag
000254  aa   000036 7350 00	als  	30
000255  aa  6 00320 7551 00	sta  	pr6|208		object_link.tag
000256  aa   430000 1150 03	cmpa 	143360,du
000257  aa   000105 6010 04	tnz  	69,ic		000364
						STATEMENT 1 ON LINE 130
	     sb = ptr (addr (p), 0);

000260  aa  6 00244 3515 00	epp1 	pr6|164		p
000261  aa  1 00000 3525 00	epbp2	pr1|0
000262  aa  6 00272 2521 00	spri2	pr6|186		sb
						STATEMENT 1 ON LINE 131
	     lotp = sb -> stack_header.lot_ptr;

000263  aa  2 00026 3715 20	epp5 	pr2|22,*		stack_header.lot_ptr
000264  aa  6 00270 6515 00	spri5	pr6|184		lotp
						STATEMENT 1 ON LINE 132
	     offset = bin (rel (linkp), 18);

000265  aa  3 00000 6351 00	eaa  	pr3|0		linkp
000266  aa   000066 7730 00	lrl  	54
000267  aa  6 00260 7561 00	stq  	pr6|176		offset
						STATEMENT 1 ON LINE 133
	     link_segment_no = baseno (linkp);

000270  aa  3 00000 2131 00	epaq 	pr3|0		linkp
000271  aa   077777 3750 03	ana  	32767,du
000272  aa  6 00262 7551 00	sta  	pr6|178		link_segment_no
						STATEMENT 1 ON LINE 134
	     searching = "1"b;

000273  aa   400000 2350 03	lda  	131072,du
000274  aa  6 00265 7551 00	sta  	pr6|181		searching
						STATEMENT 1 ON LINE 135
	     do segno = 80 to sb -> stack_header.cur_lot_size while (searching);

000275  aa  2 00013 2351 00	lda  	pr2|11		stack_header.cur_lot_size
000276  aa   000066 7330 00	lrs  	54
000277  aa  6 00276 7561 00	stq  	pr6|190
000300  aa   000120 2360 07	ldq  	80,dl
000301  aa  6 00264 7561 00	stq  	pr6|180		segno
000302  aa  6 00322 2515 00	spri1	pr6|210
000303  aa  6 00264 2361 00	ldq  	pr6|180		segno
000304  aa  6 00276 1161 00	cmpq 	pr6|190
000305  aa   000053 6054 04	tpnz 	43,ic		000360
000306  aa  6 00265 2351 00	lda  	pr6|181		searching
000307  aa   000051 6000 04	tze  	41,ic		000360
						STATEMENT 1 ON LINE 136
		lhp = lot (segno).lp;

000310  aa  6 00270 7671 66	lprp7	pr6|184,*ql	lot.lp
000311  aa  6 00236 6535 00	spri7	pr6|158		lhp
						STATEMENT 1 ON LINE 137
		if baseno (lhp) = link_segment_no then do;

000312  aa  7 00000 2131 00	epaq 	pr7|0		lhp
000313  aa   077777 3750 03	ana  	32767,du
000314  aa  6 00262 1151 00	cmpa 	pr6|178		link_segment_no
000315  aa   000041 6010 04	tnz  	33,ic		000356
						STATEMENT 1 ON LINE 138
		     reloffset = offset - bin (rel (lhp), 18);

000316  aa  7 00000 6351 00	eaa  	pr7|0		lhp
000317  aa   000066 7730 00	lrl  	54
000320  aa  6 00321 7561 00	stq  	pr6|209
000321  aa  6 00260 2361 00	ldq  	pr6|176		offset
000322  aa  6 00321 1761 00	sbq  	pr6|209
000323  aa  6 00266 7561 00	stq  	pr6|182		reloffset
						STATEMENT 1 ON LINE 140
		     if reloffset >= lhp -> linkage_header.begin_links then
						/* might be in this section */
			if reloffset < lhp -> linkage_header.block_length then do;

000324  aa  7 00006 2351 00	lda  	pr7|6		linkage_header.begin_links
000325  aa   000066 7730 00	lrl  	54
000326  aa  6 00266 1161 00	cmpq 	pr6|182		reloffset
000327  aa   000027 6054 04	tpnz 	23,ic		000356
000330  aa  7 00006 2361 00	ldq  	pr7|6		linkage_header.block_length
000331  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000332  aa  6 00266 1161 00	cmpq 	pr6|182		reloffset
000333  aa   000023 6044 04	tmoz 	19,ic		000356
						STATEMENT 1 ON LINE 144
			     if lhp -> linkage_header.unused then original_lp = addr (lhp -> linkage_header.unused) -> based_ptr;

000334  aa  7 00004 2351 00	lda  	pr7|4		linkage_header.unused
000335  aa  7 00005 2361 00	ldq  	pr7|5		linkage_header.unused
000336  aa  0 00000 1171 00	cmpaq	pr0|0		= 000000000000 000000000000
000337  aa   000004 6000 04	tze  	4,ic		000343
000340  aa  7 00004 3715 20	epp5 	pr7|4,*		based_ptr
000341  aa  6 00242 6515 00	spri5	pr6|162		original_lp
000342  aa   000003 7100 04	tra  	3,ic		000345
						STATEMENT 1 ON LINE 145
			     else original_lp = lhp -> linkage_header.original_linkage_ptr;

000343  aa  7 00003 7651 00	lprp5	pr7|3		linkage_header.original_linkage_ptr
000344  aa  6 00242 6515 00	spri5	pr6|162		original_lp
						STATEMENT 1 ON LINE 147
			     linkp = addrel (original_lp, reloffset);

000345  aa  6 00266 2361 00	ldq  	pr6|182		reloffset
000346  aa  5 00000 3521 06	epp2 	pr5|0,ql
000347  aa   000000 0520 03	adwp2	0,du
000350  aa  6 00240 2521 00	spri2	pr6|160		linkp
						STATEMENT 1 ON LINE 148
			     if linkp -> object_link.tag = FAULT_TAG_2 then
				goto start;

000351  aa  2 00000 2351 00	lda  	pr2|0		object_link.tag
000352  aa   000036 7350 00	als  	30
000353  aa   460000 1150 03	cmpa 	155648,du
000354  aa   000024 6000 04	tze  	20,ic		000400
						STATEMENT 1 ON LINE 150
			     searching = "0"b;

000355  aa  6 00265 4501 00	stz  	pr6|181		searching
						STATEMENT 1 ON LINE 151
			end;

						STATEMENT 1 ON LINE 152
		end;

						STATEMENT 1 ON LINE 153
	     end;

000356  aa  6 00264 0541 00	aos  	pr6|180		segno
000357  aa   777723 7100 04	tra  	-45,ic		000302
						STATEMENT 1 ON LINE 155
	     A_code = error_table_$no_linkage;

000360  aa  6 00044 3701 20	epp4 	pr6|36,*
000361  la  4 00014 2361 20	ldq  	pr4|12,*		error_table_$no_linkage
000362  aa  6 00274 7561 20	stq  	pr6|188,*		A_code
						STATEMENT 1 ON LINE 156
	     return;

000363  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 157
	end;

						STATEMENT 1 ON LINE 159
	else if linkp -> object_link.tag = FAULT_TAG_2 then
						/* its unsnapped, no problem */
	     lhp = addrel (linkp, linkp -> object_link.header_relp);

000364  aa   460000 1150 03	cmpa 	155648,du
000365  aa   000007 6010 04	tnz  	7,ic		000374
000366  aa  3 00000 2351 00	lda  	pr3|0		object_link.header_relp
000367  aa   000066 7330 00	lrs  	54
000370  aa  3 00000 3521 06	epp2 	pr3|0,ql
000371  aa   000000 0520 03	adwp2	0,du
000372  aa  6 00236 2521 00	spri2	pr6|158		lhp
000373  aa   000005 7100 04	tra  	5,ic		000400
						STATEMENT 1 ON LINE 164
	else do;

						STATEMENT 1 ON LINE 165
	     A_code = error_table_$bad_link_type;

000374  aa  6 00044 3701 20	epp4 	pr6|36,*
000375  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$bad_link_type
000376  aa  6 00274 7561 20	stq  	pr6|188,*		A_code
						STATEMENT 1 ON LINE 166
	     return;

000377  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 167
	end;

						STATEMENT 1 ON LINE 169
start:

	if lhp -> its.its_mod = ITS_MODIFIER		/* linkage header begins with pointer */
	then defbase = lhp -> linkage_header.def_ptr;

000400  aa  6 00236 2351 20	lda  	pr6|158,*		its.its_mod
000401  aa   000036 7350 00	als  	30
000402  aa   430000 1150 03	cmpa 	143360,du
000403  aa   000005 6010 04	tnz  	5,ic		000410
000404  aa  6 00236 3735 20	epp7 	pr6|158,*		linkage_header.def_ptr
000405  aa  7 00000 3735 20	epp7 	pr7|0,*		linkage_header.def_ptr
000406  aa  6 00232 6535 00	spri7	pr6|154		defbase
000407  aa   000044 7100 04	tra  	36,ic		000453
						STATEMENT 1 ON LINE 173
	else do;

						STATEMENT 1 ON LINE 174
	     if lhp -> virgin_linkage_header.defs_in_link = "0"b
						/* defs in text */
	     then if have_textp
		then defbase = addrel (text_ptr, lhp -> virgin_linkage_header.def_offset);

000410  aa  6 00236 2351 20	lda  	pr6|158,*		virgin_linkage_header.defs_in_link
000411  aa   000036 7350 00	als  	30
000412  aa  6 00320 7551 00	sta  	pr6|208		virgin_linkage_header.defs_in_link
000413  aa   000023 6010 04	tnz  	19,ic		000436
000414  aa  6 00252 2351 00	lda  	pr6|170		have_textp
000415  aa   000012 6000 04	tze  	10,ic		000427
000416  aa  6 00236 3735 20	epp7 	pr6|158,*		lhp
000417  aa  7 00001 2351 00	lda  	pr7|1		virgin_linkage_header.def_offset
000420  aa   000066 7730 00	lrl  	54
000421  aa  6 00032 3715 20	epp5 	pr6|26,*
000422  aa  5 00006 3521 20	epp2 	pr5|6,*		text_ptr
000423  aa  2 00000 3521 66	epp2 	pr2|0,*ql		text_ptr
000424  aa   000000 0520 03	adwp2	0,du
000425  aa  6 00232 2521 00	spri2	pr6|154		defbase
000426  aa   000025 7100 04	tra  	21,ic		000453
						STATEMENT 1 ON LINE 178
		else defbase = ptr (lhp, lhp -> virgin_linkage_header.def_offset);

000427  aa  6 00236 3735 20	epp7 	pr6|158,*		lhp
000430  aa  7 00001 2351 00	lda  	pr7|1		virgin_linkage_header.def_offset
000431  aa   000066 7730 00	lrl  	54
000432  aa  7 00000 3521 00	epp2 	pr7|0
000433  aa   000000 3120 06	eawp2	0,ql
000434  aa  6 00232 2521 00	spri2	pr6|154		defbase
000435  aa   000016 7100 04	tra  	14,ic		000453
						STATEMENT 1 ON LINE 179
	     else if lhp -> virgin_linkage_header.defs_in_link = "010000"b
						/* defs in linkage */
	     then defbase = addrel (lhp, lhp -> virgin_linkage_header.def_offset);

000436  aa   200000 1150 03	cmpa 	65536,du
000437  aa   000010 6010 04	tnz  	8,ic		000447
000440  aa  6 00236 3735 20	epp7 	pr6|158,*		lhp
000441  aa  7 00001 2351 00	lda  	pr7|1		virgin_linkage_header.def_offset
000442  aa   000066 7730 00	lrl  	54
000443  aa  7 00000 3521 06	epp2 	pr7|0,ql
000444  aa   000000 0520 03	adwp2	0,du
000445  aa  6 00232 2521 00	spri2	pr6|154		defbase
000446  aa   000005 7100 04	tra  	5,ic		000453
						STATEMENT 1 ON LINE 182
	     else do;

						STATEMENT 1 ON LINE 183
		A_code = error_table_$no_defs;

000447  aa  6 00044 3701 20	epp4 	pr6|36,*
000450  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$no_defs
000451  aa  6 00274 7561 20	stq  	pr6|188,*		A_code
						STATEMENT 1 ON LINE 184
		return;

000452  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 185
	     end;

						STATEMENT 1 ON LINE 186
	end;

						STATEMENT 1 ON LINE 188
	xp = addrel (defbase, linkp -> object_link.expression_relp);

000453  aa  6 00240 3735 20	epp7 	pr6|160,*		linkp
000454  aa  7 00001 2351 00	lda  	pr7|1		object_link.expression_relp
000455  aa   000066 7730 00	lrl  	54
000456  aa  6 00232 3521 66	epp2 	pr6|154,*ql	defbase
000457  aa   000000 0520 03	adwp2	0,du
000460  aa  6 00250 2521 00	spri2	pr6|168		xp
						STATEMENT 1 ON LINE 190
	modx = bin (linkp -> object_link.modifier, 6);

000461  aa  7 00001 2361 00	ldq  	pr7|1		object_link.modifier
000462  aa  0 00424 3771 00	anaq 	pr0|276		= 000000000000 000000000077
000463  aa  6 00263 7561 00	stq  	pr6|179		modx
						STATEMENT 1 ON LINE 191
	go to EXPRESSION_JOIN;

000464  aa   000073 7100 04	tra  	59,ic		000557
ENTRY TO given_exp                                          STATEMENT 1 ON LINE 193
given_exp: entry (A_structure_ptr, Exp_relp, Modifier, Def_section_ptr, A_code);

000465  at     000005000134
000466  tt     000132000131
000467  tt     000134000133
000470  ta     000465000000
000471  da     000102300000
000472  aa   000420 6270 00	eax7 	272
000473  aa  7 00034 3521 20	epp2 	pr7|28,*
000474  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000475  aa     000012000000
000476  aa     000000000000
000477  aa  6 00032 3735 20	epp7 	pr6|26,*
000500  aa  7 00012 3715 20	epp5 	pr7|10,*
000501  aa  6 00274 6515 00	spri5	pr6|188
						STATEMENT 1 ON LINE 199
	A_code = 0;

000502  aa  6 00274 4501 20	stz  	pr6|188,*		A_code
						STATEMENT 1 ON LINE 200
	if A_structure_ptr -> interpret_link_info.version = INTERPRET_LINK_INFO_VERSION_1 then do;

000503  aa  6 00032 3735 20	epp7 	pr6|26,*
000504  aa  7 00002 3715 20	epp5 	pr7|2,*		A_structure_ptr
000505  aa  5 00000 3715 20	epp5 	pr5|0,*		A_structure_ptr
000506  aa  5 00000 2351 00	lda  	pr5|0		interpret_link_info.version
000507  aa  5 00001 2361 00	ldq  	pr5|1		interpret_link_info.version
000510  aa   777306 1170 04	cmpaq	-314,ic		000016 = 111114111040 061056060040
000511  aa   000004 6010 04	tnz  	4,ic		000515
						STATEMENT 1 ON LINE 201
	     old_version_sw = "0"b;

000512  aa  6 00253 4501 00	stz  	pr6|171		old_version_sw
						STATEMENT 1 ON LINE 202
	     ili_ptr = A_structure_ptr;

000513  aa  6 00234 6515 00	spri5	pr6|156		ili_ptr
						STATEMENT 1 ON LINE 203
	end;

000514  aa   000005 7100 04	tra  	5,ic		000521
						STATEMENT 1 ON LINE 204
	else do;

						STATEMENT 1 ON LINE 205
	     old_version_sw = "1"b;

000515  aa   400000 2350 03	lda  	131072,du
000516  aa  6 00253 7551 00	sta  	pr6|171		old_version_sw
						STATEMENT 1 ON LINE 206
	     ili_ptr = addr (auto_interpret_link_info);

000517  aa  6 00100 3535 00	epp3 	pr6|64		auto_interpret_link_info
000520  aa  6 00234 2535 00	spri3	pr6|156		ili_ptr
						STATEMENT 1 ON LINE 207
	end;

						STATEMENT 1 ON LINE 209
	xp = addrel (Def_section_ptr, Exp_relp);

000521  aa  7 00004 2361 20	ldq  	pr7|4,*		Exp_relp
000522  aa  7 00010 3521 20	epp2 	pr7|8,*		Def_section_ptr
000523  aa  2 00000 3521 66	epp2 	pr2|0,*ql		Def_section_ptr
000524  aa   000000 0520 03	adwp2	0,du
000525  aa  6 00250 2521 00	spri2	pr6|168		xp
						STATEMENT 1 ON LINE 210
	modx = bin (Modifier, 6);

000526  aa  7 00006 3715 20	epp5 	pr7|6,*
000527  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
000530  aa  5 00000 00 0006	descb	pr5|0,6		Modifier
000531  aa  6 00056 00 0044	descb	pr6|46,36
000532  aa  6 00056 2351 00	lda  	pr6|46
000533  aa   000102 7730 00	lrl  	66
000534  aa  6 00263 7561 00	stq  	pr6|179		modx
						STATEMENT 1 ON LINE 211
	defbase = Def_section_ptr;

000535  aa  7 00010 3535 20	epp3 	pr7|8,*		Def_section_ptr
000536  aa  3 00000 3535 20	epp3 	pr3|0,*		Def_section_ptr
000537  aa  6 00232 2535 00	spri3	pr6|154		defbase
						STATEMENT 1 ON LINE 212
	ili_ptr -> interpret_link_info.segment_name,
	     ili_ptr -> interpret_link_info.entry_point_name,
	     ili_ptr -> interpret_link_info.expression,
	     ili_ptr -> interpret_link_info.modifier,
	     ili_ptr -> interpret_link_info.trap = "";

000540  aa  6 00234 3515 20	epp1 	pr6|156,*		ili_ptr
000541  aa  040 100 100 400	mlr  	(),(pr),fill(040)
000542  aa   000000 00 0000	desc9a	0,0
000543  aa  1 00002 00 0040	desc9a	pr1|2,32		interpret_link_info.segment_name
000544  aa  040 100 100 400	mlr  	(),(pr),fill(040)
000545  aa   000000 00 0000	desc9a	0,0
000546  aa  1 00012 00 0404	desc9a	pr1|10,260	interpret_link_info.entry_point_name
000547  aa   777367 2370 04	ldaq 	-265,ic		000136 = 040040040040 040040040040
000550  aa  1 00113 7551 00	sta  	pr1|75		interpret_link_info.expression
000551  aa  1 00114 7561 00	stq  	pr1|76		interpret_link_info.expression
000552  aa   777364 2350 04	lda  	-268,ic		000136 = 040040040040
000553  aa  1 00115 7551 00	sta  	pr1|77		interpret_link_info.modifier
000554  aa  040 100 100 400	mlr  	(),(pr),fill(040)
000555  aa   000000 00 0000	desc9a	0,0
000556  aa  1 00116 00 0060	desc9a	pr1|78,48		interpret_link_info.trap
						STATEMENT 1 ON LINE 218
EXPRESSION_JOIN:

	if xp -> exp_word.expression ^= 0 then do;

000557  aa  2 00000 2351 00	lda  	pr2|0		exp_word.expression
000560  aa   000022 7350 00	als  	18
000561  aa   000066 7330 00	lrs  	54
000562  aa   000045 6000 04	tze  	37,ic		000627
						STATEMENT 1 ON LINE 221
	     sign = "+";

000563  aa   053000 2350 03	lda  	22016,du
000564  aa  6 00267 7551 00	sta  	pr6|183		sign
						STATEMENT 1 ON LINE 222
	     i = xp -> exp_word.expression;

000565  aa  6 00254 7561 00	stq  	pr6|172		i
						STATEMENT 1 ON LINE 223
	     if i < 0 then do;

000566  aa  6 00254 2361 00	ldq  	pr6|172		i
000567  aa   000005 6050 04	tpl  	5,ic		000574
						STATEMENT 1 ON LINE 224
	          i = -i;

000570  aa  6 00254 3361 00	lcq  	pr6|172		i
000571  aa  6 00254 7561 00	stq  	pr6|172		i
						STATEMENT 1 ON LINE 225
		sign = "-";

000572  aa   055000 2350 03	lda  	23040,du
000573  aa  6 00267 7551 00	sta  	pr6|183		sign
						STATEMENT 1 ON LINE 226
	     end;

						STATEMENT 1 ON LINE 227
	     call ioa_$rsnnl ("^a^o", ili_ptr -> interpret_link_info.expression, lng, sign, i);

000574  aa   777334 2350 04	lda  	-292,ic		000130 = 136141136157
000575  aa  6 00320 7551 00	sta  	pr6|208
000576  aa  6 00320 3521 00	epp2 	pr6|208
000577  aa  6 00326 2521 00	spri2	pr6|214
000600  aa  6 00234 3735 20	epp7 	pr6|156,*		ili_ptr
000601  aa  7 00113 3521 00	epp2 	pr7|75		interpret_link_info.expression
000602  aa  6 00330 2521 00	spri2	pr6|216
000603  aa  6 00256 3521 00	epp2 	pr6|174		lng
000604  aa  6 00332 2521 00	spri2	pr6|218
000605  aa  6 00267 3521 00	epp2 	pr6|183		sign
000606  aa  6 00334 2521 00	spri2	pr6|220
000607  aa  6 00254 3521 00	epp2 	pr6|172		i
000610  aa  6 00336 2521 00	spri2	pr6|222
000611  aa   777316 3520 04	epp2 	-306,ic		000127 = 524000000004
000612  aa  6 00340 2521 00	spri2	pr6|224
000613  aa   777313 3520 04	epp2 	-309,ic		000126 = 524000000010
000614  aa  6 00342 2521 00	spri2	pr6|226
000615  aa   777310 3520 04	epp2 	-312,ic		000125 = 404000000021
000616  aa  6 00344 2521 00	spri2	pr6|228
000617  aa  6 00350 2521 00	spri2	pr6|232
000620  aa   777304 3520 04	epp2 	-316,ic		000124 = 524000000001
000621  aa  6 00346 2521 00	spri2	pr6|230
000622  aa  6 00324 6211 00	eax1 	pr6|212
000623  aa   024000 4310 07	fld  	10240,dl
000624  aa  6 00044 3701 20	epp4 	pr6|36,*
000625  la  4 00016 3521 20	epp2 	pr4|14,*		ioa_$rsnnl
000626  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 228
	end;

						STATEMENT 1 ON LINE 229
	tpp = addrel (defbase, xp -> exp_word.type_relp);

000627  aa  6 00250 2351 20	lda  	pr6|168,*		exp_word.type_relp
000630  aa   000066 7730 00	lrl  	54
000631  aa  6 00232 3521 66	epp2 	pr6|154,*ql	defbase
000632  aa   000000 0520 03	adwp2	0,du
000633  aa  6 00246 2521 00	spri2	pr6|166		tpp
						STATEMENT 1 ON LINE 231
	type = tpp -> type_pair.type;

000634  aa  2 00000 2351 00	lda  	pr2|0		type_pair.type
000635  aa   000066 7730 00	lrl  	54
000636  aa  6 00257 7561 00	stq  	pr6|175		type
						STATEMENT 1 ON LINE 232
	if (type = LINK_SELF_BASE) |
	   (type = LINK_SELF_OFFSETNAME) then do;

000637  aa   000005 2350 03	lda  	5,du
000640  aa   000066 7730 00	lrl  	54
000641  aa  6 00257 1161 00	cmpq 	pr6|175		type
000642  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
000643  aa  6 00320 7551 00	sta  	pr6|208
000644  aa   000001 2350 03	lda  	1,du
000645  aa   000066 7730 00	lrl  	54
000646  aa  6 00257 1161 00	cmpq 	pr6|175		type
000647  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
000650  aa  6 00321 7551 00	sta  	pr6|209
000651  aa   000003 6010 04	tnz  	3,ic		000654
000652  aa  6 00320 2351 00	lda  	pr6|208
000653  aa   000023 6000 04	tze  	19,ic		000676
						STATEMENT 1 ON LINE 234
	     class = tpp -> type_pair.segname_relp;

000654  aa  2 00001 2351 00	lda  	pr2|1		type_pair.segname_relp
000655  aa   000066 7730 00	lrl  	54
000656  aa  6 00261 7561 00	stq  	pr6|177		class
						STATEMENT 1 ON LINE 235
	     if (class >= CLASS_TEXT) &
	        (class <= CLASS_HEAP) then
		ili_ptr -> interpret_link_info.segment_name = 
			 SYMBOLIC_SECTION_NAMES (class);

000657  aa   000012 6040 04	tmi  	10,ic		000671
000660  aa   000006 1160 07	cmpq 	6,dl
000661  aa   000010 6054 04	tpnz 	8,ic		000671
000662  aa   000001 7360 00	qls  	1
000663  aa  6 00234 3735 20	epp7 	pr6|156,*		ili_ptr
000664  ta   000000 3714 06	epp5 	0,ql
000665  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
000666  aa  5 00000 00 0010	desc9a	pr5|0,8		SYMBOLIC_SECTION_NAMES
000667  aa  7 00002 00 0040	desc9a	pr7|2,32		interpret_link_info.segment_name
000670  aa   000021 7100 04	tra  	17,ic		000711
						STATEMENT 1 ON LINE 239
	     else do;

						STATEMENT 1 ON LINE 240
		A_code = error_table_$bad_link_type;

000671  aa  6 00044 3701 20	epp4 	pr6|36,*
000672  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$bad_link_type
000673  aa  6 00274 7561 20	stq  	pr6|188,*		A_code
						STATEMENT 1 ON LINE 241
		return;

000674  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 242
	     end;

						STATEMENT 1 ON LINE 243
	end;

000675  aa   000014 7100 04	tra  	12,ic		000711
						STATEMENT 1 ON LINE 244
	else do;

						STATEMENT 1 ON LINE 245
	     p = addrel (defbase, tpp -> type_pair.segname_relp);

000676  aa  2 00001 2351 00	lda  	pr2|1		type_pair.segname_relp
000677  aa   000066 7730 00	lrl  	54
000700  aa  6 00232 3515 66	epp1 	pr6|154,*ql	defbase
000701  aa   000000 0510 03	adwp1	0,du
000702  aa  6 00244 2515 00	spri1	pr6|164		p
						STATEMENT 1 ON LINE 247
	     ili_ptr -> interpret_link_info.segment_name =
	          p -> acc_string.string;

000703  aa  1 00000 2351 00	lda  	pr1|0		acc_string.count
000704  aa   000077 7730 00	lrl  	63
000705  aa  6 00234 3735 20	epp7 	pr6|156,*		ili_ptr
000706  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000707  aa  1 00000 20 0006	desc9a	pr1|0(1),ql	acc_string.string
000710  aa  7 00002 00 0040	desc9a	pr7|2,32		interpret_link_info.segment_name
						STATEMENT 1 ON LINE 249
	end;

						STATEMENT 1 ON LINE 251
	if (type = LINK_SELF_BASE) |
	   (type = LINK_REFNAME_BASE) then
	     substr (ili_ptr -> interpret_link_info.entry_point_name, 1, 2) = "|0";

000711  aa  6 00321 2351 00	lda  	pr6|209
000712  aa   000005 6010 04	tnz  	5,ic		000717
000713  aa   000003 2350 03	lda  	3,du
000714  aa   000066 7730 00	lrl  	54
000715  aa  6 00257 1161 00	cmpq 	pr6|175		type
000716  aa   000005 6010 04	tnz  	5,ic		000723
000717  aa   174060 2350 03	lda  	63536,du
000720  aa  6 00234 3735 20	epp7 	pr6|156,*		ili_ptr
000721  aa  7 00012 5511 60	stba 	pr7|10,60		interpret_link_info.entry_point_name
000722  aa   000017 7100 04	tra  	15,ic		000741
						STATEMENT 1 ON LINE 254
	else do;

						STATEMENT 1 ON LINE 255
	     p = addrel (defbase, tpp -> type_pair.offsetname_relp);

000723  aa  6 00246 3735 20	epp7 	pr6|166,*		tpp
000724  aa  7 00001 2361 00	ldq  	pr7|1		type_pair.offsetname_relp
000725  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000726  aa  6 00232 3521 66	epp2 	pr6|154,*ql	defbase
000727  aa   000000 0520 03	adwp2	0,du
000730  aa  6 00244 2521 00	spri2	pr6|164		p
						STATEMENT 1 ON LINE 257
	     substr (ili_ptr -> interpret_link_info.entry_point_name, 1, 1) = "$";

000731  aa   044000 2350 03	lda  	18432,du
000732  aa  6 00234 3715 20	epp5 	pr6|156,*		ili_ptr
000733  aa  5 00012 5511 40	stba 	pr5|10,40		interpret_link_info.entry_point_name
						STATEMENT 1 ON LINE 258
	     substr (ili_ptr -> interpret_link_info.entry_point_name, 2) = 
		p -> acc_string.string;

000734  aa  2 00000 2351 00	lda  	pr2|0		acc_string.count
000735  aa   000077 7730 00	lrl  	63
000736  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000737  aa  2 00000 20 0006	desc9a	pr2|0(1),ql	acc_string.string
000740  aa  5 00012 20 0403	desc9a	pr5|10(1),259	interpret_link_info.entry_point_name
						STATEMENT 1 ON LINE 260
	end;

						STATEMENT 1 ON LINE 262
	ili_ptr -> interpret_link_info.modifier = symbolic_modifier (modx);

000741  aa  6 00263 7271 00	lxl7 	pr6|179		modx
000742  ta   000020 2350 17	lda  	16,7
000743  aa  6 00234 3735 20	epp7 	pr6|156,*		ili_ptr
000744  aa  7 00115 7551 00	sta  	pr7|77		interpret_link_info.modifier
						STATEMENT 1 ON LINE 265
	if tpp -> type_pair.trap_relp ^= 0 then		/* there is a trap before link */
	     do;

000745  aa  6 00246 2361 20	ldq  	pr6|166,*		type_pair.trap_relp
000746  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000747  aa   000123 6000 04	tze  	83,ic		001072
						STATEMENT 1 ON LINE 267
	     p = addrel (defbase, tpp -> type_pair.trap_relp);

000750  aa  6 00232 3521 66	epp2 	pr6|154,*ql	defbase
000751  aa   000000 0520 03	adwp2	0,du
000752  aa  6 00244 2521 00	spri2	pr6|164		p
						STATEMENT 1 ON LINE 269
	     if (type = LINK_CREATE_IF_NOT_FOUND) | 
	        (type = LINK_SELF_OFFSETNAME & class = CLASS_SYSTEM) |
	        (type = LINK_SELF_OFFSETNAME & class = CLASS_HEAP) then do;

000753  aa   000006 2350 03	lda  	6,du
000754  aa   000066 7730 00	lrl  	54
000755  aa  6 00257 1161 00	cmpq 	pr6|175		type
000756  aa   000013 6000 04	tze  	11,ic		000771
000757  aa  6 00320 2351 00	lda  	pr6|208
000760  aa   000004 6000 04	tze  	4,ic		000764
000761  aa  6 00261 2361 00	ldq  	pr6|177		class
000762  aa   000005 1160 07	cmpq 	5,dl
000763  aa   000006 6000 04	tze  	6,ic		000771
000764  aa   400000 3150 03	cana 	131072,du
000765  aa   000042 6000 04	tze  	34,ic		001027
000766  aa  6 00261 2361 00	ldq  	pr6|177		class
000767  aa   000006 1160 07	cmpq 	6,dl
000770  aa   000037 6010 04	tnz  	31,ic		001027
						STATEMENT 1 ON LINE 272
		     call ioa_$rsnnl ("	Init -> def|^o, length = ^d", ili_ptr -> interpret_link_info.trap,
		     lng, tpp -> type_pair.trap_relp, p -> nwords);

000771  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000772  aa   777155 00 0034	desc9a	-403,28		000146 = 011111156151
000773  aa  6 00324 00 0034	desc9a	pr6|212,28
000774  aa  6 00324 3521 00	epp2 	pr6|212
000775  aa  6 00356 2521 00	spri2	pr6|238
000776  aa  7 00116 3521 00	epp2 	pr7|78		interpret_link_info.trap
000777  aa  6 00360 2521 00	spri2	pr6|240
001000  aa  6 00256 3521 00	epp2 	pr6|174		lng
001001  aa  6 00362 2521 00	spri2	pr6|242
001002  aa   000022 7260 07	lxl6 	18,dl
001003  aa  6 00246 3521 20	epp2 	pr6|166,*		type_pair.trap_relp
001004  aa  2 00000 5035 16	abd  	pr2|0,6
001005  aa  6 00364 2521 00	spri2	pr6|244
001006  aa  6 00244 3521 20	epp2 	pr6|164,*		b7.nwords
001007  aa  6 00366 2521 00	spri2	pr6|246
001010  aa   777113 3520 04	epp2 	-437,ic		000123 = 524000000034
001011  aa  6 00370 2521 00	spri2	pr6|248
001012  aa   777110 3520 04	epp2 	-440,ic		000122 = 524000000060
001013  aa  6 00372 2521 00	spri2	pr6|250
001014  aa   777111 3520 04	epp2 	-439,ic		000125 = 404000000021
001015  aa  6 00374 2521 00	spri2	pr6|252
001016  aa  6 00400 2521 00	spri2	pr6|256
001017  aa   777102 3520 04	epp2 	-446,ic		000121 = 606000000022
001020  aa  6 00376 2521 00	spri2	pr6|254
001021  aa  6 00354 6211 00	eax1 	pr6|236
001022  aa   024000 4310 07	fld  	10240,dl
001023  aa  6 00044 3701 20	epp4 	pr6|36,*
001024  la  4 00016 3521 20	epp2 	pr4|14,*		ioa_$rsnnl
001025  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 274
	     end;

001026  aa   000044 7100 04	tra  	36,ic		001072
						STATEMENT 1 ON LINE 275
	     else do;

						STATEMENT 1 ON LINE 276
		i = p -> lhe18;

001027  aa  2 00000 2351 00	lda  	pr2|0		b1.lhe18
001030  aa   000066 7730 00	lrl  	54
001031  aa  6 00254 7561 00	stq  	pr6|172		i
						STATEMENT 1 ON LINE 277
		j = p -> rhe18;

001032  aa  2 00000 2361 00	ldq  	pr2|0		b1.rhe18
001033  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
001034  aa  6 00255 7561 00	stq  	pr6|173		j
						STATEMENT 1 ON LINE 278
		call ioa_$rsnnl ("	Trap: call ^o, arg ^o", ili_ptr -> interpret_link_info.trap, lng, i, j);

001035  aa   777103 2370 04	ldaq 	-445,ic		000140 = 011124162141 160072040143
001036  aa  6 00354 7571 00	staq 	pr6|236
001037  aa   777103 2370 04	ldaq 	-445,ic		000142 = 141154154040 136157054040
001040  aa  6 00356 7571 00	staq 	pr6|238
001041  aa   777103 2370 04	ldaq 	-445,ic		000144 = 141162147040 136157000000
001042  aa  6 00360 7571 00	staq 	pr6|240
001043  aa  6 00354 3521 00	epp2 	pr6|236
001044  aa  6 00326 2521 00	spri2	pr6|214
001045  aa  7 00116 3521 00	epp2 	pr7|78		interpret_link_info.trap
001046  aa  6 00330 2521 00	spri2	pr6|216
001047  aa  6 00256 3521 00	epp2 	pr6|174		lng
001050  aa  6 00332 2521 00	spri2	pr6|218
001051  aa  6 00254 3521 00	epp2 	pr6|172		i
001052  aa  6 00334 2521 00	spri2	pr6|220
001053  aa  6 00255 3521 00	epp2 	pr6|173		j
001054  aa  6 00336 2521 00	spri2	pr6|222
001055  aa   777043 3520 04	epp2 	-477,ic		000120 = 524000000026
001056  aa  6 00340 2521 00	spri2	pr6|224
001057  aa   777043 3520 04	epp2 	-477,ic		000122 = 524000000060
001060  aa  6 00342 2521 00	spri2	pr6|226
001061  aa   777044 3520 04	epp2 	-476,ic		000125 = 404000000021
001062  aa  6 00344 2521 00	spri2	pr6|228
001063  aa  6 00346 2521 00	spri2	pr6|230
001064  aa  6 00350 2521 00	spri2	pr6|232
001065  aa  6 00324 6211 00	eax1 	pr6|212
001066  aa   024000 4310 07	fld  	10240,dl
001067  aa  6 00044 3701 20	epp4 	pr6|36,*
001070  la  4 00016 3521 20	epp2 	pr4|14,*		ioa_$rsnnl
001071  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 279
	     end;

						STATEMENT 1 ON LINE 280
	end;

						STATEMENT 1 ON LINE 282
	if old_version_sw then do;

001072  aa  6 00253 2351 00	lda  	pr6|171		old_version_sw
001073  aa   000024 6000 04	tze  	20,ic		001117
						STATEMENT 1 ON LINE 283
	     A_structure_ptr -> old_interpret_link_info.segment_name = ili_ptr -> interpret_link_info.segment_name;

001074  aa  6 00032 3735 20	epp7 	pr6|26,*
001075  aa  7 00002 3715 20	epp5 	pr7|2,*		A_structure_ptr
001076  aa  5 00000 3715 20	epp5 	pr5|0,*		A_structure_ptr
001077  aa  6 00234 3535 20	epp3 	pr6|156,*		ili_ptr
001100  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001101  aa  3 00002 00 0040	desc9a	pr3|2,32		interpret_link_info.segment_name
001102  aa  5 00000 00 0040	desc9a	pr5|0,32		old_interpret_link_info.segment_name
						STATEMENT 1 ON LINE 284
	     A_structure_ptr -> old_interpret_link_info.entry_point_name =
		substr(ili_ptr -> interpret_link_info.entry_point_name,1,33);

001103  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001104  aa  3 00012 00 0044	desc9a	pr3|10,36		interpret_link_info.entry_point_name
001105  aa  5 00010 00 0044	desc9a	pr5|8,36		old_interpret_link_info.entry_point_name
						STATEMENT 1 ON LINE 286
	     A_structure_ptr -> old_interpret_link_info.expression = ili_ptr -> interpret_link_info.expression;

001106  aa  3 00113 2351 00	lda  	pr3|75		interpret_link_info.expression
001107  aa  3 00114 2361 00	ldq  	pr3|76		interpret_link_info.expression
001110  aa  5 00021 7551 00	sta  	pr5|17		old_interpret_link_info.expression
001111  aa  5 00022 7561 00	stq  	pr5|18		old_interpret_link_info.expression
						STATEMENT 1 ON LINE 287
	     A_structure_ptr -> old_interpret_link_info.modifier = ili_ptr -> interpret_link_info.modifier;

001112  aa  3 00115 2351 00	lda  	pr3|77		interpret_link_info.modifier
001113  aa  5 00023 7551 00	sta  	pr5|19		old_interpret_link_info.modifier
						STATEMENT 1 ON LINE 288
	     A_structure_ptr -> old_interpret_link_info.trap = 
		substr(ili_ptr -> interpret_link_info.trap,1,32);

001114  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001115  aa  3 00116 00 0040	desc9a	pr3|78,32		interpret_link_info.trap
001116  aa  5 00024 00 0040	desc9a	pr5|20,32		old_interpret_link_info.trap
						STATEMENT 1 ON LINE 290
	end;

						STATEMENT 1 ON LINE 292
	return;

001117  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 307
     end interpret_link_;

  END PROCEDURE interpret_link_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
