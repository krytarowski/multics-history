	COMPILATION LISTING OF SEGMENT mu_sec_reg_user
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1124.64_Tue_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1976 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 mu_sec_reg_user: reg_user: procedure (ins_dbc_ptr, ins_rdbi_ptr, code);
       19 
       20 /*
       21*   This procedure checks for dead processes and registers users
       22*   and their associated relations, if applicable, at open time
       23**/
       24 
       25 /* HISTORY:
       26*
       27*   Written by O D Friesen for queued scope requests -- July 1977
       28*   Modified by A. N. Kepner, Feb 27, 1979 to correct reference to
       29*   error_table_$lock_wait_time_exceeded (was misspelled.)
       30*   Modified by A. N. Kepner, March 14, 1979 to remove the quiesce_sw
       31*   parameter and to add new users to the beginning (as opposed to the end)
       32*   of the list of open users.
       33*   Modified by M. Pierret 5 Feb 1980 to correct the use of set_lock_
       34*   and to de-queue dead procs.
       35*   Modified by M. Pierret 29 Feb 1980 to fix >one dead processes case.
       36*
       37*   80-12-12 Jim Gray : added initialization of pad areas in the user_list structure.
       38*
       39*   80-12-23 Jim Gray : added capture of error for no write permission
       40*   on the database control segment, rather than attempting a write
       41*   and winding up with an un-handled condition.
       42*
       43*   81-05-29 Jim Gray : modified to use new resultant model structures.
       44*
       45*   81-09-15 Davids: added the rtrim operator.  this  was  needed  so
       46*   that the module would compile when -prefix stringsize was used in
       47*   the call to pl1. The length of rm_rel_array.name.submodel was not
       48*   changed  to char (30) even though 30 characters is the max length
       49*   because the current length of 32 is hard-wired in to the code  in
       50*   several places.
       51*
       52*   83-05-20 Davids: explicitly declared builtins that were left implicitly
       53*   declared and deleted declarations to things that were no longer used.
       54**/
       55 
       56 	hold_ul_ptr = null;
       57 	dbc_ptr = ins_dbc_ptr;
       58 	rdbi_ptr = ins_rdbi_ptr;
       59 	code, icode, kode, num_filns = 0;
       60 	if dbc.trouble_switch
       61 	then do;
       62 		code = mdbm_error_$trouble_lock;
       63 		go to exit;
       64 	     end;
       65 
       66 	call set_lock_$lock (dbc.open_lock, mdbm_data_$lock_wait, code); /* lock the open table */
       67 	if code = error_table_$invalid_lock_reset |
       68 	     code = error_table_$locked_by_this_process
       69 	then code = 0;
       70 						/* ignore these error codes */
       71 	if code = error_table_$no_w_permission then do;
       72 		call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a^a^a",
       73 		     "No permission to set scope lock on """, rtrim (rm_db_info.db_path),
       74 		     ">", rtrim (mrds_data_$control_segment_name), """.");
       75 		goto exit;
       76 	     end;
       77 	else if code ^= 0 then do;
       78 		dbc.trouble_switch = "1"b;		/* prevent further openings while inconsistent */
       79 		goto exit;
       80 	     end;
       81 
       82 	on cleanup call clean_up;
       83 
       84 	call morgue (icode);			/* warning_flag will be examined later */
       85 	if icode ^= 0 then call error (icode);
       86 	call register_user (icode);
       87 
       88 	if warning_flag then dbc.dead_proc_flag = "1"b;
       89 	call set_lock_$unlock (dbc.open_lock, kode);
       90 	if icode ^= 0 then call error (icode);
       91 	else if kode ^= 0 then call error (kode);
       92 
       93 exit:	return;
       94 
       95 register_user: proc (icode);
       96 
       97 	dcl     i			 fixed bin;
       98 	dcl     icode		 fixed bin (35);
       99 	dcl     ptr_bit_string	 bit (72) based;	/* bit string format of pointer variable */
      100 
      101 	dbc.open_users = dbc.open_users + 1;
      102 	rmra_ptr = rm_db_info.ra_ptr;
      103 	num_filns = rm_rel_array.num_rels;
      104 	allocate user_list in (dbc.static_area) set (hold_ul_ptr);
      105 	unspec (hold_ul_ptr -> user_list) = "0"b;	/* zero pad areas */
      106 
      107 	ul_ptr = hold_ul_ptr;
      108 	call get_lock_id_ (user_list.db_lock_id);
      109 	if icode ^= 0 then call error (icode);
      110 						/* we must
      111*						   differentiate between
      112*						   different openings of the same data base
      113*						   by one process ... the pointer to the resultant
      114*						   data base info will serve as the tiebreaker in such cases */
      115 	user_list.rdbi_bits = addr (rdbi_ptr) -> ptr_bit_string;
      116 	user_list.num_filns = num_filns;
      117 	user_list.fil_list_ofs = NULL_OFS;
      118 	user_list.next_active_ofs = NULL_OFS;
      119 	user_list.next_waiting_ofs = NULL_OFS;
      120 	user_list.next_open_ofs = dbc.open_users_ofs;	/* Add user to list of data base
      121*						   open users. */
      122 	dbc.open_users_ofs = rel (ul_ptr);
      123 	user_list.group_id = get_group_id_ ();
      124 	user_list.open_mode = mdbm_data_$normal_mode;
      125 	user_list.bypass_count = 0;
      126 	user_list.allowance_count = 0;
      127 	user_list.process_id = get_process_id_ ();
      128 	user_list.ev_chn_id = 0;
      129 	user_list.dead_proc = "0"b;
      130 	user_list.dead_proc_conflict = "0"b;
      131 	user_list.priority_high = "0"b;
      132 	user_list.waiting_sw = "0"b;
      133 	user_list.active_sw = "0"b;
      134 	user_list.event_signal_sw = "0"b;
      135 	user_list.passive_sw = "1"b;			/* assume passivity */
      136 	do i = 1 to user_list.num_filns;
      137 	     user_list.file (i) = rtrim (rm_rel_array.name.submodel (i));
      138 						/* CHANGE 81-09-15 */
      139 	end;
      140 
      141      end register_user;
      142 
      143 morgue: proc (icode);
      144 
      145 /*
      146*   we are looking for dead processes which still have this data base open.
      147*   If a dead process is found then see if it has  a -permit stor, modify or delete
      148*   (denoted by dbc.passive_sw being turned OFF) on any relation.
      149*   In this case set a warning flag
      150*   to indicate that the data base is potentially infirm -- then go on and complete the opening process.
      151*
      152*   It is the user's choice whether to proceed or give up and call
      153*   the DBA.
      154*
      155*   If the dead process is passive, then de-queue it and continue
      156**/
      157 
      158 	dcl     icode		 fixed bin (35);
      159 
      160 
      161 	warning_flag = "0"b;
      162 	if dbc.open_users > 0 then do;
      163 		icode = 0;
      164 		ul_ptr = convert (dbc_ptr, dbc.open_users_ofs); /* look at all users who have the data base open */
      165 		do while (ul_ptr ^= null & icode = 0);
      166 
      167 /* determine whether the process represented by this user is dead or alive.
      168*   If it is dead then set_lock should return a status of invalid_lock_id.
      169*   If it is alive then set_lock should return a status of locked_by_this_process.
      170*   Any other status is an error .
      171**/
      172 
      173 		     de_queue_flag = "0"b;
      174 
      175 		     call dead_or_alive (icode);
      176 
      177 		     if de_queue_flag		/* If dead proc was de-queued... */
      178 		     then ul_ptr = next_ul_ptr;	/* ..then next ul ptr was saved */
      179 		     else if ul_ptr ^= null
      180 		     then ul_ptr = convert (dbc_ptr, user_list.next_open_ofs);
      181 
      182 		end;
      183 
      184 	     end;
      185 
      186      end morgue;
      187 
      188 
      189 dead_or_alive: proc (icode);
      190 
      191 	dcl     icode		 fixed bin (35);
      192 
      193 
      194 	icode = 0;
      195 	if user_list.dead_proc then status = DEAD;
      196 	else do;
      197 		status = ALIVE;
      198 		call set_lock_$lock ((user_list.db_lock_id), 0, state);
      199 		if state ^= 0 then do;
      200 			if state = error_table_$invalid_lock_reset /* locked by dead  process */
      201 			then status = DEAD;
      202 			else if state = error_table_$locked_by_this_process |
      203 				state = error_table_$lock_wait_time_exceeded
      204 			then status = ALIVE;
      205 			else icode = state;
      206 		     end;
      207 	     end;
      208 
      209 	if icode = 0
      210 	then if status = DEAD
      211 	     then if ^user_list.passive_sw
      212 		then do;
      213 			warning_flag = "1"b;
      214 			user_list.dead_proc = "1"b;
      215 		     end;
      216 
      217 		else do;
      218 			de_queue_flag = "1"b;
      219 			next_ul_ptr = convert (dbc_ptr, user_list.next_open_ofs); /* After user is dequeued */
      220 						/* we won't be able to get the next user */
      221 			call mu_de_queue_user (DQ_OPEN, FREE_FIL_LIST, dbc_ptr, ul_ptr, icode);
      222 			icode = 0;
      223 		     end;
      224 
      225 
      226      end dead_or_alive;
      227 
      228 convert: proc (a_ptr, ofs) returns (ptr);
      229 
      230 /* this procedure function converts an offset from "0"b to null
      231*   or from the offset value to a pointer value within the segment denoted by a_ptr
      232**/
      233 
      234 	dcl     result		 ptr;		/* the reultant pointer value */
      235 	dcl     a_ptr		 ptr;		/* ptr to the segment to which the offset refers */
      236 	dcl     ofs		 bit (18) unal;	/* the bit offset */
      237 
      238 	dcl     (null, ptr)		 builtin;
      239 
      240 	if ofs ^= NULL_OFS
      241 	then result = ptr (a_ptr, ofs);
      242 	else result = null;
      243 
      244 	return (result);
      245 
      246      end convert;
      247 
      248 clean_up: proc;
      249 	if hold_ul_ptr ^= null
      250 	then free hold_ul_ptr -> user_list in (dbc.static_area);
      251      end clean_up;
      252 
      253 error: proc (cd);
      254 	dcl     cd		 fixed bin (35);
      255 
      256 	code = cd;
      257 	if warning_flag then dbc.dead_proc_flag = "1"b;
      258 	call clean_up;
      259 	call set_lock_$unlock (dbc.open_lock, kode);
      260 	goto exit;
      261      end error;
      262 
      263 	dcl     code		 fixed bin (35);	/* standard status return code */
      264 	dcl     kode		 fixed bin (35);
      265 	dcl     state		 fixed bin (35);
      266 
      267 	dcl     status		 bit (1) unal;	/*  ON => process is alive; OFF => process is dead */
      268 
      269 	dcl     ins_dbc_ptr		 ptr;		/* points to data base control seg. */
      270 	dcl     ins_rdbi_ptr	 ptr;		/* points to resultant db info */
      271 
      272 	dcl     warning_flag	 bit (1) unal;	/* indicates a relation is in the scope of a dead process */
      273 	dcl     de_queue_flag	 bit (1) unal;	/* ON => dead proc was de-queued */
      274 	dcl     icode		 fixed bin (35);
      275 
      276 	dcl     hold_ul_ptr		 ptr;		/* holder for ptr to newly allocated user_list entry */
      277 	dcl     next_ul_ptr		 ptr;		/* holds next ul ptr if user de-queued */
      278 
      279 	dcl     (addr, fixed, null, rel, rtrim, unspec) builtin;
      280 	dcl     cleanup		 condition;
      281 
      282 /*	Multics subroutines		*/
      283 
      284 	dcl     set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35)),
      285 	        get_group_id_	 entry returns (char (32)),
      286 	        get_process_id_	 entry returns (bit (36)),
      287 	        get_lock_id_	 entry (bit (36) aligned),
      288 	        set_lock_$unlock	 entry (bit (36) aligned, fixed bin (35));
      289 
      290 /*	Other subroutines		*/
      291 
      292 	dcl     mu_de_queue_user	 entry (bit (1), bit (1), ptr, ptr, fixed bin (35));
      293 	declare sub_err_		 entry options (variable); /* reports error details */
      294 	declare continue		 char (1) init ("c") int static options (constant); /* dont stop after printing mesg */
      295 	declare info_ptr		 ptr init (null ());/* dummy argumnt */
      296 	declare return_value	 fixed bin (35) init (0); /* dummy argument */
      297 	declare caller_name		 char (32) init ("mu_sec_reg_user") int static options (constant); /* name of calling routine */
      298 	declare mrds_data_$control_segment_name char (32) ext; /* name of concurrenty control segment */
      299 
      300 
      301 /*		External data		*/
      302 
      303 	dcl     mdbm_data_$normal_mode fixed bin ext,
      304 	        mdbm_data_$lock_wait	 fixed bin ext,
      305 	        mdbm_error_$trouble_lock fixed bin (35) ext,
      306 	        error_table_$no_w_permission fixed bin (35) ext,
      307 	        error_table_$locked_by_this_process fixed bin (35) ext,
      308 	        error_table_$invalid_lock_reset fixed bin (35) ext,
      309 	        error_table_$lock_wait_time_exceeded fixed bin (35) ext,
      310 	        sys_info$max_seg_size	 fixed bin (35) ext;
      311 
  1     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  1     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* WARNING
  1    13*          If the rm_db_info structure is changed then the mrds_data_
  1    14*          item saved_res_version MUST be incremented to invalidate all
  1    15*          existing saved resultants
  1    16**/
  1    17 
  1    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  1    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  1    20*   resultant model that is created partially at database open  time,
  1    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  1    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  1    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  1    24*   to  provide  an  efficient  means  of  accessing  database  model
  1    25*   information, as seen from the possibly submodel view of the user,
  1    26*   and his current state of "files readied". it is the  secure  part
  1    27*   because  it  contains  the  model  information  which needs to be
  1    28*   protected  from  general  knowledge,  and   this   segment   will
  1    29*   eventually  be  capable  of  being in a lower ring. the structure
  1    30*   itself points to four arrays that are  allocated  in  it's  area,
  1    31*   that  in  turn point to the other structures mentions above, also
  1    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  1    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  1    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  1    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  1    36*   list of all known file names, the rm_rel_array only gets relation
  1    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  1    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  1    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  1    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  1    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  1    42*   file infos point to contained rel infos, the rel infos  point  to
  1    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  1    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  1    45*   foreign     keys    are    represented    by    the    structures
  1    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  1    47*   pathnames  of the model and submodel, if any, are also maintained
  1    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  1    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  1    50*   individual include files for  further  organization  information,
  1    51*   and particular data structures.
  1    52*
  1    53*   HISTORY:
  1    54*
  1    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  1    56*   so that define_area_ could be used to make it an extensible area
  1    57*
  1    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  1    59*   resultant in mu_database_index easier to keep, since no reference
  1    60*   to the area is needed.
  1    61*
  1    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  1    63*   resultant.
  1    64*
  1    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  1    66*   structure.
  1    67*
  1    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  1    69*   are  now  combined  into  the rel_array. Removed the control file
  1    70*   info which was unused. Added pointer  to  head  of  domain  list,
  1    71*   which is to be used to insure only one copy of each domain info.
  1    72*
  1    73*   83-05-19 Davids: Added the  saved_res_version element.
  1    74*
  1    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  1    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  1    77*   check, encode, or decode proc.
  1    78*
  1    79*   CAUTION: The structure entries from db_version to sm_path  should
  1    80*   not  be moved or have their declarations changed because they are
  1    81*   used in the handling of old version database openings.
  1    82*
  1    83*
  1    84**/
  1    85 
  1    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  1    87 	     2 data	      like rm_db_info_data,
  1    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  1    89 
  1    90      dcl	   rdbi_ptr	      ptr;
  1    91 
  1    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  1    93*						   like reference to it without getting the area as well */
  1    94 	     2 db_version	      fixed bin,		/* version no. of db */
  1    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  1    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  1    97 	     2 db_path	      char (168),		/* abs. path of db. */
  1    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  1    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  1   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  1   101 	     2 pad	      bit (34) unal,	/* for future use */
  1   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  1   103*                                                               dbcb and rdbi segments in the db dir */
  1   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  1   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  1   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  1   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  1   108 
  1   109 /* END mdbm_rm_db_info.incl.pl1 */
  1   110 
  1   111 
      312 
      313 
  2     1 /* BEGIN mdbm_rm_rel_array.incl.pl1 -- jaw, 8/9/78 */
  2     2 
  2     3 /* WARNING
  2     4*          If the rm_rel_array structure is changed then the mrds_data_
  2     5*          item saved_res_version MUST be incremented to invalidate all
  2     6*          existing saved resultants
  2     7**/
  2     8 
  2     9 /* HISTORY:
  2    10*
  2    11*   81-05-28 Jim Gray : added  model_name  and  file_id  as  part  of
  2    12*   combining   funtions   of   file_array  and  rel_array  into  one
  2    13*   structure. This will only allow 1 relation per file model now.
  2    14*   Also changed structure to allow more efficient searching
  2    15*   via and index builtin, rather than a programmed loop.
  2    16*   Search is now I = index(string(rm_rel_array.name), "!" || in_name)
  2    17*   with I = ((I - 1) / 33) + 1 to convert from a char to array index.
  2    18*
  2    19**/
  2    20 
  2    21 
  2    22 /* this structure is allocated in the static are of the structure
  2    23*   in  mdbm_rm_db_info.incl.pl1,  the secure portion of the database
  2    24*   resultant  model  upon  opening  the  database.  two  copies  are
  2    25*   allocated,  one for temporary relations, initially empty, and one
  2    26*   for relations known to the opener, which has a length  sufficient
  2    27*   for  all  relations known to the user, but whose names, etc. will
  2    28*   not be filled  in  until  the  file  containing  that  particular
  2    29*   relation  is readied. the rm_db_info structure contains a pointer
  2    30*   to the rel_arrays, and the array entries, when  "readied",  point
  2    31*   to  the  mdbm_rm_rel_info.incl.pl1  structures  containing  model
  2    32*   information about the relation, it's attributes, etc. */
  2    33 
  2    34 dcl 1 rm_rel_array aligned based (rmra_ptr),		/* array of open relations */
  2    35     2 num_rels fixed bin,				/* no. rels in db. */
  2    36     2 name (1:rm_num_rels_init refer (rm_rel_array.num_rels)) unal,
  2    37       3 mark char (1) unal,				/* separator character = "!" */
  2    38       3 submodel char (32) unal,			/* name of relation is submodel view, model opening => model name */
  2    39     2 rel_data (rm_num_rels_init refer (rm_rel_array.num_rels)),
  2    40       3 model_name char (30),				/* name of relation in model */
  2    41       3 ri_ptr ptr unal ;				/* pointer to rm_rel_info */
  2    42 
  2    43 dcl  rmra_ptr ptr;
  2    44 dcl  rm_num_rels_init fixed bin;
  2    45 
  2    46 /* END mdbm_rm_rel_array.incl.pl1 */
  2    47 
  2    48 
      314 
      315 
  3     1 /*	BEGIN INCLUDE FILE		mdbm_dbc.incl.pl1	08/23/78   odf			*/
  3     2 
  3     3 /* HISTORY:
  3     4*
  3     5*   Modified by odf for new version data bases in August 1978
  3     6*   Modified by Al Kepner, March 8, 1979 to add new flags for quiescing
  3     7*   Modified by M. Pierret, 8 April 1980 to look prettier, add pads
  3     8*   Modified by M. Pierret, 22 August 1980, grouping like fields (flags, offsets..)
  3     9*
  3    10*   80-11-19 Jim Gray : modified to change version number from 4  to 5 to allow
  3    11*   automatic update of dbc structures to new r-s-m-d-u scope codes from r-u.
  3    12**/
  3    13 
  3    14 dcl 1 dbc based (dbc_ptr),				/* data base control segment description */
  3    15     2 proper,
  3    16       3 version fixed bin,				/* version number of this structure */
  3    17       3 dtd_mrds fixed bin (71),			/* date time dumped by mrds utility */
  3    18       3 flags,
  3    19         4 trouble_switch bit (1) unal,			/* ON => ungraceful termination of a user process */
  3    20         4 dead_proc_flag bit (1) unal,			/* ON => dead process has access to part of data base */
  3    21         4 quiesce_sw bit (1) unal,			/* ON => db is quiesced for a administrative user */
  3    22         4 quiesce_db bit (1) unal,			/* ON => The entire data base is being quiesced. */
  3    23         4 quiesce_files bit (1) unal,			/* ON => A selected set of files is being quiesced. */
  3    24         4 pad bit (31) unal,				/* reserved for future use */
  3    25       3 quiesce_lock bit (36) aligned,			/* lock word for quiescing data base */
  3    26       3 wakeup_waiters fixed bin,			/* nbr users who have been sent a wakeup signal but have not yet
  3    27*						   received it */
  3    28       3 user_counts,
  3    29         4 open_users fixed bin,			/* nbr of users with data base open in any mode */
  3    30         4 active_users fixed bin,			/* nbr of users currently having a scope set */
  3    31         4 waiting_users fixed bin,			/* nbr of users waiting to set scope */
  3    32       3 open_lock bit (36) aligned,			/* lock word for opening data base */
  3    33       3 scope_lock bit (36) aligned,			/* lock word for setting and deleting scope */
  3    34       3 sa_size fixed bin (35),			/* size in words of static area  */
  3    35       3 pad2 bit (144),
  3    36       3 offsets,
  3    37         4 open_users_ofs bit (18) unal,			/* bit offset to list of users with data base currently open */
  3    38         4 active_users_ofs bit (18) unal,		/* bit offset to list of active users in shared mode */
  3    39         4 waiting_users_ofs bit (18) unal,		/* bit offset to list of waiting users in shared mode */
  3    40         4 obsolete bit (36) unal,			/* obsolete */
  3    41       3 pad3 bit (144),
  3    42     2 static_area area (sys_info$max_seg_size - fixed (rel (addr (dbc.static_area))) + 1);
  3    43 
  3    44 dcl  dbc_ptr ptr init (null ());
  3    45 
  3    46 dcl  VERSION_NBR fixed bin init (5) static internal options (constant);
  3    47 
  3    48 
  3    49 /* END mdbm_dcb.incl.pl1  */
  3    50 
  3    51 
      316 
      317 
  4     1 /* BEGIN mdbm_users.incl.pl1   -- odf, 08/10/78  */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(86-10-03,Dupuis), approve(86-10-21,MCR7562), audit(86-10-22,Blair),
  4     7*     install(86-10-23,MR12.0-1199):
  4     8*     Deleted the DEFAULT_WAIT variable.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 
  4    12 /* HISTORY:
  4    13*   Written by Oris Friesen August 10, 1978.
  4    14*   Modified by M. Pierret 13 December 1979, changing wakeup messages.
  4    15*   Modified by M. Pierret 13 April 1980 (Jason's birthday) to remove priority and wakeup structures
  4    16*   Modified by M. Pierret 13 August 1980 to group like fields (ids, offsets...)
  4    17*   Modified by Jim Gray - - 80-11-19, to add fields to fil_list to allow for complete
  4    18*   r-u-s-m-d scope codes, instead of just r-u.
  4    19*
  4    20*   80-12-10 Jim Gray : change names of fil_list prevent/permit modes
  4    21*   store to append_tuple, retreive to read_attr, delete to delete_tuple, modify to modify_attr,
  4    22*   and pad to mbz for consistency with MRDS access acl modes.
  4    23*
  4    24*   80-12-12 Jim Gray : Changed DEFAULT_WAIT declaration to fixed bin 35 from 71,
  4    25*   so that the wait_seconds fb35 overlay would not get 0 and thus never wait.
  4    26*   This is currently only used in mrds_dsl_set_fscope.
  4    27*
  4    28*   82-09-22 Davids: addede the opening_id element to the fil_list structure.
  4    29*   Put it at the end to make the new structure compatable with the old so
  4    30*   that testing could take place without having to recompile all the modules
  4    31*   that use the structure.
  4    32*
  4    33*   82-10-14 Davids: removed the opening_id element and added the rmri_ptr
  4    34*   element. This was done because set_fscope must be able to open the
  4    35*   relation if its not yet opened.
  4    36*   ---------------------------------------------------------------------------
  4    37*   DESCRIPTION:
  4    38*
  4    39*   The dbc contains the following information in its static area.
  4    40*   One group of information is composed of structures (user_list)
  4    41*   threaded 3 ways to form 3 lists. They are the list of active
  4    42*   scope users, of open users, and of users waiting to set scope.
  4    43*   The beginning of each of these lists is pointed to by fields
  4    44*   in the dbc proper.  All of these lists share the user_list structures,
  4    45*   and are completely contained within these structures, i.e., there
  4    46*   is no extraneous information in some knook in Scottsdale.
  4    47*
  4    48*   Associated with each user_list structure is a linked list of
  4    49*   fil_list structures.  The list is of all of the files (relations)
  4    50*   included in the user's scope request.  Unlike the user_list
  4    51*   structures which were shared by several different lists, the structures
  4    52*   in a user's file list are exclusively hers.  The entries contain
  4    53*   information about the scope request and the file name, and have
  4    54*   no real connection with the actual files in the resultant model.
  4    55*   --------------------------------------------------------------------------- */
  4    56 
  4    57 dcl 1 user_list based (ul_ptr),
  4    58     2 ids,
  4    59       3 group_id char (32),				/* group identifier of this user */
  4    60       3 process_id bit (36),				/* process identifier of this user */
  4    61       3 db_lock_id bit (36) aligned,			/* the unique lock id for this process --
  4    62*						   used to identify dead processes */
  4    63       3 ev_chn_id fixed bin (71),			/* event channel id for this process */
  4    64       3 rdbi_bits bit (72),				/* bit string of rdbi_ptr
  4    65*						   to allow concurrent openings by same process */
  4    66     2 flags,
  4    67       3 open_mode fixed bin unal,			/* the mode of the db. opening -- NORMAL or QUIESCE */
  4    68       3 passive_sw bit (1) unal,			/* OFF => -permit update on some file */
  4    69       3 active_sw bit (1) unal,			/* ON => user has a scope set */
  4    70       3 waiting_sw bit (1) unal,			/* ON => user is waiting for scope to be set */
  4    71       3 priority_high bit (1) unal,			/* obsolete */
  4    72       3 event_signal_sw bit (1) unal,			/* ON => user has been signalled thru event wait channel */
  4    73       3 dead_proc bit (1) unal,			/* ON => this user's process has died  and is inactive */
  4    74       3 dead_proc_conflict
  4    75      bit (1) unal,					/* this user's scope request conflicts with a dead process */
  4    76       3 queue_activ bit (1) unal,			/* activated from the waiting queue */
  4    77       3 pad bit (28),				/* reserved for future use */
  4    78     2 allowance_count fixed bin,			/* obsolete */
  4    79     2 bypass_count fixed bin,				/* obsolete */
  4    80     2 offsets,
  4    81       3 fil_list_ofs bit (18) unal,			/* bit offset to list of files in this user's scope request */
  4    82       3 next_active_ofs bit (18) unal,			/* bit offset to next user in this list of active scope users */
  4    83       3 next_waiting_ofs bit (18) unal,			/* bit offset to next user in user list waiting to set scope */
  4    84       3 next_open_ofs bit (18) unal,			/* bit offset to next user who has data base open in any mode */
  4    85     2 num_filns fixed bin,				/* number of files potentially accessible by this user */
  4    86     2 file (num_filns refer (user_list.num_filns)) char (30);
  4    87 						/* names of files accessible by this user */
  4    88 
  4    89 dcl 1 fil_list based (fl_ptr),			/* of files which a given user has specified for a scope  */
  4    90     2 name char (30),				/* data model name of the file specified in scope request */
  4    91     2 permits,					/* permit codes for scope setting or deleting */
  4    92       3 mbz1 bit (15) unal,
  4    93       3 modify_attr bit (1) unal,
  4    94       3 delete_tuple bit (1) unal,
  4    95       3 append_tuple bit (1) unal,
  4    96       3 update bit (1) unal,
  4    97       3 read_attr bit (1) unal,
  4    98     2 prevents,					/* prevent codes for scope setting or deleting */
  4    99       3 update bit (1) unal,
  4   100       3 read_attr bit (1) unal,
  4   101       3 append_tuple bit (1) unal,
  4   102       3 delete_tuple bit (1) unal,
  4   103       3 modify_attr bit (1) unal,
  4   104       3 mbz2 bit (29) unal,
  4   105     2 next_ofs bit (18) unal,				/* bit offset to next file entry for this user's scope request */
  4   106     2 rmri_ptr ptr;                                         /* pointer to the relation's rm_rel_info str */
  4   107                                                             /* needed so that the relation can be opened if need be */
  4   108 
  4   109 dcl  ul_ptr ptr init (null ());
  4   110 dcl  fl_ptr ptr init (null ());
  4   111 
  4   112 dcl  num_filns fixed bin;				/* number of files accessible by a given user */
  4   113 
  4   114 
  4   115 dcl  WAIT init (0) fixed bin int static options (constant);
  4   116 						/* the number of later user requests for which a user
  4   117*						   request will wait before it must be honored */
  4   118 dcl  NULL_OFS bit (18) init ("111111111111111111"b) unal int static options (constant);
  4   119 dcl  DQ_OPEN bit (1) unal init ("1"b) int static options (constant);
  4   120 						/* dequeue from open list */
  4   121 dcl  NO_DQ_OPEN bit (1) init ("0"b) int static options (constant);
  4   122 						/*  do not dequeue from open list */
  4   123 dcl  CHAR_Q_F char (8) init ("que_free") int static options (constant);
  4   124 dcl  QUE_FREE fixed bin (71);
  4   125 dcl  CHAR_ALARM char (8) init ("alarm___") int static options (constant);
  4   126 						/* wakeup up signal for time-out */
  4   127 dcl  ALARM fixed bin (71);
  4   128 dcl  FIRST_QUEUE bit (1) init ("1"b) int static options (constant);
  4   129 						/* this is the 1st time process will asleep */
  4   130 dcl  QUEUE_AGAIN bit (1) init ("0"b) int static options (constant);
  4   131 						/* being queued for the 2nd, 3rd ... time */
  4   132 dcl  SET bit (1) unal init ("1"b) int static options (constant);
  4   133 						/* check to see which scopes can be set */
  4   134 dcl  DEL bit (1) unal init ("0"b) int static options (constant);
  4   135 						/* check to see which scopes can be deleted */
  4   136 dcl  ALIVE init ("1"b) bit (1) unal int static options (constant);
  4   137 						/* process is alive */
  4   138 dcl  DEAD init ("0"b) bit (1) unal int static options (constant);
  4   139 						/* process is dead */
  4   140 dcl  Q_PRM init (3) fixed bin (35) int static options (constant);
  4   141 						/* permit retrieve, update */
  4   142 dcl  Q_PRV init (3) fixed bin (35) int static options (constant);
  4   143 						/* prevent retrieve, update */
  4   144 dcl  Q_PRM_BITS bit (2) unal init ("11"b) int static options (constant);
  4   145 						/* permit retrieve, update */
  4   146 dcl  Q_PRV_BITS bit (2) unal init ("11"b) int static options (constant);
  4   147 						/* prevent retrieve, update */
  4   148 dcl  REL_SEC bit (2) init ("11"b) int static options (constant);
  4   149 						/* measure wait time in relative seconds */
  4   150 dcl  FREE_FIL_LIST bit (1) unal init ("1"b) int static options (constant);
  4   151 						/* free this user's file lists */
  4   152 dcl  SAVE_FIL_LIST bit (1) unal init ("0"b) int static options (constant);
  4   153 						/* do not free this user's file lists */
  4   154 
  4   155 /* END mdbm_users.incl.pl1 */
  4   156 
      318 
      319 
      320      end mu_sec_reg_user;
      321 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1124.6  mu_sec_reg_user.pl1               >udd>sm>ds>w>ml>mu_sec_reg_user.pl1
312          1    08/04/88  2143.3  mdbm_rm_db_info.incl.pl1          >ldd>incl>mdbm_rm_db_info.incl.pl1
314          2    10/14/83  1709.1  mdbm_rm_rel_array.incl.pl1        >ldd>incl>mdbm_rm_rel_array.incl.pl1
316          3    10/14/83  1709.0  mdbm_dbc.incl.pl1                 >ldd>incl>mdbm_dbc.incl.pl1
318          4    10/23/86  1133.9  mdbm_users.incl.pl1               >ldd>incl>mdbm_users.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALIVE                                  constant        bit(1)                   initial packed unaligned dcl 4-136 ref 197 202
DEAD                                   constant        bit(1)                   initial packed unaligned dcl 4-138 ref 195 200 209
DQ_OPEN                         000012 constant        bit(1)                   initial packed unaligned dcl 4-119 set ref 221*
FREE_FIL_LIST                   000012 constant        bit(1)                   initial packed unaligned dcl 4-150 set ref 221*
NULL_OFS                               constant        bit(18)                  initial packed unaligned dcl 4-118 ref 117 118 119
                                                                                  240
a_ptr                                  parameter       pointer                  dcl 235 ref 228 240
active_sw                16(19)        based           bit(1)                   level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  133*
addr                                                   builtin function         dcl 279 ref 115
allowance_count          20            based           fixed bin(17,0)          level 2 dcl 4-57 set ref 126*
bypass_count             21            based           fixed bin(17,0)          level 2 dcl 4-57 set ref 125*
caller_name                     000000 constant        char(32)                 initial packed unaligned dcl 297 set ref 72*
cd                                     parameter       fixed bin(35,0)          dcl 254 ref 253 256
cleanup                         000112 stack reference condition                dcl 280 ref 82
code                                   parameter       fixed bin(35,0)          dcl 263 set ref 18 18 59* 62* 66* 67 67 67* 71 72*
                                                                                  77 256*
continue                        000010 constant        char(1)                  initial packed unaligned dcl 294 set ref 72*
data                                   based           structure                level 2 dcl 1-86
db_lock_id               11            based           bit(36)                  level 3 dcl 4-57 set ref 108* 198
db_path                   2            based           char(168)                level 3 dcl 1-86 ref 72 72
dbc                                    based           structure                level 1 unaligned dcl 3-14
dbc_ptr                         000130 automatic       pointer                  initial dcl 3-44 set ref 57* 60 66 78 88 89 3-44*
                                                                                  101 101 104 120 122 162 164* 164 179* 219* 221*
                                                                                  249 257 259
de_queue_flag                   000104 automatic       bit(1)                   packed unaligned dcl 273 set ref 173* 177 218*
dead_proc                16(23)        based           bit(1)                   level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  129* 195 214*
dead_proc_conflict       16(24)        based           bit(1)                   level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  130*
dead_proc_flag            4(01)        based           bit(1)                   level 4 packed packed unaligned dcl 3-14 set ref 88*
                                                                                  257*
error_table_$invalid_lock_reset 000042 external static fixed bin(35,0)          dcl 303 ref 67 200
error_table_$lock_wait_time_exceeded
                                000044 external static fixed bin(35,0)          dcl 303 ref 202
error_table_$locked_by_this_process
                                000040 external static fixed bin(35,0)          dcl 303 ref 67 202
error_table_$no_w_permission    000036 external static fixed bin(35,0)          dcl 303 ref 71
ev_chn_id                12            based           fixed bin(71,0)          level 3 dcl 4-57 set ref 128*
event_signal_sw          16(22)        based           bit(1)                   level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  134*
fil_list_ofs             22            based           bit(18)                  level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  117*
file                     25            based           char(30)                 array level 2 packed packed unaligned dcl 4-57 set
                                                                                  ref 137*
fl_ptr                          000134 automatic       pointer                  initial dcl 4-110 set ref 4-110*
flags                     4            based           structure                level 3 in structure "dbc" packed packed unaligned
                                                                                  dcl 3-14 in procedure "reg_user"
flags                    16            based           structure                level 2 in structure "user_list" packed packed
                                                                                  unaligned dcl 4-57 in procedure "reg_user"
get_group_id_                   000012 constant        entry                    external dcl 284 ref 123
get_lock_id_                    000016 constant        entry                    external dcl 284 ref 108
get_process_id_                 000014 constant        entry                    external dcl 284 ref 127
group_id                               based           char(32)                 level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  123*
hold_ul_ptr                     000106 automatic       pointer                  dcl 276 set ref 56* 104* 105 107 249 249
i                               000146 automatic       fixed bin(17,0)          dcl 97 set ref 136* 137 137*
icode                                  parameter       fixed bin(35,0)          dcl 98 in procedure "register_user" set ref 95 109
                                                                                  109*
icode                                  parameter       fixed bin(35,0)          dcl 158 in procedure "morgue" set ref 143 163* 165
                                                                                  175*
icode                                  parameter       fixed bin(35,0)          dcl 191 in procedure "dead_or_alive" set ref 189
                                                                                  194* 205* 209 221* 222*
icode                           000105 automatic       fixed bin(35,0)          dcl 274 in procedure "reg_user" set ref 59* 84* 85
                                                                                  85* 86* 90 90*
ids                                    based           structure                level 2 unaligned dcl 4-57
info_ptr                        000120 automatic       pointer                  initial dcl 295 set ref 72* 295*
ins_dbc_ptr                            parameter       pointer                  dcl 269 ref 18 18 57
ins_rdbi_ptr                           parameter       pointer                  dcl 270 ref 18 18 58
kode                            000100 automatic       fixed bin(35,0)          dcl 264 set ref 59* 89* 91 91* 259*
mdbm_data_$lock_wait            000032 external static fixed bin(17,0)          dcl 303 set ref 66*
mdbm_data_$normal_mode          000030 external static fixed bin(17,0)          dcl 303 ref 124
mdbm_error_$trouble_lock        000034 external static fixed bin(35,0)          dcl 303 ref 62
mrds_data_$control_segment_name 000026 external static char(32)                 packed unaligned dcl 298 ref 72 72
mu_de_queue_user                000022 constant        entry                    external dcl 292 ref 221
name                      1            based           structure                array level 2 packed packed unaligned dcl 2-34
next_active_ofs          22(18)        based           bit(18)                  level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  118*
next_open_ofs            23(18)        based           bit(18)                  level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  120* 179* 219*
next_ul_ptr                     000110 automatic       pointer                  dcl 277 set ref 177 219*
next_waiting_ofs         23            based           bit(18)                  level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  119*
null                                                   builtin function         dcl 238 in procedure "convert" ref 242
null                                                   builtin function         dcl 279 in procedure "reg_user" ref 56 295 3-44
                                                                                  4-109 4-110 165 179 249
num_filns                24            based           fixed bin(17,0)          level 2 in structure "user_list" dcl 4-57
                                                                                  in procedure "reg_user" set ref 104* 105 116* 136
                                                                                  249
num_filns                       000136 automatic       fixed bin(17,0)          dcl 4-112 in procedure "reg_user" set ref 59* 103*
                                                                                  104 104 116
num_rels                               based           fixed bin(17,0)          level 2 dcl 2-34 ref 103
offsets                  21            based           structure                level 3 in structure "dbc" packed packed unaligned
                                                                                  dcl 3-14 in procedure "reg_user"
offsets                  22            based           structure                level 2 in structure "user_list" packed packed
                                                                                  unaligned dcl 4-57 in procedure "reg_user"
ofs                                    parameter       bit(18)                  packed unaligned dcl 236 ref 228 240 240
open_lock                12            based           bit(36)                  level 3 dcl 3-14 set ref 66* 89* 259*
open_mode                16            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  124*
open_users                7            based           fixed bin(17,0)          level 4 dcl 3-14 set ref 101* 101 162
open_users_ofs           21            based           bit(18)                  level 4 packed packed unaligned dcl 3-14 set ref 120
                                                                                  122* 164*
passive_sw               16(18)        based           bit(1)                   level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  135* 209
priority_high            16(21)        based           bit(1)                   level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  131*
process_id               10            based           bit(36)                  level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  127*
proper                                 based           structure                level 2 unaligned dcl 3-14
ptr                                                    builtin function         dcl 238 ref 240
ptr_bit_string                         based           bit(72)                  packed unaligned dcl 99 ref 115
ra_ptr                  134            based           pointer                  level 3 dcl 1-86 ref 102
rdbi_bits                14            based           bit(72)                  level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  115*
rdbi_ptr                        000124 automatic       pointer                  dcl 1-90 set ref 58* 72 72 102 115
rel                                                    builtin function         dcl 279 ref 122
result                          000172 automatic       pointer                  dcl 234 set ref 240* 242* 244
return_value                    000122 automatic       fixed bin(35,0)          initial dcl 296 set ref 72* 296*
rm_db_info                             based           structure                level 1 dcl 1-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 1-92
rm_rel_array                           based           structure                level 1 dcl 2-34
rmra_ptr                        000126 automatic       pointer                  dcl 2-43 set ref 102* 103 137
rtrim                                                  builtin function         dcl 279 ref 72 72 72 72 137
set_lock_$lock                  000010 constant        entry                    external dcl 284 ref 66 198
set_lock_$unlock                000020 constant        entry                    external dcl 284 ref 89 259
state                           000101 automatic       fixed bin(35,0)          dcl 265 set ref 198* 199 200 202 202 205
static_area              30            based           area                     level 2 dcl 3-14 ref 104 249
status                          000102 automatic       bit(1)                   packed unaligned dcl 267 set ref 195* 197* 200* 202*
                                                                                  209
sub_err_                        000024 constant        entry                    external dcl 293 ref 72
submodel                  1(09)        based           char(32)                 array level 3 packed packed unaligned dcl 2-34 ref
                                                                                  137
trouble_switch            4            based           bit(1)                   level 4 packed packed unaligned dcl 3-14 set ref 60
                                                                                  78*
ul_ptr                          000132 automatic       pointer                  initial dcl 4-109 set ref 4-109* 107* 108 115 116
                                                                                  117 118 119 120 122 123 124 125 126 127 128 129
                                                                                  130 131 132 133 134 135 136 137 164* 165 177* 179
                                                                                  179* 179 195 198 209 214 219 221*
unspec                                                 builtin function         dcl 279 set ref 105*
user_counts               7            based           structure                level 3 unaligned dcl 3-14
user_list                              based           structure                level 1 unaligned dcl 4-57 set ref 104 105* 249
waiting_sw               16(20)        based           bit(1)                   level 3 packed packed unaligned dcl 4-57 set ref
                                                                                  132*
warning_flag                    000103 automatic       bit(1)                   packed unaligned dcl 272 set ref 88 161* 213* 257

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALARM                                  automatic       fixed bin(71,0)          dcl 4-127
CHAR_ALARM                             internal static char(8)                  initial packed unaligned dcl 4-125
CHAR_Q_F                               internal static char(8)                  initial packed unaligned dcl 4-123
DEL                                    internal static bit(1)                   initial packed unaligned dcl 4-134
FIRST_QUEUE                            internal static bit(1)                   initial packed unaligned dcl 4-128
NO_DQ_OPEN                             internal static bit(1)                   initial packed unaligned dcl 4-121
QUEUE_AGAIN                            internal static bit(1)                   initial packed unaligned dcl 4-130
QUE_FREE                               automatic       fixed bin(71,0)          dcl 4-124
Q_PRM                                  internal static fixed bin(35,0)          initial dcl 4-140
Q_PRM_BITS                             internal static bit(2)                   initial packed unaligned dcl 4-144
Q_PRV                                  internal static fixed bin(35,0)          initial dcl 4-142
Q_PRV_BITS                             internal static bit(2)                   initial packed unaligned dcl 4-146
REL_SEC                                internal static bit(2)                   initial packed unaligned dcl 4-148
SAVE_FIL_LIST                          internal static bit(1)                   initial packed unaligned dcl 4-152
SET                                    internal static bit(1)                   initial packed unaligned dcl 4-132
VERSION_NBR                            internal static fixed bin(17,0)          initial dcl 3-46
WAIT                                   internal static fixed bin(17,0)          initial dcl 4-115
fil_list                               based           structure                level 1 unaligned dcl 4-89
fixed                                                  builtin function         dcl 279
rm_num_rels_init                       automatic       fixed bin(17,0)          dcl 2-44
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 303

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        001062 constant        entry                    internal dcl 248 ref 82 258
convert                         001036 constant        entry                    internal dcl 228 ref 164 179 219
dead_or_alive                   000706 constant        entry                    internal dcl 189 ref 175
error                           001105 constant        entry                    internal dcl 253 ref 85 90 91 109
exit                            000405 constant        label                    dcl 93 ref 63 75 79 260
morgue                          000617 constant        entry                    internal dcl 143 ref 84
mu_sec_reg_user                 000076 constant        entry                    external dcl 18
reg_user                        000065 constant        entry                    external dcl 18
register_user                   000406 constant        entry                    internal dcl 95 ref 86

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1416        1464    1154        1426
Length      1744    1154        46         244     241           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
reg_user                            268 external procedure  is an external procedure.  
on unit on line 82                   64 on unit               
register_user                           internal procedure  shares stack frame of external procedure reg_user.  
morgue                                  internal procedure  shares stack frame of external procedure reg_user.  
dead_or_alive                           internal procedure  shares stack frame of external procedure reg_user.  
convert                                 internal procedure  shares stack frame of external procedure reg_user.  
clean_up                             64 internal procedure  is called by several nonquick procedures.  
error                                   internal procedure  shares stack frame of external procedure reg_user.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
reg_user                 000100 kode                        reg_user
                         000101 state                       reg_user
                         000102 status                      reg_user
                         000103 warning_flag                reg_user
                         000104 de_queue_flag               reg_user
                         000105 icode                       reg_user
                         000106 hold_ul_ptr                 reg_user
                         000110 next_ul_ptr                 reg_user
                         000120 info_ptr                    reg_user
                         000122 return_value                reg_user
                         000124 rdbi_ptr                    reg_user
                         000126 rmra_ptr                    reg_user
                         000130 dbc_ptr                     reg_user
                         000132 ul_ptr                      reg_user
                         000134 fl_ptr                      reg_user
                         000136 num_filns                   reg_user
                         000146 i                           register_user
                         000172 result                      convert

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac
enable_op           shorten_stack       ext_entry           int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_group_id_                 get_lock_id_                  get_process_id_               mu_de_queue_user
set_lock_$lock                set_lock_$unlock              sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$invalid_lock_reset                             error_table_$lock_wait_time_exceeded
error_table_$locked_by_this_process                         error_table_$no_w_permission  mdbm_data_$lock_wait
mdbm_data_$normal_mode        mdbm_error_$trouble_lock      mrds_data_$control_segment_name




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    295 000051       296 000053    3   44 000054    4  109 000055    4  110 000056        18 000061        56 000104
     57 000106        58 000112        59 000115        60 000121        62 000124        63 000127        66 000130
     67 000143        71 000153        72 000156        75 000313        77 000315        78 000317        79 000322
     82 000323        84 000345        85 000347        86 000353        88 000355        89 000362        90 000374
     91 000401        93 000405        95 000406       101 000410       102 000412       103 000415       104 000417
    105 000433       107 000443       108 000444       109 000454       115 000465       116 000471       117 000473
    118 000475       119 000477       120 000501       122 000505       123 000507       124 000516       125 000523
    126 000524       127 000525       128 000533       129 000536       130 000540       131 000542       132 000544
    133 000546       134 000550       135 000552       136 000554       137 000563       139 000614       141 000616
    143 000617       161 000621       162 000622       163 000625       164 000626       165 000640       173 000647
    175 000650       177 000656       179 000663       182 000704       186 000705       189 000706       194 000710
    195 000711       197 000717       198 000721       199 000737       200 000741       202 000746       205 000755
    209 000757       213 000770       214 000772       215 000774       218 000775       219 000777       221 001013
    222 001033       226 001035       228 001036       240 001040       242 001054       244 001056       248 001061
    249 001067       251 001104       253 001105       256 001107       257 001112       258 001117       259 001123
    260 001135


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
