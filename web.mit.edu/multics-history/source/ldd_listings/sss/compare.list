	COMPILATION LISTING OF SEGMENT compare
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/08/85  1156.7 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 /* format: off */
       10 
       11 
       12 compare: proc;
       13 
       14 /* The compare command and active function compares two segments.
       15*
       16*Usage:  compare pathA{|offsetA} pathB{|offsetB} {-control_args}
       17*
       18*
       19*Written 08/07/79 S. Herbst */
       20 
       21 /* Added -inhibit_error, -no_inhibit_error, -short, -total 09/25/84 S. Herbst */
       22 /* Changed to work on archive components 11/14/84 Steve Herbst */
       23 /* Fixed compilation warning about star_entry_ptr 12/03/84 Steve Herbst */
       24 /* Fixed equal convention broken by last installation 12/05/84 Steve Herbst */
       25 /* Backed out change to use max length if bit count = 0 12/11/84 Steve Herbst */
       26 
       27 
       28 /* Constants */
       29 
       30 dcl ME char (32) int static options (constant) init ("compare");
       31 dcl FORMAT (2) char (32) int static options (constant) init
       32 	("^4x^6o^2x^w", "^26x^6o^2x^w");
       33 dcl STRING_FORMAT (2) char (32) int static options (constant) init
       34 	("^4x^a", "^26x^a");
       35 dcl DOUBLE_FORMAT char (32) int static options (constant) init ("^4x^6o^2x^w^2x^6o^2x^w");
       36 dcl SKIP (2) char (32) int static options (constant) init
       37 	("^9x|^4x--------", "^31x|^4x--------");
       38 dcl DOUBLE_SKIP char (32) int static options (constant) init ("^9x|^4x--------^9x|^4x--------");
       39 
       40 /* Based */
       41 
       42 dcl word (0:max_len) bit (36) based;
       43 dcl area area based (area_ptr);
       44 
       45 /* Automatic */
       46 
       47 dcl 1 info (1:2),
       48    2 path char (194),
       49    2 msf_component_name char (32),
       50    2 (done_sw, msf_sw, noentry_sw) bit (1),
       51    2 (ptr, entries_ptr, names_ptr) ptr,
       52    2 (k, len, msf_count, msf_index, offset) fixed bin;
       53 
       54 dcl arg char (arg_len) based (arg_ptr);
       55 dcl return_arg char (return_len) varying based (return_ptr);
       56 dcl dn char (168);
       57 dcl (cn, cn1, en, en1, xcn, xen) char (32);
       58 dcl (bad_arg, bad_base) character (10) varying;
       59 
       60 dcl mask bit (36);
       61 dcl (af_sw, brief_sw, inhibit_error_sw, printed_header_sw, printed_component_header_sw, short_sw, totals_sw) bit (1);
       62 
       63 dcl (area_ptr, arg_ptr, return_ptr) ptr;
       64 
       65 dcl (arg_count, arg_len, block_len, col, common_len, dis_count) fixed bin;
       66 dcl (given_len, i, j, max_len, path_count, return_len, word_count) fixed bin;
       67 dcl max_length fixed bin (19);
       68 dcl bit_count fixed bin (24);
       69 dcl (code, octal_mask) fixed bin (35);
       70 
       71 /* External */
       72 
       73 dcl error_table_$bad_conversion fixed binary (35) external static;
       74 dcl error_table_$badopt fixed bin (35) ext;
       75 dcl error_table_$dirseg fixed bin (35) ext;
       76 dcl error_table_$item_too_big fixed bin (35) ext;
       77 dcl error_table_$noentry fixed bin (35) ext;
       78 dcl error_table_$nomatch fixed bin (35) ext;
       79 dcl error_table_$not_act_fnc fixed bin (35) ext;
       80 dcl error_table_$not_archive fixed bin (35) ext;
       81 
       82 /* Entries */
       83 
       84 dcl complain entry variable options (variable);
       85 dcl (active_fnc_err_, active_fnc_err_$suppress_name) entry options (variable);
       86 dcl (com_err_, com_err_$suppress_name) entry options (variable);
       87 dcl cu_$af_return_arg entry (fixed bin, ptr, fixed bin, fixed bin (35));
       88 dcl cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
       89 dcl cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
       90 dcl expand_pathname_$component entry (char (*), char (*), char (*), char (*), fixed bin (35));
       91 dcl get_equal_name_$component entry (char (*), char (*), char (*), char (*), char (*), char (*), fixed bin (35));
       92 dcl get_system_free_area_ entry returns (ptr);
       93 dcl hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (1), ptr, fixed bin (35));
       94 dcl hcs_$star_ entry (char(*), char(*), fixed bin(2), ptr, fixed bin, ptr, ptr, fixed bin(35));
       95 dcl hcs_$status_minf entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35));
       96 dcl hcs_$terminate_noname entry (ptr, fixed bin (35));
       97 dcl initiate_file_ entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
       98 dcl initiate_file_$component entry (char(*), char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
       99 dcl ioa_ entry options (variable);
      100 dcl pathname_ entry (char(*), char(*)) returns(char(168));
      101 dcl pathname_$component entry (char (*), char (*), char (*)) returns (char (168));
      102 dcl terminate_file_ entry (ptr, fixed bin(24), bit(*), fixed bin(35));
      103 
      104 dcl (addrel, divide, index, max, min, null, substr, sum, unspec) builtin;
      105 
      106 dcl cleanup condition;
      107 
      108 	call cu_$af_return_arg (arg_count, return_ptr, return_len, code);
      109 	if code = error_table_$not_act_fnc then do;
      110 	     af_sw = "0"b;
      111 	     complain = com_err_;
      112 	end;
      113 	else do;
      114 	     af_sw = "1"b;
      115 	     complain = active_fnc_err_;
      116 	end;
      117 
      118 	if arg_count < 2 then do;
      119 USAGE:	     if af_sw then call active_fnc_err_$suppress_name (0, ME,
      120 		"Usage:  [compare pathA{|offsetA} pathB{|offsetB} {-control_args}]");
      121 	     else call com_err_$suppress_name (0, ME,
      122 		"Usage:  compare pathA{|offsetA} pathB{|offsetB} {-control_args}");
      123 	     return;
      124 	end;
      125 
      126 	given_len, path_count = 0;
      127 	mask = (36) "1"b;
      128 	brief_sw, inhibit_error_sw, short_sw, totals_sw = "0"b;
      129 	unspec (info) = "0"b;
      130 	do i = 1 to 2;
      131 	     ptr (i), entries_ptr (i), names_ptr (i) = null;
      132 	end;
      133 	area_ptr = null;
      134 
      135 	on condition (cleanup) call clean_up;
      136 
      137 	do i = 1 to arg_count;
      138 
      139 	     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      140 
      141 	     if substr (arg, 1, 1) = "-" then
      142 		if arg = "-brief" | arg = "-bf" then
      143 		     if af_sw then go to BADOPT;
      144 		     else brief_sw = "1"b;
      145 		else if arg = "-inhibit_error" | arg = "-ihe" then
      146 		     if ^af_sw then go to BADOPT;
      147 		     else inhibit_error_sw = "1"b;
      148 		else if arg = "-long" | arg = "-lg" then
      149 		     if af_sw then go to BADOPT;
      150 		     else brief_sw = "0"b;
      151 		else if arg = "-length" | arg = "-ln" then do;
      152 		     i = i + 1;
      153 		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      154 		     if code ^= 0 then do;
      155 			call complain (0, ME, "No value specified for -length");
      156 			return;
      157 		     end;
      158 		     given_len = cv_oct_check_ (arg, code);
      159 		     bad_arg = "-length";
      160 		     if code ^= 0 then do;
      161 BAD_OCTAL_NUM:
      162 			bad_base = "an octal";
      163 BAD_NUM:			call complain (error_table_$bad_conversion, ME,
      164 			     "^a requires ^a number, not ^a.", bad_arg, bad_base, arg);
      165 			return;
      166 		     end;
      167 		     if given_len <= 0
      168 		     then do;
      169 			     bad_base = "a positive";
      170 			     go to BAD_NUM;
      171 			end;
      172 		end;
      173 		else if arg = "-mask" then do;
      174 		     i = i + 1;
      175 		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      176 		     if code ^= 0 then do;
      177 			call complain (0, ME, "No value specified for -mask");
      178 			return;
      179 		     end;
      180 		     octal_mask = cv_oct_check_ (arg, code);
      181 		     if code ^= 0
      182 		     then do;
      183 			     bad_arg = "-mask";
      184 			     go to BAD_OCTAL_NUM;
      185 			end;
      186 		     mask = unspec (octal_mask);
      187 		end;
      188 		else if arg = "-no_inhibit_error" | arg = "-nihe" then
      189 		     if ^af_sw then go to BADOPT;
      190 		     else inhibit_error_sw = "0"b;
      191 		else if arg = "-short" | arg = "-sh" then
      192 		     if af_sw then go to BADOPT;
      193 		     else short_sw = "1"b;
      194 		else if arg = "-totals" | arg = "-total" | arg = "-tt" then
      195 		     if af_sw then go to BADOPT;
      196 		     else totals_sw = "1"b;
      197 		else do;
      198 BADOPT:		     call complain (error_table_$badopt, ME, "^a", arg);
      199 		     return;
      200 		end;
      201 	     else do;
      202 		path_count = path_count + 1;
      203 		if path_count > 2 then go to USAGE;
      204 		call get_path (path_count);
      205 	     end;
      206 	end;
      207 
      208 	if path_count ^= 2 then go to USAGE;
      209 
      210 	if noentry_sw (1) | noentry_sw (2) then do;
      211 	     if inhibit_error_sw then do;
      212 		if noentry_sw (1) & noentry_sw (2) then do;
      213 		     call complain (error_table_$noentry, ME, "^/^5x^a^/^5x^a", path (1), path (2));
      214 		     go to RETURN;
      215 		end;
      216 		else do;
      217 		     return_arg = "false";  /* note that -inhibit_error is only allowed with active function */
      218 		     go to RETURN;
      219 		end;
      220 	     end;
      221 	     else do;
      222 		if noentry_sw (1) then i = 1;
      223 		else i = 2;
      224 		call complain (error_table_$noentry, ME, "^a", path (i));
      225 		go to RETURN;
      226 	     end;
      227 	end;
      228 
      229 	if ptr (1) = ptr (2) & ^msf_sw (1) & offset (1) = offset (2) then do;
      230 	     call complain (0, ME, "Attempt to compare data with itself.");
      231 	     call clean_up;
      232 	     return;
      233 	end;
      234 
      235 	if min (len (1), len (2)) = 0 & af_sw then do;	/* one or both zero length */
      236 	     if len (1) = len (2) then return_arg = "true";
      237 	     else return_arg = "false";
      238 	     call clean_up;
      239 	     return;
      240 	end;
      241 
      242 	dis_count, word_count = 0;
      243 	printed_header_sw = "0"b;
      244 
      245 	if ^msf_sw (1) & ^msf_sw (2) then call print_discrepancies ();  /* both are segments */
      246 	else do;
      247 	     if af_sw & msf_sw (1) ^= msf_sw (2) then do;
      248 		return_arg = "false";
      249 		go to RETURN;
      250 	     end;
      251 
      252 	     do while (^done_sw (1) & ^done_sw (2));
      253 		call get_next_msf_component (1);
      254 		call get_next_msf_component (2);
      255 		printed_component_header_sw = "0"b;
      256 		call print_discrepancies ();
      257 	     end;
      258 	     do i = 1 to 2;
      259 		if ^done_sw (i) then do;
      260 		     dis_count = dis_count + 1;
      261 		     if ^af_sw then call ioa_ ("Remaining components of MSF ^a", path (i));
      262 		     do while (^done_sw (i));
      263 			call get_next_msf_component (i);
      264 			word_count = word_count + len (i);
      265 			if ^af_sw then call ioa_ (STRING_FORMAT (i), get_msf_component_name (i));
      266 		     end;
      267 		end;
      268 	     end;
      269 	end;
      270 
      271 /* Print totals */
      272 
      273 	if af_sw then do;
      274 	     return_arg = "true";
      275 	     go to RETURN;
      276 	end;
      277 
      278 	if dis_count = 0 then call ioa_ ("No discrepancies.");
      279 	else call ioa_ ("^/Total ^d discrepanc^[ies^;y^], ^d word^[s^]",
      280 	     dis_count, dis_count > 1, word_count, word_count > 1);
      281 
      282 RETURN:	call clean_up;
      283 	return;
      284 
      285 clean_up: proc;
      286 
      287 dcl i fixed bin;
      288 
      289 	do i = 1 to 2;
      290 	     if ptr (i) ^= null then call terminate_file_ (ptr (i), 0, TERM_FILE_TERM, code);
      291 	     if entries_ptr (i) ^= null then free entries_ptr (i) -> star_entries in (area);
      292 	     if names_ptr (i) ^= null then free names_ptr (i) -> star_names in (area);
      293 	end;
      294 
      295 end clean_up;
      296 
      297 get_msf_component_name: proc (P_i) returns (char (64));
      298 
      299 /* Returns either "Segment" or "Component <name>" */
      300 
      301 dcl P_i fixed bin;
      302 
      303 	if ^msf_sw (P_i) then return ("Segment");
      304 	else return ("Component " || msf_component_name (P_i));
      305 
      306 end get_msf_component_name;
      307 
      308 get_next_msf_component: proc (P_i);
      309 
      310 /* Positions to next component of an MSF, turns on done_sw (P_i) if the last one. */
      311 /* For a segment, just turns on done_sw (P_i). */
      312 
      313 dcl P_i fixed bin;
      314 
      315 	if ^msf_sw (P_i) then done_sw (P_i) = "1"b;
      316 	else do;
      317 	     msf_index (P_i) = min (msf_index (P_i) + 1, msf_count (P_i));
      318 	     if msf_index (P_i) = msf_count (P_i) then done_sw (P_i) = "1"b;
      319 	     msf_component_name (P_i) =
      320 		names_ptr (P_i) -> star_names (entries_ptr (P_i) -> star_entries (msf_index (P_i)).nindex);
      321 
      322 	     call initiate_file_ (path (P_i), msf_component_name (P_i), R_ACCESS, ptr (P_i), bit_count, code);
      323 	     if code ^= 0 then do;
      324 		call complain (code, ME, "MSF component ^a", pathname_ (path (P_i), msf_component_name (P_i)));
      325 		go to RETURN;
      326 	     end;
      327 	     len (P_i) = divide (bit_count + 35, 36, 17, 0);
      328 	end;
      329 
      330 end get_next_msf_component;
      331 
      332 get_path: proc (P_i);
      333 
      334 dcl P_i fixed bin;
      335 
      336 	j = index (arg, "|");
      337 	if j = arg_len then do;			/* no offset after "|" */
      338 BAD_OFFSET:    call complain (code, ME, "Invalid offset in ^a", arg);
      339 	     goto RETURN;
      340 	end;
      341 
      342 	if j ^= 0 then do;
      343 	     offset (P_i) = cv_oct_check_ (substr (arg, j + 1), code);
      344 	     if code ^= 0 then do;
      345 		code = error_table_$bad_conversion;
      346 		goto BAD_OFFSET;
      347 	     end;
      348 	     arg_len = j - 1;
      349 	end;
      350 
      351 	call expand_pathname_$component (arg, dn, en, cn, code);
      352 	if code ^= 0 & code ^= error_table_$not_archive then do;
      353 	     call complain (code, ME, "^a", arg);
      354 	     go to RETURN;
      355 	end;
      356 
      357 	if P_i = 2 then do;
      358 	     call get_equal_name_$component (en1, cn1, en, cn, xen, xcn, code);
      359 	     if code ^= 0 then do;
      360 		call complain (code, ME, "^a^[::^a^] applied to ^a^[::^a^]",
      361 		     en, cn ^= "", cn, en1, cn1 ^= "", cn1);
      362 		go to RETURN;
      363 	     end;
      364 	     en = xen;
      365 	     cn = xcn;
      366 	end;
      367 	else do;
      368 	     en1 = en;				/* save for 2nd time through */
      369 	     cn1 = cn;
      370 	end;
      371 
      372 	path (P_i) = pathname_$component (dn, en, cn);	/* for an error message if needed */
      373 
      374 	if cn ^= "" then call initiate_file_$component (dn, en, cn, R_ACCESS, ptr (P_i), bit_count, code);
      375 	else call initiate_file_ (dn, en, R_ACCESS, ptr (P_i), bit_count, code);
      376 	if ptr (P_i) = null then do;
      377 	     if code = error_table_$dirseg then do;
      378 		bit_count = 0;
      379 		call hcs_$status_minf (dn, en, 1, 0, bit_count, 0);
      380 		if bit_count ^= 0 then do;		/* MSF */
      381 		     if offset (P_i) ^= 0 then do;
      382 			call complain (0, ME, "Nonzero offset not allowed for MSF ^a",
      383 			     pathname_ (dn, en));
      384 			go to RETURN;
      385 		     end;
      386 
      387 		     msf_sw (P_i) = "1"b;
      388 
      389 		     if area_ptr = null then area_ptr = get_system_free_area_ ();
      390 		     call hcs_$star_ (pathname_ (dn, en), "**", star_BRANCHES_ONLY, area_ptr,
      391 			star_entry_count, star_entry_ptr, star_names_ptr, code);
      392 		     if code ^= 0 then do;
      393 			if code = error_table_$nomatch then call complain (0, ME, "Invalid MSF ^a",
      394 			     pathname_ (dn, en));
      395 			else call complain (code, ME, "^a", pathname_ (dn, en));
      396 			go to RETURN;
      397 		     end;
      398 		     entries_ptr (P_i) = star_entry_ptr;
      399 		     names_ptr (P_i) = star_names_ptr;
      400 		     msf_count (P_i) = star_entry_count;
      401 		     msf_index (P_i) = 0;
      402 		     len (P_i) = 1;		/* ie., not zero length */
      403 		     return;
      404 		end;
      405 	     end;
      406 	     else if code = error_table_$noentry then do;
      407 		noentry_sw (P_i) = "1"b;
      408 		return;				/* catch this later */
      409 	     end;
      410 	     else call complain (code, ME, "^a", path (P_i));
      411 	     go to RETURN;
      412 	end;
      413 
      414 	len (P_i) = divide (bit_count + 35, 36, 17, 0);
      415 
      416 	if offset (P_i) > len (P_i) then do;
      417 	     call complain (error_table_$item_too_big, ME,"
      418 Base-zero offset ^d greater than length ^d", offset (P_i), len (P_i));
      419 	     go to RETURN;
      420 	end;
      421 
      422 end get_path;
      423 
      424 print_discrepancies: proc;
      425 
      426 	max_len = max (len (1), len (2));
      427 	common_len = min (len (1) - offset (1), len (2) - offset (2));
      428 	if given_len ^= 0 then do;
      429 	     max_len = min (max_len, offset (1) + given_len, offset (2) + given_len);
      430 	     common_len = min (common_len, given_len);
      431 	end;
      432 
      433 	k (1) = offset (1);
      434 	k (2) = offset (2);
      435 
      436 	block_len = 0;
      437 
      438 	do i = 1 to common_len;
      439 
      440 	     do i = i to common_len while
      441 		((mask & ptr (1) -> word (k (1) + block_len)) ^= (mask & ptr (2) -> word (k (2) + block_len)));
      442 		     block_len = block_len + 1;
      443 	     end;
      444 
      445 	     if block_len > 0 then do;		/* block of discrepancies */
      446 
      447 		if af_sw then do;
      448 		     return_arg = "false";
      449 		     go to RETURN;
      450 		end;
      451 
      452 		if ^printed_header_sw then call print_header;
      453 
      454 		if ^printed_component_header_sw then do;
      455 		     printed_component_header_sw = "1"b;
      456 		     if (msf_sw (1) | msf_sw (2)) & ^totals_sw then
      457 			call ioa_ ("^a / ^a:", get_msf_component_name (1), get_msf_component_name (2));
      458 		end;
      459 
      460 		dis_count = dis_count + 1;
      461 		word_count = word_count + block_len;
      462 
      463 		if short_sw | totals_sw then do;
      464 		     if ^totals_sw then call ioa_ ("^5d word^[s^; ^] at: ^6o", block_len, block_len > 1, k (1));
      465 		     k (1) = k (1) + block_len;
      466 		     k (2) = k (2) + block_len;
      467 		end;
      468 		else if block_len > 3 & brief_sw then do;
      469 		     call ioa_ (DOUBLE_FORMAT,
      470 			k (1), ptr (1) -> word (k (1)),
      471 			k (2), ptr (2) -> word (k (2)));
      472 		     call ioa_ (DOUBLE_SKIP);
      473 		     k (1) = k (1) + block_len;	/* skip block */
      474 		     k (2) = k (2) + block_len;
      475 		     call ioa_ (DOUBLE_FORMAT,
      476 			k (1) - 1, ptr (1) -> word (k (1) - 1),
      477 			k (2) - 1, ptr (2) -> word (k (2) - 1));
      478 		end;
      479 		else do;
      480 		     do j = 1 to block_len;
      481 			call ioa_ (DOUBLE_FORMAT,
      482 			     k (1), ptr (1) -> word (k (1)),
      483 			     k (2), ptr (2) -> word (k (2)));
      484 			k (1) = k (1) + 1;		/* skip block */
      485 			k (2) = k (2) + 1;
      486 		     end;
      487 		end;
      488 
      489 		if i <= common_len then do;		/* skip matching word ending the block */
      490 		     k (1) = k (1) + 1;
      491 		     k (2) = k (2) + 1;
      492 		end;
      493 
      494 		block_len = 0;
      495 	     end;
      496 
      497 	     else do;				/* no discrepancy, skip 1 matching word */
      498 		k (1) = k (1) + 1;
      499 		k (2) = k (2) + 1;
      500 	     end;
      501 	end;
      502 
      503 	if max_len > max (k (1), k (2)) then do;	/* print remaining words of longer seg */
      504 
      505 	     if af_sw then do;
      506 		return_arg = "false";
      507 		go to RETURN;
      508 	     end;
      509 
      510 	     if ^printed_header_sw then call print_header;
      511 	     if min (len (1), len (2)) = 0 then dis_count = dis_count + 1;
      512 	     else if (mask & ptr (1) -> word (k (1) - 1)) = (mask & ptr (2) -> word (k (2) - 1)) then
      513 		dis_count = dis_count + 1;		/* not continuation of previous discrepancy */
      514 	     if len (1) > len (2) then col = 1;
      515 	     else col = 2;
      516 	     block_len = max_len - k (col);
      517 	     word_count = word_count + block_len;
      518 
      519 	     if totals_sw then;
      520 	     else if short_sw then call ioa_ ("^5d word^[s^; ^] at: ^6o (file ^d)",
      521 		block_len, block_len > 1, k (col), col);
      522 	     else if block_len > 3 & brief_sw then do;
      523 		call ioa_ (FORMAT (col), k (col), ptr (col) -> word (k (col)));
      524 		call ioa_ (SKIP (col));
      525 		call ioa_ (FORMAT (col), max_len - 1, ptr (col) -> word (max_len - 1));
      526 	     end;
      527 	     else do j = k (col) to max_len - 1;
      528 		call ioa_ (FORMAT (col), j, ptr (col) -> word (j));
      529 	     end;
      530 	end;
      531 
      532 end print_discrepancies;
      533 
      534 print_header: proc;
      535 
      536 	printed_header_sw = "1"b;
      537 	if short_sw | totals_sw then return;
      538 	call ioa_ ("Discrepancies:");
      539 	call ioa_ ("^4xoffset^4xcontents^4xoffset^4xcontents");
      540 
      541 end print_header;
      542 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      543 
      544 
  2     1 /* BEGIN INCLUDE FILE . . . star_structures.incl.pl1 */
  2     2 
  2     3 /* This include file contains structures for the hcs_$star_,
  2     4*   hcs_$star_list_ and hcs_$star_dir_list_ entry points.
  2     5*
  2     6*   Written 23 October 1978 by Monte Davidoff.
  2     7*   Modified January 1979 by Michael R. Jordan to use unsigned and different pointers for different structures.
  2     8*   Modified June 1981 by C. Hornig to count link pathnames more efficiently.
  2     9**/
  2    10 
  2    11 /* automatic */
  2    12 
  2    13 declare  star_branch_count fixed binary;		/* hcs_$star_list_, hcs_$star_dir_list_: matching branch count */
  2    14 declare  star_entry_count fixed binary;			/* hcs_$star_: number of matching entries */
  2    15 declare  star_entry_ptr pointer;			/* hcs_$star_: pointer to array of entry information */
  2    16 declare  star_list_branch_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to array of info */
  2    17 declare  star_link_count fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: matching link count */
  2    18 declare  star_linkx fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: index into star_links */
  2    19 declare  star_names_ptr pointer;			/* hcs_$star_: pointer to array of entry names */
  2    20 declare  star_list_names_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to entry names */
  2    21 declare  star_select_sw fixed binary (3);		/* hcs_$star_list_, hcs_$star_dir_list_: what info to return */
  2    22 
  2    23 /* based */
  2    24 
  2    25 /* hcs_$star_ entry structure */
  2    26 
  2    27 declare 1 star_entries (star_entry_count) aligned based (star_entry_ptr),
  2    28         2 type fixed binary (2) unsigned unaligned,
  2    29 						/* storage system type */
  2    30         2 nnames fixed binary (16) unsigned unaligned,
  2    31 						/* number of names of entry that match star_name */
  2    32         2 nindex fixed binary (18) unsigned unaligned;
  2    33 						/* index of first name in star_names */
  2    34 
  2    35 /* hcs_$star_ name structure */
  2    36 
  2    37 declare  star_names (sum (star_entries (*).nnames)) char (32) based (star_names_ptr);
  2    38 
  2    39 /* hcs_$star_list_ branch structure */
  2    40 
  2    41 declare 1 star_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  2    42         2 type fixed binary (2) unsigned unaligned,
  2    43 						/* storage system type */
  2    44         2 nnames fixed binary (16) unsigned unaligned,
  2    45 						/* number of names of entry that match star_name */
  2    46         2 nindex fixed binary (18) unsigned unaligned,
  2    47 						/* index of first name in star_list_names */
  2    48         2 dtcm bit (36) unaligned,			/* date-time contents of branch were last modified */
  2    49         2 dtu bit (36) unaligned,			/* date-time branch was last used */
  2    50         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  2    51         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  2    52         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  2    53         2 pad bit (7) unaligned,
  2    54         2 records fixed binary (18) unsigned unaligned;
  2    55 						/* records used by branch */
  2    56 
  2    57 /* hcs_$star_dir_list_ branch structure */
  2    58 
  2    59 declare 1 star_dir_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  2    60         2 type fixed binary (2) unsigned unaligned,
  2    61 						/* storage system type */
  2    62         2 nnames fixed binary (16) unsigned unaligned,
  2    63 						/* number of names of entry that match star_name */
  2    64         2 nindex fixed binary (18) unsigned unaligned,
  2    65 						/* index of first name in star_list_names */
  2    66         2 dtem bit (36) unaligned,			/* date-time directory entry of branch was last modified */
  2    67         2 pad bit (36) unaligned,
  2    68         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  2    69         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  2    70         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  2    71         2 bit_count fixed binary (24) unaligned;
  2    72 						/* bit count of the branch */
  2    73 
  2    74 /* hcs_$star_list_ and hcs_$star_dir_list_ link structure */
  2    75 
  2    76 declare 1 star_links (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  2    77         2 type fixed binary (2) unsigned unaligned,
  2    78 						/* storage system type */
  2    79         2 nnames fixed binary (16) unsigned unaligned,
  2    80 						/* number of names of entry that match star_name */
  2    81         2 nindex fixed binary (18) unsigned unaligned,
  2    82 						/* index of first name in star_list_names */
  2    83         2 dtem bit (36) unaligned,			/* date-time link was last modified */
  2    84         2 dtd bit (36) unaligned,			/* date-time the link was last dumped */
  2    85         2 pathname_len fixed binary (18) unsigned unaligned,
  2    86 						/* length of the pathname of the link */
  2    87         2 pathname_index fixed binary (18) unsigned unaligned;
  2    88 						/* index of start of pathname in star_list_names */
  2    89 
  2    90 /* hcs_$star_list_ and hcs_$star_dir_list_ name array */
  2    91 
  2    92 declare  star_list_names char (32) based (star_list_names_ptr)
  2    93 	dimension (star_links (star_branch_count + star_link_count).nindex
  2    94 	 + star_links (star_branch_count + star_link_count).nnames
  2    95 	 + divide (star_links (star_branch_count + star_link_count).pathname_len + 31, 32, 17, 0)
  2    96 	   * binary (
  2    97 	     (star_links (star_branch_count + star_link_count).type = star_LINK)
  2    98 	     & (star_select_sw >= star_LINKS_ONLY_WITH_LINK_PATHS), 1));
  2    99 
  2   100 /* hcs_$star_list_ and hcs_$star_dir_list_ link pathname */
  2   101 
  2   102 declare  star_link_pathname char (star_links (star_linkx).pathname_len)
  2   103          based (addr (star_list_names (star_links (star_linkx).pathname_index)));
  2   104 
  2   105 /* internal static */
  2   106 
  2   107 /* star_select_sw values */
  2   108 
  2   109 declare  star_LINKS_ONLY fixed binary (2) internal static options (constant) initial (1);
  2   110 declare  star_BRANCHES_ONLY fixed binary (2) internal static options (constant) initial (2);
  2   111 declare  star_ALL_ENTRIES fixed binary (2) internal static options (constant) initial (3);
  2   112 declare  star_LINKS_ONLY_WITH_LINK_PATHS
  2   113          fixed binary (3) internal static options (constant) initial (5);
  2   114 declare  star_ALL_ENTRIES_WITH_LINK_PATHS
  2   115          fixed binary (3) internal static options (constant) initial (7);
  2   116 
  2   117 /* storage system types */
  2   118 
  2   119 declare  star_LINK fixed binary (2) unsigned internal static options (constant) initial (0);
  2   120 declare  star_SEGMENT fixed binary (2) unsigned internal static options (constant) initial (1);
  2   121 declare  star_DIRECTORY fixed binary (2) unsigned internal static options (constant) initial (2);
  2   122 
  2   123 /* END INCLUDE FILE . . . star_structures.incl.pl1 */
      545 
      546 
  3     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  3     2 /* format: style2,^inddcls,idind32 */
  3     3 
  3     4 declare 1 terminate_file_switches	based,
  3     5 	2 truncate		bit (1) unaligned,
  3     6 	2 set_bc			bit (1) unaligned,
  3     7 	2 terminate		bit (1) unaligned,
  3     8 	2 force_write		bit (1) unaligned,
  3     9 	2 delete			bit (1) unaligned;
  3    10 
  3    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  3    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  3    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  3    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  3    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  3    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  3    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  3    18 
  3    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      547 
      548 
      549 
      550 end compare;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/08/85  1128.7  compare.pl1                       >spec>on>41-15>compare.pl1
543          1    04/08/85  1113.3  access_mode_values.incl.pl1       >spec>on>41-15>access_mode_values.incl.pl1
545          2    06/10/82  1045.5  star_structures.incl.pl1          >ldd>include>star_structures.incl.pl1
547          3    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DOUBLE_FORMAT                   000031 constant        char(32)                 initial unaligned dcl 35 set ref 469* 475* 481*
DOUBLE_SKIP                     000001 constant        char(32)                 initial unaligned dcl 38 set ref 472*
FORMAT                          000061 constant        char(32)                 initial array unaligned dcl 31 set ref 523* 525*
                                                                                  528*
ME                              000101 constant        char(32)                 initial unaligned dcl 30 set ref 119* 121* 155* 163*
                                                                                  177* 198* 213* 224* 230* 324* 338* 353* 360* 382*
                                                                                  393* 395* 410* 417*
P_i                                    parameter       fixed bin(17,0)          dcl 334 in procedure "get_path" ref 332 343 357 372
                                                                                  374 375 376 381 387 398 399 400 401 402 407 410
                                                                                  414 416 416 417 417
P_i                                    parameter       fixed bin(17,0)          dcl 313 in procedure "get_next_msf_component" ref
                                                                                  308 315 315 317 317 317 318 318 318 319 319 319
                                                                                  319 322 322 322 324 324 324 324 327
P_i                                    parameter       fixed bin(17,0)          dcl 301 in procedure "get_msf_component_name" ref
                                                                                  297 303 304
R_ACCESS                        000163 constant        bit(3)                   initial unaligned dcl 1-11 set ref 322* 374* 375*
SKIP                            000011 constant        char(32)                 initial array unaligned dcl 36 set ref 524*
STRING_FORMAT                   000041 constant        char(32)                 initial array unaligned dcl 33 set ref 265*
TERM_FILE_TERM                  000000 constant        bit(3)                   initial unaligned dcl 3-14 set ref 290*
active_fnc_err_                 000030 constant        entry                    external dcl 85 ref 115
active_fnc_err_$suppress_name   000032 constant        entry                    external dcl 85 ref 119
af_sw                           000457 automatic       bit(1)                   unaligned dcl 61 set ref 110* 114* 119 141 145 148
                                                                                  188 191 194 235 247 261 265 273 447 505
area                                   based           area(1024)               dcl 43 ref 291 292
area_ptr                        000466 automatic       pointer                  dcl 63 set ref 133* 291 292 389 389* 390*
arg                                    based           char                     unaligned dcl 54 set ref 141 141 141 145 145 148 148
                                                                                  151 151 158* 163* 173 180* 188 188 191 191 194 194
                                                                                  194 198* 336 338* 343 343 351* 353*
arg_count                       000474 automatic       fixed bin(17,0)          dcl 65 set ref 108* 118 137
arg_len                         000475 automatic       fixed bin(17,0)          dcl 65 set ref 139* 141 141 141 145 145 148 148 151
                                                                                  151 153* 158 158 163 163 173 175* 180 180 188 188
                                                                                  191 191 194 194 194 198 198 336 337 338 338 343
                                                                                  343 348* 351 351 353 353
arg_ptr                         000470 automatic       pointer                  dcl 63 set ref 139* 141 141 141 145 145 148 148 151
                                                                                  151 153* 158 163 173 175* 180 188 188 191 191 194
                                                                                  194 194 198 336 338 343 343 351 353
bad_arg                         000446 automatic       varying char(10)         dcl 58 set ref 159* 163* 183*
bad_base                        000452 automatic       varying char(10)         dcl 58 set ref 161* 163* 169*
bit_count                       000511 automatic       fixed bin(24,0)          dcl 68 set ref 322* 327 374* 375* 378* 379* 380 414
block_len                       000476 automatic       fixed bin(17,0)          dcl 65 set ref 436* 440 440 442* 442 445 461 464*
                                                                                  464 465 466 468 473 474 480 494* 516* 517 520* 520
                                                                                  522
brief_sw                        000460 automatic       bit(1)                   unaligned dcl 61 set ref 128* 144* 150* 468 522
cleanup                         000520 stack reference condition                dcl 106 ref 135
cn                              000366 automatic       char(32)                 unaligned dcl 57 set ref 351* 358* 360 360* 365* 369
                                                                                  372* 374 374*
cn1                             000376 automatic       char(32)                 unaligned dcl 57 set ref 358* 360 360* 369*
code                            000512 automatic       fixed bin(35,0)          dcl 69 set ref 108* 109 139* 153* 154 158* 160 175*
                                                                                  176 180* 181 290* 322* 323 324* 338* 343* 344 345*
                                                                                  351* 352 352 353* 358* 359 360* 374* 375* 377 390*
                                                                                  392 393 395* 406 410*
col                             000477 automatic       fixed bin(17,0)          dcl 65 set ref 514* 515* 516 520 520* 523 523 523
                                                                                  523 524 525 525 527 528 528
com_err_                        000034 constant        entry                    external dcl 86 ref 111
com_err_$suppress_name          000036 constant        entry                    external dcl 86 ref 121
common_len                      000500 automatic       fixed bin(17,0)          dcl 65 set ref 427* 430* 430 438 440 489
complain                        000514 automatic       entry variable           dcl 84 set ref 111* 115* 155 163 177 198 213 224 230
                                                                                  324 338 353 360 382 393 395 410 417
cu_$af_return_arg               000040 constant        entry                    external dcl 87 ref 108
cu_$arg_ptr                     000042 constant        entry                    external dcl 88 ref 139 153 175
cv_oct_check_                   000044 constant        entry                    external dcl 89 ref 158 180 343
dis_count                       000501 automatic       fixed bin(17,0)          dcl 65 set ref 242* 260* 260 278 279* 279 460* 460
                                                                                  511* 511 512* 512
divide                                                 builtin function         dcl 104 ref 327 414
dn                              000314 automatic       char(168)                unaligned dcl 56 set ref 351* 372* 374* 375* 379*
                                                                                  382* 382* 390* 390* 393* 393* 395* 395*
done_sw                  70(18) 000100 automatic       bit(1)                   array level 2 packed unaligned dcl 47 set ref 252
                                                                                  252 259 262 315* 318*
en                              000406 automatic       char(32)                 unaligned dcl 57 set ref 351* 358* 360* 364* 368
                                                                                  372* 374* 375* 379* 382* 382* 390* 390* 393* 393*
                                                                                  395* 395*
en1                             000416 automatic       char(32)                 unaligned dcl 57 set ref 358* 360* 368*
entries_ptr              74     000100 automatic       pointer                  array level 2 dcl 47 set ref 131* 291 291 319 398*
error_table_$bad_conversion     000010 external static fixed bin(35,0)          dcl 73 set ref 163* 345
error_table_$badopt             000012 external static fixed bin(35,0)          dcl 74 set ref 198*
error_table_$dirseg             000014 external static fixed bin(35,0)          dcl 75 ref 377
error_table_$item_too_big       000016 external static fixed bin(35,0)          dcl 76 set ref 417*
error_table_$noentry            000020 external static fixed bin(35,0)          dcl 77 set ref 213* 224* 406
error_table_$nomatch            000022 external static fixed bin(35,0)          dcl 78 ref 393
error_table_$not_act_fnc        000024 external static fixed bin(35,0)          dcl 79 ref 109
error_table_$not_archive        000026 external static fixed bin(35,0)          dcl 80 ref 352
expand_pathname_$component      000046 constant        entry                    external dcl 90 ref 351
get_equal_name_$component       000050 constant        entry                    external dcl 91 ref 358
get_system_free_area_           000052 constant        entry                    external dcl 92 ref 389
given_len                       000502 automatic       fixed bin(17,0)          dcl 66 set ref 126* 158* 167 428 429 429 430
hcs_$star_                      000054 constant        entry                    external dcl 94 ref 390
hcs_$status_minf                000056 constant        entry                    external dcl 95 ref 379
i                               000100 automatic       fixed bin(17,0)          dcl 287 in procedure "clean_up" set ref 289* 290 290
                                                                                  291 291 292 292*
i                               000503 automatic       fixed bin(17,0)          dcl 66 in procedure "compare" set ref 130* 131 131
                                                                                  131* 137* 139* 152* 152 153* 174* 174 175* 222*
                                                                                  223* 224 258* 259 261 262 263* 264 265 265* 265*
                                                                                  438* 440* 440* 489*
index                                                  builtin function         dcl 104 ref 336
info                            000100 automatic       structure                array level 1 unaligned dcl 47 set ref 129*
inhibit_error_sw                000461 automatic       bit(1)                   unaligned dcl 61 set ref 128* 147* 190* 211
initiate_file_                  000060 constant        entry                    external dcl 97 ref 322 375
initiate_file_$component        000062 constant        entry                    external dcl 98 ref 374
ioa_                            000064 constant        entry                    external dcl 99 ref 261 265 278 279 456 464 469 472
                                                                                  475 481 520 523 524 525 528 538 539
j                               000504 automatic       fixed bin(17,0)          dcl 66 set ref 336* 337 342 343 343 348 480* 527*
                                                                                  528* 528*
k                       100     000100 automatic       fixed bin(17,0)          array level 2 dcl 47 set ref 433* 434* 440 440 464*
                                                                                  465* 465 466* 466 469* 469 469* 469 473* 473 474*
                                                                                  474 475 475 475 475 481* 481 481* 481 484* 484
                                                                                  485* 485 490* 490 491* 491 498* 498 499* 499 503
                                                                                  503 512 512 516 520* 523* 523 527
len                     101     000100 automatic       fixed bin(17,0)          array level 2 dcl 47 set ref 235 235 236 236 264
                                                                                  327* 402* 414* 416 417* 426 426 427 427 511 511
                                                                                  514 514
mask                            000456 automatic       bit(36)                  unaligned dcl 60 set ref 127* 186* 440 440 512 512
max                                                    builtin function         dcl 104 ref 426 503
max_len                         000505 automatic       fixed bin(17,0)          dcl 66 set ref 426* 429* 429 503 516 525 525 527
min                                                    builtin function         dcl 104 ref 235 317 427 429 430 511
msf_component_name       60(18) 000100 automatic       char(32)                 array level 2 packed unaligned dcl 47 set ref 304
                                                                                  319* 322* 324* 324*
msf_count               102     000100 automatic       fixed bin(17,0)          array level 2 dcl 47 set ref 317 318 400*
msf_index               103     000100 automatic       fixed bin(17,0)          array level 2 dcl 47 set ref 317* 317 318 319 401*
msf_sw                   70(19) 000100 automatic       bit(1)                   array level 2 packed unaligned dcl 47 set ref 229
                                                                                  245 245 247 247 303 315 387* 456 456
names_ptr                76     000100 automatic       pointer                  array level 2 dcl 47 set ref 131* 292 292 319 399*
nindex                    0(18)        based           fixed bin(18,0)          array level 2 packed unsigned unaligned dcl 2-27 ref
                                                                                  319
nnames                    0(02)        based           fixed bin(16,0)          array level 2 packed unsigned unaligned dcl 2-27 ref
                                                                                  292
noentry_sw               70(20) 000100 automatic       bit(1)                   array level 2 packed unaligned dcl 47 set ref 210
                                                                                  210 212 212 222 407*
null                                                   builtin function         dcl 104 ref 131 133 290 291 292 376 389
octal_mask                      000513 automatic       fixed bin(35,0)          dcl 69 set ref 180* 186
offset                  104     000100 automatic       fixed bin(17,0)          array level 2 dcl 47 set ref 229 229 343* 381 416
                                                                                  417* 427 427 429 429 433 434
path                            000100 automatic       char(194)                array level 2 packed unaligned dcl 47 set ref 213*
                                                                                  213* 224* 261* 322* 324* 324* 372* 410*
path_count                      000506 automatic       fixed bin(17,0)          dcl 66 set ref 126* 202* 202 203 204* 208
pathname_                       000066 constant        entry                    external dcl 100 ref 324 324 382 382 390 390 393 393
                                                                                  395 395
pathname_$component             000070 constant        entry                    external dcl 101 ref 372
printed_component_header_sw     000463 automatic       bit(1)                   unaligned dcl 61 set ref 255* 454 455*
printed_header_sw               000462 automatic       bit(1)                   unaligned dcl 61 set ref 243* 452 510 536*
ptr                      72     000100 automatic       pointer                  array level 2 dcl 47 set ref 131* 229 229 290 290*
                                                                                  322* 374* 375* 376 440 440 469 469 475 475 481 481
                                                                                  512 512 523 525 528
return_arg                             based           varying char             dcl 55 set ref 217* 236* 237* 248* 274* 448* 506*
return_len                      000507 automatic       fixed bin(17,0)          dcl 66 set ref 108* 217 236 237 248 274 448 506
return_ptr                      000472 automatic       pointer                  dcl 63 set ref 108* 217 236 237 248 274 448 506
short_sw                        000464 automatic       bit(1)                   unaligned dcl 61 set ref 128* 193* 463 520 537
star_BRANCHES_ONLY              000162 constant        fixed bin(2,0)           initial dcl 2-110 set ref 390*
star_entries                           based           structure                array level 1 dcl 2-27 ref 291
star_entry_count                000526 automatic       fixed bin(17,0)          dcl 2-14 set ref 291 292 390* 400
star_entry_ptr                  000530 automatic       pointer                  dcl 2-15 set ref 292 390* 398
star_names                             based           char(32)                 array unaligned dcl 2-37 ref 292 319
star_names_ptr                  000532 automatic       pointer                  dcl 2-19 set ref 390* 399
substr                                                 builtin function         dcl 104 ref 141 343 343
sum                                                    builtin function         dcl 104 ref 292
terminate_file_                 000072 constant        entry                    external dcl 102 ref 290
totals_sw                       000465 automatic       bit(1)                   unaligned dcl 61 set ref 128* 196* 456 463 464 519
                                                                                  537
unspec                                                 builtin function         dcl 104 set ref 129* 186
word                                   based           bit(36)                  array unaligned dcl 42 set ref 440 440 469* 469*
                                                                                  475* 475* 481* 481* 512 512 523* 525* 528*
word_count                      000510 automatic       fixed bin(17,0)          dcl 66 set ref 242* 264* 264 279* 279 461* 461 517*
                                                                                  517
xcn                             000426 automatic       char(32)                 unaligned dcl 57 set ref 358* 365
xen                             000436 automatic       char(32)                 unaligned dcl 57 set ref 358* 364

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 3-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 3-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 3-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 3-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 3-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 3-15
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
addrel                                                 builtin function         dcl 104
hcs_$initiate_count             000000 constant        entry                    external dcl 93
hcs_$terminate_noname           000000 constant        entry                    external dcl 96
max_length                             automatic       fixed bin(19,0)          dcl 67
star_ALL_ENTRIES                       internal static fixed bin(2,0)           initial dcl 2-111
star_ALL_ENTRIES_WITH_LINK_PATHS       internal static fixed bin(3,0)           initial dcl 2-114
star_DIRECTORY                         internal static fixed bin(2,0)           initial unsigned dcl 2-121
star_LINK                              internal static fixed bin(2,0)           initial unsigned dcl 2-119
star_LINKS_ONLY                        internal static fixed bin(2,0)           initial dcl 2-109
star_LINKS_ONLY_WITH_LINK_PATHS        internal static fixed bin(3,0)           initial dcl 2-112
star_SEGMENT                           internal static fixed bin(2,0)           initial unsigned dcl 2-120
star_branch_count                      automatic       fixed bin(17,0)          dcl 2-13
star_dir_list_branch                   based           structure                array level 1 dcl 2-59
star_link_count                        automatic       fixed bin(17,0)          dcl 2-17
star_link_pathname                     based           char                     unaligned dcl 2-102
star_links                             based           structure                array level 1 dcl 2-76
star_linkx                             automatic       fixed bin(17,0)          dcl 2-18
star_list_branch                       based           structure                array level 1 dcl 2-41
star_list_branch_ptr                   automatic       pointer                  dcl 2-16
star_list_names                        based           char(32)                 array unaligned dcl 2-92
star_list_names_ptr                    automatic       pointer                  dcl 2-20
star_select_sw                         automatic       fixed bin(3,0)           dcl 2-21
terminate_file_switches                based           structure                level 1 packed unaligned dcl 3-4

NAMES DECLARED BY EXPLICIT CONTEXT.
BADOPT                          001365 constant        label                    dcl 198 ref 141 145 148 188 191 194
BAD_NUM                         001125 constant        label                    dcl 163 ref 170
BAD_OCTAL_NUM                   001120 constant        label                    dcl 161 set ref 184
BAD_OFFSET                      002555 constant        label                    dcl 338 ref 346
RETURN                          002151 constant        label                    dcl 282 ref 214 218 225 249 275 325 339 354 362 384
                                                                                  396 411 419 449 507
USAGE                           000557 constant        label                    dcl 119 ref 203 208
clean_up                        002157 constant        entry                    internal dcl 285 ref 135 231 238 282
compare                         000513 constant        entry                    external dcl 12
get_msf_component_name          002301 constant        entry                    internal dcl 297 ref 265 265 456 456 456 456
get_next_msf_component          002337 constant        entry                    internal dcl 308 ref 253 254 263
get_path                        002536 constant        entry                    internal dcl 332 ref 204
print_discrepancies             003770 constant        entry                    internal dcl 424 ref 245 256
print_header                    005002 constant        entry                    internal dcl 534 ref 452 510

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5412        5506    5106        5422
Length      6012    5106        74         267     303           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
compare                             844 external procedure  is an external procedure.  
on unit on line 135                  64 on unit               
clean_up                             86 internal procedure  is called by several nonquick procedures.  
get_msf_component_name                  internal procedure  shares stack frame of external procedure compare.  
get_next_msf_component                  internal procedure  shares stack frame of external procedure compare.  
get_path                                internal procedure  shares stack frame of external procedure compare.  
print_discrepancies                     internal procedure  shares stack frame of external procedure compare.  
print_header                            internal procedure  shares stack frame of external procedure compare.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
clean_up                 000100 i                           clean_up
compare                  000100 info                        compare
                         000314 dn                          compare
                         000366 cn                          compare
                         000376 cn1                         compare
                         000406 en                          compare
                         000416 en1                         compare
                         000426 xcn                         compare
                         000436 xen                         compare
                         000446 bad_arg                     compare
                         000452 bad_base                    compare
                         000456 mask                        compare
                         000457 af_sw                       compare
                         000460 brief_sw                    compare
                         000461 inhibit_error_sw            compare
                         000462 printed_header_sw           compare
                         000463 printed_component_header_sw compare
                         000464 short_sw                    compare
                         000465 totals_sw                   compare
                         000466 area_ptr                    compare
                         000470 arg_ptr                     compare
                         000472 return_ptr                  compare
                         000474 arg_count                   compare
                         000475 arg_len                     compare
                         000476 block_len                   compare
                         000477 col                         compare
                         000500 common_len                  compare
                         000501 dis_count                   compare
                         000502 given_len                   compare
                         000503 i                           compare
                         000504 j                           compare
                         000505 max_len                     compare
                         000506 path_count                  compare
                         000507 return_len                  compare
                         000510 word_count                  compare
                         000511 bit_count                   compare
                         000512 code                        compare
                         000513 octal_mask                  compare
                         000514 complain                    compare
                         000526 star_entry_count            compare
                         000530 star_entry_ptr              compare
                         000532 star_names_ptr              compare

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_ne_as             alloc_cs            call_var_desc       call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return              mpfx2               enable              shorten_stack
ext_entry           int_entry           free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               active_fnc_err_$suppress_name com_err_                      com_err_$suppress_name
cu_$af_return_arg             cu_$arg_ptr                   cv_oct_check_                 expand_pathname_$component
get_equal_name_$component     get_system_free_area_         hcs_$star_                    hcs_$status_minf
initiate_file_                initiate_file_$component      ioa_                          pathname_
pathname_$component           terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_conversion   error_table_$badopt           error_table_$dirseg           error_table_$item_too_big
error_table_$noentry          error_table_$nomatch          error_table_$not_act_fnc      error_table_$not_archive




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000512       108 000520       109 000534       110 000540       111 000541       112 000545       114 000546
    115 000550       118 000554       119 000557       121 000607       123 000634       126 000635       127 000637
    128 000641       129 000645       130 000650       131 000655       132 000662       133 000664       135 000666
    137 000710       139 000717       141 000734       144 000754       145 000757       147 000771       148 000774
    150 001006       151 001010       152 001020       153 001021       154 001036       155 001040       156 001064
    158 001065       159 001111       160 001116       161 001120       163 001125       165 001167       167 001170
    169 001172       170 001177       172 001200       173 001201       174 001205       175 001206       176 001223
    177 001225       178 001251       180 001252       181 001300       183 001302       184 001307       186 001310
    187 001312       188 001313       190 001325       191 001327       193 001341       194 001344       196 001362
    198 001365       199 001417       200 001420       202 001421       203 001422       204 001425       206 001427
    208 001431       210 001434       211 001447       212 001451       213 001455       214 001512       217 001513
    218 001524       222 001525       223 001532       224 001534       225 001564       229 001565       230 001603
    231 001627       232 001633       235 001634       236 001644       237 001661       238 001672       239 001676
    242 001677       243 001701       245 001702       247 001714       248 001721       249 001732       252 001733
    253 001742       254 001746       255 001752       256 001753       257 001754       258 001755       259 001763
    260 001767       261 001770       262 002012       263 002017       264 002021       265 002025       266 002052
    268 002053       273 002055       274 002057       275 002070       278 002071       279 002110       282 002151
    283 002155       285 002156       289 002164       290 002171       291 002227       292 002237       293 002276
    295 002300       297 002301       303 002303       304 002316       308 002337       315 002341       317 002352
    318 002361       319 002365       322 002403       323 002442       324 002444       325 002524       327 002525
    330 002535       332 002536       336 002540       337 002553       338 002555       339 002612       342 002613
    343 002615       344 002653       345 002656       346 002661       348 002662       351 002665       352 002720
    353 002725       354 002756       357 002757       358 002763       359 003017       360 003021       362 003101
    364 003102       365 003105       366 003110       368 003111       369 003114       372 003117       374 003153
    375 003220       376 003255       377 003265       378 003271       379 003272       380 003332       381 003334
    382 003342       384 003412       387 003413       389 003416       390 003431       392 003516       393 003520
    395 003574       396 003641       398 003642       399 003647       400 003651       401 003654       402 003655
    403 003657       405 003660       406 003661       407 003663       408 003666       410 003667       411 003716
    414 003717       416 003724       417 003733       419 003766       422 003767       424 003770       426 003771
    427 003776       428 004007       429 004011       430 004026       433 004033       434 004035       436 004037
    438 004040       440 004047       442 004102       443 004103       445 004105       447 004107       448 004111
    449 004122       452 004123       454 004126       455 004130       456 004132       460 004174       461 004175
    463 004177       464 004203       465 004240       466 004242       467 004244       468 004245       469 004252
    472 004307       473 004320       474 004322       475 004324       478 004371       480 004372       481 004401
    484 004436       485 004437       486 004440       489 004442       490 004445       491 004446       494 004447
    495 004450       498 004451       499 004452       501 004453       503 004455       505 004463       506 004465
    507 004476       510 004477       511 004502       512 004512       514 004536       515 004544       516 004546
    517 004553       519 004554       520 004557       522 004623       523 004630       524 004662       525 004675
    526 004732       527 004733       528 004745       529 004777       532 005001       534 005002       536 005003
    537 005005       538 005012       539 005027       541 005043


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
