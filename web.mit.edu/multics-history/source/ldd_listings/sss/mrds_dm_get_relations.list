	COMPILATION LISTING OF SEGMENT mrds_dm_get_relations
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1345.2 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1976 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 
       19 /* DESCRIPTION:
       20*
       21*   The routine returns the names of all  relations  defined  in  the
       22*   database  model. There are 3 entries, mrds_dm_get_relations is an
       23*   internal entry for use by  mrds,  get_relations  is  an  external
       24*   entry  for  use  by  dmd_, and get_model_relations is an external
       25*   entry for use by mmi_. The external entries make sure the user is
       26*   a DBA if the database has been secured.
       27*
       28**/
       29 
       30 /* PARAMETERS:
       31*
       32*   ======= get_model_relations entry
       33*
       34*   open_name - - (input) char(*), the open name supplied in the call
       35*   to mmi_$open_model
       36*
       37*   area_ptr - - (input) ptr, pointer to an area in which  to  return
       38*   info
       39*
       40*   structure_version - - (input) fixed bin,  the  desired  structure
       41*   version
       42*
       43*   mrd_db_model_relations_ptr - - (output) ptr, the pointer  to  the
       44*   list of model relation names in mrd_db_model_relations.incl.pl1
       45*
       46*   code - - (output) fixed bin (35), the error status encoding
       47*
       48*   ======= mrds_dm_get_relations and get_relations entries
       49*
       50*   data_model_ptr - - (input) ptr, the pointer returned from a  call
       51*   to dmd_$open_dm
       52*
       53*   area_ptr - - (input) ptr, points to an area in  which  to  return
       54*   info
       55*
       56*   mr_ptr - - (output) ptr, points to the relation names returned in
       57*   mrds_model_relations.incl.pl1
       58*
       59*   code - - (output) fixed bin (35), the error status encoding
       60*
       61**/
       62 
       63 /* HISTORY :
       64*
       65*   Modified by J. A. Weeldreyer to incorporate domain separation  --
       66*   November, 1976.
       67*
       68*   Modified by Oris Friesen to accomodate new version data bases  --
       69*   October 1978
       70*
       71*   Modified by Jim Gray  -  -  Feb.  1980,  to  correctly  determine
       72*   whether  data_model_ptr  refers to an old or new version database
       73*   model.
       74*
       75*   80-12-30 Jim Gray : captured error  message  when  no  access  to
       76*   model segment, and translated into meaningful mrds error code.
       77*
       78*   81-01-31 Jim Gray : added setting of needed for DBA types, if  an
       79*   access violation occurs.
       80*
       81*   81-02-12  Jim  Gray  :  added  need  for  external   callers   to
       82*   dmd_$get_relations  to be a DBA if db secured, this should not be
       83*   called   internally   from   mrds,   mrds    should    use    the
       84*   mrds_dm_get_relations entry.
       85*
       86*   81-04-23 Jim Gray : changed method of  obtaining  relation  names
       87*   from that of looking at all relation model segments, to using the
       88*   file names as the relation names, and getting them all out of the
       89*   db_model segment. This was done on the premise that blocked files
       90*   are not to be implemented.
       91*
       92*   81-04-23 Jim Gray : added get_model_relations entry for mmi_
       93*
       94*   83-06-21 Davids: Removed check for old version database and the call
       95*   to v1 code if it was an old version db (old version dbs can no longer
       96*   be opened)
       97**/
       98 
       99 /* BEGIN CHANGE 81-02-12 ********************************************* */
      100 
      101 mrds_dm_get_relations: procedure (data_model_ptr_a, area_ptr_a, mr_ptr_a, code_a);
      102 
      103 /* entry to be used internal by mrds, no access checking required */
      104 
      105 	internal_call = "1"b;
      106 
      107 	data_model_ptr = data_model_ptr_a;
      108 	area_ptr = area_ptr_a;
      109 
      110 	call common ();
      111 
      112 	mr_ptr_a = mr_ptr;
      113 	code_a = code;
      114 
      115 	return;
      116 
      117 
      118 
      119 
      120 get_relations: entry (data_model_ptr_b, area_ptr_b, mr_ptr_b, code_b);
      121 
      122 /* this entry should only be called externally from dmd_, never by mrds */
      123 
      124 	internal_call = "0"b;
      125 
      126 	data_model_ptr = data_model_ptr_b;
      127 	area_ptr = area_ptr_b;
      128 
      129 	call common ();
      130 
      131 	mr_ptr_b = mr_ptr;
      132 	code_b = code;
      133 
      134 	return;
      135 
      136 /* END CHANGE 81-02-12 ****************************************** */
      137 
      138 /* BEGIN CHANGE 81-04-23 B ********************************************* */
      139 
      140 get_model_relations: entry (open_name, area_ptr_c, structure_version, mrds_db_model_relations_ptr, code_c);
      141 
      142 /* this entry is for the mmi_ interface. it calls the get_relations
      143*   entry to be able to handle both old and new version databases,
      144*   and also to be able to detect non-dba's using a secured database. */
      145 
      146 	code_c = 0;
      147 	mrds_db_model_relations_ptr = null ();
      148 
      149 /* get the model pointer from the opening name */
      150 
      151 	call mu_open_name_manager$get_model_pointer (open_name, model_type, model_ptr, code_c);
      152 	if code_c = 0 then do;
      153 
      154 /* get the list of relation names from the old or new model */
      155 
      156 		call get_relations (model_ptr, addr (local_area), mr_ptr_c, code_c);
      157 		if code_c = 0 then do;
      158 
      159 /* check the callers arguments */
      160 
      161 			mr_ptr = mr_ptr_c;
      162 			area_ptr = area_ptr_c;
      163 
      164 			if area_ptr = null () then
      165 			     code_c = error_table_$badcall;
      166 			else do;
      167 				unspec (my_area_info) = "0"b;
      168 				my_area_info.version = 1;
      169 				my_area_info.areap = area_ptr;
      170 
      171 				call area_info_ (addr (my_area_info), code_c);
      172 				if code_c ^= 0 then ;
      173 				else if my_area_info.no_freeing then
      174 				     code_c = mrds_error_$not_freeing_area;
      175 				else do;
      176 
      177 					if structure_version ^= mrds_db_model_relations_structure_version then
      178 					     code_c = error_table_$unimplemented_version;
      179 					else do;
      180 
      181 /* fill in the users structure details */
      182 
      183 						on area begin;
      184 							code_c = error_table_$area_too_small;
      185 							goto skip_allocate;
      186 						     end;
      187 
      188 						on cleanup begin;
      189 							if mrds_db_model_relations_ptr ^= null () then do;
      190 								free mrds_db_model_relations in (return_area);
      191 								mrds_db_model_relations_ptr = null ();
      192 							     end;
      193 						     end;
      194 
      195 						mrds_db_model_relations_count_init = model_relations.nrels;
      196 						allocate mrds_db_model_relations set (mrds_db_model_relations_ptr) in (return_area);
      197 						revert area;
      198 
      199 						unspec (mrds_db_model_relations) = "0"b;
      200 						mrds_db_model_relations.version = mrds_db_model_relations_structure_version;
      201 						mrds_db_model_relations.relation_count = mrds_db_model_relations_count_init;
      202 
      203 /* get all relation names */
      204 
      205 						do i = 1 to mrds_db_model_relations_count_init;
      206 
      207 						     mrds_db_model_relations.relation (i).name = model_relations.relation_name (i);
      208 
      209 						end;
      210 
      211 					     end;
      212 				     end;
      213 			     end;
      214 		     end;
      215 	     end;
      216 
      217 skip_allocate:
      218 
      219 	return;
      220 
      221 /* END CHANGE 81-04-23 B ********************************************* */
      222 
      223 common: procedure ();
      224 
      225 /* check for which version of mrds to call,
      226*   based on the version of the model being referenced */
      227 
      228 	mr_ptr = null ();
      229 	code = 0;
      230 
      231 	call hcs_$fs_get_path_name (data_model_ptr, db_path, ldn, model_name, code);
      232 	if code = 0 then do;
      233 
      234 		dbm_ptr = data_model_ptr;
      235 
      236 /* check for a non-DBA trying to use this interface
      237*   on a secured database, which is not allowed */
      238 
      239 		if ^internal_call then
      240 		     call secured_db_check ();
      241 
      242 /* get the relation names from the database model */
      243 
      244 		if code = 0 then do;
      245 
      246 /* BEGIN CHANGE 81-04-23 A ******************************************** */
      247 
      248 			on cleanup begin;
      249 				if mr_ptr ^= null then do;
      250 					free model_relations in (return_area);
      251 					mr_ptr = null ();
      252 				     end;
      253 			     end;
      254 
      255 			on no_read_permission begin;
      256 				code = mrds_error_$no_model_access;
      257 				mr_ptr = null ();
      258 				goto exit;
      259 			     end;
      260 
      261 			num_relations_alloc = db_model.num_rels;
      262 			allocate model_relations in (return_area);
      263 			unspec (model_relations) = "0"b;
      264 			model_relations.nrels = num_relations_alloc;
      265 
      266 			indx1 = 1;
      267 
      268 			do fi_ptr = ptr (dbm_ptr, db_model.file_ptr)
      269 			     repeat ptr (dbm_ptr, file_info.fwd_ptr)
      270 			     while (rel (fi_ptr) ^= NULL_OFS);
      271 
      272 /* get the relation name out of the db_model segment,
      273*   by assuming that there is one relation per file,
      274*   and the file name is the same as the relation name. */
      275 
      276 			     model_relations.relation_name (indx1) = file_info.file_name;
      277 			     indx1 = indx1 + 1;
      278 			end;
      279 
      280 /* END CHANGE 81-04-23 A ********************************************* */
      281 
      282 
      283 		     end;
      284 	     end;
      285 exit:
      286 	return;
      287 
      288      end;
      289 
      290 /* BEGIN CHANGE 81-02-12 ********************************************* */
      291 
      292 secured_db_check: procedure ();
      293 
      294 /* routine to check for the database being is a secured state,
      295*   and if so, that the user is a DBA, and thus may use the external entry */
      296 
      297 	if code ^= 0 then ;
      298 	else if internal_call then ;
      299 	else do;
      300 
      301 /* get the secured state of the dataabase */
      302 
      303 		call mrds_dm_db_secured$get_secured_status (dbm_ptr, addr (local_area),
      304 		     database_state_structure_version, database_state_ptr, code);
      305 		if code ^= 0 then
      306 
      307 		     call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      308 			"Unable to get the secured state of database """, db_path, """.");
      309 
      310 		else if ^database_state.secured then ;
      311 		else do;
      312 
      313 /* database secured, see if the user is a DBA */
      314 
      315 			call mrds_dm_authorization$get_user_class (rtrim (db_path), addr (local_area),
      316 			     mrds_authorization_structure_version, mrds_authorization_ptr, code);
      317 			if code ^= 0 then
      318 
      319 			     call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      320 				"Unable to get user class for database """, db_path, """.");
      321 
      322 			else if mrds_authorization.administrator then ;
      323 			else do;
      324 
      325 /* not DBA on secured db, issue error */
      326 
      327 				code = error_table_$insufficient_access;
      328 				call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a ^a",
      329 				     "The database """, db_path, """ has been secured,",
      330 				     "so the caller must be a DBA to use direct model access.");
      331 
      332 			     end;
      333 
      334 		     end;
      335 
      336 	     end;
      337 
      338 	if code ^= 0 then
      339 	     data_model_ptr, dbm_ptr = null ();
      340 
      341      end;
      342 
      343 /* END CHANGE 81-02-12 ************************************************ */
      344 
      345 	declare NULL_OFS		 bit (18) unal int static init ("111111111111111111"b) options (constant);
      346 	declare area		 condition;	/* if area too small */
      347 	declare area_info_		 entry (ptr, fixed bin (35)); /* gets area details */
      348 	declare area_ptr		 ptr;		/* pointer to the area in which to return information */
      349 	declare area_ptr_a		 ptr;		/* temp for mrds_dm_get_relations entry */
      350 	declare area_ptr_b		 ptr;		/* temp for get_relations entry */
      351 	declare area_ptr_c		 ptr;		/* temp for get_model_relations entry */
      352 	declare caller_name		 char (32) init ("dmd_$open_dm"); /* name of calling routine */
      353 	declare cleanup		 condition;
      354 	declare code		 fixed bin (35);	/* a standard Multics system status code (Output) */
      355 	declare code_a		 fixed bin (35);	/* temp for mrds_dm_get_relations entry */
      356 	declare code_b		 fixed bin (35);	/* temp for get_relations entry */
      357 	declare code_c		 fixed bin (35);	/* temp for get_model_relations entry */
      358 	declare continue		 char (1) init ("c"); /* dont stop after print mesg */
      359 	declare data_model_ptr	 ptr;		/* iocb pointer to the data model to be searched (Input) */
      360 	declare data_model_ptr_a	 ptr;		/* temp for mrds_dm_get_relations entry */
      361 	declare data_model_ptr_b	 ptr;		/* temp for get_relations entry */
      362 	declare db_path		 char (168);
      363 	declare error_table_$area_too_small fixed bin (35) ext; /* area not big enough */
      364 	declare error_table_$badcall	 fixed bin (35) ext;/* area ptr null */
      365 	declare error_table_$insufficient_access fixed bin (35) ext; /* not DBA and db secured */
      366 	declare error_table_$unimplemented_version fixed bin (35) ext; /* unknown structure version */
      367 	declare hcs_$fs_get_path_name	 entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
      368 	declare i			 fixed bin;	/* loop index */
      369 	declare indx1		 fixed bin;
      370 	declare info_ptr		 ptr init (null ());/* unused */
      371 	declare internal_call	 bit (1);		/* on => called from mrds, not by dmd_ */
      372 	declare ldn		 fixed bin;
      373 	declare local_area		 area (4096);	/* space for db state, and user class info */
      374 	declare mu_open_name_manager$get_model_pointer entry (char (*), char (1), ptr, fixed bin (35)); /* gets ptr from name */
      375 	declare model_name		 char (32);
      376 	declare model_ptr		 ptr;
      377 	declare model_type		 char (1);	/* type of model opening */
      378 	declare mr_ptr_a		 ptr;		/* temp for mrds_dm_get_relations entry */
      379 	declare mr_ptr_b		 ptr;		/* temp for get_relations entry */
      380 	declare mr_ptr_c		 ptr;		/* temp for get_model_relations entry */
      381 	declare mrds_dm_authorization$get_user_class entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* finds if DBA */
      382 	declare mrds_dm_db_secured$get_secured_status entry (ptr, ptr, fixed bin, ptr, fixed bin (35)); /* gets secured bit */
      383 	declare mrds_error_$no_model_access fixed bin (35) ext; /* no r acl to model */
      384 	declare mrds_error_$not_freeing_area fixed bin (35) ext; /* no freeing attr for area */
      385 	declare no_read_permission	 condition;	/* no r acl on model */
      386 	declare open_name		 char (*);	/* opening name associated with model opening */
      387 	declare return_area		 area (sys_info$max_seg_size) based (area_ptr);
      388 	declare return_value	 fixed bin (35) init (0); /* unused */
      389 	declare structure_version	 fixed bin;	/* desired version of structure */
      390 	declare sub_err_		 entry options (variable); /* reports errors */
      391 	declare sys_info$max_seg_size	 fixed bin (35) external;
      392 	declare (addr, empty, fixed, null, ptr, rel, rtrim, unspec) builtin;
      393 	declare 1 my_area_info	 like area_info;	/* local copy */
      394 
  1     1 /*	BEGIN INCLUDE FILE		mrds_model_relations.incl.pl1
  1     2*
  1     3*   Created October, 1975 for release in MR 4.0					*/
  1     4 
  1     5 dcl 1 model_relations based (mr_ptr),			/* structure to return names of all relations in a model */
  1     6     2 nrels fixed bin (10),				/* number of relations */
  1     7     2 relation_name (num_relations_alloc refer (model_relations.nrels)) char (32); /* relation names */
  1     8 
  1     9 dcl  num_relations_alloc fixed bin (10);		/* number of relations in model for allocation purposes */
  1    10 
  1    11 dcl  mr_ptr ptr;
  1    12 
  1    13 /*	END INCLUDE FILE		mrds_model_relations.incl.pl1				*/
  1    14 
      395 
      396 
  2     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  2     6*     modified to save space occupied by model
  2     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  2     8*     to add mdbm_secured bit in db_model
  2     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  2    10*     collapsed the following into an unused_offset array:
  2    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  2    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  2    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  2    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  2    15*       unused_1
  2    16*     Also changed the name of unused_2 to restructuring_history_offset
  2    17*     and changed the comment on the changer structure to indicate
  2    18*     that it will contain on database creation information.
  2    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  2    20*     used one of the unused_offsets to point to a message which indicates
  2    21*     why the db is inconsistent. The offset will be null when the db is created
  2    22*     and set the first time the message is used. this is so it will be
  2    23*     consistent with existing data bases. Also added the message structure.
  2    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  2    25*     added the undo_request element to the message structure
  2    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  2    27*     changed unused_offset (12) to last_restructruring_history_offset and
  2    28*     changed restructuring_history_offset to first_restructuring_history_offset
  2    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  2    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  2    31*     1 => vfile database and 2 => page_file database. Up to this point all
  2    32*     database types were equal to 1.
  2    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  2    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  2    35*     flags. This will allow information about transactions and dm_file
  2    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  2    37*     change is compatable with all datamodels created by the released version
  2    38*     of mrds.
  2    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  2    40*     added the rollback_on flag to the db_type_flags since it appears that you
  2    41*     can have a dmfile database that requires transactions but does not have any
  2    42*     journalizing. Also switched the order of the transactions_needed and
  2    43*     concurrency_on flags - this makes the change compatable with existing
  2    44*     dmfile databases except when displaying the model since concurrency_on and
  2    45*     rollback_on will be off in the model even though the dmfile relations had
  2    46*     them on during creation.
  2    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  2    48*      Removed ctl_file_path_ptr.
  2    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  2    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  2    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  2    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  2    53*      in the flag word for rmdb copying.
  2    54*                                                   END HISTORY COMMENTS */
  2    55 
  2    56 
  2    57 /* this include file contains the structures that go into the make up
  2    58*   of the "db_model" segment in the model for the database.
  2    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  2    60*
  2    61*   the db_model structure goes at the base of the segment, and contains items unique to
  2    62*   the whole databse. in addition, it has an area of size to fill the
  2    63*   rest of a segment, that holds the lists of files and domains in the database.
  2    64*   these lists are singly forward linked lists. all "pointers" in the database model
  2    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  2    66*   since actual pointers are process dependent on segment number.
  2    67*   the remaining structures are first a path_entry one to save pathnames in,
  2    68*   and the stack_item and constent structures, used to save a boolean
  2    69*   expression in polish form, with the stack represented by a linked list.
  2    70*   the final structure is one for identifying the status of version information */
  2    71 
  2    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  2    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  2    74 	     2 db_type_flags      unal,
  2    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  2    76 	       3 unused	      (13) bit (1) unal,
  2    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  2    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  2    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  2    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  2    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  2    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  2    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  2    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  2    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  2    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  2    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  2    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  2    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  2    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  2    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  2    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  2    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  2    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  2    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  2    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  2    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  2    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  2    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  2   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  2   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  2   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  2   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  2   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  2   105 
  2   106      dcl	   dbm_ptr	      ptr;
  2   107 
  2   108 /* the files in the database each have a file_info containing
  2   109*   their name, the file_model for each file is found by initiating the
  2   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  2   111*   the file_info list is a singly linked list in definition order */
  2   112 
  2   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  2   114 	     2 file_name	      char (30),		/* name of file */
  2   115 	     2 file_id	      bit (36),		/* id number of file */
  2   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  2   117 	     2 unused	      unal bit (18);	/* for future expansion */
  2   118 
  2   119      dcl	   fi_ptr		      ptr;
  2   120 
  2   121 /* each domain used in the database will have a domain info saved in the db_model
  2   122*   segment. it describes the domain of the given name, and it's options.
  2   123*   the domain_info's form a singly linked list in definition order */
  2   124 
  2   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  2   126 	     2 name	      char (32),		/* name of domain */
  2   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  2   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  2   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  2   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  2   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  2   132 	     2 reserved	      bit (31) unal,
  2   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  2   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  2   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  2   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  2   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  2   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  2   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  2   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  2   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  2   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  2   143 	     2 str_err_path_ptr   unal bit (18),
  2   144 	     2 str_after_path_ptr unal bit (18),
  2   145 	     2 get_before_path_ptr unal bit (18),
  2   146 	     2 get_err_path_ptr   unal bit (18),
  2   147 	     2 get_after_path_ptr unal bit (18),
  2   148 	     2 mod_before_path_ptr unal bit (18),
  2   149 	     2 mod_err_path_ptr   unal bit (18),
  2   150 	     2 mod_after_path_ptr unal bit (18),
  2   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  2   152 	     2 unused_2	      unal bit (18),
  2   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  2   154 
  2   155      dcl	   di_ptr		      ptr;
  2   156 
  2   157 /* information necessary for attributes that are not used in any relation */
  2   158 
  2   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  2   160 	     2 name char (32),			/* name of attribute */
  2   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  2   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  2   163 	     2 unused (2) bit (18) unal;
  2   164 
  2   165      dcl     ua_ptr ptr;
  2   166 
  2   167 
  2   168 /* space saving pathname$entryname structure, to be allocated
  2   169*   only when a path$entry has to be saved, else only a bit(18)
  2   170*   offset takes up space in the main model structure */
  2   171 
  2   172      declare 1 path_entry	      based (path_entry_ptr),
  2   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  2   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  2   175 	     2 reserved	      unal bit (36);	/* for future use */
  2   176 
  2   177      declare path_entry_ptr	      ptr;
  2   178 
  2   179 
  2   180 
  2   181 
  2   182 
  2   183 /* declarations for model of postfix stack holding the check option boolean expression
  2   184*   the following encoding values indicate the corresponding type of stack element
  2   185*
  2   186*   1  =
  2   187*   2  ^=
  2   188*   3  >
  2   189*   4  <
  2   190*   5  >=
  2   191*   6  <=
  2   192*
  2   193*   10  and
  2   194*   20  or
  2   195*   30  not
  2   196*
  2   197*   40  - (minus)
  2   198*
  2   199*   50  domain variable(same name as domain)
  2   200*
  2   201*   60  constant(number, bit string, or character string)
  2   202*
  2   203**/
  2   204 
  2   205 
  2   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  2   207 	     2 next	      bit (18),		/* link to next in list */
  2   208 	     2 type	      fixed binary,		/* code for this element type */
  2   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  2   210*						   if this is a constant element type */
  2   211 
  2   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  2   213 
  2   214 
  2   215 
  2   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  2   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  2   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  2   219 
  2   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  2   221 
  2   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  2   223 
  2   224 /* version structure, giving status of source for CMDB/RMDB,
  2   225*   status of model, and status of resultant */
  2   226 
  2   227 /* version number is in form MM.N.Y
  2   228*   where MM is the major version number, N is the minor version alteration,
  2   229*   and Y is the lastest modification to that alteration,
  2   230*   where M and N represent numbers 0-9, and Y is a letter */
  2   231 
  2   232      declare 1 version_status	      unal based (version_status_ptr),
  2   233 	     2 cmdb_rmdb,
  2   234 	       3 major	      fixed bin,
  2   235 	       3 minor	      fixed bin,
  2   236 	       3 modification     char (4),
  2   237 	     2 model,
  2   238 	       3 major	      fixed bin,
  2   239 	       3 minor	      fixed bin,
  2   240 	       3 modification     char (4),
  2   241 	     2 resultant,
  2   242 	       3 major	      fixed bin,
  2   243 	       3 minor	      fixed bin,
  2   244 	       3 modification     char (4);
  2   245 
  2   246      declare version_status_ptr     ptr;
  2   247 
  2   248 
  2   249 /* maintains information only about the db creation */
  2   250 
  2   251      declare 1 changer	      unal based (changer_ptr),
  2   252 	     2 id		      char (32),
  2   253 	     2 time	      fixed bin (71),
  2   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  2   255 
  2   256      declare changer_ptr	      ptr;
  2   257 
  2   258 
  2   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  2   260 	     02 len	      fixed bin,		/* length of the message */
  2   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  2   262 	     02 name	      char (32),		/* name of thing that set the message */
  2   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  2   264*                                                               that caused the database to become inconsistent */
  2   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  2   266 
  2   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  2   268 
  2   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  2   270 
  2   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  2   272 
  2   273 
      397 
      398 
  3     1 /* BEGIN INCLUDE FILE mrds_authorization.incl.pl1 - - 81-01-20 Jim Gray */
  3     2 
  3     3 /* HISTORY:
  3     4*
  3     5*   81-01-20 Jim Gray : original created for the mmi_$get_authorization interface
  3     6*
  3     7**/
  3     8 
  3     9 /* DESCRIPTION:
  3    10*
  3    11*   this structure returns the callers user_class
  3    12*   either database administrator or normal user.
  3    13*   Note that these separate classes were used to allow
  3    14*   future expansion to the user classes, rather than
  3    15*   make them logical "not"'s of one another.
  3    16*   NOTE: a DBA is always also a normal user, thus if the caller
  3    17*   is a DBA, his normal_user bit will be on also.
  3    18*
  3    19**/
  3    20 
  3    21 
  3    22 declare 1 mrds_authorization aligned based (mrds_authorization_ptr),
  3    23         2 version fixed bin,				/* version number of this structure */
  3    24         2 administrator bit (1) unal,			/* caller is a DBA */
  3    25         2 normal_user bit (1) unal,			/* caller has no special priviledges */
  3    26         2 mbz bit (34) unal ;
  3    27 
  3    28 
  3    29 declare  mrds_authorization_ptr ptr ;			/* pointer for referring to the structure */
  3    30 
  3    31 declare  mrds_authorization_structure_version fixed bin init (1) int static options (constant) ;
  3    32 
  3    33 /* END INCLUDE FILE mrds_authorization.incl.pl1 */
      399 
      400 
  4     1 /* BEGIN INCLUDE FILE mrds_database_state.incl.pl1 - - 81-01-20 Jim Gray */
  4     2 
  4     3 /* HISTORY:
  4     4*
  4     5*   81-01-20 Jim Gray : original created for the mmi_$get_secured_status interface
  4     6*
  4     7**/
  4     8 
  4     9 /* DESCRIPTION:
  4    10*
  4    11*   This structure returns the database state (secured or unsecured)
  4    12*   for determining how commands and subroutines will behave for each case.
  4    13*   The secured bit was kept separate from the unsecured,
  4    14*   rather than it's logical "not", to allow for future extensibility
  4    15*   of database secured states.
  4    16*
  4    17**/
  4    18 
  4    19 
  4    20 declare 1 database_state aligned based (database_state_ptr),
  4    21         2 version fixed bin,				/* version number of this structure */
  4    22         2 unsecured bit (1) unal,			/* database not secured */
  4    23         2 secured bit (1) unal,			/* database has been secured */
  4    24         2 mbz bit (34) unal ;
  4    25 
  4    26 
  4    27 declare  database_state_ptr ptr ;			/* pointer for referring to the structure */
  4    28 
  4    29 declare  database_state_structure_version fixed bin init (1) int static options (constant) ;
  4    30 
  4    31 /* END INCLUDE FILE mrds_database_state.incl.pl1 */
      401 
      402 
  5     1 /* BEGIN INCLUDE FILE mrds_db_model_relations.incl.pl1 - - Jim Gray 81-01-28 */
  5     2 
  5     3 /* HISTORY:
  5     4*
  5     5*   81-01-28 Jim Gray : originally created for the mmi_$get_model_relations interface.
  5     6*
  5     7*
  5     8**/
  5     9 
  5    10 /* DESCRIPTION:
  5    11*
  5    12*   This structure returns the list of all relation names in
  5    13*   the database model. A count of the number of names present is included.
  5    14*   No submodel alias names for the relations are involved.
  5    15*   This structure is to be used externally, not internal to MRDS.
  5    16*
  5    17**/
  5    18 
  5    19 
  5    20 declare 1 mrds_db_model_relations aligned based (mrds_db_model_relations_ptr),
  5    21         2 version,					/* version number for this structure */
  5    22         2 relation_count fixed bin,			/* total number of relations in this model */
  5    23         2 mbz1 bit (36) unal,
  5    24         2 relation (mrds_db_model_relations_count_init refer (mrds_db_model_relations.relation_count)),
  5    25 	3 name char (32),				/* name of the relation in the model */
  5    26 	3 mbz2 bit (36) unal ;
  5    27 
  5    28 declare  mrds_db_model_relations_ptr ptr ;
  5    29 
  5    30 declare  mrds_db_model_relations_count_init fixed bin ;
  5    31 
  5    32 declare  mrds_db_model_relations_structure_version fixed bin int static init (1) options (constant) ;
  5    33 
  5    34 /* END INCLUDE FILE mrds_db_model_relations.incl.pl1 */
      403 
      404 
  6     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  6     2 
  6     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  6     4 
  6     5 dcl  area_infop ptr;
  6     6 
  6     7 dcl 1 area_info aligned based (area_infop),
  6     8     2 version fixed bin,				/* version number for this structure is 1 */
  6     9     2 control aligned like area_control,		/* control bits for the area */
  6    10     2 owner char (32) unal,				/* creator of the area */
  6    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  6    12     2 size fixed bin (18),				/* size of the area in words */
  6    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  6    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  6    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  6    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  6    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  6    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  6    19 
  6    20 dcl 1 area_control aligned based,
  6    21     2 extend bit (1) unal,				/* says area is extensible */
  6    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  6    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  6    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  6    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  6    26     2 system bit (1) unal,				/* says area is managed by system */
  6    27     2 pad bit (30) unal;
  6    28 
  6    29 /* END INCLUDE FILE area_info.incl.pl1 */
      405 
      406 
      407      end mrds_dm_get_relations;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1145.0  mrds_dm_get_relations.pl1         >special_ldd>install>MR12.0-1187>mrds_dm_get_relations.pl1
395          1    10/14/83  1608.4  mrds_model_relations.incl.pl1     >ldd>include>mrds_model_relations.incl.pl1
397          2    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
399          3    10/14/83  1608.8  mrds_authorization.incl.pl1       >ldd>include>mrds_authorization.incl.pl1
401          4    10/14/83  1608.8  mrds_database_state.incl.pl1      >ldd>include>mrds_database_state.incl.pl1
403          5    10/14/83  1608.8  mrds_db_model_relations.incl.pl1  >ldd>include>mrds_db_model_relations.incl.pl1
405          6    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NULL_OFS                               constant        bit(18)                  initial unaligned dcl 345 ref 268
addr                                                   builtin function         dcl 392 ref 156 156 171 171 303 303 315 315
administrator             1            based           bit(1)                   level 2 packed unaligned dcl 3-22 ref 322
area                            000100 stack reference condition                dcl 346 ref 183 197
area_control                           based           structure                level 1 dcl 6-20
area_info                              based           structure                level 1 dcl 6-7
area_info_                      000010 constant        entry                    external dcl 347 ref 171
area_ptr                        000106 automatic       pointer                  dcl 348 set ref 108* 127* 162* 164 169 190 196 250
                                                                                  262
area_ptr_a                             parameter       pointer                  dcl 349 ref 101 108
area_ptr_b                             parameter       pointer                  dcl 350 ref 120 127
area_ptr_c                             parameter       pointer                  dcl 351 ref 140 162
areap                    16     010232 automatic       pointer                  level 2 dcl 393 set ref 169*
caller_name                     000110 automatic       char(32)                 initial unaligned dcl 352 set ref 305* 317* 328*
                                                                                  352*
cleanup                         000120 stack reference condition                dcl 353 ref 188 248
code                            000126 automatic       fixed bin(35,0)          dcl 354 set ref 113 132 229* 231* 232 244 256* 297
                                                                                  303* 305 305* 315* 317 317* 327* 328* 338
code_a                                 parameter       fixed bin(35,0)          dcl 355 set ref 101 113*
code_b                                 parameter       fixed bin(35,0)          dcl 356 set ref 120 132*
code_c                                 parameter       fixed bin(35,0)          dcl 357 set ref 140 146* 151* 152 156* 157 164* 171*
                                                                                  172 173* 177* 184*
continue                        000127 automatic       char(1)                  initial unaligned dcl 358 set ref 305* 317* 328*
                                                                                  358*
control                   1     010232 automatic       structure                level 2 dcl 393
data_model_ptr                  000130 automatic       pointer                  dcl 359 set ref 107* 126* 231* 234 338*
data_model_ptr_a                       parameter       pointer                  dcl 360 ref 101 107
data_model_ptr_b                       parameter       pointer                  dcl 361 ref 120 126
database_state                         based           structure                level 1 dcl 4-20
database_state_ptr              010270 automatic       pointer                  dcl 4-27 set ref 303* 310
database_state_structure_version
                                000017 constant        fixed bin(17,0)          initial dcl 4-29 set ref 303*
db_model                               based           structure                level 1 dcl 2-72
db_path                         000132 automatic       char(168)                unaligned dcl 362 set ref 231* 305* 315 315 317*
                                                                                  328*
dbm_ptr                         010262 automatic       pointer                  dcl 2-106 set ref 234* 261 268 268 278 303* 338*
empty                                                  builtin function         dcl 392 ref 373
error_table_$area_too_small     000012 external static fixed bin(35,0)          dcl 363 ref 184
error_table_$badcall            000014 external static fixed bin(35,0)          dcl 364 ref 164
error_table_$insufficient_access
                                000016 external static fixed bin(35,0)          dcl 365 ref 327
error_table_$unimplemented_version
                                000020 external static fixed bin(35,0)          dcl 366 ref 177
fi_ptr                          010264 automatic       pointer                  dcl 2-119 set ref 268* 268* 276* 278
file_info                              based           structure                level 1 dcl 2-113
file_name                              based           char(30)                 level 2 dcl 2-113 ref 276
file_ptr                 22            based           bit(18)                  level 2 packed unaligned dcl 2-72 ref 268
fwd_ptr                  11            based           bit(18)                  level 2 packed unaligned dcl 2-113 ref 278
hcs_$fs_get_path_name           000022 constant        entry                    external dcl 367 ref 231
i                               000204 automatic       fixed bin(17,0)          dcl 368 set ref 205* 207 207*
indx1                           000205 automatic       fixed bin(17,0)          dcl 369 set ref 266* 276 277* 277
info_ptr                        000206 automatic       pointer                  initial dcl 370 set ref 305* 317* 328* 370*
internal_call                   000210 automatic       bit(1)                   unaligned dcl 371 set ref 105* 124* 239 298
ldn                             000211 automatic       fixed bin(17,0)          dcl 372 set ref 231*
local_area                      000212 automatic       area(4096)               dcl 373 set ref 156 156 303 303 315 315 373*
model_name                      010212 automatic       char(32)                 unaligned dcl 375 set ref 231*
model_ptr                       010222 automatic       pointer                  dcl 376 set ref 151* 156*
model_relations                        based           structure                level 1 unaligned dcl 1-5 set ref 250 262 263*
model_type                      010224 automatic       char(1)                  unaligned dcl 377 set ref 151*
mr_ptr                          010260 automatic       pointer                  dcl 1-11 set ref 112 131 161* 195 207 228* 249 250
                                                                                  251* 257* 262* 263 264 276
mr_ptr_a                               parameter       pointer                  dcl 378 set ref 101 112*
mr_ptr_b                               parameter       pointer                  dcl 379 set ref 120 131*
mr_ptr_c                        010226 automatic       pointer                  dcl 380 set ref 156* 161
mrds_authorization                     based           structure                level 1 dcl 3-22
mrds_authorization_ptr          010266 automatic       pointer                  dcl 3-29 set ref 315* 322
mrds_authorization_structure_version
                                000017 constant        fixed bin(17,0)          initial dcl 3-31 set ref 315*
mrds_db_model_relations                based           structure                level 1 dcl 5-20 set ref 190 196 199*
mrds_db_model_relations_count_init
                                010272 automatic       fixed bin(17,0)          dcl 5-30 set ref 195* 196 196 201 205
mrds_db_model_relations_ptr            parameter       pointer                  dcl 5-28 set ref 140 147* 189 190 191* 196* 199 200
                                                                                  201 207
mrds_db_model_relations_structure_version
                                       constant        fixed bin(17,0)          initial dcl 5-32 ref 177 200
mrds_dm_authorization$get_user_class
                                000026 constant        entry                    external dcl 381 ref 315
mrds_dm_db_secured$get_secured_status
                                000030 constant        entry                    external dcl 382 ref 303
mrds_error_$no_model_access     000032 external static fixed bin(35,0)          dcl 383 ref 256
mrds_error_$not_freeing_area    000034 external static fixed bin(35,0)          dcl 384 ref 173
mu_open_name_manager$get_model_pointer
                                000024 constant        entry                    external dcl 374 ref 151
my_area_info                    010232 automatic       structure                level 1 unaligned dcl 393 set ref 167* 171 171
name                      3            based           char(32)                 array level 3 dcl 5-20 set ref 207*
no_freeing                1(04) 010232 automatic       bit(1)                   level 3 packed unaligned dcl 393 set ref 173
no_read_permission              000000 stack reference condition                dcl 385 ref 255
nrels                                  based           fixed bin(10,0)          level 2 dcl 1-5 set ref 195 250 262* 263 264*
null                                                   builtin function         dcl 392 ref 147 164 189 191 228 249 251 257 338 370
num_relations_alloc             010256 automatic       fixed bin(10,0)          dcl 1-9 set ref 261* 262 262 264
num_rels                 14            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-72 ref 261
open_name                              parameter       char                     unaligned dcl 386 set ref 140 151*
ptr                                                    builtin function         dcl 392 ref 268 278
rel                                                    builtin function         dcl 392 ref 268
relation                  3            based           structure                array level 2 dcl 5-20
relation_count            1            based           fixed bin(17,0)          level 2 dcl 5-20 set ref 190 196* 199 201*
relation_name             1            based           char(32)                 array level 2 packed unaligned dcl 1-5 set ref 207
                                                                                  276*
return_area                            based           area                     dcl 387 ref 190 196 250 262
return_value                    010230 automatic       fixed bin(35,0)          initial dcl 388 set ref 305* 317* 328* 388*
rtrim                                                  builtin function         dcl 392 ref 315 315
secured                   1(01)        based           bit(1)                   level 2 packed unaligned dcl 4-20 ref 310
structure_version                      parameter       fixed bin(17,0)          dcl 389 ref 140 177
sub_err_                        000036 constant        entry                    external dcl 390 ref 305 317 328
unspec                                                 builtin function         dcl 392 set ref 167* 199* 263*
version                                based           fixed bin(17,0)          level 2 in structure "mrds_db_model_relations"
                                                                                  dcl 5-20 in procedure "mrds_dm_get_relations" set
                                                                                  ref 200*
version                         010232 automatic       fixed bin(17,0)          level 2 in structure "my_area_info" dcl 393
                                                                                  in procedure "mrds_dm_get_relations" set ref 168*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
alloc_length                           internal static fixed bin(35,0)          dcl 2-222
area_info_version_1                    internal static fixed bin(17,0)          initial dcl 6-3
area_infop                             automatic       pointer                  dcl 6-5
changer                                based           structure                level 1 packed unaligned dcl 2-251
changer_ptr                            automatic       pointer                  dcl 2-256
constant                               based           structure                level 1 unaligned dcl 2-216
constant_ptr                           automatic       pointer                  dcl 2-220
di_ptr                                 automatic       pointer                  dcl 2-155
domain_info                            based           structure                level 1 dcl 2-125
fixed                                                  builtin function         dcl 392
message_str                            based           structure                level 1 packed unaligned dcl 2-259
message_str_len                        automatic       fixed bin(17,0)          dcl 2-269
message_str_ptr                        automatic       pointer                  dcl 2-267
path_entry                             based           structure                level 1 packed unaligned dcl 2-172
path_entry_ptr                         automatic       pointer                  dcl 2-177
stack_item                             based           structure                level 1 unaligned dcl 2-206
stack_item_ptr                         automatic       pointer                  dcl 2-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 391
ua_ptr                                 automatic       pointer                  dcl 2-165
unreferenced_attribute                 based           structure                level 1 dcl 2-159
version_status                         based           structure                level 1 packed unaligned dcl 2-232
version_status_ptr                     automatic       pointer                  dcl 2-246

NAMES DECLARED BY EXPLICIT CONTEXT.
common                          000546 constant        entry                    internal dcl 223 ref 110 129
exit                            000771 constant        label                    dcl 285 ref 258
get_model_relations             000233 constant        entry                    external dcl 140
get_relations                   000176 constant        entry                    external dcl 120 ref 156
mrds_dm_get_relations           000143 constant        entry                    external dcl 101
secured_db_check                000772 constant        entry                    internal dcl 292 ref 239
skip_allocate                   000544 constant        label                    dcl 217 ref 185

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1652        1712    1364        1662
Length      2254    1364        40         325     266           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dm_get_relations              4307 external procedure  is an external procedure.  
on unit on line 183                  64 on unit               
on unit on line 188                  64 on unit               
common                              222 internal procedure  enables or reverts conditions.  
on unit on line 248                  64 on unit               
on unit on line 255                  64 on unit               
secured_db_check                        internal procedure  shares stack frame of internal procedure common.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dm_get_relations    000106 area_ptr                    mrds_dm_get_relations
                         000110 caller_name                 mrds_dm_get_relations
                         000126 code                        mrds_dm_get_relations
                         000127 continue                    mrds_dm_get_relations
                         000130 data_model_ptr              mrds_dm_get_relations
                         000132 db_path                     mrds_dm_get_relations
                         000204 i                           mrds_dm_get_relations
                         000205 indx1                       mrds_dm_get_relations
                         000206 info_ptr                    mrds_dm_get_relations
                         000210 internal_call               mrds_dm_get_relations
                         000211 ldn                         mrds_dm_get_relations
                         000212 local_area                  mrds_dm_get_relations
                         010212 model_name                  mrds_dm_get_relations
                         010222 model_ptr                   mrds_dm_get_relations
                         010224 model_type                  mrds_dm_get_relations
                         010226 mr_ptr_c                    mrds_dm_get_relations
                         010230 return_value                mrds_dm_get_relations
                         010232 my_area_info                mrds_dm_get_relations
                         010256 num_relations_alloc         mrds_dm_get_relations
                         010260 mr_ptr                      mrds_dm_get_relations
                         010262 dbm_ptr                     mrds_dm_get_relations
                         010264 fi_ptr                      mrds_dm_get_relations
                         010266 mrds_authorization_ptr      mrds_dm_get_relations
                         010270 database_state_ptr          mrds_dm_get_relations
                         010272 mrds_db_model_relations_count_init
                                                            mrds_dm_get_relations

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_in         call_ext_out_desc   call_ext_out        call_int_this       return_mac
tra_ext_1           enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry
op_alloc_           op_freen_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
area_info_                    hcs_$fs_get_path_name         mrds_dm_authorization$get_user_class
mrds_dm_db_secured$get_secured_status                       mu_open_name_manager$get_model_pointer
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$area_too_small   error_table_$badcall          error_table_$insufficient_access
error_table_$unimplemented_version                          mrds_error_$no_model_access   mrds_error_$not_freeing_area




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    352 000121       358 000124       370 000126       373 000130       388 000133       101 000136       105 000151
    107 000153       108 000157       110 000162       112 000166       113 000171       115 000173       120 000174
    124 000204       126 000205       127 000211       129 000214       131 000220       132 000223       134 000225
    140 000226       146 000247       147 000251       151 000253       152 000301       156 000304       157 000322
    161 000325       162 000327       164 000332       167 000342       168 000345       169 000347       171 000350
    172 000363       173 000367       177 000376       183 000405       184 000421       185 000425       188 000430
    189 000444       190 000452       191 000461       193 000465       195 000466       196 000470       197 000502
    199 000503       200 000513       201 000515       205 000517       207 000525       209 000542       217 000544
    223 000545       228 000553       229 000556       231 000557       232 000607       234 000612       239 000614
    244 000617       248 000622       249 000636       250 000644       251 000651       253 000655       255 000656
    256 000672       257 000676       258 000700       261 000703       262 000710       263 000723       264 000733
    266 000735       268 000737       276 000752       277 000762       278 000763       285 000771       292 000772
    297 000773       298 000777       303 001002       305 001023       310 001106       315 001113       317 001165
    322 001251       327 001256       328 001261       338 001355       341 001363


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
