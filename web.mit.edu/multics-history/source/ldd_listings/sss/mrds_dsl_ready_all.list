	COMPILATION LISTING OF SEGMENT mrds_dsl_ready_all
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1329.8 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(86-05-14,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
       14*     install(86-08-15,MR12.0-1127):
       15*     Added code to allocate and free the resultant_attributes_info_ptr
       16*     structure (phx20301, mrds #154). Added a pointer to it as an additional
       17*     parameter to the call to mu_sec_make_res.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* HISTORY:
       22*
       23*   Originally written by Jim Gray - - July 1979
       24*
       25*   81-05-29 Jim Gray : combined functions of mrds_dsl_ready_file into
       26*   this module, and changed to handle to resultant structure.
       27*
       28*   81-09-15 Davids: added the rtrim operator.  this  was  needed  so
       29*   that the module would compile when -prefix stringsize was used in
       30*   the call to pl1. The length of rm_rel_array.name.submodel was not
       31*   changed  to char (30) even though 30 characters is the max length
       32*   because the current length of 32 is hard-wired in to the code  in
       33*   several places.
       34*
       35*   82-07-26 R. Harvey: fixed call to mrds_dsl_finish_file in cleanup
       36*   handler to correspond with reality.
       37*
       38*   82-10-05 Mike Kubicar : Converted this module for the relation manager.
       39*   Specifically, the call to mrds_dsl_finish_file was remove (the module
       40*   has been deleted) and replaced by a call to relation_manager_$close.  At
       41*   the point that mrds_dsl_finish_file was called, no scopes had yet been
       42*   set nor cursor created.  Thus, merely closing the relation will suffice.
       43*
       44*   83-02-22 Bert Moberg : get temp segment and open submodel in this routine
       45*   instead of mu_sec_make_res to save much time
       46*
       47*   83-03-17 Bert Moberg : fixed bug where finish_code was used before it was
       48*   inited; also did some clean up
       49*
       50**/
       51 
       52 mrds_dsl_ready_all: ready_all: procedure (database_index, ready_mode, error_code);
       53 
       54 /* DESCRIPTION:
       55*
       56*   given a database index of an open database, and a file ready mode,
       57*   this routine will ready all files that are not currently readied
       58*   for that database, using the given ready mode.
       59*   if an error occurs, any files that this
       60*   routine has readied, will be finished so as to leave the user
       61*   in a known state for his file ready modes
       62*
       63**/
       64 
       65 /* PARAMETERS:
       66*
       67*   database_index - - (input) fixed bin(35) integer returned by the call to mrds_dsl_open for this opening
       68*
       69*   ready_mode - - (input) fixed bin integer between 1 and 6 representing correspondingly
       70*   retrieve, monitor_retrieve, update, load, scope_retrieve, and scope_update
       71*   file ready modes
       72*
       73*   error_code - - (output) fixed bin(35) error type encoding, 0 unless an error occured
       74*
       75*   sub_error_ - - (output) condition, signaled upon error occurence to provide more  info
       76*
       77**/
       78 
       79 /* check for a recursive call */
       80 
       81 	error_code = 0;				/* initialize */
       82 
       83 	if previous_invocation then do;
       84 		error_code = mrds_error_$no_recursion;
       85 		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a",
       86 		     "Attempt to invoke this routine recursively, a release must be done first.");
       87 	     end;
       88 	else do;
       89 
       90 		previous_invocation = ON;
       91 
       92 /* initialize the "files to be readied list" cleanup */
       93 
       94 		dbrdy_ptr = null ();
       95 		temp_area_ptr = null ();
       96 		submodel_iocb_ptr = null ();
       97 		resultant_attributes_info_ptr = null;
       98 		clean_up_condition = OFF;
       99 
      100 		on cleanup begin;			/* in case user does a quit/release */
      101 			clean_up_condition = ON;
      102 			call clean_up ();
      103 		     end;
      104 
      105 /* make sure this is a legal database index */
      106 
      107 		call get_pointers ();
      108 
      109 		if error_code = 0 then do;
      110 
      111 
      112 /* initialize the list of files to be readied */
      113 
      114 			call init_file_list ();
      115 
      116 /* get a list of all non-ready files for this database */
      117 
      118 			do fa_index = 1 by 1 to rm_rel_array.num_rels;
      119 
      120 			     call add_file ();	/* put in ready list */
      121 
      122 			end;
      123 
      124 /* ready each file in the list */
      125 
      126 			call ready_files ();
      127 
      128 		     end;
      129 
      130 /* on error or cleanup, finish all files that we readied
      131*   and get rid of the ready list we built */
      132 
      133 		call clean_up ();
      134 
      135 	     end;
      136 
      137 	return;
      138 
      139 get_pointers: procedure ();
      140 
      141 /* get the nonsecure resultant segment pointer */
      142 
      143 	call mu_database_index$get_resultant_model_pointer (database_index, dbcb_ptr);
      144 	if dbcb_ptr = null () then do;
      145 		error_code = mrds_error_$invalid_db_index;
      146 		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a ^d ^a",
      147 		     "The database index", database_index, "does not refer to a known database open by this process.");
      148 	     end;
      149 	else do;
      150 
      151 /* get secure resultant pointer */
      152 
      153 		rdbi_ptr = dbcb.rdbi_ptr;
      154 
      155 /* get the database db_model segment pointer */
      156 
      157 		dbm_ptr = null;
      158 		call hcs_$initiate ((rm_db_info.db_path), "db_model", "", 0, 0, dbm_ptr, error_code);
      159 		if error_code = error_table_$moderr then do;
      160 			call mrds_dm_authorization$set_needed_access (rtrim (rm_db_info.db_path), error_code);
      161 			if error_code ^= 0 then
      162 			     error_code = error_table_$moderr;
      163 			else call hcs_$initiate ((rm_db_info.db_path), "db_model", "", 0, 0, dbm_ptr, error_code);
      164 		     end;
      165 		if dbm_ptr ^= null () then
      166 		     error_code = 0;		/* in case already known to process, etc. */
      167 		else call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      168 			"Unable to get a pointer to the database segment """,
      169 			rtrim (rm_db_info.db_path) || ">db_model", """.");
      170 
      171 /* get pointer to the file array */
      172 
      173 		rmra_ptr = rm_db_info.ra_ptr;		/* array of files accessible by this users */
      174 
      175 	     end;
      176 
      177      end;
      178 
      179 init_file_list: procedure ();
      180 
      181 /* fill in the header to the "files to be readied" list */
      182 
      183 	if dbcb_ptr ^= null () then do;
      184 
      185 		allocate db_rdy in (dbcb.static_area);
      186 		db_rdy.frdy_ptr = null;
      187 		db_rdy.dbi = database_index;
      188 		db_rdy.dbcb_ptr = dbcb_ptr;
      189 		db_rdy.db_model_ptr = dbm_ptr;
      190 
      191 	     end;
      192 
      193      end;
      194 
      195 add_file: procedure ();
      196 
      197 /* fill in the next entry in the "files to be readied" list */
      198 
      199 	allocate file_rdy in (dbcb.static_area);
      200 	file_rdy.next = null;
      201 	file_rdy.name = rtrim (rm_rel_array.name (fa_index).submodel);
      202 	file_rdy.mode = ready_mode;
      203 	file_rdy.file_array_index = fa_index;
      204 	file_rdy.file_readied = OFF;
      205 
      206 /* put the next file to ready in the list in order */
      207 
      208 	if db_rdy.frdy_ptr = null () then do;
      209 		db_rdy.frdy_ptr = frdy_ptr;		/* first on list */
      210 		last_frdy_ptr = frdy_ptr;
      211 	     end;
      212 	else do;					/* put at end of list */
      213 		last_frdy_ptr -> file_rdy.next = frdy_ptr;
      214 		last_frdy_ptr = frdy_ptr;
      215 	     end;
      216 
      217      end;
      218 
      219 ready_files: procedure ();
      220 
      221 	call mu_temp_segments$get_temp_segment (database_index, caller_name, temp_area_ptr, error_code);
      222 	if error_code ^= 0 then
      223 	     call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a",
      224 		"Unable to get a tempoaray segment.");
      225 
      226 	if dbcb.dsm_sw & error_code = 0 then do;
      227 		call mrds_dsm_open$read ((rm_db_info.sm_path), submodel_iocb_ptr, error_code);
      228 		if error_code ^= 0 then
      229 		     call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a ^a",
      230 			"Unable to open the submodel using the path -", rm_db_info.sm_path);
      231 	     end;
      232 
      233 /* allocate structure to keep track of duplicate rm_attr_info's */
      234 
      235 	rai_init_number_of_attributes = mrds_data_$number_of_resultant_attributes;
      236 	allocate resultant_attributes_info in (dbcb.static_area)
      237 	     set (resultant_attributes_info_ptr);
      238 	resultant_attributes_info.current_number_of_attributes = 0;
      239 
      240 /* make a call to ready_file for each of the files in the ready list */
      241 
      242 	do frdy_ptr = db_rdy.frdy_ptr repeat file_rdy.next
      243 	     while (frdy_ptr ^= null () & error_code = 0);
      244 
      245 	     call mu_sec_make_res (dbrdy_ptr, frdy_ptr, temp_area_ptr, submodel_iocb_ptr, resultant_attributes_info_ptr, error_code);
      246 
      247 	     if error_code = error_table_$moderr |
      248 		error_code = error_table_$no_info then /* no access on entry */
      249 		error_code = mrds_error_$no_model_access;
      250 	     else file_rdy.file_readied = ON;		/* even if not error free, so can be un-built */
      251 
      252 	end;
      253 
      254      end;
      255 
      256 clean_up: proc;
      257 
      258 /* clear the database file ready list out of the dbcb area */
      259 /* in addition, un-ready any files readied, if an error occured */
      260 
      261 	declare hold_ptr		 ptr;
      262 	declare rel_info_ptr	 ptr;
      263 
      264 	finish_code = 0;
      265 	if submodel_iocb_ptr ^= null () then do;
      266 		call mrds_dsm_close (submodel_iocb_ptr, finish_code);
      267 		if finish_code ^= 0 & ^clean_up_condition then
      268 		     call sub_err_ (finish_code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      269 			"Unable to close the submodel during clean up.");
      270 	     end;
      271 	if temp_area_ptr ^= null () then do;
      272 		call mu_temp_segments$delete_temp_segment (caller_name, temp_area_ptr, finish_code);
      273 		if finish_code ^= 0 & ^clean_up_condition then
      274 		     call sub_err_ (finish_code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      275 			"Unable to release a temp segment during clean up.");
      276 	     end;
      277 
      278 	if dbrdy_ptr ^= null () then do;
      279 
      280 		do frdy_ptr = db_rdy.frdy_ptr re   
.6     .-ÜÿÿÿÖ  gPlatnich              Office              RÆ£j   .=     .A     ê.-ðÿÿÿÖ  hPlatnich              Office              RÊ_Q   .|     .~     D.,.ÿÿÿÖ  iMQuintin              CDC                 RÊ¿¡Þˆ   .     	.’     H.@.ÿÿÿÖ  jDurand                Multics             RÊóR´U   .¤     !.­     z.T.,ÿÿÿÖ  kPlatnich              Office              RË†,x¡   .Ì     .Î     Q.h.@ÿÿÿÖ  lPlatnich              Office              RË“ã÷   .ã     .ê     `.|.TÿÿÿÖ  mPlatnich              Office              RË¯o2h   .     .     ..hÿÿÿÖ  nHinatsu               Multics             RËã•ÖŸ   .     .     +.¤.|ÿÿÿÖ  oHoover                Multics             RÌw   .     .#     '.¸.ÿÿÿÖ  pPlatnich              Office              RÏ-ƒÇ¥   .-     
.0     #.Ì.¤ÿÿÿÖ  qLyttle                Multics             RÏ0…¨è   .9     .=     Œ.à.¸ÿÿÿÖ  rPlatnich              Office              RÏ`ªrá   .`     .d     .ô.ÌÿÿÿÖ  sDonaldson             Multics             RÏÌs_   .k     .r     _..àÿÿÿÖ  tHoover                Multics             RÐ™Q÷x   .Š     .     %..ôÿÿÿÖ  uPlatnich              Office              RÑ0ïÍ   .š     
.     @.0.ÿÿÿÖ  vHoover                Multics             RÒ’ø   .­     .³     %.D.ÿÿÿÖ  wPlatnich              Office              RÒ>“v,   .½     .¿     .X.0ÿÿÿÖ  xANeal                 Multics             RÒ•¥d   .Ç     .Ï     ,.l.DÿÿÿÖ  yVu                    Multics        .Ð   RÓ|,“Ž   .Ú     	.Ý     J.€.XÿÿÿÖ  zPalmer                Multics             RÓŸ’ 5   .ð     .ó     ™.”.lÿÿÿÖ  {Platnich              Office              RÓ«;Ä©   /     /     ,.¨.€ÿÿÿÖ  |Zimmerman             Multics             RÓX‚zM   /(     (/2     J.¼.”ÿÿÿÖ  }Platnich              Office              RÔ,â¢   /E     /F     <.Ð.¨ÿÿÿÖ  ~Vu                    Multics      .l     RÔ-A.   /U     /Y     0.ä.¼ÿÿÿÖ  Platnich              Office              RÔE§•î   /e     /f     $.ø.ÐÿÿÿÖ  €Hoover                Multics             RÔªqt   /o     /u     '/.äÿÿÿÖ  Willott               Office              RÔÉ*®¹   /     /‚     L/ .øÿÿÿÖ  ‚Platnich              Office         /è   RØµÙ£Ô   /•     /˜     I/4/ÿÿÿÖ  ƒHoover                Multics             RØ¸2˜H   /«     /°     /H/ ÿÿÿÖ  „Schroth               SysMaint            RØÌ u   /¸     /¾     (/\/4ÿÿÿÖ  …Hoover                Multics             RÙ1W’È   /È     /Î     %/p/HÿÿÿÖ  †Platnich              Office              RÙƒ©XÑ   /Ø     /Û     4/„/\ÿÿÿÖ  ‡Hoover                Multics             RÚÍvö   /è     /î     %/˜/pÿÿÿÖ  ˆDRobinson             Multics             RÚÖn ¦   /ø     /ú     >/¬/„ÿÿÿÖ  ‰Kokol                 Office              RÚÞò¯ä   /
     /     /À/˜ÿÿÿÖ  ŠKokol                 Office              RÚÞbÁ^   /     /     /Ô/¬ÿÿÿÖ  ‹Willott               Office              RÚó[Â^   /     /"     &/è/ÀÿÿÿÖ  ŒFudge                 SysAdmin     /      RÛv*B   /,     /0     …/ü/ÔÿÿÿÖ  Kokol                 Office              RÛÇU^   /R     /T     7//èÿÿÿÖ  ŽCollin                Multics             RÛ™6¤u   /b     /j     M/$/üÿÿÿÖ  Hoover                Multics             RÜ7FI¼   /~     /„     %/8/ÿÿÿÖ  Kokol                 Office              RÜAK>   /Ž     /     /L/$ÿÿÿÖ  ‘Kokol                 Office              RÜA—YÍ   /—     /™     /`/8ÿÿÿÖ  ’Miko                  Multics             RÜI˜Ìm   /      !/©     /t/LÿÿÿÖ  “Elliott               Multics             RÜdÇSa   /®     /³     /ˆ/`ÿÿÿÖ  ”Schroth               SysMaint            RÜ+S{b   /¹     /½     ;/œ/tÿÿÿÖ  •Durand                Multics             RÜD	‡   /Ì     /Ó     ~/°/ˆÿÿÿÖ  –Oke                   Multics             RÝ¿d«
   /ó     &/ý     V/Ä/œÿÿÿÖ  —Wright                Multics             RÝAAï   0     0     ,/Ø/°ÿÿÿÖ  ˜Hoover                Multics             RÝS3Åt   0      0&     '/ì/ÄÿÿÿÖ  ™Hoover                Multics             RáM~“Ï   00     05     0 /Øxed bin (35), char (*), ptr, fixed bin (35));
      352 	dcl     mu_temp_segments$delete_temp_segment entry (char (*), ptr, fixed bin (35));
      353 	dcl     mu_sec_make_res	 entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
      354 	dcl     hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2),
      355 				 ptr, fixed bin (35));
      356 
  1     1 /* BEGIN mdbm_db_file_list.incl.pl1 -- odf, 8/21/78 */
  1     2 /* modified by Jim Gray -- 5/23/79, to add dbm_ptr to db_rdy, and fa_index to file_rdy */
  1     3 /* modified by Jim Gray -- June 1979, to add finish file structures */
  1     4 
  1     5 /* these structures are used as the parameter interface between
  1     6*   mrds_dsl_ready_file - mu_sec_make_res and
  1     7*   mrds_dsl_finish_file - mu_sec_unmake_res.  */
  1     8 
  1     9 dcl 1 db_rdy based (dbrdy_ptr),			/* ready file list header */
  1    10     2 dbi fixed bin (35),				/* data base index */
  1    11     2 dbcb_ptr ptr,					/* points to data base control block */
  1    12     2 db_model_ptr ptr,				/* pointer to db_model for this db */
  1    13     2 frdy_ptr ptr;					/* points to first in list of files to be readied */
  1    14 
  1    15 dcl 1 file_rdy based (frdy_ptr),			/* files to be readied */
  1    16     2 next ptr,					/* next file  in list */
  1    17     2 name char (30),				/* name of file */
  1    18     2 mode fixed bin,				/* mode in which file is to be readied */
  1    19     2 file_array_index fixed bin,			/* location in file array */
  1    20     2 file_readied bit (1) unal,			/* on => we have readied this file */
  1    21     2 unused bit (35) unal ;				/* for future use */
  1    22 
  1    23 
  1    24 dcl  dbrdy_ptr ptr;
  1    25 dcl  frdy_ptr ptr;
  1    26 
  1    27 dcl 1 db_fin based (dbfin_ptr),			/* finish file list header */
  1    28     2 dbi fixed bin (35),				/* data base index */
  1    29     2 dbcb_ptr ptr,					/* points to data base control block */
  1    30     2 ffin_ptr ptr;					/* points to first in list of files to be finished */
  1    31 
  1    32 dcl 1 file_fin based (ffin_ptr),			/* files to be finished */
  1    33     2 next ptr,					/* next file  in list */
  1    34     2 name char (30),				/* name of file */
  1    35     2 file_array_index fixed bin ;			/* index of file name in resultant file array */
  1    36 
  1    37 
  1    38 dcl  dbfin_ptr ptr;
  1    39 dcl  ffin_ptr ptr;
  1    40 
  1    41 /* END mdbm_db_file_list.incl.pl1  */
  1    42 
      357 
      358 
  2     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  2     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  2     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 /* WARNING
  2    13*          If the rm_db_info structure is changed then the mrds_data_
  2    14*          item saved_res_version MUST be incremented to invalidate all
  2    15*          existing saved resultants
  2    16**/
  2    17 
  2    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  2    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  2    20*   resultant model that is created partially at database open  time,
  2    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  2    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  2    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  2    24*   to  provide  an  efficient  means  of  accessing  database  model
  2    25*   information, as seen from the possibly submodel view of the user,
  2    26*   and his current state of "files readied". it is the  secure  part
  2    27*   because  it  contains  the  model  information  which needs to be
  2    28*   protected  from  general  knowledge,  and   this   segment   will
  2    29*   eventually  be  capable  of  being in a lower ring. the structure
  2    30*   itself points to four arrays that are  allocated  in  it's  area,
  2    31*   that  in  turn point to the other structures mentions above, also
  2    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  2    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  2    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  2    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  2    36*   list of all known file names, the rm_rel_array only gets relation
  2    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  2    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  2    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  2    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  2    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  2    42*   file infos point to contained rel infos, the rel infos  point  to
  2    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  2    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  2    45*   foreign     keys    are    represented    by    the    structures
  2    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  2    47*   pathnames  of the model and submodel, if any, are also maintained
  2    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  2    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  2    50*   individual include files for  further  organization  information,
  2    51*   and particular data structures.
  2    52*
  2    53*   HISTORY:
  2    54*
  2    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  2    56*   so that define_area_ could be used to make it an extensible area
  2    57*
  2    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  2    59*   resultant in mu_database_index easier to keep, since no reference
  2    60*   to the area is needed.
  2    61*
  2    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  2    63*   resultant.
  2    64*
  2    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  2    66*   structure.
  2    67*
  2    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  2    69*   are  now  combined  into  the rel_array. Removed the control file
  2    70*   info which was unused. Added pointer  to  head  of  domain  list,
  2    71*   which is to be used to insure only one copy of each domain info.
  2    72*
  2    73*   83-05-19 Davids: Added the  saved_res_version element.
  2    74*
  2    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  2    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  2    77*   check, encode, or decode proc.
  2    78*
  2    79*   CAUTION: The structure entries from db_version to sm_path  should
  2    80*   not  be moved or have their declarations changed because they are
  2    81*   used in the handling of old version database openings.
  2    82*
  2    83*
  2    84**/
  2    85 
  2    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  2    87 	     2 data	      like rm_db_info_data,
  2    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  2    89 
  2    90      dcl	   rdbi_ptr	      ptr;
  2    91 
  2    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  2    93*						   like reference to it without getting the area as well */
  2    94 	     2 db_version	      fixed bin,		/* version no. of db */
  2    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  2    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  2    97 	     2 db_path	      char (168),		/* abs. path of db. */
  2    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  2    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  2   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  2   101 	     2 pad	      bit (34) unal,	/* for future use */
  2   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  2   103*                                                               dbcb and rdbi segments in the db dir */
  2   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  2   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  2   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  2   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  2   108 
  2   109 /* END mdbm_rm_db_info.incl.pl1 */
  2   110 
  2   111 
      359 
      360 
  3     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  3     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  3     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  3     9*     Nguyen. The scopes_changed flag was added to make checking for this
  3    10*     more efficient (mrds error list #137).
  3    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  3    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  3    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  3    14*     care if multiple txns use the same selection_expression. (mrds #156)
  3    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  3    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  3    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  3    18*                                                   END HISTORY COMMENTS */
  3    19 
  3    20 
  3    21 /* WARNING
  3    22*          If the dbcb structure is changed then the mrds_data_
  3    23*          item saved_res_version MUST be incremented to invalidate all
  3    24*          existing saved resultants
  3    25**/
  3    26 
  3    27 /* HISTORY :
  3    28*
  3    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  3    30*   tid_list management
  3    31*
  3    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  3    33*   phony resultant in mu_database_index, without having the area dcl
  3    34*   included.
  3    35*
  3    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  3    37*   mrds_dsl_store
  3    38*
  3    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  3    40*   switches
  3    41*
  3    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  3    43*   expression,  so  that relation statistics can be updated relative
  3    44*   to number of selection expressions seem. Also  removed  init  for
  3    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  3    46*   mrds_dsl_init_res.
  3    47*
  3    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  3    49*
  3    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  3    51*   for the conversion to the relation manager.
  3    52*
  3    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  3    54*   substructures so that the entries and costs can change
  3    55*   depending on the type of database that is opened.
  3    56*
  3    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  3    58*   since modify uses a different vector type (general) than does store.
  3    59*
  3    60*   82-09-20 Davids: changed names of (store modify)_vector to
  3    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  3    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  3    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  3    64*   during the first call.
  3    65*
  3    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  3    67*   since it deals with the pointers to the cursors and not the cursors
  3    68*   themelves and added the element cursor_storage_area_ptr which points
  3    69*   to the area where the cursors are kept.
  3    70*
  3    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  3    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  3    73*   anything.
  3    74*
  3    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  3    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  3    77*   by mrds_dsl_define_temp_rel.
  3    78*
  3    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  3    80*   is needed by mu_store.
  3    81*
  3    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  3    83*   bin to float bin since the values are not integers.
  3    84*
  3    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  3    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  3    87*   added to the end of the structure to allow modules that don't use
  3    88*   the element to continue to reference the dbcb structure without recompiling.
  3    89*
  3    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  3    91*   are needed so that temp rels can be created with the same file attributes
  3    92*   as the permanent relations.
  3    93*
  3    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  3    95*   added the resultant_in_pdir bit.
  3    96*
  3    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  3    98*   added the res_already_made element.
  3    99*
  3   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  3   101*
  3   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  3   103*   one of the unused pointers.
  3   104*
  3   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  3   106*
  3   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  3   108*   leaving unused_ptrs(1).
  3   109*
  3   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  3   111*   unused_ptrs (1).
  3   112*
  3   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  3   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  3   115*   spare ptrs, entries and reserved storages for future enhancement, since
  3   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  3   117*
  3   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  3   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  3   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  3   121**/
  3   122 
  3   123 
  3   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  3   125*   that constitutes the non-secure portion of the resultant model that is
  3   126*   created during the opening of a database. it contains variables that
  3   127*   are used during the runtime access of the database, and an area
  3   128*   for evaluation of requests. it points to four other
  3   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  3   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  3   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  3   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  3   133*   used in the elimination of duplicate tuples during a retrieve.
  3   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  3   135*   that is used when the database is using the file scope mechanism
  3   136*   for concurrency control over file readying. the segment overlayed via
  3   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  3   138*   across database openings. the pointer to this dbcb structure is kept in a table
  3   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  3   140*   opening instances of resultant models. (see mu_database_index routine) */
  3   141 
  3   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  3   143 	     2 data	      like dbcb_data,
  3   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  3   145 
  3   146      dcl	   dbcb_ptr	      ptr;
  3   147 
  3   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  3   149*						   like references can avoid getting the area declaration */
  3   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  3   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  3   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  3   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  3   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  3   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  3   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  3   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  3   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  3   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  3   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  3   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  3   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  3   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  3   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  3   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  3   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  3   167*						   for eliminating duplicate tuples. */
  3   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  3   169*						   for eliminating duplicate tuples. */
  3   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  3   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  3   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  3   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  3   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  3   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  3   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  3   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  3   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  3   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  3   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  3   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  3   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  3   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  3   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  3   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  3   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  3   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  3   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  3   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  3   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  3   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  3   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  3   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  3   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  3   195 	     2 val_del	      bit (1) unal,		/* for delete */
  3   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  3   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  3   198*                                                                     not imply that the database is of type page_file */
  3   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  3   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  3   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  3   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  3   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  3   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  3   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  3   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  3   207*						   inside a sequence of -another selection expression. */
  3   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  3   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  3   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  3   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  3   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  3   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  3   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  3   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  3   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  3   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  3   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  3   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  3   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  3   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  3   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  3   223 	     2 relmgr_entries,			/* relation manager entries */
  3   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  3   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  3   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  3   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  3   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  3   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  3   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  3   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  3   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  3   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  3   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  3   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  3   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  3   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  3   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  3   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  3   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  3   241 	       3 reserved_entries (5) entry (),
  3   242 	     2 access_costs,			/* access costs for permute */
  3   243 	       3 total_primary_key_cost float bin,
  3   244 	       3 access_cost      float bin,
  3   245 	       3 access_overhead  float bin,
  3   246 	       3 us_access_cost   float bin,
  3   247 	       3 os_access_cost   float bin,
  3   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  3   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  3   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  3   251 
  3   252 /* END mrds_dbcb.incl.pl1 */
  3   253 
  3   254 
      361 
      362 
  4     1 /*   BEGIN INCLUDE FILE mrds_res_attr_info.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-05-14,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
  4     6*     install(86-08-15,MR12.0-1127):
  4     7*     Created by Al Dupuis to resolve a problem where the "rdbi" segment was
  4     8*     overflowing. Previously mrds was allocating a "rm_attr_info" structure for
  4     9*     each attribute in each relation. In certain cases (phx20301, mrds #154)
  4    10*     with very large databases, this resulted in thousands of structures being
  4    11*     allocated. This new include keeps track of "rm_attr_info" structures and
  4    12*     stops duplicates from being allocated, bringing the allocation counts down
  4    13*     from the thousands to the hundreds.
  4    14*                                                   END HISTORY COMMENTS */
  4    15 
  4    16 dcl 1 resultant_attributes_info aligned based (resultant_attributes_info_ptr),
  4    17       2 number_of_attributes fixed bin,
  4    18       2 current_number_of_attributes fixed bin,
  4    19       2 attributes (rai_init_number_of_attributes refer (resultant_attributes_info.number_of_attributes)),
  4    20         3 name char (32) unaligned,
  4    21         3 value_ptr ptr;
  4    22 dcl rai_init_number_of_attributes fixed bin;
  4    23 dcl resultant_attributes_info_ptr ptr;
  4    24 
  4    25 /*   END INCLUDE FILE mrds_res_attr_info.incl.pl1 */
      363 
      364 
  5     1 /* BEGIN mdbm_rm_rel_array.incl.pl1 -- jaw, 8/9/78 */
  5     2 
  5     3 /* WARNING
  5     4*          If the rm_rel_array structure is changed then the mrds_data_
  5     5*          item saved_res_version MUST be incremented to invalidate all
  5     6*          existing saved resultants
  5     7**/
  5     8 
  5     9 /* HISTORY:
  5    10*
  5    11*   81-05-28 Jim Gray : added  model_name  and  file_id  as  part  of
  5    12*   combining   funtions   of   file_array  and  rel_array  into  one
  5    13*   structure. This will only allow 1 relation per file model now.
  5    14*   Also changed structure to allow more efficient searching
  5    15*   via and index builtin, rather than a programmed loop.
  5    16*   Search is now I = index(string(rm_rel_array.name), "!" || in_name)
  5    17*   with I = ((I - 1) / 33) + 1 to convert from a char to array index.
  5    18*
  5    19**/
  5    20 
  5    21 
  5    22 /* this structure is allocated in the static are of the structure
  5    23*   in  mdbm_rm_db_info.incl.pl1,  the secure portion of the database
  5    24*   resultant  model  upon  opening  the  database.  two  copies  are
  5    25*   allocated,  one for temporary relations, initially empty, and one
  5    26*   for relations known to the opener, which has a length  sufficient
  5    27*   for  all  relations known to the user, but whose names, etc. will
  5    28*   not be filled  in  until  the  file  containing  that  particular
  5    29*   relation  is readied. the rm_db_info structure contains a pointer
  5    30*   to the rel_arrays, and the array entries, when  "readied",  point
  5    31*   to  the  mdbm_rm_rel_info.incl.pl1  structures  containing  model
  5    32*   information about the relation, it's attributes, etc. */
  5    33 
  5    34 dcl 1 rm_rel_array aligned based (rmra_ptr),		/* array of open relations */
  5    35     2 num_rels fixed bin,				/* no. rels in db. */
  5    36     2 name (1:rm_num_rels_init refer (rm_rel_array.num_rels)) unal,
  5    37       3 mark char (1) unal,				/* separator character = "!" */
  5    38       3 submodel char (32) unal,			/* name of relation is submodel view, model opening => model name */
  5    39     2 rel_data (rm_num_rels_init refer (rm_rel_array.num_rels)),
  5    40       3 model_name char (30),				/* name of relation in model */
  5    41       3 ri_ptr ptr unal ;				/* pointer to rm_rel_info */
  5    42 
  5    43 dcl  rmra_ptr ptr;
  5    44 dcl  rm_num_rels_init fixed bin;
  5    45 
  5    46 /* END mdbm_rm_rel_array.incl.pl1 */
  5    47 
  5    48 
      365 
      366 
  6     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  6     2 
  6     3 /* WARNING
  6     4*          If the rm_rel_info structure is changed then the mrds_data_
  6     5*          item saved_res_version MUST be incremented to invalidate all
  6     6*          existing saved resultants
  6     7**/
  6     8 
  6     9 /* HISTORY:
  6    10*
  6    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  6    12*   attributes,   and   varying  attributes,  so  that  partial  view
  6    13*   submodels will have the  info  needed  to  properly  set  up  the
  6    14*   varying length array headers in the tuple structure.
  6    15*
  6    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  6    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  6    18*   delete_tuple_perm, and make m_perm = unused_perm.
  6    19*
  6    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  6    21*   view attribute was varying character or bit, since a partial view
  6    22*   submodel will not have this information in the resultant, and  it
  6    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  6    24*   since with exact length storage  of  varying  length  attributes,
  6    25*   each  tuple  can  be  a  different  length,  which is can only be
  6    26*   determined by examining the tuple itself.
  6    27*
  6    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  6    29*   interface  to  allow  temp  rel  population  to  be known, and to
  6    30*   provide a more efficient means of finding an approx. current perm
  6    31*   relation population.
  6    32*
  6    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  6    34*   blocked  files, foreign keys, and ids procedures. Also set number
  6    35*   of files per rel to a constant of 1.
  6    36*
  6    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  6    38*   structure so that only one structure per relation is needed.
  6    39*
  6    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  6    41*   counts.   Also  added  number  of  operations  count  since  last
  6    42*   statistics update, and a time  since  the  statistics  were  last
  6    43*   updated.
  6    44*
  6    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  6    46*   identifier so that small relations could be updated on a per S.E.
  6    47*   basis
  6    48*
  6    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  6    50*   to end of structure   TR 12205 (Suggestion).
  6    51*   
  6    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  6    53*   the DMS conversion. 
  6    54*
  6    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  6    56*   array and the niocb element for DMS conversion. Also removed the
  6    57*   number_selected array (and ri_niocbs_init) since subsets are not
  6    58*   going to be used.
  6    59*
  6    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  6    61*   so that it can be used with relation manager.  Also added
  6    62*   rm_rel_info.primary_key_index_id for relation manager.
  6    63*
  6    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  6    65*   nvar_atts, model_nvar_atts.
  6    66*
  6    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  6    68*   since the duplicate key count for each secondary index is now being
  6    69*   kept in the attr_info structure and key_count was only needed to
  6    70*   help in calculating the average selectivity of each index which
  6    71*   can now be gotten directly from each index's dup key count. Also
  6    72*   removed the file_id element since it is no longer needed for
  6    73*   anything.
  6    74*
  6    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  6    76*   was removed.
  6    77*
  6    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  6    79*   used when retrieving tuples from this relation.
  6    80*
  6    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  6    82*   for the relation. Note that this structure is part of the resultant NOT
  6    83*   part of the db.control structure. The scopes are duplicated in the resultant
  6    84*   to reduce contention for the db.control structure. Note also that the pointer
  6    85*   will always point to a scope_flags structure even if no scopes have been
  6    86*   set on the relation, the structure is allocated when the db is opened.
  6    87**/
  6    88 
  6    89 
  6    90 /* DESCRIPTION:
  6    91*
  6    92*   This structure is allocated in the area part of the structure  in
  6    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  6    94*   at open  time  for  a  database.  There  will  be  one  of  these
  6    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  6    96*   database view (there may be less than the total in  the  database
  6    97*   for  a  submodel  openings).  There  will  also  be  one for each
  6    98*   temporary relation currently defined for that opening.
  6    99*
  6   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  6   101*   all  rm_rel_info  structures  allocated. It is used for searching
  6   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  6   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  6   104*   rels.
  6   105*
  6   106*   The      rm_rel_info      structure      points      to       the
  6   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  6   108*   appearing in this view of the relation. Each  of  these  in  turn
  6   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  6   110*   info for each attr.
  6   111*
  6   112*   Most of the other information here deals with  specifics  of  the
  6   113*   relation's  logical  definition,  such as key and secondary index
  6   114*   attribute inidicators, security permissions, and  tuple  physical
  6   115*   construction details.
  6   116*
  6   117**/
  6   118 
  6   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  6   120 	     2 name	      char (32),		/* from submodel */
  6   121 	     2 model_name	      char (30),		/* from model */
  6   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  6   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  6   124 	     2 modify	      bit (1) unal,
  6   125 	     2 delete	      bit (1) unal,
  6   126 	     2 store	      bit (1) unal,
  6   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  6   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  6   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  6   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  6   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  6   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  6   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  6   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  6   135 	     2 reserved	      bit (24) unal,	/* for future use */
  6   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  6   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  6   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  6   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  6   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  6   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  6   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  6   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  6   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  6   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  6   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  6   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  6   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  6   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  6   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  6   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  6   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  6   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  6   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  6   155 
  6   156      dcl	   rmri_ptr	      ptr;
  6   157      dcl	   (nkey_attr_init,
  6   158 	   natts_init,
  6   159 	   nvar_atts_init)	      fixed bin;
  6   160 
  6   161 /* END mdbm_rm_rel_info.incl.pl1 */
  6   162 
  6   163 
      367 
      368 
  7     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  7     6*     modified to save space occupied by model
  7     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  7     8*     to add mdbm_secured bit in db_model
  7     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  7    10*     collapsed the following into an unused_offset array:
  7    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  7    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  7    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  7    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  7    15*       unused_1
  7    16*     Also changed the name of unused_2 to restructuring_history_offset
  7    17*     and changed the comment on the changer structure to indicate
  7    18*     that it will contain on database creation information.
  7    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  7    20*     used one of the unused_offsets to point to a message which indicates
  7    21*     why the db is inconsistent. The offset will be null when the db is created
  7    22*     and set the first time the message is used. this is so it will be
  7    23*     consistent with existing data bases. Also added the message structure.
  7    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  7    25*     added the undo_request element to the message structure
  7    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  7    27*     changed unused_offset (12) to last_restructruring_history_offset and
  7    28*     changed restructuring_history_offset to first_restructuring_history_offset
  7    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  7    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  7    31*     1 => vfile database and 2 => page_file database. Up to this point all
  7    32*     database types were equal to 1.
  7    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  7    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  7    35*     flags. This will allow information about transactions and dm_file
  7    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  7    37*     change is compatable with all datamodels created by the released version
  7    38*     of mrds.
  7    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  7    40*     added the rollback_on flag to the db_type_flags since it appears that you
  7    41*     can have a dmfile database that requires transactions but does not have any
  7    42*     journalizing. Also switched the order of the transactions_needed and
  7    43*     concurrency_on flags - this makes the change compatable with existing
  7    44*     dmfile databases except when displaying the model since concurrency_on and
  7    45*     rollback_on will be off in the model even though the dmfile relations had
  7    46*     them on during creation.
  7    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  7    48*      Removed ctl_file_path_ptr.
  7    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  7    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  7    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  7    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  7    53*      in the flag word for rmdb copying.
  7    54*                                                   END HISTORY COMMENTS */
  7    55 
  7    56 
  7    57 /* this include file contains the structures that go into the make up
  7    58*   of the "db_model" segment in the model for the database.
  7    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  7    60*
  7    61*   the db_model structure goes at the base of the segment, and contains items unique to
  7    62*   the whole databse. in addition, it has an area of size to fill the
  7    63*   rest of a segment, that holds the lists of files and domains in the database.
  7    64*   these lists are singly forward linked lists. all "pointers" in the database model
  7    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  7    66*   since actual pointers are process dependent on segment number.
  7    67*   the remaining structures are first a path_entry one to save pathnames in,
  7    68*   and the stack_item and constent structures, used to save a boolean
  7    69*   expression in polish form, with the stack represented by a linked list.
  7    70*   the final structure is one for identifying the status of version information */
  7    71 
  7    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  7    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  7    74 	     2 db_type_flags      unal,
  7    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  7    76 	       3 unused	      (13) bit (1) unal,
  7    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  7    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  7    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  7    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  7    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  7    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  7    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  7    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  7    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  7    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  7    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  7    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  7    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  7    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  7    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  7    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  7    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  7    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  7    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  7    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  7    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  7    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  7    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  7   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  7   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  7   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  7   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  7   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  7   105 
  7   106      dcl	   dbm_ptr	      ptr;
  7   107 
  7   108 /* the files in the database each have a file_info containing
  7   109*   their name, the file_model for each file is found by initiating the
  7   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  7   111*   the file_info list is a singly linked list in definition order */
  7   112 
  7   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  7   114 	     2 file_name	      char (30),		/* name of file */
  7   115 	     2 file_id	      bit (36),		/* id number of file */
  7   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  7   117 	     2 unused	      unal bit (18);	/* for future expansion */
  7   118 
  7   119      dcl	   fi_ptr		      ptr;
  7   120 
  7   121 /* each domain used in the database will have a domain info saved in the db_model
  7   122*   segment. it describes the domain of the given name, and it's options.
  7   123*   the domain_info's form a singly linked list in definition order */
  7   124 
  7   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  7   126 	     2 name	      char (32),		/* name of domain */
  7   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  7   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  7   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  7   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  7   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  7   132 	     2 reserved	      bit (31) unal,
  7   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  7   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  7   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  7   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  7   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  7   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  7   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  7   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  7   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  7   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  7   143 	     2 str_err_path_ptr   unal bit (18),
  7   144 	     2 str_after_path_ptr unal bit (18),
  7   145 	     2 get_before_path_ptr unal bit (18),
  7   146 	     2 get_err_path_ptr   unal bit (18),
  7   147 	     2 get_after_path_ptr unal bit (18),
  7   148 	     2 mod_before_path_ptr unal bit (18),
  7   149 	     2 mod_err_path_ptr   unal bit (18),
  7   150 	     2 mod_after_path_ptr unal bit (18),
  7   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  7   152 	     2 unused_2	      unal bit (18),
  7   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  7   154 
  7   155      dcl	   di_ptr		      ptr;
  7   156 
  7   157 /* information necessary for attributes that are not used in any relation */
  7   158 
  7   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  7   160 	     2 name char (32),			/* name of attribute */
  7   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  7   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  7   163 	     2 unused (2) bit (18) unal;
  7   164 
  7   165      dcl     ua_ptr ptr;
  7   166 
  7   167 
  7   168 /* space saving pathname$entryname structure, to be allocated
  7   169*   only when a path$entry has to be saved, else only a bit(18)
  7   170*   offset takes up space in the main model structure */
  7   171 
  7   172      declare 1 path_entry	      based (path_entry_ptr),
  7   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  7   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  7   175 	     2 reserved	      unal bit (36);	/* for future use */
  7   176 
  7   177      declare path_entry_ptr	      ptr;
  7   178 
  7   179 
  7   180 
  7   181 
  7   182 
  7   183 /* declarations for model of postfix stack holding the check option boolean expression
  7   184*   the following encoding values indicate the corresponding type of stack element
  7   185*
  7   186*   1  =
  7   187*   2  ^=
  7   188*   3  >
  7   189*   4  <
  7   190*   5  >=
  7   191*   6  <=
  7   192*
  7   193*   10  and
  7   194*   20  or
  7   195*   30  not
  7   196*
  7   197*   40  - (minus)
  7   198*
  7   199*   50  domain variable(same name as domain)
  7   200*
  7   201*   60  constant(number, bit string, or character string)
  7   202*
  7   203**/
  7   204 
  7   205 
  7   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  7   207 	     2 next	      bit (18),		/* link to next in list */
  7   208 	     2 type	      fixed binary,		/* code for this element type */
  7   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  7   210*						   if this is a constant element type */
  7   211 
  7   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  7   213 
  7   214 
  7   215 
  7   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  7   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  7   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  7   219 
  7   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  7   221 
  7   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  7   223 
  7   224 /* version structure, giving status of source for CMDB/RMDB,
  7   225*   status of model, and status of resultant */
  7   226 
  7   227 /* version number is in form MM.N.Y
  7   228*   where MM is the major version number, N is the minor version alteration,
  7   229*   and Y is the lastest modification to that alteration,
  7   230*   where M and N represent numbers 0-9, and Y is a letter */
  7   231 
  7   232      declare 1 version_status	      unal based (version_status_ptr),
  7   233 	     2 cmdb_rmdb,
  7   234 	       3 major	      fixed bin,
  7   235 	       3 minor	      fixed bin,
  7   236 	       3 modification     char (4),
  7   237 	     2 model,
  7   238 	       3 major	      fixed bin,
  7   239 	       3 minor	      fixed bin,
  7   240 	       3 modification     char (4),
  7   241 	     2 resultant,
  7   242 	       3 major	      fixed bin,
  7   243 	       3 minor	      fixed bin,
  7   244 	       3 modification     char (4);
  7   245 
  7   246      declare version_status_ptr     ptr;
  7   247 
  7   248 
  7   249 /* maintains information only about the db creation */
  7   250 
  7   251      declare 1 changer	      unal based (changer_ptr),
  7   252 	     2 id		      char (32),
  7   253 	     2 time	      fixed bin (71),
  7   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  7   255 
  7   256      declare changer_ptr	      ptr;
  7   257 
  7   258 
  7   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  7   260 	     02 len	      fixed bin,		/* length of the message */
  7   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  7   262 	     02 name	      char (32),		/* name of thing that set the message */
  7   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  7   264*                                                               that caused the database to become inconsistent */
  7   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  7   266 
  7   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  7   268 
  7   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  7   270 
  7   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  7   272 
  7   273 
      369 
      370 
      371      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1314.1  mrds_dsl_ready_all.pl1            >special_ldd>install>MR12.2-1073>mrds_dsl_ready_all.pl1
357          1    10/14/83  1608.6  mdbm_db_file_list.incl.pl1        >ldd>include>mdbm_db_file_list.incl.pl1
359          2    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
361          3    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
363          4    08/15/86  1715.1  mrds_res_attr_info.incl.pl1       >ldd>include>mrds_res_attr_info.incl.pl1
365          5    10/14/83  1609.1  mdbm_rm_rel_array.incl.pl1        >ldd>include>mdbm_rm_rel_array.incl.pl1
367          6    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
369          7    10/17/86  1404.3  mdbm_db_model.incl.pl1            >ldd>include>mdbm_db_model.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
OFF                             000117 automatic       bit(1)                   initial packed unaligned dcl 332 set ref 98 204 316
                                                                                  332*
ON                              000116 automatic       bit(1)                   initial packed unaligned dcl 331 set ref 90 101 250
                                                                                  331*
caller_name                     000120 automatic       char(18)                 initial packed unaligned dcl 334 set ref 85* 146*
                                                                                  167* 221* 222* 228* 267* 272* 273* 297* 334*
clean_up_condition              000105 automatic       bit(1)                   packed unaligned dcl 328 set ref 98* 101* 267 273
                                                                                  291 297
cleanup                         000106 stack reference condition                dcl 329 ref 100
close                   152            based           entry variable           level 4 dcl 3-142 ref 295
continue                        000125 automatic       char(1)                  initial packed unaligned dcl 335 set ref 85* 146*
                                                                                  167* 222* 228* 267* 273* 297* 335*
current_number_of_attributes
                          1            based           fixed bin(17,0)          level 2 dcl 4-16 set ref 238*
data                                   based           structure                level 2 in structure "dbcb" dcl 3-142 in procedure
                                                                                  "ready_all"
data                                   based           structure                level 2 in structure "rm_db_info" dcl 2-86
                                                                                  in procedure "ready_all"
database_index                         parameter       fixed bin(35,0)          dcl 325 set ref 52 52 143* 146* 187 221*
db_model_ptr              4            based           pointer                  level 2 dcl 1-9 set ref 189*
db_path                   2            based           char(168)                level 3 dcl 2-86 ref 158 160 160 163 167
db_rdy                                 based           structure                level 1 unaligned dcl 1-9 set ref 185 306
dbcb                                   based           structure                level 1 dcl 3-142
dbcb_data                              based           structure                level 1 unaligned dcl 3-148
dbcb_ptr                        000140 automatic       pointer                  dcl 3-146 in procedure "ready_all" set ref 143* 144
                                                                                  153 183 185 188 199 226 236 295 302 306 311
dbcb_ptr                  2            based           pointer                  level 2 in structure "db_rdy" dcl 1-9 in procedure
                                                                                  "ready_all" set ref 188*
dbi                                    based           fixed bin(35,0)          level 2 dcl 1-9 set ref 187*
dbm_ptr                         000150 automatic       pointer                  dcl 7-106 set ref 157* 158* 163* 165 189
dbrdy_ptr                       000132 automatic       pointer                  dcl 1-24 set ref 94* 185* 186 187 188 189 208 209
                                                                                  242 245* 278 280 306 307*
dsm_sw                  106(08)        based           bit(1)                   level 3 packed packed unaligned dcl 3-142 ref 226
error_code                             parameter       fixed bin(35,0)          dcl 324 set ref 52 52 81* 84* 85* 109 145* 146* 158*
                                                                                  159 160* 161 161* 163* 165* 167* 221* 222 222* 226
                                                                                  227* 228 228* 242 245* 247 247 247* 291
error_table_$moderr             000022 external static fixed bin(35,0)          dcl 344 ref 159 161 247
error_table_$no_info            000026 external static fixed bin(35,0)          dcl 346 ref 247
fa_index                        000104 automatic       fixed bin(17,0)          dcl 327 set ref 118* 201 203
file_array_index         13            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 203* 294
file_rdy                               based           structure                level 1 unaligned dcl 1-15 set ref 199 302
file_readied             14            based           bit(1)                   level 2 packed packed unaligned dcl 1-15 set ref
                                                                                  204* 250* 291
finish_code                     000131 automatic       fixed bin(35,0)          dcl 341 set ref 264* 266* 267 267* 272* 273 273*
                                                                                  295* 297 297*
frdy_ptr                        000134 automatic       pointer                  dcl 1-25 in procedure "ready_all" set ref 199* 200
                                                                                  201 202 203 204 209 210 213 214 242* 242* 245*
                                                                                  250* 252 280* 280* 283 291 294 297 302*
frdy_ptr                  6            based           pointer                  level 2 in structure "db_rdy" dcl 1-9 in procedure
                                                                                  "ready_all" set ref 186* 208 209* 242 280
hcs_$initiate                   000046 constant        entry                    external dcl 354 ref 158 163
hold_ptr                        000100 automatic       pointer                  dcl 261 set ref 283* 304
info_ptr                        000126 automatic       pointer                  initial dcl 336 set ref 85* 146* 167* 222* 228* 267*
                                                                                  273* 297* 336*
last_frdy_ptr                   000114 automatic       pointer                  dcl 330 set ref 210* 213 214*
mode                     12            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 202*
mrds_data_$number_of_resultant_attributes
                                000030 external static fixed bin(35,0)          dcl 347 ref 235
mrds_dm_authorization$set_needed_access
                                000024 constant        entry                    external dcl 345 ref 160
mrds_dsm_close                  000034 constant        entry                    external dcl 349 ref 266
mrds_dsm_open$read              000036 constant        entry                    external dcl 350 ref 227
mrds_error_$invalid_db_index    000016 external static fixed bin(35,0)          dcl 339 ref 145
mrds_error_$no_model_access     000032 external static fixed bin(35,0)          dcl 348 ref 247
mrds_error_$no_recursion        000020 external static fixed bin(35,0)          dcl 343 ref 84
mu_database_index$get_resultant_model_pointer
                                000014 constant        entry                    external dcl 338 ref 143
mu_sec_make_res                 000044 constant        entry                    external dcl 353 ref 245
mu_temp_segments$delete_temp_segment
                                000042 constant        entry                    external dcl 352 ref 272
mu_temp_segments$get_temp_segment
                                000040 constant        entry                    external dcl 351 ref 221
name                      2            based           char(30)                 level 2 in structure "file_rdy" packed packed
                                                                                  unaligned dcl 1-15 in procedure "ready_all" set
                                                                                  ref 201* 297*
name                      1            based           structure                array level 2 in structure "rm_rel_array" packed
                                                                                  packed unaligned dcl 5-34 in procedure "ready_all"
next                                   based           pointer                  level 2 dcl 1-15 set ref 200* 213* 252 283
null                                                   builtin function         dcl 320 ref 94 95 96 97 144 157 165 183 186 200 208
                                                                                  242 265 271 278 280 295 307 311 336
num_rels                               based           fixed bin(17,0)          level 2 dcl 5-34 ref 118 294
number_of_attributes                   based           fixed bin(17,0)          level 2 dcl 4-16 set ref 236* 311
opening_id               42            based           bit(36)                  level 2 dcl 6-119 set ref 295*
previous_invocation             000010 internal static bit(1)                   initial packed unaligned dcl 342 set ref 83 90* 316*
ra_ptr                  134            based           pointer                  level 3 dcl 2-86 ref 173
rai_init_number_of_attributes   000142 automatic       fixed bin(17,0)          dcl 4-22 set ref 235* 236 236
rdbi_ptr                        000136 automatic       pointer                  dcl 2-90 in procedure "ready_all" set ref 153* 158
                                                                                  160 160 163 167 173 227 228
rdbi_ptr                               based           pointer                  level 3 in structure "dbcb" dcl 3-142 in procedure
                                                                                  "ready_all" ref 153
ready_mode                             parameter       fixed bin(17,0)          dcl 326 ref 52 52 202
rel_data                               based           structure                array level 2 dcl 5-34
rel_info_ptr                    000102 automatic       pointer                  dcl 262 set ref 294* 295 295
relmgr_entries          146            based           structure                level 3 dcl 3-142
resultant_attributes_info              based           structure                level 1 dcl 4-16 set ref 236 311
resultant_attributes_info_ptr   000144 automatic       pointer                  dcl 4-23 set ref 97* 236* 238 245* 311 311
return_value                    000130 automatic       fixed bin(35,0)          initial dcl 337 set ref 85* 146* 167* 222* 228* 267*
                                                                                  273* 297* 337*
ri_ptr                                 based           pointer                  array level 3 packed packed unaligned dcl 5-34 ref
                                                                                  294
rm_db_info                             based           structure                level 1 dcl 2-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 2-92
rm_rel_array                           based           structure                level 1 dcl 5-34
rm_rel_info                            based           structure                level 1 dcl 6-119
rmra_ptr                        000146 automatic       pointer                  dcl 5-43 set ref 118 173* 201 294
rtrim                                                  builtin function         dcl 320 ref 160 160 167 201
sm_path                  54            based           char(168)                level 3 dcl 2-86 set ref 227 228*
static_area             306            based           area                     level 2 dcl 3-142 ref 185 199 236 302 306 311
sub_err_                        000012 constant        entry                    external dcl 333 ref 85 146 167 222 228 267 273 297
submodel                  1(09)        based           char(32)                 array level 3 packed packed unaligned dcl 5-34 ref
                                                                                  201
submodel_iocb_ptr               000102 automatic       pointer                  dcl 323 set ref 96* 227* 245* 265 266*
temp_area_ptr                   000100 automatic       pointer                  dcl 322 set ref 95* 221* 245* 271 272*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
addr                                                   builtin function         dcl 320
alloc_length                           internal static fixed bin(35,0)          dcl 7-222
changer                                based           structure                level 1 packed packed unaligned dcl 7-251
changer_ptr                            automatic       pointer                  dcl 7-256
constant                               based           structure                level 1 unaligned dcl 7-216
constant_ptr                           automatic       pointer                  dcl 7-220
db_fin                                 based           structure                level 1 unaligned dcl 1-27
db_model                               based           structure                level 1 dcl 7-72
dbfin_ptr                              automatic       pointer                  dcl 1-38
di_ptr                                 automatic       pointer                  dcl 7-155
domain_info                            based           structure                level 1 dcl 7-125
ffin_ptr                               automatic       pointer                  dcl 1-39
fi_ptr                                 automatic       pointer                  dcl 7-119
file_fin                               based           structure                level 1 unaligned dcl 1-32
file_info                              based           structure                level 1 dcl 7-113
fixed                                                  builtin function         dcl 320
message_str                            based           structure                level 1 packed packed unaligned dcl 7-259
message_str_len                        automatic       fixed bin(17,0)          dcl 7-269
message_str_ptr                        automatic       pointer                  dcl 7-267
natts_init                             automatic       fixed bin(17,0)          dcl 6-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 6-157
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 6-157
path_entry                             based           structure                level 1 packed packed unaligned dcl 7-172
path_entry_ptr                         automatic       pointer                  dcl 7-177
rel                                                    builtin function         dcl 320
rm_num_rels_init                       automatic       fixed bin(17,0)          dcl 5-44
rmri_ptr                               automatic       pointer                  dcl 6-156
stack_item                             based           structure                level 1 unaligned dcl 7-206
stack_item_ptr                         automatic       pointer                  dcl 7-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 340
ua_ptr                                 automatic       pointer                  dcl 7-165
unreferenced_attribute                 based           structure                level 1 dcl 7-159
version_status                         based           structure                level 1 packed packed unaligned dcl 7-232
version_status_ptr                     automatic       pointer                  dcl 7-246

NAMES DECLARED BY EXPLICIT CONTEXT.
add_file                        001114 constant        entry                    internal dcl 195 ref 120
clean_up                        001503 constant        entry                    internal dcl 256 ref 102 133
get_pointers                    000434 constant        entry                    internal dcl 139 ref 107
init_file_list                  001065 constant        entry                    internal dcl 179 ref 114
mrds_dsl_ready_all              000267 constant        entry                    external dcl 52
ready_all                       000256 constant        entry                    external dcl 52
ready_files                     001175 constant        entry                    internal dcl 219 ref 126

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2372        2442    2106        2402
Length      3024    2106        50         346     264           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ready_all                           392 external procedure  is an external procedure.  
on unit on line 100                  64 on unit               
get_pointers                            internal procedure  shares stack frame of external procedure ready_all.  
init_file_list                          internal procedure  shares stack frame of external procedure ready_all.  
add_file                                internal procedure  shares stack frame of external procedure ready_all.  
ready_files                             internal procedure  shares stack frame of external procedure ready_all.  
clean_up                            188 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 previous_invocation         ready_all

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
clean_up                 000100 hold_ptr                    clean_up
                         000102 rel_info_ptr                clean_up
ready_all                000100 temp_area_ptr               ready_all
                         000102 submodel_iocb_ptr           ready_all
                         000104 fa_index                    ready_all
                         000105 clean_up_condition          ready_all
                         000114 last_frdy_ptr               ready_all
                         000116 ON                          ready_all
                         000117 OFF                         ready_all
                         000120 caller_name                 ready_all
                         000125 continue                    ready_all
                         000126 info_ptr                    ready_all
                         000130 return_value                ready_all
                         000131 finish_code                 ready_all
                         000132 dbrdy_ptr                   ready_all
                         000134 frdy_ptr                    ready_all
                         000136 rdbi_ptr                    ready_all
                         000140 dbcb_ptr                    ready_all
                         000142 rai_init_number_of_attributes
                                                            ready_all
                         000144 resultant_attributes_info_ptr
                                                            ready_all
                         000146 rmra_ptr                    ready_all
                         000150 dbm_ptr                     ready_all

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ent_var        call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          enable_op           shorten_stack       ext_entry           int_entry           op_alloc_
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
hcs_$initiate                 mrds_dm_authorization$set_needed_access                     mrds_dsm_close
mrds_dsm_open$read            mu_database_index$get_resultant_model_pointer               mu_sec_make_res
mu_temp_segments$delete_temp_segment                        mu_temp_segments$get_temp_segment
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$moderr           error_table_$no_info          mrds_data_$number_of_resultant_attributes
mrds_error_$invalid_db_index  mrds_error_$no_model_access   mrds_error_$no_recursion




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    331 000232       332 000234       334 000235       335 000243       336 000245       337 000247        52 000252
     81 000275        83 000277        84 000302        85 000304        87 000350        90 000351        94 000353
     95 000355        96 000356        97 000357        98 000360       100 000362       101 000376       102 000401
    103 000406       107 000407       109 000410       114 000413       118 000414       120 000423       122 000424
    126 000426       133 000427       137 000433       139 000434       143 000435       144 000447       145 000453
    146 000457       148 000540       153 000541       157 000544       158 000546       159 000617       160 000624
    161 000661       163 000671       165 000742       167 000751       173 001060       177 001064       179 001065
    183 001066       185 001072       186 001100       187 001102       188 001105       189 001110       193 001113
    195 001114       199 001115       200 001123       201 001125       202 001147       203 001152       204 001154
    208 001160       209 001165       210 001166       211 001170       213 001171       214 001172       217 001174
    219 001175       221 001176       222 001223       226 001273       227 001302       228 001327       235 001404
    236 001407       238 001421       242 001422       245 001435       247 001456       250 001470       252 001475
    254 001501       256 001502       264 001510       265 001512       266 001516       267 001526       271 001600
    272 001605       273 001626       278 001700       280 001705       283 001715       291 001720       294 001731
    295 001746       297 001763       302 002054       304 002057       306 002063       307 002065       311 002070
    316 002101       318 002105


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
