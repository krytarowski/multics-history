	COMPILATION LISTING OF SEGMENT mlsys_address_list_mgr_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 06/30/86  1359.9 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* format: off */
        8 
        9 /* Address list management for the Multics Mail System */
       10 
       11 /* Created:  May 1981 by G. Palter */
       12 /* Modified: 3 September 1981 by G. Palter to special case empty address lists in cv_address_list_to_* */
       13 /* Modified: July 1983 by G. Palter to convert to new mail system specification */
       14 /* Modified: 6 March 1984 by G. Palter to fix error #0422 -- mail_system_$free_address_list may damage the mail system's
       15*      internal storage if called with a pointer to an already freed address list */
       16 
       17 /* format: on,style4,delnl,insnl,ifthenstmt,ifthen,^indcomtxt */
       18 
       19 
       20 mlsys_address_list_mgr_:
       21      procedure () options (rename ((alloc_, mlsys_storage_mgr_$allocate)));
       22 
       23 	return;					/* not an entrypoint */
       24 
       25 
       26 /* Parameters */
       27 
       28 dcl  P_address_list_ptr pointer parameter;
       29 dcl  P_code fixed binary (35) parameter;
       30 
       31 dcl  P_address_list_version character (8) parameter;	/* create_*_address_list, add_address_*: version of
       32*						      address_list structure desired by the caller */
       33 
       34 dcl  P_new_address_list_ptr pointer parameter;		/* copy_address_list: set -> copy of old address list;
       35*						   merge_address_lists_*: set -> merger of input lists */
       36 
       37 dcl  P_old_address_list_ptr pointer parameter;		/* copy_address_list -> address list to be copied */
       38 
       39 dcl  P_address_list_1_ptr pointer parameter;		/* merge_address_lists_*: -> first list to be merged */
       40 dcl  P_address_list_2_ptr pointer parameter;		/* merge_address_lists_*: -> second list to be merged */
       41 dcl  P_eliminate_duplicates bit (1) aligned parameter;	/* merge_address_lists_*: ON => eliminate duplicate addresses
       42*						      from the merged list */
       43 
       44 dcl  P_address_ptr pointer parameter;			/* add_address_*, replace_address_*: -> the new address */
       45 
       46 dcl  P_address_position fixed binary parameter;		/* delete_address_*, replace_address_*: identifies which
       47*						      address in the address_list to delete/replace */
       48 /**** format: indcomtxt */
       49 
       50 
       51 /* Local copies of parameters */
       52 
       53 dcl  address_list_ptr_as_array (1) pointer aligned based (addr (address_list_ptr));
       54 
       55 dcl  (old_address_list_ptr, address_list_1_ptr, address_list_2_ptr, new_address_list_ptr) pointer;
       56 
       57 dcl  address_ptr pointer;
       58 
       59 
       60 /* Definition of the reserved data in the address_list structure */
       61 
       62 dcl  1 address_list_reserved_data aligned based (addr (address_list.reserved)),
       63        2 n_addresses_allocated fixed binary,		/* actual # of address slots available in the structure */
       64        2 reference_count fixed binary,			/* # of mail system objects which are using this list */
       65        2 flags,
       66          3 read_only bit (1) unaligned,			/* ON => user may not modify this address list */
       67          3 user_freeable bit (1) unaligned,		/* ON => user may free this list no matter the type */
       68          3 pad bit (34) unaligned;
       69 
       70 
       71 /* Remaining declarations */
       72 
       73 dcl  read_only_address_list bit (1) aligned;		/* whether to create a read-only to user-ring address list */
       74 dcl  user_freeable_address_list bit (1) aligned;		/* whether to allow user-ring to free it anyway */
       75 
       76 dcl  increment_reference_counts bit (1) aligned;
       77 
       78 dcl  (idx, jdx) fixed binary;
       79 
       80 /* format: off */
       81 dcl (error_table_$bad_index, error_table_$bad_subr_arg, error_table_$unimplemented_version, mlsys_et_$empty_address_list,
       82      mlsys_et_$not_address_list, mlsys_et_$read_only_address_list)
       83 	fixed binary (35) external;
       84 /* format: on */
       85 
       86 dcl  mlsys_address_mgr_$decrement_reference_count entry (pointer);
       87 dcl  mlsys_address_mgr_$increment_reference_count entry (pointer);
       88 dcl  mlsys_address_mgr_$verify_address entry (pointer, fixed binary (35)) returns (bit (1) aligned);
       89 dcl  mlsys_transmit_$eliminate_duplicate_addrs entry ((*) pointer, fixed binary (35));
       90 
       91 dcl  (addr, baseno, binary, mod, null, string) builtin;
       92 
       93 /* Create an empty address list */
       94 
       95 create_read_only_address_list:			/* ... writeable only by the mail system */
       96      entry (P_address_list_version, P_address_list_ptr, P_code);
       97 
       98 	read_only_address_list = "1"b;
       99 	user_freeable_address_list = "0"b;
      100 	go to CREATE_ADDRESS_LIST_COMMON;
      101 
      102 
      103 create_user_freeable_address_list:			/* ... not writeable by user-ring but can be freed there */
      104      entry (P_address_list_version, P_address_list_ptr, P_code);
      105 
      106 	read_only_address_list, user_freeable_address_list = "1"b;
      107 	go to CREATE_ADDRESS_LIST_COMMON;
      108 
      109 
      110 create_writeable_address_list:			/* ... writeable by the user: target of the user-ring gate */
      111      entry (P_address_list_version, P_address_list_ptr, P_code);
      112 
      113 	read_only_address_list = "0"b;
      114 	user_freeable_address_list = "1"b;
      115 
      116 
      117 CREATE_ADDRESS_LIST_COMMON:
      118 	if P_address_list_version ^= ADDRESS_LIST_VERSION_2 then do;
      119 	     P_code = error_table_$unimplemented_version;
      120 	     return;
      121 	end;
      122 
      123 	address_list_n_addresses = mlsys_data_$address_list_allocation;
      124 						/* allows some room for the first few addresses */
      125 
      126 	allocate address_list in (mlsys_area) set (address_list_ptr);
      127 
      128 	address_list.version = ADDRESS_LIST_VERSION_2;
      129 
      130 	address_list_reserved_data.n_addresses_allocated = address_list_n_addresses;
      131 	address_list.n_addresses = 0;			/* the list is empty */
      132 
      133 	address_list_reserved_data.reference_count = 0;	/* nothing has referenced this list yet */
      134 
      135 	string (address_list_reserved_data.flags) = ""b;
      136 	address_list_reserved_data.read_only = read_only_address_list;
      137 	address_list_reserved_data.user_freeable = user_freeable_address_list;
      138 
      139 	P_address_list_ptr = address_list_ptr;		/* give it to the caller */
      140 	P_code = 0;				/* success */
      141 
      142 	return;
      143 
      144 /* Convert the supplied address list into a read-only address list: used to prevent the user from modifying an address
      145*   list once it is being used by a message */
      146 
      147 set_read_only:
      148      entry (P_address_list_ptr);
      149 
      150 	address_list_ptr = copy_ptr (P_address_list_ptr);
      151 
      152 	address_list_reserved_data.read_only = "1"b;
      153 	address_list_reserved_data.user_freeable = "0"b;
      154 
      155 	return;
      156 
      157 
      158 
      159 /* Free an address list if its reference count is zero (ie: if no other mail system object has a pointer to this list) */
      160 
      161 free_address_list:					/* ... any type of address list */
      162      entry (P_address_list_ptr, P_code);
      163 
      164 	if ^verify_address_list (P_address_list_ptr, P_code) then return;
      165 	go to FREE_ADDRESS_LIST_COMMON;
      166 
      167 
      168 free_address_list_writeable:				/* ... only if the user-ring can free it */
      169      entry (P_address_list_ptr, P_code);
      170 
      171 	if ^verify_writeable_address_list (P_address_list_ptr, P_code) then return;
      172 
      173 
      174 FREE_ADDRESS_LIST_COMMON:
      175 	address_list_ptr = copy_ptr (P_address_list_ptr);
      176 	P_address_list_ptr = null ();			/* insure the caller doesn't use it anymore */
      177 
      178 	if address_list_reserved_data.reference_count <= 0 then do;
      179 	     do idx = 1 to address_list.n_addresses;
      180 		call mlsys_address_mgr_$decrement_reference_count (address_list.addresses (idx));
      181 	     end;					/* no longer interested in the addresses */
      182 	     free address_list in (mlsys_area);
      183 	end;
      184 
      185 	P_code = 0;				/* success */
      186 
      187 	return;
      188 
      189 /* Increment the reference count of an address list: to avoid the user accidently freeing an address list structure which
      190*   is in use by other parts of the mail system (eg: references within a message or certain types of addresses) */
      191 
      192 increment_reference_count:
      193      entry (P_address_list_ptr);
      194 
      195 	address_list_ptr = P_address_list_ptr;
      196 
      197 	address_list_reserved_data.reference_count = address_list_reserved_data.reference_count + 1;
      198 
      199 	return;
      200 
      201 
      202 
      203 /* Decrement the reference count of an address list:  If the reference count reaches zero, nothing in the mail system is
      204*   using this address list any longer and its storage is released */
      205 
      206 decrement_reference_count:
      207      entry (P_address_list_ptr);
      208 
      209 	address_list_ptr = P_address_list_ptr;
      210 
      211 	address_list_reserved_data.reference_count = address_list_reserved_data.reference_count - 1;
      212 
      213 	if address_list_reserved_data.reference_count <= 0 then call free_address_list (P_address_list_ptr, (0));
      214 
      215 	P_address_list_ptr = null ();			/* keep the caller from using it anymore */
      216 
      217 	return;
      218 
      219 /* Copy an address list: always creates a user-ring modifiable address list */
      220 
      221 copy_address_list:
      222      entry (P_old_address_list_ptr, P_new_address_list_ptr, P_code);
      223 
      224 	if ^verify_address_list (P_old_address_list_ptr, P_code) then return;
      225 	old_address_list_ptr = copy_ptr (P_old_address_list_ptr);
      226 
      227 	address_list_n_addresses =			/* use same # of slots as the original list */
      228 	     addr (old_address_list_ptr -> address_list.reserved) -> address_list_reserved_data.n_addresses_allocated;
      229 
      230 	allocate address_list in (mlsys_area) set (address_list_ptr);
      231 
      232 	address_list.version = ADDRESS_LIST_VERSION_2;
      233 	address_list_reserved_data.n_addresses_allocated = address_list_n_addresses;
      234 	address_list_reserved_data.reference_count = 0;	/* nothing has reference this list yet */
      235 	string (address_list_reserved_data.flags) = ""b;	/* turns off read-only flag: user can always modify ... */
      236 	address_list_reserved_data.user_freeable = "1"b;	/* ... an address list created by this entrypoint */
      237 
      238 	address_list.n_addresses = old_address_list_ptr -> address_list.n_addresses;
      239 
      240 	do idx = 1 to address_list.n_addresses;
      241 	     address_list.addresses (idx) = old_address_list_ptr -> address_list.addresses (idx);
      242 	     call mlsys_address_mgr_$increment_reference_count (address_list.addresses (idx));
      243 	end;
      244 
      245 	P_new_address_list_ptr = address_list_ptr;	/* success */
      246 	P_code = 0;
      247 
      248 	return;
      249 
      250 /* Merge two address lists: optionally eliminate any duplicate addresses in the resulting list; the output may replace
      251*   either of the input lists if desired */
      252 
      253 merge_address_lists:				/* ... writeable only by the mail system */
      254      entry (P_address_list_1_ptr, P_address_list_2_ptr, P_eliminate_duplicates, P_new_address_list_ptr, P_code);
      255 
      256 	read_only_address_list = "1"b;
      257 	go to MERGE_ADDRESS_LISTS_COMMON;
      258 
      259 
      260 merge_address_lists_writeable:			/* ... writeable by the user: target of the user-ring gate */
      261      entry (P_address_list_1_ptr, P_address_list_2_ptr, P_eliminate_duplicates, P_new_address_list_ptr, P_code);
      262 
      263 	read_only_address_list = "0"b;
      264 
      265 
      266 MERGE_ADDRESS_LISTS_COMMON:
      267 	address_list_1_ptr = copy_ptr (P_address_list_1_ptr);
      268 	address_list_2_ptr = copy_ptr (P_address_list_2_ptr);
      269 
      270 
      271 /* Validate the input arguments:  Insure that all non-null address_list_ptr's do indeed reference address_list strucutres,
      272*   that the caller is not attempting to merge 3 lists simultaneously, and, if invoked via the mail_system_ gate, that the
      273*   user-ring may modify the output address_list structure */
      274 
      275 	if address_list_1_ptr ^= null () then		/* it's OK for an input list to not be present */
      276 	     if ^verify_address_list (address_list_1_ptr, P_code) then return;
      277 
      278 	if address_list_2_ptr ^= null () then
      279 	     if ^verify_address_list (address_list_2_ptr, P_code) then return;
      280 
      281 	if P_new_address_list_ptr ^= null () then do;	/* must be one of the input lists ... */
      282 	     if (addr (P_new_address_list_ptr) ^= addr (P_address_list_1_ptr))
      283 		& (addr (P_new_address_list_ptr) ^= addr (P_address_list_2_ptr)) then do;
      284 		P_code = error_table_$bad_subr_arg;
      285 		return;
      286 	     end;
      287 	     if ^read_only_address_list then		/* ... furthermore it must be modifiable by the user-ring */
      288 		if ^verify_writeable_address_list (P_new_address_list_ptr, P_code) then return;
      289 	end;
      290 
      291 	if empty_address_list (address_list_1_ptr) & empty_address_list (address_list_2_ptr) then do;
      292 	     P_code = mlsys_et_$empty_address_list;	/* they can't both be empty lists */
      293 	     return;
      294 	end;
      295 
      296 
      297 /* Supplied input arguments are OK: perform the merger */
      298 
      299 	if address_list_1_ptr = null () then		/* compute the number of addresses needed in the new list */
      300 	     address_list_n_addresses = 0;
      301 	else address_list_n_addresses = address_list_1_ptr -> address_list.n_addresses;
      302 
      303 	if address_list_2_ptr ^= null () then		/* some addresses from the second list also */
      304 	     address_list_n_addresses = address_list_n_addresses + address_list_2_ptr -> address_list.n_addresses;
      305 
      306 	address_list_n_addresses =			/* room for expansion please ... */
      307 	     address_list_n_addresses + mlsys_data_$address_list_allocation
      308 	     - mod (address_list_n_addresses, mlsys_data_$address_list_allocation);
      309 
      310 	allocate address_list in (mlsys_area) set (address_list_ptr);
      311 
      312 	address_list.version = ADDRESS_LIST_VERSION_2;
      313 	address_list_reserved_data.n_addresses_allocated = address_list_n_addresses;
      314 	address_list.n_addresses = 0;			/* the list is empty */
      315 	address_list_reserved_data.reference_count = 0;	/* nothing has referenced this list yet */
      316 	string (address_list_reserved_data.flags) = ""b;
      317 	address_list_reserved_data.read_only = read_only_address_list;
      318 	address_list_reserved_data.user_freeable = ^read_only_address_list;
      319 
      320 	if addr (P_new_address_list_ptr) = addr (P_address_list_1_ptr) then do;
      321 						/* new list is going to replace the first list ... */
      322 	     increment_reference_counts = "0"b;		/* ... don't change address reference counts */
      323 	     if address_list_1_ptr ^= null () then do;	/* ... and copy the internal data if present */
      324 		address_list.reserved = address_list_1_ptr -> address_list.reserved;
      325 		address_list_reserved_data.n_addresses_allocated = address_list_n_addresses;
      326 	     end;					/* ... but don't lose the size of the new list */
      327 	end;
      328 	else increment_reference_counts = "1"b;		/* new list: will have to bump address reference counts */
      329 
      330 	if address_list_1_ptr ^= null () then do;	/* have some addresses to be copied into the new list ... */
      331 	     do idx = 1 to address_list_1_ptr -> address_list.n_addresses;
      332 		address_list.n_addresses, jdx = address_list.n_addresses + 1;
      333 		address_list.addresses (jdx) = address_list_1_ptr -> address_list.addresses (idx);
      334 		if increment_reference_counts then	/* ... another new reference for this address */
      335 		     call mlsys_address_mgr_$increment_reference_count (address_list.addresses (jdx));
      336 	     end;
      337 	end;
      338 
      339 	if addr (P_new_address_list_ptr) = addr (P_address_list_2_ptr) then do;
      340 						/* new list is going to replace the second list ... */
      341 	     increment_reference_counts = "0"b;		/* ... don't change address reference counts */
      342 	     if address_list_2_ptr ^= null () then do;	/* ... and copy the internal data if present */
      343 		address_list.reserved = address_list_2_ptr -> address_list.reserved;
      344 		address_list_reserved_data.n_addresses_allocated = address_list_n_addresses;
      345 	     end;					/* ... but don't lose the size of the new list */
      346 	end;
      347 	else increment_reference_counts = "1"b;		/* new list: will have to bump address reference counts */
      348 
      349 	if address_list_2_ptr ^= null () then do;	/* have some addresses to be copied into the new list ... */
      350 	     do idx = 1 to address_list_2_ptr -> address_list.n_addresses;
      351 		address_list.n_addresses, jdx = address_list.n_addresses + 1;
      352 		address_list.addresses (jdx) = address_list_2_ptr -> address_list.addresses (idx);
      353 		if increment_reference_counts then	/* ... another new reference for this address */
      354 		     call mlsys_address_mgr_$increment_reference_count (address_list.addresses (jdx));
      355 	     end;
      356 	end;
      357 
      358 	if P_eliminate_duplicates then		/* get rid of any duplicates in the list */
      359 	     call mlsys_transmit_$eliminate_duplicate_addrs (address_list_ptr_as_array, (0));
      360 
      361 	if P_new_address_list_ptr ^= null () then do;	/* get rid of the old list we are replacing */
      362 	     new_address_list_ptr = copy_ptr (P_new_address_list_ptr);
      363 	     free new_address_list_ptr -> address_list in (mlsys_area);
      364 	end;
      365 
      366 	P_new_address_list_ptr = address_list_ptr;
      367 	P_code = 0;				/* success */
      368 
      369 	return;
      370 
      371 /* Add an address to the given address list, expanding the list by reallocation if necessary */
      372 
      373 add_address:					/* ... writeable only by the mail system */
      374      entry (P_address_list_ptr, P_address_ptr, P_address_list_version, P_code);
      375 
      376 	read_only_address_list = "1"b;		/* ... in case we must create the list */
      377 	go to ADD_ADDRESS_COMMON;
      378 
      379 
      380 add_address_writeable:				/* ... writeable by the user: target of the user-ring gate */
      381      entry (P_address_list_ptr, P_address_ptr, P_address_list_version, P_code);
      382 
      383 	read_only_address_list = "0"b;
      384 
      385 
      386 ADD_ADDRESS_COMMON:
      387 	if ^mlsys_address_mgr_$verify_address (P_address_ptr, P_code) then return;
      388 	address_ptr = copy_ptr (P_address_ptr);
      389 
      390 	if P_address_list_ptr = null () then do;	/* need to create an address_list */
      391 	     if read_only_address_list then
      392 		call create_read_only_address_list (P_address_list_version, address_list_ptr, P_code);
      393 	     else call create_writeable_address_list (P_address_list_version, address_list_ptr, P_code);
      394 	     if P_code ^= 0 then return;		/* ... must be that the caller gave us the wrong version */
      395 	end;
      396 	else do;					/* use the already created address_list */
      397 	     if read_only_address_list then		/* ... verify it using the appropriate criteria */
      398 		if ^verify_address_list (P_address_list_ptr, P_code) then
      399 		     return;
      400 		else ;				/* ... a valid read-only address_list */
      401 	     else if ^verify_writeable_address_list (P_address_list_ptr, P_code) then return;
      402 	     address_list_ptr = copy_ptr (P_address_list_ptr);
      403 	end;
      404 
      405 	if address_list.n_addresses = address_list_reserved_data.n_addresses_allocated then do;
      406 						/* must reallocate the list */
      407 	     address_list_n_addresses =		/* ... plus some room to grow */
      408 		address_list.n_addresses + mlsys_data_$address_list_allocation;
      409 	     allocate address_list in (mlsys_area) set (new_address_list_ptr);
      410 	     new_address_list_ptr -> address_list.version = ADDRESS_LIST_VERSION_2;
      411 	     new_address_list_ptr -> address_list.reserved = address_list.reserved;
      412 	     addr (new_address_list_ptr -> address_list.reserved) -> address_list_reserved_data.n_addresses_allocated =
      413 		address_list_n_addresses;
      414 	     new_address_list_ptr -> address_list.n_addresses = address_list.n_addresses;
      415 	     do idx = 1 to address_list.n_addresses;	/* ... copy the addresses */
      416 		new_address_list_ptr -> address_list.addresses (idx) = address_list.addresses (idx);
      417 	     end;
      418 	     free address_list in (mlsys_area);		/* ... get rid of the old one */
      419 	     address_list_ptr = new_address_list_ptr;	/* ... this is now the address list */
      420 	end;
      421 
      422 	address_list.n_addresses, idx = address_list.n_addresses + 1;
      423 						/* increment # of addresses present */
      424 
      425 	address_list.addresses (idx) = address_ptr;	/* add it to the list ... */
      426 	call mlsys_address_mgr_$increment_reference_count (address_ptr);
      427 						/* ... and remember that we care about it */
      428 
      429 	P_address_list_ptr = address_list_ptr;		/* in case we've changed it */
      430 	P_code = 0;				/* success */
      431 
      432 	return;
      433 
      434 /* Delete an address from the given address list */
      435 
      436 delete_address:					/* ... writeable only by the mail system */
      437      entry (P_address_list_ptr, P_address_position, P_code);
      438 
      439 	if ^verify_address_list (P_address_list_ptr, P_code) then return;
      440 	go to DELETE_ADDRESS_COMMON;
      441 
      442 
      443 delete_address_writeable:				/* ... writeable by the user: target of the user-ring gate */
      444      entry (P_address_list_ptr, P_address_position, P_code);
      445 
      446 	if ^verify_writeable_address_list (P_address_list_ptr, P_code) then return;
      447 
      448 
      449 DELETE_ADDRESS_COMMON:
      450 	address_list_ptr = copy_ptr (P_address_list_ptr); /* internal procedure uses the "standard" address list */
      451 
      452 	if (P_address_position < 1) | (P_address_position > address_list.n_addresses) then do;
      453 	     P_code = error_table_$bad_index;
      454 	     return;
      455 	end;
      456 
      457 	call delete_the_address (P_address_position);	/* do the work */
      458 
      459 	P_code = 0;				/* success */
      460 
      461 	return;
      462 
      463 
      464 
      465 /* Actually delete the specified address from the address list (called by several entrypoints) */
      466 
      467 delete_the_address:
      468      procedure (p_address_position);
      469 
      470 dcl  p_address_position fixed binary parameter;
      471 dcl  idx fixed binary;
      472 
      473 	call mlsys_address_mgr_$decrement_reference_count (address_list.addresses (p_address_position));
      474 						/* forget about the one being deleted */
      475 
      476 	do idx = (p_address_position + 1) to address_list.n_addresses;
      477 	     address_list.addresses (idx - 1) = address_list.addresses (idx);
      478 	end;					/* move the others down so no vacate slots remain */
      479 
      480 	address_list.n_addresses = address_list.n_addresses - 1;
      481 
      482 	return;
      483 
      484      end delete_the_address;
      485 
      486 /* Replace the specified address in an address list with a different address */
      487 
      488 replace_address:					/* ... writeable only by the mail system */
      489      entry (P_address_list_ptr, P_address_position, P_address_ptr, P_code);
      490 
      491 	if ^verify_address_list (P_address_list_ptr, P_code) then return;
      492 	go to REPLACE_ADDRESS_COMMON;
      493 
      494 
      495 replace_address_writeable:				/* ... writeable by the user: target of the user-ring gate */
      496      entry (P_address_list_ptr, P_address_position, P_address_ptr, P_code);
      497 
      498 	if ^verify_writeable_address_list (P_address_list_ptr, P_code) then return;
      499 
      500 
      501 REPLACE_ADDRESS_COMMON:
      502 	if ^mlsys_address_mgr_$verify_address (P_address_ptr, P_code) then return;
      503 
      504 	address_list_ptr = copy_ptr (P_address_list_ptr);
      505 	address_ptr = copy_ptr (P_address_ptr);
      506 
      507 	if (P_address_position < 1) | (P_address_position > address_list.n_addresses) then do;
      508 	     P_code = error_table_$bad_index;
      509 	     return;
      510 	end;
      511 
      512 	idx = P_address_position;			/* always wise to copy parameters ... */
      513 
      514 	call mlsys_address_mgr_$decrement_reference_count (address_list.addresses (idx));
      515 						/* forget about the one being replaced */
      516 
      517 	address_list.addresses (idx) = address_ptr;	/* put in the new one ... */
      518 	call mlsys_address_mgr_$increment_reference_count (address_list.addresses (idx));
      519 						/* ... and make a note that we care about it */
      520 
      521 	P_code = 0;				/* success */
      522 
      523 	return;
      524 
      525 /* Verify that the caller supplied a pointer to a properly constructed address_list structure */
      526 
      527 verify_address_list:
      528      entry (P_address_list_ptr, P_code) returns (bit (1) aligned);
      529 
      530 	return (verify_address_list (P_address_list_ptr, P_code));
      531 
      532 
      533 
      534 /* Actually verifies that the caller supplied an address list structure */
      535 
      536 verify_address_list:
      537      procedure (p_address_list_ptr, p_code) returns (bit (1) aligned);
      538 
      539 dcl  p_address_list_ptr pointer parameter;
      540 dcl  p_code fixed binary (35) parameter;
      541 
      542 	if p_address_list_ptr = null () then p_code = mlsys_et_$not_address_list;
      543 
      544 	else if ^mlsys_data_$valid_segments (binary (baseno (p_address_list_ptr), 18, 0)) then
      545 	     p_code = mlsys_et_$not_address_list;	/* supplied structure wasn't allocated by us */
      546 
      547 	else if p_address_list_ptr -> address_list.version ^= ADDRESS_LIST_VERSION_2 then
      548 	     p_code = mlsys_et_$not_address_list;	/* not an address_list structure */
      549 
      550 	else p_code = 0;				/* supplied structure passes all tests */
      551 
      552 	return ((p_code = 0));
      553 
      554      end verify_address_list;
      555 
      556 /* Verify that the caller supplied a pointer to a properly constructed address_list structure which may be modified by
      557*   user-ring software via the mail_system_ gate */
      558 
      559 verify_writeable_address_list:
      560      entry (P_address_list_ptr, P_code) returns (bit (1) aligned);
      561 
      562 	return (verify_writeable_address_list (P_address_list_ptr, P_code));
      563 
      564 
      565 
      566 /* Actually verifies that the caller supplied a writeable address list structure */
      567 
      568 verify_writeable_address_list:
      569      procedure (p_address_list_ptr, p_code) returns (bit (1) aligned);
      570 
      571 dcl  p_address_list_ptr pointer parameter;
      572 dcl  p_code fixed binary (35) parameter;
      573 
      574 	if ^verify_address_list (p_address_list_ptr, p_code) then ;
      575 						/* not an address_list */
      576 
      577 	else if addr (p_address_list_ptr -> address_list.reserved) -> address_list_reserved_data.read_only then
      578 	     p_code = mlsys_et_$read_only_address_list;	/* not an address_list which the user-ring can modify */
      579 
      580 	else p_code = 0;				/* supplied structure passes all tests */
      581 
      582 	return ((p_code = 0));
      583 
      584      end verify_writeable_address_list;
      585 
      586 /* Determine if the given address list is empty */
      587 
      588 empty_address_list:
      589      procedure (p_address_list_ptr) returns (bit (1) aligned);
      590 
      591 dcl  p_address_list_ptr pointer parameter;
      592 
      593 	if p_address_list_ptr = null () then
      594 	     return ("1"b);
      595 
      596 	else return ((p_address_list_ptr -> address_list.n_addresses = 0));
      597 
      598      end empty_address_list;
      599 
  1     1 /* BEGIN INCLUDE FILE ... mlsys_copy_ptr.incl.pl1 */
  1     2 /* Created:  August 1983 by G. Palter */
  1     3 /* Recoded:  October 1983 by W. Olin Sibert to be guarenteed to work */
  1     4 
  1     5 /* Copies a pointer parameter while changing the ring number in said pointer to the ring of execution:  This change of
  1     6*   ring number is required to allow the mail system to properly manipulate ring-2 objects as requested by the caller as
  1     7*   the caller's pointer to said object would cause an access violation.  The mail system does its own validation to insure
  1     8*   that the pointer provided by the caller is legitimate */
  1     9 
  1    10 copy_ptr:
  1    11      procedure (p_pointer) returns (pointer);
  1    12 
  1    13 dcl  p_pointer pointer parameter;
  1    14 dcl  return_value pointer options (packed);
  1    15 
  1    16 	return_value = p_pointer;			/* packed pointers don't have ring numbers ... */
  1    17 
  1    18 	return (return_value);			/* ... so it will be set to the ring of execution */
  1    19 
  1    20      end copy_ptr;
  1    21 
  1    22 /* END INCLUDE FILE ... mlsys_copy_ptr.incl.pl1 */
      600 
      601 
  2     1 /* BEGIN INCLUDE FILE ... mlsys_address_list.incl.pl1 */
  2     2 /* Created:  June 1983 by G. Palter */
  2     3 
  2     4 /* Definition of an address list -- a collection of addresses used as the value of certain message fields, etc. */
  2     5 
  2     6 dcl  1 address_list aligned based (address_list_ptr),
  2     7        2 version character (8) unaligned,
  2     8        2 reserved bit (144),				/* ... exclusively for use by the mail system */
  2     9        2 n_addresses fixed binary,			/* # of address in this list */
  2    10        2 addresses (address_list_n_addresses refer (address_list.n_addresses)) pointer;
  2    11 
  2    12 dcl  ADDRESS_LIST_VERSION_2 character (8) static options (constant) initial ("mlsals02");
  2    13 
  2    14 dcl  address_list_ptr pointer;
  2    15 
  2    16 dcl  address_list_n_addresses fixed binary;		/* reserved exclusively for use by the mail system */
  2    17 
  2    18 /* END INCLUDE FILE ... mlsys_address_list.incl.pl1 */
      602 
      603 
  3     1 /* BEGIN INCLUDE FILE ... mlsys_internal_data.incl.pl1 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-06-11,Mills), approve(86-06-11,MCR7419),
  3     6*     audit(86-06-17,Margolin), install(86-06-30,MR12.0-1080):
  3     7*     Added mlsys_data_$domains_available.
  3     8*                                                   END HISTORY COMMENTS */
  3     9 
  3    10 
  3    11 /* Created:  May 1981 by G. Palter */
  3    12 /* Modified: July 1983 by G. Palter to merge with mlsys_data_ */
  3    13 
  3    14 /* Constants used internally by the Multics mail system */
  3    15 
  3    16 dcl  mlsys_data_$max_opening_retries fixed binary external; /* maximum number of times to reopen a mailbox if it gets
  3    17*                                                               damaged and salvaged while open */
  3    18 
  3    19 dcl  mlsys_data_$max_lock_wait_retries fixed binary external;
  3    20                                                             /* maximum number of times to try to send a message while the
  3    21*                                                               mailbox is locked (being salvaged?) */
  3    22 
  3    23 
  3    24 /* Allocation overhead factors:  When allocating those structures with refer extents, insure that the variable portion of
  3    25*   the structure contains a multiple of the appropriate constant number of slots.  These extra slots will be used for
  3    26*   later additions to the structure; when a new element must be added to a full structure, add this many new slots (rather
  3    27*   than a single new slot)
  3    28*
  3    29*   The following expression should be used to determine the initial allocation:
  3    30*
  3    31*          n_slots_to_allocate = n_slots_needed + CONSTANT - mod (n_slots_needed, CONSTANT); */
  3    32 
  3    33 dcl (mlsys_data_$mailbox_allocation,                        /* mailbox.messages */
  3    34      mlsys_data_$message_body_sections_allocation,          /* message.body_sections */
  3    35      mlsys_data_$message_redistributions_list_allocation,   /* message_redistributions_list.redistributions */
  3    36      mlsys_data_$message_user_fields_allocation,            /* message_user_fields_list.user_fields */
  3    37      mlsys_data_$message_references_list_allocation,        /* message_references_list.references */
  3    38      mlsys_data_$address_list_allocation)                   /* address_list.addresses */
  3    39           fixed binary external;
  3    40 
  3    41 
  3    42 /* Static data user by the Multics mail system */
  3    43 
  3    44 dcl (mlsys_data_$forum_not_available,                       /* 1 => forum isn't available on the system or in this ring */
  3    45      mlsys_data_$ism_not_available,                         /* 1 => no inter-system mailer on this system */
  3    46      mlsys_data_$domains_available)                         /* 1 =>  domain name system software on this sytem */
  3    47           fixed binary (1) external;
  3    48 
  3    49 dcl (mlsys_data_$subsystem_ring,                            /* ring in which the mail system is secured */
  3    50      mlsys_data_$highest_usable_ring,                       /* highest ring of execution which may use the mail system */
  3    51      mlsys_data_$lowest_forum_ring)                         /* lowest ring of execution with access to forum */
  3    52           fixed binary (3) external;
  3    53 
  3    54 dcl  mlsys_data_$temp_segment_list_ptr pointer external;    /* -> list of all mail system temporary segments */
  3    55 
  3    56 dcl  mlsys_data_$valid_segments (0:4095) bit (1) unaligned external;
  3    57                                                             /* indicates which segments have been used by the mail system
  3    58*                                                               for the allocation of user-visible data in order to
  3    59*                                                               validate that pointers passed from the user-ring are OK */
  3    60 
  3    61 dcl  mlsys_area area based (mlsys_data_$subsystem_area_ptr);/* area used for all user-visible allocations ... */
  3    62 dcl  mlsys_data_$subsystem_area_ptr pointer external;       /* ... and the pointer on which it is based */
  3    63 
  3    64 dcl  mlsys_data_$hash_tables_segment_ptr pointer external;  /* -> hash tables used by the mail system */
  3    65 
  3    66 dcl  mlsys_data_$transmit_cache_ptr pointer external;       /* -> cache of recently used mailboxes for mlsys_transmit_ */
  3    67 
  3    68 dcl  mlsys_data_$user_is_anonymous bit (1) aligned external;/* ON => the user is an anonymous user */
  3    69 
  3    70 dcl  mlsys_data_$person_id character (24) varying external; /* the user's Person_id */
  3    71 dcl  mlsys_data_$project_id character (12) varying external;/* the user's Project_id */
  3    72 dcl  mlsys_data_$user_id character (32) varying external;   /* the user's User_id (Person_id.Project_id) */
  3    73 
  3    74 /* END INCLUDE FILE ... mlsys_internal_data.incl.pl1 */
      604 
      605 
      606      end mlsys_address_list_mgr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/30/86  1343.8  mlsys_address_list_mgr_.pl1       >spec>install>1080>mlsys_address_list_mgr_.pl1
600          1    10/27/83  2104.2  mlsys_copy_ptr.incl.pl1           >ldd>include>mlsys_copy_ptr.incl.pl1
602          2    10/27/83  2104.2  mlsys_address_list.incl.pl1       >ldd>include>mlsys_address_list.incl.pl1
604          3    06/30/86  1338.7  mlsys_internal_data.incl.pl1      >spec>install>1080>mlsys_internal_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ADDRESS_LIST_VERSION_2          000000 constant        char(8)                  initial unaligned dcl 2-12 ref 117 128 232 312 410
                                                                                  547
P_address_list_1_ptr                   parameter       pointer                  dcl 39 set ref 253 260 266* 282 320
P_address_list_2_ptr                   parameter       pointer                  dcl 40 set ref 253 260 268* 282 339
P_address_list_ptr                     parameter       pointer                  dcl 28 set ref 95 103 110 139* 147 150* 161 164* 168
                                                                                  171* 174* 176* 192 195 206 209 213* 215* 373 380
                                                                                  390 397* 401* 402* 429* 436 439* 443 446* 449* 488
                                                                                  491* 495 498* 504* 527 530* 559 562*
P_address_list_version                 parameter       char(8)                  unaligned dcl 31 set ref 95 103 110 117 373 380 391*
                                                                                  393*
P_address_position                     parameter       fixed bin(17,0)          dcl 46 set ref 436 443 452 452 457* 488 495 507 507
                                                                                  512
P_address_ptr                          parameter       pointer                  dcl 44 set ref 373 380 386* 388* 488 495 501* 505*
P_code                                 parameter       fixed bin(35,0)          dcl 29 set ref 95 103 110 119* 140* 161 164* 168
                                                                                  171* 185* 221 224* 246* 253 260 275* 278* 284*
                                                                                  287* 292* 367* 373 380 386* 391* 393* 394 397*
                                                                                  401* 430* 436 439* 443 446* 453* 459* 488 491* 495
                                                                                  498* 501* 508* 521* 527 530* 559 562*
P_eliminate_duplicates                 parameter       bit(1)                   dcl 41 ref 253 260 358
P_new_address_list_ptr                 parameter       pointer                  dcl 34 set ref 221 245* 253 260 281 282 282 287* 320
                                                                                  339 361 362* 366*
P_old_address_list_ptr                 parameter       pointer                  dcl 37 set ref 221 224* 225*
addr                                                   builtin function         dcl 91 ref 130 133 135 136 137 152 153 178 197 197
                                                                                  211 211 213 227 233 234 235 236 282 282 282 282
                                                                                  313 315 316 317 318 320 320 325 339 339 344 358
                                                                                  405 412 577
address_list                           based           structure                level 1 dcl 2-6 set ref 126 182 230 310 363 409 418
address_list_1_ptr              000102 automatic       pointer                  dcl 55 set ref 266* 275 275* 291* 299 301 323 324
                                                                                  330 331 333
address_list_2_ptr              000104 automatic       pointer                  dcl 55 set ref 268* 278 278* 291* 303 303 342 343
                                                                                  349 350 352
address_list_n_addresses        000122 automatic       fixed bin(17,0)          dcl 2-16 set ref 123* 126 126 130 227* 230 230 233
                                                                                  299* 301* 303* 303 306* 306 306 310 310 313 325
                                                                                  344 407* 409 409 412
address_list_ptr                000120 automatic       pointer                  dcl 2-14 set ref 126* 128 130 131 133 135 136 137
                                                                                  139 150* 152 153 174* 178 179 180 182 195* 197 197
                                                                                  209* 211 211 213 230* 232 233 234 235 236 238 240
                                                                                  241 242 245 310* 312 313 314 315 316 317 318 324
                                                                                  325 332 332 333 334 343 344 351 351 352 353 358
                                                                                  366 391* 393* 402* 405 405 407 411 414 415 416 418
                                                                                  419* 422 422 425 429 449* 452 473 476 477 477 480
                                                                                  480 504* 507 514 517 518
address_list_ptr_as_array              based           pointer                  array dcl 53 set ref 358*
address_list_reserved_data             based           structure                level 1 dcl 62
address_ptr                     000110 automatic       pointer                  dcl 57 set ref 388* 425 426* 505* 517
addresses                10            based           pointer                  array level 2 dcl 2-6 set ref 180* 241* 241 242*
                                                                                  333* 333 334* 352* 352 353* 416* 416 425* 473*
                                                                                  477* 477 514* 517* 518*
baseno                                                 builtin function         dcl 91 ref 544
binary                                                 builtin function         dcl 91 ref 544
error_table_$bad_index          000014 external static fixed bin(35,0)          dcl 81 ref 453 508
error_table_$bad_subr_arg       000016 external static fixed bin(35,0)          dcl 81 ref 284
error_table_$unimplemented_version
                                000020 external static fixed bin(35,0)          dcl 81 ref 119
flags                     2            based           structure                level 2 dcl 62 set ref 135* 235* 316*
idx                             000152 automatic       fixed bin(17,0)          dcl 471 in procedure "delete_the_address" set ref
                                                                                  476* 477 477*
idx                             000115 automatic       fixed bin(17,0)          dcl 78 in procedure "mlsys_address_list_mgr_" set
                                                                                  ref 179* 180* 240* 241 241 242* 331* 333* 350*
                                                                                  352* 415* 416 416* 422* 425 512* 514 517 518
increment_reference_counts      000114 automatic       bit(1)                   dcl 76 set ref 322* 328* 334 341* 347* 353
jdx                             000116 automatic       fixed bin(17,0)          dcl 78 set ref 332* 333 334 351* 352 353
mlsys_address_mgr_$decrement_reference_count
                                000030 constant        entry                    external dcl 86 ref 180 473 514
mlsys_address_mgr_$increment_reference_count
                                000032 constant        entry                    external dcl 87 ref 242 334 353 426 518
mlsys_address_mgr_$verify_address
                                000034 constant        entry                    external dcl 88 ref 386 501
mlsys_area                             based           area(1024)               dcl 3-61 ref 126 182 230 310 363 409 418
mlsys_data_$address_list_allocation
                                000040 external static fixed bin(17,0)          dcl 3-33 ref 123 306 306 407
mlsys_data_$subsystem_area_ptr  000044 external static pointer                  dcl 3-62 ref 126 182 230 310 363 409 418
mlsys_data_$valid_segments      000042 external static bit(1)                   array unaligned dcl 3-56 ref 544
mlsys_et_$empty_address_list    000022 external static fixed bin(35,0)          dcl 81 ref 292
mlsys_et_$not_address_list      000024 external static fixed bin(35,0)          dcl 81 ref 542 544 547
mlsys_et_$read_only_address_list
                                000026 external static fixed bin(35,0)          dcl 81 ref 577
mlsys_transmit_$eliminate_duplicate_addrs
                                000036 constant        entry                    external dcl 89 ref 358
mod                                                    builtin function         dcl 91 ref 306
n_addresses               6            based           fixed bin(17,0)          level 2 dcl 2-6 set ref 126* 131* 179 182 230* 238*
                                                                                  238 240 301 303 310* 314* 331 332 332* 350 351
                                                                                  351* 363 405 407 409* 414* 414 415 418 422 422*
                                                                                  452 476 480* 480 507 596
n_addresses_allocated                  based           fixed bin(17,0)          level 2 dcl 62 set ref 130* 227 233* 313* 325* 344*
                                                                                  405 412*
new_address_list_ptr            000106 automatic       pointer                  dcl 55 set ref 362* 363 409* 410 411 412 414 416 419
null                                                   builtin function         dcl 91 ref 176 215 275 278 281 299 303 323 330 342
                                                                                  349 361 390 542 593
old_address_list_ptr            000100 automatic       pointer                  dcl 55 set ref 225* 227 238 241
p_address_list_ptr                     parameter       pointer                  dcl 591 in procedure "empty_address_list" ref 588
                                                                                  593 596
p_address_list_ptr                     parameter       pointer                  dcl 571 in procedure "verify_writeable_address_list"
                                                                                  set ref 568 574* 577
p_address_list_ptr                     parameter       pointer                  dcl 539 in procedure "verify_address_list" ref 536
                                                                                  542 544 547
p_address_position                     parameter       fixed bin(17,0)          dcl 470 ref 467 473 476
p_code                                 parameter       fixed bin(35,0)          dcl 540 in procedure "verify_address_list" set ref
                                                                                  536 542* 544* 547* 550* 552
p_code                                 parameter       fixed bin(35,0)          dcl 572 in procedure "verify_writeable_address_list"
                                                                                  set ref 568 574* 577* 580* 582
p_pointer                              parameter       pointer                  dcl 1-13 ref 1-10 1-16
read_only                 2            based           bit(1)                   level 3 packed unaligned dcl 62 set ref 136* 152*
                                                                                  317* 577
read_only_address_list          000112 automatic       bit(1)                   dcl 73 set ref 98* 106* 113* 136 256* 263* 287 317
                                                                                  318 376* 383* 391 397
reference_count           1            based           fixed bin(17,0)          level 2 dcl 62 set ref 133* 178 197* 197 211* 211
                                                                                  213 234* 315*
reserved                  2            based           bit(144)                 level 2 dcl 2-6 set ref 130 133 135 136 137 152 153
                                                                                  178 197 197 211 211 213 227 233 234 235 236 313
                                                                                  315 316 317 318 324* 324 325 343* 343 344 405 411*
                                                                                  411 412 577
return_value                    000204 automatic       pointer                  dcl 1-14 set ref 1-16* 1-18
string                                                 builtin function         dcl 91 set ref 135* 235* 316*
user_freeable             2(01)        based           bit(1)                   level 3 packed unaligned dcl 62 set ref 137* 153*
                                                                                  236* 318*
user_freeable_address_list      000113 automatic       bit(1)                   dcl 74 set ref 99* 106* 114* 137
version                                based           char(8)                  level 2 packed unaligned dcl 2-6 set ref 128* 232*
                                                                                  312* 410* 547

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
mlsys_data_$domains_available          external static fixed bin(1,0)           dcl 3-44
mlsys_data_$forum_not_available        external static fixed bin(1,0)           dcl 3-44
mlsys_data_$hash_tables_segment_ptr    external static pointer                  dcl 3-64
mlsys_data_$highest_usable_ring        external static fixed bin(3,0)           dcl 3-49
mlsys_data_$ism_not_available          external static fixed bin(1,0)           dcl 3-44
mlsys_data_$lowest_forum_ring          external static fixed bin(3,0)           dcl 3-49
mlsys_data_$mailbox_allocation         external static fixed bin(17,0)          dcl 3-33
mlsys_data_$max_lock_wait_retries      external static fixed bin(17,0)          dcl 3-19
mlsys_data_$max_opening_retries        external static fixed bin(17,0)          dcl 3-16
mlsys_data_$message_body_sections_allocation
                                       external static fixed bin(17,0)          dcl 3-33
mlsys_data_$message_redistributions_list_allocation
                                       external static fixed bin(17,0)          dcl 3-33
mlsys_data_$message_references_list_allocation
                                       external static fixed bin(17,0)          dcl 3-33
mlsys_data_$message_user_fields_allocation
                                       external static fixed bin(17,0)          dcl 3-33
mlsys_data_$person_id                  external static varying char(24)         dcl 3-70
mlsys_data_$project_id                 external static varying char(12)         dcl 3-71
mlsys_data_$subsystem_ring             external static fixed bin(3,0)           dcl 3-49
mlsys_data_$temp_segment_list_ptr      external static pointer                  dcl 3-54
mlsys_data_$transmit_cache_ptr         external static pointer                  dcl 3-66
mlsys_data_$user_id                    external static varying char(32)         dcl 3-72
mlsys_data_$user_is_anonymous          external static bit(1)                   dcl 3-68

NAMES DECLARED BY EXPLICIT CONTEXT.
ADD_ADDRESS_COMMON              001672 constant        label                    dcl 386 ref 377
CREATE_ADDRESS_LIST_COMMON      000137 constant        label                    dcl 117 ref 100 107
DELETE_ADDRESS_COMMON           002327 constant        label                    dcl 449 ref 440
FREE_ADDRESS_LIST_COMMON        000406 constant        label                    dcl 174 ref 165
MERGE_ADDRESS_LISTS_COMMON      001021 constant        label                    dcl 266 ref 257
REPLACE_ADDRESS_COMMON          002512 constant        label                    dcl 501 ref 492
add_address                     001624 constant        entry                    external dcl 373
add_address_writeable           001651 constant        entry                    external dcl 380
copy_address_list               000601 constant        entry                    external dcl 221
copy_ptr                        003132 constant        entry                    internal dcl 1-10 ref 150 174 225 266 268 362 388
                                                                                  402 449 504 505
create_read_only_address_list   000046 constant        entry                    external dcl 95 ref 391
create_user_freeable_address_list
                                000072 constant        entry                    external dcl 103
create_writeable_address_list   000116 constant        entry                    external dcl 110 ref 393
decrement_reference_count       000532 constant        entry                    external dcl 206
delete_address                  002224 constant        entry                    external dcl 436
delete_address_writeable        002267 constant        entry                    external dcl 443
delete_the_address              002744 constant        entry                    internal dcl 467 ref 457
empty_address_list              003113 constant        entry                    internal dcl 588 ref 291 291
free_address_list               000303 constant        entry                    external dcl 161 ref 213
free_address_list_writeable     000346 constant        entry                    external dcl 168
increment_reference_count       000503 constant        entry                    external dcl 192
merge_address_lists             000763 constant        entry                    external dcl 253
merge_address_lists_writeable   001004 constant        entry                    external dcl 260
mlsys_address_list_mgr_         000025 constant        entry                    external dcl 20
replace_address                 002403 constant        entry                    external dcl 488
replace_address_writeable       002450 constant        entry                    external dcl 495
set_read_only                   000241 constant        entry                    external dcl 147
verify_address_list             002642 constant        entry                    external dcl 527
verify_address_list             003006 constant        entry                    internal dcl 536 in procedure
                                                                                  "mlsys_address_list_mgr_" ref 164 224 275 278 397
                                                                                  439 491 530 574
verify_writeable_address_list   003052 constant        entry                    internal dcl 568 in procedure
                                                                                  "mlsys_address_list_mgr_" ref 171 287 401 446 498
                                                                                  562
verify_writeable_address_list   002704 constant        entry                    external dcl 559

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3666        3734    3157        3676
Length      4270    3157        46         317     506           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mlsys_address_list_mgr_             196 external procedure  is an external procedure.  
delete_the_address                      internal procedure  shares stack frame of external procedure mlsys_address_list_mgr_.  
verify_address_list                     internal procedure  shares stack frame of external procedure mlsys_address_list_mgr_.  
verify_writeable_address_list           internal procedure  shares stack frame of external procedure mlsys_address_list_mgr_.  
empty_address_list                      internal procedure  shares stack frame of external procedure mlsys_address_list_mgr_.  
copy_ptr                                internal procedure  shares stack frame of external procedure mlsys_address_list_mgr_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mlsys_address_list_mgr_  000100 old_address_list_ptr        mlsys_address_list_mgr_
                         000102 address_list_1_ptr          mlsys_address_list_mgr_
                         000104 address_list_2_ptr          mlsys_address_list_mgr_
                         000106 new_address_list_ptr        mlsys_address_list_mgr_
                         000110 address_ptr                 mlsys_address_list_mgr_
                         000112 read_only_address_list      mlsys_address_list_mgr_
                         000113 user_freeable_address_list  mlsys_address_list_mgr_
                         000114 increment_reference_counts  mlsys_address_list_mgr_
                         000115 idx                         mlsys_address_list_mgr_
                         000116 jdx                         mlsys_address_list_mgr_
                         000120 address_list_ptr            mlsys_address_list_mgr_
                         000122 address_list_n_addresses    mlsys_address_list_mgr_
                         000152 idx                         delete_the_address
                         000204 return_value                copy_ptr

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_in         call_ext_out_desc   call_ext_out        return              mod_fx1
signal              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
freen_                        mlsys_address_mgr_$decrement_reference_count
mlsys_address_mgr_$increment_reference_count                mlsys_address_mgr_$verify_address
mlsys_storage_mgr_$allocate   mlsys_transmit_$eliminate_duplicate_addrs

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_index        error_table_$bad_subr_arg     error_table_$unimplemented_version
mlsys_data_$address_list_allocation                         mlsys_data_$subsystem_area_ptr
mlsys_data_$valid_segments    mlsys_et_$empty_address_list  mlsys_et_$not_address_list
mlsys_et_$read_only_address_list




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000024        23 000034        95 000042        98 000064        99 000066       100 000067       103 000070
    106 000110       107 000113       110 000114       113 000134       114 000135       117 000137       119 000144
    120 000147       123 000156       126 000161       128 000204       130 000207       131 000211       133 000212
    135 000213       136 000214       137 000220       139 000225       140 000226       142 000227       147 000236
    150 000253       152 000263       153 000266       155 000270       161 000277       164 000317       165 000343
    168 000344       171 000362       174 000406       176 000416       178 000420       179 000423       180 000433
    181 000444       182 000446       185 000471       187 000472       192 000501       195 000515       197 000520
    199 000521       206 000530       209 000544       211 000547       213 000551       215 000564       217 000566
    221 000575       224 000615       225 000642       227 000653       230 000656       232 000702       233 000705
    234 000707       235 000710       236 000711       238 000713       240 000716       241 000725       242 000732
    243 000742       245 000744       246 000746       248 000747       253 000756       256 000777       257 001001
    260 001002       263 001020       266 001021       268 001032       275 001043       278 001073       281 001123
    282 001127       284 001146       285 001151       287 001160       291 001206       292 001221       293 001224
    299 001233       301 001241       303 001244       306 001253       310 001264       312 001307       313 001312
    314 001314       315 001315       316 001316       317 001317       318 001323       320 001331       322 001342
    323 001343       324 001347       325 001353       327 001355       328 001356       330 001360       331 001364
    332 001375       333 001402       334 001411       336 001424       339 001426       341 001437       342 001440
    343 001444       344 001451       346 001453       347 001454       349 001456       350 001462       351 001473
    352 001500       353 001507       355 001522       358 001524       361 001546       362 001552       363 001562
    366 001605       367 001607       369 001610       373 001617       376 001644       377 001646       380 001647
    383 001671       386 001672       388 001717       390 001727       391 001733       393 001750       394 001762
    395 001773       397 001774       400 002022       401 002023       402 002047       405 002057       407 002063
    409 002066       410 002111       411 002114       412 002120       414 002122       415 002124       416 002133
    417 002140       418 002142       419 002165       422 002167       425 002174       426 002177       429 002206
    430 002210       432 002211       436 002220       439 002240       440 002264       443 002265       446 002303
    449 002327       452 002337       453 002346       454 002351       457 002360       459 002366       461 002367
    488 002376       491 002421       492 002445       495 002446       498 002466       501 002512       504 002537
    505 002547       507 002557       508 002566       509 002571       512 002600       514 002601       517 002612
    518 002616       521 002626       523 002627       527 002636       530 002655       559 002702       562 002717
    467 002744       473 002746       476 002760       477 002773       478 003000       480 003002       482 003005
    536 003006       542 003010       544 003020       547 003036       550 003045       552 003046       568 003052
    574 003054       577 003073       580 003105       582 003106       588 003113       593 003115       596 003124
 1   10 003132    1   16 003134    1   18 003137


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
