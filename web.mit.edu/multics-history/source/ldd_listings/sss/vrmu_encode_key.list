	COMPILATION LISTING OF SEGMENT vrmu_encode_key
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/21/84  1337.4 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 vrmu_encode_key: proc (key_source_list_ptr, key, key_bit_len, code);
       19 
       20 /* NOTES:
       21*
       22*   This procedure encodes one or more source values to form a key.  All
       23*   supported data types (with the exception of complex data) are encoded in
       24*   such a fashion that order is preserved.  This allows for range searching
       25*   on the resulting index.
       26**/
       27 
       28 /* HISTORY:
       29*
       30*   Initially written by JA Weeldreyer -- July, 1978.
       31*
       32*   6-sept-79 Davids: added the output parameter key_bit_len which is
       33*   the actual number of bits used in the key.
       34*
       35*   17-oct-79  Davids:  Changed  dcl  of  size  (length  of   varying
       36*   attribute) to unaligned so that it can be based on a pointer that
       37*   points into the middle of a word.
       38*
       39*   18-oct-79 Davids: Simplified the encoding of varying  strings  so
       40*   that  its  more  like  fixed  length  strings.  Also took out the
       41*   internal byte alignment  of  character  strings  within  the  key
       42*   string.
       43*
       44*   28-nov-79 Davids: Modified so that a calculation of the number of
       45*   bits  used by a varying character string is performed rather then
       46*   relying on the length word of the string having been modified  to
       47*   contain  the  number of bits rather then the number of characters
       48*   (which wsa not done in all cases). Of course now the length  word
       49*   better contain the number of chacaters for all cases.
       50*
       51*   Modified  by  Jim  Gray  -  -  Dec.  1979,   to   add   call   to
       52*   mu_data_class$scalar
       53*
       54*   14-jan-80 Davids: Completely rewrote encoding code for fixed  and
       55*   float decimal unaligned.
       56*
       57*   14-jan-80 Davids: Changed types 12, 46, and 46 (all  complex)  so
       58*   that  they  merely  copy  the  data  across  to  the key since no
       59*   encoding is required (only equal and not equal are allowed).
       60*
       61*   Modified  by  R.  Lackey  March  25,  1980  to  remove  calls  to
       62*   mdbm_util_
       63*
       64*   81-09-19 Davids: added the based unsigned fixed bin variable  fb8
       65*   for  use  when  overlaying  the exponent sign and value bits in a
       66*   float binary number, this prevents a size condition from occuring
       67*   when the source exponent value is 0.
       68*
       69*   82-09-17 R.  Harvey: Renamed and modified for use by vfile_relmgr
       70*
       71*   84-05-25 B. G. Moberg: Added new entry point, compute_offset_and_length.
       72*   Although this entry point shares no code with the rest of the routine,
       73*   it was placed here because attribute lengths and offsets are calculated
       74*   differently when there are parts of keys then anywhere else.  Therefore,
       75*   it was felt that it would be much more clear if this different calculation
       76*   was done in only one routine.
       77*
       78*   84-05-30 B. G. Moberg: Changed the new entry point to also return the
       79*   alignment as there is a case that needs this.
       80**/
       81 
       82 /*  vrmu_encode_key: proc (key_source_list_ptr, key, key_bit_len, code);  */
       83 
       84 
       85 	num_dims,
       86 	     index_value_length = 0;
       87 	len_ptr = addr (key);			/* initialize */
       88 	index_ptr = addrel (len_ptr, 1);
       89 	data_ptr = addr (index.index_value);
       90 	max_bits = 2277;				/* <--------vfile_ keys can be a maximum 256
       91*				  characters.  The first 3 chars of the
       92*                                          key are rel_id, index_id, pad (see
       93*                                          index structure).  That leaves 253
       94*                                          characters of data (or 2277 bits)! 
       95*                                          (quote from Noah Davids 10/04/83) */
       96 	offset = 1;
       97 	data_str = "0"b;
       98 
       99 	do i = 1 to key_source_list.number_of_values;	/* encode each key attr. */
      100 	     call encode_proc (key_source_list.val_info.val_ptr (i), key_source_list.val_info.desc_ptr (i));
      101 	end;					/* encoding loop */
      102 
      103 	index.mbz = "0"b;				/* finish the index */
      104 	key_length = ceil (divide ((offset - 1), 9, 17, 17)) + 3; /* set key length in chars */
      105 	key_bit_len = offset + 26;			/* <------offset contains the actual 
      106*                                                number of bits that make up the
      107*                                                encode key + 1.  Adding 26
      108*                                                gives a bit length of encoded
      109*                                                key + 3 characters.  See above
      110*                                                comment for max_bits.
      111*	                                            (ibid) */
      112 
      113 	code = 0;
      114 
      115 exit:
      116 	return;
      117 
      118 encode_attr: entry (ss_ptr, a_desc_ptr, encd_str, code);
      119 
      120 /* entry to encode an arbitrary attribute value */
      121 
      122 	offset = 1;				/* initialize */
      123 	len_ptr = addr (encd_str);
      124 	data_ptr = addrel (len_ptr, 1);
      125 	max_bits = 9 * maxlength (encd_str);
      126 	data_str = "0"b;
      127 	call encode_proc (ss_ptr, a_desc_ptr);
      128 	key_length = ceil (divide ((offset - 1), 9, 17, 17));
      129 	code = 0;
      130 	return;
      131 
      132 compute_alignment_and_length: entry (ds_ptr, key_offset, key_alignment, key_attr_len);
      133 
      134 	desc_ptr = ds_ptr;
      135 	ovfl = 0;					/* most types need
      136*no alignment */
      137 	
      138 	go to compute (descriptor.type);		/* go compute this value */
      139 
      140 compute (1):					/* fixed bin short */
      141 	if descriptor.packed then p = fixed (descriptor.size.precision);
      142 	else p = 35;
      143 	len = p + 1;
      144 	go to done;
      145 
      146 compute (2):					/* fixed bin long */
      147 	if descriptor.packed then p = fixed (descriptor.size.precision);
      148 	else p = 71;
      149 	len = p + 1;
      150 	go to done;
      151 
      152 compute (3):					/* float bin short */
      153 	if descriptor.packed then p = fixed (descriptor.size.precision);
      154 	else p = 27;
      155 	len = p + 9;
      156 	go to done;
      157 
      158 compute (4):					/* float bin long */
      159 	if descriptor.packed then p = fixed (descriptor.size.precision);
      160 	else p = 63;
      161 	len = p + 9;
      162 	go to done;
      163 
      164 compute (5):					/* complex fixed bin short */
      165 	if descriptor.packed then len = 2 * (fixed (descriptor.size.precision) + 1);
      166 	else len = 72;
      167 	go to done;
      168 
      169 compute (6):					/* complex fixed bin long */
      170 	if descriptor.packed then len = 2 * (fixed (descriptor.size.precision) + 1);
      171 	else len = 144;
      172 	go to done;
      173 
      174 
      175 compute (7):					/* complex float bin short */
      176 	if descriptor.packed then len = 2 * (fixed (descriptor.size.precision) + 9);
      177 	else len = 72;
      178 	go to done;
      179 
      180 compute (8):					/* complex float bin long */
      181 	if descriptor.packed then len = 2 * (fixed (descriptor.size.precision) + 9);
      182 	else len = 144;
      183 	go to done;
      184 
      185 compute (9):					/* real fixed decimal */
      186 	ovfl = mod (key_offset, 9);		/* byte align */
      187 	p = fixed (descriptor.size.precision);
      188 	len = 9 * (p + 1);
      189 	go to done;
      190 
      191 compute (10):					/* real float decimal */
      192 	p = fixed (descriptor.size.precision);
      193 	len = 9 * (p + 2);
      194 	go to done;
      195 
      196 compute (11):					/* complex fixed decimal */
      197 	ovfl = mod (key_offset, 9);
      198 	len = 18 * (fixed (descriptor.size.precision) + 1);
      199 	go to done;
      200 
      201 compute (12):					/* complex float decimal */
      202 	p = fixed (descriptor.size.precision);
      203 	len = 18 * (fixed (descriptor.size.precision) + 2);
      204 	go to done;
      205 
      206 compute (13):					/* unsupported types */
      207 compute (14):
      208 compute (15):
      209 compute (16):
      210 compute (17):
      211 compute (18):
      212 	len = 0;					/* This should never happen */
      213 	go to done;
      214 
      215 compute (19):					/* bit string */
      216 	len = fixed (string (descriptor.size));
      217 	go to done;
      218 
      219 compute (20):					/* varying bit string */
      220 	len = fixed (string (descriptor.size)) + 36;	/* length of attribute (36 for count word) */
      221 	go to done;
      222 
      223 compute (21):					/* char. string */
      224 	len = 9 * fixed (string (descriptor.size));
      225 	go to done;
      226 
      227 compute (22):					/* varying char. string */
      228 	len = 9 * fixed (string (descriptor.size)) + 36;	/* length (in bits) of attribute (36 for the count word) */
      229 	go to done;
      230 
      231 compute (23):					/* unsupported types */
      232 compute (24):
      233 compute (25):
      234 compute (26):
      235 compute (27):
      236 compute (28):
      237 compute (29):
      238 compute (30):
      239 compute (31):
      240 compute (32):
      241 compute (33):
      242 compute (34):
      243 compute (35):
      244 compute (36):
      245 compute (37):
      246 compute (38):
      247 compute (39):
      248 compute (40):
      249 compute (41):
      250 compute (42):
      251 	len = 0;					/* This should never happen */
      252 	go to done;
      253 
      254 compute (43):
      255 	len = vrmu_data_length (desc_ptr -> descr_ovrly);
      256 	go to done;
      257 
      258 compute (44):
      259 	len = vrmu_data_length (desc_ptr -> descr_ovrly);
      260 	go to done;
      261 
      262 compute (45):
      263 	len = vrmu_data_length (desc_ptr -> descr_ovrly); /* complex float dec unal */
      264 	go to done;
      265 
      266 compute (46):
      267 	len = vrmu_data_length (desc_ptr -> descr_ovrly); /* complex fixed dec unal */
      268 	go to done;
      269 
      270 done:
      271 	key_attr_len = len;
      272 	key_alignment = 0;
      273 	if ovfl > 0 then key_alignment = 9 - ovfl;
      274 
      275 	return;
      276 
      277 encode_proc: proc (vp, dp);
      278 
      279 /* procedure to do the actual encoding */
      280 
      281 	dcl     j			 fixed bin (35);
      282 	dcl     (vp, dp)		 ptr;
      283 	dcl     valid_decimal_	 entry (fixed bin, ptr, fixed bin) returns (bit (1));
      284 	declare vrmu_data_class$scalar entry (ptr) returns (bit (1) aligned);
      285 	dcl     mdbm_error_$invalid_dec_data fixed bin (35) ext;
      286 
      287 	val_ptr = vp;
      288 	desc_ptr = dp;
      289 	if ^(vrmu_data_class$scalar (desc_ptr)) then
      290 	     call error (mdbm_error_$unsup_type);
      291 	go to encode (descriptor.type);		/* go encode this value */
      292 
      293 encode (1):					/* fixed bin short */
      294 	if descriptor.packed then p = fixed (descriptor.size.precision);
      295 	else p = 35;
      296 	call encode_fxb;
      297 	go to next;
      298 
      299 encode (2):					/* fixed bin long */
      300 	if descriptor.packed then p = fixed (descriptor.size.precision);
      301 	else p = 71;
      302 	call encode_fxb;
      303 	go to next;
      304 
      305 encode (3):					/* float bin short */
      306 	if descriptor.packed then p = fixed (descriptor.size.precision);
      307 	else p = 27;
      308 	call encode_flb;
      309 	go to next;
      310 
      311 encode (4):					/* float bin long */
      312 	if descriptor.packed then p = fixed (descriptor.size.precision);
      313 	else p = 63;
      314 	call encode_flb;
      315 	go to next;
      316 
      317 encode (5):					/* complex fixed bin short */
      318 	if descriptor.packed then len = 2 * (fixed (descriptor.size.precision) + 1);
      319 	else len = 72;
      320 	substr (data_str, offset, len) = val_ptr -> bit_str; /* no encoding for complex */
      321 	offset = offset + len;
      322 	go to next;
      323 
      324 encode (6):					/* complex fixed bin long */
      325 	if descriptor.packed then len = 2 * (fixed (descriptor.size.precision) + 1);
      326 	else len = 144;
      327 	substr (data_str, offset, len) = val_ptr -> bit_str;
      328 	offset = offset + len;
      329 	go to next;
      330 
      331 encode (7):					/* complex float bin short */
      332 	if descriptor.packed then len = 2 * (fixed (descriptor.size.precision) + 9);
      333 	else len = 72;
      334 	substr (data_str, offset, len) = val_ptr -> bit_str;
      335 	offset = offset + len;
      336 	go to next;
      337 
      338 encode (8):					/* complex float bin long */
      339 	if descriptor.packed then len = 2 * (fixed (descriptor.size.precision) + 9);
      340 	else len = 144;
      341 	substr (data_str, offset, len) = val_ptr -> bit_str;
      342 	offset = offset + len;
      343 	go to next;
      344 
      345 encode (9):					/* real fixed decimal */
      346 	ovfl = mod (offset - 1, 9);			/* byte align */
      347 	if ovfl > 0 then offset = offset + 9 - ovfl;
      348 	cp_ptr = addr (data_bits (offset));		/* point to current pos. */
      349 	p = fixed (descriptor.size.precision);		/* will always pack */
      350 	if fxd.sign = "+" then cp_ptr -> fxd.sign = "p";	/* change sign to preserve order */
      351 	else cp_ptr -> fxd.sign = "n";
      352 	if fxd.sign = "-" then /* if negative no, take 9's compl. */
      353 	     do j = 1 to p;
      354 		cp_ptr -> fxd.digit (j) = 9 - fxd.digit (j);
      355 	     end;
      356 	else do j = 1 to p;				/* if positive, just copy digits */
      357 		cp_ptr -> fxd.digit (j) = fxd.digit (j);
      358 	     end;
      359 	offset = offset + 9 * (p + 1);
      360 	go to next;
      361 
      362 encode (10):					/* real float decimal */
      363 	p = fixed (descriptor.size.precision);
      364 	call encode_fld;
      365 	offset = offset + 9 * (p + 2);
      366 	go to next;
      367 
      368 encode (11):					/* complex fixed decimal */
      369 	ovfl = mod (offset - 1, 9);
      370 	if ovfl > 0 then offset = offset + 9 - ovfl;	/* byte align */
      371 	len = 18 * (fixed (descriptor.size.precision) + 1);
      372 	substr (data_str, offset, len) = val_ptr -> bit_str; /* no encoding for complex */
      373 	offset = offset + len;
      374 	go to next;
      375 
      376 encode (12):					/* complex float decimal */
      377 	p = fixed (descriptor.size.precision);
      378 	len = 18 * (fixed (descriptor.size.precision) + 2);
      379 	substr (data_str, offset, len) = val_ptr -> bit_str;
      380 	offset = offset + len;
      381 	go to next;
      382 
      383 encode (13):					/* unsupported types */
      384 encode (14):
      385 encode (15):
      386 encode (16):
      387 encode (17):
      388 encode (18):
      389 	call error (mdbm_error_$unsup_type);
      390 
      391 encode (19):					/* bit string */
      392 	len = fixed (string (descriptor.size));
      393 	substr (data_str, offset, len) = val_ptr -> bit_str;
      394 	offset = offset + len;
      395 	go to next;
      396 
      397 encode (20):					/* varying bit string */
      398 	len = fixed (string (descriptor.size)) + 36;	/* length of attribute (36 for count word) */
      399 	substr (data_str, offset, len) = "0"b;
      400 	sz_ptr = val_ptr;				/* point to actual number of bits */
      401 	val_ptr = addr (val_ptr -> data_bits (37));	/* point to actual string */
      402 	substr (data_str, offset, size) = substr (val_ptr -> bit_str, 1, size);
      403 	offset = offset + len;
      404 	go to next;
      405 
      406 encode (21):					/* char. string */
      407 	len = 9 * fixed (string (descriptor.size));
      408 	substr (data_str, offset, len) = val_ptr -> bit_str;
      409 	offset = offset + len;
      410 	go to next;
      411 
      412 encode (22):					/* varying char. string */
      413 	len = 9 * fixed (string (descriptor.size)) + 36;	/* length (in bits) of attribute (36 for the count word) */
      414 	substr (data_str, offset, len) = "0"b;
      415 	sz_ptr = val_ptr;				/* pointer to actual number of characters */
      416 	no_bits = size * 9;
      417 	val_ptr = addr (val_ptr -> data_bits (37));	/* pointer to actual string */
      418 	substr (data_str, offset, no_bits) = substr (val_ptr -> bit_str, 1, no_bits);
      419 	offset = offset + len;
      420 	go to next;
      421 
      422 encode (23):					/* unsupported types */
      423 encode (24):
      424 encode (25):
      425 encode (26):
      426 encode (27):
      427 encode (28):
      428 encode (29):
      429 encode (30):
      430 encode (31):
      431 encode (32):
      432 encode (33):
      433 encode (34):
      434 encode (35):
      435 encode (36):
      436 encode (37):
      437 encode (38):
      438 encode (39):
      439 encode (40):
      440 encode (41):
      441 encode (42):
      442 	call error (mdbm_error_$unsup_type);
      443 
      444 encode (43):
      445 	call encode_fxd4;				/* fixed dec unal */
      446 	offset = offset + vrmu_data_length (desc_ptr -> descr_ovrly);
      447 	go to next;
      448 
      449 encode (44):
      450 	call encode_fld4;				/* float dec unal */
      451 	offset = offset + vrmu_data_length (desc_ptr -> descr_ovrly);
      452 	go to next;
      453 
      454 encode (45):
      455 	len = vrmu_data_length (desc_ptr -> descr_ovrly); /* complex float dec unal */
      456 	substr (data_str, offset, len) = val_ptr -> bit_str;
      457 	offset = offset + len;
      458 	go to next;
      459 
      460 encode (46):
      461 	len = vrmu_data_length (desc_ptr -> descr_ovrly); /* complex fixed dec unal */
      462 	substr (data_str, offset, len) = val_ptr -> bit_str;
      463 	offset = offset + len;
      464 	go to next;
      465 
      466 next:
      467 	if (offset - 1) > max_bits then /* if key has gotten too long */
      468 	     call error (mdbm_error_$long_key);
      469 
      470 encode_fxb: proc;
      471 
      472 /* Procedure to encode fixed bin, merely flips sign bit */
      473 
      474 	cp_ptr = addr (data_bits (offset));
      475 	cp_ptr -> fxb.sign = ^fxb.sign;
      476 	cp_ptr -> fxb.val = fxb.val;
      477 	offset = offset + p + 1;
      478 
      479      end encode_fxb;
      480 
      481 
      482 encode_flb: proc;
      483 
      484 /* Procedure to encode float bin, merely transforms so that bit sort will
      485*   order correctly. */
      486 
      487 	cp_ptr = addr (data_bits (offset));
      488 	flb_enc.msign = ^flb_src.msign;
      489 	flb_enc.mval = flb_src.mval;
      490 	if flb_src.msign = "1"b then /* if is neg. no */
      491 	     addr (flb_enc.esign) -> fb8 = 128 - addr (flb_src.esign) -> fb8; /* compl. exp. */
      492 						/* CHANGE 81-09-19 */
      493 	else do;					/* positive, merely flip sign bit */
      494 		flb_enc.esign = ^flb_src.esign;
      495 		flb_enc.eval = flb_src.eval;
      496 	     end;
      497 	offset = offset + p + 9;
      498 
      499      end encode_flb;
      500 
      501 encode_fld: proc;
      502 	cp_ptr = addr (data_bits (offset));
      503 	if ^valid_decimal_ (binary (descriptor.type), val_ptr, binary (descriptor.size.precision))
      504 	then call error (mdbm_error_$invalid_dec_data);
      505 	do j = 1 to p while (fld_src.digit (j) = 0);	/* scan for first non-zero digit */
      506 	end;
      507 	if j > p then do;				/* have zero value */
      508 		fld_enc.msign = "p";
      509 		fld_enc.esign,
      510 		     fld_enc.epad,
      511 		     fld_enc.eval = "0"b;
      512 		do j = 1 to p;
      513 		     fld_enc.digit (j) = 0;
      514 		end;
      515 	     end;					/* if have zero value */
      516 	else do;					/* for non-zero values */
      517 		power_delta = p - j + 1;		/* number to add to exponent */
      518 		shift_delta = j - 1;		/* no. characters to shift */
      519 		if addr (fld_src.esign) -> fb7 + power_delta > 127 then /* if will overflow */
      520 		     call error (mdbm_error_$key_encd_ovfl);
      521 		addr (fld_enc.esign) -> fb7 = addr (fld_src.esign) -> fb7 + power_delta;
      522 		fld_enc.epad = "0"b;
      523 		if fld_src.msign = "-" then do;	/* if negative no. */
      524 			fld_enc.msign = "n";
      525 			do j = 1 to p - shift_delta;	/* 9's compl. of signif. digits to front */
      526 			     fld_enc.digit (j) = 9 - fld_src.digit (j + shift_delta);
      527 			end;
      528 			do j = p - shift_delta + 1 to p; /* fill in trailing 9's */
      529 			     fld_enc.digit (j) = 9;
      530 			end;
      531 			addr (fld_enc.esign) -> fb7 = 128 - addr (fld_enc.esign) -> fb7; /* complement exp. so will sort right */
      532 		     end;				/* if negative no. */
      533 		else do;				/* if positive no. */
      534 			fld_enc.msign = "p";
      535 			do j = 1 to p - shift_delta;	/* move signif. digits to front */
      536 			     fld_enc.digit (j) = fld_src.digit (j + shift_delta);
      537 			end;
      538 			do j = p - shift_delta + 1 to p; /* put in trailing 0's */
      539 			     fld_enc.digit (j) = 0;
      540 			end;
      541 			fld_enc.esign = ^fld_enc.esign; /* flip sign bit so will sort right */
      542 		     end;				/* if positive no. */
      543 	     end;					/* if non-zero */
      544      end encode_fld;
      545 
      546 /* Encoding algorithm for fixed and float decimal unaligned
      547*
      548*   for a fixed data type just ignore rules about exponent.
      549*
      550*   For negative numbers (sign = "1101"b)
      551*   1. set sign to "0000"b
      552*   2. copy sign of exponent
      553*   3. copy complement of exponent
      554*   4. copy complement of number
      555*
      556*   For positive numbers 
      557*   1. set sign to "1111"b
      558*   2. copy number
      559*   3. if number is zero
      560*   a. set exponent to "0000000"b
      561*   b. set sign of exponet to "0"b
      562*   4. if number is not zero
      563*   a. copy exponent
      564*   b. copy sign of exponet
      565*
      566*   Note: zero is normally stored as a positive number with the maximum possible
      567*   exponent.
      568**/
      569 
      570 encode_fxd4: proc;
      571 	cp_ptr = addr (data_bits (offset));
      572 	p = fixed (descriptor.size.precision);
      573 	if mod (p, 2) = 1
      574 	then do;
      575 		digit_len = (divide ((p - 1), 2, 17, 0) * 9) + 4;
      576 		if odd_fxd4_src.sign = "1101"b
      577 		then do;
      578 			odd_fxd4_enc.sign = "0000"b;
      579 			odd_fxd4_enc.digits = ^(odd_fxd4_src.digits);
      580 		     end;
      581 		else do;
      582 			odd_fxd4_enc.sign = "1111"b;
      583 			odd_fxd4_enc.digits = odd_fxd4_src.digits;
      584 		     end;
      585 	     end;
      586 	else do;
      587 		digit_len = (divide (p, 2, 17, 0)) * 9;
      588 		if even_fxd4_src.sign = "1101"b
      589 		then do;
      590 			even_fxd4_enc.sign = "0000"b;
      591 			even_fxd4_enc.digits = ^(even_fxd4_src.digits);
      592 		     end;
      593 		else do;
      594 			even_fxd4_enc.sign = "1111"b;
      595 			even_fxd4_enc.digits = even_fxd4_src.digits;
      596 		     end;
      597 	     end;
      598      end encode_fxd4;
      599 
      600 encode_fld4: proc;
      601 	cp_ptr = addr (data_bits (offset));
      602 	p = fixed (descriptor.size.precision);
      603 	if mod (p, 2) = 1
      604 	then do;
      605 		digit_len = ((divide ((p - 1), 2, 17, 0)) * 9) + 4;
      606 		if odd_fld4_src.sign = "1101"b
      607 		then do;
      608 			odd_fld4_enc.sign = "0000"b;
      609 			odd_fld4_enc.esign = odd_fld4_src.exp.sign;
      610 			odd_fld4_enc.exp = ^(odd_fld4_src.exp.exp);
      611 			odd_fld4_enc.digits = ^(odd_fld4_src.digits);
      612 		     end;
      613 		else do;
      614 			odd_fld4_enc.sign = "1111"b;
      615 			odd_fld4_enc.digits = odd_fld4_src.digits;
      616 			if odd_fld4_src.digits = "0"b
      617 			then do;
      618 				odd_fld4_enc.esign = "0"b;
      619 				odd_fld4_enc.exp = "0"b;
      620 			     end;
      621 			else do;
      622 				odd_fld4_enc.esign = ^(odd_fld4_src.exp.sign);
      623 				odd_fld4_enc.exp = odd_fld4_src.exp.exp;
      624 			     end;
      625 		     end;
      626 	     end;
      627 	else do;
      628 		digit_len = (divide (p, 2, 17, 0)) * 9;
      629 		if even_fld4_src.sign = "1101"b
      630 		then do;
      631 			even_fld4_enc.sign = "0000"b;
      632 			even_fld4_enc.esign = even_fld4_src.exp.sign;
      633 			even_fld4_enc.exp = ^(even_fld4_src.exp.high) || ^(even_fld4_src.exp.low);
      634 			even_fld4_enc.digits = ^(even_fld4_src.digits);
      635 		     end;
      636 		else do;
      637 			even_fld4_enc.sign = "1111"b;
      638 			even_fld4_enc.digits = even_fld4_src.digits;
      639 			if even_fld4_src.digits = "0"b
      640 			then do;
      641 				even_fld4_enc.esign = "0"b;
      642 				even_fld4_enc.exp = "0"b;
      643 			     end;
      644 			else do;
      645 				even_fld4_enc.esign = ^(even_fld4_src.exp.sign);
      646 				even_fld4_enc.exp = even_fld4_src.exp.high || even_fld4_src.exp.low;
      647 			     end;
      648 		     end;
      649 	     end;
      650      end encode_fld4;
      651 
      652      end encode_proc;
      653 
      654 error: proc (cd);
      655 
      656 /* error procedure */
      657 
      658 	dcl     cd		 fixed bin (35);
      659 
      660 	code = cd;
      661 	go to exit;
      662 
      663      end error;
      664 
      665 	dcl     descr_ovrly		 bit (36) based unal;
      666 	dcl     key		 char (256) var;	/* Output: encoded key */
      667 	dcl     key_bit_len		 fixed bin (35);	/* Output: number of bits of encoded data in the key */
      668 	dcl     key_alignment	 fixed bin (17);    /* Output: number of bits to add to offset to align */
      669 	dcl     key_attr_len	 fixed bin (17);    /* Output: number of bits of encoded data in key attribute */
      670 	dcl     key_offset		 fixed bin (17);	/* Input: Current offset in key - zero based */
      671 	dcl     ds_ptr		 ptr;		/* Input: pointer to
      672*descriptor */
      673 	dcl     code		 fixed bin (35);	/* Output: status code */
      674 	dcl     max_bits		 fixed bin (35);	/* max bits allowed in encoded string */
      675 
      676 	dcl     (len_ptr,				/* pointer to length field of key */
      677 	        val_ptr,				/* ptr to a source value */
      678 	        data_ptr,				/* pointer to bit view of key */
      679 	        cp_ptr,				/* pointer to current position in key */
      680 	        ss_ptr,				/* Input:  to attr. string to be encoded */
      681 	        a_desc_ptr,				/* Input:  to descriptor of input value */
      682 	        sz_ptr)		 ptr;		/* ptr to length field of varying value */
      683 
      684 	dcl     (i,				/* internal index */
      685 	        ovfl,				/* no. overflow bits for aligning */
      686 	        offset,				/* current bit position in key */
      687 	        p,				/* precision of value */
      688 	        len				/* bit length of value */
      689 	        )			 fixed bin;
      690 
      691 	dcl     data_str		 bit (max_bits) unal based (data_ptr); /* bit string view of key */
      692 	dcl     data_bits		 (max_bits) bit (1) unal based (data_ptr); /* bit array view */
      693 	dcl     key_length		 fixed bin (35) based (len_ptr); /* char. length of key */
      694 	dcl     encd_str		 char (*) var;	/* Output:   encoded attr. value */
      695 	dcl     bit_str		 bit (len) based;	/* template */
      696 	dcl     (power_delta,			/* increase in exp. for normaliz. */
      697 	        shift_delta)	 fixed bin (7);	/* no chars to shift for norm. */
      698 	dcl     fb7		 fixed bin (7) based unal; /* template */
      699 	dcl     fb8		 fixed bin (8) based unal unsigned; /* template */
      700 	dcl     size		 fixed bin (35) unaligned based (sz_ptr); /* curr. len. of varying value */
      701 	dcl     no_bits		 fixed bin (35) unaligned; /* number of bits in vary char attr. */
      702 
      703 	dcl     1 fxb		 unal based (val_ptr), /* fixed bin template */
      704 		2 sign		 bit (1) unal,
      705 		2 val		 bit (p) unal;
      706 
      707 	dcl     1 flb_src		 unal based (val_ptr), /* template for source float bin */
      708 		2 esign		 bit (1) unal,
      709 		2 eval		 bit (7) unal,
      710 		2 msign		 bit (1) unal,
      711 		2 mval		 bit (p) unal;
      712 
      713 	dcl     1 flb_enc		 unal based (cp_ptr), /* template for encoded float bin */
      714 		2 msign		 bit (1) unal,
      715 		2 esign		 bit (1) unal,
      716 		2 eval		 bit (7) unal,
      717 		2 mval		 bit (p) unal;
      718 
      719 	dcl     1 fxd		 unal based (val_ptr), /* template for fixed dec. */
      720 		2 sign		 char (1) unal,
      721 		2 digit		 (p) pic "9" unal;
      722 
      723 	dcl     1 fld_src		 unal based (val_ptr), /* template for float dec source */
      724 		2 msign		 char (1) unal,
      725 		2 digit		 (p) pic "9" unal,
      726 		2 epad		 bit (1) unal,
      727 		2 esign		 bit (1) unal,
      728 		2 eval		 bit (7) unal;
      729 
      730 	dcl     1 fld_enc		 unal based (cp_ptr), /* template for float dec encoded */
      731 		2 msign		 char (1) unal,
      732 		2 epad		 bit (1) unal,
      733 		2 esign		 bit (1) unal,
      734 		2 eval		 bit (7) unal,
      735 		2 digit		 (p) pic "9" unal;
      736 
      737 
      738 	dcl     01 odd_fxd4_src	 based (val_ptr),
      739 		02 pad1		 bit (1) unal,
      740 		02 sign		 bit (4) unal,
      741 		02 digits		 bit (digit_len) unal;
      742 
      743 	dcl     01 even_fxd4_src	 based (val_ptr),
      744 		02 pad1		 bit (1) unal,
      745 		02 sign		 bit (4) unal,
      746 		02 digits		 bit (digit_len) unal,
      747 		02 pad2		 bit (4) unal;
      748 
      749 	dcl     01 odd_fxd4_enc	 based (cp_ptr),
      750 		02 pad1		 bit (1) unal init ("0"b),
      751 		02 sign		 bit (4) unal,
      752 		02 digits		 bit (digit_len) unal;
      753 
      754 	dcl     01 even_fxd4_enc	 based (cp_ptr),
      755 		02 pad1		 bit (1) unal init ("0"b),
      756 		02 pad2		 bit (4) unal init ("0"b),
      757 		02 sign		 bit (4) unal,
      758 		02 digits		 bit (digit_len) unal;
      759 
      760 	dcl     01 even_fld4_src	 based (val_ptr),
      761 		02 pad1		 bit (1) unal,
      762 		02 sign		 bit (4) unal,
      763 		02 digits		 bit (digit_len) unal,
      764 		02 exp,
      765 		  03 sign		 bit (1) unal,
      766 		  03 high		 bit (3) unal,
      767 		  03 pad2		 bit (1) unal,
      768 		  03 low		 bit (4) unal,
      769 		  03 pad3		 bit (4) unal;
      770 
      771 	dcl     01 odd_fld4_src	 based (val_ptr),
      772 		02 pad1		 bit (1) unal,
      773 		02 sign		 bit (4) unal,
      774 		02 digits		 bit (digit_len) unal,
      775 		02 exp,
      776 		  03 pad2		 bit (1) unal,
      777 		  03 sign		 bit (1) unal,
      778 		  03 exp		 bit (7) unal;
      779 
      780 	dcl     01 odd_fld4_enc	 based (cp_ptr),
      781 		02 pad1		 bit (1) unal init ("0"b),
      782 		02 pad2		 bit (1) unal init ("0"b),
      783 		02 sign		 bit (4) unal,
      784 		02 esign		 bit (1) unal,
      785 		02 exp		 bit (7) unal,
      786 		02 digits		 bit (digit_len) unal;
      787 
      788 	dcl     01 even_fld4_enc	 based (cp_ptr),
      789 		02 pad1		 bit (1) unal init ("0"b),
      790 		02 pad2		 bit (1) unal init ("0"b),
      791 		02 pad3		 bit (4) unal init ("0"b),
      792 		02 sign		 bit (4) unal,
      793 		02 esign		 bit (1) unal,
      794 		02 exp		 bit (7) unal,
      795 		02 digits		 bit (digit_len) unal;
      796 
      797 	dcl     digit_len		 fixed bin;
      798 
      799 
      800 	dcl     (mdbm_error_$unsup_type,
      801 	        mdbm_error_$long_key,
      802 	        mdbm_error_$key_encd_ovfl) fixed bin (35) ext;
      803 
      804 	dcl     (addr,
      805 	        addrel,
      806 	        binary,
      807 	        divide,
      808 	        fixed,
      809 	        substr,
      810 	        mod,
      811 	        string,
      812 	        maxlength,
      813 	        ceil)		 builtin;
      814 
      815 	dcl     vrmu_data_length	 entry (bit (36)) returns (fixed bin (35));
      816 
      817 
  1     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  1     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  1     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  1     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  1     5 
  1     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  1     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  1     8     2 type unsigned fixed bin (6) unal,			/* data type */
  1     9     2 packed bit (1) unal,				/* on if data item is packed */
  1    10     2 number_dims bit (4) unal,			/* dimensions */
  1    11     2 size,					/* size for string data */
  1    12       3 scale bit (12) unal,				/* scale for num. data */
  1    13       3 precision bit (12) unal,			/* prec. for num. data */
  1    14     2 array_info (num_dims),
  1    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  1    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  1    17       3 multiplier fixed bin (35);			/*  element separation */
  1    18 
  1    19 dcl  desc_ptr ptr;
  1    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  1    21 
  1    22 /* END mdbm_descriptor.incl.pl1 */
  1    23 
  1    24 
      818 
  2     1 /* BEGIN vrm_index.incl.pl1 -- jaw, 5/12/78 */
  2     2 
  2     3 /* Renamed 9/29/82 by R. Harvey */
  2     4 
  2     5 /* This structure defines the header that gets put onto the beginning of
  2     6*   each key stored into a database */
  2     7 
  2     8 
  2     9 dcl 1 index aligned based (index_ptr),			/* layout of mdbm_index for all file types */
  2    10     2 rel_id bit (12) unal,				/* relation id */
  2    11     2 index_id bit (8) unal,				/* id of index within rel */
  2    12     2 mbz bit (7) unal,				/* pad to char. */
  2    13     2 index_value char (index_value_length) unal;		/* index value; max 253 chars */
  2    14 
  2    15 dcl  index_ptr ptr;
  2    16 dcl  index_value_length fixed bin (35);
  2    17 
  2    18 /* END vrm_index.incl.pl1 */
  2    19 
      819 
  3     1 /* BEGIN vrm_key_source_list.incl.pl1 -- jaw, 6/1/78 */
  3     2 
  3     3 /* HISTORY:
  3     4*
  3     5*   81-07-18 Jim Gray : added pointer to the rm_attr_info for display purposes
  3     6*
  3     7*   81-07-19 Jim Gray : added condition that will  used  against  the
  3     8*   key value for display purposes
  3     9*   82-09-29  R. Harvey: Stolen and modified for vfile_relmgr_
  3    10*
  3    11**/
  3    12 
  3    13 
  3    14 dcl 1 key_source_list aligned based (key_source_list_ptr),	/* source info for key encoding */
  3    15     2 number_of_values fixed bin,			/* no. values in key */
  3    16     2 val_info (ksl_number_of_values refer (key_source_list.number_of_values)),
  3    17 /*      3 condition_code fixed bin,			/* encoding for condition used on this key attr */
  3    18       3 val_ptr ptr,				/* to value */
  3    19       3 desc_ptr ptr;				/* to descriptor */
  3    20 
  3    21 dcl  key_source_list_ptr ptr;
  3    22 dcl  ksl_number_of_values fixed bin;
  3    23 
  3    24 /* END vrm_key_source_list.incl.pl1 */
  3    25 
      820 
      821 
      822 
      823      end vrmu_encode_key;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/21/84  0920.3  vrmu_encode_key.pl1               >special_ldd>online>mrds_install>vrmu_encode_key.pl1
818          1    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
819          2    10/14/83  1609.1  vrm_index.incl.pl1                >ldd>include>vrm_index.incl.pl1
820          3    10/14/83  1609.1  vrm_key_source_list.incl.pl1      >ldd>include>vrm_key_source_list.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_desc_ptr                             parameter       pointer                  dcl 676 set ref 118 127*
addr                                                   builtin function         dcl 804 ref 87 89 123 348 401 417 474 487 490 490
                                                                                  502 519 521 521 531 531 571 601
addrel                                                 builtin function         dcl 804 ref 88 124
binary                                                 builtin function         dcl 804 ref 503 503 503 503
bit_str                                based           bit                      unaligned dcl 695 ref 320 327 334 341 372 379 393
                                                                                  402 408 418 456 462
cd                                     parameter       fixed bin(35,0)          dcl 658 ref 654 660
ceil                                                   builtin function         dcl 804 ref 104 128
code                                   parameter       fixed bin(35,0)          dcl 673 set ref 18 113* 118 129* 660*
cp_ptr                          000110 automatic       pointer                  dcl 676 set ref 348* 350 351 354 357 474* 475 476
                                                                                  487* 488 489 490 494 495 502* 508 509 509 509 513
                                                                                  521 522 524 526 529 531 531 534 536 539 541 541
                                                                                  571* 578 579 582 583 590 591 594 595 601* 608 609
                                                                                  610 611 614 615 618 619 622 623 631 632 633 634
                                                                                  637 638 641 642 645 646
data_bits                              based           bit(1)                   array unaligned dcl 692 set ref 348 401 417 474 487
                                                                                  502 571 601
data_ptr                        000106 automatic       pointer                  dcl 676 set ref 89* 97 124* 126 320 327 334 341 348
                                                                                  372 379 393 399 402 408 414 418 456 462 474 487
                                                                                  502 571 601
data_str                               based           bit                      unaligned dcl 691 set ref 97* 126* 320* 327* 334*
                                                                                  341* 372* 379* 393* 399* 402* 408* 414* 418* 456*
                                                                                  462*
desc_ptr                  4            based           pointer                  array level 3 in structure "key_source_list"
                                                                                  dcl 3-14 in procedure "vrmu_encode_key" set ref
                                                                                  100*
desc_ptr                        000126 automatic       pointer                  dcl 1-19 in procedure "vrmu_encode_key" set ref 134*
                                                                                  138 140 140 146 146 152 152 158 158 164 164 169
                                                                                  169 175 175 180 180 187 191 198 201 203 215 219
                                                                                  223 227 254 258 262 266 288* 289* 291 293 293 299
                                                                                  299 305 305 311 311 317 317 324 324 331 331 338
                                                                                  338 349 362 371 376 378 391 397 406 412 446 451
                                                                                  454 460 503 503 503 503 572 602
descr_ovrly                            based           bit(36)                  unaligned dcl 665 set ref 254* 258* 262* 266* 446*
                                                                                  451* 454* 460*
descriptor                             based           structure                level 1 unaligned dcl 1-6
digit                     0(09)        based           picture(1)               array level 2 in structure "fxd" packed unaligned
                                                                                  dcl 719 in procedure "vrmu_encode_key" set ref
                                                                                  354* 354 357* 357
digit                     0(18)        based           picture(1)               array level 2 in structure "fld_enc" packed
                                                                                  unaligned dcl 730 in procedure "vrmu_encode_key"
                                                                                  set ref 513* 526* 529* 536* 539*
digit                     0(09)        based           picture(1)               array level 2 in structure "fld_src" packed
                                                                                  unaligned dcl 723 in procedure "vrmu_encode_key"
                                                                                  ref 505 526 536
digit_len                       000124 automatic       fixed bin(17,0)          dcl 797 set ref 575* 579 579 583 583 587* 591 591
                                                                                  595 595 605* 609 610 611 611 615 615 616 622 623
                                                                                  628* 632 633 633 634 634 638 638 639 645 646 646
digits                    0(14)        based           bit                      level 2 in structure "odd_fld4_enc" packed unaligned
                                                                                  dcl 780 in procedure "vrmu_encode_key" set ref
                                                                                  611* 615*
digits                    0(05)        based           bit                      level 2 in structure "odd_fld4_src" packed unaligned
                                                                                  dcl 771 in procedure "vrmu_encode_key" ref 611 615
                                                                                  616
digits                    0(09)        based           bit                      level 2 in structure "even_fxd4_enc" packed
                                                                                  unaligned dcl 754 in procedure "vrmu_encode_key"
                                                                                  set ref 591* 595*
digits                    0(05)        based           bit                      level 2 in structure "even_fxd4_src" packed
                                                                                  unaligned dcl 743 in procedure "vrmu_encode_key"
                                                                                  ref 591 595
digits                    0(05)        based           bit                      level 2 in structure "even_fld4_src" packed
                                                                                  unaligned dcl 760 in procedure "vrmu_encode_key"
                                                                                  ref 634 638 639
digits                    0(05)        based           bit                      level 2 in structure "odd_fxd4_enc" packed unaligned
                                                                                  dcl 749 in procedure "vrmu_encode_key" set ref
                                                                                  579* 583*
digits                    0(05)        based           bit                      level 2 in structure "odd_fxd4_src" packed unaligned
                                                                                  dcl 738 in procedure "vrmu_encode_key" ref 579 583
digits                    0(18)        based           bit                      level 2 in structure "even_fld4_enc" packed
                                                                                  unaligned dcl 788 in procedure "vrmu_encode_key"
                                                                                  set ref 634* 638*
divide                                                 builtin function         dcl 804 ref 104 128 575 587 605 628
dp                                     parameter       pointer                  dcl 282 ref 277 288
ds_ptr                                 parameter       pointer                  dcl 671 ref 132 134
encd_str                               parameter       varying char             dcl 694 set ref 118 123 125
epad                      0(09)        based           bit(1)                   level 2 packed unaligned dcl 730 set ref 509* 522*
esign                     0(06)        based           bit(1)                   level 2 in structure "odd_fld4_enc" packed unaligned
                                                                                  dcl 780 in procedure "vrmu_encode_key" set ref
                                                                                  609* 618* 622*
esign                     0(01)        based           bit(1)                   level 2 in structure "flb_enc" packed unaligned
                                                                                  dcl 713 in procedure "vrmu_encode_key" set ref 490
                                                                                  494*
esign                                  based           bit(1)                   level 2 in structure "flb_src" packed unaligned
                                                                                  dcl 707 in procedure "vrmu_encode_key" set ref 490
                                                                                  494
esign                                  based           bit(1)                   level 2 in structure "fld_src" packed unaligned
                                                                                  dcl 723 in procedure "vrmu_encode_key" set ref 519
                                                                                  521
esign                     0(10)        based           bit(1)                   level 2 in structure "fld_enc" packed unaligned
                                                                                  dcl 730 in procedure "vrmu_encode_key" set ref
                                                                                  509* 521 531 531 541* 541
esign                     0(10)        based           bit(1)                   level 2 in structure "even_fld4_enc" packed
                                                                                  unaligned dcl 788 in procedure "vrmu_encode_key"
                                                                                  set ref 632* 641* 645*
eval                      0(01)        based           bit(7)                   level 2 in structure "flb_src" packed unaligned
                                                                                  dcl 707 in procedure "vrmu_encode_key" ref 495
eval                      0(11)        based           bit(7)                   level 2 in structure "fld_enc" packed unaligned
                                                                                  dcl 730 in procedure "vrmu_encode_key" set ref
                                                                                  509*
eval                      0(02)        based           bit(7)                   level 2 in structure "flb_enc" packed unaligned
                                                                                  dcl 713 in procedure "vrmu_encode_key" set ref
                                                                                  495*
even_fld4_enc                          based           structure                level 1 packed unaligned dcl 788
even_fld4_src                          based           structure                level 1 packed unaligned dcl 760
even_fxd4_enc                          based           structure                level 1 packed unaligned dcl 754
even_fxd4_src                          based           structure                level 1 packed unaligned dcl 743
exp                                    based           structure                level 2 in structure "odd_fld4_src" packed unaligned
                                                                                  dcl 771 in procedure "vrmu_encode_key"
exp                       0(11)        based           bit(7)                   level 2 in structure "even_fld4_enc" packed
                                                                                  unaligned dcl 788 in procedure "vrmu_encode_key"
                                                                                  set ref 633* 642* 646*
exp                                    based           structure                level 2 in structure "even_fld4_src" packed
                                                                                  unaligned dcl 760 in procedure "vrmu_encode_key"
exp                                    based           bit(7)                   level 3 in structure "odd_fld4_src" packed unaligned
                                                                                  dcl 771 in procedure "vrmu_encode_key" ref 610 623
exp                       0(07)        based           bit(7)                   level 2 in structure "odd_fld4_enc" packed unaligned
                                                                                  dcl 780 in procedure "vrmu_encode_key" set ref
                                                                                  610* 619* 623*
fb7                                    based           fixed bin(7,0)           unaligned dcl 698 set ref 519 521* 521 531* 531
fb8                                    based           fixed bin(8,0)           unsigned unaligned dcl 699 set ref 490* 490
fixed                                                  builtin function         dcl 804 ref 140 146 152 158 164 169 175 180 187 191
                                                                                  198 201 203 215 219 223 227 293 299 305 311 317
                                                                                  324 331 338 349 362 371 376 378 391 397 406 412
                                                                                  572 602
flb_enc                                based           structure                level 1 packed unaligned dcl 713
flb_src                                based           structure                level 1 packed unaligned dcl 707
fld_enc                                based           structure                level 1 packed unaligned dcl 730
fld_src                                based           structure                level 1 packed unaligned dcl 723
fxb                                    based           structure                level 1 packed unaligned dcl 703
fxd                                    based           structure                level 1 packed unaligned dcl 719
high                                   based           bit(3)                   level 3 packed unaligned dcl 760 ref 633 646
i                               000114 automatic       fixed bin(17,0)          dcl 684 set ref 99* 100 100*
index                                  based           structure                level 1 dcl 2-9
index_ptr                       000132 automatic       pointer                  dcl 2-15 set ref 88* 89 103
index_value               0(27)        based           char                     level 2 packed unaligned dcl 2-9 set ref 89
index_value_length              000134 automatic       fixed bin(35,0)          dcl 2-16 set ref 85* 89
j                               000144 automatic       fixed bin(35,0)          dcl 281 set ref 352* 354 354* 356* 357 357* 505*
                                                                                  505* 507 512* 513* 517 518 525* 526 526* 528* 529*
                                                                                  535* 536 536* 538* 539*
key                                    parameter       varying char(256)        dcl 666 set ref 18 87
key_alignment                          parameter       fixed bin(17,0)          dcl 668 set ref 132 272* 273*
key_attr_len                           parameter       fixed bin(17,0)          dcl 669 set ref 132 270*
key_bit_len                            parameter       fixed bin(35,0)          dcl 667 set ref 18 105*
key_length                             based           fixed bin(35,0)          dcl 693 set ref 104* 128*
key_offset                             parameter       fixed bin(17,0)          dcl 670 ref 132 185 196
key_source_list                        based           structure                level 1 dcl 3-14
key_source_list_ptr                    parameter       pointer                  dcl 3-21 ref 18 99 100 100
len                             000120 automatic       fixed bin(17,0)          dcl 684 set ref 143* 149* 155* 161* 164* 166* 169*
                                                                                  171* 175* 177* 180* 182* 188* 193* 198* 203* 206*
                                                                                  215* 219* 223* 227* 231* 254* 258* 262* 266* 270
                                                                                  317* 319* 320 320 321 324* 326* 327 327 328 331*
                                                                                  333* 334 334 335 338* 340* 341 341 342 371* 372
                                                                                  372 373 378* 379 379 380 391* 393 393 394 397* 399
                                                                                  402 403 406* 408 408 409 412* 414 418 419 454* 456
                                                                                  456 457 460* 462 462 463
len_ptr                         000102 automatic       pointer                  dcl 676 set ref 87* 88 104 123* 124 128
low                                    based           bit(4)                   level 3 packed unaligned dcl 760 ref 633 646
max_bits                        000100 automatic       fixed bin(35,0)          dcl 674 set ref 90* 97 125* 126 320 327 334 341 372
                                                                                  379 393 399 402 408 414 418 456 462 466
maxlength                                              builtin function         dcl 804 ref 125
mbz                       0(20)        based           bit(7)                   level 2 packed unaligned dcl 2-9 set ref 103*
mdbm_error_$invalid_dec_data    000024 external static fixed bin(35,0)          dcl 285 set ref 503*
mdbm_error_$key_encd_ovfl       000014 external static fixed bin(35,0)          dcl 800 set ref 519*
mdbm_error_$long_key            000012 external static fixed bin(35,0)          dcl 800 set ref 466*
mdbm_error_$unsup_type          000010 external static fixed bin(35,0)          dcl 800 set ref 289* 383* 422*
mod                                                    builtin function         dcl 804 ref 185 196 345 368 573 603
msign                                  based           char(1)                  level 2 in structure "fld_src" packed unaligned
                                                                                  dcl 723 in procedure "vrmu_encode_key" ref 523
msign                                  based           char(1)                  level 2 in structure "fld_enc" packed unaligned
                                                                                  dcl 730 in procedure "vrmu_encode_key" set ref
                                                                                  508* 524* 534*
msign                                  based           bit(1)                   level 2 in structure "flb_enc" packed unaligned
                                                                                  dcl 713 in procedure "vrmu_encode_key" set ref
                                                                                  488*
msign                     0(08)        based           bit(1)                   level 2 in structure "flb_src" packed unaligned
                                                                                  dcl 707 in procedure "vrmu_encode_key" ref 488 490
mval                      0(09)        based           bit                      level 2 in structure "flb_src" packed unaligned
                                                                                  dcl 707 in procedure "vrmu_encode_key" ref 489
mval                      0(09)        based           bit                      level 2 in structure "flb_enc" packed unaligned
                                                                                  dcl 713 in procedure "vrmu_encode_key" set ref
                                                                                  489*
no_bits                         000123 automatic       fixed bin(35,0)          unaligned dcl 701 set ref 416* 418 418
num_dims                        000130 automatic       fixed bin(17,0)          initial dcl 1-20 set ref 85* 1-20*
number_of_values                       based           fixed bin(17,0)          level 2 dcl 3-14 ref 99
odd_fld4_enc                           based           structure                level 1 packed unaligned dcl 780
odd_fld4_src                           based           structure                level 1 packed unaligned dcl 771
odd_fxd4_enc                           based           structure                level 1 packed unaligned dcl 749
odd_fxd4_src                           based           structure                level 1 packed unaligned dcl 738
offset                          000116 automatic       fixed bin(17,0)          dcl 684 set ref 96* 104 105 122* 128 320 321* 321
                                                                                  327 328* 328 334 335* 335 341 342* 342 345 347*
                                                                                  347 348 359* 359 365* 365 368 370* 370 372 373*
                                                                                  373 379 380* 380 393 394* 394 399 402 403* 403 408
                                                                                  409* 409 414 418 419* 419 446* 446 451* 451 456
                                                                                  457* 457 462 463* 463 466 474 477* 477 487 497*
                                                                                  497 502 571 601
ovfl                            000115 automatic       fixed bin(17,0)          dcl 684 set ref 135* 185* 196* 273 273 345* 347 347
                                                                                  368* 370 370
p                               000117 automatic       fixed bin(17,0)          dcl 684 set ref 140* 142* 143 146* 148* 149 152*
                                                                                  154* 155 158* 160* 161 187* 188 191* 193 201* 293*
                                                                                  295* 299* 301* 305* 307* 311* 313* 349* 352 356
                                                                                  359 362* 365 376* 476 476 477 489 489 497 505 507
                                                                                  512 517 519 521 525 528 528 535 538 538 572* 573
                                                                                  575 587 602* 603 605 628
packed                    0(07)        based           bit(1)                   level 2 packed unaligned dcl 1-6 ref 140 146 152 158
                                                                                  164 169 175 180 293 299 305 311 317 324 331 338
power_delta                     000121 automatic       fixed bin(7,0)           dcl 696 set ref 517* 519 521
precision                 0(24)        based           bit(12)                  level 3 packed unaligned dcl 1-6 ref 140 146 152 158
                                                                                  164 169 175 180 187 191 198 201 203 293 299 305
                                                                                  311 317 324 331 338 349 362 371 376 378 503 503
                                                                                  572 602
shift_delta                     000122 automatic       fixed bin(7,0)           dcl 696 set ref 518* 525 526 528 535 536 538
sign                                   based           bit(1)                   level 2 in structure "fxb" packed unaligned dcl 703
                                                                                  in procedure "vrmu_encode_key" set ref 475* 475
sign                      0(01)        based           bit(4)                   level 2 in structure "odd_fld4_src" packed unaligned
                                                                                  dcl 771 in procedure "vrmu_encode_key" ref 606
sign                      0(01)        based           bit(4)                   level 2 in structure "even_fld4_src" packed
                                                                                  unaligned dcl 760 in procedure "vrmu_encode_key"
                                                                                  ref 629
sign                                   based           char(1)                  level 2 in structure "fxd" packed unaligned dcl 719
                                                                                  in procedure "vrmu_encode_key" set ref 350 350*
                                                                                  351* 352
sign                      0(01)        based           bit(4)                   level 2 in structure "even_fxd4_src" packed
                                                                                  unaligned dcl 743 in procedure "vrmu_encode_key"
                                                                                  ref 588
sign                      0(05)        based           bit(4)                   level 2 in structure "even_fxd4_enc" packed
                                                                                  unaligned dcl 754 in procedure "vrmu_encode_key"
                                                                                  set ref 590* 594*
sign                                   based           bit(1)                   level 3 in structure "odd_fld4_src" packed unaligned
                                                                                  dcl 771 in procedure "vrmu_encode_key" ref 609 622
sign                      0(01)        based           bit(4)                   level 2 in structure "odd_fxd4_src" packed unaligned
                                                                                  dcl 738 in procedure "vrmu_encode_key" ref 576
sign                                   based           bit(1)                   level 3 in structure "even_fld4_src" packed
                                                                                  unaligned dcl 760 in procedure "vrmu_encode_key"
                                                                                  ref 632 645
sign                      0(02)        based           bit(4)                   level 2 in structure "odd_fld4_enc" packed unaligned
                                                                                  dcl 780 in procedure "vrmu_encode_key" set ref
                                                                                  608* 614*
sign                      0(01)        based           bit(4)                   level 2 in structure "odd_fxd4_enc" packed unaligned
                                                                                  dcl 749 in procedure "vrmu_encode_key" set ref
                                                                                  578* 582*
sign                      0(06)        based           bit(4)                   level 2 in structure "even_fld4_enc" packed
                                                                                  unaligned dcl 788 in procedure "vrmu_encode_key"
                                                                                  set ref 631* 637*
size                      0(12)        based           structure                level 2 in structure "descriptor" packed unaligned
                                                                                  dcl 1-6 in procedure "vrmu_encode_key" ref 215 219
                                                                                  223 227 391 397 406 412
size                                   based           fixed bin(35,0)          unaligned dcl 700 in procedure "vrmu_encode_key" ref
                                                                                  402 402 416
ss_ptr                                 parameter       pointer                  dcl 676 set ref 118 127*
string                                                 builtin function         dcl 804 ref 215 219 223 227 391 397 406 412
substr                                                 builtin function         dcl 804 set ref 320* 327* 334* 341* 372* 379* 393*
                                                                                  399* 402* 402 408* 414* 418* 418 456* 462*
sz_ptr                          000112 automatic       pointer                  dcl 676 set ref 400* 402 402 415* 416
type                      0(01)        based           fixed bin(6,0)           level 2 packed unsigned unaligned dcl 1-6 ref 138
                                                                                  291 503 503
val                       0(01)        based           bit                      level 2 packed unaligned dcl 703 set ref 476* 476
val_info                  2            based           structure                array level 2 dcl 3-14
val_ptr                         000104 automatic       pointer                  dcl 676 in procedure "vrmu_encode_key" set ref 287*
                                                                                  320 327 334 341 350 352 354 357 372 379 393 400
                                                                                  401* 401 402 408 415 417* 417 418 456 462 475 476
                                                                                  488 489 490 490 494 495 503* 505 519 521 523 526
                                                                                  536 576 579 583 588 591 595 606 609 610 611 615
                                                                                  616 622 623 629 632 633 633 634 638 639 645 646
                                                                                  646
val_ptr                   2            based           pointer                  array level 3 in structure "key_source_list"
                                                                                  dcl 3-14 in procedure "vrmu_encode_key" set ref
                                                                                  100*
valid_decimal_                  000020 constant        entry                    external dcl 283 ref 503
vp                                     parameter       pointer                  dcl 282 ref 277 287
vrmu_data_class$scalar          000022 constant        entry                    external dcl 284 ref 289
vrmu_data_length                000016 constant        entry                    external dcl 815 ref 254 258 262 266 446 451 454 460

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ksl_number_of_values                   automatic       fixed bin(17,0)          dcl 3-22

NAMES DECLARED BY EXPLICIT CONTEXT.
compute                         000000 constant        label                    array(46) dcl 140 ref 138
compute_alignment_and_length    000346 constant        entry                    external dcl 132
done                            000730 constant        label                    dcl 270 ref 144 150 156 162 167 172 178 183 189 194
                                                                                  199 204 213 217 221 225 229 252 256 260 264 268
encode                          000056 constant        label                    array(46) dcl 293 ref 291
encode_attr                     000263 constant        entry                    external dcl 118
encode_flb                      001732 constant        entry                    internal dcl 482 ref 308 314
encode_fld                      002022 constant        entry                    internal dcl 501 ref 364
encode_fld4                     002556 constant        entry                    internal dcl 600 ref 449
encode_fxb                      001700 constant        entry                    internal dcl 470 ref 296 302
encode_fxd4                     002442 constant        entry                    internal dcl 570 ref 444
encode_proc                     000742 constant        entry                    internal dcl 277 ref 100 127
error                           003046 constant        entry                    internal dcl 654 ref 289 383 422 466 503 519
exit                            000255 constant        label                    dcl 115 ref 661
next                            001664 constant        label                    dcl 466 ref 297 303 309 315 322 329 336 343 360 366
                                                                                  374 381 395 404 410 420 447 452 458 464
vrmu_encode_key                 000154 constant        entry                    external dcl 18

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3226        3254    3071        3236
Length      3520    3071        26         230     134           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vrmu_encode_key                     188 external procedure  is an external procedure.  
encode_proc                             internal procedure  shares stack frame of external procedure vrmu_encode_key.  
encode_fxb                              internal procedure  shares stack frame of external procedure vrmu_encode_key.  
encode_flb                              internal procedure  shares stack frame of external procedure vrmu_encode_key.  
encode_fld                              internal procedure  shares stack frame of external procedure vrmu_encode_key.  
encode_fxd4                             internal procedure  shares stack frame of external procedure vrmu_encode_key.  
encode_fld4                             internal procedure  shares stack frame of external procedure vrmu_encode_key.  
error                                   internal procedure  shares stack frame of external procedure vrmu_encode_key.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
vrmu_encode_key          000100 max_bits                    vrmu_encode_key
                         000102 len_ptr                     vrmu_encode_key
                         000104 val_ptr                     vrmu_encode_key
                         000106 data_ptr                    vrmu_encode_key
                         000110 cp_ptr                      vrmu_encode_key
                         000112 sz_ptr                      vrmu_encode_key
                         000114 i                           vrmu_encode_key
                         000115 ovfl                        vrmu_encode_key
                         000116 offset                      vrmu_encode_key
                         000117 p                           vrmu_encode_key
                         000120 len                         vrmu_encode_key
                         000121 power_delta                 vrmu_encode_key
                         000122 shift_delta                 vrmu_encode_key
                         000123 no_bits                     vrmu_encode_key
                         000124 digit_len                   vrmu_encode_key
                         000126 desc_ptr                    vrmu_encode_key
                         000130 num_dims                    vrmu_encode_key
                         000132 index_ptr                   vrmu_encode_key
                         000134 index_value_length          vrmu_encode_key
                         000144 j                           encode_proc

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_bs            call_ext_out        return              mpfx2               mod_fx1             shorten_stack
ext_entry           ext_entry_desc      ceil_fx1            unpack_pic          divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
valid_decimal_                vrmu_data_class$scalar        vrmu_data_length

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mdbm_error_$invalid_dec_data  mdbm_error_$key_encd_ovfl     mdbm_error_$long_key          mdbm_error_$unsup_type




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 1   20 000144        18 000147        85 000162        87 000164        88 000170        89 000173        90 000176
     96 000200        97 000202        99 000206       100 000217       101 000233       103 000235       104 000237
    105 000250       113 000254       115 000255       118 000256       122 000277       123 000301       124 000305
    125 000310       126 000313       127 000316       128 000326       129 000336       130 000340       132 000341
    134 000354       135 000360       138 000361       140 000365       142 000374       143 000376       144 000400
    146 000401       148 000410       149 000412       150 000414       152 000415       154 000424       155 000426
    156 000430       158 000431       160 000440       161 000442       162 000444       164 000445       166 000461
    167 000463       169 000464       171 000500       172 000502       175 000503       177 000517       178 000521
    180 000522       182 000536       183 000540       185 000541       187 000545       188 000550       189 000553
    191 000554       193 000557       194 000562       196 000563       198 000567       199 000577       201 000600
    203 000603       204 000611       206 000612       213 000613       215 000614       217 000617       219 000620
    221 000624       223 000625       225 000634       227 000635       229 000645       231 000646       252 000647
    254 000650       256 000663       258 000664       260 000677       262 000700       264 000713       266 000714
    268 000727       270 000730       272 000733       273 000734       275 000741       277 000742       287 000744
    288 000747       289 000752       291 000775       293 001001       295 001010       296 001012       297 001013
    299 001014       301 001023       302 001025       303 001026       305 001027       307 001036       308 001040
    309 001041       311 001042       313 001051       314 001053       315 001054       317 001055       319 001071
    320 001073       321 001101       322 001102       324 001103       326 001117       327 001121       328 001127
    329 001130       331 001131       333 001145       334 001147       335 001155       336 001156       338 001157
    340 001173       341 001175       342 001203       343 001204       345 001205       347 001212       348 001217
    349 001225       350 001230       351 001241       352 001244       354 001257       355 001301       356 001307
    357 001315       358 001322       359 001327       360 001333       362 001334       364 001337       365 001340
    366 001344       368 001345       370 001352       371 001357       372 001367       373 001375       374 001376
    376 001377       378 001402       379 001410       380 001416       381 001417       383 001420       391 001427
    393 001432       394 001440       395 001441       397 001442       399 001446       400 001453       401 001455
    402 001457       403 001470       404 001472       406 001473       408 001502       409 001510       410 001511
    412 001512       414 001522       415 001527       416 001531       417 001541       418 001543       419 001546
    420 001550       422 001551       444 001560       446 001561       447 001576       449 001577       451 001600
    452 001615       454 001616       456 001631       457 001637       458 001640       460 001641       462 001654
    463 001662       464 001663       466 001664       652 001677       470 001700       474 001701       475 001707
    476 001721       477 001725       479 001731       482 001732       487 001733       488 001741       489 001753
    490 001757       494 002001       495 002012       497 002015       499 002021       501 002022       502 002023
    503 002031       505 002067       506 002110       507 002115       508 002120       509 002124       512 002135
    513 002145       514 002152       515 002157       517 002160       518 002167       519 002175       521 002221
    522 002242       523 002245       524 002251       525 002254       526 002265       527 002310       528 002315
    529 002325       530 002332       531 002337       532 002355       534 002356       535 002361       536 002371
    537 002400       538 002405       539 002415       540 002422       541 002427       544 002441       570 002442
    571 002443       572 002451       573 002454       575 002460       576 002466       578 002473       579 002477
    580 002506       582 002510       583 002514       585 002517       587 002520       588 002524       590 002531
    591 002535       592 002544       594 002546       595 002552       598 002555       600 002556       601 002557
    602 002565       603 002570       605 002574       606 002602       608 002607       609 002613       610 002617
    611 002632       612 002642       614 002644       615 002650       616 002653       618 002657       619 002662
    620 002665       622 002666       623 002700       626 002705       628 002706       629 002712       631 002717
    632 002723       633 002727       634 002754       635 002764       637 002766       638 002772       639 002775
    641 003001       642 003004       643 003007       645 003010       646 003022       650 003045       654 003046
    660 003050       661 003053


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
