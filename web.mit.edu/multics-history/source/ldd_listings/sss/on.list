	COMPILATION LISTING OF SEGMENT on
	Compiled by: Multics PL/I Compiler, Release 33a, of May 30, 1990
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 07/04/90  1023.3 mdt Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(90-05-23,Gray), approve(90-05-23,MCR8175), audit(90-06-21,Huen),
       17*     install(90-07-04,MR12.4-1019):
       18*     Added cleanup handler to the condition handler to fix case where the
       19*     condition command does a non-local goto.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 
       23 on:
       24      procedure () options (variable);
       25 
       26 /* This command/active function provides the capability to trap  conditions during
       27*   the execution of a command line.  The user may specify a command line to be
       28*   invoked on detection of the condition.
       29*
       30*   Usage:		on conditions action_line {-control_args} subject_line
       31*
       32*   */
       33 
       34 /* Rewritten 24 April 1978 by G. Palter */
       35 /* Modified 12/16/80, W. Olin Sibert, to add -retry_command_line control argument */
       36 /* Modified 83-06-16, T. Oke, to only trim whitespace from the software msg. */
       37 
       38 	dcl     argument		 character (argument_lth) based (argument_ptr);
       39 	dcl     argument_lth	 fixed binary (21);
       40 	dcl     argument_ptr	 pointer;
       41 
       42 	dcl     return_value	 character (return_value_lth) varying based (return_value_ptr);
       43 	dcl     return_value_lth	 fixed binary (21);
       44 	dcl     return_value_ptr	 pointer;
       45 
       46 	dcl     active_function	 bit (1) aligned;
       47 	dcl     get_arg		 entry (fixed binary (21), pointer, fixed binary (21), fixed binary (35)) variable;
       48 	dcl     complain		 entry () options (variable) variable;
       49 
       50 	dcl     code		 fixed binary (35);
       51 
       52 	dcl     argument_count	 fixed binary (21);
       53 
       54 	dcl     (have_condlist, have_action, in_command,
       55 	        restart_sw, retry_sw, call_cl_sw, call_cp_sw, long_sw, brief_sw) bit (1) aligned;
       56 
       57 	dcl     subject		 character (subject_lth) aligned based (subject_ptr);
       58 	dcl     subject_lth		 fixed binary (21);
       59 	dcl     subject_ptr		 pointer;
       60 
       61 	dcl     subject_used	 fixed binary (21);
       62 
       63 	dcl     first_subject	 character (256) aligned;
       64 
       65 	dcl     new_subject		 character (new_subject_lth) aligned based (new_subject_ptr);
       66 	dcl     new_subject_lth	 fixed binary (21);
       67 	dcl     new_subject_ptr	 pointer;
       68 
       69 	dcl     condlist		 character (condlist_lth) based (condlist_ptr);
       70 	dcl     condlist_lth	 fixed binary (21);
       71 	dcl     condlist_ptr	 pointer;
       72 
       73 	dcl     action		 character (action_lth) based (action_ptr);
       74 	dcl     action_lth		 fixed binary (21);
       75 	dcl     action_ptr		 pointer;
       76 
       77 	dcl     exclude		 character (exclude_lth) based (exclude_ptr);
       78 	dcl     exclude_lth		 fixed binary (21);
       79 	dcl     exclude_ptr		 pointer;
       80 
       81 	dcl     system_area		 area based (system_area_ptr);
       82 	dcl     system_area_ptr	 pointer;
       83 
       84 	dcl     (idx, idx2, name_lth)	 fixed binary (21);
       85 
       86 	dcl     invocation_depth	 fixed binary;
       87 
       88 	dcl     WHITESPACE		 character (5) static options (constant) initial ("
       89  	");						/* NL SP HT VT FF */
       90 	dcl     PUNCTUATION		 character (2) static options (constant) initial (" ,");
       91 	dcl     NL		 character (1) static options (constant) initial ("
       92 ");
       93 
       94 	dcl     (error_table_$badopt,
       95 	        error_table_$inconsistent,
       96 	        error_table_$not_act_fnc,
       97 	        error_table_$wrong_no_of_args) fixed binary (35) external;
       98 
       99 	dcl     iox_$user_io	 pointer external;
      100 
      101 	dcl     active_fnc_err_	 entry () options (variable);
      102 	dcl     com_err_		 entry () options (variable);
      103 	dcl     condition_		 entry (character (*), entry);
      104 	dcl     condition_interpreter_ entry (pointer, pointer, fixed binary (21), fixed binary,
      105 				 pointer, character (*), pointer, pointer);
      106 	dcl     cu_$af_arg_ptr	 entry (fixed binary (21), pointer, fixed binary (21), fixed binary (35));
      107 	dcl     cu_$af_return_arg	 entry (fixed binary (21), pointer, fixed binary (21), fixed binary (35));
      108 	dcl     cu_$arg_count	 entry (fixed binary (21));
      109 	dcl     cu_$arg_ptr		 entry (fixed binary (21), pointer, fixed binary (21), fixed binary (35));
      110 	dcl     cu_$cl		 entry () options (variable);
      111 	dcl     cu_$cp		 entry (pointer, fixed binary (21), fixed binary (35));
      112 	dcl     get_system_free_area_	 entry () returns (pointer);
      113 	dcl     ioa_$ioa_switch	 entry () options (variable);
      114 
      115 	dcl     (any_other, cleanup)	 condition;
      116 
      117 	dcl     (addr, empty, index, length, max, null, search, substr, verify) builtin;
      118 
      119 
      120 /* Initialization */
      121 
      122 	call cu_$af_return_arg (argument_count, return_value_ptr, return_value_lth, code);
      123 
      124 	if code = 0
      125 	then do;					/* invoked as an active function */
      126 		active_function = "1"b;
      127 		get_arg = cu_$af_arg_ptr;
      128 		complain = active_fnc_err_;
      129 		return_value = "false";		/* assume nothin raised */
      130 	     end;
      131 
      132 	else if code = error_table_$not_act_fnc
      133 	then do;					/* command */
      134 		active_function = "0"b;
      135 		call cu_$arg_count (argument_count);
      136 		get_arg = cu_$arg_ptr;
      137 		complain = com_err_;
      138 	     end;
      139 
      140 	else do;					/* strange error */
      141 		call com_err_ (code, "on");
      142 		return;
      143 	     end;
      144 
      145 
      146 	have_condlist,				/* seen list of conditions to trap */
      147 	     have_action,				/* seen action to perfom */
      148 	     in_command = "0"b;			/* fetching subject line */
      149 
      150 	subject_ptr = addr (first_subject);		/* use automatic space */
      151 	subject_lth = length (first_subject);
      152 
      153 	first_subject = "";
      154 
      155 	subject_used = 0;				/* empty at the moment */
      156 
      157 	condlist_ptr,
      158 	     action_ptr,
      159 	     exclude_ptr = null ();
      160 
      161 	condlist_lth,
      162 	     action_lth,
      163 	     exclude_lth = 0;			/* list of conditions to exclude */
      164 
      165 
      166 	restart_sw,				/* automatic restart */
      167 	     retry_sw,				/* retry the command line if the condition occurs */
      168 	     call_cl_sw,				/* invoke the listener */
      169 	     call_cp_sw,				/* have some action to perform */
      170 	     long_sw,				/* print long message */
      171 	     brief_sw = "0"b;			/* print no messages */
      172 
      173 
      174 	system_area_ptr = get_system_free_area_ ();
      175 
      176 
      177 	on cleanup
      178 	     begin;
      179 		if subject_ptr ^= addr (first_subject) then
      180 		     free subject in (system_area);	/* free storage */
      181 	     end;
      182 
      183 
      184 /* Process argument list */
      185 
      186 	do idx = 1 to argument_count;
      187 
      188 	     call get_arg (idx, argument_ptr, argument_lth, code);
      189 	     if code ^= 0 then do;
      190 		     call complain (code, "on", "Fetching argument #^d", idx);
      191 		     go to RETURN;
      192 		end;
      193 
      194 
      195 	     if in_command
      196 	     then do;				/* in subject command line */
      197 CLARG:
      198 		     if subject_used + argument_lth + 1 > subject_lth
      199 		     then do;			/* must allocate more room for command line */
      200 			     new_subject_lth = max ((2 * subject_lth), (subject_lth + argument_lth));
      201 			     allocate new_subject in (system_area) set (new_subject_ptr);
      202 			     new_subject = subject;
      203 			     if subject_ptr ^= addr (first_subject) then
      204 				free subject in (system_area); /* free old copy */
      205 			     subject_ptr = new_subject_ptr;
      206 			     subject_lth = new_subject_lth;
      207 			end;
      208 		     substr (subject, (subject_used + 1), argument_lth) = argument;
      209 		     subject_used = subject_used + argument_lth + 1;
      210 		end;
      211 
      212 
      213 	     else do;				/* process options, conditions, etc */
      214 
      215 		     if substr (argument, 1, 1) = "-"
      216 		     then do;			/* an option */
      217 			     if (argument = "-restart") | (argument = "-rt")
      218 			     then if retry_sw
      219 				then do;
      220 					call complain (error_table_$inconsistent, "on", """-restart"" and ""-retry_command_line"".");
      221 					goto RETURN;
      222 				     end;
      223 				else restart_sw = "1"b;
      224 
      225 			     else if argument = "-cl"
      226 			     then if active_function
      227 				then do;		/* -cl not allowed for active function */
      228 					call complain (error_table_$badopt, "on", "Active function may not use ""-cl"".");
      229 					go to RETURN;
      230 				     end;
      231 				else call_cl_sw = "1"b;
      232 
      233 			     else if (argument = "-exclude") | (argument = "-ex")
      234 			     then do;
      235 				     idx = idx + 1; /* -exclude takes a list of conditions */
      236 				     call get_arg (idx, argument_ptr, argument_lth, code);
      237 				     if code ^= 0 then do;
      238 					     call complain (code, "on", "Condition list for ""-exclude"".");
      239 					     go to RETURN;
      240 					end;
      241 				     if exclude_ptr ^= null () then do;
      242 					     call complain (error_table_$wrong_no_of_args, "on", """-exclude"" may only be used once.");
      243 					     go to RETURN;
      244 					end;
      245 				     exclude_ptr = argument_ptr;
      246 				     exclude_lth = argument_lth;
      247 				end;
      248 
      249 			     else if (argument = "-long") | (argument = "-lg")
      250 			     then if brief_sw
      251 				then do;		/* -brief and -long */
      252 					call complain (error_table_$inconsistent, "on", """-long"" and ""-brief"".");
      253 					go to RETURN;
      254 				     end;
      255 				else long_sw = "1"b;
      256 
      257 			     else if (argument = "-brief") | (argument = "-bf")
      258 			     then if long_sw
      259 				then do;		/* -brief and -long */
      260 					call complain (error_table_$inconsistent, "on", """-long"" and ""-brief"".");
      261 					go to RETURN;
      262 				     end;
      263 				else brief_sw = "1"b;
      264 
      265 			     else if (argument = "-retry_command_line") | (argument = "-rcl")
      266 			     then if restart_sw
      267 				then do;
      268 					call complain (error_table_$inconsistent, "on", """-restart"" and ""-retry_command_line"".");
      269 					goto RETURN;
      270 				     end;
      271 				else retry_sw = "1"b;
      272 
      273 			     else do;
      274 				     call complain (error_table_$badopt, "on", """^a"".", argument);
      275 				     go to RETURN;
      276 				end;
      277 			end;
      278 
      279 
      280 		     else do;			/* condition list, action, or start of subject */
      281 			     if ^have_condlist
      282 			     then do;
      283 				     have_condlist = "1"b;
      284 				     condlist_ptr = argument_ptr;
      285 				     condlist_lth = argument_lth;
      286 				end;
      287 
      288 			     else if ^have_action
      289 			     then do;
      290 				     have_action = "1"b;
      291 				     action_ptr = argument_ptr;
      292 				     action_lth = argument_lth;
      293 				end;
      294 
      295 			     else do;
      296 				     in_command = "1"b;
      297 				     go to CLARG;
      298 				end;
      299 			end;
      300 		end;
      301 	end;
      302 
      303 
      304 	if subject_used = 0 then do;
      305 		call complain (0, "on", "Usage:  on conditions action {-control_args} subject");
      306 		go to RETURN;
      307 	     end;
      308 
      309 	subject_used = subject_used - 1;		/* elimintate trailing space */
      310 
      311 	if action_lth ^= 0
      312 	then if verify (action, WHITESPACE) ^= 0
      313 	     then call_cp_sw = "1"b;			/* actually something to do */
      314 
      315 
      316 /* Set up handlers and invoke the subject line */
      317 
      318 	idx = 1;
      319 
      320 	do while (substr (condlist, idx) ^= "");	/* while something left */
      321 	     name_lth = search (substr (condlist, idx), PUNCTUATION) - 1;
      322 	     if name_lth < 0 then name_lth = length (condlist) - idx + 1; /* rest of list */
      323 
      324 	     call condition_ ((substr (condlist, idx, name_lth)), handler);
      325 
      326 	     idx = idx + name_lth;
      327 	     idx2 = verify (substr (condlist, idx), PUNCTUATION) - 1;
      328 	     if idx2 > 0 then idx = idx + idx2;
      329 	end;
      330 
      331 
      332 RETRY_COMMAND:
      333 	invocation_depth = 0;			/* nothing raised yet */
      334 
      335 	call cu_$cp (addr (subject), subject_used, (0));
      336 
      337 
      338 RETURN:
      339 	if subject_ptr ^= addr (first_subject) then
      340 	     free subject in (system_area);
      341 
      342 	return;
      343 
      344 
      345 handler:
      346      procedure (mc_ptr, condition_name, wc_ptr, info_ptr, continue_sw);
      347 
      348 /* This internal procedure is invoked to handle any of the conditions being
      349*   trapped.  It process all control arguments.
      350*   */
      351 
      352 	dcl     mc_ptr		 pointer;		/* machine conditions */
      353 	dcl     condition_name	 character (*);	/* the conditions raised */
      354 	dcl     wc_ptr		 pointer;		/* wall crossing */
      355 	dcl     info_ptr		 pointer;		/* software information */
      356 	dcl     continue_sw		 bit (1);		/* ON if the condition should continue up */
      357 
  1     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  1     2 /* format: style2 */
  1     3 
  1     4      declare condition_info_header_ptr
  1     5 			      pointer;
  1     6      declare 1 condition_info_header
  1     7 			      aligned based (condition_info_header_ptr),
  1     8 	     2 length	      fixed bin,		/* length in words of this structure */
  1     9 	     2 version	      fixed bin,		/* version number of this structure */
  1    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  1    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  1    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  1    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  1    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  1    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  1    16 	       3 pad	      bit (32) unaligned,
  1    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  1    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  1    19 
  1    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      358 
      359 
      360 	dcl     1 software_data	 aligned like condition_info_header based (info_ptr);
      361 
      362 	dcl     small_area		 area;
      363 	dcl     (idx, idx2, idx3)	 fixed binary (21);
      364 	dcl     name_lth		 fixed binary (21);
      365 
      366 	dcl     error_msg		 character (error_msg_lth) based (error_msg_ptr);
      367 	dcl     error_msg_lth	 fixed binary (21);
      368 	dcl     error_msg_ptr	 pointer;
      369 
      370 	dcl     old_invocation_depth	fixed binary;
      371 
      372 	dcl     software_msg	 character (256) varying;
      373 
      374 	dcl     length		 builtin;
      375 
      376 
      377 /* Scan exclude list to see if we should ignore this condition */
      378 
      379 	if exclude_lth ^= 0 then do;
      380 		idx = 1;
      381 
      382 		do while (substr (exclude, idx) ^= "");
      383 		     name_lth = search (substr (exclude, idx), PUNCTUATION) - 1;
      384 		     if name_lth < 0 then name_lth = length (exclude) - idx + 1; /* rest of list */
      385 
      386 		     if condition_name = substr (exclude, idx, name_lth) then do;
      387 			     continue_sw = "1"b;	/* give it to superiors */
      388 			     return;
      389 			end;
      390 
      391 		     idx = idx + name_lth;
      392 		     idx2 = verify (substr (exclude, idx), PUNCTUATION) - 1;
      393 		     if idx2 > 0 then idx = idx + idx2;
      394 		end;
      395 	     end;
      396 
      397 
      398 /* Print a message if requested */
      399 
      400 	if ^brief_sw then do;
      401 		software_msg = "";
      402 
      403 		if info_ptr ^= null then
      404 		     if software_data.version >= 1 then
      405 			if length (software_data.info_string) > 0 then do;
      406 				software_msg = software_data.info_string;
      407 				if verify (substr (software_msg, length (software_msg), 1), WHITESPACE) = 0 then
      408 				     software_msg = substr (software_msg, 1, length (software_msg) - 1);
      409 			     end;
      410 
      411 		call ioa_$ioa_switch (iox_$user_io, "on:  Condition ""^a"" raised.  ^a",
      412 		     condition_name, software_msg);
      413 	     end;
      414 
      415 
      416 /* Check for recursive signalling */
      417 
      418 	old_invocation_depth = invocation_depth;
      419 on	cleanup invocation_depth = old_invocation_depth;
      420 	invocation_depth = invocation_depth + 1;
      421 
      422 	if invocation_depth > 2 then go to RETURN;	/* bad loop */
      423 	else if invocation_depth > 1 then do;
      424 		call ioa_$ioa_switch (iox_$user_io, "on:  Recursive signalling of ""^a"".", condition_name);
      425 		go to RETURN;
      426 	     end;
      427 
      428 
      429 /* If an active function, indicate a condition was trapped */
      430 
      431 	if active_function then
      432 	     return_value = "true";
      433 
      434 
      435 /* Print detailed information if requested */
      436 
      437 	if long_sw then do;
      438 		call condition_interpreter_ (addr (small_area), error_msg_ptr, error_msg_lth,
      439 		     3, mc_ptr, condition_name, wc_ptr, info_ptr);
      440 
      441 		idx = 1;
      442 		idx2 = index (error_msg, "Error");	/* trim the message somewhat */
      443 		if (idx2 > 0) & (idx2 < 4) then
      444 		     idx = idx2 + 6;
      445 
      446 		idx2 = verify (substr (error_msg, idx), " ");
      447 		if idx2 > 0 then
      448 		     idx = idx + idx2 - 1;
      449 
      450 		idx2 = idx;
      451 		do idx3 = idx to error_msg_lth;
      452 		     if substr (error_msg, idx3, 1) = NL then do;
      453 			     call ioa_$ioa_switch (iox_$user_io, "^a", substr (error_msg, idx2, idx3 - idx2));
      454 			     idx2 = idx3 + 1;
      455 			end;
      456 		end;
      457 	     end;					/* no need to free it as the area is in automatic */
      458 
      459 
      460 /* Invoke the action command line, call the listener, and restart */
      461 
      462 	if call_cp_sw then
      463 	     call cu_$cp (action_ptr, action_lth, (0));
      464 
      465 	invocation_depth = old_invocation_depth;
      466 
      467 	if call_cl_sw then do;
      468 		on any_other system;
      469 		call cu_$cl ((36)"0"b);
      470 		revert any_other;
      471 	     end;
      472 
      473 	if restart_sw then
      474 	     if info_ptr = null () then
      475 		return;				/* can probably restart */
      476 	     else if software_data.cant_restart then
      477 		call ioa_$ioa_switch (iox_$user_io, "on:  Can not restart ""^a"".", condition_name);
      478 	     else return;
      479 
      480 	if retry_sw then /* Try the command line again */
      481 	     goto RETRY_COMMAND;
      482 
      483 	go to RETURN;				/* abort */
      484 
      485      end handler;
      486 
      487      end on;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/04/90  1023.3  on.pl1                            >spec>install>1019>on.pl1
358          1    03/24/82  1447.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NL                              003160 constant        char(1)                  initial packed unaligned dcl 91 ref 452
PUNCTUATION                            constant        char(2)                  initial packed unaligned dcl 90 ref 321 327 383 392
WHITESPACE                      000000 constant        char(5)                  initial packed unaligned dcl 88 ref 311 407
action                                 based           char                     packed unaligned dcl 73 ref 311
action_flags              2            based           structure                level 2 dcl 360
action_lth                      000250 automatic       fixed bin(21,0)          dcl 74 set ref 161* 292* 311 311 462*
action_ptr                      000252 automatic       pointer                  dcl 75 set ref 157* 291* 311 462*
active_fnc_err_                 000022 constant        entry                    external dcl 101 ref 128
active_function                 000110 automatic       bit(1)                   dcl 46 set ref 126* 134* 225 431
addr                                                   builtin function         dcl 117 ref 150 179 203 335 335 338 438 438
any_other                       000000 stack reference condition                dcl 115 ref 468 470
argument                               based           char                     packed unaligned dcl 38 set ref 208 215 217 217 225
                                                                                  233 233 249 249 257 257 265 265 274*
argument_count                  000123 automatic       fixed bin(21,0)          dcl 52 set ref 122* 135* 186
argument_lth                    000100 automatic       fixed bin(21,0)          dcl 39 set ref 188* 197 200 208 208 209 215 217 217
                                                                                  225 233 233 236* 246 249 249 257 257 265 265 274
                                                                                  274 285 292
argument_ptr                    000102 automatic       pointer                  dcl 40 set ref 188* 208 215 217 217 225 233 233 236*
                                                                                  245 249 249 257 257 265 265 274 284 291
brief_sw                        000134 automatic       bit(1)                   dcl 54 set ref 166* 249 263* 400
call_cl_sw                      000131 automatic       bit(1)                   dcl 54 set ref 166* 231* 467
call_cp_sw                      000132 automatic       bit(1)                   dcl 54 set ref 166* 311* 462
cant_restart              2            based           bit(1)                   level 3 packed packed unaligned dcl 360 ref 476
cleanup                         000266 stack reference condition                dcl 115 ref 177 419
code                            000122 automatic       fixed bin(35,0)          dcl 50 set ref 122* 124 132 141* 188* 189 190* 236*
                                                                                  237 238*
com_err_                        000024 constant        entry                    external dcl 102 ref 137 141
complain                        000116 automatic       entry variable           dcl 48 set ref 128* 137* 190 220 228 238 242 252 260
                                                                                  268 274 305
condition_                      000026 constant        entry                    external dcl 103 ref 324
condition_info_header                  based           structure                level 1 dcl 1-6
condition_interpreter_          000030 constant        entry                    external dcl 104 ref 438
condition_name                         parameter       char                     packed unaligned dcl 353 set ref 345 386 411* 424*
                                                                                  438* 476*
condlist                               based           char                     packed unaligned dcl 69 ref 320 321 322 324 327
condlist_lth                    000244 automatic       fixed bin(21,0)          dcl 70 set ref 161* 285* 320 321 322 324 327
condlist_ptr                    000246 automatic       pointer                  dcl 71 set ref 157* 284* 320 321 322 324 327
continue_sw                            parameter       bit(1)                   packed unaligned dcl 356 set ref 345 387*
cu_$af_arg_ptr                  000032 constant        entry                    external dcl 106 ref 127
cu_$af_return_arg               000034 constant        entry                    external dcl 107 ref 122
cu_$arg_count                   000036 constant        entry                    external dcl 108 ref 135
cu_$arg_ptr                     000040 constant        entry                    external dcl 109 ref 136
cu_$cl                          000042 constant        entry                    external dcl 110 ref 469
cu_$cp                          000044 constant        entry                    external dcl 111 ref 335 462
empty                                                  builtin function         dcl 117 ref 362
error_msg                              based           char                     packed unaligned dcl 366 ref 442 446 452 453 453
error_msg_lth                   002104 automatic       fixed bin(21,0)          dcl 367 set ref 438* 442 446 451 452 453 453
error_msg_ptr                   002106 automatic       pointer                  dcl 368 set ref 438* 442 446 452 453 453
error_table_$badopt             000010 external static fixed bin(35,0)          dcl 94 set ref 228* 274*
error_table_$inconsistent       000012 external static fixed bin(35,0)          dcl 94 set ref 220* 252* 260* 268*
error_table_$not_act_fnc        000014 external static fixed bin(35,0)          dcl 94 ref 132
error_table_$wrong_no_of_args   000016 external static fixed bin(35,0)          dcl 94 set ref 242*
exclude                                based           char                     packed unaligned dcl 77 ref 382 383 384 386 392
exclude_lth                     000254 automatic       fixed bin(21,0)          dcl 78 set ref 161* 246* 379 382 383 384 386 392
exclude_ptr                     000256 automatic       pointer                  dcl 79 set ref 157* 241 245* 382 383 384 386 392
first_subject                   000141 automatic       char(256)                dcl 63 set ref 150 151 153* 179 203 338
get_arg                         000112 automatic       entry variable           dcl 47 set ref 127* 136* 188 236
get_system_free_area_           000046 constant        entry                    external dcl 112 ref 174
have_action                     000125 automatic       bit(1)                   dcl 54 set ref 146* 288 290*
have_condlist                   000124 automatic       bit(1)                   dcl 54 set ref 146* 281 283*
idx                             000262 automatic       fixed bin(21,0)          dcl 84 in procedure "on" set ref 186* 188* 190* 235*
                                                                                  235 236* 318* 320 321 322 324 326* 326 327 328*
                                                                                  328
idx                             002100 automatic       fixed bin(21,0)          dcl 363 in procedure "handler" set ref 380* 382 383
                                                                                  384 386 391* 391 392 393* 393 441* 443* 446 447*
                                                                                  447 450 451
idx2                            000263 automatic       fixed bin(21,0)          dcl 84 in procedure "on" set ref 327* 328 328
idx2                            002101 automatic       fixed bin(21,0)          dcl 363 in procedure "handler" set ref 392* 393 393
                                                                                  442* 443 443 443 446* 447 447 450* 453 453 453 453
                                                                                  454*
idx3                            002102 automatic       fixed bin(21,0)          dcl 363 set ref 451* 452 453 453 454*
in_command                      000126 automatic       bit(1)                   dcl 54 set ref 146* 195 296*
index                                                  builtin function         dcl 117 ref 442
info_ptr                               parameter       pointer                  dcl 355 set ref 345 403 403 403 406 438* 473 476
info_string               3            based           varying char(256)        level 2 dcl 360 ref 403 406
invocation_depth                000265 automatic       fixed bin(17,0)          dcl 86 set ref 332* 418 419* 420* 420 422 423 465*
ioa_$ioa_switch                 000050 constant        entry                    external dcl 113 ref 411 424 453 476
iox_$user_io                    000020 external static pointer                  dcl 99 set ref 411* 424* 453* 476*
length                                                 builtin function         dcl 117 in procedure "on" ref 151 322
length                                                 builtin function         dcl 374 in procedure "handler" ref 384 403 407 407
long_sw                         000133 automatic       bit(1)                   dcl 54 set ref 166* 255* 257 437
max                                                    builtin function         dcl 117 ref 200
mc_ptr                                 parameter       pointer                  dcl 352 set ref 345 438*
name_lth                        002103 automatic       fixed bin(21,0)          dcl 364 in procedure "handler" set ref 383* 384 384*
                                                                                  386 391
name_lth                        000264 automatic       fixed bin(21,0)          dcl 84 in procedure "on" set ref 321* 322 322* 324
                                                                                  326
new_subject                            based           char                     dcl 65 set ref 201 202*
new_subject_lth                 000241 automatic       fixed bin(21,0)          dcl 66 set ref 200* 201 201 202 206
new_subject_ptr                 000242 automatic       pointer                  dcl 67 set ref 201* 202 205
null                                                   builtin function         dcl 117 ref 157 241 403 473
old_invocation_depth            002110 automatic       fixed bin(17,0)          dcl 370 set ref 418* 419 465
restart_sw                      000127 automatic       bit(1)                   dcl 54 set ref 166* 223* 265 473
retry_sw                        000130 automatic       bit(1)                   dcl 54 set ref 166* 217 271* 480
return_value                           based           varying char             dcl 42 set ref 129* 431*
return_value_lth                000104 automatic       fixed bin(21,0)          dcl 43 set ref 122* 129 431
return_value_ptr                000106 automatic       pointer                  dcl 44 set ref 122* 129 431
search                                                 builtin function         dcl 117 ref 321 383
small_area                      000100 automatic       area(1024)               dcl 362 set ref 362* 438 438
software_data                          based           structure                level 1 dcl 360
software_msg                    002111 automatic       varying char(256)        dcl 372 set ref 401* 406* 407 407 407* 407 407 411*
subject                                based           char                     dcl 57 set ref 179 202 203 208* 335 335 338
subject_lth                     000135 automatic       fixed bin(21,0)          dcl 58 set ref 151* 179 179 197 200 200 202 203 203
                                                                                  206* 208 335 335 338 338
subject_ptr                     000136 automatic       pointer                  dcl 59 set ref 150* 179 179 202 203 203 205* 208 335
                                                                                  335 338 338
subject_used                    000140 automatic       fixed bin(21,0)          dcl 61 set ref 155* 197 208 209* 209 304 309* 309
                                                                                  335*
substr                                                 builtin function         dcl 117 set ref 208* 215 320 321 324 327 382 383 386
                                                                                  392 407 407 446 452 453 453
system_area                            based           area(1024)               dcl 81 ref 179 201 203 338
system_area_ptr                 000260 automatic       pointer                  dcl 82 set ref 174* 179 201 203 338
verify                                                 builtin function         dcl 117 ref 311 327 392 407 446
version                   1            based           fixed bin(17,0)          level 2 dcl 360 ref 403
wc_ptr                                 parameter       pointer                  dcl 354 set ref 345 438*

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
condition_info_header_ptr              automatic       pointer                  dcl 1-4

NAMES DECLARED BY EXPLICIT CONTEXT.
CLARG                           000506 constant        label                    dcl 197 ref 297
RETRY_COMMAND                   001451 constant        label                    dcl 332 ref 480
RETURN                          001470 constant        label                    dcl 338 ref 191 221 229 239 243 253 261 269 275 306
                                                                                  422 425 483
handler                         001505 constant        entry                    internal dcl 345 ref 324 324
on                              000220 constant        entry                    external dcl 23

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3416        3470    3162        3426
Length      3710    3162        52         203     234           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
on                                  254 external procedure  is an external procedure.  
on unit on line 177                  66 on unit               
handler                            1255 internal procedure  is assigned to an entry variable, and enables or reverts conditions.  
on unit on line 419                  64 on unit               
on unit on line 468                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
handler                  000100 small_area                  handler
                         002100 idx                         handler
                         002101 idx2                        handler
                         002102 idx3                        handler
                         002103 name_lth                    handler
                         002104 error_msg_lth               handler
                         002106 error_msg_ptr               handler
                         002110 old_invocation_depth        handler
                         002111 software_msg                handler
on                       000100 argument_lth                on
                         000102 argument_ptr                on
                         000104 return_value_lth            on
                         000106 return_value_ptr            on
                         000110 active_function             on
                         000112 get_arg                     on
                         000116 complain                    on
                         000122 code                        on
                         000123 argument_count              on
                         000124 have_condlist               on
                         000125 have_action                 on
                         000126 in_command                  on
                         000127 restart_sw                  on
                         000130 retry_sw                    on
                         000131 call_cl_sw                  on
                         000132 call_cp_sw                  on
                         000133 long_sw                     on
                         000134 brief_sw                    on
                         000135 subject_lth                 on
                         000136 subject_ptr                 on
                         000140 subject_used                on
                         000141 first_subject               on
                         000241 new_subject_lth             on
                         000242 new_subject_ptr             on
                         000244 condlist_lth                on
                         000246 condlist_ptr                on
                         000250 action_lth                  on
                         000252 action_ptr                  on
                         000254 exclude_lth                 on
                         000256 exclude_ptr                 on
                         000260 system_area_ptr             on
                         000262 idx                         on
                         000263 idx2                        on
                         000264 name_lth                    on
                         000265 invocation_depth            on

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ent_var_desc   call_ent_var        call_ext_out_desc   call_ext_out        return_mac
tra_ext_1           enable_op           shorten_stack       ext_entry           int_entry           int_entry_desc
set_chars_eis       index_chars_eis     op_alloc_           op_freen_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               com_err_                      condition_                    condition_interpreter_
cu_$af_arg_ptr                cu_$af_return_arg             cu_$arg_count                 cu_$arg_ptr
cu_$cl                        cu_$cp                        get_system_free_area_         ioa_$ioa_switch

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$inconsistent     error_table_$not_act_fnc      error_table_$wrong_no_of_args
iox_$user_io




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     23 000217       122 000225       124 000241       126 000243       127 000245       128 000252       129 000255
    130 000266       132 000267       134 000272       135 000273       136 000301       137 000306       138 000311
    141 000312       142 000330       146 000331       150 000334       151 000336       153 000340       155 000343
    157 000344       161 000350       166 000353       174 000361       177 000367       179 000403       181 000420
    186 000421       188 000431       189 000445       190 000447       191 000503       195 000504       197 000506
    200 000513       201 000524       202 000533       203 000541       205 000554       206 000556       208 000560
    209 000567       210 000572       215 000573       217 000600       220 000613       221 000641       223 000642
    225 000645       228 000653       229 000701       231 000702       233 000705       235 000715       236 000716
    237 000732       238 000734       239 000761       241 000762       242 000766       243 001014       245 001015
    246 001017       247 001021       249 001022       252 001034       253 001065       255 001066       257 001071
    260 001103       261 001134       263 001135       265 001140       268 001152       269 001200       271 001201
    274 001204       275 001237       277 001240       281 001241       283 001243       284 001245       285 001246
    286 001250       288 001251       290 001253       291 001255       292 001256       293 001260       296 001261
    297 001263       301 001264       304 001266       305 001270       306 001316       309 001317       311 001321
    318 001340       320 001342       321 001356       322 001367       324 001374       326 001423       327 001426
    328 001446       329 001450       332 001451       335 001452       338 001470       342 001503       345 001504
    362 001520       379 001523       380 001526       382 001530       383 001545       384 001556       386 001563
    387 001576       388 001602       391 001603       392 001605       393 001625       394 001627       400 001630
    401 001632       403 001633       406 001647       407 001654       411 001673       418 001724       419 001727
    420 001750       422 001752       423 001760       424 001764       425 002012       431 002015       437 002030
    438 002032       441 002101       442 002103       443 002112       446 002117       447 002140       450 002144
    451 002146       452 002155       453 002162       454 002216       456 002222       462 002224       465 002243
    467 002246       468 002250       469 002265       470 002300       473 002301       476 002311       478 002344
    480 002345       483 002353


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
