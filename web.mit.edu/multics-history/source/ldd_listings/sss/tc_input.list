	COMPILATION LISTING OF SEGMENT tc_input
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/07/88  1413.0 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-07-08,Coren), approve(86-07-08,MCR7300),
       12*     audit(86-07-08,Beattie), install(86-07-08,MR12.0-1089):
       13*     Changed to use v1_echo_neg_data for compatibility.
       14*  2) change(86-07-15,LJAdams), approve(86-11-11,MCR7485),
       15*     audit(86-12-16,Margolin), install(87-01-06,MR12.0-1255):
       16*     Modified to support MOWSE.
       17*  3) change(86-11-26,LJAdams), approve(86-11-26,MCR7584),
       18*     audit(86-12-16,Margolin), install(87-01-06,MR12.0-1255):
       19*     Initial DSA coding has been maintained in a non-executable form.
       20*  4) change(87-02-10,LJAdams), approve(87-03-19,MCR7642),
       21*     audit(87-04-24,Gilcrease), install(87-05-14,MR12.1-1030):
       22*     Passing a (-1) parameter to ws_tty_$read_echoed on the initial read.
       23*  5) change(87-02-12,RBarstad), approve(87-03-19,MCR7642),
       24*     audit(87-04-24,Gilcrease), install(87-05-14,MR12.1-1030):
       25*     Don't try to reset the break table if operation is OP_READ_ONE.
       26*     The break table is not needed on read one char and it was never
       27*     init'ed in the request_read structure by window_ anyway.
       28*  6) change(87-02-17,RBarstad), approve(87-03-19,MCR7642),
       29*     audit(87-04-24,Gilcrease), install(87-05-14,MR12.1-1030):
       30*     Added block bit to read_with_mark call.
       31*  7) change(87-06-02,RBarstad), approve(87-02-17,MCR7485),
       32*     audit(87-06-30,Gilcrease), install(87-08-04,MR12.1-1055):
       33*     In ...$read_and_buffer changed the (-1) back to "dummy" and added the
       34*     "screen_left" variable for readability.
       35*  8) change(87-06-15,LJAdams), approve(87-06-15,MCR7584),
       36*     audit(87-06-30,Gilcrease), install(87-08-04,MR12.1-1055):
       37*     When calling dsa_tty_$read_echoed set return code to 0 to prevent
       38*     blockage of interactive messages.
       39*  9) change(88-09-27,LJAdams), approve(88-09-27,MCR8001),
       40*     audit(88-10-06,Farley), install(88-10-07,MR12.2-1148):
       41*     There was a problem with the bounds of the data and/or control buffers
       42*     being pointed to by the input buffer being exceeded; to correct this a
       43*     check has been implemented in add_1_to_buffer, and common to ensure
       44*     that the current buffer length as kept track of in the input_buffer
       45*     structure plus the characters to be added will not exceed bounds of
       46*     the existing data/control buffer arrays. If the check fails the
       47*     push_buffer routine is called to push the data down by eliminating
       48*     those characters marked for deletion.  If this fails the size of
       49*     the data_buffer and the control_buffer is increased by calling the
       50*     grow_buffer routine.
       51*                                                   END HISTORY COMMENTS */
       52 
       53 /* Terminal Control
       54*   Input Processing -- low level
       55*   Initial implementation -- May 1981
       56*
       57*   This program accesses hcs_$tty_* directly. This programmed is destined
       58*   to stay in Terminal Control when it is divested from the video system.
       59*
       60*   Design and Initial Coding by Benson I. Margulies,
       61*   inspiration by JRD, BSG, the cow's stomach,
       62*   and lots of help from MND.
       63*
       64**/
       65 /* Modified April 82 by William York to call the new tty_read_echoed
       66*   entrypoint, the replacement for echo_negotiate_get_chars. */
       67 /* Modified 23 June 82 by WMY to fix a bug in try_to_satisfy which
       68*   caused spurious double echoing of asynchronous output that interrupted
       69*   get_echoed_chars calls. */
       70 /* Modified 19 August 1982 by WMY to go blocked waiting for FNP interrupt
       71*   when we get the echnego_awaiting_stop_sync code back from
       72*   tty_read_echoed while closing out echo negotiation.  This FINALLY
       73*   fixes the "looping while reading input" bug. */
       74 /* Modified 24 August 1982 to fix a bug in the above fix.  The close_out_echnego
       75*   routine now calls ipc_$block directly instead of tc_block, since it
       76*   doesn't want to deal with request structures from the caller. */
       77 /* Modified 10 September 1982 by WMY to fix a bug in the fix to the above
       78*   fix.  It now calls tc_block$internal to make sure that protocol wakeups
       79*   happen. */
       80 /* Modified 20 September 1982 by WMY.  Oh well, one more time.  Changed the
       81*   check_echnego entry to take a request_ptr as a parameter, and call regular
       82*   tc_block with that request_ptr.  We ALWAYS have to block on the behalf of
       83*   some particular window for async stuff to work right. */
       84 /* Modified 22 September 1982 by WMY to remove the code that attempts to
       85*   sync to the output already written if the input buffer length is 0.  This
       86*   code went blocked until the user typed something, waiting for ring 0 to
       87*   return the mark.  This was useless, and until ring 0 can be changed to
       88*   return the mark without actually waiting for new input, tc_input will just
       89*   return if the input buffer size is 0. */
       90 /* Modified 14 August 1984 by Jon A. Rochlis to remove the Code parameter from
       91*   the init entry, since it is never used. It appears never to be used by the
       92*   tc_input entry either, and I am real tempted to remove it altogether. */
       93 /* Modified 7 February 1985 by JR to use RESTORE_MASK instead of
       94*   UNMASK_ALL when calling tc_block.  This will restore the user's mask
       95*   instead of arbitrarly unmasking everything. */
       96 /* Modified June 1985 by Roger Negaret to support DSA networks. */
       97 
       98 /* format: style2,linecom,^indnoniterdo,indcomtxt,^inditerdo,dclind5,idind25 */
       99 tc_input:
      100      procedure (TC_data_ptr, Request_ptr, Code);
      101 	go to do_input;				/* skip over all these dcls */
      102 
      103 
      104 /* Parameters */
      105 
      106 	declare (
      107 	        Request_ptr		   pointer,
      108 	        TC_data_ptr		   pointer,
      109 	        Code		   fixed bin (35)
      110 	        )			   parameter;
      111 
      112 
      113 
  1     1 /*	BEGIN INCLUDE FILE ... net_event_message.incl.pl1 */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(86-07-30,Kissel), approve(86-07-30,MCR7475), audit(86-08-04,Coren),
  1     5*     install(86-10-09,MR12.0-1181):
  1     6*     This include file was formerly tty_event_message.incl.pl1.  It has been
  1     7*     updated with different fields and new constants, and renamed to
  1     8*     net_event_message.incl.pl1
  1     9*  2) change(87-04-20,GDixon), approve(87-07-13,MCR7694),
  1    10*     audit(87-06-24,Hartogs), install(87-08-04,MR12.1-1056):
  1    11*     Add NETWORK_TYPE_VALUES array.
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14 /*	describes event message passed with wakeups from the tty DIM */
  1    15 /*	Created 5/24/76 by Robert S. Coren */
  1    16 
  1    17 /* format: style3,linecom,ifthenstmt,indthenelse,^indnoniterdo,indnoniterend,initcol3,dclind5,idind32 */
  1    18 
  1    19 dcl  net_event_message_arg	       fixed bin (71);	/* For calling IPC */
  1    20 dcl  NET_EVENT_MESSAGE_VERSION_1     bit (2) internal static options (constant) init ("10"b);
  1    21 
  1    22 dcl  1 net_event_message	       aligned based (addr (net_event_message_arg)),
  1    23        2 version		       bit (2) unaligned,	/* Currently version 1 */
  1    24        2 reason		       bit (16) unaligned,	/* Additional info about the event */
  1    25        2 pad		       bit (6) unaligned,	/* Must be zero */
  1    26        2 network_type	       fixed bin (4) unsigned unaligned,
  1    27 						/* See below for constants */
  1    28        2 type		       fixed bin (8) unsigned unaligned,
  1    29 						/* Type of interrupt, see below */
  1    30        2 handle		       fixed bin (35) aligned;/* Caller's handle (devx for MCS, handle for DSA) */
  1    31 
  1    32 /* Network type constants */
  1    33 
  1    34 dcl  MCS_NETWORK_TYPE	       fixed bin (4) unsigned internal static options (constant) init (0);
  1    35 dcl  DSA_NETWORK_TYPE	       fixed bin (4) unsigned internal static options (constant) init (1);
  1    36 dcl  MOWSE_NETWORK_TYPE	       fixed bin (4) unsigned internal static options (constant) init (2);
  1    37 
  1    38 dcl  NETWORK_TYPE_VALUES (0:2) char(8) varying int static options(constant) init(
  1    39 	"MCS",
  1    40 	"DSA",
  1    41 	"MOWSE");
  1    42 
  1    43 
  1    44 /* MCS event message type constants */
  1    45 
  1    46 dcl  MAX_MCS_EVENT_MSG_TYPE	       fixed bin internal static options (constant) init (8);
  1    47 
  1    48 dcl  MCS_UNSPECIFIED_MSG	       fixed bin internal static options (constant) init (0);
  1    49 						/* used for "start" order, etc. */
  1    50 dcl  MCS_DIALUP_MSG		       fixed bin internal static options (constant) init (1);
  1    51 						/* dialup */
  1    52 dcl  MCS_HANGUP_MSG		       fixed bin internal static options (constant) init (2);
  1    53 						/* hangup */
  1    54 dcl  MCS_DIALOUT_MSG	       fixed bin internal static options (constant) init (3);
  1    55 						/* dialout status returned */
  1    56 dcl  MCS_QUIT_MSG		       fixed bin internal static options (constant) init (4);
  1    57 						/* quit */
  1    58 dcl  MCS_READ_MSG		       fixed bin internal static options (constant) init (5);
  1    59 						/* input arrived */
  1    60 dcl  MCS_WRITE_MSG		       fixed bin internal static options (constant) init (6);
  1    61 						/* output completed */
  1    62 dcl  MCS_LINE_STATUS_MSG	       fixed bin internal static options (constant) init (7);
  1    63 						/* control tables sent status */
  1    64 dcl  MCS_MASKED_MSG		       fixed bin internal static options (constant) init (8);
  1    65 						/* channel masked by FNP */
  1    66 
  1    67 dcl  MCS_MSG_TYPE_TO_PNAME	       (0:8) char (20) internal static options (constant) init ("unspecified",
  1    68 						/*  0 */
  1    69 			       "dialup",		/*  1 */
  1    70 			       "hangup",		/*  2 */
  1    71 			       "dialout status",	/*  3 */
  1    72 			       "quit",		/*  4 */
  1    73 			       "read",		/*  5 */
  1    74 			       "write",		/*  6 */
  1    75 			       "line status",	/*  7 */
  1    76 			       "masked");		/*  8 */
  1    77 
  1    78 /* DSA event message type constants */
  1    79 
  1    80 dcl  MAX_DSA_EVENT_MSG_TYPE	       fixed bin internal static options (constant) init (19);
  1    81 
  1    82 dcl  DSA_UNSPECIFIED_MSG	       fixed bin (8) uns internal static options (constant) init (0);
  1    83 dcl  DSA_ATTENTION_MSG	       fixed bin (8) uns internal static options (constant) init (1);
  1    84 dcl  DSA_DATA_ATTENTION_MSG	       fixed bin (8) uns internal static options (constant) init (2);
  1    85 dcl  DSA_DEMAND_RELEASE_SRU_MSG      fixed bin (8) uns internal static options (constant) init (3);
  1    86 dcl  DSA_DEMAND_TURN_MSG	       fixed bin (8) uns internal static options (constant) init (4);
  1    87 dcl  DSA_DEMAND_TURN_ACK_MSG	       fixed bin (8) uns internal static options (constant) init (5);
  1    88 dcl  DSA_PURGE_MSG		       fixed bin (8) uns internal static options (constant) init (6);
  1    89 dcl  DSA_RECOVER_MSG	       fixed bin (8) uns internal static options (constant) init (7);
  1    90 dcl  DSA_RECOVER_ACK_MSG	       fixed bin (8) uns internal static options (constant) init (8);
  1    91 dcl  DSA_RELEASE_SRU_MSG	       fixed bin (8) uns internal static options (constant) init (9);
  1    92 dcl  DSA_RESUME_MSG		       fixed bin (8) uns internal static options (constant) init (10);
  1    93 dcl  DSA_RESUME_ACK_MSG	       fixed bin (8) uns internal static options (constant) init (11);
  1    94 dcl  DSA_SUSPEND_MSG	       fixed bin (8) uns internal static options (constant) init (12);
  1    95 dcl  DSA_SUSPEND_ACK_MSG	       fixed bin (8) uns internal static options (constant) init (13);
  1    96 dcl  DSA_TERM_ABNORMAL_MSG	       fixed bin (8) uns internal static options (constant) init (14);
  1    97 dcl  DSA_ESTABLISHMENT_MSG	       fixed bin (8) uns internal static options (constant) init (15);
  1    98 dcl  DSA_TERMINATED_MSG	       fixed bin (8) uns internal static options (constant) init (16);
  1    99 dcl  DSA_USER_UNASSIGN_MSG	       fixed bin (8) uns internal static options (constant) init (17);
  1   100 dcl  DSA_DATA_INPUT_MSG	       fixed bin (8) uns internal static options (constant) init (18);
  1   101 dcl  DSA_DATA_OUTPUT_MSG	       fixed bin (8) uns internal static options (constant) init (19);
  1   102 
  1   103 dcl  DSA_MSG_TYPE_TO_PNAME	       (0:19) char (20) internal static options (constant) init ("unspecified",
  1   104 						/*  0 */
  1   105 			       "attention",		/*  1 */
  1   106 			       "data_attention",	/*  2 */
  1   107 			       "demand_release_sru",	/*  3 */
  1   108 			       "demand_turn",	/*  4 */
  1   109 			       "demand_turn_ack",	/*  5 */
  1   110 			       "purge",		/*  6 */
  1   111 			       "recover",		/*  7 */
  1   112 			       "recover_ack",	/*  8 */
  1   113 			       "release_sru",	/*  9 */
  1   114 			       "resume",		/* 10 */
  1   115 			       "resume_ack",	/* 11 */
  1   116 			       "suspend",		/* 12 */
  1   117 			       "suspend_ack",	/* 13 */
  1   118 			       "terminate_abnormal",	/* 14 */
  1   119 			       "establishment",	/* 15 */
  1   120 			       "terminated",	/* 16 */
  1   121 			       "user_unassign",	/* 17 */
  1   122 			       "data input",	/* 18 */
  1   123 			       "data output");	/* 19 */
  1   124 
  1   125 /*	END INCLUDE FILE ... net_event_message.incl.pl1 */
      114 
  2     1 /* BEGIN INCLUDE FILE tc_operations_.incl.pl1 BIM May 1981 */
  2     2 
  2     3 /* Modified 7 February 1985 by Jon Rochlis to add saved_ips_mask to 
  2     4*   request_header. */
  2     5 
  2     6 /* format: style3 */
  2     7 
  2     8 /* These are the operations that the "virtual video terminal" is expected to
  2     9*provide.  These are the primitive operation.  For example, the various
  2    10*flavors of region clearing are collapsed into "clear region".  The particular
  2    11*operations of clear screen, clear to end of screen, and clear to end of line
  2    12*are special cases which will be used when terminal functionality permits.  Of
  2    13*course, at the user interface level, these are provided as convienience.
  2    14*This introduces the innefficiency of mapping CLEOL -> CL-REGION -> CLEOL.
  2    15*However, CLEOL _i_n _a _w_i_n_d_o_w does not always mean CLEOL on the screen.  It will
  2    16*not unless the window is full width, or happens to be rightmost.  Similiarly,
  2    17*a user call of CLEAR_WINDOW is just a region to the terminal.  */
  2    18 
  2    19 declare	request_ptr	pointer;
  2    20 declare	REQUEST_SENTINEL	character (4) aligned init ("RqqS") internal static options (constant);
  2    21 
  2    22 declare	1 request_header	aligned based (request_ptr),
  2    23 	  2 sentinel	character (4) aligned,
  2    24 	  2 request_id	fixed bin (71),		/* Clock Value */
  2    25 	  2 window_id	bit (36) aligned,
  2    26 	  2 coords	aligned like r_coords,
  2    27 	  2 operation	fixed bin,
  2    28 	  2 flags		aligned,
  2    29 	    3 async_interruption
  2    30 			bit (1) unaligned,		/* Output */
  2    31 	    3 this_window	bit (1) unaligned,		/* ditto */
  2    32             2 saved_ips_mask  bit (36) aligned;	          /* so tc_block can restore mask from window_io_ */
  2    33 
  2    34 declare	1 r_coords	aligned based,
  2    35 	  2 row		fixed bin,
  2    36 	  2 col		fixed bin;
  2    37 
  2    38 declare	OP_ERROR		fixed bin initial (0) internal static options (constant);
  2    39 declare	OP_POSITION_CURSOR	fixed bin initial (1) internal static options (constant);
  2    40 
  2    41 declare	OP_CLEAR_REGION	fixed bin initial (2) internal static options (constant);
  2    42 
  2    43 /* This next one is for the TC operation of clearing terminal without
  2    44*   any assumptions, used when the user indicates screen damage, or on
  2    45*   reconnection. */
  2    46 
  2    47 declare	OP_CLEAR_SCREEN_NO_OPT
  2    48 			fixed bin init (4) internal static options (constant);
  2    49 
  2    50 declare	1 request_clear_region
  2    51 			aligned based (request_ptr),
  2    52 	  2 header	aligned like request_header,
  2    53 	  2 by_name	aligned,
  2    54 	    3 extent	aligned,
  2    55 	      4 rows	fixed bin,
  2    56 	      4 columns	fixed bin;
  2    57 
  2    58 declare	OP_INSERT_TEXT	fixed bin initial (3) internal static options (constant);
  2    59 
  2    60 declare	1 request_text	aligned based (request_ptr),
  2    61 	  2 header	aligned like request_header,
  2    62 	  2 by_name	aligned,
  2    63 	    3 text_ptr	pointer,
  2    64 	    3 text_length	fixed bin (21);
  2    65 
  2    66 declare	request_text_string character (request_text.text_length) based (request_text.text_ptr);
  2    67 
  2    68 declare	OP_DELETE_CHARS	fixed bin initial (6) internal static options (constant);
  2    69 
  2    70 declare	1 request_delete_chars
  2    71 			aligned based (request_ptr),
  2    72 	  2 header	aligned like request_header,
  2    73 	  2 by_name	aligned,
  2    74 	    3 count	fixed bin;
  2    75 
  2    76 declare	OP_SCROLL_REGION	fixed bin initial (7) internal static options (constant);
  2    77 
  2    78 declare	1 request_scroll_region
  2    79 			aligned based (request_ptr),
  2    80 	  2 header	aligned like request_header,
  2    81 	  2 by_name	aligned,
  2    82 	    3 start_line	fixed bin,
  2    83 	    3 n_lines	fixed bin,
  2    84 	    3 distance	fixed bin;
  2    85 
  2    86 declare	OP_BELL		fixed bin initial (8) internal static options (constant);
  2    87 declare	OP_GET_CHARS_ECHO	fixed bin initial (9) internal static options (constant);
  2    88 declare	OP_GET_CHARS_NO_ECHO
  2    89 			fixed bin initial (10) internal static options (constant);
  2    90 declare	OP_WRITE_SYNC_GET_CHARS_NO_ECHO
  2    91 			fixed bin initial (11) internal static options (constant);
  2    92 
  2    93 declare	1 request_read_status
  2    94 			aligned based (request_ptr),
  2    95 	  2 header	aligned like request_header,
  2    96 	  2 by_name	aligned,			/*  not used as such */
  2    97 	    3 returned_length
  2    98 			fixed bin,
  2    99 	    3 event_channel	fixed bin (71);
  2   100 
  2   101 declare	1 request_read	aligned based (request_ptr),
  2   102 	  2 header	aligned like request_header,
  2   103 	  2 by_name	aligned,
  2   104 	    3 buffer_ptr	pointer,
  2   105 	    3 buffer_length fixed bin (21),
  2   106 	    3 returned_length
  2   107 			fixed bin (21),
  2   108 	    3 returned_break_flag
  2   109 			bit (1) aligned,
  2   110 	    3 prompt_ptr	pointer,
  2   111 	    3 prompt_length fixed bin (21),
  2   112 	    3 breaks	bit (128) unaligned;
  2   113 
  2   114 
  2   115 declare	request_prompt	character (request_read.prompt_length) based (request_read.prompt_ptr);
  2   116 declare	request_buffer	character (request_read.buffer_length) based (request_read.buffer_ptr);
  2   117 
  2   118 declare	OP_GET_CURSOR_POSITION
  2   119 			fixed bin initial (12) internal static options (constant);
  2   120 declare	OP_READ_STATUS	fixed bin initial (13) internal static options (constant);
  2   121 declare	OP_OVERWRITE_TEXT	fixed bin initial (14) internal static options (constant);
  2   122 declare	OP_WRITE_RAW	fixed bin initial (15) internal static options (constant);
  2   123 declare	OP_READ_ONE	fixed bin initial (16) internal static options (constant);
  2   124 
  2   125 /* use request_read, and return the character in the buffer there */
  2   126 /* pass the BLOCK flag in in break_flag. Well... */
  2   127 
  2   128 /* END INCLUDE FILE tc_operations_.incl.pl1 */
      115 
      116 
  3     1 /* BEGIN INCLUDE FILE tc_data_.incl.pl1 BIM May 1981 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-07-22,LJAdams), approve(86-11-13,MCR7485),
  3     6*     audit(86-12-19,Margolin), install(87-01-06,MR12.0-1255):
  3     7*     Added mowse_terminal_iocb_ptr field.
  3     8*  2) change(86-11-26,LJAdams), approve(86-11-26,MCR7584),
  3     9*     audit(86-12-19,Margolin), install(87-01-06,MR12.0-1255):
  3    10*     tty_handle component has been added for DSA.
  3    11*                                                   END HISTORY COMMENTS */
  3    12 
  3    13 
  3    14 /* Modified DEC 1985 by R. Negaret to add network_type and tty_handle */
  3    15 /* format: style3 */
  3    16 /* This data structure should contain the information
  3    17*   to run terminal control, regardless of what I/O module
  3    18*   it happens to live in */
  3    19 
  3    20 declare	tc_data_ptr	pointer;
  3    21 declare	1 tc_data		aligned based (tc_data_ptr),
  3    22 	  2 network_type	fixed bin,		/* Identification of the network:
  3    23*                                 MCS_NETWORK_TYPE, DSA_NETWORK_TYPE, ... */
  3    24 	  2 devx		fixed bin,		/* hardcore devx */
  3    25 	  2 tty_handle	fixed bin (35),
  3    26 	  2 event		fixed bin (71),		/* tty_index wakes this up */
  3    27 	  2 mowse_terminal_iocb_ptr
  3    28 			ptr,			/* ptr to mowse_terminal_ switch */
  3    29 	  2 change_pclock	fixed bin (35),		/* for detecting async happenings */
  3    30 	  2 ttp		character (32) unaligned,	/* terminal type */
  3    31 	  2 ttt_video_ptr	pointer,
  3    32 	  2 breaktest	bit (128) unaligned,
  3    33 	  2 terminal	aligned,
  3    34 	    3 rows	fixed bin,		/* mostly for better name */
  3    35 	    3 columns	fixed bin,
  3    36 	    3 line_speed	fixed bin,
  3    37 	  2 state		aligned like terminal_state,
  3    38 	  2 tty_read_buffer character (1024) unaligned,	/* should suffice */
  3    39 	  2 input_buffer_ptr
  3    40 			pointer,
  3    41 	  2 screen_data_ptr pointer,
  3    42 	  2 desk_ptr	pointer,			/* table of windows */
  3    43 	  2 old_mode_string character (512) unaligned,
  3    44 	  2 global_buffer_index
  3    45 			fixed bin,
  3    46 	  2 global_buffer_limit
  3    47 			fixed bin,
  3    48 	  2 global_output_buffer
  3    49 			char (512) unaligned;
  3    50 
  3    51 
  3    52 declare	tc_break_array	(0:127) bit (1) unaligned defined (tc_data.breaktest) position (1);
  3    53 
  3    54 declare	1 terminal_state	aligned based,
  3    55 	  2 flags		aligned,
  3    56 	    3 insert_mode	bit (1) unaligned,
  3    57 	    3 cursor_valid	bit (1) unaligned,		/* we know pos */
  3    58 	    3 echnego_outstanding
  3    59 			bit (1) unaligned,
  3    60 	    3 mark_outstanding
  3    61 			bit (1) unaligned,
  3    62 	    3 pad		bit (32) unaligned,
  3    63 	  2 pending	aligned,
  3    64 	    3 count	fixed bin,		/* count of invocations blocked */
  3    65 	    3 input_count	fixed bin,		/* how many are input */
  3    66 	    3 protocol_evs	(72) fixed bin (71),	/* yea, too damn big */
  3    67 	    3 have_sent_protocol
  3    68 			bit (72) unaligned,
  3    69 	    3 async_same_window
  3    70 			bit (72) unaligned,		/* for reflection back to blocking window */
  3    71 	    3 blocked_windows
  3    72 			(72) bit (36) aligned,	/* only 1:count are valid */
  3    73 	  2 cursor_position aligned,			/* respectable only if valid */
  3    74 	    3 row		fixed bin,
  3    75 	    3 col		fixed bin,
  3    76 	  2 current_mark	fixed bin (9) unsigned,
  3    77 	  2 last_mark_back	fixed bin (9) unsigned;
  3    78 
  3    79 declare	state_async_same_window
  3    80 			(72) bit (1) unaligned defined (tc_data.state.pending.async_same_window) position (1);
  3    81 
  3    82 declare	state_have_sent_protocol
  3    83 			(72) bit (1) unaligned defined (tc_data.state.pending.have_sent_protocol) position (1);
  3    84 
  3    85 /* END INCLUDE FILE tc_data_.incl.pl1 */
      117 
      118 
  4     1 /* BEGIN INCLUDE FILE tc_input_buffer_.incl.pl1 BIM May 1981 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(88-09-28,LJAdams), approve(88-09-28,MCR8001),
  4     6*     audit(88-10-06,Farley), install(88-10-07,MR12.2-1148):
  4     7*     Added structures needed to reallocate additional storage for the data and
  4     8*     control buffers.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 
  4    12 /* format: style2,linecom,^indnoniterdo,indcomtxt,^inditerdo,dclind5,idind25 */
  4    13 /* INTERNAL INTERFACE */
  4    14 
  4    15 /* The input buffer is maintained as two parallel sliding windows.
  4    16*   One contains actual data characters, and the other control bits
  4    17*   associated with each character. A "data character" may be a
  4    18*   serial mark, if the MARK_CONTROL bit is set.
  4    19*
  4    20*   When the input buffer gets too full, the data is copied back
  4    21*   wards over dead data to make new space. Routines that remember
  4    22*   positions in the buffer must remember them as relative offsets
  4    23*   rather than pointers, so that the buffer can be compacted.
  4    24*
  4    25*   This is possible because no data can be "killed" that has an
  4    26*   outstanding mark after it. thus nothing between the beginning
  4    27*   of the valid window and the first mark can be Killed
  4    28*   while that mark is not killed, so that the position of the first
  4    29*   valid character cannot move forward while any async
  4    30*   operation is in progress.
  4    31**/
  4    32 
  4    33      declare 1 control_entry	        based unaligned,
  4    34 	     2 mark	        bit (1) unaligned,
  4    35 	     2 echoed	        bit (1) unaligned,
  4    36 	     2 end_of_info	        bit (1) unaligned,
  4    37 	     2 deleted	        bit (1) unaligned,	/* already used */
  4    38 	     2 pad	        bit (5) unaligned;	/* reserved */
  4    39 
  4    40 /* Use these on string (control_entry) */
  4    41 
  4    42      declare (
  4    43 	   NORMAL_CONTROL	        initial ("000000000"b),
  4    44 	   MARK_CONTROL	        initial ("100000000"b),
  4    45 	   ECHOED_CONTROL	        initial ("010000000"b),
  4    46 	   END_OF_INFO_CONTROL      initial ("001000000"b),
  4    47 	   DELETED_CONTROL	        initial ("000100000"b)
  4    48 	   )		        bit (9) unaligned internal static options (constant);
  4    49 
  4    50 
  4    51      declare 1 data_bits	        based unaligned,
  4    52 	     2 pad_1	        bit (1) unaligned,
  4    53 	     2 pad_2	        bit (1) unaligned,
  4    54 	     2 character	        bit (7) unaligned;	/* we might represent special chars */
  4    55 
  4    56      declare 1 data_char	        based unaligned,
  4    57 	     2 character	        character (1) unaligned;
  4    58 
  4    59      declare 1 data_mark	        based unaligned,
  4    60 	     2 mark_number	        fixed bin (9) unsigned unaligned;
  4    61 
  4    62 
  4    63      declare input_buffer_ptr	        pointer;
  4    64 
  4    65      declare 1 input_buffer	        aligned based (input_buffer_ptr),
  4    66 	     2 buffer_length        fixed bin (21),
  4    67 	     2 control_ptr	        pointer,		/* start of ctl buffer */
  4    68 	     2 data_ptr	        pointer,		/* start of data buffer */
  4    69 	     2 n_valid	        fixed bin (21),	/* this is index (byte (bin (END_OF_INFO_CONTROL)) - 1 in the buffer */
  4    70 	     2 n_chars_valid        fixed bin (21),	/* n nondeleted normal chars */
  4    71 						/* The next two pointer must be maintained in sync !!! */
  4    72 	     2 n_shifts	        fixed bin;		/* meter compactions */
  4    73 
  4    74      declare 1 control_buffer	        unaligned based (input_buffer.control_ptr)
  4    75 			        dimension (input_buffer.buffer_length) like control_entry;
  4    76 
  4    77      declare control_buffer_as_chars  unaligned based (input_buffer.control_ptr) character (input_buffer.buffer_length);
  4    78      ;
  4    79 
  4    80      declare 1 data_buffer	        unaligned based (input_buffer.data_ptr) dimension (input_buffer.buffer_length)
  4    81 			        like data_char;
  4    82 
  4    83      declare data_buffer_as_chars     unaligned based (input_buffer.data_ptr) character (input_buffer.buffer_length);
  4    84 
  4    85 
  4    86      declare new_buf_size              fixed bin (21);
  4    87 
  4    88      declare new_data_buf_ptr	         pointer;
  4    89 
  4    90      declare 1 new_data_buf            unaligned based (new_data_buf_ptr)
  4    91                                        dimension (new_buf_size) like data_char;
  4    92 
  4    93      declare new_control_buf_ptr       pointer;
  4    94 
  4    95      declare 1 new_control_buf         unaligned based (new_control_buf_ptr)
  4    96                                        dimension (new_buf_size) like control_entry;
  4    97 
  4    98      declare temp_data                 char(new_buf_size) based; 
  4    99 /* END INCLUDE FILE tc_input_buffer_ */
      119 
      120 
  5     1 /* BEGIN INCLUDE FILE mcs_echo_neg.incl.pl1  Bernard Greenberg 1/20/79 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(86-04-23,Coren), approve(86-04-23,MCR7300),
  5     7*     audit(86-05-19,Beattie), install(86-07-08,MR12.0-1089):
  5     8*               Changed version to 2, increased size of break table,
  5     9*               included named constant for break table size.
  5    10*                                                   END HISTORY COMMENTS */
  5    11 
  5    12 
  5    13 /* This include file defines the callable entrypoints and argument data
  5    14*   structures for ring 0 echo negotiation */
  5    15 
  5    16 /* format: style2,linecom,^indnoniterdo,indcomtxt,^inditerdo,dclind5,idind25 */
  5    17      dcl	echo_neg_datap	     ptr;
  5    18      dcl	echo_neg_data_version_2  fixed bin static options (constant) init (2);
  5    19      dcl	ECHO_NEG_BREAK_TABLE_SIZE
  5    20 			     fixed bin internal static options (constant) init (255);
  5    21 
  5    22      dcl	1 echo_neg_data	     based (echo_neg_datap) aligned,
  5    23 						/* Echo negotiation data */
  5    24 	  2 version	     fixed bin,
  5    25 	  2 break		     (0:255) bit (1) unaligned,
  5    26 						/* Break table, 1 = break */
  5    27 	  2 pad		     bit (7) unaligned,
  5    28 	  2 rubout_trigger_chars (2) unaligned,		/* Characters that cause rubout action */
  5    29 	    3 char	     char (1) unaligned,
  5    30 	  2 rubout_sequence_length
  5    31 			     fixed bin (4) unsigned unaligned,
  5    32 						/* Length of rubout sequence, output */
  5    33 	  2 rubout_pad_count     fixed bin (4) unsigned unaligned,
  5    34 						/* Count of pads needed */
  5    35 	  2 buffer_rubouts	     bit (1) unaligned,	/* 1 = put rubouts and rubbed out in buffer */
  5    36 	  2 rubout_sequence	     char (12) unaligned;	/* Actual rubout sequence */
  5    37 
  5    38 /*** VERSION 1 STRUCTURE DECLARATION FOR COMPATIBILITY (TO BE REMOVED FOR MR12) ***/
  5    39 
  5    40      dcl	echo_neg_data_version_1  fixed bin static options (constant) init (1);
  5    41 
  5    42      dcl	1 v1_echo_neg_data	     based (echo_neg_datap) aligned,
  5    43 						/* Echo negotiation data */
  5    44 	  2 version	     fixed bin,
  5    45 	  2 break		     (0:127) bit (1) unaligned,
  5    46 						/* Break table, 1 = break */
  5    47 	  2 pad		     bit (7) unaligned,
  5    48 	  2 rubout_trigger_chars (2) unaligned,		/* Characters that cause rubout action */
  5    49 	    3 char	     char (1) unaligned,
  5    50 	  2 rubout_sequence_length
  5    51 			     fixed bin (4) unsigned unaligned,
  5    52 						/* Length of rubout sequence, output */
  5    53 	  2 rubout_pad_count     fixed bin (4) unsigned unaligned,
  5    54 						/* Count of pads needed */
  5    55 	  2 buffer_rubouts	     bit (1) unaligned,	/* 1 = put rubouts and rubbed out in buffer */
  5    56 	  2 rubout_sequence	     char (12) unaligned;	/* Actual rubout sequence */
  5    57 /*** END VERSION 1 STRUCTURE ****/
  5    58 
  5    59      dcl	(
  5    60 	hcs_$tty_read_echoed,
  5    61 	hcs_$echo_negotiate_get_chars
  5    62 	)		     entry (fixed bin, ptr, fixed bin (21), fixed bin (21), fixed bin (21), fixed bin (21),
  5    63 			     fixed bin, fixed bin, fixed bin (35));
  5    64 						/*
  5    65*						   call  hcs_$echo_negotiate_get_chars
  5    66*						   (devx, datap, offset, nelem, NRETURNED, NECHOED_RETURNED, screen_left, STATE, CODE);
  5    67*						*/
  5    68 
  5    69 /* END INCLUDE FILE mcs_echo_neg.incl.pl1 */
      121 
      122 
      123 
      124 	declare code		   fixed bin (35);
      125 	declare tty_state		   fixed bin;
      126 
      127 	declare dsa_tty_$read_echoed	   entry (fixed bin (35), ptr, fixed bin (21), fixed bin (21), fixed bin (21),
      128 				   fixed bin (21), fixed bin, fixed bin, fixed bin (35));
      129 
      130 	declare ws_tty_$read_echoed	   entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (21),
      131 				   fixed bin (21), fixed bin, fixed bin, fixed bin (35));
      132 
      133 	declare add_char_offset_	   entry (ptr, fixed bin (21)) returns (ptr) reducible;
      134 	declare tc_request$write_echo	   entry (pointer, char (*));
      135 	declare tc_error		   entry (fixed binary (35), character (*));
      136 
      137 	declare tc_screen$text	   entry (pointer, fixed bin, fixed bin, bit (1) aligned, character (*));
      138 
      139 	declare tc_disconnect$check	   entry (pointer, fixed bin (35));
      140 
      141 	declare (
      142 	        video_et_$tc_tty_error,
      143 	        video_et_$tc_mark_missing
      144 	        )			   external static fixed bin (35);
      145 
      146 	declare BUF_LEN		   fixed bin internal static options (constant) init (2048);
      147 	declare UNMASK_NOTHING	   bit (36) aligned initial ("01"b) internal static options (constant);
      148 	declare RESTORE_MASK	   bit (36) aligned initial ("001"b) internal static options (constant);
      149 
      150 	declare (addr, byte, hbound, index, length, min, null, rank, rtrim, string, substr, unspec)
      151 				   builtin;
      152 
      153 
      154 init:
      155      entry (TC_data_ptr);
      156 
      157 /* The structure tc_data must be already allocated .
      158*   This program fills in the input side data */
      159 
      160 	tc_data_ptr = TC_data_ptr;
      161 	state.echnego_outstanding = "0"b;
      162 
      163 	allocate input_buffer set (input_buffer_ptr);
      164 	tc_data.input_buffer_ptr = input_buffer_ptr;
      165 	input_buffer.buffer_length = BUF_LEN;
      166 	allocate control_buffer set (input_buffer.control_ptr);
      167 	allocate data_buffer set (input_buffer.data_ptr);
      168 	input_buffer.n_valid = 0;
      169 	input_buffer.n_shifts = 0;
      170 	input_buffer.n_chars_valid = 0;
      171 	return;
      172 
      173 
      174 shut:
      175      entry (TC_data_ptr);
      176 
      177 	tc_data_ptr = TC_data_ptr;
      178 	input_buffer_ptr = tc_data.input_buffer_ptr;
      179 
      180 	free data_buffer;
      181 	free control_buffer;
      182 	free input_buffer;
      183 	tc_data.input_buffer_ptr = null ();
      184 	return;
      185 
      186 
      187 do_input:
      188 	tc_data_ptr = TC_data_ptr;
      189 	input_buffer_ptr = tc_data.input_buffer_ptr;
      190 	Code = 0;
      191 	request_ptr = Request_ptr;
      192 
      193 	declare 1 i_op		   aligned automatic,
      194 						/* the stack is the q */
      195 		2 buffer_ptr	   pointer,
      196 		2 buffer_length	   fixed bin (21),
      197 		2 cur_buffer_ptr	   pointer,
      198 		2 cur_buffer_length	   fixed bin (21),
      199 		2 write_buffer_count   fixed bin (21),
      200 		2 flags		   aligned,
      201 		  3 echo		   bit (1) unaligned,
      202 		  3 mark_was_outstanding
      203 				   bit (1) unaligned,
      204 		  3 write_sync_read	   bit (1) unaligned,
      205 		  3 just_one_char	   bit (1) unaligned,
      206 		  3 pad		   bit (32) unaligned,
      207 		2 buffer_index	   fixed bin (21);	/* last place we scanned, relative to  buffers */
      208 
      209 /* ASSERT echonegotiation cannot be pending. */
      210 /* ASSERT the request is get_chars_no_echo, get_chars_echo, read_status, or
      211*   write_sync_get_chars_no_echo */
      212 
      213 
      214 	if request_header.operation = OP_READ_STATUS
      215 	then do;
      216 	     call read_status;
      217 	     return;
      218 	end;
      219 
      220 /* ASSERT that a mark is cast after each output by tc_request */
      221 
      222 /* There are two limitations on the current mark implementation.
      223*
      224*   (1) There is only one mark.
      225*
      226*   (2) We cannot get the mark back unless there is some other
      227*   input from the terminal.
      228*
      229*   As a result, the only available strategy for now is this:
      230*
      231*   After each output, cast the mark. If it is already outstanding,
      232*   then it is lost.
      233*
      234*   For an asyncronous request for input, we wait for the last mark
      235*   left out. This syncs us correctly.
      236*
      237*   For a write-sync-read, the prompt has already been written and
      238*   marked, and we were called masked. */
      239 
      240 
      241 /* One final case - a zero-length input request of any flavor is interpreted
      242*   as a request to sync input to output, using the last mark we put out */
      243 /* Ring zero cannot currently return us the mark unless new input is typed
      244*   by the user after the mark is written.  This causes us to go blocked
      245*   waiting for some input if we want to read the mark.  Since that is pretty
      246*   useless, we will give up this sync attempt until ring 0 can be changed to
      247*   return the mark if it is there  without requiring that new input be typed.
      248*   -WMY 9/22/82  */
      249 
      250 
      251 /* Old code to sync to mark, currently out of service.
      252*
      253*   if request_read.buffer_length = 0
      254*   then do;
      255*   if mark_outstanding ()
      256*   then call retrieve_mark;
      257*   go to request_satisfied;
      258*   end;
      259*
      260**/
      261 
      262 	if request_read.buffer_length = 0
      263 	then goto request_satisfied;
      264 
      265 	unspec (i_op) = ""b;			/* turn all the flags off */
      266 	i_op.mark_was_outstanding = mark_outstanding ();
      267 
      268 	i_op.write_sync_read = (request_header.operation = OP_WRITE_SYNC_GET_CHARS_NO_ECHO);
      269 	i_op.just_one_char = (request_header.operation = OP_READ_ONE);
      270 
      271 	i_op.buffer_index = 1;			/* assume this request is interested in whole buffer. If it requires a mark, this will get reset by retrieve_mark */
      272 
      273 /* ASSERT mark_outstanding, trust tc_request to have wrote mark after cursorpos */
      274 
      275 	if i_op.write_sync_read
      276 	then call retrieve_mark;
      277 
      278 
      279 	i_op.buffer_ptr, i_op.cur_buffer_ptr = request_read.buffer_ptr;
      280 	i_op.buffer_length, i_op.cur_buffer_length = request_read.buffer_length;
      281 
      282 	if request_header.operation = OP_GET_CHARS_ECHO
      283 	then i_op.echo = "1"b;
      284 
      285 	if request_header.operation ^= OP_READ_ONE
      286 	then if (request_read.breaks ^= tc_data.breaktest)
      287 	     then call set_break_table;
      288 
      289 	request_read.returned_length = 0;
      290 	if i_op.just_one_char
      291 	then do;
      292 	     if ^request_read.returned_break_flag	/* This is really a block_flag */
      293 	     then do;
      294 		call read_to_mark_no_block (RESTORE_MASK);
      295 		request_read.returned_break_flag = try_to_satisfy ();
      296 		go to request_satisfied;
      297 	     end;
      298 	end;
      299 
      300 /* The count of 1 in the READ_ONE call will cause the following to do the right thing */
      301 
      302 
      303 	do while (^try_to_satisfy ());
      304 	     call read_and_buffer;
      305 	end;
      306 
      307 
      308 request_satisfied:					/* move the buffer down if we can */
      309 	if tc_data.state.pending.count = 0		/** **/
      310 	     & input_buffer.n_valid ^< 1
      311 	then begin;
      312 		declare (i, first_valid_x)	   fixed bin (21);
      313 
      314 		do first_valid_x = 1 to input_buffer.n_valid while (control_buffer (first_valid_x).deleted);
      315 		end;				/* set i to first nondeleted */
      316 
      317 		if first_valid_x ^> input_buffer.n_valid/** **/
      318 		     & first_valid_x > 1
      319 		then do;
      320 		     do i = first_valid_x to input_buffer.n_valid;
      321 			control_buffer (i - first_valid_x + 1) = control_buffer (i);
      322 			data_buffer (i - first_valid_x + 1) = data_buffer (i);
      323 		     end;
      324 		     input_buffer.n_valid = input_buffer.n_valid - first_valid_x + 1;
      325 		end;
      326 
      327 		else if first_valid_x > input_buffer.n_valid
      328 		then do;
      329 		     if input_buffer.n_valid + 1 > input_buffer.buffer_length
      330 		     then call grow_buffer;
      331 		     else input_buffer.n_valid = 0;
      332 		end;
      333 	     end;
      334 
      335 	return;
      336 
      337 /* ASSERT the ips mask is masked down */
      338 
      339 check_echnego:
      340      entry (TC_data_ptr, Request_ptr);
      341 
      342 	tc_data_ptr = TC_data_ptr;
      343 	request_ptr = Request_ptr;
      344 	input_buffer_ptr = tc_data.input_buffer_ptr;
      345 
      346 	if state.echnego_outstanding
      347 	then call close_out_echnego;
      348 
      349 	else if state.pending.count > 0
      350 	then call read_to_mark_no_block (UNMASK_NOTHING);
      351 
      352 	return;
      353 
      354 
      355 
      356 mark_outstanding:
      357      procedure returns (bit (1) aligned);
      358 
      359 	return (state.last_mark_back < state.current_mark);
      360      end mark_outstanding;
      361 
      362 mark_in_buffer:
      363      procedure (mark) returns (bit (1) aligned);
      364 
      365 /* Search the buffer for a mark, if it is there return 1
      366*   and set buffer_index to point to just after it. */
      367 
      368 	declare mark		   fixed bin (9) unsigned;
      369 	declare s_pos		   fixed bin (21);	/* we start looking here */
      370 	declare m_pos		   fixed bin (21);
      371 	declare mark_ptr		   pointer;
      372 	declare MARK		   character (1);
      373 
      374 	unspec (MARK) = MARK_CONTROL;
      375 	s_pos = 1;
      376 	do while (s_pos < input_buffer.n_valid);
      377 
      378 	     m_pos = index (substr (control_buffer_as_chars, s_pos, input_buffer.n_valid - s_pos + 1), MARK);
      379 	     if m_pos = 0
      380 	     then return ("0"b);			/* no marks at all */
      381 
      382 	     m_pos = s_pos + m_pos - 1;		/* index of mark in real buffer */
      383 
      384 	     mark_ptr = addr (data_buffer (m_pos));
      385 	     if mark_ptr -> data_mark.mark_number = mark
      386 	     then do;
      387 		i_op.buffer_index = m_pos + 1;
      388 		return ("1"b);
      389 	     end;
      390 
      391 	     s_pos = m_pos + 1;			/* look again after this mark */
      392 	end;					/* the do loop */
      393 
      394 	return ("0"b);
      395      end mark_in_buffer;
      396 
      397 
      398 read_to_mark:
      399      procedure (mask_type);
      400 
      401 /* do a tty read to mark to try to find the outstanding mark */
      402 
      403 	declare mark_index		   fixed bin (21);
      404 	declare n_chars_read	   fixed bin (21);
      405 	declare mask_type		   bit (36) aligned;
      406 	declare hcs_$tty_read_with_mark  entry (fixed bin, character (*), fixed bin (21), fixed bin (21), fixed bin,
      407 				   fixed bin (35));
      408 	declare ws_tty_$read_with_mark   entry (ptr, char (*), bit (1) aligned, fixed bin (21), fixed bin (21),
      409 				   fixed bin, fixed bin (35));
      410 	declare dsa_tty_$read_with_mark  entry (fixed bin (35), character (*), fixed bin (21), fixed bin (21),
      411 				   fixed bin, fixed bin (35));
      412 	declare never_block		   bit (1) aligned;
      413 
      414 	never_block = "0"b;
      415 	go to read_common;
      416 
      417 read_to_mark_no_block:
      418      entry (mask_type);
      419 
      420 	never_block = "1"b;
      421 
      422 read_common:
      423 read:						/* goto here after block returns */
      424 	n_chars_read = 0;				/* WRITE AROUND A HARDCORE BUG, that INTERPRESTS THIS AS A BUFFER OFFSET */
      425 
      426 	if tc_data.network_type = DSA_NETWORK_TYPE
      427 	then					/* DSA */
      428 	     call dsa_tty_$read_with_mark (tc_data.tty_handle, tc_data.tty_read_buffer, n_chars_read, mark_index,
      429 		tty_state, code);
      430 	else if tc_data.network_type = MOWSE_NETWORK_TYPE
      431 	then					/* MOWSE */
      432 	     call ws_tty_$read_with_mark (tc_data.mowse_terminal_iocb_ptr, tc_data.tty_read_buffer, never_block,
      433 		n_chars_read, mark_index, tty_state, code);
      434 	else					/* MCS */
      435 	     call hcs_$tty_read_with_mark (tc_data.devx, tc_data.tty_read_buffer, n_chars_read, mark_index, tty_state,
      436 		code);
      437 
      438 	if code ^= 0
      439 	then call tc_disconnect$check (tc_data_ptr, code);
      440 	if code ^= 0
      441 	then call tty_read_error (code);		/* this is not supposed to happen */
      442 
      443 	if mark_index > 0
      444 	then do;					/* the prodigal returneth */
      445 	     if mark_index > 1
      446 	     then call add_chars_to_buffer (1, mark_index - 1);
      447 						/* mark_index is index if first character after */
      448 
      449 
      450 /* Until we have multiple marks, the only one we find can be the current one */
      451 
      452 	     call add_mark_to_buffer (state.current_mark);
      453 	     state.last_mark_back = state.current_mark;
      454 
      455 	     call add_chars_to_buffer (mark_index, n_chars_read - mark_index + 1);
      456 	end;
      457 
      458 	else if n_chars_read > 0
      459 	then call add_chars_to_buffer (1, n_chars_read);
      460 
      461 	else					/* got no data, block */
      462 	     if never_block
      463 	then return;
      464 	else do;
      465 	     call block (mask_type);			/* unmask, block, mask */
      466 	     go to read;
      467 	end;
      468      end read_to_mark;
      469 
      470 retrieve_mark:
      471      procedure;
      472 
      473 /* When retrieving the mark, we desire block to use special
      474*   ips masking techniques to avoid async tasks from being run.
      475*   Since this is not lisp, we cannot lambda-bind some flag,
      476*   and a controlled variable would be ugly. So we have to
      477*   pass a parameter down through read_to_mark */
      478 
      479 
      480 	do while (^mark_in_buffer (state.current_mark));
      481 
      482 /* ASSERT that there is a mark outstanding if the current mark
      483*   is not in the buffer */
      484 
      485 	     if ^mark_outstanding ()
      486 	     then call tc_error (video_et_$tc_mark_missing, "");
      487 
      488 /* This code used to only unmask QUIT, to avoid async happenings
      489*   while stopped at WriteSyncRead. This is not really useful
      490*   because the current mark mechanism is not precise enough to be
      491*   worth this limitation. */
      492 
      493 	     call read_to_mark (RESTORE_MASK);
      494 	end;
      495      end retrieve_mark;
      496 
      497 
      498 try_to_satisfy:
      499      procedure returns (bit (1) aligned);
      500 
      501 /* see if we can fill up and finish this input request.
      502*   starting at buffer_index, we scan characters.
      503*   we skip "dead" characters, and stop on break, or count.
      504*   Any marks we find we remove, as there can be extraneous
      505*   marks if we get to set marks on all output some time. */
      506 
      507 /* for now we just examine characters in a loop, no fancy
      508*   searching. We can go for the performance some other day */
      509 
      510 	declare our_x		   fixed bin (21);	/* current index into input_buffer's */
      511 	declare her_x		   fixed bin (21);	/* current index into user buffer */
      512 
      513 	declare her_buffer		   (i_op.cur_buffer_length) character (1) unaligned based (i_op.cur_buffer_ptr);
      514 						/* use array for char-loop approach */
      515 	declare only_echoed		   bit (1) aligned;
      516 
      517 	only_echoed = "0"b;
      518 	go to common;
      519 
      520 try_to_satisfy$$already_echoed_only:
      521      entry returns (bit (1) aligned);			/* RV is a dummy */
      522 
      523 	only_echoed = "1"b;
      524 
      525 common:
      526 	call init_echo_buffer;
      527 	her_x = 1;
      528 	our_x = i_op.buffer_index;			/* start after our mark */
      529 
      530 	if input_buffer.n_valid = 0
      531 	then return ("0"b);				/* why call them back  from heaven? */
      532 	do while (our_x <= input_buffer.n_valid);	/* this terminator happens only when we run out of stuff without satisfying */
      533 
      534 	     if control_buffer (our_x).mark
      535 	     then control_buffer (our_x).deleted = "1"b;
      536 
      537 	     else if ^control_buffer (our_x).deleted
      538 	     then begin;				/* consider this character */
      539 		     declare (break_char, needs_echo) bit (1) aligned;
      540 		     declare rank_of_char	        fixed bin;
      541 
      542 		     rank_of_char = rank (data_buffer (our_x).character);
      543 						/* All chars > \177 are breaks. */
      544 		     if rank_of_char > 127
      545 		     then break_char = "1"b;
      546 		     else break_char = tc_break_array (rank_of_char);
      547 
      548 		     needs_echo = ^control_buffer (our_x).echoed & i_op.echo;
      549 
      550 /* Contract is not to return breaks and async_term. There is no good
      551*   reason for this, but I hesitate to change this without study of
      552*   window_io_video_. Both would certainly have to be changed. */
      553 
      554 		     if only_echoed & (break_char | needs_echo)
      555 		     then go to found_unechoed;
      556 
      557 		     her_buffer (her_x) = data_buffer (our_x).character;
      558 		     her_x = her_x + 1;
      559 		     control_buffer (our_x).deleted = "1"b;
      560 
      561 		     if break_char
      562 		     then do;
      563 			request_read.returned_break_flag = "1"b;
      564 			go to success;		/* try to zonk buffer */
      565 		     end;
      566 
      567 		     if needs_echo
      568 		     then call echo_char (data_buffer (our_x).character);
      569 
      570 		     if her_x = hbound (her_buffer, 1) + 1
      571 						/* DONE */
      572 		     then do;
      573 			request_read.returned_break_flag = "0"b;
      574 			go to success;
      575 		     end;
      576 		end;				/* if ^deleted */
      577 	     our_x = our_x + 1;
      578 	end;					/* do loop */
      579 
      580 /* If we got here, we ran out of buffer */
      581 
      582 	request_read.returned_length = request_read.returned_length + (her_x - 1);
      583 	i_op.cur_buffer_ptr = add_char_offset_ (i_op.cur_buffer_ptr, (her_x - 1));
      584 	i_op.cur_buffer_length = i_op.cur_buffer_length - (her_x - 1);
      585 	i_op.buffer_index = our_x;			/* avoid examining same thing twice */
      586 	input_buffer.n_chars_valid = input_buffer.n_chars_valid - (her_x - 1);
      587 	call dump_echo_buffer;
      588 	return ("0"b);
      589 
      590 /* we are going to return "1"b */
      591 /* Or we hit a character that we cound not returned because */
      592 /* it had not been echoed. In both cases our_x is one past the last one */
      593 /* that should be returned. */
      594 
      595 found_unechoed:
      596 success:
      597 	request_read.returned_length = request_read.returned_length + her_x - 1;
      598 	input_buffer.n_chars_valid = input_buffer.n_chars_valid - (her_x - 1);
      599 	if ^only_echoed
      600 	then call dump_echo_buffer;
      601 	return ("1"b);
      602      end try_to_satisfy;
      603 
      604 
      605 read_and_buffer:
      606      procedure;
      607 
      608 /* Caller of tty_read and get_chars_echo_etc. bufferer of read characters. */
      609 /* we must manage the echo_negotiation flag. */
      610 
      611 	declare n_chars_read	   fixed bin (21);
      612 
      613 /* We can ignore the mark here on the first read call. There is only one
      614*   reason the mark could be
      615*   out. It could be left from some output that no call attempted
      616*   to sync to. This is not interesting, and is not worth giving up
      617*   negotiation for. We can claim that it is "in" in case someone tries
      618*   to sync. The mark could be put out asyncronously, but we will close
      619*   out negotiation before. */
      620 
      621 	if i_op.echo
      622 	then do;					/* try to negotiate */
      623 	     state.last_mark_back = state.current_mark;	/* fake it */
      624 
      625 /* ASSERT: negotiation is not in progress. Thus n_chars_echoed must be zero
      626*   on return. */
      627 
      628 	     declare dummy		        fixed bin (21);
      629 	     declare screen_left	        fixed bin;
      630 
      631 	     screen_left = min ((tc_data.columns - request_read.col + 1), i_op.cur_buffer_length);
      632 
      633 	     if tc_data.network_type = DSA_NETWORK_TYPE
      634 	     then					/* DSA */
      635 		call dsa_tty_$read_echoed (tc_data.tty_handle, addr (tc_data.tty_read_buffer), (0) /* offset */,
      636 		     length (tc_data.tty_read_buffer), n_chars_read, dummy, screen_left, tty_state, code);
      637 
      638 	     else if tc_data.network_type = MOWSE_NETWORK_TYPE
      639 	     then call ws_tty_$read_echoed (tc_data.mowse_terminal_iocb_ptr, addr (tc_data.tty_read_buffer), (0),
      640 		     length (tc_data.tty_read_buffer), n_chars_read, dummy, screen_left, tty_state, code);
      641 
      642 	     else					/* MCS */
      643 		call hcs_$tty_read_echoed (tc_data.devx, addr (tc_data.tty_read_buffer), (0) /* offset */,
      644 		     length (tc_data.tty_read_buffer), n_chars_read, dummy, screen_left, tty_state, code);
      645 
      646 	     if code ^= 0
      647 	     then call tc_disconnect$check (tc_data_ptr, code);
      648 	     if code ^= 0				/* we cannot get awaiting_stop_sync because echoing was OFF */
      649 	     then call tty_read_error (code);
      650 
      651 	     if n_chars_read = 0
      652 	     then do;				/* we have entered negotiation */
      653 		state.echnego_outstanding = "1"b;
      654 		call block (RESTORE_MASK);
      655 
      656 /* now put them in buffer and stop echoing */
      657 		call close_out_echnego;
      658 
      659 		return;
      660 	     end;
      661 	     else do;				/* it gave us characters */
      662 		call add_chars_to_buffer (1, n_chars_read);
      663 		return;
      664 	     end;
      665 	end;
      666 	else call read_to_mark (RESTORE_MASK);
      667 
      668      end read_and_buffer;
      669 
      670 
      671 add_mark_to_buffer:
      672      procedure (mark);
      673 
      674 	declare mark		   fixed bin (9) unsigned;
      675 
      676 	call add_1_to_buffer (MARK_CONTROL, byte (mark));
      677      end add_mark_to_buffer;
      678 
      679 /* procedure for adding unechoed characters to the buffer  */
      680 add_chars_to_buffer:
      681      procedure (start, how_many);
      682 
      683 	declare (start, how_many)	   fixed bin (21);
      684 	declare 1 ce		   unaligned like control_entry;
      685 
      686 	string (ce) = NORMAL_CONTROL;
      687 	go to chars_common;
      688 
      689 add_echoed_chars_to_buffer:
      690      entry (start, how_many);
      691 
      692 	string (ce) = ECHOED_CONTROL;
      693 
      694 chars_common:
      695 	input_buffer.n_chars_valid = input_buffer.n_chars_valid + how_many;
      696 	go to common;
      697 
      698 add_1_to_buffer:
      699      entry (a_ce, the_char);
      700 	declare a_ce		   bit (9);
      701 	declare istart		   fixed bin (21);
      702 	declare the_char		   character (1) aligned;
      703 
      704 	if input_buffer.n_valid + 1 > input_buffer.buffer_length
      705 	then input_buffer.n_valid = push_buffer (input_buffer.n_valid);
      706 
      707 	input_buffer.n_valid = input_buffer.n_valid + 1;
      708 	string (control_buffer (input_buffer.n_valid)) = a_ce;
      709 	substr (data_buffer_as_chars, input_buffer.n_valid, 1) = the_char;
      710 	return;
      711 
      712 common:
      713 	if input_buffer.n_valid + how_many >= input_buffer.buffer_length
      714 	then input_buffer.n_valid = push_buffer (input_buffer.n_valid);
      715 
      716 	istart = input_buffer.n_valid + 1;
      717 
      718 	input_buffer.n_valid = input_buffer.n_valid + how_many;
      719 
      720 	begin;
      721 	     declare cx		        fixed bin;
      722 	     do cx = istart to istart + how_many;
      723 		control_buffer (cx) = ce;
      724 	     end;
      725 	end;
      726 	substr (data_buffer_as_chars, istart, how_many) = substr (tc_data.tty_read_buffer, start, how_many);
      727      end add_chars_to_buffer;
      728 
      729 
      730 push_buffer:
      731      procedure (nvalid) returns (fixed bin (21));
      732 	declare nvalid		   fixed bin (21);
      733 	declare i			   fixed bin (21);
      734 	declare first_valid_x	   fixed bin (21);
      735 
      736 /* There was a problem with the bounds of the input buffer being        */
      737 /* exceeded; to correct this a check has been implemented in            */
      738 /* add_1_to_buffer, and common to ensure that the current buffer length */
      739 /* plus the characters to be added will not exceed bounds of the        */
      740 /* input_buffer. If the check fails this routine is called to push the  */
      741 /* buffer down if we can.  If this fails the size of the data_buffer    */
      742 /* the control_buffer is increased by calling grow_buffer.              */
      743 
      744 	do first_valid_x = 1 to nvalid while (control_buffer (first_valid_x).deleted);
      745 	end;					/* set i to first nondeleted */
      746 
      747 	if first_valid_x ^> nvalid & first_valid_x > 1
      748 	then do;
      749 	     do i = first_valid_x to nvalid;
      750 		control_buffer (i - first_valid_x + 1) = control_buffer (i);
      751 		data_buffer (i - first_valid_x + 1) = data_buffer (i);
      752 	     end;
      753 	     nvalid = nvalid - first_valid_x + 1;
      754 	end;
      755 
      756 	else if first_valid_x > nvalid
      757 	then call grow_buffer;
      758 
      759 	return (nvalid);
      760 
      761      end push_buffer;
      762 
      763 
      764 grow_buffer:
      765      procedure;
      766 
      767 	new_buf_size = input_buffer.buffer_length + BUF_LEN;
      768 	allocate new_control_buf set (new_control_buf_ptr);
      769 	allocate new_data_buf set (new_data_buf_ptr);
      770 	unspec (new_control_buf) = ""b;
      771 	substr (new_control_buf_ptr -> temp_data, 1, input_buffer.buffer_length) =
      772 	     substr (input_buffer.control_ptr -> temp_data, 1, input_buffer.buffer_length);
      773 	unspec (new_data_buf) = ""b;
      774 	substr (new_data_buf_ptr -> temp_data, 1, input_buffer.buffer_length) =
      775 	     substr (input_buffer.data_ptr -> temp_data, 1, input_buffer.buffer_length);
      776 	free control_buffer;
      777 	free data_buffer;
      778 	input_buffer.buffer_length = new_buf_size;
      779 	input_buffer.control_ptr = new_control_buf_ptr;
      780 	input_buffer.data_ptr = new_data_buf_ptr;
      781 
      782      end grow_buffer;
      783 
      784 
      785 block:
      786      procedure (mask_type);
      787 	declare mask_type		   bit (36) aligned;
      788 	declare tc_block		   entry (pointer, pointer, bit (36) aligned);
      789 
      790 
      791 	if tc_data.network_type ^= MOWSE_NETWORK_TYPE
      792 	then call tc_block (tc_data_ptr, request_ptr, mask_type);
      793 
      794 	if request_header.async_interruption
      795 	then do;					/* pretend to have the mark, since state is uncertain */
      796 	     call add_mark_to_buffer (state.current_mark);
      797 	     state.last_mark_back = state.current_mark;
      798 	     go to ASYNC_INTERRUPTION;
      799 	end;
      800 
      801      end block;
      802 
      803 close_out_echnego:
      804      procedure;
      805 
      806 	declare (n_chars_read, n_chars_echoed)
      807 				   fixed bin (21);
      808 
      809 	declare error_table_$echnego_awaiting_stop_sync
      810 				   fixed bin (35) external static;
      811 
      812 	declare tc_block		   entry (pointer, pointer, bit (36) aligned);
      813 
      814 
      815 /* ASSERT echo negotiation is already in progress */
      816 
      817 	code = error_table_$echnego_awaiting_stop_sync;
      818 	do while (code = error_table_$echnego_awaiting_stop_sync);
      819 
      820 /* ASSERT: a zero col-left argument turns off negotiation according to
      821*   the echo negotiation protocol */
      822 
      823 	     if tc_data.network_type = DSA_NETWORK_TYPE
      824 	     then do;				/* DSA */
      825 		call dsa_tty_$read_echoed (tc_data.tty_handle, addr (tc_data.tty_read_buffer), (0),
      826 		     length (tc_data.tty_read_buffer), n_chars_read, n_chars_echoed, (0), tty_state, code);
      827 		code = 0;
      828 	     end;
      829 
      830 	     else if tc_data.network_type = MOWSE_NETWORK_TYPE
      831 	     then call ws_tty_$read_echoed (tc_data.mowse_terminal_iocb_ptr, addr (tc_data.tty_read_buffer), (0),
      832 		     length (tc_data.tty_read_buffer), n_chars_read, n_chars_echoed, (0), tty_state, code);
      833 
      834 
      835 	     else					/* MCS */
      836 		call hcs_$tty_read_echoed (tc_data.devx, addr (tc_data.tty_read_buffer), (0),
      837 		     length (tc_data.tty_read_buffer), n_chars_read, n_chars_echoed, (0), tty_state, code);
      838 
      839 /* if FNP echo negotiation is on, we must wait for the wakeup
      840*   which signifies the FNP has stopped negotiating.  If we don't
      841*   block here, we will pick up this wakeup unexpectedly later.
      842*   After we are through blocking, go back and read again. */
      843 
      844 	     if code = error_table_$echnego_awaiting_stop_sync & tc_data.network_type ^= MOWSE_NETWORK_TYPE
      845 	     then call tc_block (tc_data_ptr, request_ptr, UNMASK_NOTHING);
      846 
      847 	     if code = 0
      848 	     then do;
      849 
      850 		if n_chars_echoed > 0
      851 		then do;				/* got stuff back, add it to buffer and update screen image */
      852 		     call add_echoed_chars_to_buffer (1, n_chars_echoed);
      853 		     call add_chars_to_buffer (1 + n_chars_echoed, n_chars_read - n_chars_echoed);
      854 		     begin;
      855 			declare echoed		   character (n_chars_echoed)
      856 						   defined (tc_data.tty_read_buffer) position (1);
      857 			call tc_screen$text (tc_data.screen_data_ptr, state.row, state.col, "0"b, echoed);
      858 		     end;
      859 		     state.col = state.col + n_chars_echoed;
      860 		end;
      861 		else if n_chars_read > 0
      862 		then call add_chars_to_buffer (1, n_chars_read);
      863 	     end;					/* if code = 0 */
      864 	end;					/* do loop */
      865 
      866 	state.echnego_outstanding = "0"b;
      867 	return;
      868 
      869      end close_out_echnego;
      870 
      871 
      872 echo_char:
      873      procedure (char_to_echo);
      874 
      875 	declare char_to_echo	   character (1);
      876 
      877 /* We borrow the tty_read_buffer as an echo buffer. This is because
      878*   echo characters are only saved for the duration of a call to try_to_satisfy
      879**/
      880 
      881 	substr (tc_data.tty_read_buffer, i_op.write_buffer_count, 1) = char_to_echo;
      882 	i_op.write_buffer_count = i_op.write_buffer_count + 1;
      883 	return;
      884 
      885 init_echo_buffer:
      886      entry;
      887 
      888 	i_op.write_buffer_count = 1;
      889 	return;
      890 
      891 dump_echo_buffer:
      892      entry;
      893 
      894 	if i_op.write_buffer_count > 1
      895 	then begin;
      896 		declare to_echo		   character (i_op.write_buffer_count - 1)
      897 					   defined (tc_data.tty_read_buffer) position (1);
      898 
      899 		call tc_request$write_echo (tc_data_ptr, to_echo);
      900 	     end;
      901      end echo_char;
      902 
      903 tty_read_error:
      904      procedure (code);
      905 	declare code		   fixed bin (35);
      906 
      907 	declare msg		   character (100) aligned;
      908 	declare convert_status_code_	   entry (fixed binary (35), character (8) aligned, character (100) aligned);
      909 
      910 	call convert_status_code_ (code, (8)" ", msg);
      911 
      912 	call tc_error (video_et_$tc_tty_error, rtrim (msg));
      913 
      914      end tty_read_error;
      915 
      916 
      917 set_break_table:
      918      procedure;
      919 	declare hcs_$tty_order	   entry (fixed bin, character (*), pointer, fixed bin, fixed bin (35));
      920 	declare ws_tty_$order	   entry (ptr, char (*), ptr, fixed bin, fixed bin (35));
      921 	declare dsa_tty_$order	   entry (fixed bin (35), character (*), pointer, fixed bin, fixed bin (35));
      922 
      923 	tc_data.breaktest = request_read.breaks;
      924 
      925 /* This is being commented out until the change for MCR7300 is put in place
      926*   declare 1 echh		   like echo_neg_data;   */
      927 
      928 	declare 1 echh		   like v1_echo_neg_data;
      929 
      930 	unspec (echh) = ""b;
      931 	echh.version = echo_neg_data_version_1;
      932 	echh.break = tc_break_array;
      933 
      934 	if tc_data.network_type = DSA_NETWORK_TYPE
      935 	then					/* DSA */
      936 	     call dsa_tty_$order (tc_data.tty_handle, "set_echo_break_table", addr (echh), tty_state, code);
      937 
      938 	else if tc_data.network_type = MOWSE_NETWORK_TYPE
      939 	then					/* MOWSE */
      940 	     call ws_tty_$order (tc_data.mowse_terminal_iocb_ptr, "set_echo_break_table", addr (echh), tty_state, code);
      941 
      942 	else					/* MCS */
      943 	     call hcs_$tty_order (tc_data.devx, "set_echo_break_table", addr (echh), tty_state, code);
      944 
      945 	if code ^= 0
      946 	then call tc_disconnect$check (tc_data_ptr, code);
      947 	if code ^= 0
      948 	then call tty_read_error (code);
      949 
      950      end set_break_table;
      951 
      952 ASYNC_INTERRUPTION:
      953 /****
      954*      We cannot try to return any extra stuff in the buffer, because the cursor
      955*      is in the wrong place for echoing. We could call tc_request asyncronously
      956*      to reposition the cursor, but that would be a bigger pain. */
      957 	begin;
      958 	     declare dummy		        bit (1) aligned;
      959 
      960 	     if i_op.echo
      961 	     then dummy = try_to_satisfy$$already_echoed_only ();
      962 
      963 	     request_read.returned_break_flag = "0"b;
      964 	     go to request_satisfied;
      965 	end ASYNC_INTERRUPTION;
      966 
      967 read_status:
      968      procedure;
      969 	declare bx		   fixed bin;
      970 
      971 	call read_to_mark_no_block (RESTORE_MASK);
      972 
      973 	request_read_status.returned_length = 0;
      974 	do bx = 1 to input_buffer.n_valid;
      975 	     if string (control_buffer (bx)) = NORMAL_CONTROL
      976 	     then request_read_status.returned_length = request_read_status.returned_length + 1;
      977 	end;
      978 
      979 /* Anybody that blocks on  this ASYNC had damn better send a wakeup */
      980 
      981 	request_read_status.event_channel = tc_data.event;
      982 	return;
      983      end read_status;
      984 
      985      end tc_input;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/07/88  1412.5  tc_input.pl1                      >spec>install>MR12.2-1148>tc_input.pl1
114          1    08/06/87  0913.5  net_event_message.incl.pl1        >ldd>include>net_event_message.incl.pl1
115          2    03/12/85  0930.8  tc_operations_.incl.pl1           >ldd>include>tc_operations_.incl.pl1
117          3    01/06/87  1357.0  tc_data_.incl.pl1                 >ldd>include>tc_data_.incl.pl1
119          4    10/07/88  1413.1  tc_input_buffer_.incl.pl1         >spec>install>MR12.2-1148>tc_input_buffer_.incl.pl1
121          5    07/10/86  2015.0  mcs_echo_neg.incl.pl1             >ldd>include>mcs_echo_neg.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BUF_LEN                                constant        fixed bin(17,0)          initial dcl 146 ref 165 767
Code                                   parameter       fixed bin(35,0)          dcl 106 set ref 99 190*
DSA_NETWORK_TYPE                       constant        fixed bin(4,0)           initial unsigned dcl 1-35 ref 426 633 823 934
ECHOED_CONTROL                  000001 constant        bit(9)                   initial packed unaligned dcl 4-42 ref 692
MARK                            000154 automatic       char(1)                  packed unaligned dcl 372 set ref 374* 378
MARK_CONTROL                           constant        bit(9)                   initial packed unaligned dcl 4-42 set ref 374 676*
MOWSE_NETWORK_TYPE                     constant        fixed bin(4,0)           initial unsigned dcl 1-36 ref 430 638 791 830 844
                                                                                  938
NORMAL_CONTROL                         constant        bit(9)                   initial packed unaligned dcl 4-42 ref 686 975
OP_GET_CHARS_ECHO                      constant        fixed bin(17,0)          initial dcl 2-87 ref 282
OP_READ_ONE                            constant        fixed bin(17,0)          initial dcl 2-123 ref 269 285
OP_READ_STATUS                         constant        fixed bin(17,0)          initial dcl 2-120 ref 214
OP_WRITE_SYNC_GET_CHARS_NO_ECHO        constant        fixed bin(17,0)          initial dcl 2-90 ref 268
RESTORE_MASK                    000000 constant        bit(36)                  initial dcl 148 set ref 294* 493* 654* 666* 971*
Request_ptr                            parameter       pointer                  dcl 106 ref 99 191 339 343
TC_data_ptr                            parameter       pointer                  dcl 106 ref 99 154 160 174 177 187 339 342
UNMASK_NOTHING                  000001 constant        bit(36)                  initial dcl 147 set ref 349* 844*
a_ce                                   parameter       bit(9)                   packed unaligned dcl 700 ref 698 708
add_char_offset_                000016 constant        entry                    external dcl 133 ref 583
addr                                                   builtin function         dcl 150 ref 384 633 633 638 638 642 642 825 825 830
                                                                                  830 835 835 934 934 938 938 942 942
async_interruption       10            based           bit(1)                   level 3 packed packed unaligned dcl 2-22 ref 794
break                     1     000362 automatic       bit(1)                   array level 2 packed packed unaligned dcl 928 set
                                                                                  ref 932*
break_char                      000207 automatic       bit(1)                   dcl 539 set ref 544* 546* 554 561
breaks                   23            based           bit(128)                 level 3 packed packed unaligned dcl 2-101 ref 285
                                                                                  923
breaktest                24            based           bit(128)                 level 2 packed packed unaligned dcl 3-21 set ref 285
                                                                                  546 546 923* 932 932
buffer_index             11     000116 automatic       fixed bin(21,0)          level 2 dcl 193 set ref 271* 387* 528 585*
buffer_length                          based           fixed bin(21,0)          level 2 in structure "input_buffer" dcl 4-65
                                                                                  in procedure "tc_input" set ref 165* 166 167 180
                                                                                  181 329 378 704 709 712 726 767 771 771 774 774
                                                                                  776 777 778*
buffer_length             2     000116 automatic       fixed bin(21,0)          level 2 in structure "i_op" dcl 193 in procedure
                                                                                  "tc_input" set ref 280*
buffer_length            14            based           fixed bin(21,0)          level 3 in structure "request_read" dcl 2-101
                                                                                  in procedure "tc_input" ref 262 280
buffer_ptr                      000116 automatic       pointer                  level 2 in structure "i_op" dcl 193 in procedure
                                                                                  "tc_input" set ref 279*
buffer_ptr               12            based           pointer                  level 3 in structure "request_read" dcl 2-101
                                                                                  in procedure "tc_input" ref 279
bx                              000404 automatic       fixed bin(17,0)          dcl 969 set ref 974* 975*
by_name                  12            based           structure                level 2 in structure "request_read_status" dcl 2-93
                                                                                  in procedure "tc_input"
by_name                  12            based           structure                level 2 in structure "request_read" dcl 2-101
                                                                                  in procedure "tc_input"
byte                                                   builtin function         dcl 150 ref 676 676
ce                              000240 automatic       structure                level 1 packed packed unaligned dcl 684 set ref 686*
                                                                                  692* 723
char_to_echo                           parameter       char(1)                  packed unaligned dcl 875 ref 872 881
character                              based           char(1)                  array level 2 packed packed unaligned dcl 4-80 set
                                                                                  ref 542 557 567*
code                                   parameter       fixed bin(35,0)          dcl 905 in procedure "tty_read_error" set ref 903
                                                                                  910*
code                            000114 automatic       fixed bin(35,0)          dcl 124 in procedure "tc_input" set ref 426* 430*
                                                                                  434* 438 438* 440 440* 633* 638* 642* 646 646* 648
                                                                                  648* 817* 818 825* 827* 830* 835* 844 847 934*
                                                                                  938* 942* 945 945* 947 947*
col                     375            based           fixed bin(17,0)          level 4 in structure "tc_data" dcl 3-21 in procedure
                                                                                  "tc_input" set ref 857* 859* 859
col                       6            based           fixed bin(17,0)          level 4 in structure "request_read" dcl 2-101
                                                                                  in procedure "tc_input" ref 631
columns                  31            based           fixed bin(17,0)          level 3 dcl 3-21 ref 631
control_buffer                         based           structure                array level 1 packed packed unaligned dcl 4-74 set
                                                                                  ref 166 181 321* 321 708* 723* 750* 750 776 975
control_buffer_as_chars                based           char                     packed unaligned dcl 4-77 ref 378
control_entry                          based           structure                level 1 packed packed unaligned dcl 4-33
control_ptr               2            based           pointer                  level 2 dcl 4-65 set ref 166* 181 314 321 321 378
                                                                                  534 534 537 548 559 708 723 744 750 750 771 776
                                                                                  779* 975
convert_status_code_            000050 constant        entry                    external dcl 908 ref 910
coords                    5            based           structure                level 3 dcl 2-101
count                    36            based           fixed bin(17,0)          level 4 dcl 3-21 ref 308 349
cur_buffer_length         6     000116 automatic       fixed bin(21,0)          level 2 dcl 193 set ref 280* 570 584* 584 631
cur_buffer_ptr            4     000116 automatic       pointer                  level 2 dcl 193 set ref 279* 557 570 583* 583*
current_mark            376            based           fixed bin(9,0)           level 3 unsigned dcl 3-21 set ref 359 452* 453 480*
                                                                                  623 796* 797
cursor_position         374            based           structure                level 3 dcl 3-21
cx                              000242 automatic       fixed bin(17,0)          dcl 721 set ref 722* 723*
data_buffer                            based           structure                array level 1 packed packed unaligned dcl 4-80 set
                                                                                  ref 167 180 322* 322 384 751* 751 777
data_buffer_as_chars                   based           char                     packed unaligned dcl 4-83 set ref 709* 726*
data_char                              based           structure                level 1 packed packed unaligned dcl 4-56
data_mark                              based           structure                level 1 packed packed unaligned dcl 4-59
data_ptr                  4            based           pointer                  level 2 dcl 4-65 set ref 167* 180 322 322 384 542
                                                                                  557 567 709 726 751 751 774 777 780*
deleted                   0(03)        based           bit(1)                   array level 2 packed packed unaligned dcl 4-74 set
                                                                                  ref 314 534* 537 559* 744
devx                      1            based           fixed bin(17,0)          level 2 dcl 3-21 set ref 434* 642* 835* 942*
dsa_tty_$order                  000056 constant        entry                    external dcl 921 ref 934
dsa_tty_$read_echoed            000012 constant        entry                    external dcl 127 ref 633 825
dsa_tty_$read_with_mark         000040 constant        entry                    external dcl 410 ref 426
dummy                           000374 automatic       bit(1)                   dcl 958 in begin block on line 952 set ref 960*
dummy                           000221 automatic       fixed bin(21,0)          dcl 628 in procedure "read_and_buffer" set ref 633*
                                                                                  638* 642*
echh                            000362 automatic       structure                level 1 unaligned dcl 928 set ref 930* 934 934 938
                                                                                  938 942 942
echnego_outstanding      34(02)        based           bit(1)                   level 4 packed packed unaligned dcl 3-21 set ref
                                                                                  161* 346 653* 866*
echo                     10     000116 automatic       bit(1)                   level 3 packed packed unaligned dcl 193 set ref 282*
                                                                                  548 621 960
echo_neg_data_version_1                constant        fixed bin(17,0)          initial dcl 5-40 ref 931
echoed                    0(01)        based           bit(1)                   array level 2 in structure "control_buffer" packed
                                                                                  packed unaligned dcl 4-74 in procedure "tc_input"
                                                                                  set ref 548
echoed                                 defined         char                     packed unaligned dcl 855 in begin block on line 854
                                                                                  set ref 857*
error_table_$echnego_awaiting_stop_sync
                                000044 external static fixed bin(35,0)          dcl 809 ref 817 818 844
event                     4            based           fixed bin(71,0)          level 2 dcl 3-21 ref 981
event_channel            14            based           fixed bin(71,0)          level 3 dcl 2-93 set ref 981*
first_valid_x                   000253 automatic       fixed bin(21,0)          dcl 734 in procedure "push_buffer" set ref 744* 744*
                                                                                  747 747 749 750 751 753 756
first_valid_x                   000131 automatic       fixed bin(21,0)          dcl 312 in begin block on line 308 set ref 314* 314*
                                                                                  317 317 320 321 322 324 327
flags                    34            based           structure                level 3 in structure "tc_data" dcl 3-21 in procedure
                                                                                  "tc_input"
flags                    10     000116 automatic       structure                level 2 in structure "i_op" dcl 193 in procedure
                                                                                  "tc_input"
flags                    10            based           structure                level 2 in structure "request_header" dcl 2-22
                                                                                  in procedure "tc_input"
hbound                                                 builtin function         dcl 150 ref 570
hcs_$tty_order                  000052 constant        entry                    external dcl 919 ref 942
hcs_$tty_read_echoed            000010 constant        entry                    external dcl 5-59 ref 642 835
hcs_$tty_read_with_mark         000034 constant        entry                    external dcl 406 ref 434
header                                 based           structure                level 2 dcl 2-101
her_buffer                             based           char(1)                  array packed unaligned dcl 513 set ref 557* 570
her_x                           000205 automatic       fixed bin(21,0)          dcl 511 set ref 527* 557 558* 558 570 582 583 584
                                                                                  586 595 598
how_many                               parameter       fixed bin(21,0)          dcl 683 ref 680 689 694 712 718 722 726 726
i                               000130 automatic       fixed bin(21,0)          dcl 312 in begin block on line 308 set ref 320* 321
                                                                                  321 322 322*
i                               000252 automatic       fixed bin(21,0)          dcl 733 in procedure "push_buffer" set ref 749* 750
                                                                                  750 751 751*
i_op                            000116 automatic       structure                level 1 dcl 193 set ref 265*
index                                                  builtin function         dcl 150 ref 378
input_buffer                           based           structure                level 1 dcl 4-65 set ref 163 182
input_buffer_ptr                000104 automatic       pointer                  dcl 4-63 in procedure "tc_input" set ref 163* 164
                                                                                  165 166 166 167 167 168 169 170 178* 180 180 181
                                                                                  181 182 189* 308 314 314 317 320 321 321 322 322
                                                                                  324 324 327 329 329 331 344* 376 378 378 378 384
                                                                                  530 532 534 534 537 542 548 557 559 567 586 586
                                                                                  598 598 694 694 704 704 704 704 707 707 708 708
                                                                                  709 709 709 712 712 712 712 716 718 718 723 726
                                                                                  726 744 750 750 751 751 767 771 771 771 774 774
                                                                                  774 776 776 777 777 778 779 780 974 975
input_buffer_ptr       1000            based           pointer                  level 2 in structure "tc_data" dcl 3-21 in procedure
                                                                                  "tc_input" set ref 164* 178 183* 189 344
istart                          000241 automatic       fixed bin(21,0)          dcl 701 set ref 716* 722 722 726
just_one_char            10(03) 000116 automatic       bit(1)                   level 3 packed packed unaligned dcl 193 set ref 269*
                                                                                  290
last_mark_back          377            based           fixed bin(9,0)           level 3 unsigned dcl 3-21 set ref 359 453* 623* 797*
length                                                 builtin function         dcl 150 ref 633 633 638 638 642 642 825 825 830 830
                                                                                  835 835
m_pos                           000151 automatic       fixed bin(21,0)          dcl 370 set ref 378* 379 382* 382 384 387 391
mark                                   parameter       fixed bin(9,0)           unsigned dcl 368 in procedure "mark_in_buffer" ref
                                                                                  362 385
mark                                   based           bit(1)                   array level 2 in structure "control_buffer" packed
                                                                                  packed unaligned dcl 4-74 in procedure "tc_input"
                                                                                  set ref 534
mark                                   parameter       fixed bin(9,0)           unsigned dcl 674 in procedure "add_mark_to_buffer"
                                                                                  ref 671 676 676
mark_index                      000164 automatic       fixed bin(21,0)          dcl 403 set ref 426* 430* 434* 443 445 445 455* 455
mark_number                            based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 4-59
                                                                                  ref 385
mark_ptr                        000152 automatic       pointer                  dcl 371 set ref 384* 385
mark_was_outstanding     10(01) 000116 automatic       bit(1)                   level 3 packed packed unaligned dcl 193 set ref 266*
mask_type                              parameter       bit(36)                  dcl 787 in procedure "block" set ref 785 791*
mask_type                              parameter       bit(36)                  dcl 405 in procedure "read_to_mark" set ref 398 417
                                                                                  465*
min                                                    builtin function         dcl 150 ref 631
mowse_terminal_iocb_ptr
                          6            based           pointer                  level 2 dcl 3-21 set ref 430* 638* 830* 938*
msg                             000322 automatic       char(100)                dcl 907 set ref 910* 912 912
n_chars_echoed                  000301 automatic       fixed bin(21,0)          dcl 806 set ref 825* 830* 835* 850 852* 853 853 855
                                                                                  859
n_chars_read                    000300 automatic       fixed bin(21,0)          dcl 806 in procedure "close_out_echnego" set ref
                                                                                  825* 830* 835* 853 861 861*
n_chars_read                    000165 automatic       fixed bin(21,0)          dcl 404 in procedure "read_to_mark" set ref 422*
                                                                                  426* 430* 434* 455 458 458*
n_chars_read                    000220 automatic       fixed bin(21,0)          dcl 611 in procedure "read_and_buffer" set ref 633*
                                                                                  638* 642* 651 662*
n_chars_valid             7            based           fixed bin(21,0)          level 2 dcl 4-65 set ref 170* 586* 586 598* 598 694*
                                                                                  694
n_shifts                 10            based           fixed bin(17,0)          level 2 dcl 4-65 set ref 169*
n_valid                   6            based           fixed bin(21,0)          level 2 dcl 4-65 set ref 168* 308 314 317 320 324*
                                                                                  324 327 329 331* 376 378 530 532 704 704* 704*
                                                                                  707* 707 708 709 712 712* 712* 716 718* 718 974
needs_echo                      000210 automatic       bit(1)                   dcl 539 set ref 548* 554 567
network_type                           based           fixed bin(17,0)          level 2 dcl 3-21 ref 426 430 633 638 791 823 830 844
                                                                                  934 938
never_block                     000166 automatic       bit(1)                   dcl 412 set ref 414* 420* 430* 461
new_buf_size                    000106 automatic       fixed bin(21,0)          dcl 4-86 set ref 767* 768 769 770 771 771 773 774
                                                                                  774 778
new_control_buf                        based           structure                array level 1 packed packed unaligned dcl 4-95 set
                                                                                  ref 768 770*
new_control_buf_ptr             000112 automatic       pointer                  dcl 4-93 set ref 768* 770 771 779
new_data_buf                           based           structure                array level 1 packed packed unaligned dcl 4-90 set
                                                                                  ref 769 773*
new_data_buf_ptr                000110 automatic       pointer                  dcl 4-88 set ref 769* 773 774 780
null                                                   builtin function         dcl 150 ref 183
nvalid                                 parameter       fixed bin(21,0)          dcl 732 set ref 730 744 747 749 753* 753 756 759
only_echoed                     000206 automatic       bit(1)                   dcl 515 set ref 517* 523* 554 599
operation                 7            based           fixed bin(17,0)          level 2 dcl 2-22 ref 214 268 269 282 285
our_x                           000204 automatic       fixed bin(21,0)          dcl 510 set ref 528* 532 534 534 537 542 548 557 559
                                                                                  567 577* 577 585
pending                  36            based           structure                level 3 dcl 3-21
r_coords                               based           structure                level 1 dcl 2-34
rank                                                   builtin function         dcl 150 ref 542
rank_of_char                    000211 automatic       fixed bin(17,0)          dcl 540 set ref 542* 544 546
request_header                         based           structure                level 1 dcl 2-22
request_ptr                     000100 automatic       pointer                  dcl 2-19 set ref 191* 214 262 268 269 279 280 282
                                                                                  285 285 289 292 295 343* 563 573 582 582 595 595
                                                                                  631 791* 794 844* 923 963 973 975 975 981
request_read                           based           structure                level 1 dcl 2-101
request_read_status                    based           structure                level 1 dcl 2-93
returned_break_flag      16            based           bit(1)                   level 3 dcl 2-101 set ref 292 295* 563* 573* 963*
returned_length          15            based           fixed bin(21,0)          level 3 in structure "request_read" dcl 2-101
                                                                                  in procedure "tc_input" set ref 289* 582* 582 595*
                                                                                  595
returned_length          12            based           fixed bin(17,0)          level 3 in structure "request_read_status" dcl 2-93
                                                                                  in procedure "tc_input" set ref 973* 975* 975
row                     374            based           fixed bin(17,0)          level 4 dcl 3-21 set ref 857*
rtrim                                                  builtin function         dcl 150 ref 912 912
s_pos                           000150 automatic       fixed bin(21,0)          dcl 369 set ref 375* 376 378 378 382 391*
screen_data_ptr        1002            based           pointer                  level 2 dcl 3-21 set ref 857*
screen_left                     000222 automatic       fixed bin(17,0)          dcl 629 set ref 631* 633* 638* 642*
start                                  parameter       fixed bin(21,0)          dcl 683 ref 680 689 726
state                    34            based           structure                level 2 dcl 3-21
string                                                 builtin function         dcl 150 set ref 686* 692* 708* 975
substr                                                 builtin function         dcl 150 set ref 378 709* 726* 726 771* 771 774* 774
                                                                                  881*
tc_block                        000046 constant        entry                    external dcl 812 in procedure "close_out_echnego"
                                                                                  ref 844
tc_block                        000042 constant        entry                    external dcl 788 in procedure "block" ref 791
tc_break_array                         defined         bit(1)                   array packed unaligned dcl 3-52 ref 546 932
tc_data                                based           structure                level 1 dcl 3-21
tc_data_ptr                     000102 automatic       pointer                  dcl 3-20 set ref 160* 161 164 177* 178 183 187* 189
                                                                                  285 308 342* 344 346 349 359 359 426 426 426 430
                                                                                  430 430 434 434 438* 452 453 453 480 546 623 623
                                                                                  631 633 633 633 633 633 633 638 638 638 638 638
                                                                                  638 642 642 642 642 642 646* 653 726 791 791* 796
                                                                                  797 797 823 825 825 825 825 825 830 830 830 830
                                                                                  830 830 835 835 835 835 835 844 844* 857 857 857
                                                                                  857 859 859 866 881 899* 899 923 932 934 934 938
                                                                                  938 942 945* 981
tc_disconnect$check             000026 constant        entry                    external dcl 139 ref 438 646 945
tc_error                        000022 constant        entry                    external dcl 135 ref 485 912
tc_request$write_echo           000020 constant        entry                    external dcl 134 ref 899
tc_screen$text                  000024 constant        entry                    external dcl 137 ref 857
temp_data                              based           char                     packed unaligned dcl 4-98 set ref 771* 771 774* 774
terminal                 30            based           structure                level 2 dcl 3-21
terminal_state                         based           structure                level 1 dcl 3-54
the_char                               parameter       char(1)                  dcl 702 ref 698 709
to_echo                                defined         char                     packed unaligned dcl 896 set ref 899*
tty_handle                2            based           fixed bin(35,0)          level 2 dcl 3-21 set ref 426* 633* 825* 934*
tty_read_buffer         400            based           char(1024)               level 2 packed packed unaligned dcl 3-21 set ref
                                                                                  426* 430* 434* 633 633 633 633 638 638 638 638 642
                                                                                  642 642 642 726 825 825 825 825 830 830 830 830
                                                                                  835 835 835 835 857 857 881* 899 899
tty_state                       000115 automatic       fixed bin(17,0)          dcl 125 set ref 426* 430* 434* 633* 638* 642* 825*
                                                                                  830* 835* 934* 938* 942*
unspec                                                 builtin function         dcl 150 set ref 265* 374* 770* 773* 930*
v1_echo_neg_data                       based           structure                level 1 dcl 5-42
version                         000362 automatic       fixed bin(17,0)          level 2 dcl 928 set ref 931*
video_et_$tc_mark_missing       000032 external static fixed bin(35,0)          dcl 141 set ref 485*
video_et_$tc_tty_error          000030 external static fixed bin(35,0)          dcl 141 set ref 912*
write_buffer_count        7     000116 automatic       fixed bin(21,0)          level 2 dcl 193 set ref 881 882* 882 888* 894 896
write_sync_read          10(02) 000116 automatic       bit(1)                   level 3 packed packed unaligned dcl 193 set ref 268*
                                                                                  275
ws_tty_$order                   000054 constant        entry                    external dcl 920 ref 938
ws_tty_$read_echoed             000014 constant        entry                    external dcl 130 ref 638 830
ws_tty_$read_with_mark          000036 constant        entry                    external dcl 408 ref 430

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DELETED_CONTROL                        internal static bit(9)                   initial packed unaligned dcl 4-42
DSA_ATTENTION_MSG                      internal static fixed bin(8,0)           initial unsigned dcl 1-83
DSA_DATA_ATTENTION_MSG                 internal static fixed bin(8,0)           initial unsigned dcl 1-84
DSA_DATA_INPUT_MSG                     internal static fixed bin(8,0)           initial unsigned dcl 1-100
DSA_DATA_OUTPUT_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 1-101
DSA_DEMAND_RELEASE_SRU_MSG             internal static fixed bin(8,0)           initial unsigned dcl 1-85
DSA_DEMAND_TURN_ACK_MSG                internal static fixed bin(8,0)           initial unsigned dcl 1-87
DSA_DEMAND_TURN_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 1-86
DSA_ESTABLISHMENT_MSG                  internal static fixed bin(8,0)           initial unsigned dcl 1-97
DSA_MSG_TYPE_TO_PNAME                  internal static char(20)                 initial array packed unaligned dcl 1-103
DSA_PURGE_MSG                          internal static fixed bin(8,0)           initial unsigned dcl 1-88
DSA_RECOVER_ACK_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 1-90
DSA_RECOVER_MSG                        internal static fixed bin(8,0)           initial unsigned dcl 1-89
DSA_RELEASE_SRU_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 1-91
DSA_RESUME_ACK_MSG                     internal static fixed bin(8,0)           initial unsigned dcl 1-93
DSA_RESUME_MSG                         internal static fixed bin(8,0)           initial unsigned dcl 1-92
DSA_SUSPEND_ACK_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 1-95
DSA_SUSPEND_MSG                        internal static fixed bin(8,0)           initial unsigned dcl 1-94
DSA_TERMINATED_MSG                     internal static fixed bin(8,0)           initial unsigned dcl 1-98
DSA_TERM_ABNORMAL_MSG                  internal static fixed bin(8,0)           initial unsigned dcl 1-96
DSA_UNSPECIFIED_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 1-82
DSA_USER_UNASSIGN_MSG                  internal static fixed bin(8,0)           initial unsigned dcl 1-99
ECHO_NEG_BREAK_TABLE_SIZE              internal static fixed bin(17,0)          initial dcl 5-19
END_OF_INFO_CONTROL                    internal static bit(9)                   initial packed unaligned dcl 4-42
MAX_DSA_EVENT_MSG_TYPE                 internal static fixed bin(17,0)          initial dcl 1-80
MAX_MCS_EVENT_MSG_TYPE                 internal static fixed bin(17,0)          initial dcl 1-46
MCS_DIALOUT_MSG                        internal static fixed bin(17,0)          initial dcl 1-54
MCS_DIALUP_MSG                         internal static fixed bin(17,0)          initial dcl 1-50
MCS_HANGUP_MSG                         internal static fixed bin(17,0)          initial dcl 1-52
MCS_LINE_STATUS_MSG                    internal static fixed bin(17,0)          initial dcl 1-62
MCS_MASKED_MSG                         internal static fixed bin(17,0)          initial dcl 1-64
MCS_MSG_TYPE_TO_PNAME                  internal static char(20)                 initial array packed unaligned dcl 1-67
MCS_NETWORK_TYPE                       internal static fixed bin(4,0)           initial unsigned dcl 1-34
MCS_QUIT_MSG                           internal static fixed bin(17,0)          initial dcl 1-56
MCS_READ_MSG                           internal static fixed bin(17,0)          initial dcl 1-58
MCS_UNSPECIFIED_MSG                    internal static fixed bin(17,0)          initial dcl 1-48
MCS_WRITE_MSG                          internal static fixed bin(17,0)          initial dcl 1-60
NETWORK_TYPE_VALUES                    internal static varying char(8)          initial array dcl 1-38
NET_EVENT_MESSAGE_VERSION_1            internal static bit(2)                   initial packed unaligned dcl 1-20
OP_BELL                                internal static fixed bin(17,0)          initial dcl 2-86
OP_CLEAR_REGION                        internal static fixed bin(17,0)          initial dcl 2-41
OP_CLEAR_SCREEN_NO_OPT                 internal static fixed bin(17,0)          initial dcl 2-47
OP_DELETE_CHARS                        internal static fixed bin(17,0)          initial dcl 2-68
OP_ERROR                               internal static fixed bin(17,0)          initial dcl 2-38
OP_GET_CHARS_NO_ECHO                   internal static fixed bin(17,0)          initial dcl 2-88
OP_GET_CURSOR_POSITION                 internal static fixed bin(17,0)          initial dcl 2-118
OP_INSERT_TEXT                         internal static fixed bin(17,0)          initial dcl 2-58
OP_OVERWRITE_TEXT                      internal static fixed bin(17,0)          initial dcl 2-121
OP_POSITION_CURSOR                     internal static fixed bin(17,0)          initial dcl 2-39
OP_SCROLL_REGION                       internal static fixed bin(17,0)          initial dcl 2-76
OP_WRITE_RAW                           internal static fixed bin(17,0)          initial dcl 2-122
REQUEST_SENTINEL                       internal static char(4)                  initial dcl 2-20
data_bits                              based           structure                level 1 packed packed unaligned dcl 4-51
echo_neg_data                          based           structure                level 1 dcl 5-22
echo_neg_data_version_2                internal static fixed bin(17,0)          initial dcl 5-18
echo_neg_datap                         automatic       pointer                  dcl 5-17
hcs_$echo_negotiate_get_chars   000000 constant        entry                    external dcl 5-59
net_event_message                      based           structure                level 1 dcl 1-22
net_event_message_arg                  automatic       fixed bin(71,0)          dcl 1-19
request_buffer                         based           char                     packed unaligned dcl 2-116
request_clear_region                   based           structure                level 1 dcl 2-50
request_delete_chars                   based           structure                level 1 dcl 2-70
request_prompt                         based           char                     packed unaligned dcl 2-115
request_scroll_region                  based           structure                level 1 dcl 2-78
request_text                           based           structure                level 1 dcl 2-60
request_text_string                    based           char                     packed unaligned dcl 2-66
state_async_same_window                defined         bit(1)                   array packed unaligned dcl 3-79
state_have_sent_protocol               defined         bit(1)                   array packed unaligned dcl 3-82

NAMES DECLARED BY EXPLICIT CONTEXT.
ASYNC_INTERRUPTION              000473 constant        label                    dcl 952 ref 798
add_1_to_buffer                 001623 constant        entry                    internal dcl 698 ref 676
add_chars_to_buffer             001605 constant        entry                    internal dcl 680 ref 445 455 458 662 853 861
add_echoed_chars_to_buffer      001612 constant        entry                    internal dcl 689 ref 852
add_mark_to_buffer              001575 constant        entry                    internal dcl 671 ref 452 796
block                           002153 constant        entry                    internal dcl 785 ref 465 654
chars_common                    001616 constant        label                    dcl 694 ref 687
check_echnego                   000443 constant        entry                    external dcl 339
close_out_echnego               002214 constant        entry                    internal dcl 803 ref 346 657
common                          001663 constant        label                    dcl 712 in procedure "add_chars_to_buffer" ref 696
common                          001130 constant        label                    dcl 525 in procedure "try_to_satisfy" ref 518
do_input                        000155 constant        label                    dcl 187 ref 101
dump_echo_buffer                002523 constant        entry                    internal dcl 891 ref 587 599
echo_char                       002505 constant        entry                    internal dcl 872 ref 567
found_unechoed                  001341 constant        label                    dcl 595 ref 554
grow_buffer                     002060 constant        entry                    internal dcl 764 ref 329 756
init                            000050 constant        entry                    external dcl 154
init_echo_buffer                002517 constant        entry                    internal dcl 885 ref 525
mark_in_buffer                  000514 constant        entry                    internal dcl 362 ref 480
mark_outstanding                000504 constant        entry                    internal dcl 356 ref 266 485
push_buffer                     001746 constant        entry                    internal dcl 730 ref 704 712
read                            000615 constant        label                    dcl 422 ref 466
read_and_buffer                 001363 constant        entry                    internal dcl 605 ref 304
read_common                     000615 constant        label                    dcl 422 ref 415
read_status                     003050 constant        entry                    internal dcl 967 ref 216
read_to_mark                    000605 constant        entry                    internal dcl 398 ref 493 666
read_to_mark_no_block           000611 constant        entry                    internal dcl 417 ref 294 349 971
request_satisfied               000313 constant        label                    dcl 308 ref 262 296 964
retrieve_mark                   001055 constant        entry                    internal dcl 470 ref 275
set_break_table                 002631 constant        entry                    internal dcl 917 ref 285
shut                            000120 constant        entry                    external dcl 174
success                         001341 constant        label                    dcl 595 ref 564 574
tc_input                        000037 constant        entry                    external dcl 99
try_to_satisfy                  001120 constant        entry                    internal dcl 498 ref 295 303
try_to_satisfy$$already_echoed_only
                                001124 constant        entry                    internal dcl 520 ref 960
tty_read_error                  002553 constant        entry                    internal dcl 903 ref 440 648 947

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3512        3572    3225        3522
Length      4112    3225        60         303     265           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tc_input                            520 external procedure  is an external procedure.  
begin block on line 308                 begin block         shares stack frame of external procedure tc_input.  
mark_outstanding                        internal procedure  shares stack frame of external procedure tc_input.  
mark_in_buffer                          internal procedure  shares stack frame of external procedure tc_input.  
read_to_mark                            internal procedure  shares stack frame of external procedure tc_input.  
retrieve_mark                           internal procedure  shares stack frame of external procedure tc_input.  
try_to_satisfy                          internal procedure  shares stack frame of external procedure tc_input.  
begin block on line 537                 begin block         shares stack frame of external procedure tc_input.  
read_and_buffer                         internal procedure  shares stack frame of external procedure tc_input.  
add_mark_to_buffer                      internal procedure  shares stack frame of external procedure tc_input.  
add_chars_to_buffer                     internal procedure  shares stack frame of external procedure tc_input.  
begin block on line 720                 begin block         shares stack frame of external procedure tc_input.  
push_buffer                             internal procedure  shares stack frame of external procedure tc_input.  
grow_buffer                             internal procedure  shares stack frame of external procedure tc_input.  
block                                   internal procedure  shares stack frame of external procedure tc_input.  
close_out_echnego                       internal procedure  shares stack frame of external procedure tc_input.  
begin block on line 854                 begin block         shares stack frame of external procedure tc_input.  
echo_char                               internal procedure  shares stack frame of external procedure tc_input.  
begin block on line 894                 begin block         shares stack frame of external procedure tc_input.  
tty_read_error                          internal procedure  shares stack frame of external procedure tc_input.  
set_break_table                         internal procedure  shares stack frame of external procedure tc_input.  
begin block on line 952                 begin block         shares stack frame of external procedure tc_input.  
read_status                             internal procedure  shares stack frame of external procedure tc_input.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
tc_input                 000100 request_ptr                 tc_input
                         000102 tc_data_ptr                 tc_input
                         000104 input_buffer_ptr            tc_input
                         000106 new_buf_size                tc_input
                         000110 new_data_buf_ptr            tc_input
                         000112 new_control_buf_ptr         tc_input
                         000114 code                        tc_input
                         000115 tty_state                   tc_input
                         000116 i_op                        tc_input
                         000130 i                           begin block on line 308
                         000131 first_valid_x               begin block on line 308
                         000150 s_pos                       mark_in_buffer
                         000151 m_pos                       mark_in_buffer
                         000152 mark_ptr                    mark_in_buffer
                         000154 MARK                        mark_in_buffer
                         000164 mark_index                  read_to_mark
                         000165 n_chars_read                read_to_mark
                         000166 never_block                 read_to_mark
                         000204 our_x                       try_to_satisfy
                         000205 her_x                       try_to_satisfy
                         000206 only_echoed                 try_to_satisfy
                         000207 break_char                  begin block on line 537
                         000210 needs_echo                  begin block on line 537
                         000211 rank_of_char                begin block on line 537
                         000220 n_chars_read                read_and_buffer
                         000221 dummy                       read_and_buffer
                         000222 screen_left                 read_and_buffer
                         000240 ce                          add_chars_to_buffer
                         000241 istart                      add_chars_to_buffer
                         000242 cx                          begin block on line 720
                         000252 i                           push_buffer
                         000253 first_valid_x               push_buffer
                         000300 n_chars_read                close_out_echnego
                         000301 n_chars_echoed              close_out_echnego
                         000322 msg                         tty_read_error
                         000362 echh                        set_break_table
                         000374 dummy                       begin block on line 952
                         000404 bx                          read_status

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac
shorten_stack       ext_entry           alloc_storage       op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
add_char_offset_              convert_status_code_          dsa_tty_$order                dsa_tty_$read_echoed
dsa_tty_$read_with_mark       hcs_$tty_order                hcs_$tty_read_echoed          hcs_$tty_read_with_mark
tc_block                      tc_block                      tc_disconnect$check           tc_error
tc_request$write_echo         tc_screen$text                ws_tty_$order                 ws_tty_$read_echoed
ws_tty_$read_with_mark

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$echnego_awaiting_stop_sync                     video_et_$tc_mark_missing     video_et_$tc_tty_error




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     99 000033       101 000044       154 000045       160 000055       161 000061       163 000063       164 000067
    165 000071       166 000073       167 000103       168 000112       169 000113       170 000114       171 000115
    174 000116       177 000125       178 000131       180 000133       181 000140       182 000147       183 000151
    184 000154       187 000155       189 000161       190 000163       191 000164       214 000167       216 000172
    217 000173       262 000174       265 000176       266 000201       268 000211       269 000221       271 000227
    275 000231       279 000235       280 000241       282 000245       285 000252       289 000262       290 000264
    292 000267       294 000272       295 000274       296 000303       303 000304       304 000311       305 000312
    308 000313       314 000322       315 000342       317 000344       320 000352       321 000361       322 000377
    323 000415       324 000417       325 000424       327 000425       329 000427       331 000435       335 000436
    339 000437       342 000450       343 000454       344 000457       346 000461       349 000466       352 000472
    960 000473       963 000500       964 000502       985 000503       356 000504       359 000506       362 000514
    374 000516       375 000520       376 000522       378 000526       379 000544       382 000550       384 000553
    385 000560       387 000570       388 000573       391 000576       392 000601       394 000602       398 000605
    414 000607       415 000610       417 000611       420 000613       422 000615       426 000616       430 000656
    434 000722       438 000756       440 000771       443 000775       445 000777       452 001010       453 001017
    455 001022       456 001030       458 001031       461 001040       465 001044       466 001053       468 001054
    470 001055       480 001056       485 001072       493 001114       494 001116       495 001117       498 001120
    517 001122       518 001123       520 001124       523 001126       525 001130       527 001131       528 001133
    530 001135       532 001143       534 001150       537 001163       542 001167       544 001177       546 001204
    548 001212       554 001227       557 001236       558 001244       559 001245       561 001251       563 001253
    564 001256       567 001257       570 001272       573 001276       574 001300       577 001301       578 001302
    582 001303       583 001307       584 001326       585 001330       586 001332       587 001335       588 001336
    595 001341       598 001346       599 001354       601 001357       605 001363       621 001364       623 001367
    631 001372       633 001402       638 001442       642 001501       646 001535       648 001550       651 001554
    653 001556       654 001561       657 001563       659 001564       662 001565       663 001571       666 001572
    668 001574       671 001575       676 001577       677 001604       680 001605       686 001607       687 001611
    689 001612       692 001614       694 001616       696 001622       698 001623       704 001625       707 001642
    708 001644       709 001654       710 001662       712 001663       716 001677       718 001703       722 001706
    723 001717       724 001726       726 001730       727 001745       730 001746       744 001750       745 001766
    747 001770       749 001776       750 002005       751 002023       752 002041       753 002043       754 002050
    756 002051       759 002054       764 002060       767 002061       768 002064       769 002074       770 002102
    771 002107       773 002115       774 002122       776 002127       777 002135       778 002143       779 002145
    780 002150       782 002152       785 002153       791 002155       794 002174       796 002200       797 002207
    798 002212       801 002213       803 002214       817 002215       818 002220       823 002224       825 002227
    827 002265       828 002266       830 002267       835 002330       844 002366       847 002407       850 002411
    852 002413       853 002417       855 002427       857 002431       859 002466       860 002471       861 002472
    864 002500       866 002501       867 002504       872 002505       881 002507       882 002515       883 002516
    885 002517       888 002520       889 002522       891 002523       894 002524       896 002527       899 002532
    901 002552       903 002553       910 002555       912 002572       914 002627       917 002631       923 002632
    930 002637       931 002642       932 002644       934 002661       938 002725       942 002770       945 003030
    947 003043       950 003047       967 003050       971 003051       973 003053       974 003055       975 003065
    977 003076       981 003100       982 003104


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
