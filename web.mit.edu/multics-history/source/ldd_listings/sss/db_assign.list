	COMPILATION LISTING OF SEGMENT db_assign
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1820.8 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 db_assign: proc (il, lin, ill, data_ptr, sntp, db_mc_ptr, old_type, a_cur_size, a_old_size, print_mode, dec_default);
       12 
  1     1 /*	BEGIN INCLUDE FILE . . .  db_ext_stat_.incl.pl1
  1     2*   *
  1     3*   *	This include file is used to reference the common data  that is passed from the
  1     4*   *	main debug procedure  "debug" to other debug procedures.  This data is in db_ext_stat_.alm
  1     5*   *
  1     6*   *	modified 7/75 by S.E. Barr for the break instructions
  1     7**/
  1     8 
  1     9 dcl 1 db_ext_stat_$db_ext_stat_ ext static aligned,
  1    10 
  1    11     2 debug_input char (32) aligned,			/* Input switch name.  Initially "user_input" */
  1    12     2 debug_output char (32) aligned,			/* output switch name.  Initially "user_output" */
  1    13     2 return_label label,				/* The label used to do a non local goto out of debug when
  1    14*						   it was entered via a fault.  It will go to debug in
  1    15*						   another frame.  */
  1    16 
  1    17     2 debug_io_ptr (2) ptr,				/* pointers to iocb for i/o
  1    18*						   1 = input switch iocb ptr
  1    19*						   2 = output switch iocb ptr      */
  1    20     2 flags aligned,
  1    21       3 debug_io_attach (2) bit (1) unaligned,		/* 1= debug made the attachment */
  1    22       3 debug_io_open (2) bit (1) unaligned,		/* 1 = debug opened the switch */
  1    23       3 in_debug bit (1) unaligned,			/* Switch for the any_other condition.  0 = send the
  1    24*						   condition on;  1 = use the debug condition handler */
  1    25       3 static_handler_call bit (1) unal,		/* ON if mme2 call from static handler */
  1    26       3 pad bit (30) unaligned;			/* Reserved for future use */
  1    27 dcl  db_ext_stat_$break_instructions (9) bit (36) ext static aligned;
  1    28 
  1    29 /*	END OF INCLUDE FILE  ... db_ext_stat_.incl.pl1  */
       13 
       14 
       15 dcl  db_mc_ptr ptr;
       16 dcl  il char (132) aligned,
       17     (lin, ill) fixed bin,
       18      print_mode fixed bin,
       19      data_ptr ptr;
       20 
       21 dcl  a_cur_size fixed bin;
       22 dcl  cur_size fixed bin;
       23 dcl  a_old_size fixed bin;
       24 dcl  old_type fixed bin;
       25 dcl  old_size fixed bin;
       26 dcl  new_size fixed bin;
       27 dcl  last_char fixed bin;				/* ill -1 (line ends with new_line) */
       28 
       29 dcl
       30      com_err_ entry options (variable),
       31      cu_$level_get entry returns (fixed bin),
       32      db_get_count ext entry (char (132) aligned, fixed bin, fixed bin) returns (fixed bin),
       33      db_get_count$dec ext entry (char (132) aligned, fixed bin, fixed bin) returns (fixed bin),
       34      db_regs$get ext entry (ptr, char (4), bit (72), fixed bin),
       35      db_sym ext entry (char (72) var, ptr, ptr, fixed bin, fixed bin, char (1) aligned,
       36      char (*) aligned, fixed bin, fixed bin, fixed bin),
       37      print_text_$format ext entry (ptr, char (*) var),
       38      hcs_$add_acl_entries entry (char (*) aligned, char (*) aligned, ptr, fixed bin, fixed bin (35)),
       39      hcs_$delete_acl_entries entry (char (*)aligned, char (*)aligned, ptr, fixed, fixed bin (35)),
       40      get_group_id_ entry returns (char (32) aligned),
       41      hcs_$fs_get_mode ext entry (ptr, fixed bin (5), fixed bin (35)),
       42      ioa_$ioa_stream ext entry options (variable),
       43      db_parse_arg ext entry (char (132) aligned, fixed bin, fixed bin, ptr, fixed bin, fixed bin);
       44 
       45 dcl  fix_bit entry (bit (*) aligned, fixed bin) returns (fixed bin);
       46 dcl  fix_bit$double entry (bit (*) aligned, fixed bin) returns (fixed bin (71));
       47 
       48 dcl
       49      access_ok fixed bin (1),
       50      base fixed bin,
       51      code fixed bin,
       52      code35 fixed bin (35),
       53      emode fixed bin (5),
       54      off fixed bin,
       55      offset fixed bin,
       56      op fixed bin,
       57      rb (0:2) fixed bin,
       58      rep_count fixed bin,
       59      size fixed bin,
       60      max_size fixed bin,
       61      tag fixed bin,
       62      type fixed bin,
       63     (i, j, k) fixed bin;
       64 dcl  index_start_no fixed bin;			/* index in il of the beginning of a type 1 no. string */
       65 
       66 dcl 1 delete_acl aligned,
       67     2 access_name char (32),
       68     2 status_code fixed bin (35);
       69 dcl 1 segment_acl aligned,
       70     2 access_name char (32),
       71     2 modes bit (36) init ("111000000000000000000000000000000000"b),
       72     2 zero_pad bit (36) init ("0"b),
       73     2 status_code fixed bin (35);
       74 
       75 dcl (old_sign, new_sign) fixed bin;
       76 
       77 dcl  pad_bits fixed bin;
       78 dcl  off_inc fixed bin;
       79 dcl (old_bit_off, new_bit_off) fixed bin;
       80 
       81 dcl  fword fixed bin based;
       82 
       83 dcl  flword float bin based;
       84 
       85 dcl  two_words bit (72) based;
       86 
       87 dcl  words (2) bit (36) aligned based;
       88 
       89 dcl  tw_flag fixed bin init (0);
       90 
       91 dcl  reg_name char (4);
       92 
       93 dcl  len_ptr ptr;
       94 
       95 dcl  dp ptr,
       96      tp ptr,
       97      tem (17) ptr,
       98      temp ptr,
       99 
      100      bptr ptr based;
      101 dcl  packed_ptr ptr unal based;
      102 
      103 dcl (old_ptr, new_ptr) ptr;
      104 dcl  ones bit (72) int static init ((72)"1"b);
      105 
      106 dcl  TOO_BIG fixed bin int static init(1);
      107 dcl  BAD_SYNTAX fixed bin int static init(2);
      108 dcl  MISS_PAREN fixed bin int static init(3);
      109 dcl  BAD_PR fixed bin int static init(4);
      110 dcl  NO_REG fixed bin int static init(5);
      111 dcl  NO_SYM fixed bin int static init(6);
      112 dcl  OPCODE fixed bin int static init(7);
      113 dcl  TAG fixed bin int static init(8);
      114 dcl  SYNTAX fixed bin int static init(9);
      115 dcl  BAD_REP fixed bin int static init(10);
      116 dcl  mess (10) char(40) var int static init (
      117 	"Value too large",				/* TOO_BIG */
      118 	"Bad syntax in instruction input",
      119 	"Missing "")""",
      120 	"Invalid pointer register",
      121 	"Register name missing",
      122 	"Variable not defined",
      123 	"Bad opcode",
      124 	"Bad tag",
      125 	"Syntax error scanning input",
      126 	"Illegal repetition factor");
      127 dcl  sign_bit bit (1) unal based;
      128 dcl  dec_default bit (1) unal;			/* 1 = decimal default
      129*						   0 = octal default ( registers, temporaries ) */
      130 
      131 dcl (old_word, new_word) bit (36) aligned;
      132 dcl (old_double, new_double) fixed bin (71);
      133 
      134 dcl  control char (8) aligned;			/* variable ioa_ control string */
      135 
      136 dcl  mode char (1) aligned,
      137      old_str char (old_size) based (dp),
      138      str char (size) based (tp),
      139      repstr char (size*rep_count) based,
      140      old_bits bit (old_size) based (dp),
      141      new_bits bit (size) based (tp),
      142      chars (0:10000) char (1) unal based,
      143      bitarr (0:10000) bit (1) unal based,
      144      sym_name char (72) aligned,
      145      opcode6 char (6) aligned,
      146      c2 char (2) aligned,
      147      c4 char (4) aligned,
      148     (name1, name2) char (72) var,
      149      db_sym_name char (72) var,
      150     (type_char, mode_char) char (1) aligned;
      151 
      152 /*	The following declaration is included(temporarily) to allow
      153*   *	the use of the old-style names of the pointer registers.
      154**/
      155 
      156 dcl  old_pr_names (0:7) char (2) int static init
      157     ("ap", "ab", "bp", "bb", "lp", "lb", "sp", "sb");
      158 
      159 dcl  conversion condition;
      160 dcl  underflow condition;
      161 
      162 
      163 dcl  ffdouble fixed bin (71) based;			/* used for printing double words in ^d */
      164 dcl 1 ff aligned based,
      165     2 (w0, w1, w2, w3, w4, w5, w6, w7) fixed bin;
      166 
      167 dcl (addr, addrel, bit, char, fixed, index, max, min, mod, null, substr, unspec, rel) builtin;
      168 dcl (abs, binary, divide, search, verify) builtin;
      169 						/*  */
  2     1 /*	BEGIN  INCLUDE  FILE ...  db_snt.incl.pl1  Last modified  Nov 1972.  WSS  */
  2     2 /*	Modified 8/75 to add internal static pointer by S.E. Barr */
  2     3 
  2     4 
  2     5 /*	Overlay of  segment name table.  */
  2     6 
  2     7 dcl	sntp	ptr;		/* Pointer to segment name table. */
  2     8 
  2     9 dcl     1	snt	based (sntp)  aligned,
  2    10 	2  ent_pt_name char(32),	/* Entry point name. */
  2    11 	2  ent_name    char(32),	/* Entry name of segment. */
  2    12 	2  dir_name    char(168),	/* Directory name. */
  2    13 	2  pp	     ptr,		/* Pointer to current procedure. */
  2    14 	2  sp          ptr,		/* Pointer to current stack frame. */
  2    15 	2  lp          ptr,		/* Pointer to linkage section. */
  2    16 	2  symp        ptr,		/* Pointer to current symbol table block. */
  2    17 	2  symflag     bit(1) unal,	/* ON => no symbol table defined. */
  2    18 	2  std	     bit(1) unal,	/* ON => standard symbol header.  */
  2    19 	2  headp	     ptr,		/* Pointer to current symbol header. */
  2    20 	2  static_ptr  ptr;		/* Pointer to current static section. */
  2    21 
  2    22 /*	END OF INCLUDE FILE...  db_snt.incl.pl1  */
      170 
      171 /*  */
  3     1 /*	BEGIN INCLUDE FILE ... db_inst.incl.pl1  Last modified Nov 72 - WSS. */
  3     2 
  3     3 
  3     4 /*	PL/I  definitions of an instruction word.  There are two definitions.
  3     5**	One defines a full 18 bit offset field (now meaningful with 256K segments)
  3     6**	and the other defines an instruction with a pointer register field and a
  3     7**	15 bit offset field.
  3     8**/
  3     9 
  3    10 dcl	ilc_ptr	  ptr;			/* Pointer to the instruction word. */
  3    11 
  3    12 
  3    13 dcl     1	instr	  based (ilc_ptr)  	aligned,	
  3    14          (2  offset	  fixed bin (17),		/* Full 18 bit offset.  No pr field. */
  3    15 	2  opcode	  bit (10),		/* Instruction opcode. */
  3    16 	2  inhibit  bit (1),		/* ON => interrupts inhibitted. */
  3    17 	2  pr_bit	  bit (1),		/* ON => instruction has  pr  field. */
  3    18 	2  tag	  bit (6))  unaligned;	/* Tag field. */
  3    19 
  3    20 
  3    21 dcl     1	instr_pr	  based (ilc_ptr)  	aligned,	
  3    22          (2  pr	  bit (3),		/* Pointer register field. */
  3    23 	2  offset	  fixed bin (14),		/* 15 bit offset due to pr field. */
  3    24 	2  pad	  bit (18))  unaligned;
  3    25 
  3    26 
  3    27 /*	END OF INCLUDE FILE ... db_inst.incl.pl1	*/
      172 
      173 /*  */
  4     1 /* BEGIN INCLUDE FILE its.incl.pl1
  4     2*   modified 27 July 79 by JRDavis to add its_unsigned
  4     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  4     4 
  4     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  4     6     2 pad1 bit (3) unaligned,
  4     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  4     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  4     9     2 pad2 bit (9) unaligned,
  4    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  4    11 
  4    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  4    13     2 pad3 bit (3) unaligned,
  4    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  4    15     2 pad4 bit (3) unaligned,
  4    16     2 mod bit (6) unaligned;				/* further modification */
  4    17 
  4    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  4    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  4    20     2 pad1 bit (27) unaligned,
  4    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  4    22 
  4    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  4    24     2 pad2 bit (3) unaligned,
  4    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  4    26     2 pad3 bit (3) unaligned,
  4    27     2 mod bit (6) unaligned;				/* further modification */
  4    28 
  4    29 
  4    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  4    31     2 pad1 bit (3) unaligned,
  4    32     2 segno fixed bin (15) unsigned unaligned,
  4    33     2 ringno fixed bin (3) unsigned unaligned,
  4    34     2 pad2 bit (9) unaligned,
  4    35     2 its_mod bit (6) unaligned,
  4    36 
  4    37     2 offset fixed bin (18) unsigned unaligned,
  4    38     2 pad3 bit (3) unaligned,
  4    39     2 bit_offset fixed bin (6) unsigned unaligned,
  4    40     2 pad4 bit (3) unaligned,
  4    41     2 mod bit (6) unaligned;
  4    42 
  4    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  4    44     2 pr_no fixed bin (3) unsigned unaligned,
  4    45     2 pad1 bit (27) unaligned,
  4    46     2 itp_mod bit (6) unaligned,
  4    47 
  4    48     2 offset fixed bin (18) unsigned unaligned,
  4    49     2 pad2 bit (3) unaligned,
  4    50     2 bit_offset fixed bin (6) unsigned unaligned,
  4    51     2 pad3 bit (3) unaligned,
  4    52     2 mod bit (6) unaligned;
  4    53 
  4    54 
  4    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  4    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  4    57 
  4    58 /* END INCLUDE FILE   its.incl.pl1 */
      174 
      175 /*  */
      176 
      177 
      178 dcl 1 op_mnemonic_$op_mnemonic (0:1023) ext static aligned,
      179     2 opcode char (6) unal,
      180     2 dtype fixed bin (2) unal,			/* 0 - desc9a, 1 - descb, 2 - decimal */
      181 
      182     2 num_desc fixed bin (5) unal,
      183     2 num_words fixed bin (8) unal;
      184 
  5     1 /*	BEGIN INCLUDE FILE ... db_data_map.incl.pl 1   Last modified Nov 72  for  6180  - WSS. */
  5     2 
  5     3 
  5     4 /*	Below are references to the tables found in  db_data.alm.   These are the
  5     5**	PL/I  definitions of these tables.
  5     6**/
  5     7 
  5     8 dcl	db_data$n_regs		fixed bin	external;
  5     9 
  5    10 dcl	db_data$names(0:31)		char (4)	aligned	external;
  5    11 
  5    12 dcl	db_data$tags(0:63)		char (4)	aligned	external;
  5    13 
  5    14 dcl	db_data$fault_names (0:31)	char (20)	aligned	external;
  5    15 
  5    16 dcl	db_data$acv_names (16)	char (24)	aligned	external;
  5    17 
  5    18 dcl	db_data$ipr_names (7)	char (24)	aligned	external;
  5    19 
  5    20 
  5    21 
  5    22 
  5    23 /*	END OF INCLUDE FILE ... db_data_map.incl.pl1   */
      185 
      186 /*  */
      187 
      188 	temp = addr (tem);				/* get pointer to temporary storage */
      189 	dp = data_ptr;				/* get pointer to first word to change */
      190 	cur_size = a_cur_size;
      191 	old_size = a_old_size;
      192 
      193 
      194 /*  If the user does not have w access on the segment, try to add w user.proj.tag  */
      195 
      196 	call hcs_$fs_get_mode (dp, emode, code35);	/* see if the user has write permit on the segment */
      197 	if code35 = 0 then do;
      198 	     if bit (emode, 5) & "00010"b then access_ok = 1; /* if write permit is there, OK */
      199 	     else do;
      200 		access_ok = 0;			/* hasn't got write permit, change the access */
      201 		segment_acl.access_name = get_group_id_ ();
      202 		call hcs_$add_acl_entries (snt.dir_name, snt.ent_name, addr (segment_acl), 1, code35);
      203 	     end;
      204 	end;
      205 	if code35 ^= 0 then do;			/* Can't get write access on segment */
      206 	     call com_err_ (code35, "debug", "Cannot change ^p", dp);
      207 	     return;
      208 	end;
      209 
      210 	if print_mode ^= 0 then
      211 	     call ioa_$ioa_stream (debug_output, "Changing ^p", dp); /* print out location changings */
      212 
      213 	last_char = ill -1;
      214 	do while (get_char (lin));
      215 
      216 	     rep_count = 1;
      217 
      218 	     if mode = "(" then call get_rep_count (rep_count);
      219 	     if mode = "(" then call get_instruction;	/* instruction format  (opcode) */
      220 	     else if mode = "$" then do;		/* register being used as value */
      221 		dec_default = "0"b;
      222 		i = search (substr (il, lin, ill-lin+1), " ;");
      223 		if i = 0 then i = ill;
      224 		else i = lin + i -1;
      225 		if i-lin-1 < 1 then call error (NO_REG, "");
      226 		sym_name = substr (il, lin+1, i-lin-1); /* copy register name into temporary */
      227 		lin = i;
      228 		reg_name = substr (sym_name, 1, 4);
      229 		type = 1;
      230 		size = 36;
      231 		call db_regs$get (db_mc_ptr, reg_name, temp -> two_words, print_mode);
      232 		if reg_name = "aq" then size = 72;
      233 		do i = 0 to 7;
      234 		     if reg_name = db_data$names (i) then do;
      235 			size = 72;
      236 			type = 13;
      237 		     end;
      238 		end;
      239 		if size ^= 72 then tp = addrel (temp, 1);
      240 		else tp = temp;
      241 
      242 		call store_value;
      243 
      244 	     end;
      245 
      246 	     else do;				/* call db_parse_arg to pick off the other types */
      247 		index_start_no = lin;		/* patch for octal default */
      248 		type = 0;
      249 		if ^dec_default then do;
      250 		     temp -> fword = db_get_count (il, lin, i);
      251 		     if i > lin then if index (", ;
      252 ", substr (il, i, 1)) ^= 0 then do;
      253 			     type = 1;
      254 			     lin = i;
      255 			end;
      256 		end;
      257 
      258 		if type = 0 then call db_parse_arg (il, lin, ill, temp, type, size); /* scan for next item */
      259 		tp = temp;
      260 
      261 		if type = -1 then goto reset;		/* goto reset if ";", etc. */
      262 
      263 		if type = 1 | type = 3 then size = 36;	/* arithmetic type s go in fullword */
      264 		if type = 13 then size = 72;		/* pointer on double-word */
      265 
      266 		if type = 0 then do;		/* a variable as input parameter */
      267 		     db_sym_name = str;		/* copy variable name into temporary */
      268 		     call db_sym (db_sym_name, sntp, tp, offset, type, type_char, mode_char, size, max_size, code);
      269 		     if code ^= 0 then call error (NO_SYM, (name1));
      270 		end;
      271 
      272 		call store_value;
      273 
      274 	     end;
      275 	end;
      276 
      277 reset:
      278 	if access_ok = 0 then call hcs_$delete_acl_entries (snt.dir_name, snt.ent_name, addr (segment_acl), 1, code35);
      279 	return;
      280 
      281 
      282 /*  */
      283 bump:	proc;
      284 
      285 /*	This internal procedure is used to bump the data pointer
      286*   *	to the next item after the one just assigned to.
      287**/
      288 
      289 	     off_inc = divide (old_size, 36, 17, 0);
      290 	     old_bit_off = fixed  (addr (dp) -> its.bit_offset, 6);
      291 
      292 	     new_bit_off = old_bit_off + mod (old_size, 36);
      293 	     if new_bit_off > 36 then do;		/* into next word */
      294 		new_bit_off = new_bit_off - 36;
      295 		off_inc = off_inc + 1;		/* must bump word offset */
      296 	     end;
      297 
      298 	     dp = addrel (dp, off_inc);		/* this will set bit offset */
      299 						/* to zero, so we may have  */
      300 	     if new_bit_off ^= 0 then			/* to set it again */
      301 		addr (dp) -> its.bit_offset = bit (fixed (new_bit_off, 6), 6);
      302 
      303 	     rep_count = rep_count - 1;
      304 	     return;
      305 	end bump;
      306 
      307 
      308 
      309 
      310 
      311 /*  This procedure is an error exit from db_assign.  It prints an error message and goes to reset. */
      312 
      313 error:	proc (mess_code, illegal_string);
      314 
      315 dcl  mess_code fixed bin;				/* error codes for db_assign */
      316 dcl  illegal_string char (*) aligned;			/* offending character or string */
      317 
      318 	     call ioa_$ioa_stream (debug_output, "^a  ^a", mess (mess_code), illegal_string);
      319 	     goto reset;
      320 
      321 	end error;
      322 
      323 
      324 
      325 /*  This procedure looks for a non_blank character and sets mode to it.  If mode is ";" or there
      326*    are no more characters left in the line, then get_char returns "0"b.  Otherwise
      327*   it returns "1"b (for found next character).
      328**/
      329 
      330 get_char:	proc (index) returns (bit (1));
      331 
      332 dcl  index fixed bin;
      333 dcl  i fixed;
      334 
      335 	     lin = index;
      336 	     if lin <= last_char then do;
      337 		i = verify (substr (il, lin, last_char - lin + 1), " ");
      338 		if i > 0 then do;
      339 		     lin = lin + i -1;
      340 		     mode = substr (il, lin, 1);
      341 		     if mode ^= ";" then return ("1"b);
      342 		end;
      343 		else lin = last_char + 1;
      344 	     end;
      345 
      346 	     return ("0"b);
      347 
      348 	end get_char;
      349 
      350 	
      351 
      352 /*  This procedure attempts to parse an instruction of the form:
      353*
      354*	( opcode base|offset,tag )
      355*
      356**/
      357 
      358 get_instruction: proc;
      359 
      360 	     if ^get_char (lin + 1) then call error (MISS_PAREN,  "");
      361 	     j = search (substr (il, lin, last_char - lin + 1), " )"); /* blank or ) follows opcode */
      362 	     if j = 0 then call error (MISS_PAREN,  "");
      363 	     opcode6 = substr (il, lin, j -1);		/* copy opcode name */
      364 	     lin = lin + j -1;
      365 	     op = -1;
      366 	     do i = 0 to 1023 while (op = -1);		/* search for the opcode */
      367 		if opcode6 = op_mnemonic_$op_mnemonic (i).opcode then op = i;
      368 	     end;
      369 	     if op = -1 then call error (OPCODE, opcode6);
      370 
      371 	     if ^get_char (lin) then call error (SYNTAX, "");
      372 	     base = -1;				/* -1 indicates no pr specified */
      373 
      374 	     if substr (il, lin+3, 1) = "|" then do;	/* standard pointer register prN|NN */
      375 		if substr (il, lin, 2) ^= "pr" then call error (BAD_PR, "");
      376 		lin = lin + 2;
      377 		base = index ("01234567", substr (il, lin, 1)) -1;
      378 		if base = -1 then call error (BAD_PR, "");
      379 		lin = lin + 2;
      380 	     end;
      381 
      382 	     else if substr (il, lin+2, 1) = "|" then do; /*  old-style pointer pp|NN */
      383 		c2 = substr (il, lin, 2);		/* copy it for compare */
      384 		lin = lin + 3;			/* increment index */
      385 		base = -1;
      386 		do i = 0 to 7 while (base = -1);	/* search for the base name */
      387 		     if c2 = old_pr_names (i) then base = i;
      388 		end;
      389 		if base = -1 then call error (BAD_PR, "");
      390 	     end;
      391 
      392 	     j = lin;				/* check for number */
      393 	     off = db_get_count (il, lin, lin);		/* pick up the offset specified by the user */
      394 	     if j = lin then if substr (il, lin, 1) = ")" then off = 0; /* not a number */
      395 		else call error (SYNTAX, "");
      396 	     tag = 0;				/* indicates tag not yet specified */
      397 	     if substr (il, lin, 1) = "," then do;	/* a tag was specified */
      398 		j = index (substr (il, lin+1, 4), ")"); /* find location of the ")" */
      399 		if j = 0 then call error (MISS_PAREN,  "");	/* error condition */
      400 		c4 = substr (il, lin, j);		/* pick up the tag field */
      401 		lin = lin+j+1;			/* skip over rest of instruction input */
      402 
      403 		tag = -1;
      404 		do i = 0 to 63 while (tag = -1);
      405 		     if db_data$tags (i) = c4 then tag = i;
      406 		end;
      407 		if tag = -1 then call error (TAG, c4);
      408 	     end;
      409 	     else do;
      410 		if ^get_char (lin) then call error (MISS_PAREN, "");
      411 		if mode ^= ")" then call error (SYNTAX, "");
      412 		lin = lin + 1;
      413 	     end;
      414 
      415 	     do rep_count = rep_count to 1 by -1;
      416 		if print_mode ^= 0 then
      417 		     call print_text_$format (dp, name1);
      418 		k = dp -> ff.w0;			/* save the old value */
      419 		if base = -1 then do;		/* a base was never spec ified */
      420 		     dp -> instr.offset = off;	/* copy full offset into instruction */
      421 		     dp -> instr.pr_bit = "0"b;	/* make sure don't use base */
      422 		end;
      423 		else do;
      424 		     dp -> instr_pr.pr = bit (fixed (base, 3)); /* copy base into instruction */
      425 		     dp -> instr_pr.offset = off;	/* copy offset */
      426 		     dp -> instr.pr_bit = "1"b;	/* turn on bit 29 */
      427 		end;
      428 		dp -> instr.opcode = bit (fixed (op, 10)); /* fill in opcode */
      429 		dp -> instr.tag = bit (fixed (tag, 6)); /* fill in tag */
      430 		dp -> instr.inhibit = "0"b;
      431 		i = dp -> ff.w0;			/* get new value */
      432 		if print_mode ^= 0 then do;
      433 		     call print_text_$format (dp, name2);
      434 		     call ioa_$ioa_stream (debug_output, "^a^/to^/^a", name1, name2);
      435 		end;
      436 		dp = addrel (dp, 1);
      437 	     end;
      438 
      439 	     return;
      440 
      441 	end get_instruction;
      442 
      443 
      444 
      445 
      446 
      447 /*  This procedure has a value and stores it at the location given with dp.  Rep_count  is the number of
      448*    times to repeat a given value.
      449**/
      450 
      451 store_value: proc;
      452 
      453 	     len_ptr = null;
      454 	     if old_type = 0 then cur_size, old_size = size;
      455 	     else if cur_size < old_size then len_ptr = addrel (dp, -1);
      456 	     if type <= 4 then do;
      457 
      458 						/* for arithmetic values, if not a variable specified on left, just fill in rest of word */
      459 		if old_type = 0 then old_size = 36 - fixed (addr (dp) -> its.bit_offset, 6);
      460 	     end;
      461 
      462 	     if type = 21 then do;			/* character string */
      463 		if old_type ^= 21 & old_type ^= 0 then do;
      464 		     old_size = divide (old_size, 9, 17, 0); /* convert size from bits to chars */
      465 		     cur_size = divide (cur_size, 9, 17, 0);
      466 		end;
      467 		if old_size <= 0 then call error (TOO_BIG, "");
      468 		size = min (old_size, size);
      469 		new_size = rep_count*size;
      470 		if print_mode ^= 0 then do;
      471 		     if rep_count > 1 then call ioa_$ioa_stream (debug_output, """^a"" to (^d)""^a""", substr (dp -> repstr, 1, new_size), rep_count, str);
      472 		     else call ioa_$ioa_stream (debug_output, """^a"" to ""^a""", substr (dp -> old_str, 1, cur_size), str);
      473 		end;
      474 		do rep_count = rep_count to 1 by -1;
      475 		     old_str = str;
      476 		     dp = addr (dp -> chars (size));
      477 		end;
      478 		if len_ptr ^= null then do;		/* if a varying string, update length */
      479 		     len_ptr -> fword = min (new_size, old_size);
      480 		     cur_size = old_size;		/* so we won't do it again */
      481 		end;
      482 		rep_count = 1;
      483 	     end;
      484 
      485 	     else if type = 19 then do;		/* bit string */
      486 		if old_type = 21 then do;		/* if char string, convert size to bits */
      487 		     old_size = 9*old_size;
      488 		     cur_size = 9*cur_size;
      489 		end;
      490 		size = min (old_size, size);		/* bit string */
      491 		new_size = rep_count*size;
      492 
      493 		do rep_count = rep_count to 1 by -1;
      494 		     if print_mode ^= 0 then
      495 			call ioa_$ioa_stream (debug_output, """^a""b to ""^a""b", char (substr (dp -> old_bits, 1, cur_size)),
      496 			char (tp -> new_bits));
      497 		     dp -> old_bits = new_bits;
      498 		     dp = addr (dp -> bitarr (size));
      499 		end;
      500 		if len_ptr ^= null then do;
      501 		     len_ptr -> fword = min (new_size, old_size);
      502 		     cur_size = old_size;
      503 		end;
      504 	     end;
      505 
      506 	     else if type = 13 then do while (rep_count > 0); /* pointer */
      507 		if old_type = 0 then dp = addrel (dp, 0); /* eliminate bit offset if not var. */
      508 		if old_size < 36 then call error (TOO_BIG, "");
      509 		if old_size < 72 then do;		/* into packed ptr */
      510 		     unspec (old_ptr) = unspec (dp -> packed_ptr);
      511 		     if size = 36 then
      512 			unspec (new_ptr), unspec (dp -> packed_ptr) = unspec (tp -> packed_ptr);
      513 		     else unspec (new_ptr), unspec (dp -> packed_ptr) = unspec (tp -> bptr);
      514 		end;
      515 		else do;
      516 		     unspec (old_ptr) = unspec (dp -> bptr);
      517 		     if size = 36 then
      518 			unspec (new_ptr), unspec (dp -> bptr) = unspec (tp -> packed_ptr);
      519 		     else unspec (new_ptr), unspec (dp -> bptr) = unspec (tp -> bptr);
      520 		end;
      521 
      522 		if print_mode ^= 0 then
      523 		     call ioa_$ioa_stream (debug_output, "^p to ^p", old_ptr, new_ptr);
      524 		call bump;
      525 	     end;
      526 
      527 	     else if type = 14 then do while (rep_count > 0); /* offset variable */
      528 		if old_size < 36 then call error (TOO_BIG, "");
      529 		if print_mode ^= 0 then do;
      530 		     old_word = old_bits;
      531 		     new_word = new_bits;
      532 		     call ioa_$ioa_stream (debug_output, "^w to ^w", old_word, new_word);
      533 		end;
      534 
      535 		old_bits = new_bits;
      536 		call bump;
      537 	     end;
      538 
      539 
      540 	     else if type = 1 | type = 2 then do;	/* fixed bin */
      541 		if ^dec_default then do;
      542 		     if substr (il, index_start_no, 2) = "&d" then control = "^d to ^d";
      543 		     else if old_size = 36 then control = "^w to ^w";
      544 		     else control = "^o to ^o";
      545 		end;
      546 		else do;				/* decimal default assumed unles &o was used */
      547 		     if substr (il, index_start_no, 2) = "&o" then control = "^o to ^o";
      548 		     else control = "^d to ^d";
      549 		end;
      550 		do while (rep_count > 0);
      551 		     if abs (fix_bit$double ((new_bits), size)) >= binary (2)** (old_size) then call error (TOO_BIG, "");
      552 		     if dp -> sign_bit then old_sign = -1;
      553 		     else old_sign = 1;
      554 
      555 		     if tp -> sign_bit then new_sign = -1;
      556 		     else new_sign = 1;
      557 
      558 		     if print_mode ^= 0 then do;
      559 			if old_size <= 36 then do;
      560 			     old_word = old_bits;
      561 			     new_word = new_bits;
      562 			     call ioa_$ioa_stream (debug_output, control, fix_bit (old_word, old_size),
      563 				fix_bit (new_word, size));
      564 			end;
      565 
      566 			else do;
      567 			     old_double = fix_bit$double ((old_bits), old_size);
      568 			     new_double = fix_bit$double ((new_bits), size);
      569 			     if dec_default then call ioa_$ioa_stream (debug_output, control,
      570 				addr (old_double) -> ffdouble, addr (new_double) -> ffdouble);
      571 			     else call ioa_$ioa_stream (debug_output, "^w^w to ^w^w", addr (old_double) -> ff.w0,
      572 				addr (old_double) -> ff.w1,
      573 				addr (new_double) -> ff.w0, addr (new_double) -> ff.w1);
      574 			end;
      575 		     end;
      576 
      577 		     if size >= old_size then
      578 			old_bits = substr (new_bits, size-old_size+1);
      579 		     else do;
      580 			pad_bits = old_size - size;
      581 			if new_sign < 0 then substr (old_bits, 1, pad_bits) = ones;
      582 			else substr (old_bits, 1, pad_bits) = "0"b;
      583 
      584 			substr (old_bits, pad_bits+1) = new_bits;
      585 		     end;
      586 
      587 		     call bump;
      588 		end;
      589 	     end;
      590 
      591 	     else if type = 3 | type = 4 then do;
      592 		do while (rep_count > 0);
      593 		     if old_size < 9 then call error (TOO_BIG, "");
      594 
      595 		     if print_mode ^= 0 then do;
      596 			on underflow begin;		/* maybe some value wasn't really */
      597 						/* floating, so print it out octal */
      598 			     call ioa_$ioa_stream (debug_output, "^w to ^w", dp -> fword, tp -> fword);
      599 			     goto rev_under;
      600 			end;
      601 
      602 			call ioa_$ioa_stream (debug_output, "^12.4f to ^12.4f", addr (old_bits) -> flword,
      603 			     addr (new_bits) -> flword);
      604 rev_under:		revert underflow;
      605 		     end;
      606 
      607 		     old_bits = substr (new_bits, 1, min (old_size, size));
      608 		     call bump;
      609 		end;
      610 	     end;
      611 
      612 
      613 	     else call error (SYNTAX, "");
      614 	     return;
      615 
      616 
      617 	end store_value;
      618 
      619 	
      620 
      621 /*  This procedure attempts to get a repetition count.  It assumes a format:
      622*
      623*	[blank(s)]  [decimal digit(s)]  [blank(s)]
      624*
      625*    If the string is not a repetion count, lin and mode are restored.  The main procedure  will then
      626*    try to parse an instruction
      627**/
      628 
      629 get_rep_count: proc (rep);
      630 
      631 dcl  rep fixed bin;
      632 
      633 	     rep = 1;
      634 	     i = lin;				/* save in  case this is not repetition */
      635 	     if get_char (lin + 1) then do;
      636 		k = lin;
      637 		j = db_get_count$dec (il, lin, lin);
      638 
      639 		if lin = k then do;
      640 		     lin = i;
      641 		     mode = "(";
      642 		     return;
      643 		end;
      644 
      645 		if get_char (lin) then if mode = ")" then do;
      646 			if j < 1 then call error (BAD_REP, "");
      647 			if ^get_char (lin + 1) then call error (SYNTAX, "");
      648 			rep = j;
      649 			return;
      650 		     end;
      651 	     end;
      652 
      653 	     call error (MISS_PAREN,  "");
      654 
      655 	end get_rep_count;
      656 
      657      end db_assign;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1628.2  db_assign.pl1                     >dumps>old>recomp>db_assign.pl1
13           1    08/12/76  1010.2  db_ext_stat_.incl.pl1             >ldd>include>db_ext_stat_.incl.pl1
170          2    11/06/75  1110.0  db_snt.incl.pl1                   >ldd>include>db_snt.incl.pl1
172          3    05/06/74  1741.6  db_inst.incl.pl1                  >ldd>include>db_inst.incl.pl1
174          4    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
185          5    11/22/74  1603.5  db_data_map.incl.pl1              >ldd>include>db_data_map.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BAD_PR                          000012 internal static fixed bin(17,0)          initial dcl 109 set ref 375* 378* 389*
BAD_REP                         000020 internal static fixed bin(17,0)          initial dcl 115 set ref 646*
MISS_PAREN                      000011 internal static fixed bin(17,0)          initial dcl 108 set ref 360* 362* 399* 410* 653*
NO_REG                          000013 internal static fixed bin(17,0)          initial dcl 110 set ref 225*
NO_SYM                          000014 internal static fixed bin(17,0)          initial dcl 111 set ref 269*
OPCODE                          000015 internal static fixed bin(17,0)          initial dcl 112 set ref 369*
SYNTAX                          000017 internal static fixed bin(17,0)          initial dcl 114 set ref 371* 395* 411* 613* 647*
TAG                             000016 internal static fixed bin(17,0)          initial dcl 113 set ref 407*
TOO_BIG                         000010 internal static fixed bin(17,0)          initial dcl 106 set ref 467* 508* 528* 551* 593*
a_cur_size                             parameter       fixed bin(17,0)          dcl 21 ref 11 190
a_old_size                             parameter       fixed bin(17,0)          dcl 23 ref 11 191
abs                                                    builtin function         dcl 168 ref 551
access_name                     000125 automatic       char(32)                 level 2 dcl 69 set ref 201*
access_ok                       000104 automatic       fixed bin(1,0)           dcl 48 set ref 198* 200* 277
addr                                                   builtin function         dcl 167 ref 188 202 202 277 277 290 300 459 476 498
                                                                                  569 569 571 571 571 571 602 602
addrel                                                 builtin function         dcl 167 ref 239 298 436 455 507
base                            000105 automatic       fixed bin(17,0)          dcl 48 set ref 372* 377* 378 385* 386 387* 389 419
                                                                                  424
binary                                                 builtin function         dcl 168 ref 551
bit                                                    builtin function         dcl 167 ref 198 300 424 428 429
bit_offset                1(21)        based           bit(6)                   level 2 packed unaligned dcl 4-5 set ref 290 300*
                                                                                  459
bitarr                                 based           bit(1)                   array unaligned dcl 136 set ref 498
bptr                                   based           pointer                  dcl 95 set ref 513 516 517* 519 519*
c2                              000264 automatic       char(2)                  dcl 136 set ref 383* 387
c4                              000265 automatic       char(4)                  dcl 136 set ref 400* 405 407*
char                                                   builtin function         dcl 167 ref 494 494 494 494
chars                                  based           char(1)                  array unaligned dcl 136 set ref 476
code                            000106 automatic       fixed bin(17,0)          dcl 48 set ref 268* 269
code35                          000107 automatic       fixed bin(35,0)          dcl 48 set ref 196* 197 202* 205 206* 277*
com_err_                        000202 constant        entry                    external dcl 29 ref 206
control                         000234 automatic       char(8)                  dcl 134 set ref 542* 543* 544* 547* 548* 562* 569*
cur_size                        000100 automatic       fixed bin(17,0)          dcl 22 set ref 190* 454* 455 465* 465 472 472 480*
                                                                                  488* 488 494 494 502*
data_ptr                               parameter       pointer                  dcl 16 ref 11 189
db_data$names                   000240 external static char(4)                  array dcl 5-10 ref 234
db_data$tags                    000242 external static char(4)                  array dcl 5-12 ref 405
db_ext_stat_$db_ext_stat_       000200 external static structure                level 1 dcl 1-9
db_get_count                    000204 constant        entry                    external dcl 29 ref 250 393
db_get_count$dec                000206 constant        entry                    external dcl 29 ref 637
db_mc_ptr                              parameter       pointer                  dcl 15 set ref 11 231*
db_parse_arg                    000230 constant        entry                    external dcl 29 ref 258
db_regs$get                     000210 constant        entry                    external dcl 29 ref 231
db_sym                          000212 constant        entry                    external dcl 29 ref 268
db_sym_name                     000334 automatic       varying char(72)         dcl 136 set ref 267* 268*
debug_output             10     000200 external static char(32)                 level 2 dcl 1-9 set ref 210* 318* 434* 471* 472*
                                                                                  494* 522* 532* 562* 569* 571* 598* 602*
dec_default                            parameter       bit(1)                   unaligned dcl 128 set ref 11 221* 249 541 569
dir_name                 20            based           char(168)                level 2 dcl 2-9 set ref 202* 277*
divide                                                 builtin function         dcl 168 ref 289 464 465
dp                              000152 automatic       pointer                  dcl 95 set ref 189* 196* 206* 210* 290 298* 298 300
                                                                                  416* 418 420 421 424 425 426 428 429 430 431 433*
                                                                                  436* 436 455 459 471 471 472 472 475 476* 476 494
                                                                                  494 497 498* 498 507* 507 510 511 513 516 517 519
                                                                                  530 535 552 560 567 577 581 582 584 598 602 607
emode                           000110 automatic       fixed bin(5,0)           dcl 48 set ref 196* 198
ent_name                 10            based           char(32)                 level 2 dcl 2-9 set ref 202* 277*
ff                                     based           structure                level 1 dcl 164
ffdouble                               based           fixed bin(71,0)          dcl 163 set ref 569* 569*
fix_bit                         000232 constant        entry                    external dcl 45 ref 562 562 562 562
fix_bit$double                  000234 constant        entry                    external dcl 46 ref 551 567 568
fixed                                                  builtin function         dcl 167 ref 290 300 424 428 429 459
flword                                 based           float bin(27)            dcl 83 set ref 602* 602*
fword                                  based           fixed bin(17,0)          dcl 81 set ref 250* 479* 501* 598* 598*
get_group_id_                   000222 constant        entry                    external dcl 29 ref 201
hcs_$add_acl_entries            000216 constant        entry                    external dcl 29 ref 202
hcs_$delete_acl_entries         000220 constant        entry                    external dcl 29 ref 277
hcs_$fs_get_mode                000224 constant        entry                    external dcl 29 ref 196
i                               000370 automatic       fixed bin(17,0)          dcl 333 in procedure "get_char" set ref 337* 338 339
i                               000121 automatic       fixed bin(17,0)          dcl 48 in procedure "db_assign" set ref 222* 223
                                                                                  223* 224* 224 225 226 227 233* 234* 250* 251 251
                                                                                  254 366* 367 367* 386* 387 387* 404* 405 405* 431*
                                                                                  634* 640
il                                     parameter       char(132)                dcl 16 set ref 11 222 226 250* 251 258* 337 340 361
                                                                                  363 374 375 377 382 383 393* 394 397 398 400 542
                                                                                  547 637*
ill                                    parameter       fixed bin(17,0)          dcl 16 set ref 11 213 222 223 258*
illegal_string                         parameter       char                     dcl 316 set ref 313 318*
index                                                  builtin function         dcl 167 in procedure "db_assign" ref 251 377 398
index                                  parameter       fixed bin(17,0)          dcl 332 in procedure "get_char" ref 330 335
index_start_no                  000124 automatic       fixed bin(17,0)          dcl 64 set ref 247* 542 547
inhibit                   0(28)        based           bit(1)                   level 2 packed unaligned dcl 3-13 set ref 430*
instr                                  based           structure                level 1 dcl 3-13
instr_pr                               based           structure                level 1 dcl 3-21
ioa_$ioa_stream                 000226 constant        entry                    external dcl 29 ref 210 318 434 471 472 494 522 532
                                                                                  562 569 571 598 602
its                                    based           structure                level 1 dcl 4-5
j                               000122 automatic       fixed bin(17,0)          dcl 48 set ref 361* 362 363 364 392* 394 398* 399
                                                                                  400 401 637* 646 648
k                               000123 automatic       fixed bin(17,0)          dcl 48 set ref 418* 636* 639
last_char                       000103 automatic       fixed bin(17,0)          dcl 27 set ref 213* 336 337 343 361
len_ptr                         000150 automatic       pointer                  dcl 93 set ref 453* 455* 478 479 500 501
lin                                    parameter       fixed bin(17,0)          dcl 16 set ref 11 214* 222 222 224 225 226 226 227*
                                                                                  247 250* 251 254* 258* 335* 336 337 337 339* 339
                                                                                  340 343* 360 361 361 363 364* 364 371* 374 375
                                                                                  376* 376 377 379* 379 382 383 384* 384 392 393*
                                                                                  393* 394 394 397 398 400 401* 401 410* 412* 412
                                                                                  634 635 636 637* 637* 639 640* 645* 647
max_size                        000116 automatic       fixed bin(17,0)          dcl 48 set ref 268*
mess                            000021 internal static varying char(40)         initial array dcl 116 set ref 318*
mess_code                              parameter       fixed bin(17,0)          dcl 315 ref 313 318
min                                                    builtin function         dcl 167 ref 468 479 490 501 607
mod                                                    builtin function         dcl 167 ref 292
mode                            000236 automatic       char(1)                  dcl 136 set ref 218 219 220 340* 341 411 641* 645
mode_char                       000360 automatic       char(1)                  dcl 136 set ref 268*
modes                    10     000125 automatic       bit(36)                  initial level 2 dcl 69 set ref 69*
name1                           000266 automatic       varying char(72)         dcl 136 set ref 269 416* 434*
name2                           000311 automatic       varying char(72)         dcl 136 set ref 433* 434*
new_bit_off                     000145 automatic       fixed bin(17,0)          dcl 79 set ref 292* 293 294* 294 300 300
new_bits                               based           bit                      unaligned dcl 136 set ref 494 494 497 531 535 551
                                                                                  561 568 577 584 602 607
new_double                      000232 automatic       fixed bin(71,0)          dcl 132 set ref 568* 569 571 571
new_ptr                         000224 automatic       pointer                  dcl 103 set ref 511* 513* 517* 519* 522*
new_sign                        000141 automatic       fixed bin(17,0)          dcl 75 set ref 555* 556* 581
new_size                        000102 automatic       fixed bin(17,0)          dcl 26 set ref 469* 471 471 479 491* 501
new_word                        000227 automatic       bit(36)                  dcl 131 set ref 531* 532* 561* 562* 562*
null                                                   builtin function         dcl 167 ref 453 478 500
off                             000111 automatic       fixed bin(17,0)          dcl 48 set ref 393* 394* 420 425
off_inc                         000143 automatic       fixed bin(17,0)          dcl 78 set ref 289* 295* 295 298
offset                          000112 automatic       fixed bin(17,0)          dcl 48 in procedure "db_assign" set ref 268*
offset                    0(03)        based           fixed bin(14,0)          level 2 in structure "instr_pr" packed unaligned
                                                                                  dcl 3-21 in procedure "db_assign" set ref 425*
offset                                 based           fixed bin(17,0)          level 2 in structure "instr" packed unaligned
                                                                                  dcl 3-13 in procedure "db_assign" set ref 420*
old_bit_off                     000144 automatic       fixed bin(17,0)          dcl 79 set ref 290* 292
old_bits                               based           bit                      unaligned dcl 136 set ref 494 494 497* 530 535* 560
                                                                                  567 577* 581* 582* 584* 602 607*
old_double                      000230 automatic       fixed bin(71,0)          dcl 132 set ref 567* 569 571 571
old_pr_names                    000000 constant        char(2)                  initial array unaligned dcl 156 ref 387
old_ptr                         000222 automatic       pointer                  dcl 103 set ref 510* 516* 522*
old_sign                        000140 automatic       fixed bin(17,0)          dcl 75 set ref 552* 553*
old_size                        000101 automatic       fixed bin(17,0)          dcl 25 set ref 191* 289 292 454* 455 459* 464* 464
                                                                                  467 468 472 472 475 479 480 487* 487 490 494 494
                                                                                  497 501 502 508 509 528 530 535 543 551 559 560
                                                                                  562* 562* 567 567* 577 577 577 580 581 582 584 593
                                                                                  602 607 607
old_str                                based           char                     unaligned dcl 136 set ref 472 472 475*
old_type                               parameter       fixed bin(17,0)          dcl 24 ref 11 454 459 463 463 486 507
old_word                        000226 automatic       bit(36)                  dcl 131 set ref 530* 532* 560* 562* 562*
ones                            000004 constant        bit(72)                  initial unaligned dcl 104 ref 581
op                              000113 automatic       fixed bin(17,0)          dcl 48 set ref 365* 366 367* 369 428
op_mnemonic_$op_mnemonic        000236 external static structure                array level 1 dcl 178
opcode                    0(18)        based           bit(10)                  level 2 in structure "instr" packed unaligned
                                                                                  dcl 3-13 in procedure "db_assign" set ref 428*
opcode                          000236 external static char(6)                  array level 2 in structure
                                                                                  "op_mnemonic_$op_mnemonic" packed unaligned
                                                                                  dcl 178 in procedure "db_assign" ref 367
opcode6                         000262 automatic       char(6)                  dcl 136 set ref 363* 367 369*
packed_ptr                             based           pointer                  unaligned dcl 101 set ref 510 511 511* 513* 517
pad_bits                        000142 automatic       fixed bin(17,0)          dcl 77 set ref 580* 581 582 584
pr                                     based           bit(3)                   level 2 packed unaligned dcl 3-21 set ref 424*
pr_bit                    0(29)        based           bit(1)                   level 2 packed unaligned dcl 3-13 set ref 421* 426*
print_mode                             parameter       fixed bin(17,0)          dcl 16 set ref 11 210 231* 416 432 470 494 522 529
                                                                                  558 595
print_text_$format              000214 constant        entry                    external dcl 29 ref 416 433
reg_name                        000147 automatic       char(4)                  unaligned dcl 91 set ref 228* 231* 232 234
rep                                    parameter       fixed bin(17,0)          dcl 631 set ref 629 633* 648*
rep_count                       000114 automatic       fixed bin(17,0)          dcl 48 set ref 216* 218* 303* 303 415* 415* 469 471
                                                                                  471 471 471* 474* 474* 482* 491 493* 493* 506 527
                                                                                  550 592
repstr                                 based           char                     unaligned dcl 136 ref 471 471
search                                                 builtin function         dcl 168 ref 222 361
segment_acl                     000125 automatic       structure                level 1 dcl 69 set ref 202 202 277 277
sign_bit                               based           bit(1)                   unaligned dcl 127 ref 552 555
size                            000115 automatic       fixed bin(17,0)          dcl 48 set ref 230* 232* 235* 239 258* 263* 264* 267
                                                                                  268* 454 468* 468 469 471 471 471 471 472 472 475
                                                                                  476 490* 490 491 494 494 497 498 511 517 531 535
                                                                                  551 551* 561 562* 562* 568 568* 577 577 577 580
                                                                                  584 602 607 607
snt                                    based           structure                level 1 dcl 2-9
sntp                                   parameter       pointer                  dcl 2-7 set ref 11 202 202 268* 277 277
str                                    based           char                     unaligned dcl 136 set ref 267 471* 472* 475
substr                                                 builtin function         dcl 167 set ref 222 226 228 251 337 340 361 363 374
                                                                                  375 377 382 383 394 397 398 400 471 471 472 472
                                                                                  494 494 542 547 577 581* 582* 584* 607
sym_name                        000237 automatic       char(72)                 dcl 136 set ref 226* 228
tag                             000117 automatic       fixed bin(17,0)          dcl 48 in procedure "db_assign" set ref 396* 403*
                                                                                  404 405* 407 429
tag                       0(30)        based           bit(6)                   level 2 in structure "instr" packed unaligned
                                                                                  dcl 3-13 in procedure "db_assign" set ref 429*
tem                             000156 automatic       pointer                  array dcl 95 set ref 188
temp                            000220 automatic       pointer                  dcl 95 set ref 188* 231 239 240 250 258* 259
tp                              000154 automatic       pointer                  dcl 95 set ref 239* 240* 259* 267 268* 471 472 475
                                                                                  494 494 497 511 513 517 519 531 535 551 555 561
                                                                                  568 577 584 598 602 607
tw_flag                         000146 automatic       fixed bin(17,0)          initial dcl 89 set ref 89*
two_words                              based           bit(72)                  unaligned dcl 85 set ref 231*
type                            000120 automatic       fixed bin(17,0)          dcl 48 set ref 229* 236* 248* 253* 258 258* 261 263
                                                                                  263 264 266 268* 456 462 485 506 527 540 540 591
                                                                                  591
type_char                       000357 automatic       char(1)                  dcl 136 set ref 268*
underflow                       000000 stack reference condition                dcl 160 ref 596 604
unspec                                                 builtin function         dcl 167 set ref 510* 510 511 511* 511* 513 513* 513*
                                                                                  516* 516 517 517* 517* 519 519* 519*
verify                                                 builtin function         dcl 168 ref 337
w0                                     based           fixed bin(17,0)          level 2 dcl 164 set ref 418 431 571* 571*
w1                        1            based           fixed bin(17,0)          level 2 dcl 164 set ref 571* 571*
zero_pad                 11     000125 automatic       bit(36)                  initial level 2 dcl 69 set ref 69*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BAD_SYNTAX                             internal static fixed bin(17,0)          initial dcl 107
ITP_MODIFIER                           internal static bit(6)                   initial unaligned dcl 4-56
ITS_MODIFIER                           internal static bit(6)                   initial unaligned dcl 4-55
conversion                      000000 stack reference condition                dcl 159
cu_$level_get                   000000 constant        entry                    external dcl 29
db_data$acv_names                      external static char(24)                 array dcl 5-16
db_data$fault_names                    external static char(20)                 array dcl 5-14
db_data$ipr_names                      external static char(24)                 array dcl 5-18
db_data$n_regs                         external static fixed bin(17,0)          dcl 5-8
db_ext_stat_$break_instructions        external static bit(36)                  array dcl 1-27
delete_acl                             automatic       structure                level 1 dcl 66
ilc_ptr                                automatic       pointer                  dcl 3-10
itp                                    based           structure                level 1 dcl 4-18
itp_unsigned                           based           structure                level 1 dcl 4-43
its_unsigned                           based           structure                level 1 dcl 4-30
max                                                    builtin function         dcl 167
rb                                     automatic       fixed bin(17,0)          array dcl 48
rel                                                    builtin function         dcl 167
words                                  based           bit(36)                  array dcl 87

NAMES DECLARED BY EXPLICIT CONTEXT.
bump                            001053 constant        entry                    internal dcl 283 ref 524 536 587 608
db_assign                       000132 constant        entry                    external dcl 11
error                           001120 constant        entry                    internal dcl 313 ref 225 269 360 362 369 371 375 378
                                                                                  389 395 399 407 410 411 467 508 528 551 593 613
                                                                                  646 647 653
get_char                        001170 constant        entry                    internal dcl 330 ref 214 360 371 410 635 645 647
get_instruction                 001250 constant        entry                    internal dcl 358 ref 219
get_rep_count                   004125 constant        entry                    internal dcl 629 ref 218
reset                           001010 constant        label                    dcl 277 ref 261 319
rev_under                       004070 constant        label                    dcl 604 ref 599
store_value                     002243 constant        entry                    internal dcl 451 ref 242 272

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5202        5446    4744        5212
Length      6000    4744       244         316     235         170

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
db_assign                           396 external procedure  is an external procedure.  
bump                                    internal procedure  shares stack frame of internal procedure store_value.  
error                                86 internal procedure  is called during a stack extension.  
get_char                                internal procedure  shares stack frame of external procedure db_assign.  
get_instruction                         internal procedure  shares stack frame of external procedure db_assign.  
store_value                         276 internal procedure  enables or reverts conditions.  
on unit on line 596                  84 on unit               
get_rep_count                           internal procedure  shares stack frame of external procedure db_assign.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 TOO_BIG                     db_assign
000011 MISS_PAREN                  db_assign
000012 BAD_PR                      db_assign
000013 NO_REG                      db_assign
000014 NO_SYM                      db_assign
000015 OPCODE                      db_assign
000016 TAG                         db_assign
000017 SYNTAX                      db_assign
000020 BAD_REP                     db_assign
000021 mess                        db_assign

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
db_assign                000100 cur_size                    db_assign
                         000101 old_size                    db_assign
                         000102 new_size                    db_assign
                         000103 last_char                   db_assign
                         000104 access_ok                   db_assign
                         000105 base                        db_assign
                         000106 code                        db_assign
                         000107 code35                      db_assign
                         000110 emode                       db_assign
                         000111 off                         db_assign
                         000112 offset                      db_assign
                         000113 op                          db_assign
                         000114 rep_count                   db_assign
                         000115 size                        db_assign
                         000116 max_size                    db_assign
                         000117 tag                         db_assign
                         000120 type                        db_assign
                         000121 i                           db_assign
                         000122 j                           db_assign
                         000123 k                           db_assign
                         000124 index_start_no              db_assign
                         000125 segment_acl                 db_assign
                         000140 old_sign                    db_assign
                         000141 new_sign                    db_assign
                         000142 pad_bits                    db_assign
                         000143 off_inc                     db_assign
                         000144 old_bit_off                 db_assign
                         000145 new_bit_off                 db_assign
                         000146 tw_flag                     db_assign
                         000147 reg_name                    db_assign
                         000150 len_ptr                     db_assign
                         000152 dp                          db_assign
                         000154 tp                          db_assign
                         000156 tem                         db_assign
                         000220 temp                        db_assign
                         000222 old_ptr                     db_assign
                         000224 new_ptr                     db_assign
                         000226 old_word                    db_assign
                         000227 new_word                    db_assign
                         000230 old_double                  db_assign
                         000232 new_double                  db_assign
                         000234 control                     db_assign
                         000236 mode                        db_assign
                         000237 sym_name                    db_assign
                         000262 opcode6                     db_assign
                         000264 c2                          db_assign
                         000265 c4                          db_assign
                         000266 name1                       db_assign
                         000311 name2                       db_assign
                         000334 db_sym_name                 db_assign
                         000357 type_char                   db_assign
                         000360 mode_char                   db_assign
                         000370 i                           get_char

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          alloc_cs            alloc_bs            call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other_desc return              tra_ext             mod_fx1             enable
shorten_stack       ext_entry           int_entry           int_entry_desc      any_to_any_tr       real_p_int

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      db_get_count                  db_get_count$dec              db_parse_arg
db_regs$get                   db_sym                        fix_bit                       fix_bit$double
get_group_id_                 hcs_$add_acl_entries          hcs_$delete_acl_entries       hcs_$fs_get_mode
ioa_$ioa_stream               print_text_$format

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
db_data$names                 db_data$tags                  db_ext_stat_$db_ext_stat_     op_mnemonic_$op_mnemonic




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000122        69 000137        89 000142       188 000143       189 000145       190 000151       191 000153
    196 000155       197 000167       198 000171       200 000202       201 000203       202 000212       205 000252
    206 000254       207 000307       210 000310       213 000342       214 000346       216 000362       218 000364
    219 000371       220 000376       221 000400       222 000405       223 000424       224 000430       225 000433
    226 000454       227 000465       228 000467       229 000471       230 000473       231 000475       232 000512
    233 000521       234 000525       235 000531       236 000533       238 000535       239 000537       240 000546
    242 000550       244 000554       247 000555       248 000560       249 000561       250 000566       251 000603
    253 000621       254 000623       258 000625       259 000650       261 000652       263 000655       264 000663
    266 000670       267 000672       268 000703       269 000753       270 001002       272 001003       275 001007
    277 001010       279 001052       283 001053       289 001054       290 001060       292 001064       293 001071
    294 001073       295 001075       298 001076       300 001102       303 001114       304 001116       313 001117
    318 001133       319 001165       330 001170       335 001172       336 001175       337 001177       338 001216
    339 001217       340 001222       341 001226       342 001236       343 001237       346 001242       358 001250
    360 001251       361 001277       362 001317       363 001335       364 001346       365 001352       366 001354
    367 001363       368 001401       369 001403       371 001423       372 001454       374 001456       375 001465
    376 001506       377 001511       378 001523       379 001542       380 001545       382 001546       383 001552
    384 001556       386 001560       387 001567       388 001577       389 001601       392 001621       393 001624
    394 001641       395 001655       396 001672       397 001673       398 001702       399 001713       400 001731
    401 001740       403 001744       404 001746       405 001755       406 001764       407 001766       408 002006
    410 002007       411 002037       412 002057       415 002061       416 002066       418 002106       419 002110
    420 002113       421 002117       422 002121       424 002122       425 002131       426 002136       428 002140
    429 002150       430 002156       431 002160       432 002162       433 002165       434 002202       436 002233
    437 002236       439 002241       451 002242       453 002250       454 002253       455 002262       456 002270
    459 002273       462 002304       463 002307       464 002314       465 002317       467 002322       468 002341
    469 002347       470 002351       471 002354       472 002431       473 002500       474 002501       475 002510
    476 002517       477 002522       478 002525       479 002531       480 002536       482 002540       483 002542
    485 002543       486 002545       487 002550       488 002553       490 002556       491 002563       493 002565
    494 002573       497 002663       498 002674       499 002677       500 002702       501 002706       502 002713
    504 002715       506 002716       507 002723       508 002731       509 002752       510 002756       511 002762
    513 003001       514 003012       516 003013       517 003017       519 003037       522 003046       524 003100
    525 003101       527 003103       528 003110       529 003131       530 003135       531 003142       532 003147
    535 003176       536 003206       537 003207       540 003211       541 003215       542 003222       543 003233
    544 003241       545 003243       547 003244       548 003255       550 003257       551 003262       552 003347
    553 003361       555 003363       556 003373       558 003375       559 003400       560 003403       561 003406
    562 003412       564 003501       567 003502       568 003531       569 003564       571 003622       577 003661
    580 003701       581 003704       582 003714       584 003721       587 003730       588 003731       589 003732
    591 003733       592 003737       593 003742       595 003763       596 003767       598 004003       599 004033
    602 004036       604 004070       607 004071       608 004104       609 004105       610 004106       613 004107
    614 004124       629 004125       633 004127       634 004131       635 004134       636 004144       637 004147
    639 004164       640 004170       641 004172       642 004174       645 004175       646 004213       647 004233
    648 004261       649 004264       653 004265       655 004302


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
