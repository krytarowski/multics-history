	COMPILATION LISTING OF SEGMENT network_accounting_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 11/25/87  0827.7 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /**** TBS
        8*      We need to do something about robustness of this code WRT to the database.
        9*      If something happens to the database while the system is running, all of the
       10*      users will be crawling out of the inner ring.  This will spew error messages
       11*      and AS dumps like mad.
       12*
       13*      This should be handled by an any_other handler which will handle the problem. */
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(85-11-25,Herbst), approve(86-05-14,MCR7423),
       17*     audit(87-08-03,GDixon), install(87-08-04,MR12.1-1055):
       18*     Written 85-09-10, Herbst. 85-10-10,  Changed to use data records instead
       19*     of putting all info in keys. Changed to set validation level before
       20*     accessing the database via vfile_.
       21*  2) change(86-01-07,Herbst), approve(86-05-14,MCR7423),
       22*     audit(87-08-03,GDixon), install(87-08-04,MR12.1-1055):
       23*     Multiple changes during the evolution of the code.
       24*  3) change(86-10-10,Brunelle), approve(86-10-10,MCR7423),
       25*     audit(87-08-03,GDixon), install(87-08-04,MR12.1-1055):
       26*     Multiple changes during the evolution of the code.
       27*  4) change(87-08-03,Brunelle), approve(87-08-03,MCR7694),
       28*     audit(87-08-03,GDixon), install(87-08-04,MR12.1-1055):
       29*     Correct logic errors found in audit.
       30*  5) change(87-11-24,Brunelle), approve(87-11-24,MECR0001),
       31*     audit(87-11-24,Beattie), install(87-11-25,MR12.2-1003):
       32*     Correct errors causing crash on initialization including
       33*     a) setting network_account_array_ptr to null and debug_sw OFF in INIT1
       34*     b) not complaining if delete_$path gets error_table_$noentry error when
       35*        deleting network_accounting_table.
       36*                                                   END HISTORY COMMENTS */
       37 
       38 /* format: style4 */
       39 
       40 network_accounting_: proc ();
       41 
       42 	return;					/* no entry here */
       43 
       44 /* This module allows network programs to charge processes for bytes and
       45*   packets sent over channels. */
       46 
       47 /* Parameters */
       48 
       49 dcl  P_area_ptr ptr parameter;			/* user area ptr to allocate in (I) */
       50 dcl  P_array_ptr ptr parameter;			/* ptr to allocated array of all available DSA records (O) */
       51 dcl  P_error_message char (*) parameter;		/* text error message (if needed) (O) */
       52 dcl  P_path char (*) parameter;			/* path to set for test location of database (I) */
       53 dcl  P_code fixed bin (35) parameter;			/* return error code (O) */
       54 dcl  P_network_channel_use_ptr ptr;			/* ptr to data to use to update usage for a channel (I) */
       55 dcl  P_process_id bit (36) aligned;			/* specific process id to scan NAT for (I) */
       56 
       57 /* External Procedures & Variables */
       58 
       59 dcl  cu_$arg_list_ptr entry (ptr);
       60 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
       61 dcl  cu_$level_get entry (fixed bin);
       62 dcl  cu_$level_set entry (fixed bin);
       63 dcl  delete_$path entry (char (*), char (*), bit (36) aligned, char (*), fixed bin (35));
       64 dcl  error_table_$bad_processid fixed bin (35) ext static;
       65 dcl  error_table_$end_of_info fixed bin (35) ext static;
       66 dcl  error_table_$invalid_lock_reset fixed bin (35) ext static;
       67 dcl  error_table_$lock_wait_time_exceeded fixed bin (35) ext static;
       68 dcl  error_table_$locked_by_this_process fixed bin (35) ext static;
       69 dcl  error_table_$no_record fixed bin (35) ext static;
       70 dcl  error_table_$noentry fixed bin (35) ext static;
       71 dcl  error_table_$not_initialized fixed bin (35) ext static;
       72 dcl  error_table_$process_unknown fixed bin (35) ext static;
       73 dcl  get_ring_ entry () returns (fixed bin (3));
       74 dcl  hcs_$replace_acl entry (char (*), char (*), ptr, fixed bin, bit (1), fixed bin (35));
       75 dcl  hcs_$validate_processid entry (bit (36) aligned, fixed bin (35));
       76 dcl  ioa_$general_rs entry (ptr, fixed bin, fixed bin, char (*), fixed bin (21), bit (1) aligned, bit (1) aligned);
       77 dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
       78 dcl  iox_$close entry (ptr, fixed bin (35));
       79 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
       80 dcl  iox_$delete_record entry (ptr, fixed bin (35));
       81 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
       82 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
       83 dcl  iox_$position entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
       84 dcl  iox_$seek_key entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
       85 dcl  iox_$write_record entry (ptr, ptr, fixed bin (21), fixed bin (35));
       86 dcl  pathname_ entry (char (*), char (*)) returns (char (168));
       87 dcl  sys_info$system_control_dir char (168) varying ext;
       88 dcl  system_info_$timeup entry (fixed bin (71));
       89 dcl  unique_chars_ entry (bit (*)) returns (char (15));
       90 
       91 dcl  (cleanup) condition;
       92 dcl  (addr, clock, divide, length, null, rtrim, size, substr, unspec) builtin;
       93 
       94 /* Internal Static */
       95 
       96 dcl  ABORT_NO bit (1) int static options (constant) init ("0"b);
       97 dcl  ABORT_YES bit (1) int static options (constant) init ("1"b);
       98 dcl  BOF fixed bin int static options (constant) init (-1);
       99 dcl  CREATE_RECORD_NO bit (1) int static options (constant) init ("0"b);
      100 dcl  CREATE_RECORD_YES bit (1) int static options (constant) init ("1"b);
      101 dcl  FORWARD fixed bin int static options (constant) init (0);
      102 dcl  INIT_RECORD_PID bit (36) int static options (constant) init ("003000777777"b3);
      103 dcl  INIT_RECORD_SESSION_HANDLE fixed bin (35) int static options (constant) init (0);
      104 dcl  INIT_RECORD_NETWORK_ID fixed bin (35) int static options (constant) init (-1);
      105 dcl  ME char (19) int static options (constant) init ("network_accounting_");
      106 dcl  MICROSECONDS_PER_HALF_SECOND fixed bin (35) int static options (constant) init (500000);
      107 dcl  MICROSECONDS_PER_SECOND fixed bin (35) int static options (constant) init (1000000);
      108 dcl  NAT_iocb_ptr ptr int static init (null);
      109 dcl  NET_ARRAY_EXTRA_RECORD_COUNT fixed bin (35) int static options (constant) init (20);
      110 dcl  OFF bit (1) int static options (constant) init ("0"b);
      111 dcl  ON bit (1) int static options (constant) init ("1"b);
      112 dcl  RW_ACCESS bit (3) int static options (constant) init ("101"b);
      113 dcl  SEEK_HEAD_EQUAL_SEARCH fixed bin int static options (constant) init (0);
      114 dcl  TABLE_NAME char (32) int static options (constant) init ("network_accounting_table");
      115 dcl  database_directory char (168) int static init ("");
      116 dcl  i_am_initializer bit (1) int static init ("0"b);	/* ON if this is Initializer process
      117*						   or the process which last cleared the table */
      118 dcl  system_boot_time fixed bin (71) int static init (0);
      119 
      120 /* Automatic */
      121 
      122 dcl  abort_label label;
      123 dcl  caller_area_ptr ptr;				/* Ptr to user area */
      124 dcl  current_ring fixed bin;
      125 dcl  delta_time fixed bin (35);
      126 dcl  debug_sw bit (1);
      127 dcl  entrypoint_name char (32);			/* entrypoint called through */
      128 dcl  error_code fixed bin (35);			/* general internal error code */
      129 dcl  error_code_arg_sw bit (1);			/* ON if passed error code to use */
      130 dcl  error_message_arg_sw bit (1);			/* ON if user passed error message string to use */
      131 dcl  error_string char (32);
      132 dcl  get_process_total_entry bit (1);
      133 dcl  process_id_to_match bit (36) aligned;
      134 dcl  purge_lock_error fixed bin (35);
      135 dcl  record_count fixed bin;
      136 dcl  record_locked_sw bit (1);			/* ON while have specific record locked for user */
      137 dcl  reset_table_sw bit (1);				/* ON if supposed to reset entries in table after dumping them */
      138 dcl  saved_ring fixed bin init (-1);			/* ring number where called from */
      139 
      140 /* Based */
      141 
      142 dcl  1 auto_NAR aligned like network_account_record;
      143 dcl  1 auto_key aligned like network_account_record.key;
      144 dcl  caller_area area based (caller_area_ptr);
      145 dcl  1 database_acl (1) aligned like segment_acl_entry;
      146 dcl  1 info aligned like indx_info;			/* room for vfs_info.incl structures */
      147 dcl  key_char_overlay char (size (auto_key) * CHARS_PER_WORD) based (addr (auto_key));
      148 dcl  1 record_status_info aligned like rs_info;
      149 dcl  seek_head_info_room (20) fixed bin (35);
      150 dcl  seek_head_info_ptr ptr;
      151 dcl  1 seek_head_info based (seek_head_info_ptr),
      152        2 relation_type fixed bin,
      153        2 n fixed bin,
      154        2 search_key char (256 refer (seek_head_info.n));
      155 
      156 dcl  debug_switch bit (1) unaligned defined (NAR.switches.mbz);
      157 
      158 /* This entry charges the specified process ID/session ID/network type
      159*   combination for packets and bytes transmitted on the connection.
      160*
      161*   If is not gated and is only called from within the inner ring.
      162*
      163*   It may be called by the login servers and the individual users of the
      164*   connections */
      165 
      166 charge_channel_use: entry (P_network_channel_use_ptr, P_code);
      167 
      168 	entrypoint_name = "charge_channel_use";
      169 
      170 	error_code_arg_sw = ON;
      171 	error_message_arg_sw = OFF;			/* no return message string available */
      172 	call INIT1 ();
      173 	on cleanup call CLEAN_UP ();
      174 	call INIT2 ();
      175 
      176 	network_channel_use_ptr = P_network_channel_use_ptr; /* copy pointer to data to use for update */
      177 
      178 /* set up the key for the record desired */
      179 	unspec (auto_key) = "0"b;
      180 	auto_key.session_handle = NCU.session_handle;
      181 	auto_key.network_id = NCU.network_id;
      182 
      183 	if debug_sw then do;
      184 	     call REPORT_ERROR (0, ABORT_NO,
      185 		"SH=^w, OPID=^.3b, UPID=^.3b, SS=^d, PC=^5d, BC=^5d",
      186 		NCU.session_handle, NCU.owner_pid,
      187 		NCU.user_pid, NCU.session_state,
      188 		NCU.packet_count, NCU.byte_count);
      189 	end;
      190 
      191 /* NOTE: The update of the vaious combination of records is being done in
      192*   this manner to make it more obvious as to what is being done */
      193 	go to update_the_records (NCU.session_state);
      194 
      195 update_the_records (1):
      196 
      197 /* CREATE_SESSION - create a new record using the owner PID since the user
      198*   PID should be blank */
      199 
      200 /* make sure they gave us a valid PID to work with */
      201 	if NCU.owner_pid = "0"b then do;
      202 	     if debug_sw then do;
      203 		call REPORT_ERROR (0, ABORT_NO,
      204 		     "Called with invalid owner PID");
      205 	     end;
      206 	     P_code = error_table_$bad_processid;
      207 	     go to CLEANUP_AND_RETURN;
      208 	end;
      209 
      210 /* locate desired record, creating it if necessary using the data in auto_key,
      211*   and lock it */
      212 	auto_key.process_id = NCU.owner_pid;
      213 	call RECORD_SEEK_AND_LOCK (CREATE_RECORD_YES, error_code);
      214 	if error_code ^= 0 then
      215 	     call REPORT_ERROR (error_code, ABORT_YES, "creating owner record");
      216 
      217 /* add in the data for this session */
      218 	NAR.byte_count = NAR.byte_count + NCU.byte_count;
      219 	NAR.packet_count = NAR.packet_count + NCU.packet_count;
      220 	NAR.active = ON;				/* show activity */
      221 
      222 	call RECORD_UNLOCK ();
      223 	go to CLEANUP_AND_RETURN;
      224 
      225 update_the_records (2):
      226 
      227 /* ASSIGN_CONNECTION - update the data for the Owner PID and turn on the
      228*   unassigned switch. Then create a new record for the User PID. */
      229 
      230 /* make sure they gave us valid PIDs to work with */
      231 	if NCU.owner_pid = "0"b | NCU.user_pid = "0"b then do;
      232 	     if debug_sw then do;
      233 		call REPORT_ERROR (0, ABORT_NO,
      234 		     "Called with invalid owner or user PIDs");
      235 	     end;
      236 	     P_code = error_table_$bad_processid;
      237 	     go to CLEANUP_AND_RETURN;
      238 	end;
      239 
      240 /* locate owner record and lock it */
      241 	auto_key.process_id = NCU.owner_pid;
      242 	call RECORD_SEEK_AND_LOCK (CREATE_RECORD_YES, error_code);
      243 	if error_code ^= 0 then
      244 	     call REPORT_ERROR (error_code, ABORT_YES, "read owner record for assign");
      245 
      246 /* update the record */
      247 	NAR.byte_count = NAR.byte_count + NCU.byte_count;
      248 	NAR.packet_count = NAR.packet_count + NCU.packet_count;
      249 
      250 /* update the connect time for the record while assigned to the owner */
      251 	NAR.connected_time = NAR.connected_time + (clock () - NAR.update_time);
      252 
      253 /* show the connection belongs to someone else */
      254 	NAR.unassigned_switch = ON;
      255 	NAR.active = ON;				/* show activity */
      256 	call RECORD_UNLOCK ();			/* record free now */
      257 
      258 /* Now create a new record for the User PID which will now be taking over the
      259*   session.  The network type and session ID will remain the same. */
      260 	auto_key.process_id = NCU.user_pid;
      261 	call RECORD_SEEK_AND_LOCK (CREATE_RECORD_YES, error_code);
      262 	if error_code ^= 0 then
      263 	     call REPORT_ERROR (error_code, ABORT_YES, "creating user record");
      264 
      265 /* NOTE: the RECORD_SEEK_AND_LOCK call generates a zero usage data record with
      266*   update_time set to the current clock value */
      267 
      268 	NAR.active = ON;				/* show activity */
      269 
      270 	call RECORD_UNLOCK ();
      271 	go to CLEANUP_AND_RETURN;
      272 
      273 update_the_records (3):
      274 
      275 /* UPDATE_CONNECTION - update data in record of whichever process is currently
      276*   using the connection.  This is determined by the owner and user PIDs. */
      277 
      278 /* if we have a user PID defined, we will use it.  Otherwise, we will use the
      279*   owner PID.  If both are zeros, we will compain */
      280 	if NCU.user_pid ^= "0"b then
      281 	     auto_key.process_id = NCU.user_pid;
      282 	else if NCU.owner_pid ^= "0"b then
      283 	     auto_key.process_id = NCU.owner_pid;
      284 	else do;
      285 	     if debug_sw then do;
      286 		call REPORT_ERROR (0, ABORT_NO,
      287 		     "Called with invalid owner and user PIDs");
      288 	     end;
      289 	     P_code = error_table_$bad_processid;
      290 	     go to CLEANUP_AND_RETURN;
      291 	end;
      292 
      293 /* locate desired record, creating it if necessary using the data in auto_key,
      294*   and lock it */
      295 	call RECORD_SEEK_AND_LOCK (CREATE_RECORD_YES, error_code);
      296 	if error_code ^= 0 then
      297 	     call REPORT_ERROR (error_code, ABORT_YES, "read specified record");
      298 
      299 /* update the record */
      300 	NAR.byte_count = NAR.byte_count + NCU.byte_count;
      301 	NAR.packet_count = NAR.packet_count + NCU.packet_count;
      302 	NAR.active = ON;				/* show activity */
      303 
      304 	call RECORD_UNLOCK ();
      305 	go to CLEANUP_AND_RETURN;
      306 
      307 update_the_records (4):
      308 
      309 /* UNASSIGN_CONNECTION - update the data for the User PID and turn on the
      310*   unassigned and delete switches. Then locate the record for the Owner PID,
      311*   turn the unassigned switch off and set update time to the current clock
      312*   value so we can accumulate connect time again. */
      313 
      314 /* make sure they gave us valid PIDs to work with */
      315 	if NCU.owner_pid = "0"b | NCU.user_pid = "0"b then do;
      316 	     if debug_sw then do;
      317 		call REPORT_ERROR (0, ABORT_NO,
      318 		     "Called with invalid owner or user PIDs");
      319 	     end;
      320 	     P_code = error_table_$bad_processid;
      321 	     go to CLEANUP_AND_RETURN;
      322 	end;
      323 
      324 /* locate user record and lock it */
      325 	auto_key.process_id = NCU.user_pid;
      326 	call RECORD_SEEK_AND_LOCK (CREATE_RECORD_YES, error_code);
      327 	if error_code ^= 0 then
      328 	     call REPORT_ERROR (error_code, ABORT_YES, "read user record for unassign");
      329 
      330 /* update the record */
      331 	NAR.byte_count = NAR.byte_count + NCU.byte_count;
      332 	NAR.packet_count = NAR.packet_count + NCU.packet_count;
      333 
      334 /* update the connect time for the record while assigned to the owner */
      335 	NAR.connected_time = NAR.connected_time + (clock () - NAR.update_time);
      336 
      337 /* show record may be deleted when data read and that the connection belongs
      338*   to someone else now. */
      339 	NAR.unassigned_switch = ON;
      340 	NAR.delete_switch = ON;
      341 	NAR.active = ON;				/* show activity */
      342 
      343 	call RECORD_UNLOCK ();
      344 
      345 /* now locate the owner record for this session */
      346 	auto_key.process_id = NCU.owner_pid;
      347 	call RECORD_SEEK_AND_LOCK (CREATE_RECORD_YES, error_code);
      348 	if error_code ^= 0 then
      349 	     call REPORT_ERROR (error_code, ABORT_YES, "locating owner record");
      350 
      351 /* show thie connection belongs to the owner */
      352 	NAR.unassigned_switch = OFF;
      353 
      354 /* and set time so we can start accumulating connect time again */
      355 	NAR.update_time = clock ();
      356 	NAR.active = ON;				/* show activity */
      357 
      358 	call RECORD_UNLOCK ();
      359 	go to CLEANUP_AND_RETURN;
      360 
      361 update_the_records (5):
      362 
      363 /* DESTROY_SESSION - update the record for the Owner PID since the user PID
      364*   should be blank.  In addition, set the delete switch on. */
      365 
      366 /* make sure they gave us a valid PID to work with */
      367 	if NCU.owner_pid = "0"b then do;
      368 	     if debug_sw then do;
      369 		call REPORT_ERROR (0, ABORT_NO,
      370 		     "Called with invalid owner PID");
      371 	     end;
      372 	     P_code = error_table_$bad_processid;
      373 	     go to CLEANUP_AND_RETURN;
      374 	end;
      375 
      376 /* locate desired record and lock it */
      377 	auto_key.process_id = NCU.owner_pid;
      378 	call RECORD_SEEK_AND_LOCK (CREATE_RECORD_YES, error_code);
      379 	if error_code ^= 0 then
      380 	     call REPORT_ERROR (error_code, ABORT_YES, "read owner record for destroy");
      381 
      382 /* update the record */
      383 	NAR.byte_count = NAR.byte_count + NCU.byte_count;
      384 	NAR.packet_count = NAR.packet_count + NCU.packet_count;
      385 
      386 /* show record may be deleted when data read and that the connection belongs
      387*   to someone else now. */
      388 	NAR.delete_switch = ON;
      389 	NAR.unassigned_switch = ON;
      390 
      391 /* update the connect time for the record while assigned to the owner */
      392 	NAR.connected_time = NAR.connected_time + (clock () - NAR.update_time);
      393 	NAR.active = ON;				/* show activity */
      394 
      395 	call RECORD_UNLOCK ();
      396 	go to CLEANUP_AND_RETURN;
      397 
      398 CLEANUP_AND_RETURN:
      399 	call CLEAN_UP ();
      400 JUST_RETURN:
      401 	return;
      402 
      403 /* This entry reinitializes the network accounting table (NAT).
      404*   It does this by
      405*   1. deleting the current table,
      406*   2. opening it with vfile to create it,
      407*   3. setting access to all users on the system,
      408*   4. adding a dummy record to cause the file to expand from an SSF to MSF.
      409*
      410*   This entry is gated through network_accounting_gate_.
      411*
      412*   It is meant to be called only by the Initializer process when login server
      413*   is initialized. */
      414 
      415 clear_table: entry (P_error_message, P_code);
      416 
      417 	entrypoint_name = "clear_table";
      418 
      419 	error_code_arg_sw = ON;
      420 	error_message_arg_sw = ON;			/* can pass back return error string */
      421 
      422 /* remember if we are the Initializer */
      423 	i_am_initializer = ON;
      424 
      425 	call INIT1 ();
      426 	on cleanup call CLEAN_UP ();
      427 	call INIT2 ();
      428 
      429 	if debug_sw then do;
      430 	     call REPORT_ERROR (0, ABORT_NO, "Clearing NAT");
      431 	end;
      432 
      433 /* complain if database is open */
      434 	if NAT_iocb_ptr ^= null then do;
      435 	     call REPORT_ERROR (0, ABORT_NO, "Database is currently open.");
      436 	     NAT_iocb_ptr = null;
      437 	end;
      438 
      439 /* now delete the current beastie to start fresh */
      440 	call delete_$path (database_directory, TABLE_NAME, "101100"b,
      441 	     ME || "$clear_table", error_code);
      442 	if error_code ^= 0 then
      443 	     if error_code ^= error_table_$noentry then
      444 		call REPORT_ERROR (error_code, ABORT_YES, "Deleting old NAT.");
      445 
      446 /* now create the new table */
      447 	call NAT_OPEN;
      448 
      449 /* now set access on table for read/write for everyone
      450*   NOTE: table is now an SSF */
      451 	unspec (database_acl) = "0"b;
      452 	database_acl (1).access_name = "*.*.*";
      453 	database_acl (1).mode = RW_ACCESS;
      454 	call hcs_$replace_acl (database_directory, TABLE_NAME,
      455 	     addr (database_acl), 1, "1"b /* no SysDaemon */, error_code);
      456 
      457 /* write dummy record to force virgin database from SSF to MSF structured file */
      458 	auto_key.process_id = INIT_RECORD_PID;
      459 	auto_key.session_handle = INIT_RECORD_SESSION_HANDLE;
      460 	auto_key.network_id = INIT_RECORD_NETWORK_ID;
      461 	call RECORD_SEEK_AND_LOCK (CREATE_RECORD_YES, error_code);
      462 	if error_code = 0 then do;
      463 	     NAR.unassigned_switch = ON;
      464 	     NAR.update_time = clock ();
      465 	     call RECORD_UNLOCK ();
      466 	end;
      467 	else call REPORT_ERROR (error_code, ABORT_YES, "seek for initial record");
      468 
      469 	go to CLEANUP_AND_RETURN;
      470 
      471 debug: entry (new_debug_mode);
      472 dcl  new_debug_mode bit (1);
      473 
      474 	entrypoint_name = "debug";
      475 	error_code_arg_sw = OFF;
      476 	error_message_arg_sw = OFF;
      477 	call INIT1 ();
      478 	on cleanup call CLEAN_UP ();
      479 	call INIT2 ();
      480 	debug_switch = new_debug_mode;
      481 
      482 	return;
      483 
      484 /* This entry returns the full pathname of the current
      485*   network_accounting_table (NAT).
      486*
      487*   It is gated through network_accounting_gate_.
      488*
      489*   It may be called by anyone desiring to know the where the NAT is */
      490 
      491 get_path: entry returns (char (168));
      492 
      493 	if database_directory = ""			/* uninitialized */ then
      494 	     return (pathname_ ((sys_info$system_control_dir), TABLE_NAME));
      495 
      496 	return (pathname_ (database_directory, TABLE_NAME));
      497 
      498 /* This entry returns a copy of all of the data in the NAT.  The data is
      499*   allocated in a user provided area.
      500*
      501*   This entry is gated through the network_accounting_gate_.
      502*
      503*   It is meant to be called by anyone wishing to see the current network
      504*   accounting data and has access to the gate. */
      505 
      506 dump_table: entry (P_area_ptr, P_array_ptr, P_error_message, P_code);
      507 
      508 	entrypoint_name = "dump_table";
      509 	get_process_total_entry = OFF;
      510 	reset_table_sw = OFF;
      511 	go to READ_TABLE;
      512 
      513 
      514 
      515 /* This entry returns all records in the NAT for a specific processid.
      516*   It allocates space in a user provided area and returns the data for the
      517*   specific user.  If the delete bit is on for the record, it will delete it.
      518*
      519*   This entry is gated through network_accounting_gate_.
      520*
      521*   It is meant to be called by the Initializer when destroying a process to
      522*   get final network accounting data for the user. */
      523 
      524 get_process_total: entry (P_process_id, P_area_ptr, P_array_ptr, P_error_message, P_code);
      525 
      526 	entrypoint_name = "get_process_total";
      527 	get_process_total_entry = ON;
      528 	reset_table_sw = ON;			/* but will only reset for given user */
      529 	process_id_to_match = P_process_id;
      530 	go to READ_TABLE;
      531 
      532 
      533 /* This entry returns a copy of all of the data in the NAT.  The data is
      534*   allocated in a user provided area.  In addition, it zeros out all of the
      535*   current accumulated packet and byte totals and reset the current time to
      536*   the current clock value.
      537*
      538*   This entry is gated through the network_accounting_gate_.
      539*
      540*   It is meant to be called by the Initializer during the accounting update
      541*   cycle. */
      542 
      543 read_and_reset_table: entry (P_area_ptr, P_array_ptr, P_error_message, P_code);
      544 
      545 	entrypoint_name = "read_and_reset_table";
      546 	get_process_total_entry = OFF;
      547 	reset_table_sw = ON;
      548 	go to READ_TABLE;
      549 
      550 READ_TABLE:
      551 	error_code_arg_sw = ON;
      552 	error_message_arg_sw = ON;			/* can pass back return error string */
      553 	caller_area_ptr = P_area_ptr;
      554 	P_array_ptr = null;
      555 
      556 	call INIT1 ();
      557 	abort_label = RETURN_WHAT_WE_HAVE;
      558 	on cleanup call CLEAN_UP ();
      559 	call INIT2 ();
      560 
      561 	if debug_sw then do;
      562 	     call REPORT_ERROR (0, ABORT_NO,
      563 		"^[: PID=^.3b^;^s^]",
      564 		get_process_total_entry, process_id_to_match);
      565 	end;
      566 
      567 	on cleanup call CLEAN_UP ();
      568 
      569 /* determine current size of the database so we can allocate a large enough area to contain it */
      570 	unspec (indx_info) = "0"b;
      571 	indx_info.info_version = vfs_version_1;
      572 	call iox_$control (NAT_iocb_ptr, "file_status", addr (indx_info), error_code);
      573 	if error_code ^= 0 then
      574 	     call REPORT_ERROR (error_code, ABORT_YES, "get current record count");
      575 	record_count = indx_info.records;
      576 
      577 /* If database is empty, get out now. */
      578 	if record_count = 1 then go to RETURN_WHAT_WE_HAVE;
      579 
      580 /* leave space for extra records in case people are adding to database while we are extracting */
      581 	network_account_array_bound = record_count + NET_ARRAY_EXTRA_RECORD_COUNT;
      582 	allocate network_account_array in (caller_area) set (network_account_array_ptr);
      583 	network_account_array.version = NET_ACCT_ARRAY_VERSION_1;
      584 
      585 	network_account_array.count = 0;		/* no output records yet */
      586 
      587 /* position to the proper first record based on the entrypoint called thru */
      588 	if get_process_total_entry then do;
      589 
      590 /* locate 1st record with this process_id as part of key */
      591 	     seek_head_info_ptr = addr (seek_head_info_room);
      592 	     seek_head_info.relation_type = SEEK_HEAD_EQUAL_SEARCH; /* equal */
      593 	     auto_key.process_id = process_id_to_match;	/* copy process ID to search for */
      594 	     seek_head_info.n = length (unspec (auto_key.process_id)) / BITS_PER_CHAR;
      595 	     unspec (seek_head_info.search_key) = unspec (auto_key.process_id);
      596 	     call iox_$control (NAT_iocb_ptr, "seek_head", seek_head_info_ptr, error_code);
      597 	     if error_code ^= 0 then do;
      598 		if error_code ^= error_table_$no_record then
      599 		     call REPORT_ERROR (error_code, ABORT_YES, "finding 1st record for process_id");
      600 	     end;
      601 	end;
      602 	else do;
      603 	     call iox_$position (NAT_iocb_ptr, BOF, 0, error_code);
      604 	     if error_code ^= 0 then
      605 		call REPORT_ERROR (error_code, ABORT_YES, "position to beginning of file");
      606 	end;
      607 
      608 /* now loop through the NAT transfering data to the area for the user */
      609 	do while ("1"b);
      610 	     call RECORD_LOCK (error_code);		/* get a record */
      611 	     if error_code ^= 0 then do;
      612 		if error_code = error_table_$lock_wait_time_exceeded then
      613 		     go to position_to_next_record;
      614 		error_string = "lock current record";
      615 		go to RETURN_WHAT_WE_HAVE_WITH_ERROR;
      616 	     end;
      617 
      618 /* see if we've filled up the output array */
      619 	     if network_account_array.count + 1 > network_account_array.max_count then do;
      620 		P_code = 0;
      621 		go to RETURN_WHAT_WE_HAVE;
      622 	     end;
      623 
      624 /* skip over the special record used to clear the table on bootload */
      625 	     if NAR.process_id = INIT_RECORD_PID then
      626 		if NAR.session_handle = INIT_RECORD_SESSION_HANDLE then
      627 		     if NAR.network_id = INIT_RECORD_NETWORK_ID then
      628 			go to skip_this_record;
      629 
      630 /* if this is the get_process_total entrypoint and we have gone beyond the
      631*   last of the records for the process then stop now. */
      632 	     if get_process_total_entry then
      633 		if NAR.process_id > process_id_to_match then
      634 		     go to RETURN_WHAT_WE_HAVE;
      635 
      636 /* bump to location of output record, get ptr to same and clear it out */
      637 	     network_account_array.count = network_account_array.count + 1;
      638 	     network_account_data_ptr = addr (network_account_array.record (network_account_array.count));
      639 	     unspec (network_account_data) = "0"b;
      640 
      641 /* see if we should purge the record from the database.  Decision will be
      642*   based on fact there was no activity during last accounting update period,
      643*   the record has zero packet/byte counts and the process id is invalid
      644*
      645*   The record will only be purged IFF the caller is the Initializer
      646*   process and it was called through the read_and_reset_table entrypoint */
      647 
      648 	     if NAR.purged = OFF then do;
      649 		if NAR.active = OFF & NAR.packet_count = 0 & NAR.byte_count = 0 then do;
      650 		     call hcs_$validate_processid (NAR.process_id, purge_lock_error);
      651 		     if purge_lock_error = error_table_$process_unknown then do;
      652 			NAD.purged = ON;		/* show record should be purged */
      653 			NAR.purged = ON;
      654 			if i_am_initializer & reset_table_sw then do;
      655 			     NAR.delete_switch = ON;	/* show record should be deleted NOW */
      656 			     NAD.delete_sw = ON;
      657 			end;
      658 		     end;
      659 		end;
      660 	     end;
      661 
      662 /* copy data from NAT to output record */
      663 	     call READ_TABLE_COPY_NAT_DATA;
      664 
      665 /* if the caller entered through the read_and_reset_table or get_process_total
      666*   entries and is the initializer and the delete_switch is on
      667*   then delete the record */
      668 	     if i_am_initializer then
      669 		if reset_table_sw then
      670 		     if NAR.delete_switch = ON then
      671 			call RECORD_DELETE ();
      672 skip_this_record:
      673 
      674 /* unlock the record and position to the next record if needed.  This is only
      675*   done if the record wasn't deleted.  If it was deleted, already positioned
      676*   to next record */
      677 	     if record_locked_sw then do;
      678 		call RECORD_UNLOCK ();
      679 position_to_next_record:
      680 		call iox_$position (NAT_iocb_ptr, FORWARD, 1, error_code);
      681 		if error_code ^= 0 & error_code ^= error_table_$end_of_info then do;
      682 		     error_string = "position to next record";
      683 		     go to RETURN_WHAT_WE_HAVE_WITH_ERROR;
      684 		end;
      685 	     end;
      686 	end;
      687 RETURN_WHAT_WE_HAVE_WITH_ERROR:
      688 	if error_code ^= error_table_$end_of_info & error_code ^= error_table_$no_record then
      689 	     call REPORT_ERROR (error_code, ABORT_NO, error_string);
      690 
      691 RETURN_WHAT_WE_HAVE:
      692 	if debug_sw then do;
      693 	     if network_account_array_ptr = null then
      694 		call REPORT_ERROR (0, ABORT_NO, "Returning 0 entries");
      695 	     else call REPORT_ERROR (0, ABORT_NO, "Returning ^d entr^[y^;ies^]",
      696 		     network_account_array.count, network_account_array.count = 1);
      697 	end;
      698 	P_array_ptr = network_account_array_ptr;	/* pass location of array back to caller */
      699 	network_account_array_ptr = null;		/* any further errors do not affect returned info */
      700 
      701 	go to CLEANUP_AND_RETURN;
      702 
      703 /* This entry changes the pathname of the directory in which the
      704*   network_accounting_table (NAT) is located.  By default it is in
      705*   sys_info_$system_control_dir.
      706*
      707*   This entry is gated through network_accounting_gate_.
      708*
      709*   This entry is entended only for use during testing of the answering service. */
      710 
      711 test: entry (P_path);
      712 
      713 	database_directory = P_path;
      714 
      715 	if NAT_iocb_ptr ^= null then
      716 	     call NAT_CLOSE ();
      717 
      718 	return;
      719 
      720 CLEAN_UP: proc ();
      721 
      722 /* if we have a record locked, then unlock it */
      723 	if record_locked_sw then do;
      724 	     record_status_info.lock_sw = OFF;
      725 	     record_status_info.unlock_sw = ON;
      726 	     call iox_$control (NAT_iocb_ptr, "record_status", addr (record_status_info), error_code);
      727 	     record_locked_sw = OFF;
      728 	end;
      729 
      730 /* if we have an internal network_account_array allocated and this is an abort
      731*   then free the array */
      732 	if network_account_array_ptr ^= null then
      733 	     free network_account_array in (caller_area);
      734 
      735 /* return to the proper ring */
      736 	if saved_ring ^= -1 then
      737 	     call cu_$level_set (saved_ring);
      738 
      739      end CLEAN_UP;
      740 
      741 INIT1: proc ();
      742 
      743 /* get and save current ring and ring we will be going to
      744*   initialize any return argument values
      745*   and all internal switches & variables */
      746 
      747 	call cu_$level_get (saved_ring);		/* save level we were called from */
      748 	current_ring = get_ring_ ();
      749 
      750 	if error_code_arg_sw then
      751 	     P_code = 0;				/* clear return code */
      752 	if error_message_arg_sw then			/* if entry has return error message */
      753 	     P_error_message = "";			/* then start with it nice and clean */
      754 	record_locked_sw = OFF;			/* no record locked yet */
      755 	network_account_array_ptr = null;		/* so cleanup stays happy */
      756 	debug_sw = OFF;				/* start with it OFF */
      757 
      758 	if database_directory = "" then		/* uninitialized */
      759 	     database_directory = sys_info$system_control_dir;
      760 
      761 /* set up data for later lock/unlock record calls */
      762 	unspec (record_status_info) = "0"b;
      763 	record_status_info.version = rs_info_version_2;
      764 	record_status_info.record_ptr = null;
      765 
      766 	abort_label = CLEANUP_AND_RETURN;
      767 
      768      end INIT1;
      769 
      770 INIT2: proc ();
      771 
      772 /* now access the database */
      773 	call cu_$level_set (current_ring);		/* drop into the inner ring */
      774 
      775 /* the clear_table entrypoint will be doing it's own handling of the database
      776*   everyone else must get the database opened and set up */
      777 	if entrypoint_name = "clear_table" then return;
      778 
      779 	if NAT_iocb_ptr = null then
      780 	     call NAT_OPEN;
      781 
      782 /* locate Initializer's boot record */
      783 	auto_key.process_id = INIT_RECORD_PID;
      784 	auto_key.session_handle = INIT_RECORD_SESSION_HANDLE;
      785 	auto_key.network_id = INIT_RECORD_NETWORK_ID;
      786 	call RECORD_SEEK_AND_LOCK (CREATE_RECORD_NO, error_code);
      787 	if error_code ^= 0 then
      788 	     call REPORT_ERROR (error_code, ABORT_YES, "read initial record for debug flags");
      789 
      790 /* see if we have valid database */
      791 	if system_boot_time = 0 then
      792 	     call system_info_$timeup (system_boot_time);
      793 
      794 	if system_boot_time > NAR.update_time then do;
      795 	     call NAT_CLOSE ();			/* this one's no good */
      796 	     call REPORT_ERROR (error_table_$not_initialized, ABORT_YES, "Database not initialized");
      797 	end;
      798 
      799 /* setup the debug switch by looking for the initializer's dummy record */
      800 	debug_sw = debug_switch;
      801 
      802 	call RECORD_UNLOCK ();
      803 
      804      end INIT2;
      805 
      806 NAT_CLOSE: proc ();
      807 
      808 	if NAT_iocb_ptr ^= null then do;
      809 
      810 	     call iox_$close (NAT_iocb_ptr, error_code);
      811 	     if error_code ^= 0 then
      812 		call REPORT_ERROR (error_code, ABORT_NO, "close database");
      813 
      814 	     call iox_$detach_iocb (NAT_iocb_ptr, error_code);
      815 	     if error_code ^= 0 then
      816 		call REPORT_ERROR (error_code, ABORT_NO, "detach database");
      817 
      818 	     NAT_iocb_ptr = null;
      819 	end;
      820 
      821      end NAT_CLOSE;
      822 
      823 
      824 
      825 
      826 NAT_OPEN: proc ();
      827 
      828 dcl  stream_name char (32);
      829 dcl  attach_description char (168);
      830 
      831 	stream_name = "network_acct." || unique_chars_ (""b);
      832 	attach_description = "vfile_ " || rtrim (pathname_ (database_directory, TABLE_NAME));
      833 	attach_description = rtrim (attach_description) || " -stationary -share 10";
      834 
      835 	call iox_$attach_name (stream_name, NAT_iocb_ptr,
      836 	     attach_description, null, error_code);
      837 	if error_code ^= 0 then
      838 	     call REPORT_ERROR (error_code, ABORT_YES, "attaching ^a>^a",
      839 		database_directory, TABLE_NAME);
      840 	call iox_$open (NAT_iocb_ptr, Keyed_sequential_update, "0"b, error_code);
      841 	if error_code ^= 0 then do;
      842 
      843 /* if we couldn't open, make sure we get rid of it */
      844 	     call iox_$detach_iocb (NAT_iocb_ptr, (0));
      845 	     NAT_iocb_ptr = null;
      846 	     call REPORT_ERROR (error_code, ABORT_YES, "opening ^a>^a for update",
      847 		database_directory, TABLE_NAME);
      848 	end;
      849 
      850      end NAT_OPEN;
      851 
      852 READ_TABLE_COPY_NAT_DATA: proc ();
      853 
      854 /* copies data from the network_account_record (NAR) to the
      855*   network_account_data (NAD) record.
      856*
      857*   If called through the "read_and_reset_table", it will reset the data values
      858*   in the NAR;  otherwise, it sill leave the NAR alone */
      859 
      860 	NAD.key = NAR.key;
      861 	NAD.delete_sw = NAR.delete_switch;
      862 	NAD.purged = NAR.purged;
      863 	NAD.unassigned_sw = NAR.unassigned_switch;
      864 	NAD.byte_count = NAR.byte_count;
      865 	NAD.packet_count = NAR.packet_count;
      866 
      867 /* compute connect seconds (rounding up if needed) to return to the caller */
      868 	delta_time = divide (NAR.connected_time + MICROSECONDS_PER_HALF_SECOND,
      869 	     MICROSECONDS_PER_SECOND, 35, 0);
      870 	if NAR.unassigned_switch = OFF then do;
      871 	     delta_time = delta_time + divide ((clock () - NAR.update_time) + MICROSECONDS_PER_HALF_SECOND,
      872 		MICROSECONDS_PER_SECOND, 35, 0);
      873 	end;
      874 	NAD.connect_time = delta_time;
      875 
      876 /* reset incremental data values for next update interval and
      877*   reset activity indicator so we can see if record was active */
      878 	if reset_table_sw = ON then do;
      879 	     NAR.byte_count,
      880 		NAR.packet_count,
      881 		NAR.connected_time = 0;
      882 	     if NAR.unassigned_switch = OFF then
      883 		NAR.update_time = clock ();
      884 	     NAR.active = OFF;
      885 	end;
      886 
      887      end READ_TABLE_COPY_NAT_DATA;
      888 
      889 RECORD_DELETE: proc ();
      890 
      891 /* subroutine to delete the record currently being accessed.
      892*   This will implicitly unlock the record (nothing there) and
      893*   position to next record in the file */
      894 
      895 	if debug_sw then do;
      896 	     call REPORT_ERROR (0, ABORT_NO,
      897 		"Deleting record, PID=^.3b, SID=^w",
      898 		NAR.process_id, NAR.session_handle);
      899 	end;
      900 
      901 	call iox_$delete_record (NAT_iocb_ptr, error_code);
      902 	if error_code ^= 0 then do;
      903 	     if error_code = error_table_$locked_by_this_process then ; /* IGNORE, record is gone anyway */
      904 	     else do;
      905 		call REPORT_ERROR (error_code, ABORT_NO,
      906 		     "Unable to delete closed record for PID ^w, handle ^w",
      907 		     NAR.process_id, NAR.session_handle);
      908 	     end;
      909 	end;
      910 	record_locked_sw = OFF;
      911 
      912      end RECORD_DELETE;
      913 
      914 RECORD_LOCK: proc (P_code);
      915 
      916 /* lock the current record pointed to by rs_info in the database */
      917 
      918 dcl  (P_code, error_code) fixed bin (35);
      919 
      920 	P_code = 0;
      921 
      922 	record_locked_sw = ON;
      923 	record_status_info.lock_sw = ON;
      924 	record_status_info.unlock_sw = OFF;
      925 	call iox_$control (NAT_iocb_ptr, "record_status", addr (record_status_info), error_code);
      926 	if error_code ^= 0 then do;
      927 
      928 /* ignore any of the normal ignorable locking errors */
      929 	     if error_code = error_table_$invalid_lock_reset
      930 		| error_code = error_table_$lock_wait_time_exceeded
      931 		| error_code = error_table_$locked_by_this_process then ;
      932 	     else do;
      933 		P_code = error_code;
      934 		return;
      935 	     end;
      936 	end;
      937 
      938 /* return ptr to the NAT data record */
      939 	network_account_record_ptr = record_status_info.record_ptr;
      940 
      941 	return;
      942 
      943      end RECORD_LOCK;
      944 
      945 RECORD_SEEK_AND_LOCK: proc (create_record_flag, error_code);
      946 
      947 /* this procedure will seek for record defined by values in auto_key
      948*
      949*   If it doesn't find it and the create_record flag is ON, it will create a
      950*   record using values in auto_key and current clock time.
      951*
      952*   It will also lock the record prior to return */
      953 
      954 dcl  create_record_flag bit (1);
      955 dcl  error_code fixed bin (35);
      956 
      957 /* attempt to locate record desired */
      958 	call iox_$seek_key (NAT_iocb_ptr, (key_char_overlay), (0), error_code);
      959 	if error_code ^= 0 then do;			/* some sort of problem */
      960 	     if error_code = error_table_$no_record	/* record not there */
      961 		& create_record_flag then do;		/* and we should create */
      962 		if debug_sw then do;
      963 		     call REPORT_ERROR (0, ABORT_NO,
      964 			"seek_key: Creating record. PID=^.3b, SH=^w, NID=^2d",
      965 			auto_key.process_id,
      966 			auto_key.session_handle, auto_key.network_id);
      967 		end;
      968 
      969 		unspec (auto_NAR) = "0"b;
      970 		auto_NAR.version = NET_ACCT_RECORD_VERSION_1;
      971 		auto_NAR.key = auto_key;
      972 		auto_NAR.update_time = clock ();
      973 		call iox_$write_record (NAT_iocb_ptr, addr (auto_NAR), size (auto_NAR) * CHARS_PER_WORD, error_code);
      974 		if error_code ^= 0 then
      975 		     call REPORT_ERROR (error_code, ABORT_YES, "add a record");
      976 	     end;
      977 	     else call REPORT_ERROR (error_code, ABORT_YES, "seek specified record");
      978 	end;
      979 
      980 	call RECORD_LOCK (error_code);
      981 
      982      end RECORD_SEEK_AND_LOCK;
      983 
      984 RECORD_UNLOCK: proc ();
      985 
      986 /* unlock the current record pointed to by rs_info in the database */
      987 
      988 dcl  error_code fixed bin (35);
      989 
      990 	if ^record_locked_sw then return;		/* not locked so all done */
      991 
      992 	record_status_info.lock_sw = OFF;
      993 	record_status_info.unlock_sw = ON;
      994 	call iox_$control (NAT_iocb_ptr, "record_status", addr (record_status_info), error_code);
      995 	if error_code ^= 0 then
      996 	     call REPORT_ERROR (error_code, ABORT_YES, "unlock record");
      997 
      998 	record_locked_sw = OFF;
      999 
     1000      end RECORD_UNLOCK;
     1001 
     1002 REPORT_ERROR: proc options (variable);
     1003 
     1004 /* sets return error code and message, if available.  Puts message into the
     1005*   system log also.  Does non-local goto to get out of network accounting
     1006*   if told to do so. */
     1007 
     1008 /* arg	     meaning
     1009*   1	     error code
     1010*   2	     non-local goto flag
     1011*   3	     ioa_ control string
     1012*   4...	     optional arguments */
     1013 
     1014 /* following gate is for debugging only and is not released with system */
     1015 /**** dcl  ring2_nat_debug_$syserr_error_code entry options (variable); */
     1016 
     1017 dcl  error_code_to_return fixed bin (35) based (error_code_ptr);
     1018 dcl  abort_flag bit (1) based (abort_flag_ptr);
     1019 
     1020 dcl  (arg_list_ptr, error_code_ptr, abort_flag_ptr) ptr;
     1021 dcl  buffer char (500);
     1022 dcl  int_code fixed bin (35);
     1023 dcl  len fixed bin (21);
     1024 
     1025 /* get individual arg ptrs for 1st 2 args */
     1026 	call cu_$arg_list_ptr (arg_list_ptr);
     1027 	call cu_$arg_ptr (1, error_code_ptr, (0), int_code);
     1028 	call cu_$arg_ptr (2, abort_flag_ptr, (0), int_code);
     1029 
     1030 	if error_code_arg_sw then
     1031 	     P_code = error_code_to_return;		/* set return node */
     1032 
     1033 /* generate error message */
     1034 	call ioa_$general_rs (arg_list_ptr, 3, 4, buffer, len,
     1035 	     "1"b /* PAD STRING */, "0"b /* NO NL */);
     1036 
     1037 	if error_message_arg_sw then			/* return to user if we can */
     1038 	     P_error_message = substr (buffer, 1, len);
     1039 
     1040 /* stuff the error in the system log */
     1041 	if debug_sw then do;
     1042 
     1043 /**** Following commented out for release.  Gate not shipped with release */
     1044 /****	     call ring2_nat_debug_$syserr_error_code (SYSERR_LOG_OR_PRINT, */
     1045 /****		error_code_to_return, "^a$^a: ^a", ME, entrypoint_name, */
     1046 /**** 		substr (buffer, 1, len)); */
     1047 	end;
     1048 
     1049 	if abort_flag then
     1050 	     go to abort_label;
     1051 
     1052      end REPORT_ERROR;
     1053  /* Begin include file -- acl_structures.incl.pl1 BIM 3/82 */
  1     2 /* format: style3,indcomtxt,idind30 */
  1     3 
  1     4 declare   acl_ptr                       pointer;
  1     5 declare   acl_count                     fixed bin;
  1     6 
  1     7 declare 1 general_acl                   aligned based (acl_ptr), /* for fs_util_ */
  1     8           2 version                     char (8) aligned,
  1     9           2 count                       fixed bin,
  1    10           2 entries                     (acl_count refer (general_acl.count)) aligned like general_acl_entry;
  1    11 
  1    12 declare 1 general_acl_entry             based,
  1    13           2 access_name                 character (32) unaligned,
  1    14           2 mode                        bit (36) aligned,
  1    15           2 status_code                 fixed bin (35);
  1    16 
  1    17 
  1    18 declare 1 general_extended_acl          aligned based (acl_ptr), /* for fs_util_ */
  1    19           2 version                     char (8) aligned,
  1    20           2 count                       fixed bin,
  1    21           2 entries                     (acl_count refer (general_extended_acl.count)) aligned like general_extended_acl_entry;
  1    22 
  1    23 declare 1 general_extended_acl_entry    aligned based,
  1    24           2 access_name                 character (32) unaligned,
  1    25           2 mode                        bit (36) aligned,
  1    26           2 extended_mode               bit (36) aligned,
  1    27           2 status_code                 fixed bin (35);
  1    28 
  1    29 
  1    30 declare 1 general_delete_acl            aligned based (acl_ptr), /* for file_system_ */
  1    31           2 version                     char (8) aligned,
  1    32           2 count                       fixed bin,
  1    33           2 entries                     (acl_count refer (general_delete_acl.count)) aligned like delete_acl_entry;
  1    34 
  1    35 declare 1 general_delete_acl_entry      aligned based,
  1    36           2 access_name                 character (32) unaligned,
  1    37           2 status_code                 fixed bin (35);
  1    38 
  1    39 
  1    40 declare 1 segment_acl                   aligned based (acl_ptr),
  1    41           2 version                     fixed bin,
  1    42           2 count                       fixed bin,
  1    43           2 entries                     (acl_count refer (segment_acl.count)) aligned like segment_acl_entry;
  1    44 
  1    45 declare 1 segment_acl_entry             like general_extended_acl_entry aligned based;
  1    46 declare 1 segment_acl_array             (acl_count) aligned like segment_acl_entry based (acl_ptr);
  1    47 
  1    48 
  1    49 declare 1 directory_acl                 aligned based (acl_ptr),
  1    50           2 version                     fixed bin,
  1    51           2 count                       fixed bin,
  1    52           2 entries                     (acl_count refer (directory_acl.count)) aligned like directory_acl_entry;
  1    53 
  1    54 declare 1 directory_acl_entry           like general_acl_entry aligned based;
  1    55 declare 1 directory_acl_array           (acl_count) aligned like directory_acl_entry based (acl_ptr);
  1    56 
  1    57 
  1    58 declare 1 delete_acl                    based (acl_ptr) aligned,
  1    59           2 version                     fixed bin,
  1    60           2 count                       fixed bin,
  1    61           2 entries                     (acl_count refer (delete_acl.count)) aligned like delete_acl_entry;
  1    62 
  1    63 declare 1 delete_acl_entry              like general_delete_acl_entry aligned based;
  1    64 declare 1 delete_acl_array              (acl_count) aligned like delete_acl_entry based (acl_ptr);
  1    65 
  1    66 
  1    67 declare  (SEG_ACL_VERSION_1             init ("sga1"),
  1    68           DIR_ACL_VERSION_1             init ("dra1"),
  1    69           DELETE_ACL_VERSION_1          init ("dla1"))
  1    70                                         char (4) int static options (constant);
  1    71 
  1    72 declare  (GENERAL_ACL_VERSION_1         init ("gacl001"),
  1    73           GENERAL_EXTENDED_ACL_VERSION_1 init ("gxacl001"),
  1    74           GENERAL_DELETE_ACL_VERSION_1  init ("gdacl001"))
  1    75                                         char (8) internal static options (constant);
  1    76 
  1    77 declare   ACL_VERSION_1                 fixed bin init (1) int static options (constant);
  1    78 
  1    79 /* End include file acl_structures.incl.pl1 */
     1053 
     1054  /* Begin include file ..... iox_modes.incl.pl1 */
  2     2 
  2     3 /* Written by C. D. Tavares, 03/17/75 */
  2     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  2     5 
  2     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  2     7     ("stream_input", "stream_output", "stream_input_output",
  2     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  2     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  2    10      "direct_input", "direct_output", "direct_update");
  2    11 
  2    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  2    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  2    14 
  2    15 dcl (Stream_input initial (1),
  2    16      Stream_output initial (2),
  2    17      Stream_input_output initial (3),
  2    18      Sequential_input initial (4),
  2    19      Sequential_output initial (5),
  2    20      Sequential_input_output initial (6),
  2    21      Sequential_update initial (7),
  2    22      Keyed_sequential_input initial (8),
  2    23      Keyed_sequential_output initial (9),
  2    24      Keyed_sequential_update initial (10),
  2    25      Direct_input initial (11),
  2    26      Direct_output initial (12),
  2    27      Direct_update initial (13)) fixed bin int static options (constant);
  2    28 
  2    29 /* End include file ..... iox_modes.incl.pl1 */
     1054 
     1055  /* BEGIN INCLUDE FILE:  network_account_array.incl.pl1  */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(86-02-21,Herbst), approve(87-07-31,MCR7694),
  3     5*     audit(87-07-31,GDixon), install(87-08-04,MR12.1-1056):
  3     6*     Added process_id field and replaced group_id with it in the key.
  3     7*  2) change(87-04-09,Brunelle), approve(87-07-31,MCR7694),
  3     8*     audit(87-07-31,GDixon), install(87-08-04,MR12.1-1056):
  3     9*     Completely restructured.
  3    10*  3) change(87-05-07,Brunelle), approve(87-07-31,MCR7694),
  3    11*     audit(87-07-31,GDixon), install(87-08-04,MR12.1-1056):
  3    12*     Added purged and accounting bit fields.
  3    13*  4) change(87-07-31,Brunelle), approve(87-07-31,MCR7694),
  3    14*     audit(87-07-31,GDixon), install(87-08-04,MR12.1-1056):
  3    15*     Moved version field from the network_account_data structure to the
  3    16*     network_account_array structure and changed the value of the constant to
  3    17*     reflect the move.
  3    18*                                                   END HISTORY COMMENTS */
  3    19 
  3    20 /* format: style4 */
  3    21 /* used by the $dump_table, $get_process_total and $read_and_reset_table 
  3    22*   entrypoints of network_accounting_.pl1 */
  3    23 
  3    24 dcl  network_account_array_ptr ptr;
  3    25 dcl  network_account_array_bound fixed bin;
  3    26 
  3    27 dcl  1 network_account_array aligned based (network_account_array_ptr),
  3    28        2 version char (8),
  3    29        2 max_count fixed bin,
  3    30        2 count fixed bin,
  3    31        2 record (network_account_array_bound refer (network_account_array.max_count))
  3    32 	  aligned like network_account_data;
  3    33 
  3    34 dcl  network_account_data_ptr ptr;
  3    35 
  3    36 dcl  1 network_account_data aligned based (network_account_data_ptr),
  3    37        2 key,
  3    38          3 process_id bit (36) aligned,			/* of the process using the connection */
  3    39          3 session_handle fixed bin (35),		/* identifier of the connection being charged */
  3    40          3 network_id fixed bin (35),			/* identifies the network being used */
  3    41        2 switches unaligned,
  3    42          3 delete_sw bit (1) unaligned,			/* delete entry when next read */
  3    43          3 unassigned_sw bit (1) unaligned,		/* owner connected to the session */
  3    44          3 purged bit (1) unaligned,			/* network_accounting_ purged this record */
  3    45          3 accounting bit (1) unaligned,		/* used by act_ctl_ */
  3    46          3 mbz bit (32) unaligned,
  3    47        2 connect_time fixed bin (35),			/* incremental seconds of connect time to charge */
  3    48        2 byte_count fixed bin (35),			/* incremental count of bytes to be charged */
  3    49        2 packet_count fixed bin (35);			/* incremental count of packets to be charged */
  3    50 
  3    51 dcl  NET_ACCT_ARRAY_VERSION_1 char (8) int static options (constant) init ("NETACTA1");
  3    52 
  3    53 /* END INCLUDE FILE:  network_account_array.incl.pl1 */
     1055 
     1056 dcl  1 NAD aligned based (network_account_data_ptr) like network_account_data;
     1057  /* BEGIN INCLUDE FILE:  network_account_record.incl.pl1  */
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(87-03-24,Brunelle), approve(87-07-31,MCR7694),
  4     5*     audit(87-08-03,GDixon), install(87-08-04,MR12.1-1056):
  4     6*     Created.
  4     7*  2) change(87-05-07,Brunelle), approve(87-07-31,MCR7694),
  4     8*     audit(87-08-03,GDixon), install(87-08-04,MR12.1-1056):
  4     9*     Added active bit field.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 /* format: style4 */
  4    13 /* this defines the network accounting record as found in the database
  4    14*   (network_account_table). */
  4    15 
  4    16 dcl  network_account_record_ptr ptr;
  4    17 
  4    18 dcl  1 network_account_record aligned based (network_account_record_ptr),
  4    19        2 version char (8),
  4    20        2 key,
  4    21          3 process_id bit (36) aligned,			/* of the process using the connection */
  4    22          3 session_handle fixed bin (35),		/* identifier of the connection being charged */
  4    23          3 network_id fixed bin (35),			/* identifies the network being used */
  4    24        2 switches unaligned,
  4    25          3 delete_switch bit (1) unaligned,		/* delete entry when next read */
  4    26          3 unassigned_switch bit (1) unaligned,		/* OFF if process associated with process_id is using the connection.
  4    27*						   ON  if altername process is using the connection.
  4    28*						   If process_id identifies the owner of the connection
  4    29*						   (login_server), then the altername process is the
  4    30*						   user process.  If process_id identifies a user process,
  4    31*						   then alternate process is the owner process.
  4    32*						   The connection must be assigned to one or the other. */
  4    33          3 purged bit (1) unaligned,			/* purged due to inactivity */
  4    34          3 active bit (1) unaligned,			/* used to determine activity during accounting update interval */
  4    35          3 mbz bit (32) unaligned,
  4    36        2 connected_time fixed bin (71),			/* excess connect time to be added when unassigned_switch on */
  4    37        2 update_time fixed bin (71),			/* time record last updated when unassigned_switch off */
  4    38        2 byte_count fixed bin (35),			/* bytes charged so far */
  4    39        2 packet_count fixed bin (35);			/* packets charged so far */
  4    40 
  4    41 dcl  NET_ACCT_RECORD_VERSION_1 char (8) int static options (constant) init ("NETACTR1");
  4    42 						/* END INCLUDE FILE:  network_account_record.incl.pl1 */
     1057 
     1058 dcl  1 NAR aligned based (network_account_record_ptr) like network_account_record;
     1059  /* BEGIN INCLUDE FILE: network_channel_use.incl.pl1 */
  5     2 
  5     3 /****^  HISTORY COMMENTS:
  5     4*  1) change(87-03-24,Brunelle), approve(87-07-31,MCR7694),
  5     5*     audit(87-07-31,GDixon), install(87-08-04,MR12.1-1056):
  5     6*     Created.
  5     7*                                                   END HISTORY COMMENTS */
  5     8 
  5     9 /* format: style4 */
  5    10 
  5    11 dcl network_channel_use_ptr ptr;
  5    12 dcl  1 network_channel_use aligned based (network_channel_use_ptr),
  5    13        2 version char (8),
  5    14        2 network_id fixed bin,			/* Type of network connection is for */
  5    15        2 session_handle fixed bin (35),			/* unique ID for the current session */
  5    16        2 owner_pid bit (36) aligned,			/* PID of owner of the session */
  5    17        2 user_pid bit (36) aligned,			/* PID of the user of the session */
  5    18        2 session_state fixed bin,			/* current state of the connection */
  5    19        2 packet_count fixed bin (17),			/* # of additional packets to charge for */
  5    20        2 byte_count fixed bin (17);			/* # of additional bytes to charge for */
  5    21 
  5    22 /* the following are for the session state field */
  5    23 
  5    24 dcl  CREATE_SESSION fixed bin int static options (constant) init (1);
  5    25 dcl  ASSIGN_CONNECTION fixed bin int static options (constant) init (2);
  5    26 dcl  UPDATE_CONNECTION fixed bin int static options (constant) init (3);
  5    27 dcl  UNASSIGN_CONNECTION fixed bin int static options (constant) init (4);
  5    28 dcl  DESTROY_SESSION fixed bin int static options (constant) init (5);
  5    29 
  5    30 dcl  NETWORK_CHANNEL_USE_INFO_VERSION_1 char (8) int static options (constant) init ("NETCHN01");
  5    31 
  5    32 /* END INCLUDE FILE: network_channel_use.incl.pl1 */
     1059 
     1060 dcl  1 NCU aligned based (network_channel_use_ptr) like network_channel_use;
     1061  /* include file for info structure used with record_status control order
  6     2*   created by M. Asherman 1/6/76 */
  6     3 /* modified 6/15/77 to support stationary type records */
  6     4 
  6     5      dcl	   rs_info_ptr	      ptr;
  6     6      dcl	   1 rs_info	      based (rs_info_ptr) aligned,
  6     7 	     2 version	      fixed,		/* must be set to 1 or 2 (Input) */
  6     8 	     2 flags	      aligned,
  6     9 	       3 lock_sw	      bit (1) unal,		/* Input -- if ="1"b  try to lock record */
  6    10 	       3 unlock_sw	      bit (1) unal,		/* Input -- if ="1"b try to unlock record */
  6    11 	       3 create_sw	      bit (1) unal,		/* Input--if set creat new record */
  6    12 	       3 locate_sw	      bit (1) unal,		/* Input--if set causes current rec to be
  6    13*						   located outside the index by descrip, or created without key */
  6    14 	       3 inc_ref_count    bit (1) unal,		/* Input--bump reference count of record, if stationary */
  6    15 	       3 dec_ref_count    bit (1) unal,		/* Input--decrement ref count if this flag set and record stationary */
  6    16 	       3 locate_pos_sw    bit (1) unal,		/* Input--if set the record_length is taken
  6    17*						   as an input argument specifying the absolute logical record positioni	  to which both the current and next positions will be set */
  6    18 	       3 mbz1	      bit (29) unal,	/* must be set to "0"b, reserved for future use */
  6    19 	     2 record_length      fixed (21),		/* length in bytes, Input if create_sw set */
  6    20 	     2 max_rec_len	      fixed (21),		/* max length of contained record
  6    21*						   Input if create_sw is set--overrides min_block_size in effect */
  6    22 	     2 record_ptr	      ptr,		/* points to first byte of record--will be word aligned */
  6    23 	     2 descriptor	      fixed (35),		/* Input if locate_sw set and create_sw="0"b */
  6    24 	     2 ref_count	      fixed (34),		/* Output--should match number of keys on this record-- = -1 if non-stationary record */
  6    25 	     2 time_last_modified fixed (71),		/* Output */
  6    26 	     2 modifier	      fixed (35),		/* Output--also Input when locking */
  6    27 	     2 block_ptr	      ptr unal,		/* Output */
  6    28 	     2 last_image_modifier
  6    29 			      fixed (35),
  6    30 	     2 mbz2	      fixed;
  6    31 
  6    32      dcl	   1 rs_desc	      based (addr (rs_info.descriptor)),
  6    33 						/* record block descriptor structure */
  6    34 	     2 comp_num	      fixed (17) unal,	/* msf component number */
  6    35 	     2 offset	      bit (18) unal;	/* word offset of record block */
  6    36 
  6    37      dcl	   1 seq_desc	      based (addr (rs_info.descriptor)),
  6    38 						/* for sequential files */
  6    39 	     2 bitno	      bit (6) unal,
  6    40 	     2 comp_num	      fixed (11) unal,	/* msf component number */
  6    41 	     2 wordno	      bit (18) unal;	/* word offset */
  6    42 
  6    43      dcl	   rs_info_version_1      static internal fixed init (1);
  6    44      dcl	   rs_info_version_2      static internal fixed init (2);
  6    45 
     1061 
     1062  /* BEGIN INCLUDE FILE ... system_constants.incl.pl1 */
  7     2 
  7     3 /****^  HISTORY COMMENTS:
  7     4*  1) change(86-11-12,GWMay), approve(86-11-12,MCR7445), audit(86-11-19,GDixon),
  7     5*     install(86-11-21,MR12.0-1223):
  7     6*     created.
  7     7*                                                   END HISTORY COMMENTS */
  7     8 
  7     9 /* format: off */
  7    10 
  7    11 /* ************************************************************************ */
  7    12 /*							      */
  7    13 /* Function: Provides constants for commonly used Multics system values.    */
  7    14 /*							      */
  7    15 /* Usage: These values are available for use in place of "magic" numbers    */
  7    16 /*        (unexplained numbers) in programming applications.	      */
  7    17 /*							      */
  7    18 /* Definitions:						      */
  7    19 /*							      */
  7    20 /*   PER             bit     character/byte     word     page     segment   */
  7    21 /*		 					      */
  7    22 /*   bits              1            9             36     36864    9400320   */
  7    23 /*   characters/bytes	      1	           4      4096    1044480   */
  7    24 /*   words				 1      1024     261120   */
  7    25 /*   pages				           1        255   */
  7    26 /*   segments						  1   */
  7    27 /*							      */
  7    28 /*  The base values for a bit, char, word and page are determined by the    */
  7    29 /*  Multics hardware implementation.  The other values are calculated from  */
  7    30 /*  their relation to one another as shown in the matrix above.	      */
  7    31 /*							      */
  7    32 /*  BITS_PER_CHAR     = 9 (defined by the hardware)		      */
  7    33 /*  BITS_PER_WORD     = BITS_PER_CHAR * CHARS_PER_WORD		      */
  7    34 /*		  = 9 * 4					      */
  7    35 /*		  = 36					      */
  7    36 /*  BITS_PER_PAGE     = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE     */
  7    37 /*		  = 9 * 4 * 1024				      */
  7    38 /*		  = 36864					      */
  7    39 /*  BITS_PER_SEGMENT  = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE *   */
  7    40 /*		    PAGES_PER_SEGMENT			      */
  7    41 /*		  = 9 * 4 * 1024 * 255			      */
  7    42 /*		  = 9400320				      */
  7    43 /*							      */
  7    44 /*  CHARS_PER_WORD    = 4 (defined by the hardware)		      */
  7    45 /*  CHARS_PER_PAGE    = CHARS_PER_WORD * WORDS_PER_PAGE		      */
  7    46 /*		  = 4 * 1024				      */
  7    47 /*		  = 4096					      */
  7    48 /*  CHARS_PER_SEGMENT = CHARS_PER_WORD * WORDS_PER_PAGE * PAGES_PER_SEGMENT */
  7    49 /*		  = 4 * 1024 * 255				      */
  7    50 /*		  = 1044480				      */
  7    51 /*							      */
  7    52 /*  WORDS_PER_PAGE    = 1024 (defined by the hardware)		      */
  7    53 /*  WORDS_PER_SEGMENT = WORDS_PER_PAGE * PAGES_PER_SEGMENT		      */
  7    54 /*		  = 1024 * 255				      */
  7    55 /*		  = 261120				      */
  7    56 /*							      */
  7    57 /*  PAGES_PER_SEGMENT = 255 (defined by system standard)		      */
  7    58 /*							      */
  7    59 /* ************************************************************************ */
  7    60 
  7    61        declare BITS_PER_CHAR		fixed bin (4) internal static
  7    62 				options (constant) initial (9);
  7    63 
  7    64        declare BITS_PER_WORD		fixed bin (6) internal static
  7    65 				options (constant) initial (36);
  7    66 
  7    67        declare BITS_PER_PAGE		fixed bin (16) internal static
  7    68 				options (constant) initial (36864);
  7    69 
  7    70        declare BITS_PER_SEGMENT	fixed bin (24) internal static
  7    71 				options (constant) initial (9400320);
  7    72 
  7    73        declare CHARS_PER_WORD		fixed bin (3) internal static
  7    74 				options (constant) initial (4);
  7    75 
  7    76        declare CHARS_PER_PAGE		fixed bin (13) internal static
  7    77 				options (constant) initial (4096);
  7    78 
  7    79        declare CHARS_PER_SEGMENT	fixed bin (21) internal static
  7    80 				options (constant) initial (1044480);
  7    81 
  7    82        /* Note: WORDS_PER_PAGE should be equal to sys_info$max_page_size    */
  7    83 
  7    84        declare WORDS_PER_PAGE		fixed bin (11) internal static
  7    85 				options (constant) initial (1024);
  7    86 
  7    87        /* Note: WORDS_PER_SEGMENT should be equal to sys_info$max_seg_size  */
  7    88 
  7    89        declare WORDS_PER_SEGMENT	fixed bin (21) internal static
  7    90 				options (constant) initial (261120);
  7    91 
  7    92        declare PAGES_PER_SEGMENT	fixed bin (8) internal static
  7    93 				options (constant) initial (255);
  7    94 
  7    95 /* END INCLUDE FILE ... system_constants.incl.pl1 */
  7    96 
     1062 
     1063       dcl	   1 uns_info	      based (addr (info)),	/* info structure for unstructured files */
  8     2 	     2 info_version	      fixed,		/* (Input) must =1--only one version
  8     3*						   currently supported */
  8     4 	     2 type	      fixed,		/* =1 */
  8     5 	     2 end_pos	      fixed (34),		/* length (bytes) not including header */
  8     6 	     2 flags	      aligned,
  8     7 	       3 pad1	      bit (2) unal,		/* used for lock_status in other files */
  8     8 	       3 header_present   bit (1) unal,		/* on if file code is set */
  8     9 	       3 pad2	      bit (33) unal,
  8    10 	     2 header_id	      fixed (35);		/* meaning is user defined */
  8    11      dcl	   1 seq_info	      based (addr (info)),	/* info structure for sequential files */
  8    12 	     2 info_version	      fixed,
  8    13 	     2 type	      fixed,		/* =2 */
  8    14 	     2 end_pos	      fixed (34),		/* record count */
  8    15 	     2 flags	      aligned,
  8    16 	       3 lock_status      bit (2) unal,		/* 0,1,2, or 3 to indicate not locked,
  8    17*						   locked by (other,this,dead) process */
  8    18 	       3 pad	      bit (34) unal,
  8    19 	     2 version	      fixed,		/* end_pos valid only in latest version */
  8    20 	     2 action	      fixed;		/* indicates if adjustment or rollback is needed */
  8    21      dcl	   1 blk_info	      based (addr (info)),	/* info structure for blocked files */
  8    22 	     2 info_version	      fixed,
  8    23 	     2 type	      fixed,		/* =3 */
  8    24 	     2 end_pos	      fixed (34),		/* record count */
  8    25 	     2 flags	      aligned,
  8    26 	       3 lock_status      bit (2) unal,		/* same as seq_info.= */
  8    27 	       3 pad	      bit (34) unal,
  8    28 	     2 version	      fixed,		/* only one currently supported */
  8    29 	     2 action	      fixed,		/* non-zero if truncation in progress, else =0 */
  8    30 	     2 max_rec_len	      fixed (21),		/* bytes--determines characteristiWc block size */
  8    31 	     2 pad	      fixed,		/* not used at this time */
  8    32 	     2 time_last_modified fixed (71);		/* time stamp for synchronization */
  8    33      dcl	   1 indx_info	      based (addr (info)),	/* info structure for indexed files */
  8    34 	     2 info_version	      fixed,
  8    35 	     2 type	      fixed,		/* =4 */
  8    36 	     2 records	      fixed (34),		/* record count */
  8    37 	     2 flags	      aligned,
  8    38 	       3 lock_status      bit (2) unal,		/* same as seq_info.= */
  8    39 	       3 pad	      bit (34) unal,
  8    40 	     2 version_info	      aligned,
  8    41 	       3 file_version     fixed (17) unal,	/* headers differ */
  8    42 	       3 program_version  fixed (17) unal,	/* may indicate bugs */
  8    43 	     2 action	      fixed,		/* non-zero code indicates update in progress */
  8    44 	     2 non_null_recs      fixed (34),		/* count of allocated recs */
  8    45 	     2 record_bytes	      fixed (34),		/* total record length */
  8    46 	     2 free_blocks	      fixed,		/* available record blocks */
  8    47 	     2 index_height	      fixed,		/* height of index tree (0 if empty) */
  8    48 	     2 nodes	      fixed,		/* nodes being used in the index */
  8    49 	     2 key_bytes	      fixed (34),		/* total length of keys */
  8    50 	     2 change_count	      fixed (35),		/* bumped on each file modification */
  8    51 	     2 num_keys	      fixed (34),		/* number of index entries */
  8    52 	     2 dup_keys	      fixed (34),		/* 0 if all keys are distinct, else 1 for each dup */
  8    53 	     2 dup_key_bytes      fixed (34),		/* total bytes of duplicate keys */
  8    54 	     2 word	      (1) fixed;		/* reserved for future use */
  8    55      dcl	   1 vbl_info	      based (addr (info)),	/* info structure for variable files */
  8    56 	     2 info_version	      fixed,
  8    57 	     2 type	      fixed,		/* =5 */
  8    58 	     2 end_pos	      fixed (34),		/* logical end of file--not necessarily allocation count */
  8    59 	     2 flags	      aligned,
  8    60 	       3 lock_status      bit (2) unal,		/* same as seq_info.= */
  8    61 	       3 pad	      bit (34) unal,
  8    62 	     2 version	      fixed,		/* only one currently supported */
  8    63 	     2 action	      fixed,		/* same as in indexed files */
  8    64 	     2 first_nz	      fixed (34),		/* position (numeric key) for first allocated record */
  8    65 	     2 last_nz	      fixed (34),		/* last allocated record position */
  8    66 	     2 change_count	      fixed (35);		/* used for synchronization */
  8    67      dcl	   vfs_version_1	      static internal fixed init (1);
  8    68 						/* should be used in
  8    69*						   assignments to info_version */
     1063 
     1064 
     1065      end network_accounting_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/25/87  0827.8  network_accounting_.pl1           >spec>install>1003>network_accounting_.pl1
1053         1    10/14/83  1606.6  acl_structures.incl.pl1           >ldd>include>acl_structures.incl.pl1
1054         2    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
1055         3    08/06/87  0913.5  network_account_array.incl.pl1    >ldd>include>network_account_array.incl.pl1
1057         4    08/06/87  0913.5  network_account_record.incl.pl1   >ldd>include>network_account_record.incl.pl1
1059         5    08/06/87  0913.5  network_channel_use.incl.pl1      >ldd>include>network_channel_use.incl.pl1
1061         6    07/19/79  1547.0  rs_info.incl.pl1                  >ldd>include>rs_info.incl.pl1
1062         7    11/24/86  1243.9  system_constants.incl.pl1         >ldd>include>system_constants.incl.pl1
1063         8    07/19/79  1547.0  vfs_info.incl.pl1                 >ldd>include>vfs_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABORT_NO                        000074 constant        bit(1)                   initial unaligned dcl 96 set ref 184* 203* 233* 286*
                                                                                  317* 369* 430* 435* 562* 687* 693* 695* 811* 815*
                                                                                  896* 905* 963*
ABORT_YES                       000054 constant        bit(1)                   initial unaligned dcl 97 set ref 214* 243* 262* 296*
                                                                                  327* 348* 379* 442* 467* 573* 598* 604* 787* 796*
                                                                                  837* 846* 974* 977* 995*
BITS_PER_CHAR                   005546 constant        fixed bin(4,0)           initial dcl 7-61 ref 594
BOF                             000070 constant        fixed bin(17,0)          initial dcl 98 set ref 603*
CHARS_PER_WORD                         constant        fixed bin(3,0)           initial dcl 7-73 ref 958 973
CREATE_RECORD_NO                       constant        bit(1)                   initial unaligned dcl 99 set ref 786*
CREATE_RECORD_YES                      constant        bit(1)                   initial unaligned dcl 100 set ref 213* 242* 261*
                                                                                  295* 326* 347* 378* 461*
FORWARD                         000074 constant        fixed bin(17,0)          initial dcl 101 set ref 679*
INIT_RECORD_NETWORK_ID          000070 constant        fixed bin(35,0)          initial dcl 104 ref 460 625 785
INIT_RECORD_PID                 000031 constant        bit(36)                  initial unaligned dcl 102 ref 458 625 783
INIT_RECORD_SESSION_HANDLE             constant        fixed bin(35,0)          initial dcl 103 ref 459 625 784
Keyed_sequential_update         000075 constant        fixed bin(17,0)          initial dcl 2-15 set ref 840*
ME                              000024 constant        char(19)                 initial unaligned dcl 105 ref 440
MICROSECONDS_PER_HALF_SECOND    000023 constant        fixed bin(35,0)          initial dcl 106 ref 868 871
MICROSECONDS_PER_SECOND         000022 constant        fixed bin(35,0)          initial dcl 107 ref 868 871
NAD                                    based           structure                level 1 dcl 1056
NAR                                    based           structure                level 1 dcl 1058
NAT_iocb_ptr                    000010 internal static pointer                  initial dcl 108 set ref 434 436* 572* 596* 603* 679*
                                                                                  715 726* 779 808 810* 814* 818* 835* 840* 844*
                                                                                  845* 901* 925* 958* 973* 994*
NCU                                    based           structure                level 1 dcl 1060
NET_ACCT_ARRAY_VERSION_1        000010 constant        char(8)                  initial unaligned dcl 3-51 ref 583
NET_ACCT_RECORD_VERSION_1       000006 constant        char(8)                  initial unaligned dcl 4-41 ref 970
NET_ARRAY_EXTRA_RECORD_COUNT           constant        fixed bin(35,0)          initial dcl 109 ref 581
OFF                                    constant        bit(1)                   initial unaligned dcl 110 ref 171 352 475 476 509
                                                                                  510 546 648 649 724 727 754 756 870 882 884 910
                                                                                  924 992 998
ON                                     constant        bit(1)                   initial unaligned dcl 111 ref 170 220 254 255 268
                                                                                  302 339 340 341 356 388 389 393 419 420 423 463
                                                                                  527 528 547 550 552 652 653 655 656 668 725 878
                                                                                  922 923 993
P_area_ptr                             parameter       pointer                  dcl 49 ref 506 524 543 553
P_array_ptr                            parameter       pointer                  dcl 50 set ref 506 524 543 554* 698*
P_code                                 parameter       fixed bin(35,0)          dcl 53 in procedure "network_accounting_" set ref
                                                                                  166 206* 236* 289* 320* 372* 415 506 524 543 620*
                                                                                  750* 1030*
P_code                                 parameter       fixed bin(35,0)          dcl 918 in procedure "RECORD_LOCK" set ref 914 920*
                                                                                  933*
P_error_message                        parameter       char                     unaligned dcl 51 set ref 415 506 524 543 752* 1037*
P_network_channel_use_ptr              parameter       pointer                  dcl 54 ref 166 176
P_path                                 parameter       char                     unaligned dcl 52 ref 711 713
P_process_id                           parameter       bit(36)                  dcl 55 ref 524 529
RW_ACCESS                              constant        bit(3)                   initial unaligned dcl 112 ref 453
SEEK_HEAD_EQUAL_SEARCH                 constant        fixed bin(17,0)          initial dcl 113 ref 592
TABLE_NAME                      000012 constant        char(32)                 initial unaligned dcl 114 set ref 440* 454* 493*
                                                                                  496* 832* 837* 846*
abort_flag                             based           bit(1)                   unaligned dcl 1018 ref 1049
abort_flag_ptr                  000104 automatic       pointer                  dcl 1020 set ref 1028* 1049
abort_label                     000106 automatic       label variable           dcl 122 set ref 557* 766* 1049
access_name                     000171 automatic       char(32)                 array level 2 packed unaligned dcl 145 set ref 452*
active                    5(03)        based           bit(1)                   level 3 packed unaligned dcl 1058 set ref 220* 255*
                                                                                  268* 302* 341* 356* 393* 649 884*
addr                                                   builtin function         dcl 92 ref 454 454 570 571 572 572 572 572 575 591
                                                                                  638 726 726 925 925 958 973 973 994 994
arg_list_ptr                    000100 automatic       pointer                  dcl 1020 set ref 1026* 1034*
attach_description              000360 automatic       char(168)                unaligned dcl 829 set ref 832* 833* 833 835*
auto_NAR                        000152 automatic       structure                level 1 dcl 142 set ref 969* 973 973 973
auto_key                        000166 automatic       structure                level 1 dcl 143 set ref 179* 958 958 971
buffer                          000106 automatic       char(500)                unaligned dcl 1021 set ref 1034* 1037
byte_count                5            based           fixed bin(35,0)          level 2 in structure "NAD" dcl 1056 in procedure
                                                                                  "network_accounting_" set ref 864*
byte_count               10            based           fixed bin(17,0)          level 2 in structure "NCU" dcl 1060 in procedure
                                                                                  "network_accounting_" set ref 184* 218 247 300 331
                                                                                  383
byte_count               12            based           fixed bin(35,0)          level 2 in structure "NAR" dcl 1058 in procedure
                                                                                  "network_accounting_" set ref 218* 218 247* 247
                                                                                  300* 300 331* 331 383* 383 649 864 879*
caller_area                            based           area(1024)               dcl 144 ref 582 732
caller_area_ptr                 000112 automatic       pointer                  dcl 123 set ref 553* 582 732
cleanup                         000100 stack reference condition                dcl 91 ref 173 426 478 558 567
clock                                                  builtin function         dcl 92 ref 251 335 355 392 464 871 882 972
connect_time              4            based           fixed bin(35,0)          level 2 dcl 1056 set ref 874*
connected_time            6            based           fixed bin(71,0)          level 2 dcl 1058 set ref 251* 251 335* 335 392* 392
                                                                                  868 879*
count                     3            based           fixed bin(17,0)          level 2 dcl 3-27 set ref 585* 619 637* 637 638 695*
                                                                                  695
create_record_flag                     parameter       bit(1)                   unaligned dcl 954 ref 945 960
cu_$arg_list_ptr                000070 constant        entry                    external dcl 59 ref 1026
cu_$arg_ptr                     000072 constant        entry                    external dcl 60 ref 1027 1028
cu_$level_get                   000074 constant        entry                    external dcl 61 ref 747
cu_$level_set                   000076 constant        entry                    external dcl 62 ref 736 773
current_ring                    000114 automatic       fixed bin(17,0)          dcl 124 set ref 748* 773*
database_acl                    000171 automatic       structure                array level 1 dcl 145 set ref 451* 454 454
database_directory              000012 internal static char(168)                initial unaligned dcl 115 set ref 440* 454* 493 496*
                                                                                  713* 758 758* 832* 837* 846*
debug_sw                        000116 automatic       bit(1)                   unaligned dcl 126 set ref 183 202 232 285 316 368
                                                                                  429 561 691 756* 800* 895 962 1041
debug_switch                           defined         bit(1)                   unaligned dcl 156 set ref 480* 800
delete_$path                    000100 constant        entry                    external dcl 63 ref 440
delete_acl_entry                       based           structure                level 1 dcl 1-63
delete_sw                 3            based           bit(1)                   level 3 packed unaligned dcl 1056 set ref 656* 861*
delete_switch             5            based           bit(1)                   level 3 packed unaligned dcl 1058 set ref 340* 388*
                                                                                  655* 668 861
delta_time                      000115 automatic       fixed bin(35,0)          dcl 125 set ref 868* 871* 871 874
directory_acl_entry                    based           structure                level 1 dcl 1-54
divide                                                 builtin function         dcl 92 ref 868 871
entrypoint_name                 000117 automatic       char(32)                 unaligned dcl 127 set ref 168* 417* 474* 508* 526*
                                                                                  545* 777
error_code                      000127 automatic       fixed bin(35,0)          dcl 128 in procedure "network_accounting_" set ref
                                                                                  213* 214 214* 242* 243 243* 261* 262 262* 295* 296
                                                                                  296* 326* 327 327* 347* 348 348* 378* 379 379*
                                                                                  440* 442 442 442* 454* 461* 462 467* 572* 573 573*
                                                                                  596* 597 598 598* 603* 604 604* 610* 611 612 679*
                                                                                  681 681 687 687 687* 726* 786* 787 787* 810* 811
                                                                                  811* 814* 815 815* 835* 837 837* 840* 841 846*
                                                                                  901* 902 903 905*
error_code                      000472 automatic       fixed bin(35,0)          dcl 988 in procedure "RECORD_UNLOCK" set ref 994*
                                                                                  995 995*
error_code                             parameter       fixed bin(35,0)          dcl 955 in procedure "RECORD_SEEK_AND_LOCK" set ref
                                                                                  945 958* 959 960 973* 974 974* 977* 980*
error_code                      000454 automatic       fixed bin(35,0)          dcl 918 in procedure "RECORD_LOCK" set ref 925* 926
                                                                                  929 929 929 933
error_code_arg_sw               000130 automatic       bit(1)                   unaligned dcl 129 set ref 170* 419* 475* 550* 750
                                                                                  1030
error_code_ptr                  000102 automatic       pointer                  dcl 1020 set ref 1027* 1030
error_code_to_return                   based           fixed bin(35,0)          dcl 1017 ref 1030
error_message_arg_sw            000131 automatic       bit(1)                   unaligned dcl 130 set ref 171* 420* 476* 552* 752
                                                                                  1037
error_string                    000132 automatic       char(32)                 unaligned dcl 131 set ref 614* 682* 687*
error_table_$bad_processid      000102 external static fixed bin(35,0)          dcl 64 ref 206 236 289 320 372
error_table_$end_of_info        000104 external static fixed bin(35,0)          dcl 65 ref 681 687
error_table_$invalid_lock_reset 000106 external static fixed bin(35,0)          dcl 66 ref 929
error_table_$lock_wait_time_exceeded
                                000110 external static fixed bin(35,0)          dcl 67 ref 612 929
error_table_$locked_by_this_process
                                000112 external static fixed bin(35,0)          dcl 68 ref 903 929
error_table_$no_record          000114 external static fixed bin(35,0)          dcl 69 ref 598 687 960
error_table_$noentry            000116 external static fixed bin(35,0)          dcl 70 ref 442
error_table_$not_initialized    000120 external static fixed bin(35,0)          dcl 71 set ref 796*
error_table_$process_unknown    000122 external static fixed bin(35,0)          dcl 72 ref 651
flags                     1     000226 automatic       structure                level 2 dcl 148
general_acl_entry                      based           structure                level 1 unaligned dcl 1-12
general_delete_acl_entry               based           structure                level 1 dcl 1-35
general_extended_acl_entry             based           structure                level 1 dcl 1-23
get_process_total_entry         000142 automatic       bit(1)                   unaligned dcl 132 set ref 509* 527* 546* 562* 588
                                                                                  632
get_ring_                       000124 constant        entry                    external dcl 73 ref 748
hcs_$replace_acl                000126 constant        entry                    external dcl 74 ref 454
hcs_$validate_processid         000130 constant        entry                    external dcl 75 ref 650
i_am_initializer                000064 internal static bit(1)                   initial unaligned dcl 116 set ref 423* 654 668
indx_info                              based           structure                level 1 unaligned dcl 8-33 set ref 570* 572 572
info                            000204 automatic       structure                level 1 dcl 146 set ref 570 571 572 572 575
info_version                           based           fixed bin(17,0)          level 2 dcl 8-33 set ref 571*
int_code                        000303 automatic       fixed bin(35,0)          dcl 1022 set ref 1027* 1028*
ioa_$general_rs                 000132 constant        entry                    external dcl 76 ref 1034
iox_$attach_name                000134 constant        entry                    external dcl 77 ref 835
iox_$close                      000136 constant        entry                    external dcl 78 ref 810
iox_$control                    000140 constant        entry                    external dcl 79 ref 572 596 726 925 994
iox_$delete_record              000142 constant        entry                    external dcl 80 ref 901
iox_$detach_iocb                000144 constant        entry                    external dcl 81 ref 814 844
iox_$open                       000146 constant        entry                    external dcl 82 ref 840
iox_$position                   000150 constant        entry                    external dcl 83 ref 603 679
iox_$seek_key                   000152 constant        entry                    external dcl 84 ref 958
iox_$write_record               000154 constant        entry                    external dcl 85 ref 973
key                       2            based           structure                level 2 in structure "NAR" dcl 1058 in procedure
                                                                                  "network_accounting_" set ref 860
key                                    based           structure                level 2 in structure "NAD" dcl 1056 in procedure
                                                                                  "network_accounting_" set ref 860*
key                       2            based           structure                level 2 in structure "network_account_record"
                                                                                  dcl 4-18 in procedure "network_accounting_"
key                       2     000152 automatic       structure                level 2 in structure "auto_NAR" dcl 142 in procedure
                                                                                  "network_accounting_" set ref 971*
key_char_overlay                       based           char                     unaligned dcl 147 ref 958
len                             000304 automatic       fixed bin(21,0)          dcl 1023 set ref 1034* 1037
length                                                 builtin function         dcl 92 ref 594
lock_sw                   1     000226 automatic       bit(1)                   level 3 packed unaligned dcl 148 set ref 724* 923*
                                                                                  992*
max_count                 2            based           fixed bin(17,0)          level 2 dcl 3-27 set ref 582* 619 732
mbz                       5(04)        based           bit(32)                  level 3 packed unaligned dcl 1058 set ref 480* 480
                                                                                  800 800
mode                     10     000171 automatic       bit(36)                  array level 2 dcl 145 set ref 453*
n                         1            based           fixed bin(17,0)          level 2 dcl 151 set ref 594* 595
network_account_array                  based           structure                level 1 dcl 3-27 set ref 582 732
network_account_array_bound     000274 automatic       fixed bin(17,0)          dcl 3-25 set ref 581* 582 582
network_account_array_ptr       000272 automatic       pointer                  dcl 3-24 set ref 582* 583 585 619 619 637 637 638
                                                                                  638 693 695 695 698 699* 732 732 755*
network_account_data                   based           structure                level 1 dcl 3-36 set ref 639*
network_account_data_ptr        000276 automatic       pointer                  dcl 3-34 set ref 638* 639 652 656 860 861 862 863
                                                                                  864 865 874
network_account_record                 based           structure                level 1 dcl 4-18
network_account_record_ptr      000300 automatic       pointer                  dcl 4-16 set ref 218 218 219 219 220 247 247 248 248
                                                                                  251 251 251 254 255 268 300 300 301 301 302 331
                                                                                  331 332 332 335 335 335 339 340 341 352 355 356
                                                                                  383 383 384 384 388 389 392 392 392 393 463 464
                                                                                  480 625 625 625 632 648 649 649 649 650 653 655
                                                                                  668 794 800 860 861 862 863 864 865 868 870 871
                                                                                  879 879 879 882 882 884 896 896 905 905 939*
network_channel_use                    based           structure                level 1 dcl 5-12
network_channel_use_ptr         000302 automatic       pointer                  dcl 5-11 set ref 176* 180 181 184 184 184 184 184
                                                                                  184 193 195 212 218 219 225 225 241 247 248 260
                                                                                  273 273 282 282 300 301 307 307 325 331 332 346
                                                                                  361 377 383 384
network_id                4            based           fixed bin(35,0)          level 3 in structure "NAR" dcl 1058 in procedure
                                                                                  "network_accounting_" ref 625
network_id                2            based           fixed bin(17,0)          level 2 in structure "NCU" dcl 1060 in procedure
                                                                                  "network_accounting_" ref 181
network_id                2     000166 automatic       fixed bin(35,0)          level 2 in structure "auto_key" dcl 143 in procedure
                                                                                  "network_accounting_" set ref 181* 460* 785* 963*
new_debug_mode                         parameter       bit(1)                   unaligned dcl 472 ref 471 480
null                                                   builtin function         dcl 92 ref 434 436 554 693 699 715 732 755 764 779
                                                                                  808 818 835 835 845
owner_pid                 4            based           bit(36)                  level 2 dcl 1060 set ref 184* 195 212 225 241 282
                                                                                  282 307 346 361 377
packet_count              6            based           fixed bin(35,0)          level 2 in structure "NAD" dcl 1056 in procedure
                                                                                  "network_accounting_" set ref 865*
packet_count             13            based           fixed bin(35,0)          level 2 in structure "NAR" dcl 1058 in procedure
                                                                                  "network_accounting_" set ref 219* 219 248* 248
                                                                                  301* 301 332* 332 384* 384 649 865 879*
packet_count              7            based           fixed bin(17,0)          level 2 in structure "NCU" dcl 1060 in procedure
                                                                                  "network_accounting_" set ref 184* 219 248 301 332
                                                                                  384
pathname_                       000156 constant        entry                    external dcl 86 ref 493 496 832
process_id                      000166 automatic       bit(36)                  level 2 in structure "auto_key" dcl 143 in procedure
                                                                                  "network_accounting_" set ref 212* 241* 260* 273*
                                                                                  282* 325* 346* 377* 458* 593* 594 595 783* 963*
process_id                2            based           bit(36)                  level 3 in structure "NAR" dcl 1058 in procedure
                                                                                  "network_accounting_" set ref 625 632 650* 896*
                                                                                  905*
process_id_to_match             000143 automatic       bit(36)                  dcl 133 set ref 529* 562* 593 632
purge_lock_error                000144 automatic       fixed bin(35,0)          dcl 134 set ref 650* 651
purged                    3(02)        based           bit(1)                   level 3 in structure "NAD" packed unaligned dcl 1056
                                                                                  in procedure "network_accounting_" set ref 652*
                                                                                  862*
purged                    5(02)        based           bit(1)                   level 3 in structure "NAR" packed unaligned dcl 1058
                                                                                  in procedure "network_accounting_" set ref 648
                                                                                  653* 862
record                    4            based           structure                array level 2 dcl 3-27 set ref 638
record_count                    000145 automatic       fixed bin(17,0)          dcl 135 set ref 575* 578 581
record_locked_sw                000146 automatic       bit(1)                   unaligned dcl 136 set ref 672 723 727* 754* 910*
                                                                                  922* 990 998*
record_ptr                4     000226 automatic       pointer                  level 2 dcl 148 set ref 764* 939
record_status_info              000226 automatic       structure                level 1 dcl 148 set ref 726 726 762* 925 925 994 994
records                   2            based           fixed bin(34,0)          level 2 dcl 8-33 set ref 575
relation_type                          based           fixed bin(17,0)          level 2 dcl 151 set ref 592*
reset_table_sw                  000147 automatic       bit(1)                   unaligned dcl 137 set ref 510* 528* 547* 654 668 878
rs_info                                based           structure                level 1 dcl 6-6
rs_info_version_2                      constant        fixed bin(17,0)          initial dcl 6-44 ref 763
rtrim                                                  builtin function         dcl 92 ref 832 833
saved_ring                      000150 automatic       fixed bin(17,0)          initial dcl 138 set ref 138* 736 736* 747*
search_key                2            based           char                     level 2 packed unaligned dcl 151 set ref 595*
seek_head_info                         based           structure                level 1 unaligned dcl 151
seek_head_info_ptr              000270 automatic       pointer                  dcl 150 set ref 591* 592 594 595 596*
seek_head_info_room             000244 automatic       fixed bin(35,0)          array dcl 149 set ref 591
segment_acl_entry                      based           structure                level 1 dcl 1-45
session_handle            3            based           fixed bin(35,0)          level 3 in structure "NAR" dcl 1058 in procedure
                                                                                  "network_accounting_" set ref 625 896* 905*
session_handle            3            based           fixed bin(35,0)          level 2 in structure "NCU" dcl 1060 in procedure
                                                                                  "network_accounting_" set ref 180 184*
session_handle            1     000166 automatic       fixed bin(35,0)          level 2 in structure "auto_key" dcl 143 in procedure
                                                                                  "network_accounting_" set ref 180* 459* 784* 963*
session_state             6            based           fixed bin(17,0)          level 2 dcl 1060 set ref 184* 193
size                                                   builtin function         dcl 92 ref 958 973
stream_name                     000350 automatic       char(32)                 unaligned dcl 828 set ref 831* 835*
substr                                                 builtin function         dcl 92 ref 1037
switches                  5            based           structure                level 2 in structure "NAR" packed unaligned dcl 1058
                                                                                  in procedure "network_accounting_"
switches                  3            based           structure                level 2 in structure "NAD" packed unaligned dcl 1056
                                                                                  in procedure "network_accounting_"
sys_info$system_control_dir     000160 external static varying char(168)        dcl 87 ref 493 758
system_boot_time                000066 internal static fixed bin(71,0)          initial dcl 118 set ref 791 791* 794
system_info_$timeup             000162 constant        entry                    external dcl 88 ref 791
unassigned_sw             3(01)        based           bit(1)                   level 3 packed unaligned dcl 1056 set ref 863*
unassigned_switch         5(01)        based           bit(1)                   level 3 packed unaligned dcl 1058 set ref 254* 339*
                                                                                  352* 389* 463* 863 870 882
unique_chars_                   000164 constant        entry                    external dcl 89 ref 831
unlock_sw                 1(01) 000226 automatic       bit(1)                   level 3 packed unaligned dcl 148 set ref 725* 924*
                                                                                  993*
unspec                                                 builtin function         dcl 92 set ref 179* 451* 570* 594 595* 595 639* 762*
                                                                                  969*
update_time              10     000152 automatic       fixed bin(71,0)          level 2 in structure "auto_NAR" dcl 142 in procedure
                                                                                  "network_accounting_" set ref 972*
update_time              10            based           fixed bin(71,0)          level 2 in structure "NAR" dcl 1058 in procedure
                                                                                  "network_accounting_" set ref 251 335 355* 392
                                                                                  464* 794 871 882*
user_pid                  5            based           bit(36)                  level 2 dcl 1060 set ref 184* 225 260 273 273 307
                                                                                  325
version                         000152 automatic       char(8)                  level 2 in structure "auto_NAR" dcl 142 in procedure
                                                                                  "network_accounting_" set ref 970*
version                         000226 automatic       fixed bin(17,0)          level 2 in structure "record_status_info" dcl 148
                                                                                  in procedure "network_accounting_" set ref 763*
version                                based           char(8)                  level 2 in structure "network_account_array"
                                                                                  dcl 3-27 in procedure "network_accounting_" set
                                                                                  ref 583*
vfs_version_1                          constant        fixed bin(17,0)          initial dcl 8-67 ref 571

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACL_VERSION_1                          internal static fixed bin(17,0)          initial dcl 1-77
ASSIGN_CONNECTION                      internal static fixed bin(17,0)          initial dcl 5-25
BITS_PER_PAGE                          internal static fixed bin(16,0)          initial dcl 7-67
BITS_PER_SEGMENT                       internal static fixed bin(24,0)          initial dcl 7-70
BITS_PER_WORD                          internal static fixed bin(6,0)           initial dcl 7-64
CHARS_PER_PAGE                         internal static fixed bin(13,0)          initial dcl 7-76
CHARS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 7-79
CREATE_SESSION                         internal static fixed bin(17,0)          initial dcl 5-24
DELETE_ACL_VERSION_1                   internal static char(4)                  initial unaligned dcl 1-67
DESTROY_SESSION                        internal static fixed bin(17,0)          initial dcl 5-28
DIR_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 1-67
Direct_input                           internal static fixed bin(17,0)          initial dcl 2-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 2-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 2-15
GENERAL_ACL_VERSION_1                  internal static char(8)                  initial unaligned dcl 1-72
GENERAL_DELETE_ACL_VERSION_1           internal static char(8)                  initial unaligned dcl 1-72
GENERAL_EXTENDED_ACL_VERSION_1         internal static char(8)                  initial unaligned dcl 1-72
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 2-15
NETWORK_CHANNEL_USE_INFO_VERSION_1     internal static char(8)                  initial unaligned dcl 5-30
PAGES_PER_SEGMENT                      internal static fixed bin(8,0)           initial dcl 7-92
SEG_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 1-67
Sequential_input                       internal static fixed bin(17,0)          initial dcl 2-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 2-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 2-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 2-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 2-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 2-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 2-15
UNASSIGN_CONNECTION                    internal static fixed bin(17,0)          initial dcl 5-27
UPDATE_CONNECTION                      internal static fixed bin(17,0)          initial dcl 5-26
WORDS_PER_PAGE                         internal static fixed bin(11,0)          initial dcl 7-84
WORDS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 7-89
acl_count                              automatic       fixed bin(17,0)          dcl 1-5
acl_ptr                                automatic       pointer                  dcl 1-4
blk_info                               based           structure                level 1 unaligned dcl 8-21
delete_acl                             based           structure                level 1 dcl 1-58
delete_acl_array                       based           structure                array level 1 dcl 1-64
directory_acl                          based           structure                level 1 dcl 1-49
directory_acl_array                    based           structure                array level 1 dcl 1-55
general_acl                            based           structure                level 1 dcl 1-7
general_delete_acl                     based           structure                level 1 dcl 1-30
general_extended_acl                   based           structure                level 1 dcl 1-18
iox_modes                              internal static char(24)                 initial array dcl 2-6
rs_desc                                based           structure                level 1 packed unaligned dcl 6-32
rs_info_ptr                            automatic       pointer                  dcl 6-5
rs_info_version_1                      internal static fixed bin(17,0)          initial dcl 6-43
segment_acl                            based           structure                level 1 dcl 1-40
segment_acl_array                      based           structure                array level 1 dcl 1-46
seq_desc                               based           structure                level 1 packed unaligned dcl 6-37
seq_info                               based           structure                level 1 unaligned dcl 8-11
short_iox_modes                        internal static char(4)                  initial array dcl 2-12
uns_info                               based           structure                level 1 unaligned dcl 8-1
vbl_info                               based           structure                level 1 unaligned dcl 8-55

NAMES DECLARED BY EXPLICIT CONTEXT.
CLEANUP_AND_RETURN              001631 constant        label                    dcl 398 ref 207 223 237 271 290 305 321 359 373 396
                                                                                  469 701 766
CLEAN_UP                        003551 constant        entry                    internal dcl 720 ref 173 398 426 478 558 567
INIT1                           003650 constant        entry                    internal dcl 741 ref 172 425 477 556
INIT2                           003737 constant        entry                    internal dcl 770 ref 174 427 479 559
JUST_RETURN                     001635 constant        label                    dcl 400
NAT_CLOSE                       004071 constant        entry                    internal dcl 806 ref 715 795
NAT_OPEN                        004204 constant        entry                    internal dcl 826 ref 447 779
READ_TABLE                      002566 constant        label                    dcl 550 ref 511 530 548
READ_TABLE_COPY_NAT_DATA        004521 constant        entry                    internal dcl 852 ref 663
RECORD_DELETE                   004617 constant        entry                    internal dcl 889 ref 668
RECORD_LOCK                     004733 constant        entry                    internal dcl 914 ref 610 980
RECORD_SEEK_AND_LOCK            005020 constant        entry                    internal dcl 945 ref 213 242 261 295 326 347 378 461
                                                                                  786
RECORD_UNLOCK                   005245 constant        entry                    internal dcl 984 ref 222 256 270 304 343 358 395 465
                                                                                  678 802
REPORT_ERROR                    005344 constant        entry                    internal dcl 1002 ref 184 203 214 233 243 262 286
                                                                                  296 317 327 348 369 379 430 435 442 467 562 573
                                                                                  598 604 687 693 695 787 796 811 815 837 846 896
                                                                                  905 963 974 977 995
RETURN_WHAT_WE_HAVE             003403 constant        label                    dcl 691 ref 557 578 621 632
RETURN_WHAT_WE_HAVE_WITH_ERROR  003355 constant        label                    dcl 687 ref 615 683
charge_channel_use              000615 constant        entry                    external dcl 166
clear_table                     001650 constant        entry                    external dcl 415
debug                           002230 constant        entry                    external dcl 471
dump_table                      002432 constant        entry                    external dcl 506
get_path                        002311 constant        entry                    external dcl 491
get_process_total               002471 constant        entry                    external dcl 524
network_accounting_             000572 constant        entry                    external dcl 40
position_to_next_record         003324 constant        label                    dcl 679 ref 612
read_and_reset_table            002532 constant        entry                    external dcl 543
skip_this_record                003321 constant        label                    dcl 672 ref 625
test                            003507 constant        entry                    external dcl 711
update_the_records              000000 constant        label                    array(5) dcl 195 ref 193

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6270        6456    5547        6300
Length      7146    5547       166         453     520          60

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
network_accounting_                 762 external procedure  is an external procedure.  
on unit on line 173                  64 on unit               
on unit on line 426                  64 on unit               
on unit on line 478                  64 on unit               
on unit on line 558                  64 on unit               
on unit on line 567                  64 on unit               
CLEAN_UP                             88 internal procedure  is called by several nonquick procedures.  
INIT1                                   internal procedure  shares stack frame of external procedure network_accounting_.  
INIT2                                   internal procedure  shares stack frame of external procedure network_accounting_.  
NAT_CLOSE                               internal procedure  shares stack frame of external procedure network_accounting_.  
NAT_OPEN                                internal procedure  shares stack frame of external procedure network_accounting_.  
READ_TABLE_COPY_NAT_DATA                internal procedure  shares stack frame of external procedure network_accounting_.  
RECORD_DELETE                           internal procedure  shares stack frame of external procedure network_accounting_.  
RECORD_LOCK                             internal procedure  shares stack frame of external procedure network_accounting_.  
RECORD_SEEK_AND_LOCK                    internal procedure  shares stack frame of external procedure network_accounting_.  
RECORD_UNLOCK                           internal procedure  shares stack frame of external procedure network_accounting_.  
REPORT_ERROR                        246 internal procedure  is declared options(variable).  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 NAT_iocb_ptr                network_accounting_
000012 database_directory          network_accounting_
000064 i_am_initializer            network_accounting_
000066 system_boot_time            network_accounting_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
REPORT_ERROR             000100 arg_list_ptr                REPORT_ERROR
                         000102 error_code_ptr              REPORT_ERROR
                         000104 abort_flag_ptr              REPORT_ERROR
                         000106 buffer                      REPORT_ERROR
                         000303 int_code                    REPORT_ERROR
                         000304 len                         REPORT_ERROR
network_accounting_      000106 abort_label                 network_accounting_
                         000112 caller_area_ptr             network_accounting_
                         000114 current_ring                network_accounting_
                         000115 delta_time                  network_accounting_
                         000116 debug_sw                    network_accounting_
                         000117 entrypoint_name             network_accounting_
                         000127 error_code                  network_accounting_
                         000130 error_code_arg_sw           network_accounting_
                         000131 error_message_arg_sw        network_accounting_
                         000132 error_string                network_accounting_
                         000142 get_process_total_entry     network_accounting_
                         000143 process_id_to_match         network_accounting_
                         000144 purge_lock_error            network_accounting_
                         000145 record_count                network_accounting_
                         000146 record_locked_sw            network_accounting_
                         000147 reset_table_sw              network_accounting_
                         000150 saved_ring                  network_accounting_
                         000152 auto_NAR                    network_accounting_
                         000166 auto_key                    network_accounting_
                         000171 database_acl                network_accounting_
                         000204 info                        network_accounting_
                         000226 record_status_info          network_accounting_
                         000244 seek_head_info_room         network_accounting_
                         000270 seek_head_info_ptr          network_accounting_
                         000272 network_account_array_ptr   network_accounting_
                         000274 network_account_array_bound network_accounting_
                         000276 network_account_data_ptr    network_accounting_
                         000300 network_account_record_ptr  network_accounting_
                         000302 network_channel_use_ptr     network_accounting_
                         000350 stream_name                 NAT_OPEN
                         000360 attach_description          NAT_OPEN
                         000454 error_code                  RECORD_LOCK
                         000472 error_code                  RECORD_UNLOCK

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return_mac          tra_ext_2           signal_op           enable_op           shorten_stack
ext_entry           ext_entry_desc      int_entry           trunc_fx2           divide_fx1          divide_fx3
op_alloc_           op_freen_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_list_ptr              cu_$arg_ptr                   cu_$level_get                 cu_$level_set
delete_$path                  get_ring_                     hcs_$replace_acl              hcs_$validate_processid
ioa_$general_rs               iox_$attach_name              iox_$close                    iox_$control
iox_$delete_record            iox_$detach_iocb              iox_$open                     iox_$position
iox_$seek_key                 iox_$write_record             pathname_                     system_info_$timeup
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_processid    error_table_$end_of_info      error_table_$invalid_lock_reset
error_table_$lock_wait_time_exceeded                        error_table_$locked_by_this_process
error_table_$no_record        error_table_$noentry          error_table_$not_initialized  error_table_$process_unknown
sys_info$system_control_dir




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    138 000565        40 000571        42 000602       166 000611       168 000630       170 000633       171 000635
    172 000636       173 000637       174 000661       176 000662       179 000666       180 000671       181 000673
    183 000675       184 000677       193 000750       195 000753       202 000755       203 000757       206 001003
    207 001006       212 001007       213 001010       214 001012       218 001037       219 001045       220 001051
    222 001053       223 001054       225 001055       232 001061       233 001063       236 001107       237 001112
    241 001113       242 001115       243 001117       247 001144       248 001152       251 001156       254 001163
    255 001165       256 001167       260 001170       261 001173       262 001175       268 001222       270 001225
    271 001226       273 001227       282 001233       285 001237       286 001241       289 001265       290 001270
    295 001271       296 001273       300 001320       301 001326       302 001332       304 001334       305 001335
    307 001336       316 001342       317 001344       320 001370       321 001373       325 001374       326 001375
    327 001377       331 001424       332 001432       335 001436       339 001443       340 001445       341 001447
    343 001451       346 001452       347 001455       348 001457       352 001504       355 001507       356 001512
    358 001514       359 001515       361 001516       368 001520       369 001522       372 001546       373 001551
    377 001552       378 001553       379 001555       383 001602       384 001610       388 001614       389 001616
    392 001620       393 001625       395 001627       396 001630       398 001631       400 001635       415 001644
    417 001670       419 001673       420 001675       423 001676       425 001700       426 001701       427 001723
    429 001724       430 001726       434 001754       435 001761       436 002005       440 002010       442 002050
    447 002103       451 002104       452 002107       453 002112       454 002114       458 002157       459 002161
    460 002163       461 002165       462 002167       463 002171       464 002174       465 002177       466 002200
    467 002201       469 002224       471 002225       474 002240       475 002243       476 002244       477 002245
    478 002246       479 002270       480 002271       482 002277       491 002306       493 002320       496 002372
    506 002425       508 002456       509 002461       510 002462       511 002463       524 002464       526 002515
    527 002520       528 002522       529 002524       530 002527       543 002530       545 002556       546 002561
    547 002563       548 002565       550 002566       552 002570       553 002571       554 002574       556 002576
    557 002577       558 002602       559 002624       561 002625       562 002627       567 002662       570 002704
    571 002707       572 002711       573 002743       575 002770       578 002772       581 002774       582 003000
    583 003011       585 003014       588 003015       591 003020       592 003022       593 003024       594 003026
    595 003035       596 003041       597 003072       598 003074       601 003122       603 003123       604 003141
    610 003166       611 003170       612 003172       614 003175       615 003200       619 003201       620 003206
    621 003207       625 003210       632 003221       637 003230       638 003231       639 003235       648 003240
    649 003243       650 003252       651 003263       652 003267       653 003272       654 003275       655 003301
    656 003303       663 003305       668 003306       672 003321       678 003323       679 003324       681 003343
    682 003350       683 003353       686 003354       687 003355       691 003403       693 003405       695 003436
    698 003477       699 003501       701 003503       711 003504       713 003525       715 003534       718 003541
    720 003550       723 003556       724 003561       725 003563       726 003565       727 003620       732 003622
    736 003634       739 003647       741 003650       747 003651       748 003660       750 003671       752 003674
    754 003706       755 003707       756 003711       758 003712       762 003724       763 003727       764 003731
    766 003733       768 003736       770 003737       773 003740       777 003747       779 003754       783 003762
    784 003764       785 003766       786 003770       787 003772       791 004017       794 004030       795 004035
    796 004036       800 004062       802 004067       804 004070       806 004071       808 004072       810 004077
    811 004107       814 004137       815 004150       818 004200       821 004203       826 004204       831 004205
    832 004235       833 004304       835 004333       837 004366       840 004427       841 004446       844 004450
    845 004462       846 004465       850 004520       852 004521       860 004522       861 004532       862 004536
    863 004542       864 004546       865 004550       868 004552       870 004560       871 004565       874 004576
    878 004601       879 004604       882 004610       884 004614       887 004616       889 004617       895 004620
    896 004622       901 004657       902 004670       903 004672       905 004676       910 004731       912 004732
    914 004733       920 004735       922 004736       923 004740       924 004742       925 004744       926 005000
    929 005002       933 005012       934 005014       939 005015       941 005017       945 005020       958 005022
    959 005051       960 005054       962 005064       963 005066       969 005125       970 005130       971 005132
    972 005136       973 005140       974 005162       976 005211       977 005212       980 005235       982 005244
    984 005245       990 005246       992 005251       993 005253       994 005255       995 005311       998 005341
   1000 005342      1002 005343      1026 005351      1027 005357      1028 005377      1030 005417      1034 005424
   1037 005473      1041 005507      1049 005511      1052 005521


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
