ASSEMBLY LISTING OF SEGMENT >special_ldd>install>MR12.0-1206>bcpl_machine_code_.alm          
ASSEMBLED ON:	11/05/86  1029.0 mst Wed
OPTIONS USED:	list 
ASSEMBLED BY:	ALM Version  6.7  October 1986  
ASSEMBLER CREATED:	10/08/86  1557.5 mst Wed

                                     1  "  Stuff coded in ALM for faster execution or easier writing.
                                     2  "  Last modified on 08/02/74 at 19:05:37 by R F Mabee.
                                     3  "  Reinstalled with no material change in August 1974, R F Mabee.
                                     4  "  Transformed to 6180 machine code and installed in June 1973 by R F Mabee.
                                     5  "  First installed as bcpl_alm_ in September 1971 by R F Mabee.
                                     6  
                                     7  "  Copyright (c) 1974 by Massachusetts Institute of Technology and Honeywell Information Systems, Inc.
                                     8  
                                     9  "  General permission is granted to copy and use this program, but not to sell it, provided that the above
                                    10  "  copyright statement is given.  Contact Information Processing Services, MIT, for further information.
                                    11  "  Please contact R F Mabee at MIT for information on this program and versions for other machines.
                                    12  
                                    13  "		calling sequence for all routines (BCPL standard call):
                                    14  "
                                    15  "	lda	arg1
                                    16  "	sta	sb|k+2,1
                                    17  "	lda	arg2
                                    18  "	sta	sb|k+3,1
                                    19  "	..
                                    20  "	lda	argn
                                    21  "	sta	sb|k+n+1,1
                                    22  "	tspbp	routine
                                    23  "	zero	k,n		" n is restricted to 6 bits.
                                    24  "	stq	result		" i.e. result of routine is in Q, if any.
                                    25  "
                                    26  "	Return is always to bp|1. Registers bp, lp, sp, sb, and x1 should not be altered.
                                    27  "	lp can be reloaded from the caller's frame.
                                    28  
                                    29  "	save sequence used by BCPL programs:
                                    30  "
                                    31  "	adlx1	bp|0		" increment stack pointer.
                                    32  "	sprpbp	sb|0,1
                                    33  "	sprplp	sb|1,1		" new lp - set by entry sequence.
                                    34  
                                    35  "	standard BCPL return sequence:
                                    36  "
                                    37  "	lprpbp	sb|0,1
                                    38  "	sblx1	bp|0		" decrement stack pointer.
                                    39  "	lprplp	sb|1		" reload caller's lp from his frame.
                                    40  "	tra	bp|1
                                    41  
                                    42  "	These routines use x2 for the stack pointer to shorten the save and
                                    43  "	return sequences. A standard _g_e_t_l_p sequence is used only when the routine
                                    44  "	must be able to access the linkage section.
                                    45  
                                    46  	use	textc
                                    47  
                        000000      48  	segdef	RawClockTime	" RawClockTime (Space2) = Space2.
    000000                          49  RawClockTime:
    000000  aa  2 00000 6221 71     50  	eax2	bp|0,*1
    000001  aa  7 00000 5421 12     51  	sprpbp	sb|0,2
    000002  aa  7 00046 2721 20     52  	getlp			" find linkage section to reference links.
    000003  4a  4 00016 6331 20     53  	rccl	<sys_info>|[clock_],*	" clock reading in microseconds, GMT.
    000004  aa  7 00002 7601 12     54  	lprpap	sb|2,2
    000005  aa  0 00000 7571 00     55  	staq	ap|0
    000006  aa  7 00002 2361 12     56  	ldq	sb|2,2		" result to Q.
    000007  aa  7 00000 7621 12     57  	lprpbp	sb|0,2		" reload return address.
    000010  aa  7 00001 7641 11     58  	lprplp	sb|1,1		" restore caller's lp.
    000011  aa  2 00001 7101 00     59  	tra	bp|1		" that's all.
                                    60  
                        000012      61  	segdef	TimeToSeconds	" TimeToSeconds (RawTime) = Seconds since 1901.
    000012                          62  TimeToSeconds:
    000012  aa  2 00000 6221 71     63  	eax2	bp|0,*1
    000013  aa  7 00002 7601 12     64  	lprpap	sb|2,2
    000014  aa  0 00000 2371 00     65  	ldaq	ap|0
    000015  aa   000003 5070 04     66  	dvf	number-*,ic	" Divide by one million to get seconds.
    000016  aa   000044 7730 00     67  	lrl	36		" result to Q.
    000017  aa  2 00001 7101 00     68  	tra	bp|1
                                    69  
    000020  aa   000001 720440      70  number:	dec	500000		" because dvf ignores lowest bit of Q.
                                    71  
                        000021      72  	segdef	ItoR		" ItoR (Integer) = floating point number.
    000021  aa  2 00000 6221 71     73  ItoR:	eax2	bp|0,*1		" to address args.
    000022  aa   106000 4310 03     74  	fld	=35b25,du		" puts binary point between A & Q.
    000023  aa  7 00002 2351 12     75  	lda	sb|2,2		" the integer.
    000024  aa   400000 4750 03     76  	fad	=0.0,du		" normalize a floating point number.
    000025  aa  7 00003 4551 12     77  	fst	sb|3,2		" get it back in Q.
    000026  aa  7 00003 2361 12     78  	ldq	sb|3,2		" result.
    000027  aa  2 00001 7101 00     79  	tra	bp|1		" return.
                                    80  
                        000030      81  	segdef	RtoI		" RtoI (Floating point number) = Integer.
    000030  aa  2 00000 6221 71     82  RtoI:	eax2	bp|0,*1
    000031  aa  7 00002 4311 12     83  	fld	sb|2,2		" the floating point number.
    000032  0a   000035 6040 00     84  	tmi	negative
    000033  aa   216000 4350 03     85  	ufa	=71b25,du		" move binary point over to right of Q.
    000034  aa  2 00001 7101 00     86  	tra	bp|1
                                    87  
    000035  aa   000000 5130 07     88  negative:	fneg	0,dl		" make positive for proper truncation (toward zero).
    000036  aa   216000 4350 03     89  	ufa	=71b25,du
    000037  aa   000000 5330 03     90  	negl	0,du		" restore sign.
    000040  aa  2 00001 7101 00     91  	tra	bp|1
                                    92  
                        000041      93  	segdef	SetOverflowMask	" SetOverflowMask (Boolean).
    000041                          94  SetOverflowMask:
    000041  aa  2 00000 6221 71     95  	eax2	bp|0,*1
    000042  aa   004000 6340 07     96  	ldi	=o004000,dl	" disable overflow fault.
    000043  aa  7 00002 2351 12     97  	lda	sb|2,2		" the boolean value.
    000044  aa   000002 6010 04     98  	tnz	2,ic		" if true, leave disabled.
    000045  aa   000000 6340 07     99  	ldi	0,dl		" re-enable overflow fault.
    000046  aa  2 00001 7101 00    100  	tra	bp|1
                                   101  
                        000047     102  	segdef	BCPLaddr		" BCPLaddr (ITS ptr) = bcpl address.
    000047  aa  2 00000 6221 71    103  BCPLaddr:	eax2	bp|0,*1
    000050  aa  7 00002 7601 12    104  	lprpap	sb|2,2		" BCPL address of ITS pair.
    000051  aa  0 00000 3515 20    105  	eppab	ap|0,*		" evaluate ITS (or any other indirect) address.
    000052  aa  7 00003 5411 12    106  	sprpab	sb|3,2		" store BCPL pointer.
    000053  aa  7 00003 2361 12    107  	ldq	sb|3,2		" return result in Q.
    000054  aa  2 00001 7101 00    108  	tra	bp|1
                                   109  
                        000055     110  	segdef	ITS		" ITS (Address to be stored, Vector, bit offset) = Vector.
    000055  aa  2 00000 6221 71    111  ITS:	eax2	bp|0,*1
    000056  aa  7 00002 7631 12    112  	lprpbb	sb|2,2
    000057  aa  7 00003 7601 12    113  	lprpap	sb|3,2
    000060  aa  2 00000 7231 00    114  	lxl3	bp|0		" get number of arguments.
    000061  aa   000077 3630 03    115  	anx3	63,du		" mask off possible extraneous bits.
    000062  aa   000003 1030 03    116  	cmpx3	3,du		" check for third argument.
    000063  aa   000003 6040 04    117  	tmi	3,ic		" only two args, use default offset.
    000064  aa  7 00004 2361 12    118  	ldq	sb|4,2		" bit offset argument.
    000065  aa  3 00000 5035 06    119  	abd	bb|0,ql		" add in bit offset.
                                   120  
    000066  aa  0 00000 2535 00    121  	spribb	ap|0		" store as ITS pair.
    000067  aa  7 00003 2361 12    122  	ldq	sb|3,2		" result is Vector.
    000070  aa  2 00001 7101 00    123  	tra	bp|1
                                   124  
                        000071     125  	segdef	NumbArgs		" NumbArgs () = number of arguments passed to caller.
    000071  aa  7 00000 7601 11    126  NumbArgs:	lprpap	sb|0,1		" assume normal save sequence.
    000072  aa  0 00000 2361 00    127  	ldq	ap|0
    000073  aa   000077 3760 07    128  	anq	63,dl		" mask excess bits.
    000074  aa  2 00001 7101 00    129  	tra	bp|1		" that's all.
                                   130  
                        000075     131  	segdef	Readch		" Readch (Stream, lv Ch).
    000075  aa  2 00000 6221 71    132  Readch:	eax2	bp|0,*1
    000076  aa  7 00002 7601 12    133  	lprpap	sb|2,2		" stream.
    000077  aa  7 00003 7611 12    134  	lprpab	sb|3,2		" lv Ch.
    000100  aa  0 00000 2351 00    135  	lda	ap|0		" Nextch (character offset to next character).
    000101  aa  0 00001 1151 00    136  	cmpa	ap|1		" Maxch (current number of characters in buffer).
    000102  aa   000007 6050 04    137  	tpl	refill-*,ic
    000103  aa  0 00000 0541 00    138  	aos	ap|0		" count character.
    000104  aa  0 00006 7631 00    139  	lprpbb	ap|6		" load address of buffer.
    000105  aa  0 00100 1015 05    140  	mrl	(pr,al),(pr),fill(0)
    000106  aa   300000 000001     141  	desc9a	bb|0,1
    000107  aa   100000 000004     142  	desc9a	ab|0,4		" Move will pad left of Ch.
    000110  aa  2 00001 7101 00    143  	tra	bp|1
                                   144  
    000111  aa  0 00004 2341 00    145  refill:	szn	ap|4		" routine to refill buffer.
    000112  aa   000016 6000 04    146  	tze	nofill-*,ic	" cannot be refilled.
    000113  aa   000000 6210 12    147  	eax1	0,2		" prepare to call out.
    000114  aa   004000 6220 12    148  	eax2	2048,2
    000115  aa   777760 3620 03    149  	anx2	=o777760,du
    000116  aa  7 00025 7421 00    150  	stx2	sb|stack_header.stack_end_ptr+1
    000117  aa  7 00000 5421 11    151  	sprpbp	sb|0,1
    000120  aa  7 00001 5441 11    152  	sprplp	sb|1,1		" save caller's lp.
    000121  aa  7 00006 5401 11    153  	sprpap	sb|6,1		" pass one argument, namely the stream address.
    000122  aa  0 00004 7611 00    154  	lprpab	ap|4		" routine to refill buffer.
    000123  aa  1 00000 2721 00    155  	tspbp	ab|0		" call.
    000124  aa   000004 000001     156  	zero	4,1
    000125  aa  7 00000 7621 11    157  	lprpbp	sb|0,1		" undo the save.
    000126  aa  2 00000 1211 00    158  	sblx1	bp|0
    000127  aa   777746 7100 04    159  	tra	Readch-*,ic	" try Readch all over again.
                                   160  
    000130  aa   007777 2350 07    161  nofill:	lda	=o7777,dl		" return Endofstreamch if buffer cannot be refilled.
    000131  aa  1 00000 7551 00    162  	sta	ab|0
    000132  aa  2 00001 7101 00    163  	tra	bp|1
                                   164  
                        000133     165  	segdef	Writech		" Writech (Stream, Ch).
    000133  aa  2 00000 6221 71    166  Writech:	eax2	bp|0,*1
    000134  aa  7 00002 7601 12    167  	lprpap	sb|2,2		" the stream.
    000135  aa  0 00000 2351 00    168  	lda	ap|0		" Nextch (character offset in buffer).
    000136  aa  0 00001 1151 00    169  	cmpa	ap|1		" Maxch (length of buffer).
    000137  aa   000015 6050 04    170  	tpl	full-*,ic		" buffer is full - write it out.
    000140  aa  0 00000 0541 00    171  	aos	ap|0		" count character.
    000141  aa  0 00006 7631 00    172  	lprpbb	ap|6		" buffer.
    000142  aa  7 00003 3515 12    173  	eppab	sb|3,2		" lv Ch.
    000143  aa  0 00105 1005 00    174  	mlr	(pr),(pr,al)
    000144  aa   100000 600001     175  	desc9a	ab|0(3),1	" Move from rightmost byte of Ch
    000145  aa   300000 000001     176  	desc9a	bb|0,1		" to indexed byte of buffer.
    000146  aa  0 00002 2351 00    177  	lda	ap|2		" delimiter if any (character ending line).
    000147  aa  2 00001 6001 00    178  	tze	bp|1		" no delimiter.
    000150  aa  7 00003 1151 12    179  	cmpa	sb|3,2		" compare to Ch.
    000151  aa  2 00001 6011 00    180  	tnz	bp|1		" no match - done.
    000152  aa   000003 7060 04    181  	tsx6	empty-*,ic	" write out buffer, set return point.
    000153  aa  2 00001 7101 00    182  	tra	bp|1
                                   183  
    000154  aa   777757 6260 04    184  full:	eax6	Writech-*,ic	" set return point from empty
    000155  aa  0 00004 2341 00    185  empty:	szn	ap|4		" routine to write out buffer.
    000156  aa  2 00001 6001 00    186  	tze	bp|1		" buffer cannot be written out.
    000157  aa   000000 6210 12    187  	eax1	0,2		" prepare for call out.
    000160  aa   004000 6220 12    188  	eax2	2048,2
    000161  aa   777760 3620 03    189  	anx2	=o777760,du
    000162  aa  7 00025 7421 00    190  	stx2	sb|stack_header.stack_end_ptr+1
    000163  aa  7 00000 5421 11    191  	sprpbp	sb|0,1		" Save old return address
    000164  aa  7 00001 5441 11    192  	sprplp	sb|1,1		" and caller's lp.
    000165  aa  7 00004 7461 11    193  	stx6	sb|4,1		" save return point from empty.
    000166  aa  7 00010 5401 11    194  	sprpap	sb|8,1		" pass one arg, the address of the stream.
    000167  aa  0 00004 7611 00    195  	lprpab	ap|4		" routine to write out buffer.
    000170  aa  1 00000 2721 00    196  	tspbp	ab|0		" call.
    000171  aa   000006 000001     197  	zero	6,1
    000172  aa  7 00000 7621 11    198  	lprpbp	sb|0,1		" restore old return address.
    000173  aa  7 00004 2261 11    199  	ldx6	sb|4,1		" return point from empty.
    000174  aa  2 00000 1211 00    200  	sblx1	bp|0
    000175  aa   000000 7100 16    201  	tra	0,6		" return or try again to write character.
                                   202  
                        000176     203  	segdef	Packstring	" Packstring (Unpacked string, Vector).
    000176                         204  Packstring:
    000176  aa  2 00000 6221 71    205  	eax2	bp|0,*1
    000177  aa  7 00000 5421 12    206  	sprpbp	sb|0,2		" save return address.
    000200  aa  7 00002 7601 12    207  	lprpap	sb|2,2		" address of unpacked string.
    000201  aa  7 00003 7621 12    208  	lprpbp	sb|3,2		" address of vector.
    000202  aa  0 00000 2351 00    209  	lda	ap|0		" length of string.
    000203  aa   000001 0750 07    210  	ada	1,dl		" + 2 bytes for length, - 1 for divide.
    000204  aa   000002 7730 00    211  	lrl	2		" number of words in A.
    000205  aa   000020 7720 00    212  	qrl	16		" number of bytes used in last word in Qu.
    000206  aa   000000 6250 02    213  	eax5	0,qu
    000207  aa  2 00001 3521 05    214  	eppbp	bp|1,al		" bp -> last word to be stored into.
    000210  aa   000000 5310 00    215  	neg
    000211  aa   777777 6260 05    216  	eax6	-1,al		" so that bp|0,6 points to first word.
    000212  aa  0 00002 2351 00    217  	lda	ap|2
    000213  aa   000011 7730 00    218  	lrl	9
    000214  aa  0 00001 2351 00    219  	lda	ap|1
    000215  aa   000011 7730 00    220  	lrl	9
    000216  aa  0 00000 2351 00    221  	lda	ap|0
    000217  aa   000022 7730 00    222  	lrl	18
    000220  aa  0 77777 3501 00    223  	eppap	ap|-1
    000221  aa   000011 7100 04    224  	tra	penter-*,ic	" Jump into loop.
                                   225  
    000222  aa  0 00003 2351 00    226  ploop:	lda	ap|3		" take four characters in reverse order.
    000223  aa   000011 7730 00    227  	lrl	9		" and shift each one into Q.
    000224  aa  0 00002 2351 00    228  	lda	ap|2
    000225  aa   000011 7730 00    229  	lrl	9
    000226  aa  0 00001 2351 00    230  	lda	ap|1
    000227  aa   000011 7730 00    231  	lrl	9
    000230  aa  0 00000 2351 00    232  	lda	ap|0
    000231  aa   000011 7730 00    233  	lrl	9
    000232  aa  2 00000 7561 16    234  penter:	stq	bp|0,6		" store packed word.
    000233  aa  0 00004 3501 00    235  	eppap	ap|4		" advance pointer to unpacked version.
    000234  aa   000001 0660 03    236  	adx6	1,du		" increment counter.
    000235  aa   777765 6040 04    237  	tmi	ploop-*,ic
    000236  0a   000241 3760 15    238  	anq	masklist,5	" mask off trailing character positions in last word.
    000237  aa  2 77777 7561 16    239  	stq	bp|-1,6		" overwrite last word as stored within loop.
    000240  aa   000122 7100 04    240  	tra	reloadreturn-*,ic
                                   241  
    000241  aa   777000 000000     242  masklist:	oct	777000000000
    000242  aa   777777 000000     243  	oct	777777000000
    000243  aa   777777 777000     244  	oct	777777777000
    000244  aa   777777 777777     245  	oct	777777777777
                                   246  
                        000245     247  	segdef	Unpackstring	" Unpackstring (String, Vector).
    000245                         248  Unpackstring:
    000245  aa  2 00000 6221 71    249  	eax2	bp|0,*1
    000246  aa  7 00000 5421 12    250  	sprpbp	sb|0,2		" save return address.
    000247  aa  7 00002 7601 12    251  	lprpap	sb|2,2		" string address.
    000250  aa  7 00003 7621 12    252  	lprpbp	sb|3,2		" vector address.
    000251  aa  0 00000 2351 00    253  	lda	ap|0		" get character count.
    000252  aa   000022 7730 00    254  	lrl	18
    000253  aa  2 00000 7551 00    255  	sta	bp|0		" store length of string.
    000254  aa  2 00002 3521 05    256  	eppbp	bp|2,al		" bp -> last word of unpacked string to be stored.
    000255  aa   000000 5310 00    257  	neg
    000256  aa   777777 6260 05    258  	eax6	-1,al		" so bp|0,6 will point to first word (after count).
    000257  aa   000014 7100 04    259  	tra	uenter-*,ic	" Jump into loop.
                                   260  
    000260  aa  0 00000 2361 00    261  uloop:	ldq	ap|0		" next four characters.
    000261  aa   000000 2350 07    262  	lda	0,dl		" clear A.
    000262  aa   000011 7370 00    263  	lls	9		" shift next character into A.
    000263  aa  2 00000 7551 16    264  	sta	bp|0,6		" store it.
    000264  aa   000001 0660 03    265  	adx6	1,du		" check for end.
    000265  aa   000075 6050 04    266  	tpl	reloadreturn-*,ic
    000266  aa   000000 2350 07    267  	lda	0,dl
    000267  aa   000011 7370 00    268  	lls	9
    000270  aa  2 00000 7551 16    269  	sta	bp|0,6
    000271  aa   000001 0660 03    270  	adx6	1,du
    000272  aa   000070 6050 04    271  	tpl	reloadreturn-*,ic
    000273  aa   000000 2350 07    272  uenter:	lda	0,dl
    000274  aa   000011 7370 00    273  	lls	9
    000275  aa  2 00000 7551 16    274  	sta	bp|0,6
    000276  aa   000001 0660 03    275  	adx6	1,du
    000277  aa   000063 6050 04    276  	tpl	reloadreturn-*,ic
    000300  aa   000000 2350 07    277  	lda	0,dl
    000301  aa   000011 7370 00    278  	lls	9
    000302  aa  2 00000 7551 16    279  	sta	bp|0,6
    000303  aa  0 00001 3501 00    280  	eppap	ap|1		" advance pointer to string.
    000304  aa   000001 0660 03    281  	adx6	1,du		" check for end.
    000305  aa   777753 6040 04    282  	tmi	uloop-*,ic
    000306  aa   000054 7100 04    283  	tra	reloadreturn-*,ic
                                   284  
                        000307     285  	segdef	Move		" Move (Toptr, Fromptr, Wordcount).
    000307  aa  2 00000 6221 71    286  Move:	eax2	bp|0,*1
    000310  aa  7 00000 5421 12    287  	sprpbp	sb|0,2
    000311  aa  7 00002 7601 12    288  	lprpap	sb|2,2		" Toptr.
    000312  aa  7 00003 7621 12    289  	lprpbp	sb|3,2		" Fromptr.
    000313  aa   000000 6260 00    290  	eax6	0		" count number of words already moved.
    000314  aa  7 00005 4501 12    291  	stz	sb|5,2		" clear for later use.
    000315  aa  7 00004 2351 12    292  mloop:	lda	sb|4,2		" Wordcount.
    000316  aa  7 00005 4461 12    293  	sxl6	sb|5,2		" words already moved.
    000317  aa  7 00005 1751 12    294  	sba	sb|5,2		" words left to move.
    000320  aa   000042 6040 04    295  	tmi	reloadreturn-*,ic
    000321  aa   000041 6000 04    296  	tze	reloadreturn-*,ic
    000322  aa   000012 7350 00    297  	als	10		" set up for rpd.
                        001000     298  	bool	rpdbits,001000	" the only way to specify the address in octal.
    000323  aa   001000 6200 05    299  	eax0	rpdbits,al	" make it an rpda (index on first instruction).
    000324  aa   000000 0110 03    300  	odd
    000325  aa   000000 5602 01    301  	rpdx	,1		" X0 contains tally, RPDA code, and (null) termination bits.
    000326  aa  2 00000 2361 16    302  	ldq	bp|0,6
    000327  aa  0 00000 7561 16    303  	stq	ap|0,6
    000330  aa   777765 7100 04    304  	tra	mloop-*,ic
                                   305  
                        000331     306  	segdef	MoveBits		" MoveBits (To, Tobit, From, Frombit, Bitcount).
    000331  aa  2 00000 6221 71    307  MoveBits:	eax2	bp|0,*1
    000332  aa  7 00002 7601 12    308  	lprpap	sb|2,2		" To.
    000333  aa  7 00003 2351 12    309  	lda	sb|3,2		" Tobit.
    000334  aa  7 00004 7611 12    310  	lprpab	sb|4,2		" From.
    000335  aa  7 00005 2361 12    311  	ldq	sb|5,2		" Frombit.
    000336  aa  0 00000 5035 05    312  	abd	ap|0,al		" Free A by adding offset into pointer.
    000337  aa  7 00006 2351 12    313  	lda	sb|6,2		" Bitcount.
    000340  aa  2 00001 6045 00    314  	tmoz	bp|1		" Nothing to move.
                                   315  
    000341  aa  0 03140 0605 46    316  	csl	bool(03),(pr,rl,ql),(pr,rl)	" This is really a copy.
    000342  aa   100000 000005     317  	descb	ab|0,al		" Offset by ql.
    000343  aa   000000 000005     318  	descb	ap|0,al		" Length in al.
    000344  aa  2 00001 7101 00    319  	tra	bp|1
                                   320  
                        000345     321  	segdef	ScanChar		" ScanChar (Ptr, Offset, Length, Ch) = Offset to Ch or -1.
    000345  aa  2 00000 6221 71    322  ScanChar:	eax2	bp|0,*1
    000346  aa  7 00002 7601 12    323  	lprpap	sb|2,2		" Ptr.
    000347  aa  7 00003 2351 12    324  	lda	sb|3,2		" Offset.
    000350  aa  7 00004 2361 12    325  	ldq	sb|4,2		" Length.
    000351  aa  7 00005 3515 12    326  	eppab	sb|5,2		" lv Ch.
    000352  aa  0 00100 1245 45    327  	scm	mask(0),(pr,rl,al),(pr)	" Match on all 9 bits of character.
    000353  aa   000000 000006     328  	desc9a	ap|0,ql		" Length in ql, offset in al.
    000354  aa   100000 600001     329  	desc9a	ab|0(3),1		" Ch right justified.
    000355  aa  6 00000 0001 00    330  	arg	sp|0		" Resulting offset stored here.
    000356  aa  6 00000 2361 00    331  	ldq	sp|0
    000357  aa  2 00001 6071 00    332  	ttf	bp|1		" Return it if match occurred.
    000360  aa   000001 3360 07    333  	lcq	1,dl
    000361  aa  2 00001 7101 00    334  	tra	bp|1
                                   335  
    000362                         336  reloadreturn:	"		" common return sequence when bp has been stored.
    000362  aa  7 00000 7621 12    337  	lprpbp	sb|0,2
    000363  aa  2 00001 7101 00    338  	tra	bp|1
                                   339  
                        000364     340  	segdef	Subch		" Subch (String, Characteroffset) = Character.
    000364  aa  2 00000 6221 71    341  Subch:	eax2	bp|0,*1
    000365  aa  7 00002 7601 12    342  	lprpap	sb|2,2		" String.
    000366  aa  7 00003 2351 12    343  	lda	sb|3,2		" Characteroffset.
    000367  aa  0 00100 1015 05    344  	mrl	(pr,al),(pr),fill(0)	" Copy character right justified.
    000370  aa   000000 200001     345  	desc9a	ap|0(1),1	" Offset by one extra for string count byte.
    000371  aa   600000 000004     346  	desc9a	sp|0,4
    000372  aa  6 00000 2361 00    347  	ldq	sp|0
    000373  aa  2 00001 7101 00    348  	tra	bp|1
                                   349  
                        000374     350  	segdef	Level		" Level () = level (sp in left half, x1 in right half).
    000374  aa  6 00000 6351 00    351  Level:	eaa	sp|0		" sp in Au.
    000375  aa   000000 6360 11    352  	eaq	0,1		" x1 in Qu.
    000376  aa   000022 7710 00    353  	arl	18
    000377  aa   000022 7730 00    354  	lrl	18		" result in Q.
    000400  aa  2 00001 7101 00    355  	tra	bp|1
                                   356  
                        000401     357  	segdef	Longjump		" Longjump (Label, Level).
    000401  aa  2 00000 6221 71    358  Longjump:	eax2	bp|0,*1
    000402  aa  7 00000 5421 12    359  	sprpbp	sb|0,2		" save return address although don't use it.
    000403  aa  7 00046 2721 20    360  	getlp			" find linkage section.
    000404  aa  7 00002 7621 12    361  	lprpbp	sb|2,2		" label.
    000405  aa  7 00003 2361 12    362  	ldq	sb|3,2		" level.
    000406  aa  6 00000 6261 00    363  	eax6	sp|0		" current sp.
    000407  aa  7 00003 1061 12    364  	cmpx6	sb|3,2		" check for jump crossing Multics stack frames.
    000410  aa   000004 6010 04    365  	tnz	hard_way-*,ic	" do it by calling the unwinder.
    000411  aa   000000 6210 06    366  	eax1	0,ql		" set x1 (BCPL stack frame pointer).
    000412  aa  7 00001 7641 11    367  	lprplp	sb|1,1		" reload lp from old frame.
    000413  aa  2 00000 7101 00    368  	tra	bp|0		" goto label.
                                   369  
    000414  aa   000100 6230 12    370  hard_way:	eax3	64,2		" adjust stack frame.
    000415  aa   777760 3630 03    371  	anx3	=o777760,du
    000416  aa  7 00025 7431 00    372  	stx3	sb|stack_header.stack_end_ptr+1
    000417  aa  7 00000 3535 02    373  	eppbb	sb|0,qu		" old stack frame (old sp).
    000420  aa  3 00010 7561 00    374  	stq	bb|8		" store args for use by do_jump after unwinding.
    000421  aa  3 00000 2521 00    375  	spribp	bb|0
    000422  aa   000014 3520 04    376  	eppbp	do_jump-*,ic	"'return' address from unwinder
    000423  aa  7 00002 2521 12    377  	spribp	sb|2,2		" make label variable.
    000424  aa  7 00004 2535 12    378  	spribb	sb|4,2		" part of label variable by PL/I standards.
    000425  aa  7 00010 3501 12    379  	eppap	sb|8,2		" arglist for the unwinder.
    000426  aa  7 00002 3521 12    380  	eppbp	sb|2,2		" the argument - the label variable.
    000427  aa  0 00002 2521 00    381  	spribp	ap|2
    000430  aa   004000 4310 07    382  	fld	=1b24,dl		" one arg, no descriptors.
    000431  aa  0 00000 7571 00    383  	staq	ap|0		" put count in arglist.
    000432  4a  4 00020 3521 20    384  	short_call	<unwinder_>|[unwinder_]
    000433  aa  7 00036 6701 20
    000434  aa  6 00030 3701 20
    000435  aa   030071 0000 00    385  	arg	12345		" just in case unwinder_ returns.
                                   386  
    000436  aa  6 00010 7211 00    387  do_jump:	lxl1	sp|8		" come here in right stack frame.
    000437  aa  7 00001 7641 11    388  	lprplp	sb|1,1		" reload and jump.
    000440  aa  6 00000 7101 20    389  	tra	sp|0,*
                                   390  
                        000441     391  	segdef	Pl1Call		" Pl1Call (F, Arglist)
    000441  aa  2 00000 0211 00    392  Pl1Call:	adlx1	bp|0
    000442  aa  7 00000 5421 11    393  	sprpbp	sb|0,1		" save any registers needed later.
    000443  aa  6 00010 4411 00    394  	sxl1	sp|8
    000444  aa  6 00030 6501 00    395  	sprilp	sp|24
    000445  aa  7 00002 7621 11    396  	lprpbp	sb|2,1		" Pick up routine address
    000446  aa  7 00003 7601 11    397  	lprpap	sb|3,1		" and argument list pointer.
    000447  aa  7 00036 6701 20    398  	tsplp	sb|stack_header.call_op_ptr,*
    000450  aa  6 00010 7211 00    399  	lxl1	sp|8		" Restore and return.
    000451  aa  7 00000 7621 11    400  	lprpbp	sb|0,1
    000452  aa  2 00000 1211 00    401  	sblx1	bp|0
    000453  aa  7 00001 7641 11    402  	lprplp	sb|1,1
    000454  aa  2 00001 7101 00    403  	tra	bp|1
                                   404  
                        000455     405  	segdef	Bcall		" Bcall (F, n, (list X1, ..., Xn)) = F (X1, ..., Xn).
    000455  aa  2 00000 0211 00    406  Bcall:	adlx1	bp|0		" more like the regular BCPL save sequence.
    000456  aa  7 00000 5421 11    407  	sprpbp	sb|0,1		" save return address.
    000457  aa  7 00046 2721 20    408  	getlp			" find linkage section.
    000460  aa  7 00001 5441 11    409  	sprplp	sb|1,1		" save its address too.
    000461  aa   004000 6220 11    410  	eax2	2048,1		" adjust stack frame for adequate room.
    000462  aa   777760 3620 03    411  	anx2	=o777760,du
    000463  aa  7 00025 7421 00    412  	stx2	sb|stack_header.stack_end_ptr+1
    000464  aa  7 00004 7601 11    413  	lprpap	sb|4,1		" arg list address.
    000465  aa  7 00010 3521 11    414  	eppbp	sb|8,1		" address of first arg for BCPL call.
    000466  aa  7 00003 7261 11    415  	lxl6	sb|3,1		" arg count.
    000467  9a  4 00011 4461 00    416  	sxl6	lp|nargs		" initialize arg count for NumbArgs.
    000470  aa   000001 1660 03    417  cloop:	sbx6	1,du		" copy arguments into stack.
    000471  aa   000004 6040 04    418  	tmi	doit-*,ic
    000472  aa  0 00000 2361 16    419  	ldq	ap|0,6
    000473  aa  2 00000 7561 16    420  	stq	bp|0,6
    000474  aa   777774 7100 04    421  	tra	cloop-*,ic
    000475  aa  7 00002 7601 11    422  doit:	lprpap	sb|2,1		" routine address.
    000476  9a  4 00010 7101 00    423  	tra	lp|realcall	" put call and its data word in static section.
                                   424  
                                   425  	use	linklc
                                   426  	join	/link/linklc
                                   427  
    000010  aa  0 00000 2721 00    428  realcall:	tspbp	ap|0		" make the call from here.
    000011  aa   000006 030071     429  nargs:	zero	6,12345
    000012  aa  7 00000 7621 11    430  	lprpbp	sb|0,1		" restore and return.
    000013  aa  2 00000 1211 00    431  	sblx1	bp|0
    000014  aa  7 00001 7641 11    432  	lprplp	sb|1,1
    000015  aa  2 00001 7101 00    433  	tra	bp|1
                                   434  
                                   435  
                                   436  
                                   437  	use	textc		" back to text section.
                                   438  
                                   439  	include	stack_header	" Get declaration of stack_header.stack_end_ptr.
                                   1-1  "	BEGIN INCLUDE FILE ... stack_header.incl.alm  3/72  Bill Silver
                                   1-2  "
                                   1-3  "	modified 7/76 by M. Weaver for *system links and more system use of areas
                                   1-4  "	modified 3/77 by M. Weaver  to add rnt_ptr
                                   1-5  "	modified 7/77 by S. Webber to add run_unit_depth and assign_linkage_ptr
                                   1-6  "	modified 6/83 by J. Ives to add trace_frames and in_trace.
                                   1-7  
                                   1-8  " HISTORY COMMENTS:
                                   1-9  "  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
                                  1-10  "     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
                                  1-11  "     added the heap_header_ptr definition
                                  1-12  "  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
                                  1-13  "     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
                                  1-14  "     Modified to support control point management.  These changes were
                                  1-15  "     actually made in February 1985 by G. Palter.
                                  1-16  "  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
                                  1-17  "     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
                                  1-18  "     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
                                  1-19  "     bit pad after cur_lot_size for the cpm_enabled. This was done to save
                                  1-20  "     some space int the stack header and change the cpd_ptr unal to
                                  1-21  "     cpm_data_ptr (ITS pair).
                                  1-22  "                                                      END HISTORY COMMENTS
                                  1-23  
                        000004    1-24  	equ	stack_header.cpm_data_ptr,4		ptr to control point for this stack
                        000006    1-25  	equ	stack_header.combined_stat_ptr,6	ptr to separate static area
                                  1-26  
                        000010    1-27  	equ	stack_header.clr_ptr,8		ptr to area containing linkage sections
                        000012    1-28  	equ	stack_header.max_lot_size,10		number of words allowed in lot (DU)
                        000012    1-29  	equ	stack_header.main_proc_invoked,10	nonzero if main proc was invoked in run unit (DL)
                        000012    1-30  	equ	stack_header.run_unit_depth,10	number of active run units stacked (DL)
                        000013    1-31  	equ	stack_header.cur_lot_size,11		DU number of words (entries) in lot
                        000013    1-32            equ	stack_header.cpm_enabled,11		DL  non-zero if control point management is enabled
                        000014    1-33  	equ	stack_header.system_free_ptr,12	ptr to system storage area
                        000016    1-34  	equ	stack_header.user_free_ptr,14		ptr to user storage area
                                  1-35  
                        000020    1-36  	equ	stack_header.parent_ptr,16		ptr to parent stack or null
                        000022    1-37  	equ	stack_header.stack_begin_ptr,18	ptr to first stack frame
                        000024    1-38  	equ	stack_header.stack_end_ptr,20		ptr to next useable stack frame
                        000026    1-39  	equ	stack_header.lot_ptr,22		ptr to the lot for the current ring
                                  1-40  
                        000030    1-41  	equ	stack_header.signal_ptr,24		ptr to signal proc for current ring
                        000032    1-42  	equ	stack_header.bar_mode_sp,26		value of sp before entering bar mode
                        000034    1-43  	equ	stack_header.pl1_operators_ptr,28	ptr: pl1_operators_$operator_table
                        000036    1-44  	equ	stack_header.call_op_ptr,30		ptr to standard call operator
                                  1-45  
                        000040    1-46  	equ	stack_header.push_op_ptr,32		ptr to standard push operator
                        000042    1-47  	equ	stack_header.return_op_ptr,34		ptr to standard return operator
                        000044    1-48  	equ	stack_header.ret_no_pop_op_ptr,36	ptr: stand. return/ no pop operator
                        000046    1-49  	equ	stack_header.entry_op_ptr,38		ptr to standard entry operator
                                  1-50  
                        000050    1-51  	equ	stack_header.trans_op_tv_ptr,40	ptr to table of translator operator ptrs
                        000052    1-52  	equ	stack_header.isot_ptr,42		pointer to ISOT
                        000054    1-53  	equ	stack_header.sct_ptr,44		pointer to System Condition Table
                        000056    1-54  	equ	stack_header.unwinder_ptr,46		pointer to unwinder for current ring
                                  1-55  
                        000060    1-56  	equ	stack_header.sys_link_info_ptr,48	ptr to *system link name table
                        000062    1-57  	equ	stack_header.rnt_ptr,50		ptr to reference name table
                        000064    1-58  	equ	stack_header.ect_ptr,52		ptr to event channel table
                        000066    1-59  	equ	stack_header.assign_linkage_ptr,54	ptr to area for hcs_$assign_linkage calls
                        000070    1-60  	equ	stack_header.heap_header_ptr,56	ptr to heap header.
                        000072    1-61  	equ	stack_header.trace_frames,58		stack of trace_catch_ frames
                        000073    1-62  	equ	stach_header.trace_top_ptr,59		trace pointer
                        000074    1-63  	equ	stack_header.in_trace,60		trace antirecurse bit
                        000100    1-64  	equ	stack_header_end,64			length of stack header
                                  1-65  
                                  1-66  
                                  1-67  
                                  1-68  
                        000000    1-69  	equ	trace_frames.count,0		number of trace frames on stack
                        000001    1-70  	equ	trace_frames.top_ptr,1		packed pointer to top one
                                  1-71  
                                  1-72  "	The  following constant is an offset within the  pl1  operators table.
                                  1-73  "	It  references a  transfer vector table.
                                  1-74  
                        000551    1-75  	bool	tv_offset,551
                                  1-76  
                                  1-77  
                                  1-78  "	The  following constants are offsets within this transfer vector table.
                                  1-79  
                        001170    1-80  	equ	call_offset,tv_offset+271
                        001171    1-81  	equ	push_offset,tv_offset+272
                        001172    1-82  	equ	return_offset,tv_offset+273
                        001173    1-83  	equ	return_no_pop_offset,tv_offset+274
                        001174    1-84  	equ	entry_offset,tv_offset+275
                                  1-85  
                                  1-86  
                                  1-87  " 	END INCLUDE FILE stack_header.incl.alm
                                   440  
                                   441  	end

NO LITERALS
     
NAME DEFINITIONS FOR ENTRY POINTS AND SEGDEFS

    000500  5a   000003 000000 
    000501  5a   000203 600000 
    000502  aa   000000 000000 
    000503  55   000013 000002 
    000504  5a   000002 400003 
    000505  55   000006 000013 
    000506  aa  022 142 143 160
    000507  aa  154 137 155 141
    000510  aa  143 150 151 156
    000511  aa  145 137 143 157
    000512  aa  144 145 137 000
    000513  55   000020 000003 
    000514  0a   000455 400000 
    000515  55   000016 000003 
    000516  aa  005 102 143 141         Bcall
    000517  aa  154 154 000 000
    000520  55   000025 000013 
    000521  0a   000441 400000 
    000522  55   000023 000003 
    000523  aa  007 120 154 061         Pl1Call
    000524  aa  103 141 154 154
    000525  55   000033 000020 
    000526  0a   000401 400000 
    000527  55   000030 000003 
    000530  aa  010 114 157 156         Longjump
    000531  aa  147 152 165 155
    000532  aa  160 000 000 000
    000533  55   000040 000025 
    000534  0a   000374 400000 
    000535  55   000036 000003 
    000536  aa  005 114 145 166         Level
    000537  aa  145 154 000 000
    000540  55   000045 000033 
    000541  0a   000364 400000 
    000542  55   000043 000003 
    000543  aa  005 123 165 142         Subch
    000544  aa  143 150 000 000
    000545  55   000053 000040 
    000546  0a   000345 400000 
    000547  55   000050 000003 
    000550  aa  010 123 143 141         ScanChar
    000551  aa  156 103 150 141
    000552  aa  162 000 000 000
    000553  55   000061 000045 
    000554  0a   000331 400000 
    000555  55   000056 000003 
    000556  aa  010 115 157 166         MoveBits
    000557  aa  145 102 151 164
    000560  aa  163 000 000 000
    000561  55   000066 000053 
    000562  0a   000307 400000 
    000563  55   000064 000003 
    000564  aa  004 115 157 166         Move
    000565  aa  145 000 000 000
    000566  55   000075 000061 
    000567  0a   000245 400000 
    000570  55   000071 000003 
    000571  aa  014 125 156 160         Unpackstring
    000572  aa  141 143 153 163
    000573  aa  164 162 151 156
    000574  aa  147 000 000 000
    000575  55   000103 000066 
    000576  0a   000176 400000 
    000577  55   000100 000003 
    000600  aa  012 120 141 143         Packstring
    000601  aa  153 163 164 162
    000602  aa  151 156 147 000
    000603  55   000110 000075 
    000604  0a   000133 400000 
    000605  55   000106 000003 
    000606  aa  007 127 162 151         Writech
    000607  aa  164 145 143 150
    000610  55   000115 000103 
    000611  0a   000075 400000 
    000612  55   000113 000003 
    000613  aa  006 122 145 141         Readch
    000614  aa  144 143 150 000
    000615  55   000123 000110 
    000616  0a   000071 400000 
    000617  55   000120 000003 
    000620  aa  010 116 165 155         NumbArgs
    000621  aa  142 101 162 147
    000622  aa  163 000 000 000
    000623  55   000127 000115 
    000624  0a   000055 400000 
    000625  55   000126 000003 
    000626  aa  003 111 124 123         ITS
    000627  55   000135 000123 
    000630  0a   000047 400000 
    000631  55   000132 000003 
    000632  aa  010 102 103 120         BCPLaddr
    000633  aa  114 141 144 144
    000634  aa  162 000 000 000
    000635  55   000144 000127 
    000636  0a   000041 400000 
    000637  55   000140 000003 
    000640  aa  017 123 145 164         SetOverflowMask
    000641  aa  117 166 145 162
    000642  aa  146 154 157 167
    000643  aa  115 141 163 153
    000644  55   000151 000135 
    000645  0a   000030 400000 
    000646  55   000147 000003 
    000647  aa  004 122 164 157         RtoI
    000650  aa  111 000 000 000
    000651  55   000156 000144 
    000652  0a   000021 400000 
    000653  55   000154 000003 
    000654  aa  004 111 164 157         ItoR
    000655  aa  122 000 000 000
    000656  55   000165 000151 
    000657  0a   000012 400000 
    000660  55   000161 000003 
    000661  aa  015 124 151 155         TimeToSeconds
    000662  aa  145 124 157 123
    000663  aa  145 143 157 156
    000664  aa  144 163 000 000
    000665  55   000174 000156 
    000666  0a   000000 400000 
    000667  55   000170 000003 
    000670  aa  014 122 141 167         RawClockTime
    000671  aa  103 154 157 143
    000672  aa  153 124 151 155
    000673  aa  145 000 000 000
    000674  55   000002 000165 
    000675  6a   000000 400002 
    000676  55   000177 000003 
    000677  aa  014 163 171 155         symbol_table
    000700  aa  142 157 154 137
    000701  aa  164 141 142 154
    000702  aa  145 000 000 000

DEFINITIONS HASH TABLE

    000703  aa   000000 000033 
    000704  aa   000000 000000 
    000705  aa   000000 000000 
    000706  5a   000135 000000 
    000707  aa   000000 000000 
    000710  aa   000000 000000 
    000711  5a   000013 000000 
    000712  5a   000040 000000 
    000713  5a   000033 000000 
    000714  5a   000115 000000 
    000715  aa   000000 000000 
    000716  5a   000151 000000 
    000717  5a   000165 000000 
    000720  5a   000174 000000 
    000721  5a   000025 000000 
    000722  5a   000020 000000 
    000723  5a   000123 000000 
    000724  aa   000000 000000 
    000725  5a   000103 000000 
    000726  5a   000075 000000 
    000727  5a   000045 000000 
    000730  5a   000110 000000 
    000731  5a   000066 000000 
    000732  5a   000053 000000 
    000733  5a   000127 000000 
    000734  5a   000144 000000 
    000735  5a   000156 000000 
    000736  5a   000061 000000 

EXTERNAL NAMES

    000737  aa  011 165 156 167         unwinder_
    000740  aa  151 156 144 145
    000741  aa  162 137 000 000
    000742  aa  006 143 154 157         clock_
    000743  aa  143 153 137 000
    000744  aa  010 163 171 163         sys_info
    000745  aa  137 151 156 146
    000746  aa  157 000 000 000

NO TRAP POINTER WORDS

TYPE PAIR BLOCKS

    000747  aa   000004 000000 
    000750  55   000237 000237 
    000751  aa   000004 000000 
    000752  55   000244 000242 
    000753  aa   000001 000000 
    000754  aa   000000 000000 

INTERNAL EXPRESSION WORDS

    000755  5a   000247 000000 
    000756  5a   000251 000000 
    000757  aa   000000 000000 
LINKAGE INFORMATION
      
    000000  aa   000000 000000 
    000001  0a   000500 000000 
    000002  aa   000000 000000 
    000003  aa   000000 000000 
    000004  aa   000000 000000 
    000005  aa   000000 000000 
    000006  22   000016 000022 
    000007  a2   000000 000006 
    000016  9a   777762 0000 46         sys_info|clock_
    000017  5a   000256 0000 20
    000020  9a   777760 0000 46         unwinder_|unwinder_
    000021  5a   000255 0000 00
SYMBOL INFORMATION
     
SYMBOL TABLE HEADER
     
    000000  aa   000000 000001 
    000001  aa   163171 155142 
    000002  aa   164162 145145 
    000003  aa   000000 000004 
    000004  aa   000000 114732 
    000005  aa   732732 062314 
    000006  aa   000000 114775 
    000007  aa   660376 714157 
    000010  aa   141154 155040 
    000011  aa   040040 040040 
    000012  aa   000024 000040 
    000013  aa   000034 000040 
    000014  aa   000044 000100 
    000015  aa   000002 000002 
    000016  aa   000064 000000 
    000017  aa   000000 000172 
    000020  aa   000000 000132 
    000021  aa   000000 000157 
    000022  aa   000163 000132 
    000023  aa   000064 000000 
    000024  aa   101114 115040 
    000025  aa   126145 162163 
    000026  aa   151157 156040 
    000027  aa   040066 056067 
    000030  aa   040040 117143 
    000031  aa   164157 142145 
    000032  aa   162040 061071 
    000033  aa   070066 040040 
    000034  aa   107112 157150 
    000035  aa   156163 157156 
    000036  aa   056123 171163 
    000037  aa   115141 151156 
    000040  aa   164056 141040 
    000041  aa   040040 040040 
    000042  aa   040040 040040 
    000043  aa   040040 040040 
    000044  aa   154151 163164 
    000045  aa   040040 040040 
    000046  aa   040040 040040 
    000047  aa   040040 040040 
    000050  aa   040040 040040 
    000051  aa   040040 040040 
    000052  aa   040040 040040 
    000053  aa   040040 040040 
    000054  aa   040040 040040 
    000055  aa   040040 040040 
    000056  aa   040040 040040 
    000057  aa   040040 040040 
    000060  aa   040040 040040 
    000061  aa   040040 040040 
    000062  aa   040040 040040 
    000063  aa   040040 040040 
    000064  aa   000000 000001 
    000065  aa   000000 000002 
    000066  aa   000076 000067 
    000067  aa   147740 446225 
    000070  aa   000000 114774 
    000071  aa   460774 200000 
    000072  aa   000114 000066 
    000073  aa   147714 750316 
    000074  aa   000000 114774 
    000075  aa   453561 000000 
    000076  aa   076163 160145          >special_ldd>install>MR12.0-1206>bcpl_machine_code_.alm
    000077  aa   143151 141154 
    000100  aa   137154 144144 
    000101  aa   076151 156163 
    000102  aa   164141 154154 
    000103  aa   076115 122061 
    000104  aa   062056 060055 
    000105  aa   061062 060066 
    000106  aa   076142 143160 
    000107  aa   154137 155141 
    000110  aa   143150 151156 
    000111  aa   145137 143157 
    000112  aa   144145 137056 
    000113  aa   141154 155040 
    000114  aa   076163 160145          >special_ldd>install>MR12.0-1206>stack_header.incl.alm
    000115  aa   143151 141154 
    000116  aa   137154 144144 
    000117  aa   076151 156163 
    000120  aa   164141 154154 
    000121  aa   076115 122061 
    000122  aa   062056 060055 
    000123  aa   061062 060066 
    000124  aa   076163 164141 
    000125  aa   143153 137150 
    000126  aa   145141 144145 
    000127  aa   162056 151156 
    000130  aa   143154 056141 
    000131  aa   154155 040040 
               MULTICS ASSEMBLY CROSS REFERENCE LISTING

   Value        Symbol                   Source file   Line number

         455    Bcall                    bcpl_machine_code_:       405,  406.
          47    BCPLaddr                 bcpl_machine_code_:       102,  103.
        1170    call_offset              stack_header:        80.
                clock_                   bcpl_machine_code_:        53.
         470    cloop                    bcpl_machine_code_:       417,  421.
         475    doit                     bcpl_machine_code_:       418,  422.
         436    do_jump                  bcpl_machine_code_:       376,  387.
         155    empty                    bcpl_machine_code_:       181,  185.
        1174    entry_offset             stack_header:        84.
         154    full                     bcpl_machine_code_:       170,  184.
         414    hard_way                 bcpl_machine_code_:       365,  370.
          21    ItoR                     bcpl_machine_code_:        72,   73.
          55    ITS                      bcpl_machine_code_:       110,  111.
         374    Level                    bcpl_machine_code_:       350,  351.
          10    linklc                   bcpl_machine_code_:       425,  426.
         401    Longjump                 bcpl_machine_code_:       357,  358.
         241    masklist                 bcpl_machine_code_:       238,  242.
         315    mloop                    bcpl_machine_code_:       292,  304.
         307    Move                     bcpl_machine_code_:       285,  286.
         331    MoveBits                 bcpl_machine_code_:       306,  307.
          11    nargs                    bcpl_machine_code_:       416,  429.
          35    negative                 bcpl_machine_code_:        84,   88.
         130    nofill                   bcpl_machine_code_:       146,  161.
          71    NumbArgs                 bcpl_machine_code_:       125,  126.
          20    number                   bcpl_machine_code_:        66,   70.
         176    Packstring               bcpl_machine_code_:       203,  204.
         232    penter                   bcpl_machine_code_:       224,  234.
         441    Pl1Call                  bcpl_machine_code_:       391,  392.
         222    ploop                    bcpl_machine_code_:       226,  237.
        1171    push_offset              stack_header:        81.
           0    RawClockTime             bcpl_machine_code_:        48,   49.
          75    Readch                   bcpl_machine_code_:       131,  132,  159.
          10    realcall                 bcpl_machine_code_:       423,  428.
         111    refill                   bcpl_machine_code_:       137,  145.
         362    reloadreturn             bcpl_machine_code_:       240,  266,  271,  276,  283,  295,  296,  336.
        1173    return_no_pop_offset     stack_header:        83.
        1172    return_offset            stack_header:        82.
        1000    rpdbits                  bcpl_machine_code_:       298,  299.
          30    RtoI                     bcpl_machine_code_:        81,   82.
         345    ScanChar                 bcpl_machine_code_:       321,  322.
          41    SetOverflowMask          bcpl_machine_code_:        93,   94.
          73    stach_header.trace_top_ptr     stack_header:        62.
          66    stack_header.assign_linkage_ptr      stack_header:        59.
          32    stack_header.bar_mode_sp       stack_header:        42.
          36    stack_header.call_op_ptr       bcpl_machine_code_:       398,
                                               stack_header:        44.
          10    stack_header.clr_ptr     stack_header:        27.
           6    stack_header.combined_stat_ptr       stack_header:        25.
           4    stack_header.cpm_data_ptr      stack_header:        24.
          13    stack_header.cpm_enabled       stack_header:        32.
          13    stack_header.cur_lot_size      stack_header:        31.
          64    stack_header.ect_ptr     stack_header:        58.
          46    stack_header.entry_op_ptr      stack_header:        49.
          70    stack_header.heap_header_ptr   stack_header:        60.
          74    stack_header.in_trace    stack_header:        63.
          52    stack_header.isot_ptr    stack_header:        52.
          26    stack_header.lot_ptr     stack_header:        39.
          12    stack_header.main_proc_invoked       stack_header:        29.
          12    stack_header.max_lot_size      stack_header:        28.
          20    stack_header.parent_ptr  stack_header:        36.
          34    stack_header.pl1_operators_ptr       stack_header:        43.
          40    stack_header.push_op_ptr       stack_header:        46.
          42    stack_header.return_op_ptr     stack_header:        47.
          44    stack_header.ret_no_pop_op_ptr       stack_header:        48.
          62    stack_header.rnt_ptr     stack_header:        57.
          12    stack_header.run_unit_depth    stack_header:        30.
          54    stack_header.sct_ptr     stack_header:        53.
          30    stack_header.signal_ptr  stack_header:        41.
          22    stack_header.stack_begin_ptr   stack_header:        37.
          24    stack_header.stack_end_ptr     bcpl_machine_code_:       150,  190,  372,  412,
                                               stack_header:        38.
          14    stack_header.system_free_ptr   stack_header:        33.
          60    stack_header.sys_link_info_ptr       stack_header:        56.
          72    stack_header.trace_frames      stack_header:        61.
          50    stack_header.trans_op_tv_ptr   stack_header:        51.
          56    stack_header.unwinder_ptr      stack_header:        54.
          16    stack_header.user_free_ptr     stack_header:        34.
         100    stack_header_end         stack_header:        64.
         364    Subch                    bcpl_machine_code_:       340,  341.
                sys_info                 bcpl_machine_code_:        53.
           0    textc                    bcpl_machine_code_:        46,  437.
          12    TimeToSeconds            bcpl_machine_code_:        61,   62.
           0    trace_frames.count       stack_header:        69.
           1    trace_frames.top_ptr     stack_header:        70.
         551    tv_offset                stack_header:        75,   80,   81,   82,   83,   84.
         273    uenter                   bcpl_machine_code_:       259,  272.
         260    uloop                    bcpl_machine_code_:       261,  282.
         245    Unpackstring             bcpl_machine_code_:       247,  248.
                unwinder_                bcpl_machine_code_:       384.
         133    Writech                  bcpl_machine_code_:       165,  166,  184.


NO FATAL ERRORS


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
