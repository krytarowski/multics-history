	COMPILATION LISTING OF SEGMENT rs_open_str_in_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx, AZ, Sys-M  
	Compiled on: 09/10/87  1451.5 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* record_stream_ program for handling stream input openings */
       12 rs_open_str_in_:
       13      proc (iocb_ptr_arg);
       14 	iocb_ptr = iocb_ptr_arg;
       15 
       16 /* set entries for valid operations in this mode */
       17 	get_chars = get_chars_rs;
       18 	get_line = get_line_rs;
       19 	position = position_str_rs;
       20 	return;					/* end of open initialization routine */
       21 
       22 get_chars_rs:
       23      entry (iocb_ptr_arg, buff_ptr_arg, buff_len_arg, n_read, code);
       24 	call init_args;
       25 	if buff_len < 0
       26 	then code = error_table_$negative_nelem;
       27 	do while ((buff_len > 0) & (code = 0));		/* get buff_len characters */
       28 	     if n_left > 0
       29 	     then /* internal buffer is not empty */
       30 		do;				/* move chars between buffers */
       31 		     n_moved = min (buff_len, n_left);
       32 		     call move;
       33 		     if n_moved = buff_len
       34 		     then do;			/* normal return */
       35 exit:
       36 			     base = base + n_moved;
       37 			     return;
       38 			end;
       39 		     else /* more characters to be moved */
       40 			do;			/* advance through input buffer */
       41 			     buff_len = buff_len - n_moved;
       42 			     buff_ptr = addr (buff (n_moved + 1));
       43 			end;
       44 		end;
       45 	     call get_record;
       46 	end;
       47 	return;					/* end of get_chars routine */
       48 
       49 get_line_rs:
       50      entry (iocb_ptr_arg, buff_ptr_arg, buff_len_arg, n_read, code);
       51 	call init_args;
       52 	if buff_len <= 0
       53 	then code = error_table_$smallarg;
       54 	do while ((buff_len > 0) & (code = 0));		/* pick up remainder of line */
       55 	     if n_left > 0
       56 	     then /* internal buffer is not empty */
       57 		do;				/* move line between buffers */
       58 		     line_len = index (substr (rs_buffer, base, n_left), newline);
       59 		     if line_len = 0
       60 		     then length = n_left;
       61 		     else length = line_len;
       62 		     n_moved = min (length, buff_len);
       63 		     call move;			/* transfer n_moved chars from rs_buff to input buff */
       64 		     if length > buff_len
       65 		     then do;			/* error: line too long */
       66 			     code = error_table_$long_record;
       67 			     go to exit;
       68 			end;
       69 		     else if line_len > 0		/* newline has been found */
       70 		     then go to exit;
       71 		     else /* keep looking for end of line */
       72 			do;			/* advance through input_buffer */
       73 			     buff_len = buff_len - n_moved;
       74 			     buff_ptr = addr (buff (n_moved + 1));
       75 			end;
       76 		end;
       77 	     call get_record;			/* rs_buffer empty-- get another record */
       78 	end;
       79 	return;					/* end of get_line routine */
       80 
       81 position_str_rs:
       82      entry (iocb_ptr_arg, type, count, code);
       83 	call brief_init;
       84 	if type ^= 0
       85 	then do;					/* position to start or end of file */
       86 		n_left = 0;			/* flush rs_buffer */
       87 		call iox_$position (target_iocb_ptr, type, count, code);
       88 						/* pass call to target */
       89 	     end;
       90 	else /* skip case */
       91 	     do;					/* skip n lines */
       92 		if count < 0			/* no backward skips permitted */
       93 		then code = error_table_$negative_nelem;
       94 		n = count;
       95 		do while ((n > 0) & (code = 0));	/* skip n lines */
       96 		     if n_left <= 0
       97 		     then call get_record;		/* if rs_buffer is empty--fill it */
       98 		     else /* internal buffer is not empty */
       99 			do;			/* find newline in rs_buffer */
      100 			     line_len = index (substr (rs_buffer, base, n_left), newline);
      101 			     if line_len > 0
      102 			     then /* newline found */
      103 				do;		/* successful skip */
      104 				     base = base + line_len;
      105 				     n_left = n_left - line_len;
      106 				     n = n - 1;
      107 				end;
      108 			     else n_left = 0;	/* crunch past this record */
      109 			end;
      110 		end;
      111 	     end;					/* n lines skipped */
      112 	return;					/* end of stream position routine */
      113 
      114 /* internal procedures */
      115 init_args:
      116      proc;					/* initialize upon entry */
      117 	buff_len = buff_len_arg;
      118 	buff_ptr = buff_ptr_arg;
      119 	n_read = 0;
      120 brief_init:
      121      entry;
      122 	code = 0;
      123 	iocb_ptr = iocb_ptr_arg -> actual_iocb_ptr;
      124 	rsab_ptr = attach_data_ptr;
      125 	rs_buff_ptr = open_data_ptr;
      126 	return;
      127 
      128      end init_args;
      129 
      130 get_record:
      131      proc;					/* read a new record into the rs_buffer appending newline if default attachment */
      132 	call iox_$read_record (target_iocb_ptr, rs_buff_ptr, max_bufsize, n_left, code);
      133 	if code = 0
      134 	then do;
      135 		base = 1;
      136 		if length_n = 0
      137 		then /* default attachment */
      138 		     do;				/* append newline */
      139 			n_left = n_left + 1;
      140 			substr (rs_buffer, n_left, 1) = newline;
      141 		     end;
      142 	     end;
      143 	return;
      144      end get_record;
      145 
      146 move:
      147      proc;					/* take n_moved chars from rs_buffer and append to input buffer */
      148 	substr (buffer, 1, n_moved) = substr (rs_buffer, base, n_moved);
      149 	n_read = n_read + n_moved;
      150 	n_left = n_left - n_moved;
      151 	return;
      152 
      153      end move;
      154 
      155 /* declarations for entire program */
      156 	dcl     (iocb_ptr_arg, iocb_ptr, buff_ptr_arg, buff_ptr)
      157 				 ptr;
      158 	dcl     (buff_len_arg, buff_len, n_read)
      159 				 fixed (21);
      160 	dcl     code		 fixed (35);
      161 	dcl     error_table_$negative_nelem
      162 				 external fixed (35);
  1     1 
  1     2      dcl	   1 iocb		      aligned based (iocb_ptr),
  1     3 						/* I/O control block. */
  1     4 	     2 iocb_version	      fixed init (1),	/* Version number of structure. */
  1     5 	     2 name	      char (32),		/* I/O name of this block. */
  1     6 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  1     7 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  1     8 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  1     9 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  1    10 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  1    11 	     2 reserved	      bit (72),		/* Reserved for future use. */
  1    12 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  1    13 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  1    14 						/* open(p,mode,not_used,s) */
  1    15 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  1    16 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    17 						/* get_line(p,bufptr,buflen,actlen,s) */
  1    18 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    19 						/* get_chars(p,bufptr,buflen,actlen,s) */
  1    20 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    21 						/* put_chars(p,bufptr,buflen,s) */
  1    22 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  1    23 						/* modes(p,newmode,oldmode,s) */
  1    24 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  1    25 						/* position(p,u1,u2,s) */
  1    26 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  1    27 						/* control(p,order,infptr,s) */
  1    28 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    29 						/* read_record(p,bufptr,buflen,actlen,s) */
  1    30 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    31 						/* write_record(p,bufptr,buflen,s) */
  1    32 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  1    33 						/* rewrite_record(p,bufptr,buflen,s) */
  1    34 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  1    35 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    36 						/* seek_key(p,key,len,s) */
  1    37 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    38 						/* read_key(p,key,len,s) */
  1    39 	     2 read_length	      entry (ptr, fixed (21), fixed (35));
  1    40 						/* read_length(p,len,s) */
  1    41 
      163 
  2     1 /*  BEGIN:   rs_attach_block.incl.pl1			  *  *  *  *  *  */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(75-02-13,Asherman), approve(), audit(), install():
  2     6*     Initial coding.
  2     7*  2) change(87-08-30,GWMay), approve(87-08-30,MCR7730), audit(87-09-10,GDixon),
  2     8*     install(87-09-10,MR12.1-1104):
  2     9*     Changed target_name to be unaligned.
  2    10*                                                   END HISTORY COMMENTS */
  2    11 
  2    12 
  2    13 dcl	   rsab_ptr	      ptr;
  2    14      dcl	   1 rs_attach_block      based (rsab_ptr) aligned,
  2    15 						/* record_stream_ attach block */
  2    16 						/* the following are set during attachment */
  2    17 	     2 attach_descrip,
  2    18 	       3 attach_descrip_len
  2    19 			      fixed (35),
  2    20 	       3 attach_descrip_string
  2    21 			      char (66),		/* "record_stream_ <targ_sw_name> <option>" */
  2    22 	     2 target_name	      char (32) unaligned,	/* name of the target switch */
  2    23 	     2 length_n	      fixed (21),		/* =-1 --> -nnl option, */
  2    24 						/* = 0 --> default option, */
  2    25 						/* > 0 --> -length option */
  2    26 	     2 i_attached_target  bit (1) aligned,	/* ="1"b --> target attached via -target option */
  2    27 						/* the following are set during opening */
  2    28 	     2 open_descrip,
  2    29 	       3 open_descrip_len fixed (35),
  2    30 	       3 open_descrip_string
  2    31 			      char (24),
  2    32 	     2 mode	      fixed,		/* opening mode-- may be 1,2,4, or 5 if open */
  2    33 	     2 target_iocb_ptr    ptr,		/* points to the iocb for the target switch */
  2    34 	     2 i_opened_target    bit (1) aligned,	/* ="1"b --> this opening caused target to be opened */
  2    35 	     2 base	      fixed (21),		/* offset of next byte in rs_buffer */
  2    36 	     2 n_left	      fixed (21);		/* number of unprocessed bytes in rs_buffer */
  2    37 
  2    38 /*  END OF:  rs_attach_block.incl.pl1			  *  *  *  *  *  */
      164 
      165 	dcl     n_moved		 fixed (21);
      166 	dcl     error_table_$smallarg	 external fixed (35);
      167 	dcl     line_len		 fixed (21);
      168 	dcl     (index, substr, min, addr)
      169 				 builtin;
      170 	dcl     length		 fixed (21);
      171 	dcl     error_table_$long_record
      172 				 external fixed (35);
      173 	dcl     type		 fixed;
      174 	dcl     count		 fixed (21);
      175 	dcl     iox_$position	 entry (ptr, fixed, fixed (21), fixed (35));
      176 	dcl     n			 fixed (21);
      177 	dcl     newline		 char (1) aligned static internal init ("
      178 ");
      179 	dcl     iox_$read_record	 entry (ptr, ptr, fixed (21), fixed (21), fixed (35));
      180 	dcl     error_table_$no_record external fixed (35);
  3     1 /* BEGIN INCLUDE FILE ..... rs_buffer.inc.pl1 ..... 14 Feb 1975, M. Asherman */
  3     2 
  3     3      dcl	   rs_buff_ptr	      ptr;		/* points to buffer segment */
  3     4      dcl	   rs_buffer	      char (max_bufsize) based (rs_buff_ptr) aligned;
  3     5 						/* internal record_stream_ line/record buffer */
  3     6      dcl	   max_bufsize	      static internal fixed (21) init (1044480);
  3     7 						/* 255 K words */
  3     8 
  3     9 /* END INCLUDE FILE ..... rs_buffer.inc.pl1 ..... */
      181 
      182 	dcl     buffer		 char (buff_len) based (buff_ptr);
      183 	dcl     buff		 (buff_len) char (1) based (buff_ptr);
      184 
      185      end rs_open_str_in_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/10/87  1447.6  rs_open_str_in_.pl1               >special_ldd>install>MR12.1-1104>rs_open_str_in_.pl1
163          1    07/02/81  1905.0  iocbv.incl.pl1                    >ldd>include>iocbv.incl.pl1
164          2    09/10/87  1444.7  rs_attach_block.incl.pl1          >special_ldd>install>MR12.1-1104>rs_attach_block.incl.pl1
181          3    07/19/79  1547.0  rs_buffer.incl.pl1                >ldd>include>rs_buffer.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
actual_iocb_ptr          12            based           pointer                  level 2 dcl 1-2 ref 123
addr                                                   builtin function         dcl 168 ref 42 74
attach_data_ptr          16            based           pointer                  level 2 dcl 1-2 ref 124
base                     47            based           fixed bin(21,0)          level 2 dcl 2-14 set ref 35* 35 58 100 104* 104 135*
                                                                                  148
buff                                   based           char(1)                  array unaligned dcl 183 set ref 42 74
buff_len                        000104 automatic       fixed bin(21,0)          dcl 158 set ref 25 27 31 33 41* 41 52 54 62 64 73*
                                                                                  73 117* 148
buff_len_arg                           parameter       fixed bin(21,0)          dcl 158 ref 22 49 117
buff_ptr                        000102 automatic       pointer                  dcl 156 set ref 42* 42 74* 74 118* 148
buff_ptr_arg                           parameter       pointer                  dcl 156 ref 22 49 118
buffer                                 based           char                     unaligned dcl 182 set ref 148*
code                                   parameter       fixed bin(35,0)          dcl 160 set ref 22 25* 27 49 52* 54 66* 81 87* 92*
                                                                                  95 122* 132* 133
count                                  parameter       fixed bin(21,0)          dcl 174 set ref 81 87* 92 94
error_table_$long_record        000016 external static fixed bin(35,0)          dcl 171 ref 66
error_table_$negative_nelem     000012 external static fixed bin(35,0)          dcl 161 ref 25 92
error_table_$smallarg           000014 external static fixed bin(35,0)          dcl 166 ref 52
get_chars                46            based           entry variable           level 2 dcl 1-2 set ref 17*
get_line                 42            based           entry variable           level 2 dcl 1-2 set ref 18*
index                                                  builtin function         dcl 168 ref 58 100
iocb                                   based           structure                level 1 dcl 1-2
iocb_ptr                        000100 automatic       pointer                  dcl 156 set ref 14* 17 18 19 123* 124 125
iocb_ptr_arg                           parameter       pointer                  dcl 156 ref 12 14 22 49 81 123
iox_$position                   000020 constant        entry                    external dcl 175 ref 87
iox_$read_record                000022 constant        entry                    external dcl 179 ref 132
length                          000112 automatic       fixed bin(21,0)          dcl 170 set ref 59* 61* 62 64
length_n                 32            based           fixed bin(21,0)          level 2 dcl 2-14 ref 136
line_len                        000111 automatic       fixed bin(21,0)          dcl 167 set ref 58* 59 61 69 100* 101 104 105
max_bufsize                     000010 internal static fixed bin(21,0)          initial dcl 3-6 set ref 58 100 132* 140 148
min                                                    builtin function         dcl 168 ref 31 62
n                               000113 automatic       fixed bin(21,0)          dcl 176 set ref 94* 95 106* 106
n_left                   50            based           fixed bin(21,0)          level 2 dcl 2-14 set ref 28 31 55 58 59 86* 96 100
                                                                                  105* 105 108* 132* 139* 139 140 150* 150
n_moved                         000110 automatic       fixed bin(21,0)          dcl 165 set ref 31* 33 35 41 42 62* 73 74 148 148
                                                                                  149 150
n_read                                 parameter       fixed bin(21,0)          dcl 158 set ref 22 49 119* 149* 149
newline                                constant        char(1)                  initial dcl 177 ref 58 100 140
open_data_ptr            22            based           pointer                  level 2 dcl 1-2 ref 125
position                 62            based           entry variable           level 2 dcl 1-2 set ref 19*
rs_attach_block                        based           structure                level 1 dcl 2-14
rs_buff_ptr                     000114 automatic       pointer                  dcl 3-3 set ref 58 100 125* 132* 140 148
rs_buffer                              based           char                     dcl 3-4 set ref 58 100 140* 148
rsab_ptr                        000106 automatic       pointer                  dcl 2-13 set ref 28 31 35 35 55 58 58 59 86 87 96
                                                                                  100 100 104 104 105 105 108 124* 132 132 135 136
                                                                                  139 139 140 148 150 150
substr                                                 builtin function         dcl 168 set ref 58 100 140* 148* 148
target_iocb_ptr          44            based           pointer                  level 2 dcl 2-14 set ref 87* 132*
type                                   parameter       fixed bin(17,0)          dcl 173 set ref 81 84 87*

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
error_table_$no_record                 external static fixed bin(35,0)          dcl 180

NAMES DECLARED BY EXPLICIT CONTEXT.
brief_init                      000327 constant        entry                    internal dcl 120 ref 83
exit                            000075 constant        label                    dcl 35 ref 67 69
get_chars_rs                    000040 constant        entry                    external dcl 22 ref 17
get_line_rs                     000114 constant        entry                    external dcl 49 ref 18
get_record                      000343 constant        entry                    internal dcl 130 ref 45 77 96
init_args                       000316 constant        entry                    internal dcl 115 ref 24 51
move                            000402 constant        entry                    internal dcl 146 ref 32 63
position_str_rs                 000215 constant        entry                    external dcl 81 ref 19
rs_open_str_in_                 000007 constant        entry                    external dcl 12

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       540         564     422         550
Length      1022     422        24         222     116           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rs_open_str_in_                     120 external procedure  is an external procedure.  
init_args                               internal procedure  shares stack frame of external procedure rs_open_str_in_.  
get_record                              internal procedure  shares stack frame of external procedure rs_open_str_in_.  
move                                    internal procedure  shares stack frame of external procedure rs_open_str_in_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 max_bufsize                 rs_open_str_in_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rs_open_str_in_          000100 iocb_ptr                    rs_open_str_in_
                         000102 buff_ptr                    rs_open_str_in_
                         000104 buff_len                    rs_open_str_in_
                         000106 rsab_ptr                    rs_open_str_in_
                         000110 n_moved                     rs_open_str_in_
                         000111 line_len                    rs_open_str_in_
                         000112 length                      rs_open_str_in_
                         000113 n                           rs_open_str_in_
                         000114 rs_buff_ptr                 rs_open_str_in_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
iox_$position                 iox_$read_record

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$long_record      error_table_$negative_nelem   error_table_$smallarg


CONSTANTS
000420  aa     077777000043
000421  aa     000001000000

000000  aa     404000000021

000001  aa     404000000043

000002  aa     404000000025

000003  aa     464000000000

BEGIN PROCEDURE rs_open_str_in_
ENTRY TO rs_open_str_in_                                    STATEMENT 1 ON LINE 12
rs_open_str_in_:
     proc (iocb_ptr_arg);

000004  at     000001000003
000005  ta     000004000000
000006  da     000066300000
000007  aa   000200 6270 00	eax7 	128
000010  aa  7 00034 3521 20	epp2 	pr7|28,*
000011  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000012  aa     000002000000
000013  aa     000000000000
						STATEMENT 1 ON LINE 14
	iocb_ptr = iocb_ptr_arg;

000014  aa  6 00032 3735 20	epp7 	pr6|26,*
000015  aa  7 00002 3715 20	epp5 	pr7|2,*		iocb_ptr_arg
000016  aa  5 00000 3715 20	epp5 	pr5|0,*		iocb_ptr_arg
000017  aa  6 00100 6515 00	spri5	pr6|64		iocb_ptr
						STATEMENT 1 ON LINE 17
	get_chars = get_chars_rs;

000020  aa   000020 3520 04	epp2 	16,ic		000040 = 000200627000
000021  aa  5 00046 2521 00	spri2	pr5|38		iocb.get_chars
000022  aa   000376 2370 04	ldaq 	254,ic		000420 = 077777000043 000001000000
000023  aa  5 00050 7571 00	staq 	pr5|40		iocb.get_chars
						STATEMENT 1 ON LINE 18
	get_line = get_line_rs;

000024  aa   000070 3520 04	epp2 	56,ic		000114 = 000200627000
000025  aa  5 00042 2521 00	spri2	pr5|34		iocb.get_line
000026  aa  5 00044 7571 00	staq 	pr5|36		iocb.get_line
						STATEMENT 1 ON LINE 19
	position = position_str_rs;

000027  aa   000166 3520 04	epp2 	118,ic		000215 = 000200627000
000030  aa  5 00062 2521 00	spri2	pr5|50		iocb.position
000031  aa  5 00064 7571 00	staq 	pr5|52		iocb.position
						STATEMENT 1 ON LINE 20
	return;

000032  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_chars_rs                                       STATEMENT 1 ON LINE 22
get_chars_rs:
     entry (iocb_ptr_arg, buff_ptr_arg, buff_len_arg, n_read, code);

000033  at     000005000003
000034  tt     000003000002
000035  tt     000002000001
000036  ta     000033000000
000037  da     000075300000
000040  aa   000200 6270 00	eax7 	128
000041  aa  7 00034 3521 20	epp2 	pr7|28,*
000042  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000043  aa     000012000000
000044  aa     000000000000
000045  aa  6 00032 3735 20	epp7 	pr6|26,*
000046  aa  7 00012 3715 20	epp5 	pr7|10,*
000047  aa  6 00116 6515 00	spri5	pr6|78
						STATEMENT 1 ON LINE 24
	call init_args;

000050  aa   000246 6700 04	tsp4 	166,ic		000316
						STATEMENT 1 ON LINE 25
	if buff_len < 0
	then code = error_table_$negative_nelem;

000051  aa  6 00104 2361 00	ldq  	pr6|68		buff_len
000052  aa   000004 6050 04	tpl  	4,ic		000056
000053  aa  6 00044 3701 20	epp4 	pr6|36,*
000054  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$negative_nelem
000055  aa  6 00116 7561 20	stq  	pr6|78,*		code
						STATEMENT 1 ON LINE 27
	do while ((buff_len > 0) & (code = 0));

000056  aa  6 00104 2361 00	ldq  	pr6|68		buff_len
000057  aa   000032 6044 04	tmoz 	26,ic		000111
000060  aa  6 00116 2361 20	ldq  	pr6|78,*		code
000061  aa   000030 6010 04	tnz  	24,ic		000111
						STATEMENT 1 ON LINE 28
	     if n_left > 0
	     then /* internal buffer is not empty */
		do;

000062  aa  6 00106 3735 20	epp7 	pr6|70,*		rsab_ptr
000063  aa  7 00050 2361 00	ldq  	pr7|40		rs_attach_block.n_left
000064  aa   000023 6044 04	tmoz 	19,ic		000107
						STATEMENT 1 ON LINE 31
		     n_moved = min (buff_len, n_left);

000065  aa  6 00104 1161 00	cmpq 	pr6|68		buff_len
000066  aa   000002 6040 04	tmi  	2,ic		000070
000067  aa  6 00104 2361 00	ldq  	pr6|68		buff_len
000070  aa  6 00110 7561 00	stq  	pr6|72		n_moved
						STATEMENT 1 ON LINE 32
		     call move;

000071  aa   000311 6700 04	tsp4 	201,ic		000402
						STATEMENT 1 ON LINE 33
		     if n_moved = buff_len
		     then do;

000072  aa  6 00110 2361 00	ldq  	pr6|72		n_moved
000073  aa  6 00104 1161 00	cmpq 	pr6|68		buff_len
000074  aa   000005 6010 04	tnz  	5,ic		000101
						STATEMENT 1 ON LINE 35
exit:
			     base = base + n_moved;

000075  aa  6 00110 2361 00	ldq  	pr6|72		n_moved
000076  aa  6 00106 3735 20	epp7 	pr6|70,*		rsab_ptr
000077  aa  7 00047 0561 00	asq  	pr7|39		rs_attach_block.base
						STATEMENT 1 ON LINE 37
			     return;

000100  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 38
			end;

						STATEMENT 1 ON LINE 39
		     else /* more characters to be moved */
			do;

						STATEMENT 1 ON LINE 41
			     buff_len = buff_len - n_moved;

000101  aa  6 00110 3361 00	lcq  	pr6|72		n_moved
000102  aa  6 00104 0561 00	asq  	pr6|68		buff_len
						STATEMENT 1 ON LINE 42
			     buff_ptr = addr (buff (n_moved + 1));

000103  aa  6 00110 2351 00	lda  	pr6|72		n_moved
000104  aa  6 00102 3521 20	epp2 	pr6|66,*		buff
000105  aa  2 00000 5005 05	a9bd 	pr2|0,al
000106  aa  6 00102 2521 00	spri2	pr6|66		buff_ptr
						STATEMENT 1 ON LINE 43
			end;

						STATEMENT 1 ON LINE 44
		end;

						STATEMENT 1 ON LINE 45
	     call get_record;

000107  aa   000234 6700 04	tsp4 	156,ic		000343
						STATEMENT 1 ON LINE 46
	end;

000110  aa   777746 7100 04	tra  	-26,ic		000056
						STATEMENT 1 ON LINE 47
	return;

000111  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_line_rs                                        STATEMENT 1 ON LINE 49
get_line_rs:
     entry (iocb_ptr_arg, buff_ptr_arg, buff_len_arg, n_read, code);

000112  ta     000033000000
000113  da     000103300000
000114  aa   000200 6270 00	eax7 	128
000115  aa  7 00034 3521 20	epp2 	pr7|28,*
000116  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000117  aa     000012000000
000120  aa     000000000000
000121  aa  6 00032 3735 20	epp7 	pr6|26,*
000122  aa  7 00012 3715 20	epp5 	pr7|10,*
000123  aa  6 00116 6515 00	spri5	pr6|78
						STATEMENT 1 ON LINE 51
	call init_args;

000124  aa   000172 6700 04	tsp4 	122,ic		000316
						STATEMENT 1 ON LINE 52
	if buff_len <= 0
	then code = error_table_$smallarg;

000125  aa  6 00104 2361 00	ldq  	pr6|68		buff_len
000126  aa   000004 6054 04	tpnz 	4,ic		000132
000127  aa  6 00044 3701 20	epp4 	pr6|36,*
000130  la  4 00014 2361 20	ldq  	pr4|12,*		error_table_$smallarg
000131  aa  6 00116 7561 20	stq  	pr6|78,*		code
						STATEMENT 1 ON LINE 54
	do while ((buff_len > 0) & (code = 0));

000132  aa  6 00104 2361 00	ldq  	pr6|68		buff_len
000133  aa   000054 6044 04	tmoz 	44,ic		000207
000134  aa  6 00116 2361 20	ldq  	pr6|78,*		code
000135  aa   000052 6010 04	tnz  	42,ic		000207
						STATEMENT 1 ON LINE 55
	     if n_left > 0
	     then /* internal buffer is not empty */
		do;

000136  aa  6 00106 3735 20	epp7 	pr6|70,*		rsab_ptr
000137  aa  7 00050 2361 00	ldq  	pr7|40		rs_attach_block.n_left
000140  aa   000045 6044 04	tmoz 	37,ic		000205
						STATEMENT 1 ON LINE 58
		     line_len = index (substr (rs_buffer, base, n_left), newline);

000141  aa  7 00047 2351 00	lda  	pr7|39		rs_attach_block.base
000142  aa  6 00114 3715 20	epp5 	pr6|76,*		rs_buff_ptr
000143  aa  000 003 124 545	scm  	(pr,rl,al),(du),mask(000)
000144  aa  5 77777 60 0006	desc9a	pr5|-1(3),ql	rs_buffer
000145  aa   012000 00 0001	desc9a	5120,1
000146  aa  6 00056 0001 00	arg  	pr6|46
000147  aa  6 00056 2361 00	ldq  	pr6|46
000150  aa   000002 6070 04	ttf  	2,ic		000152
000151  aa   000001 3360 07	lcq  	1,dl
000152  aa   000001 0760 07	adq  	1,dl
000153  aa  6 00111 7561 00	stq  	pr6|73		line_len
						STATEMENT 1 ON LINE 59
		     if line_len = 0
		     then length = n_left;

000154  aa   000004 6010 04	tnz  	4,ic		000160
000155  aa  7 00050 2361 00	ldq  	pr7|40		rs_attach_block.n_left
000156  aa  6 00112 7561 00	stq  	pr6|74		length
000157  aa   000002 7100 04	tra  	2,ic		000161
						STATEMENT 1 ON LINE 61
		     else length = line_len;

000160  aa  6 00112 7561 00	stq  	pr6|74		length
						STATEMENT 1 ON LINE 62
		     n_moved = min (length, buff_len);

000161  aa  6 00104 1161 00	cmpq 	pr6|68		buff_len
000162  aa   000002 6040 04	tmi  	2,ic		000164
000163  aa  6 00104 2361 00	ldq  	pr6|68		buff_len
000164  aa  6 00110 7561 00	stq  	pr6|72		n_moved
						STATEMENT 1 ON LINE 63
		     call move;

000165  aa   000215 6700 04	tsp4 	141,ic		000402
						STATEMENT 1 ON LINE 64
		     if length > buff_len
		     then do;

000166  aa  6 00112 2361 00	ldq  	pr6|74		length
000167  aa  6 00104 1161 00	cmpq 	pr6|68		buff_len
000170  aa   000005 6044 04	tmoz 	5,ic		000175
						STATEMENT 1 ON LINE 66
			     code = error_table_$long_record;

000171  aa  6 00044 3701 20	epp4 	pr6|36,*
000172  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$long_record
000173  aa  6 00116 7561 20	stq  	pr6|78,*		code
						STATEMENT 1 ON LINE 67
			     go to exit;

000174  aa   777701 7100 04	tra  	-63,ic		000075
						STATEMENT 1 ON LINE 68
			end;

						STATEMENT 1 ON LINE 69
		     else if line_len > 0		/* newline has been found */
		     then go to exit;

000175  aa  6 00111 2361 00	ldq  	pr6|73		line_len
000176  aa   777677 6054 04	tpnz 	-65,ic		000075
						STATEMENT 1 ON LINE 71
		     else /* keep looking for end of line */
			do;

						STATEMENT 1 ON LINE 73
			     buff_len = buff_len - n_moved;

000177  aa  6 00110 3361 00	lcq  	pr6|72		n_moved
000200  aa  6 00104 0561 00	asq  	pr6|68		buff_len
						STATEMENT 1 ON LINE 74
			     buff_ptr = addr (buff (n_moved + 1));

000201  aa  6 00110 2351 00	lda  	pr6|72		n_moved
000202  aa  6 00102 3521 20	epp2 	pr6|66,*		buff
000203  aa  2 00000 5005 05	a9bd 	pr2|0,al
000204  aa  6 00102 2521 00	spri2	pr6|66		buff_ptr
						STATEMENT 1 ON LINE 75
			end;

						STATEMENT 1 ON LINE 76
		end;

						STATEMENT 1 ON LINE 77
	     call get_record;

000205  aa   000136 6700 04	tsp4 	94,ic		000343
						STATEMENT 1 ON LINE 78
	end;

000206  aa   777724 7100 04	tra  	-44,ic		000132
						STATEMENT 1 ON LINE 79
	return;

000207  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO position_str_rs                                    STATEMENT 1 ON LINE 81
position_str_rs:
     entry (iocb_ptr_arg, type, count, code);

000210  at     000004000003
000211  tt     000000000002
000212  ta     000001000000
000213  ta     000210000000
000214  da     000112300000
000215  aa   000200 6270 00	eax7 	128
000216  aa  7 00034 3521 20	epp2 	pr7|28,*
000217  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000220  aa     000010000000
000221  aa     000000000000
000222  aa  6 00032 3735 20	epp7 	pr6|26,*
000223  aa  7 00010 3715 20	epp5 	pr7|8,*
000224  aa  6 00116 6515 00	spri5	pr6|78
						STATEMENT 1 ON LINE 83
	call brief_init;

000225  aa   000102 6700 04	tsp4 	66,ic		000327
						STATEMENT 1 ON LINE 84
	if type ^= 0
	then do;

000226  aa  6 00032 3735 20	epp7 	pr6|26,*
000227  aa  7 00004 2361 20	ldq  	pr7|4,*		type
000230  aa   000021 6000 04	tze  	17,ic		000251
						STATEMENT 1 ON LINE 86
		n_left = 0;

000231  aa  6 00106 3715 20	epp5 	pr6|70,*		rsab_ptr
000232  aa  5 00050 4501 00	stz  	pr5|40		rs_attach_block.n_left
						STATEMENT 1 ON LINE 87
		call iox_$position (target_iocb_ptr, type, count, code);

000233  aa  5 00044 3521 00	epp2 	pr5|36		rs_attach_block.target_iocb_ptr
000234  aa  6 00144 2521 00	spri2	pr6|100
000235  aa  7 00004 3521 20	epp2 	pr7|4,*		type
000236  aa  6 00146 2521 00	spri2	pr6|102
000237  aa  7 00006 3521 20	epp2 	pr7|6,*		count
000240  aa  6 00150 2521 00	spri2	pr6|104
000241  aa  6 00116 3521 20	epp2 	pr6|78,*		code
000242  aa  6 00152 2521 00	spri2	pr6|106
000243  aa  6 00142 6211 00	eax1 	pr6|98
000244  aa   020000 4310 07	fld  	8192,dl
000245  aa  6 00044 3701 20	epp4 	pr6|36,*
000246  la  4 00020 3521 20	epp2 	pr4|16,*		iox_$position
000247  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 89
	     end;

000250  aa   000045 7100 04	tra  	37,ic		000315
						STATEMENT 1 ON LINE 90
	else /* skip case */
	     do;

						STATEMENT 1 ON LINE 92
		if count < 0			/* no backward skips permitted */
		then code = error_table_$negative_nelem;

000251  aa  7 00006 2361 20	ldq  	pr7|6,*		count
000252  aa   000004 6050 04	tpl  	4,ic		000256
000253  aa  6 00044 3701 20	epp4 	pr6|36,*
000254  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$negative_nelem
000255  aa  6 00116 7561 20	stq  	pr6|78,*		code
						STATEMENT 1 ON LINE 94
		n = count;

000256  aa  7 00006 2361 20	ldq  	pr7|6,*		count
000257  aa  6 00113 7561 00	stq  	pr6|75		n
						STATEMENT 1 ON LINE 95
		do while ((n > 0) & (code = 0));

000260  aa  6 00113 2361 00	ldq  	pr6|75		n
000261  aa   000034 6044 04	tmoz 	28,ic		000315
000262  aa  6 00116 2361 20	ldq  	pr6|78,*		code
000263  aa   000032 6010 04	tnz  	26,ic		000315
						STATEMENT 1 ON LINE 96
		     if n_left <= 0
		     then call get_record;

000264  aa  6 00106 3735 20	epp7 	pr6|70,*		rsab_ptr
000265  aa  7 00050 2361 00	ldq  	pr7|40		rs_attach_block.n_left
000266  aa   000003 6054 04	tpnz 	3,ic		000271
000267  aa   000054 6700 04	tsp4 	44,ic		000343
000270  aa   777770 7100 04	tra  	-8,ic		000260
						STATEMENT 1 ON LINE 98
		     else /* internal buffer is not empty */
			do;

						STATEMENT 1 ON LINE 100
			     line_len = index (substr (rs_buffer, base, n_left), newline);

000271  aa  7 00047 2351 00	lda  	pr7|39		rs_attach_block.base
000272  aa  6 00114 3715 20	epp5 	pr6|76,*		rs_buff_ptr
000273  aa  000 003 124 545	scm  	(pr,rl,al),(du),mask(000)
000274  aa  5 77777 60 0006	desc9a	pr5|-1(3),ql	rs_buffer
000275  aa   012000 00 0001	desc9a	5120,1
000276  aa  6 00056 0001 00	arg  	pr6|46
000277  aa  6 00056 2361 00	ldq  	pr6|46
000300  aa   000002 6070 04	ttf  	2,ic		000302
000301  aa   000001 3360 07	lcq  	1,dl
000302  aa   000001 0760 07	adq  	1,dl
000303  aa  6 00111 7561 00	stq  	pr6|73		line_len
						STATEMENT 1 ON LINE 101
			     if line_len > 0
			     then /* newline found */
				do;

000304  aa   000007 6044 04	tmoz 	7,ic		000313
						STATEMENT 1 ON LINE 104
				     base = base + line_len;

000305  aa  7 00047 0561 00	asq  	pr7|39		rs_attach_block.base
						STATEMENT 1 ON LINE 105
				     n_left = n_left - line_len;

000306  aa  6 00111 3361 00	lcq  	pr6|73		line_len
000307  aa  7 00050 0561 00	asq  	pr7|40		rs_attach_block.n_left
						STATEMENT 1 ON LINE 106
				     n = n - 1;

000310  aa   000001 3360 07	lcq  	1,dl
000311  aa  6 00113 0561 00	asq  	pr6|75		n
						STATEMENT 1 ON LINE 107
				end;

000312  aa   777746 7100 04	tra  	-26,ic		000260
						STATEMENT 1 ON LINE 108
			     else n_left = 0;

000313  aa  7 00050 4501 00	stz  	pr7|40		rs_attach_block.n_left
						STATEMENT 1 ON LINE 109
			end;

						STATEMENT 1 ON LINE 110
		end;

000314  aa   777744 7100 04	tra  	-28,ic		000260
						STATEMENT 1 ON LINE 111
	     end;

						STATEMENT 1 ON LINE 112
	return;

000315  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 185
     end rs_open_str_in_;

BEGIN PROCEDURE init_args
ENTRY TO init_args                                          STATEMENT 1 ON LINE 115
init_args:
     proc;

000316  aa  6 00120 6501 00	spri4	pr6|80
						STATEMENT 1 ON LINE 117
	buff_len = buff_len_arg;

000317  aa  6 00032 3735 20	epp7 	pr6|26,*
000320  aa  7 00006 2361 20	ldq  	pr7|6,*		buff_len_arg
000321  aa  6 00104 7561 00	stq  	pr6|68		buff_len
						STATEMENT 1 ON LINE 118
	buff_ptr = buff_ptr_arg;

000322  aa  7 00004 3715 20	epp5 	pr7|4,*		buff_ptr_arg
000323  aa  5 00000 3715 20	epp5 	pr5|0,*		buff_ptr_arg
000324  aa  6 00102 6515 00	spri5	pr6|66		buff_ptr
						STATEMENT 1 ON LINE 119
	n_read = 0;

000325  aa  7 00010 4501 20	stz  	pr7|8,*		n_read
						STATEMENT 1 ON LINE 120
brief_init:
     entry;

000326  aa   000002 7100 04	tra  	2,ic		000330
ENTRY TO brief_init                                         STATEMENT 1 ON LINE 120
brief_init:
     entry;

000327  aa  6 00120 6501 00	spri4	pr6|80
						STATEMENT 1 ON LINE 122
	code = 0;

000330  aa  6 00116 4501 20	stz  	pr6|78,*		code
						STATEMENT 1 ON LINE 123
	iocb_ptr = iocb_ptr_arg -> actual_iocb_ptr;

000331  aa  6 00032 3735 20	epp7 	pr6|26,*
000332  aa  7 00002 3715 20	epp5 	pr7|2,*		iocb_ptr_arg
000333  aa  5 00000 3715 20	epp5 	pr5|0,*		iocb_ptr_arg
000334  aa  5 00012 3535 20	epp3 	pr5|10,*		iocb.actual_iocb_ptr
000335  aa  6 00100 2535 00	spri3	pr6|64		iocb_ptr
						STATEMENT 1 ON LINE 124
	rsab_ptr = attach_data_ptr;

000336  aa  3 00016 3515 20	epp1 	pr3|14,*		iocb.attach_data_ptr
000337  aa  6 00106 2515 00	spri1	pr6|70		rsab_ptr
						STATEMENT 1 ON LINE 125
	rs_buff_ptr = open_data_ptr;

000340  aa  3 00022 3715 20	epp5 	pr3|18,*		iocb.open_data_ptr
000341  aa  6 00114 6515 00	spri5	pr6|76		rs_buff_ptr
						STATEMENT 1 ON LINE 126
	return;

000342  aa  6 00120 6101 00	rtcd 	pr6|80
						STATEMENT 1 ON LINE 128
     end init_args;

  END PROCEDURE init_args
BEGIN PROCEDURE get_record
ENTRY TO get_record                                         STATEMENT 1 ON LINE 130
get_record:
     proc;

000343  aa  6 00126 6501 00	spri4	pr6|86
						STATEMENT 1 ON LINE 132
	call iox_$read_record (target_iocb_ptr, rs_buff_ptr, max_bufsize, n_left, code);

000344  aa  6 00106 3735 20	epp7 	pr6|70,*		rsab_ptr
000345  aa  7 00044 3521 00	epp2 	pr7|36		rs_attach_block.target_iocb_ptr
000346  aa  6 00156 2521 00	spri2	pr6|110
000347  aa  6 00114 3521 00	epp2 	pr6|76		rs_buff_ptr
000350  aa  6 00160 2521 00	spri2	pr6|112
000351  aa  6 00044 3701 20	epp4 	pr6|36,*
000352  ia  4 00010 3521 00	epp2 	pr4|8		max_bufsize
000353  aa  6 00162 2521 00	spri2	pr6|114
000354  aa  7 00050 3521 00	epp2 	pr7|40		rs_attach_block.n_left
000355  aa  6 00164 2521 00	spri2	pr6|116
000356  aa  6 00116 3521 20	epp2 	pr6|78,*		code
000357  aa  6 00166 2521 00	spri2	pr6|118
000360  aa  6 00154 6211 00	eax1 	pr6|108
000361  aa   024000 4310 07	fld  	10240,dl
000362  la  4 00022 3521 20	epp2 	pr4|18,*		iox_$read_record
000363  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 133
	if code = 0
	then do;

000364  aa  6 00116 2361 20	ldq  	pr6|78,*		code
000365  aa   000014 6010 04	tnz  	12,ic		000401
						STATEMENT 1 ON LINE 135
		base = 1;

000366  aa   000001 2360 07	ldq  	1,dl
000367  aa  6 00106 3735 20	epp7 	pr6|70,*		rsab_ptr
000370  aa  7 00047 7561 00	stq  	pr7|39		rs_attach_block.base
						STATEMENT 1 ON LINE 136
		if length_n = 0
		then /* default attachment */
		     do;

000371  aa  7 00032 2361 00	ldq  	pr7|26		rs_attach_block.length_n
000372  aa   000007 6010 04	tnz  	7,ic		000401
						STATEMENT 1 ON LINE 139
			n_left = n_left + 1;

000373  aa  7 00050 0541 00	aos  	pr7|40		rs_attach_block.n_left
						STATEMENT 1 ON LINE 140
			substr (rs_buffer, n_left, 1) = newline;

000374  aa  7 00050 2351 00	lda  	pr7|40		rs_attach_block.n_left
000375  aa  6 00114 3715 20	epp5 	pr6|76,*		rs_buff_ptr
000376  aa  012 105 100 400	mlr  	(),(pr,al),fill(012)
000377  aa   000000 00 0000	desc9a	0,0
000400  aa  5 77777 60 0001	desc9a	pr5|-1(3),1	rs_buffer
						STATEMENT 1 ON LINE 141
		     end;

						STATEMENT 1 ON LINE 142
	     end;

						STATEMENT 1 ON LINE 143
	return;

000401  aa  6 00126 6101 00	rtcd 	pr6|86
						STATEMENT 1 ON LINE 144
     end get_record;

  END PROCEDURE get_record
BEGIN PROCEDURE move
ENTRY TO move                                               STATEMENT 1 ON LINE 146
move:
     proc;

000402  aa  6 00134 6501 00	spri4	pr6|92
						STATEMENT 1 ON LINE 148
	substr (buffer, 1, n_moved) = substr (rs_buffer, base, n_moved);

000403  aa  6 00102 3735 20	epp7 	pr6|66,*		buff_ptr
000404  aa  6 00106 3715 20	epp5 	pr6|70,*		rsab_ptr
000405  aa  5 00047 2351 00	lda  	pr5|39		rs_attach_block.base
000406  aa  6 00114 3535 20	epp3 	pr6|76,*		rs_buff_ptr
000407  aa  6 00110 2361 00	ldq  	pr6|72		n_moved
000410  aa  040 140 100 545	mlr  	(pr,rl,al),(pr,rl),fill(040)
000411  aa  3 77777 60 0006	desc9a	pr3|-1(3),ql	rs_buffer
000412  aa  7 00000 00 0006	desc9a	pr7|0,ql		buffer
						STATEMENT 1 ON LINE 149
	n_read = n_read + n_moved;

000413  aa  6 00032 3515 20	epp1 	pr6|26,*
000414  aa  1 00010 0561 20	asq  	pr1|8,*		n_read
						STATEMENT 1 ON LINE 150
	n_left = n_left - n_moved;

000415  aa  6 00110 3361 00	lcq  	pr6|72		n_moved
000416  aa  5 00050 0561 00	asq  	pr5|40		rs_attach_block.n_left
						STATEMENT 1 ON LINE 151
	return;

000417  aa  6 00134 6101 00	rtcd 	pr6|92
						STATEMENT 1 ON LINE 153
     end move;

  END PROCEDURE move
  END PROCEDURE rs_open_str_in_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
