	COMPILATION LISTING OF SEGMENT ms_salvager_v4_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/09/85  1116.5 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 ms_salvager_v4_: proc (a_mptr, a_code);
       12 
       13 /* Modified for version 3 message segments by J. Stern, 10/30/74 */
       14 /* Modified to use mseg_error_ by J. Stern, 11/12/75 */
       15 
       16 dcl (
       17      mseg_dir,					/* mseg directory name */
       18      comp1)					/* 1st component of directory name */
       19      char (168);
       20 
       21 dcl (
       22      mseg_name,					/* mseg entryname */
       23      comp2)					/* 2nd component of directory name */
       24      char (32);
       25 
       26 dcl (
       27      i,						/* do loop index */
       28      dir_len,					/* length of mseg directory */
       29      saved_blocks init (0),				/* number of saved message blocks */
       30      saved_messages init (0),				/* number of saved messages (internal) */
       31      original_messages,				/* number of messages before salvaging */
       32      tsaved_blocks,					/* number of saved blocks per pass */
       33      tsaved_messages)				/* number of saved messages per pass */
       34      fixed bin;
       35 
       36 dcl (alloc_len,					/* length of allocation bit string */
       37      block_offset,					/* offset to a message block */
       38      block_size,					/* size of message block */
       39      hdr_alloc_len,					/* number of allocation bits used for header */
       40      mseg_data_v4_$block_size ext,
       41      seg_size,					/* maximum size of a segment */
       42      hdr_size,					/* number of words in header before alloc_bits */
       43      trailer_offset) fixed bin (18);
       44 
       45 dcl (
       46      a_code,					/* error code (argument) */
       47      code,					/* error code, (internal) */
       48      error_table_$fatal_error ext
       49      ) fixed bin (35);
       50 
       51 dcl  reason char (40);				/* reason for salvager failure */
       52 
       53 dcl  forward bit (1) aligned;				/* ON if salvage is forward */
       54 
       55 dcl (addr, addrel, bit, divide, fixed, null, ptr, rel, size, substr) builtin;
       56 
       57 dcl (a_mptr,					/* pointer to message segment (argument) */
       58      end_ptr,					/* pointer to last message for salvage pass */
       59      last_backward_ptr init (null),			/* pointer to last saved message in backward salvage */
       60      last_forward_ptr init (null),			/* pointer to last saved message in forward salvage */
       61      last_saved_ms_ptr,				/* pointer to last message saved in a pass */
       62      salv_ptr)					/* pointer to beginning point for salvage */
       63      ptr;
       64 
       65 dcl  mseg_access_class bit (72) aligned;		/* message segment access class */
       66 
       67 dcl  hdr_ms_mask bit (36*max_hdr_ms_len) aligned based;	/* for zeroing out header message */
       68 
       69 dcl  ring_brackets (3) fixed bin(3) init(1,4,4);		/* for setting ring brackets of copy */
       70 
       71 dcl 1 new_hash_table aligned,				/* hash table regenerated by salvage */
       72     2 last_in_bucket (0:511) bit (18) unaligned init ((512) (18) "0"b);
       73 
       74 /*  */
       75 
  1     1 /* BEGIN include file mseg_hdr_v4.incl.pl1 */
  1     2 
  1     3 declare
  1     4      1 mseg_hdr_v4 aligned based,         		/* message segment header format */
  1     5      2 lock bit (36) aligned,				/* standard file system lock */
  1     6      2 mseg_pattern bit (36) aligned,			/* to identify message segments */
  1     7      2 hdr_ms_access_class bit (72) aligned,		/* access class of header message */
  1     8    2 date_time_last_salvaged fixed bin (71),		/* time message segment was last salvaged */
  1     9      2 pad (2) fixed bin,
  1    10      2 first_ms_offset bit (18) aligned,		/* offset to first logical message */
  1    11      2 last_ms_offset bit (18) aligned,			/* offset to last logical message */
  1    12      2 alloc_len fixed bin,				/* length of allocation bit string */
  1    13      2 space_left fixed bin,				/* number of empty blocks */
  1    14      2 number_of_messages fixed bin,			/* number of messages in segment */
  1    15      2 block_size fixed bin,				/* message block size */
  1    16      2 switches,
  1    17      3 mip bit (1) unaligned,				/* ON if modification is in progress */
  1    18      3 os bit (1) unaligned,				/* ON if message segment was salvaged */
  1    19      3 ms_in_hdr bit (1) unaligned,			/* ON if there is a message in the header */
  1    20      3 sip bit (1) unaligned,				/* ON if salvage is in progress */
  1    21      3 pad2 bit (32) unaligned,
  1    22      2 version_number fixed bin,
  1    23      2 hdr_ms bit (64 * 36) aligned,			/* space for header message */
  1    24      2 hash_table aligned,				/* message ID hash table */
  1    25      3 last_in_bucket (0:511) bit (18) unaligned,		/* offset of last message in this hash table bucket */
  1    26      2 alloc_bits bit (0 refer (mseg_hdr_v4.alloc_len)) aligned;/* allocation bit string */
  1    27 
  1    28 /* END include file mseg_hdr.incl.pl1 */
       76 
       77 declare version_number fixed bin init (4) int static options (constant);
       78 dcl      header_pattern bit (36) aligned init ((18) "01"b);	/* header identification pattern */
       79  declare mptr pointer;
  2     1 /* BEGIN include file ms_block_trailer.incl.pl1 */
  2     2 
  2     3 dcl  tr_ptr ptr,					/* pointer to message block trailer area */
  2     4 
  2     5      1 ms_block_trailer aligned based (tr_ptr),		/* message block trailer structure */
  2     6      2 tr_pattern bit (36) aligned,			/* for identifying beginning of trailer */
  2     7      2 f_offset bit (18) unaligned,			/* offset to next logical message */
  2     8      2 b_offset bit (18) unaligned,			/* offset to previous logical message */
  2     9      2 ring_no bit (18) unaligned,			/* validation level */
  2    10      2 back_in_bucket bit (18) unaligned,		/* offset of preceding message in same hash bucket */
  2    11      2 ms_id bit (72) aligned,			/* message id */
  2    12      2 ms_size bit (24) unaligned,			/* bit count of message */
  2    13      2 pad bit (12) unaligned,
  2    14      2 sender_id char (32) aligned,			/* id of message sender */
  2    15      2 sender_authorization bit (72) aligned,		/* access authorization of message sender */
  2    16      2 access_class bit (72) aligned;			/* access class of this message */
  2    17 
  2    18 dcl  trailer_pattern bit (36) aligned init ((36) "1"b)	/* trailer identification pattern */
  2    19      internal static;
  2    20 
  2    21 /* END include file ms_block_trailer.incl.pl1 */
       80 
       81 
       82 
       83 dcl  admin_gate_$guaranteed_eligibility_on ext entry;
       84 
       85 dcl  expand_path_ ext entry
       86     (ptr, fixed bin, ptr, ptr, fixed bin (35));
       87 
       88 dcl  copy_seg_$no_message entry
       89     (char(*), char(*), char(*), char(*), char(*), bit(1) aligned, fixed bin(35));
       90 
       91 dcl  hcs_$get_max_length_seg entry (ptr, fixed bin (18), fixed bin (35));
       92 
       93 dcl  hcs_$set_ring_brackets ext entry
       94     (char (*), char (*), (3) fixed bin (3), fixed bin (35));
       95 
       96 dcl  hcs_$truncate_seg ext entry
       97     (ptr, fixed bin (18), fixed bin (35));
       98 
       99 dcl  read_allowed_ entry
      100     (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      101 
      102 dcl  hcs_$fs_get_path_name entry
      103     (ptr, char(*), fixed bin, char(*), fixed bin(35));
      104 
      105 dcl  hcs_$get_access_class_seg ext entry
      106     (ptr, bit (72) aligned, fixed bin (35));
      107 
      108 dcl  ms_salv_util_v4_ ext entry
      109     (bit (1) aligned, ptr, ptr, ptr, fixed bin (18), fixed bin (18), fixed bin (18), fixed bin (18),
      110      bit (72) aligned, fixed bin, fixed bin, ptr);
      111 
      112 dcl  mseg_error_v4_ entry options (variable);
      113 
      114 dcl  set_lock_$lock ext entry
      115     (bit (36)aligned, fixed bin, fixed bin (35));
      116 
      117 /*  */
      118 
      119 	mptr = a_mptr;				/* copy argument */
      120 
      121 	call admin_gate_$guaranteed_eligibility_on ();	/* lock the message segment in case */
      122 	call set_lock_$lock (mptr -> mseg_hdr_v4.lock, 20, code);	/* it is not already locked */
      123 
      124 	call hcs_$get_access_class_seg (mptr, mseg_access_class, code);
      125 	if code ^= 0 then do;
      126 	     reason = "Cannot get access class.";
      127 	     go to GRIPE;
      128 	end;
      129 
      130 	call hcs_$get_max_length_seg (mptr, seg_size, code);
      131 	if code ^= 0 then do;
      132 	     reason = "Cannot get max length.";
      133 	     go to GRIPE;
      134 	end;
      135 
      136 	mptr -> mseg_hdr_v4.switches.sip = "1"b;			/* turn on "salvage in progress" flag */
      137 
      138 	block_size = fixed (mptr -> mseg_hdr_v4.block_size, 18);	/* fetch block size */
      139 	if block_size <= 0 | block_size > seg_size
      140 	then block_size = fixed (mseg_data_v4_$block_size, 18); /* take default and hope it's right */
      141 
      142 	alloc_len = divide (seg_size, block_size, 18, 0); /* compute length of allocation bits */
      143 
      144 	hdr_size = divide ((fixed (rel (addr (mptr -> mseg_hdr_v4.alloc_bits)), 18))*36 + alloc_len+35, 36, 18, 0);
      145 
      146 	if hdr_size > seg_size then do;		/* forget it */
      147 	     code = error_table_$fatal_error;
      148 	     go to FIN;
      149 	end;
      150 
      151 	hdr_alloc_len = divide (hdr_size+block_size-1, block_size, 18, 0); /* compute alloc bits used by header */
      152 
      153 	trailer_offset = fixed (block_size-size (ms_block_trailer), 18); /* compute trailer offset */
      154 
      155 	original_messages = mptr -> mseg_hdr_v4.number_of_messages;
      156 
      157 /*  */
      158 
      159 	begin;
      160 
      161 dcl  new_alloc_bits bit (alloc_len) init (""b) aligned;	/* new allocation bit string */
      162 
      163 	     do i = 1 to hdr_alloc_len;		/* turn on header allocation bits */
      164 		substr (new_alloc_bits, i, 1) = "1"b;
      165 	     end;
      166 
      167 	     if mptr -> mseg_hdr_v4.first_ms_offset ^= ""b		/* non-zero first message offset */
      168 	     then do;				/* set up for forward salvage */
      169 		salv_ptr = ptr (mptr, fixed (mptr -> mseg_hdr_v4.first_ms_offset, 18));
      170 		end_ptr = ptr (mptr, fixed (mptr -> mseg_hdr_v4.last_ms_offset, 18));
      171 		forward = "1"b;			/* first attempt forward salvage */
      172 	     end;
      173 	     else go to BACKWARD;			/* try backward salvage */
      174 
      175 /* salvage */
      176 
      177 SALVAGE_LOOP:
      178 
      179 	     tsaved_messages = 0;			/* initialize number of saved messages per pass */
      180 	     last_saved_ms_ptr = null;		/* initialize pointer to last saved message */
      181 	     call ms_salv_util_v4_
      182 		(forward, salv_ptr, addr (new_alloc_bits), addr (new_hash_table),
      183 		block_size, seg_size, alloc_len, hdr_alloc_len, mseg_access_class,
      184 		tsaved_messages, tsaved_blocks, last_saved_ms_ptr);
      185 	     saved_messages =			/* add in number of saved messages */
      186 		saved_messages + tsaved_messages;
      187 	     saved_blocks =				/* add in number of saved blocks */
      188 		saved_blocks + tsaved_blocks;
      189 	     if last_saved_ms_ptr = end_ptr		/* total success? */
      190 	     then go to REST_OF_HEADER;
      191 
      192 	     if tsaved_messages ^= 0			/* partial success? */
      193 	     then do;				/* yes */
      194 
      195 		if (forward)			/* forward salvage? */
      196 		then last_forward_ptr =		/* yes, save pointer to last good message */
      197 		     last_saved_ms_ptr;
      198 
      199 		else				/* backward salvage */
      200 		last_backward_ptr =			/* save pointer to last good message */
      201 		     last_saved_ms_ptr;
      202 
      203 	     end;
      204 
      205 	     if (forward)				/* first pass at salvaging? */
      206 	     then
      207 BACKWARD:		if mptr -> mseg_hdr_v4.last_ms_offset ^= ""b	/* non-zero last message offset */
      208 		then do;				/* yes, prepare for next pass */
      209 		     forward = "0"b;		/* set direction of salvage */
      210 		     salv_ptr = ptr (mptr, fixed (mptr -> mseg_hdr_v4.last_ms_offset, 18)); /* set salvaging pointer */
      211 		     end_ptr = ptr (mptr, fixed (mptr -> mseg_hdr_v4.first_ms_offset, 18)); /* set hopeful end of salvage ptr */
      212 		     go to SALVAGE_LOOP;
      213 		end;
      214 
      215 /*  */
      216 
      217 /* join message fragments */
      218 
      219 	     if saved_messages ^= 0			/* any success in salvaging? */
      220 	     then do;				/* yes */
      221 
      222 		if last_forward_ptr ^= null		/* forward salvage partly successful */
      223 		then do;				/* yes */
      224 
      225 		     if last_backward_ptr ^= null	/* backward salvage partly successful? */
      226 		     then do;			/* yes */
      227 			addrel (last_forward_ptr, trailer_offset) -> ms_block_trailer.f_offset =
      228 			     bit (fixed (rel (last_backward_ptr), 18), 18);
      229 			addrel (last_backward_ptr, trailer_offset) -> ms_block_trailer.b_offset =
      230 			     bit (fixed (rel (last_forward_ptr), 18), 18);
      231 		     end;
      232 
      233 		     else				/* backward salvage unsuccessful */
      234 		     do;
      235 			mptr -> mseg_hdr_v4.last_ms_offset =	/* reset last message offset in header */
      236 			     bit (fixed (rel (last_forward_ptr), 18), 18);
      237 			addrel (last_forward_ptr, trailer_offset) -> ms_block_trailer.f_offset =
      238 			     "0"b;		/* zero out next offset of new last message */
      239 		     end;
      240 
      241 		end;
      242 
      243 		else				/* forward salvage no good */
      244 		do;				/* backward salvage must have been */
      245 		     mptr -> mseg_hdr_v4.first_ms_offset =	/* reset first message offset */
      246 			bit (fixed (rel (last_backward_ptr), 18), 18);
      247 		     addrel (last_backward_ptr, trailer_offset) -> ms_block_trailer.b_offset =
      248 			"0"b;			/* zero prev message offset of new 1st message */
      249 		end;
      250 
      251 	     end;
      252 
      253 	     else					/* no messages saved */
      254 	     mptr -> mseg_hdr_v4.first_ms_offset,
      255 		mptr -> mseg_hdr_v4.last_ms_offset = (18) "0"b;	/* zero first and last offsets */
      256 
      257 REST_OF_HEADER:
      258 
      259 	     i = alloc_len - index (reverse (new_alloc_bits), "1"b) +1; /* get last used block index */
      260 	     block_offset = i * block_size;		/* get offset of end of last block */
      261 	     call hcs_$truncate_seg (mptr, block_offset, code); /* truncate to last used block */
      262 	     mptr -> mseg_hdr_v4.block_size = block_size;		/* reset block size */
      263 	     mptr -> mseg_hdr_v4.space_left =			/* reset space left */
      264 		alloc_len - hdr_alloc_len - saved_blocks;
      265 	     mptr -> mseg_hdr_v4.alloc_bits = new_alloc_bits;	/* reset allocation bit string */
      266 	     mptr -> mseg_hdr_v4.number_of_messages = saved_messages; /* set message count */
      267 	     mptr -> mseg_hdr_v4.alloc_len = alloc_len;		/* set allocation bits length */
      268 	     mptr -> mseg_hdr_v4.mseg_pattern = header_pattern;	/* set header pattern */
      269 	     mptr -> mseg_hdr_v4.version_number = version_number;	/* set version number */
      270 	     mptr -> mseg_hdr_v4.hash_table = new_hash_table;	/* copy new hash table */
      271 
      272 	     if mptr -> mseg_hdr_v4.switches.ms_in_hdr		/* header message exists */
      273 	     then if ^read_allowed_ (mseg_access_class, mptr -> mseg_hdr_v4.hdr_ms_access_class) /* bad access class */
      274 		then do;				/* wipe out header message */
      275 		     mptr -> mseg_hdr_v4.switches.ms_in_hdr = "0"b;
      276 ZERO_HDR_MS:	     mptr -> mseg_hdr_v4.hdr_ms = ""b;
      277 		     mptr -> mseg_hdr_v4.hdr_ms_access_class = (72) "0"b;
      278 		end;
      279 		else;				/* keep header message */
      280 	     else go to ZERO_HDR_MS;			/* just to be neat */
      281 
      282 	     mptr -> mseg_hdr_v4.switches.mip = "0"b;		/* turn off mip bit */
      283 	     mptr -> mseg_hdr_v4.switches.os = "1"b;		/* indicate salvage occurred */
      284 	     mptr -> mseg_hdr_v4.switches.sip = "0"b;		/* turn off salvage in progress bit */
      285 
      286 	end;					/* of BEGIN block */
      287 
      288 	if original_messages > saved_messages then
      289 	     call mseg_error_v4_ (mptr, 0, "ms_salvager_v4_", "^d message(s) may be lost.",
      290 	     original_messages - saved_messages);
      291 
      292 FIN:
      293 
      294 	a_code = code;				/* return code */
      295 	return;
      296 
      297 GRIPE:	call mseg_error_v4_ (mptr, code, "ms_salvager_v4_", reason);
      298 	go to FIN;
      299 
      300      end ms_salvager_v4_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/06/85  1619.0  ms_salvager_v4_.pl1               >spec>on>mseg>ms_salvager_v4_.pl1
76           1    05/06/85  1121.9  mseg_hdr_v4.incl.pl1              >spec>on>mseg>mseg_hdr_v4.incl.pl1
80           2    05/06/85  1121.7  ms_block_trailer_v4.incl.pl1      >spec>on>mseg>ms_block_trailer_v4.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_code                                 parameter       fixed bin(35,0)          dcl 45 set ref 11 292*
a_mptr                                 parameter       pointer                  dcl 57 ref 11 119
addr                                                   builtin function         dcl 55 ref 144 181 181 181 181
addrel                                                 builtin function         dcl 55 ref 227 229 237 247
admin_gate_$guaranteed_eligibility_on
                                000014 constant        entry                    external dcl 83 ref 121
alloc_bits              520            based           bit                      level 2 dcl 1-3 set ref 144 265*
alloc_len                       000106 automatic       fixed bin(18,0)          dcl 36 in procedure "ms_salvager_v4_" set ref 142*
                                                                                  144 161 181* 257 263 267
alloc_len                12            based           fixed bin(17,0)          level 2 in structure "mseg_hdr_v4" dcl 1-3
                                                                                  in procedure "ms_salvager_v4_" set ref 144 265
                                                                                  267*
b_offset                  1(18)        based           bit(18)                  level 2 packed unaligned dcl 2-3 set ref 229* 247*
bit                                                    builtin function         dcl 55 ref 227 229 235 245
block_offset                    000107 automatic       fixed bin(18,0)          dcl 36 set ref 260* 261*
block_size               15            based           fixed bin(17,0)          level 2 in structure "mseg_hdr_v4" dcl 1-3
                                                                                  in procedure "ms_salvager_v4_" set ref 138 262*
block_size                      000110 automatic       fixed bin(18,0)          dcl 36 in procedure "ms_salvager_v4_" set ref 138*
                                                                                  139 139 139* 142 151 151 153 181* 260 262
code                            000115 automatic       fixed bin(35,0)          dcl 45 set ref 122* 124* 125 130* 131 147* 261* 292
                                                                                  297*
divide                                                 builtin function         dcl 55 ref 142 144 151
end_ptr                         000132 automatic       pointer                  dcl 57 set ref 170* 189 211*
error_table_$fatal_error        000012 external static fixed bin(35,0)          dcl 45 ref 147
f_offset                  1            based           bit(18)                  level 2 packed unaligned dcl 2-3 set ref 227* 237*
first_ms_offset          10            based           bit(18)                  level 2 dcl 1-3 set ref 167 169 211 245* 253*
fixed                                                  builtin function         dcl 55 ref 138 139 144 153 169 170 210 211 227 229
                                                                                  235 245
forward                         000130 automatic       bit(1)                   dcl 53 set ref 171* 181* 195 205 209*
hash_table              120            based           structure                level 2 dcl 1-3 set ref 270*
hcs_$get_access_class_seg       000024 constant        entry                    external dcl 105 ref 124
hcs_$get_max_length_seg         000016 constant        entry                    external dcl 91 ref 130
hcs_$truncate_seg               000020 constant        entry                    external dcl 96 ref 261
hdr_alloc_len                   000111 automatic       fixed bin(18,0)          dcl 36 set ref 151* 163 181* 263
hdr_ms                   20            based           bit(2304)                level 2 dcl 1-3 set ref 276*
hdr_ms_access_class       2            based           bit(72)                  level 2 dcl 1-3 set ref 272* 277*
hdr_size                        000113 automatic       fixed bin(18,0)          dcl 36 set ref 144* 146 151
header_pattern                  000551 automatic       bit(36)                  initial dcl 78 set ref 78* 268
i                               000100 automatic       fixed bin(17,0)          dcl 26 set ref 163* 164* 257* 260
last_backward_ptr               000134 automatic       pointer                  initial dcl 57 set ref 57* 199* 225 227 229 245 247
last_forward_ptr                000136 automatic       pointer                  initial dcl 57 set ref 57* 195* 222 227 229 235 237
last_in_bucket                  000151 automatic       bit(18)                  initial array level 2 packed unaligned dcl 71 set
                                                                                  ref 71*
last_ms_offset           11            based           bit(18)                  level 2 dcl 1-3 set ref 170 205 210 235* 253*
last_saved_ms_ptr               000140 automatic       pointer                  dcl 57 set ref 180* 181* 189 195 199
lock                                   based           bit(36)                  level 2 dcl 1-3 set ref 122*
mip                      16            based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 282*
mptr                            000552 automatic       pointer                  dcl 79 set ref 119* 122 124* 130* 136 138 144 155
                                                                                  167 169 169 170 170 205 210 210 211 211 235 245
                                                                                  253 253 261* 262 263 265 266 267 268 269 270 272
                                                                                  272 275 276 277 282 283 284 288* 297*
ms_block_trailer                       based           structure                level 1 dcl 2-3 set ref 153
ms_in_hdr                16(02)        based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 272 275*
ms_salv_util_v4_                000026 constant        entry                    external dcl 108 ref 181
mseg_access_class               000144 automatic       bit(72)                  dcl 65 set ref 124* 181* 272*
mseg_data_v4_$block_size        000010 external static fixed bin(18,0)          dcl 36 ref 139
mseg_error_v4_                  000030 constant        entry                    external dcl 112 ref 288 297
mseg_hdr_v4                            based           structure                level 1 dcl 1-3
mseg_pattern              1            based           bit(36)                  level 2 dcl 1-3 set ref 268*
new_alloc_bits                  000100 automatic       bit                      initial dcl 161 set ref 161* 164* 181 181 257 265
new_hash_table                  000151 automatic       structure                level 1 dcl 71 set ref 181 181 270
null                                                   builtin function         dcl 55 ref 57 57 180 222 225
number_of_messages       14            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 155 266*
original_messages               000103 automatic       fixed bin(17,0)          dcl 26 set ref 155* 288 288
os                       16(01)        based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 283*
ptr                                                    builtin function         dcl 55 ref 169 170 210 211
read_allowed_                   000022 constant        entry                    external dcl 99 ref 272
reason                          000116 automatic       char(40)                 unaligned dcl 51 set ref 126* 132* 297*
rel                                                    builtin function         dcl 55 ref 144 227 229 235 245
ring_brackets                   000146 automatic       fixed bin(3,0)           initial array dcl 69 set ref 69* 69* 69*
salv_ptr                        000142 automatic       pointer                  dcl 57 set ref 169* 181* 210*
saved_blocks                    000101 automatic       fixed bin(17,0)          initial dcl 26 set ref 26* 187* 187 263
saved_messages                  000102 automatic       fixed bin(17,0)          initial dcl 26 set ref 26* 185* 185 219 266 288 288
seg_size                        000112 automatic       fixed bin(18,0)          dcl 36 set ref 130* 139 142 146 181*
set_lock_$lock                  000032 constant        entry                    external dcl 114 ref 122
sip                      16(03)        based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 136* 284*
size                                                   builtin function         dcl 55 ref 153
space_left               13            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 263*
substr                                                 builtin function         dcl 55 set ref 164*
switches                 16            based           structure                level 2 dcl 1-3
tr_ptr                                 automatic       pointer                  dcl 2-3 ref 153
trailer_offset                  000114 automatic       fixed bin(18,0)          dcl 36 set ref 153* 227 229 237 247
tsaved_blocks                   000104 automatic       fixed bin(17,0)          dcl 26 set ref 181* 187
tsaved_messages                 000105 automatic       fixed bin(17,0)          dcl 26 set ref 177* 181* 185 192
version_number           17            based           fixed bin(17,0)          level 2 in structure "mseg_hdr_v4" dcl 1-3
                                                                                  in procedure "ms_salvager_v4_" set ref 269*
version_number                         constant        fixed bin(17,0)          initial dcl 77 in procedure "ms_salvager_v4_" ref
                                                                                  269

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
comp1                                  automatic       char(168)      A¨Þ  ÿÿ  ÿÿ                 A Š 
—@ ;"snÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  A„  R¹          \‚.  ‚R     A|‚
  ÿÿ  ÿÿ                 AtŠ 
ÿÀ ;"f^Ï£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  AX  Sû          \‚Z  ‚~     AP‚6  ÿÿ  ÿÿ                 AHŠ 
eÀ ;"YÞÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  A,  U+          \‚†  ‚ª     A$‚b  ÿÿ  ÿÿ                 AŠ 
Ò@ ;"L®Ï£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  A   W‘          \‚²  ‚Ö     @ø‚Ž  ÿÿ  ÿÿ                 @ðŠ ;@ ;"?nÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  @Ô  XÙ          \‚Þ  ‚     @Ì‚º  ÿÿ  ÿÿ                 @ÄŠ ¨€ ;"1Ï£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  @¨  ZF          \‚
  ‚.     @ ‚æ  ÿÿ  ÿÿ                 @˜Š @ ;"$.Ï£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  @|  \¡          \‚6  ‚Z     @t‚  ÿÿ  ÿÿ                 @lŠ €  ;"Ï£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  @P  ^          \‚b  ‚†     @H‚>  ÿÿ  ÿÿ                 @@Š é  ;"	öÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  @$  _H          \‚Ž  ‚²     @‚j  ÿÿ  ÿÿ                 @Š U@ ;"ûÎÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  @ø  a­          \‚º  ‚Þ     @ð‚–  ÿÿ  ÿÿ                 @èŠ ¼À ;"îþÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  @Ì  bç          \‚æ  ƒ
     @Ä‚Â  ÿÿ  ÿÿ                 @¼Š )  ;"áÖÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  @   dL          \ƒ  ƒ6     @˜‚î  ÿÿ  ÿÿ                 @Š “@ ;"ÔnÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  @t  f™          \ƒ>  ƒb     @lƒ  ÿÿ  ÿÿ                 @dŠ "À ;"ÂžÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  @H  h          \ƒj  ƒŽ     @@ƒF  ÿÿ  ÿÿ                 @8Š ªÀ ;"±~Ï£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  @  jW          \ƒ–  ƒº     @ƒr  ÿÿ  ÿÿ                 @Š   ;"£6Ï£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  ?ð  lÀ          \ƒÂ  ƒæ     ?èƒž  ÿÿ  ÿÿ                 ?àŠ „€ ;"–&Ï£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  ?Ä  n"          \ƒî  ƒ     ?¼ƒÊ  ÿÿ  ÿÿ                 ?´Š ë€ ;"‰fÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  ?˜  oZ          \ƒ  ƒ>     ?ƒö  ÿÿ  ÿÿ                 ?ˆŠ Q€ ;"|ÆÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  ?l  qŽ          \ƒF  ƒj     ?dƒ"  ÿÿ  ÿÿ                 ?\Š ÂÀ ;"n~Ï£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  ?@  s          \ƒr  ƒ–     ?8ƒN  ÿÿ  ÿÿ                 ?0Š =€ ;"^ÆÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  ?  tî          \ƒž  ƒÂ     ?ƒz  ÿÿ  ÿÿ                 ?Š §€ ;"QFÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  ?è  v>          \ƒÊ  ƒî     ?àƒ¦  ÿÿ  ÿÿ                 ?ØŠ   ;"DÏ£`^ý4€A .       €yó           € çÈ            Ÿ             0/~                  ?¼  x¤          \ƒö  „     ?´ƒÒ  ÿÿ  ÿÿ                 ?¬Š ¶  ;
                         000142 salv_ptr                    ms_salvager_v4_
                         000144 mseg_access_class           ms_salvager_v4_
                         000146 ring_brackets               ms_salvager_v4_
                         000151 new_hash_table              ms_salvager_v4_
                         000551 header_pattern              ms_salvager_v4_
                         000552 mptr                        ms_salvager_v4_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
enter_begin         leave_begin         call_ext_out_desc   call_ext_out        return              alloc_auto_adj
shorten_stack       ext_entry           reverse_bs          set_bs_eis          index_bs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
admin_gate_$guaranteed_eligibility_on                       hcs_$get_access_class_seg     hcs_$get_max_length_seg
hcs_$truncate_seg             ms_salv_util_v4_              mseg_error_v4_                read_allowed_
set_lock_$lock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$fatal_error      mseg_data_v4_$block_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000045        26 000056        57 000060        69 000063        71 000077        78 000116       119 000120
    121 000124       122 000131       124 000146       125 000161       126 000163       127 000166       130 000167
    131 000202       132 000204       133 000207       136 000210       138 000213       139 000215       142 000223
    144 000226       146 000236       147 000241       148 000244       151 000245       153 000251       155 000254
    159 000256       161 000261       163 000277       164 000310       165 000314       167 000316       169 000321
    170 000325       171 000333       177 000335       180 000337       181 000341       185 000402       187 000405
    189 000407       192 000413       195 000415       199 000423       205 000425       209 000433       210 000434
    211 000441       212 000447       219 000450       222 000452       225 000456       227 000462       229 000475
    231 000511       235 000512       237 000523       241 000530       245 000531       247 000542       251 000547
    253 000550       257 000553       260 000567       261 000572       262 000605       263 000611       265 000615
    266 000623       267 000625       268 000627       269 000631       270 000633       272 000636       275 000657
    276 000663       277 000666       282 000671       283 000675       284 000677       286 000701       288 000702
    292 000751       295 000754       297 000755       298 001006


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
