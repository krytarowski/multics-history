	COMPILATION LISTING OF SEGMENT who
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 08/04/87  1645.1 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style4 */
       12 who: procedure;
       13 
       14 /* WHO - print information about who's on Multics.
       15*
       16*   HMU, HOW_MANY_USERS - give header lines with nusers and load.
       17*
       18*   This command types out the userid's of listed logged-in users
       19*   from the segment "whotab", which is maintained by the answering service
       20*   program "lg_ctl_". The possible arguments are as follows:
       21*
       22*   .      -bf       suppress header  (not allowed for af)
       23*   .	-lg	print "long who"  (not allowed for af)
       24*   .	-nm	sort lines on user name
       25*   .	-pj	sort lines on project id
       26*   .		(the default sort is by time logged in)
       27*   .	-as	print information on absentee users
       28*   .	-ia	print information on interactive users
       29*   .	-dmn	print information on daemon users
       30*   .		(default is -as -ia if none of -as -ia -dmn given)
       31*   .      -all      -as, -ia -dmn
       32*   .	Name	list only users with person name "Name"
       33*   .	.Proj	list only users with project name "Proj"
       34*   .	Name.Proj	list only users with person name "Name" and project "Proj"
       35*
       36*   Initial coding by THVV, 9/6/70 */
       37 /* changed for absentee by EDS 7/71 */
       38 /* various changes by RBR 7/72      */
       39 /* error messages changed 09/15/78 S. Herbst */
       40 /* Modified May 1979 by T. Casey and S. Herbst for MR7.0a to add -interactive and -daemon,
       41*   and to list foreground absentee users correctly */
       42 /* who active function added 01/12/81 S. Herbst */
       43 /* 12/24/81 E. N. Kittlitz.  whotab changes */
       44 /* 9/82 BIM -all, no daemons by default */
       45 /* 11/82 E. N. Kittlitz. list daemons if name explicitly given, do selection for af call */
       46 /* 06/84 J A Falksen. Utilize date_time_$format("date_time"|"^<date>!!^<time>"... */
       47 
       48 dcl  return_arg char (return_len) varying based (return_ptr);
       49 dcl  return_ptr ptr;
       50 dcl  return_len fixed bin;
       51 dcl  af_sw bit (1);
       52 
       53 
       54 dcl  argno fixed bin init (1),			/* number of argument */
       55      arg_count fixed bin,
       56      ap ptr,					/* ptr to argument */
       57      al fixed bin,					/* lth of argument */
       58      ec fixed bin (35),				/* file-system error code */
       59      (f1, f2) float bin,				/* conversion temps */
       60      sort fixed bin init (0),				/* type of sort. 0=date, 1=name, 2=proj */
       61      hmucnt fixed bin init (0),			/* number of names|projects in */
       62      abscnt fixed bin init (0),			/* hmucnt as absentee users */
       63      long bit (1) aligned init ("0"b),			/* 1 if long who wanted */
       64      abs bit (1) aligned init ("0"b),			/* 1 if listing absentee users */
       65      only_abs bit (1) aligned init ("0"b),		/* if only listing absentees */
       66      daemon bit (1) aligned init ("0"b),		/* if listing daemon users */
       67      interactive bit (1) aligned init ("0"b),		/* if listing interactive users */
       68      brief bit (1) aligned init ("0"b),			/* 1 for no heading at all */
       69      hmuflg bit (1) aligned init ("0"b),		/* selective hmu flag */
       70      selx fixed bin init (0),				/* if particular users wanted */
       71      dotl fixed bin,				/* location of dot in arg */
       72      nm (50) char (24) aligned,			/* user names wanted */
       73      pj (50) char (12) aligned,			/* user projs wanted */
       74      caller char (14) varying,			/* name of caller to com_err */
       75      why char (128) aligned,				/* reason for shutdown */
       76      arg char (al) unaligned based (ap),		/* pickup for args */
       77      sort_arg char (32) init (""),
       78      whoptr ptr int static init (null),			/* ptr to whotab */
       79      ip ptr int static init (null),			/* ptr to installation_parms */
       80      sysdir char (64) aligned int static init (">system_control_1"), /* name of dir in which who table resides */
       81      date_l fixed bin,
       82      j fixed bin,					/* index */
       83      d fixed bin,					/* distance between sorted elems */
       84      last fixed bin,				/* highest index in whotab */
       85      swap fixed bin,				/* 1 if a swap was done */
       86      ajd fixed bin,					/* temp for sort, ary(j+d) */
       87      sss char (1) aligned init ("s"),			/* pretty for user-not-on */
       88      (time, time1) char (64)var init (""),		/* ASCII time */
       89      aj fixed bin,					/* temp, ary(j) */
       90      did fixed bin init (0),				/* count of lines printed */
       91      mark char (3) aligned,				/* denotation of absentee user if = "*" */
       92      k fixed bin;					/* index */
       93 
  1     1 /* BEGIN INCLUDE FILE ... whotab.incl.pl1 */
  1     2 
  1     3 /* Modified 740723 by PG to add security info */
  1     4 /* Modified April 1976 by T. Casey to add shift and shift start and end times */
  1     5 /* Modified May 1979 by T. Casey for MR7.0a to add foreground absentee variables */
  1     6 /* Modified June 1981 by E. N. Kittlitz to add n_rate_structures. */
  1     7 /* Modified December 1981 by E. N. Kittlitz to expand header. */
  1     8 /* Modified 84-11-14  by E. A. Ranzenbach to add "session" fiedld in  place of obsolete system ID... */
  1     9 
  1    10 dcl 1 whotab based (whoptr) aligned,
  1    11     2 mxusers fixed bin,				/* max. number of users on system */
  1    12     2 n_users fixed bin,				/* current number of users */
  1    13     2 mxunits fixed bin,				/* maximun "load units" allowed */
  1    14     2 n_units fixed bin,				/* current load */
  1    15     2 timeup fixed bin (71),				/* time system was started */
  1    16     2 session char (8),				/* AS state, same as anstbl.session  */
  1    17     2 nextsd fixed bin (71),				/* time we will shutdown */
  1    18     2 until fixed bin (71),				/* projected time we start up again */
  1    19     2 lastsd fixed bin (71),				/* time of last crash or shutdown */
  1    20     2 erfno char (8),				/* if a crash, the error number */
  1    21     2 obsolete_why char (32),				/* reason for last shutdown */
  1    22     2 installation_id char (32),			/* name of installation */
  1    23     2 obsolete_message char (32),			/* message for all users */
  1    24     2 abs_event fixed bin (71),			/* event channel associated with absentee */
  1    25     2 abs_procid bit (36) aligned,			/* process to whom messages about absentee are signalled */
  1    26     2 max_abs_users fixed bin,			/* max number of absentee users */
  1    27     2 abs_users fixed bin,				/* number of absentee users logged-in */
  1    28     2 n_daemons fixed bin,				/* Number of daemon users logged in */
  1    29     2 request_channel fixed bin (71),			/* System master channel for requests to AS. */
  1    30     2 request_process_id bit (36),			/* Process ID of request dispatcher */
  1    31     2 shift fixed bin,				/* current shift (copied from anstbl, for users to see) */
  1    32     2 next_shift_change_time fixed bin (71),		/* time current shift ends */
  1    33     2 last_shift_change_time fixed bin (71),		/* time current shift started */
  1    34     2 fg_abs_users fixed bin (17) unal,			/* number of foreground absentee users */
  1    35     2 n_rate_structures fixed bin (9) unsigned unal,	/* number of rate_structures defined at bootload */
  1    36     2 pad1 bit (9) unal,
  1    37     2 pad (3) fixed bin,
  1    38     2 version fixed bin,				/* structure version */
  1    39     2 header_size fixed bin,				/* length of header in words */
  1    40     2 entry_size fixed bin,				/* length of entry in words */
  1    41 						/* laste_adjust is used only by Answering Service programs */
  1    42     2 laste_adjust fixed bin,				/* count of 32 wd blocks in hdr from header_extension_mbz1 */
  1    43     2 laste fixed bin,				/* index of last entry in use (includes laste_adjust) */
  1    44     2 freep fixed bin (18) unsigned,			/* index of first free entry. chained thru "chain" */
  1    45 
  1    46 /* whotab header extension:  The header is extended from 64 words by
  1    47*   annexing whole user entries from the 'e' array.  Each 'e' entry is 32 words
  1    48*   long. Each annexed block has its first word set to zero, indicating that no user entry is
  1    49*   present.  This allows existing programs to function with old definitions of
  1    50*   whotab.  Obviously no new header field can be more than 31 contiguous words in
  1    51*   length.  In the Answering Service, all programs using whotab must be compiled
  1    52*   with the latest version. Only lg_ctl_ uses laste_adjust. */
  1    53 
  1    54     2 header_extension_mbz1 fixed bin,			/* location 100o */
  1    55     2 n_abs (4) fixed bin,				/* number of processes from each background queue */
  1    56     2 abs_qres (4) fixed bin,				/* number of absentee positions reserved for each queue */
  1    57     2 abs_cpu_limit (4) fixed bin (35),			/* current absentee cpu limits */
  1    58     2 abs_control,					/* see absentee_user_table */
  1    59       3 mnbz bit (1) unal,				/* must not be zero */
  1    60       3 abs_maxu_auto bit (1) unal,			/* 1 if automatic */
  1    61       3 abs_maxq_auto bit (1) unal,			/* 1 if automatic */
  1    62       3 abs_qres_auto bit (1) unal,			/* 1 if automatic */
  1    63       3 abs_cpu_limit_auto bit (1) unal,		/* 1 if automatic */
  1    64       3 queue_dropped (-1:4) bit (1) unal,		/* 1 if queue dropped */
  1    65       3 abs_up bit (1) unal,				/* 1 if absentee facility is running */
  1    66       3 abs_stopped bit (1) unal,			/* 1 if absentee facility is stopped */
  1    67       3 control_pad bit (23) unal,
  1    68     2 installation_request_channel fixed bin (71),	/* IPC channel for install command */
  1    69     2 installation_request_pid bit (36),		/* installation process identifier */
  1    70     2 sysid char (32),				/* current system name */
  1    71     2 header_extension_pad1 (7) fixed bin,		/* pad to size of e element, offset 137o */
  1    72     2 header_extension_mbz2 fixed bin,			/* offset 140o */
  1    73     2 message char (124),				/* message for all users */
  1    74     2 header_extension_mbz3 fixed bin,			/* offset 200o */
  1    75     2 why char (124),				/* reason for last shutdown */
  1    76     2 e (1000),					/* offset 240o */
  1    77       3 active fixed bin,				/* nonzero means logged in */
  1    78       3 person char (28) aligned,			/* person name */
  1    79       3 project char (28),				/* project id */
  1    80       3 anon fixed bin,				/* 1 if anonymous user */
  1    81       3 padding fixed bin (71),
  1    82       3 timeon fixed bin (71),			/* time of login */
  1    83       3 units fixed bin,				/* load units */
  1    84       3 stby fixed bin,				/* 1 if stby */
  1    85       3 idcode char (4),				/* tty id code */
  1    86       3 chain fixed bin (18) unsigned,			/* chain for free list */
  1    87       3 proc_type fixed bin,				/* 1 = interactive, 2 = absentee, 3 = daemon */
  1    88       3 group char (8),				/* party-line group */
  1    89       3 fg_abs bit (1) unal,				/* "1"b if foreground absentee user */
  1    90       3 disconnected bit (1) unaligned,			/* "1"b if process is disconnected */
  1    91       3 suspended bit (1) unaligned,			/* "1"b if process is suspended */
  1    92       3 pad2 bit (33) unal,
  1    93       3 cant_bump_until fixed bin (71),			/* protected from primary bump till here */
  1    94       3 process_authorization bit (72);			/* access authorization of process */
  1    95 
  1    96 dcl  WHOTAB_VERSION_1 fixed bin init (1) static options (constant);
  1    97 
  1    98 /* END INCLUDE FILE ... whotab.incl.pl1 */
       94 
       95 
  2     1 /* BEGIN INCLUDE FILE ... installation_parms.incl.pl1 */
  2     2 
  2     3 /* Modified 740723 by PG to add short AIM access names */
  2     4 /* Modified Fall 1977 by T. Casey to add fatal loop and trm_ signal parameters */
  2     5 /* Modified 04/03/78 by CDT to add rcp_init_flags structure */
  2     6 /* Modified May 1978 by T. Casey to add resource timer and resource price list parameters */
  2     7 /* Modified November 1978 by T. Casey for MR7.0, to add absentee control parameters */
  2     8 /* Modified 17 September 1980 by G. Palter to add default absentee queue */
  2     9 /* Modified April 1981 by E. N. Kittlitz for chn_wakeup_error_loop, chn_wakeup_error_count */
  2    10 /* Modified June 1981 by E. N. Kittlitz for nrates/rate_structures UNCA rate_structure support.
  2    11*     Version, expand foregound_cpu_default_limit and abs_cpu_max_limit to fixed bin (35) fields.
  2    12*     nrscp & resource array moved from offset 2064 (octal) to 2400 (octal). */
  2    13 /* Modified 1984-06-19 BIM to remove obsolete fields, and add 
  2    14*		       strict_trusted_path. */
  2    15 /* Modified 1984-10-24 BIM for default_pdir_quota. */
  2    16 /* Modified 1984-12-05 BIM for require_operator_login. */
  2    17 /* Modified 1985-03-01 by E. Swenson for password flags. */
  2    18 
  2    19 
  2    20 /****^  HISTORY COMMENTS:
  2    21*  1) change(86-01-27,MSharpe), approve(87-05-25,MCR7690),
  2    22*     audit(87-03-29,GDixon), install(87-08-04,MR12.1-1056):
  2    23*     added vchn_requires_accept parameter.
  2    24*  2) change(87-02-17,GDixon), approve(87-05-25,MCR7680),
  2    25*     audit(87-06-02,Parisek), install(87-08-04,MR12.1-1056):
  2    26*     Correct formatting problems.
  2    27*                                                   END HISTORY COMMENTS */
  2    28 
  2    29 
  2    30 /* NOTE: rate_structure.incl.pl1 uses these declarations */
  2    31 
  2    32 
  2    33 dcl 1 installation_parms based (ip) aligned,		/* describes installation parameters */
  2    34     2 part_1 like installation_parms_part_1 aligned,
  2    35     2 resource (0 refer (installation_parms.nrscp)) like installation_parms_resource_array_part aligned;
  2    36 
  2    37 dcl  installation_parms_version_1 fixed bin init (1) static internal options (constant);
  2    38 dcl  installation_parms_version_2 fixed bin init (2) static internal options (constant);
  2    39 
  2    40 dcl 1 installation_parms_part_1 based aligned,		/* Used only by installation_parms and rate_structure */
  2    41     2 installation_id char (32),			/* Name printed at dialup and in who */
  2    42     2 company char (64),				/* company name */
  2    43     2 department char (64),				/* department */
  2    44     2 companyds char (120),				/* company, double spaced */
  2    45     2 departmentds char (120),			/* dpeartment double spaced */
  2    46     2 shifttab (336) bit (3) unal,			/* half-hrs from 0000 Mon, value is shift no */
  2    47     2 cpu_price (0: 7) float bin,			/* price for cpu hour, by shift */
  2    48     2 log_base_price (0: 7) float bin,			/* price for log hour, by shift */
  2    49     2 io_ops_price (0: 7) float bin,			/* price per 1000 terminal io ops */
  2    50     2 core_price (0: 7) float bin,			/* price for core page-hour, by shift */
  2    51     2 ndevices fixed bin,				/* number of devices to charge */
  2    52     2 devtab (16),					/* Maximum 16 */
  2    53       3 device_id char (8),				/* Name of device */
  2    54       3 device_price (0: 7) float bin,			/* Price by shift */
  2    55     2 inactive_time fixed bin,			/* seconds of inactivity permitted */
  2    56     2 warning_time fixed bin,				/* seconds from warning to logout */
  2    57     2 login_time fixed bin,				/* seconds in which to complete login */
  2    58     2 acct_update fixed bin,				/* seconds between acct update */
  2    59     2 login_tries fixed bin,				/* number of login tries allowed */
  2    60     2 disk_price float bin,				/* disk rate, in $/page-sec */
  2    61     2 registration_price float bin,			/* fee per month per user */
  2    62     2 dolsign char (1),				/* "dollar sign" */
  2    63     2 abs_cpu_price (4) float bin,			/* price for absentee cpu by queue */
  2    64     2 abs_mem_price (4) float bin,			/* Absentee memory charge */
  2    65     2 iod_rec_price (4) float bin,			/* price for io daemon lines, per K, by queue */
  2    66     2 abs_timax (4) fixed bin (35),			/* Absentee TIMAX parameter */
  2    67     2 abs_cpu_default_limit (4) fixed bin (35),		/* default absentee cpu limit in seconds (changed from usec.) */
  2    68     2 syserr_log_copy_threshold fixed bin (9),		/* Threshold (in PAGES) at which the
  2    69*						   Initializer will copy the syserr_log */
  2    70     2 default_pdir_seg_quota fixed bin (17) unaligned,	/* if system and project say 0 */
  2    71     2 default_pdir_dir_quota fixed bin (17) unaligned,       /* Always used */
  2    72     2 fatal_error_loop_count fixed bin (17) unaligned,
  2    73     2 fatal_error_loop_seconds fixed bin (17) unaligned,
  2    74     2 term_real_time_seconds fixed bin (17) unaligned,
  2    75     2 term_cpu_time_seconds fixed bin (17) unaligned,
  2    76     2 rcp_init_flags like rcp_init_flags aligned,		/* one word long */
  2    77     2 rsc_timer_seconds fixed bin (17) unaligned,		/* time interval at which to check for resource availability */
  2    78     2 pad_old_fg_cpu_default_limit bit (18) unaligned,
  2    79     2 foreground_queue_position fixed bin (17) unal,	/* queue that foreground queue comes after */
  2    80     2 idle_time_constant_seconds fixed bin (17) unal,	/* how far back to maintain moving average of load */
  2    81     2 sus_cpu_time_seconds fixed bin (17) unal,		/* allow suspended process this much cpu time */
  2    82     2 sus_real_time_seconds fixed bin (17) unal,		/* and this much real time, before bumping it */
  2    83     2 foreground_cpu_default_limit fixed bin (35),	/* default cpu time limit (sec) for foreground absentee jobs */
  2    84     2 access_authorization_ceiling bit (72),		/* "System high" access authorization. */
  2    85     2 level_names (0:7) char (32),			/* Names for security levels. */
  2    86     2 category_names (18) char (32),			/* Names for security categories. */
  2    87     2 short_level_names (0:7) char (8),			/* Abbreviated level names. */
  2    88     2 short_category_names (18) char (8),		/* Abbreviated category names. */
  2    89     2 ncon fixed bin,				/* Number of config elements. */
  2    90     2 cona (51),					/* each entry is 5 words long */
  2    91       3 cpu fixed bin (5) unal,			/* Number of CPU's */
  2    92       3 shift fixed bin (5) unal,			/* Shift number */
  2    93       3 x1 fixed bin (23) unal,
  2    94       3 kmem fixed bin (17) unal,			/* Memory size */
  2    95       3 kbulk fixed bin (17) unal,			/* Bulk store size */
  2    96       3 x2 fixed bin (17) unal,
  2    97       3 maxa fixed bin (11) unal,			/* Max abs users */
  2    98       3 maxq fixed bin (5) unal,			/* Max abs q */
  2    99       3 maxu_base fixed bin (17) unal,
  2   100       3 response_high fixed bin (17) unal,
  2   101       3 response_low fixed bin (17) unal,
  2   102       3 x3 fixed bin (17) unal,
  2   103 
  2   104 /* Absentee control parameters. New for MR7.0 */
  2   105 
  2   106     2 max_abs (0:7) fixed bin (17) unal,		/* per-shift upper limit on abs_maxu */
  2   107     2 min_abs (0:7) fixed bin (17) unal,		/* per-shift lower limit on abs_maxu */
  2   108     2 pct_abs (0:7) fixed bin (17) unal,		/* abs_maxu is this pct (per-shift) of idle units */
  2   109 
  2   110     2 max_qres (0:7, 4) fixed bin (17) unal,		/* per-shift-and-queue upper limit on reserved slots */
  2   111     2 min_qres (0:7, 4) fixed bin (17) unal,		/* per-shift-and-queue lower limit on reserved slots */
  2   112     2 pct_qres (0:7, 4) fixed bin (17) unal,		/* reserved slots are these pcts of abs_maxu */
  2   113 
  2   114     2 abs_cpu_max_limit (0:7, 4) fixed bin (35),		/* per-shift-and-queue upper limit (sec) on jobs' cpu times */
  2   115 
  2   116     2 default_absentee_queue fixed binary (17) unaligned,	/* default absentee queue for ear, etc. */
  2   117 
  2   118     2 chn_wakeup_error_loop_count fixed bin (17) unaligned, /* maximum number of channel wakeups in following interval */
  2   119     2 chn_wakeup_error_loop_seconds fixed bin (17) unaligned, /* works like fatal_error_loop_count/seconds */
  2   120     2 rate_structure_number fixed bin (17) unaligned,	/* rate_structure number of this RS */
  2   121     2 version fixed bin (35),				/* must be 2 */
  2   122     2 nrates fixed bin,				/* number of rate structures */
  2   123     2 rate_structures (0:9) char (32),			/* names of rate_structures */
  2   124     2 trusted_path_login bit (1) aligned,		/* forbid logout -hold and new_proc -auth */
  2   125     2 require_operator_login bit (1) aligned,		/* just what it says */
  2   126     2 operator_inactive_time fixed bin,			/* seconds between commands --> not logged in. */
  2   127     2 validate_daemon_commands bit (1) aligned,		/* force existence and adequate access to 
  2   128*						   mcacs segments for operators */
  2   129     2 password_min_length fixed bin,			/* minimum length of passwords */
  2   130     2 password_gpw_length fixed bin,			/* length of generated passwords */
  2   131     2 password_change_interval fixed bin,		/* number of days until must change */
  2   132     2 password_expiration_interval fixed bin,		/* number of days that a password may remain unused */
  2   133     2 vchn_requires_accept bit (1) aligned,		/* "login personid -op -vchn foo" must be
  2   134*						   "accepted" by operator if personid is not 
  2   135*						   signed on system console */
  2   136     2 end_pad (219) bit (36) aligned,			/* leave plenty of pad before the variable length price list */
  2   137     2 nrscp fixed bin;				/* length of resource price array; must have offset 2400 (octal),
  2   138*						   or someone miscounted when using part of pad2 */
  2   139 
  2   140 
  2   141 /* Entries in the following array may be accessed via system_info_$resource_price.
  2   142*   This array should not be accessed directly, since its format will change in subsequent releases of Multics. */
  2   143 
  2   144 dcl 1 installation_parms_resource_array_part (0 refer (installation_parms.nrscp)) based,
  2   145       2 name char (32),
  2   146       2 price float bin;
  2   147 
  3     1 /* BEGIN INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  3     2 
  3     3 /* Created on 04/24/78 by Michael R. Jordan */
  3     4 /* Modified 04/10/79 by C. D. Tavares */
  3     5 
  3     6 dcl  rifp ptr;
  3     7 
  3     8 dcl 1 rcp_init_flags based (rifp),
  3     9     2 unload_on_detach bit (1) unaligned,		/* ON => tape volumes are unloaded after detaching */
  3    10     2 pad1 bit (2) unaligned,				/* obsolete */
  3    11     2 resource_mgmt_enabled bit (1) unaligned,		/* ON => resource management has been enabled */
  3    12     2 auto_registration bit (1) unaligned,		/* ON => auto registration allowed */
  3    13     2 pad2 bit (2) unaligned,				/* future expansion, possibly of authentication_level */
  3    14     2 authentication_level fixed bin (2) unaligned unsigned; /* see below for values */
  3    15 
  3    16 dcl (No_authentication initial (0),
  3    17      Nominal_authentication initial (1),
  3    18      Automatic_authentication initial (2),
  3    19      Manual_authentication initial (3)) fixed bin internal static options (constant);
  3    20 
  3    21 dcl  authentication_level_names (0:3) char (12) internal static options (constant) initial
  3    22     ("none", "nominal", "automatic", "manual");
  3    23 
  3    24 /* END INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  2   148 
  2   149 
  2   150 /* END INCLUDE FILE ... installation_parms.incl.pl1 */
       96 
       97 
       98 dcl  complain entry variable options (variable);
       99 
      100 dcl  ioa_ ext entry options (variable),			/* library procedures */
      101      active_fnc_err_ entry options (variable),
      102      com_err_ ext entry options (variable),
      103      date_time_$format entry (char(*), fixed bin(71), char(*), char(*)) returns(char(250) var),
      104      cu_$af_return_arg entry (fixed bin, ptr, fixed bin, fixed bin (35)),
      105      cu_$arg_ptr ext entry (fixed bin, ptr, fixed bin, fixed bin (35)),
      106      hcs_$initiate ext entry (char (*) aligned, char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
      107      requote_string_ entry (char (*)) returns (char (*));
      108 
      109 dcl  (after, before, divide, hbound, index, null, rtrim, substr) builtin;
      110 dcl  (error_table_$badopt,
      111      error_table_$not_act_fnc,
      112      error_table_$too_many_args) ext fixed bin;
      113 
      114 /* - - - - - - - - - - */
      115 
      116 	caller = "who";				/* set name of caller to com_err_ */
      117 	go to join;
      118 
      119 how_many_users: hmu: entry;
      120 
      121 	caller = "how_many_users";
      122 	hmuflg = "1"b;
      123 
      124 join:
      125 	call cu_$af_return_arg (arg_count, return_ptr, return_len, ec);
      126 	if ec = error_table_$not_act_fnc then do;
      127 	     af_sw = "0"b;
      128 	     complain = com_err_;
      129 	end;
      130 	else if caller = "how_many_users" then do;
      131 	     call active_fnc_err_ (0, caller, "Cannot be called as an active function.");
      132 	     return;
      133 	end;
      134 	else do;
      135 	     af_sw = "1"b;
      136 	     complain = active_fnc_err_;
      137 	end;
      138 
      139 	do argno = 1 to arg_count;
      140 	     call cu_$arg_ptr (argno, ap, al, ec);	/* get nth argument */
      141 
      142 	     if arg = "-absentee" | arg = "-as" then abs = "1"b;
      143 	     else if arg = "-daemon" | arg = "-dmn" then daemon = "1"b;
      144 	     else if arg = "-interactive" | arg = "-ia" then interactive = "1"b;
      145 	     else if arg = "-all" | arg= "-a" then interactive, daemon, abs = "1"b;
      146 	     else if arg = "-name" | arg = "-nm" then sort = 1;
      147 	     else if arg = "-project" | arg = "-pj" then sort = 2;
      148 
      149 	     else if arg = "-brief" | arg = "-bf" then
      150 		if af_sw then do;
      151 BAD_AF_OPT:	     call active_fnc_err_ (0, caller, "Invalid active function control arg ^a", arg);
      152 		     return;
      153 		end;
      154 		else brief = "1"b;
      155 	     else if arg = "-long" | arg = "-lg" then
      156 		if af_sw then go to BAD_AF_OPT;
      157 		else long = "1"b;
      158 
      159 	     else if substr (arg, 1, 1) = "-" then do;	/* then it must be a name or project */
      160 bad_opt:		call complain (error_table_$badopt, caller, "^a", arg);
      161 		return;
      162 	     end;
      163 	     else do;				/* save Name | .Project */
      164 		selx = selx + 1;			/* up index in select array */
      165 		if selx > hbound (nm, 1) then do;
      166 		     call complain (error_table_$too_many_args, caller);
      167 		     return;
      168 		end;
      169 		nm (selx), pj (selx) = "";		/* blank selectors */
      170 		dotl = index (arg, ".");		/* where's the dot? */
      171 		if dotl = 0 then nm (selx) = arg;	/* no dot. is user name. */
      172 		else if dotl = 1 then pj (selx) = substr (arg, 2, al - 1);
      173 		else do;				/* dot in middle, is name.proj */
      174 		     nm (selx) = substr (arg, 1, dotl - 1); /* get name */
      175 		     pj (selx) = substr (arg, dotl + 1, al - dotl);
      176 		end;
      177 	     end;
      178 	     if sort ^= 0 & hmuflg then go to bad_opt;
      179 	end;
      180 
      181 	if ^interactive & ^abs & ^daemon then do;	/* if process type not specified */
      182 	     interactive, abs = "1"b;			/* default is to list abs and ia */
      183 	     if selx > 0 then daemon = "1"b;		/* but if name/proj given, list everything */
      184 	end;
      185 	only_abs = abs & ^interactive & ^daemon;	/* see if abs only */
      186 
      187 go:	if whoptr = null then do;			/* is this the first call? */
      188 	     call hcs_$initiate (sysdir, "whotab", "", 0, 1, whoptr, ec);
      189 	     if whoptr = null then do;
      190 		call complain (ec, caller, "^a>whotab", sysdir);
      191 		return;
      192 	     end;
      193 	end;
      194 
      195 	if ^brief & ^af_sw then do;			/* suppress header */
      196 	     if hmuflg then go to head;		/* always a header for hmu, except after brief */
      197 	     if selx = 0 then do;			/* no header with who select */
      198 		if only_abs			/* what type absentee header if any */
      199 		then if long
      200 		     then go to print_long_abs_totals;
      201 		     else go to print_abs_totals;
      202 head:		f1 = whotab.n_units / 10.0e0;		/* format up units */
      203 		f2 = whotab.mxunits / 10.0e0;		/* ... */
      204 		j = whotab.n_users - whotab.abs_users - whotab.fg_abs_users - whotab.n_daemons; /* compute interactive users */
      205 
      206 		if long then do;			/* long who? */
      207 		     if ip = null then do;
      208 			call hcs_$initiate (sysdir, "installation_parms", "", 0, 1, ip, ec);
      209 			if ip = null then do;
      210 			     call complain (ec, caller, "Insufficient access for -long option");
      211 			     return;
      212 			end;
      213 		     end;
      214 		     time = date_time_$format ("date_time", whotab.timeup, "", ""); /* yup. make heading */
      215 		     call ioa_ ("^/Multics ^a; ^a", whotab.sysid, installation_parms.installation_id);
      216 		     call ioa_ ("Load = ^.1f out of ^.1f units; users = ^d, ^d interactive, ^d daemons.",
      217 			f1, f2, whotab.n_users, j, whotab.n_daemons);
      218 		     if (whotab.abs_users + whotab.max_abs_users) ^= 0
      219 		     then				/* ! */
      220 print_long_abs_totals:	call ioa_ ("^[^/^]Absentee users = ^d background^[, ^d foreground^;^s^]; Max background absentee users = ^d^[^/^]",
      221 			     only_abs, whotab.abs_users, (whotab.fg_abs_users > 0), whotab.fg_abs_users, whotab.max_abs_users, only_abs);
      222 		     if only_abs then go to check_hmu;
      223 		     call ioa_ ("System up since ^a", time);
      224 		     if whotab.nextsd ^= 0 then do;
      225 			why = whotab.why;
      226 			if why < "" then why = "";
      227 			time = date_time_$format ("date_time", whotab.nextsd, "", "");
      228 			if whotab.until = 0 then call ioa_ ("Scheduled shutdown at ^a ^a", time, why);
      229 			else do;
      230 			     time1 = date_time_$format ("date_time", whotab.until, "", "");
      231 			     call ioa_ ("Scheduled shutdown from ^a to ^a ^a", time, time1, why);
      232 			end;
      233 		     end;
      234 		     time = date_time_$format ("date_time", whotab.lastsd, "", "");
      235 		     if whotab.erfno = "crash" then call ioa_ ("Last crash was at ^a^/", time);
      236 		     else if whotab.lastsd = 0 then call ioa_ ("");
      237 		     else if whotab.erfno = "" then call ioa_ ("Last shutdown was at ^a^/", time);
      238 		     else call ioa_ ("Last crash (ERF ^a) was at ^a^/", whotab.erfno, time);
      239 		     if hmuflg then if selx = 0 then return;
      240 			else go to shell_sort;
      241 		     call ioa_ ("^4xLogin at^6xTTY  Load^3xUser ID^/");
      242 		end;
      243 		else do;				/* short who. */
      244 		     call ioa_ ("^/Multics ^a, load ^.1f/^.1f; ^d users, ^d interactive, ^d daemons.",
      245 			whotab.sysid, f1, f2, whotab.n_users, j, whotab.n_daemons);
      246 		     if (whotab.max_abs_users + whotab.abs_users) ^= 0
      247 		     then				/* print absentee totals under certain conditions */
      248 print_abs_totals:		call ioa_
      249 			     ("^[^/^]Absentee users ^d/^d^[^x(+^d FG)^;^s^]^[^/^]",
      250 			     only_abs, whotab.abs_users, whotab.max_abs_users, (whotab.fg_abs_users > 0), whotab.fg_abs_users, only_abs);
      251 		     if ^abs then call ioa_ ("");
      252 		end;
      253 	     end;
      254 	end;
      255 check_hmu:
      256 	if hmuflg & selx = 0			/* if a simple hmu entry then finished */
      257 	then return;
      258 
      259 shell_sort: last = whotab.laste;			/* save high limit on whotab */
      260 	if hmuflg then go to count;			/* go to selective hmu counting */
      261 
      262 	begin;
      263 
      264 dcl  sort_array (last) fixed bin;
      265 
      266 	     do j = 1 to last;			/* set up sort array */
      267 		sort_array (j) = j;			/* ... */
      268 	     end;
      269 
      270 	     d = last;				/* set up for Shell sort */
      271 pass:	     d = divide (d + 1, 2, 17, 0);		/* ... */
      272 	     swap = 0;				/* ... */
      273 	     do j = 1 to last - d;			/* comparison loop */
      274 		aj = sort_array (j);		/* make temps */
      275 		ajd = sort_array (j + d);		/* ... */
      276 		if sort = 0 then if whotab.timeon (aj) > whotab.timeon (ajd) then go to ic;
      277 		if sort = 1 then if whotab.person (aj) > whotab.person (ajd) then go to ic;
      278 		if sort = 2 then if whotab.project (aj) > whotab.project (ajd) then go to ic;
      279 		     else if whotab.project (aj) = whotab.project (ajd) then if whotab.person (aj)
      280 			     > whotab.person (ajd) then do; /* Are items in order? */
      281 ic:			     sort_array (j) = ajd;	/* No. Swap entries */
      282 			     sort_array (j + d) = aj; /* ... */
      283 			     swap = swap + 1;	/* remember a swap */
      284 			end;
      285 	     end;
      286 	     if swap > 0 then go to pass;		/* if out of order do it again */
      287 	     if d > 1 then go to pass;		/* ... */
      288 
      289 
      290 
      291 	     time1 = "%%%%";			/* make sure it won't match (time) later on. */
      292 	     if af_sw then return_arg = "";
      293 
      294 	     do j = 1 to last;			/* now the print loop */
      295 		aj = sort_array (j);		/* set up speed temp */
      296 		if whotab.active (aj) = 0 then go to skip; /* skip deads */
      297 		if selx = 0 then go to print;		/* any users selected? */
      298 		do k = 1 to selx;			/* check for selected users */
      299 		     if nm (k) = whotab.person (aj) then if pj (k) = "" then go to print;
      300 			else if pj (k) = whotab.project (aj) then go to print;
      301 		     if nm (k) = "" then if pj (k) = whotab.project (aj) then go to print;
      302 		end;
      303 		go to skip;			/* user not in selected group */
      304 
      305 print:
      306 		if whotab.proc_type (aj) = 1 & ^interactive
      307 		     | whotab.proc_type (aj) = 2 & ^abs
      308 		     | whotab.proc_type (aj) = 3 & ^daemon
      309 		then goto skip;
      310 
      311 		if af_sw then do;
      312 		     if return_arg ^= "" then return_arg = return_arg || " ";
      313 		     return_arg = return_arg ||
      314 			requote_string_ (rtrim (whotab.person (aj)) || "." || rtrim (whotab.project (aj)));
      315 		     go to skip;
      316 		end;
      317 
      318 		if whotab.proc_type (aj) ^= 2 then	/* if not absentee */
      319 		     mark = "";			/* clear absentee flag */
      320 		else if whotab.fg_abs (aj) then	/* if foreground absentee */
      321 		     mark = "*FG";			/* flag it as such */
      322 		else mark = "*";			/* else flag it as background absentee */
      323 
      324 		did = did + 1;			/* remember we did one */
      325 		if long then do;			/* long who? */
      326 		     time = date_time_$format ("^<date>!! ^<time>", whotab.timeon (aj), "", "");
      327 /****		     Suppress date if it's the same as last printed date */
      328 		     date_l = index (time, "!!")-1;
      329 		     if substr (time, 1, date_l) = substr (time1, 1, date_l)
      330 		     then substr (time, 1, date_l) = " ";
      331 		     else time1 = time;
      332 		     f1 = whotab.units (aj) / 10.0e0;	/* get nice units */
      333 		     call ioa_ ("^va ^a  ^4a ^4.1f^3x^a.^a^a^x^[D^]^[S^]",
      334 			date_l, before (time, "!!"), after (time, "!!"),
      335 		          whotab.idcode (aj), f1, whotab.person (aj), whotab.project (aj),
      336 			mark, whotab.disconnected (aj), whotab.suspended (aj));
      337 		end;
      338 		else do;				/* short who. */
      339 		     call ioa_ ("^a.^a^a^x^[D^]^[S^]", whotab.person (aj), whotab.project (aj), mark,
      340 			whotab.disconnected (aj), whotab.suspended (aj));
      341 		end;
      342 
      343 skip:	     end;
      344 
      345 	end;
      346 
      347 	if ^af_sw then do;
      348 	     if ^brief then
      349 
      350 		if did = 0 then do;			/* if printed nobody */
      351 		     if selx = 1 then if nm (1) ^= "" then sss = "";
      352 		     call ioa_ ("User^a not logged in.", sss);
      353 		end;
      354 
      355 	     call ioa_ ("");			/* extra CR */
      356 	end;
      357 
      358 	return;					/* done. */
      359 
      360 /* - - - - - - - - */
      361 
      362 
      363 count:	do j = 1 to selx;				/* selective hmu counting */
      364 	     hmucnt = 0;				/* reset counters */
      365 	     abscnt = 0;
      366 
      367 	     if nm (j) = "" then do;			/* selected project counting */
      368 		do aj = 1 to last;
      369 		     if pj (j) = whotab.project (aj) then
      370 			if whotab.proc_type (aj) ^= 2
      371 			then hmucnt = hmucnt + 1;
      372 			else abscnt = abscnt + 1;
      373 		end;
      374 		call ioa_ (".^a = ^d + ^d*", pj (j), hmucnt, abscnt);
      375 	     end;
      376 
      377 	     if nm (j) ^= "" then
      378 		if pj (j) ^= ""			/* selected name.project counting */
      379 		then do;
      380 		     do aj = 1 to last;
      381 			if nm (j) = whotab.person (aj)
      382 			then if pj (j) = whotab.project (aj)
      383 			     then if whotab.proc_type (aj) ^= 2
      384 				then hmucnt = hmucnt + 1;
      385 				else abscnt = abscnt + 1;
      386 		     end;
      387 		     call ioa_ ("^a.^a = ^d + ^d*", nm (j), pj (j), hmucnt, abscnt);
      388 		end;
      389 		else do;				/* selected name counting */
      390 		     do aj = 1 to last;
      391 
      392 			if nm (j) = whotab.person (aj) then
      393 			     if whotab.proc_type (aj) ^= 2
      394 			     then hmucnt = hmucnt + 1;
      395 			     else abscnt = abscnt + 1;
      396 		     end;
      397 		     call ioa_ ("^a = ^d + ^d*", nm (j), hmucnt, abscnt);
      398 		end;
      399 	end;
      400 	return;
      401 
      402 who_init: entry (system_directory);			/* entry used for testing who command */
      403 
      404 dcl  system_directory char (*);
      405 
      406 	sysdir = system_directory;			/* copy name of directory containing who table */
      407 
      408 	whoptr = null;				/* set pointer to null */
      409 
      410 	return;
      411 
      412      end who;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/04/87  1539.1  who.pl1                           >special_ldd>install>MR12.1-1054>who.pl1
94           1    01/18/85  0953.2  whotab.incl.pl1                   >ldd>include>whotab.incl.pl1
96           2    08/04/87  1140.0  installation_parms.incl.pl1       >spec>install>1056>installation_parms.incl.pl1
2-148        3    11/21/79  1458.3  rcp_init_flags.incl.pl1           >ldd>include>rcp_init_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
abs                             000120 automatic       bit(1)                   initial dcl 54 set ref 54* 142* 145* 181 182* 185
                                                                                  251 305
abs_users                54            based           fixed bin(17,0)          level 2 dcl 1-10 set ref 204 218 218* 246 246*
abscnt                          000116 automatic       fixed bin(17,0)          initial dcl 54 set ref 54* 365* 372* 372 374* 385*
                                                                                  385 387* 395* 395 397*
active                  240            based           fixed bin(17,0)          array level 3 dcl 1-10 ref 296
active_fnc_err_                 000036 constant        entry                    external dcl 100 ref 131 136 151
af_sw                           000103 automatic       bit(1)                   unaligned dcl 51 set ref 127* 135* 149 155 195 292
                                                                                  311 347
after                                                  builtin function         dcl 109 ref 333 333
aj                              001160 automatic       fixed bin(17,0)          dcl 54 set ref 274* 276 277 278 279 279 282 295* 296
                                                                                  299 300 301 305 305 305 313 313 318 320 326 332
                                                                                  333 333 333 333 333 339 339 339 339 368* 369 369*
                                                                                  380* 381 381 381* 390* 392 392*
ajd                             001114 automatic       fixed bin(17,0)          dcl 54 set ref 275* 276 277 278 279 279 281
al                              000110 automatic       fixed bin(17,0)          dcl 54 set ref 140* 142 142 143 143 144 144 145 145
                                                                                  146 146 147 147 149 149 151 151 155 155 159 160
                                                                                  160 170 171 172 172 174 175 175
ap                              000106 automatic       pointer                  dcl 54 set ref 140* 142 142 143 143 144 144 145 145
                                                                                  146 146 147 147 149 149 151 155 155 159 160 170
                                                                                  171 172 174 175
arg                                    based           char                     unaligned dcl 54 set ref 142 142 143 143 144 144 145
                                                                                  145 146 146 147 147 149 149 151* 155 155 159 160*
                                                                                  170 171 172 174 175
arg_count                       000105 automatic       fixed bin(17,0)          dcl 54 set ref 124* 139
argno                           000104 automatic       fixed bin(17,0)          initial dcl 54 set ref 54* 139* 140*
before                                                 builtin function         dcl 109 ref 333 333
brief                           000124 automatic       bit(1)                   initial dcl 54 set ref 54* 154* 195 348
caller                          001032 automatic       varying char(14)         dcl 54 set ref 116* 121* 130 131* 151* 160* 166*
                                                                                  190* 210*
com_err_                        000040 constant        entry                    external dcl 100 ref 128
complain                        001164 automatic       entry variable           dcl 98 set ref 128* 136* 160 166 190 210
cu_$af_return_arg               000044 constant        entry                    external dcl 100 ref 124
cu_$arg_ptr                     000046 constant        entry                    external dcl 100 ref 140
d                               001111 automatic       fixed bin(17,0)          dcl 54 set ref 270* 271* 271 273 275 282 287
daemon                          000122 automatic       bit(1)                   initial dcl 54 set ref 54* 143* 145* 181 183* 185
                                                                                  305
date_l                          001107 automatic       fixed bin(17,0)          dcl 54 set ref 328* 329 329 329 333*
date_time_$format               000042 constant        entry                    external dcl 100 ref 214 227 230 234 326
did                             001161 automatic       fixed bin(17,0)          initial dcl 54 set ref 54* 324* 324 348
disconnected            273(01)        based           bit(1)                   array level 3 packed unaligned dcl 1-10 set ref 333*
                                                                                  339*
divide                                                 builtin function         dcl 109 ref 271
dotl                            000127 automatic       fixed bin(17,0)          dcl 54 set ref 170* 171 172 174 175 175
e                       240            based           structure                array level 2 dcl 1-10
ec                              000111 automatic       fixed bin(35,0)          dcl 54 set ref 124* 126 140* 188* 190* 208* 210*
erfno                    16            based           char(8)                  level 2 dcl 1-10 set ref 235 237 238*
error_table_$badopt             000054 external static fixed bin(17,0)          dcl 110 set ref 160*
error_table_$not_act_fnc        000056 external static fixed bin(17,0)          dcl 110 ref 126
error_table_$too_many_args      000060 external static fixed bin(17,0)          dcl 110 set ref 166*
f1                              000112 automatic       float bin(27)            dcl 54 set ref 202* 216* 244* 332* 333*
f2                              000113 automatic       float bin(27)            dcl 54 set ref 203* 216* 244*
fg_abs                  273            based           bit(1)                   array level 3 packed unaligned dcl 1-10 ref 320
fg_abs_users             66            based           fixed bin(17,0)          level 2 packed unaligned dcl 1-10 set ref 204 218
                                                                                  218* 246 246*
hbound                                                 builtin function         dcl 109 ref 165
hcs_$initiate                   000050 constant        entry                    external dcl 100 ref 188 208
hmucnt                          000115 automatic       fixed bin(17,0)          initial dcl 54 set ref 54* 364* 369* 369 374* 381*
                                                                                  381 387* 392* 392 397*
hmuflg                          000125 automatic       bit(1)                   initial dcl 54 set ref 54* 122* 178 196 239 255 260
idcode                  266            based           char(4)                  array level 3 dcl 1-10 set ref 333*
index                                                  builtin function         dcl 109 ref 170 328
installation_id                        based           char(32)                 level 3 dcl 2-33 set ref 215*
installation_parms                     based           structure                level 1 dcl 2-33
installation_parms_part_1              based           structure                level 1 dcl 2-40
installation_parms_resource_array_part based           structure                array level 1 unaligned dcl 2-144
interactive                     000123 automatic       bit(1)                   initial dcl 54 set ref 54* 144* 145* 181 182* 185
                                                                                  305
ioa_                            000034 constant        entry                    external dcl 100 ref 215 216 218 223 228 231 235 236
                                                                                  237 238 241 244 246 251 333 339 352 355 374 387
                                                                                  397
ip                              000012 internal static pointer                  initial dcl 54 set ref 207 208* 209 215
j                               001110 automatic       fixed bin(17,0)          dcl 54 set ref 204* 216* 244* 266* 267 267* 273* 274
                                                                                  275 281 282* 294* 295* 363* 367 369 374 377 377
                                                                                  381 381 387 387 392 397*
k                               001163 automatic       fixed bin(17,0)          dcl 54 set ref 298* 299 299 300 301 301*
last                            001112 automatic       fixed bin(17,0)          dcl 54 set ref 259* 264 266 270 273 294 368 380 390
laste                    76            based           fixed bin(17,0)          level 2 dcl 1-10 ref 259
lastsd                   14            based           fixed bin(71,0)          level 2 dcl 1-10 set ref 234* 236
long                            000117 automatic       bit(1)                   initial dcl 54 set ref 54* 157* 198 206 325
mark                            001162 automatic       char(3)                  dcl 54 set ref 318* 320* 322* 333* 339*
max_abs_users            53            based           fixed bin(17,0)          level 2 dcl 1-10 set ref 218 218* 246 246*
mxunits                   2            based           fixed bin(17,0)          level 2 dcl 1-10 ref 203
n_daemons                55            based           fixed bin(17,0)          level 2 dcl 1-10 set ref 204 216* 244*
n_units                   3            based           fixed bin(17,0)          level 2 dcl 1-10 ref 202
n_users                   1            based           fixed bin(17,0)          level 2 dcl 1-10 set ref 204 216* 244*
nextsd                   10            based           fixed bin(71,0)          level 2 dcl 1-10 set ref 224 227*
nm                              000130 automatic       char(24)                 array dcl 54 set ref 165 169* 171* 174* 299 301 351
                                                                                  367 377 381 387* 392 397*
null                                                   builtin function         dcl 109 ref 187 189 207 209 408
only_abs                        000121 automatic       bit(1)                   initial dcl 54 set ref 54* 185* 198 218* 218* 222
                                                                                  246* 246*
part_1                                 based           structure                level 2 dcl 2-33
person                  241            based           char(28)                 array level 3 dcl 1-10 set ref 277 277 279 279 299
                                                                                  313 333* 339* 381 392
pj                              000604 automatic       char(12)                 array dcl 54 set ref 169* 172* 175* 299 300 301 369
                                                                                  374* 377 381 387*
proc_type               270            based           fixed bin(17,0)          array level 3 dcl 1-10 ref 305 305 305 318 369 381
                                                                                  392
project                 250            based           char(28)                 array level 3 dcl 1-10 set ref 278 278 279 279 300
                                                                                  301 313 333* 339* 369 381
rcp_init_flags                         based           structure                level 1 packed unaligned dcl 3-8
requote_string_                 000052 constant        entry                    external dcl 100 ref 313
return_arg                             based           varying char             dcl 48 set ref 292* 312 312* 312 313* 313
return_len                      000102 automatic       fixed bin(17,0)          dcl 50 set ref 124* 292 312 313
return_ptr                      000100 automatic       pointer                  dcl 49 set ref 124* 292 312 312 312 313 313
rtrim                                                  builtin function         dcl 109 ref 313 313
selx                            000126 automatic       fixed bin(17,0)          initial dcl 54 set ref 54* 164* 164 165 169 169 171
                                                                                  172 174 175 183 197 239 255 297 298 351 363
sort                            000114 automatic       fixed bin(17,0)          initial dcl 54 set ref 54* 146* 147* 178 276 277 278
sort_arg                        001077 automatic       char(32)                 initial unaligned dcl 54 set ref 54*
sort_array                      000100 automatic       fixed bin(17,0)          array dcl 264 set ref 267* 274 275 281* 282* 295
sss                             001115 automatic       char(1)                  initial dcl 54 set ref 54* 351* 352*
substr                                                 builtin function         dcl 109 set ref 159 172 174 175 329 329 329*
suspended               273(02)        based           bit(1)                   array level 3 packed unaligned dcl 1-10 set ref 333*
                                                                                  339*
swap                            001113 automatic       fixed bin(17,0)          dcl 54 set ref 272* 283* 283 286
sysdir                          000014 internal static char(64)                 initial dcl 54 set ref 188* 190* 208* 406*
sysid                   121            based           char(32)                 level 2 dcl 1-10 set ref 215* 244*
system_directory                       parameter       char                     unaligned dcl 404 ref 402 406
time                            001116 automatic       varying char(64)         initial dcl 54 set ref 54* 214* 223* 227* 228* 231*
                                                                                  234* 235* 237* 238* 326* 328 329 329* 331 333 333
                                                                                  333 333
time1                           001137 automatic       varying char(64)         initial dcl 54 set ref 54* 230* 231* 291* 329 331*
timeon                  262            based           fixed bin(71,0)          array level 3 dcl 1-10 set ref 276 276 326*
timeup                    4            based           fixed bin(71,0)          level 2 dcl 1-10 set ref 214*
units                   264            based           fixed bin(17,0)          array level 3 dcl 1-10 ref 332
until                    12            based           fixed bin(71,0)          level 2 dcl 1-10 set ref 228 230*
whoptr                          000010 internal static pointer                  initial dcl 54 set ref 187 188* 189 202 203 204 204
                                                                                  204 204 214 215 216 216 218 218 218 218 218 218
                                                                                  224 225 227 228 230 234 235 236 237 238 244 244
                                                                                  244 246 246 246 246 246 246 259 276 276 277 277
                                                                                  278 278 279 279 279 279 296 299 300 301 305 305
                                                                                  305 313 313 318 320 326 332 333 333 333 333 333
                                                                                  339 339 339 339 369 369 381 381 381 392 392 408*
whotab                                 based           structure                level 1 dcl 1-10
why                     201            based           char(124)                level 2 in structure "whotab" dcl 1-10 in procedure
                                                                                  "who" ref 225
why                             001037 automatic       char(128)                dcl 54 in procedure "who" set ref 225* 226 226* 228*
                                                                                  231*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Automatic_authentication               internal static fixed bin(17,0)          initial dcl 3-16
Manual_authentication                  internal static fixed bin(17,0)          initial dcl 3-16
No_authentication                      internal static fixed bin(17,0)          initial dcl 3-16
Nominal_authentication                 internal static fixed bin(17,0)          initial dcl 3-16
WHOTAB_VERSION_1                       internal static fixed bin(17,0)          initial dcl 1-96
authentication_level_names             internal static char(12)                 initial array unaligned dcl 3-21
installation_parms_version_1           internal static fixed bin(17,0)          initial dcl 2-37
installation_parms_version_2           internal static fixed bin(17,0)          initial dcl 2-38
rifp                                   automatic       pointer                  dcl 3-6

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_AF_OPT                      000774 constant        label                    dcl 151 ref 155
bad_opt                         001055 constant        label                    dcl 160 ref 178
check_hmu                       002513 constant        label                    dcl 255 ref 222
count                           003613 constant        label                    dcl 363 ref 260
go                              001251 constant        label                    dcl 187
head                            001400 constant        label                    dcl 202 ref 196
hmu                             000514 constant        entry                    external dcl 119
how_many_users                  000524 constant        entry                    external dcl 119
ic                              002676 constant        label                    dcl 281 ref 276 277 278
join                            000541 constant        label                    dcl 124 ref 117
pass                            002554 constant        label                    dcl 271 ref 286 287
print                           003033 constant        label                    dcl 305 ref 297 299 300 301
print_abs_totals                002433 constant        label                    dcl 246 ref 201
print_long_abs_totals           001662 constant        label                    dcl 218 ref 198
shell_sort                      002517 constant        label                    dcl 259 ref 239
skip                            003533 constant        label                    dcl 343 ref 296 303 305 315
who                             000500 constant        entry                    external dcl 12
who_init                        004152 constant        entry                    external dcl 402

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4366        4450    4206        4376
Length      4750    4206        62         264     157          24

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
who                                 801 external procedure  is an external procedure.  
begin block on line 262             180 begin block         uses auto adjustable storage.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 whoptr                      who
000012 ip                          who
000014 sysdir                      who

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 262  000100 sort_array                  begin block on line 262
who                      000100 return_ptr                  who
                         000102 return_len                  who
                         000103 af_sw                       who
                         000104 argno                       who
                         000105 arg_count                   who
                         000106 ap                          who
                         000110 al                          who
                         000111 ec                          who
                         000112 f1                          who
                         000113 f2                          who
                         000114 sort                        who
                         000115 hmucnt                      who
                         000116 abscnt                      who
                         000117 long                        who
                         000120 abs                         who
                         000121 only_abs                    who
                         000122 daemon                      who
                         000123 interactive                 who
                         000124 brief                       who
                         000125 hmuflg                      who
                         000126 selx                        who
                         000127 dotl                        who
                         000130 nm                          who
                         000604 pj                          who
                         001032 caller                      who
                         001037 why                         who
                         001077 sort_arg                    who
                         001107 date_l                      who
                         001110 j                           who
                         001111 d                           who
                         001112 last                        who
                         001113 swap                        who
                         001114 ajd                         who
                         001115 sss                         who
                         001116 time                        who
                         001137 time1                       who
                         001160 aj                          who
                         001161 did                         who
                         001162 mark                        who
                         001163 k                           who
                         001164 complain                    who

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_g_a               alloc_char_temp     cat_realloc_chars   enter_begin_block   leave_begin_block
call_ent_var_desc   call_ext_out_desc   call_ext_out        return_mac          alloc_auto_adj      shorten_stack
ext_entry           ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               com_err_                      cu_$af_return_arg             cu_$arg_ptr
date_time_$format             hcs_$initiate                 ioa_                          requote_string_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$not_act_fnc      error_table_$too_many_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     54 000450        12 000477       116 000506       117 000512       119 000513       121 000532       122 000537
    124 000541       126 000556       127 000562       128 000563       129 000567       130 000570       131 000575
    132 000621       135 000622       136 000624       139 000630       140 000637       142 000654       143 000671
    144 000704       145 000717       146 000734       147 000747       149 000762       151 000774       152 001030
    154 001031       155 001034       157 001046       159 001051       160 001055       161 001107       164 001110
    165 001111       166 001114       167 001131       169 001132       170 001146       171 001160       172 001167
    174 001201       175 001207       178 001217       179 001223       181 001225       182 001233       183 001236
    185 001241       187 001251       188 001256       189 001323       190 001330       191 001361       195 001362
    196 001366       197 001370       198 001372       201 001377       202 001400       203 001405       204 001411
    206 001421       207 001423       208 001427       209 001475       210 001502       211 001525       214 001526
    215 001572       216 001617       218 001655       222 001727       223 001732       224 001755       225 001761
    226 001764       227 001773       228 002036       230 002066       231 002131       234 002160       235 002225
    236 002260       237 002273       238 002321       239 002344       241 002351       242 002365       244 002366
    246 002426       251 002500       255 002513       259 002517       260 002523       262 002525       264 002530
    266 002535       267 002546       268 002550       270 002552       271 002554       272 002561       273 002562
    274 002574       275 002577       276 002604       277 002621       278 002643       279 002665       281 002676
    282 002702       283 002705       285 002706       286 002710       287 002712       291 002715       292 002721
    294 002724       295 002734       296 002737       297 002744       298 002746       299 002756       300 003003
    301 003012       302 003030       303 003032       305 003033       311 003054       312 003056       313 003073
    315 003210       318 003212       320 003217       322 003226       324 003230       325 003231       326 003233
    328 003277       329 003310       331 003320       332 003325       333 003334       337 003464       339 003466
    343 003533       345 003536       347 003537       348 003541       351 003545       352 003556       355 003601
    358 003612       363 003613       364 003623       365 003624       367 003625       368 003633       369 003643
    372 003667       373 003670       374 003672       377 003724       380 003742       381 003751       385 004007
    386 004010       387 004012       388 004053       390 004054       392 004063       395 004107       396 004110
    397 004112       399 004144       400 004146       402 004147       406 004166       408 004175       410 004177


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
