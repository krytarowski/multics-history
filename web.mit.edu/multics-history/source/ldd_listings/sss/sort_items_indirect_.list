ASSEMBLY LISTING OF SEGMENT >special_ldd>install>MR12.0-1206>sort_items_indirect_.alm        
ASSEMBLED ON:	11/05/86  1038.6 mst Wed
OPTIONS USED:	list 
ASSEMBLED BY:	ALM Version  6.7  October 1986  
ASSEMBLER CREATED:	10/08/86  1557.5 mst Wed

                                     1  " **********************************************************************
                                     2  " *                                                                    *
                                     3  " * This is in the PUBLIC DOMAIN and may be copied without permission. *
                                     4  " *                                                                    *
                                     5  " **********************************************************************
    000000                           6  sort_items_indirect_:			"just a program label
                                     7  
    000000                           8  	name sort_items_indirect_		"define objectname
                                     9  
                                    10  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                    11  "sort_items_indirect_.alm is an adapted descendant of sort_items_.alm,
                                    12  "   written at AFDSC/CMMS.  The program provides a generalized facility for
                                    13  "   sorting data items based on a field that resides at varying offsets
                                    14  "   from the beginning of the item.  It uses a vector of indices of the
                                    15  "   items to be sorted and a vector of unaligned pointers to the fields
                                    16  "   on which to perform the sort.  The program sorts the indices,
                                    17  "   leaving the pointers and information untouched.  This program is
                                    18  "   written to replace the system program sort_items_indirect_.  Entry
                                    19  "   points are identical, with only the algorithm changed.
                                    20  "The outstanding feature of sort_items_indirect_.alm is its heavy dependence
                                    21  "   on hardware registers as program storage.  This reduces the necessity
                                    22  "   to access main memory and allows the program to operate more directly
                                    23  "   on the hardware.
                                    24  "The algorithm used by the program is the heapsort algorithm as stated by
                                    25  "   Knuth's "The Art of Computer Programming", (vol. 3, pp 146-147) with
                                    26  "   the modification suggested in Exercise 18 (problem pg 158, answer pg 618).
                                    27  "There are three major coding sections: init, fix_heap, and sort_heap.
                                    28  "   Each section will document current register usage.
                                    29  "The maximum number of data items is 261119!!
                                    30  
                                    31  "Written March 1982 @ AFDSC/CMMS by LT F. Patrick Clark, USAF and
                                    32  "   Lee A. Newcomb, HISI.
                                    33  "Modified April, 1983 by LT F. Patrick Clark (AFDSC/CMMS) to change
                                    34  "   sub_err_ flag parameter, fix bugs in $general entry handling and
                                    35  "   index array initialization and clean up documentation.
                                    36  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                    37  "
                                    38  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                    39  "ENTRIES:
                                    40  "   1) sort_items_indirect_$fixed_bin - sorts fixed bin (35) numbers
                                    41  "   declaration --> declare sort_items_indirect_$fixed_bin entry (ptr, ptr);
                                    42  "   usage --> call sort_items_indirect_$fixed_bin (vec_ptr, ind_ptr);
                                    43  "
                                    44  "   2) sort_items_indirect_$float_bin - sorts float bin (63) numbers
                                    45  "   declaration --> declare sort_items_indirect_$float_bin entry (ptr, ptr);
                                    46  "   usage --> call sort_items_indirect_$float_bin (vec_ptr, ind_ptr);
                                    47  "
                                    48  "   3) sort_items_indirect_$char - sorts nonvarying character strings
                                    49  "   declaration --> declare sort_items_indirect_$char entry (ptr, ptr, fixed bin (24));
                                    50  "   usage --> call sort_items_indirect_$char (vec_ptr, ind_ptr, str_length);
                                    51  "
                                    52  "   4) sort_items_indirect_$bit - sorts nonvarying bit strings
                                    53  "   declaration --> declare sort_items_indirect_$bit entry (ptr, ptr, fixed bin (24));
                                    54  "   usage --> call sort_items_indirect_$bit (vec_ptr, ind_ptr, str_length);
                                    55  "
                                    56  "   5) sort_items_indirect_$varying_char -- sorts varying character strings
                                    57  "   declaration --> declare sort_items_indirect_$varying_char entry (ptr, ptr);
                                    58  "   usage --> call sort_items_indirect_$varying_char (vec_ptr, ind_ptr);
                                    59  "
                                    60  "   6) sort_items_indirect_$adj_char -- sorts varying length character strings based
                                    61  "		on array of string lengths
                                    62  "   declaration --> declare sort_items_indirect_$adj_char entry (ptr, ptr, ptr);
                                    63  "   usage --> call sort_items_indirect_$adj_char (vec_ptr, ind_ptr, len_ptr);
                                    64  "
                                    65  "   7) sort_items_indirect_$general -- sorts items based on a user defined function
                                    66  "   declaration --> declare sort_items_indirect_$general entry (ptr, ptr, entry);
                                    67  "   usage --> call sort_items_indirect_$general (vec_ptr, ind_ptr, function_name);
                                    68  "
                                    69  "   where:
                                    70  "      vec_ptr - points to a structure of pointers of items to be sorted.  It has
                                    71  "	the form:
                                    72  "		dcl 01 vec aligned,
                                    73  "		       02 n fixed bin (24),
                                    74  "		       02 vector (vec.n) ptr unaligned;
                                    75  "      ind_ptr - points to a structure of indices of the items to be sorted.  It has
                                    76  "	the form:
                                    77  "		dcl 01 ind aligned,
                                    78  "		       02 n fixed bin (24),
                                    79  "		       02 index (vec.n) fixed bin (24);
                                    80  "      len_ptr - points to a structure of lengths of unaligned character strings to be sorted.
                                    81  "	It has the form:
                                    82  "		dcl 01 len aligned,
                                    83  "		       02 n fixed bin (24),
                                    84  "		       02 length (vec.n) fixed bin (24);
                                    85  "      str_length - data string length for $bit or $char entries.
                                    86  "      function_name - name of a user defined function which states the
                                    87  "	relationship between two data items.  It must have the following
                                    88  "	format:
                                    89  "	declaration --> declare function entry (ptr unaligned, ptr unaligned)
                                    90  "			returns (fixed bin (1));
                                    91  "	usage --> value = function (ptr_1st_item, ptr_2nd_item);
                                    92  "
                                    93  "	where:
                                    94  "	   ptr_1st_item - is an unaligned ptr to the first data item
                                    95  "	   ptr_2nd_item - is an unaligned ptr to the second data item
                                    96  "	   value - is the result of comparing the two items.  It can be:
                                    97  "	      < 0 => first item < second item
                                    98  "	      >=0 => first item >= second item
                                    99  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                   100  "
                                   101  "the seven entries
                        000127     102  	 entry fixed_bin,float_bin,char,bit,varying_char,adj_char,general
                                   103  
                                   104  "define stack frame temporaries, largest first
                                   105  	temp8	arg_list_1,arg_list_2,arg_list_3	"area for arg lists
                                   106  	tempd	arg_list_4		"arg list area, connected to temp8's above
                                   107  	temp	general_pptr_1,general_pptr_2,general_value	"$general function args
                                   108  	temp	N_in_upper,N_in_lower	"temporaries
                                   109  	temp	error_value		"error value for sub_err_
                                   110  
                                   111  "define constants for sub_err_ call
    000000                         112  total_items_err_msg:
    000000  aa  111 164 145 155    113  	aci	/Item count outside legal bounds./
    000001  aa  040 143 157 165
    000002  aa  156 164 040 157
    000003  aa  165 164 163 151
    000004  aa  144 145 040 154
    000005  aa  145 147 141 154
    000006  aa  040 142 157 165
    000007  aa  156 144 163 056
                                   114  
    000010                         115  string_length_err_msg:
    000010  aa  104 141 164 141    116  	aci	/Data length ouside legal bounds./
    000011  aa  040 154 145 156
    000012  aa  147 164 150 040
    000013  aa  157 165 163 151
    000014  aa  144 145 040 154
    000015  aa  145 147 141 154
    000016  aa  040 142 157 165
    000017  aa  156 144 163 056
                                   117  
    000020                         118  program_name:
    000020  aa  163 157 162 164    119  	aci	/sort_items_/
    000021  aa  137 151 164 145
    000022  aa  155 163 137 000
                                   120  
    000023                         121  sub_err_flag:
    000023  aa   000000 000000     122  	oct	000000000000
                                   123  
    000024                         124  fixed_35_desc:
    000024  aa   404000 000043     125  	oct	404000000043
                                   126  
    000025                         127  program_name_desc:
    000025  aa   526000 000013     128  	oct	526000000013
                                   129  
    000026                         130  sub_err_flag_desc:
    000026  aa   516000 000044     131  	oct	516000000044
                                   132  
    000027                         133  ptr_desc:
    000027  aa   464000 000000     134  	oct	464000000000
                                   135  
    000030                         136  err_msg_desc:
    000030  aa   526000 000040     137  	oct	526000000040
                                   138  "
                                   139  	include	stack_header
                                   1-1  "	BEGIN INCLUDE FILE ... stack_header.incl.alm  3/72  Bill Silver
                                   1-2  "
                                   1-3  "	modified 7/76 by M. Weaver for *system links and more system use of areas
                                   1-4  "	modified 3/77 by M. Weaver  to add rnt_ptr
                                   1-5  "	modified 7/77 by S. Webber to add run_unit_depth and assign_linkage_ptr
                                   1-6  "	modified 6/83 by J. Ives to add trace_frames and in_trace.
                                   1-7  
                                   1-8  " HISTORY COMMENTS:
                                   1-9  "  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
                                  1-10  "     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
                                  1-11  "     added the heap_header_ptr definition
                                  1-12  "  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
                                  1-13  "     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
                                  1-14  "     Modified to support control point management.  These changes were
                                  1-15  "     actually made in February 1985 by G. Palter.
                                  1-16  "  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
                                  1-17  "     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
                                  1-18  "     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
                                  1-19  "     bit pad after cur_lot_size for the cpm_enabled. This was done to save
                                  1-20  "     some space int the stack header and change the cpd_ptr unal to
                                  1-21  "     cpm_data_ptr (ITS pair).
                                  1-22  "                                                      END HISTORY COMMENTS
                                  1-23  
                        000004    1-24  	equ	stack_header.cpm_data_ptr,4		ptr to control point for this stack
                        000006    1-25  	equ	stack_header.combined_stat_ptr,6	ptr to separate static area
                                  1-26  
                        000010    1-27  	equ	stack_header.clr_ptr,8		ptr to area containing linkage sections
                        000012    1-28  	equ	stack_header.max_lot_size,10		number of words allowed in lot (DU)
                        000012    1-29  	equ	stack_header.main_proc_invoked,10	nonzero if main proc was invoked in run unit (DL)
                        000012    1-30  	equ	stack_header.run_unit_depth,10	number of active run units stacked (DL)
                        000013    1-31  	equ	stack_header.cur_lot_size,11		DU number of words (entries) in lot
                        000013    1-32            equ	stack_header.cpm_enabled,11		DL  non-zero if control point management is enabled
                        000014    1-33  	equ	stack_header.system_free_ptr,12	ptr to system storage area
                        000016    1-34  	equ	stack_header.user_free_ptr,14		ptr to user storage area
                                  1-35  
                        000020    1-36  	equ	stack_header.parent_ptr,16		ptr to parent stack or null
                        000022    1-37  	equ	stack_header.stack_begin_ptr,18	ptr to first stack frame
                        000024    1-38  	equ	stack_header.stack_end_ptr,20		ptr to next useable stack frame
                        000026    1-39  	equ	stack_header.lot_ptr,22		ptr to the lot for the current ring
                                  1-40  
                        000030    1-41  	equ	stack_header.signal_ptr,24		ptr to signal proc for current ring
                        000032    1-42  	equ	stack_header.bar_mode_sp,26		value of sp before entering bar mode
                        000034    1-43  	equ	stack_header.pl1_operators_ptr,28	ptr: pl1_operators_$operator_table
                        000036    1-44  	equ	stack_header.call_op_ptr,30		ptr to standard call operator
                                  1-45  
                        000040    1-46  	equ	stack_header.push_op_ptr,32		ptr to standard push operator
                        000042    1-47  	equ	stack_header.return_op_ptr,34		ptr to standard return operator
                        000044    1-48  	equ	stack_header.ret_no_pop_op_ptr,36	ptr: stand. return/ no pop operator
                        000046    1-49  	equ	stack_header.entry_op_ptr,38		ptr to standard entry operator
                                  1-50  
                        000050    1-51  	equ	stack_header.trans_op_tv_ptr,40	ptr to table of translator operator ptrs
                        000052    1-52  	equ	stack_header.isot_ptr,42		pointer to ISOT
                        000054    1-53  	equ	stack_header.sct_ptr,44		pointer to System Condition Table
                        000056    1-54  	equ	stack_header.unwinder_ptr,46		pointer to unwinder for current ring
                                  1-55  
                        000060    1-56  	equ	stack_header.sys_link_info_ptr,48	ptr to *system link name table
                        000062    1-57  	equ	stack_header.rnt_ptr,50		ptr to reference name table
                        000064    1-58  	equ	stack_header.ect_ptr,52		ptr to event channel table
                        000066    1-59  	equ	stack_header.assign_linkage_ptr,54	ptr to area for hcs_$assign_linkage calls
                        000070    1-60  	equ	stack_header.heap_header_ptr,56	ptr to heap header.
                        000072    1-61  	equ	stack_header.trace_frames,58		stack of trace_catch_ frames
                        000073    1-62  	equ	stach_header.trace_top_ptr,59		trace pointer
                        000074    1-63  	equ	stack_header.in_trace,60		trace antirecurse bit
                        000100    1-64  	equ	stack_header_end,64			length of stack header
                                  1-65  
                                  1-66  
                                  1-67  
                                  1-68  
                        000000    1-69  	equ	trace_frames.count,0		number of trace frames on stack
                        000001    1-70  	equ	trace_frames.top_ptr,1		packed pointer to top one
                                  1-71  
                                  1-72  "	The  following constant is an offset within the  pl1  operators table.
                                  1-73  "	It  references a  transfer vector table.
                                  1-74  
                        000551    1-75  	bool	tv_offset,551
                                  1-76  
                                  1-77  
                                  1-78  "	The  following constants are offsets within this transfer vector table.
                                  1-79  
                        001170    1-80  	equ	call_offset,tv_offset+271
                        001171    1-81  	equ	push_offset,tv_offset+272
                        001172    1-82  	equ	return_offset,tv_offset+273
                        001173    1-83  	equ	return_no_pop_offset,tv_offset+274
                        001174    1-84  	equ	entry_offset,tv_offset+275
                                  1-85  
                                  1-86  
                                  1-87  " 	END INCLUDE FILE stack_header.incl.alm
                                   140  "
                                   141  	include	stack_frame
                                   2-1  "
                                   2-2  "	BEGIN INCLUDE FILE ... stack_frame.incl.alm   6/72 RBS
                                   2-3  "
                                   2-4  " Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr
                                   2-5  " Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager_bit & main_proc_bit
                                   2-6  " Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr
                                   2-7  "
                        000020     2-8  	equ	stack_frame.prev_sp,16
                        000020     2-9  	equ	stack_frame.condition_word,16
                        000022    2-10  	equ	stack_frame.next_sp,18
                        000022    2-11  	equ	stack_frame.signaller_word,18
                        000024    2-12  	equ	stack_frame.return_ptr,20
                        000026    2-13  	equ	stack_frame.entry_ptr,22
                        000030    2-14  	equ	stack_frame.operator_ptr,24
                        000030    2-15  	equ	stack_frame.lp_ptr,24
                        000032    2-16  	equ	stack_frame.arg_ptr,26
                        000034    2-17  	equ	stack_frame.static_ptr,28
                        000035    2-18  	equ	stack_frame.support_ptr,29	" only used by fortran I/O
                        000036    2-19  	equ	stack_frame.on_unit_rel_ptrs,30
                        000037    2-20  	equ	stack_frame.operator_ret_ptr,31
                        000037    2-21  	equ	stack_frame.translator_id,31
                        000040    2-22  	equ	stack_frame.regs,32
                        000060    2-23  	equ	stack_frame.min_length,48
                        000020    2-24  	equ	stack_frame.flag_word,16
                        020000    2-25  	bool	stack_frame.main_proc_bit,020000	(DL)
                        010000    2-26  	bool	stack_frame.run_unit_manager,010000	(DL)
                        004000    2-27  	bool	stack_frame.signal_bit,004000		(DL)
                        002000    2-28  	bool	stack_frame.crawl_out_bit,002000	(DL)
                        001000    2-29  	bool	stack_frame.signaller_bit,001000	(DL)
                        000400    2-30  	bool	stack_frame.link_trap_bit,000400	(DL)
                        000200    2-31  	bool	stack_frame.support_bit,000200	(DL)
                        000100    2-32  	bool	stack_frame.condition_bit,000100	(DL)
                                  2-33  
                                  2-34  "
                                  2-35  "	END INCLUDE FILE  ... stack_frame.incl.alm
                                  2-36  "
                                   142  "
                                   143  "We use label arrays similar to those used by PL/1 in code generation.
    000031                         144  label_vec_A:				"for 1st case statement
    000031  0a   000310 7100 00    145  	tra  	compare0_A
    000032  0a   000343 7100 00    146  	tra	compare1_A
    000033  0a   000360 7100 00    147  	tra	compare2_A
    000034  0a   000375 7100 00    148  	tra	compare3_A
    000035  0a   000414 7100 00    149  	tra	compare4_A
    000036  0a   000433 7100 00    150  	tra	compare5_A
    000037  0a   000456 7100 00    151  	tra	compare6_A
                                   152  
    000040                         153  label_vec_B:				"for 2nd case statement
    000040  0a   000325 7100 00    154  	tra	compare0_B
    000041  0a   000351 7100 00    155  	tra	compare1_B
    000042  0a   000366 7100 00    156  	tra	compare2_B
    000043  0a   000404 7100 00    157  	tra	compare3_B
    000044  0a   000423 7100 00    158  	tra	compare4_B
    000045  0a   000444 7100 00    159  	tra	compare5_B
    000046  0a   000467 7100 00    160  	tra	compare6_B
                                   161  
    000047                         162  label_vec_C:				"for 3rd case statement
    000047  0a   000536 7100 00    163  	tra	compare0_C
    000050  0a   000600 7100 00    164  	tra	compare1_C
    000051  0a   000624 7100 00    165  	tra	compare2_C
    000052  0a   000650 7100 00    166  	tra	compare3_C
    000053  0a   000676 7100 00    167  	tra	compare4_C
    000054  0a   000724 7100 00    168  	tra	compare5_C
    000055  0a   000756 7100 00    169  	tra	compare6_C
                                   170  
    000056                         171  label_vec_D:				"for 4th case statemtent
    000056  0a   000555 7100 00    172  	tra	compare0_D
    000057  0a   000610 7100 00    173  	tra	compare1_D
    000060  0a   000634 7100 00    174  	tra	compare2_D
    000061  0a   000661 7100 00    175  	tra	compare3_D
    000062  0a   000707 7100 00    176  	tra	compare4_D
    000063  0a   000737 7100 00    177  	tra	compare5_D
    000064  0a   000771 7100 00    178  	tra	compare6_D
                                   179  "
    000065                         180  init:					"just a section label
                                   181  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                   182  "This is the init section of sort_items_indirect_.  Each of the seven entries
                                   183  "   pushes a stack frame and sets registers as needed.  The parameters
                                   184  "   of the entry points are found and put in registers or local storage
                                   185  "   in order to eliminate the parameter passing mechanisms usually needed
                                   186  "   for each reference.
                                   187  "This section also gets and verifies the third parameter of the entries
                                   188  "   that have one.  The $char and $bit entries put the parameter in $A,
                                   189  "   WHICH MUST NOT BE CHANGED BY ANY OTHER PART OF THOSE ENTRIES!!  The
                                   190  "   $general entry creates the function argument list and sets $PR0 to
                                   191  "   point to it, and sets $PR2 to point to the function entry value.  The
                                   192  "   $adj_char entry sets $PR2 to point to the character string length base.
                                   193  "   Register usage is as follows:
                                   194  "   PR0 -- initially is addr (agrument list)
                                   195  "	 later has addr (arg_list) {$general entry ONLY!!}
                                   196  "   PR2 -- function entry ptr {$general entry ONLY!!}
                                   197  "	 addr (adjustable length array base) {$adj_char entry ONLY!!}
                                   198  "   PR4 -- addr (linkage section)
                                   199  "   PR5 -- addr (ptr array base)
                                   200  "   PR6 -- addr (stack frame)
                                   201  "   PR7 -- initially is addr (stack base)
                                   202  "	 later has addr (vector array base)
                                   203  "   X7 -- data type as defined by entry point called
                                   204  "   A -- data string length {$char, $bit entries ONLY!!}
                                   205  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                   206  
                                   207  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    000065                         208  fixed_bin:				"entry (vec_ptr, index_ptr)
    000065  aa   000120 6270 00    209  	push
    000066  aa  7 00040 2721 20
    000067  aa   000001 2270 03    210  	ldx7	1,du			"data type by definition
    000070  aa   000131 7100 04    211  	tra	common-*,ic		"go get parameters
                                   212  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    000071                         213  float_bin:				"entry (vec_ptr, index_ptr)
    000071  aa   000120 6270 00    214  	push
    000072  aa  7 00040 2721 20
    000073  aa   000002 2270 03    215  	ldx7	2,du			"data type by definition
    000074  aa   000125 7100 04    216  	tra	common-*,ic		"go get parameters
                                   217  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    000075                         218  char:					"entry (vec_ptr, index_ptr, str_length)
    000075  aa   000120 6270 00    219  	push
    000076  aa  7 00040 2721 20
    000077  aa   000003 2270 03    220  	ldx7	3,du			"data type by definition
    000100  aa  0 00006 3515 20    221  	epp1	pr0|6,*			"addr (data string length)
    000101  aa  1 00000 2361 00    222  	ldq	pr1|0			"data string length
    000102  aa   000050 6040 04    223  	tmi	string_length_err-*,ic	"if < 0, got bad arg
    000103  aa   000002 7320 00    224  	qrs	2			"convert characters to words
    000104  aa   000044 7100 04    225  	tra	string_length_compare-*,ic	"validate arg
                                   226  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                                   227  "
    000105                         228  bit:					"entry (vec_ptr, index_ptr, str_length)
    000105  aa   000120 6270 00    229  	push
    000106  aa  7 00040 2721 20
    000107  aa   000004 2270 03    230  	ldx7	4,du			"data type by definition
    000110  aa  0 00006 3515 20    231  	epp1	pr0|6,*			"addr (data string length)
    000111  aa  1 00000 2361 00    232  	ldq	pr1|0			"data string length
    000112  aa   000040 6040 04    233  	tmi	string_length_err-*,ic	"if < 0, got bad arg
    000113  aa   000044 5060 07    234  	div	36,dl			"convert bits to words
    000114  aa   000034 7100 04    235  	tra	string_length_compare-*,ic	"validate arg
                                   236  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    000115                         237  varying_char:				"entry (vec_ptr, index_ptr)
    000115  aa   000120 6270 00    238  	push
    000116  aa  7 00040 2721 20
    000117  aa   000005 2270 03    239  	ldx7	5,du			"data type by definition
    000120  aa   000101 7100 04    240  	tra	common-*,ic		"go get parameters
                                   241  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    000121                         242  adj_char:					"entry (vec_ptr, index_ptr, length_ptr)
    000121  aa   000120 6270 00    243  	push
    000122  aa  7 00040 2721 20
    000123  aa   000006 2270 03    244  	ldx7	6,du			"data type by definition
    000124  aa  0 00006 3515 20    245  	epp1	pr0|6,*			"addr (addr (adjustable length array base))
    000125  aa  1 00000 3521 20    246  	epp2	pr1|0,*			"addr (adjustable length array base)
    000126  aa   000073 7100 04    247  	tra	common-*,ic		"go get parameters
                                   248  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    000127                         249  general:					"entry (vec_ptr, index_ptr, function)
    000127  aa   000120 6270 00    250  	push
    000130  aa  7 00040 2721 20
    000131  aa   000000 2270 03    251  	ldx7	0,du			"data type by definition
    000132  aa  0 00006 3515 20    252  	epp1	pr0|6,*			"addr (addr (entry pair))
    000133  aa  1 00002 3521 20    253  	epp2	pr1|2,*			"environment ptr
    000134  aa  6 00060 2521 00    254  	spri2	arg_list_2		"store in arg list
    000135  aa  1 00000 3521 20    255  	epp2	pr1|0,*			"addr (user function)
    000136  aa   014000 4310 07    256  	fld	6144,dl			"get arg list header
    000137  aa   000010 2750 07    257  	ora	8,dl			"call type where environment ptr is used
    000140  aa  6 00050 7571 00    258  	staq	arg_list_1		"store arg list header
    000141  aa  6 00104 3515 00    259  	epp1	general_value		"addr (return value)
    000142  aa  6 00056 2515 00    260  	spri1	arg_list_1+6		"store as 3rd parameter
    000143  aa  6 00102 3515 00    261  	epp1	general_pptr_1		"addr (1st packed ptr)
    000144  aa  6 00052 2515 00    262  	spri1	arg_list_1+2		"store as 1st parameter
    000145  aa  6 00103 3515 00    263  	epp1	general_pptr_2		"addr (2nd packed ptr)
    000146  aa  6 00054 2515 00    264  	spri1	arg_list_1+4		"store as 2nd parameter
    000147  aa   000052 7100 04    265  	tra	common-*,ic		"go get parameter
                                   266  "
    000150                         267  string_length_compare:			"verify string length
    000150  4a  4 00012 1161 20    268  	cmpq	sys_info$max_seg_size	"larger than a segment??
    000151  aa   000047 6044 04    269  	tmoz	length_good-*,ic		"no, set data length
                                   270  
    000152                         271  string_length_err:
    000152  aa   777636 3534 04    272  	epp3	string_length_err_msg-*,ic	"get error message
    000153  aa  6 00064 2535 00    273  	spri3	arg_list_2+4		"store in arg list
                                   274  
    000154                         275  sub_err_call:
    000154  4a  4 00014 2361 20    276  	ldq	error_table_$out_of_bounds	"get error value
    000155  aa  6 00107 7561 00    277  	stq	error_value		"save for sub_err_ call
    000156  aa   000014 2350 03    278  	lda	12,du			"get number of args
    000157  aa   000004 2750 07    279  	ora	4,dl			"get call type
    000160  aa   000014 2360 03    280  	ldq	12,du			"get number of descriptors
    000161  aa  6 00050 7571 00    281  	staq	arg_list_1		"store arg list header
    000162  aa  6 00107 3535 00    282  	epp3	error_value		"addr (error value)
    000163  aa  6 00052 2535 00    283  	spri3	arg_list_1+2		"store in arg list
    000164  aa   777634 3534 04    284  	epp3	program_name-*,ic		"addr (program name)
    000165  aa  6 00054 2535 00    285  	spri3	arg_list_1+4		"store in arg list
    000166  aa   777635 3534 04    286  	epp3	sub_err_flag-*,ic		"addr (sub_err_ flag)
    000167  aa  6 00056 2535 00    287  	spri3	arg_list_1+6		"store in arg list
    000170  aa  7 00020 3535 00    288  	epp3	pr7|stack_header.parent_ptr	"addr (null ptr)
    000171  aa  6 00060 2535 00    289  	spri3	arg_list_2		"store in arg list
    000172  aa  6 00104 3535 00    290  	epp3	general_value		"addr (return value)
    000173  aa  3 00000 4501 00    291  	stz	pr3|0			"zero return value
    000174  aa  6 00062 2535 00    292  	spri3	arg_list_2+2		"store in arg list
    000175  aa   777627 3534 04    293  	epp3	fixed_35_desc-*,ic		"addr (fixed bin (35) descriptor))
    000176  aa  6 00066 2535 00    294  	spri3	arg_list_2+6		"store in arg list
    000177  aa  6 00076 2535 00    295  	spri3	arg_list_3+6		"store again for return value
    000200  aa   777625 3534 04    296  	epp3	program_name_desc-*,ic	"addr (character string descriptor)
    000201  aa  6 00070 2535 00    297  	spri3	arg_list_3		"store in arg list
    000202  aa   777624 3534 04    298  	epp3	sub_err_flag_desc-*,ic	"addr (character string descriptor)
    000203  aa  6 00072 2535 00    299  	spri3	arg_list_3+2		"store in arg list
    000204  aa   777623 3534 04    300  	epp3	ptr_desc-*,ic		"addr (ptr descriptor)
    000205  aa  6 00074 2535 00    301  	spri3	arg_list_3+4		"store in arg list
    000206  aa   777622 3534 04    302  	epp3	err_msg_desc-*,ic		"get error message descriptor
    000207  aa  6 00100 2535 00    303  	spri3	arg_list_4		"store in arg list
    000210  aa  6 00000 2541 00    304  	call	sub_err_$sub_err_(arg_list_1)	"call sub_err_
    000211  aa  6 00050 3501 00
    000212  4a  4 00010 3521 20
    000213  aa  6 00040 7531 00
    000214  aa  7 00036 6701 20
    000215  aa  6 00000 1731 00
    000216  aa  6 00040 0731 00
    000217  aa  7 00042 7101 20    305  	return				"leave program
                                   306  "
    000220                         307  length_good:				"set data length in $A!!
    000220  aa  1 00000 2351 00    308  	lda	pr1|0			"get data length
                                   309  
    000221                         310  common:					"verify array ptr size is in bounds
    000221  aa  0 00002 3715 20    311  	epp5	pr0|2,*			"addr (addr (ptr array base))
    000222  aa  5 00000 3715 20    312  	epp5	pr5|0,*			"addr (ptr array base)
    000223  aa  5 00000 2361 00    313  	ldq	pr5|0			"number of items to sort
    000224  aa   000003 6040 04    314  	tmi	items_err-*,ic		"if < 0, got bad arg
    000225  4a  4 00012 1161 20    315  	cmpq	sys_info$max_seg_size	"larger than a segment??
    000226  aa   000004 6040 04    316  	tmi	n_elems_ok-*,ic		"no, continue processing
                                   317  
    000227                         318  items_err:				"have error, can't go on
    000227  aa   777551 3534 04    319  	epp3	total_items_err_msg-*,ic	"get error message
    000230  aa  6 00064 2535 00    320  	spri3	arg_list_2+4		"put in arg list
    000231  aa   777723 7100 04    321  	tra	sub_err_call-*,ic		"report problems
                                   322  
    000232                         323  n_elems_ok:
    000232  aa  6 00106 7561 00    324  	stq	N_in_lower		"store total items count
    000233  aa  0 00004 3735 20    325  	epp7	pr0|4,*			"addr (addr (vector array base))
    000234  aa  7 00000 3735 20    326  	epp7	pr7|0,*			"addr (vector array base)
    000235  aa  7 00000 7561 00    327  	stq	pr7|0			"total indices = total items
    000236  aa   000006 1070 03    328  	cmpx7	6,du			"is it $adj_char entry??
    000237  aa   000002 6010 04    329  	tnz	reset_count-*,ic		"no, initialize index array
    000240  aa  2 00000 7561 00    330  	stq	pr2|0			"total adjustable lengths = total items
                                   331  
    000241                         332  reset_count:
    000241  aa  6 00106 2361 00    333  	ldq	N_in_lower		"set indicators
    000242  aa   000007 6000 04    334  	tze	no_sort-*,ic		"if = 0, done
                                   335  
    000243                         336  init_index_array:
    000243  aa  7 00000 7561 06    337  	stq	pr7|0,ql			"set sort index
    000244  aa   000001 1760 07    338  	sbq	1,dl			"decrement index by 1
    000245  aa   777776 6010 04    339  	tnz	init_index_array-*,ic	"try again
    000246  aa  6 00106 2361 00    340  	ldq	N_in_lower		"set item count
    000247  aa   000002 1160 07    341  	cmpq	2,dl			"0 or 1 item in array??
    000250  aa   000003 6030 04    342  	trc	store_vars-*,ic		"no, have to do sort
                                   343  
    000251                         344  no_sort:					"see if we need to do sort
    000251  aa  6 00000 3731 00    345  	epbp7	pr6|0			"set $PR7 for return
    000252  aa  7 00042 7101 20    346  	return				"yes, sort finished
                                   347  
    000253                         348  store_vars: 
    000253  aa   000022 7360 00    349  	qls	18			"move total items to $QU
    000254  aa  6 00105 7561 00    350  	stq	N_in_upper		"store total items count
    000255  aa   000000 1070 03    351  	cmpx7	0,du			"is it $general entry??
    000256  aa   000002 6010 04    352  	tnz	fix_heap-*,ic		"no, start sort
    000257  aa  6 00050 3501 00    353  	epp0	arg_list_1		"yes, set $PR0 to arg list
                                   354  "
    000260                         355  fix_heap:					"just a section label
                                   356  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                   357  "This is the fix_heap section of sort_items_indirect_.  It creates a
                                   358  "   heap, which is an almost complete binary tree in which each node is
                                   359  "   less than or equal to its father.  Register usage is as follows:
                                   360  "   PR0 -- addr (arg_list) {$general entry ONLY!!}
                                   361  "   PR1 -- right son ptr (if one exists)
                                   362  "   PR2 -- function entry ptr {$general entry ONLY!!}
                                   363  "	 addr (adjustable length array base) {$adj_char entry ONLY!!}
                                   364  "   PR3 -- larger son ptr (initially assumed to be left son)
                                   365  "   PR4 -- parent ptr
                                   366  "   PR5 -- addr (ptr array base)
                                   367  "   PR6 -- addr (stack frame)
                                   368  "   PR7 -- addr (vector array base)
                                   369  "	 is temporarily set to addr (stack base) for calls {$general ONLY!!}
                                   370  "   X1 -- right son vector (if one exists)
                                   371  "   X2 -- larger son vector (initially assumed to be left son)
                                   372  "   X3 -- parent vector
                                   373  "   X4 -- larger child index (initially assumed to be left son index)
                                   374  "   X5 -- parent index
                                   375  "   X6 -- FH_do_i loop control variable
                                   376  "   X7 -- data type as defined by entry point
                                   377  "   A -- data string length {$char, $bit entries ONLY!!}
                                   378  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                   379  "
    000260  aa  6 00106 2361 00    380  	ldq	N_in_lower		"put total items in $Q
    000261  aa   000001 7720 00    381  	qrl	1			"divide by shifting bits right
    000262  aa   000000 6260 06    382  	eax6	0,ql			"load loop start value from $Q
    000263  aa   000003 7100 04    383  	tra	FH_loop_start-*,ic		"goto loop start
                                   384  
    000264                         385  FH_do_i:					"start of do i loop, or
    000264                         386  compareB_else:				"no switch was made this time, or
    000264                         387  FH_do_while_end:				"do while done, try do i again
    000264  aa  7 00000 4431 15    388  	sxl3	pr7|0,x5			"son vector = parent vector
    000265  aa   000001 1260 03    389  	sblx6	1,du			"decrement loop index by 1
                                   390  
    000266                         391  FH_loop_start:
    000266  aa   000213 6000 04    392  	tze	sort_heap-*,ic		"loop finished, go to sort_heap
    000267  aa   000000 6250 16    393  	eax5	0,x6			"loop index is parent index
    000270  aa  7 00000 7231 15    394  	lxl3	pr7|0,x5			"get parent vector
    000271  aa  5 00000 7641 13    395  	lprp4	pr5|0,x3			"get parent ptr
                                   396  
    000272                         397  FH_do_while:				"walk parent branch, swap up if son > parent
    000272  aa   000000 6360 15    398  	eaq	0,x5			"put parent index in $Q
    000273  aa   000001 7360 00    399  	qls	1			"*2, gives left son index
    000274  aa   000000 6240 02    400  	eax4	0,qu			"assume left son is larger
    000275  aa  6 00105 1041 00    401  	cmpx4	N_in_upper		"is left son index <= ptr array bound??
    000276  aa   000005 6020 04    402  	tnc	FH_two_sons-*,ic		"have two sons
    000277  aa   777765 6010 04    403  	tnz	FH_do_while_end-*,ic	"too big, try do i again
    000300  aa  7 00000 7221 14    404  	lxl2	pr7|0,x4			"get left son vector
    000301  aa  5 00000 7631 12    405  	lprp3	pr5|0,x2			"get left son ptr
    000302  0a   000040 7100 37    406  	tra	label_vec_B,x7*		"find larger of son and parent
                                   407  
    000303                         408  FH_two_sons:
    000303  aa  7 00000 7221 14    409  	lxl2	pr7|0,x4			"get left son vector
    000304  aa  5 00000 7631 12    410  	lprp3	pr5|0,x2			"get left son ptr
    000305  aa  7 00001 7211 14    411  	lxl1	pr7|1,x4			"get right son vector
    000306  aa  5 00000 7611 11    412  	lprp1	pr5|0,x1			"get right son ptr
    000307  0a   000031 7100 37    413  	tra	label_vec_A,x7*		"find larger of sons
                                   414  "
    000310                         415  compare0_A:				"for $general entry
    000310  aa  6 00102 5431 00    416  	sprp3	general_pptr_1		"store left son ptr
    000311  aa  6 00103 5411 00    417  	sprp1	general_pptr_2		"store right son ptr
                                   418  	"call pseudo-op simulated to call function
    000312  aa  6 00000 2541 00    419  	spri	pr6|0			"save all PR's
    000313  aa  6 00040 7531 00    420  	sreg	pr6|stack_frame.regs	"save rest of registers
    000314  aa  6 00000 3731 00    421  	epbp7	pr6|0			"make $PR7 point to stack base
    000315  aa  7 00036 6701 20    422  	tsp4	pr7|stack_header.call_op_ptr,*     "use stack header ptr to call
    000316  aa  6 00000 1731 00    423  	lpri	pr6|0			"reclaim our PR's
    000317  aa  6 00040 0731 00    424  	lreg	pr6|stack_frame.regs	"reclaim rest of registers
                                   425  	"test function return value
    000320  aa  6 00104 2341 00    426  	szn	general_value		"is left son data < right son data??
    000321  aa   000004 6050 04    427  	tpl	compare0_B-*,ic		"no, left son is larger
    000322  aa   000001 0240 03    428  	adlx4	1,du			"larger son index = right son index
    000323  aa   000000 6220 11    429  	eax2	0,x1			"larger son vector = right son vector
    000324  aa  1 00000 3535 00    430  	epp3	pr1|0			"larger son ptr = right son ptr
                                   431  
    000325                         432  compare0_B:				"for $general entry
    000325  aa  6 00102 5441 00    433  	sprp4	general_pptr_1		"store parent ptr
    000326  aa  6 00103 5431 00    434  	sprp3	general_pptr_2		"store son ptr
                                   435  	"call pseudo-op simulated to call function
    000327  aa  6 00000 2541 00    436  	spri	pr6|0			"save all PR's
    000330  aa  6 00040 7531 00    437  	sreg	pr6|stack_frame.regs	"save rest of registers
    000331  aa  6 00000 3731 00    438  	epbp7	pr6|0			"make $PR7 point to stack base
    000332  aa  7 00036 6701 20    439  	tsp4	pr7|stack_header.call_op_ptr,*     "use stack header ptr to call
    000333  aa  6 00000 1731 00    440  	lpri	pr6|0			"reclaim our PR's
    000334  aa  6 00040 0731 00    441  	lreg	pr6|stack_frame.regs	"reclaim rest of registers
                                   442  	"test function return value
    000335  aa  6 00104 2341 00    443  	szn	general_value		"is parent data < son data??
    000336  aa   777726 6050 04    444  	tpl	compareB_else-*,ic		"no, parent is larger
    000337  aa  7 00000 4421 15    445  	sxl2	pr7|0,x5			"parent vector = son vector
    000340  aa   000000 6250 14    446  	eax5	0,x4			"parent index = son index
    000341  aa   777731 6050 04    447  	tpl	FH_do_while-*,ic		"compare parent with new sons
    000342  aa   777722 7100 04    448  	tra	FH_do_while_end-*,ic	"if bit 0 on, parent index *2 BIG, quit
                                   449  "
    000343                         450  compare1_A:				"for $fixed_bin entry
    000343  aa  3 00000 2361 00    451  	ldq	pr3|0			"left son data
    000344  aa  1 00000 1161 00    452  	cmpq	pr1|0			"is left son data < right son data??
    000345  aa   000004 6050 04    453  	tpl	compare1_B-*,ic		"no, left son is larger
    000346  aa   000001 0240 03    454  	adlx4	1,du			"larger son index = right son index
    000347  aa   000000 6220 11    455  	eax2	0,x1			"larger son vector = right son vector
    000350  aa  1 00000 3535 00    456  	epp3	pr1|0			"larger son ptr = right son ptr
                                   457  
    000351                         458  compare1_B:				"for $fixed_bin entry
    000351  aa  4 00000 2361 00    459  	ldq	pr4|0			"parent data
    000352  aa  3 00000 1161 00    460  	cmpq	pr3|0			"is parent data < son data??
    000353  aa   777711 6050 04    461  	tpl	compareB_else-*,ic		"no, parent is larger
    000354  aa  7 00000 4421 15    462  	sxl2	pr7|0,x5			"parent vector = son vector
    000355  aa   000000 6250 14    463  	eax5	0,x4			"parent index = son index
    000356  aa   777714 6050 04    464  	tpl	FH_do_while-*,ic		"compare parent with new sons
    000357  aa   777705 7100 04    465  	tra	FH_do_while_end-*,ic	"if bit 0 on, parent index *2 BIG, quit
                                   466  "
    000360                         467  compare2_A:				"for $float_bin entry
    000360  aa  3 00000 4331 00    468  	dfld	pr3|0			"left son data
    000361  aa  1 00000 5171 00    469  	dfcmp	pr1|0			"is left son data < right son data??
    000362  aa   000004 6050 04    470  	tpl	compare2_B-*,ic		"no, left son is larger
    000363  aa   000001 0240 03    471  	adlx4	1,du			"larger son index = right son index
    000364  aa   000000 6220 11    472  	eax2	0,x1			"larger son vector = right son vector
    000365  aa  1 00000 3535 00    473  	epp3	pr1|0			"larger son ptr = right son ptr
                                   474  
    000366                         475  compare2_B:				"for $float_bin entry
    000366  aa  4 00000 4331 00    476  	dfld	pr4|0			"parent data
    000367  aa  3 00000 5171 00    477  	dfcmp	pr3|0			"is parent data < son data??
    000370  aa   777674 6050 04    478  	tpl	compareB_else-*,ic		"no, parent is larger
    000371  aa  7 00000 4421 15    479  	sxl2	pr7|0,x5			"parent vector = son vector
    000372  aa   000000 6250 14    480  	eax5	0,x4			"parent index = son index
    000373  aa   777677 6050 04    481  	tpl	FH_do_while-*,ic		"compare parent with new sons
    000374  aa   777670 7100 04    482  	tra	FH_do_while_end-*,ic	"if bit 0 on, parent index *2 BIG, quit
                                   483  "
    000375                         484  compare3_A:				"for $char entry
                                   485  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000375  aa  0 40140 1065 40    486  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000376  aa   300000 000005     487  	  desc9a	pr3|0,al			"left son data
    000377  aa   100000 000005     488  	  desc9a	pr1|0,al			"right son data
    000400  aa   000004 6030 04    489  	trc	compare3_B-*,ic		"left son is larger
    000401  aa   000001 0240 03    490  	adlx4	1,du			"larger son index = right son index
    000402  aa   000000 6220 11    491  	eax2	0,x1			"larger son vector = right son vector
    000403  aa  1 00000 3535 00    492  	epp3	pr1|0			"larger son ptr = right son ptr
                                   493  
    000404                         494  compare3_B:				"for $char entry
                                   495  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000404  aa  0 40140 1065 40    496  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000405  aa   400000 000005     497  	  desc9a	pr4|0,al			"parent data
    000406  aa   300000 000005     498  	  desc9a	pr3|0,al			"son data
    000407  aa   777655 6030 04    499  	trc	compareB_else-*,ic		"parent is larger
    000410  aa  7 00000 4421 15    500  	sxl2	pr7|0,x5			"parent vector = son vector
    000411  aa   000000 6250 14    501  	eax5	0,x4			"parent index = son index
    000412  aa   777660 6050 04    502  	tpl	FH_do_while-*,ic		"compare parent with new sons
    000413  aa   777651 7100 04    503  	tra	FH_do_while_end-*,ic	"if bit 0 on, parent index *2 BIG, quit
                                   504  "
    000414                         505  compare4_A:				"for $bit entry
                                   506  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000414  aa  0 00140 0665 40    507  	cmpb	(pr,rl),(pr,rl),fill(0)	"compare two bit strings
    000415  aa   300000 000005     508  	  descb	pr3|0,al			"left son data
    000416  aa   100000 000005     509  	  descb	pr1|0,al			"right son data
    000417  aa   000004 6030 04    510  	trc	compare4_B-*,ic		"left son is larger
    000420  aa   000001 0240 03    511  	adlx4	1,du			"larger son index = right son index
    000421  aa   000000 6220 11    512  	eax2	0,x1			"larger son vector = right son vector
    000422  aa  1 00000 3535 00    513  	epp3	pr1|0			"larger son ptr = right son ptr
                                   514  
    000423                         515  compare4_B:				"for $bit entry
                                   516  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000423  aa  0 00140 0665 40    517  	cmpb	(pr,rl),(pr,rl),fill(0)	"compare two bit strings
    000424  aa   400000 000005     518  	  descb	pr4|0,al			"parent data
    000425  aa   300000 000005     519  	  descb	pr3|0,al			"son data
    000426  aa   777636 6030 04    520  	trc	compareB_else-*,ic		"parent is larger
    000427  aa  7 00000 4421 15    521  	sxl2	pr7|0,x5			"parent vector = son vector
    000430  aa   000000 6250 14    522  	eax5	0,x4			"parent index = son index
    000431  aa   777641 6050 04    523  	tpl	FH_do_while-*,ic		"compare parent with new sons
    000432  aa   777632 7100 04    524  	tra	FH_do_while_end-*,ic	"if bit 0 on, parent index *2 BIG, quit
                                   525  "
    000433                         526  compare5_A:				"for $varying_char entry
    000433  aa  3 00000 2351 00    527  	lda	pr3|0			"left son data length
    000434  aa  1 00000 2361 00    528  	ldq	pr1|0			"right son data length
    000435  aa  0 40140 1065 40    529  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000436  aa   300001 000005     530  	  desc9a	pr3|1,al			"left son data
    000437  aa   100001 000006     531  	  desc9a	pr1|1,ql			"right son data
    000440  aa   000004 6030 04    532  	trc	compare5_B-*,ic		"left son is larger
    000441  aa   000001 0240 03    533  	adlx4	1,du			"larger son index = right son index
    000442  aa   000000 6220 11    534  	eax2	0,x1			"larger son vector = right son vector
    000443  aa  1 00000 3535 00    535  	epp3	pr1|0			"larger son ptr = right son ptr
                                   536  
    000444                         537  compare5_B:				"for $varying_char entry
    000444  aa  4 00000 2351 00    538  	lda	pr4|0			"parent data length
    000445  aa  3 00000 2361 00    539  	ldq	pr3|0			"son data length
    000446  aa  0 40140 1065 40    540  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare the two strings
    000447  aa   400001 000005     541  	  desc9a	pr4|1,al			"parent data
    000450  aa   300001 000006     542  	  desc9a	pr3|1,ql			"son data
    000451  aa   777613 6030 04    543  	trc	compareB_else-*,ic		"parent is larger
    000452  aa  7 00000 4421 15    544  	sxl2	pr7|0,x5			"parent vector = son vector
    000453  aa   000000 6250 14    545  	eax5	0,x4			"parent index = son index
    000454  aa   777616 6050 04    546  	tpl	FH_do_while-*,ic		"compare parent with new sons
    000455  aa   777607 7100 04    547  	tra	FH_do_while_end-*,ic	"if bit 0 on, parent index *2 BIG, quit
                                   548  "
    000456                         549  compare6_A:				"for $adj_char entry
    000456  aa  2 00000 2351 12    550  	lda	pr2|0,x2			"left son data length
    000457  aa  2 00000 2361 11    551  	ldq	pr2|0,x1			"right son data length
    000460  aa  0 40140 1065 40    552  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000461  aa   300000 000005     553  	  desc9a	pr3|0,al			"left son data
    000462  aa   100000 000006     554  	  desc9a	pr1|0,ql			"right son data
    000463  aa   000004 6030 04    555  	trc	compare6_B-*,ic		"left son is larger
    000464  aa   000001 0240 03    556  	adlx4	1,du			"larger son index = right son index
    000465  aa   000000 6220 11    557  	eax2	0,x1			"larger son vector = right son vector
    000466  aa  1 00000 3535 00    558  	epp3	pr1|0			"larger son ptr = right son ptr
                                   559  
    000467                         560  compare6_B:				"for $adj_char entry
    000467  aa  2 00000 2351 13    561  	lda	pr2|0,x3			"parent data length
    000470  aa  2 00000 2361 12    562  	ldq	pr2|0,x2			"son data length
    000471  aa  0 40140 1065 40    563  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000472  aa   400000 000005     564  	  desc9a	pr4|0,al			"parent data
    000473  aa   300000 000006     565  	  desc9a	pr3|0,ql			"son data
    000474  aa   777570 6030 04    566  	trc	compareB_else-*,ic		"parent is larger
    000475  aa  7 00000 4421 15    567  	sxl2	pr7|0,x5			"parent vector = son vector
    000476  aa   000000 6250 14    568  	eax5	0,x4			"parent index = son index
    000477  aa   777573 6050 04    569  	tpl	FH_do_while-*,ic		"compare parent with new sons
    000500  aa   777564 7100 04    570  	tra	FH_do_while_end-*,ic	"if bit 0 on, parent index *2 BIG, quit
                                   571  "
    000501                         572  sort_heap:				"just a program label
                                   573  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                   574  "This is the sort_heap section of sort_items_indirect_.  It sorts the
                                   575  "   heap by putting the root node value in its proper place and
                                   576  "   adjusting the remaining heap, producing a new root node value.
                                   577  "   Register usage is as follows:
                                   578  "   PR0 -- addr (arg_list) {$general entry ONLY!!}
                                   579  "   PR1 -- right son ptr (if one exists)
                                   580  "   PR2 -- function entry ptr {$general entry ONLY!!}
                                   581  "	 addr (adjustable length array base) {$adj_char ONLY!!}
                                   582  "   PR3 -- larger son ptr for compare C (initially assumed to be left son)
                                   583  "	 parent ptr for compare D
                                   584  "   PR4 -- last leaf ptr
                                   585  "   PR5 -- addr (ptr array base)
                                   586  "   PR6 -- addr (stack frame)
                                   587  "   PR7 -- addr (vector array base)
                                   588  "	 is temporarily set to addr (stack base) for calls {$general ONLY!!}
                                   589  "   X1 -- right son vector (if on exists)
                                   590  "   X2 -- larger son vector for compare C (initially assumed to be left son)
                                   591  "         parent vector for compare D
                                   592  "   X3 -- last leaf vector
                                   593  "   X4 -- larger child index (initially assumed to be left son index)
                                   594  "   X5 -- parent index
                                   595  "   X6 -- SH_do_i loop control variable
                                   596  "   X7 -- data type as defined by entry point
                                   597  "   A -- data string length {$char, $bit entries ONLY!!}
                                   598  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                   599  "
    000501  aa  6 00105 2261 00    600  	ldx6	N_in_upper		"put total items in loop counter
    000502  aa   000002 7100 04    601  	tra	SH_loop_start-*,ic		"goto loop start
                                   602  
    000503                         603  SH_do_i:					"start of do i loop, or
    000503                         604  compareD_then:				"finished backing up tree, or
    000503                         605  SH_do_while_end:				"do while done, try do i again
    000503  aa  7 00000 4431 14    606  	sxl3	pr7|0,x4			"son vector = last leaf vector
                                   607  
    000504                         608  SH_loop_start:
    000504  aa   000001 1260 03    609  	sblx6	1,du			"decrement loop index by 1
    000505  aa   000303 6000 04    610  	tze	sort_end-*,ic		"loop done, goto sort_end
    000506  aa  6 00105 7461 00    611  	stx6	N_in_upper		"store counter index bound
    000507  aa  7 00001 7231 16    612  	lxl3	pr7|1,x6			"get last leaf vector
    000510  aa  5 00000 7641 13    613  	lprp4	pr5|0,x3			"get last leaf ptr
    000511  aa  7 00001 2361 00    614  	ldq	pr7|1			"get root vector
    000512  aa  7 00001 7561 16    615  	stq	pr7|1,x6			"last leaf vector = root vector
    000513  aa   000001 2250 03    616  	ldx5	1,du			"parent index = 1
                                   617  
    000514                         618  SH_do_while:				"walk tree, swap up if son > last leaf
    000514  aa   000000 6360 15    619  	eaq	0,x5			"put parent index in $Q
    000515  aa   000001 7360 00    620  	qls	1			"multiply by 2
    000516  aa   000000 6240 02    621  	eax4	0,qu			"put in larger child index
    000517  aa  6 00105 1041 00    622  	cmpx4	N_in_upper		"is larger son index <= loop index??
    000520  aa   000004 6020 04    623  	tnc	SH_two_sons-*,ic		"have two sons
    000521  aa   000010 6000 04    624  	tze	SH_one_son-*,ic		"have one son
    000522  aa   000000 6240 15    625  	eax4	0,x5			"too big, get old value
    000523  0a   000056 7100 37    626  	tra	label_vec_D,x7*		"go back up tree
                                   627  
    000524                         628  SH_two_sons:
    000524  aa  7 00000 7221 14    629  	lxl2	pr7|0,x4			"get left son vector
    000525  aa  5 00000 7631 12    630  	lprp3	pr5|0,x2			"get left son ptr
    000526  aa  7 00001 7211 14    631  	lxl1	pr7|1,x4			"get right son vector
    000527  aa  5 00000 7611 11    632  	lprp1	pr5|0,x1			"get right son ptr
    000530  0a   000047 7100 37    633  	tra	label_vec_C,x7*		"find larger of sons
                                   634  
    000531                         635  SH_one_son:
    000531  aa  7 00000 7221 14    636  	lxl2	pr7|0,x4			"get larger son vector
    000532  aa  7 00000 4421 15    637  	sxl2	pr7|0,x5			"parent vector = son vector
    000533  aa   000000 6250 14    638  	eax5	0,x4			"parent index = son index
    000534  aa   777760 6050 04    639  	tpl	SH_do_while-*,ic		"compare parent with new sons
    000535  0a   000056 7100 37    640  	tra	label_vec_D,x7*		"else go back up tree
                                   641  "
    000536                         642  compare0_C:				"for $general entry
    000536  aa  6 00102 5431 00    643  	sprp3	general_pptr_1		"left son ptr
    000537  aa  6 00103 5411 00    644  	sprp1	general_pptr_2		"right son ptr
                                   645  	"call pseudo-op simulated to call function
    000540  aa  6 00000 2541 00    646  	spri	pr6|0			"save all PR's
    000541  aa  6 00040 7531 00    647  	sreg	pr6|stack_frame.regs	"save rest of registers
    000542  aa  6 00000 3731 00    648  	epbp7	pr6|0			"make $PR7 point to stack base
    000543  aa  7 00036 6701 20    649  	tsp4	pr7|stack_header.call_op_ptr,*     "use stack header ptr to call
    000544  aa  6 00000 1731 00    650  	lpri	pr6|0			"reclaim our PR's
    000545  aa  6 00040 0731 00    651  	lreg	pr6|stack_frame.regs	"reclaim rest of registers
                                   652  	"test function return value
    000546  aa  6 00104 2341 00    653  	szn	general_value		"is left son data < right son data??
    000547  aa   000003 6050 04    654  	tpl	assignment0_C-*,ic		"no, left son is larger
    000550  aa   000001 0240 03    655  	adlx4	1,du			"larger son index = right son index
    000551  aa   000000 6220 11    656  	eax2	0,x1			"larger son vector = right son vector
                                   657  
    000552                         658  assignment0_C:
    000552  aa  7 00000 4421 15    659  	sxl2	pr7|0,x5			"parent vector = son vector
    000553  aa   000000 6250 14    660  	eax5	0,x4			"parent index = son index
    000554  aa   777740 6050 04    661  	tpl	SH_do_while-*,ic		"compare parent with new sons
                                   662  
    000555                         663  compare0_D:				"for $general entry
    000555  aa   000000 6360 14    664  	eaq	0,x4			"put son index in $Q
    000556  aa   000001 7720 00    665  	qrl	1			"divide by shifting bits right
    000557  aa   000000 6250 02    666  	eax5	0,qu			"put in parent index
    000560  aa   777723 6000 04    667  	tze	compareD_then-*,ic		"if = 0, try do i loop again
    000561  aa  7 00000 7221 15    668  	lxl2	pr7|0,x5			"get parent vector
    000562  aa  5 00000 7631 12    669  	lprp3	pr5|0,x2			"get parent ptr
    000563  aa  6 00102 5431 00    670  	sprp3	general_pptr_1		"set parent ptr
    000564  aa  6 00103 5441 00    671  	sprp4	general_pptr_2		"set last leaf ptr
                                   672  	"call pseudo-op simulated to call function
    000565  aa  6 00000 2541 00    673  	spri	pr6|0			"save all PR's
    000566  aa  6 00040 7531 00    674  	sreg	pr6|stack_frame.regs	"save rest of registers
    000567  aa  6 00000 3731 00    675  	epbp7	pr6|0			"make $PR7 point to stack base
    000570  aa  7 00036 6701 20    676  	tsp4	pr7|stack_header.call_op_ptr,*     "use stack header ptr to call
    000571  aa  6 00000 1731 00    677  	lpri	pr6|0			"reclaim our PR's
    000572  aa  6 00040 0731 00    678  	lreg	pr6|stack_frame.regs	"reclaim rest of registers
                                   679  	"test function return value
    000573  aa  6 00104 2341 00    680  	szn	general_value		"is parent data < last leaf data??
    000574  aa   777707 6050 04    681  	tpl	compareD_then-*,ic		"no, parent is larger
    000575  aa  7 00000 4421 14    682  	sxl2	pr7|0,x4			"son vector = parent vector
    000576  aa   000000 6240 15    683  	eax4	0,x5			"son index = parent index
    000577  aa   777756 7100 04    684  	tra	compare0_D-*,ic		"go back up tree
                                   685  "
    000600                         686  compare1_C:				"for $fixed_bin entry
    000600  aa  3 00000 2361 00    687  	ldq	pr3|0			"left son data
    000601  aa  1 00000 1161 00    688  	cmpq	pr1|0			"is left son data < right son data??
    000602  aa   000003 6050 04    689  	tpl	assignment1_C-*,ic		"no, left son is larger
    000603  aa   000001 0240 03    690  	adlx4	1,du			"larger son index = right son index
    000604  aa   000000 6220 11    691  	eax2	0,x1			"larger son vector = right son vector
                                   692  
    000605                         693  assignment1_C:
    000605  aa  7 00000 4421 15    694  	sxl2	pr7|0,x5			"parent vector = son vector
    000606  aa   000000 6250 14    695  	eax5	0,x4			"parent index = son index
    000607  aa   777705 6050 04    696  	tpl	SH_do_while-*,ic		"compare parent with new sons
                                   697  
    000610                         698  compare1_D:				"for $fixed_bin entry
    000610  aa   000000 6360 14    699  	eaq	0,x4			"put son index in $Q
    000611  aa   000001 7720 00    700  	qrl	1			"divide by shifting bits right
    000612  aa   000000 6250 02    701  	eax5	0,qu			"put in parent index
    000613  aa   777670 6000 04    702  	tze	compareD_then-*,ic		"if = 0, try do i loop again
    000614  aa  7 00000 7221 15    703  	lxl2	pr7|0,x5			"get parent vector
    000615  aa  5 00000 7631 12    704  	lprp3	pr5|0,x2			"get parent ptr
    000616  aa  3 00000 2361 00    705  	ldq	pr3|0			"parent data
    000617  aa  4 00000 1161 00    706  	cmpq	pr4|0			"is parent data < last leaf data??
    000620  aa   777663 6050 04    707  	tpl	compareD_then-*,ic		"no, parent is larger
    000621  aa  7 00000 4421 14    708  	sxl2	pr7|0,x4			"son vector = parent vector
    000622  aa   000000 6240 15    709  	eax4	0,x5			"son index = parent index
    000623  aa   777765 7100 04    710  	tra	compare1_D-*,ic		"go back up tree
                                   711  "
    000624                         712  compare2_C:				"for $float_bin entry
    000624  aa  3 00000 4331 00    713  	dfld	pr3|0			"left son data
    000625  aa  1 00000 5171 00    714  	dfcmp	pr1|0			"is left son data < right son data??
    000626  aa   000003 6050 04    715  	tpl	assignment2_C-*,ic		"no, left son is larger
    000627  aa   000001 0240 03    716  	adlx4	1,du			"larger son index = right son index
    000630  aa   000000 6220 11    717  	eax2	0,x1			"larger son vector = right son vector
                                   718  
    000631                         719  assignment2_C:
    000631  aa  7 00000 4421 15    720  	sxl2	pr7|0,x5			"parent vector = son vector
    000632  aa   000000 6250 14    721  	eax5	0,x4			"parent index = son index
    000633  aa   777661 6050 04    722  	tpl	SH_do_while-*,ic		"compare parent with new sons
                                   723  
    000634                         724  compare2_D:				"for $float_bin entry
    000634  aa   000000 6360 14    725  	eaq	0,x4			"put son index in $Q
    000635  aa   000001 7720 00    726  	qrl	1			"divide by shifting bits right
    000636  aa   000000 6250 02    727  	eax5	0,qu			"put in parent index
    000637  aa   777644 6000 04    728  	tze	compareD_then-*,ic		"if = 0, try do i loop again
    000640  aa  7 00000 7221 15    729  	lxl2	pr7|0,x5			"get parent vector
    000641  aa  5 00000 7631 12    730  	lprp3	pr5|0,x2			"get parent ptr
    000642  aa  3 00000 4331 00    731  	dfld	pr3|0			"parent data
    000643  aa  4 00000 5171 00    732  	dfcmp	pr4|0			"is parent data < last leaf data??
    000644  aa   777637 6050 04    733  	tpl	compareD_then-*,ic		"no, parent is larger
    000645  aa  7 00000 4421 14    734  	sxl2	pr7|0,x4			"son vector = parent vector
    000646  aa   000000 6240 15    735  	eax4	0,x5			"son index = parent index
    000647  aa   777765 7100 04    736  	tra	compare2_D-*,ic		"go back up tree
                                   737  "
    000650                         738  compare3_C:				"for $char entry
                                   739  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000650  aa  0 40140 1065 40    740  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000651  aa   300000 000005     741  	  desc9a	pr3|0,al			"left son data
    000652  aa   100000 000005     742  	  desc9a	pr1|0,al			"right son data
    000653  aa   000003 6030 04    743  	trc	assignment3_C-*,ic		"left son is larger
    000654  aa   000001 0240 03    744  	adlx4	1,du			"larger son index = right son index
    000655  aa   000000 6220 11    745  	eax2	0,x1			"larger son vector = right son vector
                                   746  
    000656                         747  assignment3_C:
    000656  aa  7 00000 4421 15    748  	sxl2	pr7|0,x5			"parent vector = son vector
    000657  aa   000000 6250 14    749  	eax5	0,x4			"parent index = son index
    000660  aa   777634 6050 04    750  	tpl	SH_do_while-*,ic		"compare parent with new sons
                                   751  
    000661                         752  compare3_D:				"for $char entry
    000661  aa   000000 6360 14    753  	eaq	0,x4			"put son index in $Q
    000662  aa   000001 7720 00    754  	qrl	1			"divide by shifting bits right
    000663  aa   000000 6250 02    755  	eax5	0,qu			"put in parent index
    000664  aa   777617 6000 04    756  	tze	compareD_then-*,ic		"if = 0, try do i loop again
    000665  aa  7 00000 7221 15    757  	lxl2	pr7|0,x5			"get parent vector
    000666  aa  5 00000 7631 12    758  	lprp3	pr5|0,x2			"get parent ptr
                                   759  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000667  aa  0 40140 1065 40    760  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000670  aa   300000 000005     761  	  desc9a	pr3|0,al			"parent data
    000671  aa   400000 000005     762  	  desc9a	pr4|0,al			"last leaf data
    000672  aa   777611 6030 04    763  	trc	compareD_then-*,ic		"parent is larger
    000673  aa  7 00000 4421 14    764  	sxl2	pr7|0,x4			"son vector = parent vector
    000674  aa   000000 6240 15    765  	eax4	0,x5			"son index = parent index
    000675  aa   777764 7100 04    766  	tra	compare3_D-*,ic		"go back up tree
                                   767  "
    000676                         768  compare4_C:				"for $bit entry
                                   769  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000676  aa  0 00140 0665 40    770  	cmpb	(pr,rl),(pr,rl),fill(0)	"compare two bit strings
    000677  aa   300000 000005     771  	  descb	pr3|0,al			"left son data
    000700  aa   100000 000005     772  	  descb	pr1|0,al			"right son data
    000701  aa   000003 6030 04    773  	trc	assignment4_C-*,ic		"left son is larger
    000702  aa   000001 0240 03    774  	adlx4	1,du			"larger son index = right son index
    000703  aa   000000 6220 11    775  	eax2	0,x1			"larger son vector = right son vector
                                   776  
    000704                         777  assignment4_C:
    000704  aa  7 00000 4421 15    778  	sxl2	pr7|0,x5			"parent vector = son vector
    000705  aa   000000 6250 14    779  	eax5	0,x4			"parent index = son index
    000706  aa   777606 6050 04    780  	tpl	SH_do_while-*,ic		"compare parent with new sons
                                   781  
    000707                         782  compare4_D:				"for $bit entry
    000707  aa   000000 6360 14    783  	eaq	0,x4			"put son index in $Q
    000710  aa   000001 7720 00    784  	qrl	1			"divide by shifting bits right
    000711  aa   000000 6250 02    785  	eax5	0,qu			"put in parent index
    000712  aa   777571 6000 04    786  	tze	compareD_then-*,ic		"if = 0, try do i loop again
    000713  aa  7 00000 7221 15    787  	lxl2	pr7|0,x5			"get parent vector
    000714  aa  5 00000 7631 12    788  	lprp3	pr5|0,x2			"get parent ptr
                                   789  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000715  aa  0 00140 0665 40    790  	cmpb	(pr,rl),(pr,rl),fill(0)	"compare two bit strings
    000716  aa   300000 000005     791  	  descb	pr3|0,al			"parent data
    000717  aa   400000 000005     792  	  descb	pr4|0,al			"last leaf data
    000720  aa   777563 6030 04    793  	trc	compareD_then-*,ic		"parent is larger
    000721  aa  7 00000 4421 14    794  	sxl2	pr7|0,x4			"son vector = parent vector
    000722  aa   000000 6240 15    795  	eax4	0,x5			"son index = parent index
    000723  aa   777764 7100 04    796  	tra	compare4_D-*,ic		"go back up tree
                                   797  "
    000724                         798  compare5_C:				"for $varying_char entry
    000724  aa  3 00000 2351 00    799  	lda	pr3|0			"left son data length
    000725  aa  1 00000 2361 00    800  	ldq	pr1|0			"right son data length
    000726  aa  0 40140 1065 40    801  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000727  aa   300001 000005     802  	  desc9a	pr3|1,al			"left son data
    000730  aa   100001 000006     803  	  desc9a	pr1|1,ql			"right son data
    000731  aa   000003 6030 04    804  	trc	assignment5_C-*,ic		"left son is larger
    000732  aa   000001 0240 03    805  	adlx4	1,du			"larger son index = right son index
    000733  aa   000000 6220 11    806  	eax2	0,x1			"larger son vector = right son vector
                                   807  
    000734                         808  assignment5_C:
    000734  aa  7 00000 4421 15    809  	sxl2	pr7|0,x5			"parent vector = son vector
    000735  aa   000000 6250 14    810  	eax5	0,x4			"parent index = son index
    000736  aa   777556 6050 04    811  	tpl	SH_do_while-*,ic		"compare parent with new sons
                                   812  
    000737                         813  compare5_D:				"for $varying_char entry
    000737  aa   000000 6360 14    814  	eaq	0,x4			"put son index in $Q
    000740  aa   000001 7720 00    815  	qrl	1			"divide by shifting bits right
    000741  aa   000000 6250 02    816  	eax5	0,qu			"put in parent index
    000742  aa   777541 6000 04    817  	tze	compareD_then-*,ic		"if = 0, try do i loop again
    000743  aa  7 00000 7221 15    818  	lxl2	pr7|0,x5			"get parent vector
    000744  aa  5 00000 7631 12    819  	lprp3	pr5|0,x2			"get parent ptr
    000745  aa  3 00000 2351 00    820  	lda	pr3|0			"parent data length
    000746  aa  4 00000 2361 00    821  	ldq	pr4|0			"last leaf data length
    000747  aa  0 40140 1065 40    822  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000750  aa   300001 000005     823  	  desc9a	pr3|1,al			"parent data
    000751  aa   400001 000006     824  	  desc9a	pr4|1,ql			"last leaf data
    000752  aa   777531 6030 04    825  	trc	compareD_then-*,ic		"parent is larger
    000753  aa  7 00000 4421 14    826  	sxl2	pr7|0,x4			"son vector = parent vector
    000754  aa   000000 6240 15    827  	eax4	0,x5			"son index = parent index
    000755  aa   777762 7100 04    828  	tra	compare5_D-*,ic		"go back up tree
                                   829  "
    000756                         830  compare6_C:				"for $adj_char entry
    000756  aa  2 00000 2351 12    831  	lda	pr2|0,x2			"left son data length
    000757  aa  2 00000 2361 11    832  	ldq	pr2|0,x1			"right son data length
    000760  aa  0 40140 1065 40    833  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000761  aa   300000 000005     834  	  desc9a	pr3|0,al			"left son data
    000762  aa   100000 000006     835  	  desc9a	pr1|0,ql			"right son data
    000763  aa   000003 6030 04    836  	trc	assignment6_C-*,ic		"left son is larger
    000764  aa   000001 0240 03    837  	adlx4	1,du			"larger son index = right son index
    000765  aa   000000 6220 11    838  	eax2	0,x1			"larger son vector = right son vector
                                   839  
    000766                         840  assignment6_C:
    000766  aa  7 00000 4421 15    841  	sxl2	pr7|0,x5			"parent vector = son vector
    000767  aa   000000 6250 14    842  	eax5	0,x4			"parent index = son index
    000770  aa   777524 6050 04    843  	tpl	SH_do_while-*,ic		"compare parent with new sons
                                   844  
    000771                         845  compare6_D:				"for $adj_char entry
    000771  aa   000000 6360 14    846  	eaq	0,x4			"put son index in $Q
    000772  aa   000001 7720 00    847  	qrl	1			"divide by shifting bits right
    000773  aa   000000 6250 02    848  	eax5	0,qu			"put in parent index
    000774  aa   777507 6000 04    849  	tze	compareD_then-*,ic		"if = 0, try do i loop again
    000775  aa  7 00000 7221 15    850  	lxl2	pr7|0,x5			"get parent vector
    000776  aa  5 00000 7631 12    851  	lprp3	pr5|0,x2			"get parent ptr
    000777  aa  2 00000 2351 12    852  	lda	pr2|0,x2			"parent data length
    001000  aa  2 00000 2361 13    853  	ldq	pr2|0,x3			"last leaf data length
    001001  aa  0 40140 1065 40    854  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    001002  aa   300000 000005     855  	  desc9a	pr3|0,al			"parent data
    001003  aa   400000 000006     856  	  desc9a	pr4|0,ql			"last leaf data
    001004  aa   777477 6030 04    857  	trc	compareD_then-*,ic		"parent is larger
    001005  aa  7 00000 4421 14    858  	sxl2	pr7|0,x4			"son vector = parent vector
    001006  aa   000000 6240 15    859  	eax4	0,x5			"son index = parent index
    001007  aa   777762 7100 04    860  	tra	compare6_D-*,ic		"go back up tree
                                   861  
    001010                         862  sort_end:					"sort finished, go home
    001010  aa  6 00000 3731 00    863  	epbp7	pr6|0			"set $PR7 for return
    001011  aa  7 00042 7101 20    864  	return
                                   865  	end				"program done
ENTRY SEQUENCES
     
    001012  5a   000055 0000 00
    001013  aa  7 00046 2721 20
    001014  0a   000065 7100 00
    001015  5a   000047 0000 00
    001016  aa  7 00046 2721 20
    001017  0a   000071 7100 00
    001020  5a   000042 0000 00
    001021  aa  7 00046 2721 20
    001022  0a   000075 7100 00
    001023  5a   000036 0000 00
    001024  aa  7 00046 2721 20
    001025  0a   000105 7100 00
    001026  5a   000027 0000 00
    001027  aa  7 00046 2721 20
    001030  0a   000115 7100 00
    001031  5a   000021 0000 00
    001032  aa  7 00046 2721 20
    001033  0a   000121 7100 00
    001034  5a   000014 0000 00
    001035  aa  7 00046 2721 20
    001036  0a   000127 7100 00

NO LITERALS
     
NAME DEFINITIONS FOR ENTRY POINTS AND SEGDEFS

    001040  5a   000003 000000 
    001041  5a   000072 600000 
    001042  aa   000000 000000 
    001043  55   000014 000002 
    001044  5a   000002 400003 
    001045  55   000006 000014 
    001046  aa  024 163 157 162
    001047  aa  164 137 151 164
    001050  aa  145 155 163 137
    001051  aa  151 156 144 151
    001052  aa  162 145 143 164
    001053  aa  137 000 000 000
    001054  55   000021 000003 
    001055  0a   001035 500000 
    001056  55   000017 000003 
    001057  aa  007 147 145 156         general
    001060  aa  145 162 141 154
    001061  55   000027 000014 
    001062  0a   001032 500000 
    001063  55   000024 000003 
    001064  aa  010 141 144 152         adj_char
    001065  aa  137 143 150 141
    001066  aa  162 000 000 000
    001067  55   000036 000021 
    001070  0a   001027 500000 
    001071  55   000032 000003 
    001072  aa  014 166 141 162         varying_char
    001073  aa  171 151 156 147
    001074  aa  137 143 150 141
    001075  aa  162 000 000 000
    001076  55   000042 000027 
    001077  0a   001024 500000 
    001100  55   000041 000003 
    001101  aa  003 142 151 164         bit
    001102  55   000047 000036 
    001103  0a   001021 500000 
    001104  55   000045 000003 
    001105  aa  004 143 150 141         char
    001106  aa  162 000 000 000
    001107  55   000055 000042 
    001110  0a   001016 500000 
    001111  55   000052 000003 
    001112  aa  011 146 154 157         float_bin
    001113  aa  141 164 137 142
    001114  aa  151 156 000 000
    001115  55   000063 000047 
    001116  0a   001013 500000 
    001117  55   000060 000003 
    001120  aa  011 146 151 170         fixed_bin
    001121  aa  145 144 137 142
    001122  aa  151 156 000 000
    001123  55   000002 000055 
    001124  6a   000000 400002 
    001125  55   000066 000003 
    001126  aa  014 163 171 155         symbol_table
    001127  aa  142 157 154 137
    001130  aa  164 141 142 154
    001131  aa  145 000 000 000

DEFINITIONS HASH TABLE

    001132  aa   000000 000015 
    001133  aa   000000 000000 
    001134  5a   000021 000000 
    001135  aa   000000 000000 
    001136  aa   000000 000000 
    001137  5a   000042 000000 
    001140  5a   000027 000000 
    001141  5a   000055 000000 
    001142  5a   000063 000000 
    001143  5a   000036 000000 
    001144  5a   000014 000000 
    001145  5a   000047 000000 
    001146  aa   000000 000000 
    001147  aa   000000 000000 

EXTERNAL NAMES

    001150  aa  015 157 165 164         out_of_bounds
    001151  aa  137 157 146 137
    001152  aa  142 157 165 156
    001153  aa  144 163 000 000
    001154  aa  014 145 162 162         error_table_
    001155  aa  157 162 137 164
    001156  aa  141 142 154 145
    001157  aa  137 000 000 000
    001160  aa  014 155 141 170         max_seg_size
    001161  aa  137 163 145 147
    001162  aa  137 163 151 172
    001163  aa  145 000 000 000
    001164  aa  010 163 171 163         sys_info
    001165  aa  137 151 156 146
    001166  aa  157 000 000 000
    001167  aa  010 163 165 142         sub_err_
    001170  aa  137 145 162 162
    001171  aa  137 000 000 000

NO TRAP POINTER WORDS

TYPE PAIR BLOCKS

    001172  aa   000004 000000 
    001173  55   000114 000110 
    001174  aa   000004 000000 
    001175  55   000124 000120 
    001176  aa   000004 000000 
    001177  55   000127 000127 
    001200  aa   000001 000000 
    001201  aa   000000 000000 

INTERNAL EXPRESSION WORDS

    001202  5a   000132 000000 
    001203  5a   000134 000000 
    001204  5a   000136 000000 
    001205  aa   000000 000000 
LINKAGE INFORMATION
      
    000000  aa   000000 000000 
    000001  0a   001040 000000 
    000002  aa   000000 000000 
    000003  aa   000000 000000 
    000004  aa   000000 000000 
    000005  aa   000000 000000 
    000006  22   000010 000016 
    000007  a2   000000 000000 
    000010  9a   777770 0000 46         sub_err_|sub_err_
    000011  5a   000144 0000 00
    000012  9a   777766 0000 46         sys_info|max_seg_size
    000013  5a   000143 0000 00
    000014  9a   777764 0000 46         error_table_|out_of_bounds
    000015  5a   000142 0000 00
SYMBOL INFORMATION
     
SYMBOL TABLE HEADER
     
    000000  aa   000000 000001 
    000001  aa   163171 155142 
    000002  aa   164162 145145 
    000003  aa   000000 000004 
    000004  aa   000000 114732 
    000005  aa   732732 062314 
    000006  aa   000000 114775 
    000007  aa   664633 227351 
    000010  aa   141154 155040 
    000011  aa   040040 040040 
    000012  aa   000024 000040 
    000013  aa   000034 000040 
    000014  aa   000044 000100 
    000015  aa   000002 000002 
    000016  aa   000064 000000 
    000017  aa   000000 000232 
    000020  aa   000000 000150 
    000021  aa   000000 000216 
    000022  aa   000222 000150 
    000023  aa   000064 000000 
    000024  aa   101114 115040 
    000025  aa   126145 162163 
    000026  aa   151157 156040 
    000027  aa   040066 056067 
    000030  aa   040040 117143 
    000031  aa   164157 142145 
    000032  aa   162040 061071 
    000033  aa   070066 040040 
    000034  aa   107112 157150 
    000035  aa   156163 157156 
    000036  aa   056123 171163 
    000037  aa   115141 151156 
    000040  aa   164056 141040 
    000041  aa   040040 040040 
    000042  aa   040040 040040 
    000043  aa   040040 040040 
    000044  aa   154151 163164 
    000045  aa   040040 040040 
    000046  aa   040040 040040 
    000047  aa   040040 040040 
    000050  aa   040040 040040 
    000051  aa   040040 040040 
    000052  aa   040040 040040 
    000053  aa   040040 040040 
    000054  aa   040040 040040 
    000055  aa   040040 040040 
    000056  aa   040040 040040 
    000057  aa   040040 040040 
    000060  aa   040040 040040 
    000061  aa   040040 040040 
    000062  aa   040040 040040 
    000063  aa   040040 040040 
    000064  aa   000000 000001 
    000065  aa   000000 000003 
    000066  aa   000102 000071 
    000067  aa   147740 446043 
    000070  aa   000000 114774 
    000071  aa   460601 400000 
    000072  aa   000121 000066 
    000073  aa   147714 750316 
    000074  aa   000000 114774 
    000075  aa   453561 000000 
    000076  aa   000137 000041 
    000077  aa   052721 247134 
    000100  aa   000000 105272 
    000101  aa   317215 400000 
    000102  aa   076163 160145          >special_ldd>install>MR12.0-1206>sort_items_indirect_.alm
    000103  aa   143151 141154 
    000104  aa   137154 144144 
    000105  aa   076151 156163 
    000106  aa   164141 154154 
    000107  aa   076115 122061 
    000110  aa   062056 060055 
    000111  aa   061062 060066 
    000112  aa   076163 157162 
    000113  aa   164137 151164 
    000114  aa   145155 163137 
    000115  aa   151156 144151 
    000116  aa   162145 143164 
    000117  aa   137056 141154 
    000120  aa   155040 040040 
    000121  aa   076163 160145          >special_ldd>install>MR12.0-1206>stack_header.incl.alm
    000122  aa   143151 141154 
    000123  aa   137154 144144 
    000124  aa   076151 156163 
    000125  aa   164141 154154 
    000126  aa   076115 122061 
    000127  aa   062056 060055 
    000130  aa   061062 060066 
    000131  aa   076163 164141 
    000132  aa   143153 137150 
    000133  aa   145141 144145 
    000134  aa   162056 151156 
    000135  aa   143154 056141 
    000136  aa   154155 040040 
    000137  aa   076154 144144          >ldd>include>stack_frame.incl.alm
    000140  aa   076151 156143 
    000141  aa   154165 144145 
    000142  aa   076163 164141 
    000143  aa   143153 137146 
    000144  aa   162141 155145 
    000145  aa   056151 156143 
    000146  aa   154056 141154 
    000147  aa   155040 040040 
               MULTICS ASSEMBLY CROSS REFERENCE LISTING

   Value        Symbol                   Source file   Line number

         121    adj_char                 sort_items_indirect_:     102,  242.
          50    arg_list_1               sort_items_indirect_:     105,  258,  260,  262,  264,  281,  283,  285,  287,  304,  353.
          60    arg_list_2               sort_items_indirect_:     105,  254,  273,  289,  292,  294,  320.
          70    arg_list_3               sort_items_indirect_:     105,  295,  297,  299,  301.
         100    arg_list_4               sort_items_indirect_:     106,  303.
         552    assignment0_C            sort_items_indirect_:     654,  658.
         605    assignment1_C            sort_items_indirect_:     689,  693.
         631    assignment2_C            sort_items_indirect_:     715,  719.
         656    assignment3_C            sort_items_indirect_:     743,  747.
         704    assignment4_C            sort_items_indirect_:     773,  777.
         734    assignment5_C            sort_items_indirect_:     804,  808.
         766    assignment6_C            sort_items_indirect_:     836,  840.
         105    bit                      sort_items_indirect_:     102,  228.
        1170    call_offset              stack_header:        80.
          75    char                     sort_items_indirect_:     102,  218.
         221    common                   sort_items_indirect_:     211,  216,  240,  247,  265,  310.
         310    compare0_A               sort_items_indirect_:     145,  415.
         325    compare0_B               sort_items_indirect_:     154,  427,  432.
         536    compare0_C               sort_items_indirect_:     163,  642.
         555    compare0_D               sort_items_indirect_:     172,  663,  684.
         343    compare1_A               sort_items_indirect_:     146,  450.
         351    compare1_B               sort_items_indirect_:     155,  453,  458.
         600    compare1_C               sort_items_indirect_:     164,  686.
         610    compare1_D               sort_items_indirect_:     173,  698,  710.
         360    compare2_A               sort_items_indirect_:     147,  467.
         366    compare2_B               sort_items_indirect_:     156,  470,  475.
         624    compare2_C               sort_items_indirect_:     165,  712.
         634    compare2_D               sort_items_indirect_:     174,  724,  736.
         375    compare3_A               sort_items_indirect_:     148,  484.
         404    compare3_B               sort_items_indirect_:     157,  489,  494.
         650    compare3_C               sort_items_indirect_:     166,  738.
         661    compare3_D               sort_items_indirect_:     175,  752,  766.
         414    compare4_A               sort_items_indirect_:     149,  505.
         423    compare4_B               sort_items_indirect_:     158,  510,  515.
         676    compare4_C               sort_items_indirect_:     167,  768.
         707    compare4_D               sort_items_indirect_:     176,  782,  796.
         433    compare5_A               sort_items_indirect_:     150,  526.
         444    compare5_B               sort_items_indirect_:     159,  532,  537.
         724    compare5_C               sort_items_indirect_:     168,  798.
         737    compare5_D               sort_items_indirect_:     177,  813,  828.
         456    compare6_A               sort_items_indirect_:     151,  549.
         467    compare6_B               sort_items_indirect_:     160,  555,  560.
         756    compare6_C               sort_items_indirect_:     169,  830.
         771    compare6_D               sort_items_indirect_:     178,  845,  860.
         264    compareB_else            sort_items_indirect_:     386,  444,  461,  478,  499,  520,  543,  566.
         503    compareD_then            sort_items_indirect_:     604,  667,  681,  702,  707,  728,  733,  756,  763,  786,
                                                                   793,  817,  825,  849,  857.
        1174    entry_offset             stack_header:        84.
                error_table_             sort_items_indirect_:     276.
         107    error_value              sort_items_indirect_:     109,  277,  282.
          30    err_msg_desc             sort_items_indirect_:     136,  302.
         264    FH_do_i                  sort_items_indirect_:     385.
         272    FH_do_while              sort_items_indirect_:     397,  447,  464,  481,  502,  523,  546,  569.
         264    FH_do_while_end          sort_items_indirect_:     387,  403,  448,  465,  482,  503,  524,  547,  570.
         266    FH_loop_start            sort_items_indirect_:     383,  391.
         303    FH_two_sons              sort_items_indirect_:     402,  408.
          24    fixed_35_desc            sort_items_indirect_:     124,  293.
          65    fixed_bin                sort_items_indirect_:     102,  208.
         260    fix_heap                 sort_items_indirect_:     352,  355.
          71    float_bin                sort_items_indirect_:     102,  213.
         127    general                  sort_items_indirect_:     102,  249.
         102    general_pptr_1           sort_items_indirect_:     107,  261,  416,  433,  643,  670.
         103    general_pptr_2           sort_items_indirect_:     107,  263,  417,  434,  644,  671.
         104    general_value            sort_items_indirect_:     107,  259,  290,  426,  443,  653,  680.
          65    init                     sort_items_indirect_:     180.
         243    init_index_array         sort_items_indirect_:     336,  339.
         227    items_err                sort_items_indirect_:     314,  318.
          31    label_vec_A              sort_items_indirect_:     144,  413.
          40    label_vec_B              sort_items_indirect_:     153,  406.
          47    label_vec_C              sort_items_indirect_:     162,  633.
          56    label_vec_D              sort_items_indirect_:     171,  626,  640.
         220    length_good              sort_items_indirect_:     269,  307.
                max_seg_size             sort_items_indirect_:     268,  315.
         251    no_sort                  sort_items_indirect_:     334,  344.
         232    n_elems_ok               sort_items_indirect_:     316,  323.
         106    N_in_lower               sort_items_indirect_:     108,  324,  333,  340,  380.
         105    N_in_upper               sort_items_indirect_:     108,  350,  401,  600,  611,  622.
                out_of_bounds            sort_items_indirect_:     276.
          20    program_name             sort_items_indirect_:     118,  284.
          25    program_name_desc        sort_items_indirect_:     127,  296.
          27    ptr_desc                 sort_items_indirect_:     133,  300.
        1171    push_offset              stack_header:        81.
         241    reset_count              sort_items_indirect_:     329,  332.
        1173    return_no_pop_offset     stack_header:        83.
        1172    return_offset            stack_header:        82.
         503    SH_do_i                  sort_items_indirect_:     603.
         514    SH_do_while              sort_items_indirect_:     618,  639,  661,  696,  722,  750,  780,  811,  843.
         503    SH_do_while_end          sort_items_indirect_:     605.
         504    SH_loop_start            sort_items_indirect_:     601,  608.
         531    SH_one_son               sort_items_indirect_:     624,  635.
         524    SH_two_sons              sort_items_indirect_:     623,  628.
        1010    sort_end                 sort_items_indirect_:     610,  862.
         501    sort_heap                sort_items_indirect_:     392,  572.
           0    sort_items_indirect_     sort_items_indirect_:       6.
          73    stach_header.trace_top_ptr     stack_header:        62.
          32    stack_frame.arg_ptr      stack_frame:   16.
         100    stack_frame.condition_bit      stack_frame:   32.
          20    stack_frame.condition_word     stack_frame:    9.
        2000    stack_frame.crawl_out_bit      stack_frame:   28.
          26    stack_frame.entry_ptr    stack_frame:   13.
          20    stack_frame.flag_word    stack_frame:   24.
         400    stack_frame.link_trap_bit      stack_frame:   30.
          30    stack_frame.lp_ptr       stack_frame:   15.
       20000    stack_frame.main_proc_bit      stack_frame:   25.
          60    stack_frame.min_length   stack_frame:   23.
          22    stack_frame.next_sp      stack_frame:   10.
          36    stack_frame.on_unit_rel_ptrs   stack_frame:   19.
          30    stack_frame.operator_ptr       stack_frame:   14.
          37    stack_frame.operator_ret_ptr   stack_frame:   20.
          20    stack_frame.prev_sp      stack_frame:    8.
          40    stack_frame.regs         sort_items_indirect_:     420,  424,  437,  441,  647,  651,  674,  678,
                                         stack_frame:   22.
          24    stack_frame.return_ptr   stack_frame:   12.
       10000    stack_frame.run_unit_manager   stack_frame:   26.
        1000    stack_frame.signaller_bit      stack_frame:   29.
          22    stack_frame.signaller_word     stack_frame:   11.
        4000    stack_frame.signal_bit   stack_frame:   27.
          34    stack_frame.static_ptr   stack_frame:   17.
         200    stack_frame.support_bit  stack_frame:   31.
          35    stack_frame.support_ptr  stack_frame:   18.
          37    stack_frame.translator_id      stack_frame:   21.
          66    stack_header.assign_linkage_ptr      stack_header:        59.
          32    stack_header.bar_mode_sp       stack_header:        42.
          36    stack_header.call_op_ptr       sort_items_indirect_:     422,  439,  649,  676,
                                               stack_header:        44.
          10    stack_header.clr_ptr     stack_header:        27.
           6    stack_header.combined_stat_ptr       stack_header:        25.
           4    stack_header.cpm_data_ptr      stack_header:        24.
          13    stack_header.cpm_enabled       stack_header:        32.
          13    stack_header.cur_lot_size      stack_header:        31.
          64    stack_header.ect_ptr     stack_header:        58.
          46    stack_header.entry_op_ptr      stack_header:        49.
          70    stack_header.heap_header_ptr   stack_header:        60.
          74    stack_header.in_trace    stack_header:        63.
          52    stack_header.isot_ptr    stack_header:        52.
          26    stack_header.lot_ptr     stack_header:        39.
          12    stack_header.main_proc_invoked       stack_header:        29.
          12    stack_header.max_lot_size      stack_header:        28.
          20    stack_header.parent_ptr  sort_items_indirect_:     288,
                                         stack_header:        36.
          34    stack_header.pl1_operators_ptr       stack_header:        43.
          40    stack_header.push_op_ptr       stack_header:        46.
          42    stack_header.return_op_ptr     stack_header:        47.
          44    stack_header.ret_no_pop_op_ptr       stack_header:        48.
          62    stack_header.rnt_ptr     stack_header:        57.
          12    stack_header.run_unit_depth    stack_header:        30.
          54    stack_header.sct_ptr     stack_header:        53.
          30    stack_header.signal_ptr  stack_header:        41.
          22    stack_header.stack_begin_ptr   stack_header:        37.
          24    stack_header.stack_end_ptr     stack_header:        38.
          14    stack_header.system_free_ptr   stack_header:        33.
          60    stack_header.sys_link_info_ptr       stack_header:        56.
          72    stack_header.trace_frames      stack_header:        61.
          50    stack_header.trans_op_tv_ptr   stack_header:        51.
          56    stack_header.unwinder_ptr      stack_header:        54.
          16    stack_header.user_free_ptr     stack_header:        34.
         100    stack_header_end         stack_header:        64.
         253    store_vars               sort_items_indirect_:     342,  348.
         150    string_length_compare    sort_items_indirect_:     225,  235,  267.
         152    string_length_err        sort_items_indirect_:     223,  233,  271.
          10    string_length_err_msg    sort_items_indirect_:     115,  272.
                sub_err_                 sort_items_indirect_:     304.
         154    sub_err_call             sort_items_indirect_:     275,  321.
          23    sub_err_flag             sort_items_indirect_:     121,  286.
          26    sub_err_flag_desc        sort_items_indirect_:     130,  298.
                sys_info                 sort_items_indirect_:     268,  315.
           0    total_items_err_msg      sort_items_indirect_:     112,  319.
           0    trace_frames.count       stack_header:        69.
           1    trace_frames.top_ptr     stack_header:        70.
         551    tv_offset                stack_header:        75,   80,   81,   82,   83,   84.
         115    varying_char             sort_items_indirect_:     102,  237.


NO FATAL ERRORS


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
