	COMPILATION LISTING OF SEGMENT print_motd
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 01/12/88  1248.3 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(87-03-17,Blair), approve(87-03-17,MCR7638),
       17*     audit(87-03-20,Gilcrease), install(87-04-03,MR12.1-1021):
       18*     Implement 5 control arguments to allow printing of project motds, and all
       19*     or new portions of the project or system motds.  The CAs are: -system,
       20*     -project, -all_text, -new_text, -current_project.  Change code not to
       21*     call com_err_ when a value_seg is created for the user by default.
       22*  2) change(87-04-06,Blair), approve(87-04-06,PBF7638), audit(87-04-06,GWMay),
       23*     install(87-04-08,MR12.1-1022):
       24*     Suppress printing the header when the bit_count of the motd is 0 and don't
       25*     print an error message when the default project doesn't exist.
       26*  3) change(87-05-04,Blair), approve(87-05-08,MCR7688),
       27*     audit(87-05-19,Gilcrease), install(87-05-26,MR12.1-1037):
       28*     Banner will be suppressed when the change amounts to deletion of lines
       29*     from the original.
       30*  4) change(87-12-15,Blair), approve(88-01-07,MCR7824),
       31*     audit(88-01-07,LJAdams), install(88-01-12,MR12.2-1012):
       32*     Ignore the error message when the motd segment doesn't exist in all cases.
       33*     TR 20986.
       34*                                                   END HISTORY COMMENTS */
       35 
       36 /* Prints all lines in the message-of-the-day (MOTD) segment which have been changed or added since the user last used
       37*   this command */
       38 
       39 /* Created:  28 July 1971 by Peter R. Bos */
       40 /* Modified: 14 December 1972 by R. Mullen to convert to version 2 PL/I */
       41 /* Modified: 29 March 1977 by S. Herbst to convert to iox_ */
       42 /* Modified: 14 July 1978 by S. Herbst to use Person_id.motd rather than anonymous.motd for anonymous users */
       43 /* Modified: 12 December 1979 by S. Herbst to fix no_s_permission bug when obtaining date-time-contents-modified */
       44 /* Modified: 23 March 1982 by G. Palter to convert to use the user's value segment */
       45 
       46 /* format: style4,delnl,insnl,ifthenstmt,ifthen */
       47 
       48 
       49 print_motd:
       50 pmotd:
       51      procedure () options (variable);
       52 
       53 
       54 /* DECLARATIONS */
       55 
       56 dcl  1 user_motd aligned based (user_motd_ptr),
       57        2 dtcm fixed binary (71),
       58        2 lth fixed binary (21),
       59        2 motd character (user_motd_lth refer (user_motd.lth));
       60 dcl  user_motd_ptr pointer;
       61 dcl  user_motd_lth fixed binary (21);
       62 
       63 dcl  system_motd character (system_motd_lth) based (system_motd_ptr);
       64 dcl  system_motd_lth fixed binary (21);
       65 dcl  system_motd_ptr pointer;
       66 dcl  system_motd_dtcm fixed binary (71);
       67 
       68 dcl  system_area area based (system_area_ptr);
       69 dcl  system_area_ptr pointer;
       70 dcl  user_info_$whoami entry (char(*), char(*));
       71 dcl  code fixed binary (35);
       72 
       73 dcl  (used, next_nl) fixed binary (21);
       74 
       75 dcl  n_arguments fixed binary;
       76 
       77 dcl  PRINT_MOTD character (32) static options (constant) initial ("print_motd");
       78 
       79 dcl  NL character (1) static options (constant) initial ("
       80 ");
       81 
       82 dcl  CHASE fixed binary (1) static options (constant) initial (1);
       83 dcl  DELETE_OR_UNLINK bit (6) static options (constant) initial ("010110"b);
       84 
       85 dcl  SYSTEM_CONTROL_DIR character (168) static /* options (constant) */ initial (">system_control_dir");
       86 dcl  MOTD_ENAME character (32) static options (constant) initial ("message_of_the_day");
       87 
       88 dcl  DEFAULT_VALUE_SEGMENT pointer static options (constant) initial (null ());
       89 dcl  PERMANENT_VALUE bit (36) aligned static options (constant) initial ("01"b);
       90 
       91 dcl  error_table_$action_not_performed fixed binary (35) external;
       92 dcl  error_table_$badopt fixed binary (35) external static;
       93 dcl  error_table_$no_s_permission fixed binary (35) external;
       94 dcl  error_table_$noentry fixed binary (35) external;
       95 dcl  error_table_$oldnamerr fixed binary (35) external;
       96 
       97 dcl  iox_$user_output pointer external;
       98 dcl  ioa_ entry() options(variable);
       99 dcl  ioa_$nnl entry() options(variable);
      100 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin(21), fixed bin(35));
      101 dcl  cu_$arg_count entry (fixed binary, fixed binary (35));
      102 dcl  com_err_ entry () options (variable);
      103 dcl  delete_$path entry (character (*), character (*), bit (6), character (*), fixed binary (35));
      104 dcl  get_system_free_area_ entry () returns (pointer);
      105 dcl  hcs_$status_ entry (character (*), character (*), fixed binary (1), pointer, pointer, fixed binary (35));
      106 dcl  initiate_file_ entry (character (*), character (*), bit (*), pointer, fixed binary (24), fixed binary (35));
      107 dcl  iox_$put_chars entry (pointer, pointer, fixed binary (21), fixed binary (35));
      108 dcl  pathname_ entry (character (*), character (*)) returns (character (168));
      109 dcl  terminate_file_ entry (pointer, fixed binary (24), bit (*), fixed binary (35));
      110 dcl  user_info_ entry (character (*));
      111 dcl  user_info_$homedir entry (character (*));
      112 dcl  value_$get_data
      113 	entry (pointer, bit (36) aligned, character (*), pointer, pointer, fixed binary (18), fixed binary (35));
      114 dcl  value_$get_path entry (character (*), fixed binary (35));
      115 dcl  value_$set_data
      116 	entry (pointer, bit (36) aligned, character (*), pointer, fixed binary (18), pointer, pointer,
      117 	fixed binary (18), fixed binary (35));
      118 dcl  value_$set_path entry (character (*), bit (1), fixed binary (35));
      119 
      120 dcl  cleanup condition;
      121 
      122 dcl  (addr, currentsize, divide, index, null, rtrim, length, substr, unspec) builtin;
      123 dcl  (some_type_specified_sw, need_project, curr_pj_sw, all_sw, new_sw, already_printed, have_project) bit (1) aligned init ("0"b);
      124 dcl  arg_ptr ptr;
      125 dcl  arg_len fixed bin (21);
      126 dcl  arg character (arg_len) based (arg_ptr);
      127 dcl  administrator_ename char (32);
      128 dcl  idx fixed bin;
      129 dcl  person char (22);
      130 dcl  pmotd_value_name character (32);
      131 dcl  proj char (9);
      132 dcl  my_project char (9);
      133 dcl  project_dir character (168);
      134 /**/
      135 
      136 	call cu_$arg_count (n_arguments, code);		/* insure we are invoked properly */
      137 	if code ^= 0 then do;
      138 	     call com_err_ (code, PRINT_MOTD);
      139 	     return;
      140 	end;
      141 
      142 	call user_info_$whoami (person, proj);
      143 	my_project = proj;
      144 
      145 	if n_arguments = 0 then do;
      146 	     call psmotd;
      147 	     call ppmotd;
      148 	     return;
      149 	end;
      150 
      151 	system_area_ptr = get_system_free_area_ ();
      152 	do idx = 1 to n_arguments;
      153 	     call cu_$arg_ptr (idx, arg_ptr, arg_len, code);
      154 	     if substr (arg,1,1) = "-" then do;
      155 		if need_project  & ^have_project then do;
      156 		     call com_err_ (error_table_$badopt, PRINT_MOTD, "^a, missing PROJECT", arg);
      157 		     return;
      158 		     end;	     
      159 		else if arg = "-sys" | arg = "-system"
      160 		     then do;
      161 		     some_type_specified_sw = "1"b;
      162 		     need_project = "0"b;
      163 		     end;
      164 		else if arg = "-all_text" | arg = "-all" | arg = "-a" 
      165 		     then do;
      166 			all_sw = "1"b;
      167 			new_sw ="0"b;
      168 			need_project = "0"b;
      169 			end;
      170 		else if arg = "-new_text" | arg = "-new" 
      171 		     then do;
      172 			new_sw = "1"b;
      173 			all_sw = "0"b;
      174 			need_project = "0"b;
      175 			end;
      176 		else if arg = "-project" | arg = "-pj" 
      177 		     then if idx = n_arguments then do;
      178 			call com_err_ (error_table_$badopt, PRINT_MOTD, "missing PROJECT following ^a" , arg);
      179 			return;
      180 			end;
      181 		     else do;
      182 			some_type_specified_sw = "1"b;
      183 			need_project = "1"b;
      184 			have_project = "0"b;
      185 			end;
      186 		else if arg = "-current_project" | arg = "-cpj"
      187 		     then do;
      188 			curr_pj_sw = "1"b;
      189 			need_project = "0"b;
      190 			some_type_specified_sw = "1"b;
      191 			end;
      192 		else do;
      193 		     call com_err_ (error_table_$badopt, PRINT_MOTD, "^a", arg);
      194 		     return;
      195 		     end;
      196 				
      197 		end;                /* arg didn't begin with "-" */
      198 	     else if ^need_project then do;
      199 		call com_err_ (error_table_$badopt, PRINT_MOTD, "^a", arg);
      200 		return;
      201 		end;
      202 	     else have_project = "1"b;
      203 	end;                                   /* no more arguments to process */
      204      
      205 	if n_arguments ^= 0 & ^some_type_specified_sw then do;      /* only -new or -all */
      206 	     call psmotd;
      207 	     call ppmotd;
      208 	     return;
      209 	     end;
      210 
      211 	idx = 1;
      212 	do while (idx <= n_arguments);
      213 	     call cu_$arg_ptr (idx, arg_ptr, arg_len, code);
      214 	    if arg = "-all_text" | arg = "-all" | arg = "-a" | arg = "-new_text" | arg = "-new" then idx = idx + 1;  /* skip over these */
      215 	    else if arg = "-sys" | arg = "-system" then do;
      216 		    idx = idx + 1;
      217 		    call psmotd;
      218 		    end;
      219 	     else if arg = "-current_project" | arg = "-cpj" then do;
      220 		     idx = idx + 1;
      221 		     call ppmotd;
      222 		     end;
      223 	     else do;  /* arg must be a project */
      224 		idx = idx + 1;
      225 		if  idx <= n_arguments then do;
      226 		     call cu_$arg_ptr (idx, arg_ptr, arg_len, code);
      227 		     do while ((substr (arg, 1, 1) ^= "-") & (idx <= n_arguments)); /* loop through all the projects */
      228 			proj = arg;
      229 			call ppmotd;
      230 			idx = idx +1;
      231 			if idx <= n_arguments then
      232 			     call cu_$arg_ptr (idx, arg_ptr, arg_len, code);
      233 		     end;
      234 		end;
      235 		end;
      236 	     end;
      237 	     return;
      238 /* INTERNAL SUBROUTINES */
      239 
      240 psmotd:
      241      procedure ();
      242 	project_dir = ">sc1";
      243 	pmotd_value_name = "print_motd._";
      244 	administrator_ename = MOTD_ENAME;
      245 	call main_body;
      246      end psmotd;
      247 
      248 
      249 ppmotd:
      250      procedure ();
      251 	project_dir = ">udd>" || proj;
      252 	pmotd_value_name = "project_motd." || rtrim (proj) || "._";
      253 	administrator_ename = rtrim (proj) || ".motd";
      254 	if proj = my_project & already_printed then;
      255 	else call main_body;
      256 	if proj = my_project then already_printed = "1"b;
      257      end ppmotd;
      258 
      259 main_body:
      260           procedure ();
      261 dcl  banner_printed bit (1) aligned;
      262 
      263 	system_area_ptr = get_system_free_area_ ();
      264 	user_motd_ptr, system_motd_ptr = null ();	/* for cleanup handler */
      265 
      266 	on condition (cleanup)
      267 	     begin;
      268 		if user_motd_ptr ^= null () then free user_motd in (system_area);
      269 		if system_motd_ptr ^= null () then call terminate_file_ (system_motd_ptr, 0, TERM_FILE_TERM, (0));
      270 	     end;
      271 
      272 	call get_system_motd ();			/* "fetch" system's MOTD data */
      273 
      274 	call get_user_motd ();			/* fetch user's MOTD data from the value segment */
      275 
      276 	if user_motd.dtcm >= system_motd_dtcm & ^all_sw then go to RETURN_FROM_PRINT_MOTD;
      277 						/* nothing new added to system MOTD yet */
      278 
      279 /* System MOTD has changed since this user last checked it: print any lines which do not appear in the old MOTD */
      280 
      281 	banner_printed = "0"b;
      282 
      283 	if system_motd_lth > 0 then			/* don't bother if there's nothing in it */
      284 	     if user_motd.lth = 0 | all_sw then do;		/* ... user hasn't seen any of it yet */
      285 		call ioa_ ("^[All messages^;New messages^] in ^a:^/", all_sw, administrator_ename);
      286 		call iox_$put_chars (iox_$user_output, system_motd_ptr, system_motd_lth, (0));
      287 		call ioa_$nnl ("^/");
      288 		end;
      289 	     
      290 	     else do;
      291 		used = 0;
      292 		do while (used < system_motd_lth);
      293 		     begin;
      294 dcl  rest_of_system_motd character (system_motd_lth - used) unaligned defined (system_motd) position (used + 1);
      295 			next_nl = index (rest_of_system_motd, NL);
      296 			if next_nl = 0 then		/* use reset of segment */
      297 			     next_nl = length (rest_of_system_motd);
      298 			begin;
      299 dcl  system_motd_line character (next_nl) unaligned defined (system_motd) position (used + 1);
      300 			     if index (user_motd.motd, system_motd_line) = 0 then do;
      301 				if ^banner_printed then do;
      302 				     call ioa_ ("Changed messages in ^a:^/", administrator_ename);
      303 				     banner_printed = "1"b;
      304 				     end;
      305 				call iox_$put_chars (iox_$user_output, addr (system_motd_line),
      306 				     length (system_motd_line), (0));
      307 				end;
      308 			end;
      309 			used = used + next_nl;
      310 		     end;
      311 		end;
      312 		if substr (system_motd, system_motd_lth, 1) ^= NL then call ioa_ ("^/");
      313 		else call ioa_$nnl ("^/");
      314 	     end;
      315 
      316 
      317 /* Update user's MOTD to be a copy of the current system MOTD */
      318 
      319 	free user_motd in (system_area);		/* get rid of current one */
      320 
      321 	user_motd_lth = system_motd_lth;
      322 	allocate user_motd in (system_area) set (user_motd_ptr);
      323 
      324 	user_motd.dtcm = system_motd_dtcm;
      325 	user_motd.motd = system_motd;
      326 
      327 	call put_user_motd ();			/* put it back into the value segment */
      328 
      329 RETURN_FROM_PRINT_MOTD:
      330 	if user_motd_ptr ^= null () then free user_motd in (system_area);
      331 
      332 	if system_motd_ptr ^= null () then call terminate_file_ (system_motd_ptr, 0, TERM_FILE_TERM, (0));
      333 
      334 	return;
      335 
      336 /**/
      337 
      338 /* Get the system's MOTD */
      339 
      340 get_system_motd:
      341      procedure ();
      342 
      343 dcl  1 short_status aligned like status_branch.short;
      344 dcl  system_motd_bc fixed binary (24);
      345 
      346 	call initiate_file_ (project_dir, administrator_ename, R_ACCESS, system_motd_ptr, system_motd_bc, code);
      347 	if code = error_table_$noentry then goto RETURN_FROM_PRINT_MOTD;
      348 	if code ^= 0 then do;
      349 	     call com_err_ (code, PRINT_MOTD, "^a", pathname_ (project_dir, administrator_ename));
      350 	     go to RETURN_FROM_PRINT_MOTD;
      351 	end;
      352      	if system_motd_bc = 0 then goto RETURN_FROM_PRINT_MOTD; /* segment exists, but no messages */
      353 	
      354 	call hcs_$status_ (project_dir, administrator_ename, CHASE, addr (short_status), null (), code);
      355 	if (code ^= 0) & (code ^= error_table_$no_s_permission) then do;
      356 	     call com_err_ (code, PRINT_MOTD, "Determining date-time modified of ^a.",
      357 		pathname_ (project_dir, administrator_ename));
      358 	     go to RETURN_FROM_PRINT_MOTD;
      359 	end;
      360 
      361 	system_motd_lth = divide ((system_motd_bc + 8), 9, 21, 0);
      362 	system_motd_dtcm = cv_fs_time (short_status.dtcm);
      363 
      364 	return;
      365 
      366      end get_system_motd;
      367 
      368 
      369 
      370 /* Convert a file-system date/time to a normal clock reading */
      371 
      372 cv_fs_time:
      373      procedure (p_time_bits) returns (fixed binary (71));
      374 
      375 dcl  p_time_bits bit (36) parameter;
      376 dcl  time fixed binary (71);
      377 
      378 	unspec (time) = (20)"0"b || p_time_bits || (16)"0"b;
      379 
      380 	return (time);
      381 
      382      end cv_fs_time;
      383 
      384 /**/
      385 
      386 /* Get the user's MOTD data from the value segment */
      387 
      388 get_user_motd:
      389      procedure ();
      390 
      391 	call value_$get_data (DEFAULT_VALUE_SEGMENT, PERMANENT_VALUE, pmotd_value_name, system_area_ptr, user_motd_ptr,
      392 	     (0), code);
      393 
      394 	if (code = error_table_$oldnamerr) | (code = error_table_$noentry) then do;
      395 	     call convert_motd_segment ();
      396 	     call value_$get_data (DEFAULT_VALUE_SEGMENT, PERMANENT_VALUE, pmotd_value_name, system_area_ptr,
      397 		user_motd_ptr, (0), code);
      398 	end;
      399 
      400 	if code ^= 0 then do;			/* couldn't find it anywhere: first use of print_motd */
      401 	     user_motd_lth = 0;
      402 	     allocate user_motd in (system_area) set (user_motd_ptr);
      403 	     user_motd.dtcm = 0;
      404 	end;
      405 
      406 	return;
      407 
      408 /**/
      409 
      410 /* Internal to get_user_motd: converts from the old mechanism used to store per-user MOTD data to the value segment.  The
      411*   old mechanism was a segment named Person_id.motd in the user's home directory which contained the text of the last MOTD
      412*   seen; the DTCM of the segment was used to compare against that of the system MOTD */
      413 
      414 convert_motd_segment:
      415 	procedure ();
      416 
      417 dcl  1 short_status aligned like status_branch.short;
      418 
      419 dcl  home_dir character (168);
      420 dcl  person_id character (24);
      421 
      422 dcl  old_user_motd character (user_motd_lth) based (old_user_motd_ptr);
      423 dcl  old_user_motd_bc fixed binary (24);
      424 dcl  old_user_motd_ptr pointer;
      425 dcl  old_user_motd_ename character (32);
      426 
      427 
      428 	     call user_info_$homedir (home_dir);
      429 	     call user_info_ (person_id);
      430 	     old_user_motd_ename = rtrim (person_id) || ".motd";
      431 
      432 	     old_user_motd_ptr = null ();		/* for cleanup handler */
      433 
      434 	     on condition (cleanup)
      435 		begin;
      436 		     if old_user_motd_ptr ^= null () then
      437 			call terminate_file_ (old_user_motd_ptr, 0, TERM_FILE_TERM, (0));
      438 		end;
      439 
      440 	     call initiate_file_ (home_dir, old_user_motd_ename, R_ACCESS, old_user_motd_ptr, old_user_motd_bc, code);
      441 	     if code ^= 0 then return;		/* no old-style MOTD segment */
      442 
      443 	     call hcs_$status_ (home_dir, old_user_motd_ename, CHASE, addr (short_status), null (), code);
      444 	     if (code ^= 0) & (code ^= error_table_$no_s_permission) then do;
      445 		call com_err_ (code, PRINT_MOTD, "Determining date-time modified of ^a.",
      446 		     pathname_ (home_dir, old_user_motd_ename));
      447 		short_status.dtcm = ""b;		/* assume it's very old */
      448 	     end;
      449 
      450 	     user_motd_lth = divide ((old_user_motd_bc + 8), 9, 21, 0);
      451 
      452 	     allocate user_motd in (system_area) set (user_motd_ptr);
      453 	     user_motd.dtcm = cv_fs_time (short_status.dtcm);
      454 	     user_motd.motd = old_user_motd;
      455 
      456 	     call put_user_motd ();			/* returns only if OK */
      457 
      458 	     call delete_$path (home_dir, old_user_motd_ename, DELETE_OR_UNLINK, PRINT_MOTD, code);
      459 	     if code = 0 then old_user_motd_ptr = null ();/* no longer exists */
      460 	     else if code = error_table_$action_not_performed then
      461 		call com_err_ (0, PRINT_MOTD, "^a is no longer used by this command and should be deleted.",
      462 		     pathname_ (home_dir, old_user_motd_ename));
      463 	     else call com_err_ (code, PRINT_MOTD, "Deleting ^a.", pathname_ (home_dir, old_user_motd_ename));
      464 
      465 	     return;
      466 
      467 	end convert_motd_segment;
      468 
      469      end get_user_motd;
      470 
      471 /**/
      472 
      473 /* Put the updated MOTD data into the user's value segment */
      474 
      475 put_user_motd:
      476      procedure ();
      477 
      478 	call value_$set_data (DEFAULT_VALUE_SEGMENT, PERMANENT_VALUE, pmotd_value_name, user_motd_ptr,
      479 	     currentsize (user_motd), null (), (null ()), (0), code);
      480 
      481 	if code = error_table_$noentry then do;		/* value segment not present: try to create it */
      482 	     call create_default_value_segment ();
      483 	     call value_$set_data (DEFAULT_VALUE_SEGMENT, PERMANENT_VALUE, pmotd_value_name, user_motd_ptr,
      484 		currentsize (user_motd), null (), (null ()), (0), code);
      485 	end;
      486 
      487 	if code ^= 0 then do;			/* abort the whole thing if this fails */
      488 	     call com_err_ (code, PRINT_MOTD,
      489 		"Attempting to update message-of-the-day information in default value segment.");
      490 	     go to RETURN_FROM_PRINT_MOTD;
      491 	end;
      492 
      493 	return;
      494 
      495 
      496 
      497 /* Internal to put_user_motd: create the default value segment (if possible) */
      498 
      499 create_default_value_segment:
      500 	procedure ();
      501 
      502 dcl  value_segment_path character (168);
      503 
      504 	     call value_$set_path ("", "1"b, code);
      505 
      506 	     if code = 0 then do;			/* created it */
      507 		call value_$get_path (value_segment_path, (0));
      508 		call ioa_ ("^a:  Created ^a.", PRINT_MOTD, value_segment_path);
      509 	     end;
      510 
      511 	     return;
      512 
      513 	end create_default_value_segment;
      514 
      515      end put_user_motd;
      516 
      517 /**/
      518 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      519 
      520 
  2     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  2     2 /* format: style2,^inddcls,idind32 */
  2     3 
  2     4 declare 1 terminate_file_switches	based,
  2     5 	2 truncate		bit (1) unaligned,
  2     6 	2 set_bc			bit (1) unaligned,
  2     7 	2 terminate		bit (1) unaligned,
  2     8 	2 force_write		bit (1) unaligned,
  2     9 	2 delete			bit (1) unaligned;
  2    10 
  2    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  2    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  2    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  2    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  2    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  2    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  2    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  2    18 
  2    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      521 
      522 
  3     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  3     2 
  3     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  3     4 
  3     5 /* This include file contains branch and link structures returned by
  3     6*   hcs_$status_ and hcs_$status_long. */
  3     7 
  3     8 dcl 1 status_branch aligned based (status_ptr),
  3     9     2 short aligned,
  3    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  3    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  3    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  3    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  3    14       3 dtu bit (36) unaligned,			/* date/time last used */
  3    15       3 mode bit (5) unaligned,			/* caller's effective access */
  3    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  3    17       3 pad1 bit (8) unaligned,
  3    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  3    19 
  3    20 /* Limit of information returned by hcs_$status_ */
  3    21 
  3    22     2 long aligned,
  3    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  3    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  3    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  3    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  3    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  3    28       3 pad2 bit (8) unaligned,
  3    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  3    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  3    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  3    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  3    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  3    34       3 pad3 bit (5) unaligned,
  3    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  3    36       3 uid bit (36) unaligned;			/* unique ID */
  3    37 
  3    38 dcl 1 status_link aligned based (status_ptr),
  3    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  3    40     2 nnames fixed bin (16) unaligned unsigned,
  3    41     2 names_relp bit (18) unaligned,
  3    42     2 dtem bit (36) unaligned,
  3    43     2 dtd bit (36) unaligned,
  3    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  3    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  3    46 
  3    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  3    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  3    49 						/* array of names returned */
  3    50      status_pathname character (status_link.pathname_length) aligned
  3    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  3    52 						/* link target path */
  3    53      status_area_ptr pointer,
  3    54      status_ptr pointer;
  3    55 
  3    56 dcl (Link initial (0),
  3    57      Segment initial (1),
  3    58      Directory initial (2)) fixed bin internal static options (constant);
  3    59 						/* values for type fields declared above */
  3    60 
  3    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      523 
      524 
      525      end main_body;
      526      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/12/88  1245.0  print_motd.pl1                    >spec>install>1012>print_motd.pl1
519          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
521          2    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
523          3    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CHASE                           000066 constant        fixed bin(1,0)           initial dcl 82 set ref 354* 443*
DEFAULT_VALUE_SEGMENT           000002 constant        pointer                  initial dcl 88 set ref 391* 396* 478* 483*
DELETE_OR_UNLINK                000014 constant        bit(6)                   initial unaligned dcl 83 set ref 458*
MOTD_ENAME                      000004 constant        char(32)                 initial unaligned dcl 86 ref 244
NL                              003523 constant        char(1)                  initial unaligned dcl 79 ref 295 312
PERMANENT_VALUE                 000001 constant        bit(36)                  initial dcl 89 set ref 391* 396* 478* 483*
PRINT_MOTD                      000015 constant        char(32)                 initial unaligned dcl 77 set ref 138* 156* 178* 193*
                                                                                  199* 349* 356* 445* 458* 460* 463* 488* 508*
R_ACCESS                        000056 constant        bit(3)                   initial unaligned dcl 1-11 set ref 346* 440*
TERM_FILE_TERM                  000000 constant        bit(3)                   initial unaligned dcl 2-14 set ref 269* 332* 436*
addr                                                   builtin function         dcl 122 ref 305 305 354 354 443 443
administrator_ename             000131 automatic       char(32)                 unaligned dcl 127 set ref 244* 253* 285* 302* 346*
                                                                                  349* 349* 354* 356* 356*
all_sw                          000121 automatic       bit(1)                   initial dcl 123 set ref 123* 166* 173* 276 283 285*
already_printed                 000123 automatic       bit(1)                   initial dcl 123 set ref 123* 254 256*
arg                                    based           char                     unaligned dcl 126 set ref 154 156* 159 159 164 164
                                                                                  164 170 170 176 176 178* 186 186 193* 199* 214 214
                                                                                  214 214 214 215 215 219 219 227 228
arg_len                         000130 automatic       fixed bin(21,0)          dcl 125 set ref 153* 154 156 156 159 159 164 164 164
                                                                                  170 170 176 176 178 178 186 186 193 193 199 199
                                                                                  213* 214 214 214 214 214 215 215 219 219 226* 227
                                                                                  228 231*
arg_ptr                         000126 automatic       pointer                  dcl 124 set ref 153* 154 156 159 159 164 164 164 170
                                                                                  170 176 176 178 186 186 193 199 213* 214 214 214
                                                                                  214 214 215 215 219 219 226* 227 228 231*
banner_printed                  000100 automatic       bit(1)                   dcl 261 set ref 281* 301 303*
cleanup                         000000 stack reference condition                dcl 120 ref 266 434
code                            000112 automatic       fixed bin(35,0)          dcl 71 set ref 136* 137 138* 153* 213* 226* 231*
                                                                                  346* 347 348 349* 354* 355 355 356* 391* 394 394
                                                                                  396* 400 440* 441 443* 444 444 445* 458* 459 460
                                                                                  463* 478* 481 483* 487 488* 504* 506
com_err_                        000036 constant        entry                    external dcl 102 ref 138 156 178 193 199 349 356 445
                                                                                  460 463 488
cu_$arg_count                   000034 constant        entry                    external dcl 101 ref 136
cu_$arg_ptr                     000032 constant        entry                    external dcl 100 ref 153 213 226 231
curr_pj_sw                      000120 automatic       bit(1)                   initial dcl 123 set ref 123* 188*
currentsize                                            builtin function         dcl 122 ref 478 478 483 483
delete_$path                    000040 constant        entry                    external dcl 103 ref 458
divide                                                 builtin function         dcl 122 ref 361 450
dtcm                                   based           fixed bin(71,0)          level 2 in structure "user_motd" dcl 56 in procedure
                                                                                  "pmotd" set ref 276 324* 403* 453*
dtcm                      1     000100 automatic       bit(36)                  level 2 in structure "short_status" packed unaligned
                                                                                  dcl 417 in procedure "convert_motd_segment" set
                                                                                  ref 447* 453*
dtcm                      1     000120 automatic       bit(36)                  level 2 in structure "short_status" packed unaligned
                                                                                  dcl 343 in procedure "get_system_motd" set ref
                                                                                  362*
error_table_$action_not_performed
                                000012 external static fixed bin(35,0)          dcl 91 ref 460
error_table_$badopt             000014 external static fixed bin(35,0)          dcl 92 set ref 156* 178* 193* 199*
error_table_$no_s_permission    000016 external static fixed bin(35,0)          dcl 93 ref 355 444
error_table_$noentry            000020 external static fixed bin(35,0)          dcl 94 ref 347 394 481
error_table_$oldnamerr          000022 external static fixed bin(35,0)          dcl 95 ref 394
get_system_free_area_           000042 constant        entry                    external dcl 104 ref 151 263
have_project                    000124 automatic       bit(1)                   initial dcl 123 set ref 123* 155 184* 202*
hcs_$status_                    000044 constant        entry                    external dcl 105 ref 354 443
home_dir                        000104 automatic       char(168)                unaligned dcl 419 set ref 428* 440* 443* 445* 445*
                                                                                  458* 460* 460* 463* 463*
idx                             000141 automatic       fixed bin(17,0)          dcl 128 set ref 152* 153* 176* 211* 212 213* 214*
                                                                                  214 216* 216 220* 220 224* 224 225 226* 227 230*
                                                                                  230 231 231*
index                                                  builtin function         dcl 122 ref 295 300
initiate_file_                  000046 constant        entry                    external dcl 106 ref 346 440
ioa_                            000026 constant        entry                    external dcl 98 ref 285 302 312 508
ioa_$nnl                        000030 constant        entry                    external dcl 99 ref 287 313
iox_$put_chars                  000050 constant        entry                    external dcl 107 ref 286 305
iox_$user_output                000024 external static pointer                  dcl 97 set ref 286* 305*
length                                                 builtin function         dcl 122 ref 296 305 305
lth                       2            based           fixed bin(21,0)          level 2 dcl 56 set ref 268 283 300 319 322* 325 329
                                                                                  402* 452* 454 478 478 483 483
motd                      3            based           char                     level 2 dcl 56 set ref 300 325* 454*
my_project                      000163 automatic       char(9)                  unaligned dcl 132 set ref 143* 254 256
n_arguments                     000115 automatic       fixed bin(17,0)          dcl 75 set ref 136* 145 152 176 205 212 225 227 231
need_project                    000117 automatic       bit(1)                   initial dcl 123 set ref 123* 155 162* 168* 174* 183*
                                                                                  189* 198
new_sw                          000122 automatic       bit(1)                   initial dcl 123 set ref 123* 167* 172*
next_nl                         000114 automatic       fixed bin(21,0)          dcl 73 set ref 295* 296 296* 299 309
null                                                   builtin function         dcl 122 ref 264 268 269 329 332 354 354 432 436 443
                                                                                  443 459 478 478 478 483 483 483
old_user_motd                          based           char                     unaligned dcl 422 ref 454
old_user_motd_bc                000164 automatic       fixed bin(24,0)          dcl 423 set ref 440* 450
old_user_motd_ename             000170 automatic       char(32)                 unaligned dcl 425 set ref 430* 440* 443* 445* 445*
                                                                                  458* 460* 460* 463* 463*
old_user_motd_ptr               000166 automatic       pointer                  dcl 424 set ref 432* 436 436* 440* 454 459*
p_time_bits                            parameter       bit(36)                  unaligned dcl 375 ref 372 378
pathname_                       000052 constant        entry                    external dcl 108 ref 349 349 356 356 445 445 460 460
                                                                                  463 463
person                          000142 automatic       char(22)                 unaligned dcl 129 set ref 142*
person_id                       000156 automatic       char(24)                 unaligned dcl 420 set ref 429* 430
pmotd_value_name                000150 automatic       char(32)                 unaligned dcl 130 set ref 243* 252* 391* 396* 478*
                                                                                  483*
proj                            000160 automatic       char(9)                  unaligned dcl 131 set ref 142* 143 228* 251 252 253
                                                                                  254 256
project_dir                     000166 automatic       char(168)                unaligned dcl 133 set ref 242* 251* 346* 349* 349*
                                                                                  354* 356* 356*
rest_of_system_motd                    defined         char                     unaligned dcl 294 ref 295 296
rtrim                                                  builtin function         dcl 122 ref 252 253 430
short                                  based           structure                level 2 dcl 3-8
short_status                    000100 automatic       structure                level 1 dcl 417 in procedure "convert_motd_segment"
                                                                                  set ref 443 443
short_status                    000120 automatic       structure                level 1 dcl 343 in procedure "get_system_motd" set
                                                                                  ref 354 354
some_type_specified_sw          000116 automatic       bit(1)                   initial dcl 123 set ref 123* 161* 182* 190* 205
status_branch                          based           structure                level 1 dcl 3-8
substr                                                 builtin function         dcl 122 ref 154 227 312
system_area                            based           area(1024)               dcl 68 ref 268 319 322 329 402 452
system_area_ptr                 000110 automatic       pointer                  dcl 69 set ref 151* 263* 268 319 322 329 391* 396*
                                                                                  402 452
system_motd                            based           char                     unaligned dcl 63 ref 295 295 296 296 300 300 305 305
                                                                                  305 305 305 305 305 305 312 325
system_motd_bc                  000124 automatic       fixed bin(24,0)          dcl 344 set ref 346* 352 361
system_motd_dtcm                000106 automatic       fixed bin(71,0)          dcl 66 set ref 276 324 362*
system_motd_line                       defined         char                     unaligned dcl 299 set ref 300 305 305 305 305
system_motd_lth                 000103 automatic       fixed bin(21,0)          dcl 64 set ref 283 286* 292 294 295 296 300 305 305
                                                                                  305 305 312 312 321 325 361*
system_motd_ptr                 000104 automatic       pointer                  dcl 65 set ref 264* 269 269* 286* 295 296 300 305
                                                                                  305 305 305 312 325 332 332* 346*
terminate_file_                 000054 constant        entry                    external dcl 109 ref 269 332 436
time                            000100 automatic       fixed bin(71,0)          dcl 376 set ref 378* 380
unspec                                                 builtin function         dcl 122 set ref 378*
used                            000113 automatic       fixed bin(21,0)          dcl 73 set ref 291* 292 294 295 296 300 305 305 305
                                                                                  305 309* 309
user_info_                      000056 constant        entry                    external dcl 110 ref 429
user_info_$homedir              000060 constant        entry                    external dcl 111 ref 428
user_info_$whoami               000010 constant        entry                    external dcl 70 ref 142
user_motd                              based           structure                level 1 dcl 56 set ref 268 319 322 329 402 452 478
                                                                                  478 483 483
user_motd_lth                   000102 automatic       fixed bin(21,0)          dcl 61 set ref 321* 322 322 401* 402 402 450* 452
                                                                                  452 454
user_motd_ptr                   000100 automatic       pointer                  dcl 60 set ref 264* 268 268 276 283 300 319 322* 324
                                                                                  325 329 329 391* 396* 402* 403 452* 453 454 478*
                                                                                  478 478 483* 483 483
value_$get_data                 000062 constant        entry                    external dcl 112 ref 391 396
value_$get_path                 000064 constant        entry                    external dcl 114 ref 507
value_$set_data                 000066 constant        entry                    external dcl 115 ref 478 483
value_$set_path                 000070 constant        entry                    external dcl 118 ref 504
value_segment_path              000106 automatic       char(168)                unaligned dcl 502 set ref 507* 508*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
Directory                              internal static fixed bin(17,0)          initial dcl 3-56
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Link                                   internal static fixed bin(17,0)          initial dcl 3-56
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SYSTEM_CONTROL_DIR                     internal static char(168)                initial unaligned dcl 85
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Segment                                internal static fixed bin(17,0)          initial dcl 3-56
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 2-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 2-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 2-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 2-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 2-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 2-15
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
status_area_ptr                        automatic       pointer                  dcl 3-47
status_entry_names                     based           char(32)                 array dcl 3-47
status_link                            based           structure                level 1 dcl 3-38
status_pathname                        based           char                     dcl 3-47
status_ptr                             automatic       pointer                  dcl 3-47
terminate_file_switches                based           structure                level 1 packed unaligned dcl 2-4

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN_FROM_PRINT_MOTD          001720 constant        label                    dcl 329 ref 276 347 350 352 358 490
convert_motd_segment            002435 constant        entry                    internal dcl 414 ref 395
create_default_value_segment    003425 constant        entry                    internal dcl 499 ref 482
cv_fs_time                      002245 constant        entry                    internal dcl 372 ref 362 453
get_system_motd                 001771 constant        entry                    internal dcl 340 ref 272
get_user_motd                   002273 constant        entry                    internal dcl 388 ref 274
main_body                       001267 constant        entry                    internal dcl 259 ref 245 255
pmotd                           000265 constant        entry                    external dcl 49
ppmotd                          001140 constant        entry                    internal dcl 249 ref 147 207 221 229
print_motd                      000275 constant        entry                    external dcl 49
psmotd                          001121 constant        entry                    internal dcl 240 ref 146 206 217
put_user_motd                   003214 constant        entry                    internal dcl 475 ref 327 456

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4072        4164    3527        4102
Length      4500    3527        72         300     343           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
pmotd                               213 external procedure  is an external procedure.  
psmotd                                  internal procedure  shares stack frame of external procedure pmotd.  
ppmotd                                  internal procedure  shares stack frame of external procedure pmotd.  
main_body                           302 internal procedure  enables or reverts conditions.  
on unit on line 266                  84 on unit               
begin block on line 293                 begin block         shares stack frame of internal procedure main_body.  
begin block on line 298                 begin block         shares stack frame of internal procedure main_body.  
get_system_motd                         internal procedure  shares stack frame of internal procedure main_body.  
cv_fs_time                           68 internal procedure  is called by several nonquick procedures.  
get_user_motd                           internal procedure  shares stack frame of internal procedure main_body.  
convert_motd_segment                246 internal procedure  enables or reverts conditions.  
on unit on line 434                  84 on unit               
put_user_motd                       200 internal procedure  is called by several nonquick procedures.  
create_default_value_segment            internal procedure  shares stack frame of internal procedure put_user_motd.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
convert_motd_segment     000100 short_status                convert_motd_segment
                         000104 home_dir                    convert_motd_segment
                         000156 person_id                   convert_motd_segment
                         000164 old_user_motd_bc            convert_motd_segment
                         000166 old_user_motd_ptr           convert_motd_segment
                         000170 old_user_motd_ename         convert_motd_segment
cv_fs_time               000100 time                        cv_fs_time
main_body                000100 banner_printed              main_body
                         000120 short_status                get_system_motd
                         000124 system_motd_bc              get_system_motd
pmotd                    000100 user_motd_ptr               pmotd
                         000102 user_motd_lth               pmotd
                         000103 system_motd_lth             pmotd
                         000104 system_motd_ptr             pmotd
                         000106 system_motd_dtcm            pmotd
                         000110 system_area_ptr             pmotd
                         000112 code                        pmotd
                         000113 used                        pmotd
                         000114 next_nl                     pmotd
                         000115 n_arguments                 pmotd
                         000116 some_type_specified_sw      pmotd
                         000117 need_project                pmotd
                         000120 curr_pj_sw                  pmotd
                         000121 all_sw                      pmotd
                         000122 new_sw                      pmotd
                         000123 already_printed             pmotd
                         000124 have_project                pmotd
                         000126 arg_ptr                     pmotd
                         000130 arg_len                     pmotd
                         000131 administrator_ename         pmotd
                         000141 idx                         pmotd
                         000142 person                      pmotd
                         000150 pmotd_value_name            pmotd
                         000160 proj                        pmotd
                         000163 my_project                  pmotd
                         000166 project_dir                 pmotd
put_user_motd            000106 value_segment_path          create_default_value_segment

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry           int_entry
set_chars_eis       index_chars_eis     op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   delete_$path
get_system_free_area_         hcs_$status_                  initiate_file_                ioa_
ioa_$nnl                      iox_$put_chars                pathname_                     terminate_file_
user_info_                    user_info_$homedir            user_info_$whoami             value_$get_data
value_$get_path               value_$set_data               value_$set_path

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$badopt           error_table_$no_s_permission
error_table_$noentry          error_table_$oldnamerr        iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    123 000253        49 000264       136 000303       137 000314       138 000316       139 000333       142 000334
    143 000351       145 000356       146 000360       147 000361       148 000362       151 000363       152 000372
    153 000401       154 000416       155 000423       156 000427       157 000465       159 000466       161 000477
    162 000501       163 000502       164 000503       166 000517       167 000521       168 000522       169 000523
    170 000524       172 000534       173 000536       174 000537       175 000540       176 000541       178 000554
    179 000607       182 000610       183 000612       184 000613       185 000614       186 000615       188 000625
    189 000627       190 000630       191 000631       193 000632       194 000664       197 000665       198 000666
    199 000670       200 000722       202 000723       203 000725       205 000727       206 000733       207 000734
    208 000735       211 000736       212 000740       213 000743       214 000760       215 001010       216 001020
    217 001021       218 001022       219 001023       220 001033       221 001034       222 001035       224 001036
    225 001037       226 001042       227 001057       228 001070       229 001074       230 001075       231 001076
    233 001116       236 001117       237 001120       240 001121       242 001122       243 001125       244 001130
    245 001133       246 001137       249 001140       251 001141       252 001154       253 001214       254 001243
    255 001253       256 001257       257 001265       259 001266       263 001274       264 001303       266 001307
    268 001323       269 001340       270 001375       272 001376       274 001377       276 001400       281 001407
    283 001410       285 001420       286 001444       287 001463       288 001476       291 001477       292 001500
    294 001504       295 001510       296 001523       299 001526       300 001531       301 001543       302 001545
    303 001565       305 001567       309 001614       311 001617       312 001620       313 001642       319 001655
    321 001665       322 001670       324 001704       325 001706       327 001714       329 001720       332 001734
    334 001770       340 001771       346 001772       347 002030       348 002035       349 002037       350 002106
    352 002107       354 002111       355 002150       356 002156       358 002226       361 002227       362 002233
    364 002243       372 002244       378 002252       380 002270       388 002273       391 002274       394 002335
    395 002344       396 002350       400 002411       401 002414       402 002415       403 002431       406 002433
    414 002434       428 002442       429 002452       430 002463       432 002511       434 002514       436 002530
    438 002563       440 002564       441 002623       443 002627       444 002667       445 002676       447 002747
    450 002750       452 002756       453 002774       454 003005       456 003016       458 003023       459 003055
    460 003064       463 003140       465 003212       475 003213       478 003221       481 003301       482 003307
    483 003310       487 003371       488 003375       490 003421       493 003424       499 003425       504 003426
    506 003453       507 003457       508 003475       511 003522


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
