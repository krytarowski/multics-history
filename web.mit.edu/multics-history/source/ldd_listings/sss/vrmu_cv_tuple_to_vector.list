	COMPILATION LISTING OF SEGMENT vrmu_cv_tuple_to_vector
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1156.18_Tue_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 vrmu_cv_tuple_to_vector: proc; return;
        8 
        9 /*
       10*.	 BEGIN_DESCRIPTION
       11*
       12*This routine will convert a data record from vfile_ to a vector format.
       13*
       14*.	 END_DESCRIPTION
       15**/
       16 
       17 /* History:
       18*
       19*   82-08-26  R. Harvey:  Initially written from the mess that was mu_get_data
       20*   82-11-01  R. Harvey:  Modified to use non-null simple_typed_vector_ptr
       21*   83-03-01  R. Harvey:  Modified find_and_create_item to use a character
       22*	   string copy where possible. This, along with changing the
       23*	   add_bit_offset_ type calls to use the addbitno builtin caused
       24*	   a significant performance improvement when moving long strings.
       25*   83-07-14  R. Harvey:  Changed find_and_create_item to use the current length
       26*	   of a varying string instead of the max length. Also, only 
       27*	   byte-aligned data is copied by a character move. These changes are
       28*	   due to Bert Moberg.
       29*   83-08-17  Bert Moberg: changed the per-attribute move code for increased
       30*	   speed.
       31**/
       32 
       33 simple_vector: entry (I_tuple_ptr, I_work_area_ptr, I_id_list_ptr, I_rel_desc_ptr, X_simple_typed_vector_ptr, O_code);
       34 
       35 /*       Parameters            */
       36 
       37 	dcl     I_tuple_ptr		 ptr;
       38 	dcl     I_work_area_ptr	 ptr;
       39 	dcl     I_id_list_ptr	 ptr;
       40 	dcl     I_rel_desc_ptr	 ptr;
       41 	dcl     X_simple_typed_vector_ptr ptr;
       42 	dcl     O_code		 fixed bin (35);
       43 
       44 
       45 /* Copy parameters */
       46 
       47 	tuple_ptr = I_tuple_ptr;
       48 	work_area_ptr = I_work_area_ptr;
       49 	id_list_ptr = I_id_list_ptr;
       50 	vrm_rel_desc_ptr = I_rel_desc_ptr;
       51 	simple_typed_vector_ptr = X_simple_typed_vector_ptr;
       52 
       53 	next_put_ptr = null;
       54 
       55 	if id_list_ptr ^= null then /* If an id_list exists check its version */
       56 	     if id_list.version ^= ID_LIST_VERSION_1 then
       57 		call error (error_table_$unimplemented_version);
       58 
       59 	if simple_typed_vector_ptr = null () then do;
       60 						/*  Allocate the simple vector in the caller's work area */
       61 
       62 		if id_list_ptr ^= null then
       63 		     stv_number_of_dimensions = id_list.number_of_ids; /* Number of attributes to make for this tuple */
       64 		else stv_number_of_dimensions = vrm_rel_desc.number_attrs;
       65 
       66 		on area call error (error_table_$noalloc); /* Leave this around */
       67 
       68 		allocate simple_typed_vector in (work_area) set (simple_typed_vector_ptr);
       69 
       70 		simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
       71 		simple_typed_vector.number_of_dimensions = stv_number_of_dimensions;
       72 
       73 /* Calculate length of data to be returned */
       74 
       75 		len = 0;
       76 
       77 		do i = 1 to simple_typed_vector.number_of_dimensions;
       78 		     if id_list_ptr ^= null () then
       79 			attr_id = id_list.id (i);
       80 		     else attr_id = i;
       81 
       82 		     descriptor_ptr = addr (vrm_rel_desc.attr (attr_id).descriptor);
       83 		     len = len + align_data_item (descriptor_ptr, len); /* Added necessary pad to align properly */
       84 
       85 		     len = len + vrm_rel_desc.attr (attr_id).bit_length;
       86 		end;
       87 
       88 		allocate target_str in (work_area) set (next_put_ptr); /* Allocate space for all output values needed */
       89 	     end;
       90 
       91 /* Copy specified attributes and set value_ptrs */
       92 
       93 	data_ptr = addr (tuple.data);
       94 
       95 	do i = 1 to simple_typed_vector.number_of_dimensions; /* Loop for each value to be moved */
       96 
       97 	     if id_list_ptr ^= null () then
       98 		attr_id = id_list.id (i);
       99 	     else attr_id = i;
      100 	     vrm_attr_info_ptr = addr (vrm_rel_desc.attr (attr_id));
      101 	     descriptor_ptr = addr (vrm_rel_desc.attr (attr_id).descriptor);
      102 	     if next_put_ptr ^= null () then do;	/* no vector was passed in */
      103 		     position = fixed (bitno (next_put_ptr), 24);
      104 		     next_put_ptr = addbitno (next_put_ptr, align_data_item (descriptor_ptr, position));
      105 		     simple_typed_vector.dimension (i).value_ptr = next_put_ptr;
      106 		     call find_and_create_item (descriptor_ptr, next_put_ptr, attr_len);
      107 		     next_put_ptr = addbitno (next_put_ptr, attr_len);
      108 
      109 
      110 		end;				/* no vector */
      111 	     else do;				/* vector passed in - use caller's data ptr */
      112 		     val_ptr = simple_typed_vector.dimension (i).value_ptr;
      113 		     call find_and_create_item (descriptor_ptr, val_ptr, attr_len);
      114 		end;
      115 
      116 	end;					/* attr. value loop */
      117 
      118 	X_simple_typed_vector_ptr = simple_typed_vector_ptr;
      119 	O_code = 0;
      120 
      121 Exit:	return;
      122 
      123 general_vector: entry (I_tuple_ptr, I_work_area_ptr, I_rel_desc_ptr, I_general_typed_vector_ptr, O_code);
      124 
      125 /* Parameters */
      126 
      127 /*	dcl     I_tuple_ptr		 ptr;		*/
      128 /*	dcl     I_work_area_ptr	 ptr;		*/
      129 /*	dcl     I_rel_desc_ptr	 ptr;		*/
      130 	dcl     I_general_typed_vector_ptr ptr;
      131 						/*	dcl     O_code		 fixed bin (35);	*/
      132 
      133 
      134 /* Copy input parameters */
      135 
      136 	tuple_ptr = I_tuple_ptr;
      137 	work_area_ptr = I_work_area_ptr;
      138 	vrm_rel_desc_ptr = I_rel_desc_ptr;
      139 	general_typed_vector_ptr = I_general_typed_vector_ptr;
      140 
      141 /* Calculate the length of data to be returned */
      142 
      143 	len = 0;
      144 	do i = 1 to general_typed_vector.number_of_dimensions;
      145 	     attr_id = general_typed_vector.dimension (i).identifier;
      146 	     descriptor_ptr = addr (vrm_rel_desc.attr (attr_id).descriptor);
      147 	     len = len + align_data_item (descriptor_ptr, len); /* Added necessary pad to align properly */
      148 
      149 	     len = len + vrm_rel_desc.attr (attr_id).bit_length;
      150 	end;
      151 
      152 	on area call error (error_table_$noalloc);
      153 	allocate target_str in (work_area) set (next_put_ptr); /* Set up space for output values */
      154 
      155 /* Copy each attribute selected */
      156 
      157 	data_ptr = addr (tuple.data);
      158 
      159 	do i = 1 to general_typed_vector.number_of_dimensions;
      160 	     attr_id = general_typed_vector.dimension (i).identifier;
      161 	     vrm_attr_info_ptr = addr (vrm_rel_desc.attr (attr_id));
      162 	     position = fixed (bitno (next_put_ptr), 24);
      163 	     descriptor_ptr = addr (vrm_rel_desc.attr (attr_id).descriptor);
      164 	     next_put_ptr = addbitno (next_put_ptr, align_data_item (descriptor_ptr, position));
      165 
      166 	     general_typed_vector.dimension (i).value_ptr = next_put_ptr;
      167 	     call find_and_create_item (descriptor_ptr, next_put_ptr, attr_len);
      168 	     next_put_ptr = addbitno (next_put_ptr, attr_len);
      169 	end;
      170 
      171 	O_code = 0;
      172 	return;
      173 
      174 find_and_create_item: proc (desc_ptr, target_data_ptr, len);
      175 
      176 /* 
      177*   Procedure to move a single value. If the source and target are both byte
      178*   aligned and a multiple of 9 bits in length, then use a character string
      179*   overlay to move the data instead of a bit string.
      180**/
      181 
      182 	dcl     desc_ptr		 ptr;		/* ptr to descriptor */
      183 	dcl     len		 fixed bin (24);
      184 	dcl     (toff, soff)	 fixed bin (24);
      185 	dcl     bit_str		 bit (len) based;
      186 	dcl     char_string		 char (clen) based;
      187 	dcl     clen		 fixed bin (21);
      188 	dcl     target_data_ptr	 ptr;
      189 	dcl     vary_length		 fixed bin (35) unaligned based;
      190 	dcl     equal_0_mod_9	 dim (0:36) bit (1) internal static options (constant)
      191 				 init ("1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b,
      192 				 "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b,
      193 				 "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b,
      194 				 "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b,
      195 				 "1"b);
      196 
      197 /* Set up a pointer to the item in the record and determine the length */
      198 
      199 	if vrm_attr_info.varying			/* set pointer to item */
      200 	then do;
      201 		item_ptr = addbitno (data_ptr, tuple.var_offsets (vrm_attr_info.bit_offset) - 1);
      202 		len = item_ptr -> vary_length;
      203 		if desc_ptr -> arg_descriptor.type = 22 then len = len * 9;
      204 		len = len + 36;
      205 	     end;
      206 	else do;
      207 		item_ptr = addbitno (data_ptr, vrm_attr_info.bit_offset - 1);
      208 						/* Note that a -1 is needed because a bit_offset = 1
      209*						   indicates the first bit which really is an offset of 0. */
      210 		len = vrm_attr_info.bit_length;
      211 	     end;
      212 
      213 /*  Now decide how to move the data */
      214 
      215 	if len >= MIN_CHAR_MOVE then do;		/* check for minimum bit count */
      216 		toff = fixed (addr (target_data_ptr) -> its.bit_offset); /* number of bits from a word alignment */
      217 		soff = fixed (addr (item_ptr) -> its.bit_offset);
      218 		if equal_0_mod_9 (toff) & equal_0_mod_9 (soff) & mod (len, 9) = 0 then do;
      219 			clen = divide (len, 9, 21, 0);/* number of characters to move */
      220 			target_data_ptr -> char_string = /* move by characters */
      221 			     item_ptr -> char_string;
      222 			return;			/* EXIT THIS SUBROUTINE */
      223 		     end;
      224 	     end;
      225 
      226 /* We get here if we did not do the character move */
      227 
      228 	target_data_ptr -> bit_str = item_ptr -> bit_str;
      229 
      230 
      231      end find_and_create_item;
      232 
      233 /* * * * * * * * * * * * * *     align_data_item     * * * * * * * * * * *   */
      234 
      235 align_data_item: procedure (arg_descriptor_ptr, base_to_pad) returns (fixed bin);
      236 
      237 /* HISTORY:
      238*
      239*   Originally written by Jim Gray - - December 1979
      240*
      241**/
      242 
      243 
      244 
      245 /* DESCRIPTION:
      246*
      247*   given a pointer to a standard multics pl1 data argument descriptor,
      248*   and a current storage offset at which data is to be placed,
      249*   this routine calculates from the data type, and the given address
      250*   the number of padding bits needed to properly align the data
      251*   on either a byte, word, or double word boundary, as required
      252*   by the data type definition, and routines such as assign_.
      253*   currently the data types that assign_ can handle are supported
      254*   by this routine(i.e. 1-12, 19-22, 33-34, 43-46)
      255*
      256**/
      257 
      258 /* PARAMETERS:
      259*
      260*   arg_descriptor_ptr - - (input) pointer, points to the standard multics pl1
      261*   argument descriptor for the data to be byte/word/even_word aligned using the
      262*   given address
      263*
      264*   base_to_pad - - (input) fixed bin(35), the current address(offset), of the last
      265*   data item, after which the data item described by the input descriptor
      266*   is to be placed, for the first data item, base_to_pad = 0.
      267*
      268*   needed_bits - - (output) fixed bin, the number of bits to add to base_to_pad,
      269*   in order to obtain the correct byte/word/even_word alignment for the
      270*   data type as described by the input descriptor.
      271*
      272**/
      273 
      274 /* using the declared alignment and data type for this attribute,
      275*   return the number of bits necessary to put the data on a boundary
      276*   as defined by pl1, such as byte, word or double word aligned, for using that type.
      277*   directly in such operations as the any_to_any convert via assign_
      278*   without having to do a bit move to get the proper alignment.
      279*   this makes data storage in the tuple a true representation of the pl1
      280*   attributes of unaligned and aligned for complete user choice
      281*   in the trade off between speed and space. */
      282 
      283 
      284 	dcl     needed_bits		 fixed bin;	/* number of bits needed to get the alignment */
      285 	dcl     base_to_pad		 fixed bin (24) parameter; /* original value to be padded out */
      286 
      287 	needed_bits = 0;				/* initialize */
      288 
      289 	if arg_descriptor_ptr = null () then ;
      290 	else if arg_descriptor.packed then do;		/* unaligned */
      291 
      292 		if ^(arg_descriptor.type = 21 | (arg_descriptor.type >= 9 & arg_descriptor.type <= 12) /* char or decimal */
      293 		     | (arg_descriptor.type >= 43 & arg_descriptor.type <= 46)) then ; /* packed decimal */
      294 		else needed_bits = pad (BYTE, base_to_pad);
      295 
      296 	     end;
      297 	else do;					/* aligned */
      298 
      299 		if (arg_descriptor.type >= 9 & arg_descriptor.type <= 12) | /* decimal */
      300 		     (arg_descriptor.type >= 43 & arg_descriptor.type <= 46) | /* packed decimal */
      301 		     (arg_descriptor.type >= 19 & arg_descriptor.type <= 22) | /* bit or char */
      302 		     arg_descriptor.type = 1 | arg_descriptor.type = 3 | arg_descriptor.type = 33 then /* binary short */
      303 		     needed_bits = pad (WORD, base_to_pad);
      304 
      305 		else if arg_descriptor.type = 2 | arg_descriptor.type = 34 | /* binary long */
      306 			(arg_descriptor.type >= 4 & arg_descriptor.type <= 8) then /* binary complex */
      307 		     needed_bits = pad (DOUBLE_WORD, base_to_pad);
      308 		else ;				/* none needed otherwise */
      309 
      310 	     end;
      311 
      312 	return (needed_bits);
      313 
      314 
      315 pad: procedure (pad_size, pad_base) returns (fixed bin);
      316 
      317 /* routine to return the number of bits necessary to pad a bit count
      318*   out to an alignment boundary of 9(byte), 36(word), or 72(double word) bits
      319*   as determined by the pad size input */
      320 
      321 	if mod (pad_base, pad_size) = 0 then
      322 	     number_of_bits = 0;
      323 	else do;
      324 
      325 		number_of_bits = pad_size - mod (pad_base, pad_size);
      326 
      327 	     end;
      328 
      329 	return (number_of_bits);
      330 
      331 
      332 	dcl     pad_size		 fixed bin;	/* either 9 or 36 or 72 */
      333 	dcl     pad_base		 fixed bin (24);	/* current bit length to be padded */
      334 	dcl     number_of_bits	 fixed bin;	/* what has to be added to get to the desired boundary */
      335 
      336      end pad;
      337 
  1     1 /* BEGIN INCLUDE FILE ... arg_descriptor.incl.pl1
  1     2*
  1     3*   James R. Davis 1 Mar 79 */
  1     4 /* Modified June 83 JMAthane for extended arg descriptor format */
  1     5 
  1     6      dcl	   1 arg_descriptor	      based (arg_descriptor_ptr) aligned,
  1     7 	     2 flag	      bit (1) unal,
  1     8 	     2 type	      fixed bin (6) unsigned unal,
  1     9 	     2 packed	      bit (1) unal,
  1    10 	     2 number_dims	      fixed bin (4) unsigned unal,
  1    11 	     2 size	      fixed bin (24) unsigned unal;
  1    12 
  1    13      dcl	   1 fixed_arg_descriptor based (arg_descriptor_ptr) aligned,
  1    14 	     2 flag	      bit (1) unal,
  1    15 	     2 type	      fixed bin (6) unsigned unal,
  1    16 	     2 packed	      bit (1) unal,
  1    17 	     2 number_dims	      fixed bin (4) unsigned unal,
  1    18 	     2 scale	      fixed bin (11) unal,
  1    19 	     2 precision	      fixed bin (12) unsigned unal;
  1    20 
  1    21      dcl	   1 extended_arg_descriptor based (arg_descriptor_ptr) aligned,
  1    22 	     2 flag	      bit (1) unal,		/* = "1"b */
  1    23 	     2 type	      fixed bin (6) unsigned unal, /* = 58 */
  1    24 	     2 packed	      bit (1) unal,		/* significant if number_dims ^= 0 */
  1    25 	     2 number_dims	      fixed (4) unsigned unal,/* number of variable dimensions */
  1    26 	     2 size	      bit (24) unal,
  1    27 	     2 dims	      (0 refer (extended_arg_descriptor.number_dims)), /* part referenced by called generated code */
  1    28 	       3 low	      fixed bin (35),
  1    29 	       3 high	      fixed bin (35),
  1    30 	       3 multiplier	      fixed bin (35),	/* in bits if packed, in words if not */
  1    31 	     2 real_type	      fixed bin (18) unsigned unal,
  1    32 	     2 type_offset	      fixed bin (18) unsigned unal; /* offset rel to symbol tree to symbol node for type, if any */
  1    33 
  1    34      dcl	   arg_descriptor_ptr     ptr;
  1    35 
  1    36      dcl	   extended_arg_type      fixed bin init (58);
  1    37 
  1    38 /* END INCLUDE file .... arg_descriptor.incl.pl1  */
      338 
      339 
      340 
      341 
      342 	dcl     BYTE		 fixed bin init (9) internal static options (constant); /* byte boundary = 9 bits */
      343 	dcl     WORD		 fixed bin init (36) int static options (constant); /* word boundary = 36 bits */
      344 	dcl     DOUBLE_WORD		 fixed bin init (72) int static options (constant); /* double word boundary = 72 bits */
      345 
      346 
      347 
      348      end align_data_item;
      349 
      350 error: proc (ecode);
      351 
      352 	dcl     ecode		 fixed bin (35);
      353 
      354 	if simple_typed_vector_ptr ^= null ()
      355 	then free simple_typed_vector;
      356 
      357 	O_code = ecode;
      358 
      359 	go to Exit;
      360 
      361      end;
      362 
  2     1 /*   BEGIN INCLUDE  vrm_rel_desc.incl.pl1		   */
  2     2 
  2     3 /* 83-05-26 Roger Lackey : Added vrm_attr_info.key_head bit for relation_cursors */
  2     4 
  2     5 dcl 1 vrm_rel_desc based (vrm_rel_desc_ptr),
  2     6     2 record_id bit (12) unal,			/* Distinguish us from tuples and collection records */
  2     7     2 version char (8),				/* Version of this structure */
  2     8     2 file_id bit (7),				/* Value of file id from model */
  2     9     2 rel_id bit (12),				/* Relation id */
  2    10     2 switches,
  2    11       3 MRDS_compatible bit (1) unal,			/* For pre-relation_manager_ MRDS */
  2    12       3 stationary_records
  2    13      bit (1) unal,					/* On = stationary */
  2    14       3 indexed bit (1) unal,				/* This relation has attributes with secondary indices */
  2    15       3 pad bit (33) unal,
  2    16     2 var_offset fixed bin (35),			/* Position of first varying attr */
  2    17     2 maximum_data_length
  2    18      fixed bin (35),				/* Maximum size of tuple in characters */
  2    19     2 number_primary_key_attrs
  2    20      fixed bin,					/* Number of attributes which make up the primary key */
  2    21     2 number_sec_indexes fixed bin,			/* Number of attributes which have a secondary index */
  2    22     2 last_var_attr_no fixed bin,			/* Attr index of last varying attribute */
  2    23     2 number_var_attrs fixed bin,			/* Number of varying attributes */
  2    24     2 number_attrs fixed bin,				/* Number of attribute in rel */
  2    25     2 attr (vrd_no_of_attrs				/* Description of each attribute */
  2    26      refer (vrm_rel_desc.number_attrs)) aligned like vrm_attr_info;
  2    27 
  2    28 dcl 1 vrm_attr_info based (vrm_attr_info_ptr),
  2    29 						/* Attribute specific info */
  2    30     2 name char (32),				/* Name of the attribute */
  2    31     2 descriptor bit (36) aligned,			/* domain descriptor */
  2    32     2 varying bit (1) unal,				/* ON = This is a varying string */
  2    33     2 key_head bit (1) unal,				/* ON = This attr can be a keyhead */
  2    34     2 primary_key_attr bit (1) unal,			/* ON = This is a primary key attribute */
  2    35     2 pad bit (15) unal,				/* unused */
  2    36     2 index_collextion_ix fixed bin (17) unal,		/* Index into vrm_open_info.index_collection array if key_head is on */
  2    37     2 bit_length fixed bin (35),			/* Maximum bit length of tuple */
  2    38     2 bit_offset fixed bin (35);			/* Offset in tuple if fixed, index to offset in tuple if varying */
  2    39 
  2    40 
  2    41 dcl  vrm_rel_desc_ptr pointer;
  2    42 dcl  vrd_no_of_attrs fixed bin;
  2    43 dcl  VRM_REL_DESC_RECORD_ID bit (12) unal int static options (constant) init ("100000000000"b);
  2    44 dcl  VRM_REL_DESC_VERSION_1 char (8) int static options (constant) init ("       1");
  2    45 dcl  vrm_attr_info_ptr pointer;
  2    46 dcl  VRM_REL_DESC_KEY char (256) varying int static options (constant) init ("@relation_description");
  2    47 
  2    48 /*   END INCLUDE  vrm_rel_desc.incl.pl1		   */
      363 
      364 
  3     1 /* ***********************************************************
  3     2*   *                                                         *
  3     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  3     4*   *                                                         *
  3     5*   *********************************************************** */
  3     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  3     7 
  3     8 /* Written by Lindsey Spratt, 04/02/82.
  3     9*Modified:
  3    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  3    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  3    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  3    13*	  type.
  3    14**/
  3    15 
  3    16 /* format: style2,ind3 */
  3    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  3    18 	     2 type	      fixed bin (17) unal,
  3    19 	     2 number_of_dimensions
  3    20 			      fixed bin (17) unal,
  3    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  3    22 	       3 value_ptr	      ptr unaligned;
  3    23 
  3    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  3    25 	     2 type	      fixed bin (17) unal,
  3    26 	     2 number_of_dimensions
  3    27 			      fixed bin (17) unal,
  3    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  3    29 	       3 identifier	      fixed bin (17) unal,
  3    30 	       3 pad	      bit (18) unal,
  3    31 	       3 value_ptr	      ptr unal;
  3    32 
  3    33      dcl	   simple_typed_vector_ptr
  3    34 			      ptr;
  3    35      dcl	   stv_number_of_dimensions
  3    36 			      fixed bin (17);
  3    37 
  3    38      dcl	   general_typed_vector_ptr
  3    39 			      ptr;
  3    40      dcl	   gtv_number_of_dimensions
  3    41 			      fixed bin (17);
  3    42 
  3    43      dcl	   (
  3    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  3    45 			      init (1),		/* value_ptr was aligned. */
  3    46 	   GENERAL_TYPED_VECTOR_TYPE
  3    47 			      init (2),
  3    48 	   SIMPLE_TYPED_VECTOR_TYPE
  3    49 			      init (3)
  3    50 	   )		      fixed bin (17) internal static options (constant);
  3    51 
  3    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      365 
      366 
  4     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION
  4     4*        The id_list structure is used to identify attributes, fields and
  4     5*   dimensions by various modules of the Data Management System.
  4     6**/
  4     7 
  4     8 /* HISTORY:
  4     9*Written by Matthew Pierret, '82.
  4    10*Modified:
  4    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  4    12*            (constant)' and to initialize automatic variables.
  4    13**/
  4    14 
  4    15 /* format: style2,ind3 */
  4    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  4    17 	     2 version	      fixed bin (35),
  4    18 	     2 number_of_ids      fixed bin (17),
  4    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  4    20 
  4    21      dcl	   id_list_ptr	      ptr init (null);
  4    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  4    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  4    24 
  4    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      367 
      368 
  5     1 /* BEGIN vrm_tuple.incl.pl1 -- jaw, 7/25/78 */
  5     2 
  5     3 /* 82-08-27 R. Harvey: taken from mdbm_tuple.incl.pl1 for vfile_relmgr_.
  5     4*   Modified dimension references to point to entries in vrm_rel_desc.    */ 
  5     5 
  5     6 
  5     7 dcl 1 tuple aligned based (tuple_ptr),			/* tuple format, all file types */
  5     8     2 rel_id bit (12) unal,				/* relation id */
  5     9     2 attr_exists (vrm_rel_desc.number_attrs) bit (1) unal,	/* existance flags */
  5    10     2 var_offsets (vrm_rel_desc.number_var_attrs) fixed bin (35) unal, /* offsets for variable attr.; stored as len|value */
  5    11     2 force_even_word (tuple_pad_length) fixed bin (71) aligned, /* pad to even word boundary */
  5    12     2 data char (vrm_rel_desc.maximum_data_length) unal;		/* space for data */
  5    13 
  5    14 
  5    15 dcl  tuple_ptr ptr;
  5    16 dcl  tuple_length fixed bin (21);			/* byte count */
  5    17 
  5    18 declare  tuple_pad_length fixed bin internal static init (0) ; /* minimum array size needed for even word padding */
  5    19 
  5    20 
  5    21 
  5    22 /* END vrm_tuple.incl.pl1 */
  5    23 
      369 
      370 
  6     1 /* BEGIN INCLUDE FILE its.incl.pl1
  6     2*   modified 27 July 79 by JRDavis to add its_unsigned
  6     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  6     4 
  6     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  6     6     2 pad1 bit (3) unaligned,
  6     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  6     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  6     9     2 pad2 bit (9) unaligned,
  6    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  6    11 
  6    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  6    13     2 pad3 bit (3) unaligned,
  6    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  6    15     2 pad4 bit (3) unaligned,
  6    16     2 mod bit (6) unaligned;				/* further modification */
  6    17 
  6    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  6    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  6    20     2 pad1 bit (27) unaligned,
  6    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  6    22 
  6    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  6    24     2 pad2 bit (3) unaligned,
  6    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  6    26     2 pad3 bit (3) unaligned,
  6    27     2 mod bit (6) unaligned;				/* further modification */
  6    28 
  6    29 
  6    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  6    31     2 pad1 bit (3) unaligned,
  6    32     2 segno fixed bin (15) unsigned unaligned,
  6    33     2 ringno fixed bin (3) unsigned unaligned,
  6    34     2 pad2 bit (9) unaligned,
  6    35     2 its_mod bit (6) unaligned,
  6    36 
  6    37     2 offset fixed bin (18) unsigned unaligned,
  6    38     2 pad3 bit (3) unaligned,
  6    39     2 bit_offset fixed bin (6) unsigned unaligned,
  6    40     2 pad4 bit (3) unaligned,
  6    41     2 mod bit (6) unaligned;
  6    42 
  6    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  6    44     2 pr_no fixed bin (3) unsigned unaligned,
  6    45     2 pad1 bit (27) unaligned,
  6    46     2 itp_mod bit (6) unaligned,
  6    47 
  6    48     2 offset fixed bin (18) unsigned unaligned,
  6    49     2 pad2 bit (3) unaligned,
  6    50     2 bit_offset fixed bin (6) unsigned unaligned,
  6    51     2 pad3 bit (3) unaligned,
  6    52     2 mod bit (6) unaligned;
  6    53 
  6    54 
  6    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  6    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  6    57 
  6    58 /* END INCLUDE FILE   its.incl.pl1 */
      371 
      372 
  7     1 /* BEGIN INCLUDE FILE ... arg_descriptor.incl.pl1
  7     2*
  7     3*   James R. Davis 1 Mar 79 */
  7     4 /* Modified June 83 JMAthane for extended arg descriptor format */
  7     5 
  7     6      dcl	   1 arg_descriptor	      based (arg_descriptor_ptr) aligned,
  7     7 	     2 flag	      bit (1) unal,
  7     8 	     2 type	      fixed bin (6) unsigned unal,
  7     9 	     2 packed	      bit (1) unal,
  7    10 	     2 number_dims	      fixed bin (4) unsigned unal,
  7    11 	     2 size	      fixed bin (24) unsigned unal;
  7    12 
  7    13      dcl	   1 fixed_arg_descriptor based (arg_descriptor_ptr) aligned,
  7    14 	     2 flag	      bit (1) unal,
  7    15 	     2 type	      fixed bin (6) unsigned unal,
  7    16 	     2 packed	      bit (1) unal,
  7    17 	     2 number_dims	      fixed bin (4) unsigned unal,
  7    18 	     2 scale	      fixed bin (11) unal,
  7    19 	     2 precision	      fixed bin (12) unsigned unal;
  7    20 
  7    21      dcl	   1 extended_arg_descriptor based (arg_descriptor_ptr) aligned,
  7    22 	     2 flag	      bit (1) unal,		/* = "1"b */
  7    23 	     2 type	      fixed bin (6) unsigned unal, /* = 58 */
  7    24 	     2 packed	      bit (1) unal,		/* significant if number_dims ^= 0 */
  7    25 	     2 number_dims	      fixed (4) unsigned unal,/* number of variable dimensions */
  7    26 	     2 size	      bit (24) unal,
  7    27 	     2 dims	      (0 refer (extended_arg_descriptor.number_dims)), /* part referenced by called generated code */
  7    28 	       3 low	      fixed bin (35),
  7    29 	       3 high	      fixed bin (35),
  7    30 	       3 multiplier	      fixed bin (35),	/* in bits if packed, in words if not */
  7    31 	     2 real_type	      fixed bin (18) unsigned unal,
  7    32 	     2 type_offset	      fixed bin (18) unsigned unal; /* offset rel to symbol tree to symbol node for type, if any */
  7    33 
  7    34      dcl	   arg_descriptor_ptr     ptr;
  7    35 
  7    36      dcl	   extended_arg_type      fixed bin init (58);
  7    37 
  7    38 /* END INCLUDE file .... arg_descriptor.incl.pl1  */
      373 
      374 
      375 	dcl     addbitno		 builtin;
      376 	dcl     area		 condition;
      377 	dcl     attr_id		 fixed bin;	/* attribute identifier for temp use */
      378 	dcl     attr_len		 fixed bin (24);
      379 	dcl     bitno		 builtin;
      380 	dcl     data_ptr		 ptr;
      381 	dcl     descriptor_ptr	 ptr;
      382 	dcl     error_table_$noalloc	 fixed bin (35) ext static;
      383 	dcl     error_table_$unimplemented_version fixed bin (35) ext static;
      384 	dcl     i			 fixed bin;	/* do index */
      385 	dcl     item_ptr		 ptr;
      386 	dcl     len		 fixed bin (24);
      387 	dcl     MIN_CHAR_MOVE	 fixed bin int static init (90); /* number of bits */
      388 	dcl     next_put_ptr	 ptr;		/* used to keep place in output area */
      389 	dcl     position		 fixed bin (24);
      390 	dcl     target_str		 bit (len) based;
      391 	dcl     val_ptr		 ptr;
      392 	dcl     work_area		 area based (work_area_ptr);
      393 	dcl     work_area_ptr	 ptr;
      394 
      395 
      396 	dcl     (addr, divide, fixed, mod, null) builtin;
      397 
      398 
      399 
      400      end vrmu_cv_tuple_to_vector;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1156.1  vrmu_cv_tuple_to_vector.pl1       >udd>sm>ds>w>ml>vrmu_cv_tuple_to_vector.pl1
338          1    11/02/83  1945.0  arg_descriptor.incl.pl1           >ldd>incl>arg_descriptor.incl.pl1
363          2    10/14/83  1709.1  vrm_rel_desc.incl.pl1             >ldd>incl>vrm_rel_desc.incl.pl1
365          3    10/14/83  1709.1  vu_typed_vector.incl.pl1          >ldd>incl>vu_typed_vector.incl.pl1
367          4    10/14/83  1709.1  dm_id_list.incl.pl1               >ldd>incl>dm_id_list.incl.pl1
369          5    10/14/83  1709.1  vrm_tuple.incl.pl1                >ldd>incl>vrm_tuple.incl.pl1
371          6    11/26/79  1420.6  its.incl.pl1                      >ldd>incl>its.incl.pl1
373          7    11/02/83  1945.0  arg_descriptor.incl.pl1           >ldd>incl>arg_descriptor.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BYTE                            000006 constant        fixed bin(17,0)          initial dcl 342 set ref 294*
DOUBLE_WORD                     000000 constant        fixed bin(17,0)          initial dcl 344 set ref 305*
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 4-23 ref 55
I_general_typed_vector_ptr             parameter       pointer                  dcl 130 ref 123 139
I_id_list_ptr                          parameter       pointer                  dcl 39 ref 33 49
I_rel_desc_ptr                         parameter       pointer                  dcl 40 ref 33 50 123 138
I_tuple_ptr                            parameter       pointer                  dcl 37 ref 33 47 123 136
I_work_area_ptr                        parameter       pointer                  dcl 38 ref 33 48 123 137
MIN_CHAR_MOVE                          constant        fixed bin(17,0)          initial dcl 387 ref 215
O_code                                 parameter       fixed bin(35,0)          dcl 42 set ref 33 119* 123 171* 357*
SIMPLE_TYPED_VECTOR_TYPE               constant        fixed bin(17,0)          initial dcl 3-43 ref 70
WORD                            000007 constant        fixed bin(17,0)          initial dcl 343 set ref 299*
X_simple_typed_vector_ptr              parameter       pointer                  dcl 41 set ref 33 51 118*
addbitno                                               builtin function         dcl 375 ref 104 107 164 168 201 207
addr                                                   builtin function         dcl 396 ref 82 93 100 101 146 157 161 163 216 217
area                            000122 stack reference condition                dcl 376 ref 66 152
arg_descriptor                         based           structure                level 1 dcl 7-6 in procedure
                                                                                  "vrmu_cv_tuple_to_vector"
arg_descriptor                         based           structure                level 1 dcl 1-6 in procedure "align_data_item"
arg_descriptor_ptr                     parameter       pointer                  dcl 1-34 ref 235 289 290 292 292 292 292 292 299 299
                                                                                  299 299 299 299 299 299 299 305 305 305 305
attr                     14            based           structure                array level 2 dcl 2-5 set ref 100 161
attr_id                         000130 automatic       fixed bin(17,0)          dcl 377 set ref 78* 80* 82 85 97* 99* 100 101 145*
                                                                                  146 149 160* 161 163
attr_len                        000131 automatic       fixed bin(24,0)          dcl 378 set ref 106* 107 113* 167* 168
base_to_pad                            parameter       fixed bin(24,0)          dcl 285 set ref 235 294* 299* 305*
bit_length               26            based           fixed bin(35,0)          array level 3 in structure "vrm_rel_desc" dcl 2-5
                                                                                  in procedure "vrmu_cv_tuple_to_vector" set ref 85
                                                                                  149
bit_length               12            based           fixed bin(35,0)          level 2 in structure "vrm_attr_info" dcl 2-28
                                                                                  in procedure "vrmu_cv_tuple_to_vector" ref 210
bit_offset               13            based           fixed bin(35,0)          level 2 in structure "vrm_attr_info" dcl 2-28
                                                                                  in procedure "vrmu_cv_tuple_to_vector" ref 201 207
bit_offset                1(21)        based           bit(6)                   level 2 in structure "its" packed packed unaligned
                                                                                  dcl 6-5 in procedure "vrmu_cv_tuple_to_vector" ref
                                                                                  216 217
bit_str                                based           bit                      packed unaligned dcl 185 set ref 228* 228
bitno                                                  builtin function         dcl 379 ref 103 162
char_string                            based           char                     packed unaligned dcl 186 set ref 220* 220
clen                            000300 automatic       fixed bin(21,0)          dcl 187 set ref 219* 220 220
data                                   based           char                     level 2 packed packed unaligned dcl 5-7 set ref 93
                                                                                  157
data_ptr                        000132 automatic       pointer                  dcl 380 set ref 93* 157* 201 207
desc_ptr                               parameter       pointer                  dcl 182 ref 174 203
descriptor               24            based           bit(36)                  array level 3 dcl 2-5 set ref 82 101 146 163
descriptor_ptr                  000134 automatic       pointer                  dcl 381 set ref 82* 83* 101* 104* 106* 113* 146*
                                                                                  147* 163* 164* 167*
dimension                 1            based           structure                array level 2 in structure "simple_typed_vector"
                                                                                  packed packed unaligned dcl 3-17 in procedure
                                                                                  "vrmu_cv_tuple_to_vector"
dimension                 1            based           structure                array level 2 in structure "general_typed_vector"
                                                                                  packed packed unaligned dcl 3-24 in procedure
                                                                                  "vrmu_cv_tuple_to_vector"
divide                                                 builtin function         dcl 396 ref 219
ecode                                  parameter       fixed bin(35,0)          dcl 352 ref 350 357
equal_0_mod_9                   000002 constant        bit(1)                   initial array packed unaligned dcl 190 ref 218 218
error_table_$noalloc            000010 external static fixed bin(35,0)          dcl 382 set ref 66* 152*
error_table_$unimplemented_version
                                000012 external static fixed bin(35,0)          dcl 383 set ref 55*
extended_arg_type               000120 automatic       fixed bin(17,0)          initial dcl 7-36 in procedure
                                                                                  "vrmu_cv_tuple_to_vector" set ref 7-36*
extended_arg_type               000311 automatic       fixed bin(17,0)          initial dcl 1-36 in procedure "align_data_item" set
                                                                                  ref 1-36*
fixed                                                  builtin function         dcl 396 ref 103 162 216 217
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 3-24
general_typed_vector_ptr        000110 automatic       pointer                  dcl 3-38 set ref 139* 144 145 159 160 166
i                               000136 automatic       fixed bin(17,0)          dcl 384 set ref 77* 78 80* 95* 97 99 105 112* 144*
                                                                                  145* 159* 160 166*
id                        2            based           fixed bin(17,0)          array level 2 dcl 4-16 ref 78 97
id_list                                based           structure                level 1 dcl 4-16
id_list_ptr                     000112 automatic       pointer                  initial dcl 4-21 set ref 49* 55 55 62 62 78 78 97 97
                                                                                  4-21*
identifier                1            based           fixed bin(17,0)          array level 3 packed packed unaligned dcl 3-24 ref
                                                                                  145 160
il_number_of_ids                000114 automatic       fixed bin(17,0)          initial dcl 4-22 set ref 4-22*
item_ptr                        000140 automatic       pointer                  dcl 385 set ref 201* 202 207* 217 220 228
its                                    based           structure                level 1 dcl 6-5
len                                    parameter       fixed bin(24,0)          dcl 183 in procedure "find_and_create_item" set ref
                                                                                  174 202* 203* 203 204* 204 210* 215 218 219 228
                                                                                  228
len                             000142 automatic       fixed bin(24,0)          dcl 386 in procedure "vrmu_cv_tuple_to_vector" set
                                                                                  ref 75* 83* 83 83* 85* 85 88 88 143* 147* 147 147*
                                                                                  149* 149 153 153
maximum_data_length       6            based           fixed bin(35,0)          level 2 dcl 2-5 ref 93 157
mod                                                    builtin function         dcl 396 ref 218 321 325
needed_bits                     000310 automatic       fixed bin(17,0)          dcl 284 set ref 287* 294* 299* 305* 312
next_put_ptr                    000144 automatic       pointer                  dcl 388 set ref 53* 88* 102 103 104* 104 105 106*
                                                                                  107* 107 153* 162 164* 164 166 167* 168* 168
null                                                   builtin function         dcl 396 ref 53 55 59 62 78 97 102 4-21 289 354
number_attrs             13            based           fixed bin(17,0)          level 2 dcl 2-5 ref 64 93 157 201
number_of_bits                  000320 automatic       fixed bin(17,0)          dcl 334 set ref 321* 325* 329
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 3-17 in procedure
                                                                                  "vrmu_cv_tuple_to_vector" set ref 68* 71* 77 95
                                                                                  354
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "general_typed_vector" packed
                                                                                  packed unaligned dcl 3-24 in procedure
                                                                                  "vrmu_cv_tuple_to_vector" ref 144 159
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 4-16 ref 62
number_var_attrs         12            based           fixed bin(17,0)          level 2 dcl 2-5 ref 93 157
packed                    0(07)        based           bit(1)                   level 2 packed packed unaligned dcl 1-6 ref 290
pad_base                               parameter       fixed bin(24,0)          dcl 333 ref 315 321 325
pad_size                               parameter       fixed bin(17,0)          dcl 332 ref 315 321 325 325
position                        000146 automatic       fixed bin(24,0)          dcl 389 set ref 103* 104* 162* 164*
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 3-17 set ref 68
                                                                                  354
simple_typed_vector_ptr         000104 automatic       pointer                  dcl 3-33 set ref 51* 59 68* 70 71 77 95 105 112 118
                                                                                  354 354
soff                            000277 automatic       fixed bin(24,0)          dcl 184 set ref 217* 218
stv_number_of_dimensions        000106 automatic       fixed bin(17,0)          dcl 3-35 set ref 62* 64* 68 68 71
target_data_ptr                        parameter       pointer                  dcl 188 set ref 174 216 220 228
target_str                             based           bit                      packed unaligned dcl 390 ref 88 153
toff                            000276 automatic       fixed bin(24,0)          dcl 184 set ref 216* 218
tuple                                  based           structure                level 1 dcl 5-7
tuple_pad_length                       constant        fixed bin(17,0)          initial dcl 5-18 ref 93 157
tuple_ptr                       000116 automatic       pointer                  dcl 5-15 set ref 47* 93 136* 157 201
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "arg_descriptor" packed packed
                                                                                  unsigned unaligned dcl 1-6 in procedure
                                                                                  "align_data_item" ref 292 292 292 292 292 299 299
                                                                                  299 299 299 299 299 299 299 305 305 305 305
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 3-17 in procedure
                                                                                  "vrmu_cv_tuple_to_vector" set ref 70*
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "arg_descriptor" packed packed
                                                                                  unsigned unaligned dcl 7-6 in procedure
                                                                                  "vrmu_cv_tuple_to_vector" ref 203
val_ptr                         000150 automatic       pointer                  dcl 391 set ref 112* 113*
value_ptr                 2            based           pointer                  array level 3 in structure "general_typed_vector"
                                                                                  packed packed unaligned dcl 3-24 in procedure
                                                                                  "vrmu_cv_tuple_to_vector" set ref 166*
value_ptr                 1            based           pointer                  array level 3 in structure "simple_typed_vector"
                                                                                  packed packed unaligned dcl 3-17 in procedure
                                                                                  "vrmu_cv_tuple_to_vector" set ref 105* 112
var_offsets                            based           fixed bin(35,0)          array level 2 packed packed unaligned dcl 5-7 ref
                                                                                  201
vary_length                            based           fixed bin(35,0)          packed unaligned dcl 189 ref 202
varying                  11            based           bit(1)                   level 2 packed packed unaligned dcl 2-28 ref 199
version                                based           fixed bin(35,0)          level 2 dcl 4-16 ref 55
vrm_attr_info                          based           structure                level 1 unaligned dcl 2-28
vrm_attr_info_ptr               000102 automatic       pointer                  dcl 2-45 set ref 100* 161* 199 201 207 210
vrm_rel_desc                           based           structure                level 1 unaligned dcl 2-5
vrm_rel_desc_ptr                000100 automatic       pointer                  dcl 2-41 set ref 50* 64 82 85 93 93 93 100 101 138*
                                                                                  146 149 157 157 157 161 163 201
work_area                              based           area(1024)               dcl 392 ref 68 88 153
work_area_ptr                   000152 automatic       pointer                  dcl 393 set ref 48* 68 88 137* 153

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 3-43
ITP_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 6-56
ITS_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 6-55
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 3-43
VRM_REL_DESC_KEY                       internal static varying char(256)        initial dcl 2-46
VRM_REL_DESC_RECORD_ID                 internal static bit(12)                  initial packed unaligned dcl 2-43
VRM_REL_DESC_VERSION_1                 internal static char(8)                  initial packed unaligned dcl 2-44
arg_descriptor_ptr                     automatic       pointer                  dcl 7-34
extended_arg_descriptor                based           structure                level 1 dcl 7-21 in procedure
                                                                                  "vrmu_cv_tuple_to_vector"
extended_arg_descriptor                based           structure                level 1 dcl 1-21 in procedure "align_data_item"
fixed_arg_descriptor                   based           structure                level 1 dcl 1-13 in procedure "align_data_item"
fixed_arg_descriptor                   based           structure                level 1 dcl 7-13 in procedure
                                                                                  "vrmu_cv_tuple_to_vector"
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 3-40
itp                                    based           structure                level 1 dcl 6-18
itp_unsigned                           based           structure                level 1 dcl 6-43
its_unsigned                           based           structure                level 1 dcl 6-30
tuple_length                           automatic       fixed bin(21,0)          dcl 5-16
vrd_no_of_attrs                        automatic       fixed bin(17,0)          dcl 2-42

NAMES DECLARED BY EXPLICIT CONTEXT.
Exit                            000422 constant        label                    dcl 121 set ref 359
align_data_item                 001042 constant        entry                    internal dcl 235 ref 83 104 147 164
error                           001225 constant        entry                    internal dcl 350 ref 55 66 152
find_and_create_item            000676 constant        entry                    internal dcl 174 ref 106 113 167
general_vector                  000430 constant        entry                    external dcl 123
pad                             001204 constant        entry                    internal dcl 315 ref 294 299 305
simple_vector                   000045 constant        entry                    external dcl 33
vrmu_cv_tuple_to_vector         000030 constant        entry                    external dcl 7

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1430        1444    1321        1440
Length      1754    1321        14         273     106           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vrmu_cv_tuple_to_vector             231 external procedure  is an external procedure.  
on unit on line 66                   70 on unit               
on unit on line 152                  70 on unit               
find_and_create_item                    internal procedure  shares stack frame of external procedure vrmu_cv_tuple_to_vector.  
align_data_item                         internal procedure  shares stack frame of external procedure vrmu_cv_tuple_to_vector.  
pad                                     internal procedure  shares stack frame of external procedure vrmu_cv_tuple_to_vector.  
error                                64 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
vrmu_cv_tuple_to_vector  000100 vrm_rel_desc_ptr            vrmu_cv_tuple_to_vector
                         000102 vrm_attr_info_ptr           vrmu_cv_tuple_to_vector
                         000104 simple_typed_vector_ptr     vrmu_cv_tuple_to_vector
                         000106 stv_number_of_dimensions    vrmu_cv_tuple_to_vector
                         000110 general_typed_vector_ptr    vrmu_cv_tuple_to_vector
                         000112 id_list_ptr                 vrmu_cv_tuple_to_vector
                         000114 il_number_of_ids            vrmu_cv_tuple_to_vector
                         000116 tuple_ptr                   vrmu_cv_tuple_to_vector
                         000120 extended_arg_type           vrmu_cv_tuple_to_vector
                         000130 attr_id                     vrmu_cv_tuple_to_vector
                         000131 attr_len                    vrmu_cv_tuple_to_vector
                         000132 data_ptr                    vrmu_cv_tuple_to_vector
                         000134 descriptor_ptr              vrmu_cv_tuple_to_vector
                         000136 i                           vrmu_cv_tuple_to_vector
                         000140 item_ptr                    vrmu_cv_tuple_to_vector
                         000142 len                         vrmu_cv_tuple_to_vector
                         000144 next_put_ptr                vrmu_cv_tuple_to_vector
                         000146 position                    vrmu_cv_tuple_to_vector
                         000150 val_ptr                     vrmu_cv_tuple_to_vector
                         000152 work_area_ptr               vrmu_cv_tuple_to_vector
                         000276 toff                        find_and_create_item
                         000277 soff                        find_and_create_item
                         000300 clen                        find_and_create_item
                         000310 needed_bits                 align_data_item
                         000311 extended_arg_type           align_data_item
                         000320 number_of_bits              pad

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_int_this       call_int_other      return_mac          tra_ext_1           mdfx1               enable_op
ext_entry           int_entry           op_alloc_           op_freen_

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$noalloc          error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 4   21 000017    4   22 000021    7   36 000023         7 000027         7 000036        33 000037        47 000060
     48 000064        49 000067        50 000072        51 000075        53 000100        55 000102        59 000117
     62 000123        64 000133        66 000136        68 000162        70 000176        71 000201        75 000207
     77 000210        78 000223        80 000234        82 000236        83 000242        85 000246        86 000256
     88 000260        93 000267        95 000307        97 000323        99 000334       100 000336       101 000341
    102 000344       103 000350       104 000360       105 000366       106 000374       107 000376       110 000402
    112 000403       113 000412       116 000414       118 000416       119 000421       121 000422       123 000423
    136 000443       137 000447       138 000452       139 000455       143 000460       144 000461       145 000475
    146 000506       147 000512       149 000516       150 000526       152 000530       153 000554       157 000563
    159 000603       160 000617       161 000630       162 000633       163 000644       164 000647       166 000655
    167 000664       168 000666       169 000672       171 000674       172 000675       174 000676       199 000700
    201 000704       202 000732       203 000740       204 000751       205 000753       207 000754       210 000764
    215 000766       216 000771       217 000776       218 001002       219 001020       220 001024       222 001031
    228 001032       231 001041       235 001042    1   36 001044       287 001046       289 001047       290 001054
    292 001060       294 001077       296 001112       299 001113       305 001155       312 001200       315 001204
    321 001206       325 001215       329 001220       350 001224       354 001232       357 001250       359 001254


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
