	COMPILATION LISTING OF SEGMENT mrds_dm_display_cmdb
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1335.8 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 mrds_dm_display_cmdb: proc (I_mrds_dm_display_info_ptr, O_err_msg, O_err_code);
        8 
        9 /* The purpose of this procedure is to display the db_model info in the
       10*   form of a cmdb source.  The output is through the iocb_ptr supplied in
       11*   mrds_dm_display_info.
       12**/
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(82-05-15,Lackey), approve(), audit(), install():
       17*     written.
       18*  2) change(83-10-03,Benjamin), approve(), audit(), install():
       19*     to put the attribute information handling inside a begin block to keep from
       20*     truncating the line when there are a lot of attributes.
       21*  3) change(85-12-07,Spitzer), approve(85-12-07,MCR7311),
       22*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
       23*     Don't put unreferenced domains in the cmdb output. Put in a check to see
       24*     if there are any referenced domains in the database. Use crossreference
       25*     file for list of attributes.
       26*                                                   END HISTORY COMMENTS */
       27 
       28 
       29 /*      PARAMETERS     */
       30 
       31 	dcl     I_mrds_dm_display_info_ptr ptr parameter; /* Pointer to mrds_dm_display_info structure */
       32 	dcl     O_err_msg		 char (*) parameter;/* Text of error message */
       33 	dcl     O_err_code		 fixed bin (35) parameter; /* Erro code */
       34 
       35 
       36 /* mrds_dm_display_cmdb:  proc (I_mrds_dm_display_info_ptr, O_err_msg, O_err_code); */
       37 
       38 	mrds_dm_display_info_ptr = I_mrds_dm_display_info_ptr; /* Init parameters */
       39 	O_err_msg = "";
       40 	O_err_code = 0;
       41 
       42 	iocb_ptr = mrds_dm_display_info.output_iocb_ptr;	/* For faster reference */
       43 	temp_file_iocb_ptr = null;
       44 	dbm_ptr = mrds_dm_display_info.dbm_ptr;
       45 	rel_name_table_ptr = null;			/* Not allocated yet */
       46 	number_indexed_rels = 0;			/* Number relations indexed */
       47 
       48 	on cleanup call tidy_up;			/* Establish clenaup handler */
       49 
       50 
       51 	if mrds_dm_display_info.version ^= MRDS_DM_DISPLAY_INFO_VERSION_1 then
       52 	     call error (error_table_$unimplemented_version,
       53 		"For mrds_dm_display_info.version");
       54 
       55 
       56 
       57 /*   ****   Output the header   ***    */
       58 
       59 	if mrds_dm_display_info.sw.long then do;	/* If long output header */
       60 
       61 		call date_time_ (clock (), time_of_list);
       62 
       63 		call
       64 		     ioa_$ioa_switch (iocb_ptr,
       65 		     "^/ /* Created from   ^a ^/^2-^a^-*/",
       66 		     mrds_dm_display_info.db_path,
       67 		     time_of_list);
       68 	     end;
       69 
       70 /*    **** Output domain section  ****    */
       71 
       72 	if db_model.domain_ptr = NULL_OFFSET then do;
       73 NO_DOMAINS:         call ioa_$ioa_switch (iocb_ptr,
       74 		     "^2/No domains exist for the data base^/^a",
       75 		     mrds_dm_display_info.db_path);
       76 		return;
       77 	     end;
       78 
       79 	call ioa_$ioa_switch (iocb_ptr, "^/domain:");	/* Domain section */
       80 
       81 	found_one = "1"b;
       82 	do di_ptr = ptr (dbm_ptr, db_model.domain_ptr) /* Loop thru all domains */
       83 	     repeat ptr (dbm_ptr, domain_info.fwd_thread)
       84 	     while (rel (di_ptr) ^= NULL_OFFSET);
       85 
       86 	     if ^domain_info.unreferenced then do;
       87 		if found_one then found_one = "0"b;
       88 		else call ioa_$ioa_switch (iocb_ptr, ",");
       89 		long_desc_str = mdbm_util_$display_descriptor (addr (domain_info.db_desc));
       90 		if mrds_dm_display_info.sw.long then do;
       91 			desc_str = long_desc_str;
       92 			call ioa_$ioa_switch_nnl (iocb_ptr, "^-^a^/^-^5x^a",
       93 			     domain_info.name, long_desc_str);
       94 		     end;
       95 		else do;
       96 			desc_str = mdbm_util_$trim_descriptor (long_desc_str);
       97 			call ioa_$ioa_switch_nnl (iocb_ptr, "^-^20a^1x^a",
       98 			     domain_info.name, desc_str);
       99 		     end;
      100 
      101 		if domain_info.check_path_ptr ^= NULL_OFFSET then
      102 		     call ioa_$ioa_switch_nnl (iocb_ptr, "^/^15x-check_proc ^a",
      103 			get_path_entry (domain_info.check_path_ptr, "$"));
      104 
      105 		if domain_info.encd_path_ptr ^= NULL_OFFSET then
      106 		     call ioa_$ioa_switch_nnl (iocb_ptr, "^/^15x-encode_proc ^a",
      107 			get_path_entry (domain_info.encd_path_ptr, "$"));
      108 
      109 		if domain_info.decd_path_ptr ^= NULL_OFFSET then
      110 		     call ioa_$ioa_switch_nnl (iocb_ptr, "^/^15x-decode_proc ^a",
      111 			get_path_entry (domain_info.decd_path_ptr, "$"));
      112 
      113 		if domain_info.db_desc ^= domain_info.user_desc then
      114 		     /* It had a -decode_dcl */
      115 		     call ioa_$ioa_switch_nnl (iocb_ptr, "^/^15x-decode_dcl ^/^15x^a",
      116 			mdbm_util_$display_descriptor (addr (domain_info.user_desc)));
      117 
      118 		end;
      119 	end;					/* End Domain section */
      120 	if found_one then goto NO_DOMAINS;
      121 
      122 	call ioa_$ioa_switch (iocb_ptr, ";");
      123 
      124 	if db_model.num_rels > 0 then call build_db_attr_list; /* Build attribute list in vfile */
      125 
      126 /*   *****        Output Attribute section if needed         ***        */
      127 
      128 	if found_one then do;			/* If any attributes
      129*						   exists with a name different
      130*						   then its domain name */
      131 
      132 		call ioa_$ioa_switch (iocb_ptr, "^2/attribute:"); /* Attribute section */
      133 
      134 		call iox_$position (temp_file_iocb_ptr, BOF, 0, code);
      135 		if code ^= 0 then call error (code, "Positioning temp file to BOF");
      136 
      137 		printed_one_sw = "0"b;
      138 
      139 		seek_head_info.seek_type = 0;
      140 		seek_head_info.seek_key = ATTRIBUTE_KEY_HEAD;
      141 		seek_head_info.n = length (ATTRIBUTE_KEY_HEAD);
      142 		call iox_$control (temp_file_iocb_ptr, "seek_head", addr (seek_head_info), code);
      143 		if code = error_table_$no_record then do;
      144 		     call ioa_$ioa_switch (iocb_ptr, "^2/No attributes exist for the data base^/^a",
      145 			mrds_dm_display_info.db_path);
      146 		     return;
      147 		     end;
      148 
      149 		crossref_info_record_ptr = addr (domain_offset);
      150 		do while (code = 0);
      151 
      152 		     call iox_$read_key (temp_file_iocb_ptr, key, rec_len, code);
      153 		     if code = 0 then
      154 			if substr (key, 1, length (ATTRIBUTE_KEY_HEAD)) ^= ATTRIBUTE_KEY_HEAD then
      155 			     code = error_table_$end_of_info;
      156 
      157 		     if code = 0 then do;
      158 			call iox_$read_record (temp_file_iocb_ptr,
      159 			     crossref_info_record_ptr, 2, (0), code);
      160 			if code = error_table_$long_record then
      161 			     code = 0;
      162 			if code = 0 then do;
      163 
      164 			     di_ptr = ptr (dbm_ptr, domain_offset);
      165 			     key = substr (key, length (ATTRIBUTE_KEY_HEAD) + 1);
      166 
      167 			     if rtrim (domain_info.name) ^= key then do;
      168 
      169 				     if printed_one_sw then
      170 					call ioa_$ioa_switch (iocb_ptr, ","); /* Put comma at end of line */
      171 
      172 				     call ioa_$ioa_switch_nnl (iocb_ptr, "^-^20a^1x^a",
      173 					key, di_ptr -> domain_info.name);
      174 
      175 				     printed_one_sw = "1"b;
      176 				end;
      177 			     end;
      178 			end;
      179 
      180 		end;				/* do while code = 0 */
      181 
      182 		if code ^= error_table_$end_of_info then
      183 		     call error (code, "Getting attribute names from temp fiel");
      184 
      185 		call ioa_$ioa_switch (iocb_ptr, ";");	/* Put semicolon at end of line */
      186 	     end;					/* End found one */
      187 
      188 /*    *****     Output relation section       *****     */
      189 
      190 	if db_model.num_rels < 1 then do;		/* No relation defined in db */
      191 		call ioa_$ioa_switch (iocb_ptr,
      192 		     "^2/There are no relations defined for the data base^/^a",
      193 		     mrds_dm_display_info.db_path);
      194 		return;
      195 	     end;
      196 
      197 
      198 	call ioa_$ioa_switch_nnl (iocb_ptr, "^2/relation:"); /* Relation section */
      199 
      200 	do i = 1 to rel_name_table_ix;
      201 
      202 	     call ioa_$ioa_switch_nnl (iocb_ptr, "^/^-^20a^1x(", rel_name_table (i).rel_name);
      203 
      204 	     fm_ptr = rel_name_table (i).file_model_ptr;
      205 	     ri_ptr = rel_name_table (i).rel_info_ptr;
      206 
      207 	     begin;
      208 
      209 		dcl     attr_line		 char (rel_info.num_attr * 35) varying;
      210 
      211 		attr_line = "";
      212 
      213 		do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr) /* Loop thru all attibutes getting the attr_name */
      214 		     repeat ptr (fm_ptr, attr_info.fwd_thread)
      215 		     while (rel (ai_ptr) ^= NULL_OFFSET);
      216 
      217 		     attr_line = attr_line || rtrim (attr_info.name);
      218 
      219 		     if attr_info.key_attr then attr_line = attr_line || "*";
      220 
      221 		     if attr_info.fwd_thread = NULL_OFFSET then /* Last attr in rel */
      222 			attr_line = attr_line || ")";
      223 		     else attr_line = attr_line || "  ";
      224 
      225 		end;
      226 
      227 		if i = db_model.num_rels then /* Last relation */
      228 		     call ioa_$ioa_switch_nnl (iocb_ptr, "^a;", attr_line);
      229 		else call ioa_$ioa_switch_nnl (iocb_ptr, "^a,", attr_line);
      230 
      231 	     end;					/* begin block */
      232 
      233 	     line = "";
      234 	end;
      235 
      236 /*     *****     index section for output     ***** */
      237 
      238 	if number_indexed_rels > 0 then do;		/* If any relations were indexed */
      239 
      240 		call ioa_$ioa_switch_nnl (iocb_ptr, "^2/index:");
      241 
      242 		number_indexed_rels_used = 0;
      243 
      244 		do i = 1 to rel_name_table_ix;
      245 
      246 		     if rel_name_table (i).indexed then do;
      247 
      248 			     number_indexed_rels_used = number_indexed_rels_used + 1;
      249 
      250 			     call ioa_$ioa_switch_nnl (iocb_ptr, "^/^-^20a^1x(", rel_name_table (i).rel_name);
      251 
      252 			     fm_ptr = rel_name_table (i).file_model_ptr;
      253 			     ri_ptr = rel_name_table (i).rel_info_ptr;
      254 			     line = "";
      255 			     one_found = "0"b;
      256 
      257 			     do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr) /* Loop thru all attibutes getting the attr_name */
      258 				repeat ptr (fm_ptr, attr_info.fwd_thread)
      259 				while (rel (ai_ptr) ^= NULL_OFFSET);
      260 
      261 				if attr_info.index_attr then do;
      262 
      263 					if one_found then line = line || "  ";
      264 					line = line || rtrim (attr_info.name);
      265 
      266 					one_found = "1"b;
      267 				     end;
      268 			     end;
      269 
      270 			     if number_indexed_rels_used = number_indexed_rels then /* last one */
      271 				call ioa_$ioa_switch_nnl (iocb_ptr, "^a);", line);
      272 			     else call ioa_$ioa_switch_nnl (iocb_ptr, "^a),", line);
      273 
      274 			     line = "";
      275 			end;
      276 
      277 		end;				/* End if rel_name_table.indexed */
      278 
      279 	     end;					/* END if indexed_found */
      280 
      281 	call ioa_$ioa_switch (iocb_ptr, "^/");		/* Add a couple if line feeds at the end */
      282 
      283 	call tidy_up;
      284 
      285 exit:	return;
      286 
      287 /*  * * * * * * * * * * *  build_db_attr_list  * * * * * * * * * * * * * *   */
      288 
      289 
      290 build_db_attr_list: proc;
      291 
      292 /*
      293*   This internal subroutine calls the subroutine to build the database
      294*   crossreference file. It also checks to see if an attribute name exists that
      295*   is different then a domain name, if so it sets the found_one bit. The
      296*   rel_name_table is allocated and filled in as the relation info is
      297*   encountered.
      298**/
      299 
      300 	temp_file_iocb_ptr = mrds_dm_display_info.xref_iocb_ptr;
      301 	if temp_file_iocb_ptr = null then do;
      302 	     call mu_db_xref$xref_build (mrds_dm_display_info.temp_dir_path, mrds_dm_display_info.db_path, dbm_ptr,
      303 		mrds_dm_display_info.xref_name, mrds_dm_display_info.xref_iocb_ptr, error_message, code);
      304 	     if code ^= 0 then call error (code, error_message);
      305 
      306 	     temp_file_iocb_ptr = mrds_dm_display_info.xref_iocb_ptr;
      307 	     end;
      308 
      309 /* Create the rel_name_table structure and initialize it */
      310 	allocate rel_name_table in (wa) set (rel_name_table_ptr);
      311 	rel_name_table (*).indexed = "0"b;		/* Init to off */
      312 	rel_name_table_ix = 0;			/* To start with */
      313 	rel_name_table (*).file_model_ptr = null;
      314 
      315 	found_one = "0"b;				/* Just to be sure */
      316 
      317 /*  Walk the file_info list to get relation info */
      318 	do fi_ptr = ptr (dbm_ptr, db_model.file_ptr) /* Loop thru all files (relations ) */
      319 	     repeat ptr (dbm_ptr, file_info.fwd_ptr)
      320 	     while (rel (fi_ptr) ^= NULL_OFFSET);
      321 
      322 	     file_model_name = rtrim (file_info.file_name) || ".m";
      323 
      324 	     call initiate_file_ (db_path, file_model_name, R_ACCESS, fm_ptr, (0), code);
      325 	     if fm_ptr = null then call error (code, rtrim (db_path) || ">" || file_model_name);
      326 
      327 	     ri_ptr = ptr (fm_ptr, file_model.rel_ptr);	/* Relation info ptr */
      328 	     rel_name_table_ix = rel_name_table_ix + 1;	/* Next array index */
      329 	     rel_name_table (rel_name_table_ix).rel_name = file_info.file_name; /* Save rel info */
      330 	     rel_name_table (rel_name_table_ix).file_model_ptr = fm_ptr;
      331 	     rel_name_table (rel_name_table_ix).rel_info_ptr = ri_ptr;
      332 	     rel_name_table (rel_name_table_ix).indexed = rel_info.indexed;
      333 	     if rel_name_table (rel_name_table_ix).indexed then
      334 		number_indexed_rels = number_indexed_rels + 1; /* Keep count */
      335 
      336 /*
      337*   Look through all the attributes in each relation looking for an attribute
      338*   that is based upon a domain with a different name. If we find one, set
      339*   found_one on. This bit is later used to determine if the "attribute:"
      340*   statement need to be emitted. We can stop looking after the first one
      341*   is found, as we only have to find one.
      342**/
      343 	     do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr)
      344 		repeat ptr (fm_ptr, attr_info.fwd_thread)
      345 		while (rel (ai_ptr) ^= NULL_OFFSET & ^found_one);
      346 
      347 		di_ptr = ptr (dbm_ptr, attr_info.domain_ptr);
      348 		if domain_info.name ^= attr_info.name
      349 		then found_one = "1"b;
      350 	     end;					/* END of all attrs */
      351 
      352 	end;					/* END of all files (relations) */
      353 						/* vfile_ now contains all unique attribute names as keys with domain offset as data */
      354 
      355      end build_db_attr_list;
      356 
      357 
      358 /*  * * * * * * * * * * * * * *      error     * * * * * * * * * * * * * *   */
      359 
      360 
      361 
      362 error: proc (err_code, err_message);			/* Error procedure  */
      363 
      364 	dcl     err_code		 fixed bin (35);
      365 	dcl     err_message		 char (*);
      366 
      367 
      368 	O_err_code = err_code;
      369 	O_err_msg = err_message;
      370 	call tidy_up;
      371 	goto exit;
      372 
      373      end error;
      374 
      375 
      376 
      377 
      378 
      379 /* * * * * * * * * * * * * * * *   tidy_up  * * * * * * * * * * * * * * *  */
      380 
      381 tidy_up: proc;
      382 
      383 	if rel_name_table_ptr ^= null then do;
      384 	     do i = 1 to rel_name_table_ix;
      385 		call terminate_file_ (rel_name_table (i).file_model_ptr, 0, TERM_FILE_TERM, (0));
      386 		end;
      387 	     free rel_name_table;
      388 	     end;
      389 
      390      end tidy_up;
      391 
      392 /*    * * * * * * * *     get_path_entry      * * * * * * * * * *           */
      393 
      394 get_path_entry: procedure (path_ptr, separator) returns (char (256));
      395 
      396 	dcl     path_ptr		 bit (18) unal;	/* offset to struct in dbm_area */
      397 	dcl     separator		 char (1);	/* either ">" or "$" */
      398 
      399 /* get the path - entry character string from the path_entry structure */
      400 
      401 	path_entry_ptr = ptr (dbm_ptr, path_ptr);
      402 
      403 	return (rtrim (path_entry.path) || separator || rtrim (path_entry.entry));
      404 
      405      end get_path_entry;
      406 
      407 	dcl     addr		 builtin;
      408 	dcl     BOF		 int static options (constant) init (-1);
      409 	dcl     cleanup		 condition;
      410 	dcl     clock		 builtin;
      411 	dcl     code		 fixed bin (35);
      412 	dcl     date_time_		 entry (fixed bin (71), char (*));
      413 	dcl     desc_str		 char (120) varying;
      414 	dcl     domain_offset	 bit (18) aligned;
      415 	dcl     error_message	 char (500);
      416 	dcl     error_table_$end_of_info fixed bin (35) ext static;
      417 	dcl     error_table_$long_record fixed bin(35) ext static;
      418 	dcl     error_table_$no_record fixed bin (35) ext static;
      419 	dcl     error_table_$unimplemented_version fixed bin (35) ext static;
      420 	dcl     file_model_name	 char (32);
      421 	dcl     fixed		 builtin;
      422 	dcl     found_one		 bit (1);
      423 	dcl     i			 fixed bin;
      424 	dcl     initiate_file_	 entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
      425 	dcl     ioa_$ioa_switch	 entry () options (variable);
      426 	dcl     ioa_$ioa_switch_nnl	 entry () options (variable);
      427 	dcl     iocb_ptr		 ptr;
      428 	dcl     iox_$control	 entry (ptr, char(*), ptr, fixed bin(35));
      429 	dcl     iox_$position	 entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
      430 	dcl     iox_$read_key	 entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
      431 	dcl     iox_$read_record	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      432 	dcl     key		 char (256) varying;
      433 	dcl     length		 builtin;
      434 	dcl     line		 char (500) varying;
      435 	dcl     long_desc_str	 char (120) varying;
      436 	dcl     mdbm_util_$display_descriptor entry (ptr) returns (char (120) varying);
      437 	dcl     mdbm_util_$trim_descriptor entry (char (120) varying) returns (char (*));
      438 	dcl     mu_db_xref$xref_build	 entry (char(*), char(*), ptr, char(*), ptr, char(*), fixed bin(35));
      439 	dcl     null		 builtin;
      440 	dcl     NULL_OFFSET		 int static bit (18) unal init ((18)"1"b) options (constant);
      441 	dcl     number_indexed_rels	 fixed bin;
      442 	dcl     number_indexed_rels_used fixed bin;
      443 	dcl     one_found		 bit (1);
      444 	dcl     printed_one_sw	 bit (1);
      445 	dcl     ptr		 builtin;
      446 	dcl     rec_len		 fixed bin (21);
      447 	dcl     rel		 builtin;
      448 	dcl     rel_name_table_ix	 fixed bin;
      449 	dcl     rtrim		 builtin;
      450 	dcl     substr		 builtin;
      451 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
      452 	dcl     temp_file_iocb_ptr	 ptr;
      453 	dcl     terminate_file_	 entry (ptr, fixed bin(24), bit(*), fixed bin(35));
      454 	dcl     time_of_list	 char (24);
      455 	dcl     wa		 area based (mrds_dm_display_info.work_area_ptr);
      456 
      457 	dcl     1 seek_head_info	 aligned,
      458 	          2 seek_type	 fixed bin,
      459 		2 n		 fixed bin,
      460 		2 seek_key	 char (256);
      461 
      462 	dcl     1 rel_name_table	 (db_model.num_rels) aligned based (rel_name_table_ptr),
      463 		2 rel_name	 char (32),	/* Relation name of this relation */
      464 		2 file_model_ptr	 ptr,		/* Pointer to file_model for this relation */
      465 		2 rel_info_ptr	 ptr,		/* Pointer to rel_info for this relation */
      466 		2 indexed		 bit (1);		/* On = this rel contains an indexed attr */
      467 
      468 	dcl     rel_name_table_ptr	 ptr;		/* Pointer to rel_name_table */
      469 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      470 
      471 
  2     1 /*  BEGIN INCLUDE  mrds_dm_display_info.incl.pl1       */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(85-12-07,Spitzer), approve(85-12-07,MCR7311),
  2     7*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  2     8*     Add flag fields for unreferenced objects and crossrefs.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 dcl 1 mrds_dm_display_info aligned based (mrds_dm_display_info_ptr),
  2    13     2 version fixed bin,
  2    14     2 output_iocb_ptr ptr,				/* Output iocb pointer */
  2    15     2 db_path char (168) unal,			/* Absolute pathname of the database */
  2    16     2 temp_dir_path char (168) unal,			/* Absolute pathname of temp dir */
  2    17     2 work_area_ptr ptr,				/* Pointer to freeing area */
  2    18     2 dbm_ptr ptr,					/* Pointer to the db_model of the database */
  2    19     2 sw,						/* Control switches */
  2    20       3 default bit (1) unal,				/* Neither -long or -brief */
  2    21       3 long bit (1) unal,				/* On = long mode */
  2    22       3 cmdb bit (1) unal,				/* On = cmdb type output */
  2    23       3 names_only bit (1) unal,			/* Only the name for either relation, attribute, domain, index
  2    24*						   name_list is pointer to by mrds_dm_display_info.name_list_ptr */
  2    25       3 domains bit (1) unal,				/* Domain info only */
  2    26       3 attribute bit (1) unal,			/* Attibute info only */
  2    27       3 relation bit (1) unal,			/* Relation info only */
  2    28       3 index bit (1) unal,				/* Index relation info only */
  2    29       3 history bit (1) unal,				/* On = list history */
  2    30       3 header bit (1) unal,				/* On = display header */
  2    31       3 unreferenced_domains bit (1) unal,		/* On = display only unreferenced domains */
  2    32       3 unreferenced_attributes bit (1) unal,		/* On = display only unreferenced attributes */
  2    33       3 domain_xref bit (1) unal,			/* On = display a domain crossreference */
  2    34       3 attribute_xref bit (1) unal,			/* On = display an attribute crossreference */
  2    35       3 all_xref bit (1) unal,			/* On = display a complete crossreference */
  2    36       3 mbz bit (21) unal,				/* Unnused  must be zeros */
  2    37 						/* The following  are pointer to name list like
  2    38*						   name_list  structure below */
  2    39 
  2    40     2 dom_name_list_ptr ptr,				/* Pointer to domain name list */
  2    41     2 attr_name_list_ptr ptr,				/* Pointer to attribute name list */
  2    42     2 rel_name_list_ptr ptr,				/* Pointer to relation name list */
  2    43     2 index_name_list_ptr ptr,			/* Pointer to index rel name list */
  2    44 
  2    45     2 xref_iocb_ptr ptr,				/* Pointer to database xref */
  2    46     2 xref_name char (32) unaligned;			/* Name of xref file created */
  2    47 
  2    48 dcl 1 name_list aligned based (name_list_ptr),		/* General name list */
  2    49     2 num_names fixed bin,				/* Number of names in list */
  2    50     2 name (num_names_alloc refer (name_list.num_names)) char (32);
  2    51 
  2    52 dcl  mrds_dm_display_info_ptr pointer;
  2    53 dcl  name_list_ptr pointer;
  2    54 dcl  MRDS_DM_DISPLAY_INFO_VERSION_1 int static options (constant) init (1);
  2    55 dcl  num_names_alloc fixed bin;
  2    56 
  2    57 /*  END INCLUDE  mrds_dm_display_info.incl.pl1       */
      472 
      473 
  3     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  3     6*     modified to save space occupied by model
  3     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  3     8*     to add mdbm_secured bit in db_model
  3     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  3    10*     collapsed the following into an unused_offset array:
  3    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  3    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  3    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  3    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  3    15*       unused_1
  3    16*     Also changed the name of unused_2 to restructuring_history_offset
  3    17*     and changed the comment on the changer structure to indicate
  3    18*     that it will contain on database creation information.
  3    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  3    20*     used one of the unused_offsets to point to a message which indicates
  3    21*     why the db is inconsistent. The offset will be null when the db is created
  3    22*     and set the first time the message is used. this is so it will be
  3    23*     consistent with existing data bases. Also added the message structure.
  3    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  3    25*     added the undo_request element to the message structure
  3    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  3    27*     changed unused_offset (12) to last_restructruring_history_offset and
  3    28*     changed restructuring_history_offset to first_restructuring_history_offset
  3    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  3    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  3    31*     1 => vfile database and 2 => page_file database. Up to this point all
  3    32*     database types were equal to 1.
  3    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  3    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  3    35*     flags. This will allow information about transactions and dm_file
  3    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  3    37*     change is compatable with all datamodels created by the released version
  3    38*     of mrds.
  3    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  3    40*     added the rollback_on flag to the db_type_flags since it appears that you
  3    41*     can have a dmfile database that requires transactions but does not have any
  3    42*     journalizing. Also switched the order of the transactions_needed and
  3    43*     concurrency_on flags - this makes the change compatable with existing
  3    44*     dmfile databases except when displaying the model since concurrency_on and
  3    45*     rollback_on will be off in the model even though the dmfile relations had
  3    46*     them on during creation.
  3    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  3    48*      Removed ctl_file_path_ptr.
  3    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  3    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  3    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  3    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  3    53*      in the flag word for rmdb copying.
  3    54*                                                   END HISTORY COMMENTS */
  3    55 
  3    56 
  3    57 /* this include file contains the structures that go into the make up
  3    58*   of the "db_model" segment in the model for the database.
  3    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  3    60*
  3    61*   the db_model structure goes at the base of the segment, and contains items unique to
  3    62*   the whole databse. in addition, it has an area of size to fill the
  3    63*   rest of a segment, that holds the lists of files and domains in the database.
  3    64*   these lists are singly forward linked lists. all "pointers" in the database model
  3    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  3    66*   since actual pointers are process dependent on segment number.
  3    67*   the remaining structures are first a path_entry one to save pathnames in,
  3    68*   and the stack_item and constent structures, used to save a boolean
  3    69*   expression in polish form, with the stack represented by a linked list.
  3    70*   the final structure is one for identifying the status of version information */
  3    71 
  3    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  3    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  3    74 	     2 db_type_flags      unal,
  3    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  3    76 	       3 unused	      (13) bit (1) unal,
  3    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  3    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  3    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  3    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  3    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  3    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  3    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  3    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  3    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  3    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  3    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  3    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  3    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  3    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  3    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  3    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  3    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  3    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  3    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  3    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  3    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  3    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  3    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  3   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  3   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  3   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  3   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  3   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  3   105 
  3   106      dcl	   dbm_ptr	      ptr;
  3   107 
  3   108 /* the files in the database each have a file_info containing
  3   109*   their name, the file_model for each file is found by initiating the
  3   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  3   111*   the file_info list is a singly linked list in definition order */
  3   112 
  3   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  3   114 	     2 file_name	      char (30),		/* name of file */
  3   115 	     2 file_id	      bit (36),		/* id number of file */
  3   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  3   117 	     2 unused	      unal bit (18);	/* for future expansion */
  3   118 
  3   119      dcl	   fi_ptr		      ptr;
  3   120 
  3   121 /* each domain used in the database will have a domain info saved in the db_model
  3   122*   segment. it describes the domain of the given name, and it's options.
  3   123*   the domain_info's form a singly linked list in definition order */
  3   124 
  3   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  3   126 	     2 name	      char (32),		/* name of domain */
  3   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  3   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  3   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  3   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  3   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  3   132 	     2 reserved	      bit (31) unal,
  3   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  3   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  3   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  3   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  3   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  3   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  3   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  3   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  3   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  3   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  3   143 	     2 str_err_path_ptr   unal bit (18),
  3   144 	     2 str_after_path_ptr unal bit (18),
  3   145 	     2 get_before_path_ptr unal bit (18),
  3   146 	     2 get_err_path_ptr   unal bit (18),
  3   147 	     2 get_after_path_ptr unal bit (18),
  3   148 	     2 mod_before_path_ptr unal bit (18),
  3   149 	     2 mod_err_path_ptr   unal bit (18),
  3   150 	     2 mod_after_path_ptr unal bit (18),
  3   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  3   152 	     2 unused_2	      unal bit (18),
  3   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  3   154 
  3   155      dcl	   di_ptr		      ptr;
  3   156 
  3   157 /* information necessary for attributes that are not used in any relation */
  3   158 
  3   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  3   160 	     2 name char (32),			/* name of attribute */
  3   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  3   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  3   163 	     2 unused (2) bit (18) unal;
  3   164 
  3   165      dcl     ua_ptr ptr;
  3   166 
  3   167 
  3   168 /* space saving pathname$entryname structure, to be allocated
  3   169*   only when a path$entry has to be saved, else only a bit(18)
  3   170*   offset takes up space in the main model structure */
  3   171 
  3   172      declare 1 path_entry	      based (path_entry_ptr),
  3   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  3   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  3   175 	     2 reserved	      unal bit (36);	/* for future use */
  3   176 
  3   177      declare path_entry_ptr	      ptr;
  3   178 
  3   179 
  3   180 
  3   181 
  3   182 
  3   183 /* declarations for model of postfix stack holding the check option boolean expression
  3   184*   the following encoding values indicate the corresponding type of stack element
  3   185*
  3   186*   1  =
  3   187*   2  ^=
  3   188*   3  >
  3   189*   4  <
  3   190*   5  >=
  3   191*   6  <=
  3   192*
  3   193*   10  and
  3   194*   20  or
  3   195*   30  not
  3   196*
  3   197*   40  - (minus)
  3   198*
  3   199*   50  domain variable(same name as domain)
  3   200*
  3   201*   60  constant(number, bit string, or character string)
  3   202*
  3   203**/
  3   204 
  3   205 
  3   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  3   207 	     2 next	      bit (18),		/* link to next in list */
  3   208 	     2 type	      fixed binary,		/* code for this element type */
  3   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  3   210*						   if this is a constant element type */
  3   211 
  3   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  3   213 
  3   214 
  3   215 
  3   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  3   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  3   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  3   219 
  3   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  3   221 
  3   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  3   223 
  3   224 /* version structure, giving status of source for CMDB/RMDB,
  3   225*   status of model, and status of resultant */
  3   226 
  3   227 /* version number is in form MM.N.Y
  3   228*   where MM is the major version number, N is the minor version alteration,
  3   229*   and Y is the lastest modification to that alteration,
  3   230*   where M and N represent numbers 0-9, and Y is a letter */
  3   231 
  3   232      declare 1 version_status	      unal based (version_status_ptr),
  3   233 	     2 cmdb_rmdb,
  3   234 	       3 major	      fixed bin,
  3   235 	       3 minor	      fixed bin,
  3   236 	       3 modification     char (4),
  3   237 	     2 model,
  3   238 	       3 major	      fixed bin,
  3   239 	       3 minor	      fixed bin,
  3   240 	       3 modification     char (4),
  3   241 	     2 resultant,
  3   242 	       3 major	      fixed bin,
  3   243 	       3 minor	      fixed bin,
  3   244 	       3 modification     char (4);
  3   245 
  3   246      declare version_status_ptr     ptr;
  3   247 
  3   248 
  3   249 /* maintains information only about the db creation */
  3   250 
  3   251      declare 1 changer	      unal based (changer_ptr),
  3   252 	     2 id		      char (32),
  3   253 	     2 time	      fixed bin (71),
  3   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  3   255 
  3   256      declare changer_ptr	      ptr;
  3   257 
  3   258 
  3   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  3   260 	     02 len	      fixed bin,		/* length of the message */
  3   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  3   262 	     02 name	      char (32),		/* name of thing that set the message */
  3   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  3   264*                                                               that caused the database to become inconsistent */
  3   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  3   266 
  3   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  3   268 
  3   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  3   270 
  3   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  3   272 
  3   273 
      474 
      475 
  4     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  4     6*     modified to save space occupied by model
  4     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  4     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  4     9*     the number of secondary indices in the relation - it was always zero.
  4    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  4    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  4    12*     DMS conversion.
  4    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  4    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  4    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  4    16*     for relation manager changes.
  4    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  4    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  4    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  4    20*     <rel> files are good (for rmdb)
  4    21*                                                   END HISTORY COMMENTS */
  4    22 
  4    23 
  4    24 /* each file in the database will have a model segment with the name
  4    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  4    26*   the file_model structure is allocated at the base of the segment for a given file.
  4    27*   it contains an area with which all other structures in this include file are allocated.
  4    28*   these structures contain the information about which relations, foreign keys,
  4    29*   and attributes are members of this file. all lists are singly linked lists in
  4    30*   definition order. pointers to these structures are obtained by using the "pointer"
  4    31*   builtin function with arguments of the segment base pointer, and the
  4    32*   offset (bit (18)) relative to that pointer that is actually stored in
  4    33*   the file model itself. this is because pointer segment numbers are
  4    34*   per process dependent. the major lists pointed to by the file_model structure
  4    35*   are the list of relations in this file(each with a contained attribute list),
  4    36*   and the list of foreign keys whose parent relation resides in this file
  4    37*   (along with a participating attribute sublist, and the child relation list,
  4    38*   if they are also in this file) */
  4    39 
  4    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  4    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  4    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  4    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  4    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  4    45     2 reserved bit (32) unal,				/* reserved for future flags */
  4    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  4    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  4    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  4    49     2 pad_1 fixed bin (35),				/* for future use */
  4    50     2 pad_2 fixed bin (35),
  4    51     2 ratd_len fixed bin (21),			/* length of above */
  4    52     2 mratd_len fixed bin (21),			/* length of above */
  4    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  4    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  4    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  4    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  4    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  4    58     2 block_size unal fixed bin,			/* no. pages in block */
  4    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  4    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  4    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  4    62     2 num_rels unal fixed bin,			/* number of relations in file */
  4    63     2 num_links unal fixed bin,			/* number of links in file */
  4    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  4    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  4    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  4    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  4    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  4    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  4    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  4    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  4    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  4    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  4    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  4    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  4    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  4    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  4    78     2 open_eu_err_path_ptr unal bit (18),
  4    79     2 open_eu_after_path_ptr unal bit (18),
  4    80     2 open_er_before_path_ptr unal bit (18),
  4    81     2 open_er_err_path_ptr unal bit (18),
  4    82     2 open_er_after_path_ptr unal bit (18),
  4    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  4    84     2 open_neu_err_path_ptr unal bit (18),
  4    85     2 open_neu_after_path_ptr unal bit (18),
  4    86     2 open_ner_before_path_ptr unal bit (18),
  4    87     2 open_ner_err_path_ptr unal bit (18),
  4    88     2 open_ner_after_path_ptr unal bit (18),
  4    89     2 open_pu_before_path_ptr unal bit (18),
  4    90     2 open_pu_err_path_ptr unal bit (18),
  4    91     2 open_pu_after_path_ptr unal bit (18),
  4    92     2 open_pr_before_path_ptr unal bit (18),
  4    93     2 open_pr_err_path_ptr unal bit (18),
  4    94     2 open_pr_after_path_ptr unal bit (18),
  4    95     2 open_cu_before_path_ptr unal bit (18),
  4    96     2 open_cu_err_path_ptr unal bit (18),
  4    97     2 open_cu_after_path_ptr unal bit (18),
  4    98     2 open_cr_before_path_ptr unal bit (18),
  4    99     2 open_cr_err_path_ptr unal bit (18),
  4   100     2 open_cr_after_path_ptr unal bit (18),
  4   101     2 close_before_path_ptr unal bit (18),
  4   102     2 close_err_path_ptr unal bit (18),
  4   103     2 close_after_path_ptr unal bit (18),
  4   104     2 unused_1 unal bit (18),				/* for future expansion */
  4   105     2 unused_2 unal bit (18),
  4   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  4   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  4   108 dcl  fm_ptr ptr;
  4   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  4   110 dcl  atd_ptr ptr;
  4   111 dcl  atd_len fixed bin;
  4   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  4   113     2 ncomponents fixed bin,
  4   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  4   115 dcl  cna_ptr ptr;
  4   116 dcl  ncomp_init fixed bin;
  4   117 
  4   118 /* a rel_info structure contains information describing a relation.
  4   119*   a relation may only occur in one file, thus there is one rel_info
  4   120*   per relation per database, each stored in the file_model area for
  4   121*   the file that contains it. the list of rel_info's in this file
  4   122*   form a singly linked list in definition order.
  4   123*   the rel_info itself points to a list of the attributes it contains,
  4   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  4   125 
  4   126 dcl 1 rel_info aligned based (ri_ptr),
  4   127     2 name char (32),				/* relation name */
  4   128     2 id  bit (36) aligned,				/* relation id number */
  4   129     2 hashed bit (1) unal,				/* on if hashed */
  4   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  4   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  4   132     2 system bit (1) unal,				/* on if dont care how stored */
  4   133     2 indexed bit (1) unal,				/* on if secondary index */
  4   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  4   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  4   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  4   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  4   138     2 reserved bit (27) unal,				/* for future flags */
  4   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  4   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  4   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  4   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  4   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  4   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  4   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  4   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  4   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  4   148     2 unused_3 unal fixed bin,			/* element that was never used */
  4   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  4   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  4   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  4   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  4   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  4   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  4   155     2 attr_ptr unal bit (18),				/* to attr. info */
  4   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  4   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  4   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  4   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  4   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  4   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  4   162     2 link_err_path_ptr unal bit (18),
  4   163     2 link_after_path_ptr unal bit (18),
  4   164     2 unlk_before_path_ptr unal bit (18),
  4   165     2 unlk_err_path_ptr unal bit (18),
  4   166     2 unlk_after_path_ptr unal bit (18),
  4   167     2 str_before_path_ptr unal bit (18),
  4   168     2 str_err_path_ptr unal bit (18),
  4   169     2 str_after_path_ptr unal bit (18),
  4   170     2 del_before_path_ptr unal bit (18),
  4   171     2 del_err_path_ptr unal bit (18),
  4   172     2 del_after_path_ptr unal bit (18),
  4   173     2 mod_before_path_ptr unal bit (18),
  4   174     2 mod_err_path_ptr unal bit (18),
  4   175     2 mod_after_path_ptr unal bit (18),
  4   176     2 find_before_path_ptr unal bit (18),
  4   177     2 find_err_path_ptr unal bit (18),
  4   178     2 find_after_path_ptr unal bit (18),
  4   179     2 retr_before_path_ptr unal bit (18),
  4   180     2 retr_err_path_ptr unal bit (18),
  4   181     2 retr_after_path_ptr unal bit (18),
  4   182     2 unused_1 unal bit (18),				/* for future expansion */
  4   183     2 unused_2 unal bit (18),
  4   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  4   185 dcl  ri_ptr ptr;
  4   186 
  4   187 /* a attr_info structure contains information about an attribute in a given relation.
  4   188*   since attributes may appear in more than one relation, each occurence of an attribute
  4   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  4   190*   the list is singly linked in definition order. the attr_info describes
  4   191*   the data it represents, and how that data is used during a database search. */
  4   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  4   193     2 name char (32),				/* name of attribute */
  4   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  4   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  4   196     2 link_attr bit (1) unal,				/* on if participates in link */
  4   197     2 reserved bit (33) unal,
  4   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  4   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  4   200     2 key_order unal fixed bin,			/* relative posit. in key */
  4   201     2 bit_offset fixed bin (35),			/* position in tuple */
  4   202     2 bit_length fixed bin (35),			/* length if fixed */
  4   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  4   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  4   205     2 domain_ptr unal bit (18),			/* to domain info */
  4   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  4   207     2 fwd_thread unal bit (18),			/* to next in list */
  4   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  4   209 dcl  ai_ptr ptr;
  4   210 
  4   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  4   212*   each time a foreign key definition indicates a relation as it's parent,
  4   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  4   214*   a relation can be parent and/or child in any number of foreign keys.
  4   215*   the parent_link_info structure describes the foreign key, and also points
  4   216*   to a list of the attributes that participate in this foreign key.
  4   217*   (this could be from 1 up to all attributes in the relation)
  4   218*   the attr_list structures are in a singly linked list in definition order
  4   219*   for this purpose. also pointed to is a list of child_link_info's
  4   220*   that describe the child relations in this foreign key. since foreign keys
  4   221*   may span files, not all related child_link_info's have to be in this file's
  4   222*   model area. */
  4   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  4   224     2 name char (32),				/* name of link */
  4   225     2 singular bit (1) unal,				/* on if system owned link */
  4   226     2 temp bit (1) unal,				/* on if temp. order */
  4   227     2 first bit (1) unal,				/* insertion indicators */
  4   228     2 last bit (1) unal,
  4   229     2 next bit (1) unal,
  4   230     2 prior bit (1) unal,
  4   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  4   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  4   233     2 dup_first bit (1) unal,				/* duplicates first */
  4   234     2 dup_last bit (1) unal,				/* duplicates last */
  4   235     2 indexed bit (1) unal,				/* locate parent via index */
  4   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  4   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  4   238     2 thread_27 bit (1) unal,
  4   239     2 thread_18 bit (1) unal,
  4   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  4   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  4   242     2 reserved bit (19) unal,				/* reserved for future flags */
  4   243     2 index_id aligned bit (8),			/* id of index if indexed */
  4   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  4   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  4   246     2 n_children unal fixed bin,			/* no. children in link */
  4   247     2 child_fn char (30),				/* file name for first child in list */
  4   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  4   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  4   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  4   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  4   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  4   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  4   254     2 sort_err_path_ptr unal bit (18),
  4   255     2 sort_after_path_ptr unal bit (18),
  4   256     2 srch_before_path_ptr unal bit (18),
  4   257     2 srch_err_path_ptr unal bit (18),
  4   258     2 srch_after_path_ptr unal bit (18),
  4   259     2 link_before_path_ptr unal bit (18),
  4   260     2 link_err_path_ptr unal bit (18),
  4   261     2 link_after_path_ptr unal bit (18),
  4   262     2 unlk_before_path_ptr unal bit (18),
  4   263     2 unlk_err_path_ptr unal bit (18),
  4   264     2 unlk_after_path_ptr unal bit (18),
  4   265     2 unused_1 unal bit (18),				/* for future expansion */
  4   266     2 unused_2 unal bit (18),
  4   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  4   268 dcl  pli_ptr ptr;
  4   269 
  4   270 /* a child_link_info structure is the counter part of a parent_link_info
  4   271*   for foreign key child relations. each time a relation is defined to be
  4   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  4   273*   this list is singly linked in foreign key definition order.
  4   274*   the child_link_info points to a list of participating attributes from the
  4   275*   child relation by means of a singly linked list of attr_list structures
  4   276*   in definition order. the number of attributes in the parent attr_list
  4   277*   and the child attr_list lists are the same with corresponding attr_list
  4   278*   attributes having the same domain. all child_link_infos in this file
  4   279*   are on a seperately linked list. this may not include all
  4   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  4   281*   since foreign keys may span files, and the child_link_info will
  4   282*   reside in the file containing it's associated relation_info. */
  4   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  4   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  4   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  4   286     2 fixed bit (1) unal,				/* on if membership fixed */
  4   287     2 optional bit (1) unal,				/* on if membership optional */
  4   288     2 auto bit (1) unal,				/* on if insertion automatic */
  4   289     2 manual bit (1) unal,				/* on if insertion manual */
  4   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  4   291     2 range_sel bit (1) unal,				/* on if range type selection */
  4   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  4   293     2 key_dup_last bit (1) unal,
  4   294     2 key_null bit (1) unal,				/* on if null allowed */
  4   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  4   296     2 sel_current bit (1) unal,
  4   297     2 sel_key bit (1) unal,
  4   298     2 sel_proc bit (1) unal,
  4   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  4   300     2 reserved bit (21) unal,
  4   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  4   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  4   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  4   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  4   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  4   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  4   307     2 parent_fn char (30),				/* file name for parent info */
  4   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  4   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  4   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  4   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  4   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  4   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  4   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  4   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  4   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  4   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  4   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  4   319     2 link_err_path_ptr unal bit (18),
  4   320     2 link_after_path_ptr unal bit (18),
  4   321     2 unlk_before_path_ptr unal bit (18),
  4   322     2 unlk_err_path_ptr unal bit (18),
  4   323     2 unlk_after_path_ptr unal bit (18),
  4   324     2 srch_before_path_ptr unal bit (18),
  4   325     2 srch_err_path_ptr unal bit (18),
  4   326     2 srch_after_path_ptr unal bit (18),
  4   327     2 unused_1 unal bit (18),				/* for future expansion */
  4   328     2 unused_2 unal bit (18) ;
  4   329 dcl  cli_ptr ptr;
  4   330 
  4   331 /* the attr_list structure is associated with the parent_link_info
  4   332*   and child_link_info structures to represent by means of a singly linked list
  4   333*   the participating attributes from relations in a foreign key.
  4   334*   the parent_link_info has a list for the parent relation,
  4   335*   and the child_link_info has a list for the child relation.
  4   336*   the participating attributes are a subset(not necessary proper) of
  4   337*   those attributes contained in a relation definition.
  4   338*   there are equal numbers of attr_list structures in the parent and
  4   339*   child lists of the same foreign key. the corresponding attributes in these
  4   340*   lists must have the same domain. */
  4   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  4   342     2 attr_fn char (30),				/* file name for attr. */
  4   343     2 attr_ptr unal bit (18),				/* to attr info block */
  4   344     2 fwd_thread unal bit (18);			/* to next in list */
  4   345 dcl  al_ptr ptr;
  4   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  4   347     2 ascend bit (1) unal,				/* ascending order */
  4   348     2 descend bit (1) unal,				/* descending order */
  4   349     2 reserved bit (34) unal,
  4   350     2 attr_ptr unal bit (18),				/* to attr info */
  4   351     2 fwd_thread unal bit (18);			/* to next in list */
  4   352 dcl  sk_ptr ptr;
  4   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  4   354     2 attr_ptr unal bit (18),				/* to attr info */
  4   355     2 fwd_thread unal bit (18);			/* to next in list */
  4   356 dcl  dp_ptr ptr;
  4   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  4   358     2 link_fn char (30),				/* file name for thru link */
  4   359     2 link_ptr unal bit (18),				/* to parent link info */
  4   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  4   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  4   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  4   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  4   364     2 fwd_thread unal bit (18);			/* to next in chain */
  4   365 dcl  sc_ptr ptr;
  4   366 
  4   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  4   368 
  4   369 
      476 
      477 
  5     1 /*  START OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 /****^  HISTORY COMMENTS:
  5     4*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
  5     5*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  5     6*     written.
  5     7*                                                   END HISTORY COMMENTS */
  5     8 
  5     9 /*DESCRIPTION
  5    10*  The following structures are the definition of the records with the keyed
  5    11*  vfile that is built during restructuring. This file serves as a crossreference
  5    12*  of unique attributes and domains used within the specified MRDS database. Each
  5    13*  object is a char (33); the first byte is set to an unprintable character so we
  5    14*  can use the index builtin to find a specific object.
  5    15**/
  5    16 
  5    17 dcl crossref_info_record_ptr ptr;
  5    18 dcl crossref_info_record_count fixed bin (21);
  5    19 dcl 1 crossref_info_record based (crossref_info_record_ptr),
  5    20      2 offset bit (18) unal,
  5    21      2 pad bit (18) unal,
  5    22      2 count fixed bin (21),
  5    23      2 entry (crossref_info_record_count refer (crossref_info_record.count)) unaligned,
  5    24       3 object_head char (1),
  5    25       3 object char (32);
  5    26 
  5    27 dcl crossref_info_record_objects char (33*crossref_info_record.count)
  5    28 			   based (addr (crossref_info_record.entry(1)));
  5    29 dcl OBJECT_HEAD char (1) int static options (constant) init (" ");
  5    30 
  5    31 dcl ATTRIBUTE_KEY_HEAD char (10) int static options (constant) init ("attribute:");
  5    32 dcl DOMAIN_KEY_HEAD char (7) int static options (constant) init ("domain:");
  5    33 dcl RELATION_KEY_HEAD char (9) int static options (constant) init ("relation:");
  5    34 
  5    35 /*DESCRIPTION
  5    36*  The following structures are used to contain sufficient crossreference
  5    37*  information for the delete_attribute and delete_domain requests. These
  5    38*  requests require a more complete view of a crossreference tree, associating
  5    39*  domains, attributes and relations in 2 directions.
  5    40**/
  5    41 
  5    42 dcl domain_list_ptr ptr;
  5    43 dcl domain_list_count fixed bin;
  5    44 dcl domain_list_names char (33*domain_list.count) based (addr (domain_list.name(1)));
  5    45 dcl 1 domain_list based (domain_list_ptr),
  5    46      2 count fixed bin,				/* number of domains in the list */
  5    47      2 name (domain_list_count refer (domain_list.count))
  5    48 	  char (33) unaligned,			/* name of this domain */
  5    49      2 attribute_list_ptr (domain_list_count refer (domain_list.count))
  5    50 		      ptr;			/* -> attribute_list structure */
  5    51 
  5    52 dcl attribute_list_ptr ptr;
  5    53 dcl attribute_list_count fixed bin;
  5    54 dcl attribute_list_names char (33*attribute_list.count) based (addr (attribute_list.name(1)));
  5    55 dcl 1 attribute_list based (attribute_list_ptr),
  5    56      2 count fixed bin,				/* number of attributes in the list */
  5    57      2 name (attribute_list_count refer (attribute_list.count))
  5    58 	  char (33) unaligned,			/* name of this attribute */
  5    59      2 domain_info_ptr (attribute_list_count refer (attribute_list.count))
  5    60 		   bit (18) unal,			/* offset in db_model of the domain_info structure for this attribute */
  5    61      2 attribute_ptr (attribute_list_count refer (attribute_list.count))
  5    62 		 ptr;				/* -> attribute structure */
  5    63 
  5    64 dcl relation_list_ptr ptr;
  5    65 dcl relation_list_count fixed bin;
  5    66 dcl relation_list_names char (33*relation_list.count) based (addr (relation_list.name (1)));
  5    67 dcl 1 relation_list based (relation_list_ptr),
  5    68      2 count fixed bin,				/* number of relations that are to be touched in this operation */
  5    69      2 name (relation_list_count refer (relation_list.count))
  5    70 	  char (33) unaligned,			/* name of this relation */
  5    71      2 relation_ptr (relation_list_count refer (relation_list.count))
  5    72 		ptr;				/* -> relation structure */
  5    73 
  5    74 dcl relation_ptr ptr;
  5    75 dcl relation_attribute_count fixed bin;
  5    76 dcl relation_attribute_names char (33*relation.attribute_count) based (addr (relation.attribute_names (1)));
  5    77 dcl 1 relation based (relation_ptr),
  5    78      2 name char (32),				/* name of the relation */
  5    79      2 file_model_ptr ptr,				/* -> relation.m segment */
  5    80      2 copy_file_model_ptr ptr,
  5    81      2 attribute_count fixed bin,			/* number of attributes defined for this relation */
  5    82      2 mbz fixed bin (35),
  5    83      2 attribute (relation_attribute_count refer (relation.attribute_count)),
  5    84       3 flags aligned,
  5    85         4 delete bit (1) unaligned,			/* ON: delete this attribute */
  5    86         4 new bit (1) unaligned,			/* ON: this attribute is added to the relation */
  5    87         4 part_of_key bit (1) unaligned,                    /* ON: this attribute is part of the primary key */
  5    88         4 to_be_deleted bit (1) unaligned,
  5    89         4 pad bit (32) unaligned,
  5    90       3 domain_info_ptr bit (18) aligned,		/* -> db_model domain_info structure */
  5    91       3 attribute_info_ptr ptr,			/* -> file_model attribute_info structure */
  5    92       3 value_ptr ptr,				/* if flags.new, this -> the value of the column to be stored */
  5    93 						/*   it must be of the correct data type as specified by the domain */
  5    94      2 attribute_names (relation_attribute_count refer (relation.attribute_count))
  5    95 		   char (33) unaligned;
  5    96 
  5    97 dcl attribute_ptr ptr;
  5    98 dcl attribute_count fixed bin;
  5    99 dcl 1 attribute based (attribute_ptr),
  5   100      2 count fixed bin,				/* number of relations this attribute is used in */
  5   101      2 relation_idx (attribute_count refer (attribute.count))
  5   102 		fixed bin;			/* index into list of relation names */
  5   103 
  5   104 /*  END OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      478 
      479 
  6     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  6     2 /* format: style2,^inddcls,idind32 */
  6     3 
  6     4 declare 1 terminate_file_switches	based,
  6     5 	2 truncate		bit (1) unaligned,
  6     6 	2 set_bc			bit (1) unaligned,
  6     7 	2 terminate		bit (1) unaligned,
  6     8 	2 force_write		bit (1) unaligned,
  6     9 	2 delete			bit (1) unaligned;
  6    10 
  6    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  6    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  6    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  6    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  6    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  6    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  6    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  6    18 
  6    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      480 
      481 
      482      end mrds_dm_display_cmdb;
      483 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1142.7  mrds_dm_display_cmdb.pl1          >special_ldd>install>MR12.0-1187>mrds_dm_display_cmdb.pl1
470          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
472          2    10/16/86  1140.1  mrds_dm_display_info.incl.pl1     >special_ldd>install>MR12.0-1187>mrds_dm_display_info.incl.pl1
474          3    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
476          4    10/16/86  1139.9  mdbm_file_model.incl.pl1          >special_ldd>install>MR12.0-1187>mdbm_file_model.incl.pl1
478          5    10/16/86  1140.3  rmdb_crossref_info.incl.pl1       >special_ldd>install>MR12.0-1187>rmdb_crossref_info.incl.pl1
480          6    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTRIBUTE_KEY_HEAD              000001 constant        char(10)                 initial unaligned dcl 5-31 ref 140 141 153 153 165
BOF                             000004 constant        fixed bin(17,0)          initial dcl 408 set ref 134*
I_mrds_dm_display_info_ptr             parameter       pointer                  dcl 31 ref 7 38
MRDS_DM_DISPLAY_INFO_VERSION_1         constant        fixed bin(17,0)          initial dcl 2-54 ref 51
NULL_OFFSET                            constant        bit(18)                  initial unaligned dcl 440 ref 72 82 101 105 109 213
                                                                                  221 257 318 343
O_err_code                             parameter       fixed bin(35,0)          dcl 33 set ref 7 40* 368*
O_err_msg                              parameter       char                     unaligned dcl 32 set ref 7 39* 369*
R_ACCESS                        000042 constant        bit(3)                   initial unaligned dcl 1-11 set ref 324*
TERM_FILE_TERM                  000000 constant        bit(3)                   initial unaligned dcl 6-14 set ref 385*
addr                                                   builtin function         dcl 407 ref 89 89 113 113 142 142 149
ai_ptr                          001056 automatic       pointer                  dcl 4-209 set ref 213* 213* 217 219 221* 225 257*
                                                                                  257* 261 264* 268 343* 343* 347 348* 350
attr_info                              based           structure                level 1 dcl 4-192
attr_line                       000100 automatic       varying char             dcl 209 set ref 211* 217* 217 219* 219 221* 221 223*
                                                                                  223 227* 229*
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 4-126 ref 213 257 343
check_path_ptr           15            based           bit(18)                  level 2 packed unaligned dcl 3-125 set ref 101 101*
                                                                                  101*
cleanup                         000100 stack reference condition                dcl 409 ref 48
clock                                                  builtin function         dcl 410 ref 61 61
code                            000106 automatic       fixed bin(35,0)          dcl 411 set ref 134* 135 135* 142* 143 150 152* 153
                                                                                  153* 157 158* 160 160* 162 182 182* 302* 304 304*
                                                                                  324* 325*
crossref_info_record_ptr        001060 automatic       pointer                  dcl 5-17 set ref 149* 158*
date_time_                      000010 constant        entry                    external dcl 412 ref 61
db_desc                  11            based           bit(36)                  level 2 dcl 3-125 set ref 89 89 113
db_model                               based           structure                level 1 dcl 3-72
db_path                   4            based           char(168)                level 2 packed unaligned dcl 2-12 set ref 63* 73*
                                                                                  144* 191* 302* 324* 325
dbm_ptr                         001042 automatic       pointer                  dcl 3-106 in procedure "mrds_dm_display_cmdb" set
                                                                                  ref 44* 72 82 82 119 124 164 190 227 302* 310 311
                                                                                  313 318 318 347 352 387 401
dbm_ptr                 132            based           pointer                  level 2 in structure "mrds_dm_display_info" dcl 2-12
                                                                                  in procedure "mrds_dm_display_cmdb" ref 44
decd_path_ptr            16(18)        based           bit(18)                  level 2 packed unaligned dcl 3-125 set ref 109 109*
                                                                                  109*
desc_str                        000107 automatic       varying char(120)        dcl 413 set ref 91* 96* 97*
di_ptr                          001046 automatic       pointer                  dcl 3-155 set ref 82* 82* 86 89 89 92 97 101 101 101
                                                                                  105 105 105 109 109 109 113 113 113 113* 119 164*
                                                                                  167 172 347* 348
domain_info                            based           structure                level 1 dcl 3-125
domain_offset                   000146 automatic       bit(18)                  dcl 414 set ref 149 164
domain_ptr               22(18)        based           bit(18)                  level 2 in structure "db_model" packed unaligned
                                                                                  dcl 3-72 in procedure "mrds_dm_display_cmdb" ref
                                                                                  72 82
domain_ptr               17            based           bit(18)                  level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 4-192 in procedure "mrds_dm_display_cmdb" ref
                                                                                  347
encd_path_ptr            16            based           bit(18)                  level 2 packed unaligned dcl 3-125 set ref 105 105*
                                                                                  105*
entry                    52            based           char(32)                 level 2 packed unaligned dcl 3-172 ref 403
err_code                               parameter       fixed bin(35,0)          dcl 364 ref 362 368
err_message                            parameter       char                     unaligned dcl 365 ref 362 369
error_message                   000147 automatic       char(500)                unaligned dcl 415 set ref 302* 304*
error_table_$end_of_info        000012 external static fixed bin(35,0)          dcl 416 ref 153 182
error_table_$long_record        000014 external static fixed bin(35,0)          dcl 417 ref 160
error_table_$no_record          000016 external static fixed bin(35,0)          dcl 418 ref 143
error_table_$unimplemented_version
                                000020 external static fixed bin(35,0)          dcl 419 set ref 51*
fi_ptr                          001044 automatic       pointer                  dcl 3-119 set ref 318* 318* 322 329* 352
file_info                              based           structure                level 1 dcl 3-113
file_model                             based           structure                level 1 dcl 4-40
file_model_name                 000344 automatic       char(32)                 unaligned dcl 420 set ref 322* 324* 325
file_model_ptr           10            based           pointer                  array level 2 dcl 462 set ref 204 252 313* 330* 385*
file_name                              based           char(30)                 level 2 dcl 3-113 ref 322 329
file_ptr                 22            based           bit(18)                  level 2 packed unaligned dcl 3-72 ref 318
fm_ptr                          001052 automatic       pointer                  dcl 4-108 set ref 204* 213 225 252* 257 268 324* 325
                                                                                  327 327 330 343 350
found_one                       000354 automatic       bit(1)                   unaligned dcl 422 set ref 81* 87 87* 120 128 315*
                                                                                  343 348*
fwd_ptr                  11            based           bit(18)                  level 2 packed unaligned dcl 3-113 ref 352
fwd_thread               20            based           bit(18)                  level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 4-192 in procedure "mrds_dm_display_cmdb" ref
                                                                                  221 225 268 350
fwd_thread               14(18)        based           bit(18)                  level 2 in structure "domain_info" packed unaligned
                                                                                  dcl 3-125 in procedure "mrds_dm_display_cmdb" ref
                                                                                  119
i                               000355 automatic       fixed bin(17,0)          dcl 423 set ref 200* 202 204 205* 227 244* 246 250
                                                                                  252 253* 384* 385*
index_attr               10(01)        based           bit(1)                   level 2 packed unaligned dcl 4-192 ref 261
indexed                  14            based           bit(1)                   array level 2 in structure "rel_name_table" dcl 462
                                                                                  in procedure "mrds_dm_display_cmdb" set ref 246
                                                                                  311* 332* 333
indexed                  11(04)        based           bit(1)                   level 2 in structure "rel_info" packed unaligned
                                                                                  dcl 4-126 in procedure "mrds_dm_display_cmdb" ref
                                                                                  332
initiate_file_                  000022 constant        entry                    external dcl 424 ref 324
ioa_$ioa_switch                 000024 constant        entry                    external dcl 425 ref 63 73 79 88 122 132 144 169 185
                                                                                  191 281
ioa_$ioa_switch_nnl             000026 constant        entry                    external dcl 426 ref 92 97 101 105 109 113 172 198
                                                                                  202 227 229 240 250 270 272
iocb_ptr                        000356 automatic       pointer                  dcl 427 set ref 42* 63* 73* 79* 88* 92* 97* 101*
                                                                                  105* 109* 113* 122* 132* 144* 169* 172* 185* 191*
                                                                                  198* 202* 227* 229* 240* 250* 270* 272* 281*
iox_$control                    000030 constant        entry                    external dcl 428 ref 142
iox_$position                   000032 constant        entry                    external dcl 429 ref 134
iox_$read_key                   000034 constant        entry                    external dcl 430 ref 152
iox_$read_record                000036 constant        entry                    external dcl 431 ref 158
key                             000360 automatic       varying char(256)        dcl 432 set ref 152* 153 165* 165 167 172*
key_attr                 10            based           bit(1)                   level 2 packed unaligned dcl 4-192 ref 219
length                                                 builtin function         dcl 433 ref 141 153 165
line                            000461 automatic       varying char(500)        dcl 434 set ref 233* 254* 263* 263 264* 264 270*
                                                                                  272* 274*
long                    134(01)        based           bit(1)                   level 3 packed unaligned dcl 2-12 ref 59 90
long_desc_str                   000657 automatic       varying char(120)        dcl 435 set ref 89* 91 92* 96*
mdbm_util_$display_descriptor   000040 constant        entry                    external dcl 436 ref 89 113
mdbm_util_$trim_descriptor      000042 constant        entry                    external dcl 437 ref 96
mrds_dm_display_info                   based           structure                level 1 dcl 2-12
mrds_dm_display_info_ptr        001040 automatic       pointer                  dcl 2-52 set ref 38* 42 44 51 59 63 73 90 144 191
                                                                                  300 302 302 302 302 306 310 324 325
mu_db_xref$xref_build           000044 constant        entry                    external dcl 438 ref 302
n                         1     000734 automatic       fixed bin(17,0)          level 2 dcl 457 set ref 141*
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 4-192
                                                                                  in procedure "mrds_dm_display_cmdb" ref 217 264
                                                                                  348
name                                   based           char(32)                 level 2 in structure "domain_info" dcl 3-125
                                                                                  in procedure "mrds_dm_display_cmdb" set ref 92*
                                                                                  97* 167 172* 348
null                                                   builtin function         dcl 439 ref 43 45 301 313 325 383
num_attr                 12            based           fixed bin(17,0)          level 2 packed unaligned dcl 4-126 ref 209
num_rels                 14            based           fixed bin(17,0)          level 2 packed unaligned dcl 3-72 ref 124 190 227
                                                                                  310 311 313 387
number_indexed_rels             000716 automatic       fixed bin(17,0)          dcl 441 set ref 46* 238 270 333* 333
number_indexed_rels_used        000717 automatic       fixed bin(17,0)          dcl 442 set ref 242* 248* 248 270
one_found                       000720 automatic       bit(1)                   unaligned dcl 443 set ref 255* 263 266*
output_iocb_ptr           2            based           pointer                  level 2 dcl 2-12 ref 42
path                                   based           char(168)                level 2 packed unaligned dcl 3-172 ref 403
path_entry                             based           structure                level 1 packed unaligned dcl 3-172
path_entry_ptr                  001050 automatic       pointer                  dcl 3-177 set ref 401* 403 403
path_ptr                               parameter       bit(18)                  unaligned dcl 396 ref 394 401
printed_one_sw                  000721 automatic       bit(1)                   unaligned dcl 444 set ref 137* 169 175*
ptr                                                    builtin function         dcl 445 ref 82 119 164 213 225 257 268 318 327 343
                                                                                  347 350 352 401
rec_len                         000722 automatic       fixed bin(21,0)          dcl 446 set ref 152*
rel                                                    builtin function         dcl 447 ref 82 213 257 318 343
rel_info                               based           structure                level 1 dcl 4-126
rel_info_ptr             12            based           pointer                  array level 2 dcl 462 set ref 205 253 331*
rel_name                               based           char(32)                 array level 2 dcl 462 set ref 202* 250* 329*
rel_name_table                         based           structure                array level 1 dcl 462 set ref 310 387
rel_name_table_ix               000723 automatic       fixed bin(17,0)          dcl 448 set ref 200 244 312* 328* 328 329 330 331
                                                                                  332 333 384
rel_name_table_ptr              001036 automatic       pointer                  dcl 468 set ref 45* 202 204 205 246 250 252 253 310*
                                                                                  311 313 329 330 331 332 333 383 385 387
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 4-40 ref 327
ri_ptr                          001054 automatic       pointer                  dcl 4-185 set ref 205* 209 213 253* 257 327* 331 332
                                                                                  343
rtrim                                                  builtin function         dcl 449 ref 167 217 264 322 325 403 403
seek_head_info                  000734 automatic       structure                level 1 dcl 457 set ref 142 142
seek_key                  2     000734 automatic       char(256)                level 2 dcl 457 set ref 140*
seek_type                       000734 automatic       fixed bin(17,0)          level 2 dcl 457 set ref 139*
separator                              parameter       char(1)                  unaligned dcl 397 ref 394 403
substr                                                 builtin function         dcl 450 ref 153 165
sw                      134            based           structure                level 2 dcl 2-12
temp_dir_path            56            based           char(168)                level 2 packed unaligned dcl 2-12 set ref 302*
temp_file_iocb_ptr              000724 automatic       pointer                  dcl 452 set ref 43* 134* 142* 152* 158* 300* 301
                                                                                  306*
terminate_file_                 000046 constant        entry                    external dcl 453 ref 385
time_of_list                    000726 automatic       char(24)                 unaligned dcl 454 set ref 61* 63*
unreferenced             10(04)        based           bit(1)                   level 2 packed unaligned dcl 3-125 ref 86
user_desc                12            based           bit(36)                  level 2 dcl 3-125 set ref 113 113 113
version                                based           fixed bin(17,0)          level 2 dcl 2-12 ref 51
wa                                     based           area(1024)               dcl 455 ref 310
work_area_ptr           130            based           pointer                  level 2 dcl 2-12 ref 310
xref_iocb_ptr           146            based           pointer                  level 2 dcl 2-12 set ref 300 302* 306
xref_name               150            based           char(32)                 level 2 packed unaligned dcl 2-12 set ref 302*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
DOMAIN_KEY_HEAD                        internal static char(7)                  initial unaligned dcl 5-32
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
OBJECT_HEAD                            internal static char(1)                  initial unaligned dcl 5-29
RELATION_KEY_HEAD                      internal static char(9)                  initial unaligned dcl 5-33
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 6-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 6-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 6-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 6-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 6-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 6-15
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
al_ptr                                 automatic       pointer                  dcl 4-345
alloc_length                           internal static fixed bin(35,0)          dcl 3-222
atd                                    based           char                     unaligned dcl 4-109
atd_len                                automatic       fixed bin(17,0)          dcl 4-111
atd_ptr                                automatic       pointer                  dcl 4-110
attr_list                              based           structure                level 1 dcl 4-341
attribute                              based           structure                level 1 unaligned dcl 5-99
attribute_count                        automatic       fixed bin(17,0)          dcl 5-98
attribute_list                         based           structure                level 1 unaligned dcl 5-55
attribute_list_count                   automatic       fixed bin(17,0)          dcl 5-53
attribute_list_names                   based           char                     unaligned dcl 5-54
attribute_list_ptr                     automatic       pointer                  dcl 5-52
attribute_ptr                          automatic       pointer                  dcl 5-97
changer                                based           structure                level 1 packed unaligned dcl 3-251
changer_ptr                            automatic       pointer                  dcl 3-256
child_link_info                        based           structure                level 1 dcl 4-283
cli_ptr                                automatic       pointer                  dcl 4-329
cna_ptr                                automatic       pointer                  dcl 4-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 4-112
constant                               based           structure                level 1 unaligned dcl 3-216
constant_ptr                           automatic       pointer                  dcl 3-220
crossref_info_record                   based           structure                level 1 unaligned dcl 5-19
crossref_info_record_count             automatic       fixed bin(21,0)          dcl 5-18
crossref_info_record_objects           based           char                     unaligned dcl 5-27
domain_list                            based           structure                level 1 unaligned dcl 5-45
domain_list_count                      automatic       fixed bin(17,0)          dcl 5-43
domain_list_names                      based           char                     unaligned dcl 5-44
domain_list_ptr                        automatic       pointer                  dcl 5-42
dp_ptr                                 automatic       pointer                  dcl 4-356
dup_prev                               based           structure                level 1 dcl 4-353
fixed                                                  builtin function         dcl 421
message_str                            based           structure                level 1 packed unaligned dcl 3-259
message_str_len                        automatic       fixed bin(17,0)          dcl 3-269
message_str_ptr                        automatic       pointer                  dcl 3-267
name_list                              based           structure                level 1 dcl 2-48
name_list_ptr                          automatic       pointer                  dcl 2-53
ncomp_init                             automatic       fixed bin(17,0)          dcl 4-116
num_names_alloc                        automatic       fixed bin(17,0)          dcl 2-55
parent_link_info                       based           structure                level 1 dcl 4-223
pli_ptr                                automatic       pointer                  dcl 4-268
relation                               based           structure                level 1 unaligned dcl 5-77
relation_attribute_count               automatic       fixed bin(17,0)          dcl 5-75
relation_attribute_names               based           char                     unaligned dcl 5-76
relation_list                          based           structure                level 1 unaligned dcl 5-67
relation_list_count                    automatic       fixed bin(17,0)          dcl 5-65
relation_list_names                    based           char                     unaligned dcl 5-66
relation_list_ptr                      automatic       pointer                  dcl 5-64
relation_ptr                           automatic       pointer                  dcl 5-74
sc_ptr                                 automatic       pointer                  dcl 4-365
select_chain                           based           structure                level 1 dcl 4-357
sk_ptr                                 automatic       pointer                  dcl 4-352
sort_key                               based           structure                level 1 dcl 4-346
stack_item                             based           structure                level 1 unaligned dcl 3-206
stack_item_ptr                         automatic       pointer                  dcl 3-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 451
terminate_file_switches                based           structure                level 1 packed unaligned dcl 6-4
ua_ptr                                 automatic       pointer                  dcl 3-165
unreferenced_attribute                 based           structure                level 1 dcl 3-159
version_status                         based           structure                level 1 packed unaligned dcl 3-232
version_status_ptr                     automatic       pointer                  dcl 3-246

NAMES DECLARED BY EXPLICIT CONTEXT.
NO_DOMAINS                      000442 constant        label                    dcl 73 ref 120
build_db_attr_list              002452 constant        entry                    internal dcl 290 ref 124
error                           003072 constant        entry                    internal dcl 362 ref 51 135 182 304 325
exit                            002451 constant        label                    dcl 285 ref 371
get_path_entry                  003224 constant        entry                    internal dcl 394 ref 101 101 105 105 109 109
mrds_dm_display_cmdb            000260 constant        entry                    external dcl 7
tidy_up                         003133 constant        entry                    internal dcl 381 ref 48 283 370

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3560        3630    3322        3570
Length      4220    3322        50         354     235           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dm_display_cmdb                725 external procedure  is an external procedure.  
on unit on line 48                   64 on unit               
begin block on line 207              86 begin block         uses auto adjustable storage.  
build_db_attr_list                      internal procedure  shares stack frame of external procedure mrds_dm_display_cmdb.  
error                                65 internal procedure  is called during a stack extension.  
tidy_up                              86 internal procedure  is called by several nonquick procedures.  
get_path_entry                          internal procedure  shares stack frame of external procedure mrds_dm_display_cmdb.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 207  000100 attr_line                   begin block on line 207
mrds_dm_display_cmdb     000106 code                        mrds_dm_display_cmdb
                         000107 desc_str                    mrds_dm_display_cmdb
                         000146 domain_offset               mrds_dm_display_cmdb
                         000147 error_message               mrds_dm_display_cmdb
                         000344 file_model_name             mrds_dm_display_cmdb
                         000354 found_one                   mrds_dm_display_cmdb
                         000355 i                           mrds_dm_display_cmdb
                         000356 iocb_ptr                    mrds_dm_display_cmdb
                         000360 key                         mrds_dm_display_cmdb
                         000461 line                        mrds_dm_display_cmdb
                         000657 long_desc_str               mrds_dm_display_cmdb
                         000716 number_indexed_rels         mrds_dm_display_cmdb
                         000717 number_indexed_rels_used    mrds_dm_display_cmdb
                         000720 one_found                   mrds_dm_display_cmdb
                         000721 printed_one_sw              mrds_dm_display_cmdb
                         000722 rec_len                     mrds_dm_display_cmdb
                         000723 rel_name_table_ix           mrds_dm_display_cmdb
                         000724 temp_file_iocb_ptr          mrds_dm_display_cmdb
                         000726 time_of_list                mrds_dm_display_cmdb
                         000734 seek_head_info              mrds_dm_display_cmdb
                         001036 rel_name_table_ptr          mrds_dm_display_cmdb
                         001040 mrds_dm_display_info_ptr    mrds_dm_display_cmdb
                         001042 dbm_ptr                     mrds_dm_display_cmdb
                         001044 fi_ptr                      mrds_dm_display_cmdb
                         001046 di_ptr                      mrds_dm_display_cmdb
                         001050 path_entry_ptr              mrds_dm_display_cmdb
                         001052 fm_ptr                      mrds_dm_display_cmdb
                         001054 ri_ptr                      mrds_dm_display_cmdb
                         001056 ai_ptr                      mrds_dm_display_cmdb
                         001060 crossref_info_record_ptr    mrds_dm_display_cmdb

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   enter_begin_block   leave_begin_block   call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other      return_mac          tra_ext_1           alloc_auto_adj
enable_op           shorten_stack       ext_entry_desc      int_entry           int_entry_desc      op_alloc_
op_freen_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
date_time_                    initiate_file_                ioa_$ioa_switch               ioa_$ioa_switch_nnl
iox_$control                  iox_$position                 iox_$read_key                 iox_$read_record
mdbm_util_$display_descriptor mdbm_util_$trim_descriptor    mu_db_xref$xref_build         terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$long_record      error_table_$no_record
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      7 000254        38 000273        39 000277        40 000303        42 000304        43 000306        44 000310
     45 000312        46 000313        48 000314        51 000336        59 000361        61 000365        63 000404
     72 000435        73 000442        76 000467        79 000470        81 000512        82 000514        86 000525
     87 000531        88 000535        89 000554        90 000570        91 000574        92 000601        94 000632
     96 000633        97 000664       101 000716       105 000766       109 001033       113 001102       119 001145
    120 001154       122 001156       124 001175       128 001202       132 001204       134 001225       135 001243
    137 001264       139 001265       140 001266       141 001271       142 001273       143 001326       144 001332
    146 001356       149 001357       150 001361       152 001364       153 001401       157 001412       158 001414
    160 001436       162 001443       164 001445       165 001451       167 001462       169 001500       172 001520
    175 001551       180 001553       182 001554       185 001576       190 001615       191 001622       194 001647
    198 001650       200 001671       202 001701       204 001734       205 001741       207 001744       209 001747
    227 001763       229 001766       211 001771       213 001772       217 002004       219 002032       221 002044
    223 002061       225 002073       227 002100       229 002132       231 002156       233 002157       234 002160
    238 002162       240 002164       242 002205       244 002206       246 002215       248 002221       250 002222
    252 002253       253 002260       254 002263       255 002264       257 002265       261 002275       263 002301
    264 002315       266 002341       268 002343       270 002351       272 002400       274 002423       277 002424
    281 002426       283 002445       285 002451       290 002452       300 002453       301 002456       302 002462
    304 002522       306 002540       310 002543       311 002554       312 002572       313 002573       315 002610
    318 002611       322 002623       324 002652       325 002712       327 002771       328 003002       329 003003
    330 003013       331 003015       332 003016       333 003023       343 003025       347 003037       348 003045
    350 003053       352 003061       355 003070       362 003071       368 003105       369 003112       370 003122
    371 003127       381 003132       383 003140       384 003145       385 003156       386 003212       387 003215
    390 003223       394 003224       401 003226       403 003236


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
