	COMPILATION LISTING OF SEGMENT cm_put_header
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0954.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*          The entry cm_put_header$cm_put_header implements
       11*     collection_manager_$put_header.
       12*          The entry cm_put_header$unprotected implements
       13*     collection_manager_$put_unprotected_header.
       14*
       15*          This routine puts a caller-supplied header associated with a 
       16*     collection.  If the header is not already present (indicated by
       17*     collection_header.header_record_id equal to "0"b), the given header is
       18*     allocated.  If the header is already present, it is replaced by the 
       19*     given header.  If entered via the $unprotected entry, the replacement
       20*     is done without obtaining an exclusive lock on the control interval in 
       21*     which the header is stored, but the new header must be the same length
       22*     as the old one.
       23**/
       24 
       25 /* Written by Matthew Pierret.
       26*Modified:
       27*06/08/82 by Matthew Pierret: Changed call to cm_allocate_element$header to
       28*            be to cm_allocate_element. The collection_header that was being 
       29*            passed was for the collection whose header was being put; 
       30*            cm_allocate_element$header assumes that it is the header of the 
       31*            collection that the header is being put into, i.e. the header collection.
       32*06/15/82 by Matthew Pierret: Changed calling sequence of cm_put_element.
       33*08/04/82 by Matthew Pierret: Changed to use bit(36)aligned collection id.
       34*11/05/82 by Matthew Pierret: Changed to get opening info for specified 
       35*            collection and header collection, and to pass a pointer to the
       36*            header collection info (hc_cm_info_ptr) to 
       37*            cm_(allocate put)_element$info;
       38*01/27/83 by Matthew Pierret: Upgraded to CM_INFO_VERSION_2. Changed to report
       39*            certain errors from cm_put_element which indicate internal
       40*            inconsistencies via sub_err_.
       41*06/12/84 by Matthew Pierret: Re-named cm_put_element to cm_modify,
       42*            cm_allocate_element to cm_put.
       43*10/03/84 by Matthew Pierret: Changed to use ERROR_RETURN procedure to return
       44*            in the case of an error.  Added addr and 
       45*            error_table_$unimplemented_version in the main procedure.
       46*            Changed to use local code variable instead of p_code parameter.
       47**/
       48 
       49 /* format: style2,ind3 */
       50 
       51 /* format: style2,ind3 */
       52 
       53 cm_put_header:
       54    proc (p_file_opening_id, p_collection_id, p_header_ptr, p_header_length, p_code);
       55 
       56 
       57 /* START OF DECLARATIONS */
       58 /* Parameter */
       59 
       60       dcl	    p_file_opening_id      bit (36) aligned;
       61       dcl	    p_collection_id	       bit (36) aligned;
       62       dcl	    p_header_ptr	       ptr;
       63       dcl	    p_header_length	       fixed bin (35);
       64       dcl	    p_code	       fixed bin (35);
       65 
       66 /* Automatic */
       67 
       68       dcl	    code		       fixed bin (35);
       69       dcl	    hc_cm_info_ptr	       ptr init (null);
       70       dcl	    is_unprotected	       bit (1) aligned init ("0"b);
       71 
       72 /* Based */
       73 /* Builtin */
       74 
       75       dcl	    (addr, null)	       builtin;
       76 
       77 /* Controlled */
       78 /* Constant */
       79 
       80       dcl	    myname	       char (32) varying init ("cm_put_header") int static options (constant);
       81       dcl	    UNINITIALIZED_ELEMENT_ID
       82 			       bit (36) aligned init ("0"b) int static options (constant);
       83       dcl	    END_OF_ELEMENT	       fixed bin (35) init (-1);
       84 
       85 /* Entry */
       86 
       87       dcl	    sub_err_	       entry () options (variable);
       88 
       89 /* External */
       90 
       91       dcl	    (
       92 	    dm_error_$ci_not_allocated,
       93 	    dm_error_$ci_not_in_collection,
       94 	    dm_error_$misformatted_ci,
       95 	    dm_error_$no_element,
       96 	    error_table_$unimplemented_version
       97 	    )		       fixed bin (35) ext;
       98 
       99 /* END OF DECLARATIONS */
      100 
      101       goto JOIN;
      102 
      103 unprotected:
      104    entry (p_file_opening_id, p_collection_id, p_header_ptr, p_header_length, p_code);
      105 
      106       is_unprotected = "1"b;
      107 
      108 JOIN:
      109       p_code, code = 0;
      110 
      111       call cm_opening_info$get (p_file_opening_id, p_collection_id, cm_info_ptr, code);
      112       if code ^= 0
      113       then call ERROR_RETURN (code);
      114 
      115       call CHECK_VERSION ("cm_info", cm_info.version, CM_INFO_VERSION_2);
      116 
      117       collection_header_ptr = cm_info.header_ptr;
      118 
      119       call CHECK_VERSION ("collection_header", collection_header.version, COLLECTION_HEADER_VERSION_2);
      120 
      121       call cm_opening_info$get (cm_info.file_oid, HEADER_COLLECTION_ID, hc_cm_info_ptr, code);
      122       if code ^= 0
      123       then call ERROR_RETURN (code);
      124 
      125       if collection_header.header_record_element_id = UNINITIALIZED_ELEMENT_ID
      126       then
      127          do;
      128 	  element_id_string = p_collection_id;
      129 
      130 	  call cm_put$info (hc_cm_info_ptr, p_header_ptr, p_header_length, element_id_string, (0), code);
      131 	  if code ^= 0
      132 	  then call ERROR_RETURN (code);
      133 
      134 	  collection_header.header_record_element_id = element_id_string;
      135 	  call cm_modify$info (hc_cm_info_ptr, collection_header_ptr, END_OF_ELEMENT, p_collection_id, (0), code);
      136 	  if code ^= 0
      137 	  then if code = dm_error_$no_element | code = dm_error_$ci_not_allocated
      138 		  | code = dm_error_$ci_not_in_collection | code = dm_error_$misformatted_ci
      139 	       then call sub_err_ (code, myname, ACTION_CANT_RESTART, null, 0,
      140 		       "^/An internal inconsistency was encountered attempting to restore the^/collection header of collection ^3bo at control interval ^d, slot ^d."
      141 		       , cm_info.collection_id,
      142 		       addr (collection_header.header_record_element_id) -> element_id.control_interval_id,
      143 		       addr (collection_header.header_record_element_id) -> element_id.index);
      144 
      145          end;
      146       else
      147          do;
      148 	  element_id_string = collection_header.header_record_element_id;
      149 
      150 	  if is_unprotected
      151 	  then call cm_modify$unprotected_info (hc_cm_info_ptr, p_header_ptr, p_header_length, element_id_string, (0),
      152 		  code);
      153 	  else call cm_modify$info (hc_cm_info_ptr, p_header_ptr, p_header_length, element_id_string, (0), code);
      154 
      155 	  if code ^= 0
      156 	  then if code = dm_error_$no_element | code = dm_error_$ci_not_allocated
      157 		  | code = dm_error_$ci_not_in_collection | code = dm_error_$misformatted_ci
      158 	       then call sub_err_ (code, myname, ACTION_CANT_RESTART, null, 0,
      159 		       "^/An internal inconsistency was encountered attempting to restore the user^/header of collection ^3bo at control interval ^d, slot ^d."
      160 		       , cm_info.collection_id,
      161 		       addr (collection_header.header_record_element_id) -> element_id.control_interval_id,
      162 		       addr (collection_header.header_record_element_id) -> element_id.index);
      163          end;
      164 
      165 MAIN_RETURN:
      166       return;
      167 
      168 
      169 ERROR_RETURN:
      170    proc (er_p_code);
      171 
      172       dcl	    er_p_code	       fixed bin (35);
      173 
      174       p_code = er_p_code;
      175       go to MAIN_RETURN;
      176 
      177    end ERROR_RETURN;
      178 
      179 CHECK_VERSION:
      180    proc (p_structure_name, p_given_version, p_correct_version);
      181 
      182       dcl	    p_structure_name       char (*);
      183       dcl	    p_given_version	       char (8) aligned;
      184       dcl	    p_correct_version      char (8) aligned;
      185 
      186       if p_given_version ^= p_correct_version
      187       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      188 	      "^/Expected version ^8a of ^a structure; received ^8a.", p_correct_version, p_structure_name,
      189 	      p_given_version);
      190 
      191       return;
      192 
      193    end CHECK_VERSION;
      194 
  1     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*        The cm_info structure is used to hold per-process opening information
  1     5*   about a collection.  It is generally allocated in the process' DM free
  1     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  1     7*   is used to provide access the cm_info structure, keeping it in a hash
  1     8*   table keyed on file opening id and collection id combined.
  1     9*        Currently cm_info is never freed until the process terminates.  Each
  1    10*   time a new transaction is started, detected when the current transaction
  1    11*   id of a process differs from cm_info.current_transaction_id, the information
  1    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  1    13*   demand, as most modules do not need the information in the storage record.
  1    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  1    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  1    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  1    17*   requested, it is placed at the location pointed to by
  1    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  1    19**/
  1    20 
  1    21 /* HISTORY:
  1    22*Written by Matthew Pierret, 10/27/82. 
  1    23*Modified:
  1    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  1    25*            storage_record_buffer_ptr. This points to the storage_record.
  1    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  1    27*            but storage_record_buffer_ptr continues to point at where the
  1    28*            storage_record was. When the storge_record is again requested,
  1    29*            it is put back in the same place rather than allocating a new
  1    30*            storage_record.
  1    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  1    32*            init clause from the version component.
  1    33**/
  1    34 
  1    35 /* format: style2,ind3,ll79 */
  1    36 
  1    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  1    38 	     2 version	      char (8),
  1    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  1    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  1    41 	     2 collection_id      bit (36) aligned init ("0"b),
  1    42 	     2 header_ptr	      ptr init (null),
  1    43 	     2 storage_record_ptr ptr init (null),
  1    44 	     2 storage_record_buffer_ptr
  1    45 			      ptr init (null);
  1    46 
  1    47      dcl	   cm_info_ptr	      ptr init (null);
  1    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  1    49 			      internal static options (constant);
  1    50 
  1    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      195 
      196       ;
      197 
  2     1 /* BEGIN INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*       Associated with each collection is the following collection_header
  2     5*   structure stored as an element in the Header Collection of the file.
  2     6*   The identifier of this element is also the idenfifier of the collection.
  2     7*   Even the Header Collection has a collection_header stored in the Header
  2     8*   Collection itself in the element identified by the constant
  2     9*   HEADER_COLLECTION_HEADER_ELEMENT_ID declared in dm_cm_hdr_col_ids.incl.pl1.
  2    10*   The information in collection_header is expected to be stable information.
  2    11*   The structure elements are described as follows:
  2    12*   
  2    13*   version is a character string version equal to COLLECTION_HEADER_VERSION_2.
  2    14*   
  2    15*   flags.fixed_size_elements indicates, if on that all elements in the
  2    16*   collection are of a fixed length.
  2    17*   
  2    18*   flags.thread_elements indicates that elements in a collection are to be
  2    19*   threaded in a linked list.  This is currrently unupported.
  2    20*   
  2    21*   flags.thread_control_intervals indicates, if on, that control intervals in
  2    22*   a collection are to be threaded in a linked list.  This is only useful if
  2    23*   the control interval storage method is blocked.
  2    24*   
  2    25*   flags.must_be_zero1 is reserved for future use and must be "0"b.
  2    26*   
  2    27*   control_interval_storage_method is the method of storage management of
  2    28*   control intervals for this collection, either
  2    29*   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD (not yet supported) or
  2    30*   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, declared in
  2    31*   dm_cism_info.incl.pl1.
  2    32*   
  2    33*   element_storage_method is the method of storage management of elements in
  2    34*   this collection, either BASIC_ELEMENT_STORAGE_METHOD or
  2    35*   ORDERED_ELEMENT_STORAGE_METHOD, declared in dm_esm_info.incl.pl1.
  2    36*   
  2    37*   maximum_element_size is the maximum size of an element in bits in this
  2    38*   collection.
  2    39*   
  2    40*   header_record_element_id is the identifier of an element containing a
  2    41*   caller-defined header for this collection.  If equal to "0"b, no
  2    42*   caller-defined header yet exists.  The put_header collection_manager_
  2    43*   operation stores such a header.
  2    44*   
  2    45*   storage_record_element_id is the identifier of the element containing the
  2    46*   storage_record for this collection.  The storage_record contains
  2    47*   information expected to be dynamic, such as the identifier of the last
  2    48*   control interval of the collection.  Its format is also dependent upon the
  2    49*   storage methods in effect for this collection.  storage_record structures
  2    50*   are declared in dm_cm_storage_record.incl.pl1.
  2    51*
  2    52**/
  2    53 
  2    54 /* HISTORY:
  2    55*Written by Matthew Pierret, 04/01/82.
  2    56*Modified:
  2    57*07/01/82 by Matthew Pierret: Changed to version A, added storage_record_area.
  2    58*10/29/82 by Matthew Pierret: Changed to version 2 ("col_hdr2"), separated
  2    59*            storage_record_area out, leaving storage_record_element_id behind.
  2    60*09/18/84 by Matthew Pierret: Added DESCRIPTION section.
  2    61**/
  2    62 
  2    63 /* format: style2,ind3,ll79 */
  2    64 
  2    65      dcl	   1 collection_header    aligned based (collection_header_ptr),
  2    66 	     2 version	      char (8),
  2    67 	     2 flags	      unaligned,
  2    68 	       3 fixed_size_elements
  2    69 			      bit (1),
  2    70 	       3 thread_elements  bit (1),
  2    71 	       3 thread_control_intervals
  2    72 			      bit (1),
  2    73 	       3 must_be_zero1    bit (15),
  2    74 	     2 control_interval_storage_method
  2    75 			      fixed bin (17) unal,
  2    76 	     2 element_storage_method
  2    77 			      fixed bin (17),
  2    78 	     2 maximum_element_size
  2    79 			      fixed bin (35),
  2    80 	     2 header_record_element_id
  2    81 			      bit (36) aligned,
  2    82 	     2 storage_record_element_id
  2    83 			      bit (36) aligned;
  2    84 
  2    85      dcl	   collection_header_ptr  ptr;
  2    86      dcl	   COLLECTION_HEADER_VERSION_2
  2    87 			      init ("col_hdr2") char (8) aligned
  2    88 			      int static options (constant);
  2    89 
  2    90 /* END INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
      198 
      199 
  3     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*        Contains the declaration of an element identifier.  Element
  3     6*   identifiers consist of two parts, the id (number) of the control interval
  3     7*   in which the element resides, and the index into the slot table of
  3     8*   the element in the control interval.  The declaration of the element_id 
  3     9*   structure reflects this division of the element identifier.  The structure 
  3    10*   is based on the automatic bit string element_id_string because programs
  3    11*   generally pass bit strings (element_id_string) to each other, then 
  3    12*   interpret the bit string by overlaying the element_id structure ony if
  3    13*   it is necessary to access the parts of the id.  Basing element_id on
  3    14*   addr(element_id_string) instead of on a pointer removes the necessity
  3    15*   for always setting that pointer explicitly and guarantees that changes
  3    16*   made to the string or structure do not get inconsistent.
  3    17*
  3    18*   Changes made to element_id must also be made to datum_id, declared in 
  3    19*   dm_cm_datum.incl.pl1.
  3    20**/
  3    21 
  3    22 /* HISTORY:
  3    23*Written by Matthew Pierret, 04/01/82.
  3    24*Modified:
  3    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  3    26**/
  3    27 
  3    28 /* format: style2,ind3,ll79 */
  3    29 
  3    30      dcl	   element_id_string      bit (36) aligned;
  3    31 
  3    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  3    33 	     2 control_interval_id
  3    34 			      fixed bin (24) unal unsigned,
  3    35 	     2 index	      fixed bin (12) unal unsigned;
  3    36 
  3    37 
  3    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      200 
      201 
  4     1 /* BEGIN INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        Contains the identifier of the Header Collection for a file
  4     6*   managed by the collection_manager_.  This is used by callers of 
  4     7*   collection_manager who wish to maintain their own file header or who wish
  4     8*   to maintain their own collection header information beyond the caller
  4     9*   collection header provided by colleciton_manager_$(get put)_header.
  4    10**/
  4    11 
  4    12 /* HISTORY:
  4    13*Written by Matthew Pierret, 09/24/84.
  4    14*Modified:
  4    15**/
  4    16 
  4    17 /* format: style2,ind3,ll79 */
  4    18 
  4    19      dcl	   HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36)
  4    20 			      aligned internal static options (constant);
  4    21 
  4    22 /* END INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
      202 
      203 
  5     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*   Contains entry declarations of internally available collection_manager_
  5     6*   entries.  Entries which are only available via the collection_manager_
  5     7*   transfer vector are not included here, but are declared instead in 
  5     8*   dm_collmgr_entry_dcls.incl.pl1.
  5     9**/
  5    10 
  5    11 /* HISTORY:
  5    12*Written by Mathew Pierret, 04/01/82.
  5    13*Modified:
  5    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
  5    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
  5    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
  5    17*            Added cm_get_element$info*, $header*.  The former is used when
  5    18*            the caller has a cm_info structure already; the latter is used to
  5    19*            get collection headers.
  5    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
  5    21*            Added cm_allocate_element$info.
  5    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
  5    23*            calling sequence for returning free space.
  5    24*            Added cm_free_cn_datum("" $header).
  5    25*01/07/83 by Matthew Pierret:  Added:
  5    26*            cm_allocate_element$buffered("" _info);
  5    27*            cm_put_element$buffered("" _info);
  5    28*            cm_put_datum_in_place$buffered("" _continued);
  5    29*            cm_put_datum_in_pool$buffered("" _continued);
  5    30*            cm_compact$buffered.
  5    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
  5    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
  5    33*            Added cm_opening_info$get_storage_record.
  5    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
  5    35*            id of the previous datum.
  5    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
  5    37*            which is for the number of slots after allocation.
  5    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
  5    39*            header header_return_slot).
  5    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
  5    41*            Added cm_get_element$bypass_info.
  5    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
  5    43*            cm_free_opening_info.
  5    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
  5    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
  5    46*            $does_replacement_fit to cm_determine_free_space.  These entries
  5    47*            return flags indicating if a datum fits in the ci and the pool.
  5    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
  5    49*            returned the new value of bci_header.free_slot_is_present.
  5    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
  5    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
  5    52*            entries.  Changed cm_get_element_$bypass_info to have the same
  5    53*            calling sequence as other cm_get_element entries.
  5    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
  5    55*            and cm_allocate_element to cm_put.
  5    56*            Switched the element_length/element_ptr parameter pair to be
  5    57*            element_ptr/element_length in cm_modify and cm_put.
  5    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
  5    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
  5    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
  5    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
  5    62*            Removed cm_find_free_space. Commented out un-used entries.
  5    63*            Re-named allocate  entries to put entries, except for allocate_ci.
  5    64*            Re-named free element and free datum entries to use delete instead
  5    65*            of free, and cm_recursive_put to cm_recursive_modify.
  5    66*            Removed cm_get_element$bypass_info.
  5    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
  5    68*            that cm_modify$buffered uses it.
  5    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
  5    70**/
  5    71 
  5    72 /* format: style2,ind3 */
  5    73 
  5    74 
  5    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  5    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
  5    77      dcl	   cm_allocate_ci$info_header
  5    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
  5    79 
  5    80 
  5    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  5    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  5    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  5    84      dcl	   cm_compact$buffered_replacement
  5    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  5    86 
  5    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  5    88 
  5    89      dcl	   cm_delete_cn_datum$header
  5    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  5    91 
  5    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  5    93 			      fixed bin (35));
  5    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
  5    95 
  5    96      dcl	   cm_determine_free_space$all
  5    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
  5    98      dcl	   cm_determine_free_space$effective
  5    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
  5   100 			      fixed bin (35));
  5   101      dcl	   cm_determine_free_space$does_new_datum_fit
  5   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
  5   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
  5   104 
  5   105 /**** Not yet used *********************************************************
  5   106*     dcl	   cm_determine_free_space$does_replacement_fit
  5   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
  5   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
  5   109*************************************************************************** */
  5   110 
  5   111      dcl	   cm_find_ci_to_alloc_datum
  5   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
  5   113 			      fixed bin (24) uns, fixed bin (35));
  5   114 
  5   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
  5   116 			      bit (1) aligned, fixed bin (35));
  5   117 
  5   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
  5   119      dcl	   cm_free_ci$raw_return_prev_next
  5   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
  5   121 			      fixed bin (24) uns, fixed bin (35));
  5   122      dcl	   cm_free_ci$trace_thread_modifications_on
  5   123 			      entry ();
  5   124      dcl	   cm_free_ci$trace_thread_modifications_off
  5   125 			      entry ();
  5   126 
  5   127 
  5   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  5   129 
  5   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  5   131      dcl	   cm_get_bci_header$exclusive
  5   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  5   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  5   134 
  5   135 /**** Not yet used ********************************************************
  5   136*     dcl	   cm_get_bci_header$slot_exclusive
  5   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  5   138*************************************************************************** */
  5   139 
  5   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  5   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  5   142      dcl	   cm_get_element$exclusive
  5   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  5   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  5   145 
  5   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  5   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  5   148 			      fixed bin (35), fixed bin (35));
  5   149 
  5   150 /**** Not yet used ********************************************************
  5   151*     dcl	   cm_get_element_portion$exclusive
  5   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  5   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  5   154*			      fixed bin (35), fixed bin (35));
  5   155*************************************************************************** */
  5   156 
  5   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  5   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  5   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  5   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  5   161 
  5   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   163 			      fixed bin (35), fixed bin (35));
  5   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   165 			      fixed bin (35), fixed bin (35));
  5   166 
  5   167 /******* Not yet used *****************************************************
  5   168*     dcl	   cm_modify$buffered_info
  5   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  5   170*			      fixed bin (35));
  5   171*****************************************************************************/
  5   172 
  5   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  5   174      dcl	   cm_modify$unprotected_info
  5   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  5   176 
  5   177 
  5   178 /******* Not yet used *****************************************************
  5   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
  5   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
  5   181*****************************************************************************/
  5   182 
  5   183 
  5   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  5   185      dcl	   cm_opening_info$get_storage_record
  5   186 			      entry (ptr, fixed bin (35));
  5   187      dcl	   cm_opening_info$full_get
  5   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  5   189      dcl	   cm_opening_info$opening_table_ptr
  5   190 			      entry () returns (ptr);
  5   191 
  5   192      dcl	   cm_postcommit_increment
  5   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  5   194 
  5   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   196 			      fixed bin (35), fixed bin (35));
  5   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   198 			      fixed bin (35), fixed bin (35));
  5   199 
  5   200 /******* Not yet used *****************************************************
  5   201*     dcl	   cm_put$buffered_info
  5   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  5   203*			      fixed bin (35));
  5   204*****************************************************************************/
  5   205 
  5   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  5   207 
  5   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  5   209 			      fixed bin (35));
  5   210 
  5   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
  5   212 
  5   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  5   214 			      fixed bin (35));
  5   215      dcl	   cm_put_datum_in_place$buffered
  5   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  5   217      dcl	   cm_put_datum_in_place$buffered_continued
  5   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  5   219 			      fixed bin (35));
  5   220      dcl	   cm_put_datum_in_place$continued
  5   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  5   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  5   223 
  5   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  5   225 			      fixed bin (35));
  5   226      dcl	   cm_put_datum_in_pool$buffered
  5   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  5   228      dcl	   cm_put_datum_in_pool$buffered_continued
  5   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  5   230 			      fixed bin (35));
  5   231      dcl	   cm_put_datum_in_pool$continued
  5   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  5   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  5   234 
  5   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  5   236 			      fixed bin (35));
  5   237      dcl	   cm_put_ordered_element$buffered
  5   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  5   239 			      fixed bin (35));
  5   240 
  5   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
  5   242 
  5   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
  5   244 			      fixed bin (35));
  5   245 
  5   246 
  5   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
  5   248 			      entry ();
  5   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
  5   250 			      entry ();
  5   251 
  5   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      204 
      205 
  6     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  6     2 /* format: style3 */
  6     3 
  6     4 /* These constants are to be used for the flags argument of sub_err_ */
  6     5 /* They are just "string (condition_info_header.action_flags)" */
  6     6 
  6     7 declare	(
  6     8 	ACTION_CAN_RESTART	init (""b),
  6     9 	ACTION_CANT_RESTART init ("1"b),
  6    10 	ACTION_DEFAULT_RESTART
  6    11 			init ("01"b),
  6    12 	ACTION_QUIET_RESTART
  6    13 			init ("001"b),
  6    14 	ACTION_SUPPORT_SIGNAL
  6    15 			init ("0001"b)
  6    16 	)		bit (36) aligned internal static options (constant);
  6    17 
  6    18 /* End include file */
      206 
      207 
      208    end cm_put_header;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0912.8  cm_put_header.pl1                 >spec>on>7192.pbf-04/04/85>cm_put_header.pl1
195          1    01/07/85  0858.4  dm_cm_info.incl.pl1               >ldd>include>dm_cm_info.incl.pl1
198          2    01/07/85  0858.2  dm_cm_collection_header.incl.pl1  >ldd>include>dm_cm_collection_header.incl.pl1
200          3    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
202          4    01/07/85  0858.8  dm_hdr_collection_id.incl.pl1     >ldd>include>dm_hdr_collection_id.incl.pl1
204          5    04/04/85  0819.0  dm_cm_entry_dcls.incl.pl1         >spec>on>7192.pbf-04/04/85>dm_cm_entry_dcls.incl.pl1
206          6    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000030 constant        bit(36)                  initial dcl 6-7 set ref 136* 155* 186*
CM_INFO_VERSION_2               000002 constant        char(8)                  initial dcl 1-48 set ref 115*
COLLECTION_HEADER_VERSION_2     000000 constant        char(8)                  initial dcl 2-86 set ref 119*
END_OF_ELEMENT                  000105 automatic       fixed bin(35,0)          initial dcl 83 set ref 83* 135*
HEADER_COLLECTION_ID            000033 constant        bit(36)                  initial dcl 4-19 set ref 121*
UNINITIALIZED_ELEMENT_ID               constant        bit(36)                  initial dcl 81 ref 125
addr                                                   builtin function         dcl 75 ref 136 136 155 155
cm_info                                based           structure                level 1 dcl 1-37
cm_info_ptr                     000106 automatic       pointer                  initial dcl 1-47 set ref 111* 115 117 121 136 155
                                                                                  1-47*
cm_modify$info                  000024 constant        entry                    external dcl 5-173 ref 135 153
cm_modify$unprotected_info      000026 constant        entry                    external dcl 5-174 ref 150
cm_opening_info$get             000030 constant        entry                    external dcl 5-184 ref 111 121
cm_put$info                     000032 constant        entry                    external dcl 5-206 ref 130
code                            000100 automatic       fixed bin(35,0)          dcl 68 set ref 108* 111* 112 112* 121* 122 122* 130*
                                                                                  131 131* 135* 136 136 136 136 136 136* 150* 153*
                                                                                  155 155 155 155 155 155*
collection_header                      based           structure                level 1 dcl 2-65
collection_header_ptr           000110 automatic       pointer                  dcl 2-85 set ref 117* 119 125 134 135* 136 136 148
                                                                                  155 155
collection_id             4            based           bit(36)                  initial level 2 dcl 1-37 set ref 136* 155*
control_interval_id                    based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 3-32 set ref
                                                                                  136* 155*
dm_error_$ci_not_allocated      000012 external static fixed bin(35,0)          dcl 91 ref 136 155
dm_error_$ci_not_in_collection  000014 external static fixed bin(35,0)          dcl 91 ref 136 155
dm_error_$misformatted_ci       000016 external static fixed bin(35,0)          dcl 91 ref 136 155
dm_error_$no_element            000020 external static fixed bin(35,0)          dcl 91 ref 136 155
element_id                             based           structure                level 1 dcl 3-32
element_id_string               000112 automatic       bit(36)                  dcl 3-30 set ref 128* 130* 134 148* 150* 153*
er_p_code                              parameter       fixed bin(35,0)          dcl 172 ref 169 174
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 91 set ref 186*
file_oid                  3            based           bit(36)                  initial level 2 dcl 1-37 set ref 121*
hc_cm_info_ptr                  000102 automatic       pointer                  initial dcl 69 set ref 69* 121* 130* 135* 150* 153*
header_ptr                6            based           pointer                  initial level 2 dcl 1-37 ref 117
header_record_element_id
                          5            based           bit(36)                  level 2 dcl 2-65 set ref 125 134* 136 136 148 155
                                                                                  155
index                     0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 3-32 set ref
                                                                                  136* 155*
is_unprotected                  000104 automatic       bit(1)                   initial dcl 70 set ref 70* 106* 150
myname                          000004 constant        varying char(32)         initial dcl 80 set ref 136* 155* 186*
null                                                   builtin function         dcl 75 ref 69 136 136 155 155 1-47 186 186
p_code                                 parameter       fixed bin(35,0)          dcl 64 set ref 53 103 108* 174*
p_collection_id                        parameter       bit(36)                  dcl 61 set ref 53 103 111* 128 135*
p_correct_version                      parameter       char(8)                  dcl 184 set ref 179 186 186*
p_file_opening_id                      parameter       bit(36)                  dcl 60 set ref 53 103 111*
p_given_version                        parameter       char(8)                  dcl 183 set ref 179 186 186*
p_header_length                        parameter       fixed bin(35,0)          dcl 63 set ref 53 103 130* 150* 153*
p_header_ptr                           parameter       pointer                  dcl 62 set ref 53 103 130* 150* 153*
p_structure_name                       parameter       char                     unaligned dcl 182 set ref 179 186*
sub_err_                        000010 constant        entry                    external dcl 87 ref 136 155 186
version                                based           char(8)                  level 2 in structure "collection_header" dcl 2-65
                                                                                  in procedure "cm_put_header" set ref 119*
version                                based           char(8)                  level 2 in structure "cm_info" dcl 1-37 in procedure
                                                                                  "cm_put_header" set ref 115*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 6-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 6-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 6-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 6-7
cm_allocate_ci                  000000 constant        entry                    external dcl 5-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 5-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 5-77
cm_compact                      000000 constant        entry                    external dcl 5-81
cm_compact$buffered             000000 constant        entry                    external dcl 5-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 5-84
cm_compact$replacement          000000 constant        entry                    external dcl 5-83
cm_delete                       000000 constant        entry                    external dcl 5-92
cm_delete$info                  000000 constant        entry                    external dcl 5-94
cm_delete_cn_datum              000000 constant        entry                    external dcl 5-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 5-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 5-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 5-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 5-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 5-111
cm_find_free_slot               000000 constant        entry                    external dcl 5-115
cm_free_ci$info                 000000 constant        entry                    external dcl 5-118
cm_free_ci$raw_return_prev_next 000000 constant        entry                    external dcl 5-119
cm_free_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 5-124
cm_free_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 5-122
cm_free_opening_info            000000 constant        entry                    external dcl 5-128
cm_get_bci_header               000000 constant        entry                    external dcl 5-130
cm_get_bci_header$exclusive     000000 constant        entry                    external dcl 5-131
cm_get_bci_header$slot          000000 constant        entry                    external dcl 5-133
cm_get_element                  000000 constant        entry                    external dcl 5-140
cm_get_element$exclusive        000000 constant        entry                    external dcl 5-142
cm_get_element_portion          000000 constant        entry                    external dcl 5-146
cm_get_id$id                    000000 constant        entry                    external dcl 5-157
cm_get_id$ptr                   000000 constant        entry                    external dcl 5-159
cm_modify                       000000 constant        entry                    external dcl 5-162
cm_modify$buffered              000000 constant        entry                    external dcl 5-164
cm_opening_info$full_get        000000 constant        entry                    external dcl 5-187
cm_opening_info$get_storage_record
                                000000 constant        entry                    external dcl 5-185
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 5-189
cm_postcommit_increment         000000 constant        entry                    external dcl 5-192
cm_put                          000000 constant        entry                    external dcl 5-195
cm_put$buffered                 000000 constant        entry                    external dcl 5-197
cm_put_basic_element            000000 constant        entry                    external dcl 5-208
cm_put_cn_datum                 000000 constant        entry                    external dcl 5-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 5-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 5-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 5-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 5-220
cm_put_datum_in_pool            000000 constant        entry                    external dcl 5-224
cm_put_datum_in_pool$buffered   000000 constant        entry                    external dcl 5-226
cm_put_datum_in_pool$buffered_continued
                                000000 constant        entry                    external dcl 5-228
cm_put_datum_in_pool$continued  000000 constant        entry                    external dcl 5-231
cm_put_ordered_element          000000 constant        entry                    external dcl 5-235
cm_put_ordered_element$buffered 000000 constant        entry                    external dcl 5-237
cm_put_overlength_tail          000000 constant        entry                    external dcl 5-241
cm_recursive_modify             000000 constant        entry                    external dcl 5-243
cm_replace_buffered_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 5-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 5-247

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000705 constant        entry                    internal dcl 179 ref 115 119
ERROR_RETURN                    000677 constant        entry                    internal dcl 169 ref 112 122 131
JOIN                            000232 constant        label                    dcl 108 ref 101
MAIN_RETURN                     000676 constant        label                    dcl 165 ref 175
cm_put_header                   000211 constant        entry                    external dcl 53
unprotected                     000222 constant        entry                    external dcl 103

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1170        1224    1014        1200
Length      1542    1014        34         301     154           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_put_header                       248 external procedure  is an external procedure.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure cm_put_header.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure cm_put_header.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_put_header            000100 code                        cm_put_header
                         000102 hc_cm_info_ptr              cm_put_header
                         000104 is_unprotected              cm_put_header
                         000105 END_OF_ELEMENT              cm_put_header
                         000106 cm_info_ptr                 cm_put_header
                         000110 collection_header_ptr       cm_put_header
                         000112 element_id_string           cm_put_header

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_modify$info                cm_modify$unprotected_info    cm_opening_info$get           cm_put$info
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$ci_not_allocated    dm_error_$ci_not_in_collection                              dm_error_$misformatted_ci
dm_error_$no_element          error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     69 000173        70 000175        83 000176    1   47 000200        53 000204       101 000217       103 000220
    106 000230       108 000232       111 000235       112 000252       115 000256       117 000277       119 000302
    121 000327       122 000345       125 000351       128 000354       130 000357       131 000401       134 000405
    135 000410       136 000433       145 000527       148 000530       150 000531       153 000557       155 000602
    165 000676       169 000677       174 000701       175 000704       179 000705       186 000716       191 001006


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
