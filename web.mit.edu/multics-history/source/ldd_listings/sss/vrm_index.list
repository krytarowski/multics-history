	COMPILATION LISTING OF SEGMENT vrm_index
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/21/84  1336.8 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 create_index: proc (I_rel_opening_id, I_id_list_ptr, I_flags, I_style, O_index_collection_id, O_code);
        8 
        9 
       10 /* .		         BEGIN_DESCRIPTION
       11*
       12*   Create an index for a relation using exactly ONE of the relation's
       13*   attributes.  When called with the Unique index bit set in the flags
       14*   structure, a primary key will be assumed and the index_collection_id
       15*   returned will be all zero bits in this case.  In the case of a single
       16*   indexed attribute, the collection id will be the bit string equivalent of
       17*   the attribute number.  The only bit in the flags structure that is honored
       18*   is the 'relation_must_be_empty' flag.  If the relation is found to not be
       19*   empty when this flag is set, an error code will be returned and the index
       20*   will not be created.  The 'style' parameter is ignored.
       21*
       22*   .		         END_DESCRIPTION
       23**/
       24 
       25 /* History:
       26*
       27*   82-09-29  R. Harvey:  Initially written
       28*   82-11-02  R. Harvey:  Modified for internal relation info structure
       29*   82-11-30  R. Harvey:  Modified to not use scan_records so that stationary
       30*		     records relations work properly.
       31*   83-01-19  R. Harvey:  Modified so that destruction of indices is done
       32*		     without looking at each tuple.
       33*   83-06-07  Roger Lackey : Added vrm_rel_desc.attr info for relation cursors
       34*   83-10-03  Roger Lackey : Changed the way that key offsets wer calculated and
       35*		        added key_bit_len value to collection info.
       36*   84-05-25  Bert Moberg : Changed to call the new routine
       37*                           vrmu_encode_key$compute_offset_and_length to
       38*                           properly calculate key offsets and lengths
       39*   84-05-30  Bert Moberg : Changed the new call to
       40*		       vrmu_encode_key$compute_offset_and_length to
       41*		       call vrmu_encode_key$compute_alignment_and_length
       42*		       as there was one case were the first try did not
       43*		       work.
       44**/
       45 
       46 
       47 /* create_index: proc (I_rel_opening_id, I_id_list_ptr, I_flags, I_style, O_index_collection_id, O_code); */
       48 
       49 
       50 /*       Parameters        */
       51 
       52 	dcl     I_rel_opening_id	 bit (36) aligned;
       53 	dcl     I_id_list_ptr	 ptr;
       54 	dcl     I_flags		 bit (36) aligned;
       55 	dcl     I_style		 fixed bin (17);
       56 	dcl     O_index_collection_id	 bit (36) aligned;
       57 	dcl     O_code		 fixed bin (35);
       58 
       59 
       60 
       61 	O_index_collection_id = "0"b;
       62 	O_code = 0;
       63 
       64 	id_list_ptr = I_id_list_ptr;
       65 	if id_list.version ^= ID_LIST_VERSION_1 then
       66 	     call error (error_table_$unimplemented_version);
       67 	string (flags) = I_flags;
       68 
       69 	change_bits_ptr, key_list_ptr, scan_iocb_ptr, index_iocb_ptr, pk_iocb_ptr, get_key_info_ptr, rs_info_ptr = null;
       70 	on cleanup call tidy_up;
       71 
       72 	call vrm_open_man$get_open_info_ptr (I_rel_opening_id, vrm_open_info_ptr, code);
       73 	if code ^= 0 then call error (code);
       74 	vrm_rel_desc_ptr = vrm_open_info.relation_model_ptr;
       75 	vrm_com_ptr = vrm_open_info.com_ptr;
       76 
       77 	if ^flags.index_is_unique then do;		/* assume non-primary key */
       78 		attr_no = id_list.id (1);		/* only support one-attribute indexes for now */
       79 
       80 		call init_create;
       81 
       82 		vrm_rel_desc.number_sec_indexes = vrm_rel_desc.number_sec_indexes + 1;
       83 
       84 		vci_no_of_attributes = 1;
       85 		allocate vrm_collection_info in (wa) set (vrm_collection_info_ptr);
       86 
       87 		call calculate_collection_id (attr_no, O_index_collection_id);
       88 		vrm_collection_info.id = substr (O_index_collection_id, 1, 8);
       89 		vrm_collection_info.unique = "0"b;
       90 		vrm_collection_info.primary_key = "0"b;
       91 		vrm_collection_info.pad = "0"b;
       92 		call fill_attribute_info;
       93 		call add_collection_info;
       94 
       95 		do x = 1 to vrm_collection_info.number_of_attributes;
       96 		     ax = vrm_collection_info.attribute (x).attr_index;
       97 		     vrm_rel_desc.attr (ax).primary_key_attr = "0"b;
       98 		     if vrm_collection_info.attribute (x).key_offset = 0 then
       99 			vrm_rel_desc.attr (ax).key_head = "1"b;
      100 		end;
      101 
      102 		tuple_ptr = addr (tuple_ptr);		/* make sure non-null */
      103 		do while (tuple_ptr ^= null ());
      104 		     call get_a_tuple (scan_iocb_ptr, file_id, tuple_id, tuple_ptr);
      105 		     if tuple_ptr ^= null () then do;
      106 			     call vrmu_build_index_list (vrm_rel_desc_ptr, vrm_open_info_ptr, tuple_ptr, change_bits_ptr, key_list_ptr, code);
      107 			     if code = 0 then call vrmu_add_indexes (index_iocb_ptr, key_list_ptr, tuple_id, code);
      108 			     if code ^= 0 then call error (code);
      109 			end;			/* tuple_ptr ^ null */
      110 		end;				/* do while */
      111 
      112 	     end;					/* index not unique */
      113 	else do;					/* primary key */
      114 		O_index_collection_id = "0"b;
      115 		vci_no_of_attributes = id_list.number_of_ids;
      116 		allocate vrm_collection_info in (wa) set (vrm_collection_info_ptr);
      117 		vrm_collection_info.id = "0"b;
      118 		vrm_collection_info.unique = "1"b;
      119 		vrm_collection_info.primary_key = "1"b;
      120 		vrm_collection_info.pad = "0"b;
      121 
      122 		call fill_attribute_info;
      123 		call add_collection_info;
      124 
      125 		vrm_rel_desc.number_primary_key_attrs = id_list.number_of_ids;
      126 		vrm_open_info.primary_key_info_ptr = vrm_collection_info_ptr;
      127 		do x = 1 to vrm_collection_info.number_of_attributes;
      128 		     ax = vrm_collection_info.attribute (x).attr_index;
      129 		     vrm_rel_desc.attr (ax).primary_key_attr = "1"b;
      130 		     if vrm_collection_info.attribute (x).key_offset = 0 then
      131 			vrm_rel_desc.attr (ax).key_head = "1"b;
      132 		end;
      133 
      134 	     end;					/* primary key */
      135 
      136 	if ^vrm_rel_desc.MRDS_compatible then do;	/* create info record */
      137 		call open_iocb (KSQU, "vrm_key_info", pk_iocb_ptr);
      138 		if code ^= 0 then call error (code);
      139 
      140 		call iox_$seek_key (pk_iocb_ptr, VRM_COLLECTION_KEY_HEAD || char (O_index_collection_id),
      141 		     (0), code);
      142 		if code ^= error_table_$no_record & code ^= 0 then call error (code);
      143 
      144 		call iox_$write_record (pk_iocb_ptr, vrm_collection_info_ptr, currentsize (vrm_collection_info), code);
      145 		if code ^= 0 then call error (code);
      146 
      147 	     end;					/* (non-MRDS) */
      148 
      149 
      150 
      151 	call tidy_up;
      152 
      153 Exit:	return;
      154 
      155 destroy_index: entry (I_rel_opening_id, I_index_collection_id, O_code);
      156 
      157 
      158 /* Parameters	   */
      159 
      160 /*	dcl     I_rel_opening_id       bit (36) aligned parameter;      */
      161 	dcl     I_index_collection_id	 bit (36) aligned parameter;
      162 
      163 /*	dcl     O_code		 fixed bin (35) parameter;	    */
      164 
      165 
      166 	O_code = 0;
      167 
      168 	call vrm_open_man$get_open_info_ptr (I_rel_opening_id, vrm_open_info_ptr, code);
      169 	if code ^= 0 then call error (code);
      170 	vrm_rel_desc_ptr = vrm_open_info.relation_model_ptr;
      171 	vrm_com_ptr = vrm_open_info.com_ptr;
      172 
      173 	found = "0"b;
      174 	do i = 1 to vrm_open_info.number_of_index_collections while (^found);
      175 	     if vrm_open_info.index_collection (i).id = I_index_collection_id then
      176 		do;
      177 		     found = "1"b;
      178 		     collection_index = i;
      179 		     vrm_collection_info_ptr = vrm_open_info.index_collection (i).info_ptr;
      180 		end;
      181 	end;
      182 
      183 	if ^found then call error (dm_error_$collection_not_in_relation);
      184 
      185 	change_bits_ptr, key_list_ptr, scan_iocb_ptr, index_iocb_ptr, get_key_info_ptr, pk_iocb_ptr = null;
      186 	on cleanup call tidy_up;
      187 	call init_destroy;
      188 
      189 
      190 	call iox_$position (index_iocb_ptr, -1, 0, code); /* -1 = goto beginning of file */
      191 	if code ^= 0 then call error (code);
      192 
      193 	index_head = "";
      194 	unspec (index_head) = vrm_rel_desc.rel_id || vrm_collection_info.id || "0000000"b;
      195 	seek_head_info.search_key = index_head;
      196 	call iox_$control (index_iocb_ptr, "seek_head", addr (seek_head_info), code);
      197 	if code ^= 0 then do;			/* check for empty relation */
      198 		if code ^= error_table_$no_record
      199 		then call error (code);
      200 		call tidy_up;
      201 		goto Exit;
      202 	     end;
      203 
      204 	key_found = index_head;
      205 	do while (substr (key_found, 1, 3) = index_head & code = 0);
      206 	     call iox_$control (index_iocb_ptr, "delete_key", null (), code);
      207 	     if code ^= 0 then call error (code);
      208 
      209 	     call iox_$read_key (index_iocb_ptr, key_found, (0), code);
      210 	     if code ^= 0
      211 	     then if code ^= error_table_$end_of_info then call error (code);
      212 	end;
      213 
      214 	call remove_collection_info;
      215 	vrm_rel_desc.number_sec_indexes = vrm_rel_desc.number_sec_indexes - 1;
      216 	if ^vrm_rel_desc.MRDS_compatible then do;	/* delete index record */
      217 	     end;
      218 
      219 	O_code = 0;
      220 	call tidy_up;				/* do non-local goto */
      221 
      222 init_create: proc;
      223 
      224 	call open_iocb (KSQU, "vrm_add_index", index_iocb_ptr);
      225 	call open_iocb (KSQR, "vrm_scan_records", scan_iocb_ptr);
      226 
      227 	call setup_for_relation_scan (scan_iocb_ptr);
      228 
      229 	cb_number_of_change_bits = vrm_rel_desc.number_attrs;
      230 	allocate change_bits set (change_bits_ptr);
      231 
      232 	string (change_bits.position) = "0"b;
      233 	change_bits.position (attr_no) = "1"b;
      234 
      235 	kl_number_of_keys = 1;
      236 	allocate key_list set (key_list_ptr);
      237 
      238 	file_id = vrm_rel_desc.file_id;
      239 
      240      end init_create;
      241 
      242 
      243 
      244 
      245 
      246 init_destroy: proc;
      247 
      248 	call open_iocb (KSQU, "vrm_delete_index", index_iocb_ptr);
      249 	call open_iocb (KSQR, "vrm_scan_records", scan_iocb_ptr);
      250 
      251 	call setup_for_relation_scan (scan_iocb_ptr);
      252 
      253 	cb_number_of_change_bits = vrm_rel_desc.number_attrs;
      254 	allocate change_bits set (change_bits_ptr);
      255 
      256 	string (change_bits.position) = "0"b;
      257 	do i = 1 to vrm_collection_info.number_of_attributes;
      258 	     attr_no = vrm_collection_info.attribute (i).attr_index;
      259 	     change_bits.position (attr_no) = "1"b;
      260 	end;
      261 
      262 	kl_number_of_keys = 1;
      263 	allocate key_list set (key_list_ptr);
      264 
      265 	file_id = vrm_rel_desc.file_id;
      266 
      267 	index_value_length = 0;			/* keep the compiler happy */
      268 
      269 
      270 	dcl     (i, attr_no)	 fixed bin;
      271 
      272      end init_destroy;
      273 
      274 open_iocb: proc (open_mode, open_name, iocb_ptr);
      275 
      276 	dcl     open_mode		 fixed bin (17) parameter;
      277 	dcl     open_name		 char (24) varying parameter;
      278 	dcl     iocb_ptr		 ptr parameter;
      279 
      280 	dcl     atd		 char (344) varying;
      281 	dcl     attach_desc		 char (344);
      282 	dcl     code		 fixed bin (35);
      283 
      284 
      285 	atd = "vfile_ " || rtrim (vrm_open_info.database_dir_path);
      286 	atd = atd || ">";
      287 	atd = atd || rtrim (vrm_open_info.relation_name);
      288 	atd = atd || " -dup_ok -share ";
      289 	atd = atd || ltrim (char (vrm_data_$max_vfile_wait_time));
      290 	if vrm_rel_desc.switches.stationary_records then
      291 	     atd = atd || " -stationary";
      292 
      293 	attach_desc = atd;
      294 	call iox_$attach_name (unique_chars_ ("0"b) || open_name,
      295 	     iocb_ptr,
      296 	     rtrim (attach_desc), null (), code);
      297 	if code ^= 0 then call error (code);
      298 	call iox_$open (iocb_ptr, open_mode, "0"b, code);
      299 	if code ^= 0 then call error (code);
      300 
      301      end open_iocb;
      302 
      303 setup_for_relation_scan: proc (sfrs_rel_scan_iocb_ptr);
      304 						/*
      305*   This routine sets up the beginning of the primary key so that the
      306*   get_a_tuple routine can be called to get each record in turn
      307**/
      308 
      309 /* PARAMETERS */
      310 
      311 	dcl     sfrs_rel_scan_iocb_ptr ptr;		/* (input) pointer to the iocb that will be used to
      312*						   .       scan all the tuples in the relation */
      313 
      314 /* AUTOMATIC */
      315 
      316 	dcl     sfrs_code		 fixed bin (35);
      317 
      318 
      319 	call iox_$position (sfrs_rel_scan_iocb_ptr, -1, 0, sfrs_code); /* goto beginning of file */
      320 	if sfrs_code = 0
      321 	then do;
      322 		seek_head_info.relation_type = 0;	/* equal */
      323 		seek_head_info.n = 3;		/* 3 chars */
      324 		addr (seek_head_info.search_key) -> index.rel_id = vrm_rel_desc.rel_id;
      325 		addr (seek_head_info.search_key) -> index.index_id = "0"b; /* primary key */
      326 		addr (seek_head_info.search_key) -> index.mbz = "0"b;
      327 		call iox_$control (sfrs_rel_scan_iocb_ptr, "seek_head", addr (seek_head_info), sfrs_code);
      328 	     end;
      329 	if sfrs_code ^= 0 & sfrs_code ^= error_table_$no_record
      330 	then call error (sfrs_code);
      331 
      332 	gk_key_len = 256;
      333 	allocate gk_info set (get_key_info_ptr);
      334 	unspec (get_key_info_ptr -> gk_info.flags) = "0"b;
      335 	get_key_info_ptr -> gk_info.flags.current = "1"b;
      336 	get_key_info_ptr -> gk_info.flags.reset_pos = "0"b;
      337 
      338 	allocate rs_info set (rs_info_ptr);
      339 	rs_info.version = rs_info_version_2;
      340 	string (rs_info.flags) = "0"b;
      341 
      342 	return;
      343 
      344      end setup_for_relation_scan;
      345 
      346 get_a_tuple: proc (gat_rel_scan_iocb_ptr, gat_file_id, gat_tid, gat_tuple_ptr);
      347 
      348 /*
      349*   This routine determines a pointer  to  the  next  tuple  and  the
      350*   tuple's  tuple  id  which is based on the vfile record descriptor
      351*   for the record which contains the tuple. The tuple_id  and  vfile
      352*   descriptor are different for historical reasons.
      353**/
      354 
      355 /* PARAMETERS */
      356 
      357 	dcl     gat_rel_scan_iocb_ptr	 ptr;		/* (input) pointer to the iocb that will be used to
      358*						   .       scan all the tuples in the relation */
      359 	dcl     gat_file_id		 bit (7);		/* (input) id of the file as defined in the database model */
      360 	dcl     gat_tid		 bit (36) aligned;	/* (output) a tuple id */
      361 	dcl     gat_tuple_ptr	 ptr;		/* (output) pointer to a tuple */
      362 
      363 /* AUTOMATIC */
      364 
      365 	dcl     gat_code		 fixed bin (35);	/* local error code */
      366 	dcl     tid_ptr		 pointer;		/* Pointer to tid structure */
      367 	dcl     vfd_ptr		 pointer;		/* Pointer to vfd structure */
      368 
      369 
      370 /* BASED     */
      371 
      372 	dcl     1 tid		 aligned based (tid_ptr), /* MRDS tuple id (tid) */
      373 		2 non_std_desc	 bit (1) unal,	/* Non-standard descriptor bit */
      374 		2 temp		 bit (1) unal,	/* On if temp relation */
      375 		2 file_id		 bit (7) unal,	/* File id from mrds db_model file_id_list */
      376 		2 comp_num	 bit (10) unal,	/* Component number */
      377 		2 offset		 bit (17) unal;	/* Offset within component */
      378 
      379 
      380 	dcl     1 vfd		 aligned based (vfd_ptr), /* Vfile desc */
      381 		2 pad_1		 bit (8) unal,
      382 		2 comp_number	 bit (10) unal,	/* Component number */
      383 		2 comp_offset	 bit (17) unal,	/* Offset with in component */
      384 		2 pade_2		 bit (1) unal;
      385 
      386 
      387 	call iox_$control (gat_rel_scan_iocb_ptr, "get_key", get_key_info_ptr, gat_code);
      388 	if gat_code ^= 0
      389 	then do;
      390 		if gat_code = error_table_$end_of_info | gat_code = error_table_$no_record
      391 		then gat_tuple_ptr = null ();
      392 		else call error (gat_code);
      393 	     end;
      394 	else do;
      395 		call iox_$control (gat_rel_scan_iocb_ptr, "record_status", addr (rs_info), gat_code);
      396 		if gat_code ^= 0
      397 		then call error (gat_code);
      398 		else do;
      399 
      400 /* Convert vfile_descriptor to tuple_id (tid) */
      401 			vfd_ptr = addr (rs_info.descriptor);
      402 			tid_ptr = addr (gat_tid);
      403 			tid.non_std_desc = "1"b;
      404 			tid.temp = "0"b;
      405 			tid.file_id = gat_file_id;
      406 			tid.comp_num = vfd.comp_number;
      407 			tid.offset = vfd.comp_offset;
      408 
      409 			gat_tuple_ptr = rs_info.record_ptr;
      410 			call iox_$position (gat_rel_scan_iocb_ptr, 0, 1, gat_code); /* skip 1 record */
      411 		     end;
      412 	     end;
      413 
      414 	return;
      415 
      416      end get_a_tuple;
      417 
      418 fill_attribute_info: proc;
      419 
      420 	key_offset = 0;
      421 	do i = 1 to id_list.number_of_ids;
      422 	     attr_no = id_list.id (i);
      423 
      424 	     desc_ptr = addr (vrm_rel_desc.attr (attr_no).descriptor);
      425 
      426 	     call vrmu_encode_key$compute_alignment_and_length (desc_ptr, key_offset,
      427 		key_alignment, key_bit_len);
      428 
      429 	     key_offset = key_offset + key_alignment;
      430 	     vrm_collection_info.attribute (i).attr_index = attr_no;
      431 	     vrm_collection_info.attribute (i).key_offset = key_offset;
      432 	     vrm_collection_info.attribute (i).key_bit_len = key_bit_len;
      433 	     key_offset = key_offset + key_bit_len;
      434 
      435 	end;					/* do i */
      436 
      437 
      438 	dcl     attr_no		 fixed bin;
      439 	dcl     i			 fixed bin;
      440 	dcl     key_alignment	 fixed bin;
      441 	dcl     key_bit_len		 fixed bin;
      442 	dcl     key_offset		 fixed bin;
      443 
      444      end fill_attribute_info;
      445 
      446 calculate_collection_id: proc (attr_no, O_id);
      447 
      448 /* This procedure obtains a unassigned collection id and returns it as O_id */
      449 
      450 	dcl     attr_no		 fixed bin (17) parameter;
      451 	dcl     O_id		 bit (36) aligned parameter;
      452 
      453 	dcl     j			 fixed bin;
      454 	dcl     available		 bit (1) init ("0"b);
      455 	dcl     found		 bit (1);
      456 	dcl     candidate_id	 bit (36) aligned based (addr (id_structure));
      457 	dcl     1 id_structure	 aligned,
      458 		2 index_no	 fixed bin (8) uns unal,
      459 		2 pad		 bit (28) unal init ("0"b);
      460 
      461 	do id_structure.index_no = 1 to 255 while (^available);
      462 	     found = "0"b;
      463 	     do j = 1 to vrm_open_info.number_of_index_collections;
      464 		if vrm_open_info.index_collection (j).id = candidate_id then found = "1"b;
      465 	     end;					/* do j = 1  */
      466 
      467 	     if ^found then do;			/* got it */
      468 		     O_id = candidate_id;
      469 		     available = "1"b;
      470 		end;				/* if ^found */
      471 	end;					/* do 1 to 255 */
      472 
      473 	if ^available then call error (mdbm_error_$max_indexes);
      474 
      475 
      476      end calculate_collection_id;
      477 
      478 add_collection_info: proc;
      479 
      480 	dcl     old_vrm_open_info_ptr	 ptr;
      481 
      482 
      483 	voi_no_of_index_collections = vrm_open_info.number_of_index_collections + 1;
      484 	old_vrm_open_info_ptr = vrm_open_info_ptr;
      485 	allocate vrm_open_info in (wa) set (vrm_open_info_ptr);
      486 	vrm_open_info.number_of_index_collections = vrm_open_info.number_of_index_collections - 1; /* So we can copy old info */
      487 	vrm_open_info_ptr -> vrm_open_info = old_vrm_open_info_ptr -> vrm_open_info;
      488 	vrm_open_info.number_of_index_collections = vrm_open_info.number_of_index_collections + 1; /* Original value */
      489 	vrm_open_info.index_collection (voi_no_of_index_collections).id = O_index_collection_id;
      490 	vrm_open_info.index_collection (voi_no_of_index_collections).info_ptr = vrm_collection_info_ptr;
      491 	call vrm_open_man$set_open_info_ptr (vrm_open_info.opening_id, vrm_open_info_ptr);
      492 	free old_vrm_open_info_ptr -> vrm_open_info in (wa);
      493 
      494      end add_collection_info;
      495 
      496 remove_collection_info: proc;
      497 
      498 	vrm_collection_info_ptr = vrm_open_info.index_collection (collection_index).info_ptr;
      499 	attr_no = vrm_collection_info.attribute (1).attr_index;
      500 	vrm_open_info.index_collection (collection_index).id = "0"b;
      501 	vrm_open_info.index_collection (collection_index).info_ptr = null ();
      502 
      503      end remove_collection_info;
      504 
      505 tidy_up: proc;
      506 
      507 	if index_iocb_ptr ^= null () then call close_iocb (index_iocb_ptr);
      508 	if scan_iocb_ptr ^= null () then call close_iocb (scan_iocb_ptr);
      509 	if pk_iocb_ptr ^= null () then call close_iocb (pk_iocb_ptr);
      510 	if change_bits_ptr ^= null () then free change_bits;
      511 	if key_list_ptr ^= null () then free key_list;
      512 	if get_key_info_ptr ^= null () then free get_key_info_ptr -> gk_info;
      513 	if rs_info_ptr ^= null () then free rs_info;
      514 
      515 
      516      end tidy_up;
      517 
      518 
      519 close_iocb: proc (iocb_ptr);
      520 
      521 	dcl     iocb_ptr		 ptr parameter;
      522 
      523 	dcl     code		 fixed bin (35);
      524 
      525 	call iox_$close (iocb_ptr, code);
      526 	call iox_$detach_iocb (iocb_ptr, code);		/* ignore code */
      527 	call iox_$destroy_iocb (iocb_ptr, code);
      528 
      529 
      530      end close_iocb;
      531 
      532 
      533 
      534 
      535 
      536 error: proc (ecode);
      537 
      538 	dcl     ecode		 fixed bin (35);
      539 
      540 
      541 	O_code = ecode;
      542 	go to Exit;
      543 
      544      end error;
      545 
  1     1 /*   BEGIN INCLUDE   vrm_open_info.incl.pl1		    */
  1     2 
  1     3 /* R. Harvey  82-11-02 
  1     4*   82-09-82 Roger Lackey: added iocb_list_ptr */
  1     5 
  1     6 dcl 1 vrm_open_info aligned based (vrm_open_info_ptr),	/* Vfile relation description */
  1     7     2 version char (8),				/* Version number of this structure */
  1     8     2 opening_id bit (36) aligned,			/* Opening id associated with this desc */
  1     9     2 file_uid bit (36) aligned,			/* Unique id of msf dir */
  1    10     2 number_of_openings fixed bin,			/* Number of separate calls to vrm$open */
  1    11     2 switches,
  1    12       3 shared bit (1) unal,				/* Open relation in shared mode */
  1    13       3 pad bit (35) unal init ("0"b),			/* Unused must be zero */
  1    14     2 database_dir_path char (168) varying,		/* Absolute path of database */
  1    15     2 relation_name char (30) varying,			/* Name of relation */
  1    16     2 relation_model_ptr pointer,			/* Pointer to the relation_model in the relation itself or a temp seg */
  1    17     2 com_ptr pointer,				/* Temp seg for cursors and scratch space */
  1    18     2 iocb_list_ptr pointer,				/* Pointer to first vrm_iocb_list_block */
  1    19     2 primary_key_info_ptr pointer,			/* Special case collection info ptr */
  1    20     2 number_of_index_collections fixed bin,		/* Count of index collections (include primary key) */
  1    21     2 index_collection (voi_no_of_index_collections
  1    22 		   refer (vrm_open_info.number_of_index_collections)),
  1    23       3 id bit (36),
  1    24       3 info_ptr ptr unal;				/* Points to more detailed info */
  1    25 
  1    26 
  1    27 dcl  VRM_OPEN_INFO_VERSION_1 char (8) int static options (constant) init ("       1");
  1    28 dcl  vrm_open_info_ptr ptr;
  1    29 dcl  voi_no_of_index_collections fixed bin;
  1    30 
  1    31 /*   END INCLUDE  vrm_open_info.incl.pl1	   */
      546 
      547 
  2     1 /*   BEGIN INCLUDE  vrm_rel_desc.incl.pl1		   */
  2     2 
  2     3 /* 83-05-26 Roger Lackey : Added vrm_attr_info.key_head bit for relation_cursors */
  2     4 
  2     5 dcl 1 vrm_rel_desc based (vrm_rel_desc_ptr),
  2     6     2 record_id bit (12) unal,			/* Distinguish us from tuples and collection records */
  2     7     2 version char (8),				/* Version of this structure */
  2     8     2 file_id bit (7),				/* Value of file id from model */
  2     9     2 rel_id bit (12),				/* Relation id */
  2    10     2 switches,
  2    11       3 MRDS_compatible bit (1) unal,			/* For pre-relation_manager_ MRDS */
  2    12       3 stationary_records
  2    13      bit (1) unal,					/* On = stationary */
  2    14       3 indexed bit (1) unal,				/* This relation has attributes with secondary indices */
  2    15       3 pad bit (33) unal,
  2    16     2 var_offset fixed bin (35),			/* Position of first varying attr */
  2    17     2 maximum_data_length
  2    18      fixed bin (35),				/* Maximum size of tuple in characters */
  2    19     2 number_primary_key_attrs
  2    20      fixed bin,					/* Number of attributes which make up the primary key */
  2    21     2 number_sec_indexes fixed bin,			/* Number of attributes which have a secondary index */
  2    22     2 last_var_attr_no fixed bin,			/* Attr index of last varying attribute */
  2    23     2 number_var_attrs fixed bin,			/* Number of varying attributes */
  2    24     2 number_attrs fixed bin,				/* Number of attribute in rel */
  2    25     2 attr (vrd_no_of_attrs				/* Description of each attribute */
  2    26      refer (vrm_rel_desc.number_attrs)) aligned like vrm_attr_info;
  2    27 
  2    28 dcl 1 vrm_attr_info based (vrm_attr_info_ptr),
  2    29 						/* Attribute specific info */
  2    30     2 name char (32),				/* Name of the attribute */
  2    31     2 descriptor bit (36) aligned,			/* domain descriptor */
  2    32     2 varying bit (1) unal,				/* ON = This is a varying string */
  2    33     2 key_head bit (1) unal,				/* ON = This attr can be a keyhead */
  2    34     2 primary_key_attr bit (1) unal,			/* ON = This is a primary key attribute */
  2    35     2 pad bit (15) unal,				/* unused */
  2    36     2 index_collextion_ix fixed bin (17) unal,		/* Index into vrm_open_info.index_collection array if key_head is on */
  2    37     2 bit_length fixed bin (35),			/* Maximum bit length of tuple */
  2    38     2 bit_offset fixed bin (35);			/* Offset in tuple if fixed, index to offset in tuple if varying */
  2    39 
  2    40 
  2    41 dcl  vrm_rel_desc_ptr pointer;
  2    42 dcl  vrd_no_of_attrs fixed bin;
  2    43 dcl  VRM_REL_DESC_RECORD_ID bit (12) unal int static options (constant) init ("100000000000"b);
  2    44 dcl  VRM_REL_DESC_VERSION_1 char (8) int static options (constant) init ("       1");
  2    45 dcl  vrm_attr_info_ptr pointer;
  2    46 dcl  VRM_REL_DESC_KEY char (256) varying int static options (constant) init ("@relation_description");
  2    47 
  2    48 /*   END INCLUDE  vrm_rel_desc.incl.pl1		   */
      548 
      549 
  3     1 /*   BEGIN INCLUDE   vrm_collection_info.incl.pl1		    */
  3     2 
  3     3 /*  R. Harvey  82-11-02 */
  3     4 
  3     5 
  3     6      dcl	   1 vrm_collection_info  aligned based (vrm_collection_info_ptr),
  3     7 						/* Index collection description */
  3     8 	     2 record_id	      unal,
  3     9 	       3 header	      bit (4) unal,		/* collection type */
  3    10 	       3 id	      bit (8) unal,		/* index id */
  3    11 	     2 unique	      bit (1) unal,
  3    12 	     2 primary_key	      bit (1) unal,		/* This is the MRDS primary key collection */
  3    13 	     2 pad	      bit (26) unal,
  3    14 	     2 number_of_attributes
  3    15 			      fixed bin,
  3    16 	     2 attribute	      (vci_no_of_attributes refer (vrm_collection_info.number_of_attributes)),
  3    17 	       3 attr_index	      fixed bin,		/* Attribute number in relation description */
  3    18 	       3 key_offset	      fixed bin,		/* Offset within key in bits */
  3    19 	       3 key_bit_len      fixed bin ;		/* Length of key in bits */
  3    20 
  3    21      dcl	   vrm_collection_info_ptr
  3    22 			      ptr;
  3    23      dcl	   vci_no_of_attributes   fixed bin;
  3    24      dcl	   vrm_collection_header_type
  3    25 			      bit (4) unal int static options (constant) init ("1100"b);
  3    26      dcl	   VRM_COLLECTION_KEY_HEAD char (16) int static options (constant) init ("@collection_info");
  3    27 
  3    28 /*   END INCLUDE  vrm_collection_info.incl.pl1	   */
      550 
      551 
  4     1 /*  BEGIN INCLUDE   vrm_com.incl.pl1		 */
  4     2 
  4     3 /*  Written 82-08-23 by R. Harvey		 */
  4     4 
  4     5      dcl	   vrm_com_ptr	      ptr;
  4     6      dcl	   1 vrm_com	      aligned based (vrm_com_ptr),
  4     7 	     2 get_seg_ptr	      ptr,		/* temp seg for retrieve routines */
  4     8 	     2 put_seg_ptr	      ptr,		/* temp seg for store routines */
  4     9 	     2 mod_seg_ptr	      ptr,		/* temp seg for modify routines */
  4    10 	     2 work_area_ptr      ptr,		/* freeing area for oid_table sections and rel_descriptors */
  4    11 	     2 highest_oid	      bit (36) aligned,	/* highest valid oid */
  4    12 	     2 next_free_oid      bit (36) aligned,	/* offset of first in free chain */
  4    13 	     2 first_assigned_oid bit (36) aligned,	/* offset of first in assigned chain */
  4    14 	     2 oid_area	      area (sys_info$max_seg_size - fixed (rel (addr (vrm_com.work_area_ptr))));
  4    15 
  4    16 /*  END INCLUDE    vrm_com.incl.pl1		 */
      552 
      553 
  5     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION
  5     4*        The id_list structure is used to identify attributes, fields and
  5     5*   dimensions by various modules of the Data Management System.
  5     6**/
  5     7 
  5     8 /* HISTORY:
  5     9*Written by Matthew Pierret, '82.
  5    10*Modified:
  5    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  5    12*            (constant)' and to initialize automatic variables.
  5    13**/
  5    14 
  5    15 /* format: style2,ind3 */
  5    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  5    17 	     2 version	      fixed bin (35),
  5    18 	     2 number_of_ids      fixed bin (17),
  5    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  5    20 
  5    21      dcl	   id_list_ptr	      ptr init (null);
  5    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  5    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  5    24 
  5    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      554 
      555 
  6     1 /* BEGIN vrm_tuple.incl.pl1 -- jaw, 7/25/78 */
  6     2 
  6     3 /* 82-08-27 R. Harvey: taken from mdbm_tuple.incl.pl1 for vfile_relmgr_.
  6     4*   Modified dimension references to point to entries in vrm_rel_desc.    */ 
  6     5 
  6     6 
  6     7 dcl 1 tuple aligned based (tuple_ptr),			/* tuple format, all file types */
  6     8     2 rel_id bit (12) unal,				/* relation id */
  6     9     2 attr_exists (vrm_rel_desc.number_attrs) bit (1) unal,	/* existance flags */
  6    10     2 var_offsets (vrm_rel_desc.number_var_attrs) fixed bin (35) unal, /* offsets for variable attr.; stored as len|value */
  6    11     2 force_even_word (tuple_pad_length) fixed bin (71) aligned, /* pad to even word boundary */
  6    12     2 data char (vrm_rel_desc.maximum_data_length) unal;		/* space for data */
  6    13 
  6    14 
  6    15 dcl  tuple_ptr ptr;
  6    16 dcl  tuple_length fixed bin (21);			/* byte count */
  6    17 
  6    18 declare  tuple_pad_length fixed bin internal static init (0) ; /* minimum array size needed for even word padding */
  6    19 
  6    20 
  6    21 
  6    22 /* END vrm_tuple.incl.pl1 */
  6    23 
      556 
      557 
  7     1 /* BEGIN vrm_change_bits.incl.pl1 -- R. Harvey */
  7     2 
  7     3 dcl  1 change_bits based (change_bits_ptr),
  7     4        2 number_of_change_bits fixed bin (17),
  7     5        2 position (cb_number_of_change_bits refer (change_bits.number_of_change_bits)) bit (1) unal;
  7     6 
  7     7 dcl  cb_number_of_change_bits fixed bin;
  7     8 dcl  change_bits_ptr ptr;
  7     9 
  7    10 /* END vrm_change_bits.incl.pl1 */
      558 
      559 
  8     1 /* BEGIN vrm_key_list.incl.pl1 -- jaw, 1/17/79 */
  8     2 
  8     3 dcl 1 key_list aligned based (key_list_ptr),		/* list of keys for add_key or delete_key */
  8     4     2 number_of_keys fixed bin,			/* no. keys in list */
  8     5     2 key_info (kl_number_of_keys refer (key_list.number_of_keys)),
  8     6       3 item_index fixed bin,				/* attr. index or plink index */
  8     7       3 cand_key bit (1) unal,			/* on if key is for candidate key */
  8     8       3 unique_val bit (1) unal,			/* on if value must be unique */
  8     9       3 pad bit (34) unal,
  8    10       3 vf_info,					/* info for vfile control orders */
  8    11         4 input_key bit (1) unal,			/* if key val supplied */
  8    12         4 input_desc bit (1) unal,			/* if desc. supplied */
  8    13         4 reserved bit (34) unal,
  8    14         4 vf_desc,					/* vfile_ descriptor */
  8    15 	5 comp_no fixed bin (17) unal,
  8    16 	5 offset bit (18) unal,
  8    17         4 key char (256) var;
  8    18 
  8    19 dcl  key_list_ptr ptr;
  8    20 dcl  kl_number_of_keys fixed bin;
  8    21 
  8    22 /* END vrm_key_list.incl.pl1 */
      560 
      561 
  9     1 /* BEGIN vrm_index.incl.pl1 -- jaw, 5/12/78 */
  9     2 
  9     3 /* Renamed 9/29/82 by R. Harvey */
  9     4 
  9     5 /* This structure defines the header that gets put onto the beginning of
  9     6*   each key stored into a database */
  9     7 
  9     8 
  9     9 dcl 1 index aligned based (index_ptr),			/* layout of mdbm_index for all file types */
  9    10     2 rel_id bit (12) unal,				/* relation id */
  9    11     2 index_id bit (8) unal,				/* id of index within rel */
  9    12     2 mbz bit (7) unal,				/* pad to char. */
  9    13     2 index_value char (index_value_length) unal;		/* index value; max 253 chars */
  9    14 
  9    15 dcl  index_ptr ptr;
  9    16 dcl  index_value_length fixed bin (35);
  9    17 
  9    18 /* END vrm_index.incl.pl1 */
  9    19 
      562 
      563 
 10     1 /* ak_info -- include file for info structures used by the following vfile_
 10     2*   control orders: "add_key", "delete_key", "get_key", and "reassign_key".
 10     3*   Created by M. Asherman 3/23/76
 10     4*   Modified 5/13/77 to add separate gk_info structure */
 10     5 
 10     6      dcl	   1 ak_info	      based (ak_info_ptr),
 10     7 	     2 header	      like ak_header,
 10     8 	     2 key	      char (ak_key_len refer (ak_info.header.key_len));
 10     9 
 10    10      dcl	   1 ak_header	      based (ak_info_ptr),
 10    11 	     2 flags	      aligned,
 10    12 	       3 input_key	      bit (1) unal,		/* set if key is input arg */
 10    13 	       3 input_desc	      bit (1) unal,		/* set if descriptor is an input arg */
 10    14 	       3 mbz	      bit (34) unal,	/* not used for the present */
 10    15 	     2 descrip	      fixed (35),		/* record designator */
 10    16 	     2 key_len	      fixed;
 10    17 
 10    18      dcl	   ak_info_ptr	      ptr;
 10    19      dcl	   ak_key_len	      fixed;
 10    20 
 10    21 
 10    22      dcl	   1 rk_info	      based (rk_info_ptr),
 10    23 	     2 header	      like rk_header,
 10    24 	     2 key	      char (rk_key_len refer (rk_info.header.key_len));
 10    25 
 10    26      dcl	   1 rk_header	      based (rk_info_ptr),
 10    27 	     2 flags	      aligned,
 10    28 	       3 input_key	      bit (1) unal,		/* same as above */
 10    29 	       3 input_old_desc   bit (1) unal,		/* set if specified entry has initial descrip
 10    30*						   given by old_descrip */
 10    31 	       3 input_new_desc   bit (1) unal,		/* set if new val for descrip is input in this struc */
 10    32 	       3 mbz	      bit (33) unal,
 10    33 	     2 old_descrip	      fixed (35),		/* used if first flag is set */
 10    34 	     2 new_descrip	      fixed (35),		/* used only if second flag is set */
 10    35 	     2 key_len	      fixed;
 10    36 
 10    37      dcl	   rk_info_ptr	      ptr;
 10    38      dcl	   rk_key_len	      fixed;
 10    39 
 10    40 
 10    41      dcl	   1 gk_info	      based (gk_info_ptr),	/* structure for get_key order */
 10    42 	     2 header	      like gk_header,
 10    43 	     2 key	      char (gk_key_len refer (gk_info.header.key_len));
 10    44 						/* may be Input as well as Output */
 10    45 
 10    46      dcl	   1 gk_header	      based (gk_info_ptr),
 10    47 	     2 flags	      aligned,
 10    48 	       3 input_key	      bit (1) unal,		/* if set, use key in this structure */
 10    49 	       3 input_desc	      bit (1) unal,		/* if set, descriptor given in this structure */
 10    50 	       3 desc_code	      fixed (2) unal,	/* 0=any, 1=current -- applies when input_desc="0"b */
 10    51 	       3 position_specification
 10    52 			      unal,
 10    53 	         4 current	      bit (1) unal,		/* otherwise next */
 10    54 	         4 rel_type	      fixed (2) unal,	/* as in seek_head, if input_key = "1"b */
 10    55 	         4 head_size      fixed bin (9) unsigned unaligned,
 10    56 						/* size of head for initial seek */
 10    57 	       3 reset_pos	      bit (1) unal,		/* if set, final position unchanged by this operation */
 10    58 	       3 pad	      bit (8) unal,
 10    59 	       3 version	      fixed (8) unal,
 10    60 	     2 descrip	      fixed (35),		/* Output, except when input_desc="1"b */
 10    61 	     2 key_len	      fixed;		/* Input when input_key="1"b, also Output in all cases */
 10    62 
 10    63      dcl	   gk_info_ptr	      ptr;
 10    64      dcl	   gk_key_len	      fixed;
 10    65 
 10    66      dcl	   gk_info_version_0      internal static fixed options (constant) init (0);
 10    67 
 10    68 /* end ak_info.incl.pl1 */
      564 
      565 
 11     1 /* include file for info structure used with record_status control order
 11     2*   created by M. Asherman 1/6/76 */
 11     3 /* modified 6/15/77 to support stationary type records */
 11     4 
 11     5      dcl	   rs_info_ptr	      ptr;
 11     6      dcl	   1 rs_info	      based (rs_info_ptr) aligned,
 11     7 	     2 version	      fixed,		/* must be set to 1 or 2 (Input) */
 11     8 	     2 flags	      aligned,
 11     9 	       3 lock_sw	      bit (1) unal,		/* Input -- if ="1"b  try to lock record */
 11    10 	       3 unlock_sw	      bit (1) unal,		/* Input -- if ="1"b try to unlock record */
 11    11 	       3 create_sw	      bit (1) unal,		/* Input--if set creat new record */
 11    12 	       3 locate_sw	      bit (1) unal,		/* Input--if set causes current rec to be
 11    13*						   located outside the index by descrip, or created without key */
 11    14 	       3 inc_ref_count    bit (1) unal,		/* Input--bump reference count of record, if stationary */
 11    15 	       3 dec_ref_count    bit (1) unal,		/* Input--decrement ref count if this flag set and record stationary */
 11    16 	       3 locate_pos_sw    bit (1) unal,		/* Input--if set the record_length is taken
 11    17*						   as an input argument specifying the absolute logical record positioni	  to which both the current and next positions will be set */
 11    18 	       3 mbz1	      bit (29) unal,	/* must be set to "0"b, reserved for future use */
 11    19 	     2 record_length      fixed (21),		/* length in bytes, Input if create_sw set */
 11    20 	     2 max_rec_len	      fixed (21),		/* max length of contained record
 11    21*						   Input if create_sw is set--overrides min_block_size in effect */
 11    22 	     2 record_ptr	      ptr,		/* points to first byte of record--will be word aligned */
 11    23 	     2 descriptor	      fixed (35),		/* Input if locate_sw set and create_sw="0"b */
 11    24 	     2 ref_count	      fixed (34),		/* Output--should match number of keys on this record-- = -1 if non-stationary record */
 11    25 	     2 time_last_modified fixed (71),		/* Output */
 11    26 	     2 modifier	      fixed (35),		/* Output--also Input when locking */
 11    27 	     2 block_ptr	      ptr unal,		/* Output */
 11    28 	     2 last_image_modifier
 11    29 			      fixed (35),
 11    30 	     2 mbz2	      fixed;
 11    31 
 11    32      dcl	   1 rs_desc	      based (addr (rs_info.descriptor)),
 11    33 						/* record block descriptor structure */
 11    34 	     2 comp_num	      fixed (17) unal,	/* msf component number */
 11    35 	     2 offset	      bit (18) unal;	/* word offset of record block */
 11    36 
 11    37      dcl	   1 seq_desc	      based (addr (rs_info.descriptor)),
 11    38 						/* for sequential files */
 11    39 	     2 bitno	      bit (6) unal,
 11    40 	     2 comp_num	      fixed (11) unal,	/* msf component number */
 11    41 	     2 wordno	      bit (18) unal;	/* word offset */
 11    42 
 11    43      dcl	   rs_info_version_1      static internal fixed init (1);
 11    44      dcl	   rs_info_version_2      static internal fixed init (2);
 11    45 
      566 
      567 
      568 /* Area */
      569 
      570 	dcl     wa		 area based (vrm_com.work_area_ptr);
      571 
      572 /* Automatic */
      573 
      574 	dcl     attr_no		 fixed bin (17);
      575 	dcl     code		 fixed bin (35);
      576 	dcl     collection_index	 fixed bin;
      577 	dcl     file_id		 bit (7);
      578 	dcl     found		 bit (1) aligned;
      579 	dcl     get_key_info_ptr	 ptr;
      580 	dcl     i			 fixed bin (17);
      581 	dcl     index_iocb_ptr	 ptr;
      582 	dcl     index_head		 char (3);
      583 	dcl     key_found		 char (256) varying;
      584 	dcl     pk_iocb_ptr		 ptr;
      585 	dcl     scan_iocb_ptr	 ptr;
      586 	dcl     tuple_id		 bit (36) aligned;
      587 	dcl     ax		 fixed bin;
      588 	dcl     x			 fixed bin;
      589 
      590 /* Builtin */
      591 
      592 	dcl     (addr,
      593 	        char,
      594 	        currentsize,
      595 	        fixed,
      596 	        ltrim,
      597 	        null,
      598 	        rel,
      599 	        rtrim,
      600 	        string,
      601 	        substr,
      602 	        unspec
      603 	        )			 builtin;
      604 
      605 /* Condition */
      606 
      607 	dcl     cleanup		 condition;
      608 
      609 /* Internal static */
      610 
      611 	dcl     KSQR		 fixed bin (17) int static init (8);
      612 	dcl     KSQU		 fixed bin (17) int static init (10);
      613 
      614 /* External entries */
      615 
      616 	dcl     iox_$attach_name	 entry (char (*), ptr, char (*), ptr, fixed bin (35));
      617 	dcl     iox_$close		 entry (ptr, fixed bin (35));
      618 	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
      619 	dcl     iox_$destroy_iocb	 entry (ptr, fixed bin (35));
      620 	dcl     iox_$detach_iocb	 entry (ptr, fixed bin (35));
      621 	dcl     iox_$open		 entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      622 	dcl     iox_$position	 entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
      623 	dcl     iox_$read_key	 entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
      624 	dcl     iox_$seek_key	 entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
      625 	dcl     iox_$write_record	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
      626 	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
      627 	dcl     vrm_open_man$get_open_info_ptr entry (bit (36) aligned, ptr, fixed bin (35));
      628 	dcl     vrm_open_man$set_open_info_ptr entry (bit (36) aligned, ptr);
      629 	dcl     vrmu_add_indexes	 entry (ptr, ptr, bit (36) aligned, fixed bin (35));
      630 	dcl     vrmu_build_index_list	 entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
      631 	dcl     vrmu_encode_key$compute_alignment_and_length
      632 				 entry (ptr, fixed bin, fixed bin, fixed bin);
      633 
      634 /* External static */
      635 
      636 	dcl     (
      637 	        error_table_$unimplemented_version,
      638 	        error_table_$end_of_info,
      639 	        error_table_$no_record,
      640 	        mdbm_error_$max_indexes,
      641 	        dm_error_$collection_not_in_relation,
      642 	        sys_info$max_seg_size,
      643 	        vrm_data_$max_vfile_wait_time
      644 	        )			 ext static fixed bin (35);
      645 
      646 /* Structure */
      647 
      648 	dcl     1 flags		 aligned,
      649 		2 relation_must_be_empty bit (1) unal,
      650 		2 index_is_clustering bit (1) unal,
      651 		2 index_is_unique	 bit (1) unal,
      652 		2 pad		 bit (33) unal;
      653 
      654 	dcl     1 seek_head_info,
      655 		2 relation_type	 fixed bin,
      656 		2 n		 fixed bin,
      657 		2 search_key	 char (3);
      658 
      659 
      660 	dcl     desc_ptr		 ptr;
      661 
      662 	dcl     1 descriptor	 based (desc_ptr),
      663 		2 version		 bit (1) unal,
      664 		2 type		 fixed bin (6) unsigned unal,
      665 		2 packed		 bit (1) unal,
      666 		2 number_dims	 bit (4) unal,
      667 		2 size		 fixed bin (24) unsigned unal;
      668 
      669      end create_index;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/21/84  0920.2  vrm_index.pl1                     >special_ldd>online>mrds_install>vrm_index.pl1
546          1    10/14/83  1609.1  vrm_open_info.incl.pl1            >ldd>include>vrm_open_info.incl.pl1
548          2    10/14/83  1609.1  vrm_rel_desc.incl.pl1             >ldd>include>vrm_rel_desc.incl.pl1
550          3    10/14/83  1609.1  vrm_collection_info.incl.pl1      >ldd>include>vrm_collection_info.incl.pl1
552          4    10/14/83  1609.1  vrm_com.incl.pl1                  >ldd>include>vrm_com.incl.pl1
554          5    10/14/83  1609.1  dm_id_list.incl.pl1               >ldd>include>dm_id_list.incl.pl1
556          6    10/14/83  1609.1  vrm_tuple.incl.pl1                >ldd>include>vrm_tuple.incl.pl1
558          7    10/14/83  1609.1  vrm_change_bits.incl.pl1          >ldd>include>vrm_change_bits.incl.pl1
560          8    10/14/83  1609.1  vrm_key_list.incl.pl1             >ldd>include>vrm_key_list.incl.pl1
562          9    10/14/83  1609.1  vrm_index.incl.pl1                >ldd>include>vrm_index.incl.pl1
564         10    07/19/79  1547.0  ak_info.incl.pl1                  >ldd>include>ak_info.incl.pl1
566         11    07/19/79  1547.0  rs_info.incl.pl1                  >ldd>include>rs_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 5-23 ref 65
I_flags                                parameter       bit(36)                  dcl 54 ref 7 67
I_id_list_ptr                          parameter       pointer                  dcl 53 ref 7 64
I_index_collection_id                  parameter       bit(36)                  dcl 161 ref 155 175
I_rel_opening_id                       parameter       bit(36)                  dcl 52 set ref 7 72* 155 168*
I_style                                parameter       fixed bin(17,0)          dcl 55 ref 7
KSQR                            000010 internal static fixed bin(17,0)          initial dcl 611 set ref 225* 249*
KSQU                            000011 internal static fixed bin(17,0)          initial dcl 612 set ref 137* 224* 248*
MRDS_compatible           3(01)        based           bit(1)                   level 3 packed unaligned dcl 2-5 ref 136 216
O_code                                 parameter       fixed bin(35,0)          dcl 57 set ref 7 62* 155 166* 219* 541*
O_id                                   parameter       bit(36)                  dcl 451 set ref 446 468*
O_index_collection_id                  parameter       bit(36)                  dcl 56 set ref 7 61* 87* 88 114* 140 489
VRM_COLLECTION_KEY_HEAD         000000 constant        char(16)                 initial unaligned dcl 3-26 ref 140
addr                                                   builtin function         dcl 592 ref 102 196 196 324 325 326 327 327 395 395
                                                                                  401 402 424 464 468
ak_header                              based           structure                level 1 unaligned dcl 10-10
atd                             000334 automatic       varying char(344)        dcl 280 set ref 285* 286* 286 287* 287 288* 288 289*
                                                                                  289 290* 290 293
attach_desc                     000463 automatic       char(344)                unaligned dcl 281 set ref 293* 294 294
attr                     14            based           structure                array level 2 dcl 2-5
attr_index                3            based           fixed bin(17,0)          array level 3 dcl 3-6 set ref 96 128 258 430* 499
attr_no                                parameter       fixed bin(17,0)          dcl 450 in procedure "calculate_collection_id" ref
                                                                                  446
attr_no                         000136 automatic       fixed bin(17,0)          dcl 574 in procedure "create_index" set ref 78* 87*
                                                                                  233 499*
attr_no                         000644 automatic       fixed bin(17,0)          dcl 438 in procedure "fill_attribute_info" set ref
                                                                                  422* 424 430
attr_no                         000323 automatic       fixed bin(17,0)          dcl 270 in procedure "init_destroy" set ref 258* 259
attribute                 3            based           structure                array level 2 dcl 3-6
available                       000661 automatic       bit(1)                   initial unaligned dcl 454 set ref 454* 461 469* 473
ax                              000261 automatic       fixed bin(17,0)          dcl 587 set ref 96* 97 98 128* 129 130
candidate_id                           based           bit(36)                  dcl 456 ref 464 468
cb_number_of_change_bits        000122 automatic       fixed bin(17,0)          dcl 7-7 set ref 229* 230 230 253* 254 254
change_bits                            based           structure                level 1 unaligned dcl 7-3 set ref 230 254 510
change_bits_ptr                 000124 automatic       pointer                  dcl 7-8 set ref 69* 106* 185* 230* 232 233 254* 256
                                                                                  259 510 510
char                                                   builtin function         dcl 592 ref 140 289
cleanup                         000264 stack reference condition                dcl 607 ref 70 186
code                            000611 automatic       fixed bin(35,0)          dcl 282 in procedure "open_iocb" set ref 294* 297
                                                                                  297* 298* 299 299*
code                            000106 automatic       fixed bin(35,0)          dcl 523 in procedure "close_iocb" set ref 525* 526*
                                                                                  527*
code                            000137 automatic       fixed bin(35,0)          dcl 575 in procedure "create_index" set ref 72* 73
                                                                                  73* 106* 107 107* 108 108* 138 138* 140* 142 142
                                                                                  142* 144* 145 145* 168* 169 169* 190* 191 191*
                                                                                  196* 197 198 198* 205 206* 207 207* 209* 210 210
                                                                                  210*
collection_index                000140 automatic       fixed bin(17,0)          dcl 576 set ref 178* 498 500 501
com_ptr                  74            based           pointer                  level 2 dcl 1-6 set ref 75 171
comp_num                  0(09)        based           bit(10)                  level 2 packed unaligned dcl 372 set ref 406*
comp_number               0(08)        based           bit(10)                  level 2 packed unaligned dcl 380 ref 406
comp_offset               0(18)        based           bit(17)                  level 2 packed unaligned dcl 380 ref 407
current                   0(05)        based           bit(1)                   level 5 packed unaligned dcl 10-41 set ref 335*
currentsize                                            builtin function         dcl 592 ref 144 144
database_dir_path         6            based           varying char(168)        level 2 dcl 1-6 set ref 285
desc_ptr                        000276 automatic       pointer                  dcl 660 set ref 424* 426*
descriptor               24            based           bit(36)                  array level 3 in structure "vrm_rel_desc" dcl 2-5
                                                                                  in procedure "create_index" set ref 424
descriptor                6            based           fixed bin(35,0)          level 2 in structure "rs_info" dcl 11-6 in procedure
                                                                                  "create_index" set ref 401
dm_error_$collection_not_in_relation
                                000062 external static fixed bin(35,0)          dcl 636 set ref 183*
ecode                                  parameter       fixed bin(35,0)          dcl 538 ref 536 541
error_table_$end_of_info        000054 external static fixed bin(35,0)          dcl 636 ref 210 390
error_table_$no_record          000056 external static fixed bin(35,0)          dcl 636 ref 142 198 329 390
error_table_$unimplemented_version
                                000052 external static fixed bin(35,0)          dcl 636 set ref 65*
file_id                         000141 automatic       bit(7)                   unaligned dcl 577 in procedure "create_index" set
                                                                                  ref 104* 238* 265*
file_id                   2(18)        based           bit(7)                   level 2 in structure "vrm_rel_desc" packed unaligned
                                                                                  dcl 2-5 in procedure "create_index" ref 238 265
file_id                   0(02)        based           bit(7)                   level 2 in structure "tid" packed unaligned dcl 372
                                                                                  in procedure "get_a_tuple" set ref 405*
flags                           000272 automatic       structure                level 1 dcl 648 in procedure "create_index" set ref
                                                                                  67*
flags                                  based           structure                level 3 in structure "gk_info" dcl 10-41
                                                                                  in procedure "create_index" set ref 334*
flags                     1            based           structure                level 2 in structure "rs_info" dcl 11-6 in procedure
                                                                                  "create_index" set ref 340*
found                           000662 automatic       bit(1)                   unaligned dcl 455 in procedure
                                                                                  "calculate_collection_id" set ref 462* 464* 467
found                           000142 automatic       bit(1)                   dcl 578 in procedure "create_index" set ref 173* 174
                                                                                  177* 183
gat_code                        000630 automatic       fixed bin(35,0)          dcl 365 set ref 387* 388 390 390 392* 395* 396 396*
                                                                                  410*
gat_file_id                            parameter       bit(7)                   unaligned dcl 359 ref 346 405
gat_rel_scan_iocb_ptr                  parameter       pointer                  dcl 357 set ref 346 387* 395* 410*
gat_tid                                parameter       bit(36)                  dcl 360 set ref 346 402
gat_tuple_ptr                          parameter       pointer                  dcl 361 set ref 346 390* 409*
get_key_info_ptr                000144 automatic       pointer                  dcl 579 set ref 69* 185* 333* 334 335 336 387* 512
                                                                                  512
gk_header                              based           structure                level 1 unaligned dcl 10-46
gk_info                                based           structure                level 1 unaligned dcl 10-41 set ref 333 512
gk_key_len                      000132 automatic       fixed bin(17,0)          dcl 10-64 set ref 332* 333 333
header                                 based           structure                level 2 unaligned dcl 10-41
i                               000146 automatic       fixed bin(17,0)          dcl 580 in procedure "create_index" set ref 174* 175
                                                                                  178 179*
i                               000645 automatic       fixed bin(17,0)          dcl 439 in procedure "fill_attribute_info" set ref
                                                                                  421* 422 430 431 432*
i                               000322 automatic       fixed bin(17,0)          dcl 270 in procedure "init_destroy" set ref 257*
                                                                                  258*
id                        2            based           fixed bin(17,0)          array level 2 in structure "id_list" dcl 5-16
                                                                                  in procedure "create_index" ref 78 422
id                      103            based           bit(36)                  array level 3 in structure "vrm_open_info" dcl 1-6
                                                                                  in procedure "create_index" set ref 175 464 489*
                                                                                  500*
id                        0(04)        based           bit(8)                   level 3 in structure "vrm_collection_info" packed
                                                                                  unaligned dcl 3-6 in procedure "create_index" set
                                                                                  ref 88* 117* 194
id_list                                based           structure                level 1 dcl 5-16
id_list_ptr                     000114 automatic       pointer                  initial dcl 5-21 set ref 64* 65 78 115 125 5-21* 421
                                                                                  422
id_structure                    000663 automatic       structure                level 1 dcl 457 set ref 464 468
il_number_of_ids                000116 automatic       fixed bin(17,0)          initial dcl 5-22 set ref 5-22*
index                                  based           structure                level 1 dcl 9-9
index_collection        103            based           structure                array level 2 dcl 1-6
index_head                      000152 automatic       char(3)                  unaligned dcl 582 set ref 193* 194* 195 204 205
index_id                  0(12)        based           bit(8)                   level 2 packed unaligned dcl 9-9 set ref 325*
index_iocb_ptr                  000150 automatic       pointer                  dcl 581 set ref 69* 107* 185* 190* 196* 206* 209*
                                                                                  224* 248* 507 507*
index_is_unique           0(02) 000272 automatic       bit(1)                   level 2 packed unaligned dcl 648 set ref 77
index_no                        000663 automatic       fixed bin(8,0)           level 2 packed unsigned unaligned dcl 457 set ref
                                                                                  461*
index_value_length              000131 automatic       fixed bin(35,0)          dcl 9-16 set ref 267*
info_ptr                104            based           pointer                  array level 3 packed unaligned dcl 1-6 set ref 179
                                                                                  490* 498 501*
iocb_ptr                               parameter       pointer                  dcl 521 in procedure "close_iocb" set ref 519 525*
                                                                                  526* 527*
iocb_ptr                               parameter       pointer                  dcl 278 in procedure "open_iocb" set ref 274 294*
                                                                                  298*
iox_$attach_name                000012 constant        entry                    external dcl 616 ref 294
iox_$close                      000014 constant        entry                    external dcl 617 ref 525
iox_$control                    000016 constant        entry                    external dcl 618 ref 196 206 327 387 395
iox_$destroy_iocb               000020 constant        entry                    external dcl 619 ref 527
iox_$detach_iocb                000022 constant        entry                    external dcl 620 ref 526
iox_$open                       000024 constant        entry                    external dcl 621 ref 298
iox_$position                   000026 constant        entry                    external dcl 622 ref 190 319 410
iox_$read_key                   000030 constant        entry                    external dcl 623 ref 209
iox_$seek_key                   000032 constant        entry                    external dcl 624 ref 140
iox_$write_record               000034 constant        entry                    external dcl 625 ref 144
j                               000660 automatic       fixed bin(17,0)          dcl 453 set ref 463* 464*
key_alignment                   000646 automatic       fixed bin(17,0)          dcl 440 set ref 426* 429
key_bit_len               5            based           fixed bin(17,0)          array level 3 in structure "vrm_collection_info"
                                                                                  dcl 3-6 in procedure "create_index" set ref 432*
key_bit_len                     000647 automatic       fixed bin(17,0)          dcl 441 in procedure "fill_attribute_info" set ref
                                                                                  426* 432 433
key_found                       000153 automatic       varying char(256)        dcl 583 set ref 204* 205 209*
key_head                 25(01)        based           bit(1)                   array level 3 packed unaligned dcl 2-5 set ref 98*
                                                                                  130*
key_len                   2            based           fixed bin(17,0)          level 3 dcl 10-41 set ref 333* 512
key_list                               based           structure                level 1 dcl 8-3 set ref 236 263 511
key_list_ptr                    000126 automatic       pointer                  dcl 8-19 set ref 69* 106* 107* 185* 236* 263* 511
                                                                                  511
key_offset                4            based           fixed bin(17,0)          array level 3 in structure "vrm_collection_info"
                                                                                  dcl 3-6 in procedure "create_index" set ref 98 130
                                                                                  431*
key_offset                      000650 automatic       fixed bin(17,0)          dcl 442 in procedure "fill_attribute_info" set ref
                                                                                  420* 426* 429* 429 431 433* 433
kl_number_of_keys               000130 automatic       fixed bin(17,0)          dcl 8-20 set ref 235* 236 236 262* 263 263
ltrim                                                  builtin function         dcl 592 ref 289
mbz                       0(20)        based           bit(7)                   level 2 packed unaligned dcl 9-9 set ref 326*
mdbm_error_$max_indexes         000060 external static fixed bin(35,0)          dcl 636 set ref 473*
n                         1     000273 automatic       fixed bin(17,0)          level 2 dcl 654 set ref 323*
non_std_desc                           based           bit(1)                   level 2 packed unaligned dcl 372 set ref 403*
null                                                   builtin function         dcl 592 ref 69 103 105 185 206 206 5-21 294 294 390
                                                                                  501 507 508 509 510 511 512 513
number_attrs             13            based           fixed bin(17,0)          level 2 dcl 2-5 ref 229 253
number_of_attributes      2            based           fixed bin(17,0)          level 2 dcl 3-6 set ref 85* 95 116* 127 144 144 257
number_of_change_bits                  based           fixed bin(17,0)          level 2 dcl 7-3 set ref 230* 232 254* 256 510
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 5-16 ref 115 125 421
number_of_index_collections
                        102            based           fixed bin(17,0)          level 2 dcl 1-6 set ref 174 463 483 485* 486* 486
                                                                                  487 488* 488 492
number_of_keys                         based           fixed bin(17,0)          level 2 dcl 8-3 set ref 236* 263* 511
number_primary_key_attrs
                          7            based           fixed bin(17,0)          level 2 dcl 2-5 set ref 125*
number_sec_indexes       10            based           fixed bin(17,0)          level 2 dcl 2-5 set ref 82* 82 215* 215
offset                    0(19)        based           bit(17)                  level 2 packed unaligned dcl 372 set ref 407*
old_vrm_open_info_ptr           000674 automatic       pointer                  dcl 480 set ref 484* 487 492
open_mode                              parameter       fixed bin(17,0)          dcl 276 set ref 274 298*
open_name                              parameter       varying char(24)         dcl 277 ref 274 294
opening_id                2            based           bit(36)                  level 2 dcl 1-6 set ref 491*
pad                       0(14)        based           bit(26)                  level 2 in structure "vrm_collection_info" packed
                                                                                  unaligned dcl 3-6 in procedure "create_index" set
                                                                                  ref 91* 120*
pad                       5(01)        based           bit(35)                  initial level 3 in structure "vrm_open_info" packed
                                                                                  unaligned dcl 1-6 in procedure "create_index" set
                                                                                  ref 485*
pad                       0(08) 000663 automatic       bit(28)                  initial level 2 in structure "id_structure" packed
                                                                                  unaligned dcl 457 in procedure
                                                                                  "calculate_collection_id" set ref 457*
pk_iocb_ptr                     000254 automatic       pointer                  dcl 584 set ref 69* 137* 140* 144* 185* 509 509*
position                  1            based           bit(1)                   array level 2 packed unaligned dcl 7-3 set ref 232*
                                                                                  233* 256* 259*
position_specification
                          0(05)        based           structure                level 4 packed unaligned dcl 10-41
primary_key               0(13)        based           bit(1)                   level 2 packed unaligned dcl 3-6 set ref 90* 119*
primary_key_attr         25(02)        based           bit(1)                   array level 3 packed unaligned dcl 2-5 set ref 97*
                                                                                  129*
primary_key_info_ptr    100            based           pointer                  level 2 dcl 1-6 set ref 126*
record_id                              based           structure                level 2 packed unaligned dcl 3-6
record_ptr                4            based           pointer                  level 2 dcl 11-6 set ref 409
rel_id                    2(25)        based           bit(12)                  level 2 in structure "vrm_rel_desc" packed unaligned
                                                                                  dcl 2-5 in procedure "create_index" ref 194 324
rel_id                                 based           bit(12)                  level 2 in structure "index" packed unaligned
                                                                                  dcl 9-9 in procedure "create_index" set ref 324*
relation_model_ptr       72            based           pointer                  level 2 dcl 1-6 set ref 74 170
relation_name            61            based           varying char(30)         level 2 dcl 1-6 set ref 287
relation_type                   000273 automatic       fixed bin(17,0)          level 2 dcl 654 set ref 322*
reset_pos                 0(18)        based           bit(1)                   level 4 packed unaligned dcl 10-41 set ref 336*
rk_header                              based           structure                level 1 unaligned dcl 10-26
rs_info                                based           structure                level 1 dcl 11-6 set ref 338 395 395 513
rs_info_ptr                     000134 automatic       pointer                  dcl 11-5 set ref 69* 338* 339 340 395 395 401 409
                                                                                  513 513
rs_info_version_2                      constant        fixed bin(17,0)          initial dcl 11-44 ref 339
rtrim                                                  builtin function         dcl 592 ref 285 287 294 294
scan_iocb_ptr                   000256 automatic       pointer                  dcl 585 set ref 69* 104* 185* 225* 227* 249* 251*
                                                                                  508 508*
search_key                2     000273 automatic       char(3)                  level 2 packed unaligned dcl 654 set ref 195* 324
                                                                                  325 326
seek_head_info                  000273 automatic       structure                level 1 unaligned dcl 654 set ref 196 196 327 327
sfrs_code                       000620 automatic       fixed bin(35,0)          dcl 316 set ref 319* 320 327* 329 329 329*
sfrs_rel_scan_iocb_ptr                 parameter       pointer                  dcl 311 set ref 303 319* 327*
stationary_records        3(02)        based           bit(1)                   level 3 packed unaligned dcl 2-5 ref 290
string                                                 builtin function         dcl 592 set ref 67* 232* 256* 340*
substr                                                 builtin function         dcl 592 ref 88 205
switches                  3(01)        based           structure                level 2 in structure "vrm_rel_desc" packed unaligned
                                                                                  dcl 2-5 in procedure "create_index"
switches                  5            based           structure                level 2 in structure "vrm_open_info" dcl 1-6
                                                                                  in procedure "create_index"
temp                      0(01)        based           bit(1)                   level 2 packed unaligned dcl 372 set ref 404*
tid                                    based           structure                level 1 dcl 372
tid_ptr                         000632 automatic       pointer                  dcl 366 set ref 402* 403 404 405 406 407
tuple_id                        000260 automatic       bit(36)                  dcl 586 set ref 104* 107*
tuple_ptr                       000120 automatic       pointer                  dcl 6-15 set ref 102* 102 103 104* 105 106*
unique                    0(12)        based           bit(1)                   level 2 packed unaligned dcl 3-6 set ref 89* 118*
unique_chars_                   000036 constant        entry                    external dcl 626 ref 294
unspec                                                 builtin function         dcl 592 set ref 194* 334*
vci_no_of_attributes            000110 automatic       fixed bin(17,0)          dcl 3-23 set ref 84* 85 85 115* 116 116
version                                based           fixed bin(17,0)          level 2 in structure "rs_info" dcl 11-6 in procedure
                                                                                  "create_index" set ref 339*
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 5-16 in procedure
                                                                                  "create_index" ref 65
vfd                                    based           structure                level 1 dcl 380
vfd_ptr                         000634 automatic       pointer                  dcl 367 set ref 401* 406 407
voi_no_of_index_collections     000102 automatic       fixed bin(17,0)          dcl 1-29 set ref 483* 485 485 489 490
vrm_attr_info                          based           structure                level 1 unaligned dcl 2-28
vrm_collection_info                    based           structure                level 1 dcl 3-6 set ref 85 116 144 144
vrm_collection_info_ptr         000106 automatic       pointer                  dcl 3-21 set ref 85* 88 89 90 91 95 96 98 116* 117
                                                                                  118 119 120 126 127 128 130 144* 144 144 179* 194
                                                                                  257 258 430 431 432 490 498* 499
vrm_com                                based           structure                level 1 dcl 4-6
vrm_com_ptr                     000112 automatic       pointer                  dcl 4-5 set ref 75* 85 116 171* 485 492
vrm_data_$max_vfile_wait_time   000064 external static fixed bin(35,0)          dcl 636 ref 289
vrm_open_info                          based           structure                level 1 dcl 1-6 set ref 485 487* 487 492
vrm_open_info_ptr               000100 automatic       pointer                  dcl 1-28 set ref 72* 74 75 106* 126 168* 170 171 174
                                                                                  175 179 285 287 463 464 483 484 485* 486 486 487
                                                                                  488 488 489 490 491 491* 498 500 501
vrm_open_man$get_open_info_ptr  000040 constant        entry                    external dcl 627 ref 72 168
vrm_open_man$set_open_info_ptr  000042 constant        entry                    external dcl 628 ref 491
vrm_rel_desc                           based           structure                level 1 unaligned dcl 2-5
vrm_rel_desc_ptr                000104 automatic       pointer                  dcl 2-41 set ref 74* 82 82 97 98 106* 125 129 130
                                                                                  136 170* 194 215 215 216 229 238 253 265 290 324
                                                                                  424
vrmu_add_indexes                000044 constant        entry                    external dcl 629 ref 107
vrmu_build_index_list           000046 constant        entry                    external dcl 630 ref 106
vrmu_encode_key$compute_alignment_and_length
                                000050 constant        entry                    external dcl 631 ref 426
wa                                     based           area(1024)               dcl 570 ref 85 116 485 492
work_area_ptr             6            based           pointer                  level 2 dcl 4-6 ref 85 116 485 492
x                               000262 automatic       fixed bin(17,0)          dcl 588 set ref 95* 96 98* 127* 128 130*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
VRM_OPEN_INFO_VERSION_1                internal static char(8)                  initial unaligned dcl 1-27
VRM_REL_DESC_KEY                       internal static varying char(256)        initial dcl 2-46
VRM_REL_DESC_RECORD_ID                 internal static bit(12)                  initial unaligned dcl 2-43
VRM_REL_DESC_VERSION_1                 internal static char(8)                  initial unaligned dcl 2-44
ak_info                                based           structure                level 1 unaligned dcl 10-6
ak_info_ptr                            automatic       pointer                  dcl 10-18
ak_key_len                             automatic       fixed bin(17,0)          dcl 10-19
descriptor                             based           structure                level 1 packed unaligned dcl 662
fixed                                                  builtin function         dcl 592
gk_info_ptr                            automatic       pointer                  dcl 10-63
gk_info_version_0                      internal static fixed bin(17,0)          initial dcl 10-66
index_ptr                              automatic       pointer                  dcl 9-15
rel                                                    builtin function         dcl 592
rk_info                                based           structure                level 1 unaligned dcl 10-22
rk_info_ptr                            automatic       pointer                  dcl 10-37
rk_key_len                             automatic       fixed bin(17,0)          dcl 10-38
rs_desc                                based           structure                level 1 packed unaligned dcl 11-32
rs_info_version_1                      internal static fixed bin(17,0)          initial dcl 11-43
seq_desc                               based           structure                level 1 packed unaligned dcl 11-37
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 636
tuple                                  based           structure                level 1 dcl 6-7
tuple_length                           automatic       fixed bin(21,0)          dcl 6-16
tuple_pad_length                       internal static fixed bin(17,0)          initial dcl 6-18
vrd_no_of_attrs                        automatic       fixed bin(17,0)          dcl 2-42
vrm_attr_info_ptr                      automatic       pointer                  dcl 2-45
vrm_collection_header_type             internal static bit(4)                   initial unaligned dcl 3-24

NAMES DECLARED BY EXPLICIT CONTEXT.
Exit                            000644 constant        label                    dcl 153 ref 201 542
add_collection_info             002521 constant        entry                    internal dcl 478 ref 93 123
calculate_collection_id         002427 constant        entry                    internal dcl 446 ref 87
close_iocb                      002744 constant        entry                    internal dcl 519 ref 507 508 509
create_index                    000107 constant        entry                    external dcl 7
destroy_index                   000651 constant        entry                    external dcl 155
error                           003004 constant        entry                    internal dcl 536 ref 65 73 108 138 142 145 169 183
                                                                                  191 198 207 210 297 299 329 392 396 473
fill_attribute_info             002350 constant        entry                    internal dcl 418 ref 92 122
get_a_tuple                     002166 constant        entry                    internal dcl 346 ref 104
init_create                     001247 constant        entry                    internal dcl 222 ref 80
init_destroy                    001356 constant        entry                    internal dcl 246 ref 187
open_iocb                       001504 constant        entry                    internal dcl 274 ref 137 224 225 248 249
remove_collection_info          002606 constant        entry                    internal dcl 496 ref 214
setup_for_relation_scan         002034 constant        entry                    internal dcl 303 ref 227 251
tidy_up                         002625 constant        entry                    internal dcl 505 ref 70 151 186 200 220

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3434        3522    3071        3444
Length      4162    3071        66         424     342           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
create_index                        899 external procedure  is an external procedure.  
on unit on line 70                   64 on unit               
on unit on line 186                  64 on unit               
init_create                             internal procedure  shares stack frame of external procedure create_index.  
init_destroy                            internal procedure  shares stack frame of external procedure create_index.  
open_iocb                               internal procedure  shares stack frame of external procedure create_index.  
setup_for_relation_scan                 internal procedure  shares stack frame of external procedure create_index.  
get_a_tuple                             internal procedure  shares stack frame of external procedure create_index.  
fill_attribute_info                     internal procedure  shares stack frame of external procedure create_index.  
calculate_collection_id                 internal procedure  shares stack frame of external procedure create_index.  
add_collection_info                     internal procedure  shares stack frame of external procedure create_index.  
remove_collection_info                  internal procedure  shares stack frame of external procedure create_index.  
tidy_up                              84 internal procedure  is called by several nonquick procedures.  
close_iocb                              internal procedure  shares stack frame of internal procedure tidy_up.  
error                                   internal procedure  shares stack frame of external procedure create_index.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 KSQR                        create_index
000011 KSQU                        create_index

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
create_index             000100 vrm_open_info_ptr           create_index
                         000102 voi_no_of_index_collections create_index
                         000104 vrm_rel_desc_ptr            create_index
                         000106 vrm_collection_info_ptr     create_index
                         000110 vci_no_of_attributes        create_index
                         000112 vrm_com_ptr                 create_index
                         000114 id_list_ptr                 create_index
                         000116 il_number_of_ids            create_index
                         000120 tuple_ptr                   create_index
                         000122 cb_number_of_change_bits    create_index
                         000124 change_bits_ptr             create_index
                         000126 key_list_ptr                create_index
                         000130 kl_number_of_keys           create_index
                         000131 index_value_length          create_index
                         000132 gk_key_len                  create_index
                         000134 rs_info_ptr                 create_index
                         000136 attr_no                     create_index
                         000137 code                        create_index
                         000140 collection_index            create_index
                         000141 file_id                     create_index
                         000142 found                       create_index
                         000144 get_key_info_ptr            create_index
                         000146 i                           create_index
                         000150 index_iocb_ptr              create_index
                         000152 index_head                  create_index
                         000153 key_found                   create_index
                         000254 pk_iocb_ptr                 create_index
                         000256 scan_iocb_ptr               create_index
                         000260 tuple_id                    create_index
                         000261 ax                          create_index
                         000262 x                           create_index
                         000272 flags                       create_index
                         000273 seek_head_info              create_index
                         000276 desc_ptr                    create_index
                         000322 i                           init_destroy
                         000323 attr_no                     init_destroy
                         000334 atd                         open_iocb
                         000463 attach_desc                 open_iocb
                         000611 code                        open_iocb
                         000620 sfrs_code                   setup_for_relation_scan
                         000630 gat_code                    get_a_tuple
                         000632 tid_ptr                     get_a_tuple
                         000634 vfd_ptr                     get_a_tuple
                         000644 attr_no                     fill_attribute_info
                         000645 i                           fill_attribute_info
                         000646 key_alignment               fill_attribute_info
                         000647 key_bit_len                 fill_attribute_info
                         000650 key_offset                  fill_attribute_info
                         000660 j                           calculate_collection_id
                         000661 available                   calculate_collection_id
                         000662 found                       calculate_collection_id
                         000663 id_structure                calculate_collection_id
                         000674 old_vrm_open_info_ptr       add_collection_info
tidy_up                  000106 code                        close_iocb

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
enable              shorten_stack       ext_entry           int_entry           any_to_any_tr       alloc_based
alloc_based_storage free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
iox_$attach_name              iox_$close                    iox_$control                  iox_$destroy_iocb
iox_$detach_iocb              iox_$open                     iox_$position                 iox_$read_key
iox_$seek_key                 iox_$write_record             unique_chars_
vrm_open_man$get_open_info_ptr                              vrm_open_man$set_open_info_ptr
vrmu_add_indexes              vrmu_build_index_list         vrmu_encode_key$compute_alignment_and_length

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$collection_not_in_relation                        error_table_$end_of_info      error_table_$no_record
error_table_$unimplemented_version                          mdbm_error_$max_indexes       vrm_data_$max_vfile_wait_time




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 5   21 000073    5   22 000075         7 000101        61 000120        62 000122        64 000123        65 000126
     67 000140        69 000143        70 000153        72 000175        73 000211        74 000215        75 000220
     77 000223        78 000226        80 000231        82 000232        84 000234        85 000236        87 000250
     88 000261        89 000267        90 000271        91 000273        92 000277        93 000300        95 000301
     96 000311        97 000315        98 000321       100 000330       102 000332       103 000334       104 000340
    105 000342       106 000346       107 000367       108 000406       110 000412       112 000413       114 000414
    115 000416       116 000421       117 000433       118 000435       119 000437       120 000441       122 000444
    123 000445       125 000446       126 000452       127 000455       128 000465       129 000471       130 000475
    132 000504       136 000506       137 000512       138 000532       140 000536       142 000601       144 000612
    145 000634       151 000640       153 000644       155 000645       166 000662       168 000663       169 000677
    170 000703       171 000706       173 000711       174 000712       175 000725       177 000734       178 000736
    179 000740       181 000743       183 000745       185 000756       186 000765       187 001007       190 001010
    191 001030       193 001034       194 001036       195 001055       196 001060       197 001112       198 001114
    200 001121       201 001125       204 001126       205 001133       206 001145       207 001200       209 001204
    210 001222       212 001231       214 001232       215 001233       216 001236       219 001241       220 001242
    669 001246       222 001247       224 001250       225 001270       227 001310       229 001312       230 001315
    232 001326       233 001331       235 001335       236 001337       238 001347       240 001355       246 001356
    248 001357       249 001377       251 001417       253 001421       254 001424       256 001435       257 001440
    258 001451       259 001454       260 001460       262 001462       263 001464       265 001474       267 001502
    272 001503       274 001504       285 001506       286 001542       287 001552       288 001577       289 001611
    290 001647       293 001665       294 001671       297 002002       298 002007       299 002027       301 002033
    303 002034       319 002036       320 002056       322 002060       323 002061       324 002063       325 002070
    326 002072       327 002074       329 002127       332 002136       333 002140       334 002151       335 002152
    336 002154       338 002156       339 002162       340 002164       342 002165       346 002166       387 002170
    388 002216       390 002220       392 002231       393 002233       395 002234       396 002267       401 002274
    402 002277       403 002302       404 002304       405 002306       406 002312       407 002317       409 002324
    410 002327       414 002347       418 002350       420 002351       421 002352       422 002363       424 002366
    426 002372       429 002407       430 002411       431 002416       432 002421       433 002423       435 002424
    444 002426       446 002427       454 002431       457 002432       461 002434       462 002446       463 002447
    464 002457       465 002466       467 002470       468 002472       469 002475       471 002477       473 002507
    476 002520       478 002521       483 002522       484 002526       485 002527       486 002543       487 002545
    488 002555       489 002557       490 002564       491 002566       492 002577       494 002605       496 002606
    498 002607       499 002614       500 002617       501 002621       503 002623       505 002624       507 002632
    508 002645       509 002660       510 002673       511 002706       512 002720       513 002734       516 002743
    519 002744       525 002746       526 002757       527 002771       530 003003       536 003004       541 003006
    542 003010


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
