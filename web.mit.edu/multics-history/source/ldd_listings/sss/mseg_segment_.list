	COMPILATION LISTING OF SEGMENT mseg_segment_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1151.70_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1992   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(92-09-03,WAAnderson), approve(92-09-03,MECR0016),
       12*     audit(92-09-17,Vu), install(92-09-24,MR12.5-1017):
       13*     During message segment compaction the message segment gets truncated to a
       14*     length of 0. This action overwrites the lockword held by the calling
       15*     process.  The fix ensures the lockword (which is the first word in the
       16*     segment) does not get set to 0.
       17*  2) change(92-10-02,WAAnderson), approve(92-10-02,MCR8271),
       18*     audit(92-10-13,Vu), install(92-10-21,MR12.5-1032):
       19*     This MCR closes MECR0016.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 /* Message segment primitive operations (mseg_) which manipulate the entire message segment as a whole */
       23 
       24 /* Created:  April 1985 by G. Palter based upon mseg_ and mseg_compact_ */
       25 
       26 /* format: style3,linecom */
       27 
       28 mseg_segment_:
       29      procedure ();
       30 
       31 	return;					/* not an entrypoint */
       32 
       33 
       34 /* Parameters */
       35 
       36 dcl	P_mseg_operation_ptr
       37 			pointer parameter;
       38 dcl	P_code		fixed binary (35) parameter;
       39 
       40 dcl	P_compaction_ratio	float binary parameter;	/* compact_seg: %'age of waste to cause compaction (I) */
       41 
       42 dcl	P_source_mseg_operation_ptr			/* copy_seg: -> description of segment to copy (I) */
       43 			pointer parameter;
       44 dcl	P_target_mseg_operation_ptr			/* copy_seg: -> description of target segment (I) */
       45 			pointer parameter;
       46 dcl	P_error_on_target	bit (1) aligned parameter;	/* copy_seg: set ON => target in error (O) */
       47 
       48 dcl	P_salvaged_flag	bit (1) aligned parameter;	/* get_salvage_flag_seg: set ON => segment was salvaged (O) */
       49 
       50 dcl	P_max_length	fixed binary (19) parameter;	/* set_max_length_seg: the segment's new max length (I) */
       51 
       52 
       53 /* Local copies of parameters */
       54 
       55 dcl	1 source_mseg_operation
       56 			aligned based (source_mseg_operation_ptr) like mseg_operation;
       57 dcl	source_mseg_operation_ptr
       58 			pointer;
       59 
       60 dcl	1 target_mseg_operation
       61 			aligned based (target_mseg_operation_ptr) like mseg_operation;
       62 dcl	target_mseg_operation_ptr
       63 			pointer;
       64 
       65 dcl	segment_in_error	fixed binary;
       66 dcl	(
       67 	SOURCE		initial (1),
       68 	TARGET		initial (2)
       69 	)		fixed binary static options (constant);
       70 
       71 dcl	code		fixed binary (35);
       72 
       73 
       74 /* Remaining declartions */
       75 
       76 dcl	system_area	area based (system_area_ptr);
       77 dcl	system_area_ptr	pointer;
       78 
       79 dcl	1 target_mseg_segment_header
       80 			aligned based (target_mseg_ptr) like mseg_segment.header;
       81 dcl	target_mseg_ptr	pointer;
       82 dcl	target_mseg_dir_name
       83 			character (168);
       84 dcl	target_mseg_entryname
       85 			character (32);
       86 
       87 dcl	source_mseg_ptr	pointer;
       88 dcl	source_mseg_dir_name
       89 			character (168);
       90 dcl	source_mseg_entryname
       91 			character (32);
       92 
       93 dcl	source_mseg_message_bits
       94 			bit (source_mseg_operation.ms_len) aligned based (source_mseg_operation.ms_ptr);
       95 
       96 dcl	compacted_segment	(compacted_size) bit (36) aligned based;
       97 dcl	compacted_size	fixed binary (19);
       98 
       99 dcl	1 local_mseg_segment_header
      100 			aligned like mseg_segment.header;
      101 dcl	initialize_block_map
      102 			bit (1) aligned;
      103 
      104 dcl	1 an_operation	aligned like mseg_operation;
      105 
      106 dcl	1 local_aef	aligned like audit_event_flags;
      107 
      108 dcl	operation_name	character (64);
      109 dcl	operation_specific_return
      110 			entry (fixed binary (35)) variable;
      111 dcl	operation_specific_abort
      112 			entry () variable;
      113 
      114 dcl	mseg_dir_name	character (168);
      115 dcl	mseg_entryname	character (32);
      116 
      117 dcl	(rqo_detected, salvage_if_errors, free_source_message_bits)
      118 			bit (1) aligned;
      119 
      120 dcl	(source_max_length, target_max_length)
      121 			fixed binary (19);
      122 dcl	(n_new_blocks, n_new_header_blocks, n_virgin_blocks, n_used_or_wasted_blocks, n_wasted_blocks)
      123 			fixed binary (18);
      124 
      125 dcl       TRUNCATE_ALL_BUT_THE_LOCKWORD fixed bin (19) int static options (constant) init (1); 
      126 
      127 dcl	access_operations_$mseg_attr_mod
      128 			bit (36) aligned external;
      129 
      130 dcl	(
      131 	error_table_$action_not_performed,
      132 	error_table_$bad_segment,
      133 	error_table_$clnzero,
      134 	error_table_$invalid_max_length,
      135 	error_table_$messages_off,
      136 	error_table_$no_message,
      137 	error_table_$rqover
      138 	)		fixed binary (35) external;
      139 
      140 dcl	access_audit_r1_$log_obj_ptr
      141 			entry () options (variable);
      142 dcl	aim_util_$get_access_class
      143 			entry (bit (72) aligned) returns (bit (72) aligned);
      144 dcl	get_process_id_	entry () returns (bit (36));
      145 dcl	get_system_free_area_
      146 			entry () returns (pointer);
      147 dcl	get_temp_segment_	entry (character (*), pointer, fixed binary (35));
      148 dcl	hcs_$get_max_length_seg
      149 			entry (pointer, fixed binary (19), fixed binary (35));
      150 dcl	hcs_$set_max_length_seg
      151 			entry (pointer, fixed binary (19), fixed binary (35));
      152 dcl	hcs_$truncate_seg	entry (pointer, fixed binary (19), fixed binary (35));
      153 dcl	mseg_message_$add_message_for_mseg
      154 			entry (pointer, character (*), fixed binary (35));
      155 dcl	mseg_message_$read_message_for_mseg
      156 			entry (pointer, character (*), pointer, fixed binary (35));
      157 dcl	mseg_utils_$abort_operation
      158 			entry (pointer);
      159 dcl	mseg_utils_$begin_operation
      160 			entry (bit (36) aligned, pointer, character (*), character (*), character (*), pointer,
      161 			bit (1) aligned, fixed binary (35));
      162 dcl	mseg_utils_$finish_operation
      163 			entry (pointer);
      164 dcl	mseg_utils_$salvage_for_cause
      165 			entry (pointer, fixed binary (35)) options (variable);
      166 dcl	release_temp_segment_
      167 			entry (character (*), pointer, fixed binary (35));
      168 
      169 dcl	(addr, copy, currentsize, divide, float, length, low, mod, null, rtrim, string, substr, unspec)
      170 			builtin;
      171 
      172 dcl	(cleanup, record_quota_overflow)
      173 			condition;
      174 
      175 /* Compact the segment */
      176 
      177 mseg_segment_$compact_seg:
      178      entry (P_mseg_operation_ptr, P_compaction_ratio, P_code);
      179 
      180 	call setup_operation ();			/* for cleanup handler */
      181 	target_mseg_ptr = null ();
      182 	salvage_if_errors, free_source_message_bits = "0"b;
      183 	operation_specific_return = return_from_compact_seg;
      184 	operation_specific_abort = abort_compact_seg;
      185 
      186 	on cleanup call operation_was_aborted ();
      187 
      188 	call begin_operation (mseg_operations_$compact_seg);
      189 	if rqo_detected
      190 	then call return_from_operation (0);
      191 	else if code ^= 0
      192 	then call return_from_operation (code);
      193 
      194 	if mseg_segment.n_messages = 0		/* can't be any waste unless there's something present */
      195 	then call return_from_operation (0);
      196 
      197 
      198 	/*** When deciding whether to compact, the ratio of unused blocks to the "size" of the segment is checked
      199*	     against the caller's compaction ratio.  If the unused ratio exceeds the compaction ratio and there is at
      200*	     least one page of unused blocks, the segment is compacted.  However, if the caller's compaction ratio is
      201*	     negative, the compaction is always performed regardless of the amount of space it may (or may not) recover.
      202*	     In order to make the unused block ratio useful, the unused blocks after the last used block are not counted
      203*	     when computing either the size of the segment or the number of unused blocks. */
      204 
      205 	if P_compaction_ratio >= 0.0e0
      206 	then do;
      207 
      208 		n_virgin_blocks = mseg_segment.n_blocks_allocated - find_last_one_bit (mseg_segment.block_map.map);
      209 		n_used_or_wasted_blocks = mseg_segment.n_blocks_allocated - n_virgin_blocks;
      210 		n_wasted_blocks = mseg_segment.n_blocks_unused - n_virgin_blocks;
      211 
      212 		if n_wasted_blocks = 0		/* there's no waste at all */
      213 		then call return_from_operation (0);
      214 
      215 		if (float (n_wasted_blocks) / float (n_used_or_wasted_blocks)) < P_compaction_ratio
      216 		then call return_from_operation (0);	/* there isn't enough waste to satisfy our caller */
      217 
      218 		if (mseg_segment.block_size * n_wasted_blocks)
      219 		     < mod ((mseg_segment.block_size * n_used_or_wasted_blocks), 1024)
      220 		then call return_from_operation (0);	/* we won't recover any pages so why bother */
      221 	     end;
      222 
      223 
      224 	/*** Control arrives here only if we are going to compact the segment -- We compact the segment by copying its
      225*	     messages into a "message segment" in the process directory.  This so-called message segment is actually
      226*	     just a temporary segment with an associated mseg_operation structure containing the necessary information
      227*	     to satisfy mseg_message_$add_message_for_mseg. */
      228 
      229 	/*** Finish preparation of the source -- Save the segment's wakeup state in its mseg_operation so we can store
      230*	     it in the target segment while initalizing the target's header.  Also, to insure that the target's block
      231*	     map is the proper length, we claim that the target's max length is equal to the source even though, as a
      232*	     temporary segment, its max length may indeed be larger. */
      233 
      234 	source_mseg_operation_ptr = mseg_operation_ptr;
      235 	source_mseg_ptr = mseg_ptr;
      236 
      237 	if mseg_segment.wakeup_state_set
      238 	then call get_wakeup_state_seg ();
      239 	else mseg_operation.wakeup_state_valid = "0"b;
      240 
      241 	call hcs_$get_max_length_seg (mseg_ptr, target_max_length, code);
      242 	if code ^= 0
      243 	then call return_from_operation (code);
      244 
      245 
      246 	/*** Prepare the target -- Create an mseg_operation which will satisfy mseg_message_$add_message_for_mseg and
      247*	     then get a temporary segment to serve as the target. */
      248 
      249 	an_operation = source_mseg_operation;
      250 	an_operation.mseg_ptr_valid,			/* the source segment is never the target ... */
      251 	     an_operation.access_info_valid = "0"b;	/* ... and its access info doesn't apply to the target */
      252 	an_operation.suppress_access_checks = "1"b;	/* must be able to  copy all messages */
      253 
      254 	call get_temp_segment_ (operation_name, target_mseg_ptr, code);
      255 	if code ^= 0
      256 	then call return_from_operation (code);
      257 
      258 	an_operation.mseg_ptr = target_mseg_ptr;
      259 	an_operation.mseg_ptr_valid = "1"b;
      260 
      261 	target_mseg_operation_ptr = addr (an_operation);
      262 
      263 	call mseg_utils_$begin_operation (mseg_operations_$copy_seg_target, target_mseg_operation_ptr, ((64)" "),
      264 	     target_mseg_dir_name, target_mseg_entryname, target_mseg_ptr, rqo_detected, code);
      265 	if rqo_detected
      266 	then call return_from_operation (error_table_$rqover);
      267 	else if code ^= 0
      268 	then call return_from_operation (code);
      269 
      270 
      271 	/*** Copy the source segment to its "target" which actually performs the compaction */
      272 
      273 	salvage_if_errors = "1"b;			/* if we RQO reading from the segment, it's busted */
      274 
      275 	on record_quota_overflow call return_rqover_from_operation ();
      276 
      277 	call initialize_target_header ("1"b);		/* put in the saved wakeup state */
      278 
      279 	call copy_messages ();
      280 
      281 
      282 	/*** Move the target back into the real segment which will complete this operation -- As the compacted segment
      283*	     is guaranteed to not use more pages than its original, we can pratically guarantee that an RQO will not
      284*	     occur on pages that had been zero in the original by first truncating the segment.  If, however, an RQO
      285*	     does occur while copying into the segment, we will stop the copy and salvage what's there as our handler
      286*	     for record_quota_overflow will prevent an automatic salvage by mseg_utils_$abort_operation. */
      287 
      288 	segment_in_error = SOURCE;
      289 
      290 	call hcs_$truncate_seg (source_mseg_ptr, TRUNCATE_ALL_BUT_THE_LOCKWORD, (0));
      291 
      292 	compacted_size =
      293 	     target_mseg_segment_header.block_size
      294 	     * (target_mseg_segment_header.n_blocks_allocated - target_mseg_segment_header.n_blocks_unused);
      295 
      296 	source_mseg_ptr -> compacted_segment = target_mseg_ptr -> compacted_segment;
      297 
      298 	revert record_quota_overflow;			/* success! */
      299 	call return_from_operation (0);
      300 
      301 
      302 
      303 /* Special processing required upon completion of a compact_seg operation */
      304 
      305 return_from_compact_seg:
      306      procedure (p_code);
      307 
      308 dcl	p_code		fixed binary (35) parameter;
      309 
      310 	if target_mseg_ptr ^= null ()
      311 	then do;
      312 		call release_temp_segment_ (operation_name, target_mseg_ptr, (0));
      313 		target_mseg_ptr = null ();
      314 	     end;
      315 
      316 	if salvage_if_errors & (p_code ^= 0)		/* the flag is only set while actually copying */
      317 	then if segment_in_error = SOURCE
      318 	     then if p_code = error_table_$rqover
      319 		then call mseg_utils_$salvage_for_cause (source_mseg_operation_ptr, error_table_$rqover);
      320 
      321 	if free_source_message_bits			/* this flag is also only set while acutally copying */
      322 	then if source_mseg_operation.message_info.ms_ptr ^= null ()
      323 	     then do;
      324 		     free source_mseg_message_bits in (system_area);
      325 		     source_mseg_operation.message_info.ms_ptr = null ();
      326 		end;
      327 
      328 	return;
      329 
      330      end return_from_compact_seg;
      331 
      332 
      333 
      334 /* Special processing required upon abnormal termination of a compact_seg operation */
      335 
      336 abort_compact_seg:
      337      procedure ();
      338 
      339 	if free_source_message_bits			/* this flag is only set while acutally copying */
      340 	then if source_mseg_operation.message_info.ms_ptr ^= null ()
      341 	     then do;
      342 		     free source_mseg_message_bits in (system_area);
      343 		     source_mseg_operation.message_info.ms_ptr = null ();
      344 		end;
      345 
      346 	if target_mseg_ptr ^= null ()
      347 	then do;
      348 		call release_temp_segment_ (operation_name, target_mseg_ptr, (0));
      349 		target_mseg_ptr = null ();
      350 	     end;
      351 
      352 	return;
      353 
      354      end abort_compact_seg;
      355 
      356 /* Copy the segment -- This entrypoint doesn't use mseg_operation_ptr as we are invoked with two message segments which
      357*   must be given equal treatment in terms of begin/finish/abort operation actions. */
      358 
      359 mseg_segment_$copy_seg:
      360      entry (P_source_mseg_operation_ptr, P_target_mseg_operation_ptr, P_error_on_target, P_code);
      361 
      362 	call setup_operation ();			/* for cleanup handler */
      363 	source_mseg_operation_ptr, target_mseg_operation_ptr = null ();
      364 	salvage_if_errors, free_source_message_bits = "0"b;
      365 	operation_specific_return = return_from_copy_seg;
      366 	operation_specific_abort = abort_copy_seg;
      367 
      368 	on cleanup call operation_was_aborted ();
      369 
      370 
      371 	/*** Lock the target segment and verify that it is, in fact, empty */
      372 
      373 	segment_in_error = TARGET;
      374 
      375 	target_mseg_operation_ptr = P_target_mseg_operation_ptr;
      376 
      377 	call mseg_utils_$begin_operation (mseg_operations_$copy_seg_target, target_mseg_operation_ptr, operation_name,
      378 	     target_mseg_dir_name, target_mseg_entryname, target_mseg_ptr, rqo_detected, code);
      379 	if rqo_detected
      380 	then call return_from_operation (error_table_$rqover);
      381 	else if code ^= 0
      382 	then call return_from_operation (code);
      383 
      384 	if (target_mseg_segment_header.n_messages ^= 0) | target_mseg_segment_header.wakeup_state_set
      385 	then call return_from_operation (error_table_$clnzero);
      386 
      387 
      388 	/*** Lock the source segment -- If it's empty, we're done. */
      389 
      390 	segment_in_error = SOURCE;
      391 
      392 	source_mseg_operation_ptr = P_source_mseg_operation_ptr;
      393 
      394 	call mseg_utils_$begin_operation (mseg_operations_$copy_seg_source, source_mseg_operation_ptr, operation_name,
      395 	     source_mseg_dir_name, source_mseg_entryname, source_mseg_ptr, rqo_detected, code);
      396 	if rqo_detected				/* couldn't even lock the source: there's nothing to copy */
      397 	then call return_from_operation (0);
      398 	else if code ^= 0
      399 	then call return_from_operation (code);
      400 
      401 
      402 	/*** Verify that the max length of the target is, at least, as large as the source */
      403 
      404 	segment_in_error = SOURCE;
      405 	call hcs_$get_max_length_seg (source_mseg_ptr, source_max_length, code);
      406 	if code ^= 0
      407 	then call return_from_operation (code);
      408 
      409 	segment_in_error = TARGET;
      410 	call hcs_$get_max_length_seg (target_mseg_ptr, target_max_length, code);
      411 	if code ^= 0
      412 	then call return_from_operation (code);
      413 
      414 	if target_max_length < source_max_length	/* it may not all fit */
      415 	then call return_from_operation (error_table_$invalid_max_length);
      416 
      417 
      418 	/*** Everything looks OK -- Copy the segment */
      419 
      420 	salvage_if_errors = "1"b;			/* RQO on source or any error on target should salvage */
      421 
      422 	on record_quota_overflow call return_rqover_from_operation ();
      423 
      424 	call initialize_target_header ("0"b);		/* do not copy the source's wakeup state */
      425 
      426 	call copy_messages ();
      427 
      428 	revert record_quota_overflow;
      429 
      430 	call return_from_operation (0);		/* success! */
      431 
      432 
      433 
      434 /* Return after completion of the copy_seg operation -- If an RQO occured while accessing the source segment, we will
      435*   salvage it because a properly formed message segment should never have message block offsets which reference an all
      436*   zero page and, as we are handling RQO ourselves, the standard abort_operation salvage will not occur.  On the other
      437*   hand, if any error is detected while accessing the target segment, we will salvage it because we shouldn't get an error
      438*   adding messages. */
      439 
      440 return_from_copy_seg:
      441      procedure (p_code);
      442 
      443 dcl	p_code		fixed binary (35) parameter;
      444 
      445 	if salvage_if_errors & (p_code ^= 0)		/* the flag is only set while actually copying */
      446 	then if segment_in_error = SOURCE
      447 	     then if p_code = error_table_$rqover
      448 		then call mseg_utils_$salvage_for_cause (source_mseg_operation_ptr, error_table_$rqover);
      449 		else ;
      450 
      451 	     else if segment_in_error = TARGET
      452 	     then if p_code ^= error_table_$bad_segment
      453 		then do;				/* only salvage if mseg_message_ hasn't already done so */
      454 			call mseg_utils_$salvage_for_cause (target_mseg_operation_ptr, p_code);
      455 			if p_code ^= error_table_$rqover
      456 			then p_code = error_table_$bad_segment;
      457 		     end;
      458 
      459 	if free_source_message_bits			/* this flag is also only set while acutally copying */
      460 	then if source_mseg_operation.message_info.ms_ptr ^= null ()
      461 	     then do;
      462 		     free source_mseg_message_bits in (system_area);
      463 		     source_mseg_operation.message_info.ms_ptr = null ();
      464 		end;
      465 
      466 	if target_mseg_operation_ptr ^= null ()
      467 	then call mseg_utils_$finish_operation (target_mseg_operation_ptr);
      468 
      469 	if source_mseg_operation_ptr ^= null ()
      470 	then call mseg_utils_$finish_operation (source_mseg_operation_ptr);
      471 
      472 	P_error_on_target = (segment_in_error = TARGET);	/* tell caller where (if anywhere) the error occured */
      473 
      474 	return;
      475 
      476      end return_from_copy_seg;
      477 
      478 
      479 
      480 /* Abort the copy_seg operation */
      481 
      482 abort_copy_seg:
      483      procedure ();
      484 
      485 	if free_source_message_bits			/* this flag is only set while acutally copying */
      486 	then if source_mseg_operation.message_info.ms_ptr ^= null ()
      487 	     then do;
      488 		     free source_mseg_message_bits in (system_area);
      489 		     source_mseg_operation.message_info.ms_ptr = null ();
      490 		end;
      491 
      492 	call mseg_utils_$abort_operation (source_mseg_operation_ptr);
      493 
      494 	call mseg_utils_$abort_operation (target_mseg_operation_ptr);
      495 
      496 	return;
      497 
      498      end abort_copy_seg;
      499 
      500 /* Get the salvaged flag -- The salvaged indicator is set whenever the message segment is salvaged and remains set until
      501*   it explicitly reset by someone with "d" extended access to the segment. */
      502 
      503 mseg_segment_$get_salvaged_flag_seg:
      504      entry (P_mseg_operation_ptr, P_salvaged_flag, P_code);
      505 
      506 	call setup_operation ();			/* for cleanup handler */
      507 	on cleanup call operation_was_aborted ();
      508 
      509 	call begin_operation (mseg_operations_$get_salvaged_flag_seg);
      510 
      511 	if rqo_detected				/* the header is zero and accessing it causes RQOs, */
      512 	then P_salvaged_flag = "0"b;			/* ... so we know the flag is off without actually looking */
      513 
      514 	else if code = 0				/* we can look at the header without trouble */
      515 	then P_salvaged_flag = mseg_segment.flags.salvaged;
      516 
      517 	call return_from_operation (code);
      518 
      519 /* Get the wakeup acceptance state */
      520 
      521 mseg_segment_$get_wakeup_state_seg:
      522      entry (P_mseg_operation_ptr, P_code);
      523 
      524 	call setup_operation ();			/* for cleanup handler */
      525 	on cleanup call operation_was_aborted ();
      526 
      527 	call begin_operation (mseg_operations_$get_wakeup_state_seg);
      528 	if rqo_detected				/* header's empty so no one is accepting wakeups here */
      529 	then call return_from_operation (error_table_$messages_off);
      530 	else if code ^= 0
      531 	then call return_from_operation (code);
      532 
      533 	if ^mseg_segment.wakeup_state_set
      534 	then call return_from_operation (error_table_$messages_off);
      535 
      536 	call get_wakeup_state_seg ();
      537 
      538 	call return_from_operation (0);
      539 
      540 
      541 
      542 /* Actually get the wakeup state -- This internal procedure is only invoked if the message segment's header claims that
      543*   the wakeup state is actually present.  In earlier version 5 message segments, the wakeup state was actually stored in
      544*   several pieces throughout the header.  This internal procedure is also used by compact_seg. */
      545 
      546 get_wakeup_state_seg:
      547      procedure ();
      548 
      549 						/** format: idind30 */
      550 dcl	1 old_wakeup_state		aligned,
      551 	  2 state,
      552 	    3 switches		aligned,
      553 	      4 allow_normal	bit (1) unaligned,
      554 	      4 allow_urgent	bit (1) unaligned,
      555 	      4 pad		bit (34) unaligned,
      556 	    3 lock_id		bit (36) aligned,
      557 	    3 event_channel		fixed bin (71),
      558 	    3 process_id		bit (36) aligned,
      559 	  2 pad			(64 - 5) bit (36) aligned;
      560 						/* format: idind20 */
      561 
      562 	if mseg_segment.wakeup_state.version = MSEG_WAKEUP_STATE_VERSION_1
      563 	then mseg_operation.wakeup_state = mseg_segment.wakeup_state.state;
      564 
      565 	else do;					/* early version 5 message segment */
      566 		unspec (old_wakeup_state) = unspec (header_msg);
      567 		mseg_operation.wakeup_state.version = MSEG_WAKEUP_STATE_VERSION_1;
      568 		string (mseg_operation.wakeup_state.flags) = string (old_wakeup_state.switches);
      569 		mseg_operation.wakeup_state.event_channel = old_wakeup_state.event_channel;
      570 		mseg_operation.wakeup_state.access_class = header_msg_access_class;
      571 		mseg_operation.wakeup_state.process_id = old_wakeup_state.process_id;
      572 		mseg_operation.wakeup_state.lock_id = old_wakeup_state.lock_id;
      573 	     end;
      574 
      575 	mseg_operation.wakeup_state_valid = "1"b;	/* it's very definitely OK now */
      576 
      577 	return;
      578 
      579      end get_wakeup_state_seg;
      580 
      581 /* Reset the salvaged flag */
      582 
      583 mseg_segment_$reset_salvaged_flag_seg:
      584      entry (P_mseg_operation_ptr, P_code);
      585 
      586 	call setup_operation ();			/* for cleanup handler */
      587 	on cleanup call operation_was_aborted ();
      588 
      589 	call begin_operation (mseg_operations_$reset_salvaged_flag_seg);
      590 	if rqo_detected				/* header's empty so the salvaged flag is already reset */
      591 	then call return_from_operation (0);
      592 	else if code ^= 0
      593 	then call return_from_operation (code);
      594 
      595 	if mseg_segment.flags.salvaged
      596 	then do;
      597 
      598 		mseg_segment.flags.salvaged = "0"b;	/* actually reset the flag */
      599 
      600 		if mseg_operation.call_admin_gate & ^mseg_operation.suppress_access_checks
      601 		     & mseg_operation.access_info.multiclass
      602 		then do;				/* audit the covert channel */
      603 			string (local_aef) = ""b;
      604 			local_aef.grant = "1"b;
      605 			local_aef.cc_10_100 = "1"b;
      606 			call access_audit_r1_$log_obj_ptr (operation_name, mseg_operation.validation_level,
      607 			     string (local_aef), access_operations_$mseg_attr_mod, mseg_ptr, 0, null (), 0,
      608 			     "Message segment salvage flag reset.");
      609 		     end;
      610 	     end;
      611 
      612 	call return_from_operation (0);
      613 
      614 /* Reset the wakeup acceptance state (i.e., turn it off) */
      615 
      616 mseg_segment_$reset_wakeup_state_seg:
      617      entry (P_mseg_operation_ptr, P_code);
      618 
      619 	call setup_operation ();			/* for cleanup handler */
      620 	on cleanup call operation_was_aborted ();
      621 
      622 	call begin_operation (mseg_operations_$reset_wakeup_state_seg);
      623 	if rqo_detected				/* header's empty so the wakeup state is already reset */
      624 	then call return_from_operation (0);
      625 	else if code ^= 0
      626 	then call return_from_operation (code);
      627 
      628 	mseg_segment.wakeup_state_set = "0"b;
      629 	unspec (mseg_segment.wakeup_state) = ""b;
      630 
      631 	call return_from_operation (0);
      632 
      633 /* Set the max length */
      634 
      635 mseg_segment_$set_max_length_seg:
      636      entry (P_mseg_operation_ptr, P_max_length, P_code);
      637 
      638 	call setup_operation ();			/* for cleanup handler */
      639 	on cleanup call operation_was_aborted ();
      640 
      641 	call begin_operation (mseg_operations_$set_max_length_seg);
      642 
      643 	if rqo_detected
      644 	then do;	/*** The header is empty and any attempts to access it cause an RQO.  We can still try to set the max
      645*		     length, however, by using a local copy of the header while being careful not to reference its
      646*		     block map which doesn't exist. */
      647 		mseg_ptr = addr (local_mseg_segment_header);
      648 		mseg_segment.n_messages = 0;
      649 		mseg_segment.block_size = mseg_data_$block_size;
      650 		initialize_block_map = "0"b;
      651 	     end;
      652 
      653 	else if code = 0
      654 	then do;	/*** We can access the header without problems. */
      655 		if mseg_segment.block_size = 0
      656 		then mseg_segment.block_size = mseg_data_$block_size;
      657 		initialize_block_map = "1"b;
      658 	     end;
      659 
      660 	else call return_from_operation (code);		/* couldn't get to the segment at all */
      661 
      662 	if mseg_segment.n_messages > 0
      663 	then call return_from_operation (error_table_$action_not_performed);
      664 
      665 
      666 	/*** The new max length must be large enough to hold the header and a single zero length message. */
      667 
      668 	if P_max_length <= 0
      669 	then call return_from_operation (error_table_$invalid_max_length);
      670 
      671 	n_new_blocks = divide (P_max_length, mseg_segment.block_size, 18, 0);
      672 						/* format: off */
      673 	n_new_header_blocks =
      674 	     divide ((currentsize (local_mseg_segment_header) + divide ((n_new_blocks + 35), 36, 18, 0)
      675 		    + mseg_segment.block_size - 1), mseg_segment.block_size, 18, 0);
      676 						/* format: on */
      677 	if n_new_blocks <= n_new_header_blocks
      678 	then call return_from_operation (error_table_$invalid_max_length);
      679 
      680 
      681 	/*** The new max length is OK -- set it */
      682 
      683 	call hcs_$set_max_length_seg (mseg_operation.mseg_ptr, P_max_length, code);
      684 
      685 	if (code = 0) & initialize_block_map
      686 	then do;	/*** We set the max length and can access the actual header -- Initialize the block map. */
      687 		mseg_segment.n_blocks_allocated = n_new_blocks;
      688 		mseg_segment.n_blocks_unused = n_new_blocks - n_new_header_blocks;
      689 		mseg_segment.block_map.map = copy ("1"b, n_new_header_blocks);
      690 	     end;
      691 
      692 	call return_from_operation (code);
      693 
      694 /* Set the wakeup acceptance state */
      695 
      696 mseg_segment_$set_wakeup_state_seg:
      697      entry (P_mseg_operation_ptr, P_code);
      698 
      699 	call setup_operation ();			/* for cleanup handler */
      700 	on cleanup call operation_was_aborted ();
      701 
      702 	call begin_operation (mseg_operations_$set_wakeup_state_seg);
      703 	if rqo_detected
      704 	then call return_from_operation (error_table_$rqover);
      705 	else if code ^= 0
      706 	then call return_from_operation (code);
      707 
      708 	mseg_segment.wakeup_state.version = MSEG_WAKEUP_STATE_VERSION_1;
      709 
      710 	mseg_segment.wakeup_state.flags = mseg_operation.wakeup_state.flags;
      711 	mseg_segment.wakeup_state.event_channel = mseg_operation.wakeup_state.event_channel;
      712 
      713 	mseg_segment.wakeup_state.access_class = aim_util_$get_access_class (mseg_operation.caller.authorization);
      714 	mseg_segment.wakeup_state.process_id = get_process_id_ ();
      715 	mseg_segment.wakeup_state.lock_id = mseg_data_$lock_id;
      716 
      717 	unspec (mseg_segment.header.wakeup_state.pad) = ""b;
      718 
      719 	mseg_segment.wakeup_state_set = "1"b;		/* it's now set */
      720 
      721 	call return_from_operation (0);
      722 
      723 /* Common initialization for all operations */
      724 
      725 setup_operation:
      726      procedure ();
      727 
      728 	code = 0;
      729 
      730 	operation_specific_abort = nulle;		/* nothing special when we abort or return (yet) */
      731 	operation_specific_return = nulle;
      732 
      733 	mseg_operation_ptr = null ();
      734 
      735 	return;
      736 
      737      end setup_operation;
      738 
      739 
      740 
      741 /* Begin the operation -- This procedure isn't part of setup_operation so that we can be certain to have a cleanup handler
      742*   available at all times that the message segment may be in use. */
      743 
      744 begin_operation:
      745      procedure (p_mseg_operation_id);
      746 
      747 dcl	p_mseg_operation_id bit (36) aligned parameter;
      748 
      749 	mseg_operation_ptr = P_mseg_operation_ptr;
      750 
      751 	call mseg_utils_$begin_operation (p_mseg_operation_id, mseg_operation_ptr, operation_name, mseg_dir_name,
      752 	     mseg_entryname, mseg_ptr, rqo_detected, code);
      753 
      754 	return;
      755 
      756      end begin_operation;
      757 
      758 
      759 
      760 /* The "null" entry which indicates that there's no special abort/return processing for an operation */
      761 
      762 nulle:
      763      procedure ();
      764 
      765 	return;
      766 
      767      end nulle;
      768 
      769 /* Return after completion of an operation */
      770 
      771 return_from_operation:
      772      procedure (p_code);
      773 
      774 dcl	p_code		fixed binary (35) parameter;
      775 
      776 	if operation_specific_return ^= nulle		/* let the operation do anything special */
      777 	then call operation_specific_return (p_code);
      778 
      779 	if mseg_operation_ptr ^= null ()		/* may be invoked before we've called begin_operation */
      780 	then call mseg_utils_$finish_operation (mseg_operation_ptr);
      781 
      782 	P_code = p_code;				/* set our caller's status code */
      783 	go to RETURN_FROM_OPERATION;
      784 
      785      end return_from_operation;
      786 
      787 RETURN_FROM_OPERATION:
      788 	return;
      789 
      790 
      791 
      792 /* Return error_table_$rqover to our caller after an RQO is detected */
      793 
      794 return_rqover_from_operation:
      795      procedure ();
      796 
      797 	if operation_specific_return ^= nulle		/* let the operation do anything special */
      798 	then call operation_specific_return (error_table_$rqover);
      799 
      800 	if mseg_operation_ptr ^= null ()		/* may be invoked by copy_seg which doesn't use this value */
      801 	then call mseg_utils_$finish_operation (mseg_operation_ptr);
      802 
      803 	P_code = error_table_$rqover;			/* set our caller's status code */
      804 	go to RETURN_FROM_OPERATION;
      805 
      806      end return_rqover_from_operation;
      807 
      808 
      809 
      810 /* Abort an operation */
      811 
      812 operation_was_aborted:
      813      procedure ();
      814 
      815 	if operation_specific_abort ^= nulle		/* let the operation do anything special */
      816 	then call operation_specific_abort ();
      817 
      818 	call mseg_utils_$abort_operation (mseg_operation_ptr);
      819 
      820 	return;
      821 
      822      end operation_was_aborted;
      823 
      824 /* Finds the last one bit in a bit string as index (reverse (bit_string), "1"b) is too slow */
      825 
      826 find_last_one_bit:
      827      procedure (p_bit_string) returns (fixed binary (24));
      828 
      829 dcl	p_bit_string	bit (*) unaligned parameter;
      830 dcl	the_bits_as_chars	character (n_chars) aligned based (addr (p_bit_string));
      831 dcl	the_char		character (1) aligned;
      832 dcl	the_char_as_bits	bit (9) aligned based (addr (the_char));
      833 dcl	(n_bits, bit_idx)	fixed binary (24);
      834 dcl	(n_chars, char_idx) fixed binary (21);
      835 
      836 	n_bits = length (p_bit_string);
      837 
      838 	if mod (n_bits, 9) ^= 0
      839 	then do;					/* must check the last bits by hand */
      840 		do bit_idx = 0 to (mod (n_bits, 9) - 1);
      841 		     if substr (p_bit_string, (n_bits - bit_idx), 1)
      842 		     then return ((n_bits - bit_idx));
      843 		end;
      844 		n_bits = n_bits - mod (n_bits, 9);	/* ... they were all zero */
      845 	     end;
      846 
      847 	n_chars = divide (n_bits, 9, 21, 0);
      848 	char_idx = length (rtrim (the_bits_as_chars, low (1)));
      849 
      850 	if char_idx = 0
      851 	then return (0);				/* no one bits at all */
      852 
      853 	the_char = substr (the_bits_as_chars, char_idx, 1);
      854 	do bit_idx = 9 to 1 by -1;
      855 	     if substr (the_char_as_bits, bit_idx)
      856 	     then return ((9 * (char_idx - 1)) + bit_idx);
      857 	end;
      858 
      859 	return ((9 * (char_idx - 1)));		/* won't get here, but ... */
      860 
      861      end find_last_one_bit;
      862 
      863 /* Initialize the copy target's header -- Our caller has already locked the segment and determined its max length. */
      864 
      865 initialize_target_header:
      866      procedure (p_copy_source_wakeup_state);
      867 
      868 dcl	p_copy_source_wakeup_state
      869 			bit (1) aligned parameter;
      870 
      871 	target_mseg_segment_header.n_messages, target_mseg_segment_header.date_time_last_salvaged = 0;
      872 	unspec (target_mseg_segment_header.message_chain) = ""b;
      873 	string (target_mseg_segment_header.flags) = ""b;
      874 	unspec (target_mseg_segment_header.wakeup_state) = ""b;
      875 	unspec (target_mseg_segment_header.hash_table) = ""b;
      876 
      877 	target_mseg_segment_header.sentinel = MSEG_SEGMENT_SENTINEL;
      878 	target_mseg_segment_header.version = MSEG_SEGMENT_VERSION_5;
      879 
      880 	target_mseg_segment_header.block_size = mseg_data_$block_size;
      881 	target_mseg_segment_header.n_blocks_allocated =
      882 	     divide (target_max_length, target_mseg_segment_header.block_size, 18, 0);
      883 						/* format: off */
      884 	n_new_header_blocks =
      885 	     divide ((currentsize (target_mseg_segment_header)
      886 		    + divide ((target_mseg_segment_header.n_blocks_allocated + 35), 36, 18, 0)
      887 		    + target_mseg_segment_header.block_size - 1), target_mseg_segment_header.block_size, 18, 0);
      888 						/* format: on */
      889 
      890 	target_mseg_segment_header.n_blocks_unused =
      891 	     target_mseg_segment_header.n_blocks_allocated - n_new_header_blocks;
      892 
      893 	target_mseg_ptr -> mseg_segment.block_map.map = copy ("1"b, n_new_header_blocks);
      894 
      895 	if p_copy_source_wakeup_state
      896 	then do;
      897 		if source_mseg_operation.wakeup_state_valid
      898 		then target_mseg_segment_header.wakeup_state.state = source_mseg_operation.wakeup_state;
      899 		target_mseg_segment_header.wakeup_state_set = source_mseg_operation.wakeup_state_valid;
      900 	     end;
      901 
      902 	return;
      903 
      904      end initialize_target_header;
      905 
      906 /* Copy all messages in the source message segment to the target -- We call mseg_message_$read_message_for_mseg and
      907*   mseg_message_$add_message_for_mseg to do the actuall reading/writing.  These special entrypoints are implemented
      908*   knowing that they are invoked with the message segment's already locked. */
      909 
      910 copy_messages:
      911      procedure ();
      912 
      913 	source_mseg_operation.suppress_access_checks,	/* insure mseg_message_ copies all the messages */
      914 	     target_mseg_operation.suppress_access_checks = "1"b;
      915 	target_mseg_operation.add_message_info_all_valid = "1"b;
      916 
      917 	source_mseg_operation.message_info.version = MSEG_MESSAGE_INFO_V1;
      918 	string (source_mseg_operation.message_info.control_flags) = ""b;
      919 	source_mseg_operation.message_info.ms_ptr = null ();
      920 
      921 	system_area_ptr = get_system_free_area_ ();
      922 
      923 	free_source_message_bits = "1"b;		/* force cleanup handlers to get rid of leftovers */
      924 
      925 	segment_in_error = SOURCE;
      926 	source_mseg_operation.message_info.message_code = MSEG_READ_FIRST;
      927 	call mseg_message_$read_message_for_mseg (source_mseg_operation_ptr, operation_name, system_area_ptr, code);
      928 
      929 	do while (code = 0);
      930 
      931 	     segment_in_error = TARGET;
      932 	     target_mseg_operation.message_info = source_mseg_operation.message_info;
      933 	     call mseg_message_$add_message_for_mseg (target_mseg_operation_ptr, operation_name, code);
      934 	     if code ^= 0
      935 	     then call return_from_operation (code);
      936 
      937 	     if source_mseg_operation.message_info.ms_ptr ^= null ()
      938 	     then do;
      939 		     free source_mseg_message_bits in (system_area);
      940 		     source_mseg_operation.message_info.ms_ptr = null ();
      941 		end;
      942 
      943 	     segment_in_error = SOURCE;
      944 	     source_mseg_operation.message_info.message_code = MSEG_READ_AFTER_SPECIFIED;
      945 	     call mseg_message_$read_message_for_mseg (source_mseg_operation_ptr, operation_name, system_area_ptr, code)
      946 		;
      947 	end;
      948 
      949 	if code ^= error_table_$no_message		/* we were unable to read a message */
      950 	then call return_from_operation (code);
      951 
      952 	free_source_message_bits = "0"b;
      953 
      954 	return;
      955 
      956      end copy_messages;
      957 
      958 /* format: off */
      959  /* Begin include file mseg_data_.incl.pl1 BIM 1985-04-15 */
  1     2 /* format: style4 */
  1     3 
  1     4 declare  mseg_data_$lock_id bit (72) aligned external;
  1     5 declare  mseg_data_$block_size fixed bin (35) ext static;
  1     6 declare  mseg_data_$max_message_size fixed bin (35) ext static;
  1     7 declare  mseg_data_$template_operation bit (36) aligned external static; /* like mseg_operation */
  1     8 declare  mseg_data_$admin_ring fixed binary (3) external;
  1     9 declare  mseg_data_$execution_ring fixed bin (3) ext static;
  1    10 declare  mseg_data_$process_max_authorization bit (72) aligned ext static;
  1    11 declare  mseg_data_$group_id char (32) unaligned external static;
  1    12 
  1    13 /* End include file mseg_data_.incl.pl1 */
      959 
      960  /* BEGIN INCLUDE FILE ... mseg_segment.incl.pl1 */
  2     2 /* Created:  April 1985 by G. Palter from msg_hdr.incl.pl1 */
  2     3 
  2     4 /* format: style3,linecom */
  2     5 
  2     6 /* NOTE: This include file references the mseg_wakeup_state structure which is defined separately in
  2     7*   mseg_wakeup_state.incl.pl1.  Programs which use this include file must also include mseg_wakeup_state.incl.pl1 to
  2     8*   prevent compilation errors. */
  2     9 
  2    10 
  2    11 /* Definition of the structure of a message segment --
  2    12*
  2    13*   A message segment is composed of three sections -- the header, the block map, and the blocks space.
  2    14*
  2    15*   In addition to the message ID hash table and the head&tail of the chronological message chain, the message header also
  2    16*   contains the state of wakeup acceptance for this segment.  In order to maintain compatibility with early version 5
  2    17*   message segments, the wakeup state is maintained in a 64 word area of the header which had been known as the "header
  2    18*   message".  See mseg_wakeup_state.incl.pl1 for additional information.
  2    19*
  2    20*   The entire message segment, including the header and block map, is treated as an array of fixed size blocks.  The block
  2    21*   map contains a bit for each block in the message which indicates whether that block is in use.  (The blocks which
  2    22*   overlay the header and block map are always marked as being in use).  The size of the block map is based on the
  2    23*   maxlength of the message segment in order to provide more free space in very small message segments.
  2    24*
  2    25*   When a message is added to a message segment, its content is split into blocks which are allocated in the blocks space.
  2    26*   The blocks space starts with the first block after the block map and occupies the remainder of the segment. */
  2    27 
  2    28 declare	1 mseg_segment	aligned based (mseg_ptr),
  2    29 	  2 header	aligned,
  2    30 	    3 lock	bit (36) aligned,
  2    31 	    3 sentinel	bit (36) aligned,		/* proves that this segment is a message segment */
  2    32 	    3 reserved	bit (72) aligned,		/* ... for compatibility with early version 5 segments */
  2    33 	    3 date_time_last_salvaged
  2    34 			fixed binary (71),
  2    35 	    3 pad		(2) bit (36) aligned,
  2    36 	    3 message_chain,			/* the chronological chain of messages in the segment ... */
  2    37 	      4 first_message			/* ... the first (oldest) message */
  2    38 			fixed binary (18) unaligned unsigned,
  2    39 	      4 pad1	bit (18) unaligned,
  2    40 	      4 last_message			/* ... the last (youngest) message */
  2    41 			fixed binary (18) unaligned unsigned,
  2    42 	      4 pad2	bit (18) unaligned,
  2    43 	    3 n_blocks_allocated			/* total # of blocks available in this message segment ... */
  2    44 			fixed binary (18),		/* ... including space occupied by the header and block map */
  2    45 	    3 n_blocks_unused
  2    46 			fixed binary (18),
  2    47 	    3 n_messages	fixed binary (18),
  2    48 	    3 block_size	fixed binary,		/* ... in words */
  2    49 	    3 flags,
  2    50 	      4 modification_in_progress
  2    51 			bit (1) unaligned,
  2    52 	      4 salvaged	bit (1) unaligned,		/* ON => the message segment had been salvaged earlier */
  2    53 	      4 wakeup_state_set
  2    54 			bit (1) unaligned,
  2    55 	      4 salvage_in_progress
  2    56 			bit (1) unaligned,
  2    57 	      4 pad	bit (32) unaligned,
  2    58 	    3 version	fixed binary,
  2    59 	    3 wakeup_state	aligned,
  2    60 	      4 state	aligned like mseg_wakeup_state,
  2    61 	      4 pad	(64 - 10) bit (36) aligned,	/* ... for compatibility with early version 5 segments */
  2    62 	    3 hash_table	aligned,			/* ... based on the low order 9 bits of the message ID */
  2    63 	      4 last_message
  2    64 			(0:511) fixed binary (18) unaligned unsigned,
  2    65 	  2 block_map	aligned,			/* ON => the block is in use */
  2    66 	    3 map		bit (0 refer (mseg_segment.n_blocks_allocated)) unaligned;
  2    67 
  2    68 declare	mseg_ptr		pointer;
  2    69 
  2    70 declare	MSEG_SEGMENT_VERSION_5			/* presently supported version */
  2    71 			fixed binary static options (constant) initial (5);
  2    72 
  2    73 declare	MSEG_SEGMENT_SENTINEL
  2    74 			bit (36) aligned static options (constant) initial ("252525252525"b3);
  2    75 
  2    76 
  2    77 /* Redefinitions required to access the wakeup_state of the segment in early version 5 message segments */
  2    78 
  2    79 declare	header_msg_access_class
  2    80 			bit (72) aligned defined (mseg_segment.reserved);
  2    81 
  2    82 declare	header_msg_present	bit (1) unaligned defined (mseg_segment.wakeup_state_set);
  2    83 
  2    84 declare	header_msg	(64) bit (36) aligned based (addr (mseg_segment.wakeup_state));
  2    85 
  2    86 /* END INCLUDE FILE ... mseg_segment.incl.pl1 */
      960 
      961  /* BEGIN INCLUDE FILE ... mseg_wakeup_state.incl.pl1 */
  3     2 /* Created:  April 1985 by G. Palter */
  3     3 
  3     4 /* format: style3,linecom */
  3     5 
  3     6 /* Description of the wakeup state of a message segment --
  3     7*
  3     8*   The wakeup state defines which process, if any, is willing to receive normal or urgent IPC wakeups when a message which
  3     9*   requests such a wakeup is added to a message segment.  The process is allowed to separately accept or defer normal and
  3    10*   urgent wakeups.  Note that deferring a wakeup is not the same as not accepting wakeups.  A process is not allowed to
  3    11*   stop accepting wakeups once it has accepted them as to do so would introduce a relatively high badnwidth covert
  3    12*   channel.  (In the present implementation, urgent wakeups are really no different from normal wakeups.  Eventually,
  3    13*   urgent wakeups should be implemented using an IPS signal along with the IPC wakeup).
  3    14*
  3    15*   mseg_$get_wakeup_state_seg requires that the caller supply the proper value for mseg_wakeup_state.version in the
  3    16*   mseg_operation.  If there is no wakeup state recorded in the message segment, mseg_$get_wakeup_state_seg will return
  3    17*   the status code error_table_$messages_off.
  3    18*
  3    19*   mseg_$set_wakeup_state_seg ignores the values of the access_class, process_id, and lock_id elements supplied by the
  3    20*   caller in the mseg_operation.  mseg_$set_wakeup_state_seg will, instead, furnish the values of the process making the
  3    21*   call for these elements and will return these values to its caller.  In other words, mseg_$set_wakeup_state_seg can not
  3    22*   be used by one process to accept/defer wakeups on behalf of another process. */
  3    23 
  3    24 declare	1 mseg_wakeup_state aligned based (mseg_wakeup_state_ptr),
  3    25 	  2 version	character (8) unaligned,
  3    26 	  2 flags		aligned,
  3    27 	    3 accepting_normal_wakeups		/* ON => process has accepted normal wakeups */
  3    28 			bit (1) unaligned,		/* OFF => process has deferred normal wakeups */
  3    29 	    3 accepting_urgent_wakeups		/* ON => process has accepted urgent wakeups */
  3    30 			bit (1) unaligned,		/* OFF => process has deferred urgent wakeups */
  3    31 	    3 pad		bit (34) unaligned,
  3    32 	  2 pad		bit (36) aligned,
  3    33 	  2 event_channel	fixed binary (71),		/* IPC event channel on which to send normal/urgent wakeups */
  3    34 	  2 access_class	bit (72) aligned,		/* AIM access class of the process accepting wakeups */
  3    35 	  2 process_id	bit (36) aligned,		/* ID of the process accepting wakeups */
  3    36 	  2 lock_id	bit (36) aligned;		/* lock ID used to test if said process is still alive */
  3    37 
  3    38 declare	mseg_wakeup_state_ptr
  3    39 			pointer;
  3    40 
  3    41 declare	MSEG_WAKEUP_STATE_VERSION_1
  3    42 			character (8) static options (constant) initial ("msegwkp1");
  3    43 
  3    44 /* END INCLUDE FILE ... mseg_wakeup_state.incl.pl1 */
      961 
      962  /* BEGIN INCLUDE FILE ... mseg_operation.incl.pl1 */
  4     2 
  4     3 /* format: style3,idind30,linecom */
  4     4 
  4     5 /**** Created 1985-04-16, BIM: from Pandolf's  mseg_access_operation */
  4     6 
  4     7 /**** NOTES:
  4     8*      The caller of mseg_ must set mseg_operation.access_operation to record
  4     9*      the type of access checking it has performed and which mseg_ should
  4    10*      perform when needed (i.e., for those entrypoints which operate on
  4    11*      messages like mseg_$read_message).
  4    12*
  4    13*      mseg_operation.operation is reserved explicitly for use by mseg_ and
  4    14*      its underlying modules.
  4    15*
  4    16*      You must also include entry_access_info, mseg_message_info, and
  4    17*      mbx_wakeup_state along with this include file. */
  4    18 
  4    19 dcl	mseg_operation_ptr		pointer;
  4    20 dcl	MSEG_OPERATION_VERSION_1	fixed bin internal static options (constant) init (1);
  4    21 dcl	MSEG_TYPE_MBX		fixed bin init (1) internal static options (constant);
  4    22 dcl	MSEG_TYPE_MS		fixed bin init (2) internal static options (constant);
  4    23 
  4    24 dcl	1 mseg_operation		based (mseg_operation_ptr) aligned,
  4    25 	  2 version		fixed binary,	/* current version is MSEG_OPERATION_VERSION_1 */
  4    26 	  2 type			fixed binary,	/* MBX or MS */
  4    27 	  2 access_operation	fixed binary,	/* type of access checks required for the operation */
  4    28 	  2 operation		bit (36) aligned,	/* for use by mseg_ and underlying modules */
  4    29 	  2 caller		aligned,		/* always collected in gate target */
  4    30 	    3 validation_level	fixed bin (3),
  4    31 	    3 privileges		bit (18) aligned,	/* factored for speed */
  4    32 	    3 pad_align_double	fixed bin (71),	/* just to force alignment */
  4    33 	    3 authorization		bit (72) aligned,	/* must be 2word aligned */
  4    34 	    3 max_authorization	bit (72) aligned,
  4    35 	    3 group_id		char (32) unaligned,
  4    36 	  2 flags			aligned,
  4    37 	    3 mseg_pathname_valid	bit (1) unaligned,
  4    38 	    3 mseg_ptr_valid	bit (1) unaligned,
  4    39 	    3 mseg_index_valid	bit (1) unaligned,
  4    40 	    3 access_info_valid	bit (1) unaligned,
  4    41 	    3 md_ptr_valid		bit (1) unaligned,
  4    42 	    3 message_info_valid	bit (1) unaligned,	/* note -- for some operations not all fields are used */
  4    43 	    3 wakeup_state_valid	bit (1) unaligned,
  4    44 	    3 suppress_access_checks	bit (1) unaligned,	/* set by privileged interfaces, suppresses ALL access checking */
  4    45 	    3 call_admin_gate	bit (1) unaligned,	/* we is in ring 1, boss */
  4    46 	    3 only_own_access	bit (1) unaligned,	/* the user had o rather than r/d */
  4    47 	    3 add_message_info_all_valid
  4    48 				bit (1) unaligned,	/* Believe ALL the fields in message info on an add */
  4    49 	    3 pad			bit (24) unaligned,
  4    50 	  2 dir_name		char (168) unaligned,
  4    51 	  2 entryname		char (32) unaligned,
  4    52 	  2 mseg_ptr		pointer,
  4    53 	  2 md_ptr		pointer,		/* message descriptor */
  4    54 	  2 mseg_index		fixed bin,
  4    55 	  2 access_info		aligned like entry_access_info,
  4    56 	  2 message_info		aligned like mseg_message_info,
  4    57 	  2 wakeup_state		aligned like mseg_wakeup_state;
  4    58 
  4    59 /* END INCLUDE FILE ... mseg_operation.incl.pl1 */
      962 
      963  /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  5     2 /* format: style3,idind30 */
  5     3 
  5     4 /* structure returned when message is read from a message segment */
  5     5 
  5     6 
  5     7 dcl	mseg_message_info_ptr	pointer;
  5     8 
  5     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  5    10 	  2 version		char (8) aligned,
  5    11 	  2 message_code		fixed bin,
  5    12 	  2 control_flags		unaligned,
  5    13 	    3 own			bit (1),
  5    14 	    3 delete		bit (1),
  5    15 	    3 pad			bit (34),
  5    16 	  2 ms_ptr		ptr,		/* pointer to message */
  5    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  5    18 	  2 ms_id			bit (72),		/* unique ID of message */
  5    19 						/* input in some cases */
  5    20 	  2 ms_access_class		bit (72),		/* message access class */
  5    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  5    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  5    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  5    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  5    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  5    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  5    27 
  5    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  5    29 
  5    30 declare	(
  5    31 	MSEG_READ_FIRST		init (1),
  5    32 	MSEG_READ_LAST		init (2),
  5    33 	MSEG_READ_SPECIFIED		init (3),
  5    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  5    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  5    36 	fixed bin int static options (constant);
  5    37 
  5    38 declare  (MSEG_READ_OWN		init ("1"b),
  5    39 	MSEG_READ_DELETE		init ("01"b)
  5    40 	)			bit (36) aligned internal static options (constant);
  5    41 
  5    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
      963 
      964  /* BEGIN INCLUDE FILE ... entry_access_info.incl.pl1 */
  6     2 
  6     3 /*
  6     4*   Written  03/22/85 by M. Pandolf
  6     5*   Modified 1985-04-19, BIM: added parent access class.
  6     6**/
  6     7 
  6     8 dcl  entry_access_info_ptr pointer;
  6     9 dcl  ENTRY_ACCESS_INFO_VERSION_1 char (8) internal static options (constant)
  6    10      init ("eainf001");
  6    11 
  6    12 dcl 1 entry_access_info aligned based (entry_access_info_ptr),
  6    13     2 version char (8),				/* = ENTRY_ACCESS_INFO_VERSION_1 */
  6    14     2 type fixed bin,				/* see status_structures.incl.pl1 */
  6    15     2 dir_name char (168) unaligned,			/* parent of this entry */
  6    16     2 entryname char (32) unaligned,			/* primary name of this entry */
  6    17     2 uid bit (36) aligned,				
  6    18     2 ring_brackets (3) fixed bin (3),			/* for dirs, the dir ring brackets are here */
  6    19     2 extended_ring_brackets (3) fixed bin (3),		/* not-yet-implemented x-rb's */
  6    20     2 effective_access_modes bit (36) aligned,		/* for dirs, dir mode is here */
  6    21     2 extended_access_modes bit (36) aligned,		/* always null for dirs */
  6    22     2 access_class bit (72) aligned,			/* for multiclass, max access class */
  6    23     2 parent_access_class bit (72) aligned,		/* for multiclass, this is effectively the min access class */
  6    24     2 multiclass bit (1) aligned;
  6    25 
  6    26 /* END INCLUDE FILE ... entry_access_info.incl.pl1 */
      964 
      965  /* BEGIN INCLUDE FILE ... mseg_operations_.incl.pl1 */
  7     2 /* Created:  April 1985 by G. Palter */
  7     3 
  7     4 /* format: style3,linecom */
  7     5 
  7     6 /* The defined message segment primitive operations (mseg_) */
  7     7 
  7     8 declare	(
  7     9 	mseg_operations_$add_acl_entries_seg,
  7    10 	mseg_operations_$add_message,
  7    11 	mseg_operations_$chname_seg,
  7    12 	mseg_operations_$close_seg,
  7    13 	mseg_operations_$compact_seg,
  7    14 	mseg_operations_$copy_seg_source,
  7    15 	mseg_operations_$copy_seg_target,
  7    16 	mseg_operations_$count_messages,
  7    17 	mseg_operations_$create_seg,
  7    18 	mseg_operations_$delete_acl_entries_seg,
  7    19 	mseg_operations_$delete_message,
  7    20 	mseg_operations_$delete_seg,
  7    21 	mseg_operations_$get_salvaged_flag_seg,
  7    22 	mseg_operations_$get_wakeup_state_seg,
  7    23 	mseg_operations_$initiate_seg,
  7    24 	mseg_operations_$list_acl_seg,
  7    25 	mseg_operations_$list_acl_entries_seg,
  7    26 	mseg_operations_$open_seg,
  7    27 	mseg_operations_$read_message,
  7    28 	mseg_operations_$replace_acl_seg,
  7    29 	mseg_operations_$reset_salvaged_flag_seg,
  7    30 	mseg_operations_$reset_wakeup_state_seg,
  7    31 	mseg_operations_$set_max_length_seg,
  7    32 	mseg_operations_$set_safety_switch_seg,
  7    33 	mseg_operations_$set_wakeup_state_seg,
  7    34 	mseg_operations_$update_message
  7    35 	)		bit (36) aligned external;
  7    36 
  7    37 /* END INCLUDE FILE ... mseg_operations_.incl.pl1 */
      965 
      966  /* begin include file - access_audit_eventflags.incl.pl1 */
  8     2 /* NOTE: This include file has an ALM counterpart made with cif.
  8     3*Keep it up to date. */
  8     4 
  8     5 dcl 1 audit_event_flags	based aligned,
  8     6       2 special_op	bit (1) unal,  /* special sys operation */
  8     7       2 grant	bit (1) unal,  /* operation was successful */
  8     8       2 admin_op	bit (1) unal,  /* administrative operation */
  8     9       2 priv_op	bit (1) unal,  /* privileged operation */
  8    10       2 cc_1_10	bit (1) unal,  /* small covert channel */
  8    11       2 cc_10_100	bit (1) unal,  /* moderate covert channel */
  8    12       2 receiver	bit (1) unal,  /* on receiving end of channel */
  8    13       2 pad	bit (29) unal;
  8    14 
  8    15 /* end include file - access_audit_eventflags.incl.pl1 */
      966 
      967 
      968 
      969 /* BEGIN MESSAGE DOCUMENTATION
      970*
      971*
      972*   Message:
      973*   Audit (mseg_$reset_salvaged_flag_seg): GRANTED modifying message segment attributes
      974*	ADDED_INFO <Message segment salvage flag reset.>
      975*
      976*   S:	$access_audit
      977*
      978*   T:	$run
      979*
      980*   M:	The salvaged indicator of a message segment or mailbox was reset at
      981*	the user's request.  Repeated occurences of this event over a short
      982*	period of time could indicate an attempt to exploit a moderate
      983*	bandwidth covert channel.  ADDED_INFO will identify the user and
      984*	segment in question.
      985*
      986*   A:	$notify_ssa
      987*
      988*
      989*   END MESSAGE DOCUMENTATION */
      990 
      991 /* format: on */
      992 
      993      end mseg_segment_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1151.7  mseg_segment_.pl1                 >udd>sm>ds>w>ml>mseg_segment_.pl1
959          1    05/17/85  0719.0  mseg_data_.incl.pl1               >ldd>incl>mseg_data_.incl.pl1
960          2    05/17/85  0715.7  mseg_segment.incl.pl1             >ldd>incl>mseg_segment.incl.pl1
961          3    05/17/85  0715.7  mseg_wakeup_state.incl.pl1        >ldd>incl>mseg_wakeup_state.incl.pl1
962          4    05/17/85  0715.6  mseg_operation.incl.pl1           >ldd>incl>mseg_operation.incl.pl1
963          5    01/10/85  2102.8  mseg_message_info.incl.pl1        >ldd>incl>mseg_message_info.incl.pl1
964          6    05/17/85  0715.5  entry_access_info.incl.pl1        >ldd>incl>entry_access_info.incl.pl1
965          7    05/17/85  0715.7  mseg_operations_.incl.pl1         >ldd>incl>mseg_operations_.incl.pl1
966          8    01/30/85  1623.9  access_audit_eventflags.incl.pl1  >ldd>incl>access_audit_eventflags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
MSEG_MESSAGE_INFO_V1            000000 constant        char(8)                  initial dcl 5-28 ref 917
MSEG_READ_AFTER_SPECIFIED              constant        fixed bin(17,0)          initial dcl 5-30 ref 944
MSEG_READ_FIRST                        constant        fixed bin(17,0)          initial dcl 5-30 ref 926
MSEG_SEGMENT_SENTINEL           000004 constant        bit(36)                  initial dcl 2-73 ref 877
MSEG_SEGMENT_VERSION_5                 constant        fixed bin(17,0)          initial dcl 2-70 ref 878
MSEG_WAKEUP_STATE_VERSION_1     000002 constant        char(8)                  initial packed unaligned dcl 3-41 ref 562 567 708
P_code                                 parameter       fixed bin(35,0)          dcl 38 set ref 177 359 503 521 583 616 635 696 782*
                                                                                  803*
P_compaction_ratio                     parameter       float bin(27)            dcl 40 ref 177 205 215
P_error_on_target                      parameter       bit(1)                   dcl 46 set ref 359 472*
P_max_length                           parameter       fixed bin(19,0)          dcl 50 set ref 635 668 671 683*
P_mseg_operation_ptr                   parameter       pointer                  dcl 36 ref 177 503 521 583 616 635 696 749
P_salvaged_flag                        parameter       bit(1)                   dcl 48 set ref 503 511* 514*
P_source_mseg_operation_ptr            parameter       pointer                  dcl 42 ref 359 392
P_target_mseg_operation_ptr            parameter       pointer                  dcl 44 ref 359 375
SOURCE                                 constant        fixed bin(17,0)          initial dcl 66 ref 288 316 390 404 445 925 943
TARGET                                 constant        fixed bin(17,0)          initial dcl 66 ref 373 409 451 472 931
TRUNCATE_ALL_BUT_THE_LOCKWORD   000026 constant        fixed bin(19,0)          initial dcl 125 set ref 290*
access_audit_r1_$log_obj_ptr    000030 constant        entry                    external dcl 140 ref 606
access_class            260            based           bit(72)                  level 3 in structure "mseg_operation" dcl 4-24
                                                                                  in procedure "mseg_segment_" set ref 570*
access_class             26            based           bit(72)                  level 5 in structure "mseg_segment" dcl 2-28
                                                                                  in procedure "mseg_segment_" set ref 713*
access_info             115            based           structure                level 2 dcl 4-24
access_info_valid        24(03) 001004 automatic       bit(1)                   level 3 packed packed unaligned dcl 104 set ref 250*
access_operations_$mseg_attr_mod
                                000010 external static bit(36)                  dcl 127 set ref 606*
add_message_info_all_valid
                         24(10)        based           bit(1)                   level 3 packed packed unaligned dcl 60 set ref 915*
addr                                                   builtin function         dcl 169 ref 261 566 647 848 853 855
aim_util_$get_access_class      000032 constant        entry                    external dcl 142 ref 713
an_operation                    001004 automatic       structure                level 1 dcl 104 set ref 249* 261
audit_event_flags                      based           structure                level 1 dcl 8-5
authorization            10            based           bit(72)                  level 3 dcl 4-24 set ref 713*
bit_idx                         001600 automatic       fixed bin(24,0)          dcl 833 set ref 840* 841 841* 854* 855 855*
block_map               520            based           structure                level 2 dcl 2-28
block_size               15            based           fixed bin(17,0)          level 3 in structure "mseg_segment" dcl 2-28
                                                                                  in procedure "mseg_segment_" set ref 218 218 649*
                                                                                  655 655* 671 673 673
block_size               15            based           fixed bin(17,0)          level 2 in structure "target_mseg_segment_header"
                                                                                  dcl 79 in procedure "mseg_segment_" set ref 292
                                                                                  880* 881 884 884
call_admin_gate          24(08)        based           bit(1)                   level 3 packed packed unaligned dcl 4-24 ref 600
caller                    4            based           structure                level 2 dcl 4-24
cc_10_100                 0(05) 001270 automatic       bit(1)                   level 2 packed packed unaligned dcl 106 set ref 605*
char_idx                        001602 automatic       fixed bin(21,0)          dcl 834 set ref 848* 850 853 855 859
cleanup                         001416 stack reference condition                dcl 172 ref 186 368 507 525 587 620 639 700
code                            000105 automatic       fixed bin(35,0)          dcl 71 set ref 191 191* 241* 242 242* 254* 255 255*
                                                                                  263* 267 267* 377* 381 381* 394* 398 398* 405* 406
                                                                                  406* 410* 411 411* 514 517* 530 530* 592 592* 625
                                                                                  625* 653 660* 683* 685 692* 705 705* 728* 751*
                                                                                  927* 929 933* 934 934* 945* 949 949*
compacted_segment                      based           bit(36)                  array dcl 96 set ref 296* 296
compacted_size                  000260 automatic       fixed bin(19,0)          dcl 97 set ref 292* 296
control_flags           223            based           structure                level 3 packed packed unaligned dcl 55 set ref 918*
copy                                                   builtin function         dcl 169 ref 689 893
currentsize                                            builtin function         dcl 169 ref 673 884
date_time_last_salvaged
                          4            based           fixed bin(71,0)          level 2 dcl 79 set ref 871*
divide                                                 builtin function         dcl 169 ref 671 673 673 847 881 884 884
entry_access_info                      based           structure                level 1 dcl 6-12
error_table_$action_not_performed
                                000012 external static fixed bin(35,0)          dcl 130 set ref 662*
error_table_$bad_segment        000014 external static fixed bin(35,0)          dcl 130 ref 451 455
error_table_$clnzero            000016 external static fixed bin(35,0)          dcl 130 set ref 384*
error_table_$invalid_max_length 000020 external static fixed bin(35,0)          dcl 130 set ref 414* 668* 677*
error_table_$messages_off       000022 external static fixed bin(35,0)          dcl 130 set ref 528* 533*
error_table_$no_message         000024 external static fixed bin(35,0)          dcl 130 ref 949
error_table_$rqover             000026 external static fixed bin(35,0)          dcl 130 set ref 265* 316 316* 379* 445 445* 455 703*
                                                                                  797* 803
event_channel             2     001446 automatic       fixed bin(71,0)          level 3 in structure "old_wakeup_state" dcl 550
                                                                                  in procedure "get_wakeup_state_seg" set ref 569
event_channel            24            based           fixed bin(71,0)          level 5 in structure "mseg_segment" dcl 2-28
                                                                                  in procedure "mseg_segment_" set ref 711*
event_channel           256            based           fixed bin(71,0)          level 3 in structure "mseg_operation" dcl 4-24
                                                                                  in procedure "mseg_segment_" set ref 569* 711
flags                    24            based           structure                level 2 in structure "source_mseg_operation" dcl 55
                                                                                  in procedure "mseg_segment_"
flags                    24            based           structure                level 2 in structure "target_mseg_operation" dcl 60
                                                                                  in procedure "mseg_segment_"
flags                    24     001004 automatic       structure                level 2 in structure "an_operation" dcl 104
                                                                                  in procedure "mseg_segment_"
flags                    16            based           structure                level 3 in structure "mseg_segment" dcl 2-28
                                                                                  in procedure "mseg_segment_"
flags                    24            based           structure                level 2 in structure "mseg_operation" dcl 4-24
                                                                                  in procedure "mseg_segment_"
flags                   254            based           structure                level 3 in structure "mseg_operation" dcl 4-24
                                                                                  in procedure "mseg_segment_" set ref 568* 710
flags                    22            based           structure                level 5 in structure "mseg_segment" dcl 2-28
                                                                                  in procedure "mseg_segment_" set ref 710*
flags                    16            based           structure                level 2 in structure "target_mseg_segment_header"
                                                                                  dcl 79 in procedure "mseg_segment_" set ref 873*
float                                                  builtin function         dcl 169 ref 215 215
free_source_message_bits        001406 automatic       bit(1)                   dcl 117 set ref 182* 321 339 364* 459 485 923* 952*
get_process_id_                 000034 constant        entry                    external dcl 144 ref 714
get_system_free_area_           000036 constant        entry                    external dcl 145 ref 921
get_temp_segment_               000040 constant        entry                    external dcl 147 ref 254
grant                     0(01) 001270 automatic       bit(1)                   level 2 packed packed unaligned dcl 106 set ref 604*
hash_table              120            based           structure                level 2 dcl 79 set ref 875*
hcs_$get_max_length_seg         000042 constant        entry                    external dcl 148 ref 241 405 410
hcs_$set_max_length_seg         000044 constant        entry                    external dcl 150 ref 683
hcs_$truncate_seg               000046 constant        entry                    external dcl 152 ref 290
header                                 based           structure                level 2 dcl 2-28
header_msg                             based           bit(36)                  array dcl 2-84 ref 566
header_msg_access_class                defined         bit(72)                  dcl 2-79 ref 570
initialize_block_map            001002 automatic       bit(1)                   dcl 101 set ref 650* 657* 685
length                                                 builtin function         dcl 169 ref 836 848
local_aef                       001270 automatic       structure                level 1 dcl 106 set ref 603* 606 606
local_mseg_segment_header       000262 automatic       structure                level 1 dcl 99 set ref 647 673
lock_id                 263            based           bit(36)                  level 3 in structure "mseg_operation" dcl 4-24
                                                                                  in procedure "mseg_segment_" set ref 572*
lock_id                  31            based           bit(36)                  level 5 in structure "mseg_segment" dcl 2-28
                                                                                  in procedure "mseg_segment_" set ref 715*
lock_id                   1     001446 automatic       bit(36)                  level 3 in structure "old_wakeup_state" dcl 550
                                                                                  in procedure "get_wakeup_state_seg" set ref 572
low                                                    builtin function         dcl 169 ref 848
map                     520            based           bit                      level 3 packed packed unaligned dcl 2-28 set ref
                                                                                  208* 689* 893*
message_chain            10            based           structure                level 2 dcl 79 set ref 872*
message_code            222            based           fixed bin(17,0)          level 3 dcl 55 set ref 926* 944*
message_info            220            based           structure                level 2 in structure "source_mseg_operation" dcl 55
                                                                                  in procedure "mseg_segment_" set ref 932
message_info            220            based           structure                level 2 in structure "target_mseg_operation" dcl 60
                                                                                  in procedure "mseg_segment_" set ref 932*
mod                                                    builtin function         dcl 169 ref 218 838 840 844
ms_len                  226            based           fixed bin(24,0)          level 3 dcl 55 ref 324 324 342 342 462 462 488 488
                                                                                  939 939
ms_ptr                  224            based           pointer                  level 3 dcl 55 set ref 321 324 325* 339 342 343* 459
                                                                                  462 463* 485 488 489* 919* 937 939 940*
mseg_data_$block_size           000070 external static fixed bin(35,0)          dcl 1-5 ref 649 655 880
mseg_data_$lock_id              000066 external static bit(72)                  dcl 1-4 ref 715
mseg_dir_name                   001322 automatic       char(168)                packed unaligned dcl 114 set ref 751*
mseg_entryname                  001374 automatic       char(32)                 packed unaligned dcl 115 set ref 751*
mseg_message_$add_message_for_mseg
                                000050 constant        entry                    external dcl 153 ref 933
mseg_message_$read_message_for_mseg
                                000052 constant        entry                    external dcl 155 ref 927 945
mseg_message_info                      based           structure                level 1 dcl 5-9
mseg_operation                         based           structure                level 1 dcl 4-24
mseg_operation_ptr              001434 automatic       pointer                  dcl 4-19 set ref 234 239 562 567 568 569 570 571 572
                                                                                  575 600 600 600 606 683 710 711 713 733* 749* 751*
                                                                                  779 779* 800 800* 818*
mseg_operations_$compact_seg    000072 external static bit(36)                  dcl 7-8 set ref 188*
mseg_operations_$copy_seg_source
                                000074 external static bit(36)                  dcl 7-8 set ref 394*
mseg_operations_$copy_seg_target
                                000076 external static bit(36)                  dcl 7-8 set ref 263* 377*
mseg_operations_$get_salvaged_flag_seg
                                000100 external static bit(36)                  dcl 7-8 set ref 509*
mseg_operations_$get_wakeup_state_seg
                                000102 external static bit(36)                  dcl 7-8 set ref 527*
mseg_operations_$reset_salvaged_flag_seg
                                000104 external static bit(36)                  dcl 7-8 set ref 589*
mseg_operations_$reset_wakeup_state_seg
                                000106 external static bit(36)                  dcl 7-8 set ref 622*
mseg_operations_$set_max_length_seg
                                000110 external static bit(36)                  dcl 7-8 set ref 641*
mseg_operations_$set_wakeup_state_seg
                                000112 external static bit(36)                  dcl 7-8 set ref 702*
mseg_ptr                110            based           pointer                  level 2 in structure "mseg_operation" dcl 4-24
                                                                                  in procedure "mseg_segment_" set ref 683*
mseg_ptr                110     001004 automatic       pointer                  level 2 in structure "an_operation" dcl 104
                                                                                  in procedure "mseg_segment_" set ref 258*
mseg_ptr                        001432 automatic       pointer                  dcl 2-68 in procedure "mseg_segment_" set ref 194
                                                                                  208 208 209 210 218 218 235 237 241* 514 533 562
                                                                                  562 566 570 595 598 606* 628 629 647* 648 649 655
                                                                                  655 662 671 673 673 687 688 689 708 710 711 713
                                                                                  714 715 717 719 751*
mseg_ptr_valid           24(01) 001004 automatic       bit(1)                   level 3 packed packed unaligned dcl 104 set ref 250*
                                                                                  259*
mseg_segment                           based           structure                level 1 dcl 2-28
mseg_utils_$abort_operation     000054 constant        entry                    external dcl 157 ref 492 494 818
mseg_utils_$begin_operation     000056 constant        entry                    external dcl 159 ref 263 377 394 751
mseg_utils_$finish_operation    000060 constant        entry                    external dcl 162 ref 466 469 779 800
mseg_utils_$salvage_for_cause   000062 constant        entry                    external dcl 164 ref 316 445 454
mseg_wakeup_state                      based           structure                level 1 dcl 3-24
multiclass              217            based           bit(1)                   level 3 dcl 4-24 ref 600
n_bits                          001577 automatic       fixed bin(24,0)          dcl 833 set ref 836* 838 840 841 841 844* 844 844
                                                                                  847
n_blocks_allocated       12            based           fixed bin(18,0)          level 3 in structure "mseg_segment" dcl 2-28
                                                                                  in procedure "mseg_segment_" set ref 208 208 208
                                                                                  209 687* 689 893
n_blocks_allocated       12            based           fixed bin(18,0)          level 2 in structure "target_mseg_segment_header"
                                                                                  dcl 79 in procedure "mseg_segment_" set ref 292
                                                                                  881* 884 890
n_blocks_unused          13            based           fixed bin(18,0)          level 3 in structure "mseg_segment" dcl 2-28
                                                                                  in procedure "mseg_segment_" set ref 210 688*
n_blocks_unused          13            based           fixed bin(18,0)          level 2 in structure "target_mseg_segment_header"
                                                                                  dcl 79 in procedure "mseg_segment_" set ref 292
                                                                                  890*
n_chars                         001601 automatic       fixed bin(21,0)          dcl 834 set ref 847* 848 853
n_messages               14            based           fixed bin(18,0)          level 2 in structure "target_mseg_segment_header"
                                                                                  dcl 79 in procedure "mseg_segment_" set ref 384
                                                                                  871*
n_messages               14            based           fixed bin(18,0)          level 3 in structure "mseg_segment" dcl 2-28
                                                                                  in procedure "mseg_segment_" set ref 194 648* 662
n_new_blocks                    001411 automatic       fixed bin(18,0)          dcl 122 set ref 671* 673 677 687 688
n_new_header_blocks             001412 automatic       fixed bin(18,0)          dcl 122 set ref 673* 677 688 689 884* 890 893
n_used_or_wasted_blocks         001414 automatic       fixed bin(18,0)          dcl 122 set ref 209* 215 218
n_virgin_blocks                 001413 automatic       fixed bin(18,0)          dcl 122 set ref 208* 209 210
n_wasted_blocks                 001415 automatic       fixed bin(18,0)          dcl 122 set ref 210* 212 215 218
null                                                   builtin function         dcl 169 ref 181 310 313 321 325 339 343 346 349 363
                                                                                  459 463 466 469 485 489 606 606 733 779 800 919
                                                                                  937 940
old_wakeup_state                001446 automatic       structure                level 1 dcl 550 set ref 566*
operation_name                  001271 automatic       char(64)                 packed unaligned dcl 108 set ref 254* 312* 348* 377*
                                                                                  394* 606* 751* 927* 933* 945*
operation_specific_abort        001316 automatic       entry variable           dcl 111 set ref 184* 366* 730* 815 815
operation_specific_return       001312 automatic       entry variable           dcl 109 set ref 183* 365* 731* 776 776 797 797
p_bit_string                           parameter       bit                      packed unaligned dcl 829 set ref 826 836 841 848 853
p_code                                 parameter       fixed bin(35,0)          dcl 774 in procedure "return_from_operation" set ref
                                                                                  771 776* 782
p_code                                 parameter       fixed bin(35,0)          dcl 308 in procedure "return_from_compact_seg" ref
                                                                                  305 316 316
p_code                                 parameter       fixed bin(35,0)          dcl 443 in procedure "return_from_copy_seg" set ref
                                                                                  440 445 445 451 454* 455 455*
p_copy_source_wakeup_state             parameter       bit(1)                   dcl 868 ref 865 895
p_mseg_operation_id                    parameter       bit(36)                  dcl 747 set ref 744 751*
pad                      32            based           bit(36)                  array level 4 dcl 2-28 set ref 717*
process_id                4     001446 automatic       bit(36)                  level 3 in structure "old_wakeup_state" dcl 550
                                                                                  in procedure "get_wakeup_state_seg" set ref 571
process_id              262            based           bit(36)                  level 3 in structure "mseg_operation" dcl 4-24
                                                                                  in procedure "mseg_segment_" set ref 571*
process_id               30            based           bit(36)                  level 5 in structure "mseg_segment" dcl 2-28
                                                                                  in procedure "mseg_segment_" set ref 714*
record_quota_overflow           001424 stack reference condition                dcl 172 ref 275 298 422 428
release_temp_segment_           000064 constant        entry                    external dcl 166 ref 312 348
reserved                  2            based           bit(72)                  level 3 dcl 2-28 ref 570 570
rqo_detected                    001404 automatic       bit(1)                   dcl 117 set ref 189 263* 265 377* 379 394* 396 511
                                                                                  528 590 623 643 703 751*
rtrim                                                  builtin function         dcl 169 ref 848
salvage_if_errors               001405 automatic       bit(1)                   dcl 117 set ref 182* 273* 316 364* 420* 445
salvaged                 16(01)        based           bit(1)                   level 4 packed packed unaligned dcl 2-28 set ref 514
                                                                                  595 598*
segment_in_error                000104 automatic       fixed bin(17,0)          dcl 65 set ref 288* 316 373* 390* 404* 409* 445 451
                                                                                  472 925* 931* 943*
sentinel                  1            based           bit(36)                  level 2 dcl 79 set ref 877*
source_max_length               001407 automatic       fixed bin(19,0)          dcl 120 set ref 405* 414
source_mseg_dir_name            000176 automatic       char(168)                packed unaligned dcl 88 set ref 394*
source_mseg_entryname           000250 automatic       char(32)                 packed unaligned dcl 90 set ref 394*
source_mseg_message_bits               based           bit                      dcl 93 ref 324 342 462 488 939
source_mseg_operation                  based           structure                level 1 dcl 55 set ref 249
source_mseg_operation_ptr       000100 automatic       pointer                  dcl 57 set ref 234* 249 316* 321 324 324 324 325 339
                                                                                  342 342 342 343 363* 392* 394* 445* 459 462 462
                                                                                  462 463 469 469* 485 488 488 488 489 492* 897 897
                                                                                  899 913 917 918 919 926 927* 932 937 939 939 939
                                                                                  940 944 945*
source_mseg_ptr                 000174 automatic       pointer                  dcl 87 set ref 235* 290* 296 394* 405*
state                    20            based           structure                level 4 in structure "mseg_segment" dcl 2-28
                                                                                  in procedure "mseg_segment_" set ref 562
state                    20            based           structure                level 3 in structure "target_mseg_segment_header"
                                                                                  dcl 79 in procedure "mseg_segment_" set ref 897*
state                           001446 automatic       structure                level 2 in structure "old_wakeup_state" dcl 550
                                                                                  in procedure "get_wakeup_state_seg"
string                                                 builtin function         dcl 169 set ref 568* 568 603* 606 606 873* 918*
substr                                                 builtin function         dcl 169 ref 841 853 855
suppress_access_checks
                         24(07)        based           bit(1)                   level 3 in structure "target_mseg_operation" packed
                                                                                  packed unaligned dcl 60 in procedure
                                                                                  "mseg_segment_" set ref 913*
suppress_access_checks
                         24(07)        based           bit(1)                   level 3 in structure "mseg_operation" packed packed
                                                                                  unaligned dcl 4-24 in procedure "mseg_segment_"
                                                                                  ref 600
suppress_access_checks
                         24(07) 001004 automatic       bit(1)                   level 3 in structure "an_operation" packed packed
                                                                                  unaligned dcl 104 in procedure "mseg_segment_" set
                                                                                  ref 252*
suppress_access_checks
                         24(07)        based           bit(1)                   level 3 in structure "source_mseg_operation" packed
                                                                                  packed unaligned dcl 55 in procedure
                                                                                  "mseg_segment_" set ref 913*
switches                        001446 automatic       structure                level 3 dcl 550 set ref 568
system_area                            based           area(1024)               dcl 76 ref 324 342 462 488 939
system_area_ptr                 000106 automatic       pointer                  dcl 77 set ref 324 342 462 488 921* 927* 939 945*
target_max_length               001410 automatic       fixed bin(19,0)          dcl 120 set ref 241* 410* 414 881
target_mseg_dir_name            000112 automatic       char(168)                packed unaligned dcl 82 set ref 263* 377*
target_mseg_entryname           000164 automatic       char(32)                 packed unaligned dcl 84 set ref 263* 377*
target_mseg_operation                  based           structure                level 1 dcl 60
target_mseg_operation_ptr       000102 automatic       pointer                  dcl 62 set ref 261* 263* 363* 375* 377* 454* 466
                                                                                  466* 494* 913 915 932 933*
target_mseg_ptr                 000110 automatic       pointer                  dcl 81 set ref 181* 254* 258 263* 292 292 292 296
                                                                                  310 312* 313* 346 348* 349* 377* 384 384 410* 871
                                                                                  871 872 873 874 875 877 878 880 881 881 884 884
                                                                                  884 884 890 890 893 897 899
target_mseg_segment_header             based           structure                level 1 dcl 79 set ref 884
the_bits_as_chars                      based           char                     dcl 830 ref 848 853
the_char                        001576 automatic       char(1)                  dcl 831 set ref 853* 855
the_char_as_bits                       based           bit(9)                   dcl 832 ref 855
unspec                                                 builtin function         dcl 169 set ref 566* 566 629* 717* 872* 874* 875*
validation_level          4            based           fixed bin(3,0)           level 3 dcl 4-24 set ref 606*
version                  20            based           char(8)                  level 5 in structure "mseg_segment" packed packed
                                                                                  unaligned dcl 2-28 in procedure "mseg_segment_"
                                                                                  set ref 562 708*
version                  17            based           fixed bin(17,0)          level 2 in structure "target_mseg_segment_header"
                                                                                  dcl 79 in procedure "mseg_segment_" set ref 878*
version                 252            based           char(8)                  level 3 in structure "mseg_operation" packed packed
                                                                                  unaligned dcl 4-24 in procedure "mseg_segment_"
                                                                                  set ref 567*
version                 220            based           char(8)                  level 3 in structure "source_mseg_operation" dcl 55
                                                                                  in procedure "mseg_segment_" set ref 917*
wakeup_state            252            based           structure                level 2 in structure "source_mseg_operation" dcl 55
                                                                                  in procedure "mseg_segment_" ref 897
wakeup_state             20            based           structure                level 3 in structure "mseg_segment" dcl 2-28
                                                                                  in procedure "mseg_segment_" set ref 566 629*
wakeup_state            252            based           structure                level 2 in structure "mseg_operation" dcl 4-24
                                                                                  in procedure "mseg_segment_" set ref 562*
wakeup_state             20            based           structure                level 2 in structure "target_mseg_segment_header"
                                                                                  dcl 79 in procedure "mseg_segment_" set ref 874*
wakeup_state_set         16(02)        based           bit(1)                   level 3 in structure "target_mseg_segment_header"
                                                                                  packed packed unaligned dcl 79 in procedure
                                                                                  "mseg_segment_" set ref 384 899*
wakeup_state_set         16(02)        based           bit(1)                   level 4 in structure "mseg_segment" packed packed
                                                                                  unaligned dcl 2-28 in procedure "mseg_segment_"
                                                                                  set ref 237 533 628* 719*
wakeup_state_valid       24(06)        based           bit(1)                   level 3 in structure "mseg_operation" packed packed
                                                                                  unaligned dcl 4-24 in procedure "mseg_segment_"
                                                                                  set ref 239* 575*
wakeup_state_valid       24(06)        based           bit(1)                   level 3 in structure "source_mseg_operation" packed
                                                                                  packed unaligned dcl 55 in procedure
                                                                                  "mseg_segment_" ref 897 899

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ENTRY_ACCESS_INFO_VERSION_1            internal static char(8)                  initial packed unaligned dcl 6-9
MSEG_OPERATION_VERSION_1               internal static fixed bin(17,0)          initial dcl 4-20
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 5-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 5-38
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 5-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 5-38
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 5-30
MSEG_TYPE_MBX                          internal static fixed bin(17,0)          initial dcl 4-21
MSEG_TYPE_MS                           internal static fixed bin(17,0)          initial dcl 4-22
entry_access_info_ptr                  automatic       pointer                  dcl 6-8
header_msg_present                     defined         bit(1)                   packed unaligned dcl 2-82
mseg_data_$admin_ring                  external static fixed bin(3,0)           dcl 1-8
mseg_data_$execution_ring              external static fixed bin(3,0)           dcl 1-9
mseg_data_$group_id                    external static char(32)                 packed unaligned dcl 1-11
mseg_data_$max_message_size            external static fixed bin(35,0)          dcl 1-6
mseg_data_$process_max_authorization   external static bit(72)                  dcl 1-10
mseg_data_$template_operation          external static bit(36)                  dcl 1-7
mseg_message_info_ptr                  automatic       pointer                  dcl 5-7
mseg_operations_$add_acl_entries_seg   external static bit(36)                  dcl 7-8
mseg_operations_$add_message           external static bit(36)                  dcl 7-8
mseg_operations_$chname_seg            external static bit(36)                  dcl 7-8
mseg_operations_$close_seg             external static bit(36)                  dcl 7-8
mseg_operations_$count_messages        external static bit(36)                  dcl 7-8
mseg_operations_$create_seg            external static bit(36)                  dcl 7-8
mseg_operations_$delete_acl_entries_seg
                                       external static bit(36)                  dcl 7-8
mseg_operations_$delete_message        external static bit(36)                  dcl 7-8
mseg_operations_$delete_seg            external static bit(36)                  dcl 7-8
mseg_operations_$initiate_seg          external static bit(36)                  dcl 7-8
mseg_operations_$list_acl_entries_seg  external static bit(36)                  dcl 7-8
mseg_operations_$list_acl_seg          external static bit(36)                  dcl 7-8
mseg_operations_$open_seg              external static bit(36)                  dcl 7-8
mseg_operations_$read_message          external static bit(36)                  dcl 7-8
mseg_operations_$replace_acl_seg       external static bit(36)                  dcl 7-8
mseg_operations_$set_safety_switch_seg external static bit(36)                  dcl 7-8
mseg_operations_$update_message        external static bit(36)                  dcl 7-8
mseg_wakeup_state_ptr                  automatic       pointer                  dcl 3-38

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN_FROM_OPERATION           002133 constant        label                    dcl 787 ref 783 804
abort_compact_seg               002242 constant        entry                    internal dcl 336 ref 184
abort_copy_seg                  002461 constant        entry                    internal dcl 482 ref 366
begin_operation                 002602 constant        entry                    internal dcl 744 ref 188 509 527 589 622 641 702
copy_messages                   003305 constant        entry                    internal dcl 910 ref 279 426
find_last_one_bit               003043 constant        entry                    internal dcl 826 ref 208
get_wakeup_state_seg            002527 constant        entry                    internal dcl 546 ref 237 536
initialize_target_header        003205 constant        entry                    internal dcl 865 ref 277 424
mseg_segment_                   000056 constant        entry                    external dcl 28
mseg_segment_$compact_seg       000070 constant        entry                    external dcl 177
mseg_segment_$copy_seg          000541 constant        entry                    external dcl 359
mseg_segment_$get_salvaged_flag_seg
                                001120 constant        entry                    external dcl 503
mseg_segment_$get_wakeup_state_seg
                                001207 constant        entry                    external dcl 521
mseg_segment_$reset_salvaged_flag_seg
                                001312 constant        entry                    external dcl 583
mseg_segment_$reset_wakeup_state_seg
                                001500 constant        entry                    external dcl 616
mseg_segment_$set_max_length_seg
                                001573 constant        entry                    external dcl 635
mseg_segment_$set_wakeup_state_seg
                                002003 constant        entry                    external dcl 696
nulle                           002656 constant        entry                    internal dcl 762 ref 730 731 776 797 815
operation_was_aborted           003004 constant        entry                    internal dcl 812 ref 186 368 507 525 587 620 639 700
return_from_compact_seg         002135 constant        entry                    internal dcl 305 ref 183
return_from_copy_seg            002323 constant        entry                    internal dcl 440 ref 365
return_from_operation           002664 constant        entry                    internal dcl 771 ref 189 191 194 212 215 218 242 255
                                                                                  265 267 299 379 381 384 396 398 406 411 414 430
                                                                                  517 528 530 533 538 590 592 612 623 625 631 660
                                                                                  662 668 677 692 703 705 721 934 949
return_rqover_from_operation    002730 constant        entry                    internal dcl 794 ref 275 422
setup_operation                 002570 constant        entry                    internal dcl 725 ref 180 362 506 524 586 619 638 699

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4574        4710    3526        4604
Length      5406    3526       114         462    1045           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mseg_segment_                      1106 external procedure  is an external procedure.  
on unit on line 186                  64 on unit               
on unit on line 275                  64 on unit               
return_from_compact_seg              80 internal procedure  is assigned to an entry variable.  
abort_compact_seg                    80 internal procedure  is assigned to an entry variable.  
on unit on line 368                  64 on unit               
on unit on line 422                  64 on unit               
return_from_copy_seg                 70 internal procedure  is assigned to an entry variable.  
abort_copy_seg                       68 internal procedure  is assigned to an entry variable.  
on unit on line 507                  64 on unit               
on unit on line 525                  64 on unit               
get_wakeup_state_seg                    internal procedure  shares stack frame of external procedure mseg_segment_.  
on unit on line 587                  64 on unit               
on unit on line 620                  64 on unit               
on unit on line 639                  64 on unit               
on unit on line 700                  64 on unit               
setup_operation                         internal procedure  shares stack frame of external procedure mseg_segment_.  
begin_operation                         internal procedure  shares stack frame of external procedure mseg_segment_.  
nulle                                64 internal procedure  is assigned to an entry variable.  
return_from_operation                   internal procedure  shares stack frame of external procedure mseg_segment_.  
return_rqover_from_operation         70 internal procedure  is called by several nonquick procedures.  
operation_was_aborted                68 internal procedure  is called by several nonquick procedures.  
find_last_one_bit                       internal procedure  shares stack frame of external procedure mseg_segment_.  
initialize_target_header                internal procedure  shares stack frame of external procedure mseg_segment_.  
copy_messages                           internal procedure  shares stack frame of external procedure mseg_segment_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mseg_segment_            000100 source_mseg_operation_ptr   mseg_segment_
                         000102 target_mseg_operation_ptr   mseg_segment_
                         000104 segment_in_error            mseg_segment_
                         000105 code                        mseg_segment_
                         000106 system_area_ptr             mseg_segment_
                         000110 target_mseg_ptr             mseg_segment_
                         000112 target_mseg_dir_name        mseg_segment_
                         000164 target_mseg_entryname       mseg_segment_
                         000174 source_mseg_ptr             mseg_segment_
                         000176 source_mseg_dir_name        mseg_segment_
                         000250 source_mseg_entryname       mseg_segment_
                         000260 compacted_size              mseg_segment_
                         000262 local_mseg_segment_header   mseg_segment_
                         001002 initialize_block_map        mseg_segment_
                         001004 an_operation                mseg_segment_
                         001270 local_aef                   mseg_segment_
                         001271 operation_name              mseg_segment_
                         001312 operation_specific_return   mseg_segment_
                         001316 operation_specific_abort    mseg_segment_
                         001322 mseg_dir_name               mseg_segment_
                         001374 mseg_entryname              mseg_segment_
                         001404 rqo_detected                mseg_segment_
                         001405 salvage_if_errors           mseg_segment_
                         001406 free_source_message_bits    mseg_segment_
                         001407 source_max_length           mseg_segment_
                         001410 target_max_length           mseg_segment_
                         001411 n_new_blocks                mseg_segment_
                         001412 n_new_header_blocks         mseg_segment_
                         001413 n_virgin_blocks             mseg_segment_
                         001414 n_used_or_wasted_blocks     mseg_segment_
                         001415 n_wasted_blocks             mseg_segment_
                         001432 mseg_ptr                    mseg_segment_
                         001434 mseg_operation_ptr          mseg_segment_
                         001446 old_wakeup_state            get_wakeup_state_seg
                         001576 the_char                    find_last_one_bit
                         001577 n_bits                      find_last_one_bit
                         001600 bit_idx                     find_last_one_bit
                         001601 n_chars                     find_last_one_bit
                         001602 char_idx                    find_last_one_bit

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_e_as              alloc_bit_temp      call_ent_var        call_ext_out_desc   call_ext_out
call_int_other      return_mac          make_label_var      tra_ext_1           mdfx1               mdfx3
enable_op           shorten_stack       ext_entry           int_entry           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
access_audit_r1_$log_obj_ptr  aim_util_$get_access_class    get_process_id_               get_system_free_area_
get_temp_segment_             hcs_$get_max_length_seg       hcs_$set_max_length_seg       hcs_$truncate_seg
mseg_message_$add_message_for_mseg                          mseg_message_$read_message_for_mseg
mseg_utils_$abort_operation   mseg_utils_$begin_operation   mseg_utils_$finish_operation  mseg_utils_$salvage_for_cause
release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$mseg_attr_mod                            error_table_$action_not_performed
error_table_$bad_segment      error_table_$clnzero          error_table_$invalid_max_length
error_table_$messages_off     error_table_$no_message       error_table_$rqover           mseg_data_$block_size
mseg_data_$lock_id            mseg_operations_$compact_seg  mseg_operations_$copy_seg_source
mseg_operations_$copy_seg_target                            mseg_operations_$get_salvaged_flag_seg
mseg_operations_$get_wakeup_state_seg                       mseg_operations_$reset_salvaged_flag_seg
mseg_operations_$reset_wakeup_state_seg                     mseg_operations_$set_max_length_seg
mseg_operations_$set_wakeup_state_seg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     28 000055        31 000063       177 000064       180 000100       181 000101       182 000103       183 000105
    184 000110       186 000113       188 000135       189 000144       191 000153       194 000157       205 000165
    208 000170       209 000214       210 000217       212 000222       215 000226       218 000242       234 000261
    235 000263       237 000265       239 000272       241 000274       242 000307       249 000313       250 000317
    252 000323       254 000325       255 000346       258 000352       259 000354       261 000356       263 000360
    265 000427       267 000442       273 000446       275 000450       277 000472       279 000476       288 000477
    290 000501       292 000515       296 000522       298 000527       299 000530       359 000533       362 000551
    363 000552       364 000555       365 000557       366 000562       368 000565       373 000607       375 000611
    377 000615       379 000661       381 000674       384 000700       390 000715       392 000717       394 000723
    396 000767       398 000776       404 001002       405 001004       406 001017       409 001023       410 001025
    411 001040       414 001044       420 001056       422 001060       424 001102       426 001106       428 001107
    430 001110       503 001113       506 001130       507 001131       509 001153       511 001162       514 001170
    517 001200       521 001202       524 001217       525 001220       527 001242       528 001251       530 001264
    533 001270       536 001303       538 001304       583 001307       586 001322       587 001323       589 001345
    590 001354       592 001363       595 001367       598 001373       600 001375       603 001406       604 001407
    605 001411       606 001413       612 001472       616 001475       619 001510       620 001511       622 001533
    623 001542       625 001551       628 001555       629 001560       631 001563       635 001566       638 001603
    639 001604       641 001626       643 001635       647 001640       648 001642       649 001643       650 001646
    651 001647       653 001650       655 001652       657 001660       658 001662       660 001663       662 001665
    668 001677       671 001711       673 001716       677 001725       683 001736       685 001753       687 001757
    688 001762       689 001764       690 001775       692 001776       696 002000       699 002013       700 002014
    702 002036       703 002045       705 002060       708 002064       710 002070       711 002073       713 002075
    714 002106       715 002120       717 002123       719 002126       721 002130       787 002133       305 002134
    310 002142       312 002147       313 002170       316 002173       321 002217       324 002227       325 002234
    328 002240       336 002241       339 002247       342 002257       343 002264       346 002270       348 002274
    349 002316       352 002321       440 002322       445 002330       449 002354       451 002355       454 002362
    455 002372       459 002401       462 002411       463 002416       466 002422       469 002435       472 002451
    474 002457       482 002460       485 002466       488 002476       489 002503       492 002507       494 002516
    496 002526       546 002527       562 002530       566 002542       567 002545       568 002551       569 002553
    570 002555       571 002561       572 002563       575 002565       577 002567       725 002570       728 002571
    730 002572       731 002575       733 002577       735 002601       744 002602       749 002604       751 002610
    754 002654       762 002655       765 002663       771 002664       776 002666       779 002710       782 002723
    783 002726       794 002727       797 002735       800 002760       803 002774       804 003000       812 003003
    815 003011       818 003032       820 003042       826 003043       836 003054       838 003061       840 003064
    841 003073       843 003106       844 003110       847 003116       848 003121       850 003135       853 003142
    854 003146       855 003153       857 003174       859 003177       865 003205       871 003207       872 003213
    873 003216       874 003217       875 003222       877 003225       878 003227       880 003231       881 003234
    884 003237       890 003246       893 003251       895 003262       897 003267       899 003300       902 003304
    910 003305       913 003306       915 003314       917 003316       918 003321       919 003322       921 003324
    923 003333       925 003335       926 003337       927 003342       929 003366       931 003370       932 003372
    933 003377       934 003420       937 003424       939 003431       940 003436       943 003441       944 003443
    945 003446       947 003472       949 003473       952 003500       954 003501


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
