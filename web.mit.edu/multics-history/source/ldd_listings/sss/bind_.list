	COMPILATION LISTING OF SEGMENT bind_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/12/86  1652.0 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
       15*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
       16*     Modified cleanup handler to work with new bound object being created in a
       17*     temp segment and then copied into the working dir.
       18*  2) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
       19*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1212):
       20*     Generate first_ref_traps must be called after make_defs because make_defs
       21*     my generate links when binding PASCAL objects. First ref traps must be
       22*     generated after links.
       23*                                                   END HISTORY COMMENTS */
       24 
       25 
       26 /* This is the main program of the binder.
       27*
       28*   Designed and initially coded by Michael J. Spier, August 19, 1970,
       29*   Completely revised by Michael J. Spier, December 23, 1971  */
       30 /* modified 75.06.20 by M. Weaver for separate static */
       31 /* modified 5/76 by M. Weaver  for -brief option */
       32 /* modified 1/77 by Melanie Weaver to call ext_link_$finish */
       33 /* modified 8/77 by Melanie Weaver to check for perprocess static in non-standard  */
       34 /* modified 9/78 by David Spector to release temp segments on cleanup */
       35 /* modified Dec 78 by David Spector to make repatch table automatically extensible */
       36 /* Modified 01/14/81 W. Olin Sibert for new format of input structure, and -force_order */
       37 /* Modified 01/21/81, WOS, to rename to bind_ so binder_ could remain "compatible" */
       38 /* Modified 05/3/83 by Melanie Weaver to add handler for fatal_binder_error condition */
       39 /* Modified  10/20/84 by M. Sharpe to use new binder_input_.incl.pl1; to check for bindfile
       40*   errors before wiping out the old bound segment */
       41 
       42 /* Warning: several places in the binder a fixed bin variable is referenced as
       43*   based bit or based char; currently, referencing them via addr(variable)
       44*   will make the pl1 compiler realize what is really being changed. */
       45 
       46 /* format: style4,^indattr,^indcomtxt */
       47 
       48 bind_: procedure (argp);
       49 
       50 declare  argp pointer;
       51 
       52 
       53 /* DECLARATION OF EXTERNAL ENTRIES */
       54 
       55 declare  relocate_symbol_ external entry ();
       56 declare  com_err_ external entry options (variable);
       57 declare  decode_link_$init external entry ();
       58 declare  dissect_object_ external entry (pointer);
       59 declare  dissect_object_$init external entry ();
       60 declare  ext_link_$init external entry ();
       61 declare  ext_link_$finish entry ();
       62 declare  generate_def_$init external entry ();
       63 declare  get_temp_segment_ external entry (char (*), ptr, fixed bin (35));
       64 declare  form_bind_map_ external entry (pointer, fixed bin (35));
       65 declare  form_link_info_ external entry (pointer, fixed bin (35));
       66 declare  get_wdir_ external entry () returns (char (168) aligned);
       67 declare  generate_first_ref_traps_ external entry ();
       68 declare  int_link_$init external entry ();
       69 declare  hcs_$set_bc_seg external entry (pointer, fixed bin (24), fixed bin (35));
       70 declare  hcs_$chname_seg ext entry (ptr, char (*) aligned, char (*) aligned, fixed bin (35));
       71 declare  ioa_ external entry options (variable);
       72 declare  ioa_$rs external entry options (variable);
       73 declare  incorporate_options_ external entry ();
       74 declare  make_bindmap_ external entry ();
       75 declare  make_defs_$regenerate_block external entry (pointer);
       76 declare  make_defs_$open_section external entry ();
       77 declare  make_defs_$close_section external entry ();
       78 declare  make_bound_object_map_ external entry (fixed bin (35));
       79 declare  parse_bindfile_ external entry ();
       80 declare  rebuild_object_$init external entry ();
       81 declare  rebuild_object_ external entry (pointer);
       82 declare  release_temp_segment_ external entry (char (*), ptr, fixed bin (35));
       83 declare  temp_mgr_$allocate external entry (fixed bin);
       84 declare  temp_mgr_$reserve external entry (pointer);
       85 declare  temp_mgr_$init external entry ();
       86 declare  temp_mgr_$make_object external entry ();
       87 declare  temp_mgr_$close_files external entry ();
       88 declare  terminate_file_ external entry (ptr, fixed bin (24), bit (*), fixed bin (35));
       89 declare  tssi_$clean_up_segment external entry (pointer);
       90 declare  tssi_$get_segment external entry (char (*) aligned, char (*) aligned, ptr, ptr, fixed bin (35));
       91 declare  tssi_$finish_segment external entry (pointer, fixed bin (24), bit (36) aligned,
       92 	    ptr, fixed bin (35));
       93 
       94 /* DECLARATION OF AUTOMATIC STORAGE VARIABLES */
       95 
       96 declare  (i, pos, nobjects) fixed bin;
       97 declare  hash_index fixed bin (34);
       98 declare  (val, lng, symb_relc) fixed bin (18);
       99 declare  code fixed bin (35);
      100 declare  list_acinfop pointer;
      101 declare  (inpp, linkptr, old_ptr, p, sp, textp) pointer;
      102 declare  (dirname char (168), segname char (32)) aligned;
      103 declare  listname char (32) aligned;
      104 declare  whalf char (3) aligned;
      105 
      106 declare  1 x aligned,
      107 	 2 obj_ptr pointer,
      108 	 2 list_ptr pointer,
      109 	 2 list_bc fixed bin (24),
      110 	 2 long fixed bin,
      111 	 2 nopts fixed bin;
      112 
      113 /* DECLARATION OF BUILTIN FUNCTIONS */
      114 
      115 declare  (addr, addrel, bin, bit, divide, fixed, hbound, index, min, mod, null, rel, substr, unspec) builtin;
      116 declare  size builtin;
      117 declare  rank builtin;
      118 
      119 declare  cleanup condition;
      120 declare  fatal_binder_error condition;
      121 
      122 /* DECLARATION OF EXTERNAL STATIC */
      123 
      124 declare  (error_table_$pathlong, error_table_$segnamedup) ext fixed bin (35);
      125 
      126 /* DECLARATION OF INTERNAL STATIC */
      127 
      128 declare  BINDER_INPUT_VERSION_1 char (4) aligned internal static options (constant) init ("BI.1");
      129 declare  NL char (1) static options (constant) init ("
      130 ");
      131 declare  FF char (1) static options (constant) init ("");
      132 
      133 /* DECLARATION OF BASED STRUCTURES */
      134 
      135 declare  linksection (val) aligned fixed bin based;
      136 declare  1 halfword aligned based,
      137 	 2 lhe18 bit (18) unaligned,
      138 	 2 rhe18 bit (18) unaligned;
      139 declare  1 pr_offset aligned based,
      140 	 2 dum1 bit (3) unaligned,
      141 	 2 lhe15 bit (15) unaligned,
      142 	 2 dum2 bit (3) unaligned,
      143 	 2 rhe15 bit (15) unaligned;
      144 declare  1 clngns_overlay aligned based (addr (comp.clngns)),
      145 	 2 dum bit (35) unaligned,
      146 	 2 odd bit (1) unaligned;
      147 declare  reset_bx (bx_$size) fixed bin (35) based (addr (bx_$area_begin));
      148 declare  based_string char (10000) based (p);
      149 
      150 declare  1 temp_seg based aligned,			/* Format of temp segments */
      151 	 2 next_temp_ptr ptr,			/* ptr to next temp seg in chain */
      152 	 2 storage bit (0);				/* Start of temp_mgr_ storage */
      153 
      154 
      155 
      156 /* PROLOGUE - Initialize binder's temporaries, and validate format of
      157*   bindfile before starting actual binding.			*/
      158 
      159 
      160 	inpp = argp;				/* copy pointer to input structure */
      161 
      162 	reset_bx (*) = 0;				/* reset main data base to zeros */
      163 
      164 	bx_$inpp = inpp;				/* record address of input structure */
      165 	bx_$caller = inp.caller_name;
      166 
      167 	list_acinfop,
      168 	     old_ptr,
      169 	     bx_$temp,
      170 	     bx_$bsegp,
      171 	     bx_$temp_bsegp,
      172 	     bx_$bseg_acinfop = null;
      173 
      174 
      175 	on cleanup begin;				/* delete the temp copy of the bound seg on a fault */
      176 	     if bx_$temp_bsegp ^= null then call terminate_file_ (bx_$temp_bsegp, 0, TERM_FILE_DELETE, 0);
      177 						/* clean up temp for new bound object */
      178 	     if list_acinfop ^= null then call tssi_$clean_up_segment (list_acinfop);
      179 						/* clean up temp for list segment */
      180 
      181 /* Return all temp segments to free pool. */
      182 
      183 	     if old_ptr ^= null then do;		/* release the temp seg we got for version 2 input */
      184 		call release_temp_segment_ ("bind_", inpp, (0));
      185 		inpp = old_ptr;
      186 	     end;
      187 
      188 	     do p = bx_$temp repeat sp while (p ^= null); /* Follow chain of temp segments */
      189 		sp = p -> temp_seg.next_temp_ptr;	/* Get ptr to next temp segment */
      190 		call release_temp_segment_ ("bind", p, code);
      191 		if code ^= 0 then
      192 		     do;
      193 		     call com_err_ (code, inp.caller_name);
      194 		     return;
      195 		end;
      196 	     end;
      197 	end;
      198 
      199 
      200 	if inp.version = BINDER_INPUT_VERSION_1 then call CONVERT_I_TO_II (); /* convert to new version */
      201 	else if inp.version ^= BINDER_INPUT_VERSION_2 then do; /* Complain and give up */
      202 	     call com_err_ (0, inp.caller_name, "Invalid version ""^4a"" in binder input structure.", inp.version);
      203 	     return;
      204 	end;
      205 
      206 
      207 	bx_$debug = fixed (inp.debug, 1);		/* copy debug flag */
      208 	bx_$brief = bin (inp.brief_opt, 1);		/* copy brief flag */
      209 	bx_$force_order = bin (inp.force_order_opt, 1);	/* Copy command-line Force_order option */
      210 						/* (this may also get set in parse_bindfile)_ */
      211 	on fatal_binder_error begin;
      212 	     bx_$fatal_error = 1;
      213 	     go to return;
      214 	end;
      215 
      216 
      217 
      218 	call temp_mgr_$init;
      219 						/* create temp segment, return pointer to main database */
      220 	if bx_$fatal_error = 1 then goto return;
      221 
      222 	bx_$v_lng = rank (substr (bx_$vers_name, 1, 1));	/* get length of version name */
      223 
      224 	sntp,
      225 	     bx_$sntp = bx_$freep;			/* allocate segname table */
      226 	snt.max_size = bx_$snt_limit;
      227 	call temp_mgr_$reserve (addr (snt.entry (snt.max_size + 1))); /* determine end of table */
      228 						/* reserve the area allocated to main table */
      229 	if bx_$fatal_error ^= 0 then goto return;
      230 
      231 	odnp,
      232 	     bx_$odnp = bx_$freep;			/* oddname table  */
      233 	od.max_size = bx_$oddname_limit;
      234 	call temp_mgr_$reserve (addr (od.entry (od.max_size + 1)));
      235 
      236 	rptp = bx_$freep;				/* Reserve first chunk of repatch table */
      237 	bx_$first_rptp,
      238 	     bx_$last_rptp = rptp;
      239 	call temp_mgr_$reserve (addrel (addr (rpt), size (rpt)));
      240 	rpt.thread = null;				/* No more chunks */
      241 	rpt.npt = 0;				/* No entries in chunk */
      242 
      243 	bx_$ncomp = inp.nobj;
      244 	bx_$adnp = null;
      245 
      246 	call parse_bindfile_;			/* parse the bindfile, if there is one */
      247 	if bx_$fatal_error = 1 then goto return;
      248 
      249 	inpp = bx_$inpp;				/* refresh, in case it was modified by parse_bindfile_ */
      250 
      251 	if list_seg then do;			/* be sure segname || ".list" is <= 32 chars */
      252 	     i = index (bx_$bound_segname, " ");	/* get length of name */
      253 	     if ((i = 0) | (i > 27)) then do;
      254 		call com_err_ (error_table_$pathlong, inp.caller_name, "Cannot add .list to ^a", bx_$bound_segname);
      255 		bx_$fatal_error = 1;
      256 		go to return;			/* don't make user have to delete empty seg */
      257 	     end;
      258 	end;
      259 
      260 	ctp,
      261 	     bx_$ctp = bx_$freep;			/* allocate component table */
      262 	nobjects = bx_$ncomp;			/* get number of component objects */
      263 	call temp_mgr_$reserve (addr (comp_tbl (nobjects + 1))); /* reserve area for component table */
      264 	if bx_$fatal_error = 1 then goto return;
      265 
      266 
      267 	call temp_mgr_$make_object;			/* create the new bound segment */
      268 	if bx_$fatal_error = 1 then goto return;
      269 
      270 	if ^inp.brief_opt then call ioa_ ("Binding ^a", bx_$bound_segname);
      271 
      272 
      273 
      274 
      275 /* FIRST PASS OF BINDER = obtain ITS pointers to all relevant parts (e.g., definition
      276*   section, relocation bits, etc.) of every object to be bound, and copy the text
      277*   sections into the new bound segment.				*/
      278 
      279 
      280 	call dissect_object_$init;
      281 
      282 	do i = 1 to nobjects;			/* start processing components */
      283 	     ctep,
      284 		comp_tbl (i) = bx_$freep;		/* allocate entry for this component */
      285 	     call temp_mgr_$reserve (addr (comp.last_item));
      286 	     unspec (comp) = ""b;			/* iniitalize structure; seems to be necessary */
      287 	     comp.cindex = i;			/* remember entry's index in table */
      288 	     comp.filename = inp.obj (i).filename;	/* store object's filename */
      289 	     lng = index (comp.filename, " ");		/* compute filename's length */
      290 	     if lng = 0 then lng = 32;
      291 	     else lng = lng - 1;
      292 	     comp.fn_lng = lng;			/* remember length */
      293 	     comp.ctxtp = inp.obj (i).base;		/* get pointer to object segment */
      294 	     comp.cbitcount = inp.obj (i).bitcount;	/* and its bitcount */
      295 	     call dissect_object_ (ctep);		/* and process this object segment */
      296 	end;
      297 
      298 	if bx_$tintlng >= 16384 then do;		/* max is 16K because of 15-bit link offsets */
      299 	     call com_err_ (0, inp.caller_name,
      300 		"length of internal static >= 16384, the maximum static section length");
      301 	     bx_$fatal_error = 1;
      302 	end;
      303 
      304 	bx_$maxlinklng = min (bx_$maxlinklng, 16384);	/* enforce usable size */
      305 	if (bx_$has_comb_stat = 0 & bx_$has_sep_stat = 1)
      306 	then bx_$bound_sep_stat = 1;			/* have at  least 1 nonzero sep stat and no comb stat */
      307 	else bx_$bound_sep_stat = 0;
      308 
      309 	if bx_$fatal_error = 1 then go to return;
      310 
      311 	call incorporate_options_;
      312 	if bx_$fatal_error = 1 then goto return;
      313 
      314 /* Create hash table for segname table (snt), all of whose entries have already been stored. */
      315 
      316 	do hash_index = 0 to hbound (snt.hash_table, 1);
      317 	     snt.hash_table (hash_index) = null;	/* Clear hash table */
      318 	end;
      319 	do i = 1 to snt.n_names;			/* Scan entire snt */
      320 
      321 /* Hash code segment name from table. */
      322 
      323 	     hash_index = 0;
      324 	     do pos = 1 to min (snt.entry (i).lng, 24);	/* 24 times max */
      325 		hash_index = 2 * hash_index + bin (unspec (substr (snt.entry (i).name, pos, 1)), 9);
      326 	     end;
      327 	     hash_index = mod (hash_index, hbound (snt.hash_table, 1) + 1);
      328 
      329 /* Push snt entry into bucket thus found. */
      330 
      331 	     snt.entry (i).hash_thread = snt.hash_table (hash_index);
      332 	     snt.hash_table (hash_index) = addr (snt.entry (i));
      333 	end;
      334 
      335 
      336 
      337 /* SECOND PASS OF THE BINDER = allocate temporary area for construction of
      338*   new linkage section, relocate all text sections building up the linkage
      339*   section in the process, and finally construct the new definition section
      340*   of the new bound object segment.				*/
      341 
      342 	val = bx_$textlng;				/* get length of text portion */
      343 	val = divide (val + 1, 2, 17, 0) * 2;		/* make it a 0 mod 2 value */
      344 	bx_$textlng = val;				/* and restore to data base */
      345 
      346 
      347 	bx_$tdefp = addrel (bx_$temp_bsegp, val);
      348 	call temp_mgr_$allocate (bx_$maxlinklng);	/* make sure an area of sufficient size available */
      349 	if bx_$bound_sep_stat = 1 then do;
      350 	     bx_$tintp = bx_$freep;			/* static will be between defs and link */
      351 	     val = 8;				/* locatiion of first link */
      352 	     linkptr,
      353 		bx_$tlinkp = addrel (bx_$tintp, bx_$tintlng); /*  ptr to temp linkage section */
      354 	end;
      355 	else do;					/* bound segment has static in linkage */
      356 	     linkptr,
      357 		bx_$tlinkp = bx_$freep;		/*  linkage immediately follows defs */
      358 	     val = bx_$tintlng + 8;
      359 	     bx_$tintp = addrel (linkptr, 8);
      360 	end;
      361 	call temp_mgr_$reserve (addrel (bx_$freep, bx_$maxlinklng)); /* and reserve area */
      362 
      363 	strmp,
      364 	     bx_$strmp = bx_$freep;			/* get pointer to generated string map */
      365 	strm.max_size = bx_$stringmap_limit;
      366 	call temp_mgr_$reserve (addr (strm.entry (strm.max_size + 2)));
      367 
      368 /* now fabricate a new header for this linkage section */
      369 
      370 	linkptr -> virgin_linkage_header.link_begin = bit (bin (val, 18), 18); /* and store in header */
      371 	bx_$tlinklng = val;				/* remember current length of linkage section */
      372 
      373 /* now compute length of first part of binder's symbol block */
      374 
      375 	bx_$n_lng = index (bx_$bound_segname, " ") - 1;
      376 	if bx_$n_lng = -1 then bx_$n_lng = 32;
      377 
      378 /* make symbol section header length mod 8 */
      379 	i = divide (bx_$v_lng + 3, 4, 17, 0);		/* compute length of version name in words */
      380 	bx_$s_lng = divide ((27 + i), 8, 17, 0) * 8;	/* 27 for 20 + 7 */
      381 	call rebuild_object_$init;
      382 	call decode_link_$init;
      383 	call int_link_$init;
      384 	call make_defs_$open_section;			/* must call before ext_link_$init */
      385 	call ext_link_$init;
      386 	call generate_def_$init;
      387 
      388 	symb_relc = bx_$s_lng;
      389 	do i = 1 to nobjects;
      390 	     ctep = comp_tbl (i);			/* pointer to component entry */
      391 						/* the following must be done here because incorporate_options_ may have changed comp.clngns */
      392 	     if clngns_overlay.odd then comp.cpads = 1;
      393 	     comp.crels = symb_relc;
      394 	     symb_relc = symb_relc + comp.clngns + comp.cpads;
      395 						/* compute new relocation counter */
      396 	     if comp.ignore = 0 then call rebuild_object_ (ctep);
      397 	end;
      398 
      399 
      400 	do i = 1 to nobjects;
      401 	     ctep = comp_tbl (i);			/* pointer to component entry */
      402 	     if comp.ignore = 0 then call make_defs_$regenerate_block (ctep);
      403 	end;
      404 
      405 	if bx_$n_firstrefs > 0 then call generate_first_ref_traps_ ();
      406 						/* combine first ref trap arrays of each  component */
      407 
      408 
      409 	call make_defs_$close_section;		/* close new definition section */
      410 
      411 	call ext_link_$finish;			/* print out multiple init messages */
      412 	if bx_$fatal_error = 1 then goto return;
      413 
      414 
      415 
      416 
      417 /* FINAL PASS OF THE BINDER = copy new linkage section into new object segment,
      418*   and relocate symbol sections into it 			*/
      419 
      420 	val = bx_$curdeflng;			/* length of new definition section */
      421 	val = divide (val + 1, 2, 17, 0) * 2;		/* make it a 0 mod 2 value */
      422 	bx_$curdeflng = val;			/* restore just in case */
      423 	if bx_$bound_sep_stat = 0 then do;		/*  int static is inside linkage */
      424 	     bx_$blnkp = addrel (bx_$tdefp, val);	/* ptr to location of new  linkage sectiin */
      425 	     val = bx_$tlinklng;			/* includes static */
      426 	     bx_$blnkp -> linksection = bx_$tlinkp -> linksection;
      427 	     bx_$bstatp = addrel (bx_$blnkp, 8);
      428 	end;
      429 	else do;					/*  static precedes linkage */
      430 	     bx_$bstatp = addrel (bx_$tdefp, val);
      431 	     val = bx_$tintlng + bx_$tlinklng;		/* get length of link and static */
      432 	     bx_$bstatp -> linksection = bx_$tintp -> linksection; /* copy linkage and static into object */
      433 	     bx_$blnkp = addrel (bx_$bstatp, bx_$tintlng);/* get ptr to linkage in object */
      434 	     val = bx_$tlinklng;			/* fill in length of actual linkage */
      435 	end;
      436 	bx_$t_lng = bx_$textlng + bx_$curdeflng;	/* length of new text section */
      437 	val = divide (val + 1, 2, 17, 0) * 2;		/* make length of linkage section 0 mod 2 value */
      438 	bx_$l_lng = val;				/* and store in main data base */
      439 	bx_$bdefp = bx_$tdefp;
      440 	bx_$d_lng = bx_$curdeflng;
      441 	bx_$i_lng = bx_$tintlng;
      442 
      443 	bx_$blnkp -> virgin_linkage_header.linkage_section_lng = bit (bin (bx_$l_lng, 18), 18);
      444 	bx_$blnkp -> virgin_linkage_header.def_offset = rel (bx_$bdefp);
      445 	bx_$blnkp -> virgin_linkage_header.static_length = bit (bin (bx_$i_lng, 18), 18);
      446 
      447 	bx_$bsymp = addrel (bx_$blnkp, bx_$l_lng);	/* compute base of symbol section */
      448 
      449 	call relocate_symbol_;			/* relocate and assemble symbol sections */
      450 	if bx_$fatal_error = 1 then goto return;
      451 
      452 
      453 /* EPILOG - make bindmap and object map, and complete addresses and values
      454*   which were not available at some previous point of time. Close all
      455*   files and terminate names.				*/
      456 
      457 	call make_bindmap_;
      458 
      459 
      460 	do rptp = bx_$first_rptp repeat rpt.thread while (rptp ^= null);
      461 						/* Scan repatch table */
      462 	     do i = 1 to rpt.npt;			/* Scan chunk of repatch table */
      463 		rptep = addr (rpt.entry (i));		/* pointer to next repatch table entry */
      464 		if rpte.pbase = "t" then textp = bx_$temp_bsegp;
      465 		else if rpte.pbase = "l" then textp = bx_$blnkp;
      466 		else if rpte.pbase = "s" then textp = bx_$bsymp;
      467 		textp = addrel (textp, rpte.poffset);	/* get pointer to instruction to patch */
      468 		whalf = rpte.halfword;		/* determine which halfword to patch */
      469 		if whalf = "lhe" then val = fixed (textp -> halfword.lhe18, 18);
      470 		else if whalf = "l15" then val = fixed (textp -> pr_offset.lhe15, 15);
      471 		else if whalf = "rhe" then val = fixed (textp -> halfword.rhe18, 18);
      472 		val = val + fixed (rpte.pexpr, 18);	/* add expression value */
      473 		if rpte.code = "l" then val = val + bin (rel (bx_$blnkp), 18);
      474 		else if rpte.code = "s" then val = val + bin (rel (bx_$bsymp), 18);
      475 		if whalf = "lhe" then textp -> halfword.lhe18 = bit (bin (val, 18), 18);
      476 		else if whalf = "l15" then textp -> pr_offset.lhe15 = addr (val) -> pr_offset.rhe15;
      477 		else textp -> halfword.rhe18 = bit (bin (val, 18), 18);
      478 	     end;
      479 	end;
      480 
      481 
      482 /* and now, at last, make an object map for the new object segment */
      483 
      484 	call make_bound_object_map_ (code);
      485 	if code ^= 0 then
      486 	     do;
      487 	     call com_err_ (0, inp.caller_name, "Cannot generate object map");
      488 	     bx_$fatal_error = 1;
      489 	     bx_$o_lng = bx_$t_lng + (bx_$bound_sep_stat * bx_$i_lng) + bx_$l_lng + bx_$s_lng; /* to get bitcount */
      490 	     bx_$bseg_bitcount = bx_$o_lng * 36;	/* ... */
      491 	end;
      492 
      493 	bx_$o_lng = divide (bx_$bseg_bitcount, 36, 17, 0);
      494 
      495 
      496 	if bx_$fatal_error = 1 then goto return;
      497 	call hcs_$set_bc_seg (bx_$temp_bsegp, bx_$bseg_bitcount, code);
      498 
      499 	if list_seg = "1"b then			/* produce a listing segment */
      500 	     do;
      501 	     dirname = get_wdir_ ();			/* get directory name */
      502 	     segname = bx_$bound_segname;		/* get name of bound object segment */
      503 	     i = index (segname, " ");
      504 	     substr (segname, i, 5) = ".list";
      505 	     list_ptr = null;
      506 	     call tssi_$get_segment (dirname, segname, list_ptr, list_acinfop, code); /* create segment */
      507 	     if list_ptr = null then
      508 		do;
      509 		call com_err_ (code, inp.caller_name, segname);
      510 		bx_$fatal_error = 1;
      511 		goto return;
      512 	     end;
      513 	     listname = segname;			/* copy segment name */
      514 	     substr (listname, i, 5) = ".map ";
      515 	     call hcs_$chname_seg (list_ptr, "", listname, code);
      516 	     if code ^= 0 then			/* name duplication */
      517 		if code ^= error_table_$segnamedup then
      518 		     do;
      519 		     call com_err_ (0, inp.caller_name, "Cannot add name ^a to segment ^a", listname, segname);
      520 		end;
      521 	     obj_ptr = bx_$temp_bsegp;		/* pointer to new bound object segment */
      522 	     list_bc = 0;
      523 	     if list_opt = "1"b then
      524 		do;				/* copy bindfile, if any */
      525 		if inp.bindfilep = null then goto output_bindmap;
      526 		p = list_ptr;			/* copy for convenience */
      527 		call ioa_$rs ("^/^/^-^-Bindfile for ^a^/", dirname, val, bx_$bound_segname);
      528 		substr (based_string, 1, val) = substr (dirname, 1, val);
      529 		lng = divide (inp.bindfile_bc, 9, 17, 0); /* get character count */
      530 		substr (based_string, val + 1, lng) = substr (bindfilep -> based_string, 1, lng);
      531 		lng = lng + val;
      532 		substr (based_string, lng + 1, 2) = FF || NL;
      533 		list_bc = (lng + 2) * 9;		/* set bitcount of list segment */
      534 	     end;
      535 output_bindmap:
      536 	     long = 1;
      537 	     nopts = 0;
      538 	     if map_opt = "1"b then call form_bind_map_ (addr (x), code); /* go produce bindmap information */
      539 	     if list_opt = "1"b then
      540 		do;
      541 		unspec (x.long) = "740000000000"b3;	/* fabricate form_link_info_ arguments */
      542 		lng = divide (list_bc, 9, 17, 0);	/* get length in chars of list seg */
      543 		substr (list_ptr -> based_string, lng + 1, 2) = FF || NL;
      544 		list_bc = list_bc + 18;		/* increase length by 2 chars */
      545 		call form_link_info_ (addr (x), code);	/* output link info  */
      546 	     end;
      547 	     if list_ptr ^= null then call tssi_$finish_segment
      548 		     (list_ptr, list_bc, "1011"b, list_acinfop, code);
      549 	end;
      550 
      551 return:
      552 	if bx_$fatal_error = 1 then
      553 	     do;
      554 	     bx_$addname = 0;
      555 	     call com_err_ (0, inp.caller_name,
      556 		"Fatal error has occurred; binding of ^a unsuccessful.^/The incomplete version exists in [pd]>^a.",
      557 		bx_$bound_segname, bx_$bound_segname);
      558 	end;
      559 
      560 	call temp_mgr_$close_files;
      561 
      562 	if old_ptr ^= null then do;			/* release the temp seg we got for version 2 input */
      563 	     call release_temp_segment_ ("bind_", inpp, (0));
      564 	     inpp = old_ptr;
      565 	end;
      566 
      567 
      568 	return;
      569 
      570 
      571 CONVERT_I_TO_II:
      572      proc ();
      573 
      574 /* program to convert version 1 inp to version 2 inp. */
      575 
      576 /*  Automatic  */
      577 
      578 dcl  idx fixed bin;
      579 
      580 /*  Based */
      581 
      582 dcl  1 v1_inp aligned based (old_ptr),			/* the now-obsolete version 1 binder_input */
      583        2 version char (4) aligned,
      584        2 caller_name char (32) unaligned,		/* Name of command on whose behalf binder is being invoked */
      585 
      586        2 bound_seg_name char (32) unaligned,		/* name of new bound segment */
      587 
      588        2 narc fixed bin,				/* number of input archive files */
      589        2 nupd fixed bin,				/* number of update archive files */
      590 
      591        2 archive (30) aligned,			/* info about input archives, for source map, etc. */
      592          3 path char (168) unaligned,			/* for identifying archive */
      593          3 real_path char (168) unaligned,		/* determined by translator_info_ */
      594          3 ptr pointer,				/* pointer to archive */
      595          3 bc fixed bin (24),				/* and its bitcount */
      596          3 uid bit (36) aligned,			/* unique id of archive */
      597          3 dtm fixed bin (71),			/* date-time modified of archive */
      598 
      599        2 bindfilep pointer,				/* pointer to bindfile */
      600        2 bindfile_bc fixed bin (24),			/* bitcount of bindfile */
      601        2 bindfile_name char (32) unaligned,		/* name of bindfile */
      602        2 bindfile_time_up fixed bin (71),		/* date updated in archive */
      603        2 bindfile_time_mod fixed bin (71),		/* date last modified */
      604        2 bindfile_idx fixed bin,			/* index of archive bindfile was in */
      605 
      606        2 options aligned,
      607          3 debug bit (1) unaligned,			/* 1-> debug option ON */
      608          3 list_seg bit (1) unaligned,			/* 1 -> make list seg */
      609          3 map_opt bit (1) unaligned,			/* 1 -> map option  */
      610          3 list_opt bit (1) unaligned,			/* 1 -> list option */
      611          3 brief_opt bit (1) unaligned,			/* 1 -> brief option */
      612          3 force_order_opt bit (1) unaligned,		/* 1 -> force_order option from command line */
      613          3 flags_pad bit (30) unaligned,
      614 
      615        2 nobj fixed bin,				/* number of objects to be bound */
      616 
      617        2 v1_obj (400) aligned like v1_obj;
      618 
      619 dcl  1 v1_obj aligned based (p),			/* dcl of single input entry for version 1 binder_input */
      620        2 filename char (32) unaligned,
      621        2 base pointer,				/* pointer to base of object segment */
      622        2 bitcount fixed bin (24),			/* bitcount of object segment */
      623        2 option bit (18) unaligned,			/* pointer into option structure */
      624        2 flag bit (1) unaligned,			/* This word of unaligned bits ought to be a substructure, */
      625        2 pad bit (17) unaligned,			/* but if it is, pl1 scope-of-names stupidly rejects refs */
      626 						/* to obj.flag as "ambiguous", because of inp.obj.flag */
      627        2 archive_idx fixed bin,			/* index of archive from which this component comes */
      628        2 time_mod fixed bin (71),			/* DTCM of component (from archive) */
      629        2 time_up fixed bin (71);			/* Time updated in archive */
      630 
      631 	old_ptr = inpp;
      632 	call get_temp_segment_ ("bind_", inpp, code);
      633 	if code ^= 0 then do;
      634 	     call com_err_ (code, "bind_", "Could not get temporary segment for version 2 input structure");
      635 	     bx_$fatal_error = 1;
      636 	     goto return;
      637 	end;
      638 
      639 	inp.version = BINDER_INPUT_VERSION_2;
      640 	inp.caller_name = v1_inp.caller_name;
      641 	inp.bound_seg_name = v1_inp.bound_seg_name;
      642 	inp.narc = v1_inp.narc;
      643 	inp.nupd = v1_inp.nupd;
      644 	inp.ntotal = inp.narc + inp.nupd;
      645 	inp.nobj = v1_inp.nobj;
      646 
      647 	inp.bindfilep = v1_inp.bindfilep;
      648 	inp.bindfile_bc = v1_inp.bindfile_bc;
      649 	inp.bindfile_name = v1_inp.bindfile_name;
      650 	inp.bindfile_time_up = v1_inp.bindfile_time_up;
      651 	inp.bindfile_time_mod = v1_inp.bindfile_time_mod;
      652 	inp.bindfile_idx = v1_inp.bindfile_idx;
      653 
      654 	unspec (inp.options) = unspec (v1_inp.options);
      655 
      656 	do idx = 1 to inp.ntotal;
      657 	     inp.archive (idx) = v1_inp.archive (idx), by name;
      658 	     inp.archive (idx).standalone_seg = "0"b;
      659 	end;
      660 
      661 	do idx = 1 to inp.nobj;
      662 	     inp.obj (idx) = v1_inp.v1_obj (idx), by name;
      663 	     inp.obj (idx).new_order = 0;
      664 	     inp.obj (idx).to_be_ignored,
      665 		inp.obj (idx).objectname_stmt = "0"b;
      666 	end;
      667 
      668 	return;
      669 
      670      end CONVERT_I_TO_II;
      671 
      672 
      673  /****  START OF:	bindext.incl.pl1			 *  *  *  *  *  */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(86-06-14,Elhard), approve(86-06-14,MCR7198),
  1     6*     audit(86-06-30,Weaver):
  1     7*     Added declarations for bx_$caller and bx_$temp_bsegp.
  1     8*                                                   END HISTORY COMMENTS */
  1     9 
  1    10 /* DECLARATION OF BINDER'S MAIN DATABASE */
  1    11 
  1    12 /* include file bindext.incl.pl1 */
  1    13 
  1    14 /* Modified Sept 1978 by David Spector for using "get_temp_segment_" in temp_mgr_ */
  1    15 /* Modified Dec 1978 by David Spector for making repatch table automatically extensible */
  1    16 /* Modified 01/15/81 W. Olin Sibert for new options */
  1    17 
  1    18 declare  bx_$vers_name char (168) aligned external;	/* ASCII version name, in ACC form */
  1    19 declare  bx_$vers_number fixed bin external;		/* integer part of version number */
  1    20 declare  bx_$size fixed bin external;			/* size of main data base, for resetting */
  1    21 declare  bx_$snt_limit fixed bin external;		/* preset limit for segname table */
  1    22 declare  bx_$oddname_limit fixed bin external;		/* preset limit for oddname table */
  1    23 declare  bx_$stringmap_limit fixed bin external;		/* preset limit for stringmap table */
  1    24 declare  bx_$addname_limit fixed bin external;		/* preset limit for addname table */
  1    25 declare  bx_$area_begin fixed bin (18) external;		/* beginning of main data base */
  1    26 declare  bx_$ctp pointer external;			/* pointer to component table */
  1    27 declare  bx_$freep pointer external;			/* pointer to beginning of free area */
  1    28 declare  bx_$isp pointer external;			/* pointer to first insym table */
  1    29 declare  bx_$inpp pointer external;			/* pointer to binder's input structure */
  1    30 declare  bx_$bsegp pointer external;			/* pointer to base of new object segment */
  1    31 declare  bx_$temp pointer external;			/* pointer to threaded list of temp segments */
  1    32 declare  bx_$optp pointer external;			/* pointer to options table */
  1    33 declare  bx_$odnp pointer external;			/* pointer to oddname table */
  1    34 declare  bx_$first_rptp pointer external;		/* pointer to first chunk of repatch table */
  1    35 declare  bx_$last_rptp pointer external;		/* pointer to current chunk of threaded repatch table */
  1    36 declare  bx_$adnp pointer external;			/* pointer to addname table */
  1    37 declare  bx_$bindmap_def pointer external;		/* pointer to new object's "bind_map" definition */
  1    38 declare  bx_$bdefp pointer external;			/* pointer to new object's definition section */
  1    39 declare  bx_$bstatp pointer external;			/* pointer to new object's static section */
  1    40 declare  bx_$blnkp pointer external;			/* pointer to new object's linkage section */
  1    41 declare  bx_$bsymp pointer external;			/* pointer to new object's symbol section */
  1    42 declare  bx_$sntp pointer external;			/* pointer to segname table */
  1    43 declare  bx_$tdefp pointer external;			/* pointer to temporary new definition section */
  1    44 declare  bx_$tintp pointer external;			/* pointer to temporary new internal static */
  1    45 declare  bx_$tlinkp pointer external;			/* pointer to temporary new linkage section */
  1    46 declare  bx_$strmp pointer external;			/*  pointer to stringmap table */
  1    47 declare  bx_$n_firstrefs fixed bin external;		/* count of components with firstref traps */
  1    48 declare  bx_$bound_segname char (32) aligned external;	/* name of new bound object */
  1    49 declare  bx_$fatal_error fixed bin external;		/* 1 -> fatal error was detected */
  1    50 declare  bx_$bseg_acinfop pointer external;		/* new object's acinfop for "tssi_" */
  1    51 declare  bx_$bseg_bitcount fixed bin (24) external;	/* new object's bitcount */
  1    52 declare  bx_$o_lng fixed bin (19) external;		/* length of new bound object */
  1    53 declare  bx_$t_lng fixed bin (18) external;		/* length of new text section */
  1    54 declare  bx_$d_lng fixed bin (18) external;		/* length of new definition section */
  1    55 declare  bx_$i_lng fixed bin external;			/* length of new static section */
  1    56 declare  bx_$l_lng fixed bin external;			/* length of new linkage section */
  1    57 declare  bx_$s_lng fixed bin (18) external;		/* length of new symbol section */
  1    58 declare  bx_$addname fixed bin external;		/* 1 -> addname option specified */
  1    59 declare  bx_$debug fixed bin external;			/* 1 -> debug option was specified */
  1    60 declare  bx_$brief fixed bin external;			/* 1 -> brief option was specified */
  1    61 declare  bx_$force_order fixed bin external;		/* 1 -> -force_order specified on command line */
  1    62 declare  bx_$has_sep_stat fixed bin external;		/* 1 -> a comp has nonzero sep static */
  1    63 declare  bx_$has_comb_stat fixed bin external;		/* 1 -> a comp has nonzero combined static */
  1    64 declare  bx_$bound_sep_stat fixed bin external;		/* 1 -> bound segment has separate static */
  1    65 declare  bx_$perprocess_static fixed bin external;	/* 1 -> bound segment has perprocess static switch on */
  1    66 declare  bx_$standard fixed bin external;		/* 1 -> bound seg is in standard format */
  1    67 declare  bx_$bproc fixed bin external;			/* 1 -> at least one component is a procedure */
  1    68 declare  bx_$textlng fixed bin (18) external;		/* length of new pure text portion */
  1    69 declare  bx_$curdeflng fixed bin (18) external;		/* current length of new definition section */
  1    70 declare  bx_$tintlng fixed bin external;		/* current length of new internal static */
  1    71 declare  bx_$maxlinklng fixed bin external;		/* maximum size linkage section may attain */
  1    72 declare  bx_$maxdeflng fixed bin (18) external;		/* maximum size definition section may attain */
  1    73 declare  bx_$tlinklng fixed bin external;		/* current size of linkage section */
  1    74 declare  bx_$ncomp fixed bin external;			/* number of component objects to be bound */
  1    75 declare  bx_$v_lng fixed bin external;			/* length of version name string */
  1    76 declare  bx_$n_lng fixed bin external;			/* length of bound segment name string */
  1    77 declare  bx_$nsymdefs fixed bin external;		/* count of non-null symbol definitions */
  1    78 declare  bx_$nsegdefs fixed bin external;		/* count of non-null segment name definitions */
  1    79 declare  bx_$temp_bsegp ptr external;			/* pointer to the temporary bound seg in the process dir */
  1    80 declare  bx_$caller char (32) aligned external;		/* name of the caller of bind_ for error messages */
  1    81 
  1    82 /****  END OF:	bindext.incl.pl1			 *  *  *  *  *  */
      673 
      674  	/* Include file comptbl.incl.pl1 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  2     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  2     7*     added link_regeneration_table pointer (clrtp) to component structure.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 declare	(ctp, ctep) pointer;
  2    11 
  2    12 declare	comp_tbl(1000) pointer based(ctp);
  2    13 
  2    14 
  2    15 
  2    16 declare	1 comp aligned based(ctep),		/* declaration of a component entry */
  2    17 	2 filename char(32) aligned,		/* object segment's file name */
  2    18 	2 compiler char(8) aligned,		/* name of compiler which produced this object */
  2    19 	2 format char(8) aligned,		/* format of object code (PL/1, ALM etc.)  */
  2    20 
  2    21 	2 ctxtp pointer,			/* pointer to base of text section */
  2    22 	2 cdefp pointer,			/* pointer to definitions */
  2    23 	2 cstatp pointer,			/* pointer to static section */
  2    24 	2 clnkp pointer,			/* pointer to head of linkage section */
  2    25 	2 csymp pointer,			/* pointer to symbol table */
  2    26 	2 cfrtp pointer,			/* pointer to first ref trap array */
  2    27 	2 crltp pointer,			/* pointer to rel-text */
  2    28 	2 crllp pointer,			/* pointer to rel-link */
  2    29 	2 crlsp pointer,			/* pointer to rel-symb */
  2    30 	2 insymentp pointer,		/* pointer to this component's insym table entry */
  2    31 	2 clrtp pointer,			/* pointer to link_regeneration_table */
  2    32 	2 unused_1 pointer,			/* reserve */
  2    33 	2 unused_2 pointer,			/* reserve */
  2    34 	2 unused_3 fixed bin,		/* reserve */
  2    35 	2 cindex fixed bin,			/* this entry's index in table */
  2    36 	2 standard_object fixed bin,		/* 1 -> this object has standard format */
  2    37 	2 defthread fixed bin,		/* beginning of comp's definition block */
  2    38 	2 fn_lng fixed bin,			/* length of filename string */
  2    39 	2 ignore fixed bin,			/* 1->ignore erroneous entry */
  2    40 	2 io_table fixed bin,		/* 1 -> symbol table needed for io */
  2    41 	2 table_deleted fixed bin,		/* 1 -> symbol table is being deleted */
  2    42 	2 separate_static fixed bin,		/* 1 -> component has nonzero separate static */
  2    43          (2 defblockp,			/* rel pointer to component's definition block */
  2    44 	2 current_def) bit(18) unaligned,	/* rel pointer to component's current def */
  2    45 	2 cbitcount fixed bin(24),		/* bitcount of component segment */
  2    46 	2 clngt fixed bin(18),		/* length of pure text section */
  2    47 	2 cpadt fixed bin,			/* number of added padwords for text */
  2    48 	2 clngd fixed bin(18),		/* length of definition section */
  2    49 	2 clngi fixed bin,			/* length of internal static */
  2    50 	2 cpadi fixed bin,			/* number of added padwords for internal static  */
  2    51 	2 clngs fixed bin(18),		/* length of original symbol table */
  2    52 	2 clngns fixed bin(18),		/* length of new symb section stripped of relbits */
  2    53 	2 clngss fixed bin(18),		/* length of symbol section minus relbits and table */
  2    54 	2 cpads fixed bin,			/* padding length if section length is odd */
  2    55 	2 n_sym_blks fixed bin,		/* number of symbol blocks */
  2    56 
  2    57 	2 crelt fixed bin,			/* relocation value for text */
  2    58 	2 creli fixed bin,			/* relocation value for internal static */
  2    59 	2 crels fixed bin,			/* relocation value for symbol section */
  2    60 	2 last_item fixed bin;		/*** MUST ALWAYS BE LAST IN STRUCTURE ***/
  2    61  
  2    62 
  2    63 
      674 
      675  	/* Include file bndtbl.incl.pl1 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  3     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  3     7*     Added link_regeneration_table and eliminated the use of "p" as a pointer
  3     8*     to base structures on..
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 	/* DIVERSE BINDER TABLES */
  3    12 
  3    13 	/* Modified Oct 1978 by David Spector for hash coding snt and strm */
  3    14 	/* Modified Dec 1978 by David Spector for making repatch table
  3    15*	   automatically extensible */
  3    16 	
  3    17 declare	(sntp, adnp, odnp, rptp, rptep, strmp, lrtp) pointer;
  3    18 
  3    19 	/* The SEGNAME table  -  segnames and synonyms of all components */
  3    20 
  3    21 declare	1 snt aligned based(sntp),
  3    22 	2 hash_table (0:210) unaligned ptr,	/* prime length */
  3    23 	2 max_size fixed bin,		/* size limit of allocated segname table */
  3    24 	2 n_names fixed bin,		/* number of segname-table entries used */
  3    25 	2 entry(1000) like seg;
  3    26 
  3    27 	/* declaration of a SEGNAME entry */
  3    28 
  3    29 declare	1 seg aligned based,		/* redeclaration of a single segname */
  3    30 	  2 name char(33) aligned,		/* segname in ACC string format */
  3    31 	  2 lng fixed bin,			/* length of segname, incl ACC count */
  3    32 	  2 addname fixed bin,		/* 1-> add name to bound segment */
  3    33 	  2 defrel bit(18),			/* offset in defs of new definition */
  3    34 	  2 comp pointer,			/* pointer to associated component table */
  3    35 	  2 hash_thread ptr;		/* thread to next "seg" in bucket */
  3    36 
  3    37 
  3    38 	/* the ADDNAME table  - list of names specified by "Addname" statement */
  3    39 
  3    40 declare	1 an aligned based(adnp),
  3    41 	2 max_size fixed bin,		/* size limit of addname table */
  3    42 	2 n_an fixed bin,			/* number of names to add */
  3    43 	2 syn(1000) char(32) aligned;		/* contains the names to be added */
  3    44 
  3    45 
  3    46 	/* The ODDNAME table  -  scratchpad memory to suppress redundant error messages */
  3    47 
  3    48 declare	1 od aligned based(odnp),
  3    49 	2 max_size fixed bin,		/* max size of table */
  3    50 	2 n_odds fixed bin,			/* current size of table */
  3    51 	2 entry(1000),
  3    52 	  3 name char(289) aligned;
  3    53 
  3    54 
  3    55 	/* The REPATCH table  -  of halfwords to be relocated at a later time */
  3    56 
  3    57 declare	1 rpt aligned based(rptp),
  3    58 	2 thread unaligned ptr,			/* To next rpt (null at end) */
  3    59 	2 npt fixed bin,
  3    60 	2 entry(1000) like rpte aligned;
  3    61 
  3    62 
  3    63 declare	1 rpte aligned based(rptep),		/* declaration of single repatch table entry */
  3    64 	2 poffset bit(18) unaligned,		/* offset into text of word to be patched */
  3    65 	2 pexpr bit(18) unaligned,		/* value to add to patched halfword */
  3    66 	2 halfword char(3) aligned,		/* designates wordhalf to be patched */
  3    67 	2 pbase char(1) unaligned,		/* section designator of word to be patched */
  3    68 	2 code char(1) unaligned;		/* code of section base to be used as patch value */
  3    69 
  3    70 
  3    71 	/* The STRINGMAP table - to avoid redundant strings in definition section */
  3    72 
  3    73 declare	1 strm aligned based(strmp),
  3    74 	2 hash_table (0:862) fixed bin(17),	/* prime length */
  3    75 	2 max_size fixed bin,
  3    76 	2 nstr fixed bin,
  3    77 	2 entry(2048) unaligned,
  3    78 	  3 map bit(18),			/* rel pointer to string in def section */
  3    79 	  3 hash_thread fixed bin(17);	/* index of next strm.entry in hash bucket */
  3    80 
  3    81 	/* The LINK_REGENERATION table - to flag links which have and  */
  3    82 	/* have not been regenerated to insure generation of all links */
  3    83 	
  3    84 declare	1 lrt		aligned based (lrtp),
  3    85 	  2 count		fixed bin,
  3    86 	  2 start_offset	fixed bin (18) unsigned,
  3    87 	  2 regenerated (0 refer (lrt.count))
  3    88 			bit (18) unaligned;
  3    89 
  3    90 declare	UNRESOLVED	bit (18) static options (constant) init ("000000"b3);
  3    91 declare	INTERNALLY_RESOLVED	bit (18) static options (constant) init ("777777"b3);
      675 
      676  /* BEGIN INCLUDE FILE linkdcl.incl.pl1 --- last modified 15 Nov 1971 by C Garman */
  4     2 
  4     3 /* Last Modified (Date and Reason):
  4     4*   6/75 by M.Weaver to add virgin_linkage_header declaration
  4     5*   6/75 by S.Webber to comment existing structures better
  4     6*   9/77 by M. Weaver to add run_depth to link
  4     7*   2/83 by M. Weaver to add linkage header flags and change run_depth precision
  4     8**/
  4     9 
  4    10 /* format: style3 */
  4    11 dcl	1 link		based aligned,		/* link pair in linkage section */
  4    12 	  2 head_ptr	bit (18) unal,		/* rel pointer to beginning of linkage section */
  4    13 	  2 ringno	bit (3) unal,
  4    14 	  2 mbz		bit (6) unal,
  4    15 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  4    16 	  2 ft2		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  4    17 	  2 exp_ptr	bit (18) unal,		/* pointer (rel to defs) of expression word */
  4    18 	  2 mbz2		bit (12) unal,
  4    19 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  4    20 
  4    21 dcl	1 exp_word	based aligned,		/* expression word in link definition */
  4    22 	  2 type_ptr	bit (18) unal,		/* pointer (rel to defs) of type pair structure */
  4    23 	  2 exp		bit (18) unal;		/* constant expression to be added in when snapping link */
  4    24 
  4    25 dcl	1 type_pair	based aligned,		/* type pair in link definition */
  4    26 	  2 type		bit (18) unal,		/* type of link. may be 1,2,3,4,5, or 6 */
  4    27 	  2 trap_ptr	bit (18) unal,		/* pointer (rel to defs) to the trap word */
  4    28 	  2 seg_ptr	bit (18) unal,		/* pointer to ACC reference name for segment referenced */
  4    29 	  2 ext_ptr	bit (18) unal;		/* pointer (rel to defs)  of ACC segdef name */
  4    30 
  4    31 dcl	1 header		based aligned,		/* linkage block header */
  4    32 	  2 def_ptr	ptr,			/* pointer to definition section */
  4    33 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  4    34 	  2 original_linkage_ptr
  4    35 			ptr unal,			/* pointer to linkage section in object segment */
  4    36 	  2 unused	bit (72),
  4    37 	  2 stats,
  4    38 	    3 begin_links	bit (18) unal,		/* offset (rel to this section) of first link */
  4    39 	    3 block_length	bit (18) unal,		/* number of words in this linkage section */
  4    40 	    3 segment_number
  4    41 			bit (18) unal,		/* text segment number associated with this section */
  4    42 	    3 static_length bit (18) unal;		/* number of words of static for this segment */
  4    43 
  4    44 dcl	1 linkage_header_flags
  4    45 			aligned based,		/* overlay of def_ptr for flags */
  4    46 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  4    47 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  4    48 	  2 perprocess_static
  4    49 			bit (1) unaligned,		/* 1 copy of static section is used by all tasks/run units */
  4    50 	  2 pad2		bit (6) unaligned;
  4    51 
  4    52 dcl	1 virgin_linkage_header
  4    53 			aligned based,		/* template for linkage header in object segment */
  4    54 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  4    55 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  4    56 	  2 def_offset	bit (18) unaligned,		/* offset of definition section */
  4    57 	  2 first_ref_relp	bit (18) unaligned,		/* offset of trap-at-first-reference offset array */
  4    58 	  2 filled_in_later bit (144),
  4    59 	  2 link_begin	bit (18) unaligned,		/* offset of first link */
  4    60 	  2 linkage_section_lng
  4    61 			bit (18) unaligned,		/* length of linkage section */
  4    62 	  2 segno_pad	bit (18) unaligned,		/* will be segment number of copied linkage */
  4    63 	  2 static_length	bit (18) unaligned;		/* length of static section */
  4    64 
  4    65 
  4    66 dcl	1 trap_word	based aligned,		/* trap word in link definition */
  4    67 	  2 call_ptr	bit (18) unal,		/* pointer (rel to link) of link to trap procedure */
  4    68 	  2 arg_ptr	bit (18) unal;		/* pointer (rel to link) of link to arg info for trap proc */
  4    69 
  4    70 dcl	1 name		based aligned,		/* storage of ASCII names in definitions */
  4    71 	  2 nchars	bit (9) unaligned,		/* number of characters in name */
  4    72 	  2 char_string	char (31) unaligned;	/* 31-character name */
  4    73 
  4    74 /* END INCLUDE FILE linkdcl.incl.pl1 */
      676 
      677  /* BEGIN INCLUDE FILE ... binder_input.incl.pl1 ... 01/14/81 W. Olin Sibert */
  5     2 /* Input structure for binder_. Modified to contain more useful information 01/14/81 */
  5     3 
  5     4 /* This file is used only by bind.pl1, bind_.pl1 and parse_bindfile_.pl1 */
  5     5 
  5     6 /* Modified 9/24/84 by M Sharpe to hold a few new flags (originally done
  5     7*   by Henry Bodzin, Ford Motor Co.), and to allow "unlimited" number of 
  5     8*   input archives/segments and object components. */
  5     9 
  5    10 dcl 1 inp aligned based (inpp),			/* Really based on bx_$inpp */
  5    11     2 version char (4) aligned,
  5    12     2 caller_name char (32) unaligned,			/* Name of command on whose behalf binder is being invoked */
  5    13 
  5    14     2 bound_seg_name char (32) unaligned,		/* name of new bound segment */
  5    15 
  5    16     2 narc fixed bin,				/* number of input archive files */
  5    17     2 nupd fixed bin,				/* number of update archive files */
  5    18     2 ntotal fixed bin,				/* total number of input and update files */
  5    19     2 nobj fixed bin,				/* number of objects to be bound */
  5    20 
  5    21     2 bindfilep pointer,				/* pointer to bindfile */
  5    22     2 bindfile_bc fixed bin (24),			/* bitcount of bindfile */
  5    23     2 bindfile_name char (32) unaligned,		/* name of bindfile */
  5    24     2 bindfile_time_up fixed bin (71),			/* date updated in archive */
  5    25     2 bindfile_time_mod fixed bin (71),			/* date last modified */
  5    26     2 bindfile_idx fixed bin,				/* index of archive bindfile was in */
  5    27 
  5    28     2 options aligned,
  5    29       3 debug bit (1) unaligned,			/* 1-> debug option ON */
  5    30       3 list_seg bit (1) unaligned,			/* 1 -> make list seg */
  5    31       3 map_opt bit (1) unaligned,			/* 1 -> map option  */
  5    32       3 list_opt bit (1) unaligned,			/* 1 -> list option */
  5    33       3 brief_opt bit (1) unaligned,			/* 1 -> brief option */
  5    34       3 force_order_opt bit (1) unaligned,		/* 1 -> force_order option from command line */
  5    35       3 zeroseg_seen bit (1) unaligned,			/* 1 -> a zero-length object is in the obj array */
  5    36       3 flags_pad bit(29) unaligned,
  5    37 						/* ---- any additions to the include file must be made before
  5    38*						   the "archive" substructure, as inp.ntotal is incremented
  5    39*						   and the structure is extended as we pick up the names of
  5    40*						   archives/segs from the command line arguments. Similarly,
  5    41*						   after inp.ntotal is determined, the "obj" substructure is
  5    42*						   filled and inp.nobj is incremented as we open up each
  5    43*						   archive and take the necessary information from the
  5    44*						   components.  To allocate the structure, the user must first
  5    45*						   set NTOTAL and NOBJ, allocate the structure and then set
  5    46*						   inp.notal and inp.nobj; otherwise, this structure must be
  5    47*						   declared in a temporary segment.  */
  5    48 
  5    49     2 archive (NTOTAL refer (inp.ntotal)) aligned,	/* info about input archives/segs, for source map, etc. */
  5    50       3 path char (168) unaligned,			/* for identifying archive */
  5    51       3 real_path char (168) unaligned,			/* determined by translator_info_ */
  5    52       3 ptr pointer,				/* pointer to archive */
  5    53       3 bc fixed bin (24),				/* and its bitcount */
  5    54       3 standalone_seg bit (1) unaligned,		/* 1 -> standalone_seg;0 -> archive */
  5    55       3 entryname char (32),				/* entryname of segment */
  5    56       3 uid bit (36) aligned,				/* unique id of archive */
  5    57       3 dtm fixed bin (71),				/* date-time modified of archive */
  5    58 
  5    59 
  5    60     2 obj (NOBJ refer (inp.nobj)) aligned like obj;
  5    61 
  5    62 
  5    63 dcl 1 obj aligned based (p),				/* declaration of single input entry */
  5    64     2 filename char (32) unaligned,
  5    65     2 base pointer,					/* pointer to base of object segment */
  5    66     2 bitcount fixed bin (24),			/* bitcount of object segment */
  5    67     2 option bit (18) unaligned,			/* pointer into option structure */
  5    68     2 new_order fixed bin(9) unsigned unaligned,		/* new position from XXX_Order statement */
  5    69     2 to_be_ignored bit(1) unaligned,			/* mentioned in Ignore statement or is zero-length */
  5    70     2 objectname_stmt bit(1) unaligned,			/* mentioned in objectname: statement */
  5    71     2 flag bit (1) unaligned,				/* This word of unaligned bits ought to be a substructure, */
  5    72     2 pad bit (6) unaligned,				/* but if it is, pl1 scope-of-names stupidly rejects refs */
  5    73 						/* to obj.flag as "ambiguous", because of inp.obj.flag */
  5    74     2 archive_idx fixed bin,				/* index of archive from which this component comes */
  5    75     2 time_mod fixed bin (71),			/* DTCM of component (from archive) */
  5    76     2 time_up fixed bin (71); 			/* Time updated in archive */
  5    77 
  5    78 
  5    79 dcl  BINDER_INPUT_VERSION_2 char (4) aligned internal static options (constant) init ("BI.2");
  5    80 dcl  (NOBJ, NTOTAL)    fixed bin init (0);
  5    81 
  5    82 
  5    83 /* END INCLUDE FILE ... binder_input.incl.pl1 */
      677 
      678  /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  6     2 /* format: style2,^inddcls,idind32 */
  6     3 
  6     4 declare 1 terminate_file_switches	based,
  6     5 	2 truncate		bit (1) unaligned,
  6     6 	2 set_bc			bit (1) unaligned,
  6     7 	2 terminate		bit (1) unaligned,
  6     8 	2 force_write		bit (1) unaligned,
  6     9 	2 delete			bit (1) unaligned;
  6    10 
  6    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  6    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  6    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  6    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  6    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  6    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  6    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  6    18 
  6    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      678 
      679 
      680      end bind_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/12/86  1607.4  bind_.pl1                         >spec>install>1212>bind_.pl1
673          1    07/16/86  1222.1  bindext.incl.pl1                  >ldd>include>bindext.incl.pl1
674          2    07/16/86  1222.1  comptbl.incl.pl1                  >ldd>include>comptbl.incl.pl1
675          3    07/16/86  1222.1  bndtbl.incl.pl1                   >ldd>include>bndtbl.incl.pl1
676          4    07/27/83  0910.0  linkdcl.incl.pl1                  >ldd>include>linkdcl.incl.pl1
677          5    12/18/84  0934.2  binder_input.incl.pl1             >ldd>include>binder_input.incl.pl1
678          6    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BINDER_INPUT_VERSION_1          000002 constant        char(4)                  initial dcl 128 ref 200
BINDER_INPUT_VERSION_2          000001 constant        char(4)                  initial dcl 5-79 ref 201 639
FF                                     constant        char(1)                  initial unaligned dcl 131 ref 532 543
NL                                     constant        char(1)                  initial unaligned dcl 129 ref 532 543
NOBJ                            000264 automatic       fixed bin(17,0)          initial dcl 5-80 set ref 5-80*
NTOTAL                          000265 automatic       fixed bin(17,0)          initial dcl 5-80 set ref 5-80*
TERM_FILE_DELETE                000000 constant        bit(5)                   initial unaligned dcl 6-17 set ref 176*
addr                                                   builtin function         dcl 115 ref 162 227 227 234 234 239 239 263 263 285
                                                                                  285 332 366 366 392 463 476 538 538 545 545
addrel                                                 builtin function         dcl 115 ref 239 239 347 352 359 361 361 424 427 430
                                                                                  433 447 467
archive                  50            based           structure                array level 2 in structure "inp" dcl 5-10
                                                                                  in procedure "bind_" set ref 657*
archive                  24            based           structure                array level 2 in structure "v1_inp" dcl 582
                                                                                  in procedure "CONVERT_I_TO_II" ref 657
argp                                   parameter       pointer                  dcl 50 ref 48 160
base                                   based           pointer                  array level 3 dcl 5-10 set ref 293
based_string                           based           char(10000)              unaligned dcl 148 set ref 528* 530* 530 532* 543*
bin                                                    builtin function         dcl 115 ref 208 209 325 370 443 445 473 474 475 477
bindfile_bc              30            based           fixed bin(24,0)          level 2 in structure "inp" dcl 5-10 in procedure
                                                                                  "bind_" set ref 529 648*
bindfile_bc            5242            based           fixed bin(24,0)          level 2 in structure "v1_inp" dcl 582 in procedure
                                                                                  "CONVERT_I_TO_II" ref 648
bindfile_idx           5260            based           fixed bin(17,0)          level 2 in structure "v1_inp" dcl 582 in procedure
                                                                                  "CONVERT_I_TO_II" ref 652
bindfile_idx             46            based           fixed bin(17,0)          level 2 in structure "inp" dcl 5-10 in procedure
                                                                                  "bind_" set ref 652*
bindfile_name          5243            based           char(32)                 level 2 in structure "v1_inp" packed unaligned
                                                                                  dcl 582 in procedure "CONVERT_I_TO_II" ref 649
bindfile_name            31            based           char(32)                 level 2 in structure "inp" packed unaligned dcl 5-10
                                                                                  in procedure "bind_" set ref 649*
bindfile_time_mod      5256            based           fixed bin(71,0)          level 2 in structure "v1_inp" dcl 582 in procedure
                                                                                  "CONVERT_I_TO_II" ref 651
bindfile_time_mod        44            based           fixed bin(71,0)          level 2 in structure "inp" dcl 5-10 in procedure
                                                                                  "bind_" set ref 651*
bindfile_time_up       5254            based           fixed bin(71,0)          level 2 in structure "v1_inp" dcl 582 in procedure
                                                                                  "CONVERT_I_TO_II" ref 650
bindfile_time_up         42            based           fixed bin(71,0)          level 2 in structure "inp" dcl 5-10 in procedure
                                                                                  "bind_" set ref 650*
bindfilep                26            based           pointer                  level 2 in structure "inp" dcl 5-10 in procedure
                                                                                  "bind_" set ref 525 530 647*
bindfilep              5240            based           pointer                  level 2 in structure "v1_inp" dcl 582 in procedure
                                                                                  "CONVERT_I_TO_II" ref 647
bit                                                    builtin function         dcl 115 ref 370 443 445 475 477
bitcount                               based           fixed bin(24,0)          array level 3 dcl 5-10 set ref 294
bound_seg_name           11            based           char(32)                 level 2 in structure "v1_inp" packed unaligned
                                                                                  dcl 582 in procedure "CONVERT_I_TO_II" ref 641
bound_seg_name           11            based           char(32)                 level 2 in structure "inp" packed unaligned dcl 5-10
                                                                                  in procedure "bind_" set ref 641*
brief_opt                47(04)        based           bit(1)                   level 3 packed unaligned dcl 5-10 set ref 208 270
bx_$addname                     000234 external static fixed bin(17,0)          dcl 1-58 set ref 554*
bx_$adnp                        000162 external static pointer                  dcl 1-36 set ref 244*
bx_$area_begin                  000140 external static fixed bin(18,0)          dcl 1-25 set ref 162
bx_$bdefp                       000164 external static pointer                  dcl 1-38 set ref 439* 444
bx_$blnkp                       000170 external static pointer                  dcl 1-40 set ref 424* 426 427 433* 443 444 445 447
                                                                                  465 473
bx_$bound_segname               000210 external static char(32)                 dcl 1-48 set ref 252 254* 270* 375 502 527* 555*
                                                                                  555*
bx_$bound_sep_stat              000250 external static fixed bin(17,0)          dcl 1-64 set ref 305* 307* 349 423 489
bx_$brief                       000240 external static fixed bin(17,0)          dcl 1-60 set ref 208*
bx_$bseg_acinfop                000214 external static pointer                  dcl 1-50 set ref 167*
bx_$bseg_bitcount               000216 external static fixed bin(24,0)          dcl 1-51 set ref 490* 493 497*
bx_$bsegp                       000150 external static pointer                  dcl 1-30 set ref 167*
bx_$bstatp                      000166 external static pointer                  dcl 1-39 set ref 427* 430* 432 433
bx_$bsymp                       000172 external static pointer                  dcl 1-41 set ref 447* 466 474
bx_$caller                      000274 external static char(32)                 dcl 1-80 set ref 165*
bx_$ctp                         000142 external static pointer                  dcl 1-26 set ref 260*
bx_$curdeflng                   000254 external static fixed bin(18,0)          dcl 1-69 set ref 420 422* 436 440
bx_$d_lng                       000224 external static fixed bin(18,0)          dcl 1-54 set ref 440*
bx_$debug                       000236 external static fixed bin(17,0)          dcl 1-59 set ref 207*
bx_$fatal_error                 000212 external static fixed bin(17,0)          dcl 1-49 set ref 212* 220 229 247 255* 264 268 301*
                                                                                  309 312 412 450 488* 496 510* 551 635*
bx_$first_rptp                  000156 external static pointer                  dcl 1-34 set ref 237* 460
bx_$force_order                 000242 external static fixed bin(17,0)          dcl 1-61 set ref 209*
bx_$freep                       000144 external static pointer                  dcl 1-27 ref 224 231 236 260 283 350 356 361 361 363
bx_$has_comb_stat               000246 external static fixed bin(17,0)          dcl 1-63 ref 305
bx_$has_sep_stat                000244 external static fixed bin(17,0)          dcl 1-62 ref 305
bx_$i_lng                       000226 external static fixed bin(17,0)          dcl 1-55 set ref 441* 445 489
bx_$inpp                        000146 external static pointer                  dcl 1-29 set ref 164* 249
bx_$l_lng                       000230 external static fixed bin(17,0)          dcl 1-56 set ref 438* 443 447 489
bx_$last_rptp                   000160 external static pointer                  dcl 1-35 set ref 237*
bx_$maxlinklng                  000260 external static fixed bin(17,0)          dcl 1-71 set ref 304* 304 348* 361 361
bx_$n_firstrefs                 000206 external static fixed bin(17,0)          dcl 1-47 ref 405
bx_$n_lng                       000270 external static fixed bin(17,0)          dcl 1-76 set ref 375* 376 376*
bx_$ncomp                       000264 external static fixed bin(17,0)          dcl 1-74 set ref 243* 262
bx_$o_lng                       000220 external static fixed bin(19,0)          dcl 1-52 set ref 489* 490 493*
bx_$oddname_limit               000134 external static fixed bin(17,0)          dcl 1-22 ref 233
bx_$odnp                        000154 external static pointer                  dcl 1-33 set ref 231*
bx_$s_lng                       000232 external static fixed bin(18,0)          dcl 1-57 set ref 380* 388 489
bx_$size                        000130 external static fixed bin(17,0)          dcl 1-20 ref 162
bx_$snt_limit                   000132 external static fixed bin(17,0)          dcl 1-21 ref 226
bx_$sntp                        000174 external static pointer                  dcl 1-42 set ref 224*
bx_$stringmap_limit             000136 external static fixed bin(17,0)          dcl 1-23 ref 365
bx_$strmp                       000204 external static pointer                  dcl 1-46 set ref 363*
bx_$t_lng                       000222 external static fixed bin(18,0)          dcl 1-53 set ref 436* 489
bx_$tdefp                       000176 external static pointer                  dcl 1-43 set ref 347* 424 430 439
bx_$temp                        000152 external static pointer                  dcl 1-31 set ref 167* 188
bx_$temp_bsegp                  000272 external static pointer                  dcl 1-79 set ref 167* 176 176* 347 464 497* 521
bx_$textlng                     000252 external static fixed bin(18,0)          dcl 1-68 set ref 342 344* 436
bx_$tintlng                     000256 external static fixed bin(17,0)          dcl 1-70 ref 298 352 358 431 433 441
bx_$tintp                       000200 external static pointer                  dcl 1-44 set ref 350* 352 359* 432
bx_$tlinklng                    000262 external static fixed bin(17,0)          dcl 1-73 set ref 371* 425 431 434
bx_$tlinkp                      000202 external static pointer                  dcl 1-45 set ref 352* 356* 426
bx_$v_lng                       000266 external static fixed bin(17,0)          dcl 1-75 set ref 222* 379
bx_$vers_name                   000126 external static char(168)                dcl 1-18 ref 222
caller_name               1            based           char(32)                 level 2 in structure "inp" packed unaligned dcl 5-10
                                                                                  in procedure "bind_" set ref 165 193* 202* 254*
                                                                                  299* 487* 509* 519* 555* 640*
caller_name               1            based           char(32)                 level 2 in structure "v1_inp" packed unaligned
                                                                                  dcl 582 in procedure "CONVERT_I_TO_II" ref 640
cbitcount                60            based           fixed bin(24,0)          level 2 dcl 2-16 set ref 294*
cindex                   47            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 287*
cleanup                         000232 stack reference condition                dcl 119 ref 175
clngns                   67            based           fixed bin(18,0)          level 2 dcl 2-16 set ref 392 394
clngns_overlay                         based           structure                level 1 dcl 144
code                            000107 automatic       fixed bin(35,0)          dcl 99 in procedure "bind_" set ref 190* 191 193*
                                                                                  484* 485 497* 506* 509* 515* 516 516 538* 545*
                                                                                  547* 632* 633 634*
code                      2(09)        based           char(1)                  level 2 in structure "rpte" packed unaligned
                                                                                  dcl 3-63 in procedure "bind_" ref 473 474
com_err_                        000012 constant        entry                    external dcl 56 ref 193 202 254 299 487 509 519 555
                                                                                  634
comp                                   based           structure                level 1 dcl 2-16 set ref 286*
comp_tbl                               based           pointer                  array dcl 2-12 set ref 263 263 283* 390 401
cpads                    71            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 392* 394
crels                    75            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 393*
ctep                            000250 automatic       pointer                  dcl 2-10 set ref 283* 285 285 286 287 288 289 292
                                                                                  293 294 295* 390* 392 392 393 394 394 396 396*
                                                                                  401* 402 402*
ctp                             000246 automatic       pointer                  dcl 2-10 set ref 260* 263 263 283 390 401
ctxtp                    14            based           pointer                  level 2 dcl 2-16 set ref 293*
debug                    47            based           bit(1)                   level 3 packed unaligned dcl 5-10 set ref 207
decode_link_$init               000014 constant        entry                    external dcl 57 ref 382
def_offset                1            based           bit(18)                  level 2 packed unaligned dcl 4-52 set ref 444*
dirname                         000126 automatic       char(168)                dcl 102 set ref 501* 506* 527* 528
dissect_object_                 000016 constant        entry                    external dcl 58 ref 295
dissect_object_$init            000020 constant        entry                    external dcl 59 ref 280
divide                                                 builtin function         dcl 115 ref 343 379 380 421 437 493 529 542
entry                   326            based           structure                array level 2 in structure "snt" dcl 3-21
                                                                                  in procedure "bind_" set ref 227 227 332
entry                     2            based           structure                array level 2 in structure "od" dcl 3-48
                                                                                  in procedure "bind_" set ref 234 234
entry                     2            based           structure                array level 2 in structure "rpt" dcl 3-57
                                                                                  in procedure "bind_" set ref 463
entry                  1541            based           structure                array level 2 in structure "strm" packed unaligned
                                                                                  dcl 3-73 in procedure "bind_" set ref 366 366
error_table_$pathlong           000122 external static fixed bin(35,0)          dcl 124 set ref 254*
error_table_$segnamedup         000124 external static fixed bin(35,0)          dcl 124 ref 516
ext_link_$finish                000024 constant        entry                    external dcl 61 ref 411
ext_link_$init                  000022 constant        entry                    external dcl 60 ref 385
fatal_binder_error              000240 stack reference condition                dcl 120 ref 211
filename                               based           char(32)                 level 2 in structure "comp" dcl 2-16 in procedure
                                                                                  "bind_" set ref 288* 289
filename                               based           char(32)                 array level 3 in structure "inp" packed unaligned
                                                                                  dcl 5-10 in procedure "bind_" set ref 288
fixed                                                  builtin function         dcl 115 ref 207 469 470 471 472
fn_lng                   52            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 292*
force_order_opt          47(05)        based           bit(1)                   level 3 packed unaligned dcl 5-10 set ref 209
form_bind_map_                  000032 constant        entry                    external dcl 64 ref 538
form_link_info_                 000034 constant        entry                    external dcl 65 ref 545
generate_def_$init              000026 constant        entry                    external dcl 62 ref 386
generate_first_ref_traps_       000040 constant        entry                    external dcl 67 ref 405
get_temp_segment_               000030 constant        entry                    external dcl 63 ref 632
get_wdir_                       000036 constant        entry                    external dcl 66 ref 501
halfword                               based           structure                level 1 dcl 136 in procedure "bind_"
halfword                  1            based           char(3)                  level 2 in structure "rpte" dcl 3-63 in procedure
                                                                                  "bind_" ref 468
hash_index                      000103 automatic       fixed bin(34,0)          dcl 97 set ref 316* 317* 323* 325* 325 327* 327 331
                                                                                  332
hash_table                             based           pointer                  array level 2 packed unaligned dcl 3-21 set ref 316
                                                                                  317* 327 331 332*
hash_thread             344            based           pointer                  array level 3 dcl 3-21 set ref 331*
hbound                                                 builtin function         dcl 115 ref 316 327
hcs_$chname_seg                 000046 constant        entry                    external dcl 70 ref 515
hcs_$set_bc_seg                 000044 constant        entry                    external dcl 69 ref 497
i                               000100 automatic       fixed bin(17,0)          dcl 96 set ref 252* 253 253 282* 283 287 288 293
                                                                                  294* 319* 324 325 331 332* 379* 380 389* 390* 400*
                                                                                  401* 462* 463* 503* 504 514
idx                             000304 automatic       fixed bin(17,0)          dcl 578 set ref 656* 657 657 657 657 657 657 657 657
                                                                                  657 657 657 657 658* 661* 662 662 662 662 662 662
                                                                                  662 662 662 662 662 662 662 662 662 662 662 662
                                                                                  663 664 664*
ignore                   53            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 396 402
incorporate_options_            000054 constant        entry                    external dcl 73 ref 311
index                                                  builtin function         dcl 115 ref 252 289 375 503
inp                                    based           structure                level 1 dcl 5-10
inpp                            000112 automatic       pointer                  dcl 101 set ref 160* 164 165 184* 185* 193 200 201
                                                                                  202 202 207 208 209 243 249* 251 254 270 288 293
                                                                                  294 299 487 499 509 519 523 525 529 530 538 539
                                                                                  555 563* 564* 631 632* 639 640 641 642 643 644 644
                                                                                  644 645 647 648 649 650 651 652 654 656 657 658
                                                                                  661 662 663 664 664
int_link_$init                  000042 constant        entry                    external dcl 68 ref 383
ioa_                            000050 constant        entry                    external dcl 71 ref 270
ioa_$rs                         000052 constant        entry                    external dcl 72 ref 527
last_item                76            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 285 285
lhe15                     0(03)        based           bit(15)                  level 2 packed unaligned dcl 139 set ref 470 476*
lhe18                                  based           bit(18)                  level 2 packed unaligned dcl 136 set ref 469 475*
link_begin                6            based           bit(18)                  level 2 packed unaligned dcl 4-52 set ref 370*
linkage_section_lng       6(18)        based           bit(18)                  level 2 packed unaligned dcl 4-52 set ref 443*
linkptr                         000114 automatic       pointer                  dcl 101 set ref 352* 356* 359 370
linksection                            based           fixed bin(17,0)          array dcl 135 set ref 426* 426 432* 432
list_acinfop                    000110 automatic       pointer                  dcl 100 set ref 167* 178 178* 506* 547*
list_bc                   4     000222 automatic       fixed bin(24,0)          level 2 dcl 106 set ref 522* 533* 542 544* 544 547*
list_opt                 47(03)        based           bit(1)                   level 3 packed unaligned dcl 5-10 set ref 523 539
list_ptr                  2     000222 automatic       pointer                  level 2 dcl 106 set ref 505* 506* 507 515* 526 543
                                                                                  547 547*
list_seg                 47(01)        based           bit(1)                   level 3 packed unaligned dcl 5-10 set ref 251 499
listname                        000210 automatic       char(32)                 dcl 103 set ref 513* 514* 515* 519*
lng                             000105 automatic       fixed bin(18,0)          dcl 98 in procedure "bind_" set ref 289* 290 290*
                                                                                  291* 291 292 529* 530 530 531* 531 532 533 542*
                                                                                  543
lng                     337            based           fixed bin(17,0)          array level 3 in structure "snt" dcl 3-21
                                                                                  in procedure "bind_" set ref 324
long                      5     000222 automatic       fixed bin(17,0)          level 2 dcl 106 set ref 535* 541*
make_bindmap_                   000056 constant        entry                    external dcl 74 ref 457
make_bound_object_map_          000066 constant        entry                    external dcl 78 ref 484
make_defs_$close_section        000064 constant        entry                    external dcl 77 ref 409
make_defs_$open_section         000062 constant        entry                    external dcl 76 ref 384
make_defs_$regenerate_block     000060 constant        entry                    external dcl 75 ref 402
map_opt                  47(02)        based           bit(1)                   level 3 packed unaligned dcl 5-10 set ref 538
max_size                323            based           fixed bin(17,0)          level 2 in structure "snt" dcl 3-21 in procedure
                                                                                  "bind_" set ref 226* 227 227
max_size                               based           fixed bin(17,0)          level 2 in structure "od" dcl 3-48 in procedure
                                                                                  "bind_" set ref 233* 234 234
max_size               1537            based           fixed bin(17,0)          level 2 in structure "strm" dcl 3-73 in procedure
                                                                                  "bind_" set ref 365* 366 366
min                                                    builtin function         dcl 115 ref 304 324
mod                                                    builtin function         dcl 115 ref 327
n_names                 324            based           fixed bin(17,0)          level 2 dcl 3-21 ref 319
name                    326            based           char(33)                 array level 3 dcl 3-21 set ref 325
narc                     21            based           fixed bin(17,0)          level 2 in structure "v1_inp" dcl 582 in procedure
                                                                                  "CONVERT_I_TO_II" ref 642
narc                     21            based           fixed bin(17,0)          level 2 in structure "inp" dcl 5-10 in procedure
                                                                                  "bind_" set ref 642* 644
new_order                              based           fixed bin(9,0)           array level 3 packed unsigned unaligned dcl 5-10 set
                                                                                  ref 663*
next_temp_ptr                          based           pointer                  level 2 dcl 150 ref 189
nobj                     24            based           fixed bin(17,0)          level 2 in structure "inp" dcl 5-10 in procedure
                                                                                  "bind_" set ref 243 645* 661
nobj                   5262            based           fixed bin(17,0)          level 2 in structure "v1_inp" dcl 582 in procedure
                                                                                  "CONVERT_I_TO_II" ref 645
nobjects                        000102 automatic       fixed bin(17,0)          dcl 96 set ref 262* 263 263 282 389 400
nopts                     6     000222 automatic       fixed bin(17,0)          level 2 dcl 106 set ref 537*
npt                       1            based           fixed bin(17,0)          level 2 dcl 3-57 set ref 241* 462
ntotal                   23            based           fixed bin(17,0)          level 2 dcl 5-10 set ref 288 293 294 644* 656 662
                                                                                  662 662 662 662 662 662 662 662 662 663 664 664
null                                                   builtin function         dcl 115 ref 167 176 178 183 188 240 244 317 460 505
                                                                                  507 525 547 562
nupd                     22            based           fixed bin(17,0)          level 2 in structure "v1_inp" dcl 582 in procedure
                                                                                  "CONVERT_I_TO_II" ref 643
nupd                     22            based           fixed bin(17,0)          level 2 in structure "inp" dcl 5-10 in procedure
                                                                                  "bind_" set ref 643* 644
obj                                    based           structure                level 1 dcl 5-63 in procedure "bind_"
obj                                    based           structure                array level 2 in structure "inp" dcl 5-10
                                                                                  in procedure "bind_" set ref 662*
obj_ptr                         000222 automatic       pointer                  level 2 dcl 106 set ref 521*
objectname_stmt                        based           bit(1)                   array level 3 packed unaligned dcl 5-10 set ref 664*
od                                     based           structure                level 1 dcl 3-48
odd                       0(35)        based           bit(1)                   level 2 packed unaligned dcl 144 ref 392
odnp                            000254 automatic       pointer                  dcl 3-17 set ref 231* 233 234 234 234 234
old_ptr                         000116 automatic       pointer                  dcl 101 set ref 167* 183 185 562 564 631* 640 641
                                                                                  642 643 645 647 648 649 650 651 652 654 657 662
options                  47            based           structure                level 2 in structure "inp" dcl 5-10 in procedure
                                                                                  "bind_" set ref 654*
options                5261            based           structure                level 2 in structure "v1_inp" dcl 582 in procedure
                                                                                  "CONVERT_I_TO_II" ref 654
p                               000120 automatic       pointer                  dcl 101 set ref 188* 188* 189 190* 526* 528 530 532
parse_bindfile_                 000070 constant        entry                    external dcl 79 ref 246
pbase                     2            based           char(1)                  level 2 packed unaligned dcl 3-63 ref 464 465 466
pexpr                     0(18)        based           bit(18)                  level 2 packed unaligned dcl 3-63 ref 472
poffset                                based           bit(18)                  level 2 packed unaligned dcl 3-63 ref 467
pos                             000101 automatic       fixed bin(17,0)          dcl 96 set ref 324* 325*
pr_offset                              based           structure                level 1 dcl 139
rank                                                   builtin function         dcl 117 ref 222
rebuild_object_                 000074 constant        entry                    external dcl 81 ref 396
rebuild_object_$init            000072 constant        entry                    external dcl 80 ref 381
rel                                                    builtin function         dcl 115 ref 444 473 474
release_temp_segment_           000076 constant        entry                    external dcl 82 ref 184 190 563
relocate_symbol_                000010 constant        entry                    external dcl 55 ref 449
reset_bx                               based           fixed bin(35,0)          array dcl 147 set ref 162*
rhe15                     0(21)        based           bit(15)                  level 2 packed unaligned dcl 139 ref 476
rhe18                     0(18)        based           bit(18)                  level 2 packed unaligned dcl 136 set ref 471 477*
rpt                                    based           structure                level 1 dcl 3-57 set ref 239 239 239 239
rpte                                   based           structure                level 1 dcl 3-63
rptep                           000260 automatic       pointer                  dcl 3-17 set ref 463* 464 465 466 467 468 472 473
                                                                                  474
rptp                            000256 automatic       pointer                  dcl 3-17 set ref 236* 237 239 239 239 239 240 241
                                                                                  460* 460* 462 463* 479
seg                                    based           structure                level 1 dcl 3-29
segname                         000200 automatic       char(32)                 dcl 102 set ref 502* 503 504* 506* 509* 513 519*
size                                                   builtin function         dcl 116 ref 239 239
snt                                    based           structure                level 1 dcl 3-21
sntp                            000252 automatic       pointer                  dcl 3-17 set ref 224* 226 227 227 227 227 316 317
                                                                                  319 324 325 327 331 331 332 332
sp                              000122 automatic       pointer                  dcl 101 set ref 189* 196
standalone_seg          177            based           bit(1)                   array level 3 packed unaligned dcl 5-10 set ref 658*
static_length             7(18)        based           bit(18)                  level 2 packed unaligned dcl 4-52 set ref 445*
strm                                   based           structure                level 1 dcl 3-73
strmp                           000262 automatic       pointer                  dcl 3-17 set ref 363* 365 366 366 366 366
substr                                                 builtin function         dcl 115 set ref 222 325 504* 514* 528* 528 530* 530
                                                                                  532* 543*
symb_relc                       000106 automatic       fixed bin(18,0)          dcl 98 set ref 388* 393 394* 394
temp_mgr_$allocate              000100 constant        entry                    external dcl 83 ref 348
temp_mgr_$close_files           000110 constant        entry                    external dcl 87 ref 560
temp_mgr_$init                  000104 constant        entry                    external dcl 85 ref 218
temp_mgr_$make_object           000106 constant        entry                    external dcl 86 ref 267
temp_mgr_$reserve               000102 constant        entry                    external dcl 84 ref 227 234 239 263 285 361 366
temp_seg                               based           structure                level 1 dcl 150
terminate_file_                 000112 constant        entry                    external dcl 88 ref 176
textp                           000124 automatic       pointer                  dcl 101 set ref 464* 465* 466* 467* 467 469 470 471
                                                                                  475 476 477
thread                                 based           pointer                  level 2 packed unaligned dcl 3-57 set ref 240* 479
to_be_ignored                          based           bit(1)                   array level 3 packed unaligned dcl 5-10 set ref 664*
tssi_$clean_up_segment          000114 constant        entry                    external dcl 89 ref 178
tssi_$finish_segment            000120 constant        entry                    external dcl 91 ref 547
tssi_$get_segment               000116 constant        entry                    external dcl 90 ref 506
unspec                                                 builtin function         dcl 115 set ref 286* 325 541* 654* 654
v1_inp                                 based           structure                level 1 dcl 582
v1_obj                 5264            based           structure                array level 2 in structure "v1_inp" dcl 582
                                                                                  in procedure "CONVERT_I_TO_II" ref 662
v1_obj                                 based           structure                level 1 dcl 619 in procedure "CONVERT_I_TO_II"
val                             000104 automatic       fixed bin(18,0)          dcl 98 set ref 342* 343* 343 344 347 351* 358* 370
                                                                                  371 420* 421* 421 422 424 425* 426 430 431* 432
                                                                                  434* 437* 437 438 469* 470* 471* 472* 472 473* 473
                                                                                  474* 474 475 476 477 527* 528 528 530 531
version                                based           char(4)                  level 2 dcl 5-10 set ref 200 201 202* 639*
virgin_linkage_header                  based           structure                level 1 dcl 4-52
whalf                           000220 automatic       char(3)                  dcl 104 set ref 468* 469 470 471 475 476
x                               000222 automatic       structure                level 1 dcl 106 set ref 538 538 545 545

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
INTERNALLY_RESOLVED                    internal static bit(18)                  initial unaligned dcl 3-91
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 6-12
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 6-16
TERM_FILE_TERM                         internal static bit(3)                   initial unaligned dcl 6-14
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 6-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 6-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 6-15
UNRESOLVED                             internal static bit(18)                  initial unaligned dcl 3-90
adnp                                   automatic       pointer                  dcl 3-17
an                                     based           structure                level 1 dcl 3-40
bx_$addname_limit                      external static fixed bin(17,0)          dcl 1-24
bx_$bindmap_def                        external static pointer                  dcl 1-37
bx_$bproc                              external static fixed bin(17,0)          dcl 1-67
bx_$isp                                external static pointer                  dcl 1-28
bx_$maxdeflng                          external static fixed bin(18,0)          dcl 1-72
bx_$nsegdefs                           external static fixed bin(17,0)          dcl 1-78
bx_$nsymdefs                           external static fixed bin(17,0)          dcl 1-77
bx_$optp                               external static pointer                  dcl 1-32
bx_$perprocess_static                  external static fixed bin(17,0)          dcl 1-65
bx_$standard                           external static fixed bin(17,0)          dcl 1-66
bx_$vers_number                        external static fixed bin(17,0)          dcl 1-19
exp_word                               based           structure                level 1 dcl 4-21
header                                 based           structure                level 1 dcl 4-31
link                                   based           structure                level 1 dcl 4-11
linkage_header_flags                   based           structure                level 1 dcl 4-44
lrt                                    based           structure                level 1 dcl 3-84
lrtp                                   automatic       pointer                  dcl 3-17
name                                   based           structure                level 1 dcl 4-70
terminate_file_switches                based           structure                level 1 packed unaligned dcl 6-4
trap_word                              based           structure                level 1 dcl 4-66
type_pair                              based           structure                level 1 dcl 4-25

NAMES DECLARED BY EXPLICIT CONTEXT.
CONVERT_I_TO_II                 003070 constant        entry                    internal dcl 571 ref 200
bind_                           000221 constant        entry                    external dcl 48
output_bindmap                  002660 constant        label                    dcl 535 ref 525
return                          002770 constant        label                    dcl 551 ref 213 220 229 247 256 264 268 309 312 412
                                                                                  450 496 511 636

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4576        5074    3457        4606
Length      5604    3457       276         473    1117           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bind_                               332 external procedure  is an external procedure.  
on unit on line 175                  86 on unit               
on unit on line 211                  64 on unit               
CONVERT_I_TO_II                         internal procedure  shares stack frame of external procedure bind_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bind_                    000100 i                           bind_
                         000101 pos                         bind_
                         000102 nobjects                    bind_
                         000103 hash_index                  bind_
                         000104 val                         bind_
                         000105 lng                         bind_
                         000106 symb_relc                   bind_
                         000107 code                        bind_
                         000110 list_acinfop                bind_
                         000112 inpp                        bind_
                         000114 linkptr                     bind_
                         000116 old_ptr                     bind_
                         000120 p                           bind_
                         000122 sp                          bind_
                         000124 textp                       bind_
                         000126 dirname                     bind_
                         000200 segname                     bind_
                         000210 listname                    bind_
                         000220 whalf                       bind_
                         000222 x                           bind_
                         000246 ctp                         bind_
                         000250 ctep                        bind_
                         000252 sntp                        bind_
                         000254 odnp                        bind_
                         000256 rptp                        bind_
                         000260 rptep                       bind_
                         000262 strmp                       bind_
                         000264 NOBJ                        bind_
                         000265 NTOTAL                      bind_
                         000304 idx                         CONVERT_I_TO_II

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          tra_ext_1           mdfx1               enable_op
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      decode_link_$init             dissect_object_               dissect_object_$init
ext_link_$finish              ext_link_$init                form_bind_map_                form_link_info_
generate_def_$init            generate_first_ref_traps_     get_temp_segment_             get_wdir_
hcs_$chname_seg               hcs_$set_bc_seg               incorporate_options_          int_link_$init
ioa_                          ioa_$rs                       make_bindmap_                 make_bound_object_map_
make_defs_$close_section      make_defs_$open_section       make_defs_$regenerate_block   parse_bindfile_
rebuild_object_               rebuild_object_$init          release_temp_segment_         relocate_symbol_
temp_mgr_$allocate            temp_mgr_$close_files         temp_mgr_$init                temp_mgr_$make_object
temp_mgr_$reserve             terminate_file_               tssi_$clean_up_segment        tssi_$finish_segment
tssi_$get_segment

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bx_$addname                   bx_$adnp                      bx_$area_begin                bx_$bdefp
bx_$blnkp                     bx_$bound_segname             bx_$bound_sep_stat            bx_$brief
bx_$bseg_acinfop              bx_$bseg_bitcount             bx_$bsegp                     bx_$bstatp
bx_$bsymp                     bx_$caller                    bx_$ctp                       bx_$curdeflng
bx_$d_lng                     bx_$debug                     bx_$fatal_error               bx_$first_rptp
bx_$force_order               bx_$freep                     bx_$has_comb_stat             bx_$has_sep_stat
bx_$i_lng                     bx_$inpp                      bx_$l_lng                     bx_$last_rptp
bx_$maxlinklng                bx_$n_firstrefs               bx_$n_lng                     bx_$ncomp
bx_$o_lng                     bx_$oddname_limit             bx_$odnp                      bx_$s_lng
bx_$size                      bx_$snt_limit                 bx_$sntp                      bx_$stringmap_limit
bx_$strmp                     bx_$t_lng                     bx_$tdefp                     bx_$temp
bx_$temp_bsegp                bx_$textlng                   bx_$tintlng                   bx_$tintp
bx_$tlinklng                  bx_$tlinkp                    bx_$v_lng                     bx_$vers_name
error_table_$pathlong         error_table_$segnamedup




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     48 000216    5   80 000226       160 000230       162 000234       164 000246       165 000250       167 000254
    175 000263       176 000277       178 000331       183 000345       184 000352       185 000376       188 000402
    189 000415       190 000420       191 000443       193 000446       194 000464       196 000465       197 000470
    200 000471       201 000476       202 000500       203 000532       207 000533       208 000540       209 000544
    211 000550       212 000564       213 000566       218 000571       220 000576       222 000602       224 000605
    226 000611       227 000614       229 000625       231 000630       233 000634       234 000636       236 000650
    237 000654       239 000657       240 000672       241 000674       243 000676       244 000702       246 000704
    247 000710       249 000714       251 000717       252 000723       253 000735       254 000740       255 000771
    256 000774       260 000775       262 001001       263 001003       264 001014       267 001020       268 001024
    270 001030       280 001054       282 001061       283 001071       285 001100       286 001111       287 001115
    288 001117       289 001132       290 001143       291 001147       292 001151       293 001153       294 001163
    295 001170       296 001177       298 001201       299 001205       301 001232       304 001235       305 001242
    307 001252       309 001253       311 001256       312 001262       316 001266       317 001273       318 001276
    319 001300       323 001311       324 001312       325 001327       326 001350       327 001352       331 001360
    332 001366       333 001370       342 001372       343 001375       344 001401       347 001402       348 001407
    349 001415       350 001421       351 001424       352 001426       354 001435       356 001436       358 001442
    359 001445       361 001450       363 001463       365 001470       366 001473       370 001503       371 001511
    375 001514       376 001525       379 001531       380 001535       381 001541       382 001545       383 001552
    384 001557       385 001564       386 001571       388 001576       389 001601       390 001611       392 001615
    393 001622       394 001624       396 001627       397 001640       400 001642       401 001651       402 001655
    403 001666       405 001670       409 001677       411 001704       412 001711       420 001715       421 001717
    422 001723       423 001724       424 001726       425 001733       426 001735       427 001743       428 001746
    430 001747       431 001754       432 001757       433 001765       434 001771       436 001773       437 001776
    438 002003       439 002004       440 002007       441 002011       443 002013       444 002022       445 002026
    447 002033       449 002037       450 002043       457 002047       460 002053       462 002064       463 002075
    464 002101       465 002113       466 002122       467 002130       468 002135       469 002137       470 002145
    471 002154       472 002161       473 002164       474 002201       475 002211       476 002222       477 002232
    478 002237       479 002241       484 002244       485 002253       487 002255       488 002303       489 002306
    490 002316       493 002320       496 002324       497 002327       499 002341       501 002347       502 002356
    503 002363       504 002374       505 002377       506 002401       507 002430       509 002434       510 002456
    511 002461       513 002462       514 002465       515 002471       516 002516       519 002523       521 002556
    522 002562       523 002563       525 002571       526 002575       527 002577       528 002626       529 002633
    530 002637       531 002643       532 002645       533 002654       535 002660       537 002662       538 002663
    539 002704       541 002712       542 002714       543 002717       544 002726       545 002730       547 002743
    551 002770       554 002774       555 002775       560 003030       562 003035       563 003041       564 003065
    568 003067       571 003070       631 003071       632 003073       633 003116       634 003120       635 003146
    636 003151       639 003152       640 003154       641 003161       642 003164       643 003166       644 003170
    645 003172       647 003174       648 003176       649 003201       650 003204       651 003206       652 003210
    654 003212       656 003214       657 003223       658 003261       659 003263       661 003265       662 003275
    663 003422       664 003434       666 003450       668 003452


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
