	COMPILATION LISTING OF SEGMENT checker_load_MST_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 07/16/87  1336.4 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(87-01-13,GDixon), approve(87-04-16,MCR7614),
       12*     audit(87-05-21,Farley), install(87-07-15,MR12.1-1040):
       13*     Add support for storing boot program as first segment of MST image stored
       14*     in a file.
       15*                                                   END HISTORY COMMENTS */
       16 
       17 
       18 /* checker_load_MST_.pl1 -- eat an entire Multics system tape */
       19 /* format: style2 */
       20 /* BIM 8/82, bugfix to linkage sections 11/82 */
       21 /* Modified by Keith Loepere to handle collections in which objects aren't 
       22*   loaded into segments. */
       23 /* Modified 3/84 by Keith Loepere for "unpaged segs" and bugfixes. */
       24 /* Modified 1/85 by Keith Loepere to really understand unloaded collections. */
       25 
       26 checker_load_MST_:
       27      procedure;
       28 
       29 
       30 /* This program reads an MST, building the data structure */
       31 /* needed to do a crossreference later. As it goes, it checks */
       32 /* for a variety of errors. Emphasis is given to errors made */
       33 /* be the preparer of the header file, RATHER than on generate_mst */
       34 /* gratuitously screwing up. Useful data on each segment is printed, */
       35 /* and serious errors (overflowed segments) produce com_err_ calls. */
       36 
       37 /* We expect tape_reader_ to signal MST_tape_eof_ if it runs out of */
       38 /* tape. */
       39 
       40 	dcl     absolute_pathname_	 entry (char (*), char (*), fixed bin (35));
       41 
       42 	dcl     checker_print_	 entry options (variable);
       43 	dcl     checker_print_$error	 entry options (variable);
       44 	dcl     checker_print_$skip	 entry;
       45 	dcl     checker_print_$page	 entry;
       46 	dcl     ioa_		 entry () options (variable);
       47 	dcl     tape_reader_	 entry (ptr, fixed bin (18));
       48 	dcl     sslt_manager_$build_entry
       49 				 entry (ptr, ptr, fixed bin (17));
       50 	dcl     sslt_manager_$get_seg_num
       51 				 entry (char (32), fixed bin (18), fixed bin (35));
       52 	dcl     object_info_$brief	 entry (ptr, fixed bin (24), ptr, fixed bin (35));
       53 
       54 	dcl     com_err_		 entry () options (variable);
       55 	dcl     error_table_$namedup	 fixed bin (35) ext static;
       56 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
       57 	dcl     ME		 char (32) init ("checker_load_MST_") int static options (constant);
       58 
       59 	dcl     (addr, addrel, after, baseno, before, bin, char, currentsize, divide, hbound, index, max, min, ptr,
       60 	        substr, sum, unspec, size)
       61 				 builtin;
       62 
       63 
       64 	dcl     collection_started	 bit (1) aligned;
       65 	dcl     header_ptr		 pointer;
       66 	dcl     header_area		 (1000) bit (36) aligned;
       67 	dcl     HEADER_MAX_SIZE	 fixed bin init (1000) int static options (constant);
       68 
       69 
       70 	declare 1 control_word	 aligned,
       71 		2 type		 fixed bin (18) uns unal,
       72 		2 count		 fixed bin (18) uns unal;
       73 
       74 	declare 1 collection_mark	 aligned,
       75 		2 major		 fixed bin (18) uns unal,
       76 		2 minor		 fixed bin (18) uns unal;
       77 
       78 	declare (
       79 	        SEGMENT		 init (1),
       80 	        HEADER		 init (0),
       81 	        COLLECTION_MARK	 init (2)
       82 	        )			 fixed bin (18) uns int static options (constant);
       83 
       84 /* format: off */
       85  /* BEGIN INCLUDE FILE slt.incl.pl1 --- Last modified 2/76 SHW */
  1     2 
  1     3 /* Declarations for Segment Loading Table header and array.
  1     4*
  1     5*   Used by Initialization and MST Checker subroutines */
  1     6 
  1     7 dcl sltp ptr,					/* pointer to base of SLT segment */
  1     8     names_ptr ptr,					/* pointer to base of SLT names segment */
  1     9     namep ptr,					/* pointer to segment name list block */
  1    10     pathp ptr,					/* pointer to segment's directory path name */
  1    11     aclp ptr;					/* pointer to acl structure */
  1    12 
  1    13 declare 1 slt based (sltp) aligned,			/* declaration of Segment Loading Table (SLT) */
  1    14 	2 name_seg_ptr ptr,				/* words 0-1, pointer (ITS pair) to name segment */
  1    15 	2 free_core_start fixed bin (24),		/* word 2, start of free core after perm-wired */
  1    16 	2 first_sup_seg fixed bin (18),		/* word 3, first supervisor segment number */
  1    17 	2 last_sup_seg fixed bin (18), 		/* word 4, last supervisor segment number */
  1    18 	2 first_init_seg fixed bin (18),		/* word 5, first initializer segment number */
  1    19 	2 last_init_seg fixed bin (18),		/* word 6, last initializer segment number */
  1    20 	2 free_core_size fixed bin (24),		/* size (in words) of free core after perm-wired */
  1    21 	2 seg (0:8191) aligned,			/* segment entries (4 words each) */
  1    22 	  3 slte (4) fixed bin (35);			/* Space for SLT entries */
  1    23 
  1    24 /* auxiliary segment of SLT for storing of segment names and directory path names */
  1    25 
  1    26 declare 1 name_seg based (names_ptr) aligned,		/* name segment header */
  1    27 	2 pad bit (18) unal,
  1    28 	2 next_loc bit (18) unal,			/* Next available free location in name seg */
  1    29 	2 ht (0:127) bit (18) aligned;		/* Names hash table */
  1    30 
  1    31 declare 1 segnam based (namep) aligned,			/* declaration for segment name block */
  1    32 	2 count fixed bin (17),			/* number of segment names in this block */
  1    33 	2 names (50 refer (segnam.count)),		/* segment name array */
  1    34 	  3 hp bit (18) unal,			/* hash thread pointer */
  1    35 	  3 ref bit (1) unal,			/* "1"b if name referenced */
  1    36 	  3 pad bit (5) unal,
  1    37 	  3 segno bit (12) unal,			/* segment number associated with this name */
  1    38 	  3 name char (32) unal;			/* space for name (max 32 characters) */
  1    39 
  1    40 declare 1 path based (pathp) aligned,			/* declaration for directory path name */
  1    41 	2 size fixed bin (17),			/* length of pathname */
  1    42 	2 name char (168 refer (path.size)) unal,	/* directory path name */
  1    43 	2 acls fixed bin;				/* ACL list starts here */
  1    44 
  1    45 declare 1 acls based (aclp) aligned,			/* declaration for acl list */
  1    46 	2 count fixed bin,				/* number of entries in acl list */
  1    47 	2 acl (50 refer (acls.count)),		/* array of acl entries */
  1    48 	  3 userid char (32),			/* user specification */
  1    49 	  3 mode bit (36) aligned,			/* mode for the specified user */
  1    50 	  3 pad bit (36) aligned,
  1    51 	  3 code fixed bin;
  1    52 
  1    53 
  1    54 /* END INCLUDE FILE slt.incl.pl1 */
       85 
       86  /* BEGIN INCLUDE FILE slte.incl.pl1 */
  2     2 /* Declaration for Segment Loading Table Entry structure.
  2     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
  2     4 /* modified 5/4/76 by Noel I. Morris	*/
  2     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
  2     6 /* format: style3 */
  2     7 
  2     8 dcl	sltep		ptr;
  2     9 
  2    10 dcl	1 slte_uns	based (sltep) aligned,
  2    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  2    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  2    13 /**** End of word 1 */
  2    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
  2    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  2    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  2    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
  2    18 	  2 layout_seg	bit (1),			/* mailbox & such */
  2    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
  2    20 	  2 pad1		bit (3),			/* unused */
  2    21 	  2 wired		bit (1),			/* segment is wired if ON */
  2    22 	  2 paged		bit (1),			/* segment is paged if ON */
  2    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
  2    24 	  2 pad3		bit (2),
  2    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  2    26 /**** End of 1st half of word 2 */
  2    27 	  2 pad4		bit (3),
  2    28 	  2 branch_required bit (1),			/* path name supplied if ON */
  2    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  2    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  2    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  2    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  2    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  2    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  2    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  2    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  2    37 /***** End of word 2 */
  2    38 	  2 pad5		bit (6),
  2    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
  2    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
  2    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
  2    42 /***** End of word 3 */
  2    43 	  2 pad7		bit (3),
  2    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
  2    45 	  2 bit_count	fixed bin (24) uns
  2    46 	  )		unaligned;		/* bitcount of segment */
  2    47 
  2    48 dcl	1 slte		based (sltep) aligned,
  2    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  2    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  2    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
  2    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  2    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  2    54 	  2 firmware_seg    bit (1),
  2    55 	  2 layout_seg      bit (1),
  2    56 	  2 breakpointable  bit (1),
  2    57 	  2 pad2		bit (3),
  2    58 	  2 wired		bit (1),			/* segment is wired if ON */
  2    59 	  2 paged		bit (1),			/* segment is paged if ON */
  2    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
  2    61 	  2 pad3		bit (2),
  2    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  2    63 	  2 pad4		bit (3),
  2    64 	  2 branch_required bit (1),			/* path name supplied if ON */
  2    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  2    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  2    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  2    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  2    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  2    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  2    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  2    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  2    73 	  2 pad5		bit (6),
  2    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
  2    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
  2    76 	  2 segno		bit (18),			/* text/link segment number */
  2    77 	  2 pad6		bit (3),
  2    78 	  2 max_length	bit (9),			/* maximum length for segment */
  2    79 	  2 bit_count	bit (24)
  2    80 	  )		unaligned;		/* bitcount of segment */
  2    81 
  2    82 /* END INCLUDE FILE slte.incl.pl1 */
       86 
       87  /* BEGIN INCLUDE FILE object_link_dcls.incl.pl1 BIM 1981 from linkdcl */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  3     6*     audit(86-11-18,Schroth), install(86-11-20,MR12.0-1222):
  3     7*     Modified to add partial_link structure for an object MSF partially snapped
  3     8*     link.
  3     9*  2) change(86-11-13,DGHowe), approve(86-11-13,MCR7391), audit(86-11-13,Zwick),
  3    10*     install(86-11-20,MR12.0-1222):
  3    11*     Added a declaration of FAULT_TAG_1, FAULT_TAG_2 and FAULT_TAG_3.
  3    12*                                                   END HISTORY COMMENTS */
  3    13 
  3    14 
  3    15 /* format: style3 */
  3    16 /* everything you ever wanted in a linkage section */
  3    17 
  3    18 /*
  3    19* Last Modified (Date and Reason):
  3    20*  15 Nov 1971 by C Garman 
  3    21*   6/75 by M.Weaver to add virgin_linkage_header declaration
  3    22*   6/75 by S.Webber to comment existing structures better
  3    23*   9/77 by M. Weaver to add run_depth to link
  3    24*   7/81 by B. Margulies for firstref structure, unsigned fixed bins.
  3    25*   3/83 by M. Weaver to add flags overlaying def_ptr
  3    26**/
  3    27 
  3    28 declare	1 object_link	based aligned,		/* link pair in linkage section */
  3    29 	  2 header_relp	fixed bin (17) unal,	/* rel pointer to beginning of linkage, always negative */
  3    30 	  2 ringno	fixed bin (3) unsigned unal,	/* MBZ */
  3    31 	  2 mbz		bit (6) unal,
  3    32 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  3    33 	  2 tag		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  3    34 	  2 expression_relp fixed bin (18) unsigned unal, /* pointer (rel to defs) of expression word */
  3    35 	  2 mbz2		bit (12) unal,
  3    36 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  3    37 
  3    38 declare	1 partial_link	based aligned,		/* partially snapped link */
  3    39 	  2 type		fixed bin (3) unsigned unal,	/* target section of link */
  3    40 	  2 component	fixed bin (15) unsigned unal,	/* target component index */
  3    41 	  2 mbz1		bit (12) unal,
  3    42 	  2 tag		bit (6) unal,		/* fault tag 3 47(8), ITS 43(8) if snapped */
  3    43 	  
  3    44 	  2 offset	fixed bin (18) unsigned unal,	/* word offset of link */
  3    45 	  2 mbz2		bit (3) unal,
  3    46 	  2 bit_offset	fixed bin (6) unsigned unal,	/* bit offset (in practice, always 0) */
  3    47 	  2 mbz3		bit (3) unal,
  3    48 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  3    49 
  3    50 declare	1 linkage_header	based aligned,		/* linkage block header */
  3    51 	  2 def_ptr	ptr,			/* pointer to definition section */
  3    52 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  3    53 	  2 original_linkage_ptr
  3    54 			ptr unal,			/* pointer to linkage section in object segment */
  3    55 	  2 unused	bit (72),
  3    56 	  2 stats,
  3    57 	    3 begin_links	fixed bin (18) unsigned unal, /* offset (rel to this section) of first link */
  3    58 	    3 block_length	fixed bin (18) unsigned unal, /* number of words in this linkage section */
  3    59 	    3 segment_number
  3    60 			fixed bin (18) unsigned unal, /* text segment number associated with this section */
  3    61 	    3 static_length fixed bin (18) unsigned unal; /* number of words of static for this segment */
  3    62 
  3    63 declare	1 linkage_header_flags
  3    64 			aligned based,		/* overlay of def_ptr for flags */
  3    65 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  3    66 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  3    67 	  2 perprocess_static
  3    68 			bit (1) unaligned,		/* 1 copy of static section is shared among all tasks/run units */
  3    69 	  2 pad2		bit (6) unaligned;
  3    70 
  3    71 declare	1 virgin_linkage_header
  3    72 			aligned based,		/* template for linkage header in object segment */
  3    73 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  3    74 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  3    75 	  2 def_offset	fixed bin (18) unsigned unaligned,
  3    76 						/* offset of definition section */
  3    77 	  2 first_ref_relp	fixed bin (18) unsigned unaligned,
  3    78 						/* offset of trap-at-first-reference offset array */
  3    79 	  2 filled_in_later bit (144),
  3    80 	  2 link_begin	fixed bin (18) unsigned unaligned,
  3    81 						/* offset of first link */
  3    82 	  2 linkage_section_lng
  3    83 			fixed bin (18) unsigned unaligned,
  3    84 						/* length of linkage section */
  3    85 	  2 segno_pad	fixed bin (18) unsigned unaligned,
  3    86 						/* will be segment number of copied linkage */
  3    87 	  2 static_length	fixed bin (18) unsigned unaligned;
  3    88 						/* length of static section */
  3    89 
  3    90 declare	1 fr_traps	based aligned,		/* First Reference Trap Procedures */
  3    91 	  2 decl_vers	fixed bin,		/* version of this struc, value=1, ABS reloc */
  3    92 	  2 n_traps	fixed bin,		/* number of traps on this segment, ABS */
  3    93 	  2 trap_array	(n_fr_traps refer (fr_traps.n_traps)) aligned,
  3    94 	    3 call_relp	fixed bin (18) unsigned unaligned,
  3    95 						/* LINK18, offset of link defining procedure to call */
  3    96 	    3 info_relp	fixed bin (18) unsigned unaligned;
  3    97 						/* LINK18, offser of link defining argument list for trap proc */
  3    98 
  3    99 declare	FR_TRAPS_VERSION_1	init (1) fixed bin internal static options (constant);
  3   100 declare   FAULT_TAG_1	bit(6) unaligned init ("40"b3) static options (constant);
  3   101 declare   FAULT_TAG_2	bit(6) unaligned init ("46"b3) static options (constant);
  3   102 declare   FAULT_TAG_3	bit(6) unaligned init ("47"b3) static options (constant);
  3   103 
  3   104 /* END INCLUDE FILE object_link_dcls.incl.pl1 */
       87 
       88  /* Begin include file definition_dcls.incl.pl1 BIM 1981 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  4     6*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  4     7*     Modified to add indirect bit to definition flags, add msf_map_relp to the
  4     8*     definition header, declare the msf_map, and add structures and constants
  4     9*     for deferred initialization.
  4    10*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420),
  4    11*     audit(86-08-05,Schroth), install(86-11-20,MR12.0-1222):
  4    12*     added the structures for pointer initialization. pointer_init_template.
  4    13*     changed list_template_entry
  4    14*                                                   END HISTORY COMMENTS */
  4    15 
  4    16 
  4    17 /* Modified:  */
  4    18 /*   13 Dec 1982 by Lee A. Newcomb to put definition_header.hash_table_relp */
  4    19 /*	after unused half-word instead of before it. */
  4    20 /*   1 March 1983 by M. Weaver to add list template init type */
  4    21 
  4    22 /* format: style3,idind25 */
  4    23 /* everything for the definition section */
  4    24 
  4    25 declare	(
  4    26 	CLASS_TEXT	     init (0),		/* text section definition */
  4    27 	CLASS_LINKAGE	     init (1),		/* linkage section definition */
  4    28 	CLASS_SYMBOL	     init (2),		/* symbol section definition */
  4    29 	CLASS_SEGNAME	     init (3),		/* segment name definition */
  4    30 	CLASS_STATIC	     init (4),		/* static section definition */
  4    31 	CLASS_SYSTEM	     init (5),		/* valid only in self links, not def class */
  4    32 	CLASS_HEAP	     init (6)		/* valid only in self links, not def class */
  4    33 	)		     fixed bin (3) unsigned internal static options (constant);
  4    34 
  4    35 declare	CLASS_NAMES	     (0:6) character (12) internal static options (constant)
  4    36 			     init ("text", "linkage", "symbol", "segname", "static", "system", "heap");
  4    37 
  4    38 declare	SYMBOLIC_SECTION_NAMES   (0:6) character (8)
  4    39 			     init ("*text", "*link", "*symbol", *, "*static", "*system", "*heap") internal static
  4    40 			     options (constant);
  4    41 
  4    42 declare	1 definition_flags	     unaligned based,
  4    43 	  2 new		     bit (1),		/* should be "1"b */
  4    44 	  2 ignore	     bit (1),		/* cannot snap link to this */
  4    45 	  2 entry		     bit (1),		/* can tra here */
  4    46 	  2 retain	     bit (1),		/* binder respects this */
  4    47 	  2 argcount	     bit (1),		/* OBSOLETE */
  4    48 	  2 descriptors	     bit (1),		/* OBSOLETE */
  4    49 	  2 indirect	     bit (1),		/* target is a pointer to actual target */
  4    50 	  2 unused	     bit (8);		/* Must be zero */
  4    51 
  4    52 
  4    53 
  4    54 
  4    55 /* Header of the definition section */
  4    56 
  4    57 declare	def_header_ptr	     pointer;
  4    58 declare	1 definition_header	     aligned based (def_header_ptr),
  4    59 	  2 def_list_relp	     fixed bin (18) unsigned unaligned,
  4    60 						/* first definition, reloc def18 */
  4    61 	  2 msf_map_relp	     fixed bin (18) unsigned unaligned,
  4    62 						/* msf_map if any, or 0 if none.  reloc def18 unless none */
  4    63 	  2 hash_table_relp	     fixed bin (18) unsigned unaligned,
  4    64 						/* def hash table, if any, or 0 if none. reloc def18 unless none */
  4    65 	  2 flags		     unaligned like definition_flags;
  4    66 						/* both new and ignore must be "1"b here */
  4    67 
  4    68 /* A non class=3 definition. See segname_definition below for class=3 */
  4    69 
  4    70 
  4    71 declare	def_ptr		     pointer;
  4    72 declare	1 definition	     aligned based (def_ptr),
  4    73 	  2 forward_relp	     unal fixed bin (18) unsigned,
  4    74 						/* offset of next def */
  4    75 	  2 backward_relp	     unal fixed bin (18) unsigned,
  4    76 						/* offset of previous def */
  4    77 	  2 thing_relp	     unal fixed bin (18) unsigned,
  4    78 						/* offset in section specified by class of thing this defines */
  4    79 	  2 flags		     unaligned like definition_flags,
  4    80 	  2 class		     unal fixed bin (3) unsigned,
  4    81 						/* Type of definition */
  4    82 	  2 name_relp	     unal fixed bin (18) unsigned,
  4    83 						/* offset of ACC for symbol */
  4    84 	  2 segname_relp	     unal fixed bin (18) unsigned;
  4    85 						/* offset of segname def to which this belongs */
  4    86 
  4    87 /* Class=3, segname definition */
  4    88 
  4    89 declare	segname_ptr	     pointer;
  4    90 declare	1 segname_definition     aligned based (segname_ptr),
  4    91 	  2 forward_relp	     unal fixed bin (18) unsigned,
  4    92 						/* offset of next def */
  4    93 	  2 backward_relp	     unal fixed bin (18) unsigned,
  4    94 						/* offset of previous def */
  4    95 	  2 next_segname_relp    unal fixed bin (18) unsigned,
  4    96 						/* offset of next segname def */
  4    97 	  2 flags		     unaligned like definition_flags,
  4    98 	  2 class		     unal fixed bin (3) unsigned,
  4    99 						/* 3 for segname */
  4   100 	  2 name_relp	     unal fixed bin (18) unsigned,
  4   101 						/* offset of ACC for symbol */
  4   102 	  2 first_relp	     unal fixed bin (18) unsigned;
  4   103 						/* see following : */
  4   104 
  4   105 /* Definition blocks are chained off of segname definitions.
  4   106*   segname_definition.first_relp is one of three things:
  4   107*    (1) the def section offset of the first ordinary (class^=3) definition
  4   108*      belonging to this segname block. In the case where there are more than
  4   109*      one segname's on a block, all their first_relp will point
  4   110*      to the same place.
  4   111*
  4   112*    (2) if there are no ordinary definitions associated with this segname,
  4   113*      then it is the def section offset of the next segname. 
  4   114*
  4   115*    (3) if there are no ordinary definitions in the block, and it
  4   116*      is the last block, then it points to a word containing 0.
  4   117*
  4   118* Thus the end of a list of synonym segnames can be detected by forward_relp
  4   119*   pointing to a class=3 definition whose first_relp is not the same as
  4   120*   the current definitions first_relp.
  4   121**/
  4   122 
  4   123 /* All the definitions are linked through the forward and
  4   124*   backward thread variables. The end of the chain can is indicated
  4   125*   by forward pointing to a zero word. */
  4   126 
  4   127 
  4   128 declare	exp_ptr		     pointer;
  4   129 declare	1 exp_word	     based (exp_ptr) aligned, /* expression word in link definition */
  4   130 	  2 type_relp	     fixed bin (18) unsigned unal,
  4   131 						/* pointer (rel to defs) of type pair structure */
  4   132 	  2 expression	     fixed bin (17) unal;	/* constant expression to be added in when snapping link */
  4   133 
  4   134 declare	(
  4   135 	LINK_SELF_BASE	     init (1),		/* *section|0+expression,modifier */
  4   136 						/* which section determined by segname_relp */
  4   137 	LINK_OBSOLETE_2	     init (2),		/* not used */
  4   138 	LINK_REFNAME_BASE	     init (3),		/* refname|0+expression,modifier */
  4   139 	LINK_REFNAME_OFFSETNAME  init (4),		/* refname|offsetname+expression,modifier */
  4   140 	LINK_SELF_OFFSETNAME     init (5),		/* *section|offsetname+expression,modifier */
  4   141 	LINK_CREATE_IF_NOT_FOUND init (6),		/* OBSOLETE: like LINK_REFNAME_OFFSETNAME except that it will create instead of taking linkage_error */
  4   142 	SECTION_TEXT	     init (0),		/* *text */
  4   143 	SECTION_LINK	     init (1),		/* *link */
  4   144 	SECTION_SYMBOL	     init (2),		/* *symbol */
  4   145 	SECTION_UNUSED	     init (3),		/* reserved */
  4   146 	SECTION_STATIC	     init (4),		/* *static */
  4   147 	SECTION_SYSTEM	     init (5),		/* *system */
  4   148 	SECTION_HEAP	     init (6)		/* *heap */
  4   149 	)		     fixed bin (18) unsigned unaligned internal static options (constant);
  4   150 
  4   151 /* use CLASS_NAMES for section names */
  4   152 
  4   153 declare	LINK_TYPE_NAMES	     (1:6)
  4   154 			     init ("absolute in section", "unused", "absolute off of refname",
  4   155 			     "symbolic off of refname", "symbolic in section", "symbolic off of refname; create")
  4   156 			     character (32) varying internal static options (constant);
  4   157 
  4   158 
  4   159 declare	type_ptr		     pointer;
  4   160 declare	1 type_pair	     based (type_ptr) aligned,/* type pair in link definition */
  4   161 	  2 type		     fixed bin (18) unsigned unal,
  4   162 						/* see above */
  4   163 	  2 trap_relp	     fixed bin (18) unsigned unal,
  4   164 						/* pointer (rel to defs) to the trap word */
  4   165 						/* unless LINK_SELF_OFFSETNAME off of *system or create link */
  4   166 	  2 segname_relp	     fixed bin (18) unsigned unal,
  4   167 						/* pointer (rel to defs) to ACC reference name for segment referenced, 
  4   168* /*or section code for SELF links */
  4   169 	  2 offsetname_relp	     fixed bin (18) unsigned unal;
  4   170 						/* for OFFSETNAME links, ACC string of name of location. */
  4   171 						/* for others, must be ZERO */
  4   172 
  4   173 
  4   174 /* Link Trap Pair */
  4   175 
  4   176 declare	link_trap_ptr	     pointer;
  4   177 declare	1 link_trap_pair	     aligned based (link_trap_ptr),
  4   178 	  2 call_relp	     fixed bin (18) unsigned unaligned,
  4   179 						/* LINK18, link to thing to call */
  4   180 	  2 info_relp	     fixed bin (18) unsigned unaligned;
  4   181 						/* LINK18, link to argument list */
  4   182 
  4   183 
  4   184 /* initialization info for *system or *heap link */
  4   185 
  4   186 
  4   187 /* NOTE --------------------------------------------------
  4   188*   the following structures defining initialization information are also
  4   189*   defined in fortran_storage.incl.pl1  system_link_init_info.incl.pl1
  4   190*   and should be kept equivalent
  4   191*   -------------------------------------------------------
  4   192**/
  4   193 
  4   194 declare	(
  4   195 	INIT_NO_INIT	     init (0),
  4   196 	INIT_COPY_INFO	     init (3),
  4   197 	INIT_DEFINE_AREA	     init (4),
  4   198 	INIT_LIST_TEMPLATE	     init (5),
  4   199 	INIT_DEFERRED	     init (6)
  4   200 	)		     fixed bin internal static options (constant);
  4   201 
  4   202 /* for type = 0 or 4 */
  4   203 
  4   204 declare	link_init_ptr	     pointer;
  4   205 declare	1 link_init	     aligned based (link_init_ptr),
  4   206 	  2 n_words	     fixed bin (35),	/* number to invent */
  4   207 	  2 type		     fixed bin;		/* see types above */
  4   208 
  4   209 /* for type=3, there is data to copy */
  4   210 
  4   211 declare	1 link_init_copy_info    aligned based (link_init_ptr),
  4   212 	  2 header	     aligned like link_init,
  4   213 	  2 initial_data	     (link_init_n_words refer (link_init_copy_info.header.n_words)) bit (36) aligned;
  4   214 
  4   215 declare	link_init_n_words	     fixed bin;
  4   216 
  4   217 /* for type = 5, there is a list template to copy */
  4   218 
  4   219 declare	1 link_init_list_template
  4   220 			     aligned based (link_init_ptr),
  4   221 	  2 header	     aligned like link_init,
  4   222 	  2 pad		     bit (18) unaligned,
  4   223 	  2 n_words_in_list	     fixed bin (18) unsigned unaligned,
  4   224 	  2 template	     (link_init_n_words_in_list refer (link_init_list_template.n_words_in_list));
  4   225 
  4   226 declare	link_init_n_words_in_list
  4   227 			     fixed bin;
  4   228 
  4   229 /* A list template consists of a series of entries with the following
  4   230*   description, concatenated together.  n_bits and datum are bit items,
  4   231*   to permit a wide range of inputs.
  4   232*
  4   233*   1.  A 'repeat' of '0' signifies skipping of 'n_bits' bits.
  4   234*   2.  A 'n_bits' of '0' signifies the last item of the list.
  4   235*
  4   236*   COMMON, VLA's, and LA's are presumed to start at the base pointer
  4   237*   of their particular storage section. */
  4   238 
  4   239 declare	1 list_template_entry    aligned based,
  4   240 	  2 n_bits	     fixed bin (35) aligned,	/* size of datum */
  4   241 	  2 mbz		     bit (3) unaligned,	/* future expansion */
  4   242 	  2 init_type	     fixed bin (3) unsigned unaligned, /* 0 normal init, 1 ptr init, 2 packed ptr init */
  4   243 	  2 repeat	     fixed bin (30) unsigned unaligned,
  4   244 						/* number of times to repeat datum */
  4   245 	  2 datum		     bit (link_init_n_bits_in_datum refer (list_template_entry.n_bits));
  4   246 
  4   247 
  4   248 /* the pointer_init_template represents the initialization information
  4   249*   for ITS and packed pointers.  Both pointer types require the entire
  4   250*   72 bit structure.
  4   251**/
  4   252 
  4   253 dcl       1 pointer_init_template  based,
  4   254 	  2 ptr_type	     fixed bin (18) unsigned unaligned,  /* 0 text section, 1 linkage section, 2 static section */
  4   255 	  2 section_offset	     fixed bin (18) unsigned unaligned,  /* offset to item in specified section */
  4   256 	  2 word_offset	     fixed bin (18) unsigned unaligned,  /* offset from section item to target in words */
  4   257 	  2 mbz		     bit (12) unaligned,
  4   258 	  2 bit_offset	     fixed bin (6) unsigned unaligned;   /* offset from section item|word offset to target in bits */
  4   259 
  4   260 
  4   261 declare	link_init_n_bits_in_datum
  4   262 			     fixed bin (35);
  4   263 
  4   264 /* for type = 6, the init_info resides in another MSF component */
  4   265 /* target_relp is a linkage section offset to a partial link to */
  4   266 /* the base of the linkage section of the component containing  */
  4   267 /* the actual init_info. link_relp is the offset of the actual  */
  4   268 /* link within that linkage section.			    */
  4   269 
  4   270 declare	1 link_init_deferred     aligned based (link_init_ptr),
  4   271 	  2 header	     aligned like link_init,
  4   272 	  2 target_relp	     fixed bin (18) unsigned unaligned,
  4   273 	  2 link_relp	     fixed bin (18) unsigned unaligned;
  4   274 
  4   275 /* Definition section hash table */
  4   276 
  4   277 declare	def_ht_ptr	     pointer;
  4   278 declare	1 definition_ht	     aligned based (def_ht_ptr),
  4   279 	  2 n_entries	     fixed bin,
  4   280 	  2 table		     (def_ht_n_entries refer (definition_ht.n_entries)) aligned,
  4   281 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  4   282 	    3 unused	     bit (18) unaligned;
  4   283 
  4   284 declare	def_ht_n_entries	     fixed bin;
  4   285 
  4   286 
  4   287 /* Component name ht */
  4   288 declare	comp_ht_ptr	     pointer;
  4   289 declare	1 component_ht	     aligned based (comp_ht_ptr),
  4   290 	  2 n_entries	     fixed bin,
  4   291 	  2 table		     (comp_ht_n_entries refer (component_ht.n_entries)) aligned,
  4   292 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  4   293 						/* hashed segname */
  4   294 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  4   295 						/* first segname def of block containing def_relp */
  4   296 
  4   297 declare	comp_ht_n_entries	     fixed bin;
  4   298 
  4   299 /* Duplicate name table */
  4   300 
  4   301 declare	dup_table_ptr	     pointer;
  4   302 declare	1 duplicate_table	     aligned based (dup_table_ptr),
  4   303 	  2 mbz		     bit (18) unaligned,	/* to tell it from a definition */
  4   304 	  2 n_names	     fixed bin (18) unsigned unaligned,
  4   305 						/* n in table */
  4   306 	  2 table		     (dup_table_n_names refer (duplicate_table.n_names)) aligned,
  4   307 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  4   308 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  4   309 
  4   310 declare	dup_table_n_names	     fixed bin;
  4   311 
  4   312 /* The msf_map is found in the definition section of an	*/
  4   313 /* object MSF component.  It is used by the linker to	*/
  4   314 /* determine whether a segment is a component of an object	*/
  4   315 /* MSF or a standard single-segment object.		*/
  4   316   
  4   317   dcl msf_map_ptr		ptr;
  4   318   dcl 01 msf_map		aligned based (msf_map_ptr),
  4   319        02 version		char (8),
  4   320        02 component_count	fixed bin (15) unsigned,
  4   321        02 my_component	fixed bin (15) unsigned;
  4   322   
  4   323   dcl msf_map_version_1	char (8) static options (constant)
  4   324 			     init ("msfmp1.0");
  4   325   
  4   326 declare	acc_string_ptr	     pointer;
  4   327 declare	1 acc_string	     aligned based (acc_string_ptr),
  4   328 	  2 count		     fixed bin (9) unsigned unaligned,
  4   329 	  2 string	     character (max (3, acc_string_length) refer (acc_string.count)) unaligned,
  4   330 	  2 mbz		     bit (0) aligned;	/* this causes the statement */
  4   331 						/* unspec (acc_string) = ""b to zero out */
  4   332 						/* the last word, if the string is not of length 0mod4 */
  4   333 
  4   334 declare	acc_string_length	     fixed bin (21);
  4   335 
  4   336 
  4   337 /* end include file definitions_dcls.incl.pl1 */
       88 
       89  /* Begin include file checker_dcls_.incl.pl1 BIM 7/82 */
  5     2 /* Modified for loaded by Keith Loepere, December 1983 */
  5     3 /* format: style3,idind30 */
  5     4 
  5     5 dcl	checker_data_$temp_ptrs	(4) ptr external static;
  5     6 dcl	checker_data_$slt_ptr	ptr external static;
  5     7 dcl	checker_data_$area_ptr	ptr external static;
  5     8 dcl	checker_area		area (sys_info$max_seg_size) based (checker_data_$area_ptr);
  5     9 
  5    10 dcl	checker_data_$name_table_ptr	ptr external static;
  5    11 dcl	checker_data_$buffer_ptr	ptr external static;
  5    12 dcl	checker_data_$meter_ptr	ptr external static;
  5    13 
  5    14 dcl	checker_data_$input_iocbp	ptr ext static;
  5    15 dcl	checker_data_$output_iocbp	ptr ext static;
  5    16 
  5    17 
  5    18 dcl	checker_data_$last_wired_collection
  5    19 				fixed bin external static;
  5    20 dcl	checker_data_$last_text_wired_collection
  5    21 				fixed bin external static;
  5    22 dcl	checker_data_$last_supervisor_collection
  5    23 				fixed bin external static;
  5    24 
  5    25 dcl       1 checker_data_$collection_names (0:10) external static,
  5    26 	2 major fixed bin,
  5    27 	2 minor fixed bin;
  5    28 
  5    29 dcl	checker_data_$loaded	(0:10) external static bit (1) aligned;
  5    30 
  5    31 dcl	checker_data_$n_temp_ptrs	fixed bin external static;
  5    32 
  5    33 dcl       checker_data_$severity	fixed bin external static;
  5    34 
  5    35 dcl	1 meters			aligned based (checker_data_$meter_ptr),
  5    36 	  2 sizes			aligned,
  5    37 	    3 wired_ai_linkage_size	fixed bin,
  5    38 	    3 paged_ai_linkage_size	fixed bin,
  5    39 	    3 wired_wi_linkage_size	fixed bin,
  5    40 	    3 paged_wi_linkage_size	fixed bin,
  5    41 	    3 wired_as_linkage_size	fixed bin,
  5    42 	    3 paged_as_linkage_size	fixed bin,
  5    43 	    3 wired_ws_linkage_size	fixed bin,
  5    44 	    3 paged_ws_linkage_size	fixed bin,
  5    45 	    3 wired_definitions_size	fixed bin,
  5    46 	    3 paged_definitions_size	fixed bin,
  5    47 	  2 wired_nt_size		fixed bin,
  5    48 	  2 paged_nt_size		fixed bin,
  5    49             2 overflown aligned,
  5    50 	    3 (wired_ai_linkage, paged_ai_linkage, wired_wi_linkage,
  5    51 	       paged_wi_linkage, wired_as_linkage, paged_as_linkage,
  5    52 	       wired_ws_linkage, paged_ws_linkage,
  5    53 	       wired_definitions, paged_definitions,
  5    54 	       wired_nt, paged_nt,
  5    55 	       wired_storage) bit (1) unaligned,
  5    56 	  2 counts		aligned,
  5    57 	    3 wired_sdw_count	fixed bin,
  5    58 	    3 paged_sdw_count	fixed bin,
  5    59 	    3 wired_slte_count	fixed bin,
  5    60 	    3 paged_slte_count	fixed bin,
  5    61 	  2 wired_nt_used		fixed bin,
  5    62 	  2 paged_nt_used		fixed bin,
  5    63 	  2 used			aligned,
  5    64 	    3 wired_ai_linkage_used	fixed bin,
  5    65 	    3 paged_ai_linkage_used	fixed bin,
  5    66 	    3 wired_wi_linkage_used	fixed bin,
  5    67 	    3 paged_wi_linkage_used	fixed bin,
  5    68 	    3 wired_as_linkage_used	fixed bin,
  5    69 	    3 paged_as_linkage_used	fixed bin,
  5    70 	    3 wired_ws_linkage_used	fixed bin,
  5    71 	    3 paged_ws_linkage_used	fixed bin,
  5    72 	    3 wired_definitions_used	fixed bin,
  5    73 	    3 paged_definitions_used	fixed bin,
  5    74 	  2 per_collection		(0:10) aligned,
  5    75 	    3 read		bit (1) aligned,
  5    76 	    3 mark		aligned,
  5    77 	      4 major		fixed bin,
  5    78 	      4 minor		fixed bin,
  5    79 	    3 first_segment		fixed bin (18),
  5    80 	    3 last_segment		fixed bin (18),
  5    81 	    3 segment_count		fixed bin (17),
  5    82 	    3 words_used		fixed bin (35),	/* for wired */
  5    83 	    3 pages_used		fixed bin (35),	/* for paged */
  5    84 	    3 wired_pages_used	fixed bin (35),	/* for both! */
  5    85 	    3 perm_segment_count	fixed bin,	/* stay forever */
  5    86 	    3 temp_segment_count	fixed bin,	/* one collection */
  5    87 	    3 init_segment_count	fixed bin,	/* all of initialization */
  5    88 	    3 user_ring_segment_count fixed bin,
  5    89 	    3 user_ring_segment_pages fixed bin,
  5    90 	    3 ai_linkage_used	fixed bin,
  5    91 	    3 wi_linkage_used	fixed bin,
  5    92 	    3 as_linkage_used	fixed bin,
  5    93 	    3 ws_linkage_used	fixed bin,
  5    94 	    3 definitions_used	fixed bin,
  5    95 	    3 name_table_used	fixed bin,
  5    96 	  2 per_segment		(0:1024) aligned,
  5    97 	    3 collection		fixed bin,
  5    98 	    3 next		fixed bin (18),
  5    99 	    3 link_ptr		pointer unaligned,
  5   100 	    3 defs_ptr		pointer unaligned;
  5   101 
  5   102 declare	segment_links_ptr		pointer;
  5   103 declare	1 segment_links		aligned based (segment_links_ptr),
  5   104 	  2 n_links		fixed bin,
  5   105 	  2 per_link (a_n_links refer (segment_links.n_links)) aligned,
  5   106 	    3 expression_relps        fixed bin (18) uns unal,
  5   107 	    3 modifiers               bit (6) unal;
  5   108 
  5   109 						/* rel pointers into def section stored in area */
  5   110 
  5   111 declare	a_n_links			fixed bin;
  5   112 
  5   113 declare	segment_defs_ptr		pointer;
  5   114 declare	1 segment_defs		based (segment_defs_ptr) aligned,
  5   115 	  2 length		fixed bin,
  5   116 	  2 definitions		(a_defs_length refer (segment_defs.length)) bit (36) aligned;
  5   117 
  5   118 declare	a_defs_length		fixed bin;
  5   119 
  5   120 declare (CHECKER_WARNING init (1), /* */
  5   121          CHECKER_ERROR   init (2), /* */
  5   122          CHECKER_SEVERE  init (3), /* */
  5   123          CHECKER_FATAL   init (4)) fixed bin int static options (constant);
  5   124 
  5   125 declare ERROR_NAMES (1:4) char (16) init ("WARNING", "ERROR", "SEVERE ERROR", "FATAL ERROR") int static options (constant);
  5   126 
  5   127 /* End include file checker_dcls_.incl.pl1 */
       89 
       90  /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  6     2*coded February 8, 1972 by Michael J. Spier	*/
  6     3 /* modified May 26, 1972 by M. Weaver */
  6     4 /* modified 15 April, 1975 by M. Weaver */
  6     5 
  6     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  6     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  6     8 	2 textp pointer,			/* pointer to beginning of text section */
  6     9 	2 defp pointer,			/* pointer to beginning of definition section */
  6    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  6    11 	2 statp pointer,			/* pointer to beginning of static section */
  6    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  6    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  6    14 	2 tlng fixed bin,			/* length in words of text section */
  6    15 	2 dlng fixed bin,			/* length in words of definition section */
  6    16 	2 llng fixed bin,			/* length in words of linkage section */
  6    17 	2 ilng fixed bin,			/* length in words of static section */
  6    18 	2 slng fixed bin,			/* length in words of symbol section */
  6    19 	2 blng fixed bin,			/* length in words of break map */
  6    20 	2 format,				/* word containing bit flags about object type */
  6    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  6    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  6    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  6    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  6    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  6    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  6    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  6    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  6    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  6    30 	  3 pad bit(27) unaligned,
  6    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  6    32 	2 textlinkp pointer,		/* ptr to first link in text */
  6    33 
  6    34 	/* LIMIT OF BRIEF STRUCTURE */
  6    35 
  6    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  6    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  6    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  6    39 	2 cvers aligned,			/* generator version name in printable char string form */
  6    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  6    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  6    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  6    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  6    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  6    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  6    46 
  6    47 	/* LIMIT OF DISPLAY STRUCTURE */
  6    48 
  6    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  6    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  6    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  6    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  6    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  6    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  6    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  6    56 					/* currently not used by system */
  6    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  6    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  6    59 
  6    60 declare	object_info_version_2 fixed bin int static init(2);
  6    61 
  6    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
       90 
       91  /* BEGIN INCLUDE FILE tape_mult_boot_info.incl.pl1 */
  7     2 /* Written by J. A. Bush 6/27/81 */
  7     3 
  7     4 dcl 1 boot_program_info aligned,
  7     5     2 version fixed bin,				/* Currently 1 */
  7     6     2 boot_program_ptr pointer,			/* Pointer to text section of boot program */
  7     7     2 boot_program_text_length fixed bin (21),		/* Length of the text section in words */
  7     8     2 boot_program_name char (32) unaligned;		/* Name for recording in label */
  7     9 
  7    10 dcl  BOOT_PROGRAM_INFO_VERSION_1 fixed bin internal static options
  7    11     (constant) init (1);
  7    12 
  7    13 /* END INCLUDE FILE tape_mult_boot_info.incl.pl1 */
       91 
       92 /* format: on */
       93 
       94 	dcl     1 oi		 aligned like object_info;
       95 
       96 	dcl     1 cur_slte		 aligned like slte_uns;
       97 	dcl     Collection		 fixed bin;
       98 	dcl     code		 fixed bin (35);
       99 	dcl     hc_seg_ptr		 ptr;
      100 	dcl     segment_name	 character (32);
      101 	dcl     segment_number	 fixed bin (18);
      102 	dcl     nx		 fixed bin;
      103 	dcl     (first, second, third) char (32);
      104 	dcl     MST_tape_eof_	 condition;
      105 
      106 
      107 	sltp = checker_data_$slt_ptr;			/* pointer to simulated slt */
      108 	names_ptr = checker_data_$name_table_ptr;
      109 
      110 	sltep, header_ptr = addr (header_area);
      111 	namep = addrel (header_ptr, size (slte));	/* SLT entry is 4 words long */
      112 
      113 
      114 	call CHECK_BOOTABLE_LABEL;
      115 
      116 
      117 /* First, report on the collection 0 segments. Trust the data that */
      118 /* sslt_init_ put in the slt for bound_bootload_1 */
      119 
      120 
      121 	call checker_print_ ("Begin collection 0.0:");
      122 	meters.per_collection (0).read = "1"b;
      123 
      124 	Collection = 0;
      125 
      126 /* The first control word :: the header for BBL1 */
      127 
      128 	call Read_Control_Word;
      129 	if control_word.type ^= HEADER
      130 	then call checker_print_$error (CHECKER_FATAL, (0), "tape format", "Tape does not begin with header record.");
      131 
      132 	call tape_reader_ (addr (header_area), (control_word.count));
      133 						/* take the header */
      134 	do segment_number = slt.first_sup_seg to slt.last_sup_seg;
      135 	     call checker_print_$skip;
      136 	     call PROCESS_SLTE (segment_number);	/* do for slte data */
      137 	end;
      138 	do segment_number = slt.first_init_seg to slt.last_init_seg;
      139 	     call checker_print_$skip;
      140 	     call PROCESS_SLTE (segment_number);	/* ditto */
      141 	end;
      142 
      143 	call checker_print_$skip;
      144 	call checker_print_ ("End collection 0.0");
      145 
      146 	call COLLECTION_SUMMARY;
      147 
      148 
      149 /* Read in the first segment, which has already been described by the */
      150 /* collection 0 template. This code could be expanded to check if */
      151 /* it bears some reasonable resemblance to the template. */
      152 
      153 	call Read_Control_Word;			/* Control word for first seg */
      154 	call tape_reader_ (checker_data_$buffer_ptr, (control_word.count));
      155 
      156 /* Fine, preliminaries are set */
      157 
      158 	on MST_tape_eof_ go to NO_MORE_COLLECTIONS;
      159 
      160 	do while ("1"b);
      161 	     Collection = Collection + 1;
      162 	     if Collection > hbound (meters.per_collection, 1)
      163 	     then do;
      164 		     call com_err_ (code, ME, "More than ^d collections.", Collection - 1);
      165 		     return;
      166 		end;
      167 	     call LOAD_ONE_COLLECTION;
      168 	     call COLLECTION_SUMMARY;
      169 	end;
      170 
      171 NO_MORE_COLLECTIONS:
      172 	call TOTAL_SUMMARY;
      173 	return;					/* Let our caller move on to the cref */
      174 
      175 LOAD_ONE_COLLECTION:
      176      procedure;
      177 
      178 	declare expect_link		 bit (1) aligned;
      179 	declare expect_defs		 bit (1) aligned;
      180 	declare 1 prev_slte		 aligned like slte_uns;
      181 	declare text_segment_number	 fixed bin (18);
      182 
      183 	unspec (prev_slte) = ""b;
      184 	expect_link, expect_defs = "0"b;
      185 	text_segment_number = -1;
      186 	collection_started = "0"b;
      187 
      188 
      189 LOAD_LOOP:
      190 	call Read_Control_Word;
      191 
      192 
      193 /* Allow EOF to take on last collection */
      194 
      195 	if ^collection_started
      196 	then do;
      197 		meters.per_collection (Collection).read = "1"b;
      198 		call checker_print_$page;
      199 		call checker_print_ ("Begin collection ^d.^d: ^[WIRED ENVIROMNENT^]",
      200 		     checker_data_$collection_names (Collection).major,
      201 		     checker_data_$collection_names (Collection).minor,
      202 		     Collection <= checker_data_$last_wired_collection);
      203 		collection_started = "1"b;
      204 	     end;
      205 
      206 	call checker_print_$skip;
      207 
      208 	if control_word.type = COLLECTION_MARK
      209 	then do;
      210 		if expect_link | expect_defs
      211 		then do;
      212 			call checker_print_$error (CHECKER_SEVERE, (0), "tape format",
      213 			     " Collection ended without expected ^[definitions^;linkage^] segment.", expect_link);
      214 		     end;
      215 		if control_word.count ^= 1
      216 		then call checker_print_$error (CHECKER_FATAL, (0), "tape format",
      217 			"Collection mark not one word long.");
      218 
      219 		call tape_reader_ (addr (collection_mark), (control_word.count));
      220 		if collection_mark.major ^= checker_data_$collection_names (Collection).major
      221 		     | collection_mark.minor ^= checker_data_$collection_names (Collection).minor
      222 		then call checker_print_$error (CHECKER_WARNING, (0), "collection mark",
      223 			"Collection ^d.^d ended with mark ^d.^d.",
      224 			checker_data_$collection_names (Collection).major,
      225 			checker_data_$collection_names (Collection).minor, collection_mark.major,
      226 			collection_mark.minor);
      227 
      228 		meters.per_collection (Collection).mark.major = collection_mark.major;
      229 		meters.per_collection (Collection).mark.minor = collection_mark.minor;
      230 		call checker_print_ ("Collection mark ^d.^d", collection_mark.major, collection_mark.minor);
      231 		call ioa_ ("Read collection ^d.^d", collection_mark.major, collection_mark.minor);
      232 
      233 		return;
      234 	     end;
      235 
      236 	else if control_word.type ^= HEADER
      237 	then call checker_print_$error (CHECKER_FATAL, (0), "tape format",
      238 		"Segment ^a was not followed by a header record.", segment_name);
      239 
      240 /* Process header record */
      241 
      242 	if (control_word.count > HEADER_MAX_SIZE) | (control_word.count < 4)
      243 	then call checker_print_$error (CHECKER_FATAL, (0), "tape format", "Header size ^d unreasonable.",
      244 		control_word.count);
      245 
      246 /* So far, a well-formed tape */
      247 
      248 /* Check in a segment */
      249 
      250 	call tape_reader_ (addr (header_area), (control_word.count));
      251 
      252 	cur_slte = addr (header_area) -> slte_uns;
      253 
      254 /* check for duplicated segment names */
      255 	segment_name = segnam.names (1).name;		/* primary name */
      256 
      257 	if checker_data_$loaded (Collection)
      258 	then do nx = 1 to segnam.count;
      259 		call sslt_manager_$get_seg_num (segnam.names (nx).name, segment_number, code);
      260 		if code = 0
      261 		then call checker_print_$error (CHECKER_SEVERE, error_table_$namedup, "segment_name",
      262 			"Name ^a already on seg # ^o", segnam.names (nx).name, segment_number);
      263 	     end;
      264 
      265 /* Now get control word for seg itself */
      266 
      267 	call Read_Control_Word;
      268 
      269 	if control_word.type ^= SEGMENT
      270 	then call checker_print_$error (CHECKER_FATAL, (0), segment_name, "Segment header not followed by contents.");
      271 
      272 	if ^checker_data_$loaded (Collection)		/* object is specially handled */
      273 	then do;
      274 		call PROCESS_SPECIAL_SLTE (addr (header_area));
      275 		call tape_reader_ (checker_data_$buffer_ptr, (control_word.count));
      276 		go to LOAD_LOOP;
      277 	     end;
      278 
      279 	if ^cur_slte.defs & ^(cur_slte.link_sect & prev_slte.combine_link)
      280 	then do;					/* If a segment is to be created ... */
      281 		call sslt_manager_$build_entry (addr (header_area), hc_seg_ptr, (0));
      282 
      283 		segment_number = bin (baseno (hc_seg_ptr), 18);
      284 		call PROCESS_SLTE (segment_number);	/* classify and record */
      285 						/* and set cur_slte to be the version slt_manager_ cooked up */
      286 	     end;
      287 
      288 /* now see what sort of beast */
      289 
      290 	if cur_slte.firmware_seg
      291 	then do;
      292 		call tape_reader_ (checker_data_$buffer_ptr, (control_word.count));
      293 		go to LOAD_LOOP;
      294 	     end;
      295 
      296 	if cur_slte.link_sect			/* somebodies linkage */
      297 	then do;
      298 		if ^expect_link			/* orphan linkage ? */
      299 		then call checker_print_$error (CHECKER_FATAL, (0), "tape format", "Unexpected linkage section ^a.",
      300 			segment_name);
      301 
      302 		expect_link = "0"b;
      303 		expect_defs = "1"b;			/* just as night follows day */
      304 
      305 		if prev_slte.combine_link		/* this is to be combined */
      306 		then call ENTER_COMBINED_LINKAGE;
      307 		else call ENTER_UNCOMBINED_LINKAGE;
      308 	     end;
      309 
      310 	else if cur_slte.defs
      311 	then do;
      312 		if ^expect_defs
      313 		then call checker_print_$error (CHECKER_FATAL, (0), "tape format", "Unexpected definitions seg ^a.",
      314 			segment_name);
      315 
      316 		call ENTER_DEFINITIONS;
      317 		expect_defs = "0"b;
      318 	     end;
      319 
      320 	else do;					/* A text section, by george */
      321 		if expect_link | expect_defs
      322 		then call checker_print_$error (CHECKER_FATAL, (0), "tape format", "Unexpected text section ^a.",
      323 			segment_name);
      324 
      325 
      326 		expect_link = cur_slte.link_provided;
      327 
      328 		call ENTER_TEXT;
      329 		text_segment_number = segment_number;
      330 	     end;
      331 	prev_slte = cur_slte;
      332 	go to LOAD_LOOP;
      333 
      334 ENTER_TEXT:
      335      procedure;
      336 
      337 	call tape_reader_ (checker_data_$buffer_ptr, (control_word.count));
      338 						/* skip it, at least */
      339 
      340 	if cur_slte.ringbrack (1) = 0			/* hardcore segments have no linkage, or linkage */
      341 						/* stripped off */
      342 	then return;
      343 
      344 /* For user ring segments, the linkage and defs are still in the segment */
      345 
      346 	if cur_slte.bit_count ^= (control_word.count * 36)/* match? */
      347 	then return;
      348 
      349 	oi.version_number = object_info_version_2;
      350 	call object_info_$brief (checker_data_$buffer_ptr, (cur_slte.bit_count), addr (oi), code);
      351 	if code = 0
      352 	then do;
      353 		call PROCESS_LINKAGE (segment_number, oi.linkp, (oi.llng));
      354 		call PROCESS_DEFS (segment_number, oi.defp, (oi.dlng));
      355 	     end;
      356 
      357      end ENTER_TEXT;
      358 
      359 ENTER_COMBINED_LINKAGE:
      360      procedure;
      361 
      362 /* See what linkage section is in question */
      363 
      364 	if /* tree */ prev_slte.link_sect_wired
      365 	then if prev_slte.init_seg
      366 	     then do;				/* WI linkage */
      367 		     if Collection <= checker_data_$last_wired_collection
      368 		     then do;
      369 			     meters.wired_wi_linkage_used = meters.wired_wi_linkage_used + control_word.count;
      370 			     call CHECK (meters.wired_wi_linkage_size, meters.wired_wi_linkage_used, "1"b /*wired*/,
      371 				"wi_linkage", meters.overflown.wired_wi_linkage);
      372 			end;
      373 		     meters.paged_wi_linkage_used = meters.paged_wi_linkage_used + control_word.count;
      374 		     call CHECK (meters.paged_wi_linkage_size, meters.paged_wi_linkage_used, "0"b, "wi_linkage",
      375 			meters.overflown.paged_wi_linkage);
      376 		     meters.per_collection (Collection).wi_linkage_used =
      377 			meters.per_collection (Collection).wi_linkage_used + control_word.count;
      378 		end;
      379 	     else do;				/* WS linkage */
      380 		     if Collection <= checker_data_$last_wired_collection
      381 		     then do;
      382 			     meters.wired_ws_linkage_used = meters.wired_ws_linkage_used + control_word.count;
      383 			     call CHECK (meters.wired_ws_linkage_size, meters.wired_ws_linkage_used, "1"b,
      384 				"ws_linkage", meters.overflown.wired_ws_linkage);
      385 			end;
      386 
      387 		     meters.paged_ws_linkage_used = meters.paged_ws_linkage_used + control_word.count;
      388 		     call CHECK (meters.paged_ws_linkage_size, meters.paged_ws_linkage_used, "0"b, "ws_linkage",
      389 			meters.overflown.paged_ws_linkage);
      390 		     meters.per_collection (Collection).ws_linkage_used =
      391 			meters.per_collection (Collection).ws_linkage_used + control_word.count;
      392 		end;
      393 	else if prev_slte.init_seg			/* AI linkage */
      394 	     then do;
      395 		     if Collection <= checker_data_$last_wired_collection
      396 		     then do;
      397 			     meters.wired_ai_linkage_used = meters.wired_ai_linkage_used + control_word.count;
      398 			     call CHECK (meters.wired_ai_linkage_size, meters.wired_ai_linkage_used, "1"b,
      399 				"ai_linkage", meters.overflown.wired_ai_linkage);
      400 			end;
      401 		     meters.paged_ai_linkage_used = meters.paged_ai_linkage_used + control_word.count;
      402 		     call CHECK (meters.paged_ai_linkage_size, meters.paged_ai_linkage_used, "0"b, "ai_linkage",
      403 			meters.overflown.paged_ai_linkage);
      404 		     meters.per_collection (Collection).ai_linkage_used =
      405 			meters.per_collection (Collection).ai_linkage_used + control_word.count;
      406 		end;
      407 	     else do;				/* AS linkage */
      408 		     if Collection <= checker_data_$last_wired_collection
      409 		     then do;
      410 			     meters.wired_as_linkage_used = meters.wired_as_linkage_used + control_word.count;
      411 			     call CHECK (meters.wired_as_linkage_size, meters.wired_as_linkage_used, "1"b,
      412 				"as_linkage", meters.overflown.wired_as_linkage);
      413 			end;
      414 		     meters.paged_as_linkage_used = meters.paged_as_linkage_used + control_word.count;
      415 		     call CHECK (meters.paged_as_linkage_size, meters.paged_as_linkage_used, "1"b, "as_linkage",
      416 			meters.overflown.paged_ai_linkage);
      417 		     meters.per_collection (Collection).as_linkage_used =
      418 			meters.per_collection (Collection).as_linkage_used + control_word.count;
      419 		end;
      420 
      421 ENTER_UNCOMBINED_LINKAGE:
      422      entry;
      423 
      424 	call tape_reader_ (checker_data_$buffer_ptr, (control_word.count));
      425 	checker_data_$buffer_ptr -> linkage_header.segment_number = text_segment_number;
      426 	call PROCESS_LINKAGE (text_segment_number, checker_data_$buffer_ptr, (control_word.count));
      427 	return;
      428 
      429 CHECK:
      430      procedure (limit, amount, paged, name, printed);
      431 	declare limit		 fixed bin;
      432 	declare amount		 fixed bin;
      433 	declare paged		 bit (1) aligned;
      434 	declare name		 char (32);
      435 	declare printed		 bit (1) unaligned;
      436 
      437 	if limit < 0
      438 	then return;				/* as yet unknown */
      439 	if amount < limit
      440 	then return;				/* clear */
      441 
      442 	if ^printed
      443 	then call checker_print_$error (CHECKER_SEVERE, (0), segment_name,
      444 		" ^[PAGED^;WIRED^] ^a OVERFLOW. Increase ^[max_length^;cur_length^] of ^a.", paged, name, paged, name)
      445 		;
      446 	else printed = "1"b;
      447      end CHECK;
      448 
      449      end ENTER_COMBINED_LINKAGE;
      450 
      451 ENTER_DEFINITIONS:
      452      procedure;
      453 
      454 	if Collection <= checker_data_$last_wired_collection
      455 	then meters.wired_definitions_used = meters.wired_definitions_used + control_word.count;
      456 	meters.paged_definitions_used = meters.paged_definitions_used + control_word.count;
      457 	meters.per_collection (Collection).definitions_used =
      458 	     meters.per_collection (Collection).definitions_used + control_word.count;
      459 	if meters.wired_definitions_size > 0
      460 	then if Collection <= checker_data_$last_wired_collection
      461 	     then if meters.wired_definitions_used > meters.wired_definitions_size
      462 		then do;
      463 			if ^meters.overflown.wired_definitions
      464 			then call checker_print_$error (CHECKER_SEVERE, (0), segment_name,
      465 				" WIRED DEFINITIONS OVERFLOW. Increase cur_length for definitions_");
      466 			meters.overflown.wired_definitions = "1"b;
      467 		     end;
      468 		else ;
      469 	     else if meters.paged_definitions_used > meters.paged_definitions_size
      470 	     then do;
      471 		     if ^meters.overflown.paged_definitions
      472 		     then call checker_print_$error (CHECKER_SEVERE, (0), segment_name,
      473 			     " PAGED DEFINITIONS OVERFLOW. Increase max_length of definitions_.");
      474 		     meters.overflown.paged_definitions = "1"b;
      475 		end;
      476 
      477 	call tape_reader_ (checker_data_$buffer_ptr, (control_word.count));
      478 	call PROCESS_DEFS (text_segment_number, checker_data_$buffer_ptr, (control_word.count));
      479      end ENTER_DEFINITIONS;
      480 
      481 PROCESS_LINKAGE:
      482      procedure (segment_number, link_ptr, links_length);
      483 
      484 	declare segment_number	 fixed bin (18);
      485 	declare link_ptr		 pointer;
      486 	declare links_ptr		 pointer;
      487 	declare links_length	 fixed bin (18) uns;
      488 	declare links_count		 fixed bin;
      489 	declare lx		 fixed bin;
      490 	declare section_length	 fixed bin;
      491 
      492 
      493 	section_length = min (links_length, link_ptr -> virgin_linkage_header.linkage_section_lng);
      494 
      495 	if section_length ^> size (virgin_linkage_header)
      496 	then return;
      497 
      498 	links_count = divide (section_length, 2, 17, 0);	/* 2 words each */
      499 
      500 	if links_count = 0
      501 	then return;
      502 
      503 /* and see if the count we have is good */
      504 
      505 	links_ptr = addrel (link_ptr, link_ptr -> linkage_header.begin_links);
      506 	begin;
      507 	     declare 1 links	      (1:links_count) aligned like object_link based (links_ptr);
      508 	     do lx = 1 to links_count;
      509 		if links (lx).tag ^= "46"b3 | links (lx).mbz ^= "0"b | links (lx).mbz2 ^= "0"b
      510 		then do;
      511 			links_count = lx - 1;
      512 			goto COUNTED;
      513 		     end;
      514 	     end;
      515 COUNTED:
      516 	end;
      517 
      518 	a_n_links = links_count;
      519 	allocate segment_links in (checker_area);
      520 	unspec (segment_links.per_link) = ""b;
      521 
      522 	begin;
      523 	     declare 1 links	      (1:links_count) aligned like object_link based (links_ptr);
      524 	     do lx = 1 to links_count;
      525 		segment_links.expression_relps (lx) = links (lx).expression_relp;
      526 		segment_links.modifiers (lx) = links (lx).modifier;
      527 	     end;
      528 	end;
      529 	meters.per_segment (segment_number).link_ptr = segment_links_ptr;
      530      end PROCESS_LINKAGE;
      531 
      532 PROCESS_DEFS:
      533      procedure (segno, defs_ptr, defs_length);
      534 	declare defs_ptr		 pointer;
      535 	declare defs_length		 fixed bin (18) uns;
      536 	declare dptr		 pointer;
      537 	declare segno		 fixed bin (18);
      538 
      539 	a_defs_length = defs_length;
      540 	allocate segment_defs in (checker_area);
      541 
      542 	dptr = addr (segment_defs.definitions);
      543 	begin;
      544 	     declare to		      (defs_length) bit (36) aligned based (dptr);
      545 	     declare from		      (defs_length) bit (36) aligned based (defs_ptr);
      546 	     to = from;
      547 	end;
      548 	meters.per_segment (segno).defs_ptr = segment_defs_ptr;
      549      end PROCESS_DEFS;
      550      end LOAD_ONE_COLLECTION;
      551 
      552 PROCESS_SLTE:
      553      procedure (p_segment_number);
      554 	declare p_segment_number	 fixed bin (18);
      555 	declare p_sltep		 ptr;
      556 
      557 	declare segment_number	 fixed bin (18);
      558 	declare this_sltep		 ptr;
      559 	declare 1 this_slte		 aligned like slte_uns based (this_sltep);
      560 	declare this_namep		 ptr;
      561 	declare this_pathp		 ptr;
      562 	declare this_aclp		 ptr;
      563 	declare a_name		 char (32);
      564 	declare next_name		 fixed bin;
      565 	declare aclx		 fixed bin;
      566 
      567 	declare (word_length, wired_length)
      568 				 fixed bin (19);
      569 	declare paged_length	 fixed bin;
      570 
      571 	segment_number = p_segment_number;
      572 	this_sltep = addr (slt.seg (segment_number));
      573 	this_namep = ptr (checker_data_$name_table_ptr, this_slte.names_ptr);
      574 	if this_sltep -> slte.branch_required
      575 	then do;
      576 		this_pathp = ptr (checker_data_$name_table_ptr, this_slte.path_ptr);
      577 		this_aclp = addr (this_pathp -> path.acls);
      578 	     end;
      579 
      580 	call REPORT_SEGMENT;
      581 
      582 /* meter this object */
      583 
      584 	meters.per_collection (Collection).segment_count = meters.per_collection (Collection).segment_count + 1;
      585 	if Collection <= checker_data_$last_wired_collection
      586 	then do;
      587 		meters.wired_sdw_count = meters.wired_sdw_count + 1;
      588 		meters.wired_slte_count = meters.wired_slte_count + 1;
      589 		meters.wired_nt_used = meters.wired_nt_used + currentsize (this_namep -> segnam);
      590 		if this_slte.branch_required
      591 		then meters.wired_nt_used = meters.wired_nt_used + currentsize (this_pathp -> path);
      592 		if this_slte.acl_provided
      593 		then meters.wired_nt_used = meters.wired_nt_used + currentsize (this_aclp -> acls) - 1;
      594 						/* overlaps path */
      595 
      596 		if meters.wired_nt_size > 0
      597 		then if meters.wired_nt_used > meters.wired_nt_size
      598 		     then do;
      599 			     if ^meters.overflown.wired_nt
      600 			     then call checker_print_$error (CHECKER_SEVERE, (0), segment_name,
      601 				     " WIRED NAME_TABLE OVERFLOW. Increase cur_length of name_table in template_slt_.cds"
      602 				     );
      603 			     meters.overflown.wired_nt = "1"b;
      604 			end;
      605 	     end;
      606 	else do;
      607 		meters.paged_sdw_count = meters.paged_sdw_count + 1;
      608 		meters.paged_slte_count = meters.paged_slte_count + 1;
      609 		meters.paged_nt_used = meters.paged_nt_used + currentsize (this_namep -> segnam);
      610 		if this_slte.branch_required
      611 		then meters.paged_nt_used = meters.paged_nt_used + currentsize (this_pathp -> path);
      612 		if this_slte.acl_provided
      613 		then meters.paged_nt_used = meters.paged_nt_used + currentsize (this_aclp -> acls) - 1;
      614 						/* overlaps path */
      615 		if meters.paged_nt_size > 0
      616 		then if meters.paged_nt_used > meters.paged_nt_size
      617 		     then do;
      618 			     if ^meters.overflown.paged_nt
      619 			     then call checker_print_$error (CHECKER_SEVERE, (0), segment_name,
      620 				     " PAGED NAME_TABLE OVERFLOW. Increase max_length of name_table in template_slt_.cds"
      621 				     );
      622 			     meters.overflown.paged_nt = "1"b;
      623 			end;
      624 	     end;
      625 
      626 	if Collection <= checker_data_$last_text_wired_collection
      627 	then if ^this_slte.layout_seg			/* not taken from free pool */
      628 	     then meters.per_collection (Collection).words_used =
      629 		     meters.per_collection (Collection).words_used + wired_length;
      630 
      631 	meters.per_collection (Collection).name_table_used =
      632 	     meters.per_collection (Collection).name_table_used + currentsize (this_namep -> segnam);
      633 	if this_slte.branch_required
      634 	then meters.per_collection (Collection).name_table_used =
      635 		meters.per_collection (Collection).name_table_used + currentsize (this_pathp -> path);
      636 	if this_slte.acl_provided
      637 	then meters.name_table_used = meters.name_table_used + currentsize (this_aclp -> acls) - 1;
      638 
      639 	if this_slte.paged
      640 	then meters.per_collection (Collection).pages_used =
      641 		meters.per_collection (Collection).pages_used + paged_length;
      642 
      643 	if this_slte.wired & this_slte.paged
      644 	then meters.per_collection (Collection).wired_pages_used =
      645 		meters.per_collection (Collection).wired_pages_used + paged_length;
      646 
      647 	if this_slte.temp_seg
      648 	then meters.per_collection (Collection).temp_segment_count =
      649 		meters.per_collection (Collection).temp_segment_count + 1;
      650 
      651 	else if this_slte.init_seg
      652 	then meters.per_collection (Collection).init_segment_count =
      653 		meters.per_collection (Collection).init_segment_count + 1;
      654 
      655 	else meters.per_collection (Collection).perm_segment_count =
      656 		meters.per_collection (Collection).perm_segment_count + 1;
      657 
      658 	if this_slte.ringbrack (1) > 0
      659 	then do;
      660 		meters.per_collection (Collection).user_ring_segment_count =
      661 		     meters.per_collection (Collection).user_ring_segment_count + 1;
      662 		meters.per_collection (Collection).user_ring_segment_pages =
      663 		     meters.per_collection (Collection).user_ring_segment_pages + paged_length;
      664 	     end;
      665 
      666 	if meters.per_collection (Collection).first_segment = -1
      667 	then meters.per_collection (Collection).last_segment, meters.per_collection (Collection).first_segment =
      668 		segment_number;
      669 	else do;
      670 		meters.per_segment (meters.per_collection (Collection).last_segment).next = segment_number;
      671 		meters.per_collection (Collection).last_segment = segment_number;
      672 	     end;
      673 
      674 	meters.per_segment (segment_number).collection = Collection;
      675 
      676 	call INTERESTING_SEGMENT;
      677 	return;
      678 
      679 PROCESS_SPECIAL_SLTE:
      680      entry (p_sltep);
      681 
      682 	this_sltep = p_sltep;
      683 	this_namep = addrel (this_sltep, size (slte));
      684 	if this_sltep -> slte.branch_required
      685 	then do;
      686 		this_pathp = addrel (this_namep, currentsize (this_namep -> segnam));
      687 		this_aclp = addr (this_pathp -> path.acls);
      688 	     end;
      689 
      690 	call REPORT_SEGMENT;
      691 
      692 /* meter this object */
      693 
      694 	meters.per_collection (Collection).segment_count = meters.per_collection (Collection).segment_count + 1;
      695 	if Collection <= checker_data_$last_wired_collection
      696 	then meters.per_collection (Collection).words_used =
      697 		meters.per_collection (Collection).words_used + wired_length;
      698 
      699 	if this_slte.paged
      700 	then meters.per_collection (Collection).pages_used =
      701 		meters.per_collection (Collection).pages_used + paged_length;
      702 
      703 	if this_slte.wired & this_slte.paged
      704 	then meters.per_collection (Collection).wired_pages_used =
      705 		meters.per_collection (Collection).wired_pages_used + paged_length;
      706 
      707 	if Collection <= checker_data_$last_supervisor_collection
      708 	then meters.per_collection (Collection).temp_segment_count =
      709 		meters.per_collection (Collection).temp_segment_count + 1;
      710 
      711 	else meters.per_collection (Collection).perm_segment_count =
      712 		meters.per_collection (Collection).perm_segment_count + 1;
      713 
      714 	if this_slte.ringbrack (1) > 0
      715 	then do;
      716 		meters.per_collection (Collection).user_ring_segment_count =
      717 		     meters.per_collection (Collection).user_ring_segment_count + 1;
      718 		meters.per_collection (Collection).user_ring_segment_pages =
      719 		     meters.per_collection (Collection).user_ring_segment_pages + paged_length;
      720 	     end;
      721 	return;
      722 
      723 INTERESTING_SEGMENT:
      724      procedure;
      725 
      726 /* See if this segment is one whose size is a limiter */
      727 /* use the global "segment_name" for comparisons */
      728 
      729 	if segment_name = "ai_linkage"
      730 	then call SIZES (meters.wired_ai_linkage_size, meters.paged_ai_linkage_size);
      731 	else if segment_name = "as_linkage"
      732 	then call SIZES (meters.wired_as_linkage_size, meters.paged_as_linkage_size);
      733 	else if segment_name = "wi_linkage"
      734 	then call SIZES (meters.wired_wi_linkage_size, meters.paged_wi_linkage_size);
      735 	else if segment_name = "ws_linkage"
      736 	then call SIZES (meters.wired_ws_linkage_size, meters.paged_ws_linkage_size);
      737 	else if segment_name = "definitions_"
      738 	then call SIZES (meters.wired_definitions_size, meters.paged_definitions_size);
      739 	else if segment_name = "name_table"
      740 	then call SIZES (meters.wired_nt_size, meters.paged_nt_size);
      741 	else if segment_name = "dseg"
      742 	then do;
      743 		meters.wired_sdw_count = divide (wired_length, 2, 18, 0);
      744 		meters.paged_sdw_count = 2048;	/* not available from header */
      745 	     end;
      746 	else if segment_name = "slt"
      747 	then do;
      748 		meters.wired_slte_count = divide (wired_length - 8, 4, 19, 0);
      749 						/* header is 4 words slte is 8 words */
      750 		meters.paged_slte_count = divide ((paged_length * 1024) - 8, 4, 19, 0);
      751 	     end;
      752 
      753 	return;
      754 
      755 SIZES:
      756      procedure (wired_to_set, paged_to_set);
      757 	declare (wired_to_set, paged_to_set)
      758 				 fixed bin;
      759 
      760 	wired_to_set = wired_length;
      761 	paged_to_set = paged_length * 1024;
      762      end SIZES;
      763 
      764      end INTERESTING_SEGMENT;
      765 
      766 SEG_PAGED:
      767      procedure returns (bit (1) aligned);
      768 
      769 /* Should we report paged length? */
      770 
      771 	return (this_slte.ringbrack (1) > 0 /* all user ring segments */
      772 	     | Collection > checker_data_$last_wired_collection /* loaded paged */
      773 	     | (Collection ^> checker_data_$last_wired_collection & /* else */ (this_slte.paged & ^this_slte.temp_seg))
      774 	     /* must stay around */);
      775      end SEG_PAGED;
      776 
      777 REPORT_SEGMENT:
      778      procedure;
      779 
      780 	segment_name = this_namep -> segnam.names (1).name;
      781 
      782 	call checker_print_ (
      783 	     "^32a^2x^[^3o^;^3x^s^]^2x(^1d, ^1d, ^1d)^50t^[read ^]^[execute ^]^[write ^]^[privileged ^]^[encacheable ^]^[gate ^]^[wired^]",
      784 	     segment_name, checker_data_$loaded (Collection), segment_number, slte_uns.ringbrack,
      785 	     substr (this_slte.access, 1, 1), substr (this_slte.access, 2, 1), substr (this_slte.access, 3, 1),
      786 	     substr (this_slte.access, 4, 1), this_slte.cache, this_slte.ringbrack (3) > this_slte.ringbrack (2),
      787 	     this_slte.wired | this_slte.firmware_seg);	/* firmware segs are wired */
      788 
      789 /* use the namep from the header */
      790 
      791 	if this_namep -> segnam.count > 1
      792 	then a_name = this_namep -> segnam.names (2).name;
      793 	else a_name = "";
      794 
      795 	if ^this_slte.init_seg & ^this_slte.temp_seg & ^this_slte.per_process & ^this_slte.firmware_seg
      796 	then next_name = 2;
      797 	else do;
      798 		call checker_print_ ("^5x^32a^50t^[init seg; ^]^[temp seg; ^]^[per process; ^]^[firmware^]", a_name,
      799 		     this_slte.init_seg, this_slte.temp_seg, this_slte.per_process, this_slte.firmware_seg);
      800 		next_name = 3;
      801 	     end;
      802 
      803 	word_length = divide (this_slte.bit_count, 36, 24, 0);
      804 	wired_length = divide (word_length + 1023, 1024, 18, 0) * 1024;
      805 	paged_length = max (this_slte.cur_length, this_slte.max_length);
      806 
      807 	if this_namep -> segnam.count >= next_name
      808 	then do;
      809 		a_name = this_namep -> segnam.names (next_name).name;
      810 		next_name = next_name + 1;
      811 	     end;
      812 	else a_name = "";
      813 
      814 	if this_slte.abs_seg
      815 	then call checker_print_ ("^5x^32a^50tabs seg -- no storage allocated.", a_name);
      816 
      817 	else call checker_print_ (
      818 		"^5x^32a^50t^[wired length: ^d words;^;^s^] ^[paged length: ^d pages;^;^s^] ^[max length: ^d pages;^;^s^]",
      819 		a_name, Collection ^> checker_data_$last_wired_collection, wired_length, SEG_PAGED (), paged_length,
      820 		this_slte.branch_required & (this_slte.max_length ^= paged_length & this_slte.max_length ^= 0),
      821 		this_slte.max_length);
      822 
      823 
      824 	if this_slte.branch_required
      825 	then do;
      826 		if this_namep -> segnam.count >= next_name
      827 		then do;
      828 			a_name = this_namep -> segnam.names (next_name).name;
      829 			next_name = next_name + 1;
      830 		     end;
      831 		else a_name = "";
      832 
      833 		call checker_print_ ("^5x^32a^50tpath: ^a>^a", a_name, this_pathp -> path.name, segment_name);
      834 	     end;
      835 
      836 	if next_name ^> this_namep -> segnam.count
      837 	then begin;
      838 		declare namex		 fixed bin;
      839 		do namex = next_name to this_namep -> segnam.count by 4;
      840 		     if namex + 3 > this_namep -> segnam.count
      841 		     then do;
      842 			     go to RESIDUE (this_namep -> segnam.count - namex + 1);
      843 RESIDUE (1):
      844 			     call checker_print_ ("^5x^32a", this_namep -> segnam.names (namex).name);
      845 			     go to EXIT_NAMES;
      846 RESIDUE (2):
      847 			     call checker_print_ ("^5x^32a^x^32a", this_namep -> segnam.names (namex).name,
      848 				this_namep -> segnam.names (namex + 1).name);
      849 			     go to EXIT_NAMES;
      850 RESIDUE (3):
      851 			     call checker_print_ ("^5x^32a^x^32a^x^32a", this_namep -> segnam.names (namex).name,
      852 				this_namep -> segnam.names (namex + 1).name,
      853 				this_namep -> segnam.names (namex + 2).name);
      854 EXIT_NAMES:
      855 			end;
      856 		     else call checker_print_ ("^5x^32a^x^32a^x^32a^x^32a", this_namep -> segnam.names (namex).name,
      857 			     this_namep -> segnam.names (namex + 1).name,
      858 			     this_namep -> segnam.names (namex + 2).name,
      859 			     this_namep -> segnam.names (namex + 3).name);
      860 		end;
      861 	     end;
      862 
      863 	if this_slte.acl_provided
      864 	then do;
      865 		do aclx = 1 to this_aclp -> acls.count;
      866 		     call checker_print_ ("^5x^[null^]^[r^]^[e^]^[w^]^10t^32a",
      867 			substr (this_aclp -> acls.mode (aclx), 1, 3) = "000"b,
      868 			substr (this_aclp -> acls.mode (aclx), 1, 1), substr (this_aclp -> acls.mode (aclx), 2, 1),
      869 			substr (this_aclp -> acls.mode (aclx), 3, 1), this_aclp -> acls.userid (aclx));
      870 		end;
      871 	     end;
      872 
      873 /* Now check for mistakes */
      874 
      875 
      876 	if this_slte.temp_seg & ^this_slte.init_seg
      877 	then call checker_print_$error (CHECKER_SEVERE, (0), segment_name,
      878 		" Temp seg but not init seg, will not be deleted.");
      879 
      880 	if ^substr (this_slte.access, 1, 1) & ^this_slte.abs_seg
      881 	then call checker_print_$error (CHECKER_SEVERE, (0), segment_name, " No read access in SDW");
      882 
      883 	if this_slte.branch_required & ^this_slte.paged
      884 	then call checker_print_$error (CHECKER_SEVERE, (0), segment_name, " Only paged segments may have branches.");
      885 
      886 	if this_slte.branch_required & this_slte.init_seg
      887 	then call checker_print_$error (CHECKER_SEVERE, (0), segment_name, "  Init segs may not have branches.");
      888 
      889 	if this_slte.paged & (this_slte.max_length ^= 0) & (this_slte.max_length < this_slte.cur_length)
      890 	then call checker_print_$error (CHECKER_SEVERE, (0), segment_name, " Max length < Cur length.");
      891 
      892 	if this_slte.paged & (this_slte.cur_length * 1024) < word_length
      893 	then call checker_print_$error (CHECKER_SEVERE, (0), segment_name, " Cur length < Bit count.");
      894 
      895 	if this_slte.ringbrack (1) > this_slte.ringbrack (2) | this_slte.ringbrack (1) > this_slte.ringbrack (3)
      896 	     | this_slte.ringbrack (2) > this_slte.ringbrack (3)
      897 	then call checker_print_$error (CHECKER_SEVERE, (0), segment_name, " Illegal ring bracket order.");
      898 
      899 	if (this_slte.ringbrack (1) > 0 | this_slte.ringbrack (2) > 0 | this_slte.ringbrack (3) > 0)
      900 	     & ^this_slte.branch_required
      901 	then call checker_print_ (CHECKER_SEVERE, (0), segment_name, " Gate has no branch.");
      902 
      903 	if this_slte.branch_required
      904 	then do;
      905 		if this_pathp -> path.size = 0
      906 		then call checker_print_$error (CHECKER_SEVERE, (0), segment_name, " Zero length branch pathname.");
      907 		if char (this_pathp -> path.name, 1) ^= ">"
      908 		then call checker_print_$error (CHECKER_SEVERE, (0), segment_name, " Pathname must begin with > .");
      909 		call absolute_pathname_ (this_pathp -> path.name, (""), code);
      910 		if code ^= 0
      911 		then call checker_print_$error (CHECKER_SEVERE, code, segment_name, " Bad pathname: ^a.",
      912 			this_pathp -> path.name);
      913 	     end;
      914 
      915 	if this_slte.acl_provided
      916 	then do aclx = 1 to this_aclp -> acls.count;
      917 		first = before (this_aclp -> acls.userid (aclx), ".");
      918 		second = before (after (this_aclp -> acl.userid (aclx), "."), ".");
      919 		third = after (after (this_aclp -> acls.userid (aclx), "."), ".");
      920 		if first = "" | second = "" | third = "" | index (third, ".") > 0
      921 		then call checker_print_$error (CHECKER_SEVERE, (0), segment_name,
      922 			" Invalid Access Name Format in ^a.", this_aclp -> acls.userid (aclx));
      923 	     end;
      924 	return;
      925      end REPORT_SEGMENT;
      926      end PROCESS_SLTE;
      927 
      928 Read_Control_Word:
      929      proc;
      930 
      931 	call tape_reader_ (addr (control_word), 1);
      932 
      933      end Read_Control_Word;
      934 
      935 COLLECTION_SUMMARY:
      936      procedure;
      937 	declare 1 PC		 aligned like meters.per_collection defined (meters.per_collection (Collection));
      938 
      939 	call checker_print_$page;
      940 	call checker_print_ ("Summary of Collection: ^d.^d", PC.mark.major, PC.mark.minor);
      941 	call checker_print_$skip;
      942 	call checker_print_ ("Segments read:^32t^d; ^d temp, ^d init, ^d perm(^d user ring)", PC.segment_count,
      943 	     PC.temp_segment_count, PC.init_segment_count, PC.perm_segment_count, PC.user_ring_segment_count);
      944 	if Collection <= checker_data_$last_wired_collection
      945 	then call checker_print_ ("Wired storage:^32t^d words.", PC.words_used);
      946 	call checker_print_ ("Paged storage:^32t^d pages.", PC.pages_used);
      947 	call checker_print_ ("Wired paged storage:^32t^d pages.", PC.wired_pages_used);
      948 	if PC.user_ring_segment_count > 0
      949 	then call checker_print_ ("User ring pages:^32t^d pages.", PC.user_ring_segment_pages);
      950 	call checker_print_$skip;
      951 
      952 	if Collection <= checker_data_$last_supervisor_collection & checker_data_$loaded (Collection)
      953 	then do;
      954 
      955 		call checker_print_ ("Combined linkage usage:  Active Wired (in words)");
      956 		call checker_print_ ("-----------------------|------|------");
      957 		call checker_print_ ("                  init: ^6d^x^6d", PC.ai_linkage_used, PC.wi_linkage_used);
      958 		call checker_print_ ("                   sup: ^6d^x^6d", PC.as_linkage_used, PC.ws_linkage_used);
      959 		call checker_print_$skip;
      960 
      961 		call checker_print_ ("Definitions Used: ^5d words.", PC.definitions_used);
      962 		call checker_print_ ("Name Table Used:  ^5d words.", PC.name_table_used);
      963 	     end;
      964      end COLLECTION_SUMMARY;
      965 
      966 TOTAL_SUMMARY:
      967      procedure;
      968 
      969 	call checker_print_$page;
      970 	call checker_print_ ("Total Summary:");
      971 	call checker_print_$skip;
      972 
      973 	call checker_print_ ("total segments: ^d.", sum (meters.per_collection.segment_count));
      974 	call checker_print_ ("          temp: ^d.", sum (meters.per_collection.temp_segment_count));
      975 	call checker_print_ ("          init: ^d.", sum (meters.per_collection.init_segment_count));
      976 	call checker_print_ ("          perm: ^d.", sum (meters.per_collection.perm_segment_count));
      977 	call checker_print_ ("     user ring: ^d.", sum (meters.per_collection.user_ring_segment_count));
      978 
      979 	call checker_print_ ("Wired Environment Usage");
      980 	call checker_print_ ("     Name                 Size            Used");
      981 	call USAGE ("ai_linkage", meters.wired_ai_linkage_size, meters.wired_ai_linkage_used,
      982 	     meters.overflown.wired_ai_linkage);
      983 	call USAGE ("wi_linkage", meters.wired_wi_linkage_size, meters.wired_wi_linkage_used,
      984 	     meters.overflown.wired_wi_linkage);
      985 	call USAGE ("as_linkage", meters.wired_as_linkage_size, meters.wired_as_linkage_used,
      986 	     meters.overflown.wired_as_linkage);
      987 	call USAGE ("ws_linkage", meters.wired_ws_linkage_size, meters.wired_ws_linkage_used,
      988 	     meters.overflown.wired_ws_linkage);
      989 	call USAGE ("definitions", meters.wired_definitions_size, meters.wired_definitions_used,
      990 	     meters.overflown.wired_definitions);
      991 	call USAGE ("name table", meters.wired_nt_size, meters.wired_nt_used, meters.overflown.wired_nt);
      992 
      993 	call checker_print_$skip;
      994 	call checker_print_ ("Paged Environment Usage");
      995 	call checker_print_ ("     Name                 Size            Used");
      996 	call USAGE ("ai_linkage", meters.paged_ai_linkage_size, meters.paged_ai_linkage_used,
      997 	     meters.overflown.paged_ai_linkage);
      998 	call USAGE ("wi_linkage", meters.paged_wi_linkage_size, meters.paged_wi_linkage_used,
      999 	     meters.overflown.paged_wi_linkage);
     1000 	call USAGE ("as_linkage", meters.paged_as_linkage_size, meters.paged_as_linkage_used,
     1001 	     meters.overflown.paged_as_linkage);
     1002 	call USAGE ("ws_linkage", meters.paged_ws_linkage_size, meters.paged_ws_linkage_used,
     1003 	     meters.overflown.paged_ws_linkage);
     1004 	call USAGE ("definitions", meters.paged_definitions_size, meters.paged_definitions_used,
     1005 	     meters.overflown.paged_definitions);
     1006 	call USAGE ("name table", meters.paged_nt_size, meters.paged_nt_used, meters.overflown.paged_nt);
     1007 
     1008 	return;
     1009 
     1010 USAGE:
     1011      procedure (name, size, used, overflown);
     1012 	declare name		 char (*);
     1013 	declare size		 fixed bin;
     1014 	declare used		 fixed bin;
     1015 	declare overflown		 bit (1) unaligned;
     1016 
     1017 	call checker_print_ ("^[*****^;^5x^]^20a^x^6d^36t^6d^43t^[OVERFLOWN^]", overflown, name, size, used, overflown);
     1018      end USAGE;
     1019      end TOTAL_SUMMARY;
     1020 
     1021 CHECK_BOOTABLE_LABEL:
     1022      procedure;
     1023 
     1024 	declare 1 BPI		 aligned like boot_program_info;
     1025 	declare tape_reader_$rewind	 entry (char (32), fixed bin (21));
     1026 
     1027 	call tape_reader_$rewind (BPI.boot_program_name, BPI.boot_program_text_length);
     1028 	if BPI.boot_program_name = ""
     1029 	then do;
     1030 		call checker_print_ ("No bootable label on MST.");
     1031 		return;				/* No boot program */
     1032 	     end;
     1033 
     1034 	call checker_print_ ("Boot program: ^a, ^d words.", BPI.boot_program_name, BPI.boot_program_text_length);
     1035 
     1036 	call checker_print_$skip;
     1037 
     1038      end CHECK_BOOTABLE_LABEL;
     1039 
     1040      end checker_load_MST_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/15/87  1602.4  checker_load_MST_.pl1             >special_ldd>install>MR12.1-1040>checker_load_MST_.pl1
85           1    05/24/82  1005.0  slt.incl.pl1                      >ldd>include>slt.incl.pl1
86           2    07/11/84  0937.3  slte.incl.pl1                     >ldd>include>slte.incl.pl1
87           3    11/24/86  1226.9  object_link_dcls.incl.pl1         >ldd>include>object_link_dcls.incl.pl1
88           4    11/24/86  1226.9  definition_dcls.incl.pl1          >ldd>include>definition_dcls.incl.pl1
89           5    07/11/84  0937.3  checker_dcls_.incl.pl1            >ldd>include>checker_dcls_.incl.pl1
90           6    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
91           7    03/27/82  0429.7  tape_mult_boot_info.incl.pl1      >ldd>include>tape_mult_boot_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BPI                             002536 automatic       structure                level 1 dcl 1024
CHECKER_FATAL                   000104 constant        fixed bin(17,0)          initial dcl 5-120 set ref 129* 215* 236* 242* 269*
                                                                                  298* 312* 321*
CHECKER_SEVERE                  000103 constant        fixed bin(17,0)          initial dcl 5-120 set ref 212* 260* 442* 463* 471*
                                                                                  599* 618* 876* 880* 883* 886* 889* 892* 895* 899*
                                                                                  905* 907* 910* 920*
CHECKER_WARNING                 000105 constant        fixed bin(17,0)          initial dcl 5-120 set ref 220*
COLLECTION_MARK                        constant        fixed bin(18,0)          initial unsigned dcl 78 ref 208
Collection                      002206 automatic       fixed bin(17,0)          dcl 97 set ref 124* 161* 161 162 164 197 199 199 199
                                                                                  220 220 220 220 228 229 257 272 367 376 376 380
                                                                                  390 390 395 404 404 408 417 417 454 457 457 459
                                                                                  584 584 585 626 626 626 631 631 633 633 639 639
                                                                                  643 643 647 647 651 651 655 655 660 660 662 662
                                                                                  666 666 666 670 671 674 694 694 695 695 695 699
                                                                                  699 703 703 707 707 707 711 711 716 716 718 718
                                                                                  771 771 782 817 940 940 942 942 942 942 942 944
                                                                                  944 946 947 948 948 952 952 957 957 958 958 961
                                                                                  962
HEADER                                 constant        fixed bin(18,0)          initial unsigned dcl 78 ref 129 236
HEADER_MAX_SIZE                        constant        fixed bin(17,0)          initial dcl 67 ref 242
ME                              000003 constant        char(32)                 initial unaligned dcl 57 set ref 164*
MST_tape_eof_                   002254 stack reference condition                dcl 104 ref 158
PC                                     defined         structure                level 1 dcl 937
SEGMENT                                constant        fixed bin(18,0)          initial unsigned dcl 78 ref 269
a_defs_length                   002074 automatic       fixed bin(17,0)          dcl 5-118 set ref 539* 540 540
a_n_links                       002070 automatic       fixed bin(17,0)          dcl 5-111 set ref 518* 519 519
a_name                          002400 automatic       char(32)                 unaligned dcl 563 set ref 791* 793* 798* 809* 812*
                                                                                  814* 817* 828* 831* 833*
abs_seg                   1(05)        based           bit(1)                   level 2 packed unaligned dcl 559 ref 814 880
absolute_pathname_              000010 constant        entry                    external dcl 40 ref 909
access                    1            based           bit(4)                   level 2 packed unaligned dcl 559 ref 782 782 782 782
                                                                                  782 782 782 782 880
acl                       1            based           structure                array level 2 dcl 1-45
acl_provided              1(17)        based           bit(1)                   level 2 packed unaligned dcl 559 ref 592 612 636 863
                                                                                  915
acls                                   based           structure                level 1 dcl 1-45 in procedure "checker_load_MST_"
                                                                                  set ref 592 612 636
acls                                   based           fixed bin(17,0)          level 2 in structure "path" dcl 1-40 in procedure
                                                                                  "checker_load_MST_" set ref 577 687
aclx                            002411 automatic       fixed bin(17,0)          dcl 565 set ref 865* 866 866 866 866 866 866 866
                                                                                  866* 915* 917 918 919 920*
addr                                                   builtin function         dcl 59 ref 110 132 132 219 219 250 250 252 274 274
                                                                                  281 281 350 350 542 572 577 687 931 931
addrel                                                 builtin function         dcl 59 ref 111 505 683 686
after                                                  builtin function         dcl 59 ref 918 919 919
ai_linkage_used          16            defined         fixed bin(17,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 957*
ai_linkage_used          53            based           fixed bin(17,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 404* 404
amount                                 parameter       fixed bin(17,0)          dcl 432 ref 429 439
as_linkage_used          55            based           fixed bin(17,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 417* 417
as_linkage_used          20            defined         fixed bin(17,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 958*
baseno                                                 builtin function         dcl 59 ref 283
before                                                 builtin function         dcl 59 ref 917 918
begin_links               6            based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 3-50 ref 505
bin                                                    builtin function         dcl 59 ref 283
bit_count                 3(12)        based           fixed bin(24,0)          level 2 in structure "this_slte" packed unsigned
                                                                                  unaligned dcl 559 in procedure "PROCESS_SLTE" ref
                                                                                  803
bit_count                 3(12) 002202 automatic       fixed bin(24,0)          level 2 in structure "cur_slte" packed unsigned
                                                                                  unaligned dcl 96 in procedure "checker_load_MST_"
                                                                                  set ref 346 350
boot_program_info               002076 automatic       structure                level 1 dcl 7-4
boot_program_name         5     002536 automatic       char(32)                 level 2 packed unaligned dcl 1024 set ref 1027* 1028
                                                                                  1034*
boot_program_text_length
                          4     002536 automatic       fixed bin(21,0)          level 2 dcl 1024 set ref 1027* 1034*
branch_required           1(21)        based           bit(1)                   level 2 in structure "this_slte" packed unaligned
                                                                                  dcl 559 in procedure "PROCESS_SLTE" ref 590 610
                                                                                  633 817 824 883 886 899 903
branch_required           1(21)        based           bit(1)                   level 2 in structure "slte" packed unaligned
                                                                                  dcl 2-48 in procedure "checker_load_MST_" ref 574
                                                                                  684
cache                     1(04)        based           bit(1)                   level 2 packed unaligned dcl 559 set ref 782*
char                                                   builtin function         dcl 59 ref 907
checker_area                           based           area                     dcl 5-8 ref 519 540
checker_data_$area_ptr          000042 external static pointer                  dcl 5-7 ref 519 540
checker_data_$buffer_ptr        000046 external static pointer                  dcl 5-11 set ref 154* 275* 292* 337* 350* 424* 425
                                                                                  426* 477* 478*
checker_data_$collection_names  000060 external static structure                array level 1 unaligned dcl 5-25
checker_data_$last_supervisor_collection
                                000056 external static fixed bin(17,0)          dcl 5-22 ref 707 952
checker_data_$last_text_wired_collection
                                000054 external static fixed bin(17,0)          dcl 5-20 ref 626
checker_data_$last_wired_collection
                                000052 external static fixed bin(17,0)          dcl 5-18 ref 199 367 380 395 408 454 459 585 695 771
                                                                                  771 817 944
checker_data_$loaded            000062 external static bit(1)                   array dcl 5-29 set ref 257 272 782* 952
checker_data_$meter_ptr         000050 external static pointer                  dcl 5-12 ref 122 162 197 228 229 369 369 370 370 370
                                                                                  373 373 374 374 374 376 376 382 382 383 383 383
                                                                                  387 387 388 388 388 390 390 397 397 398 398 398
                                                                                  401 401 402 402 402 404 404 410 410 411 411 411
                                                                                  414 414 415 415 415 417 417 454 454 456 456 457
                                                                                  457 459 459 459 463 466 469 469 471 474 529 548
                                                                                  584 584 587 587 588 588 589 589 590 590 592 592
                                                                                  596 596 596 599 603 607 607 608 608 609 609 610
                                                                                  610 612 612 615 615 615 618 622 626 626 631 631
                                                                                  633 633 636 636 639 639 643 643 647 647 651 651
                                                                                  655 655 660 660 662 662 666 666 666 670 670 671
                                                                                  674 694 694 695 695 699 699 703 703 707 707 711
                                                                                  711 716 716 718 718 729 729 731 731 733 733 735
                                                                                  735 737 737 739 739 743 744 748 750 940 940 942
                                                                                  942 942 942 942 944 946 947 948 948 957 957 958
                                                                                  958 961 962 973 973 974 974 975 975 976 976 977
                                                                                  977 981 981 981 983 983 983 985 985 985 987 987
                                                                                  987 989 989 989 991 991 991 996 996 996 998 998
                                                                                  998 1000 1000 1000 1002 1002 1002 1004 1004 1004
                                                                                  1006 1006 1006
checker_data_$name_table_ptr    000044 external static pointer                  dcl 5-10 ref 108 573 576
checker_data_$slt_ptr           000040 external static pointer                  dcl 5-6 ref 107
checker_print_                  000012 constant        entry                    external dcl 42 ref 121 144 199 230 782 798 814 817
                                                                                  833 843 846 850 856 866 899 940 942 944 946 947
                                                                                  948 955 956 957 958 961 962 970 973 974 975 976
                                                                                  977 979 980 994 995 1017 1030 1034
checker_print_$error            000014 constant        entry                    external dcl 43 ref 129 212 215 220 236 242 260 269
                                                                                  298 312 321 442 463 471 599 618 876 880 883 886
                                                                                  889 892 895 905 907 910 920
checker_print_$page             000020 constant        entry                    external dcl 45 ref 198 939 969
checker_print_$skip             000016 constant        entry                    external dcl 44 ref 135 139 143 206 941 950 959 971
                                                                                  993 1036
code                            002207 automatic       fixed bin(35,0)          dcl 98 set ref 164* 259* 260 350* 351 909* 910 910*
collection              371            based           fixed bin(17,0)          array level 3 dcl 5-35 set ref 674*
collection_mark                 002055 automatic       structure                level 1 dcl 74 set ref 219 219
collection_started              000100 automatic       bit(1)                   dcl 64 set ref 186* 195 203*
com_err_                        000034 constant        entry                    external dcl 54 ref 164
combine_link              1(27) 002274 automatic       bit(1)                   level 2 packed unaligned dcl 180 set ref 279 305
control_word                    002054 automatic       structure                level 1 dcl 70 set ref 931 931
count                     0(18) 002054 automatic       fixed bin(18,0)          level 2 in structure "control_word" packed unsigned
                                                                                  unaligned dcl 70 in procedure "checker_load_MST_"
                                                                                  set ref 132 154 215 219 242 242 242* 250 275 292
                                                                                  337 346 369 373 376 382 387 390 397 401 404 410
                                                                                  414 417 424 426 454 456 457 477 478
count                                  based           fixed bin(17,0)          level 2 in structure "acls" dcl 1-45 in procedure
                                                                                  "checker_load_MST_" ref 592 612 636 865 915
count                                  based           fixed bin(17,0)          level 2 in structure "segnam" dcl 1-31 in procedure
                                                                                  "checker_load_MST_" ref 257 589 609 631 686 791
                                                                                  807 826 836 839 840 842
counts                   15            based           structure                level 2 dcl 5-35
cur_length                2            based           fixed bin(9,0)           level 2 packed unsigned unaligned dcl 559 ref 805
                                                                                  889 892
cur_slte                        002202 automatic       structure                level 1 dcl 96 set ref 252* 331
currentsize                                            builtin function         dcl 59 ref 589 590 592 609 610 612 631 633 636 686
definition_flags                       based           structure                level 1 packed unaligned dcl 4-42
definitions               1            based           bit(36)                  array level 2 dcl 5-114 set ref 542
definitions_used         57            based           fixed bin(17,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 457* 457
definitions_used         22            defined         fixed bin(17,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 961*
defp                      4     002114 automatic       pointer                  level 2 dcl 94 set ref 354*
defs                      1(29) 002202 automatic       bit(1)                   level 2 packed unaligned dcl 96 set ref 279 310
defs_length                            parameter       fixed bin(18,0)          unsigned dcl 535 ref 532 539 546
defs_ptr                               parameter       pointer                  dcl 534 in procedure "PROCESS_DEFS" ref 532 546
defs_ptr                374            based           pointer                  array level 3 in structure "meters" packed unaligned
                                                                                  dcl 5-35 in procedure "checker_load_MST_" set ref
                                                                                  548*
divide                                                 builtin function         dcl 59 ref 498 743 748 750 803 804
dlng                     17     002114 automatic       fixed bin(17,0)          level 2 dcl 94 set ref 354
dptr                            002356 automatic       pointer                  dcl 536 set ref 542* 546
error_table_$namedup            000036 external static fixed bin(35,0)          dcl 55 set ref 260*
expect_defs                     002273 automatic       bit(1)                   dcl 179 set ref 184* 210 303* 312 317* 321
expect_link                     002272 automatic       bit(1)                   dcl 178 set ref 184* 210 212* 298 302* 321 326*
expression_relp           1            based           fixed bin(18,0)          array level 2 packed unsigned unaligned dcl 523 ref
                                                                                  525
expression_relps          1            based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 5-103
                                                                                  set ref 525*
firmware_seg              1(06) 002202 automatic       bit(1)                   level 2 in structure "cur_slte" packed unaligned
                                                                                  dcl 96 in procedure "checker_load_MST_" set ref
                                                                                  290
firmware_seg              1(06)        based           bit(1)                   level 2 in structure "this_slte" packed unaligned
                                                                                  dcl 559 in procedure "PROCESS_SLTE" set ref 782
                                                                                  795 798*
first                           002224 automatic       char(32)                 unaligned dcl 103 set ref 917* 920
first_init_seg            5            based           fixed bin(18,0)          level 2 dcl 1-13 ref 138
first_segment            40            based           fixed bin(18,0)          array level 3 dcl 5-35 set ref 666 666*
first_sup_seg             3            based           fixed bin(18,0)          level 2 dcl 1-13 ref 134
from                                   based           bit(36)                  array dcl 545 ref 546
hbound                                                 builtin function         dcl 59 ref 162
hc_seg_ptr                      002210 automatic       pointer                  dcl 99 set ref 281* 283
header_area                     000104 automatic       bit(36)                  array dcl 66 set ref 110 132 132 250 250 252 274 274
                                                                                  281 281
header_ptr                      000102 automatic       pointer                  dcl 65 set ref 110* 111
index                                                  builtin function         dcl 59 ref 920
init_seg                  1(22) 002274 automatic       bit(1)                   level 2 in structure "prev_slte" packed unaligned
                                                                                  dcl 180 in procedure "LOAD_ONE_COLLECTION" set ref
                                                                                  364 393
init_seg                  1(22)        based           bit(1)                   level 2 in structure "this_slte" packed unaligned
                                                                                  dcl 559 in procedure "PROCESS_SLTE" set ref 651
                                                                                  795 798* 876 886
init_segment_count       13            defined         fixed bin(17,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 942*
init_segment_count       50            based           fixed bin(17,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 651* 651
                                                                                  975 975
ioa_                            000022 constant        entry                    external dcl 46 ref 231
last_init_seg             6            based           fixed bin(18,0)          level 2 dcl 1-13 ref 138
last_segment             41            based           fixed bin(18,0)          array level 3 dcl 5-35 set ref 666* 670 671*
last_sup_seg              4            based           fixed bin(18,0)          level 2 dcl 1-13 ref 134
layout_seg                1(07)        based           bit(1)                   level 2 packed unaligned dcl 559 ref 626
length                                 based           fixed bin(17,0)          level 2 dcl 5-114 set ref 540*
limit                                  parameter       fixed bin(17,0)          dcl 431 ref 429 437 439
link_init                              based           structure                level 1 dcl 4-205
link_provided             1(24) 002202 automatic       bit(1)                   level 2 packed unaligned dcl 96 set ref 326
link_ptr                               parameter       pointer                  dcl 485 in procedure "PROCESS_LINKAGE" ref 481 493
                                                                                  505 505
link_ptr                373            based           pointer                  array level 3 in structure "meters" packed unaligned
                                                                                  dcl 5-35 in procedure "checker_load_MST_" set ref
                                                                                  529*
link_sect                 1(25) 002202 automatic       bit(1)                   level 2 packed unaligned dcl 96 set ref 279 296
link_sect_wired           1(26) 002274 automatic       bit(1)                   level 2 packed unaligned dcl 180 set ref 364
linkage_header                         based           structure                level 1 dcl 3-50
linkage_section_lng       6(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 3-71 ref 493
linkp                     6     002114 automatic       pointer                  level 2 dcl 94 set ref 353*
links                                  based           structure                array level 1 dcl 507 in begin block on line 506
links                                  based           structure                array level 1 dcl 523 in begin block on line 522
links_count                     002342 automatic       fixed bin(17,0)          dcl 488 set ref 498* 500 508 511* 518 524
links_length                           parameter       fixed bin(18,0)          unsigned dcl 487 ref 481 493
links_ptr                       002340 automatic       pointer                  dcl 486 set ref 505* 509 509 509 525 526
llng                     20     002114 automatic       fixed bin(17,0)          level 2 dcl 94 set ref 353
lx                              002343 automatic       fixed bin(17,0)          dcl 489 set ref 508* 509 509 509 511* 524* 525 525
                                                                                  526 526*
major                           002055 automatic       fixed bin(18,0)          level 2 in structure "collection_mark" packed
                                                                                  unsigned unaligned dcl 74 in procedure
                                                                                  "checker_load_MST_" set ref 220 220* 228 230* 231*
major                     1            defined         fixed bin(17,0)          level 3 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 940*
major                           000060 external static fixed bin(17,0)          array level 2 in structure
                                                                                  "checker_data_$collection_names" dcl 5-25
                                                                                  in procedure "checker_load_MST_" set ref 199* 220
                                                                                  220*
major                    36            based           fixed bin(17,0)          array level 4 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 228*
mark                     36            based           structure                array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_"
mark                      1            defined         structure                level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY"
max                                                    builtin function         dcl 59 ref 805
max_length                3(03)        based           fixed bin(9,0)           level 2 packed unsigned unaligned dcl 559 set ref
                                                                                  805 817 817 817* 889 889
mbz                       0(21)        based           bit(6)                   array level 2 packed unaligned dcl 507 ref 509
mbz2                      1(18)        based           bit(12)                  array level 2 packed unaligned dcl 507 ref 509
meters                                 based           structure                level 1 dcl 5-35
min                                                    builtin function         dcl 59 ref 493
minor                     1     000060 external static fixed bin(17,0)          array level 2 in structure
                                                                                  "checker_data_$collection_names" dcl 5-25
                                                                                  in procedure "checker_load_MST_" set ref 199* 220
                                                                                  220*
minor                     0(18) 002055 automatic       fixed bin(18,0)          level 2 in structure "collection_mark" packed
                                                                                  unsigned unaligned dcl 74 in procedure
                                                                                  "checker_load_MST_" set ref 220 220* 229 230* 231*
minor                    37            based           fixed bin(17,0)          array level 4 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 229*
minor                     2            defined         fixed bin(17,0)          level 3 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 940*
mode                     11            based           bit(36)                  array level 3 dcl 1-45 ref 866 866 866 866 866 866
                                                                                  866
modifier                  1(30)        based           bit(6)                   array level 2 packed unaligned dcl 523 ref 526
modifiers                 1(18)        based           bit(6)                   array level 3 packed unaligned dcl 5-103 set ref
                                                                                  526*
n_links                                based           fixed bin(17,0)          level 2 dcl 5-103 set ref 519* 520
name                                   parameter       char(32)                 unaligned dcl 434 in procedure "CHECK" set ref 429
                                                                                  442* 442*
name                      1            based           char                     level 2 in structure "path" packed unaligned
                                                                                  dcl 1-40 in procedure "checker_load_MST_" set ref
                                                                                  833* 907 909* 910*
name                      2            based           char(32)                 array level 3 in structure "segnam" packed unaligned
                                                                                  dcl 1-31 in procedure "checker_load_MST_" set ref
                                                                                  255 259* 260* 780 791 809 828 843* 846* 846* 850*
                                                                                  850* 850* 856* 856* 856* 856*
name                                   parameter       char                     unaligned dcl 1012 in procedure "USAGE" set ref 1010
                                                                                  1017*
name_table_used          23            defined         fixed bin(17,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 962*
name_table_used          60            based           fixed bin(17,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 631* 631
                                                                                  633* 633 636* 636
namep                           002062 automatic       pointer                  dcl 1-7 set ref 111* 255 257 259 260
names                     1            based           structure                array level 2 dcl 1-31
names_ptr                              based           bit(18)                  level 2 in structure "this_slte" packed unaligned
                                                                                  dcl 559 in procedure "PROCESS_SLTE" ref 573
names_ptr                       002060 automatic       pointer                  dcl 1-7 in procedure "checker_load_MST_" set ref
                                                                                  108*
namex                           002450 automatic       fixed bin(17,0)          dcl 838 set ref 839* 840 842 843 846 846 850 850 850
                                                                                  856 856 856 856*
next                    372            based           fixed bin(18,0)          array level 3 dcl 5-35 set ref 670*
next_name                       002410 automatic       fixed bin(17,0)          dcl 564 set ref 795* 800* 807 809 810* 810 826 828
                                                                                  829* 829 836 839
nx                              002223 automatic       fixed bin(17,0)          dcl 102 set ref 257* 259 260*
object_info                            based           structure                level 1 dcl 6-6
object_info_$brief              000032 constant        entry                    external dcl 52 ref 350
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 6-60 ref 349
object_link                            based           structure                level 1 dcl 3-28
oi                              002114 automatic       structure                level 1 dcl 94 set ref 350 350
overflown                              parameter       bit(1)                   unaligned dcl 1015 in procedure "USAGE" set ref 1010
                                                                                  1017* 1017*
overflown                14            based           structure                level 2 in structure "meters" dcl 5-35 in procedure
                                                                                  "checker_load_MST_"
p_segment_number                       parameter       fixed bin(18,0)          dcl 554 ref 552 571
p_sltep                                parameter       pointer                  dcl 555 ref 679 682
paged                     1(13)        based           bit(1)                   level 2 in structure "this_slte" packed unaligned
                                                                                  dcl 559 in procedure "PROCESS_SLTE" ref 639 643
                                                                                  699 703 771 883 889 892
paged                                  parameter       bit(1)                   dcl 433 in procedure "CHECK" set ref 429 442* 442*
paged_ai_linkage         14(01)        based           bit(1)                   level 3 packed unaligned dcl 5-35 set ref 402* 415*
                                                                                  996*
paged_ai_linkage_size
                          1            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 402* 729* 996*
paged_ai_linkage_used
                         24            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 401* 401 402* 996*
paged_as_linkage         14(05)        based           bit(1)                   level 3 packed unaligned dcl 5-35 set ref 1000*
paged_as_linkage_size
                          5            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 415* 731* 1000*
paged_as_linkage_used
                         30            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 414* 414 415* 1000*
paged_definitions        14(09)        based           bit(1)                   level 3 packed unaligned dcl 5-35 set ref 471 474*
                                                                                  1004*
paged_definitions_size
                         11            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 469 737* 1004*
paged_definitions_used
                         34            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 456* 456 469 1004*
paged_length                    002414 automatic       fixed bin(17,0)          dcl 569 set ref 639 643 662 699 703 718 750 761 805*
                                                                                  817* 817
paged_nt                 14(11)        based           bit(1)                   level 3 packed unaligned dcl 5-35 set ref 618 622*
                                                                                  1006*
paged_nt_size            13            based           fixed bin(17,0)          level 2 dcl 5-35 set ref 615 615 739* 1006*
paged_nt_used            22            based           fixed bin(17,0)          level 2 dcl 5-35 set ref 609* 609 610* 610 612* 612
                                                                                  615 1006*
paged_sdw_count          16            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 607* 607 744*
paged_slte_count         20            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 608* 608 750*
paged_to_set                           parameter       fixed bin(17,0)          dcl 757 set ref 755 761*
paged_wi_linkage         14(03)        based           bit(1)                   level 3 packed unaligned dcl 5-35 set ref 374* 998*
paged_wi_linkage_size
                          3            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 374* 733* 998*
paged_wi_linkage_used
                         26            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 373* 373 374* 998*
paged_ws_linkage         14(07)        based           bit(1)                   level 3 packed unaligned dcl 5-35 set ref 388* 1002*
paged_ws_linkage_size
                          7            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 388* 735* 1002*
paged_ws_linkage_used
                         32            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 387* 387 388* 1002*
pages_used               44            based           fixed bin(35,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 639* 639
                                                                                  699* 699
pages_used                7            defined         fixed bin(35,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 946*
path                                   based           structure                level 1 dcl 1-40 set ref 590 610 633
path_ptr                  0(18)        based           bit(18)                  level 2 packed unaligned dcl 559 ref 576
per_collection           35            based           structure                array level 2 dcl 5-35 set ref 162 940 940 940 940
                                                                                  942 942 942 942 942 942 942 942 942 942 944 944
                                                                                  946 946 947 947 948 948 948 948 957 957 957 957
                                                                                  958 958 958 958 961 961 962 962
per_link                  1            based           structure                array level 2 dcl 5-103 set ref 520*
per_process               1(14)        based           bit(1)                   level 2 packed unaligned dcl 559 set ref 795 798*
per_segment             371            based           structure                array level 2 dcl 5-35
perm_segment_count       11            defined         fixed bin(17,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 942*
perm_segment_count       46            based           fixed bin(17,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 655* 655
                                                                                  711* 711 976 976
prev_slte                       002274 automatic       structure                level 1 dcl 180 set ref 183* 331*
printed                                parameter       bit(1)                   unaligned dcl 435 set ref 429 442 446*
ptr                                                    builtin function         dcl 59 ref 573 576
read                     35            based           bit(1)                   array level 3 dcl 5-35 set ref 122* 197*
ringbrack                 2(09)        based           fixed bin(3,0)           array level 2 in structure "slte_uns" packed
                                                                                  unsigned unaligned dcl 2-10 in procedure
                                                                                  "checker_load_MST_" set ref 782*
ringbrack                 2(09) 002202 automatic       fixed bin(3,0)           array level 2 in structure "cur_slte" packed
                                                                                  unsigned unaligned dcl 96 in procedure
                                                                                  "checker_load_MST_" set ref 340
ringbrack                 2(09)        based           fixed bin(3,0)           array level 2 in structure "this_slte" packed
                                                                                  unsigned unaligned dcl 559 in procedure
                                                                                  "PROCESS_SLTE" ref 658 714 771 782 782 895 895 895
                                                                                  895 895 895 899 899 899
second                          002234 automatic       char(32)                 unaligned dcl 103 set ref 918* 920
section_length                  002344 automatic       fixed bin(17,0)          dcl 490 set ref 493* 495 498
seg                      10            based           structure                array level 2 dcl 1-13 set ref 572
segment_count            42            based           fixed bin(17,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 584* 584
                                                                                  694* 694 973 973
segment_count             5            defined         fixed bin(17,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 942*
segment_defs                           based           structure                level 1 dcl 5-114 set ref 540
segment_defs_ptr                002072 automatic       pointer                  dcl 5-113 set ref 540* 542 548
segment_links                          based           structure                level 1 dcl 5-103 set ref 519
segment_links_ptr               002066 automatic       pointer                  dcl 5-102 set ref 519* 520 525 526 529
segment_name                    002212 automatic       char(32)                 unaligned dcl 100 set ref 236* 255* 269* 298* 312*
                                                                                  321* 442* 463* 471* 599* 618* 729 731 733 735 737
                                                                                  739 741 746 780* 782* 833* 876* 880* 883* 886*
                                                                                  889* 892* 895* 899* 905* 907* 910* 920*
segment_number            7            based           fixed bin(18,0)          level 3 in structure "linkage_header" packed
                                                                                  unsigned unaligned dcl 3-50 in procedure
                                                                                  "checker_load_MST_" set ref 425*
segment_number                  002222 automatic       fixed bin(18,0)          dcl 101 in procedure "checker_load_MST_" set ref
                                                                                  134* 136* 138* 140* 259* 260* 283* 284* 329 353*
                                                                                  354*
segment_number                         parameter       fixed bin(18,0)          dcl 484 in procedure "PROCESS_LINKAGE" ref 481 529
segment_number                  002366 automatic       fixed bin(18,0)          dcl 557 in procedure "PROCESS_SLTE" set ref 571* 572
                                                                                  666 670 671 674 782*
segnam                                 based           structure                level 1 dcl 1-31 set ref 589 609 631 686
segno                                  parameter       fixed bin(18,0)          dcl 537 ref 532 548
size                                                   builtin function         dcl 59 in procedure "checker_load_MST_" ref 111 495
                                                                                  683
size                                   parameter       fixed bin(17,0)          dcl 1013 in procedure "USAGE" set ref 1010 1017*
size                                   based           fixed bin(17,0)          level 2 in structure "path" dcl 1-40 in procedure
                                                                                  "checker_load_MST_" ref 577 590 610 633 687 833
                                                                                  833 905 907 909 909 910 910
sizes                                  based           structure                level 2 dcl 5-35
slt                                    based           structure                level 1 dcl 1-13
slte                                   based           structure                level 1 dcl 2-48 ref 111 683
slte_uns                               based           structure                level 1 dcl 2-10 set ref 252
sltep                           002064 automatic       pointer                  dcl 2-8 set ref 110* 111 683 782
sltp                            002056 automatic       pointer                  dcl 1-7 set ref 107* 134 134 138 138 572
sslt_manager_$build_entry       000026 constant        entry                    external dcl 48 ref 281
sslt_manager_$get_seg_num       000030 constant        entry                    external dcl 50 ref 259
stats                     6            based           structure                level 2 dcl 3-50
substr                                                 builtin function         dcl 59 ref 782 782 782 782 782 782 782 782 866 866
                                                                                  866 866 866 866 866 880
sum                                                    builtin function         dcl 59 ref 973 973 974 974 975 975 976 976 977 977
tag                       0(30)        based           bit(6)                   array level 2 packed unaligned dcl 507 ref 509
tape_reader_                    000024 constant        entry                    external dcl 47 ref 132 154 219 250 275 292 337 424
                                                                                  477 931
tape_reader_$rewind             000064 constant        entry                    external dcl 1025 ref 1027
temp_seg                  1(23)        based           bit(1)                   level 2 packed unaligned dcl 559 set ref 647 771 795
                                                                                  798* 876
temp_segment_count       47            based           fixed bin(17,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 647* 647
                                                                                  707* 707 974 974
temp_segment_count       12            defined         fixed bin(17,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 942*
text_segment_number             002300 automatic       fixed bin(18,0)          dcl 181 set ref 185* 329* 425 426* 478*
third                           002244 automatic       char(32)                 unaligned dcl 103 set ref 919* 920 920
this_aclp                       002376 automatic       pointer                  dcl 562 set ref 577* 592 612 636 687* 865 866 866
                                                                                  866 866 866 866 866 866 915 917 918 919 920
this_namep                      002372 automatic       pointer                  dcl 560 set ref 573* 589 609 631 683* 686 686 780
                                                                                  791 791 807 809 826 828 836 839 840 842 843 846
                                                                                  846 850 850 850 856 856 856 856
this_pathp                      002374 automatic       pointer                  dcl 561 set ref 576* 577 590 610 633 686* 687 833
                                                                                  905 907 909 910
this_slte                              based           structure                level 1 dcl 559
this_sltep                      002370 automatic       pointer                  dcl 558 set ref 572* 573 574 576 590 592 610 612 626
                                                                                  633 636 639 643 643 647 651 658 682* 683 684 699
                                                                                  703 703 714 771 771 771 782 782 782 782 782 782
                                                                                  782 782 782 782 782 782 782 795 795 795 795 798
                                                                                  798 798 798 803 805 805 814 817 817 817 817 824
                                                                                  863 876 876 880 880 883 883 886 886 889 889 889
                                                                                  889 892 892 895 895 895 895 895 895 899 899 899
                                                                                  899 903 915
to                                     based           bit(36)                  array dcl 544 set ref 546*
type                            002054 automatic       fixed bin(18,0)          level 2 packed unsigned unaligned dcl 70 set ref 129
                                                                                  208 236 269
unspec                                                 builtin function         dcl 59 set ref 183* 520*
used                                   parameter       fixed bin(17,0)          dcl 1014 in procedure "USAGE" set ref 1010 1017*
used                     23            based           structure                level 2 in structure "meters" dcl 5-35 in procedure
                                                                                  "checker_load_MST_"
user_ring_segment_count
                         51            based           fixed bin(17,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 660* 660
                                                                                  716* 716 977 977
user_ring_segment_count
                         14            defined         fixed bin(17,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 942* 948
user_ring_segment_pages
                         15            defined         fixed bin(17,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 948*
user_ring_segment_pages
                         52            based           fixed bin(17,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 662* 662
                                                                                  718* 718
userid                    1            based           char(32)                 array level 3 dcl 1-45 set ref 866* 917 918 919 920*
version_number                  002114 automatic       fixed bin(17,0)          level 2 dcl 94 set ref 349*
virgin_linkage_header                  based           structure                level 1 dcl 3-71 ref 495
wi_linkage_used          17            defined         fixed bin(17,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 957*
wi_linkage_used          54            based           fixed bin(17,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 376* 376
wired                     1(12)        based           bit(1)                   level 2 packed unaligned dcl 559 ref 643 703 782
wired_ai_linkage         14            based           bit(1)                   level 3 packed unaligned dcl 5-35 set ref 398* 981*
wired_ai_linkage_size                  based           fixed bin(17,0)          level 3 dcl 5-35 set ref 398* 729* 981*
wired_ai_linkage_used
                         23            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 397* 397 398* 981*
wired_as_linkage         14(04)        based           bit(1)                   level 3 packed unaligned dcl 5-35 set ref 411* 985*
wired_as_linkage_size
                          4            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 411* 731* 985*
wired_as_linkage_used
                         27            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 410* 410 411* 985*
wired_definitions        14(08)        based           bit(1)                   level 3 packed unaligned dcl 5-35 set ref 463 466*
                                                                                  989*
wired_definitions_size
                         10            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 459 459 737* 989*
wired_definitions_used
                         33            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 454* 454 459 989*
wired_length                    002413 automatic       fixed bin(19,0)          dcl 567 set ref 626 695 743 748 760 804* 817*
wired_nt                 14(10)        based           bit(1)                   level 3 packed unaligned dcl 5-35 set ref 599 603*
                                                                                  991*
wired_nt_size            12            based           fixed bin(17,0)          level 2 dcl 5-35 set ref 596 596 739* 991*
wired_nt_used            21            based           fixed bin(17,0)          level 2 dcl 5-35 set ref 589* 589 590* 590 592* 592
                                                                                  596 991*
wired_pages_used         10            defined         fixed bin(35,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 947*
wired_pages_used         45            based           fixed bin(35,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 643* 643
                                                                                  703* 703
wired_sdw_count          15            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 587* 587 743*
wired_slte_count         17            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 588* 588 748*
wired_to_set                           parameter       fixed bin(17,0)          dcl 757 set ref 755 760*
wired_wi_linkage         14(02)        based           bit(1)                   level 3 packed unaligned dcl 5-35 set ref 370* 983*
wired_wi_linkage_size
                          2            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 370* 733* 983*
wired_wi_linkage_used
                         25            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 369* 369 370* 983*
wired_ws_linkage         14(06)        based           bit(1)                   level 3 packed unaligned dcl 5-35 set ref 383* 987*
wired_ws_linkage_size
                          6            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 383* 735* 987*
wired_ws_linkage_used
                         31            based           fixed bin(17,0)          level 3 dcl 5-35 set ref 382* 382 383* 987*
word_length                     002412 automatic       fixed bin(19,0)          dcl 567 set ref 803* 804 892
words_used               43            based           fixed bin(35,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 626* 626
                                                                                  695* 695
words_used                6            defined         fixed bin(35,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 944*
ws_linkage_used          21            defined         fixed bin(17,0)          level 2 in structure "PC" dcl 937 in procedure
                                                                                  "COLLECTION_SUMMARY" set ref 958*
ws_linkage_used          56            based           fixed bin(17,0)          array level 3 in structure "meters" dcl 5-35
                                                                                  in procedure "checker_load_MST_" set ref 390* 390

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BOOT_PROGRAM_INFO_VERSION_1            internal static fixed bin(17,0)          initial dcl 7-10
CHECKER_ERROR                          internal static fixed bin(17,0)          initial dcl 5-120
CLASS_HEAP                             internal static fixed bin(3,0)           initial unsigned dcl 4-25
CLASS_LINKAGE                          internal static fixed bin(3,0)           initial unsigned dcl 4-25
CLASS_NAMES                            internal static char(12)                 initial array unaligned dcl 4-35
CLASS_SEGNAME                          internal static fixed bin(3,0)           initial unsigned dcl 4-25
CLASS_STATIC                           internal static fixed bin(3,0)           initial unsigned dcl 4-25
CLASS_SYMBOL                           internal static fixed bin(3,0)           initial unsigned dcl 4-25
CLASS_SYSTEM                           internal static fixed bin(3,0)           initial unsigned dcl 4-25
CLASS_TEXT                             internal static fixed bin(3,0)           initial unsigned dcl 4-25
ERROR_NAMES                            internal static char(16)                 initial array unaligned dcl 5-125
FAULT_TAG_1                            internal static bit(6)                   initial unaligned dcl 3-100
FAULT_TAG_2                            internal static bit(6)                   initial unaligned dcl 3-101
FAULT_TAG_3                            internal static bit(6)                   initial unaligned dcl 3-102
FR_TRAPS_VERSION_1                     internal static fixed bin(17,0)          initial dcl 3-99
INIT_COPY_INFO                         internal static fixed bin(17,0)          initial dcl 4-194
INIT_DEFERRED                          internal static fixed bin(17,0)          initial dcl 4-194
INIT_DEFINE_AREA                       internal static fixed bin(17,0)          initial dcl 4-194
INIT_LIST_TEMPLATE                     internal static fixed bin(17,0)          initial dcl 4-194
INIT_NO_INIT                           internal static fixed bin(17,0)          initial dcl 4-194
LINK_CREATE_IF_NOT_FOUND               internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
LINK_OBSOLETE_2                        internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
LINK_REFNAME_BASE                      internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
LINK_REFNAME_OFFSETNAME                internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
LINK_SELF_BASE                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
LINK_SELF_OFFSETNAME                   internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
LINK_TYPE_NAMES                        internal static varying char(32)         initial array dcl 4-153
SECTION_HEAP                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SECTION_LINK                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SECTION_STATIC                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SECTION_SYMBOL                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SECTION_SYSTEM                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SECTION_TEXT                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SECTION_UNUSED                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SYMBOLIC_SECTION_NAMES                 internal static char(8)                  initial array unaligned dcl 4-38
acc_string                             based           structure                level 1 dcl 4-327
acc_string_length                      automatic       fixed bin(21,0)          dcl 4-334
acc_string_ptr                         automatic       pointer                  dcl 4-326
aclp                                   automatic       pointer                  dcl 1-7
checker_data_$input_iocbp              external static pointer                  dcl 5-14
checker_data_$n_temp_ptrs              external static fixed bin(17,0)          dcl 5-31
checker_data_$output_iocbp             external static pointer                  dcl 5-15
checker_data_$severity                 external static fixed bin(17,0)          dcl 5-33
checker_data_$temp_ptrs                external static pointer                  array dcl 5-5
comp_ht_n_entries                      automatic       fixed bin(17,0)          dcl 4-297
comp_ht_ptr                            automatic       pointer                  dcl 4-288
component_ht                           based           structure                level 1 dcl 4-289
def_header_ptr                         automatic       pointer                  dcl 4-57
def_ht_n_entries                       automatic       fixed bin(17,0)          dcl 4-284
def_ht_ptr                             automatic       pointer                  dcl 4-277
def_ptr                                automatic       pointer                  dcl 4-71
definition                             based           structure                level 1 dcl 4-72
definition_header                      based           structure                level 1 dcl 4-58
definition_ht                          based           structure                level 1 dcl 4-278
dup_table_n_names                      automatic       fixed bin(17,0)          dcl 4-310
dup_table_ptr                          automatic       pointer                  dcl 4-301
duplicate_table                        based           structure                level 1 dcl 4-302
exp_ptr                                automatic       pointer                  dcl 4-128
exp_word                               based           structure                level 1 dcl 4-129
fr_traps                               based           structure                level 1 dcl 3-90
link_init_copy_info                    based           structure                level 1 dcl 4-211
link_init_deferred                     based           structure                level 1 dcl 4-270
link_init_list_template                based           structure                level 1 dcl 4-219
link_init_n_bits_in_datum              automatic       fixed bin(35,0)          dcl 4-261
link_init_n_words                      automatic       fixed bin(17,0)          dcl 4-215
link_init_n_words_in_list              automatic       fixed bin(17,0)          dcl 4-226
link_init_ptr                          automatic       pointer                  dcl 4-204
link_trap_pair                         based           structure                level 1 dcl 4-177
link_trap_ptr                          automatic       pointer                  dcl 4-176
linkage_header_flags                   based           structure                level 1 dcl 3-63
list_template_entry                    based           structure                level 1 dcl 4-239
msf_map                                based           structure                level 1 dcl 4-318
msf_map_ptr                            automatic       pointer                  dcl 4-317
msf_map_version_1                      internal static char(8)                  initial unaligned dcl 4-323
name_seg                               based           structure                level 1 dcl 1-26
partial_link                           based           structure                level 1 dcl 3-38
pathp                                  automatic       pointer                  dcl 1-7
pointer_init_template                  based           structure                level 1 packed unaligned dcl 4-253
segname_definition                     based           structure                level 1 dcl 4-90
segname_ptr                            automatic       pointer                  dcl 4-89
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 56
type_pair                              based           structure                level 1 dcl 4-160
type_ptr                               automatic       pointer                  dcl 4-159

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK                           003726 constant        entry                    internal dcl 429 ref 370 374 383 388 398 402 411 415
CHECK_BOOTABLE_LABEL            011323 constant        entry                    internal dcl 1021 ref 114
COLLECTION_SUMMARY              007473 constant        entry                    internal dcl 935 ref 146 168
COUNTED                         004272 constant        label                    dcl 515 ref 512
ENTER_COMBINED_LINKAGE          003235 constant        entry                    internal dcl 359 ref 305
ENTER_DEFINITIONS               004017 constant        entry                    internal dcl 451 ref 316
ENTER_TEXT                      003144 constant        entry                    internal dcl 334 ref 328
ENTER_UNCOMBINED_LINKAGE        003665 constant        entry                    internal dcl 421 ref 307
EXIT_NAMES                      006255 constant        label                    dcl 854 ref 845 849
INTERESTING_SEGMENT             005154 constant        entry                    internal dcl 723 ref 676
LOAD_LOOP                       001707 constant        label                    dcl 189 ref 276 293 332
LOAD_ONE_COLLECTION             001676 constant        entry                    internal dcl 175 ref 167
NO_MORE_COLLECTIONS             001674 constant        label                    dcl 171 ref 158
PROCESS_DEFS                    004350 constant        entry                    internal dcl 532 ref 354 478
PROCESS_LINKAGE                 004212 constant        entry                    internal dcl 481 ref 353 426
PROCESS_SLTE                    004411 constant        entry                    internal dcl 552 ref 136 140 284
PROCESS_SPECIAL_SLTE            005037 constant        entry                    internal dcl 679 ref 274
REPORT_SEGMENT                  005421 constant        entry                    internal dcl 777 ref 580 690
RESIDUE                         000000 constant        label                    array(3) dcl 843 ref 842
Read_Control_Word               007454 constant        entry                    internal dcl 928 ref 128 153 189 267
SEG_PAGED                       005363 constant        entry                    internal dcl 766 ref 817 817
SIZES                           005353 constant        entry                    internal dcl 755 ref 729 731 733 735 737 739
TOTAL_SUMMARY                   010122 constant        entry                    internal dcl 966 ref 171
USAGE                           011251 constant        entry                    internal dcl 1010 ref 981 983 985 987 989 991 996
                                                                                  998 1000 1002 1004 1006
checker_load_MST_               001360 constant        entry                    external dcl 26

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11750       12036   11447       11760
Length     12542   11447        66         470     300           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
checker_load_MST_                  2070 external procedure  is an external procedure.  
on unit on line 158                  64 on unit               
LOAD_ONE_COLLECTION                     internal procedure  shares stack frame of external procedure checker_load_MST_.  
ENTER_TEXT                              internal procedure  shares stack frame of external procedure checker_load_MST_.  
ENTER_COMBINED_LINKAGE                  internal procedure  shares stack frame of external procedure checker_load_MST_.  
CHECK                                   internal procedure  shares stack frame of external procedure checker_load_MST_.  
ENTER_DEFINITIONS                       internal procedure  shares stack frame of external procedure checker_load_MST_.  
PROCESS_LINKAGE                         internal procedure  shares stack frame of external procedure checker_load_MST_.  
begin block on line 506                 begin block         shares stack frame of external procedure checker_load_MST_.  
begin block on line 522                 begin block         shares stack frame of external procedure checker_load_MST_.  
PROCESS_DEFS                            internal procedure  shares stack frame of external procedure checker_load_MST_.  
begin block on line 543                 begin block         shares stack frame of external procedure checker_load_MST_.  
PROCESS_SLTE                            internal procedure  shares stack frame of external procedure checker_load_MST_.  
INTERESTING_SEGMENT                     internal procedure  shares stack frame of external procedure checker_load_MST_.  
SIZES                                   internal procedure  shares stack frame of external procedure checker_load_MST_.  
SEG_PAGED                               internal procedure  shares stack frame of external procedure checker_load_MST_.  
REPORT_SEGMENT                          internal procedure  shares stack frame of external procedure checker_load_MST_.  
begin block on line 836                 begin block         shares stack frame of external procedure checker_load_MST_.  
Read_Control_Word                       internal procedure  shares stack frame of external procedure checker_load_MST_.  
COLLECTION_SUMMARY                      internal procedure  shares stack frame of external procedure checker_load_MST_.  
TOTAL_SUMMARY                           internal procedure  shares stack frame of external procedure checker_load_MST_.  
USAGE                                   internal procedure  shares stack frame of external procedure checker_load_MST_.  
CHECK_BOOTABLE_LABEL                    internal procedure  shares stack frame of external procedure checker_load_MST_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
checker_load_MST_        000100 collection_started          checker_load_MST_
                         000102 header_ptr                  checker_load_MST_
                         000104 header_area                 checker_load_MST_
                         002054 control_word                checker_load_MST_
                         002055 collection_mark             checker_load_MST_
                         002056 sltp                        checker_load_MST_
                         002060 names_ptr                   checker_load_MST_
                         002062 namep                       checker_load_MST_
                         002064 sltep                       checker_load_MST_
                         002066 segment_links_ptr           checker_load_MST_
                         002070 a_n_links                   checker_load_MST_
                         002072 segment_defs_ptr            checker_load_MST_
                         002074 a_defs_length               checker_load_MST_
                         002076 boot_program_info           checker_load_MST_
                         002114 oi                          checker_load_MST_
                         002202 cur_slte                    checker_load_MST_
                         002206 Collection                  checker_load_MST_
                         002207 code                        checker_load_MST_
                         002210 hc_seg_ptr                  checker_load_MST_
                         002212 segment_name                checker_load_MST_
                         002222 segment_number              checker_load_MST_
                         002223 nx                          checker_load_MST_
                         002224 first                       checker_load_MST_
                         002234 second                      checker_load_MST_
                         002244 third                       checker_load_MST_
                         002272 expect_link                 LOAD_ONE_COLLECTION
                         002273 expect_defs                 LOAD_ONE_COLLECTION
                         002274 prev_slte                   LOAD_ONE_COLLECTION
                         002300 text_segment_number         LOAD_ONE_COLLECTION
                         002340 links_ptr                   PROCESS_LINKAGE
                         002342 links_count                 PROCESS_LINKAGE
                         002343 lx                          PROCESS_LINKAGE
                         002344 section_length              PROCESS_LINKAGE
                         002356 dptr                        PROCESS_DEFS
                         002366 segment_number              PROCESS_SLTE
                         002370 this_sltep                  PROCESS_SLTE
                         002372 this_namep                  PROCESS_SLTE
                         002374 this_pathp                  PROCESS_SLTE
                         002376 this_aclp                   PROCESS_SLTE
                         002400 a_name                      PROCESS_SLTE
                         002410 next_name                   PROCESS_SLTE
                         002411 aclx                        PROCESS_SLTE
                         002412 word_length                 PROCESS_SLTE
                         002413 wired_length                PROCESS_SLTE
                         002414 paged_length                PROCESS_SLTE
                         002450 namex                       begin block on line 836
                         002536 BPI                         CHECK_BOOTABLE_LABEL

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             r_le_a              call_ext_out_desc   call_ext_out
return_mac          tra_ext_1           enable_op           ext_entry           int_entry           op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            checker_print_                checker_print_$error          checker_print_$page
checker_print_$skip           com_err_                      ioa_                          object_info_$brief
sslt_manager_$build_entry     sslt_manager_$get_seg_num     tape_reader_                  tape_reader_$rewind

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
checker_data_$area_ptr        checker_data_$buffer_ptr      checker_data_$collection_names
checker_data_$last_supervisor_collection                    checker_data_$last_text_wired_collection
checker_data_$last_wired_collection                         checker_data_$loaded          checker_data_$meter_ptr
checker_data_$name_table_ptr  checker_data_$slt_ptr         error_table_$namedup




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     26 001357       107 001365       108 001370       110 001373       111 001377       114 001402       121 001403
    122 001417       124 001424       128 001425       129 001426       132 001467       134 001505       135 001515
    136 001522       137 001524       138 001526       139 001537       140 001544       141 001546       143 001550
    144 001555       146 001574       153 001575       154 001576       158 001612       160 001631       161 001632
    162 001633       164 001636       165 001670       167 001671       168 001672       169 001673       171 001674
    173 001675       175 001676       183 001677       184 001702       185 001704       186 001706       189 001707
    195 001710       197 001712       198 001721       199 001725       203 001764       206 001766       208 001773
    210 002000       212 002005       215 002047       219 002111       220 002127       228 002223       229 002234
    230 002237       231 002263       233 002310       236 002311       242 002355       250 002430       252 002446
    255 002452       257 002456       259 002473       260 002510       263 002563       267 002565       269 002566
    272 002623       274 002630       275 002634       276 002650       279 002651       281 002662       283 002677
    284 002703       290 002705       292 002710       293 002724       296 002725       298 002730       302 002775
    303 002776       305 003000       307 003005       308 003006       310 003007       312 003012       316 003056
    317 003057       318 003060       321 003061       326 003130       328 003134       329 003135       331 003137
    332 003143       334 003144       337 003145       340 003161       346 003166       349 003177       350 003201
    351 003222       353 003224       354 003230       357 003234       359 003235       364 003236       367 003244
    369 003250       370 003255       373 003302       374 003310       376 003335       378 003347       380 003350
    382 003354       383 003361       387 003406       388 003414       390 003441       392 003453       393 003454
    395 003457       397 003463       398 003470       401 003513       402 003521       404 003546       406 003560
    408 003561       410 003565       411 003572       414 003617       415 003625       417 003652       421 003664
    424 003666       425 003702       426 003710       427 003725       429 003726       437 003730       439 003733
    442 003736       446 004013       447 004016       451 004017       454 004020       456 004031       457 004036
    459 004044       463 004054       466 004107       468 004114       469 004115       471 004120       474 004153
    477 004160       478 004173       479 004211       481 004212       493 004214       495 004224       498 004227
    500 004231       505 004233       508 004237       509 004247       511 004264       512 004267       514 004270
    518 004272       519 004274       520 004306       524 004314       525 004323       526 004331       527 004335
    529 004337       530 004347       532 004350       539 004352       540 004354       542 004366       546 004370
    548 004401       549 004410       552 004411       571 004413       572 004415       573 004421       574 004430
    576 004433       577 004441       580 004447       584 004450       585 004456       587 004461       588 004462
    589 004463       590 004467       592 004501       596 004512       599 004516       603 004551       605 004556
    607 004557       608 004560       609 004561       610 004565       612 004577       615 004610       618 004614
    622 004647       626 004654       631 004671       633 004700       636 004713       639 004742       643 004755
    647 004767       651 004775       655 005003       658 005005       660 005011       662 005012       666 005014
    670 005023       671 005030       674 005031       676 005035       677 005036       679 005037       682 005041
    683 005045       684 005050       686 005053       687 005061       690 005067       694 005070       695 005076
    699 005107       703 005122       707 005134       711 005142       714 005144       716 005150       718 005151
    721 005153       723 005154       729 005155       731 005175       733 005215       735 005235       737 005255
    739 005275       741 005315       743 005321       744 005327       745 005331       746 005332       748 005336
    750 005345       753 005352       755 005353       760 005355       761 005357       762 005362       766 005363
    771 005365       777 005421       780 005422       782 005426       791 005561       793 005571       795 005574
    798 005603       800 005650       803 005652       804 005657       805 005663       807 005675       809 005700
    810 005707       811 005710       812 005711       814 005714       817 005740       824 006036       826 006042
    828 006045       829 006054       830 006055       831 006056       833 006061       836 006114       839 006117
    840 006127       842 006132       843 006135       845 006161       846 006162       849 006215       850 006216
    854 006255       856 006256       860 006322       863 006325       865 006331       866 006341       870 006423
    876 006425       880 006465       883 006522       886 006562       889 006620       892 006667       895 006731
    899 007006       903 007057       905 007063       907 007116       909 007160       910 007205       915 007252
    917 007265       918 007306       919 007341       920 007363       923 007451       924 007453       928 007454
    931 007455       933 007472       935 007473       939 007474       940 007501       941 007530       942 007535
    944 007575       946 007623       947 007647       948 007673       950 007723       952 007730       955 007737
    956 007752       957 007766       958 010015       959 010044       961 010051       962 010075       964 010121
    966 010122       969 010123       970 010130       971 010145       973 010152       974 010217       975 010262
    976 010327       977 010372       979 010437       980 010453       981 010467       983 010522       985 010557
    987 010613       989 010647       991 010704       993 010740       994 010745       995 010761       996 010775
    998 011032      1000 011067      1002 011123      1004 011157      1006 011214      1008 011250      1010 011251
   1017 011262      1018 011322      1021 011323      1027 011324      1028 011335      1030 011341      1031 011355
   1034 011356      1036 011402      1038 011407


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
