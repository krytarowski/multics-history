	COMPILATION LISTING OF SEGMENT load_doc_db_ent
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/11/85  1138.7 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* format: style2 */
        7 load_doc_db_ent:
        8      proc;
        9 
       10 /*
       11*DESCRIPTION:
       12*
       13*   This command takes the AN50 master index listin file and stores it into the
       14*   online_doc database.  It strips entry names and topics from AN50 master 
       15*   index and stores them as entry_name attributes in the entry_name_rel
       16*   relation in online_doc.db.
       17**/
       18 
       19 /* 
       20*HISTORY:
       21*Originally written by Jim Paradise, autumn 1980.
       22*Modified:
       23*81-02-21 by M. Pierret: added cu_ calls, reformatted.
       24*81-06-05 by M. Pierret: parse =name field to extract entry names,
       25*            exclude parenthetical comments.
       26*83-03-29 by M. Pierret: Changed to use structure database.
       27*83-04-12 by M. Pierret: Added the -entry_name/-topic control args. They are 
       28*            used to specify whether entry names or topics are to be extracted
       29*            from the input file. There are no short forms. This change was
       30*            necessitated by a change in the format of the master index listin.
       31*83-09-28 by M. Pierret: Made strip_blanks and index_end inline subroutines
       32*            instead of including char_utils.incl.pl1.
       33*85-02-08 by Steve Herbst: Fixed uninitialized -topic/-entry_name default and
       34*	  added cleanup handler, improved error messages.
       35**/
       36 
       37 /* DESCRIPTION of PARAMETERS:
       38*
       39*mrds_db_path - is the pathname to the online_doc.db database
       40*input_file   - is the pathname of the AN50 master index lister file.
       41*	     This program assumes the file is in the following format:
       42*
       43*{ ... }
       44*{ ... }	first 3 lines are ignored
       45*{ ... }
       46*~ =manual _____ =nb AANN =rev _____ =name entry_value
       47*~ =manual _____ =nb AANN =rev _____ =name entry_value
       48*	.
       49*	.
       50*	.
       51*
       52*-or-
       53*~ =manual _____ =nb AANN =rev _____ =topic topic_value
       54*~ =manual _____ =nb AANN =rev _____ =topic topic_value
       55*  .
       56*  .
       57*  .
       58*
       59*   The =rev field may or may not be present. entry_value may be of
       60*   the forms:
       61*          entry_name
       62*          entry_name (comment -not to be stored)
       63*	entry_name {short_name}
       64*	entry_name {short_name} (comment - not to be stored)
       65*   topic_value may be one of:
       66*          topic
       67*	topic of multiple words
       68*	topic of multiple words (comment - to be stored)
       69*
       70*   Everything that is stored is first converted to lower-case
       71*   to provide a canonical version for searching.
       72**/
       73 
       74 /*
       75*ERRORS:
       76*
       77*   Any of the errors possible from trying to read a listing segment via vfile_
       78*   unstructured read.
       79*   Any of the errors possible from trying to store data into a MRDS database.
       80*
       81*------------------------------------------------------------
       82*
       83*NOTES:
       84*
       85*   This command should use cu_$ entries.
       86*   This command should use the xxx{.listin} convention.
       87*
       88*------------------------------------------------------------ */
       89 
       90 /* Constants */
       91 
       92 dcl ME char (32) int static options (constant) init ("load_doc_db_ent");
       93 dcl (NORMAL_EXIT init (1), ON_CLEANUP init (2)) fixed bin int static options (constant);
       94 dcl LOWER_CASE_ALPHA char (26) int static options (constant) init ("abcdefghijklmnopqrstuvwxyz");
       95 dcl UPPER_CASE_ALPHA char (26) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
       96 dcl NL char (1) int static options (constant) init ("
       97 ");
       98 
       99 /* Based */
      100 
      101 dcl arg char (arg_len) based (arg_ptr);
      102 
      103 /* Automatic */
      104 
      105 	dcl     order_number	 char (32) varying;
      106 	dcl     last_error_order_number
      107 				 char (32) varying;
      108 	dcl     manual_number	 fixed bin;
      109 	dcl     name_field		 char (64) varying;
      110 	dcl     entry_name		 char (64) varying;
      111 	dcl     topic_or_entry_name_field_indicator
      112 				 char (8) varying;
      113 
      114 	dcl     line		 char (1024) var;
      115 	dcl     begin_char		 char (1) var;
      116 	dcl     end_char		 char (1);
      117 	dcl     next_char		 char (1);
      118 	dcl     tuple_name		 char (30);
      119 	dcl     mrds_db_path	 char (168);
      120 	dcl     input_file		 char (168);
      121 	dcl     arg_len		 fixed bin (21);
      122 	dcl     return_arg_len	 fixed bin (21);
      123 	dcl     dbi		 fixed bin (35);
      124 	dcl     nargs		 fixed bin;
      125 	dcl     pos_after_nb	 fixed;
      126 	dcl     pos_after_name	 fixed;
      127 	dcl     end_of_nb_field	 fixed;
      128 	dcl     dummy_idx		 fixed bin;
      129 	dcl     num_lines_read	 fixed;
      130 	dcl     code		 fixed (35);
      131 
      132 	dcl     arg_ptr		 ptr;
      133 	dcl     iocb_ptr		 ptr;
      134 	dcl     return_arg_ptr	 ptr;
      135 
      136 	dcl     exitting_sw		 bit (1) init ("0"b);
      137 	dcl     more_names_are_present bit (1);
      138 	dcl     open		 bit (1) init ("0"b);
      139 	dcl     is_active_function	 bit (1) aligned;
      140 
      141 /* External */
      142 
      143 dcl error_table_$badopt fixed bin (35) ext;
      144 dcl error_table_$not_act_fnc fixed bin (35) ext;
      145 dcl iox_$error_output ptr ext;
      146 dcl mdbm_error_$dup_store fixed bin (35) ext;
      147 
      148 /* Entries */
      149 
      150 	dcl     absolute_pathname_	 entry (char (*), char (*), fixed bin (35));
      151 	dcl     absolute_pathname_$add_suffix
      152 				 entry (char (*), char (*), char (*), fixed bin (35));
      153 	dcl     com_err_		 entry options (variable);
      154 	dcl     com_err_$suppress_name entry options (variable);
      155 	dcl     cu_$af_return_arg	 entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      156 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      157 	dcl     ioa_		 entry options (variable);
      158 	dcl     ioa_$ioa_switch	 entry options (variable);
      159 	dcl     iox_$attach_ioname	 entry (char (*), ptr, char (*), ptr, fixed (35));
      160 	dcl     iox_$open		 entry (ptr, fixed, bit (1) aligned, fixed (35));
      161 	dcl     iox_$get_line	 entry (ptr, ptr, fixed (21), fixed (21), fixed (35));
      162 	dcl     iox_$close		 entry (ptr, fixed (35));
      163 	dcl     iox_$detach_iocb	 entry (ptr, fixed (35));
      164 	dcl     dsl_$open		 entry options (variable);
      165 	dcl     dsl_$store		 entry options (variable);
      166 	dcl     dsl_$close		 entry options (variable);
      167 	dcl     dsl_$retrieve	 entry options (variable);
      168 
      169 /* Builtins */
      170 
      171 dcl (addr, after, before, index, length, ltrim, null, rtrim, substr, translate, verify) builtin;
      172 
      173 /* Conditions */
      174 
      175 dcl cleanup condition;
      176 
      177 /* Get the two arguments to this command: mrds_db_path and input_file.
      178*   Return if the arguments are not found or if they refer to objects that
      179*   do not exist. */
      180 
      181 	call cu_$af_return_arg (nargs, return_arg_ptr, return_arg_len, code);
      182 	if code = 0
      183 	then is_active_function = "1"b;
      184 	else if code = error_table_$not_act_fnc
      185 	then is_active_function = "0"b;
      186 	else do;
      187 		call com_err_ (code, ME);
      188 		return;
      189 	     end;
      190 
      191 	if (nargs ^= 2 & nargs ^= 3) | is_active_function
      192 	then do;
      193 		call com_err_$suppress_name
      194 		     (0, ME, "Usage: ^a database_path input_file {-topic | -entry_name}", ME);
      195 		return;
      196 	     end;
      197 
      198 	call cu_$arg_ptr (1, arg_ptr, arg_len, code);
      199 	call absolute_pathname_$add_suffix (arg, "db", mrds_db_path, code);
      200 	if code ^= 0
      201 	then do;
      202 		call com_err_ (code, ME, "^a", arg);
      203 		return;
      204 	     end;
      205 
      206 	call cu_$arg_ptr (2, arg_ptr, arg_len, code);
      207 	call absolute_pathname_$add_suffix (arg, "listin", input_file, code);
      208 	if code ^= 0
      209 	then do;
      210 		call com_err_ (code, ME, "^a", arg);
      211 		return;
      212 	     end;
      213 
      214 	if nargs = 3
      215 	then do;
      216 		call cu_$arg_ptr (3, arg_ptr, arg_len, code);
      217 		if arg = "-topic"
      218 		then topic_or_entry_name_field_indicator = " =topic";
      219 		else if arg = "-entry_name"
      220 		then topic_or_entry_name_field_indicator = " =name";
      221 		else do;
      222 			call com_err_ (error_table_$badopt, ME,
      223 			     "Usage: ^a <database path> <input file> {-topic|-entry_name}", ME);
      224 			return;
      225 		     end;
      226 	     end;
      227 	else topic_or_entry_name_field_indicator = " =name";
      228 
      229 	manual_number = 0;
      230 	last_error_order_number = "";
      231 
      232 /* Establish cleanup handler */
      233 
      234 	dbi = -1;
      235 	iocb_ptr = null;
      236 
      237 	on cleanup call clean_up (ON_CLEANUP);
      238 
      239 /* Open the MRDS database */
      240 
      241 	call dsl_$open (mrds_db_path, dbi, 4, code);
      242 	call check_code ("Calling dsl_$open on " || mrds_db_path);
      243 
      244 /* Skip the first three lines */
      245 
      246 	do dummy_idx = 1 to 3;
      247 	     call read_line;
      248 	end;
      249 
      250 /* Loop through the records, storing */
      251 
      252 	do while ("1"b);
      253 
      254 	     call read_line_to_eof;
      255 
      256 	     pos_after_nb = index_end (line, "=nb ");
      257 	     if pos_after_nb <= 0
      258 	     then call syntax_error ("Missing ""=nb""");
      259 	     end_of_nb_field = index (line, " =rev");
      260 	     if end_of_nb_field <= 0
      261 	     then do;
      262 		     end_of_nb_field = index (line, topic_or_entry_name_field_indicator);
      263 		     if end_of_nb_field <= 0
      264 		     then call syntax_error ("Missing ""=name"" or ""=topic""");
      265 		end;
      266 	     order_number = rtrim (substr (line, pos_after_nb, end_of_nb_field - pos_after_nb));
      267 	     call strip_blanks (order_number);
      268 	     if length (order_number) ^= 4
      269 	     then call syntax_error ("Order number must be 4 characters long.");
      270 	     call dsl_$retrieve (dbi, "-range (x full_name_rel) -select x.manual_number -where x.order_number = .V.",
      271 		order_number, manual_number, code);
      272 	     if code ^= 0
      273 	     then do;
      274 		     if order_number ^= last_error_order_number then
      275 			call com_err_ (code, ME, "^/Order number ^a not found in MRDS database.", order_number);
      276 		     last_error_order_number = order_number;
      277 		     go to END_LOOP;
      278 		end;
      279 	     pos_after_name = index_end (line, topic_or_entry_name_field_indicator || " ");
      280 	     if pos_after_name <= 0
      281 	     then call syntax_error ("Wrong delimiter after ""=name"" or ""=topic""");
      282 	     name_field = substr (line, pos_after_name);
      283 	     call strip_blanks (name_field);
      284 	     if name_field = " "
      285 	     then call syntax_error ("Blank ""=name"" or ""=topic"" value.");
      286 
      287 /* Canonicalize name to lower-case and single blanks */
      288 
      289 	     do while (index (name_field, "  ") ^= 0);	/* search for two consecutive blanks*/
      290 		name_field = before (name_field, "  ") || " " || after (name_field, "  ");
      291 	     end;
      292 	     name_field = translate (name_field, LOWER_CASE_ALPHA, UPPER_CASE_ALPHA);
      293 
      294 /* name_field's which have "{"s in them contain multiple names, and each
      295*   must be extracted. Those that have no " "s are single names and should
      296*   be stored as is. Those that have a "(" following the first " " are
      297*   single entry or subsystem names with parenthetical comments; the single 
      298*   name should be stored.  In all of these cases the parenthetical comments
      299*   should be discarded.
      300*      If none of these conditions is present, one can assume that the 
      301*   name_field contains a section title, and parenthetical comments
      302*   should be retained. 
      303*      Ex:
      304*         print (LINUS request)  => print
      305*         print {pr} (read_mail) => print
      306*			  => pr
      307*         print		  => print
      308*         Interrupted I/O (BOS)  => Interrupted I/O (BOS)
      309**/
      310 
      311 	     if index (name_field, " ") = 0
      312 	     then end_char = NL;			/* case: single entry name */
      313 	     else do;
      314 		     next_char = substr (after (name_field, " "), 1, 1);
      315 		     if next_char = "{" | /* case: entry name followed by short name(s) */ next_char = "("
      316 						/* case: entry name followed by  parenthetical comment */
      317 		     then end_char = " ";
      318 		     else end_char = NL;		/* case: multiple word topic */
      319 		end;
      320 
      321 	     begin_char = "";
      322 	     tuple_name = "entry_name_rel";
      323 	     more_names_are_present = "1"b;
      324 
      325 	     do while (more_names_are_present);
      326 
      327 		entry_name = before (name_field, end_char);
      328 		entry_name = after (entry_name, begin_char);
      329 		call strip_blanks (entry_name);
      330 		name_field = after (name_field, end_char);
      331 		call strip_blanks (name_field);
      332 		begin_char = "{";
      333 		end_char = "}";
      334 		if index (name_field, begin_char) = 0
      335 		then more_names_are_present = "0"b;
      336 
      337 		call dsl_$store (dbi, tuple_name, entry_name, manual_number, code);
      338 		if code ^= 0
      339 		then if code ^= mdbm_error_$dup_store
      340 		     then call com_err_ (code, ME, "^/(^d) ^a", num_lines_read, line);
      341 	     end;
      342 
      343 END_LOOP:
      344 	end;
      345 RETURN:
      346 	call clean_up (NORMAL_EXIT);
      347 
      348 	return;
      349 
      350 clean_up: proc (P_when);
      351 
      352 dcl P_when fixed bin;
      353 
      354 	exitting_sw = "1"b;
      355 	if dbi ^= -1 then do;
      356 	     call dsl_$close (dbi, code);
      357 	     if P_when = NORMAL_EXIT then call check_code ("dsl_$close");
      358 	end;
      359 	call iox_$close (iocb_ptr, code);
      360 	if P_when = NORMAL_EXIT then call check_code ("iox_$close");
      361 	call iox_$detach_iocb (iocb_ptr, code);
      362 	if P_when = NORMAL_EXIT then call check_code ("iox_$detach_iocb");
      363 
      364 end clean_up;
      365 
      366 syntax_error: proc (P_str);
      367 
      368 dcl P_str char (*);
      369 
      370 	call ioa_$ioa_switch (iox_$error_output,
      371 	     "*** Syntax error on line ^d:  ^a^/Text of line:  ^a", num_lines_read, P_str, line);
      372 	goto END_LOOP;
      373 
      374 end syntax_error;
      375 
      376 /* SUPPORT SUBROUTINES */
      377 
      378 
      379 strip_blanks:
      380      proc (string);
      381 
      382 	dcl     string		 char (*) var;
      383 	dcl     temp_string		 char (1024) varying;
      384 	dcl     first_char_pos	 fixed bin;
      385 
      386 	first_char_pos = verify (string, " 	");	/* space, tab */
      387 	if first_char_pos > 0
      388 	then temp_string = substr (string, first_char_pos);
      389 	else temp_string = string;
      390 
      391 	if temp_string = ""
      392 	then string = " ";
      393 	else string = rtrim (temp_string);
      394 
      395 	return;
      396      end;
      397 
      398 
      399 index_end:
      400      proc (string, search) returns (fixed);
      401 
      402 	dcl     string		 char (*) varying;
      403 	dcl     search		 char (*) varying;
      404 	dcl     last_char_pos	 fixed bin;
      405 	dcl     first_char_pos	 fixed bin;
      406 
      407 	first_char_pos = index (string, search);
      408 	if first_char_pos ^= 0
      409 	then last_char_pos = first_char_pos + length (search);
      410 	else last_char_pos = first_char_pos;
      411 
      412 	return (last_char_pos);
      413      end index_end;
      414 
      415 
      416 
      417 check_code:
      418      proc (str);
      419 	dcl     str		 char (*);
      420 	if code = 0
      421 	then return;
      422 	call com_err_ (code, ME, str);
      423 	return;
      424      end check_code;
      425 
      426 /* get line from input file */
      427 
      428 
      429 read_line:
      430      proc;
      431 	dcl     buff_ptr		 ptr;
      432 	dcl     num_chars		 fixed (21);
      433 	dcl     buffer		 char (10000);
      434 	dcl     expect_eof		 bit (1);
      435 	expect_eof = "0"b;
      436 start:
      437 	buff_ptr = addr (buffer);
      438 	if ^open
      439 	then do;
      440 		call iox_$attach_ioname ("f", iocb_ptr, "vfile_ " || input_file, null, code);
      441 		call check_code ("iox_$attach_ioname");
      442 		call iox_$open (iocb_ptr, 1, "0"b, code);
      443 		call check_code ("iox_$open");
      444 		num_lines_read = 0;
      445 		open = "1"b;
      446 	     end;
      447 	call iox_$get_line (iocb_ptr, buff_ptr, length (buffer), num_chars, code);
      448 	if code ^= 0
      449 	then goto error1;
      450 	if num_chars > 10000
      451 	then goto error1;
      452 	num_lines_read = num_lines_read + 1;
      453 	line = substr (buffer, 1, num_chars);
      454 	if substr (line, length (line)) = NL
      455 	then line = substr (line, 1, length (line) - 1);
      456 
      457 	return;
      458 error1:
      459 	if ^expect_eof
      460 	then call com_err_ (code, ME, " ^d ^d ^a", num_lines_read, num_chars, substr (buffer, 1, num_chars));
      461 	go to RETURN;
      462 
      463 read_line_to_eof:
      464      entry;
      465 	expect_eof = "1"b;
      466 	goto start;
      467 
      468 end read_line;
      469 
      470 
      471 end load_doc_db_ent;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/11/85  1137.6  load_doc_db_ent.pl1               >spec>on>6373>load_doc_db_ent.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
LOWER_CASE_ALPHA                000007 constant        char(26)                 initial unaligned dcl 94 ref 292
ME                              000016 constant        char(32)                 initial unaligned dcl 92 set ref 187* 193* 193* 202*
                                                                                  210* 222* 222* 274* 338* 422* 458*
NL                              003436 constant        char(1)                  initial unaligned dcl 96 ref 311 318 454
NORMAL_EXIT                     000074 constant        fixed bin(17,0)          initial dcl 93 set ref 345* 357 360 362
ON_CLEANUP                      000070 constant        fixed bin(17,0)          initial dcl 93 set ref 237*
P_str                                  parameter       char                     unaligned dcl 368 set ref 366 370*
P_when                                 parameter       fixed bin(17,0)          dcl 352 ref 350 357 360 362
UPPER_CASE_ALPHA                000000 constant        char(26)                 initial unaligned dcl 95 ref 292
absolute_pathname_$add_suffix   000020 constant        entry                    external dcl 151 ref 199 207
addr                                                   builtin function         dcl 171 ref 436
after                                                  builtin function         dcl 171 ref 290 314 328 330
arg                                    based           char                     unaligned dcl 101 set ref 199* 202* 207* 210* 217
                                                                                  219
arg_len                         000732 automatic       fixed bin(21,0)          dcl 121 set ref 198* 199 199 202 202 206* 207 207
                                                                                  210 210 216* 217 219
arg_ptr                         000744 automatic       pointer                  dcl 132 set ref 198* 199 202 206* 207 210 216* 217
                                                                                  219
before                                                 builtin function         dcl 171 ref 290 327
begin_char                      000572 automatic       varying char(1)          dcl 115 set ref 321* 328 332* 334
buff_ptr                        001410 automatic       pointer                  dcl 431 set ref 436* 447*
buffer                          001413 automatic       char(10000)              unaligned dcl 433 set ref 436 447 447 453 458 458
cleanup                         000756 stack reference condition                dcl 175 ref 237
code                            000743 automatic       fixed bin(35,0)          dcl 130 set ref 181* 182 184 187* 198* 199* 200 202*
                                                                                  206* 207* 208 210* 216* 241* 270* 272 274* 337*
                                                                                  338 338 338* 356* 359* 361* 420 422* 440* 442*
                                                                                  447* 448 458*
com_err_                        000022 constant        entry                    external dcl 153 ref 187 202 210 222 274 338 422 458
com_err_$suppress_name          000024 constant        entry                    external dcl 154 ref 193
cu_$af_return_arg               000026 constant        entry                    external dcl 155 ref 181
cu_$arg_ptr                     000030 constant        entry                    external dcl 156 ref 198 206 216
dbi                             000734 automatic       fixed bin(35,0)          dcl 123 set ref 234* 241* 270* 337* 355 356*
dsl_$close                      000052 constant        entry                    external dcl 166 ref 356
dsl_$open                       000046 constant        entry                    external dcl 164 ref 241
dsl_$retrieve                   000054 constant        entry                    external dcl 167 ref 270
dsl_$store                      000050 constant        entry                    external dcl 165 ref 337
dummy_idx                       000741 automatic       fixed bin(17,0)          dcl 128 set ref 246*
end_char                        000574 automatic       char(1)                  unaligned dcl 116 set ref 311* 315* 318* 327 330
                                                                                  333*
end_of_nb_field                 000740 automatic       fixed bin(17,0)          dcl 127 set ref 259* 260 262* 263 266
entry_name                      000144 automatic       varying char(64)         dcl 110 set ref 327* 328* 328 329* 337*
error_table_$badopt             000010 external static fixed bin(35,0)          dcl 143 set ref 222*
error_table_$not_act_fnc        000012 external static fixed bin(35,0)          dcl 144 ref 184
exitting_sw                     000752 automatic       bit(1)                   initial unaligned dcl 136 set ref 136* 354*
expect_eof                      006317 automatic       bit(1)                   unaligned dcl 434 set ref 435* 458 465*
first_char_pos                  000101 automatic       fixed bin(17,0)          dcl 405 in procedure "index_end" set ref 407* 408
                                                                                  408 410
first_char_pos                  001401 automatic       fixed bin(17,0)          dcl 384 in procedure "strip_blanks" set ref 386* 387
                                                                                  387
index                                                  builtin function         dcl 171 ref 259 262 289 311 334 407
input_file                      000660 automatic       char(168)                unaligned dcl 120 set ref 207* 440
ioa_$ioa_switch                 000032 constant        entry                    external dcl 158 ref 370
iocb_ptr                        000746 automatic       pointer                  dcl 133 set ref 235* 359* 361* 440* 442* 447*
iox_$attach_ioname              000034 constant        entry                    external dcl 159 ref 440
iox_$close                      000042 constant        entry                    external dcl 162 ref 359
iox_$detach_iocb                000044 constant        entry                    external dcl 163 ref 361
iox_$error_output               000014 external static pointer                  dcl 145 set ref 370*
iox_$get_line                   000040 constant        entry                    external dcl 161 ref 447
iox_$open                       000036 constant        entry                    external dcl 160 ref 442
is_active_function              000755 automatic       bit(1)                   dcl 139 set ref 182* 184* 191
last_char_pos                   000100 automatic       fixed bin(17,0)          dcl 404 set ref 408* 410* 412
last_error_order_number         000111 automatic       varying char(32)         dcl 106 set ref 230* 274 276*
length                                                 builtin function         dcl 171 ref 268 408 447 447 454 454
line                            000170 automatic       varying char(1024)       dcl 114 set ref 256* 259 262 266 279* 282 338* 370*
                                                                                  453* 454 454 454* 454 454
manual_number                   000122 automatic       fixed bin(17,0)          dcl 108 set ref 229* 270* 337*
mdbm_error_$dup_store           000016 external static fixed bin(35,0)          dcl 146 ref 338
more_names_are_present          000753 automatic       bit(1)                   unaligned dcl 137 set ref 323* 325 334*
mrds_db_path                    000606 automatic       char(168)                unaligned dcl 119 set ref 199* 241* 242
name_field                      000123 automatic       varying char(64)         dcl 109 set ref 282* 283* 284 289 290* 290 290 292*
                                                                                  292 311 314 327 330* 330 331* 334
nargs                           000735 automatic       fixed bin(17,0)          dcl 124 set ref 181* 191 191 214
next_char                       000575 automatic       char(1)                  unaligned dcl 117 set ref 314* 315 315
null                                                   builtin function         dcl 171 ref 235 440 440
num_chars                       001412 automatic       fixed bin(21,0)          dcl 432 set ref 447* 450 453 458* 458 458
num_lines_read                  000742 automatic       fixed bin(17,0)          dcl 129 set ref 338* 370* 444* 452* 452 458*
open                            000754 automatic       bit(1)                   initial unaligned dcl 138 set ref 138* 438 445*
order_number                    000100 automatic       varying char(32)         dcl 105 set ref 266* 267* 268 270* 274 274* 276
pos_after_name                  000737 automatic       fixed bin(17,0)          dcl 126 set ref 279* 280 282
pos_after_nb                    000736 automatic       fixed bin(17,0)          dcl 125 set ref 256* 257 266 266
return_arg_len                  000733 automatic       fixed bin(21,0)          dcl 122 set ref 181*
return_arg_ptr                  000750 automatic       pointer                  dcl 134 set ref 181*
rtrim                                                  builtin function         dcl 171 ref 266 393
search                                 parameter       varying char             dcl 403 ref 399 407 408
str                                    parameter       char                     unaligned dcl 419 set ref 417 422*
string                                 parameter       varying char             dcl 382 in procedure "strip_blanks" set ref 379 386
                                                                                  387 389 391* 393*
string                                 parameter       varying char             dcl 402 in procedure "index_end" ref 399 407
substr                                                 builtin function         dcl 171 ref 266 282 314 387 453 454 454 458 458
temp_string                     001000 automatic       varying char(1024)       dcl 383 set ref 387* 389* 391 393
topic_or_entry_name_field_indicator
                                000165 automatic       varying char(8)          dcl 111 set ref 217* 219* 227* 262 279
translate                                              builtin function         dcl 171 ref 292
tuple_name                      000576 automatic       char(30)                 unaligned dcl 118 set ref 322* 337*
verify                                                 builtin function         dcl 171 ref 386

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
absolute_pathname_              000000 constant        entry                    external dcl 150
ioa_                            000000 constant        entry                    external dcl 157
ltrim                                                  builtin function         dcl 171

NAMES DECLARED BY EXPLICIT CONTEXT.
END_LOOP                        002031 constant        label                    dcl 343 ref 277 372
RETURN                          002032 constant        label                    dcl 345 ref 461
check_code                      002430 constant        entry                    internal dcl 417 ref 242 357 360 362 441 443
clean_up                        002042 constant        entry                    internal dcl 350 ref 237 345
error1                          002676 constant        label                    dcl 458 ref 448 450
index_end                       002366 constant        entry                    internal dcl 399 ref 256 279
load_doc_db_ent                 000346 constant        entry                    external dcl 7
read_line                       002470 constant        entry                    internal dcl 429 ref 247
read_line_to_eof                002752 constant        entry                    internal dcl 463 ref 254
start                           002472 constant        label                    dcl 436 ref 466
strip_blanks                    002251 constant        entry                    internal dcl 379 ref 267 283 329 331
syntax_error                    002201 constant        entry                    internal dcl 366 ref 257 263 268 280 284

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3714        3772    3441        3724
Length      4206    3441        56         200     253           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
load_doc_db_ent                    3512 external procedure  is an external procedure.  
on unit on line 237                  70 on unit               
clean_up                             82 internal procedure  is called by several nonquick procedures.  
syntax_error                            internal procedure  shares stack frame of external procedure load_doc_db_ent.  
strip_blanks                            internal procedure  shares stack frame of external procedure load_doc_db_ent.  
index_end                            68 internal procedure  is called during a stack extension.  
check_code                           80 internal procedure  is called by several nonquick procedures.  
read_line                               internal procedure  shares stack frame of external procedure load_doc_db_ent.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
index_end                000100 last_char_pos               index_end
                         000101 first_char_pos              index_end
load_doc_db_ent          000100 order_number                load_doc_db_ent
                         000111 last_error_order_number     load_doc_db_ent
                         000122 manual_number               load_doc_db_ent
                         000123 name_field                  load_doc_db_ent
                         000144 entry_name                  load_doc_db_ent
                         000165 topic_or_entry_name_field_indicator
                                                            load_doc_db_ent
                         000170 line                        load_doc_db_ent
                         000572 begin_char                  load_doc_db_ent
                         000574 end_char                    load_doc_db_ent
                         000575 next_char                   load_doc_db_ent
                         000576 tuple_name                  load_doc_db_ent
                         000606 mrds_db_path                load_doc_db_ent
                         000660 input_file                  load_doc_db_ent
                         000732 arg_len                     load_doc_db_ent
                         000733 return_arg_len              load_doc_db_ent
                         000734 dbi                         load_doc_db_ent
                         000735 nargs                       load_doc_db_ent
                         000736 pos_after_nb                load_doc_db_ent
                         000737 pos_after_name              load_doc_db_ent
                         000740 end_of_nb_field             load_doc_db_ent
                         000741 dummy_idx                   load_doc_db_ent
                         000742 num_lines_read              load_doc_db_ent
                         000743 code                        load_doc_db_ent
                         000744 arg_ptr                     load_doc_db_ent
                         000746 iocb_ptr                    load_doc_db_ent
                         000750 return_arg_ptr              load_doc_db_ent
                         000752 exitting_sw                 load_doc_db_ent
                         000753 more_names_are_present      load_doc_db_ent
                         000754 open                        load_doc_db_ent
                         000755 is_active_function          load_doc_db_ent
                         001000 temp_string                 strip_blanks
                         001401 first_char_pos              strip_blanks
                         001410 buff_ptr                    read_line
                         001412 num_chars                   read_line
                         001413 buffer                      read_line
                         006317 expect_eof                  read_line

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            realloc_cs          cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other_desc call_int_other      return              enable              shorten_stack
ext_entry           int_entry           int_entry_desc      set_cs_eis          index_cs_eis        index_after_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_$add_suffix com_err_                      com_err_$suppress_name        cu_$af_return_arg
cu_$arg_ptr                   dsl_$close                    dsl_$open                     dsl_$retrieve
dsl_$store                    ioa_$ioa_switch               iox_$attach_ioname            iox_$close
iox_$detach_iocb              iox_$get_line                 iox_$open

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$not_act_fnc      iox_$error_output             mdbm_error_$dup_store




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      7 000345       136 000353       138 000354       181 000355       182 000371       184 000376       187 000403
    188 000417       191 000420       193 000427       195 000457       198 000460       199 000477       200 000531
    202 000533       203 000565       206 000566       207 000605       208 000637       210 000641       211 000673
    214 000674       216 000677       217 000716       219 000731       222 000742       224 000771       226 000772
    227 000773       229 000777       230 001000       234 001001       235 001003       237 001005       241 001031
    242 001057       246 001075       247 001103       248 001104       254 001106       256 001107       257 001133
    259 001144       260 001153       262 001154       263 001163       266 001172       267 001216       268 001221
    270 001232       272 001265       274 001267       276 001325       277 001332       279 001333       280 001373
    282 001404       283 001421       284 001424       289 001437       290 001452       291 001535       292 001537
    311 001555       314 001573       315 001607       318 001620       321 001622       322 001623       323 001626
    325 001630       327 001632       328 001647       329 001670       330 001673       331 001716       332 001721
    333 001725       334 001727       337 001737       338 001767       341 002030       343 002031       345 002032
    348 002040       350 002041       354 002047       355 002052       356 002055       357 002070       359 002112
    360 002124       361 002145       362 002157       364 002200       366 002201       370 002212       372 002250
    379 002251       386 002262       387 002277       389 002315       391 002325       393 002343       395 002364
    399 002365       407 002406       408 002420       410 002424       412 002425       417 002427       420 002443
    422 002446       423 002467       429 002470       435 002471       436 002472       438 002474       440 002476
    441 002540       442 002556       443 002577       444 002614       445 002615       447 002617       448 002640
    450 002642       452 002645       453 002646       454 002655       457 002675       458 002676       461 002750
    463 002752       465 002753       466 002755


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
