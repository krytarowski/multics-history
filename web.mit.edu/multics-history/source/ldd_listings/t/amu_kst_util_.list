	COMPILATION LISTING OF SEGMENT amu_kst_util_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/13/85  0934.2 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 amu_kst_util_: proc ();
        7 
        8 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend,ifthendo,ifthen,^thendo */
        9 
       10 /* *	Utility procedure for AMU, used to manipulate a KST in the local
       11*   *	address space. Algorithms cribbed from kstsrch.pl1, get_kstep.pl1.
       12*   *	Because the copy of the KST we are searching may not begin at the
       13*   *	beginning of a segment, much hair must be gone through to get the
       14*   *	right values of pointers and offsets; this is the reason for the
       15*   *	high density of addrels in the code */
       16 
       17 /* 03/12/80 W. Olin Sibert */
       18 /* Modified 01/12/85 by B. Braun to add entry $expand_uid_path.
       19*
       20*/* parameters */
       21 
       22 dcl  (
       23      P_expand_path char(*),
       24      P_kstp pointer,				/* pointer to KST or copy thereof */
       25      P_uid bit (36) aligned,
       26      P_kste_offset fixed bin (18),			/* offset of interesting KST entry */
       27      P_uid_path (16) bit (36) aligned,
       28      P_segno fixed bin,
       29      P_code fixed bin (35)
       30      ) parameter;
       31 
       32 /* automatic */
       33 
       34 dcl code				fixed bin (35);
       35 dcl count				fixed bin;
       36 dcl depth				fixed bin;
       37 dcl dirname			char(168);
       38 dcl  dlen				fixed bin;
       39 dcl ename				char(32);
       40 dcl hash_idx			fixed bin;
       41 dcl i				fixed bin;
       42 dcl idx				fixed bin;
       43 dcl jdx				fixed bin;
       44 dcl kste_offset			fixed bin(18);
       45 dcl par_kste_offset			fixed bin (18);
       46 dcl par_segno			fixed bin;
       47 dcl segno				fixed bin;
       48 dcl tmr				bit(1);
       49 dcl  1 tsdw			like sdw aligned;
       50 dcl uid				bit (36) aligned;
       51 dcl uid_path (16)			bit (36) aligned;
       52 dcl (rzdp, rzdsp) ptr;
       53 
       54 /* internal static */
       55 
       56 dcl ROOT_UID                            bit(36) aligned init("777777777777"b3) int static options(constant);
       57 
       58 /* external entries */
       59 
       60 dcl amu_$kst_util_uid_to_kstep	entry (ptr, bit(36) aligned, fixed bin (18), fixed bin(35));
       61 dcl get_temp_segment_		entry (char(*), ptr, fixed bin(35));
       62 dcl phcs_$initiate			entry (char (*), char (*), char (*), fixed bin, fixed bin, ptr, fixed bin (35));
       63 dcl phcs_$ring_0_peek		entry (ptr, ptr, fixed bin);
       64 dcl phcs_$terminate_noname		entry (ptr, fixed bin (35));
       65 dcl release_temp_segment_		entry (char(*), ptr, fixed bin(35));
       66 dcl ring0_get_$segptr		entry (char (*), char (*), ptr, fixed bin (35));
       67 
       68 /* external static */
       69 
       70 dcl (
       71      error_table_$noentry,
       72      error_table_$invalidsegno,
       73      error_table_$action_not_performed
       74      )				fixed bin (35) external static;
       75 
       76 /* builtins */
       77 
       78 dcl (addr, addrel, baseno, binary, dimension, 
       79      fixed, hbound, lbound, mod, null, 
       80      pointer, ptr, rel, rtrim, unspec)		builtin;
       81 
       82 dcl cleanup			condition;
       83 
       84 /*****************************************************************************/
       85 
       86 amu_kst_util_$expand_uid_path:   entry (P_kstp, P_uid_path, P_expand_path, P_code);
       87 
       88 /* Determines the pathname, given a uids for the path.
       89*     P_kstp           pointer to the kst (input)
       90*     P_uid_path       array of uids for a pathname. This can be obtained via a
       91*		  call to kst_util_$uid_to_uid_path (input)
       92*     P_expand_path    The pathname (output)
       93*     P_code	  Standard error code (output)
       94**/
       95 
       96     kstp = P_kstp;
       97     uid_path = P_uid_path;
       98     P_expand_path, dirname, ename = "";			/* start with null names */
       99     tmr = "0"b;
      100     P_code, code = 0;
      101     rzdsp, rzdp, dp = null();
      102     on cleanup begin;
      103        if dp ^= null() then call release_temp_segment_ ("amu_kst_util_", dp, (0));
      104        end;
      105 
      106     call get_temp_segment_ ("amu_kst_util_", dp, code);
      107     call ring0_get_$segptr ("", "dseg", rzdsp, code); /* get ptr to our dseg */
      108 
      109     /* Have to special case the root */
      110 
      111     if (uid_path(1) = ROOT_UID) & (uid_path(2) = ""b) then do;
      112        /* This is the ROOT segment */
      113        dirname = ">";
      114        goto RET;
      115        end;
      116 
      117     /* now go from the root+1 and form the complete pathname of target entry */
      118 
      119     do i = 2 to  hbound(uid_path, 1) while (uid_path (i) ^= ""b);
      120        if dirname = "" then    /* looking at the root, this is what we start with. */
      121           call phcs_$initiate (">", ename, "", 0, 0, rzdp, code);
      122        else call phcs_$initiate (dirname, ename, "", 0, 0, rzdp, code);
      123        if rzdp = null then go to RET1;		/* if some problem, get out of here */
      124        call phcs_$ring_0_peek (rzdp, dp, 1);	/* cause seg fault */
      125 FTSDW:
      126        call phcs_$ring_0_peek (addr (rzdsp -> sdwa (fixed (baseno (rzdp)))), addr (tsdw), 2);
      127        if ^tsdw.df then goto FTSDW;		/* we must be faulted */
      128        dlen = fixed (tsdw.bound, 15) * 16 + 16;
      129        call phcs_$ring_0_peek (rzdp, dp, dlen);	/* copy dir seg out of ring 0 */
      130        tmr = "0"b;
      131        do ep = ptr (dp, dp -> dir.entryfrp) repeat ptr (dp, ep -> entry.efrp) while (dp ^= ep & tmr = "0"b);
      132 	if ep -> entry.uid = uid_path(i) then do;	/* found right one */
      133 	   tmr = "1"b;			/* set terminate cond */
      134 	   dirname = rtrim (dirname) || ">" || addr (entry.primary_name) -> names.name;
      135 	   call phcs_$terminate_noname (rzdp, code);
      136 					/* terminate this ref */
      137 	   end;
      138 	end;
      139        if ^tmr then do;			/* didn't find name */
      140 RET1:
      141           dirname = rtrim (dirname) || ">" || "CANNOT-COMPLETE-PATH";
      142           go to RET;
      143 	end;
      144        end;    /* end of uid_path loop */
      145 
      146      code = 0;
      147 RET:
      148      if dp ^= null() then call release_temp_segment_ ("amu_kst_util_", dp, (0));
      149      P_code = code;
      150      P_expand_path = dirname;              /* copy pathname */
      151      return;
      152 
      153 /*****************************************************************************/
      154 
      155 amu_kst_util_$uid_to_kstep:
      156      entry (P_kstp, P_uid, P_kste_offset, P_code);
      157 
      158 /* *	This entry returns the offset of the KSTE with the specified UID,
      159*   *	or returns error_table_$noentry if it's not there */
      160 
      161 	kstp = P_kstp;
      162 	uid = P_uid;
      163 
      164 	if uid = ""b then do;			/* can't search for zero UID */
      165 	     P_kste_offset = 0;
      166 	     code = error_table_$action_not_performed;
      167 	     goto MAIN_RETURN;
      168 	     end;
      169 
      170 	hash_idx = mod (binary (uid, 36), dimension (kst.uid_hash_bucket, 1));
      171 
      172 	count = 0;				/* make sure we don't loop too long */
      173 	kste_offset = binary (kst.uid_hash_bucket (hash_idx), 18);
      174 	kstep = addrel (kstp, kste_offset);
      175 	do kstep = addrel (kstp, kste_offset) repeat (addrel(kstp,kste.fp))
      176 	     while (kste.fp ^= "0"b);			/* search until we find one */
      177 
      178 	     if kste.uid = ""b then do;		/* BAD */
      179 		P_kste_offset = 0;
      180 		code = error_table_$action_not_performed;
      181 		goto MAIN_RETURN;
      182 		end;
      183 
      184 	     if kste.uid = uid then do;		/* got it */
      185 		P_kste_offset = fixed(rel(kstep),18) - fixed(rel(kstp),18);
      186 		code = 0;
      187 		goto MAIN_RETURN;
      188 		end;
      189 
      190 	     count = count + 1;
      191 	     if count > 4096 then do;
      192 		P_kste_offset = 0;
      193 		code = error_table_$action_not_performed;
      194 		goto MAIN_RETURN;
      195 		end;
      196 	end;					/* of search loop */
      197 
      198 /* OK try the hard way */
      199 	do i = lbound(kst_entry,1) to hbound(kst_entry,1);
      200 	     if P_uid = kst_entry (i).uid then do;
      201 		kstep = addr(kst_entry (i));
      202 		P_kste_offset = fixed(rel(kstep),18) - fixed(rel(kstp),18);
      203 		code = 0;
      204 		goto MAIN_RETURN;
      205 	     end;
      206 	end;
      207 	P_kste_offset = 0;
      208 	code = error_table_$noentry;
      209 	goto MAIN_RETURN;				/* end of code for $uid_to_kstep entry */
      210 
      211 
      212 /*****************************************************************************/
      213 
      214 amu_kst_util_$uid_to_uid_path:
      215      entry (P_kstp, P_uid, P_uid_path, P_code);
      216 
      217 /* *	This entry returns the UID pathname of the parent of the segment
      218*   *	identified by P_uid, of a non-zero error code. The UID path is derived
      219*   *	by chasing up through the KST, using the branch pointer in a KSTE to
      220*   *	get the segment number of its parent. */
      221 
      222 	kstp = P_kstp;
      223 	uid = P_uid;
      224 
      225 	call amu_$kst_util_uid_to_kstep (kstp, uid, kste_offset, P_code);
      226 						/* first, find it */
      227 	if P_code ^= 0 then return;			/* sorry, nope */
      228 
      229 	goto UID_PATH_COMMON;			/* otherwise join common code */
      230 
      231 /*****************************************************************************/
      232 
      233 amu_kst_util_$segno_to_uid_path:
      234      entry (P_kstp, P_segno, P_uid_path, P_code);
      235 
      236 	kstp = P_kstp;
      237 	segno = P_segno;
      238 
      239 	kste_offset = validate_segno (segno);		/* see if it's OK */
      240 	if code ^= 0 then goto MAIN_RETURN;		/* no good */
      241 
      242 	goto UID_PATH_COMMON;
      243 
      244 /*****************************************************************************/
      245 
      246 amu_kst_util_$segno_to_uid:
      247 	entry (P_kstp,P_segno,P_uid,P_code);
      248 
      249 	kstp = P_kstp;
      250 	segno = P_segno;
      251 	kste_offset = validate_segno (segno);		/* see if it's OK */
      252 	if code ^= 0 then goto MAIN_RETURN;		/* no good */
      253 	kstep = addrel(kstp,kste_offset);
      254 	P_uid = kste.uid;
      255 	goto MAIN_RETURN;
      256 	
      257 
      258 	
      259 UID_PATH_COMMON:					/* Now, try to find all our parents */
      260 	depth = 1;
      261 	kstep = addrel (kstp, kste_offset);		/* point to the original KSTE */
      262 	uid_path (depth) = kste.uid;
      263 	do while (kste.uid ^= "777777777777"b3);	/* loop upwards till we find the ROOT */
      264 	     if unspec (kste.entryp) = ""b then do;	/* can't happen, of course */
      265 		code = error_table_$action_not_performed;
      266 		goto MAIN_RETURN;
      267 		end;
      268 
      269 	     par_segno = binary (baseno (kste.entryp));
      270 	     par_kste_offset = validate_segno (par_segno);
      271 	     if code ^= 0 then do;			/* par_segno is invalid?? */
      272 		code = error_table_$action_not_performed;
      273 		goto MAIN_RETURN;
      274 		end;
      275 
      276 	     kstep = addrel (kstp, par_kste_offset);	/* find our parent */
      277 	     depth = depth + 1;			/* and record his UID */
      278 	     if depth > hbound (uid_path, 1) then do;	/* too many???? */
      279 		code = error_table_$action_not_performed;
      280 		goto MAIN_RETURN;
      281 		end;
      282 
      283 	     uid_path (depth) = kste.uid;		/* this is parent UID -- continues until we hit the root */
      284 	end;
      285 
      286 	jdx = 1;					/* now that we have as many UIDs as we're gonna get, */
      287 	do idx = depth to 1 by -1;			/* let's put them in our return argument */
      288 	     P_uid_path (jdx) = uid_path (idx);
      289 	     jdx = jdx + 1;
      290 	end;
      291 
      292 	do idx = jdx to hbound (P_uid_path, 1);		/* and put zeros in the rest */
      293 	     P_uid_path (idx) = ""b;
      294 	end;
      295 
      296 	code = 0;					/* all done for this */
      297 	goto MAIN_RETURN;
      298 
      299 
      300 MAIN_RETURN:					/* general-purpose exit */
      301 	P_code = code;				/* copy the error code */
      302 	return;					/* and return */
      303 
      304 
      305 /*****************************************************************************/
      306 
      307 validate_segno:
      308      proc (P_segno) returns (fixed bin (18));
      309 
      310 /* *	This procedure verifies that the segment number supplied is a valid
      311*   *	one according to the KST, returning the KSTE offset if it is OK, and
      312*   *	setting code and returning zero if it is not. */
      313 
      314 dcl  P_segno fixed bin parameter;
      315 
      316 dcl  offset fixed bin (18);
      317 
      318 	if P_segno < kst.lowseg | P_segno > kst.highseg then do;
      319 INVALIDSEGNO:
      320 	     code = error_table_$invalidsegno;
      321 	     return (0);
      322 	     end;
      323 
      324 	offset = binary (rel (addr (pointer (kstp, 0) -> kst.kst_entry (P_segno))), 18);
      325 						/* find the right KSTE */
      326 
      327 	if unspec (addrel (kstp, offset) -> kste.entryp) = ""b then goto INVALIDSEGNO;
      328 						/* no branch ptr means no segno */
      329 
      330 	code = 0;					/* it's OK */
      331 	return (offset);
      332 
      333      end validate_segno;
  1     1 /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  1     2 
  1     3 
  1     4 /* Template for an entry. Length = 38 words */
  1     5 
  1     6 dcl  ep ptr;
  1     7 
  1     8 dcl 1 entry based (ep) aligned,
  1     9 
  1    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  1    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  1    12 
  1    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  1    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  1    15 
  1    16     2 uid bit (36),					/* unique id of entry */
  1    17 
  1    18     2 dtem bit (36),				/* date-time entry modified */
  1    19 
  1    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  1    21     2 pad0 bit (17),
  1    22     2 nnames fixed bin (17),				/* number of names for this entry */
  1    23 
  1    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  1    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  1    26 
  1    27     2 author,					/* user who created branch */
  1    28       3 pers_rp bit (18),				/* name of user who created branch */
  1    29       3 proj_rp bit (18),				/* project of user who created branch */
  1    30 
  1    31       3 tag char (1),				/* tag of user who created branch */
  1    32       3 pad1 char (3),
  1    33 
  1    34     2 primary_name bit (504),				/* first name on name list */
  1    35 
  1    36     2 dtd bit (36),					/* date time dumped */
  1    37 
  1    38     2 pad2 bit (36),
  1    39 
  1    40 
  1    41 /* the declarations below are for branch only */
  1    42 
  1    43 
  1    44     2 pvid bit (36),				/* physical volume id */
  1    45 
  1    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  1    47     2 pad3 bit (18),
  1    48 
  1    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  1    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  1    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  1    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  1    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  1    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  1    55     2 audit_flag bit (1),				/* segment must be audited for security */
  1    56     2 security_oosw bit (1),				/* security out of service switch */
  1    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  1    58     2 master_dir bit (1),				/* TRUE for master directory */
  1    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  1    60     2 pad4 bit (11),
  1    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  1    62 
  1    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  1    64 
  1    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  1    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  1    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  1    68 
  1    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  1    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  1    71 
  1    72     2 bc_author,					/* user who last set the bit count */
  1    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  1    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  1    75 
  1    76       3 tag char (1),				/* tag of user who set the bit count */
  1    77       3 pad5 bit (2),
  1    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  1    79 
  1    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  1    81 
  1    82     2 pad6 bit (36),
  1    83 
  1    84     2 checksum bit (36),				/* checksum from dtd */
  1    85 
  1    86     2 owner bit (36);				/* uid of containing directory */
  1    87 
  1    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      334 
  2     1 /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  2     2 /* Modified 8/74 for NSS */
  2     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  2     4 /* Modified 3/82 BIM for change pclock */
  2     5 /* format: style3 */
  2     6 
  2     7 /* Template for the directory header. Length = 64 words. */
  2     8 
  2     9 dcl  dp ptr;
  2    10 
  2    11 dcl 1 dir based (dp) aligned,
  2    12 
  2    13    2 modify bit (36),				/* Process ID of last modifier */
  2    14    2 type bit (18) unaligned,			/* type of object = dir header */
  2    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  2    16     2 dtc (3),					/* date-time checked by salvager array */
  2    17       3 date bit (36),				/* the date */
  2    18       3 error bit (36),				/* what errors were discovered */
  2    19 
  2    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  2    21 
  2    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  2    23 
  2    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  2    25 
  2    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  2    27 
  2    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  2    29     2 version_number fixed bin (17),			/* version number of header */
  2    30 
  2    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  2    32     2 pad2 bit (18),
  2    33 
  2    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  2    35     2 pad3 bit (18),
  2    36 
  2    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  2    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  2    39 
  2    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  2    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  2    42 
  2    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  2    44     2 dir_count fixed bin (17),			/* number of directory branches */
  2    45 
  2    46     2 lcount fixed bin (17),				/* number of links */
  2    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  2    48 
  2    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  2    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  2    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  2    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  2    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  2    54     2 pad4 bit (14),
  2    55 
  2    56     2 iacl_count (0:7),
  2    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  2    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  2    59 
  2    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  2    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  2    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  2    63 
  2    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  2    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  2    66 
  2    67     2 htsize fixed bin (17),				/* size of hash table */
  2    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  2    69 
  2    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  2    71     2 pad6 fixed bin (17),
  2    72 
  2    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  2    74     2 pad7 bit (18)) unaligned,
  2    75 
  2    76     2 dts bit (36),					/* date-time directory last salvaged */
  2    77 
  2    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  2    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  2    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  2    81     2 checksum bit (36),				/* checksummed from uid on */
  2    82     2 owner bit (36);				/* uid of parent dir */
  2    83 
  2    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  2    85 
  2    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      335 
  3     1 /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  3     2 
  3     3 /* Template for names of branches or links. Length = 14 words. */
  3     4 
  3     5 dcl np ptr;
  3     6 
  3     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  3     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  3     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  3    10 
  3    11     2 type bit (18) unaligned,			/* type = dir name */
  3    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  3    13 
  3    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  3    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  3    16 
  3    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  3    18     2 pad3 bit (18) unal,
  3    19 
  3    20     2 name char(32) aligned,
  3    21 
  3    22     2 checksum bit (36),				/* checksum from entry_rp */
  3    23 
  3    24     2 owner bit (36);				/* uid of entry */
  3    25 
  3    26 
  3    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      336 
  4     1 /*  BEGIN INCLUDE FILE  - - - kst.incl.pl1 - - - 
  4     2*
  4     3*Modified March 1976 by R. Bratt 
  4     4*Modified November 1984 to remove hdr, Keith Loepere. */
  4     5 
  4     6 dcl  pds$kstp ext ptr,
  4     7     (kstp, kstep) ptr;
  4     8 
  4     9 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  4    10     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  4    11     2 highseg fixed bin (17),				/* highest segment number described by kst */
  4    12     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  4    13     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  4    14     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  4    15     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  4    16     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  4    17     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  4    18     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  4    19     2 template bit (1) unaligned,			/* this is a template kst if set */
  4    20     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  4    21     2 unused_2 bit (9) unaligned,
  4    22     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  4    23     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  4    24     2 lv (1:256) bit (36),				/* private logical volume connection list */
  4    25     2 end_of_kst bit (36);
  4    26 
  4    27 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  4    28     2 fp bit (18) unaligned,				/* forward rel pointer */
  4    29     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  4    30     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  4    31     2 entryp ptr unaligned,				/* branch pointer */
  4    32     2 uid bit (36) aligned,				/* unique identifier */
  4    33     2 access_information unaligned,
  4    34       3 dtbm bit (36),				/* date time branch modified */
  4    35       3 extended_access bit (33),			/* extended access from the branch */
  4    36       3 access bit (3),				/* rew */
  4    37       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  4    38     2 pad1 bit (3) unaligned,
  4    39     2 flags unaligned,
  4    40       3 dirsw bit (1),				/* directory switch */
  4    41       3 allow_write bit (1),				/* set if initiated with write permission */
  4    42       3 priv_init bit (1),				/* privileged initiation */
  4    43       3 tms bit (1),				/* transparent modification switch */
  4    44       3 tus bit (1),				/* transparent usage switch */
  4    45       3 tpd bit (1),				/* transparent paging device switch */
  4    46       3 audit bit (1),				/* audit switch */
  4    47       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  4    48       3 pad bit (3),
  4    49     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  4    50 
  4    51 /*  END INCLUDE FILE - - - - - - - - - - - - kst.incl.pl1 - - - - - - - - - - - - */
      337 
  5     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  5     2 
  5     3 dcl  sdwp ptr;
  5     4 
  5     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  5     6 
  5     7    (2 add bit (24),					/* main memory address of page table */
  5     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  5     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  5    10     2 df_no bit (2),				/* directed fault number */
  5    11 
  5    12     2 pad1 bit (1),
  5    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  5    14     2 access,					/* access bits */
  5    15       3 read bit (1),				/* read permission bit */
  5    16       3 execute bit (1),				/* execute permission bit */
  5    17       3 write bit (1),				/* write permission bit */
  5    18       3 privileged bit (1),				/* privileged bit */
  5    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  5    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  5    21     2 cache bit (1),				/* cache enable bit */
  5    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  5    23 
  5    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  5    25 
  5    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      338 
      339 
      340      end;						/* amu_kst_util_ */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/13/85  0903.8  amu_kst_util_.pl1                 >special_ldd>online>6897>amu_kst_util_.pl1
334          1    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
335          2    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
336          3    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
337          4    01/30/85  1523.9  kst.incl.pl1                      >ldd>include>kst.incl.pl1
338          5    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_code                                 parameter       fixed bin(35,0)          dcl 22 set ref 86 100* 149* 155 214 225* 227 233 246
                                                                                  300*
P_expand_path                          parameter       char                     unaligned dcl 22 set ref 86 98* 150*
P_kste_offset                          parameter       fixed bin(18,0)          dcl 22 set ref 155 165* 179* 185* 192* 202* 207*
P_kstp                                 parameter       pointer                  dcl 22 ref 86 96 155 161 214 222 233 236 246 249
P_segno                                parameter       fixed bin(17,0)          dcl 22 in procedure "amu_kst_util_" ref 233 237 246
                                                                                  250
P_segno                                parameter       fixed bin(17,0)          dcl 314 in procedure "validate_segno" ref 307 318
                                                                                  318 324
P_uid                                  parameter       bit(36)                  dcl 22 set ref 155 162 200 214 223 246 254*
P_uid_path                             parameter       bit(36)                  array dcl 22 set ref 86 97 214 233 288* 292 293*
ROOT_UID                        001434 constant        bit(36)                  initial dcl 56 ref 111
addr                                                   builtin function         dcl 78 ref 125 125 125 125 134 201 324
addrel                                                 builtin function         dcl 78 ref 174 175 196 253 261 276 327
amu_$kst_util_uid_to_kstep      000010 constant        entry                    external dcl 60 ref 225
baseno                                                 builtin function         dcl 78 ref 125 125 269
binary                                                 builtin function         dcl 78 ref 170 173 269 324
bound                     1(01) 000200 automatic       bit(14)                  level 2 packed unaligned dcl 49 set ref 128
cleanup                         000230 stack reference condition                dcl 82 ref 102
code                            000100 automatic       fixed bin(35,0)          dcl 34 set ref 100* 106* 107* 120* 122* 135* 146*
                                                                                  149 166* 180* 186* 193* 203* 208* 240 252 265* 271
                                                                                  272* 279* 296* 300 319* 330*
count                           000101 automatic       fixed bin(17,0)          dcl 35 set ref 172* 190* 190 191
depth                           000102 automatic       fixed bin(17,0)          dcl 36 set ref 259* 262 277* 277 278 283 287
df                        0(33) 000200 automatic       bit(1)                   level 2 packed unaligned dcl 49 set ref 127
dimension                                              builtin function         dcl 78 ref 170
dir                                    based           structure                level 1 dcl 2-11
dirname                         000103 automatic       char(168)                unaligned dcl 37 set ref 98* 113* 120 122* 134* 134
                                                                                  140* 140 150
dlen                            000155 automatic       fixed bin(17,0)          dcl 38 set ref 128* 129*
dp                              000240 automatic       pointer                  dcl 2-9 set ref 101* 103 103* 106* 124* 129* 131 131
                                                                                  131 138 147 147*
efrp                                   based           bit(18)                  level 2 packed unaligned dcl 1-8 ref 138
ename                           000156 automatic       char(32)                 unaligned dcl 39 set ref 98* 120* 122*
entry                                  based           structure                level 1 dcl 1-8
entryfrp                 16            based           bit(18)                  level 2 packed unaligned dcl 2-11 ref 131
entryp                    3            based           pointer                  level 2 packed unaligned dcl 4-27 ref 264 269 327
ep                              000236 automatic       pointer                  dcl 1-6 set ref 131* 131* 132 134* 138
error_table_$action_not_performed
                                000032 external static fixed bin(35,0)          dcl 70 ref 166 180 193 265 272 279
error_table_$invalidsegno       000030 external static fixed bin(35,0)          dcl 70 ref 319
error_table_$noentry            000026 external static fixed bin(35,0)          dcl 70 ref 208
fixed                                                  builtin function         dcl 78 ref 125 125 128 185 185 202 202
fp                                     based           bit(18)                  level 2 packed unaligned dcl 4-27 ref 175 196
get_temp_segment_               000012 constant        entry                    external dcl 61 ref 106
hash_idx                        000166 automatic       fixed bin(17,0)          dcl 40 set ref 170* 173
hbound                                                 builtin function         dcl 78 ref 119 199 278 292
highseg                   1            based           fixed bin(17,0)          level 2 dcl 4-9 ref 199 318
i                               000167 automatic       fixed bin(17,0)          dcl 41 set ref 119* 119* 132* 199* 200 201*
idx                             000170 automatic       fixed bin(17,0)          dcl 42 set ref 287* 288* 292* 293*
jdx                             000171 automatic       fixed bin(17,0)          dcl 43 set ref 286* 288 289* 289 292
kst                                    based           structure                level 1 dcl 4-9
kst_entry               110            based           structure                array level 2 dcl 4-9 set ref 199 199 201 324
kste                                   based           structure                level 1 dcl 4-27
kste_offset                     000172 automatic       fixed bin(18,0)          dcl 44 set ref 173* 174 175 225* 239* 251* 253 261
kstep                           000244 automatic       pointer                  dcl 4-6 set ref 174* 175* 175* 178 184 185* 196 201*
                                                                                  202 253* 254 261* 262 263 264 269 276* 283
kstp                            000242 automatic       pointer                  dcl 4-6 set ref 96* 161* 170 173 174 175 185 196 199
                                                                                  199 200 201 202 222* 225* 236* 249* 253 261 276
                                                                                  318 318 324 327
lbound                                                 builtin function         dcl 78 ref 199
lowseg                                 based           fixed bin(17,0)          level 2 dcl 4-9 ref 199 200 201 318 324
mod                                                    builtin function         dcl 78 ref 170
name                      4            based           char(32)                 level 2 dcl 3-7 ref 134
names                                  based           structure                level 1 dcl 3-7
null                                                   builtin function         dcl 78 ref 101 103 123 147
offset                          000262 automatic       fixed bin(18,0)          dcl 316 set ref 324* 327 331
par_kste_offset                 000173 automatic       fixed bin(18,0)          dcl 45 set ref 270* 276
par_segno                       000174 automatic       fixed bin(17,0)          dcl 46 set ref 269* 270*
phcs_$initiate                  000014 constant        entry                    external dcl 62 ref 120 122
phcs_$ring_0_peek               000016 constant        entry                    external dcl 63 ref 124 125 129
phcs_$terminate_noname          000020 constant        entry                    external dcl 64 ref 135
pointer                                                builtin function         dcl 78 ref 324
primary_name             10            based           bit(504)                 level 2 packed unaligned dcl 1-8 set ref 134
ptr                                                    builtin function         dcl 78 ref 131 138
rel                                                    builtin function         dcl 78 ref 185 185 202 202 324
release_temp_segment_           000022 constant        entry                    external dcl 65 ref 103 147
ring0_get_$segptr               000024 constant        entry                    external dcl 66 ref 107
rtrim                                                  builtin function         dcl 78 ref 134 140
rzdp                            000224 automatic       pointer                  dcl 52 set ref 101* 120* 122* 123 124* 125 125 129*
                                                                                  135*
rzdsp                           000226 automatic       pointer                  dcl 52 set ref 101* 107* 125 125
sdw                                    based           structure                level 1 dcl 5-5
sdwa                                   based           structure                array level 1 dcl 5-24 set ref 125 125
segno                           000175 automatic       fixed bin(17,0)          dcl 47 set ref 237* 239* 250* 251*
tmr                             000176 automatic       bit(1)                   unaligned dcl 48 set ref 99* 130* 131 133* 139
tsdw                            000200 automatic       structure                level 1 dcl 49 set ref 125 125
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 1-8 in procedure
                                                                                  "amu_kst_util_" ref 132
uid                             000202 automatic       bit(36)                  dcl 50 in procedure "amu_kst_util_" set ref 162* 164
                                                                                  170 184 223* 225*
uid                       4            based           bit(36)                  level 2 in structure "kste" dcl 4-27 in procedure
                                                                                  "amu_kst_util_" ref 178 184 254 262 263 283
uid                     114            based           bit(36)                  array level 3 in structure "kst" dcl 4-9
                                                                                  in procedure "amu_kst_util_" set ref 200
uid_hash_bucket          10            based           bit(18)                  array level 2 packed unaligned dcl 4-9 ref 170 173
uid_path                        000203 automatic       bit(36)                  array dcl 51 set ref 97* 111 111 119 119 132 262*
                                                                                  278 283* 288
unspec                                                 builtin function         dcl 78 ref 264 327

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
np                                     automatic       pointer                  dcl 3-5
pds$kstp                               external static pointer                  dcl 4-6
sdwp                                   automatic       pointer                  dcl 5-3
version_number_2                       internal static fixed bin(17,0)          initial dcl 2-84

NAMES DECLARED BY EXPLICIT CONTEXT.
FTSDW                           000423 constant        label                    dcl 125 ref 127
INVALIDSEGNO                    001367 constant        label                    dcl 319 ref 327
MAIN_RETURN                     001353 constant        label                    dcl 300 ref 167 181 187 194 204 209 240 252 255 266
                                                                                  273 280 297
RET                             000650 constant        label                    dcl 147 ref 114 142
RET1                            000604 constant        label                    dcl 140 ref 123
UID_PATH_COMMON                 001240 constant        label                    dcl 259 ref 229 242
amu_kst_util_                   000040 constant        entry                    external dcl 6
amu_kst_util_$expand_uid_path   000053 constant        entry                    external dcl 86
amu_kst_util_$segno_to_uid      001207 constant        entry                    external dcl 246
amu_kst_util_$segno_to_uid_path 001157 constant        entry                    external dcl 233
amu_kst_util_$uid_to_kstep      000720 constant        entry                    external dcl 155
amu_kst_util_$uid_to_uid_path   001111 constant        entry                    external dcl 214
validate_segno                  001357 constant        entry                    internal dcl 307 ref 239 251 270

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1746        2002    1437        1756
Length      2306    1437        34         270     307           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
amu_kst_util_                       255 external procedure  is an external procedure.  
on unit on line 102                  84 on unit               
validate_segno                          internal procedure  shares stack frame of external procedure amu_kst_util_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
amu_kst_util_            000100 code                        amu_kst_util_
                         000101 count                       amu_kst_util_
                         000102 depth                       amu_kst_util_
                         000103 dirname                     amu_kst_util_
                         000155 dlen                        amu_kst_util_
                         000156 ename                       amu_kst_util_
                         000166 hash_idx                    amu_kst_util_
                         000167 i                           amu_kst_util_
                         000170 idx                         amu_kst_util_
                         000171 jdx                         amu_kst_util_
                         000172 kste_offset                 amu_kst_util_
                         000173 par_kste_offset             amu_kst_util_
                         000174 par_segno                   amu_kst_util_
                         000175 segno                       amu_kst_util_
                         000176 tmr                         amu_kst_util_
                         000200 tsdw                        amu_kst_util_
                         000202 uid                         amu_kst_util_
                         000203 uid_path                    amu_kst_util_
                         000224 rzdp                        amu_kst_util_
                         000226 rzdsp                       amu_kst_util_
                         000236 ep                          amu_kst_util_
                         000240 dp                          amu_kst_util_
                         000242 kstp                        amu_kst_util_
                         000244 kstep                       amu_kst_util_
                         000262 offset                      validate_segno

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        return              mpfx2
mod_fx3             enable              shorten_stack       ext_entry           ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$kst_util_uid_to_kstep    get_temp_segment_             phcs_$initiate                phcs_$ring_0_peek
phcs_$terminate_noname        release_temp_segment_         ring0_get_$segptr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$invalidsegno     error_table_$noentry




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      6 000037        86 000045        96 000071        97 000075        98 000101        99 000114       100 000115
    101 000117       102 000123       103 000137       104 000171       106 000172       107 000217       111 000246
    113 000253       114 000256       119 000257       120 000267       122 000340       123 000402       124 000406
    125 000423       127 000453       128 000456       129 000464       130 000477       131 000500       132 000514
    133 000521       134 000523       135 000562       138 000574       139 000602       140 000604       142 000643
    144 000645       146 000647       147 000650       149 000702       150 000705       151 000712       155 000713
    161 000730       162 000734       164 000736       165 000737       166 000740       167 000743       170 000744
    172 000750       173 000751       174 000760       175 000763       178 000770       179 000773       180 000775
    181 001000       184 001001       185 001003       186 001013       187 001014       190 001015       191 001016
    192 001021       193 001023       194 001026       196 001027       199 001034       200 001045       201 001060
    202 001062       203 001072       204 001073       206 001074       207 001076       208 001100       209 001103
    214 001104       222 001123       223 001127       225 001131       227 001146       229 001151       233 001152
    236 001167       237 001173       239 001175       240 001177       242 001201       246 001202       249 001217
    250 001223       251 001225       252 001227       253 001231       254 001235       255 001237       259 001240
    261 001242       262 001246       263 001251       264 001256       265 001260       266 001263       269 001264
    270 001270       271 001272       272 001274       273 001277       276 001300       277 001304       278 001305
    279 001310       280 001313       283 001314       284 001316       286 001317       287 001321       288 001327
    289 001333       290 001334       292 001337       293 001345       294 001347       296 001351       297 001352
    300 001353       302 001356       307 001357       318 001361       319 001367       321 001372       324 001375
    327 001410       330 001414       331 001415


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
