	COMPILATION LISTING OF SEGMENT azm_display_am_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/19/84  1119.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 azm_display_am_: proc (P_sci_ptr, P_amu_info_ptr, prds_sw, sdw_sw, ptw_sw, only_fulls,
       10 	sdw_segno, ptw_pageno, P_code);
       11 
       12 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend,ifthendo,ifthen,^thendo */
       13 
       14 
       15 /* Associative memory display program for analyze_multics.
       16*   Taken from ol_dumps display_am by Rich Coppola Sept 1982.
       17**/
       18 
       19 /* Parameters */
       20 
       21 dcl  P_amu_info_ptr ptr;
       22 dcl  P_sci_ptr ptr;
       23 dcl  P_code fixed bin (35);
       24 dcl  prds_sw bit (1);				/* "1"b = do AMs from prds */
       25 dcl  sdw_sw bit (1);				/* "1"b = do SDWs only */
       26 dcl  ptw_sw bit (1);				/* "1"b = do PTWs only */
       27 dcl  only_fulls bit (1);				/* "1"b = display only full entries */
       28 dcl  sdw_segno fixed bin;				/* display entries that have this segno */
       29 dcl  ptw_pageno fixed bin;				/* display entries that have this pageno */
       30 
       31 
       32 /* Automatic Data */
       33 
       34 dcl  DPS8xxM bit (1);				/* "1"b = DPS8xxM type CPU */
       35 dcl  IDX fixed bin;
       36 dcl  code fixed bin (35);
       37 dcl  data_buf_ptr ptr init (null);
       38 dcl  dup_entry (0:63) bit (1) unal;
       39 dcl  first fixed bin (18);
       40 dcl  first_entry fixed bin;
       41 dcl  first_level fixed bin;
       42 dcl  flag_string char (7);
       43 dcl  i fixed bin;
       44 dcl  idx fixed bin;
       45 dcl  index_changed bit (1) init ("0"b);
       46 dcl  j fixed bin;
       47 dcl  last_entry fixed bin;
       48 dcl  last_level fixed bin;
       49 dcl  nregs fixed bin;				/* # of regs 16/64 */
       50 dcl  ptws_printed bit (1) init ("0"b);
       51 dcl  pageno_sw bit (1) init ("0"b);
       52 dcl  ptr_ptr ptr init (null);
       53 dcl  ptw_hdr_printed bit (1);
       54 dcl  ptw_level_printed bit (1) init ("0"b);
       55 dcl  ptw_ptrs_ptr ptr;
       56 dcl  ptw_regs_ptr ptr;
       57 dcl  range fixed bin (18);
       58 dcl  reg_ptr ptr init (null);
       59 dcl  sci_ptr ptr;
       60 dcl  sdw_hdr_printed bit (1);
       61 dcl  sdw_level_printed bit (1) init ("0"b);
       62 dcl  sdw_ptrs_ptr ptr;
       63 dcl  sdw_regs_ptr ptr;
       64 dcl  sdws_printed bit (1) init ("0"b);
       65 dcl  seg_ptr pointer;
       66 dcl  segno fixed bin;
       67 dcl  segno_sw bit (1) init ("0"b);
       68 dcl  temp_ptr ptr init (null);
       69 dcl  usage_string char (8);
       70 
       71 /* Constants */
       72 
       73 dcl  AM_LEVEL (1:4) char (1) int static options (constant) init ("A", "B", "C", "D");
       74 						/* levels of dps8 AMs */
       75 
       76 /* Based */
       77 
       78 
       79 dcl  last_three_sets bit (48 * 36) based;
       80 dcl  1 ptw_regs (0:63) aligned like amptwreg based (ptw_regs_ptr);
       81 dcl  1 ptw_ptrs (0:63) aligned like amptwptr based (ptw_ptrs_ptr);
       82 dcl  1 sdw_regs (0:63) aligned like amsdwreg based (sdw_regs_ptr);
       83 dcl  1 sdw_ptrs (0:63) aligned like amsdwptr based (sdw_ptrs_ptr);
       84 
       85 /* External entries */
       86 
       87 dcl  amu_$definition_ptr entry (ptr, char (*), char (*), fixed bin (35)) returns (ptr);
       88 dcl  amu_$do_translation entry (ptr, fixed bin, ptr, fixed bin (18), fixed bin (18), fixed bin (35));
       89 dcl  amu_$fdump_mpt_temp_change_idx entry (ptr, fixed bin);
       90 dcl  amu_$fdump_mpt_revert_idx entry (ptr);
       91 dcl  amu_$get_name entry (ptr, ptr) returns (char (*));
       92 dcl  amu_$get_name_no_comp entry (ptr, ptr) returns (char (*));
       93 dcl  amu_$return_val_per_process entry (ptr, fixed bin) returns (bit (1));
       94 dcl  ssu_$get_temp_segment	entry (ptr, char(*), ptr);
       95 dcl  ssu_$release_temp_segment	entry (ptr, ptr);
       96 dcl  ioa_ entry options (variable);
       97 dcl  ioa_$rsnnl entry options (variable);
       98 
       99 dcl  (addr, addrel, baseno, binary, 
      100      baseptr, divide, fixed, lbound,
      101      null, rel)			builtin;
      102 
      103 dcl  any_other condition;			
      104 
      105 
      106 	amu_info_ptr = P_amu_info_ptr;
      107 	sci_ptr = P_sci_ptr;
      108 	P_code = 0;
      109 	data_buf_ptr = null ();
      110 
      111 	on condition (any_other) go to done;
      112 
      113 	call set_up;
      114 	     if sdw_sw then do;
      115 	        call display_sdw;
      116 	if sdws_printed = "0"b then do;
      117 	   if segno_sw then		/* none printed and, */
      118 						/* if we were looking for only one */
      119 	     call ioa_ ("^/A valid entry for SEGNO ^o not found in SDWAM from ^[Dump^;prds$am_data^].",
      120 	   sdw_segno, ^prds_sw);
      121 	   end;
      122 	end;
      123 
      124 	if ptw_sw then do;
      125 	   call display_ptw;
      126 	if ptws_printed = "0"b then do;
      127 	   if (pageno_sw | sdw_sw) then do;/* same as for SDWs */
      128 	     if ptw_pageno = -1 then ptw_sw = "0"b;
      129 	     call ioa_ ("^/A valid entry for ^[PAGENO ^o ^;^s^]^[of ^]^[ SEGNO ^o ^;^s^]not found in PTWAM from ^[Dump^;prds$am_data^].",
      130 		ptw_sw, ptw_pageno, (ptw_sw & sdw_segno ^= -1), 
      131 	        sdw_sw, sdw_segno, ^prds_sw);
      132 	     end;
      133 	  end;
      134          end;
      135 done:
      136          if data_buf_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
      137          return;
      138 
      139 
      140 
      141 
      142 
      143 display_ptw:
      144      proc;
      145 
      146 	first_entry = 0;
      147 	last_entry = 15;
      148 
      149 	if DPS8xxM then do;
      150 	     first_level = 1;
      151 	     last_level = 4;
      152 	     end;
      153 
      154 	else do;
      155 	     first_level = 1;
      156 	     last_level = 1;
      157 	     end;
      158 
      159 	call validate_am_ptw;
      160 
      161 	if ptw_pageno ^= -1 then pageno_sw = "1"b;
      162 	if sdw_segno ^= -1 then segno_sw = "1"b;
      163 	ptw_level_printed, ptw_hdr_printed = "0"b;
      164 
      165 	do IDX = first_level to last_level;
      166 	   ptw_level_printed = "0"b;
      167 	     do idx = first_entry to last_entry;
      168 
      169 		seg_ptr =
      170 		     addrel (baseptr (binary (ptw_ptrs (idx).pointer, 15)), (binary (ptw_ptrs (idx).pageno, 12) * 16))
      171 		     ;				/* get a pointer to the segment, so we can get its name */
      172 
      173 		if (only_fulls & ^ptw_ptrs (idx).valid) then go to bypass_ptw;
      174 
      175 		if (segno_sw & (fixed (ptw_ptrs (idx).pointer, 15) ^= sdw_segno)) then go to bypass_ptw;
      176 
      177 		if pageno_sw then
      178 		     if divide (binary (ptw_ptrs (idx).pageno, 12), 16, 12, 0) ^= ptw_pageno then go to bypass_ptw;
      179 		if ^DPS8xxM then
      180 		     call ioa_$rsnnl ("^6x^2d", usage_string, (0), binary (ptw_ptrs (idx).usage, 4));
      181 
      182 		else call ioa_$rsnnl ("^2x^6b", usage_string, (0), ptw_ptrs (idx).usage);
      183 		if ptw_hdr_printed = "0"b then do;
      184 		     call ioa_ ("^/PTW Associative Memory ^[at the time of the dump^;at prds$am_data^].", ^prds_sw);
      185 		     call ioa_ (" ADDRESS^3xM^2xF/E USAGE_CT SEG # PAGE SEG_NAME|OFFSET");
      186 		     ptw_hdr_printed = "1"b;
      187 		     end;
      188 
      189 		if (DPS8xxM & ^ptw_level_printed) then do;
      190 		     call ioa_ ("LEVEL [^a]", AM_LEVEL (IDX));
      191 		     ptw_level_printed = "1"b;
      192 		     end;
      193 
      194 		call ioa_ (
      195 		     "^8o^2x^[yes^;no ^]^2x^[F^;E^]^2x^8a ^5o ^4o ^[^a^;^s N/A^]^[^/^-*** POSSIBLE DUPLICATE ENTRY ***^]"
      196 		     , binary ((ptw_regs (idx).addr || "000000"b), 24), ptw_regs (idx).modif, ptw_ptrs (idx).valid,
      197 		     usage_string, binary (ptw_ptrs (idx).pointer, 15),
      198 		     divide (binary (ptw_ptrs (idx).pageno, 12), 16, 12, 0), ptw_ptrs (idx).valid,
      199 						/* skip the naming if this PTWAM entry is empty */
      200 		     amu_$get_name (amu_info_ptr, seg_ptr), dup_entry (idx));
      201 		ptws_printed = "1"b;
      202 bypass_ptw:
      203 	     end;
      204 
      205 	     first_entry = last_entry + 1;
      206 	     last_entry = first_entry + 15;
      207 
      208 	end;
      209 	return;
      210      end display_ptw;
      211 
      212 
      213 display_sdw:
      214      proc;
      215 
      216 	first_entry = 0;
      217 	last_entry = 15;
      218 
      219 	if DPS8xxM then do;
      220 	     first_level = 1;
      221 	     last_level = 4;
      222 	     end;
      223 
      224 	else do;
      225 	     first_level = 1;
      226 	     last_level = 1;
      227 	     end;
      228 
      229 	call validate_am_sdw;
      230 
      231 	if sdw_segno ^= -1 then segno_sw = "1"b;
      232 	sdw_level_printed, sdw_hdr_printed = "0"b;
      233 	do IDX = first_level to last_level;
      234 	   sdw_level_printed = "0"b;
      235 	     do idx = first_entry to last_entry;
      236 		if (only_fulls & ^sdw_ptrs (idx).valid) then go to bypass_sdw;
      237 
      238 		if (segno_sw & (fixed (sdw_ptrs (idx).pointer, 15) ^= sdw_segno)) then go to bypass_sdw;
      239 		call ioa_$rsnnl ("^[R^; ^]^[E^; ^]^[W^; ^]^[P^; ^]^[U^; ^]^[G^; ^]^[C^; ^]", flag_string, (0),
      240 						/* generate the REWPUGC string */
      241 		     sdw_regs (idx).read, sdw_regs (idx).execute, sdw_regs (idx).write, sdw_regs (idx).privileged,
      242 		     sdw_regs (idx).unpaged, sdw_regs (idx).entry_bound_sw, sdw_regs (idx).cache);
      243 
      244 		if ^DPS8xxM then
      245 		     call ioa_$rsnnl ("^6x^2d", usage_string, (0), binary (sdw_ptrs (idx).usage, 4));
      246 
      247 		else call ioa_$rsnnl ("^2x^6b", usage_string, (0), sdw_ptrs (idx).usage);
      248 		temp_ptr = baseptr (binary (sdw_ptrs (idx).pointer, 15));
      249 
      250 		if sdw_hdr_printed = "0"b then do;
      251 		     call ioa_ ("^/SDW Associative Memory ^[at the time of the dump^;at prds$am_data^].", ^prds_sw);
      252 		     call ioa_ (" ADDRESS^2xRINGS^2xBOUND^2xREWPUGC^4xCL F/E USAGE-CT SEG # SEG_NAME");
      253 		     sdw_hdr_printed = "1"b;
      254 		     end;
      255 
      256 		if (DPS8xxM & ^sdw_level_printed) then do;
      257 		     call ioa_ ("LEVEL [^a]", AM_LEVEL (IDX));
      258 		     sdw_level_printed = "1"b;
      259 		     end;
      260 
      261 		call ioa_ (
      262 		     "^8o^2x^1.3b,^1.3b,^1.3b ^6o^2x^7a ^[^5o^;^s^4x-^]^2x^[F^;E^]^2x^8a ^5o ^[^a^;^s N/A^]^[^/^-*** POSSIBLE DUPLICATE ENTRY ***^]"
      263 		     , binary (sdw_regs (idx).addr, 24), sdw_regs (idx).r1, sdw_regs (idx).r2, sdw_regs (idx).r3,
      264 		     binary ((sdw_regs (idx).bound || "0000"b), 18), flag_string,
      265 		     ((^sdw_regs (idx).entry_bound_sw) & sdw_regs (idx).execute),
      266 						/* skip next if there is none */
      267 		     binary (sdw_regs (idx).cl, 14), sdw_ptrs (idx).valid, usage_string,
      268 		     binary (sdw_ptrs (idx).pointer, 15), sdw_ptrs (idx).valid,
      269 						/* skip the naming if the entry isn't valid */
      270 		     amu_$get_name_no_comp (amu_info_ptr, temp_ptr), dup_entry (idx));
      271 		sdws_printed = "1"b;
      272 bypass_sdw:
      273 	     end;
      274 
      275 	     first_entry = last_entry + 1;
      276 	     last_entry = first_entry + 15;
      277 
      278 	end;
      279 	return;
      280      end display_sdw;
      281 
      282 
      283 get_data_:
      284      proc (data_ptr, seg, word, number);
      285 dcl  seg fixed bin;
      286 dcl  data_ptr ptr;
      287 dcl  (word, number) fixed bin (18);
      288 	if ^amu_$return_val_per_process (amu_info_ptr, seg) then do;
      289 	     index_changed = "1"b;
      290 	     call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, lbound (fdump_process_table.array, 1));
      291 	     end;
      292 	call amu_$do_translation (amu_info_ptr, seg, data_ptr, word, number, code);
      293 	if index_changed = "1"b then do;
      294 	     call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      295 	     index_changed = "0"b;
      296 	     end;
      297      end get_data_;
      298 
      299 
      300 set_up:
      301      proc;
      302 
      303           code = 0;
      304 	if ^prds_sw then do;			/* do AMs from 'dump' */
      305 	     dumpptr = fdump_info.dump_seg_ptr (0);
      306 	     sdw_regs_ptr = addr (dump.amsdwregs);
      307 	     sdw_ptrs_ptr = addr (dump.amsdwptrs);
      308 	     ptw_regs_ptr = addr (dump.amptwregs);
      309 	     ptw_ptrs_ptr = addr (dump.amptwptrs);
      310 	     end;
      311 
      312 	else do;					/* do AMs from PRDS */
      313 	     range = 512;				/* need 512 words */
      314 	     temp_ptr = amu_$definition_ptr (amu_info_ptr, "prds", "am_data", code);
      315 	     if code ^= 0 then do;
      316 		P_code = code;
      317 		return;
      318 		end;
      319 
      320 	     segno = fixed (baseno (temp_ptr), 17);
      321 	     first = fixed (rel (temp_ptr), 18);
      322 	     call ssu_$get_temp_segment (sci_ptr, "azm_display_am_", data_buf_ptr);
      323 
      324 	     call get_data_ (data_buf_ptr, segno, first, range);
      325 						/* ensure data is contigous */
      326 	     if code ^= 0 then do;
      327 		P_code = code;
      328 		if data_buf_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
      329 		return;
      330 		end;
      331 
      332 	     ptw_regs_ptr = data_buf_ptr;
      333 	     ptw_ptrs_ptr = addrel (ptw_regs_ptr, 64);
      334 	     sdw_regs_ptr = addrel (ptw_ptrs_ptr, 64);
      335 	     sdw_ptrs_ptr = addrel (sdw_regs_ptr, 128);
      336 	     end;
      337 
      338 
      339 	temp_ptr = addrel (ptw_regs_ptr, 16);		/* base to 2'nd set of regs */
      340 	if temp_ptr -> last_three_sets = "0"b then do;	/* if second set is zero then */
      341 	     nregs = 15;				/* AMs are from a l68 */
      342 	     DPS8xxM = "0"b;
      343 	     end;
      344 
      345 	else do;					/* No, they are from a DPS8M */
      346 	     nregs = 63;
      347 	     DPS8xxM = "1"b;
      348 	     end;
      349 
      350 	return;
      351      end set_up;
      352 
      353 validate_am_ptw:
      354      proc;
      355 
      356 	dup_entry (*) = "0"b;
      357 
      358 	do i = 0 to nregs - 1;
      359 	     do j = i + 1 to nregs;
      360 		if (ptw_ptrs (i).valid & ptw_ptrs (j).valid) then do;
      361 		     if ptw_regs (i).addr = ptw_regs (j).addr then do;
      362 			dup_entry (i) = "1"b;
      363 			dup_entry (j) = "1"b;
      364 			end;
      365 
      366 		     else if ptw_ptrs (i).usage = ptw_ptrs (j).usage then do;
      367 			if ^DPS8xxM then do;	/* if its not a dps8 */
      368 			     dup_entry (i) = "1"b;
      369 			     dup_entry (j) = "1"b;
      370 			     end;
      371 			end;
      372 
      373 		     else if (ptw_ptrs (i).pointer = ptw_ptrs (j).pointer)
      374 			     & (ptw_ptrs (i).pageno = ptw_ptrs (j).pageno) then do;
      375 			dup_entry (i) = "1"b;
      376 			dup_entry (j) = "1"b;
      377 			end;
      378 
      379 
      380 
      381 		     if (dup_entry (i) & dup_entry (j)) then do;
      382 			if ptw_regs (i).addr = ptw_regs (j).addr then
      383 			     if ptw_ptrs (i).pointer ^= ptw_ptrs (j).pointer then do;
      384 				if DPS8xxM then go to cancel_dup_ptw;
      385 				if ptw_ptrs (i).usage ^= ptw_ptrs (j).usage then do;
      386 cancel_dup_ptw:
      387 				     dup_entry (i), dup_entry (j) = "0"b;
      388 				     end;
      389 				end;
      390 			end;
      391 		     end;
      392 	     end;
      393 	end;
      394 	return;
      395      end validate_am_ptw;
      396 
      397 validate_am_sdw:
      398      proc;
      399 
      400 	dup_entry (*) = "0"b;
      401 
      402 	do i = 0 to nregs - 1;
      403 	     do j = i + 1 to nregs;
      404 		if (sdw_ptrs (i).valid & sdw_ptrs (j).valid) then do;
      405 
      406 		     if sdw_regs (i).addr = sdw_regs (j).addr then do;
      407 			dup_entry (i) = "1"b;
      408 			dup_entry (j) = "1"b;
      409 			end;
      410 
      411 		     else if sdw_ptrs (i).pointer = sdw_ptrs (j).pointer then do;
      412 			dup_entry (i) = "1"b;
      413 			dup_entry (j) = "1"b;
      414 			end;
      415 
      416 		     else if sdw_ptrs (i).usage = sdw_ptrs (j).usage then do;
      417 			if ^DPS8xxM then do;	/* if its not a dps8 */
      418 			     dup_entry (i) = "1"b;	/* for dps8 it is LRU not usage ctr */
      419 			     dup_entry (j) = "1"b;
      420 			     end;
      421 			end;
      422 
      423 
      424 		     if (dup_entry (i) & dup_entry (j)) then do;
      425 			if sdw_regs (i).addr = sdw_regs (j).addr then
      426 			     if sdw_regs (i).bound = sdw_regs (j).bound then
      427 				if (sdw_regs (i).r2 & sdw_regs (i).r3) ^= (sdw_regs (j).r2 & sdw_regs (j).r3) then
      428 				     if sdw_ptrs (i).pointer ^= sdw_ptrs (j).pointer then do;
      429 					if DPS8xxM then go to cancel_dup_sdw;
      430 					if sdw_ptrs (i).usage ^= sdw_ptrs (j).usage then do;
      431 cancel_dup_sdw:
      432 					     dup_entry (i), dup_entry (j) = "0"b;
      433 					     end;
      434 					end;
      435 			end;
      436 		     end;
      437 	     end;
      438 	end;
      439 	return;
      440      end validate_am_sdw;
      441 
  1     1 
  1     2 /* BEGIN INCLUDE FILE ... assoc_mem.incl.pl1 ... Last modified 1 March 1973 */
  1     3 
  1     4 dcl 1 amptwreg aligned based,				/* Associative Memory page table word register */
  1     5    (2 addr bit (18),				/* upper 18 bits of 24 bit core address of page */
  1     6     2 pad1 bit (11),
  1     7     2 modif bit (1),				/* page has been modified bit */
  1     8     2 pad2 bit (6)) unaligned;
  1     9 
  1    10 
  1    11 dcl 1 amptwptr aligned based,				/* Associative Memory page table word pointer */
  1    12    (2 pointer bit (15),				/* effective segment number */
  1    13     2 pageno bit (12),				/* page number to which this ptw refers */
  1    14     2 valid bit (1),				/* 1 => this register contains valid information */
  1    15     2 amptwptr_pad bit (4),
  1    16     2 usage bit (4)) unaligned;			/* relative usage, "1111"b is most recent */
  1    17 
  1    18 
  1    19 dcl 1 amsdwreg aligned based,				/* Associative Memory segment descriptor word register */
  1    20    (2 addr bit (24),				/* core address of page table or segment */
  1    21     2 r1 bit (3),					/* read/write ring bracket */
  1    22     2 r2 bit (3),					/* read/execute bracket */
  1    23     2 r3 bit (3),					/* call bracket  */
  1    24     2 pad1 bit (3),
  1    25 
  1    26     2 pad2 bit (1),
  1    27     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  1    28     2 read bit (1),					/* read permission bit */
  1    29     2 execute bit (1),				/* execute permission bit */
  1    30     2 write bit (1),				/* write permission bit */
  1    31     2 privileged bit (1),				/* privileged mode bit */
  1    32     2 unpaged bit (1),				/* 1 =>  addr is base address of segment */
  1    33     2 entry_bound_sw bit (1),				/* 0 => cl is checked by hardware */
  1    34     2 cache bit (1),				/* segment is encacheable */
  1    35     2 cl bit (14)) unaligned;				/* entry bound */
  1    36 
  1    37 
  1    38 dcl 1 amsdwptr aligned based,				/* Associative Memory segment descriptor word pointer */
  1    39    (2 pointer bit (15),				/* effective segment number */
  1    40     2 pad1 bit (12),
  1    41     2 valid bit (1),				/* 1 => this register contains valid information */
  1    42     2 pad2 bit (4),
  1    43     2 usage bit (4)) unaligned;			/* relative usage,."1111"b is most recently used */
  1    44 
  1    45 /* END INCLUDE FILE ... assoc_mem.incl.pl1 ... */
      442 
      443 
  2     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  2     2 
  2     3 dcl  sdwp ptr;
  2     4 
  2     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  2     6 
  2     7    (2 add bit (24),					/* main memory address of page table */
  2     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  2     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  2    10     2 df_no bit (2),				/* directed fault number */
  2    11 
  2    12     2 pad1 bit (1),
  2    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  2    14     2 access,					/* access bits */
  2    15       3 read bit (1),				/* read permission bit */
  2    16       3 execute bit (1),				/* execute permission bit */
  2    17       3 write bit (1),				/* write permission bit */
  2    18       3 privileged bit (1),				/* privileged bit */
  2    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  2    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  2    21     2 cache bit (1),				/* cache enable bit */
  2    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  2    23 
  2    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  2    25 
  2    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      444 
      445 
  3     1 /* BEGIN INCLUDE FILE  ptw.incl.pl1  ---  09/13/74 for nss */
  3     2 
  3     3 dcl  ptp ptr;					/* pointer to either page table or page table word */
  3     4 
  3     5 dcl 1 ptw based (ptp) aligned,			/* page table word */
  3     6 
  3     7     (2 add bit (18),				/* address of page, type of which is defined by add_type */
  3     8     2 add_type bit (4),				/* 0000=null, 1000=core, 0100=disk, 0010=pd, 0001=swap */
  3     9     2 first bit (1),				/* the page has not yet been written out */
  3    10     2 processed bit (1),				/* temporary used during post-purging and error signalling */
  3    11     2 pad1 bit (1),
  3    12     2 unusable1 bit (1),				/* can't be used because hardware resets this bit */
  3    13     2 phu bit (1),					/* page has been used bit */
  3    14     2 phm1 bit (1),					/* Cumulative OR of hardware phm's */
  3    15     2 nypd bit (1),					/* must be moved to paging device */
  3    16     2 phm bit (1),					/* page has been modified bit */
  3    17     2 phu1 bit (1),					/* page has been used in the quantum */
  3    18     2 wired bit (1),				/* page is to remain in core */
  3    19     2 os bit (1),					/* page is out-of-service (I/O in progress) */
  3    20     2 df bit (1),					/* directed fault if this is 0 (page not in core) */
  3    21     2 df_no bit (2)) unaligned;			/* directed fault number for page faults */
  3    22 
  3    23 dcl 1 ptwa (0:255) based (ptp) aligned like ptw;		/* page table */
  3    24 
  3    25 dcl  ptwa_bits (0:255) based (ptp) bit (36) aligned;	/* page table array as raw bits */
  3    26 
  3    27 dcl 1 mptw based (ptp) aligned,			/* page table word while page is not in core */
  3    28     2 devadd bit (22) unaligned,			/* device address where page resides */
  3    29     2 pad bit (14) unaligned;
  3    30 
  3    31 dcl 1 mptwa (0 : 1) based (ptp) aligned,		/* page table while pages are not in core */
  3    32     2 devadd bit (22) unaligned,			/* device address where page resides */
  3    33     2 pad bit (14) unaligned;
  3    34 
  3    35 dcl 1 atptw based (ptp) aligned,			/* PL/I has problems on overlay-def based */
  3    36     2 add bit (18) unal,
  3    37     2 (core, disk, pd, reserved) bit (1) unal,		/* address types */
  3    38     2 pad bit (14) unal;
  3    39 
  3    40 dcl 1 atptwa (0:255) based (ptp) aligned like atptw;
  3    41 
  3    42 /* END INCLUDE FILE  ptw.incl.pl1 */
      446 
      447 
  4     1 /*	BEGIN INCLUDE FILE amu_info.incl.pl1		*/
  4     2 
  4     3 dcl 1 amu_info aligned based (amu_info_ptr),
  4     4     2 version char (8) aligned,			/* AMU_INFO_VERSION */
  4     5     2 flags aligned,
  4     6       3 early_dump bit(1) unal,
  4     7       3 pad  bit(35) unal,
  4     8     2 type fixed bin unal,				/* One of the types below */
  4     9     2 time_created fixed bin (71) aligned,		/* time created -- for debugging purposes */
  4    10     2 chain,					/* a chain of all the amu_info's which exist */
  4    11       3 prev pointer unaligned,
  4    12       3 next pointer unaligned,
  4    13 
  4    14     2 area_ptr pointer,				/* pointer to area used for allocating things */
  4    15 
  4    16     2 translation_table_ptr pointer,			/* pointer to address map -- always present */
  4    17 						/*   SEE: amu_translation.incl.pl1 */
  4    18     2 fdump_info_ptr pointer, 			
  4    19 						/* pointer to FDUMP info, present if looking at an FDUMP */
  4    20 						/*   SEE: amu_fdump_info.incl.pl1 */
  4    21 						/* old_uid_table pointer if looking at a SAVED PROC. */
  4    22 						/* See: amu_old_uid_table			*/
  4    23 	
  4    24 
  4    25     2 hardcore_info_ptr pointer,			/* pointer to hardcore information -- always present */
  4    26 						/*   SEE: amu_hardcore_info.incl.pl1 */
  4    27     2 copy_chain pointer,				/* pointer to info about segment copies */
  4    28 						/*   SEE: amu_copy_info.incl.pl1 */
  4    29     2 process_info_ptr pointer,			/* pointer to process info for this translation */
  4    30 						/*   SEE: amu_process_info.incl.pl1 */
  4    31     2 process_idx fixed bin,				/* index of process in translation-specifc process table */
  4    32 
  4    33     2 proc_idx_hold fixed bin,			/* a place to keep the index when a changing to another proc */
  4    34 
  4    35     2 error_info,					/* various info about how amu_error_ is to behave */
  4    36       3 error_flags aligned,
  4    37         4 handler_exists bit (1) unaligned,		/* set to indicate existence of an amu_error handler */
  4    38         4 in_subsystem bit (1) unaligned,		/* This amu_info belongs to an ssu_ maintained subsystem */
  4    39         4 pad bit (34) unaligned,
  4    40       3 sci_ptr pointer,				/* sci_ptr for subsystem, if in_subsystem = "1"b */
  4    41     2 definitions_info_ptr ptr;
  4    42 
  4    43 dcl  amu_area area based (amu_info.area_ptr);
  4    44 
  4    45 dcl  amu_info_ptr pointer;
  4    46 
  4    47 dcl (FDUMP_TYPE		init (1037),		/* the various legitimate types of amu_info's */
  4    48      FDUMP_PROCESS_TYPE	init (1038),
  4    49      ONLINE_TYPE		init (1039),
  4    50      ONLINE_PROCESS_TYPE	init (1040),
  4    51      NETWORK_FDUMP_TYPE	init (1041),
  4    52      NETWORK_ONLINE_TYPE	init (1042),
  4    53      SAVED_PROC_TYPE	init (1043),
  4    54      INDIRECT_TYPE		init (1044)) fixed bin internal static options (constant);
  4    55 
  4    56 dcl  AMU_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_v1");
  4    57 dcl  AMU_INFO_VERSION char (8) internal static options (constant) init ("amu_v1");
  4    58 dcl  AMU_INFO_VERSION_2 char (8) internal static options (constant) init ("amu_v2");
  4    59 
  4    60 dcl  PDIR_SUFFIX		char(4) init("pdir") int static options(constant);
  4    61 
  4    62 /*	END INCLUDE FILE amu_info.incl.pl1		*/
      448 
      449 
  5     1 /*	BEGIN INCLUDE FILE amu_hardcore_info.incl.pl1	*/
  5     2 
  5     3 /* This structure contains information about the hardcore supervisor address
  5     4*   space for an address translation. */
  5     5 
  5     6 dcl 1 hardcore_info aligned based (amu_info.hardcore_info_ptr),
  5     7 
  5     8     2 pointers,					/* assorted pointers to various useful items */
  5     9       3 slt aligned,				/* SLT */
  5    10         4 fptr pointer unaligned,			/* address in foreign address space */
  5    11         4 lptr pointer unaligned,			/* location in local address space */
  5    12       3 sltnt aligned like hardcore_info.slt,		/* SLT names segment */
  5    13       3 definitions aligned like hardcore_info.slt,	/* hardcore definitions_ segment */
  5    14 
  5    15       3 sst aligned like hardcore_info.slt,		/* SST */
  5    16       3 tc_data aligned like hardcore_info.slt,		/* TC_DATA */
  5    17       3 sstnt aligned like hardcore_info.slt,		/* SSTNT (if any -- foreign_ptr = null if not) */
  5    18       3 upt aligned like hardcore_info.slt,		/* unpaged_page_tables (if any -- foreign_ptr = null if not) */
  5    19 
  5    20     2 segno,					/* segment numbers of various per-process/per-processor segs */
  5    21       3 prds fixed bin (15),				/* segno of PRDS */
  5    22       3 dseg fixed bin (15),				/* DSEG */
  5    23       3 pds fixed bin (15),				/* PDS */
  5    24       3 kst fixed bin (15),				/* KST */
  5    25       3 stack_0 fixed bin (15),			/* segno of stack_0 -- first one in stack group */
  5    26       3 unpaged_page_tables fixed bin(15),		/* segno of unpaged_page_tables if it exists */
  5    27 
  5    28     2 apt,					/* information about the APT */
  5    29       3 foreign_ptr pointer unaligned,			/* foreign and local pointers to tcm.apt */
  5    30       3 local_ptr pointer unaligned,
  5    31       3 count fixed bin,				/* number of APTEs */
  5    32       3 size fixed bin,				/* size of a single APTE */
  5    33 
  5    34     2 hcs_count fixed bin,				/* highest hardcore segno */
  5    35 
  5    36     2 pad1 fixed bin;
  5    37 
  5    38 dcl hardcore_cur_ptr ptr;
  5    39 
  5    40 dcl 1 hardcore_cur based (hardcore_cur_ptr),
  5    41     2 sltp ptr,
  5    42     2 sltntp ptr,
  5    43     2 defp ptr,
  5    44     2 sstp ptr,
  5    45     2 tc_datap ptr,
  5    46     2 sstntp ptr,
  5    47     2 uptp ptr;
  5    48 	
  5    49     
  5    50 
  5    51 
  5    52 /*	END INCLUDE FILE amu_hardcore_info.incl.pl1	*/
      450 
      451 
  6     1 /* BEGIN INCLUDE FILE ... bos_dump.incl.pl1 ... */
  6     2 /* Modified 1 September 1976 */
  6     3 /* Modified 11/11/80 by J. A. Bush for the DPS8/70M CPU */
  6     4 /* Modified 6/12/81 by Rich Coppola to extend the dps8 extended fault reg to 
  6     5*   15 bits  */
  6     6 /* Modified 02/23/81, W. Olin Sibert, to describe old and new FDUMP styles */
  6     7 
  6     8 
  6     9 dcl  dumpptr ptr;					/* pointer to following structure */
  6    10 
  6    11 dcl 1 dump based (dumpptr) aligned,			/* header of dump by fdump */
  6    12     2 dump_header aligned like dump_header,
  6    13 
  6    14     2 segs (1008),					/* segment array */
  6    15       3 segno bit (18) unal,				/* segment number */
  6    16       3 length bit (18) unal, 			/* length of segment in sector sized blocks */
  6    17 
  6    18     2 amptwregs (0 : 63) bit (36),			/* assoc. mem. page table word regs */
  6    19     2 amptwptrs (0 : 63) bit (36),			/* assoc. mem. page table word pointers */
  6    20     2 amsdwregs (0 : 63) bit (72),			/* assoc. mem. segment descriptor word registers */
  6    21     2 amsdwptrs (0 : 63) bit (36),			/* assoc. mem. segment descriptor word pointers */
  6    22 
  6    23     2 ouhist (0 : 63) bit (72), 			/* operations unit history registers */
  6    24     2 cuhist (0 : 63) bit (72), 			/* control unit history registers */
  6    25     2 duhist (0 : 63) bit (72), 			/* decimal unit history registers */
  6    26     2 auhist (0 : 63) bit (72), 			/* appending unit history registers */
  6    27 
  6    28     2 prs (0 : 7) ptr,				/* pointer registers */
  6    29 
  6    30     2 regs aligned like dump_registers, 		/* assorted machine registers */
  6    31 
  6    32     2 low_order_port bit (3), 			/* from which clock is read */
  6    33     2 pad4 bit (36),
  6    34     2 mctime fixed bin (52),				/* time conditions were taken */
  6    35     2 pad5 (0 : 3) bit (36),
  6    36 
  6    37     2 misc_registers like dump_misc_registers,		/* Assorted registers & processor data */
  6    38 
  6    39     2 ptrlen (0 : 7) bit (36),			/* pointers and lengths for EIS */
  6    40 
  6    41     2 coreblocks (0 : 7),
  6    42       3 num_first bit (18) unal,			/* first addr in coreblock */
  6    43       3 num_blocks bit (18) unal,			/* number of blocks used */
  6    44     2 pad7 (112) fixed bin;
  6    45 
  6    46 
  6    47 dcl 1 dump_header aligned based,			/* Standard header for FDUMP */
  6    48     2 words_dumped fixed bin (35),			/* total words in dump */
  6    49     2 valid bit (1),				/* = 1 if there is a 6180 dump to be had */
  6    50     2 time fixed bin (71),				/* time of dump */
  6    51     2 erfno fixed bin (18),				/* Error Report Form Number */
  6    52     2 num_segs fixed bin,				/* number of segments dumped */
  6    53     2 valid_355 bit (1),				/* = 1 if there is a dn355 dump to be had */
  6    54     2 dumped_355s bit (4),				/* indicates which 355s were dumped */
  6    55     2 time_355 fixed bin (71),			/* time of 355 dump */
  6    56     2 version fixed bin,				/* currently 2 */
  6    57     2 pad0 (5) fixed bin;				/* pad0 to 16 words */
  6    58 
  6    59 dcl 1 dump_registers aligned based,			/* Standard (SREG) arrangement of registers in dump */
  6    60    (2 x (0 : 7) bit (18),				/* index registers */
  6    61     2 a bit (36),					/* the a register */
  6    62     2 q bit (36),					/* the q register */
  6    63     2 e bit (8),					/* the e register */
  6    64     2 pad2 bit (28),				/* pad */
  6    65     2 t bit (27),					/* timer register */
  6    66     2 pad3 bit (6), 				/* pad */
  6    67     2 ralr bit (3)) unaligned;			/* ring alarm register */
  6    68 
  6    69 dcl 1 dump_misc_registers aligned based,
  6    70     2 scu (0 : 7) bit (36),				/* from store control unit instr. */
  6    71     2 mcm (0 : 7) bit (72),				/* memory controller masks every 64 K */
  6    72     2 dbr bit (72), 				/* descriptor segment base register */
  6    73     2 intrpts bit (36),				/* interrupts */
  6    74     2 bar bit (36), 				/* base address register */
  6    75     2 modereg bit (36),				/* mode register */
  6    76     2 cmodereg bit (36),				/* cache mode register */
  6    77     2 faultreg bit (36),				/* fault register */
  6    78     2 ext_fault_reg bit (15) unaligned,			/* DPS8 extended fault register */
  6    79     2 pad6 bit (21) unaligned;
  6    80     
  6    81     
  6    82 
  6    83 dcl 1 v1_dump aligned based (dumpptr),			/* Old version of FDUMP (pre March, 1981) */
  6    84     2 dump_header aligned like dump_header,
  6    85 
  6    86     2 segs (688),					/* segment array */
  6    87       3 segno bit (18) unal,				/* segment number */
  6    88       3 length bit (18) unal, 			/* length of segment in sector sized blocks */
  6    89 
  6    90     2 amsdwregs (0 : 15) bit (72),			/* assoc. mem. segment descriptor word registers */
  6    91     2 amsdwptrs (0 : 15) bit (36),			/* assoc. mem. segment descriptor word pointers */
  6    92     2 amptwregs (0 : 15) bit (36),			/* assoc. mem. page table word regs */
  6    93     2 amptwptrs (0 : 15) bit (36),			/* assoc. mem. page table word pointers */
  6    94     2 pad1 (0 : 15) bit (36),
  6    95 
  6    96     2 ouhist (0 : 15) bit (72), 			/* operations unit history registers */
  6    97     2 cuhist (0 : 15) bit (72), 			/* control unit history registers */
  6    98     2 auhist (0 : 15) bit (72), 			/* appending unit history registers */
  6    99     2 duhist (0 : 15) bit (72), 			/* decimal unit history registers */
  6   100 
  6   101     2 prs (0 : 7) ptr,				/* pointer registers */
  6   102 
  6   103     2 regs aligned like dump_registers, 		/* assorted machine registers */
  6   104 
  6   105     2 mctime fixed bin (52),				/* time conditions were taken */
  6   106     2 pad4 (0 : 5) bit (36),
  6   107 
  6   108     2 misc_registers aligned like dump_misc_registers,	/* Assorted registers */
  6   109 
  6   110     2 pad5 bit (36),
  6   111     2 ptrlen (0 : 7) bit (36),			/* pointers and lengths for EIS */
  6   112     2 pad6 (15) bit (36),
  6   113     2 low_order_port bit (3), 			/* from which clock was read */
  6   114 
  6   115     2 coreblocks (0 : 7),
  6   116       3 num_first bit (18) unal,			/* first addr in coreblock */
  6   117       3 num_blocks bit (18) unal;			/* number of blocks used */
  6   118 
  6   119 
  6   120 dcl  DUMP_VERSION_1 fixed bin internal static options (constant) init (1);
  6   121 dcl  DUMP_VERSION_2 fixed bin internal static options (constant) init (2);
  6   122 
  6   123 /* END INCLUDE FILE ... bos_dump.incl.pl1 ... */
      452 
      453 
  7     1 /*	BEGIN INCLUDE FILE amu_fdump_info.incl.pl1	*/
  7     2 
  7     3 dcl 1 fdump_info aligned based (amu_info.fdump_info_ptr),
  7     4     2 version char (8),
  7     5     2 ref_count fixed bin,				/* number of initiations */
  7     6 
  7     7     2 erf_name char (32),				/* ERF name for this dump */
  7     8     2 dump_dname char (168),				/* location of the dump */
  7     9     2 dump_ename char (32),				/* ename of component zero */
  7    10     2 system_id char (8),				/* the system_id of this erf */
  7    11     2 version_id char (8),				/* the version id of this erf */
  7    12     2 dump_seg_0_uid bit (36) aligned,			/* for determining EQ-ness and gullibility checking */
  7    13 
  7    14     2 n_dump_segs fixed bin,				/* number of real segs in the dump */
  7    15     2 copy_block_ptr pointer, 			/* pointer to chain of temp segment blocks */
  7    16 
  7    17     2 dump_seg_ptr (0:31) pointer,			/* pointer and length arrays */
  7    18     2 dump_seg_lth (0:31) fixed bin (18),
  7    19 
  7    20     2 fdump_process_table_ptr pointer;			/* pointer to array describing processes */
  7    21 
  7    22 
  7    23 dcl 1 fdump_process_table aligned based (fdump_info.fdump_process_table_ptr),
  7    24     2 size fixed bin,				/* number of entries */
  7    25 
  7    26     2 array (0:alloc_fdump_process_table_size - 1 refer (fdump_process_table.size)) like fp_table;
  7    27 
  7    28 dcl 1 fp_table based (fp_table_ptr),
  7    29       2 first_seg fixed bin,
  7    30       2 last_seg fixed bin,
  7    31       2 process_info_ptr pointer unaligned,		/* pointer to process_info structure, if filled in */
  7    32       2 dmp_seg_indx fixed bin,			/* dump seg index where process can be found */
  7    33       2 dmp_seg_offset fixed bin (24),			/* offset in the segment refered to by dmp_seg_indx where process starts */
  7    34       2 cpu_name char (1),
  7    35       2 dbr fixed bin (24),				/* address portion of DBR */
  7    36       2 apte_offset fixed bin (18);
  7    37 
  7    38 dcl fp_table_ptr ptr;
  7    39 
  7    40 dcl  alloc_fdump_process_table_size fixed bin;
  7    41 
  7    42 dcl  AMU_FDUMP_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_erf1");
  7    43 dcl  AMU_FDUMP_INFO_VERSION char (8) internal static options (constant) init ("amu_erf1");
  7    44 
  7    45 /*	END INCLUDE FILE amu_fdump_info.incl.pl1	*/
      454 
      455 
      456 
      457      end azm_display_am_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/84  1440.1  azm_display_am_.pl1               >special_ldd>online>6897-11/15/84>azm_display_am_.pl1
442          1    08/12/81  2025.7  assoc_mem.incl.pl1                >ldd>include>assoc_mem.incl.pl1
444          2    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
446          3    05/03/78  1422.1  ptw.incl.pl1                      >ldd>include>ptw.incl.pl1
448          4    11/15/84  1524.3  amu_info.incl.pl1                 >special_ldd>online>6897-11/15/84>amu_info.incl.pl1
450          5    11/15/84  1437.4  amu_hardcore_info.incl.pl1        >special_ldd>online>6897-11/15/84>amu_hardcore_info.incl.pl1
452          6    08/12/81  2025.8  bos_dump.incl.pl1                 >ldd>include>bos_dump.incl.pl1
454          7    09/22/83  1102.5  amu_fdump_info.incl.pl1           >ldd>include>amu_fdump_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AM_LEVEL                        000000 constant        char(1)                  initial array unaligned dcl 73 set ref 190* 257*
DPS8xxM                         000100 automatic       bit(1)                   unaligned dcl 34 set ref 149 179 189 219 244 256
                                                                                  342* 347* 367 384 417 429
IDX                             000101 automatic       fixed bin(17,0)          dcl 35 set ref 165* 190* 233* 257*
P_amu_info_ptr                         parameter       pointer                  dcl 21 ref 9 106
P_code                                 parameter       fixed bin(35,0)          dcl 23 set ref 9 108* 316* 327*
P_sci_ptr                              parameter       pointer                  dcl 22 ref 9 107
addr                                                   builtin function         dcl 99 in procedure "azm_display_am_" ref 306 307
                                                                                  308 309
addr                                   based           bit(24)                  array level 2 in structure "sdw_regs" packed
                                                                                  unaligned dcl 82 in procedure "azm_display_am_"
                                                                                  ref 261 261 406 406 425 425
addr                                   based           bit(18)                  array level 2 in structure "ptw_regs" packed
                                                                                  unaligned dcl 80 in procedure "azm_display_am_"
                                                                                  ref 194 194 361 361 382 382
addrel                                                 builtin function         dcl 99 ref 169 333 334 335 339
amptwptr                               based           structure                level 1 dcl 1-11
amptwptrs              2100            based           bit(36)                  array level 2 dcl 6-11 set ref 309
amptwreg                               based           structure                level 1 dcl 1-4
amptwregs              2000            based           bit(36)                  array level 2 dcl 6-11 set ref 308
amsdwptr                               based           structure                level 1 dcl 1-38
amsdwptrs              2400            based           bit(36)                  array level 2 dcl 6-11 set ref 307
amsdwreg                               based           structure                level 1 dcl 1-19
amsdwregs              2200            based           bit(72)                  array level 2 dcl 6-11 set ref 306
amu_$definition_ptr             000010 constant        entry                    external dcl 87 ref 314
amu_$do_translation             000012 constant        entry                    external dcl 88 ref 292
amu_$fdump_mpt_revert_idx       000016 constant        entry                    external dcl 90 ref 294
amu_$fdump_mpt_temp_change_idx  000014 constant        entry                    external dcl 89 ref 290
amu_$get_name                   000020 constant        entry                    external dcl 91 ref 194
amu_$get_name_no_comp           000022 constant        entry                    external dcl 92 ref 261
amu_$return_val_per_process     000024 constant        entry                    external dcl 93 ref 288
amu_info                               based           structure                level 1 dcl 4-3
amu_info_ptr                    000174 automatic       pointer                  dcl 4-45 set ref 106* 194* 261* 288* 290* 290 290
                                                                                  292* 294* 305 314*
any_other                       000166 stack reference condition                dcl 103 ref 111
array                     1            based           structure                array level 2 dcl 7-23 ref 290 290
atptw                                  based           structure                level 1 dcl 3-35
baseno                                                 builtin function         dcl 99 ref 320
baseptr                                                builtin function         dcl 99 ref 169 248
binary                                                 builtin function         dcl 99 ref 169 169 177 179 179 194 194 194 194 194
                                                                                  194 244 244 248 261 261 261 261 261 261 261 261
bound                     1(01)        based           bit(14)                  array level 2 packed unaligned dcl 82 ref 261 261
                                                                                  425 425
cache                     1(21)        based           bit(1)                   array level 2 packed unaligned dcl 82 set ref 239*
cl                        1(22)        based           bit(14)                  array level 2 packed unaligned dcl 82 ref 261 261
code                            000102 automatic       fixed bin(35,0)          dcl 36 set ref 292* 303* 314* 315 316 326 327
data_buf_ptr                    000104 automatic       pointer                  initial dcl 37 set ref 37* 109* 135 135* 322* 324*
                                                                                  328 328* 332
data_ptr                               parameter       pointer                  dcl 286 set ref 283 292*
divide                                                 builtin function         dcl 99 ref 177 194 194
dump                                   based           structure                level 1 dcl 6-11
dump_header                            based           structure                level 1 dcl 6-47
dump_misc_registers                    based           structure                level 1 dcl 6-69
dump_registers                         based           structure                level 1 dcl 6-59
dump_seg_ptr            106            based           pointer                  array level 2 dcl 7-3 ref 305
dumpptr                         000176 automatic       pointer                  dcl 6-9 set ref 305* 306 307 308 309
dup_entry                       000106 automatic       bit(1)                   array unaligned dcl 38 set ref 194* 261* 356* 362*
                                                                                  363* 368* 369* 375* 376* 381 381 386* 386* 400*
                                                                                  407* 408* 412* 413* 418* 419* 424 424 431* 431*
entry_bound_sw            1(20)        based           bit(1)                   array level 2 packed unaligned dcl 82 set ref 239*
                                                                                  261
execute                   1(16)        based           bit(1)                   array level 2 packed unaligned dcl 82 set ref 239*
                                                                                  261
fdump_info                             based           structure                level 1 dcl 7-3
fdump_info_ptr           14            based           pointer                  level 2 dcl 4-3 ref 290 290 305
fdump_process_table                    based           structure                level 1 dcl 7-23
fdump_process_table_ptr
                        246            based           pointer                  level 2 dcl 7-3 ref 290 290
first                           000110 automatic       fixed bin(18,0)          dcl 39 set ref 321* 324*
first_entry                     000111 automatic       fixed bin(17,0)          dcl 40 set ref 146* 167 205* 206 216* 235 275* 276
first_level                     000112 automatic       fixed bin(17,0)          dcl 41 set ref 150* 155* 165 220* 225* 233
fixed                                                  builtin function         dcl 99 ref 175 238 320 321
flag_string                     000114 automatic       char(7)                  unaligned dcl 42 set ref 239* 261*
fp_table                               based           structure                level 1 unaligned dcl 7-28
hardcore_info                          based           structure                level 1 dcl 5-6
i                               000116 automatic       fixed bin(17,0)          dcl 43 set ref 358* 359 360 361 362 366 368 373 373
                                                                                  375 381 382 382 385 386* 402* 403 404 406 407 411
                                                                                  412 416 418 424 425 425 425 425 425 430 431*
idx                             000117 automatic       fixed bin(17,0)          dcl 44 set ref 167* 169 169 173 175 177 179 179 182
                                                                                  194 194 194 194 194 194 194 194 194 194* 235* 236
                                                                                  238 239 239 239 239 239 239 239 244 244 247 248
                                                                                  261 261 261 261 261 261 261 261 261 261 261 261
                                                                                  261 261 261 261*
index_changed                   000120 automatic       bit(1)                   initial unaligned dcl 45 set ref 45* 289* 293 295*
ioa_                            000032 constant        entry                    external dcl 96 ref 117 129 184 185 190 194 251 252
                                                                                  257 261
ioa_$rsnnl                      000034 constant        entry                    external dcl 97 ref 179 182 239 244 247
j                               000121 automatic       fixed bin(17,0)          dcl 46 set ref 359* 360 361 363 366 369 373 373 376
                                                                                  381 382 382 385 386* 403* 404 406 408 411 413 416
                                                                                  419 424 425 425 425 425 425 430 431*
last_entry                      000122 automatic       fixed bin(17,0)          dcl 47 set ref 147* 167 205 206* 217* 235 275 276*
last_level                      000123 automatic       fixed bin(17,0)          dcl 48 set ref 151* 156* 165 221* 226* 233
last_three_sets                        based           bit(1728)                unaligned dcl 79 ref 340
lbound                                                 builtin function         dcl 99 ref 290 290
modif                     0(29)        based           bit(1)                   array level 2 packed unaligned dcl 80 set ref 194*
nregs                           000124 automatic       fixed bin(17,0)          dcl 49 set ref 341* 346* 358 359 402 403
null                                                   builtin function         dcl 99 ref 37 52 58 68 109 135 328
number                                 parameter       fixed bin(18,0)          dcl 287 set ref 283 292*
only_fulls                             parameter       bit(1)                   unaligned dcl 27 ref 9 173 236
pageno                    0(15)        based           bit(12)                  array level 2 packed unaligned dcl 81 ref 169 177
                                                                                  194 194 373 373
pageno_sw                       000126 automatic       bit(1)                   initial unaligned dcl 51 set ref 51* 127 161* 177
pointer                                based           bit(15)                  array level 2 in structure "sdw_ptrs" packed
                                                                                  unaligned dcl 83 in procedure "azm_display_am_"
                                                                                  ref 238 248 261 261 411 411 425 425
pointer                                based           bit(15)                  array level 2 in structure "ptw_ptrs" packed
                                                                                  unaligned dcl 81 in procedure "azm_display_am_"
                                                                                  ref 169 175 194 194 373 373 382 382
pointers                               based           structure                level 2 dcl 5-6
prds_sw                                parameter       bit(1)                   unaligned dcl 24 ref 9 117 129 184 251 304
privileged                1(18)        based           bit(1)                   array level 2 packed unaligned dcl 82 set ref 239*
ptr_ptr                         000130 automatic       pointer                  initial dcl 52 set ref 52*
ptw                                    based           structure                level 1 dcl 3-5
ptw_hdr_printed                 000132 automatic       bit(1)                   unaligned dcl 53 set ref 163* 183 186*
ptw_level_printed               000133 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 163* 166* 189
                                                                                  191*
ptw_pageno                             parameter       fixed bin(17,0)          dcl 29 set ref 9 128 129* 161 177
ptw_ptrs                               based           structure                array level 1 dcl 81
ptw_ptrs_ptr                    000134 automatic       pointer                  dcl 55 set ref 169 169 173 175 177 179 179 182 194
                                                                                  194 194 194 194 194 309* 333* 334 360 360 366 366
                                                                                  373 373 373 373 382 382 385 385
ptw_regs                               based           structure                array level 1 dcl 80
ptw_regs_ptr                    000136 automatic       pointer                  dcl 56 set ref 194 194 194 308* 332* 333 339 361 361
                                                                                  382 382
ptw_sw                                 parameter       bit(1)                   unaligned dcl 26 set ref 9 124 128* 129* 129
ptws_printed                    000125 automatic       bit(1)                   initial unaligned dcl 50 set ref 50* 126 201*
r1                        0(24)        based           bit(3)                   array level 2 packed unaligned dcl 82 set ref 261*
r2                        0(27)        based           bit(3)                   array level 2 packed unaligned dcl 82 set ref 261*
                                                                                  425 425
r3                        0(30)        based           bit(3)                   array level 2 packed unaligned dcl 82 set ref 261*
                                                                                  425 425
range                           000140 automatic       fixed bin(18,0)          dcl 57 set ref 313* 324*
read                      1(15)        based           bit(1)                   array level 2 packed unaligned dcl 82 set ref 239*
reg_ptr                         000142 automatic       pointer                  initial dcl 58 set ref 58*
rel                                                    builtin function         dcl 99 ref 321
sci_ptr                         000144 automatic       pointer                  dcl 59 set ref 107* 135* 322* 328*
sdw                                    based           structure                level 1 dcl 2-5
sdw_hdr_printed                 000146 automatic       bit(1)                   unaligned dcl 60 set ref 232* 250 253*
sdw_level_printed               000147 automatic       bit(1)                   initial unaligned dcl 61 set ref 61* 232* 234* 256
                                                                                  258*
sdw_ptrs                               based           structure                array level 1 dcl 83
sdw_ptrs_ptr                    000150 automatic       pointer                  dcl 62 set ref 236 238 244 244 247 248 261 261 261
                                                                                  261 307* 335* 404 404 411 411 416 416 425 425 430
                                                                                  430
sdw_regs                               based           structure                array level 1 dcl 82
sdw_regs_ptr                    000152 automatic       pointer                  dcl 63 set ref 239 239 239 239 239 239 239 261 261
                                                                                  261 261 261 261 261 261 261 261 261 306* 334* 335
                                                                                  406 406 425 425 425 425 425 425 425 425
sdw_segno                              parameter       fixed bin(17,0)          dcl 28 set ref 9 117* 129 129* 162 175 231 238
sdw_sw                                 parameter       bit(1)                   unaligned dcl 25 set ref 9 114 127 129*
sdws_printed                    000154 automatic       bit(1)                   initial unaligned dcl 64 set ref 64* 116 271*
seg                                    parameter       fixed bin(17,0)          dcl 285 set ref 283 288* 292*
seg_ptr                         000156 automatic       pointer                  dcl 65 set ref 169* 194*
segno                           000160 automatic       fixed bin(17,0)          dcl 66 set ref 320* 324*
segno_sw                        000161 automatic       bit(1)                   initial unaligned dcl 67 set ref 67* 117 162* 175
                                                                                  231* 238
slt                                    based           structure                level 3 dcl 5-6
ssu_$get_temp_segment           000026 constant        entry                    external dcl 94 ref 322
ssu_$release_temp_segment       000030 constant        entry                    external dcl 95 ref 135 328
temp_ptr                        000162 automatic       pointer                  initial dcl 68 set ref 68* 248* 261* 314* 320 321
                                                                                  339* 340
unpaged                   1(19)        based           bit(1)                   array level 2 packed unaligned dcl 82 set ref 239*
usage                     0(32)        based           bit(4)                   array level 2 in structure "ptw_ptrs" packed
                                                                                  unaligned dcl 81 in procedure "azm_display_am_"
                                                                                  set ref 179 179 182* 366 366 385 385
usage                     0(32)        based           bit(4)                   array level 2 in structure "sdw_ptrs" packed
                                                                                  unaligned dcl 83 in procedure "azm_display_am_"
                                                                                  set ref 244 244 247* 416 416 430 430
usage_string                    000164 automatic       char(8)                  unaligned dcl 69 set ref 179* 182* 194* 244* 247*
                                                                                  261*
valid                     0(27)        based           bit(1)                   array level 2 in structure "sdw_ptrs" packed
                                                                                  unaligned dcl 83 in procedure "azm_display_am_"
                                                                                  set ref 236 261* 261* 404 404
valid                     0(27)        based           bit(1)                   array level 2 in structure "ptw_ptrs" packed
                                                                                  unaligned dcl 81 in procedure "azm_display_am_"
                                                                                  set ref 173 194* 194* 360 360
word                                   parameter       fixed bin(18,0)          dcl 287 set ref 283 292*
write                     1(17)        based           bit(1)                   array level 2 packed unaligned dcl 82 set ref 239*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AMU_FDUMP_INFO_VERSION                 internal static char(8)                  initial unaligned dcl 7-43
AMU_FDUMP_INFO_VERSION_1               internal static char(8)                  initial unaligned dcl 7-42
AMU_INFO_VERSION                       internal static char(8)                  initial unaligned dcl 4-57
AMU_INFO_VERSION_1                     internal static char(8)                  initial unaligned dcl 4-56
AMU_INFO_VERSION_2                     internal static char(8)                  initial unaligned dcl 4-58
DUMP_VERSION_1                         internal static fixed bin(17,0)          initial dcl 6-120
DUMP_VERSION_2                         internal static fixed bin(17,0)          initial dcl 6-121
FDUMP_PROCESS_TYPE                     internal static fixed bin(17,0)          initial dcl 4-47
FDUMP_TYPE                             internal static fixed bin(17,0)          initial dcl 4-47
INDIRECT_TYPE                          internal static fixed bin(17,0)          initial dcl 4-47
NETWORK_FDUMP_TYPE                     internal static fixed bin(17,0)          initial dcl 4-47
NETWORK_ONLINE_TYPE                    internal static fixed bin(17,0)          initial dcl 4-47
ONLINE_PROCESS_TYPE                    internal static fixed bin(17,0)          initial dcl 4-47
ONLINE_TYPE                            internal static fixed bin(17,0)          initial dcl 4-47
PDIR_SUFFIX                            internal static char(4)                  initial unaligned dcl 4-60
SAVED_PROC_TYPE                        internal static fixed bin(17,0)          initial dcl 4-47
alloc_fdump_process_table_size         automatic       fixed bin(17,0)          dcl 7-40
amu_area                               based           area(1024)               dcl 4-43
atptwa                                 based           structure                array level 1 dcl 3-40
fp_table_ptr                           automatic       pointer                  dcl 7-38
hardcore_cur                           based           structure                level 1 unaligned dcl 5-40
hardcore_cur_ptr                       automatic       pointer                  dcl 5-38
mptw                                   based           structure                level 1 dcl 3-27
mptwa                                  based           structure                array level 1 dcl 3-31
ptp                                    automatic       pointer                  dcl 3-3
ptwa                                   based           structure                array level 1 dcl 3-23
ptwa_bits                              based           bit(36)                  array dcl 3-25
sdwa                                   based           structure                array level 1 dcl 2-24
sdwp                                   automatic       pointer                  dcl 2-3
v1_dump                                based           structure                level 1 dcl 6-83

NAMES DECLARED BY EXPLICIT CONTEXT.
azm_display_am_                 000362 constant        entry                    external dcl 9
bypass_ptw                      001272 constant        label                    dcl 202 ref 173 175 177
bypass_sdw                      002065 constant        label                    dcl 272 ref 236 238
cancel_dup_ptw                  002563 constant        label                    dcl 386 ref 384
cancel_dup_sdw                  003021 constant        label                    dcl 431 ref 429
display_ptw                     000634 constant        entry                    internal dcl 143 ref 125
display_sdw                     001304 constant        entry                    internal dcl 213 ref 115
done                            000616 constant        label                    dcl 135 ref 111
get_data_                       002077 constant        entry                    internal dcl 283 ref 324
set_up                          002172 constant        entry                    internal dcl 300 ref 113
validate_am_ptw                 002374 constant        entry                    internal dcl 353 ref 159
validate_am_sdw                 002576 constant        entry                    internal dcl 397 ref 229

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3232        3270    3047        3242
Length      3632    3047        36         326     162           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
azm_display_am_                     566 external procedure  is an external procedure.  
on unit on line 111                  64 on unit               
display_ptw                             internal procedure  shares stack frame of external procedure azm_display_am_.  
display_sdw                             internal procedure  shares stack frame of external procedure azm_display_am_.  
get_data_                               internal procedure  shares stack frame of external procedure azm_display_am_.  
set_up                                  internal procedure  shares stack frame of external procedure azm_display_am_.  
validate_am_ptw                         internal procedure  shares stack frame of external procedure azm_display_am_.  
validate_am_sdw                         internal procedure  shares stack frame of external procedure azm_display_am_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
azm_display_am_          000100 DPS8xxM                     azm_display_am_
                         000101 IDX                         azm_display_am_
                         000102 code                        azm_display_am_
                         000104 data_buf_ptr                azm_display_am_
                         000106 dup_entry                   azm_display_am_
                         000110 first                       azm_display_am_
                         000111 first_entry                 azm_display_am_
                         000112 first_level                 azm_display_am_
                         000114 flag_string                 azm_display_am_
                         000116 i                           azm_display_am_
                         000117 idx                         azm_display_am_
                         000120 index_changed               azm_display_am_
                         000121 j                           azm_display_am_
                         000122 last_entry                  azm_display_am_
                         000123 last_level                  azm_display_am_
                         000124 nregs                       azm_display_am_
                         000125 ptws_printed                azm_display_am_
                         000126 pageno_sw                   azm_display_am_
                         000130 ptr_ptr                     azm_display_am_
                         000132 ptw_hdr_printed             azm_display_am_
                         000133 ptw_level_printed           azm_display_am_
                         000134 ptw_ptrs_ptr                azm_display_am_
                         000136 ptw_regs_ptr                azm_display_am_
                         000140 range                       azm_display_am_
                         000142 reg_ptr                     azm_display_am_
                         000144 sci_ptr                     azm_display_am_
                         000146 sdw_hdr_printed             azm_display_am_
                         000147 sdw_level_printed           azm_display_am_
                         000150 sdw_ptrs_ptr                azm_display_am_
                         000152 sdw_regs_ptr                azm_display_am_
                         000154 sdws_printed                azm_display_am_
                         000156 seg_ptr                     azm_display_am_
                         000160 segno                       azm_display_am_
                         000161 segno_sw                    azm_display_am_
                         000162 temp_ptr                    azm_display_am_
                         000164 usage_string                azm_display_am_
                         000174 amu_info_ptr                azm_display_am_
                         000176 dumpptr                     azm_display_am_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   call_ext_out        return              tra_ext             enable
shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$definition_ptr           amu_$do_translation           amu_$fdump_mpt_revert_idx
amu_$fdump_mpt_temp_change_idx                              amu_$get_name                 amu_$get_name_no_comp
amu_$return_val_per_process   ioa_                          ioa_$rsnnl                    ssu_$get_temp_segment
ssu_$release_temp_segment

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      9 000353        37 000367        45 000371        50 000372        51 000373        52 000374        54 000375
     58 000376        61 000377        64 000400        67 000401        68 000402       106 000403       107 000407
    108 000412       111 000413       113 000432       114 000433       115 000441       116 000442       117 000444
    124 000502       125 000510       126 000511       127 000513       128 000523       129 000533       135 000616
    137 000633       143 000634       146 000635       147 000636       149 000640       150 000642       151 000644
    152 000646       155 000647       156 000651       159 000652       161 000653       162 000661       163 000666
    165 000670       166 000677       167 000700       169 000707       173 000725       175 000737       177 000744
    179 000752       182 001010       183 001042       184 001044       185 001074       186 001110       189 001112
    190 001116       191 001142       194 001144       201 001267       202 001272       205 001274       206 001277
    208 001301       209 001303       213 001304       216 001305       217 001306       219 001310       220 001312
    221 001314       222 001316       225 001317       226 001321       229 001322       231 001323       232 001331
    233 001333       234 001343       235 001344       236 001353       238 001364       239 001372       244 001466
    247 001525       248 001560       250 001566       251 001570       252 001620       253 001634       256 001636
    257 001642       258 001666       261 001670       271 002062       272 002065       275 002067       276 002072
    278 002074       279 002076       283 002077       288 002101       289 002120       290 002122       292 002134
    293 002156       294 002161       295 002170       297 002171       300 002172       303 002173       304 002174
    305 002202       306 002206       307 002210       308 002212       309 002214       310 002216       313 002217
    314 002221       315 002255       316 002257       317 002261       320 002262       321 002266       322 002271
    324 002315       326 002317       327 002321       328 002323       329 002340       332 002341       333 002343
    334 002346       335 002351       339 002354       340 002357       341 002363       342 002365       343 002366
    346 002367       347 002371       350 002373       353 002374       356 002375       358 002410       359 002417
    360 002427       361 002436       362 002445       363 002450       364 002454       366 002455       367 002465
    368 002467       369 002472       371 002475       373 002476       375 002516       376 002521       381 002524
    382 002534       384 002552       385 002554       386 002563       392 002571       393 002573       394 002575
    397 002576       400 002577       402 002612       403 002621       404 002631       406 002640       407 002656
    408 002661       409 002665       411 002666       412 002676       413 002701       414 002704       416 002705
    417 002714       418 002716       419 002721       424 002724       425 002734       429 003010       430 003012
    431 003021       437 003027       438 003031       439 003033


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
