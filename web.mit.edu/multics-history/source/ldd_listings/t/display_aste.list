	COMPILATION LISTING OF SEGMENT display_aste
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/18/86  1411.8 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 /* format: style2,indcomtxt,idind25 */
       12 display_aste:
       13      procedure;
       14 
       15 /* NSS VERSION, with get_temp_segments_, detailed AST printout, disk_table,
       16*   phcs_, -at, address interpretation, BSG 05-06/76 */
       17 /* Modified August 1982, E. N. Kittlitz. move the core_map out of sst. */
       18 /* Modified 84-01-21 BIM for rename, new features */
       19 /* Modified January 1985 by Keith Loepere to display multi_class. */
       20 /* Modified 1985-03-29, BIM: silly bug in CME flag display. */
       21 
       22 	dcl     arg		   char (argl) based (argp);
       23 	dcl     argl		   fixed bin (21);
       24 	dcl     argp		   ptr;
       25 	dcl     argx		   fixed bin;
       26 	dcl     n_args		   fixed bin;
       27 	dcl     (user_seg_count, first_user_seg)
       28 				   fixed bin;
       29 	declare ptp		   pointer;
       30 	declare ptwp		   pointer;
       31 	declare pt		   (0:255) bit (36) aligned based;
       32 	declare last_pte		   bit (36) aligned;
       33 	declare skipping		   bit (1) aligned;
       34 	declare time_string		   char (32);
       35 	declare octal		   bit (1) aligned;
       36 
       37 	dcl     (i, aste_offset, segno)  fixed bin;
       38 	dcl     pvname		   char (32);
       39 	dcl     diskname		   char (8);
       40 	dcl     code		   fixed bin (35);
       41 	dcl     fdevadd		   fixed bin (18);
       42 	dcl     cdevadd		   char (16);
       43 	dcl     ptwaddr		   fixed bin (18);
       44 	dcl     ll		   fixed bin;
       45 	dcl     1 sdw1		   like sdw aligned;
       46 	dcl     wpl		   fixed bin;
       47 	dcl     ptwbase		   fixed bin (24);
       48 	dcl     iox_$user_output	   ptr ext static;
       49 	dcl     check_gate_access_	   entry (character (*), pointer, fixed binary (35));
       50 	dcl     dump_segment_	   entry (pointer, pointer, fixed binary, fixed binary (18), fixed binary (18),
       51 				   bit (*));
       52 	dcl     expand_pathname_	   entry (character (*), character (*), character (*), fixed binary (35));
       53 	dcl     (dsp0, segptr, sstp0, cmp0, cmp)
       54 				   ptr;
       55 	dcl     sptp		   ptr;
       56 	dcl     cmap_length		   fixed bin (19);
       57 	dcl     pathname		   char (168);
       58 	dcl     dirname		   char (168);
       59 	dcl     myname		   char (20) static init ("display_aste") options (constant);
       60 	dcl     ename		   char (32);
       61 	dcl     pts		   fixed bin (3);
       62 	dcl     ptsizes		   (0:3) fixed bin init ((4) 0);
       63 	dcl     q			   (3) ptr init ((3) null ());
       64 	dcl     core_add		   fixed bin (18);
       65 	dcl     devadd		   bit (22);
       66 	dcl     devadd_add_type	   bit (4) defined (devadd) pos (19);
       67 	dcl     devadd_nulled_flag	   bit (1) defined (devadd);
       68 	dcl     devadd_record_no	   bit (18) defined (devadd);
       69 	dcl     last_ptw		   bit (36);
       70 	dcl     file_map_sw		   bit (1) aligned;
       71 	dcl     (force_slt, force_offset)
       72 				   bit (1) aligned;
       73 	dcl     rastap		   fixed bin;
       74 	dcl     sys_info$page_size	   fixed bin (35) external static;
       75 
       76 	dcl     (
       77 	        com_err_,
       78 	        com_err_$suppress_name,
       79 	        ioa_,
       80 	        ioa_$nnl,
       81 	        ioa_$rsnnl
       82 	        )			   ext entry options (variable);
       83 	dcl     mdc_$read_disk_table	   entry (ptr, fixed bin (35));
       84 	dcl     (get_temp_segments_, release_temp_segments_)
       85 				   entry (char (*), (*) ptr, fixed bin (35));
       86 	dcl     pathname_		   entry (char (*), char (*)) returns (char (168));
       87 	dcl     get_line_length_$switch  entry (ptr, fixed bin (35)) returns (fixed bin);
       88 	dcl     hcs_$high_low_seg_count  entry (fixed bin, fixed bin);
       89 	dcl     hcs_$fs_get_path_name	   entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
       90 	dcl     (
       91 	        hcs_$initiate,
       92 	        phcs_$initiate
       93 	        )			   entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr,
       94 				   fixed bin (35));
       95 	dcl     ring_zero_peek_	   entry (ptr, ptr, fixed bin (19), fixed bin (35));
       96 	dcl     ring_zero_peek_$get_max_length_ptr
       97 				   entry (ptr, fixed bin (19), fixed bin (35));
       98 	dcl     ring0_get_$segptr	   ext entry (char (*), char (*), ptr, fixed bin (35));
       99 	dcl     ring0_get_$name	   entry (char (*), char (*), ptr, fixed bin (35));
      100 	dcl     cu_$arg_count	   entry (fixed bin, fixed bin (35));
      101 	dcl     cu_$arg_ptr		   entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      102 	dcl     cv_oct_check_	   ext entry (char (*), fixed bin (35)) returns (fixed bin (35));
      103 	dcl     cv_oct_		   entry (char (*)) returns (fixed bin (35));
      104 	dcl     date_time_$format	   entry (character (*), fixed binary (71), character (*), character (*))
      105 				   returns (character (250) var);
      106 
      107 	dcl     error_table_$invalidsegno
      108 				   fixed bin (35) ext static;
      109 	dcl     error_table_$too_many_args
      110 				   fixed bin (35) ext static;
      111 	dcl     error_table_$noarg	   fixed bin (35) ext static;
      112 	dcl     error_table_$bad_conversion
      113 				   fixed bin (35) ext static;
      114 	dcl     error_table_$badopt	   fixed bin (35) ext static;
      115 
      116 	dcl     (addr, addrel, baseno, baseptr, fixed, length, ptr, rel, size, addwordno, bin, byte, copy, index, rtrim,
      117 	        search, string, substr, unspec, verify)
      118 				   builtin;
      119 	dcl     (cleanup, linkage_error) condition;
      120 
      121 
      122 	octal = "0"b;
      123 	q = null ();
      124 	on cleanup call release_temp_segments_ (myname, q, (0));
      125 
      126 	call cu_$arg_count (n_args, code);
      127 	if code ^= 0
      128 	then do;
      129 		call com_err_ (code, myname);
      130 		return;
      131 	     end;
      132 	if n_args = 0
      133 	then
      134 USAGE:
      135 	     do;
      136 		call com_err_$suppress_name (0, myname,
      137 		     "Usage: display_aste {pathname | -hardcore R0 segment name/number | -at sst_seg offset");
      138 		return;
      139 	     end;
      140 
      141 	pathname = "";
      142 	file_map_sw = "0"b;
      143 	force_slt = "0"b;
      144 	force_offset = "0"b;
      145 	aste_offset = 0;
      146 
      147 	do argx = 1 to n_args;
      148 	     call cu_$arg_ptr (argx, argp, argl, (0));
      149 	     if index (arg, "-") ^= 1
      150 	     then do;				/* positional path */
      151 		     if pathname ^= ""		/* true even for -off */
      152 		     then
      153 TOO_MANY:
      154 			do;
      155 			     call com_err_ (error_table_$too_many_args, myname,
      156 				"Only one segment specifier is permitted. ^a is the second.", arg);
      157 			     return;
      158 			end;
      159 		     pathname = arg;
      160 		end;
      161 	     else if arg = "-octal" | arg = "-oc"
      162 	     then octal = "1"b;
      163 	     else if arg = "-no_octal" | arg = "-noc"
      164 	     then octal = "0"b;
      165 	     else if arg = "-hardcore" | arg = "-hc"
      166 	     then do;
      167 		     if pathname ^= ""
      168 		     then go to TOO_MANY;
      169 		     if argx = n_args
      170 		     then call MISSING ("hardcore segment name/number following -hardcore");
      171 		     force_slt = "1"b;
      172 		     argx = argx + 1;
      173 		     call cu_$arg_ptr (argx, argp, argl, (0));
      174 		     pathname = arg;
      175 		end;
      176 	     else if arg = "-at" | arg = "-offset" | arg = "-off"
      177 	     then do;
      178 		     if pathname ^= ""
      179 		     then go to TOO_MANY;
      180 		     if argx = n_args
      181 		     then call MISSING ("offset following -at.");
      182 		     argx = argx + 1;
      183 		     call cu_$arg_ptr (argx, argp, argl, (0));
      184 		     force_offset = "1"b;
      185 		     pathname = "at offset " || arg;
      186 		     aste_offset = cv_oct_check_ (arg, code);
      187 		     if code ^= 0
      188 		     then do;
      189 			     call com_err_ (error_table_$bad_conversion, myname, "^a is not an octal offset.", arg);
      190 			     return;
      191 			end;
      192 		end;
      193 	     else if arg = "-file_map" | arg = "-fm"
      194 	     then file_map_sw = "1"b;
      195 	     else if arg = "-no_file_map" | arg = "-nfm"
      196 	     then file_map_sw = "0"b;
      197 	     else do;
      198 		     call com_err_ (error_table_$badopt, myname, "^a", arg);
      199 		     return;
      200 		end;
      201 	end;					/* the loop */
      202 
      203 	if pathname = ""
      204 	then go to USAGE;				/* not likely ... */
      205 
      206 	if ^force_offset & ^force_slt
      207 	then do;
      208 		call expand_pathname_ (pathname, dirname, ename, code);
      209 		if code ^= 0
      210 		then do;
      211 			call com_err_ (code, myname, "^a", pathname);
      212 			return;
      213 		     end;
      214 	     end;
      215 
      216 /**** We have checked as best we can before fetching from ring 0 */
      217 
      218 	go to PARSED;
      219 
      220 RETURN:
      221 	return;
      222 MISSING:
      223      procedure (w);
      224 	declare w			   char (*);
      225 
      226 	call com_err_ (error_table_$noarg, myname, "^a", w);
      227 	go to RETURN;
      228      end;
      229 
      230 
      231 PARSED:
      232 /**** Fish things out of ring 0 */
      233 	call get_temp_segments_ (myname, q, code);
      234 	if code ^= 0
      235 	then do;
      236 		call com_err_ (code, myname, "Getting temp segs");
      237 		return;
      238 	     end;
      239 
      240 	sstp = q (1);
      241 	dtp = q (2);
      242 	cmp = q (3);
      243 
      244 	call mdc_$read_disk_table (dtp, code);
      245 	if code ^= 0
      246 	then do;
      247 		dtp = null ();
      248 		call com_err_ (code, myname, "Reading disk table. ");
      249 	     end;
      250 
      251 
      252 	call ring0_get_$segptr ("", "sst", sstp0, code);	/* get pointer to sst */
      253 	call ring0_get_$segptr ("", "dseg", dsp0, code);	/* and pointer to dseg */
      254 	call ring_zero_peek_ (sstp0, sstp, size (sst), code);
      255 						/* get header of sst */
      256 	if code ^= 0
      257 	then do;
      258 		call com_err_ (code, myname, "Getting header of SST");
      259 		call rts;
      260 		return;
      261 	     end;
      262 	ptwbase = fixed (sst.ptwbase, 24);
      263 	do i = 0 to 3;
      264 	     ptsizes (i) = sst.pts (i);
      265 	end;
      266 	rastap = fixed (rel (sst.astap), 18);		/* get offset to start of ASTE's */
      267 
      268 	astep = addrel (sstp, rastap);		/* space for ASTE copy at end of SST copy */
      269 	sptp = addrel (astep, size (aste));		/* including the page table */
      270 	cmp0 = sst.cmp;				/* core map */
      271 
      272 	call ring_zero_peek_$get_max_length_ptr (cmp0, cmap_length, code);
      273 	cmap_length = cmap_length - fixed (rel (cmp0), 18);
      274 						/* ignore -1's at front of core_map */
      275 
      276 	if code ^= 0
      277 	then do;
      278 		call com_err_ (code, myname, "Getting length of core-map");
      279 		call rts;
      280 		return;
      281 	     end;
      282 
      283 
      284 
      285 /* ASCERTAIN THE SEGMENT'S IDENTITY AND AST OFFSET */
      286 
      287 	if ^force_slt & ^force_offset
      288 	then do;					/* try to initiate as pathname */
      289 
      290 		call hcs_$initiate (dirname, ename, "", 0, 0, segptr, code);
      291 		if segptr = null
      292 		then do;				/* segment can't be made known */
      293 			call check_gate_access_ ("phcs_", codeptr (display_aste), code);
      294 			if code ^= 0
      295 			then go to no_phcs;
      296 			call phcs_$initiate (dirname, ename, "", 0, 0, segptr, code);
      297 		     end;
      298 no_phcs:
      299 		if segptr = null ()
      300 		then do;
      301 			if search (pathname, "><") > 0
      302 			then do;			/* cannot possibly be SLT name */
      303 				call com_err_ (code, myname, "^a.", pathname_ (dirname, ename));
      304 				call rts;
      305 				return;
      306 			     end;
      307 			force_slt = "1"b;		/* assume hardcore */
      308 		     end;
      309 	     end;
      310 
      311 
      312 	if force_slt
      313 	then do;					/* segptr must be null */
      314 
      315 		if verify (rtrim (pathname), "01234567") = 0
      316 						/* octal it is */
      317 		then do;
      318 			segno = cv_oct_ (pathname);
      319 			segptr = baseptr (segno);
      320 			call hcs_$high_low_seg_count (user_seg_count, first_user_seg);
      321 			if segno < first_user_seg
      322 			then do;
      323 				call ring0_get_$name (dirname, ename, segptr, code);
      324 				if code ^= 0
      325 				then do;
      326 					call com_err_ (code, myname,
      327 					     "Segment ^o not found in hardcore address space.", segno);
      328 					call rts;
      329 					return;
      330 				     end;
      331 				if dirname ^= ""
      332 				then pathname = pathname_ (dirname, ename);
      333 				else pathname = ename;
      334 			     end;
      335 			else if segno < first_user_seg + user_seg_count
      336 			then do;
      337 				dirname, ename = "";
      338 				call hcs_$fs_get_path_name (segptr, dirname, (0), ename, code);
      339 				if code ^= 0
      340 				then do;		/* cannot possibly have an SDW */
      341 					call com_err_ (code, myname, "segment number ^o.", segno);
      342 					call rts;
      343 					return;
      344 				     end;
      345 				pathname = pathname_ (dirname, ename);
      346 			     end;
      347 			else do;			/* invalid segno */
      348 				call com_err_ (error_table_$invalidsegno, myname, "^o.", segno);
      349 				call rts;
      350 				return;
      351 			     end;
      352 
      353 		     end;
      354 		else do;
      355 			call ring0_get_$segptr ("", pathname, segptr, code);
      356 			if segptr = null
      357 			then do;
      358 				call com_err_ (code, myname, pathname);
      359 						/* Give up */
      360 				call rts;
      361 				return;
      362 			     end;
      363 		     end;
      364 	     end;
      365 
      366 	if ^force_offset
      367 	then do;					/* we have a segptr by now, or have punted */
      368 
      369 		segno = fixed (baseno (segptr));	/* get segment number of segment */
      370 		call ring_zero_peek_ (addr (dsp0 -> sdwa (segno)), addr (sdw1), size (sdw1), code);
      371 						/* Get sdw */
      372 		if sdw1.unpaged
      373 		then do;				/* If segment is not paged.. */
      374 			call com_err_ (0, myname, "^a is not paged.", pathname);
      375 						/* tell user */
      376 			call rts;
      377 			return;
      378 		     end;
      379 		ptwaddr = fixed (sdw1.add, 24);
      380 		if ^sdw1.df
      381 		then do;				/* make sure segment is active */
      382 			call com_err_ (0, myname, "^a not connected.", pathname);
      383 			call rts;
      384 			return;
      385 		     end;
      386 
      387 		aste_offset = ptwaddr - ptwbase - size (aste);
      388 						/* get offset of ast entry */
      389 		if aste_offset < 0
      390 		then do;
      391 			call com_err_ (0, myname, "^a does not have an aste.", pathname);
      392 			call rts;
      393 			return;
      394 		     end;
      395 	     end;
      396 
      397 /* WHEW! got here means we have the aste offset, definitely */
      398 
      399 /* DISPLAY THE AST ENTRY */
      400 
      401 
      402 	call ring_zero_peek_ (ptr (sstp0, aste_offset), astep, 256 + size (aste), code);
      403 						/* copy the AST entry */
      404 	call ring_zero_peek_ (cmp0, cmp, cmap_length, code);
      405 						/* copy the whole core map */
      406 
      407 	ll = get_line_length_$switch (null (), code);
      408 	if ll > 109				/* dump segment needs this much space */
      409 	then wpl = 8;
      410 	else wpl = 4;
      411 
      412 	if force_offset
      413 	then do;					/* try for a name */
      414 		if aste.hc
      415 		then do;
      416 			segptr = baseptr (aste.strp);
      417 			call ring0_get_$name (dirname, ename, segptr, code);
      418 			if code = 0
      419 			then do;
      420 				if dirname = ""
      421 				then pathname = ename;
      422 				else pathname = pathname_ (dirname, ename);
      423 			     end;
      424 		     end;
      425 	     end;
      426 
      427 	if substr (pathname, 1, 2) = "at"
      428 	then call ioa_ ("ASTE at ^o in sst_seg", aste_offset);
      429 	call ioa_ ("ASTE for ^a at ^o in sst_seg", pathname, aste_offset);
      430 						/* indicate location of AST */
      431 	call ioa_ (" fp: ^6o, bp: ^6o, infl: ^6o, infp: ^6o", aste.fp, aste.bp, aste.infl, aste.infp);
      432 	call ioa_ (" strp: ^6o, par_astep: ^6o, UID: ^w", aste.strp, aste.par_astep, aste.uid);
      433 	call ioa_ (" msl: ^d, csl: ^d, records: ^d, np: ^d", fixed (aste.msl), fixed (aste.csl), fixed (aste.records),
      434 	     fixed (aste.np));
      435 
      436 	call flag$$init;
      437 
      438 	call flag (aste.usedf, "usedf");
      439 	call flag (aste.init, "init");
      440 	call flag (aste.gtus, "gtus");
      441 	call flag (aste.gtms, "gtms");
      442 	call flag (aste.hc, "hc");
      443 	call flag (aste.hc_sdw, "hc_sdw");
      444 	call flag (aste.any_access_on, "any_access_on");
      445 	call flag (aste.write_access_on, "write_access_on");
      446 	call flag (aste.inhibit_cache, "inhibit_cache");
      447 	call flag (aste.explicit_deact_ok, "explicit_deact_ok");
      448 	call flag (aste.deact_error, "deact_error");
      449 	call flag (aste.hc_part, "hc_part");
      450 	call flag (aste.fm_damaged, "fm_damaged");
      451 	call flag (aste.dius, "dius");
      452 	call flag (aste.nid, "nid");
      453 	call flag (aste.ehs, "ehs");
      454 	call flag (aste.nqsw, "nqsw");
      455 	call flag (aste.volmap_seg, "volmap_seg");
      456 	call flag (aste.dirsw, "dirsw");
      457 	call flag (aste.master_dir, "master_dir");
      458 	call flag (aste.multi_class, "multi_class");
      459 	call flag (aste.tqsw (0), "tqsw(S)");
      460 	call flag (aste.tqsw (1), "tqsw(D)");
      461 	call flag (aste.npfs, "npfs");
      462 	call flag (aste.dnzp, "dnzp");
      463 	call flag (aste.ddnp, "ddnp");
      464 	call flag (aste.synchronized, "synchronized");
      465 	call flag (aste.fmchanged, "fmchanged");
      466 	call flag (aste.fmchanged1, "fmchanged1");
      467 	call flag (aste.fms, "fms");
      468 	call flag (aste.damaged, "damaged");
      469 	call flag (aste.pack_ovfl, "pack_ovfl");
      470 
      471 
      472 	call fs_date_time (aste.dtu, time_string);
      473 	if aste.dtu ^= ""b
      474 	then call ioa_ (" DTU: ^a", time_string);
      475 	call fs_date_time (aste.dtm, time_string);
      476 	if aste.dtm ^= ""b
      477 	then call ioa_ (" DTM: ^a", time_string);
      478 
      479 	call flag$$display;
      480 
      481 	if aste.dirsw				/* Quota */
      482 	then call ioa_ (" quota: (^d, ^d), used: (^d, ^d)", aste.quota (0), aste.quota (1), aste.used (0),
      483 		aste.used (1));
      484 	else call ioa_ (" usage count: ^d", seg_aste.usage);
      485 
      486 	if dtp ^= null ()
      487 	then if aste.pvtx > 0 & aste.pvtx <= dt.n_entries
      488 	     then do;
      489 		     diskname = dt.array (aste.pvtx).drive_name;
      490 		     pvname = dt.array (aste.pvtx).pvname;
      491 		     call ioa_ (" vtocx ^o on pvtx ^d (""^a""), disk ^a", aste.vtocx, aste.pvtx, pvname, diskname);
      492 		end;
      493 	     else go to NO_NAME;
      494 	else
      495 NO_NAME:
      496 	     call ioa_ (" vtocx ^o on pvtx ^d", aste.vtocx, aste.pvtx);
      497 
      498 	pts = ptsizes (fixed (astep -> aste.ptsi, 3));	/* get page table size */
      499 	if file_map_sw
      500 	then call file_map;
      501 	if octal
      502 	then call octal_dump;
      503 	call rts;
      504 	return;
      505 
      506 /* DISPLAY THE PAGE TABLE */
      507 
      508 file_map:
      509      procedure;
      510 	call ioa_$nnl ("^/File map:^/");
      511 	skipping = "0"b;
      512 	last_pte = ""b;
      513 	ptp = addwordno (astep, size (aste));
      514 	do i = 0 to pts - 1;
      515 	     if ptp -> pt (i) = last_pte & i < (pts - 1)
      516 	     then skipping = "1"b;
      517 	     else if skipping
      518 	     then do;
      519 		     skipping = "0"b;
      520 		     call ioa_ ("======");
      521 		end;
      522 	     if ^skipping | i = pts - 1
      523 	     then do;
      524 		     ptwp = addr (ptp -> pt (i));
      525 		     call ioa_$nnl ("^3d ", i);
      526 		     call display_ptw (ptwp);
      527 		     last_pte = ptp -> pt (i);
      528 		end;
      529 	end;
      530 	return;
      531      end file_map;
      532 
      533 octal_dump:
      534      procedure;
      535 
      536 	call ioa_ ("^/Octal dump:^/");
      537 	call ioa_ ("ASTE:");
      538 	call dump_segment_ (iox_$user_output, addr (aste), -1, 0, size (aste), "01000"b);
      539 	call ioa_ ("^/File map:");
      540 	call dump_segment_ (iox_$user_output, addwordno (astep, size (aste)), -1, 0, (pts), "01000"b);
      541 	return;
      542      end octal_dump;
      543 
      544 rts:
      545      proc;
      546 	call release_temp_segments_ (myname, q, (0));
      547      end rts;
      548 
      549 fs_date_time:
      550      procedure (dt, cdt);
      551 
      552 	declare dt		   bit (36);
      553 	declare cdt		   char (*);
      554 	declare 1 clock_		   aligned like clock_value;
      555 	declare time		   fixed bin (71);
      556 
      557 	declare code		   fixed bin (35);
      558 	declare sub_error_		   condition;
      559 
      560 
      561 	clock_ = ""b;
      562 	clock_.fs_time = dt;
      563 	unspec (time) = string (clock_);
      564 	if time = 0
      565 	then
      566 ZERO:
      567 	     do;
      568 		cdt = "ZERO";
      569 		return;
      570 	     end;
      571 
      572 	on sub_error_ go to ZERO;
      573 	cdt = date_time_$format ("iso_long_date_time", time, "", "");
      574 	return;
      575      end fs_date_time;
      576 
      577 
      578 display_ptw:
      579      procedure (p);
      580 
      581 	declare p			   ptr;
      582 	declare 1 ptw		   aligned like l68_ptw based (p);
      583 	declare 1 core_ptw		   aligned like l68_core_ptw based (p);
      584 	if ptw.add_type & add_type.core ^= ""b
      585 	then do;
      586 		call ioa_ ("^a ^[^^^]er,^[^^^]phu,^[^^^]phu1,^[^^^]phm,^[^^^]phm1,^[^^^]wired,^[^^^]os,^[^^^]valid",
      587 		     display_devadd (substr (unspec (ptw), 1, 22)), ^core_ptw.er, ^core_ptw.phu, ^core_ptw.phu1,
      588 		     ^core_ptw.phm, ^core_ptw.phm1, ^core_ptw.wired, ^core_ptw.os, ^core_ptw.valid);
      589 		cmep = ptr (cmp, core_ptw.frame * 4);
      590 		call ioa_ ("      Disk address: ^a", display_devadd (cme.devadd));
      591 		call ioa_ (
      592 		     "      CME flags: ^[^^^]synch_held,io=^[output^;input^],^[^^^]er,^[^^^]removing,^[^^^]abs_w,^[^^^]abs_usable,^/                 ^[^^^]notify_requested,^[^^^]phm_hedge,pin_counter=^d"
      593 		     , ^cme.synch_held, cme.io, ^cme.er, ^cme.removing, ^cme.abs_w, ^cme.abs_usable,
      594 		     ^cme.notify_requested, ^cme.phm_hedge, cme.pin_counter);
      595 	     end;
      596 	else call ioa_ ("^a", display_devadd (substr (unspec (ptw), 1, 22)));
      597 
      598 
      599 	return;
      600      end display_ptw;
      601 
      602 display_devadd:
      603      procedure (D) returns (char (*));
      604 
      605 	declare D			   bit (22) unaligned;
      606 
      607 	declare 1 devadd_b		   unaligned,
      608 		2 add		   bit (18),
      609 		2 type		   bit (4);
      610 
      611 	declare 1 devadd		   unaligned,
      612 		2 null		   bit (1),
      613 		2 add		   fixed bin (17) unsigned,
      614 		2 type		   bit (4);
      615 	declare null		   builtin;
      616 
      617 	declare RS		   char (1000) varying;
      618 	declare ptp		   pointer;
      619 	declare nulled		   bit (1);
      620 
      621 	RS = "";
      622 	string (devadd_b) = D;
      623 	unspec (devadd) = D;
      624 	ptp = addr (devadd);
      625 
      626 	nulled = "0"b;
      627 	if (devadd.type & add_type.non_null) ^= ""b
      628 	then do;
      629 		if (devadd.type & add_type.core) ^= ""b
      630 		then call ioa_$rsnnl ("Memory address ^8o", RS, (0), ptp -> l68_core_ptw.frame * sys_info$page_size);
      631 		else if (devadd.type & add_type.disk) ^= ""b
      632 		then do;
      633 			if devadd.null
      634 			then do;
      635 				nulled = "1"b;
      636 				devadd.null = "0"b;
      637 			     end;
      638 			call ioa_$rsnnl ("Disk page ^8o ^[(nulled)^]", RS, (0), devadd.add, nulled);
      639 		     end;
      640 		else call ioa_$rsnnl ("Invalid type ^4b add ^o", RS, (0), devadd.type, devadd.add);
      641 	     end;
      642 	else do;					/* null address */
      643 
      644 		declare 1 null_address	   unaligned,
      645 			2 three_7_7_0	   bit (12) unaligned,
      646 			2 key		   bit (6),
      647 			2 type		   bit (4);
      648 
      649 		string (null_address) = D;		/* so far, so good */
      650 		call ioa_$rsnnl ("Null address from ^a", RS, (0), pc_null_address_names (bin (null_address.key, 6)));
      651 
      652 	     end;
      653 
      654 	return (RS);
      655 
      656      end display_devadd;
      657 
      658 	declare flags		   (0:1) char (1000) varying;
      659 						/* off, on */
      660 	declare line_used		   (0:1) fixed bin; /* line length used up on cur line */
      661 	declare line_length		   fixed bin;
      662 
      663 flag$$init:
      664      procedure;
      665 
      666 	declare get_line_length_$switch  entry (pointer, fixed binary (35)) returns (fixed binary);
      667 	declare iox_$user_output	   ptr ext static;
      668 
      669 	line_length = get_line_length_$switch (iox_$user_output, code);
      670 	if code ^= 0
      671 	then line_length = 72;
      672 	flags (0) = "OFF:     ";
      673 	flags (1) = "ON:      ";			/* these are eight characters long */
      674 	line_used (*) = 9;				/* always prepend space */
      675 	return;
      676 
      677 flag:
      678      entry (flag_bit, flag_name);
      679 
      680 	declare flag_bit		   bit (1) unaligned;
      681 	declare flag_name		   char (*);
      682 
      683 	declare flag_bin		   fixed bin (1);
      684 
      685 	flag_bin = bin (flag_bit, 1);
      686 	if line_used (flag_bin) + length (flag_name) + 1 > line_length
      687 	then do;
      688 		flags (flag_bin) = flags (flag_bin) || byte (10) || copy (" ", 9);
      689 						/* NL */
      690 		line_used (flag_bin) = 9;
      691 	     end;
      692 	flags (flag_bin) = flags (flag_bin) || " " || flag_name;
      693 						/* assume trimmed */
      694 	line_used (flag_bin) = line_used (flag_bin) + 1 + length (flag_name);
      695 	return;
      696 
      697 flag$$display:
      698      entry;
      699 
      700 	call ioa_ ("^/^a^/^a^/", flags (1), flags (0));
      701 	return;
      702      end flag$$init;
      703 
      704 
  1     1 /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  1     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  1     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  1     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  1     5 
  1     6 dcl  sst_seg$ external;
  1     7 dcl  sstp ptr;
  1     8 
  1     9 dcl 1 sst based (sstp) aligned,
  1    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  1    11 
  1    12 /* SST HEADER */
  1    13 
  1    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  1    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  1    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  1    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  1    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  1    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  1    20 
  1    21     2 ptl bit (36),					/* global page table loop lock */
  1    22     2 astl bit (36),				/* global ast allocation block lock */
  1    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  1    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  1    25     2 nused fixed bin,				/* number of pages on used list */
  1    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  1    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  1    28 
  1    29     2 astap ptr,					/* aste array pointer */
  1    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  1    31     2 astsize fixed bin,				/* size of an AST entry */
  1    32     2 cmesize fixed bin,				/* size of a CME entry */
  1    33     2 root_astep ptr,				/* pointer to the root AST entry */
  1    34 
  1    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  1    36     2 level (0:3),					/* per-list information about ASTE's */
  1    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  1    38 
  1    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  1    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  1    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  1    42     2 strsize fixed bin,				/* Trailer size in words. */
  1    43 
  1    44 /* CORE MAP HEADER */
  1    45 
  1    46     2 cmp ptr,					/* pointer to start of core map */
  1    47     2 usedp bit (18),				/* pointer to first used core block */
  1    48     2 wtct fixed bin,				/* count of pages being written */
  1    49 
  1    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  1    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  1    52 						/* MISC */
  1    53 
  1    54     2 double_write fixed bin,				/* trigger for store through scheme */
  1    55 						/* 0 = no double writes,
  1    56*						   1 = all non-pd pages get written,
  1    57*						   2 = all directories get written */
  1    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  1    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  1    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  1    61 
  1    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  1    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  1    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  1    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  1    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  1    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  1    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  1    69 
  1    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  1    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  1    72 
  1    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  1    74 
  1    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  1    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  1    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  1    78 
  1    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  1    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  1    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  1    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  1    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  1    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  1    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  1    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  1    87 
  1    88 
  1    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  1    90 
  1    91     2 steps fixed bin,				/* number of steps taken around used list */
  1    92     2 needc fixed bin,				/* number of times core page needed */
  1    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  1    94     2 ctwait fixed bin,				/* number of times write counter was full */
  1    95     2 wired fixed bin,				/* number of pages wired by pc */
  1    96     2 laps fixed bin,				/* number of times around used list */
  1    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  1    98     2 skipu fixed bin,				/* because of being used */
  1    99 
  1   100     2 skipm fixed bin,				/* because of being modified */
  1   101     2 skipos fixed bin,				/* because out of service */
  1   102     2 aused fixed bin,				/* number of AST entries on used list */
  1   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  1   104     2 deact_count fixed bin,				/* count of deactivations */
  1   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  1   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  1   107 
  1   108     2 reads (8) fixed bin,				/* number of reads for each did */
  1   109     2 writes (8) fixed bin,				/* number of writes for each did */
  1   110 
  1   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  1   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  1   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  1   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  1   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  1   116     2 total_sf fixed bin,				/* total number of seg_faults */
  1   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  1   118     2 post_list_size fixed bin,
  1   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  1   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  1   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  1   122     2 pre_page_list_size fixed bin,
  1   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  1   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  1   125 
  1   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  1   127 
  1   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  1   129 
  1   130 /* MAIN MEMORY USAGE INFORMATION */
  1   131 
  1   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  1   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  1   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  1   135     2 recopies fixed bin,				/* number of times recopied because modified */
  1   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  1   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  1   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  1   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  1   140 
  1   141 /*  AST METERS  */
  1   142 
  1   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  1   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  1   145 
  1   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  1   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  1   148     2 asearches fixed bin,				/* count of full searches made */
  1   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  1   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  1   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  1   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  1   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  1   154 
  1   155     2 alaps fixed bin,				/* lap counter for AST list */
  1   156     2 updates fixed bin,				/* calls to updateb */
  1   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  1   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  1   159     2 total_bf fixed bin,				/* count of bound faults */
  1   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  1   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  1   162 
  1   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  1   164 
  1   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  1   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  1   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  1   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  1   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  1   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  1   171 
  1   172 /* PRE-PAGE METERS */
  1   173 
  1   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  1   175 
  1   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  1   177 
  1   178 
  1   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  1   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  1   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  1   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  1   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  1   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  1   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  1   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  1   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  1   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  1   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  1   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  1   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  1   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  1   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  1   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  1   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  1   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  1   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  1   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  1   199     2 activations fixed bin,				/* total count of activations */
  1   200     2 dir_activations fixed bin,			/* count of directory activations */
  1   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  1   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  1   203     2 evict_recover_data,				/* see evict_page.alm */
  1   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  1   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  1   206 
  1   207 /* Data for metering force_write facility 08/19/78 */
  1   208 
  1   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  1   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  1   211     2 fw_none fixed bin,				/* Force write wrote none */
  1   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  1   213 
  1   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  1   215     2 pf_unlock_ptl_meterings fixed bin,
  1   216 
  1   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  1   218     2 backup_activations fixed bin (35),		/* activations for backup */
  1   219     2 metering_flags aligned,				/* small chunks of misc. information */
  1   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  1   221       3 pad bit (35) unal,
  1   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  1   223 
  1   224 /* METERS FOR STACK TRUNCATION */
  1   225 
  1   226     2 (stk_truncate_should_didnt,			/* counts */
  1   227        stk_truncate_should_did,
  1   228        stk_truncate_shouldnt_didnt,
  1   229        stk_truncate_shouldnt_did) fixed bin (35),
  1   230     2 stk_pages_truncated fixed bin (35),
  1   231     2 stk_pages_truncated_in_core fixed bin (35),
  1   232 
  1   233 /* SUPPORT FOR PC SEGMOVES */
  1   234 
  1   235     2 segmove_lock aligned,
  1   236       3 pid bit (36) aligned,
  1   237       3 event bit (36) aligned,
  1   238       3 notify bit (1) aligned,
  1   239     2 segmove_io_limit fixed bin, /* max read aheads */
  1   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  1   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  1   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  1   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  1   244 
  1   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  1   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  1   247     2 segmove_vtocx fixed bin,			/* ditto */
  1   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  1   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  1   250 
  1   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  1   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  1   253     2 trace_sw aligned,				/* tracing control flags */
  1   254       3 pad_trace bit (32) unaligned,
  1   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  1   256       3 tty_trace bit (1) unaligned,
  1   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  1   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  1   259     2 new_pages fixed bin,				/* newly created pages */
  1   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  1   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  1   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  1   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  1   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  1   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  1   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  1   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  1   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  1   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  1   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  1   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  1   272 
  1   273 /* END INCLUDE FILE sst.incl.pl1 */
      705 
  2     1 /*	BEGIN INCLUDE FILE ... disk_table.incl.pl1 ... Created Oct 75 for NSS */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  2     6*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  2     7*     Add support for subvolumes.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 
  2    11 /*		Modified July 1977 by T. Casey to add pdirs_ok switch in lve */
  2    12 /*		Modified April 1981 by J. Bongiovanni to add shared_spindle_flip */
  2    13 /*		Modified 831122 by E. A. Ranzenbach to add vacate_pdirs bit to lve. */
  2    14 
  2    15 /* The disk table lives in ring 1. Its entries parallel the PVT */
  2    16 
  2    17 dcl  dtp ptr,
  2    18      dtep ptr,
  2    19      lvep ptr;
  2    20 
  2    21      
  2    22 
  2    23 dcl 1 dt based (dtp) aligned,
  2    24 
  2    25     2 n_entries fixed bin (17),			/* number of disk table entries */
  2    26     2 max_n_entries fixed bin (17),			/* max number of disk table entries */
  2    27     2 n_in_use fixed bin (17),			/* number of disk table entries in use */
  2    28     2 rpvx fixed bin,				/* index (pvtx, too) of the RPV */
  2    29     2 version fixed bin init (1),
  2    30     2 n_lv_entries fixed bin,				/* Number of LV entries */
  2    31     2 pad (2) bit (36),
  2    32     2 array (0 refer (dt.max_n_entries)) like dte,
  2    33     2 lv_array (0 refer (dt.max_n_entries)) like lve;
  2    34 
  2    35 dcl 1 dte based (dtep) aligned,
  2    36     2 drive_name char (8),				/* device name */
  2    37     (2 device_type fixed bin (8),			/* device type */
  2    38     2 used bit (1),					/* TRUE if this entry is used for paging */
  2    39     2 known bit (1),				/* TRUE if label has been read and checked */
  2    40     2 storage_system bit (1),				/* TRUE for storage system (vs io disk) */
  2    41     2 permanent bit (1),				/* TRUE if cannot be demounted */
  2    42     2 deleted bit (1),				/* TRUE if deleted by "deld" */
  2    43     2 rpv bit (1),					/* TRUE if the root physical volume */
  2    44     2 demounted bit (1),				/* TRUE if was here or was assumed here */
  2    45     2 need_salvage bit (1),				/* TRUE if this vol was volsalv'd automatic */
  2    46     2 hc_accepted bit (1),				/* TRUE if vol accepted by ring 0 init */
  2    47     2 shared_spindle_flip bit (1),			/* used by ring-4 for shared spindle allocation */
  2    48     2 is_sub_vol bit (1),
  2    49     2 pad bit (3),
  2    50     2 lvx fixed bin (11),				/* index in lv_array of lve */
  2    51     2 pre_accepted bit (1)) unaligned,			/* TRUE if was used in previous bootload */
  2    52     2 sv_num  fixed bin unal,				/* this sv number */
  2    53     2 num_of_sv fixed bin unal,			/* number of sv for this pv */
  2    54     2 sv_name   char (2) aligned,
  2    55     2 pvid bit (36),				/* physical volume ID */
  2    56     2 pvname char (32);				/* Physical volume name. */
  2    57 
  2    58 dcl 1 lve based (lvep) aligned,
  2    59     2 lvid bit (36),				/* logical volume ID */
  2    60     (2 used bit (1),				/* TRUE if entry used */
  2    61     2 hv_mounted bit (1),				/* TRUE if hvol is really OK */
  2    62     2 public bit (1),				/* TRUE for public vol */
  2    63     2 mounting bit (1),				/* TRUE if mhv is in progress */
  2    64     2 demounting bit (1),				/* TRUE if dhv is in progress */
  2    65     2 good_candidate bit (1) unal,			/* used for auto dhv */
  2    66     2 demounted_only bit (1) unal,			/* lve here only to warm demounted pve's */
  2    67     2 pdirs_ok bit (1) unal,				/* TRUE if process directory segments can be on this lv */
  2    68     2 prev_bootload bit (1) unal,			/* TRUE if can auto-accept pvs */
  2    69     2 vacate_pdirs bit (1) unal,			/* if TRUE we will demand move all perprocess segs */
  2    70     2 pad bit (26)) unal,
  2    71     2 lvname char (32),				/* Logical volume name */
  2    72     2 min_access_class bit (72),			/* Security stuff */
  2    73     2 max_access_class bit (72);			/* .. */
  2    74 
  2    75 /*	END INCLUDE FILE ...disk_table.incl.pl1 */
      706 
  3     1 /* BEGIN INCLUDE FILE ... ptw.l68.incl.pl1 ... 02/26/81, for ADP conversion */
  3     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  3     3 
  3     4 dcl 1 l68_core_ptw aligned based (ptp), 		/* In-core page descriptor */
  3     5     2 frame fixed bin (14) unsigned unaligned,		/* Core frame number */
  3     6     2 pad1 bit (4) unaligned,
  3     7     2 flags unaligned like l68_ptw_flags;
  3     8 
  3     9 dcl 1 l68_ptw aligned based (ptp),			/* General declaration for out-of-core PTW */
  3    10     2 add bit (18) unaligned,
  3    11     2 flags like l68_ptw_flags unaligned;
  3    12 
  3    13 dcl 1 l68_special_ptw aligned based (ptp) like l68_ptw;	/* Page is somewhere peculiar -- add_type = "01"b */
  3    14 dcl 1 l68_real_disk_ptw aligned based (ptp) like l68_ptw;	/* PTW for page actually on disk -- add_type = "10"b */
  3    15 dcl 1 l68_null_disk_ptw aligned based (ptp) like l68_ptw;	/* PTW for page not yet on disk -- add_type = "11"b */
  3    16 
  3    17 dcl 1 l68_ptw_flags unaligned based,			/* Various software/hardware flags */
  3    18    (2 add_type bit (4),				/* 0000=null, 1000=core, 0100=disk, 0010=pd, 0001=swap */
  3    19     2 first bit (1),				/* the page has not yet been written out */
  3    20     2 er bit (1),					/* error on last page I/O (also used by post-purge as temp) */
  3    21 
  3    22     2 pad1 bit (1),
  3    23     2 unusable1 bit (1),				/* can't be used because hardware resets this bit */
  3    24     2 phu bit (1),					/* page has been used bit */
  3    25 
  3    26     2 phm1 bit (1), 				/* Cumulative OR of hardware phm's */
  3    27     2 nypd bit (1), 				/* must be moved to paging device */
  3    28     2 phm bit (1),					/* page has been modified bit */
  3    29 
  3    30     2 phu1 bit (1), 				/* page has been used in the quantum */
  3    31     2 wired bit (1),				/* page is to remain in core */
  3    32     2 os bit (1),					/* page is out-of-service (I/O in progress) */
  3    33     2 valid bit (1),				/* directed fault if this is 0 (page not in core) */
  3    34     2 df_no bit (2)) unaligned;			/* directed fault number for page faults */
  3    35 
  3    36 /* END INCLUDE FILE ... ptw.l68.incl.pl1 */
      707 
  4     1 /* Begin include file pc_null_address_names.incl.pl1 */
  4     2 /* format: style3 */
  4     3 
  4     4 declare	pc_null_address_names
  4     5 			(0:58) char (60) int static options (constant) varying init ("zeros",
  4     6 						/* 0 */
  4     7 			(6) (1)"invalid source",	/* 1 -> 6 */
  4     8 			"pc$move_page_table_1",	/* 7 */
  4     9 			"pc$move_page_table_2",	/* 10 */
  4    10 			"get_aste",		/* 11 */
  4    11 			"make_sdw",		/* 12 */
  4    12 			"put_aste",		/* 13 */
  4    13 			(2) (1)"invalid source",	/* 15 */
  4    14 			"list_deposit",		/* 16 */
  4    15 			"get_file_map",		/* 17 */
  4    16 			"fill_page_table",		/* 20 */
  4    17 			"init_sst",		/* 21 */
  4    18 			"get_file_map_vt",		/* 22 */
  4    19 			"unprotected",		/* 23 */
  4    20 			"page_bad",		/* 24 */
  4    21 			"page_problem",		/* 25 */
  4    22 			"page_parity",		/* 26 */
  4    23 			"page[devparity",		/* 27 */
  4    24 			(34) (1)"invalid source",	/* 28 - 53 */
  4    25 			"get_file_map_dumper" /* 72, sort of */);
  4    26 
  4    27 /* End include file pc_null_address_names.incl.pl1 */
      708 
  5     1 /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  5     2 
  5     3 /* Template for an AST entry. Length = 12 words. */
  5     4 
  5     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  5     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  5     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  5     8 
  5     9 dcl  astep ptr;
  5    10 
  5    11 dcl 1 aste based (astep) aligned,
  5    12 
  5    13     (2 fp bit (18),					/* forward  used list rel pointer */
  5    14     2 bp bit (18),					/* backward used list rel pointer */
  5    15 
  5    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  5    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  5    18 
  5    19     2 strp bit (18),				/* rel pointer to process trailer */
  5    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  5    21 
  5    22     2 uid bit (36),					/* segment unique id */
  5    23 
  5    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  5    25     2 pvtx fixed bin (8),				/* physical volume table index */
  5    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  5    27 
  5    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  5    29     2 init bit (1),					/* used bit - insure 1 lap */
  5    30     2 gtus bit (1),					/* global transparent usage switch */
  5    31     2 gtms bit (1),					/* global transparent modified switch */
  5    32     2 hc bit (1),					/* hard core segment */
  5    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  5    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  5    35     2 write_access_on bit (1),			/* any sdw allows write access */
  5    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  5    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  5    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  5    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  5    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  5    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  5    42     2 pad1 bit (2),					/* OO */
  5    43     2 dius bit (1),					/* dumper in use switch */
  5    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  5    45     2 dmpr_pad bit (1),
  5    46     2 ehs bit (1),					/* entry hold switch */
  5    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  5    48     2 dirsw bit (1),				/* directory switch */
  5    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  5    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  5    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  5    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  5    53 
  5    54     2 dtu bit (36),					/* date and time segment last used */
  5    55 
  5    56     2 dtm bit (36),					/* date and time segment last modified */
  5    57 
  5    58 
  5    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  5    60 
  5    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  5    62 
  5    63     2 csl bit (9),					/* current segment length in 1024 words units */
  5    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  5    65     2 fms bit (1),					/* file modified switch */
  5    66     2 npfs bit (1),					/* no page fault switch */
  5    67     2 gtpd bit (1),					/* global transparent paging device switch */
  5    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  5    69     2 per_process bit (1),				/* use master quota for this entry */
  5    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  5    71     2 pad2 bit (2),
  5    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  5    73     2 np bit (9),					/* number of pages in core */
  5    74 
  5    75 
  5    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  5    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  5    78     2 damaged bit (1),				/* PC declared segment unusable */
  5    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  5    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  5    81     2 pad3 bit (6),					/* OOOOOOOOO */
  5    82     2 ptsi bit (2),					/* page table size index */
  5    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  5    84 
  5    85 
  5    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  5    87 
  5    88 
  5    89 dcl 1 aste_part aligned based (astep),
  5    90 
  5    91     2 one bit (36) unaligned,				/* fp and bp */
  5    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  5    93     2 three bit (8) unaligned;			/* ptsi and marker */
  5    94 
  5    95 
  5    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  5    97     2 pad1 bit (8*36),
  5    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  5    99     2 pad2 bit (3*36);
  5   100 
  5   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      709 
  6     1 /* BEGIN INCLUDE FILE cmp.incl.pl1 --- October 1982 */
  6     2 /* Note: This include file has an ALM counterpart NOT made with cif (for historical reasons). Keep it up to date */
  6     3 
  6     4 dcl  cmep ptr;					/* pointer to core map entry */
  6     5 
  6     6 dcl 1 cme based (cmep) aligned,			/* core map entry */
  6     7     2 fp bit (18) unaligned,				/* forward pointer to next entry */
  6     8     2 bp bit (18) unaligned,				/* backward pointer to previous entry */
  6     9 
  6    10     2 devadd bit (22) unaligned,			/* device address of page in the core block */
  6    11     2 pad5 bit (1) unaligned,
  6    12     2 synch_held bit (1) unaligned,			/* Page of synchronized seg held in memory */
  6    13     2 io bit (1) unaligned,				/* input/output indicator 1=output, 0=input */
  6    14     2 pad2 bit (1) unaligned,
  6    15     2 er bit (1) unaligned,				/* indicates error in previous IO activity */
  6    16     2 removing bit (1) unaligned,			/* core is being removed by reconfiguration */
  6    17     2 abs_w bit (1) unaligned,			/* absolute address must not be changed for page */
  6    18     2 abs_usable bit (1) unaligned,			/* page may be assigned with fixed absolute address */
  6    19     2 notify_requested bit (1) unaligned,		/* notify requested on I/O completion */
  6    20     2 pad3 bit (1) unaligned,
  6    21     2 phm_hedge bit (1) unaligned,			/* on => pc$flush_core ought write. */
  6    22     2 contr bit (3) unaligned,			/* controller in which core block is located */
  6    23 
  6    24     2 ptwp bit (18) unaligned,			/* pointer to page table word for the page */
  6    25     2 astep bit (18) unaligned,			/* relative AST entry pointer of page */
  6    26     2 pin_counter fixed bin (17) unaligned,		/* number of times to skip eviction */
  6    27     2 synch_page_entryp bit (18) unaligned;		/* relp to synch page entry */
  6    28 
  6    29 
  6    30 dcl 1 cma (0: 1) based aligned like cme;		/* Core map array */
  6    31 
  6    32 dcl 1 mcme based (cmep) aligned,			/* core map entry for extracting DID */
  6    33     2 pad bit (36) unaligned,
  6    34     2 record_no bit (18) unaligned,			/* record number of device */
  6    35     2 add_type bit (4) unaligned,			/* see add_type.incl.pl1 */
  6    36     2 flags bit (14) unal,
  6    37     2 pad1 bit (18) unal;
  6    38 
  6    39 
  6    40 /* END INCLUDE FILE  cmp.incl.pl1 */
      710 
  7     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  7     2 
  7     3 dcl  sdwp ptr;
  7     4 
  7     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  7     6 
  7     7    (2 add bit (24),					/* main memory address of page table */
  7     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  7     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  7    10     2 df_no bit (2),				/* directed fault number */
  7    11 
  7    12     2 pad1 bit (1),
  7    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  7    14     2 access,					/* access bits */
  7    15       3 read bit (1),				/* read permission bit */
  7    16       3 execute bit (1),				/* execute permission bit */
  7    17       3 write bit (1),				/* write permission bit */
  7    18       3 privileged bit (1),				/* privileged bit */
  7    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  7    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  7    21     2 cache bit (1),				/* cache enable bit */
  7    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  7    23 
  7    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  7    25 
  7    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      711 
  8     1 /* Begin include system_clock_value_.incl.pl1 BIM 83-12-22. */
  8     2 /* Format of clock doubleword */
  8     3 /* format: style3,indcomtxt */
  8     4 
  8     5 declare	clock_value_ptr	pointer;
  8     6 declare	1 clock_value	aligned based (clock_value_ptr),
  8     7 	  2 sign		bit unaligned,
  8     8 	  2 unused_range	bit (19) unaligned,
  8     9 	  2 fs_time	bit (36) unaligned,		/* FB 36 unsigned dont work */
  8    10 	  2 micro_time	bit (16) unaligned;
  8    11 
  8    12 /* End include file system_clock_value_.incl.pl1 */
      712 
  9     1 
  9     2 	/* BEGIN INCLUDE FILE add_type.incl.pl1 */
  9     3 	/* 02/26/75 by Bernard S. Greenberg */
  9     4 
  9     5 	/* This file provides a structure for checking
  9     6*		PTW/CME address type fields in PL/I */
  9     7 
  9     8 dcl 1 add_type unaligned static internal,
  9     9 	2 core bit (4) init ("1000"b),		/* in core- S/B only in PTW */
  9    10 	2 disk bit (4) init ("0100"b),		/* Disk address */
  9    11 	2 pd   bit (4) init ("0010"b),		/* Paging Device */
  9    12 	2 reserved bit (4) init ("0001"b),		/* Reserved */
  9    13 	2 non_null bit (4) init ("1111"b);		/* Not null address */
  9    14 
  9    15 dcl 1 badd_type unaligned based,
  9    16     2 (core, disk, pd, reserved) bit (1) unaligned;
  9    17 
  9    18 	/* END INCLUDE FILE add_type.incl.pl1 */
      713 
      714      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/18/86  1234.9  display_aste.pl1                  >spec>install>1098>display_aste.pl1
705          1    01/30/85  1523.9  sst.incl.pl1                      >ldd>include>sst.incl.pl1
706          2    07/18/86  1218.4  disk_table.incl.pl1               >spec>install>1098>disk_table.incl.pl1
707          3    03/27/82  0430.2  ptw.l68.incl.pl1                  >ldd>include>ptw.l68.incl.pl1
708          4    11/26/84  0910.9  pc_null_address_names.incl.pl1    >ldd>include>pc_null_address_names.incl.pl1
709          5    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
710          6    11/23/82  0953.7  cmp.incl.pl1                      >ldd>include>cmp.incl.pl1
711          7    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
712          8    04/09/84  1125.2  system_clock_value_.incl.pl1      >ldd>include>system_clock_value_.incl.pl1
713          9    09/29/77  1502.7  add_type.incl.pl1                 >ldd>include>add_type.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
D                                      parameter       bit(22)                  unaligned dcl 605 ref 602 622 623 649
RS                              000102 automatic       varying char(1000)       dcl 617 set ref 621* 629* 638* 640* 650* 654
abs_usable                1(29)        based           bit(1)                   level 2 packed unaligned dcl 6-6 ref 591
abs_w                     1(28)        based           bit(1)                   level 2 packed unaligned dcl 6-6 ref 591
add                             000150 automatic       bit(24)                  level 2 in structure "sdw1" packed unaligned dcl 45
                                                                                  in procedure "display_aste" set ref 379
add                       0(01) 000101 automatic       fixed bin(17,0)          level 2 in structure "devadd" packed unsigned
                                                                                  unaligned dcl 611 in procedure "display_devadd"
                                                                                  set ref 638* 640*
add_type                  0(18)        based           bit(4)                   level 3 in structure "ptw" packed unaligned dcl 582
                                                                                  in procedure "display_ptw" ref 584
add_type                        000000 constant        structure                level 1 packed unaligned dcl 9-8 in procedure
                                                                                  "display_aste"
addr                                                   builtin function         dcl 116 ref 370 370 370 370 524 538 538 624
addrel                                                 builtin function         dcl 116 ref 268 269
addwordno                                              builtin function         dcl 116 ref 513 540 540
any_access_on             5(06)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 444*
arg                                    based           char                     unaligned dcl 22 set ref 149 155* 159 161 161 163
                                                                                  163 165 165 174 176 176 176 185 186* 189* 193 193
                                                                                  195 195 198*
argl                            000100 automatic       fixed bin(21,0)          dcl 23 set ref 148* 149 155 155 159 161 161 163 163
                                                                                  165 165 173* 174 176 176 176 183* 185 186 186 189
                                                                                  189 193 193 195 195 198 198
argp                            000102 automatic       pointer                  dcl 24 set ref 148* 149 155 159 161 161 163 163 165
                                                                                  165 173* 174 176 176 176 183* 185 186 189 193 193
                                                                                  195 195 198
argx                            000104 automatic       fixed bin(17,0)          dcl 25 set ref 147* 148* 169 172* 172 173* 180 182*
                                                                                  182 183*
array                    10            based           structure                array level 2 dcl 2-23
astap                    30            based           pointer                  level 2 dcl 1-9 ref 266
aste                                   based           structure                level 1 dcl 5-11 set ref 269 387 402 513 538 538 538
                                                                                  538 540 540
aste_offset                     000130 automatic       fixed bin(17,0)          dcl 37 set ref 145* 186* 387* 389 402 402 427* 429*
astep                           001350 automatic       pointer                  dcl 5-9 set ref 268* 269 269 387 402* 402 414 416
                                                                                  431 431 431 431 432 432 432 433 433 433 433 433
                                                                                  433 433 433 438 439 440 441 442 443 444 445 446
                                                                                  447 448 449 450 451 452 453 454 455 456 457 458
                                                                                  459 460 461 462 463 464 465 466 467 468 469 472
                                                                                  473 475 476 481 481 481 481 481 484 486 486 489
                                                                                  490 491 491 494 494 498 513 513 538 538 538 538
                                                                                  540 540 540 540
baseno                                                 builtin function         dcl 116 ref 369
baseptr                                                builtin function         dcl 116 ref 319 416
bin                                                    builtin function         dcl 116 ref 650 685
bp                        0(18)        based           bit(18)                  level 2 packed unaligned dcl 5-11 set ref 431*
byte                                                   builtin function         dcl 116 ref 688
cdt                                    parameter       char                     unaligned dcl 553 set ref 549 568* 573*
check_gate_access_              000012 constant        entry                    external dcl 49 ref 293
cleanup                         000344 stack reference condition                dcl 119 ref 124
clock_                          000100 automatic       structure                level 1 dcl 554 set ref 561* 563
clock_value                            based           structure                level 1 dcl 8-6
cmap_length                     000170 automatic       fixed bin(19,0)          dcl 56 set ref 272* 273* 273 404*
cme                                    based           structure                level 1 dcl 6-6
cmep                            001352 automatic       pointer                  dcl 6-4 set ref 589* 590 591 591 591 591 591 591 591
                                                                                  591 591
cmp                      54            based           pointer                  level 2 in structure "sst" dcl 1-9 in procedure
                                                                                  "display_aste" ref 270
cmp                             000164 automatic       pointer                  dcl 53 in procedure "display_aste" set ref 242* 404*
                                                                                  589
cmp0                            000162 automatic       pointer                  dcl 53 set ref 270* 272* 273 404*
code                            000144 automatic       fixed bin(35,0)          dcl 40 set ref 126* 127 129* 186* 187 208* 209 211*
                                                                                  231* 234 236* 244* 245 248* 252* 253* 254* 256
                                                                                  258* 272* 276 278* 290* 293* 294 296* 303* 323*
                                                                                  324 326* 338* 339 341* 355* 358* 370* 402* 404*
                                                                                  407* 417* 418 669* 670
com_err_                        000022 constant        entry                    external dcl 76 ref 129 155 189 198 211 226 236 248
                                                                                  258 278 303 326 341 348 358 374 382 391
com_err_$suppress_name          000024 constant        entry                    external dcl 76 ref 136
copy                                                   builtin function         dcl 116 ref 688
core                            000000 constant        bit(4)                   initial level 2 packed unaligned dcl 9-8 ref 584 629
core_ptw                               based           structure                level 1 dcl 583
csl                      12            based           bit(9)                   level 2 packed unaligned dcl 5-11 set ref 433 433
cu_$arg_count                   000066 constant        entry                    external dcl 100 ref 126
cu_$arg_ptr                     000070 constant        entry                    external dcl 101 ref 148 173 183
cv_oct_                         000074 constant        entry                    external dcl 103 ref 318
cv_oct_check_                   000072 constant        entry                    external dcl 102 ref 186
damaged                  13(19)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 468*
date_time_$format               000076 constant        entry                    external dcl 104 ref 573
ddnp                     12(15)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 463*
deact_error               5(10)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 448*
devadd                    1            based           bit(22)                  level 2 in structure "cme" packed unaligned dcl 6-6
                                                                                  in procedure "display_aste" set ref 590*
devadd                          000101 automatic       structure                level 1 packed unaligned dcl 611 in procedure
                                                                                  "display_devadd" set ref 623* 624
devadd_b                        000100 automatic       structure                level 1 packed unaligned dcl 607 set ref 622*
df                        0(33) 000150 automatic       bit(1)                   level 2 packed unaligned dcl 45 set ref 380
dirname                         000243 automatic       char(168)                unaligned dcl 58 set ref 208* 290* 296* 303* 303*
                                                                                  323* 331 331* 337* 338* 345* 417* 420 422*
dirsw                     5(21)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 456* 481
disk                      0(04) 000000 constant        bit(4)                   initial level 2 packed unaligned dcl 9-8 ref 631
diskname                        000142 automatic       char(8)                  unaligned dcl 39 set ref 489* 491*
dius                      5(16)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 451*
dnzp                     12(13)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 462*
drive_name               10            based           char(8)                  array level 3 dcl 2-23 ref 489
dsp0                            000154 automatic       pointer                  dcl 53 set ref 253* 370 370
dt                                     based           structure                level 1 dcl 2-23 in procedure "display_aste"
dt                                     parameter       bit(36)                  unaligned dcl 552 in procedure "fs_date_time" ref
                                                                                  549 562
dte                                    based           structure                level 1 dcl 2-35
dtm                       7            based           bit(36)                  level 2 packed unaligned dcl 5-11 set ref 475* 476
dtp                             001346 automatic       pointer                  dcl 2-17 set ref 241* 244* 247* 486 486 489 490
dtu                       6            based           bit(36)                  level 2 packed unaligned dcl 5-11 set ref 472* 473
dump_segment_                   000014 constant        entry                    external dcl 50 ref 538 540
ehs                       5(19)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 453*
ename                           000315 automatic       char(32)                 unaligned dcl 60 set ref 208* 290* 296* 303* 303*
                                                                                  323* 331* 333 337* 338* 345* 417* 420 422*
er                        1(26)        based           bit(1)                   level 2 in structure "cme" packed unaligned dcl 6-6
                                                                                  in procedure "display_aste" ref 591
er                        0(23)        based           bit(1)                   level 3 in structure "core_ptw" packed unaligned
                                                                                  dcl 583 in procedure "display_ptw" ref 586
error_table_$bad_conversion     000106 external static fixed bin(35,0)          dcl 112 set ref 189*
error_table_$badopt             000110 external static fixed bin(35,0)          dcl 114 set ref 198*
error_table_$invalidsegno       000100 external static fixed bin(35,0)          dcl 107 set ref 348*
error_table_$noarg              000104 external static fixed bin(35,0)          dcl 111 set ref 226*
error_table_$too_many_args      000102 external static fixed bin(35,0)          dcl 109 set ref 155*
expand_pathname_                000016 constant        entry                    external dcl 52 ref 208
explicit_deact_ok         5(09)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 447*
file_map_sw                     000340 automatic       bit(1)                   dcl 70 set ref 142* 193* 195* 499
first_user_seg                  000107 automatic       fixed bin(17,0)          dcl 27 set ref 320* 321 335
fixed                                                  builtin function         dcl 116 ref 262 266 273 369 379 433 433 433 433 433
                                                                                  433 433 433 498
flag_bin                        001426 automatic       fixed bin(1,0)           dcl 683 set ref 685* 686 688 688 690 692 692 694 694
flag_bit                               parameter       bit(1)                   unaligned dcl 680 ref 677 685
flag_name                              parameter       char                     unaligned dcl 681 ref 677 686 692 694
flags                     0(18)        based           structure                level 2 in structure "core_ptw" packed unaligned
                                                                                  dcl 583 in procedure "display_ptw"
flags                           000352 automatic       varying char(1000)       array dcl 658 in procedure "display_aste" set ref
                                                                                  672* 673* 688* 688 692* 692 700* 700*
flags                     0(18)        based           structure                level 2 in structure "ptw" packed unaligned dcl 582
                                                                                  in procedure "display_ptw"
fm_damaged                5(12)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 450*
fmchanged                12(09)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 465*
fmchanged1               13(18)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 466*
fms                      12(10)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 467*
force_offset                    000342 automatic       bit(1)                   dcl 71 set ref 144* 184* 206 287 366 412
force_slt                       000341 automatic       bit(1)                   dcl 71 set ref 143* 171* 206 287 307* 312
fp                                     based           bit(18)                  level 2 packed unaligned dcl 5-11 set ref 431*
frame                                  based           fixed bin(14,0)          level 2 in structure "l68_core_ptw" packed unsigned
                                                                                  unaligned dcl 3-4 in procedure "display_aste" ref
                                                                                  629
frame                                  based           fixed bin(14,0)          level 2 in structure "core_ptw" packed unsigned
                                                                                  unaligned dcl 583 in procedure "display_ptw" ref
                                                                                  589
fs_time                   0(20) 000100 automatic       bit(36)                  level 2 packed unaligned dcl 554 set ref 562*
get_line_length_$switch         000044 constant        entry                    external dcl 87 in procedure "display_aste" ref 407
get_line_length_$switch         000112 constant        entry                    external dcl 666 in procedure "flag$$init" ref 669
get_temp_segments_              000036 constant        entry                    external dcl 84 ref 231
gtms                      5(03)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 441*
gtus                      5(02)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 440*
hc                        5(04)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 414 442*
hc_part                   5(11)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 449*
hc_sdw                    5(05)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 443*
hcs_$fs_get_path_name           000050 constant        entry                    external dcl 89 ref 338
hcs_$high_low_seg_count         000046 constant        entry                    external dcl 88 ref 320
hcs_$initiate                   000052 constant        entry                    external dcl 90 ref 290
i                               000127 automatic       fixed bin(17,0)          dcl 37 set ref 263* 264 264* 514* 515 515 522 524
                                                                                  525* 527*
index                                                  builtin function         dcl 116 ref 149
infl                      1            based           bit(18)                  level 2 packed unaligned dcl 5-11 set ref 431*
infp                      1(18)        based           bit(18)                  level 2 packed unaligned dcl 5-11 set ref 431*
inhibit_cache             5(08)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 446*
init                      5(01)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 439*
io                        1(24)        based           bit(1)                   level 2 packed unaligned dcl 6-6 set ref 591*
ioa_                            000026 constant        entry                    external dcl 76 ref 427 429 431 432 433 473 476 481
                                                                                  484 491 494 520 536 537 539 586 590 591 596 700
ioa_$nnl                        000030 constant        entry                    external dcl 76 ref 510 525
ioa_$rsnnl                      000032 constant        entry                    external dcl 76 ref 629 638 640 650
iox_$user_output                000010 external static pointer                  dcl 48 in procedure "display_aste" set ref 538* 540*
iox_$user_output                000114 external static pointer                  dcl 667 in procedure "flag$$init" set ref 669*
key                       0(12) 000501 automatic       bit(6)                   level 2 packed unaligned dcl 644 set ref 650
l68_core_ptw                           based           structure                level 1 dcl 3-4
l68_ptw                                based           structure                level 1 dcl 3-9
l68_ptw_flags                          based           structure                level 1 packed unaligned dcl 3-17
last_pte                        000114 automatic       bit(36)                  dcl 32 set ref 512* 515 527*
length                                                 builtin function         dcl 116 ref 686 694
line_length                     001342 automatic       fixed bin(17,0)          dcl 661 set ref 669* 670* 686
line_used                       001340 automatic       fixed bin(17,0)          array dcl 660 set ref 674* 686 690* 694* 694
ll                              000146 automatic       fixed bin(17,0)          dcl 44 set ref 407* 408
lve                                    based           structure                level 1 dcl 2-58
master_dir                5(22)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 457*
mdc_$read_disk_table            000034 constant        entry                    external dcl 83 ref 244
msl                       4            based           bit(9)                   level 2 packed unaligned dcl 5-11 set ref 433 433
multi_class               5(13)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 458*
myname                          001661 constant        char(20)                 initial unaligned dcl 59 set ref 124* 129* 136* 155*
                                                                                  189* 198* 211* 226* 231* 236* 248* 258* 278* 303*
                                                                                  326* 341* 348* 358* 374* 382* 391* 546*
n_args                          000105 automatic       fixed bin(17,0)          dcl 26 set ref 126* 132 147 169 180
n_entries                              based           fixed bin(17,0)          level 2 dcl 2-23 ref 486
nid                       5(17)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 452*
non_null                  0(16) 000000 constant        bit(4)                   initial level 2 packed unaligned dcl 9-8 ref 627
notify_requested          1(30)        based           bit(1)                   level 2 packed unaligned dcl 6-6 ref 591
np                       12(27)        based           bit(9)                   level 2 packed unaligned dcl 5-11 set ref 433 433
npfs                     12(11)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 461*
nqsw                      5(20)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 454*
null                            000101 automatic       bit(1)                   level 2 packed unaligned dcl 611 set ref 633 636*
null_address                    000501 automatic       structure                level 1 packed unaligned dcl 644 set ref 649*
nulled                          000500 automatic       bit(1)                   unaligned dcl 619 set ref 626* 635* 638*
octal                           000126 automatic       bit(1)                   dcl 35 set ref 122* 161* 163* 501
os                        0(32)        based           bit(1)                   level 3 packed unaligned dcl 583 ref 586
p                                      parameter       pointer                  dcl 581 ref 578 584 586 586 586 586 586 586 586 586
                                                                                  586 586 589 596 596
pack_ovfl                13(20)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 469*
par_astep                 2(18)        based           bit(18)                  level 2 packed unaligned dcl 5-11 set ref 432*
pathname                        000171 automatic       char(168)                unaligned dcl 57 set ref 141* 151 159* 167 174* 178
                                                                                  185* 203 208* 211* 301 315 318* 331* 333* 345*
                                                                                  355* 358* 374* 382* 391* 420* 422* 427 429*
pathname_                       000042 constant        entry                    external dcl 86 ref 303 303 331 345 422
pc_null_address_names           000001 constant        varying char(60)         initial array dcl 4-4 set ref 650*
phcs_$initiate                  000054 constant        entry                    external dcl 90 ref 296
phm                       0(29)        based           bit(1)                   level 3 packed unaligned dcl 583 ref 586
phm1                      0(27)        based           bit(1)                   level 3 packed unaligned dcl 583 ref 586
phm_hedge                 1(32)        based           bit(1)                   level 2 packed unaligned dcl 6-6 ref 591
phu                       0(26)        based           bit(1)                   level 3 packed unaligned dcl 583 ref 586
phu1                      0(30)        based           bit(1)                   level 3 packed unaligned dcl 583 ref 586
pin_counter               3            based           fixed bin(17,0)          level 2 packed unaligned dcl 6-6 set ref 591*
pt                                     based           bit(36)                  array dcl 31 set ref 515 524 527
ptp                             000476 automatic       pointer                  dcl 618 in procedure "display_devadd" set ref 624*
                                                                                  629
ptp                             000110 automatic       pointer                  dcl 29 in procedure "display_aste" set ref 513* 515
                                                                                  524 527
ptr                                                    builtin function         dcl 116 ref 402 402 589
pts                      40            based           fixed bin(17,0)          array level 2 in structure "sst" dcl 1-9
                                                                                  in procedure "display_aste" ref 264
pts                             000325 automatic       fixed bin(3,0)           dcl 61 in procedure "display_aste" set ref 498* 514
                                                                                  515 522 540
ptsi                     13(28)        based           bit(2)                   level 2 packed unaligned dcl 5-11 set ref 498
ptsizes                         000326 automatic       fixed bin(17,0)          initial array dcl 62 set ref 62* 62* 62* 62* 264*
                                                                                  498
ptw                                    based           structure                level 1 dcl 582 ref 586 586 596 596
ptwaddr                         000145 automatic       fixed bin(18,0)          dcl 43 set ref 379* 387
ptwbase                  25            based           fixed bin(24,0)          level 2 in structure "sst" dcl 1-9 in procedure
                                                                                  "display_aste" ref 262
ptwbase                         000153 automatic       fixed bin(24,0)          dcl 47 in procedure "display_aste" set ref 262* 387
ptwp                            000112 automatic       pointer                  dcl 30 set ref 524* 526*
pvname                          000132 automatic       char(32)                 unaligned dcl 38 in procedure "display_aste" set ref
                                                                                  490* 491*
pvname                   16            based           char(32)                 array level 3 in structure "dt" dcl 2-23
                                                                                  in procedure "display_aste" ref 490
pvtx                      4(09)        based           fixed bin(8,0)           level 2 packed unaligned dcl 5-11 set ref 486 486
                                                                                  489 490 491* 494*
q                               000332 automatic       pointer                  initial array dcl 63 set ref 63* 63* 63* 123* 124*
                                                                                  231* 240 241 242 546*
quota                    10            based           fixed bin(18,0)          array level 2 packed unsigned unaligned dcl 5-11 set
                                                                                  ref 481* 481*
rastap                          000343 automatic       fixed bin(17,0)          dcl 73 set ref 266* 268
records                  12(18)        based           bit(9)                   level 2 packed unaligned dcl 5-11 set ref 433 433
rel                                                    builtin function         dcl 116 ref 266 273
release_temp_segments_          000040 constant        entry                    external dcl 84 ref 124 546
removing                  1(27)        based           bit(1)                   level 2 packed unaligned dcl 6-6 ref 591
ring0_get_$name                 000064 constant        entry                    external dcl 99 ref 323 417
ring0_get_$segptr               000062 constant        entry                    external dcl 98 ref 252 253 355
ring_zero_peek_                 000056 constant        entry                    external dcl 95 ref 254 370 402 404
ring_zero_peek_$get_max_length_ptr
                                000060 constant        entry                    external dcl 96 ref 272
rtrim                                                  builtin function         dcl 116 ref 315
sdw                                    based           structure                level 1 dcl 7-5
sdw1                            000150 automatic       structure                level 1 dcl 45 set ref 370 370 370 370
sdwa                                   based           structure                array level 1 dcl 7-24 set ref 370 370
search                                                 builtin function         dcl 116 ref 301
seg_aste                               based           structure                level 1 dcl 5-96
segno                           000131 automatic       fixed bin(17,0)          dcl 37 set ref 318* 319 321 326* 335 341* 348* 369*
                                                                                  370 370
segptr                          000156 automatic       pointer                  dcl 53 set ref 290* 291 296* 298 319* 323* 338* 355*
                                                                                  356 369 416* 417*
size                                                   builtin function         dcl 116 ref 254 254 269 370 370 387 402 513 538 538
                                                                                  540 540
skipping                        000115 automatic       bit(1)                   dcl 33 set ref 511* 515* 517 519* 522
sptp                            000166 automatic       pointer                  dcl 55 set ref 269*
sst                                    based           structure                level 1 dcl 1-9 ref 254 254
sstp                            001344 automatic       pointer                  dcl 1-7 set ref 240* 254* 254 254 262 264 266 268
                                                                                  270
sstp0                           000160 automatic       pointer                  dcl 53 set ref 252* 254* 402 402
string                                                 builtin function         dcl 116 set ref 563 622* 649*
strp                      2            based           bit(18)                  level 2 packed unaligned dcl 5-11 set ref 416 432*
sub_error_                      000104 stack reference condition                dcl 558 ref 572
substr                                                 builtin function         dcl 116 ref 427 586 586 596 596
synch_held                1(23)        based           bit(1)                   level 2 packed unaligned dcl 6-6 ref 591
synchronized             13(21)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 464*
sys_info$page_size              000020 external static fixed bin(35,0)          dcl 74 ref 629
time                            000102 automatic       fixed bin(71,0)          dcl 555 set ref 563* 564 573*
time_string                     000116 automatic       char(32)                 unaligned dcl 34 set ref 472* 473* 475* 476*
tqsw                      5(24)        based           bit(1)                   array level 2 packed unaligned dcl 5-11 set ref 459*
                                                                                  460*
type                      0(18) 000101 automatic       bit(4)                   level 2 packed unaligned dcl 611 set ref 627 629 631
                                                                                  640*
uid                       3            based           bit(36)                  level 2 packed unaligned dcl 5-11 set ref 432*
unpaged                   1(19) 000150 automatic       bit(1)                   level 2 packed unaligned dcl 45 set ref 372
unspec                                                 builtin function         dcl 116 set ref 563* 586 586 596 596 623*
usage                    10            based           fixed bin(35,0)          level 2 dcl 5-96 set ref 484*
used                     11            based           fixed bin(18,0)          array level 2 packed unsigned unaligned dcl 5-11 set
                                                                                  ref 481* 481*
usedf                     5            based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 438*
user_seg_count                  000106 automatic       fixed bin(17,0)          dcl 27 set ref 320* 335
valid                     0(33)        based           bit(1)                   level 3 packed unaligned dcl 583 ref 586
verify                                                 builtin function         dcl 116 ref 315
volmap_seg                5(23)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 455*
vtocx                     4(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-11 set ref 491* 494*
w                                      parameter       char                     unaligned dcl 224 set ref 222 226*
wired                     0(31)        based           bit(1)                   level 3 packed unaligned dcl 583 ref 586
wpl                             000152 automatic       fixed bin(17,0)          dcl 46 set ref 408* 410*
write_access_on           5(07)        based           bit(1)                   level 2 packed unaligned dcl 5-11 set ref 445*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
asta                                   based           bit(432)                 array dcl 5-86
aste_part                              based           structure                level 1 dcl 5-89
badd_type                              based           structure                level 1 packed unaligned dcl 9-15
cdevadd                                automatic       char(16)                 unaligned dcl 42
clock_value_ptr                        automatic       pointer                  dcl 8-5
cma                                    based           structure                array level 1 dcl 6-30
code                                   automatic       fixed bin(35,0)          dcl 557
core_add                               automatic       fixed bin(18,0)          dcl 64
devadd                                 automatic       bit(22)                  unaligned dcl 65
devadd_add_type                        defined         bit(4)                   unaligned dcl 66
devadd_nulled_flag                     defined         bit(1)                   unaligned dcl 67
devadd_record_no                       defined         bit(18)                  unaligned dcl 68
dtep                                   automatic       pointer                  dcl 2-17
fdevadd                                automatic       fixed bin(18,0)          dcl 41
l68_null_disk_ptw                      based           structure                level 1 dcl 3-15
l68_real_disk_ptw                      based           structure                level 1 dcl 3-14
l68_special_ptw                        based           structure                level 1 dcl 3-13
last_ptw                               automatic       bit(36)                  unaligned dcl 69
linkage_error                   000000 stack reference condition                dcl 119
lvep                                   automatic       pointer                  dcl 2-17
mcme                                   based           structure                level 1 dcl 6-32
null                                                   builtin function         dcl 615
sdwp                                   automatic       pointer                  dcl 7-3
sst_seg$                               external static fixed bin(17,0)          dcl 1-6

NAMES DECLARED BY EXPLICIT CONTEXT.
MISSING                         007263 constant        entry                    internal dcl 222 ref 169 180
NO_NAME                         007211 constant        label                    dcl 494 ref 486
PARSED                          003615 constant        label                    dcl 231 ref 218
RETURN                          003614 constant        label                    dcl 220 ref 227
TOO_MANY                        003125 constant        label                    dcl 151 set ref 167 178
USAGE                           003023 constant        label                    dcl 132 set ref 203
ZERO                            007717 constant        label                    dcl 564 ref 572
display_aste                    002647 constant        entry                    external dcl 12 ref 293 293
display_devadd                  010416 constant        entry                    internal dcl 602 ref 586 590 596
display_ptw                     010010 constant        entry                    internal dcl 578 ref 526
file_map                        007326 constant        entry                    internal dcl 508 ref 499
flag                            010742 constant        entry                    internal dcl 677 ref 438 439 440 441 442 443 444 445
                                                                                  446 447 448 449 450 451 452 453 454 455 456 457
                                                                                  458 459 460 461 462 463 464 465 466 467 468 469
flag$$display                   011113 constant        entry                    internal dcl 697 ref 479
flag$$init                      010677 constant        entry                    internal dcl 663 ref 436
fs_date_time                    007662 constant        entry                    internal dcl 549 ref 472 475
no_phcs                         004332 constant        label                    dcl 298 ref 294
octal_dump                      007453 constant        entry                    internal dcl 533 ref 501
rts                             007635 constant        entry                    internal dcl 544 ref 259 279 304 328 342 349 360 376
                                                                                  383 392 503

NAMES DECLARED BY CONTEXT OR IMPLICATION.
codeptr                                                builtin function         ref 293 293
null                                                   builtin function         ref 63 63 63 123 247 291 298 356 407 407 486

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12230       12346   11571       12240
Length     13024   11571       116         441     437           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
display_aste                       1206 external procedure  is an external procedure.  
on unit on line 124                  80 on unit               
MISSING                                 internal procedure  shares stack frame of external procedure display_aste.  
file_map                                internal procedure  shares stack frame of external procedure display_aste.  
octal_dump                              internal procedure  shares stack frame of external procedure display_aste.  
rts                                     internal procedure  shares stack frame of external procedure display_aste.  
fs_date_time                        168 internal procedure  enables or reverts conditions.  
on unit on line 572                  64 on unit               
display_ptw                             internal procedure  shares stack frame of external procedure display_aste.  
display_devadd                      372 internal procedure  uses returns(char(*)) or returns(bit(*)).  
flag$$init                              internal procedure  shares stack frame of external procedure display_aste.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
display_aste             000100 argl                        display_aste
                         000102 argp                        display_aste
                         000104 argx                        display_aste
                         000105 n_args                      display_aste
                         000106 user_seg_count              display_aste
                         000107 first_user_seg              display_aste
                         000110 ptp                         display_aste
                         000112 ptwp                        display_aste
                         000114 last_pte                    display_aste
                         000115 skipping                    display_aste
                         000116 time_string                 display_aste
                         000126 octal                       display_aste
                         000127 i                           display_aste
                         000130 aste_offset                 display_aste
                         000131 segno                       display_aste
                         000132 pvname                      display_aste
                         000142 diskname                    display_aste
                         000144 code                        display_aste
                         000145 ptwaddr                     display_aste
                         000146 ll                          display_aste
                         000150 sdw1                        display_aste
                         000152 wpl                         display_aste
                         000153 ptwbase                     display_aste
                         000154 dsp0                        display_aste
                         000156 segptr                      display_aste
                         000160 sstp0                       display_aste
                         000162 cmp0                        display_aste
                         000164 cmp                         display_aste
                         000166 sptp                        display_aste
                         000170 cmap_length                 display_aste
                         000171 pathname                    display_aste
                         000243 dirname                     display_aste
                         000315 ename                       display_aste
                         000325 pts                         display_aste
                         000326 ptsizes                     display_aste
                         000332 q                           display_aste
                         000340 file_map_sw                 display_aste
                         000341 force_slt                   display_aste
                         000342 force_offset                display_aste
                         000343 rastap                      display_aste
                         000352 flags                       display_aste
                         001340 line_used                   display_aste
                         001342 line_length                 display_aste
                         001344 sstp                        display_aste
                         001346 dtp                         display_aste
                         001350 astep                       display_aste
                         001352 cmep                        display_aste
                         001426 flag_bin                    flag$$init
display_devadd           000100 devadd_b                    display_devadd
                         000101 devadd                      display_devadd
                         000102 RS                          display_devadd
                         000476 ptp                         display_devadd
                         000500 nulled                      display_devadd
                         000501 null_address                display_devadd
fs_date_time             000100 clock_                      fs_date_time
                         000102 time                        fs_date_time

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this_desc
return              tra_ext             enable              shorten_stack       ext_entry           int_entry
int_entry_desc      return_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
check_gate_access_            com_err_                      com_err_$suppress_name        cu_$arg_count
cu_$arg_ptr                   cv_oct_                       cv_oct_check_                 date_time_$format
dump_segment_                 expand_pathname_              get_line_length_$switch       get_line_length_$switch
get_temp_segments_            hcs_$fs_get_path_name         hcs_$high_low_seg_count       hcs_$initiate
ioa_                          ioa_$nnl                      ioa_$rsnnl                    mdc_$read_disk_table
pathname_                     phcs_$initiate                release_temp_segments_        ring0_get_$name
ring0_get_$segptr             ring_zero_peek_               ring_zero_peek_$get_max_length_ptr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_conversion   error_table_$badopt           error_table_$invalidsegno     error_table_$noarg
error_table_$too_many_args    iox_$user_output              iox_$user_output              sys_info$page_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 002646        62 002654        63 002672       122 002715       123 002716       124 002731       126 002770
    127 003001       129 003003       130 003020       132 003021       136 003023       138 003050       141 003051
    142 003054       143 003055       144 003056       145 003057       147 003060       148 003067       149 003105
    151 003121       155 003125       157 003160       159 003161       160 003164       161 003165       163 003200
    165 003212       167 003222       169 003226       171 003237       172 003241       173 003242       174 003260
    175 003265       176 003266       178 003302       180 003306       182 003317       183 003320       184 003336
    185 003340       186 003356       187 003404       189 003406       190 003441       192 003442       193 003443
    195 003456       198 003470       199 003522       201 003523       203 003525       206 003531       208 003535
    209 003561       211 003563       212 003612       218 003613       220 003614       231 003615       234 003636
    236 003640       237 003667       240 003670       241 003672       242 003674       244 003676       245 003707
    247 003711       248 003713       252 003737       253 003766       254 004015       256 004034       258 004036
    259 004062       260 004063       262 004064       263 004067       264 004073       265 004077       266 004101
    268 004105       269 004110       270 004113       272 004115       273 004130       276 004135       278 004137
    279 004163       280 004164       287 004165       290 004171       291 004234       293 004240       294 004265
    296 004267       298 004332       301 004336       303 004350       304 004417       305 004420       307 004421
    312 004423       315 004425       318 004450       319 004467       320 004472       321 004503       323 004506
    324 004533       326 004535       328 004565       329 004566       331 004567       333 004614       334 004617
    335 004620       337 004624       338 004632       339 004664       341 004666       342 004721       343 004722
    345 004723       346 004743       348 004744       349 004773       350 004774       353 004775       355 004776
    356 005023       358 005027       360 005050       361 005051       366 005052       369 005054       370 005060
    372 005104       374 005107       376 005143       377 005144       379 005145       380 005150       382 005153
    383 005204       384 005205       387 005206       389 005211       391 005212       392 005243       393 005244
    402 005245       404 005270       407 005305       408 005322       410 005330       412 005332       414 005334
    416 005340       417 005345       418 005372       420 005374       422 005404       427 005424       429 005450
    431 005474       432 005531       433 005563       436 005632       438 005633       439 005652       440 005673
    441 005714       442 005735       443 005756       444 005777       445 006024       446 006051       447 006076
    448 006123       449 006147       450 006170       451 006213       452 006234       453 006255       454 006276
    455 006317       456 006343       457 006364       458 006407       459 006433       460 006454       461 006475
    462 006516       463 006537       464 006560       465 006603       466 006627       467 006652       468 006673
    469 006714       472 006740       473 006755       475 006777       476 007014       479 007036       481 007037
    484 007100       486 007123       489 007136       490 007144       491 007150       492 007210       494 007211
    498 007245       499 007253       501 007256       503 007261       504 007262       222 007263       226 007274
    227 007325       508 007326       510 007327       511 007346       512 007347       513 007350       514 007353
    515 007363       517 007375       519 007377       520 007400       522 007413       524 007421       525 007424
    526 007443       527 007445       529 007450       530 007452       533 007453       536 007454       537 007473
    538 007506       539 007552       540 007567       541 007634       544 007635       546 007636       547 007660
    549 007661       561 007675       562 007706       563 007713       564 007715       568 007717       569 007725
    572 007726       573 007745       574 010007       578 010010       584 010012       586 010024       589 010166
    590 010177       591 010233       595 010354       596 010355       599 010413       602 010415       621 010423
    622 010424       623 010431       624 010434       626 010436       627 010437       629 010450       631 010514
    633 010521       635 010524       636 010526       638 010530       639 010566       640 010567       641 010627
    649 010630       650 010633       654 010667       663 010677       669 010700       670 010713       672 010717
    673 010724       674 010730       675 010741       677 010742       685 010753       686 010763       688 010770
    690 011036       692 011042       694 011104       695 011112       697 011113       700 011114       701 011141


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
