	COMPILATION LISTING OF SEGMENT amu_definition_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/19/84  1135.3 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 amu_definition_: proc;
        7 	return;
        8 
        9 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend,ifthendo,ifthen,^thendo */
       10 
       11 
       12 dcl  P_amu_info_ptr ptr,
       13      P_entrypoint_name char (*),
       14      P_prn_name char (*),
       15      P_seg_ptr ptr,
       16      P_segno fixed bin,
       17      P_offset fixed bin (18),
       18      P_seg_name char (*),
       19      P_data_ptr ptr,
       20      P_code fixed bin (35);
       21 
       22 
       23 dcl  data_ptr ptr;
       24 dcl  ptr_data (0:7) ptr based (data_ptr);
       25 dcl  ptr_entry bit (1);
       26 dcl  prn_name char (6);
       27 dcl  def_name char (72) varying;
       28 dcl  temp_def_name char (72);
       29 dcl  def_offset fixed bin (18);
       30 dcl  d_type fixed bin;
       31 dcl  seg_ptr pointer;
       32 dcl  def_ptr pointer;
       33 dcl  last_name_entry_ptr pointer;
       34 dcl  hash_index fixed bin;
       35 dcl  code fixed bin (35);
       36 dcl  name_entry_ptr pointer;
       37 dcl  name_entry_lth fixed bin;
       38 
       39 dcl  1 name_entry aligned based (name_entry_ptr),
       40        2 next pointer unaligned,
       41        2 seg_ptr pointer unaligned,
       42        2 name_lth fixed bin,
       43        2 name char (name_entry_lth refer (name_entry.name_lth));
       44 
       45 dcl  1 cur_ptrs like hardcore_cur;
       46 
       47 dcl  ring0_get_$definition_given_slt
       48 	entry (ptr, char (*), char (*), fixed bin (18), fixed bin, fixed bin (35), ptr, ptr, ptr);
       49 dcl  amu_$hardcore_info_set_cur_ptrs entry (ptr, ptr);
       50 dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
       51 dcl  ioa_ entry () options (variable);
       52 
       53 
       54 dcl  (
       55      error_table_$bad_arg
       56      ) fixed bin (35) external static;
       57 
       58 
       59 dcl  (addr, addrel, baseptr, dimension, 
       60       fixed, length, mod, null, pointer,
       61       rank, rel, rtrim, search, substr) builtin;
       62 
       63 
       64 
       65 amu_definition_$ptr:
       66      entry (P_amu_info_ptr, P_seg_name, P_entrypoint_name, P_code) returns (ptr);
       67 	ptr_entry = "1"b;
       68 	goto comm_code;
       69 
       70 amu_definition_$offset:
       71      entry (P_amu_info_ptr, P_seg_name, P_entrypoint_name, P_code) returns (fixed bin (18));
       72 	ptr_entry = "0"b;
       73 comm_code:
       74 	amu_info_ptr = P_amu_info_ptr;
       75 	if search (P_seg_name, "<>") ^= 0 then do;	/* it's a pathname, reject it */
       76 	     P_code = error_table_$bad_arg;		/* best code I could find */
       77 	     if ptr_entry then
       78 		return (null ());
       79 	     else return (0);
       80 	     end;
       81 	call cr_def_name;
       82 
       83 	call lookup (temp_def_name);			/* sets name_entry_ptr, last_name_entry_ptr, hash_index */
       84 	call find_def;
       85 	if name_entry_ptr = null () then do;		/* not there already, we must find it */
       86 
       87 
       88 	     if code ^= 0 then do;
       89 		P_code = code;			/* Nope. */
       90 		if ptr_entry then
       91 		     return (null ());
       92 		else return (0);
       93 		end;
       94 	     def_ptr = addrel (seg_ptr, def_offset);	/* generate a pointer to the actual definition */
       95 	     call insert (temp_def_name, def_ptr);	/* insert it */
       96 	     end;
       97 
       98 	else def_ptr = name_entry.seg_ptr;		/* otherwise, copy it from the found name_entry */
       99 	P_code = 0;
      100 	if ptr_entry then
      101 	     return (def_ptr);
      102 	else return (fixed (rel (def_ptr), 18));
      103 
      104 amu_definition_$set_prn_name:
      105      entry (P_amu_info_ptr, P_prn_name, P_seg_name, P_entrypoint_name, P_code);
      106 	amu_info_ptr = P_amu_info_ptr;
      107 	prn_name = P_prn_name;
      108 	code, P_code = 0;
      109 	call set_t_idx;
      110 	if code ^= 0 then do;
      111 	     P_code = code;
      112 	     return;
      113 	end;
      114 	call cr_def_name;
      115 	call lookup (temp_def_name);
      116 	if name_entry_ptr = null () then do;
      117 	     call find_def;
      118 	     if code ^= 0 then do;
      119 		P_code = code;
      120 		return;
      121 		end;
      122 	     end;
      123 	definitions_info.t_ptrs (t_ptr_indx).val = pointer (def_ptr, def_offset);
      124 	P_code = 0;
      125 	return;
      126 
      127 amu_definition_$set_prn:
      128      entry (P_amu_info_ptr, P_prn_name, P_segno, P_offset, P_code);
      129 	amu_info_ptr = P_amu_info_ptr;
      130 	prn_name = P_prn_name;
      131 	code, P_code = 0;
      132 	call set_t_idx;
      133 	if code ^= 0 then do;
      134 	     P_code = code;
      135 	     return;
      136 	end;
      137 	definitions_info.t_ptrs (t_ptr_indx).val = pointer (baseptr (P_segno), P_offset);
      138 	return;
      139 
      140 amu_definition_$get_prn:
      141      entry (P_amu_info_ptr, P_prn_name, P_seg_ptr, P_code);
      142 	amu_info_ptr = P_amu_info_ptr;
      143 	prn_name = P_prn_name;
      144 	code, P_code = 0;
      145 	call set_t_idx;
      146 	if code ^= 0 then do;
      147 	     P_code = code;
      148 	     return;
      149 	     end;
      150 
      151 
      152 	P_seg_ptr = definitions_info.t_ptrs (t_ptr_indx).val;
      153 	return;
      154 
      155 
      156 amu_definition_$set_from:
      157      entry (P_amu_info_ptr, P_prn_name, P_data_ptr, P_code);
      158 	amu_info_ptr = P_amu_info_ptr;
      159 	prn_name = P_prn_name;
      160 	data_ptr = P_data_ptr;
      161 	code, P_code = 0;
      162 	if prn_name = "prs" then do;
      163 	     do t_ptr_indx = 0 to 7;
      164 		if addr (ptr_data (t_ptr_indx)) -> its.its_mod = ITS_MODIFIER then
      165 		     definitions_info.t_ptrs (t_ptr_indx).val = ptr_data (t_ptr_indx);
      166 		else call ioa_ ("^2w not its ^a not set", ptr_data (t_ptr_indx),
      167 			definitions_info.t_ptrs (t_ptr_indx).name);
      168 	     end;
      169 	     end;
      170 	else do;
      171 	     call set_t_idx;
      172 	     if t_ptr_indx = 8 then do;
      173 		if addr (ptr_data (6)) -> its.its_mod = ITS_MODIFIER then
      174 		     definitions_info.t_ptrs (t_ptr_indx).val = ptr_data (6);
      175 						/* special case prfr */
      176 		else call ioa_ ("^2w not its ^a not set", ptr_data (6), definitions_info.t_ptrs (t_ptr_indx).name);
      177 		return;
      178 		end;
      179 	     if t_ptr_indx = 9 then do;
      180 		call ioa_ ("prmc can not be set from");
      181 		return;
      182 		end;
      183 	     if addr (ptr_data (t_ptr_indx)) -> its.its_mod = ITS_MODIFIER then
      184 		definitions_info.t_ptrs (t_ptr_indx).val = ptr_data (t_ptr_indx);
      185 	     else call ioa_ ("^2w not its ^a not set", ptr_data (t_ptr_indx), definitions_info.t_ptrs (t_ptr_indx).name)
      186 		     ;
      187 	     end;
      188 	return;
      189 
      190 
      191 
      192 set_t_idx:
      193      proc;
      194 	code = 0;
      195 	if prn_name = "frame" | prn_name = "fr" then do;
      196 	     t_ptr_indx = 8;
      197 	     return;
      198 	     end;
      199 
      200 	if prn_name = "mcp" then do;
      201 	     t_ptr_indx = 9;
      202 	     return;
      203 	     end;
      204 
      205 
      206 	if substr (prn_name, 1, 2) = "pr" then do;
      207 	     t_ptr_indx = cv_oct_check_ (substr (prn_name, 3, 1), code);
      208 	     if code ^= 0 then do;
      209 		if prn_name = "prfr" then do;
      210 		     t_ptr_indx = 8;
      211 		     code = 0;
      212 		     return;
      213 		     end;
      214 		if prn_name = "prmc" then do;
      215 		     t_ptr_indx = 9;
      216 		     code = 0;
      217 		     return;
      218 		     end;
      219 		P_code = code;
      220 		return;
      221 		end;
      222 	     end;
      223 	else do;
      224 	     code = 0;
      225 	     do t_ptr_indx = 0 to 9;
      226 		if prn_name = definitions_info.t_ptrs (t_ptr_indx).name then return;
      227 	     end;
      228 	     end;
      229 	if t_ptr_indx > 9 then do;
      230 	     code = error_table_$bad_arg;
      231 	     return;
      232 	     end;
      233      end set_t_idx;
      234 
      235 cr_def_name:
      236      proc;
      237 	def_name = rtrim (P_seg_name);		/* construct lookup name */
      238 	def_name = def_name || "$";
      239 	def_name = def_name || rtrim (P_entrypoint_name);
      240 	temp_def_name = def_name;
      241      end cr_def_name;
      242 
      243 find_def:
      244      proc;
      245 	seg_ptr = null ();				/* indicate that this should be an output argument */
      246 	hardcore_cur_ptr = addr (cur_ptrs);
      247 	call amu_$hardcore_info_set_cur_ptrs (amu_info_ptr, hardcore_cur_ptr);
      248 	call ring0_get_$definition_given_slt (seg_ptr, P_seg_name, P_entrypoint_name, def_offset, d_type, code,
      249 	     hardcore_cur.sltp, hardcore_cur.sltntp, hardcore_cur.defp);
      250      end find_def;
      251 
      252 lookup:
      253      proc (P_name);
      254 
      255 /* *	This procedure looks up P_name in the internal name hash table, and sets
      256*   *	hash_index, name_entry_ptr, and last_name_entry_ptr appropriately. It will
      257*   *	always set hash_index correctly. If P_name is found, name_entry_ptr points
      258*   *	to the name_entry block for it, and last_name_entry_ptr will be invalid.
      259*   *	If P_name is not found, name_entry_ptr will be null, and last_name_entry_ptr
      260*   *	will either point to the last name_entry block in the chain, or be null if
      261*   *	the chain is empty. */
      262 
      263 dcl  P_name char (*) parameter;
      264 
      265 dcl  hash_sum fixed bin;
      266 dcl  idx fixed bin;
      267 
      268 	hash_sum = 43;				/* This is just to start it somewhere other than zero */
      269 						/* The choice of 43 is completely arbitrary */
      270 	do idx = 1 to length (rtrim (P_name));
      271 	     hash_sum = hash_sum + rank (substr (P_name, idx, 1));
      272 	end;
      273 
      274 	hash_index = 1 + mod (hash_sum, dimension (hash_buckets, 1));
      275 
      276 	last_name_entry_ptr = null ();
      277 	do name_entry_ptr = hash_buckets (hash_index) repeat (name_entry_ptr -> name_entry.next)
      278 	     while (name_entry_ptr ^= null ());
      279 
      280 	     last_name_entry_ptr = name_entry_ptr;
      281 
      282 	     if name_entry.name = P_name then return;	/* jackpot */
      283 	end;					/* of loop through name_entry blocks */
      284 
      285 	return;					/* all done. the pointers are set appropriately by the loop */
      286      end lookup;
      287 
      288 
      289 
      290 insert:
      291      proc (P_name, P_ptr);
      292 
      293 /* *	This procedure adds another name_entry block to the appropriate chain for
      294*   *	the association of P_name and P_ptr. It assumes that hash_index and
      295*   *	last_name_entry_ptr have already been set properly (presumably by lookup). */
      296 
      297 dcl  (
      298      P_name char (*),
      299      P_ptr pointer
      300      ) parameter;
      301 
      302 
      303 	name_entry_lth = length (rtrim (P_name));
      304 
      305 	allocate name_entry in (amu_area) set (name_entry_ptr);
      306 
      307 	name_entry.next = null ();			/* initialize values */
      308 	name_entry.seg_ptr = P_ptr;
      309 	name_entry.name_lth = name_entry_lth;
      310 	name_entry.name = P_name;
      311 
      312 	if last_name_entry_ptr ^= null () then		/* and string in -- after last one, if there was such; */
      313 	     last_name_entry_ptr -> name_entry.next = name_entry_ptr;
      314 	else hash_buckets (hash_index) = name_entry_ptr;
      315 
      316 	return;					/* all done */
      317      end insert;
      318 
      319 
  1     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  1     2 
  1     3 dcl  sdwp ptr;
  1     4 
  1     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  1     6 
  1     7    (2 add bit (24),					/* main memory address of page table */
  1     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  1     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  1    10     2 df_no bit (2),				/* directed fault number */
  1    11 
  1    12     2 pad1 bit (1),
  1    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  1    14     2 access,					/* access bits */
  1    15       3 read bit (1),				/* read permission bit */
  1    16       3 execute bit (1),				/* execute permission bit */
  1    17       3 write bit (1),				/* write permission bit */
  1    18       3 privileged bit (1),				/* privileged bit */
  1    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  1    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  1    21     2 cache bit (1),				/* cache enable bit */
  1    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  1    23 
  1    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  1    25 
  1    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      320 
      321 
  2     1 /*	BEGIN INCLUDE FILE amu_info.incl.pl1		*/
  2     2 
  2     3 dcl 1 amu_info aligned based (amu_info_ptr),
  2     4     2 version char (8) aligned,			/* AMU_INFO_VERSION */
  2     5     2 flags aligned,
  2     6       3 early_dump bit(1) unal,
  2     7       3 pad  bit(35) unal,
  2     8     2 type fixed bin unal,				/* One of the types below */
  2     9     2 time_created fixed bin (71) aligned,		/* time created -- for debugging purposes */
  2    10     2 chain,					/* a chain of all the amu_info's which exist */
  2    11       3 prev pointer unaligned,
  2    12       3 next pointer unaligned,
  2    13 
  2    14     2 area_ptr pointer,				/* pointer to area used for allocating things */
  2    15 
  2    16     2 translation_table_ptr pointer,			/* pointer to address map -- always present */
  2    17 						/*   SEE: amu_translation.incl.pl1 */
  2    18     2 fdump_info_ptr pointer, 			
  2    19 						/* pointer to FDUMP info, present if looking at an FDUMP */
  2    20 						/*   SEE: amu_fdump_info.incl.pl1 */
  2    21 						/* old_uid_table pointer if looking at a SAVED PROC. */
  2    22 						/* See: amu_old_uid_table			*/
  2    23 	
  2    24 
  2    25     2 hardcore_info_ptr pointer,			/* pointer to hardcore information -- always present */
  2    26 						/*   SEE: amu_hardcore_info.incl.pl1 */
  2    27     2 copy_chain pointer,				/* pointer to info about segment copies */
  2    28 						/*   SEE: amu_copy_info.incl.pl1 */
  2    29     2 process_info_ptr pointer,			/* pointer to process info for this translation */
  2    30 						/*   SEE: amu_process_info.incl.pl1 */
  2    31     2 process_idx fixed bin,				/* index of process in translation-specifc process table */
  2    32 
  2    33     2 proc_idx_hold fixed bin,			/* a place to keep the index when a changing to another proc */
  2    34 
  2    35     2 error_info,					/* various info about how amu_error_ is to behave */
  2    36       3 error_flags aligned,
  2    37         4 handler_exists bit (1) unaligned,		/* set to indicate existence of an amu_error handler */
  2    38         4 in_subsystem bit (1) unaligned,		/* This amu_info belongs to an ssu_ maintained subsystem */
  2    39         4 pad bit (34) unaligned,
  2    40       3 sci_ptr pointer,				/* sci_ptr for subsystem, if in_subsystem = "1"b */
  2    41     2 definitions_info_ptr ptr;
  2    42 
  2    43 dcl  amu_area area based (amu_info.area_ptr);
  2    44 
  2    45 dcl  amu_info_ptr pointer;
  2    46 
  2    47 dcl (FDUMP_TYPE		init (1037),		/* the various legitimate types of amu_info's */
  2    48      FDUMP_PROCESS_TYPE	init (1038),
  2    49      ONLINE_TYPE		init (1039),
  2    50      ONLINE_PROCESS_TYPE	init (1040),
  2    51      NETWORK_FDUMP_TYPE	init (1041),
  2    52      NETWORK_ONLINE_TYPE	init (1042),
  2    53      SAVED_PROC_TYPE	init (1043),
  2    54      INDIRECT_TYPE		init (1044)) fixed bin internal static options (constant);
  2    55 
  2    56 dcl  AMU_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_v1");
  2    57 dcl  AMU_INFO_VERSION char (8) internal static options (constant) init ("amu_v1");
  2    58 dcl  AMU_INFO_VERSION_2 char (8) internal static options (constant) init ("amu_v2");
  2    59 
  2    60 dcl  PDIR_SUFFIX		char(4) init("pdir") int static options(constant);
  2    61 
  2    62 /*	END INCLUDE FILE amu_info.incl.pl1		*/
      322 
      323 
  3     1 /* Begin amu_definitions.incl.pl1  */
  3     2 /* This is a place to keep the definitions for a translation */
  3     3 
  3     4 dcl 1 definitions_info based (amu_info.definitions_info_ptr),
  3     5     2 hash_buckets (127) pointer unaligned,
  3     6     2 t_ptrs (0:9),
  3     7        3 name char (4),
  3     8        3 val ptr unal,
  3     9     2 pad fixed bin;
  3    10 
  3    11 dcl t_ptr_indx fixed bin;
  3    12 dcl  init_ptr_names (0:9) char (4) init ("ap", "ab", "bp", "bb", "lp", "lb", "sp", "sb", "prfr", "prmc");
  3    13 	
  3    14 
  3    15 /* End amu_definitions_info.incl.pl1 */
      324 
      325 
  4     1 /*	BEGIN INCLUDE FILE amu_hardcore_info.incl.pl1	*/
  4     2 
  4     3 /* This structure contains information about the hardcore supervisor address
  4     4*   space for an address translation. */
  4     5 
  4     6 dcl 1 hardcore_info aligned based (amu_info.hardcore_info_ptr),
  4     7 
  4     8     2 pointers,					/* assorted pointers to various useful items */
  4     9       3 slt aligned,				/* SLT */
  4    10         4 fptr pointer unaligned,			/* address in foreign address space */
  4    11         4 lptr pointer unaligned,			/* location in local address space */
  4    12       3 sltnt aligned like hardcore_info.slt,		/* SLT names segment */
  4    13       3 definitions aligned like hardcore_info.slt,	/* hardcore definitions_ segment */
  4    14 
  4    15       3 sst aligned like hardcore_info.slt,		/* SST */
  4    16       3 tc_data aligned like hardcore_info.slt,		/* TC_DATA */
  4    17       3 sstnt aligned like hardcore_info.slt,		/* SSTNT (if any -- foreign_ptr = null if not) */
  4    18       3 upt aligned like hardcore_info.slt,		/* unpaged_page_tables (if any -- foreign_ptr = null if not) */
  4    19 
  4    20     2 segno,					/* segment numbers of various per-process/per-processor segs */
  4    21       3 prds fixed bin (15),				/* segno of PRDS */
  4    22       3 dseg fixed bin (15),				/* DSEG */
  4    23       3 pds fixed bin (15),				/* PDS */
  4    24       3 kst fixed bin (15),				/* KST */
  4    25       3 stack_0 fixed bin (15),			/* segno of stack_0 -- first one in stack group */
  4    26       3 unpaged_page_tables fixed bin(15),		/* segno of unpaged_page_tables if it exists */
  4    27 
  4    28     2 apt,					/* information about the APT */
  4    29       3 foreign_ptr pointer unaligned,			/* foreign and local pointers to tcm.apt */
  4    30       3 local_ptr pointer unaligned,
  4    31       3 count fixed bin,				/* number of APTEs */
  4    32       3 size fixed bin,				/* size of a single APTE */
  4    33 
  4    34     2 hcs_count fixed bin,				/* highest hardcore segno */
  4    35 
  4    36     2 pad1 fixed bin;
  4    37 
  4    38 dcl hardcore_cur_ptr ptr;
  4    39 
  4    40 dcl 1 hardcore_cur based (hardcore_cur_ptr),
  4    41     2 sltp ptr,
  4    42     2 sltntp ptr,
  4    43     2 defp ptr,
  4    44     2 sstp ptr,
  4    45     2 tc_datap ptr,
  4    46     2 sstntp ptr,
  4    47     2 uptp ptr;
  4    48 	
  4    49     
  4    50 
  4    51 
  4    52 /*	END INCLUDE FILE amu_hardcore_info.incl.pl1	*/
      326 
      327 
  5     1 /* BEGIN INCLUDE FILE its.incl.pl1
  5     2*   modified 27 July 79 by JRDavis to add its_unsigned
  5     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  5     4 
  5     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  5     6     2 pad1 bit (3) unaligned,
  5     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  5     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  5     9     2 pad2 bit (9) unaligned,
  5    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  5    11 
  5    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  5    13     2 pad3 bit (3) unaligned,
  5    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  5    15     2 pad4 bit (3) unaligned,
  5    16     2 mod bit (6) unaligned;				/* further modification */
  5    17 
  5    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  5    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  5    20     2 pad1 bit (27) unaligned,
  5    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  5    22 
  5    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  5    24     2 pad2 bit (3) unaligned,
  5    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  5    26     2 pad3 bit (3) unaligned,
  5    27     2 mod bit (6) unaligned;				/* further modification */
  5    28 
  5    29 
  5    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  5    31     2 pad1 bit (3) unaligned,
  5    32     2 segno fixed bin (15) unsigned unaligned,
  5    33     2 ringno fixed bin (3) unsigned unaligned,
  5    34     2 pad2 bit (9) unaligned,
  5    35     2 its_mod bit (6) unaligned,
  5    36 
  5    37     2 offset fixed bin (18) unsigned unaligned,
  5    38     2 pad3 bit (3) unaligned,
  5    39     2 bit_offset fixed bin (6) unsigned unaligned,
  5    40     2 pad4 bit (3) unaligned,
  5    41     2 mod bit (6) unaligned;
  5    42 
  5    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  5    44     2 pr_no fixed bin (3) unsigned unaligned,
  5    45     2 pad1 bit (27) unaligned,
  5    46     2 itp_mod bit (6) unaligned,
  5    47 
  5    48     2 offset fixed bin (18) unsigned unaligned,
  5    49     2 pad2 bit (3) unaligned,
  5    50     2 bit_offset fixed bin (6) unsigned unaligned,
  5    51     2 pad3 bit (3) unaligned,
  5    52     2 mod bit (6) unaligned;
  5    53 
  5    54 
  5    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  5    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  5    57 
  5    58 /* END INCLUDE FILE   its.incl.pl1 */
      328 
      329      end amu_definition_;				/* External procedure */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/84  1445.3  amu_definition_.pl1               >special_ldd>online>6897-11/15/84>amu_definition_.pl1
320          1    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
322          2    11/15/84  1524.3  amu_info.incl.pl1                 >special_ldd>online>6897-11/15/84>amu_info.incl.pl1
324          3    09/22/83  1102.5  amu_definitions.incl.pl1          >ldd>include>amu_definitions.incl.pl1
326          4    11/15/84  1437.4  amu_hardcore_info.incl.pl1        >special_ldd>online>6897-11/15/84>amu_hardcore_info.incl.pl1
328          5    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ITS_MODIFIER                           constant        bit(6)                   initial unaligned dcl 5-55 ref 164 173 183
P_amu_info_ptr                         parameter       pointer                  dcl 12 ref 65 70 73 104 106 127 129 140 142 156 158
P_code                                 parameter       fixed bin(35,0)          dcl 12 set ref 65 70 76* 89* 99* 104 108* 111* 119*
                                                                                  124* 127 131* 134* 140 144* 147* 156 161* 219*
P_data_ptr                             parameter       pointer                  dcl 12 ref 156 160
P_entrypoint_name                      parameter       char                     unaligned dcl 12 set ref 65 70 104 239 248*
P_name                                 parameter       char                     unaligned dcl 263 in procedure "lookup" ref 252 270
                                                                                  271 282
P_name                                 parameter       char                     unaligned dcl 297 in procedure "insert" ref 290 303
                                                                                  310
P_offset                               parameter       fixed bin(18,0)          dcl 12 ref 127 137
P_prn_name                             parameter       char                     unaligned dcl 12 ref 104 107 127 130 140 143 156 159
P_ptr                                  parameter       pointer                  dcl 297 ref 290 308
P_seg_name                             parameter       char                     unaligned dcl 12 set ref 65 70 75 104 237 248*
P_seg_ptr                              parameter       pointer                  dcl 12 set ref 140 152*
P_segno                                parameter       fixed bin(17,0)          dcl 12 ref 127 137
addr                                                   builtin function         dcl 59 ref 164 173 183 246
addrel                                                 builtin function         dcl 59 ref 94
amu_$hardcore_info_set_cur_ptrs 000012 constant        entry                    external dcl 49 ref 247
amu_area                               based           area(1024)               dcl 2-43 ref 305
amu_info                               based           structure                level 1 dcl 2-3
amu_info_ptr                    000210 automatic       pointer                  dcl 2-45 set ref 73* 106* 123 129* 137 142* 152 158*
                                                                                  164 166 173 176 183 185 226 247* 274 277 305 314
area_ptr                 10            based           pointer                  level 2 dcl 2-3 ref 305
baseptr                                                builtin function         dcl 59 ref 137
code                            000165 automatic       fixed bin(35,0)          dcl 35 set ref 88 89 108* 110 111 118 119 131* 133
                                                                                  134 144* 146 147 161* 194* 207* 208 211* 216* 219
                                                                                  224* 230* 248*
cur_ptrs                        000172 automatic       structure                level 1 unaligned dcl 45 set ref 246
cv_oct_check_                   000014 constant        entry                    external dcl 50 ref 207
d_type                          000154 automatic       fixed bin(17,0)          dcl 30 set ref 248*
data_ptr                        000100 automatic       pointer                  dcl 23 set ref 160* 164 164 166 173 173 176 183 183
                                                                                  185
def_name                        000106 automatic       varying char(72)         dcl 27 set ref 237* 238* 238 239* 239 240
def_offset                      000153 automatic       fixed bin(18,0)          dcl 29 set ref 94 123 248*
def_ptr                         000160 automatic       pointer                  dcl 32 set ref 94* 95* 98* 100 102 123
definitions_info                       based           structure                level 1 unaligned dcl 3-4
definitions_info_ptr     32            based           pointer                  level 2 dcl 2-3 ref 123 137 152 164 166 173 176 183
                                                                                  185 226 274 277 314
defp                      4            based           pointer                  level 2 dcl 4-40 set ref 248*
dimension                                              builtin function         dcl 59 ref 274
error_table_$bad_arg            000020 external static fixed bin(35,0)          dcl 54 ref 76 230
fixed                                                  builtin function         dcl 59 ref 102
hardcore_cur                           based           structure                level 1 unaligned dcl 4-40
hardcore_cur_ptr                000226 automatic       pointer                  dcl 4-38 set ref 246* 247* 248 248 248
hardcore_info                          based           structure                level 1 dcl 4-6
hash_buckets                           based           pointer                  array level 2 packed unaligned dcl 3-4 set ref 274
                                                                                  277 314*
hash_index                      000164 automatic       fixed bin(17,0)          dcl 34 set ref 274* 277 314
hash_sum                        000276 automatic       fixed bin(17,0)          dcl 265 set ref 268* 271* 271 274
idx                             000277 automatic       fixed bin(17,0)          dcl 266 set ref 270* 271*
init_ptr_names                  000213 automatic       char(4)                  initial array unaligned dcl 3-12 set ref 3-12* 3-12*
                                                                                  3-12* 3-12* 3-12* 3-12* 3-12* 3-12* 3-12* 3-12*
ioa_                            000016 constant        entry                    external dcl 51 ref 166 176 180 185
its                                    based           structure                level 1 dcl 5-5
its_mod                   0(30)        based           bit(6)                   level 2 packed unaligned dcl 5-5 ref 164 173 183
last_name_entry_ptr             000162 automatic       pointer                  dcl 33 set ref 276* 280* 312 312
length                                                 builtin function         dcl 59 ref 270 303
mod                                                    builtin function         dcl 59 ref 274
name                      3            based           char                     level 2 in structure "name_entry" dcl 39
                                                                                  in procedure "amu_definition_" set ref 282 310*
name                    177            based           char(4)                  array level 3 in structure "definitions_info" packed
                                                                                  unaligned dcl 3-4 in procedure "amu_definition_"
                                                                                  set ref 166* 176* 185* 226
name_entry                             based           structure                level 1 dcl 39 set ref 305
name_entry_lth                  000170 automatic       fixed bin(17,0)          dcl 37 set ref 303* 305 305 309
name_entry_ptr                  000166 automatic       pointer                  dcl 36 set ref 85 98 116 277* 277* 280 282* 283 305*
                                                                                  307 308 309 310 312 314
name_lth                  2            based           fixed bin(17,0)          level 2 dcl 39 set ref 282 305* 309* 310
next                                   based           pointer                  level 2 packed unaligned dcl 39 set ref 283 307*
                                                                                  312*
null                                                   builtin function         dcl 59 ref 77 85 90 116 245 276 277 307 312
pointer                                                builtin function         dcl 59 ref 123 137
pointers                               based           structure                level 2 dcl 4-6
prn_name                        000104 automatic       char(6)                  unaligned dcl 26 set ref 107* 130* 143* 159* 162 195
                                                                                  195 200 206 207 207 209 214 226
ptr_data                               based           pointer                  array dcl 24 set ref 164 164 166* 173 173 176* 183
                                                                                  183 185*
ptr_entry                       000102 automatic       bit(1)                   unaligned dcl 25 set ref 67* 72* 77 90 100
rank                                                   builtin function         dcl 59 ref 271
rel                                                    builtin function         dcl 59 ref 102
ring0_get_$definition_given_slt 000010 constant        entry                    external dcl 47 ref 248
rtrim                                                  builtin function         dcl 59 ref 237 239 270 303
sdw                                    based           structure                level 1 dcl 1-5
search                                                 builtin function         dcl 59 ref 75
seg_ptr                         000156 automatic       pointer                  dcl 31 in procedure "amu_definition_" set ref 94
                                                                                  245* 248*
seg_ptr                   1            based           pointer                  level 2 in structure "name_entry" packed unaligned
                                                                                  dcl 39 in procedure "amu_definition_" set ref 98
                                                                                  308*
slt                                    based           structure                level 3 dcl 4-6
sltntp                    2            based           pointer                  level 2 dcl 4-40 set ref 248*
sltp                                   based           pointer                  level 2 dcl 4-40 set ref 248*
substr                                                 builtin function         dcl 59 ref 206 207 207 271
t_ptr_indx                      000212 automatic       fixed bin(17,0)          dcl 3-11 set ref 123 137 152 163* 164 164 164 166
                                                                                  166* 172 173 176 179 183 183 183 185 185 196* 201*
                                                                                  207* 210* 215* 225* 226* 229
t_ptrs                  177            based           structure                array level 2 packed unaligned dcl 3-4
temp_def_name                   000131 automatic       char(72)                 unaligned dcl 28 set ref 83* 95* 115* 240*
val                     200            based           pointer                  array level 3 packed unaligned dcl 3-4 set ref 123*
                                                                                  137* 152 164* 173* 183*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AMU_INFO_VERSION                       internal static char(8)                  initial unaligned dcl 2-57
AMU_INFO_VERSION_1                     internal static char(8)                  initial unaligned dcl 2-56
AMU_INFO_VERSION_2                     internal static char(8)                  initial unaligned dcl 2-58
FDUMP_PROCESS_TYPE                     internal static fixed bin(17,0)          initial dcl 2-47
FDUMP_TYPE                             internal static fixed bin(17,0)          initial dcl 2-47
INDIRECT_TYPE                          internal static fixed bin(17,0)          initial dcl 2-47
ITP_MODIFIER                           internal static bit(6)                   initial unaligned dcl 5-56
NETWORK_FDUMP_TYPE                     internal static fixed bin(17,0)          initial dcl 2-47
NETWORK_ONLINE_TYPE                    internal static fixed bin(17,0)          initial dcl 2-47
ONLINE_PROCESS_TYPE                    internal static fixed bin(17,0)          initial dcl 2-47
ONLINE_TYPE                            internal static fixed bin(17,0)          initial dcl 2-47
PDIR_SUFFIX                            internal static char(4)                  initial unaligned dcl 2-60
SAVED_PROC_TYPE                        internal static fixed bin(17,0)          initial dcl 2-47
itp                                    based           structure                level 1 dcl 5-18
itp_unsigned                           based           structure                level 1 dcl 5-43
its_unsigned                           based           structure                level 1 dcl 5-30
sdwa                                   based           structure                array level 1 dcl 1-24
sdwp                                   automatic       pointer                  dcl 1-3

NAMES DECLARED BY EXPLICIT CONTEXT.
amu_definition_                 000132 constant        entry                    external dcl 6
amu_definition_$get_prn         000717 constant        entry                    external dcl 140
amu_definition_$offset          000215 constant        entry                    external dcl 70
amu_definition_$ptr             000161 constant        entry                    external dcl 65
amu_definition_$set_from        001015 constant        entry                    external dcl 156
amu_definition_$set_prn         000606 constant        entry                    external dcl 127
amu_definition_$set_prn_name    000443 constant        entry                    external dcl 104
comm_code                       000241 constant        label                    dcl 73 ref 68
cr_def_name                     001507 constant        entry                    internal dcl 235 ref 81 114
find_def                        001604 constant        entry                    internal dcl 243 ref 84 117
insert                          001777 constant        entry                    internal dcl 290 ref 95
lookup                          001672 constant        entry                    internal dcl 252 ref 83 115
set_t_idx                       001341 constant        entry                    internal dcl 192 ref 109 132 145 171

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2544        2566    2312        2554
Length      3102    2312        22         300     232           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
amu_definition_                     298 external procedure  is an external procedure.  
set_t_idx                               internal procedure  shares stack frame of external procedure amu_definition_.  
cr_def_name                             internal procedure  shares stack frame of external procedure amu_definition_.  
find_def                                internal procedure  shares stack frame of external procedure amu_definition_.  
lookup                                  internal procedure  shares stack frame of external procedure amu_definition_.  
insert                                  internal procedure  shares stack frame of external procedure amu_definition_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
amu_definition_          000100 data_ptr                    amu_definition_
                         000102 ptr_entry                   amu_definition_
                         000104 prn_name                    amu_definition_
                         000106 def_name                    amu_definition_
                         000131 temp_def_name               amu_definition_
                         000153 def_offset                  amu_definition_
                         000154 d_type                      amu_definition_
                         000156 seg_ptr                     amu_definition_
                         000160 def_ptr                     amu_definition_
                         000162 last_name_entry_ptr         amu_definition_
                         000164 hash_index                  amu_definition_
                         000165 code                        amu_definition_
                         000166 name_entry_ptr              amu_definition_
                         000170 name_entry_lth              amu_definition_
                         000172 cur_ptrs                    amu_definition_
                         000210 amu_info_ptr                amu_definition_
                         000212 t_ptr_indx                  amu_definition_
                         000213 init_ptr_names              amu_definition_
                         000226 hardcore_cur_ptr            amu_definition_
                         000276 hash_sum                    lookup
                         000277 idx                         lookup

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              mod_fx1             signal              ext_entry
ext_entry_desc      alloc_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$hardcore_info_set_cur_ptrs                             cv_oct_check_                 ioa_
ring0_get_$definition_given_slt

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 3   12 000055         6 000131         7 000142        65 000154        67 000205        68 000207        70 000210
     72 000240        73 000241        75 000245        76 000264        77 000267        79 000304        81 000317
     83 000320        84 000323        85 000324        88 000330        89 000332        90 000333        92 000351
     94 000364        95 000370        96 000373        98 000374        99 000377       100 000400       102 000416
    104 000435       106 000474       107 000500       108 000506       109 000510       110 000511       111 000513
    112 000514       114 000526       115 000527       116 000532       117 000536       118 000537       119 000541
    120 000542       123 000554       124 000565       125 000566       127 000601       129 000627       130 000633
    131 000641       132 000643       133 000644       134 000646       135 000647       137 000661       138 000676
    140 000712       142 000740       143 000744       144 000752       145 000754       146 000755       147 000757
    148 000760       152 000772       153 001001       156 001013       158 001036       159 001042       160 001050
    161 001053       162 001055       163 001063       164 001067       166 001104       168 001136       169 001140
    171 001141       172 001142       173 001145       176 001160       177 001213       179 001225       180 001227
    181 001246       183 001260       185 001275       188 001327       192 001341       194 001342       195 001343
    196 001356       197 001360       200 001361       201 001367       202 001371       206 001372       207 001376
    208 001424       209 001426       210 001434       211 001436       212 001437       214 001440       215 001446
    216 001450       217 001451       219 001452       220 001454       222 001455       224 001456       225 001457
    226 001463       227 001475       229 001477       230 001502       231 001505       233 001506       235 001507
    237 001510       238 001536       239 001545       240 001577       241 001603       243 001604       245 001605
    246 001607       247 001611       248 001622       250 001671       252 001672       268 001703       270 001705
    271 001727       272 001736       274 001740       276 001745       277 001747       280 001760       282 001762
    283 001773       285 001776       290 001777       303 002010       305 002024       307 002037       308 002041
    310 002045       312 002053       314 002061       316 002065


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
