	COMPILATION LISTING OF SEGMENT monitor_cache
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 03/01/88  1330.8 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(87-11-25,Fawcett), approve(87-11-25,MCR7798),
       14*     audit(88-02-22,Parisek), install(88-03-01,MR12.2-1031):
       15*     Change to initialize the variable fact_dividend to the default value of
       16*     15.
       17*                                                   END HISTORY COMMENTS */
       18 
       19 
       20 monitor_cache: proc ();
       21 
       22 /* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
       23 
       24 
       25 
       26 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * *
       27*
       28*          Name:	monitor_cache
       29*          
       30*          The monitor_cache command initiates and controls automatic monitoring of
       31*          cache memory error data saved during normal fault processing.  This command
       32*          should be used to constantly monitor the cache memory error data to provide
       33*          a warning when error rates become excessive.  Error rate threshold values
       34*          are compared against a per system, using the -priv control argument
       35*          described below, or a per process threshold.  See "Changing the Threshold
       36*          Values", below for information pertaining to changing the per-system
       37*          defaults and for setting up per-process values that are different from the
       38*          per-system defaults.  The current threshold values may be displayed using
       39*          the display_cache_treshold command.
       40*          
       41*          Usage:	monitor_cache {list} {-control_arguments}
       42*          
       43*          where:
       44*          
       45*          1. list	is a list of cpu tags whose cache error rates should be monitored.
       46*          	If list is not provided, then all possible cpu's will be monitored.
       47*          
       48*          2. -control_arguments may be chosen from the following:
       49*          
       50*             -brief, -bf
       51*                    suppresses the "Cpu cpu_tag below cache error threshold." message
       52*          	when the error rate is within the specified threshold limits. This
       53*          	does not suppress the warning when the error rate is above the
       54*          	threshold values. This is the default.
       55*          
       56*             -long, -lg
       57*          	emits a "Cpu cpu_tag below cache error threshold." message on
       58*          	the user_output i/o switch.
       59*          
       60*             -cpu   cpu_list
       61*          	an alternate method of specifying list, above.
       62*          
       63*             -priv  causes  warning messages of "Cache above error threshold for cpu
       64*          	cpu_tag." to be written into the syserr_log and output to the
       65*          	operator console with an audible alarm. The use of this control
       66*          	argument uses the per system threshold values in
       67*          	>tools>cache_threshold_defaults_. The use of this control argument
       68*          	causes the polling message described under -long above to be
       69*          	put into the syserr_log instead of the user_output i/o switch.
       70*          	The use of this control argument requires re access to the hphcs_ 
       71*          	gate.
       72*          
       73*             -stop, -sp
       74*          	stops monitoring for the cpu's in the list argument or the operands
       75*          	of the -cpu control argument. If no cpu tags have been specified,
       76*          	then monitoring for all cpus is terminated.
       77*          
       78*             -start, -sr
       79*          	resumes monitoring for cpu's specified by the list argument or the
       80*          	operands of the -cpu control argument. Monitoring will continue with
       81*          	the next scheduled cycle.
       82*          
       83*             -time N, -tm N
       84*          	specifies the monitoring interval in minutes. The default time is 15
       85*          	minutes.
       86*          
       87*          Notes:
       88*          
       89*          Use of this command requires re access to the phcs_ gate.
       90*          
       91*          The monitor interval is closely associated with the threshold values
       92*          in that the threshold is specified in terms of an acceptable error
       93*          rate N in X time.  
       94*          	
       95*          Changing the Threshold Values:
       96*          
       97*          The per-system and per-process default threshold values are defined in
       98*          >system_library_tools>cache_threshold_defaults_.  This segment is created by
       99*          a cds source segment of the same name.  In order to change the system
      100*          default values, it is necessary to change this source segment, recompile and
      101*          install the generated object in >tools.  A per-process threshold that is
      102*          different from the per-system values may be created by performing the same
      103*          operations, except that it should be found in the process' object search
      104*          rules before >tools or it may be specifically initiated.
      105*                    	
      106*       Status:
      107*         	0) Created:     2/84 by GA Texada
      108*
      109**  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      110 
      111 dcl cache_meters_$for_monitor entry (ptr, fixed bin, fixed bin (35)),
      112   com_err_	     entry () options (variable),
      113   cu_$arg_count	     entry (fixed bin, fixed bin (35)),
      114   cu_$arg_ptr	     entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
      115   hcs_$get_user_effmode  entry (char (*), char (*), char (*), fixed bin, fixed bin (5),
      116 		     fixed bin (35)),
      117   hcs_$initiate	     entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr,
      118 		     fixed bin (35)),
      119   hcs_$make_ptr	     entry (ptr, char (*), char (*), ptr, fixed bin (35)),
      120   hcs_$terminate_noname  entry (ptr, fixed bin (35)),
      121   hphcs_$syserr	     entry options (variable),
      122   get_temp_segment_	     entry (char (*), ptr, fixed bin (35)),
      123   release_temp_segment_  entry (char (*), ptr, fixed bin (35)),
      124   ioa_		     entry () options (variable),
      125   ipc_$create_ev_chn     entry (fixed bin (71), fixed bin (35)),
      126   ipc_$decl_ev_call_chn  entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35)),
      127   timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71)),
      128   timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
      129 
      130 dcl (error_table_$bad_arg,
      131   error_table_$badcall,
      132   error_table_$bad_conversion,
      133   error_table_$badopt,
      134   error_table_$inconsistent,
      135   error_table_$not_privileged) fixed bin (35) ext static;
      136 
      137 dcl CPU_TAGS	     char (16) int static init ("ABCDEFGHabcdefgh") options (constant),
      138   DEFAULT_INTERVAL	     fixed bin int static init (15) options (constant),
      139 						/* 15 minutes is default interval		*/
      140   DEFAULT_SET	     bit (8) int static init ((8)"1"b) options (constant),
      141 						/* all cpus				*/
      142   TRUE		     bit (1) int static init ("1"b) options (constant),
      143   FALSE		     bit (1) int static init ("0"b) options (constant),
      144   myname		     char (13) init ("monitor_cache") int static options (constant);
      145 
      146 dcl ap		     ptr,
      147   Arg		     char (al) based (ap),
      148   (Nargs, ncpus, i, j)   fixed bin,
      149   al		     fixed bin (21),
      150   (countersp, static_threshold_ptr) ptr int static init (null ()),
      151   (brief, inited, priv)  bit (1) init static init ("0"b),
      152   (error_found, got_a_cpu, interval, start, stop) bit (1),
      153   code		     fixed bin (35),
      154   acpu_list	     bit (8) init ((8)"0"b),
      155   cpu_list	     bit (8) int static init ((8)"0"b),
      156   factor_dividend	     fixed dec (30, 2),
      157   factor		     fixed dec (30, 2) int static init (0),
      158   monitor_interval	     fixed bin (71) int static init (0),
      159   monitor_wakeup_chn     fixed bin (71) int static init (-1),
      160   (amonitor_interval, start_hack) fixed bin (71);
      161 
      162 dcl 1 cache_counters     (MAX_CPUS) aligned based (countersp),
      163     2 cpu_tag	     fixed bin (35),
      164     2 cache_type	     fixed bin (35),
      165     2 cache_err_ctrs     (17) fixed bin (35);
      166 
      167 dcl cleanup	     condition;
      168 
      169 dcl (clock, divide, fixed, index, mod, null, substr, verify) builtin;
      170 
      171 
      172 
      173 	call check_phcs_access (code);		/* if he doesn't have this then forget trying	*/
      174 	if code ^= 0 then do;			/* because we can't get the meter data		*/
      175 	    call com_err_ (code, myname, "Access to phcs_ is required.");
      176 						/* from cache_meters_$for_monitor		*/
      177 	    return;
      178 	  end;
      179 	if ^inited then do;
      180 	    brief = TRUE;
      181 	    priv = FALSE;
      182 	  end;
      183           factor_dividend = DEFAULT_INTERVAL;
      184 	amonitor_interval = DEFAULT_INTERVAL * 60000000;
      185 						/* make it microseconds			*/
      186 	got_a_cpu, interval, start, stop = FALSE;
      187 	call cu_$arg_count (Nargs, code);
      188 	if code ^= 0 then do;
      189 	    call com_err_ (code, myname);
      190 	    return;
      191 	  end;
      192 	if Nargs <= 0 then do;
      193 	    if inited then goto recursive_invocation;
      194 	  end;
      195 	else do i = 1 to Nargs;
      196 	    call cu_$arg_ptr (i, ap, al, code);
      197 	    if code ^= 0 then do;
      198 	        call com_err_ (code, myname);
      199 	        call janitor (TRUE);
      200 	        return;
      201 	      end;
      202 	    if substr (Arg, 1, 1) ^= "-" then do;	/* must be cpu tag or cpu list		*/
      203 	        if verify (Arg, CPU_TAGS) ^= 0 then goto cpu_list_error;
      204 	        call mark_cpu;
      205 	      end;
      206 	    else do;
      207 have_next_arg:    if Arg = "-brief" | Arg = "-bf" then brief = TRUE;
      208 	        else if Arg = "-long" | Arg = "-lg" then brief = FALSE;
      209 	        else if Arg = "-priv" then do;
      210 		  call check_hphcs_access (code);	/* might as well do it now...			*/
      211 		  if code ^= 0 then do;
      212 		      call com_err_ (code, myname, "hphcs_");
      213 		      call janitor (TRUE);
      214 		      return;
      215 		    end;
      216 		  else priv = TRUE;
      217 		end;
      218 	        else if Arg = "-stop" | Arg = "-sp" then stop = TRUE;
      219 	        else if Arg = "-start" | Arg = "-sr" then start = TRUE;
      220 	        else if Arg = "-time" | Arg = "-tm" then do;
      221 		  call get_next_arg (TRUE);
      222 		  if code ^= 0 then do;
      223 		      call com_err_ (code, myname, "Missing monitor interval.");
      224 		      call janitor (^inited);
      225 		      return;
      226 		    end;
      227 		  if verify (Arg, "0123456789") ^= 0 then do;
      228 						/* not a valid number			*/
      229 		      call com_err_ (error_table_$bad_conversion, myname, "^a is not a valid number.", Arg);
      230 		      call janitor (^inited);
      231 		      return;
      232 		    end;
      233 		  amonitor_interval = fixed (Arg);
      234 		  factor_dividend = fixed (Arg, 30, 2);
      235 		  if amonitor_interval < 1 then do;
      236 		      call com_err_ (0, myname, "The interval time must be greater than or equal to 1 minute.");
      237 		      call janitor (^inited);
      238 		      return;
      239 		    end;
      240 		  interval = TRUE;
      241 		  amonitor_interval = amonitor_interval * 60000000;
      242 						/* make it microseconds			*/
      243 		end;
      244 	        else if Arg = "-cpu" then do;		/* just monitor these			*/
      245 		  do while (TRUE);
      246 		    call get_next_arg (TRUE);
      247 		    if ap = null () then do;
      248 		        if ^got_a_cpu then do;
      249 			  call com_err_ (code, myname, "Processing -cpu");
      250 			  call janitor (^inited);
      251 			  return;
      252 			end;
      253 		        else goto finished_args;
      254 		      end;
      255 		    if substr (Arg, 1, 1) = "-" then do;
      256 		        if got_a_cpu then goto have_next_arg;
      257 		        else goto cpu_list_error;
      258 		      end;
      259 		    if verify (Arg, CPU_TAGS) ^= 0 then do;
      260 cpu_list_error:	        call com_err_ (error_table_$bad_arg, myname, "^a contains an invalid cpu tag.", Arg);
      261 		        call janitor (^inited);
      262 		        return;
      263 		      end;
      264 		    got_a_cpu = TRUE;
      265 		    call mark_cpu ();
      266 		  end;
      267 		end;
      268 	        else do;				/* hmm, don't know this ctl arg		*/
      269 		  call com_err_ (error_table_$badopt, myname, "^a.", Arg);
      270 		  call janitor (^inited);
      271 		  return;
      272 		end;
      273 	      end;				/* must have been a ctl arg			*/
      274 finished_args:
      275 	  end;					/* all done with arguments			*/
      276 
      277 	if ^inited then
      278 	     if (stop) then do;			/* can't do this until we have started monitoring */
      279 	         call com_err_ (error_table_$badcall, myname, "Monitoring has not been started, -stop ignored.");
      280 	         return;
      281 	       end;
      282 
      283 	if inited then do;
      284 	    if ^(start | stop) then do;
      285 recursive_invocation:
      286 	        call com_err_ (error_table_$badcall, myname,
      287 		"Monitoring has already been invoked. Use the -stop control argument.");
      288 	        call janitor (FALSE);
      289 	        return;
      290 	      end;
      291 	    if interval then do;
      292 	        call com_err_ (0, myname, "The monitoring interval may not be changed during monitoring.");
      293 	        return;
      294 	      end;
      295 	    if (start & stop) then do;
      296 	        call com_err_ (error_table_$inconsistent, myname, "Both ""-start"" and ""-stop"" specified.");
      297 	        return;
      298 	      end;
      299 	    if start then do;			/* turn some back ON			*/
      300 	        if acpu_list = (8)"0"b then do;
      301 		  call com_err_ (0, myname, "No cpu list found for -start control argument.");
      302 		  call janitor (FALSE);
      303 		  return;
      304 		end;
      305 	        else do;
      306 		  do i = 1 to MAX_CPUS;
      307 		    if (substr (acpu_list, i, 1)) then substr (cpu_list, i, 1) = TRUE;
      308 		  end;
      309 		end;
      310 	      end;
      311 	    else if stop then do;			/* turn off if we have a list			*/
      312 	        if acpu_list ^= (8)"0"b then do;
      313 		  do i = 1 to MAX_CPUS;
      314 		    if (substr (acpu_list, i, 1)) then substr (cpu_list, i, 1) = FALSE;
      315 		  end;
      316 		end;
      317 	        else do;				/* ok stop all monitoring			*/
      318 		  call janitor (TRUE);		/* cleanup and quit				*/
      319 		  return;
      320 		end;
      321 	      end;
      322 	  end;
      323 	if ^inited then do;
      324 	    on cleanup call janitor (TRUE);
      325 	    cache_threshold_datap = null ();
      326 	    if priv then call use_tools_for_defaults ();	/* always use >tools for priv			*/
      327 	    else do;
      328 	        call find_defaults ();
      329 	        if cache_threshold_datap = null () then call use_tools_for_defaults ();
      330 	      end;
      331 	    if cache_threshold_datap = null () then do;
      332 	        call com_err_ (code, myname, "Unable to find the cache threshold defaults.");
      333 	        call janitor (TRUE);
      334 	        return;
      335 	      end;
      336 
      337 	    static_threshold_ptr = cache_threshold_datap; /* save this				*/
      338 	    call cache_meters_$for_monitor (null (), ncpus, code);
      339 						/* null ptr tells of initial call to reset per process*/
      340 	    if code ^= 0 then do;			/* meter data				*/
      341 	        call com_err_ (code, myname, "Initial cache_meters_ call to reset counters.");
      342 	        call janitor (TRUE);
      343 	        return;
      344 	      end;
      345 	    call get_temp_segment_ (myname, countersp, code);
      346 	    if code ^= 0 then do;
      347 	        call com_err_ (code, myname, "Attempting to get a temporary segment.");
      348 	        call janitor (TRUE);
      349 	        return;
      350 	      end;
      351 	    if acpu_list = (8)"0"b then acpu_list = DEFAULT_SET;
      352 						/* no cpu's specified, do 'em all		*/
      353 	    call set_interval_and_factor ();
      354 	    cpu_list = acpu_list;
      355 	    call ipc_$create_ev_chn (monitor_wakeup_chn, code);
      356 	    if code ^= 0 then do;
      357 	        call com_err_ (code, myname, "Creating event channel.");
      358 	        call janitor (TRUE);
      359 	        return;
      360 	      end;
      361 	    call ipc_$decl_ev_call_chn (monitor_wakeup_chn, wakeup_monitor, null (), 1, code);
      362 	    if code ^= 0 then do;
      363 	        call com_err_ (code, myname, "Creating event call channel.");
      364 	        call janitor (TRUE);
      365 	        return;
      366 	      end;
      367 	    start_hack = clock ();
      368 	    call timer_manager_$alarm_wakeup (start_hack + monitor_interval, "00"b, monitor_wakeup_chn);
      369 	    inited = TRUE;
      370 	  end;
      371 	return;
      372 
      373 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      374 
      375 display_cache_threshold: entry ();
      376 
      377 
      378 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      379 /*									*/
      380 /* This entry uses the current cache threshold data segment (if one is found via the	*/
      381 /* search rules, or the default one in >tools.					*/
      382 /*									*/
      383 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      384 
      385 dcl di		     fixed bin;
      386 
      387 	if static_threshold_ptr ^= null () then cache_threshold_datap = static_threshold_ptr;
      388 						/* use this if we have one inited		*/
      389 	else do;
      390 	    call find_defaults ();
      391 	    if cache_threshold_datap = null () then call use_tools_for_defaults;
      392 	    if cache_threshold_datap = null () then do;
      393 	        call com_err_ (code, "display_cache_threshold", "Unable to find the cache threshold defaults.");
      394 	        return;
      395 	      end;
      396 	  end;
      397 	call ioa_ ("	 Error Name	      Allowable per hour
      398 -------------------------------------------------------");
      399 	do di = 1 to NO_CACHE_ERR_TYPES;
      400 	  call ioa_ ("^2x^32a^10x^d", CACHE_ERROR_NAME (di), cache_threshold_data_array (di));
      401 	end;
      402 	return;
      403 
      404 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      405 
      406 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      407 
      408 
      409 wakeup_monitor:
      410      entry ();
      411 
      412 	call timer_manager_$reset_alarm_wakeup (monitor_wakeup_chn);
      413 	start_hack = clock ();
      414 	call cache_meters_$for_monitor (countersp, ncpus, code);
      415 	if code ^= 0 then do;
      416 	    call com_err_ (code, myname);
      417 	  end;
      418 
      419 	else do;
      420 	    if cpu_list = FALSE then ;		/* no checking done				*/
      421 	    else do;
      422 	        cache_threshold_datap = static_threshold_ptr;
      423 	        do i = 1 to ncpus;
      424 		error_found = FALSE;
      425 		if (substr (cpu_list, cache_counters (i).cpu_tag)) then do;
      426 		    do j = 1 to NO_CACHE_ERR_TYPES;
      427 		      if cache_counters.cache_err_ctrs (i, j) >
      428 		        (cache_threshold_data_array (j) * factor) then do;
      429 			error_found = TRUE;		/* some kind kind of over threshold		*/
      430 			call announce (TRUE, i, j, (cache_counters.cache_err_ctrs (i, j)));
      431 						/* announce the error			*/
      432 		        end;
      433 		    end;
      434 		    if (^error_found) & (substr (cpu_list, i, 1)) then call announce (FALSE, i, 0, 0);
      435 						/* just in case			*/
      436 		  end;				/* end if cpu is being monitored		*/
      437 	        end;
      438 	      end;
      439 	  end;
      440 	call timer_manager_$alarm_wakeup (start_hack + monitor_interval, "00"b, monitor_wakeup_chn);
      441 	call janitor (FALSE);			/* we are done				*/
      442 	return;
      443 
      444 
      445 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      446 
      447 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      448 
      449 check_phcs_access: proc (code);
      450 
      451 dcl code		     fixed bin (35),
      452   mode		     fixed bin (5);
      453 
      454     call hcs_$get_user_effmode (">sl1", "phcs_", "", 0, mode, code);
      455     if code ^= 0 then return;
      456     if (mode >= RE_ACCESS_BIN) then ;
      457     else code = error_table_$not_privileged;
      458     return;
      459   end check_phcs_access;
      460 
      461 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      462 
      463 check_hphcs_access: proc (code);
      464 
      465 dcl code		     fixed bin (35),
      466   mode		     fixed bin (5);
      467 
      468     call hcs_$get_user_effmode (">sl1", "hphcs_", "", 0, mode, code);
      469     if code ^= 0 then return;
      470     if (mode >= RE_ACCESS_BIN) then ;
      471     else code = error_table_$not_privileged;
      472     return;
      473   end check_hphcs_access;
      474 
      475 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      476 
      477 
      478 get_next_arg: proc (required_arg);
      479 
      480 dcl required_arg	     bit (1) parameter;
      481 
      482     i = i + 1;					/* set to next arg				*/
      483     call cu_$arg_ptr (i, ap, al, code);
      484     if ap = null () then do;
      485       end;
      486   end get_next_arg;
      487 
      488 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      489 
      490 
      491 mark_cpu: proc ();
      492 
      493 dcl i		     fixed bin;
      494 
      495     do i = 1 to al;					/* now mark the tag as interested		*/
      496       substr (acpu_list, mod (index (CPU_TAGS, substr (Arg, i, 1)) - 1, 8) + 1, 1) = TRUE;
      497     end;
      498   end mark_cpu;
      499 
      500 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      501 
      502 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      503 
      504 announce:
      505   proc (error, cputag, error_number, how_many);
      506 
      507 dcl error		     bit (1) parameter,
      508   (cputag, error_number, how_many) fixed bin parameter;
      509 
      510     if error then do;
      511         if priv then
      512 	   call hphcs_$syserr (BEEP, "monitor_cache:  Cpu ^a is above the cache error threshold for ^a. ^d during this interval.",
      513 	     CPU_NAMES (cache_counters.cpu_tag (cputag)), CACHE_ERROR_NAME (error_number), how_many);
      514         else call ioa_ (myname || ": Cpu ^a is above the cache error threshold for ^a. ^d during this interval.",
      515 	     CPU_NAMES (cache_counters.cpu_tag (cputag)), CACHE_ERROR_NAME (error_number), how_many);
      516       end;
      517     else do;					/* no error, announce monitoring if applicable	*/
      518         if priv then call hphcs_$syserr (LOG, "monitor_cache:  Cpu ^a below cache error threshold.",
      519 	     CPU_NAMES (cache_counters.cpu_tag (cputag)));
      520         else if ^brief then call ioa_ (myname || ":  Cpu ^a is below cache error threshold.",
      521 	     CPU_NAMES (cache_counters.cpu_tag (cputag)));
      522       end;
      523 
      524   end announce;
      525 
      526 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      527 
      528 set_interval_and_factor: proc ();
      529 
      530     monitor_interval = amonitor_interval;		/* calculate the factor viv a vis 1 hour	*/
      531     factor = divide (factor_dividend, 60.0, 30, 2);
      532     if factor <= 0 then factor = 1;
      533   end set_interval_and_factor;
      534 
      535 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      536 
      537 janitor: proc (finish);
      538 
      539 dcl finish	     bit (1) parameter;
      540 
      541     if finish then do;				/* stop all monitoring			*/
      542         if countersp ^= null () then do;		/* then finish up				*/
      543 	  call release_temp_segment_ (myname, countersp, (0));
      544 	  countersp = null ();
      545 	end;
      546         if monitor_wakeup_chn ^= -1 then call timer_manager_$reset_alarm_wakeup (monitor_wakeup_chn);
      547         if static_threshold_ptr ^= null () then call hcs_$terminate_noname (static_threshold_ptr, (0));
      548         static_threshold_ptr = null ();
      549         inited = FALSE;
      550       end;
      551   end janitor;
      552 
      553 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      554 
      555 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      556 
      557 find_defaults: proc ();
      558 
      559 
      560     call hcs_$make_ptr (null (), "cache_threshold_defaults_", "", cache_threshold_datap, code);
      561 
      562   end find_defaults;
      563 
      564 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      565 
      566 
      567 use_tools_for_defaults: proc ();
      568 
      569     call hcs_$initiate (">system_library_tools", "cache_threshold_defaults_", "", 0, 0,
      570       cache_threshold_datap, code);
      571   end use_tools_for_defaults;
      572 
      573 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      574 
      575 
  1     1 /*  START OF:	cache_threshold_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* This include file is used by cache_threshold_defaults_ and monitor_cache to provide	*/
  1     6 	/* for comparing the acceptable cache memory error rates.				*/
  1     7 	/* Created: 2/84 by GA Texada							*/
  1     8 	/*									*/
  1     9 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    10 
  1    11 	
  1    12 	
  1    13 dcl cache_threshold_datap ptr,
  1    14 
  1    15   1 cache_threshold_data aligned based(cache_threshold_datap),
  1    16 
  1    17     2 pri_dir_parity     fixed bin (35),		/* All cache types				*/
  1    18 						/* PFR bit 32				*/
  1    19     2 port_buffer(4)     fixed bin (35),		/* DPS8 cache types all 4 ports		*/
  1    20 						/* EFR bits 36-39				*/
  1    21     2 pri_dir	     fixed bin (35),		/* DPS8 cache types				*/
  1    22 						/* EFR bit 40				*/
  1    23     2 wno_parity_any_port fixed bin (35),		/* DPS8 NON VS&SC only			*/
  1    24 						/* EFR bit 41				*/
  1    25     2 dup_dir_parity(4)     fixed bin (35),		/* DPS8 VS&SC only, lvl 0-3			*/
  1    26 						/* EFR bits 42-45				*/
  1    27     2 dup_dir_multimatch fixed bin (35),		/* DPS8 cache types				*/
  1    28 						/* EFR bit 46				*/
  1    29     2 pad(5) fixed bin(35),				/* UNUSED in the error counter array		*/
  1    30 	
  1    31  cache_threshold_data_array(17) fixed bin(35) aligned based(cache_threshold_datap);
  1    32 
  1    33 
  1    34 /*  END OF:	cache_threshold_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      576 
      577 
  2     1 /*  START OF:	fim_meters.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* Declarations useful for programs which interpret the per-cpu fault and cache
  2     4*   error counter data maintained in wired_hardcore_data$cpu_X_flt_ctr_array and
  2     5*   wired_hardcore_data$cpu_X_cache_err_ctr_array.  The fault counters are an
  2     6*   array of counts by fault number, where the first NO_HARDWARE_FAULTS
  2     7*   fault numbers correspond to hardware faults, and the remaining
  2     8*   correspond to sub-cases of hardware faults, as defined procedurally in
  2     9*   fim.  The per-cpu  cache error counters are simply an array of error counters.
  2    10*   The cache error counter array is defined as: location ZERO contains the 
  2    11*   cache size/type and is filled in by init_processor;location 1 thru 12 hold 
  2    12*   the error counters as filled in by fim_util or page_fault.
  2    13*   
  2    14*   Written March 1981 by J. Bongiovanni								*/
  2    15 /* Modified July 1981 by M. Weaver for undefined_pointer
  2    16*   Modified October 1983 by Rich Coppola for support of per-processor fault and cache counters.
  2    17**/
  2    18 
  2    19 dcl  MAX_CPUS fixed bin init (8) int static options (constant);
  2    20    						/* current maximum of CPU numbers */
  2    21 
  2    22 dcl  CPU_NAMES (8) char (1) int static options (constant) init (
  2    23 	"A", "B", "C", "D", "E", "F", "G", "H");
  2    24 dcl  (NO_HARDWARE_FAULTS init (32), NO_TOTAL_FAULTS init (128))
  2    25           fixed bin int static options (constant);
  2    26 
  2    27 dcl  EXTANT_FAULT (32) bit (1) unaligned init ((26) (1)"1"b, (5) (1)"0"b, "1"b)
  2    28           int static options (constant);		/* by hardware fault no. "1"=> valid		*/
  2    29 
  2    30 dcl  LONG_FAULT_NAME (128) char (30) init		/* full names of faults			*/
  2    31 						/* begin of hardware faults			*/
  2    32           ("shutdown", "store", "mme1", "fault_tag_1", "timer_runout",
  2    33            "command", "derail", "lockup", "connect", "parity",
  2    34            "illegal_procedure", "op_not_complete", "startup",
  2    35            "overflow", "divide_check", "execute", "segment_fault",
  2    36            "page_fault", "directed_fault_2", "directed_fault_3",
  2    37            "access_violation", "mme2", "mme3", "mme4", "linkage_fault",
  2    38            "fault_tag_3", (5) (1)"<invalid>", "trouble",
  2    39 						/* begin of subordinate faults		*/
  2    40            "illegal_opcode", "null_pointer", "illegal_modifier", "illegal_ring_order",
  2    41            "not_in_execute_bracket", "no_execute_permission", "not_in_read_bracket",
  2    42            "no_read_permission", "not_in_write_bracket", "no_write_permission",
  2    43            "not_a_gate", "not_in_call_bracket", "outward_call", "bad_outward_call",
  2    44            "inward_return", "cross_ring_transfer", "ring_alarm_fault", "am_fault",
  2    45            "out_of_bounds", "fixedoverflow", "overflow", "underflow", "stringsize",
  2    46            "illegal_procedure", "stack_out_of_bounds", "packed_pointer_fault",
  2    47            "lot_fault", "isot_fault", "system_packed_pointer", (4) (1)" ",
  2    48 	"size", "neti", "command", "sus_", "trm_", "wkp_", "undefined_pointer", (56) (1)" ")
  2    49           
  2    50           int static options (constant);
  2    51 
  2    52 dcl  SHORT_FAULT_NAME (32) char (3) init		/* short names of hardware faults		*/
  2    53           ("sdf", "str", "mme", "ft1", "tro", "cmd", "drl", "luf",
  2    54            "con", "par", "ipr", "onc", "suf", "ovf", "div", "exf",
  2    55            "df0", "df1", "df2", "df3", "acv", (3) (1)" ", "ft2",
  2    56            "ft3", (5) (1)" ", "trb") int static options (constant);
  2    57      
  2    58 
  2    59 /* The following table is used to thread subordinate (non-hardware known)
  2    60*   faults to primary (hardware known) fault types.  Its existence and
  2    61*   contents depends on the way fim handles faults, and it corresponds
  2    62*   roughly to fault_table in fim.  This table is an array of threads by
  2    63*   fault number.  To follow a thread for a hardware fault, use the
  2    64*   value of this table indexed by hardware fault number to find the
  2    65*   first subordinate fault number (0=>none).  Continue for the subordinate
  2    66*   fault until a thread of 0 is encountered.							*/
  2    67 	
  2    68 dcl  THREAD_FAULT (128) fixed bin int static options (constant) init (
  2    69            0, 0, 0, 0, 0, 58, 0, 0, 0, 0,
  2    70            33, 0, 0, 52, 0, 0, 0, 0, 0, 0,
  2    71            34, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2    72            0, 0, 35, 36, 56, 37, 38, 39, 40, 41,
  2    73            42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
  2    74            57, 53, 54, 55, 66, 0, 72, 59, 60, 61,
  2    75            68, (67) 0);
  2    76 
  2    77 
  2    78 dcl  CACHE_TYPES (0:5) char (9) int static options (constant) init (
  2    79 	"L68_NONE", "  L68_2K", " DPS8_8K", " VSSC_8K", "VSSC_16K", "VSSC_32K");
  2    80 
  2    81 
  2    82 /* The cache size is placed in the first word of the per-processor array
  2    83*by init_processor. The following declarations list the currently known sizes 
  2    84*and their decodes */
  2    85 
  2    86 dcl  L68_NONE fixed bin int static options (constant) init (0),
  2    87      L68_2K fixed bin int static options (constant) init (1),
  2    88      DPS8_8K fixed bin int static options (constant) init (2),
  2    89      VSSC_8K fixed bin int static options (constant) init (3),
  2    90      VSSC_16K fixed bin int static options (constant) init (4),
  2    91      VSSC_32K fixed bin int static options (constant) init (5);
  2    92 
  2    93 dcl NO_CACHE_ERR_TYPES fixed bin int static options (constant) init (12);
  2    94 
  2    95 
  2    96 /* Note PFR = Primary Fault Reg (L68/DPS8), EFR = Extended Fault Reg (DPS8) */
  2    97 
  2    98 dcl  CACHE_ERROR_NAME (12) char (32) var int static options (constant) init (
  2    99 	"Primary Dir Parity/MultiMatch",		/* Cell 1; PFR Bit 32  */
  2   100 	"PT A Buffer OVFL/PAR/SEQ Err",		/* Cell 2; EFR Bit 36  */
  2   101 	"PT B Buffer OVFL/PAR/SEQ Err",		/* Cell 3; EFR Bit 37  */
  2   102           "PT C Buffer OVFL/PAR/SEQ Err",		/* Cell 4; EFR Bit 38  */
  2   103 	"PT D Buffer OVFL/PAR/SEQ Err",		/* Cell 5; EFR Bit 39  */
  2   104 	"Primary DIR/PT Buffer OVFL",			/* Cell 6; EFR Bit 40  */
  2   105 	"WNO Parity ANY Port",			/* Cell 7; EFR Bit 41  for DPS8 (cache type = 2) ONLY */
  2   106 						/* NOTE: This counter is NOT USED by the VS&SC Cache,
  2   107*						   ONLY the 8k model CPU */
  2   108           "Level 0 Dup Dir Parity",			/* Cell 8; EFR Bit 42  */
  2   109 	"Level 1 Dup Dir Parity",			/* Cell 9; EFR Bit 43  */
  2   110 	"Level 2 Dup Dir Parity",			/* Cell 10; EFR Bit 44  */
  2   111 	"Level 3 Dup Dir Parity",			/* Cell 10; EFR Bit 45  */
  2   112 	"Dup Dir MultiMatch");
  2   113 						/* Cell 11; EFR Bit 46  */
  2   114 
  2   115 
  2   116 /*  END OF:	fim_meters.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      579 
  3     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  3     2*
  3     3*   Values for the "access mode" argument so often used in hardcore
  3     4*   James R. Davis 26 Jan 81  MCR 4844
  3     5*   Added constants for SM access 4/28/82 Jay Pattin
  3     6*   Added text strings 03/19/85 Chris Jones
  3     7**/
  3     8 
  3     9 
  3    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  3    11 dcl	(
  3    12 	N_ACCESS		   init ("000"b),
  3    13 	R_ACCESS		   init ("100"b),
  3    14 	E_ACCESS		   init ("010"b),
  3    15 	W_ACCESS		   init ("001"b),
  3    16 	RE_ACCESS		   init ("110"b),
  3    17 	REW_ACCESS	   init ("111"b),
  3    18 	RW_ACCESS		   init ("101"b),
  3    19 	S_ACCESS		   init ("100"b),
  3    20 	M_ACCESS		   init ("010"b),
  3    21 	A_ACCESS		   init ("001"b),
  3    22 	SA_ACCESS		   init ("101"b),
  3    23 	SM_ACCESS		   init ("110"b),
  3    24 	SMA_ACCESS	   init ("111"b)
  3    25 	)		   bit (3) internal static options (constant);
  3    26 
  3    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  3    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  3    29 
  3    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  3    31 			   static options (constant);
  3    32 
  3    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  3    34 			   static options (constant);
  3    35 
  3    36 dcl	(
  3    37 	N_ACCESS_BIN	   init (00000b),
  3    38 	R_ACCESS_BIN	   init (01000b),
  3    39 	E_ACCESS_BIN	   init (00100b),
  3    40 	W_ACCESS_BIN	   init (00010b),
  3    41 	RW_ACCESS_BIN	   init (01010b),
  3    42 	RE_ACCESS_BIN	   init (01100b),
  3    43 	REW_ACCESS_BIN	   init (01110b),
  3    44 	S_ACCESS_BIN	   init (01000b),
  3    45 	M_ACCESS_BIN	   init (00010b),
  3    46 	A_ACCESS_BIN	   init (00001b),
  3    47 	SA_ACCESS_BIN	   init (01001b),
  3    48 	SM_ACCESS_BIN	   init (01010b),
  3    49 	SMA_ACCESS_BIN	   init (01011b)
  3    50 	)		   fixed bin (5) internal static options (constant);
  3    51 
  3    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      580 
      581 
  4     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  4     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  4     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  4     4 
  4     5 /* This include file has an ALM version.  Keep 'em in sync! */
  4     6 
  4     7 dcl (
  4     8 
  4     9 /* The following constants define the message action codes.  This indicates
  4    10*how a message is to be handled.  */
  4    11 
  4    12      SYSERR_CRASH_SYSTEM	init (1),			
  4    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  4    14 
  4    15      SYSERR_TERMINATE_PROCESS	init (2),
  4    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  4    17 
  4    18      SYSERR_PRINT_WITH_ALARM	init (3),
  4    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  4    20 
  4    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  4    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  4    23 
  4    24      SYSERR_LOG_OR_PRINT	init (4),
  4    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  4    26 
  4    27      SYSERR_LOG_OR_DISCARD	init (5),
  4    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  4    29 
  4    30 
  4    31 /* The following constants are added to the normal severities to indicate
  4    32*different sorting classes of messages.  */
  4    33 
  4    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  4    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  4    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  4    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  4    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  4    39 	) fixed bin internal static options (constant);
  4    40 
  4    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      582 
      583      end monitor_cache;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/01/88  1330.0  monitor_cache.pl1                 >spec>install>1031>monitor_cache.pl1
576          1    04/26/84  1340.5  cache_threshold_data.incl.pl1     >ldd>include>cache_threshold_data.incl.pl1
578          2    10/28/83  1424.1  fim_meters.incl.pl1               >ldd>include>fim_meters.incl.pl1
580          3    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
582          4    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Arg                                    based           char                     packed unaligned dcl 146 set ref 202 203 207 207 208
                                                                                  208 209 218 218 219 219 220 220 227 229* 233 234
                                                                                  244 255 259 260* 269* 496
BEEP                            000250 constant        fixed bin(17,0)          initial dcl 4-7 set ref 511*
CACHE_ERROR_NAME                000000 constant        varying char(32)         initial array dcl 2-98 set ref 400* 511* 514*
CPU_NAMES                       000154 constant        char(1)                  initial array packed unaligned dcl 2-22 set ref 511*
                                                                                  514* 518* 520*
CPU_TAGS                        000163 constant        char(16)                 initial packed unaligned dcl 137 ref 203 259 496
DEFAULT_INTERVAL                004614 constant        fixed bin(17,0)          initial dcl 137 ref 183 184
DEFAULT_SET                            constant        bit(8)                   initial packed unaligned dcl 137 ref 351
FALSE                           000247 constant        bit(1)                   initial packed unaligned dcl 137 set ref 181 186 208
                                                                                  288* 302* 314 420 424 434* 441* 549
LOG                             000200 constant        fixed bin(17,0)          initial dcl 4-7 set ref 518*
MAX_CPUS                               constant        fixed bin(17,0)          initial dcl 2-19 ref 306 313
NO_CACHE_ERR_TYPES                     constant        fixed bin(17,0)          initial dcl 2-93 ref 399 426
Nargs                           000102 automatic       fixed bin(17,0)          dcl 146 set ref 187* 192 195
RE_ACCESS_BIN                          constant        fixed bin(5,0)           initial dcl 3-36 ref 456 470
TRUE                            000162 constant        bit(1)                   initial packed unaligned dcl 137 set ref 180 199*
                                                                                  207 213* 216 218 219 221* 240 245 246* 264 307
                                                                                  318* 324* 333* 342* 348* 358* 364* 369 429 430*
                                                                                  496
acpu_list                       000115 automatic       bit(8)                   initial packed unaligned dcl 146 set ref 146* 300
                                                                                  307 312 314 351 351* 354 496*
al                              000106 automatic       fixed bin(21,0)          dcl 146 set ref 196* 202 203 207 207 208 208 209 218
                                                                                  218 219 219 220 220 227 229 229 233 234 244 255
                                                                                  259 260 260 269 269 483* 495 496
amonitor_interval               000126 automatic       fixed bin(71,0)          dcl 146 set ref 184* 233* 235 241* 241 530
ap                              000100 automatic       pointer                  dcl 146 set ref 196* 202 203 207 207 208 208 209 218
                                                                                  218 219 219 220 220 227 229 233 234 244 247 255
                                                                                  259 260 269 483* 484 496
brief                           000014 internal static bit(1)                   initial packed unaligned dcl 146 set ref 180* 207*
                                                                                  208* 520
cache_counters                         based           structure                array level 1 dcl 162
cache_err_ctrs            2            based           fixed bin(35,0)          array level 2 dcl 162 ref 427 430
cache_meters_$for_monitor       000034 constant        entry                    external dcl 111 ref 338 414
cache_threshold_data_array             based           fixed bin(35,0)          array dcl 1-13 set ref 400* 427
cache_threshold_datap           000142 automatic       pointer                  dcl 1-13 set ref 325* 329 331 337 387* 391 392 400
                                                                                  422* 427 560* 569*
cleanup                         000132 stack reference condition                dcl 167 ref 324
clock                                                  builtin function         dcl 169 ref 367 413
code                                   parameter       fixed bin(35,0)          dcl 451 in procedure "check_phcs_access" set ref 449
                                                                                  454* 455 457*
code                            000114 automatic       fixed bin(35,0)          dcl 146 in procedure "monitor_cache" set ref 173*
                                                                                  174 175* 187* 188 189* 196* 197 198* 210* 211 212*
                                                                                  222 223* 249* 332* 338* 340 341* 345* 346 347*
                                                                                  355* 356 357* 361* 362 363* 393* 414* 415 416*
                                                                                  483* 560* 569*
code                                   parameter       fixed bin(35,0)          dcl 465 in procedure "check_hphcs_access" set ref
                                                                                  463 468* 469 471*
com_err_                        000036 constant        entry                    external dcl 111 ref 175 189 198 212 223 229 236 249
                                                                                  260 269 279 285 292 296 301 332 341 347 357 363
                                                                                  393 416
countersp                       000010 internal static pointer                  initial dcl 146 set ref 345* 414* 425 427 430 511
                                                                                  514 518 520 542 543* 544*
cpu_list                        000017 internal static bit(8)                   initial packed unaligned dcl 146 set ref 307* 314*
                                                                                  354* 420 425 434
cpu_tag                                based           fixed bin(35,0)          array level 2 dcl 162 ref 425 511 514 518 520
cputag                                 parameter       fixed bin(17,0)          dcl 507 ref 504 511 514 518 520
cu_$arg_count                   000040 constant        entry                    external dcl 111 ref 187
cu_$arg_ptr                     000042 constant        entry                    external dcl 111 ref 196 483
di                              000140 automatic       fixed bin(17,0)          dcl 385 set ref 399* 400 400*
divide                                                 builtin function         dcl 169 ref 531
error                                  parameter       bit(1)                   packed unaligned dcl 507 ref 504 510
error_found                     000107 automatic       bit(1)                   packed unaligned dcl 146 set ref 424* 429* 434
error_number                           parameter       fixed bin(17,0)          dcl 507 ref 504 511 514
error_table_$bad_arg            000074 external static fixed bin(35,0)          dcl 130 set ref 260*
error_table_$bad_conversion     000100 external static fixed bin(35,0)          dcl 130 set ref 229*
error_table_$badcall            000076 external static fixed bin(35,0)          dcl 130 set ref 279* 285*
error_table_$badopt             000102 external static fixed bin(35,0)          dcl 130 set ref 269*
error_table_$inconsistent       000104 external static fixed bin(35,0)          dcl 130 set ref 296*
error_table_$not_privileged     000106 external static fixed bin(35,0)          dcl 130 ref 457 471
factor                          000020 internal static fixed dec(30,2)          initial dcl 146 set ref 427 531* 532 532*
factor_dividend                 000116 automatic       fixed dec(30,2)          dcl 146 set ref 183* 234* 531
finish                                 parameter       bit(1)                   packed unaligned dcl 539 ref 537 541
fixed                                                  builtin function         dcl 169 ref 233 234
get_temp_segment_               000056 constant        entry                    external dcl 111 ref 345
got_a_cpu                       000110 automatic       bit(1)                   packed unaligned dcl 146 set ref 186* 248 256 264*
hcs_$get_user_effmode           000044 constant        entry                    external dcl 111 ref 454 468
hcs_$initiate                   000046 constant        entry                    external dcl 111 ref 569
hcs_$make_ptr                   000050 constant        entry                    external dcl 111 ref 560
hcs_$terminate_noname           000052 constant        entry                    external dcl 111 ref 547
how_many                               parameter       fixed bin(17,0)          dcl 507 set ref 504 511* 514*
hphcs_$syserr                   000054 constant        entry                    external dcl 111 ref 511 518
i                               000104 automatic       fixed bin(17,0)          dcl 146 in procedure "monitor_cache" set ref 195*
                                                                                  196* 306* 307 307* 313* 314 314* 423* 425 427 430*
                                                                                  430 434 434* 482* 482 483*
i                               000206 automatic       fixed bin(17,0)          dcl 493 in procedure "mark_cpu" set ref 495* 496*
index                                                  builtin function         dcl 169 ref 496
inited                          000015 internal static bit(1)                   initial packed unaligned dcl 146 set ref 179 193 224
                                                                                  230 237 250 261 270 277 283 323 369* 549*
interval                        000111 automatic       bit(1)                   packed unaligned dcl 146 set ref 186* 240* 291
ioa_                            000062 constant        entry                    external dcl 111 ref 397 400 514 520
ipc_$create_ev_chn              000064 constant        entry                    external dcl 111 ref 355
ipc_$decl_ev_call_chn           000066 constant        entry                    external dcl 111 ref 361
j                               000105 automatic       fixed bin(17,0)          dcl 146 set ref 426* 427 427 430* 430*
mod                                                    builtin function         dcl 169 ref 496
mode                            000160 automatic       fixed bin(5,0)           dcl 451 in procedure "check_phcs_access" set ref
                                                                                  454* 456
mode                            000170 automatic       fixed bin(5,0)           dcl 465 in procedure "check_hphcs_access" set ref
                                                                                  468* 470
monitor_interval                000030 internal static fixed bin(71,0)          initial dcl 146 set ref 368 440 530*
monitor_wakeup_chn              000032 internal static fixed bin(71,0)          initial dcl 146 set ref 355* 361* 368* 412* 440* 546
                                                                                  546*
myname                          000156 constant        char(13)                 initial packed unaligned dcl 137 set ref 175* 189*
                                                                                  198* 212* 223* 229* 236* 249* 260* 269* 279* 285*
                                                                                  292* 296* 301* 332* 341* 345* 347* 357* 363* 416*
                                                                                  514 520 543*
ncpus                           000103 automatic       fixed bin(17,0)          dcl 146 set ref 338* 414* 423
null                                                   builtin function         dcl 169 ref 247 325 329 331 338 338 361 361 387 391
                                                                                  392 484 542 544 547 548 560 560
priv                            000016 internal static bit(1)                   initial packed unaligned dcl 146 set ref 181* 216*
                                                                                  326 511 518
release_temp_segment_           000060 constant        entry                    external dcl 111 ref 543
required_arg                           parameter       bit(1)                   packed unaligned dcl 480 ref 478
start                           000112 automatic       bit(1)                   packed unaligned dcl 146 set ref 186* 219* 284 295
                                                                                  299
start_hack                      000130 automatic       fixed bin(71,0)          dcl 146 set ref 367* 368 413* 440
static_threshold_ptr            000012 internal static pointer                  initial dcl 146 set ref 337* 387 387 422 547 547*
                                                                                  548*
stop                            000113 automatic       bit(1)                   packed unaligned dcl 146 set ref 186* 218* 277 284
                                                                                  295 311
substr                                                 builtin function         dcl 169 set ref 202 255 307 307* 314 314* 425 434
                                                                                  496* 496
timer_manager_$alarm_wakeup     000070 constant        entry                    external dcl 111 ref 368 440
timer_manager_$reset_alarm_wakeup
                                000072 constant        entry                    external dcl 111 ref 412 546
verify                                                 builtin function         dcl 169 ref 203 227 259

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 4-7
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
CACHE_TYPES                            internal static char(9)                  initial array packed unaligned dcl 2-78
CRASH                                  internal static fixed bin(17,0)          initial dcl 4-7
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 3-33
DPS8_8K                                internal static fixed bin(17,0)          initial dcl 2-86
EXTANT_FAULT                           internal static bit(1)                   initial array packed unaligned dcl 2-27
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 4-7
L68_2K                                 internal static fixed bin(17,0)          initial dcl 2-86
L68_NONE                               internal static fixed bin(17,0)          initial dcl 2-86
LONG_FAULT_NAME                        internal static char(30)                 initial array packed unaligned dcl 2-30
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
NO_HARDWARE_FAULTS                     internal static fixed bin(17,0)          initial dcl 2-24
NO_TOTAL_FAULTS                        internal static fixed bin(17,0)          initial dcl 2-24
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 3-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 3-30
SHORT_FAULT_NAME                       internal static char(3)                  initial array packed unaligned dcl 2-52
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 3-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 4-7
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 4-7
THREAD_FAULT                           internal static fixed bin(17,0)          initial array dcl 2-68
VSSC_16K                               internal static fixed bin(17,0)          initial dcl 2-86
VSSC_32K                               internal static fixed bin(17,0)          initial dcl 2-86
VSSC_8K                                internal static fixed bin(17,0)          initial dcl 2-86
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
cache_threshold_data                   based           structure                level 1 dcl 1-13

NAMES DECLARED BY EXPLICIT CONTEXT.
announce                        003505 constant        entry                    internal dcl 504 ref 430 434
check_hphcs_access              003347 constant        entry                    internal dcl 463 ref 210
check_phcs_access               003266 constant        entry                    internal dcl 449 ref 173
cpu_list_error                  001625 constant        label                    dcl 260 ref 203 257
display_cache_threshold         002667 constant        entry                    external dcl 375
find_defaults                   004040 constant        entry                    internal dcl 557 ref 328 390
finished_args                   001745 constant        label                    dcl 274 ref 248
get_next_arg                    003430 constant        entry                    internal dcl 478 ref 221 246
have_next_arg                   001144 constant        label                    dcl 207 ref 256
janitor                         003737 constant        entry                    internal dcl 537 ref 199 213 224 230 237 250 261 270
                                                                                  288 302 318 324 333 342 348 358 364 441
mark_cpu                        003455 constant        entry                    internal dcl 491 ref 204 265
monitor_cache                   000727 constant        entry                    external dcl 20
recursive_invocation            002006 constant        label                    dcl 285 ref 193
set_interval_and_factor         003721 constant        entry                    internal dcl 528 ref 353
use_tools_for_defaults          004077 constant        entry                    internal dcl 567 ref 326 329 391
wakeup_monitor                  003032 constant        entry                    external dcl 409 ref 361 361

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5144        5254    4620        5154
Length      5632    4620       110         341     323          24

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
monitor_cache                       560 external procedure  is an external procedure.  
on unit on line 324                  70 on unit               
check_phcs_access                       internal procedure  shares stack frame of external procedure monitor_cache.  
check_hphcs_access                      internal procedure  shares stack frame of external procedure monitor_cache.  
get_next_arg                            internal procedure  shares stack frame of external procedure monitor_cache.  
mark_cpu                                internal procedure  shares stack frame of external procedure monitor_cache.  
announce                                internal procedure  shares stack frame of external procedure monitor_cache.  
set_interval_and_factor                 internal procedure  shares stack frame of external procedure monitor_cache.  
janitor                              80 internal procedure  is called by several nonquick procedures.  
find_defaults                           internal procedure  shares stack frame of external procedure monitor_cache.  
use_tools_for_defaults                  internal procedure  shares stack frame of external procedure monitor_cache.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 countersp                   monitor_cache
000012 static_threshold_ptr        monitor_cache
000014 brief                       monitor_cache
000015 inited                      monitor_cache
000016 priv                        monitor_cache
000017 cpu_list                    monitor_cache
000020 factor                      monitor_cache
000030 monitor_interval            monitor_cache
000032 monitor_wakeup_chn          monitor_cache

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
monitor_cache            000100 ap                          monitor_cache
                         000102 Nargs                       monitor_cache
                         000103 ncpus                       monitor_cache
                         000104 i                           monitor_cache
                         000105 j                           monitor_cache
                         000106 al                          monitor_cache
                         000107 error_found                 monitor_cache
                         000110 got_a_cpu                   monitor_cache
                         000111 interval                    monitor_cache
                         000112 start                       monitor_cache
                         000113 stop                        monitor_cache
                         000114 code                        monitor_cache
                         000115 acpu_list                   monitor_cache
                         000116 factor_dividend             monitor_cache
                         000126 amonitor_interval           monitor_cache
                         000130 start_hack                  monitor_cache
                         000140 di                          monitor_cache
                         000142 cache_threshold_datap       monitor_cache
                         000160 mode                        check_phcs_access
                         000170 mode                        check_hphcs_access
                         000206 i                           mark_cpu

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          mpfx2
mdfx1               enable_op           ext_entry           int_entry           trunc_fx2           real_to_real_truncate_
any_to_any_truncate_clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cache_meters_$for_monitor     com_err_                      cu_$arg_count                 cu_$arg_ptr
get_temp_segment_             hcs_$get_user_effmode         hcs_$initiate                 hcs_$make_ptr
hcs_$terminate_noname         hphcs_$syserr                 ioa_                          ipc_$create_ev_chn
ipc_$decl_ev_call_chn         release_temp_segment_         timer_manager_$alarm_wakeup
timer_manager_$reset_alarm_wakeup

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bad_conversion   error_table_$badcall          error_table_$badopt
error_table_$inconsistent     error_table_$not_privileged




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    146 000723        20 000726       173 000735       174 000737       175 000741       177 000765       179 000766
    180 000771       181 000773       183 000774       184 001002       186 001005       187 001012       188 001022
    189 001024       190 001041       192 001042       193 001044       194 001047       195 001050       196 001057
    197 001074       198 001076       199 001113       200 001121       202 001122       203 001127       204 001142
    205 001143       207 001144       208 001162       209 001175       210 001201       211 001203       212 001205
    213 001230       214 001236       216 001237       217 001242       218 001243       219 001256       220 001271
    221 001301       222 001303       223 001305       224 001331       225 001343       227 001344       229 001360
    230 001413       231 001425       233 001426       234 001441       235 001451       236 001455       237 001502
    238 001514       240 001515       241 001517       243 001523       244 001524       246 001530       247 001532
    248 001536       249 001540       250 001567       251 001601       255 001602       256 001607       257 001611
    259 001612       260 001625       261 001660       262 001672       264 001673       265 001675       266 001676
    267 001677       269 001700       270 001732       271 001744       274 001745       277 001747       279 001754
    280 001777       283 002000       284 002002       285 002006       288 002031       289 002037       291 002040
    292 002042       293 002066       295 002067       296 002073       297 002116       299 002117       300 002121
    301 002124       302 002150       303 002156       306 002157       307 002167       308 002177       310 002201
    311 002202       312 002204       313 002207       314 002217       315 002227       316 002231       318 002232
    319 002240       323 002241       324 002244       325 002270       326 002272       328 002277       329 002300
    331 002305       332 002311       333 002335       334 002343       337 002344       338 002347       340 002363
    341 002365       342 002411       343 002417       345 002420       346 002441       347 002443       348 002467
    349 002475       351 002476       353 002503       354 002504       355 002510       356 002520       357 002522
    358 002546       359 002554       361 002555       362 002604       363 002606       364 002632       365 002640
    367 002641       368 002643       369 002662       371 002665       375 002666       387 002675       390 002705
    391 002706       392 002713       393 002717       394 002746       397 002747       399 002763       400 002773
    401 003026       402 003030       409 003031       412 003040       413 003047       414 003051       415 003064
    416 003066       417 003103       420 003104       422 003111       423 003113       424 003123       425 003124
    426 003146       427 003155       429 003211       430 003213       433 003217       434 003221       437 003235
    440 003237       441 003257       442 003265       449 003266       454 003270       455 003333       456 003337
    457 003343       458 003346       463 003347       468 003351       469 003414       470 003420       471 003424
    472 003427       478 003430       482 003432       483 003433       484 003450       486 003454       491 003455
    495 003456       496 003465       497 003502       498 003504       504 003505       510 003507       511 003514
    514 003564       516 003630       518 003631       520 003666       524 003720       528 003721       530 003722
    531 003725       532 003731       533 003735       537 003736       541 003744       542 003752       543 003756
    544 003777       546 004002       547 004015       548 004033       549 004036       551 004037       557 004040
    560 004041       562 004076       567 004077       569 004100       571 004151


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
