	COMPILATION LISTING OF SEGMENT read_table_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1749.6 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* This subroutine compiles the digram table, given a pointer to the
        7*   segment containing the source.  It returns a flag if compiling was
        8*   unsuccessful */
        9 
       10 read_table_: procedure (source_table_ptr, bc) returns (bit (1));
       11 
       12 dcl  source_table char (1048575) based (source_table_ptr);
       13 dcl  source_table_ptr ptr;
  1     1 
  1     2 /* ******** include file digram_structure.incl.pl1 ******* */
  1     3 
  1     4 dcl  digrams$digrams external;
  1     5 dcl  digrams$n_units fixed bin external;
  1     6 dcl  digrams$letters external;
  1     7 dcl  digrams$rules external;
  1     8 
  1     9 /* This array contains information about all possible pairs of units */
  1    10 
  1    11 dcl 1 digrams (n_units, n_units) based (addr (digrams$digrams)),
  1    12     2 begin bit (1),				/* on if this pair must begin syllable */
  1    13     2 not_begin bit (1),				/* on if this pair must not begin */
  1    14     2 end bit (1),					/* on if this pair must end syllable */
  1    15     2 not_end bit (1),				/* on if this pair must not end */
  1    16     2 break bit (1),				/* on if this pair is a break pair */
  1    17     2 prefix bit (1),				/* on if vowel must precede this pair in same syllable */
  1    18     2 suffix bit (1),				/* on if vowel must follow this pair in same syllable */
  1    19     2 illegal_pair bit (1),				/* on if this pair may not appear */
  1    20     2 pad bit (1);					/* this makes 9 bits/entry */
  1    21 
  1    22 /* This array contains left justified 1 or 2-letter pairs representing each unit */
  1    23 
  1    24 dcl  letters (0:n_units) char (2) aligned based (addr (digrams$letters));
  1    25 
  1    26 /* This is the same as letters, but allows reference to individual characters */
  1    27 
  1    28 dcl 1 letters_split (0:n_units) based (addr (digrams$letters)),
  1    29     2 first char (1),
  1    30     2 second char (1),
  1    31     2 pad char (2);
  1    32 
  1    33 /* This array has rules for each unit */
  1    34 
  1    35 dcl 1 rules (n_units) aligned based (addr (digrams$rules)),
  1    36     2 no_final_split bit (1),				/* can't be the only vowel in last syllable */
  1    37     2 not_begin_syllable bit (1),			/* can't begin a syllable */
  1    38     2 vowel bit (1),				/* this is a vowel */
  1    39     2 alternate_vowel bit (1);			/* this is an alternate vowel, (i.e., "y") */
  1    40 
  1    41 dcl  n_units defined digrams$n_units fixed bin;
  1    42 
  1    43 /* ******** end include file digram_structure.incl.pl1 *********** */
       14 
       15 dcl (i, j, k, l) fixed bin;
       16 dcl  errflag bit (1) init ("0"b);
       17 dcl  fatal_flag bit (1) init ("0"b);
       18 dcl  neither_is_vowel bit (1);
       19 dcl  p ptr;
       20 dcl 1 x based (p) like digrams;
       21 dcl  letters_ (0:90) aligned char (2);			/* storage for letters until we know how many units there are */
       22 dcl 1 rules_ (90) aligned like rules;			/* ditto for rules */
       23 dcl  code fixed bin (35);
       24 dcl  flag bit (1);
       25 dcl  char char (1) init (" ");
       26 dcl  bc fixed bin (24);
       27 dcl  bitcount fixed bin (24);
       28 dcl  cleanup condition;
       29 dcl  term_$seg_ptr entry (ptr, fixed bin (35));
       30 dcl  get_group_id_ entry returns (char (32) aligned);
       31 dcl  hcs_$delentry_seg entry (ptr, fixed bin (35));
       32 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
       33 dcl (hcs_$add_acl_entries, hcs_$delete_acl_entries) entry
       34     (char (*), char (*), ptr, fixed bin, fixed bin (35));
       35 dcl 1 acl aligned,
       36     2 user_name char (32),
       37     2 modes bit (36),
       38     2 pad bit (36),
       39     2 code fixed bin (35);
       40 dcl  null builtin;
       41 dcl  loc fixed init (1);
       42 dcl  end bit (1);
       43 dcl  new_line char (1) init ("
       44 ");
       45 dcl  com_err_$suppress_name entry options (variable);
       46 dcl  hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35));
       47 dcl  get_pdir_ entry returns (char (168) aligned);
       48 dcl  get_wdir_ entry returns (char (168) aligned);
       49 dcl  alm entry options (variable);
       50 dcl  alm_prog based (prog_ptr) char (262144);
       51 dcl  prog_ptr ptr static init (null);
       52 dcl  seg_index init (1) fixed bin;
       53 
       54 /* This procedure creates an ALM program containing empty blocks of storage.
       55*   After finding out how many units there are, the size of each of these
       56*   blocks can be determined.  The ALM program is then assembled, and
       57*   segdef's are thus created which point to the beginning of each of
       58*   these blocks.
       59*
       60*   The first statement of the ALM program will be:
       61*
       62*   equ n,xxxxx
       63*
       64*   where xxxxx will be the number of units determined.  The rest of
       65*   the statements are below:  */
       66 
       67 dcl  alm_statements (9) char (30) varying init (
       68      "segdef digrams",
       69      "segdef n_units",
       70      "segdef letters",
       71      "segdef rules",
       72      "bss n_units,1",				/* n_units fixed bin */
       73      "bss digrams,(n*n+3)/4",				/* digrams(n_units,n_units) bit(9) */
       74      "bss letters,n+1",				/* letters(0:n_units) char(2) aligned */
       75      "bss rules,4*n",				/* 1 rules(n_units) aligned, 2 (b1,b2,b3,b4) bit(1) */
       76      "end");
       77 
       78 
       79 
       80 
       81 dcl  ioa_ entry options (variable);
       82 dcl  ioa_$nnl entry options (variable);
       83 
       84 /* check if a dollar sign ends segment */
       85 
       86 	if substr (source_table, bc/9 - 1, 1) ^= "$"
       87 	then goto dollar_error;
       88 
       89 /* first read all the different letters or pairs to be defined */
       90 
       91 	do i = 1 to 90 while (char ^= ";");		/* read until semicolon */
       92 	     char = substr (source_table, loc, 1);
       93 	     loc = loc + 1;
       94 	     if char < "a" | char > "z"
       95 	     then
       96 		do;
       97 		call ioa_$nnl ("alpha character expected");
       98 fatal_error:
       99 		fatal_flag = "1"b;
      100 		goto err;
      101 	     end;
      102 	     substr (letters_ (i), 1, 1) = char;
      103 	     char = substr (source_table, loc, 1);
      104 	     loc = loc + 1;
      105 	     substr (letters_ (i), 2, 1) = " ";
      106 	     if char < "a" | char > "z"
      107 	     then					/* second character is not alphabetic */
      108 
      109 try_bits:
      110 
      111 		if char = "1" | char = "0" | char = " "
      112 		then				/* second character is a bit */
      113 		     do;
      114 		     rules_ (i).not_begin_syllable = char = "1";
      115 		     char = substr (source_table, loc, 1);
      116 		     loc = loc + 1;
      117 		     if char = "1" | char = "0" | char = " "
      118 		     then				/* another "rules" bit */
      119 			do;
      120 			rules_ (i).no_final_split = char = "1";
      121 			char = substr (source_table, loc, 1);
      122 			loc = loc + 1;
      123 		     end;
      124 		     else				/* no second "rules" bit */
      125 		     do;
      126 			rules_ (i).no_final_split = "0"b;
      127 		     end;
      128 		end;
      129 		else				/* second character is not a bit and not alphabetic */
      130 		rules_ (i).not_begin_syllable, rules_ (i).no_final_split = "0"b;
      131 	     else					/* second character is alphabetic */
      132 	     do;
      133 		substr (letters_ (i), 2, 1) = char;
      134 		char = substr (source_table, loc, 1);
      135 		loc = loc + 1;
      136 		goto try_bits;
      137 	     end;
      138 
      139 /* check character following for comma, new_line, or semicolon */
      140 
      141 	     if char ^= ";" & char ^= "," & char ^= new_line
      142 	     then
      143 		do;
      144 		call ioa_$nnl ("comma, blank, zero, one, or letter expected");
      145 		goto fatal_error;
      146 	     end;
      147 
      148 /* check if this unit is already defined */
      149 
      150 	     if i ^= 1
      151 	     then
      152 		do j = 1 to i - 1;
      153 		if letters_ (j) = letters_ (i)
      154 		then do;
      155 		     call ioa_$nnl ("duplicate unit specification ""^a""", letters_ (j));
      156 		     goto fatal_error;
      157 		end;
      158 	     end;
      159 
      160 /* set vowel flags */
      161 
      162 	     rules_ (i).vowel = letters_ (i) = "a " | letters_ (i) = "e " | letters_ (i) = "i " | letters_ (i) = "o " | letters_ (i) = "u ";
      163 	     rules_ (i).alternate_vowel = letters_ (i) = "y ";
      164 	end;
      165 
      166 	if i > 90
      167 	then
      168 	     do;
      169 	     call ioa_ ("Too many units defined");	/* more than 90 units */
      170 	     return ("1"b);
      171 	end;
      172 
      173 /* this is the on unit for aborted compilation
      174*   It deletes the temporary segment containing the alm program, and
      175*   deletes the acl entry of digrams that references this process's id. */
      176 
      177 	on condition (cleanup)
      178 	     begin;
      179 	     if prog_ptr ^= null
      180 	     then call hcs_$delentry_seg (prog_ptr, code);
      181 	     call hcs_$delete_acl_entries (get_wdir_ (), "digrams", addr (acl), 1, code);
      182 	end;
      183 
      184 /* now that we know how many units, we can create the ALM program */
      185 
      186 /* first create the source segment in the process directory */
      187 
      188 	call hcs_$make_seg ("", "digrams.alm", "", 01010b, prog_ptr, code);
      189 	if prog_ptr = null
      190 	then do;
      191 error_in_alm_prog:
      192 	     call com_err_$suppress_name (code, "digram_table_compiler", "digrams.alm in process directory");
      193 	     return ("1"b);
      194 	end;
      195 
      196 	call addline ("equ n," || substr (character (i-1), verify (character (i-1), " "))); /* first line of ALM program */
      197 	do j = 1 to hbound (alm_statements, 1);		/* all the rest of the lines */
      198 	     call addline (alm_statements (j));
      199 	end;
      200 
      201 /* set the bit count of the source segment */
      202 
      203 	call hcs_$set_bc_seg (prog_ptr, (seg_index - 1)*9, code);
      204 	if code ^= 0 then goto error_in_alm_prog;
      205 
      206 /* assemble the ALM program */
      207 
      208 	call alm (before (get_pdir_ (), " ") || ">digrams");
      209 
      210 /* Hopefully we got no errors.  If we did, we can't tell */
      211 /* Delete the alm program, and set the acl of the object program
      212*   to rw for this process */
      213 
      214 	call hcs_$delentry_seg (prog_ptr, code);	/* ignore code */
      215 	prog_ptr = null ();				/* just to be clean */
      216 	acl.user_name = get_group_id_ ();
      217 	acl.modes = "101"b;
      218 	acl.pad = ""b;
      219 	call hcs_$add_acl_entries (get_wdir_ (), "digrams", addr (acl), 1, code);
      220 	if code ^= 0
      221 	then do;
      222 	     call com_err_$suppress_name (code, "digram_table_compiler", "digrams");
      223 	     return ("1"b);
      224 	end;
      225 
      226 /* Store stuff into the object segment */
      227 
      228 	n_units = i - 1;				/* This is the first reference to the object segment */
      229 	letters (0) = "";
      230 	do i = 1 to n_units;
      231 	     letters (i) = letters_ (i);
      232 	     rules (i) = rules_ (i);
      233 	end;
      234 
      235 /* digram table is compiled now */
      236 
      237 	do i = 1 to n_units;
      238 	     do j = 1 to n_units;
      239 		p = addr (digrams (i, j));
      240 		x.begin, x.not_begin, x.end, x.not_end, x.break, x.prefix, x.suffix = "0"b;
      241 		char = substr (source_table, loc, 1);
      242 		do while (char = new_line);
      243 		     loc = loc + 1;
      244 		     char = substr (source_table, loc, 1);
      245 		end;
      246 		if char = "$" then do; call ioa_ ("illegal $ -- premature end"); return ("1"b); end;
      247 		if char = " " | char = "1"
      248 		then
      249 		     do;
      250 		     x.begin = char = "1";
      251 		     loc = loc + 1;
      252 		     call next_char_bit;
      253 		     x.not_begin = char = "1";
      254 		     call next_char_bit;
      255 		     x.break = char = "1";
      256 		     call next_char;
      257 		     x.prefix = char = "-";
      258 		end;
      259 		call next_char;
      260 		if char = " " | char = "-" then goto erra;
      261 		if char ^= letters_split (i).first then goto errb;
      262 		call next_letter (i);
      263 		call next_char;
      264 		if char = " " | char = "-" then goto erra;
      265 		if char ^= letters_split (j).first
      266 		then
      267 		     do;
      268 
      269 /* in case the second unit of a digram pair specification is illegal,
      270*   this sequence attempts to get in sync again so that messages will not
      271*   be printed indefinitely.  If the first lunit is illegal,
      272*   no attempt is made to get in sync. */
      273 		     k = 1;
      274 errb1:		     do k = max (k, 1) to n_units while (char ^= letters_split (k).first);
      275 		     end;				/* this takes care of skipping some units or duplicating the last unit */
      276 		     if k <= n_units
      277 		     then
      278 			do;
      279 			if letters_split (k).second ^= " "
      280 			then
      281 			     do;
      282 			     char = substr (source_table, loc, 1);
      283 			     if char ^= letters_split (k).second
      284 			     then
      285 				do;
      286 				k = k + 1;
      287 				goto errb1;
      288 			     end;
      289 			end;
      290 			j = k + 1;
      291 		     end;
      292 		     else j = j + 1;		/* if the unit can't be found, assume it's there but spelled wrong */
      293 errb:		     j = j - 1;			/* if there is an extra digram that can't be found, we'll get another message */
      294 		     call ioa_$nnl ("out of order or illegal letter"); goto err;
      295 		end;
      296 		call next_letter (j);
      297 		char = substr (source_table, loc, 1);
      298 		loc = loc + 1;
      299 		if char ^= "," & char ^= new_line & char ^= "$"
      300 		then
      301 		     do;
      302 		     if char ^= " " & char ^= "-" & char ^= "+"
      303 		     then
      304 erra:			do;
      305 			call ioa_$nnl ("alpha character expected");
      306 			goto err;
      307 		     end;
      308 		     if char = "-"
      309 		     then x.suffix = "1"b;
      310 		     else
      311 		     if char = "+"
      312 		     then x.illegal_pair = "1"b;
      313 		     call next_bit;
      314 		     if end then goto loop;
      315 		     x.end = char = "1";
      316 		     call next_bit;
      317 		     if end then goto loop;
      318 		     x.not_end = char = "1";
      319 		     char = substr (source_table, loc, 1);
      320 		     if char ^= new_line & char ^= ","
      321 		     then do; call ioa_$nnl ("end of line expected"); goto err; end;
      322 		     loc = loc + 1;
      323 		end;
      324 loop:
      325 		neither_is_vowel = ^rules.vowel (i) & ^rules.vowel (j) & ^rules.alternate_vowel (i) & ^rules.alternate_vowel (j);
      326 		if (x.begin & (x.not_begin| (x.end & neither_is_vowel)| (^x.not_end & neither_is_vowel)| (x.break & ^rules.vowel (i)))) |
      327 		(rules.not_begin_syllable (j) & x.break) |
      328 		(x.end & (x.not_end| (^x.not_begin & neither_is_vowel)| (x.break & ^rules.vowel (j)))) |
      329 		(x.break & (^x.not_begin & ^rules.vowel (i) | ^x.not_end & ^rules.vowel (j))) |
      330 		(x.begin|x.not_begin|x.end|x.not_end|x.break|x.prefix|x.suffix)&x.illegal_pair
      331 		then
      332 		     do;
      333 		     call ioa_$nnl ("consistency error");
      334 err:		     do k = 1 to loc-1 while (substr (source_table, loc-k, 1) ^= new_line);
      335 		     end;
      336 		     do l = 0 to bc/9-loc while (substr (source_table, loc+l, 1) ^= new_line);
      337 		     end;
      338 		     if ^errflag then
      339 			call ioa_$nnl (" before * on following line");
      340 		     call ioa_ (":^/    " || substr (source_table, loc-k+1, k-1) ||
      341 			"*" || substr (source_table, loc, l));
      342 		     if fatal_flag then return ("1"b);	/* fatal error, can't continue */
      343 		     char = substr (source_table, loc-1, 1);
      344 		     do loc = loc by 1 while (char ^= "," &
      345 			     char ^= new_line & char ^= "$");
      346 			char = substr (source_table, loc, 1);
      347 		     end;
      348 		     errflag = "1"b;
      349 		end;
      350 	     end;
      351 	end;
      352 
      353 	call hcs_$delete_acl_entries (get_wdir_ (), "digrams", addr (acl), 1, code);
      354 
      355 /* at end of table, make sure "$" follows and terminate segment */
      356 
      357 	if substr (source_table, loc, 1) ^= "$"
      358 	then do;
      359 dollar_error:
      360 	     call ioa_ ("$ not found at end of segment");
      361 	     return ("1"b);
      362 	end;
      363 	call term_$seg_ptr (source_table_ptr, code);
      364 	return (errflag);
      365 
      366 /* get next letter, space, or "-" */
      367 
      368 next_char: procedure;
      369 	     char = substr (source_table, loc, 1);
      370 	     loc = loc + 1;
      371 	     if (char<"a" | char>"z") & char ^= " " & char ^= "-"
      372 	     then do; call ioa_$nnl ("alpha character expected"); goto err; end;
      373 	end;
      374 
      375 /* get next space or "1" */
      376 
      377 next_char_bit: procedure;
      378 	     char = substr (source_table, loc, 1);
      379 	     if char ^= " " & char ^= "1"
      380 	     then
      381 		do;
      382 		call ioa_$nnl ("space or 1 expected");
      383 		goto err;
      384 	     end;
      385 	     loc = loc + 1;
      386 	end;
      387 
      388 /* get next space, "1", ",", or new_line */
      389 
      390 next_bit:	procedure;
      391 	     char = substr (source_table, loc, 1);
      392 	     string (end) = "0"b;			/* fool indent */
      393 	     loc = loc + 1;
      394 	     if char ^= " "
      395 	     then
      396 		if char = "," | char = new_line
      397 		then end = "1"b;
      398 		else
      399 		if char ^= "1"
      400 		then
      401 		     do;
      402 		     call ioa_$nnl ("space, 1, comma, or new line expected");
      403 		     goto err;
      404 		end;
      405 	end;
      406 
      407 /* get next letter if this unit is a 2-letter unit */
      408 
      409 next_letter: proc (i);
      410 dcl  i fixed bin;
      411 	     if letters_split (i).second ^= " "
      412 	     then
      413 		do;
      414 		call next_char;
      415 		if char ^= letters_split (i).second
      416 		then
      417 		     do;
      418 		     call ioa_$nnl ("""" || letters_split (i).second || """ expected");
      419 		     goto err;
      420 		end;
      421 	     end;
      422 	end;
      423 
      424 /* Add a line to ALM program */
      425 
      426 addline:	proc (string);
      427 dcl  string char (30) varying;
      428 	     substr (alm_prog, seg_index, length (string) + 1) = string || "
      429 ";
      430 	     seg_index = seg_index + length (string) + 1;
      431 	end;
      432 
      433      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1530.3  read_table_.pl1                   >dumps>old>recomp>read_table_.pl1
14           1    06/16/75  2003.4  digram_structure.incl.pl1         >ldd>include>digram_structure.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
acl                             001026 automatic       structure                level 1 dcl 35 set ref 181 181 219 219 353 353
alm                             000046 constant        entry                    external dcl 49 ref 208
alm_prog                               based           char(262144)             unaligned dcl 50 set ref 428*
alm_statements                  001045 automatic       varying char(30)         initial array dcl 67 set ref 67* 67* 67* 67* 67* 67*
                                                                                  67* 67* 67* 197 198*
alternate_vowel           3            based           bit(1)                   array level 2 in structure "rules" dcl 1-35
                                                                                  in procedure "read_table_" set ref 324 324
alternate_vowel           3     000245 automatic       bit(1)                   array level 2 in structure "rules_" dcl 22
                                                                                  in procedure "read_table_" set ref 163*
bc                                     parameter       fixed bin(24,0)          dcl 26 ref 10 86 336
begin                                  based           bit(1)                   level 2 packed unaligned dcl 20 set ref 240* 250*
                                                                                  326 326
break                     0(04)        based           bit(1)                   level 2 packed unaligned dcl 20 set ref 240* 255*
                                                                                  326 326 326 326 326
char                            001016 automatic       char(1)                  initial unaligned dcl 25 set ref 25* 91 92* 94 94
                                                                                  102 103* 106 106 106 106 106 114 115* 117 117 117
                                                                                  120 121* 133 134* 141 141 141 241* 242 244* 246
                                                                                  247 247 250 253 255 257 260 260 261 264 264 265
                                                                                  274 282* 283 297* 299 299 299 302 302 302 308 310
                                                                                  315 318 319* 320 320 343* 344 344 344 346* 369*
                                                                                  371 371 371 371 378* 379 379 391* 394 394 394 398
                                                                                  415
cleanup                         001020 stack reference condition                dcl 28 ref 177
code                            001015 automatic       fixed bin(35,0)          dcl 23 set ref 179* 181* 188* 191* 203* 204 214*
                                                                                  219* 220 222* 353* 363*
com_err_$suppress_name          000036 constant        entry                    external dcl 45 ref 191 222
digrams                                based           structure                array level 1 packed unaligned dcl 1-11 set ref 239
digrams$digrams                 000012 external static fixed bin(17,0)          dcl 1-4 set ref 239
digrams$letters                 000016 external static fixed bin(17,0)          dcl 1-6 set ref 229 231 261 265 274 279 283 411 415
                                                                                  418
digrams$n_units                 000014 external static fixed bin(17,0)          dcl 1-5 set ref 228* 228 230 230 237 237 238 238 239
                                                                                  239 239 239 274 274 276 276
digrams$rules                   000020 external static fixed bin(17,0)          dcl 1-7 set ref 232 324 324 324 324 326 326 326 326
                                                                                  326
end                             001042 automatic       bit(1)                   unaligned dcl 42 in procedure "read_table_" set ref
                                                                                  314 317 392* 394*
end                       0(02)        based           bit(1)                   level 2 in structure "x" packed unaligned dcl 20
                                                                                  in procedure "read_table_" set ref 240* 315* 326
                                                                                  326 326
errflag                         000104 automatic       bit(1)                   initial unaligned dcl 16 set ref 16* 338 348* 364
fatal_flag                      000105 automatic       bit(1)                   initial unaligned dcl 17 set ref 17* 98* 342
first                                  based           char(1)                  array level 2 packed unaligned dcl 1-28 ref 261 265
                                                                                  274
get_group_id_                   000024 constant        entry                    external dcl 30 ref 216
get_pdir_                       000042 constant        entry                    external dcl 47 ref 208
get_wdir_                       000044 constant        entry                    external dcl 48 ref 181 181 219 219 353 353
hcs_$add_acl_entries            000032 constant        entry                    external dcl 33 ref 219
hcs_$delentry_seg               000026 constant        entry                    external dcl 31 ref 179 214
hcs_$delete_acl_entries         000034 constant        entry                    external dcl 33 ref 181 353
hcs_$make_seg                   000030 constant        entry                    external dcl 32 ref 188
hcs_$set_bc_seg                 000040 constant        entry                    external dcl 46 ref 203
i                                      parameter       fixed bin(17,0)          dcl 410 in procedure "next_letter" ref 409 411 415
                                                                                  418
i                               000100 automatic       fixed bin(17,0)          dcl 15 in procedure "read_table_" set ref 91* 102
                                                                                  105 114 120 126 129 129 133 150 150 153 162 162
                                                                                  162 162 162 162 163 163* 166 196 196 228 230* 231
                                                                                  231 232 232* 237* 239 261 262* 324 324 326 326*
illegal_pair              0(07)        based           bit(1)                   level 2 packed unaligned dcl 20 set ref 310* 326
ioa_                            000050 constant        entry                    external dcl 81 ref 169 246 340 359
ioa_$nnl                        000052 constant        entry                    external dcl 82 ref 97 144 155 294 305 321 333 338
                                                                                  372 382 402 418
j                               000101 automatic       fixed bin(17,0)          dcl 15 set ref 150* 153 155* 197* 198* 238* 239 265
                                                                                  290* 292* 292 293* 293 296* 324 324 326 326 326*
k                               000102 automatic       fixed bin(17,0)          dcl 15 set ref 273* 274* 274 274* 276 279 283 286*
                                                                                  286 290 334* 334* 340 340
l                               000103 automatic       fixed bin(17,0)          dcl 15 set ref 336* 336* 340
letters                                based           char(2)                  array dcl 1-24 set ref 229* 231*
letters_                        000112 automatic       char(2)                  array dcl 21 set ref 102* 105* 133* 153 153 155* 162
                                                                                  162 162 162 162 163 231
letters_split                          based           structure                array level 1 packed unaligned dcl 1-28
loc                             001041 automatic       fixed bin(17,0)          initial dcl 41 set ref 41* 92 93* 93 103 104* 104
                                                                                  115 116* 116 121 122* 122 134 135* 135 241 243*
                                                                                  243 244 251* 251 282 297 298* 298 319 322* 322 334
                                                                                  334 336 336 340 340 343 344* 344* 346* 357 369
                                                                                  370* 370 378 385* 385 391 393* 393
modes                    10     001026 automatic       bit(36)                  level 2 dcl 35 set ref 217*
n_units                                defined         fixed bin(17,0)          dcl 1-41 set ref 228* 230 237 238 239 239 274 276
neither_is_vowel                000106 automatic       bit(1)                   unaligned dcl 18 set ref 324* 326 326 326
new_line                        001043 automatic       char(1)                  initial unaligned dcl 43 set ref 43* 141 242 299 320
                                                                                  334 336 344 394
no_final_split                  000245 automatic       bit(1)                   array level 2 dcl 22 set ref 120* 126* 129*
not_begin                 0(01)        based           bit(1)                   level 2 packed unaligned dcl 20 set ref 240* 253*
                                                                                  326 326 326 326
not_begin_syllable        1            based           bit(1)                   array level 2 in structure "rules" dcl 1-35
                                                                                  in procedure "read_table_" set ref 326
not_begin_syllable        1     000245 automatic       bit(1)                   array level 2 in structure "rules_" dcl 22
                                                                                  in procedure "read_table_" set ref 114* 129*
not_end                   0(03)        based           bit(1)                   level 2 packed unaligned dcl 20 set ref 240* 318*
                                                                                  326 326 326 326
null                                                   builtin function         dcl 40 ref 179 189 215
p                               000110 automatic       pointer                  dcl 19 set ref 239* 240 240 240 240 240 240 240 250
                                                                                  253 255 257 308 310 315 318 326 326 326 326 326
                                                                                  326 326 326 326 326 326 326 326 326 326 326 326
                                                                                  326 326 326 326
pad                      11     001026 automatic       bit(36)                  level 2 dcl 35 set ref 218*
prefix                    0(05)        based           bit(1)                   level 2 packed unaligned dcl 20 set ref 240* 257*
                                                                                  326
prog_ptr                        000010 internal static pointer                  initial dcl 51 set ref 179 179* 188* 189 203* 214*
                                                                                  215* 428
rules                                  based           structure                array level 1 dcl 1-35 set ref 232*
rules_                          000245 automatic       structure                array level 1 dcl 22 set ref 232
second                    0(09)        based           char(1)                  array level 2 packed unaligned dcl 1-28 ref 279 283
                                                                                  411 415 418
seg_index                       001044 automatic       fixed bin(17,0)          initial dcl 52 set ref 52* 203 428 430* 430
source_table                           based           char(1048575)            unaligned dcl 12 ref 86 92 103 115 121 134 241 244
                                                                                  282 297 319 334 336 340 340 343 346 357 369 378
                                                                                  391
source_table_ptr                       parameter       pointer                  dcl 13 set ref 10 86 92 103 115 121 134 241 244 282
                                                                                  297 319 334 336 340 340 343 346 357 363* 369 378
                                                                                  391
string                                 parameter       varying char(30)         dcl 427 ref 426 428 428 430
suffix                    0(06)        based           bit(1)                   level 2 packed unaligned dcl 20 set ref 240* 308*
                                                                                  326
term_$seg_ptr                   000022 constant        entry                    external dcl 29 ref 363
user_name                       001026 automatic       char(32)                 level 2 dcl 35 set ref 216*
vowel                     2            based           bit(1)                   array level 2 in structure "rules" dcl 1-35
                                                                                  in procedure "read_table_" set ref 324 324 326 326
                                                                                  326 326
vowel                     2     000245 automatic       bit(1)                   array level 2 in structure "rules_" dcl 22
                                                                                  in procedure "read_table_" set ref 162*
x                                      based           structure                level 1 packed unaligned dcl 20

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
bitcount                               automatic       fixed bin(24,0)          dcl 27
flag                                   automatic       bit(1)                   unaligned dcl 24

NAMES DECLARED BY EXPLICIT CONTEXT.
addline                         003314 constant        entry                    internal dcl 426 ref 196 198
dollar_error                    003032 constant        label                    dcl 359 ref 86
err                             002523 constant        label                    dcl 334 ref 100 294 306 321 372 383 403 419
erra                            002204 constant        label                    dcl 302 ref 260 264
errb                            002136 constant        label                    dcl 293 set ref 261
errb1                           002057 constant        label                    dcl 274 ref 287
error_in_alm_prog               001202 constant        label                    dcl 191 ref 204
fatal_error                     000525 constant        label                    dcl 98 ref 145 156
loop                            002322 constant        label                    dcl 324 ref 314 317
next_bit                        003175 constant        entry                    internal dcl 390 ref 313 316
next_char                       003073 constant        entry                    internal dcl 368 ref 256 259 263 414
next_char_bit                   003140 constant        entry                    internal dcl 377 ref 252 254
next_letter                     003242 constant        entry                    internal dcl 409 ref 262 296
read_table_                     000270 constant        entry                    external dcl 10
try_bits                        000551 constant        label                    dcl 106 ref 136

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 181 181 219 219 229 231 232 239 239 261 265 274
                                                                                  279 283 324 324 324 324 326 326 326 326 326 353
                                                                                  353 411 415 418
before                                                 builtin function         ref 208
character                                              builtin function         ref 196 196
hbound                                                 builtin function         ref 197
length                                                 builtin function         ref 428 430
max                                                    builtin function         ref 274
string                                                 builtin function         ref 392
substr                                                 builtin function         set ref 86 92 102* 103 105* 115 121 133* 134 196 241
                                                                                  244 282 297 319 334 336 340 340 343 346 357 369
                                                                                  378 391 428*
verify                                                 builtin function         ref 196

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3570        3644    3365        3600
Length      4102    3365        54         222     203           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
read_table_                         880 external procedure  is an external procedure.  
on unit on line 177                 159 on unit               
next_char                               internal procedure  shares stack frame of external procedure read_table_.  
next_char_bit                           internal procedure  shares stack frame of external procedure read_table_.  
next_bit                                internal procedure  shares stack frame of external procedure read_table_.  
next_letter                             internal procedure  shares stack frame of external procedure read_table_.  
addline                                 internal procedure  shares stack frame of external procedure read_table_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 prog_ptr                    read_table_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
read_table_              000100 i                           read_table_
                         000101 j                           read_table_
                         000102 k                           read_table_
                         000103 l                           read_table_
                         000104 errflag                     read_table_
                         000105 fatal_flag                  read_table_
                         000106 neither_is_vowel            read_table_
                         000110 p                           read_table_
                         000112 letters_                    read_table_
                         000245 rules_                      read_table_
                         001015 code                        read_table_
                         001016 char                        read_table_
                         001026 acl                         read_table_
                         001041 loc                         read_table_
                         001042 end                         read_table_
                         001043 new_line                    read_table_
                         001044 seg_index                   read_table_
                         001045 alm_statements              read_table_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        return
enable              shorten_stack       ext_entry           int_entry           trunc_fx2           divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
alm                           com_err_$suppress_name        get_group_id_                 get_pdir_
get_wdir_                     hcs_$add_acl_entries          hcs_$delentry_seg             hcs_$delete_acl_entries
hcs_$make_seg                 hcs_$set_bc_seg               ioa_                          ioa_$nnl
term_$seg_ptr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
digrams$digrams               digrams$letters               digrams$n_units               digrams$rules




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     10 000264        16 000275        17 000276        25 000277        41 000301        43 000303        52 000305
     67 000306        86 000436        91 000457        92 000467        93 000477        94 000500        97 000506
     98 000525       100 000527       102 000530       103 000532       104 000537       105 000540       106 000543
    114 000560       115 000566       116 000576       117 000577       120 000607       121 000612       122 000617
    123 000620       126 000621       128 000622       129 000623       133 000630       134 000633       135 000640
    136 000641       141 000642       144 000651       145 000665       150 000666       153 000700       155 000711
    156 000731       158 000732       162 000734       163 000772       164 000776       166 001000       169 001002
    170 001021       177 001027       179 001043       181 001060       182 001132       188 001133       189 001175
    191 001202       193 001234       196 001242       197 001315       198 001323       199 001332       203 001334
    204 001353       208 001355       214 001417       215 001431       216 001434       217 001442       218 001444
    219 001445       220 001516       222 001520       223 001551       228 001557       229 001563       230 001565
    231 001574       232 001601       233 001612       237 001614       238 001624       239 001634       240 001654
    241 001701       242 001711       243 001714       244 001715       245 001725       246 001726       246 001730
    246 001744       247 001752       250 001756       251 001765       252 001766       253 001767       254 001777
    255 002000       256 002010       257 002011       259 002021       260 002022       261 002027       262 002036
    263 002040       264 002041       265 002046       273 002055       274 002057       275 002100       276 002102
    279 002105       282 002115       283 002125       286 002127       287 002130       290 002131       291 002134
    292 002135       293 002136       294 002140       294 002153       296 002154       297 002156       298 002166
    299 002167       302 002176       305 002204       306 002223       308 002224       310 002233       313 002241
    314 002242       315 002244       316 002254       317 002255       318 002257       319 002267       320 002277
    321 002304       321 002320       322 002321       324 002322       326 002351       333 002505       334 002523
    335 002544       336 002546       337 002576       338 002600       340 002616       342 002677       343 002710
    344 002720       346 002731       347 002741       348 002743       350 002745       351 002747       353 002751
    357 003022       359 003032       361 003046       363 003054       364 003065       368 003073       369 003074
    370 003104       371 003105       372 003117       372 003136       373 003137       377 003140       378 003141
    379 003151       382 003156       383 003172       385 003173       386 003174       390 003175       391 003176
    392 003206       393 003207       394 003210       398 003222       402 003224       403 003240       405 003241
    409 003242       411 003244       414 003254       415 003255       418 003270       419 003312       422 003313
    426 003314       428 003316       430 003335       431 003341


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
