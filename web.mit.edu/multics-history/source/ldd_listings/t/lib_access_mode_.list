	COMPILATION LISTING OF SEGMENT lib_access_mode_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/15/84  0848.4 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       12 	/*									*/
       13 	/* Name:  lib_access_mode_							*/
       14 	/*									*/
       15 	/*      This subroutine is part of the library maintenance tools.  It gets and sets the	*/
       16 	/* current user's (person.project.a) access to a given library entry.			*/
       17 	/*									*/
       18 	/* Entry:  lib_access_mode_$get						*/
       19 	/*									*/
       20 	/*      This entry gets user's access to a given entry.				*/
       21 	/*									*/
       22 	/* Usage									*/
       23 	/*									*/
       24 	/* dcl lib_access_mode_$get entry (ptr, fixed bin(35));				*/
       25 	/*									*/
       26 	/* call lib_access_mode_$get (Pnode, code);					*/
       27 	/*									*/
       28 	/* where:									*/
       29 	/* 1. Pnode	is a pointer to the library node representing the library entry. (In)	*/
       30 	/* 2. code	is an error code. (Out)					*/
       31 	/*									*/
       32 
       33 	/* Entry:  lib_access_mode_$set						*/
       34 	/*									*/
       35 	/*      This entry sets the user's access to a given library entry.  If necessary,	*/
       36 	/* the user will be given access to the archive, directory, or MSF which contains the	*/
       37 	/* library entry.  Links are chased.						*/
       38 	/*									*/
       39 	/*      If the user already has sufficient access to meet the requirements of the 	*/
       40 	/* requested access mode, then no changes are made.  				*/
       41 	/*									*/
       42 	/*      Access is granted in such a way that it can be unset, leaving the ACL in its	*/
       43 	/* original state, by call lib_access_mode_$unset.				*/
       44 	/*									*/
       45 	/* Usage									*/
       46 	/*									*/
       47 	/* dcl lib_access_mode_$set (ptr, bit(36) aligned, fixed bin, fixed bin(35));		*/
       48 	/*									*/
       49 	/* call lib_access_mode_$set (Pnode, new_mode, unset_depth, code);			*/
       50 	/*									*/
       51 	/* where:									*/
       52 	/* 1.  Pnode	is as above. (In)						*/
       53 	/* 2.  new_mode	is a bit string describing the required user access. (In)		*/
       54 	/*		For directories, the bits represent "sma..."b.			*/
       55 	/*		For other entries, the bits represent "rew..."b.			*/
       56 	/* 3.  unset_depth	defines the depth up or down the library node tree to which access	*/
       57 	/*		changes had to be made in order to set the user's access.  This	*/
       58 	/*		value must be given to lib_access_mode_$unset to properly unset	*/
       59 	/*		the access mode. (Out)					*/
       60 	/* 4.  code	is as above. (Out)						*/
       61 	/*									*/
       62 	/* Entry:  lib_access_mode_$unset						*/
       63 	/*									*/
       64 	/*      This entry undoes what the $set entry does, so that all ACLs are in their original*/
       65 	/* state.									*/
       66 	/*									*/
       67 	/* Usage									*/
       68 	/*									*/
       69 	/* dcl lib_access_mode_$unset (ptr, fixed bin, fixed bin(35));			*/
       70 	/*									*/
       71 	/* call lib_access_mode_$unset (Pnode, unset_depth, code);				*/
       72 	/*									*/
       73 	/* where:									*/
       74 	/* 1. - 3.	are as described above.					*/
       75 	/*									*/
       76 	/* Status:								*/
       77 	/*									*/
       78 	/* 0) Created in  June, 1976  by Gary C. Dixon					*/
       79 	/* 1) Modified on October 11, 1983 by Jim Lippard to change all occurrences of		*/
       80 	/* error_table_$invalid_data_format to error_table_$improper_data_format.		*/
       81 	/*									*/
       82 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       83 
       84 
       85 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       86 
       87 
       88 lib_access_mode_:	procedure;
       89 
       90      dcl						/*	Parameters			*/
       91 	new_mode			bit(36) aligned,	/* access to node which is required.		*/
       92 	unset_depth		fixed bin,	/* depth up/down tree to which setting was done.	*/
       93 	code			fixed bin(35);	/* return code.				*/
       94 
       95      dcl						/*	Automatic Variables			*/
       96 	Bmode			bit(5),		/* bit access mode (xrewx, or xsmxa).		*/
       97 	Nmode			fixed bin(5),	/* binary access mode.			*/
       98 	Pmsf_fcb			ptr,		/* ptr to msf_manager_ control block.		*/
       99 	Sunset_required		bit(1) aligned,	/* on if ACL changed during $set call.		*/
      100 	1 acle			aligned,		/* segment ACL entry addition structure.	*/
      101 	  2 user			char(32),
      102 	  2 mode			bit(36),
      103 	  2 pad			bit(36),
      104 	  2 code			fixed bin(35),
      105 	1 del_acle		aligned,		/* segment ACL entry deletion structure.	*/
      106 	  2 user			char(32),
      107 	  2 code			fixed bin(35),
      108 	dir			char(168) varying,	/* dir part of node pathname.			*/
      109 	1 dir_acle		aligned,		/* directory ACL entry addition structure.	*/
      110 	  2 user			char(32),
      111 	  2 mode			bit(36),
      112 	  2 code			fixed bin(35),
      113 	ent			char(32) varying;	/* ent part of node pathname.			*/
      114 
      115      dcl						/* 	Built-in Functions and Conditions	*/
      116          (addr, bit, null, substr)
      117 				builtin,
      118 	cleanup			condition;
      119 
      120      dcl						/*	Entries Called			*/
      121 	get_group_id_	entry returns (char(32)),
      122 	get_ring_		entry returns (fixed bin(3)),
      123          (hcs_$add_acl_entries,
      124 	hcs_$add_dir_acl_entries,
      125 	hcs_$delete_acl_entries,
      126 	hcs_$delete_dir_acl_entries,
      127 	installation_tools_$add_acl_entries,
      128 	installation_tools_$delete_acl_entries)
      129 				entry (char(*), char(*), ptr, fixed bin, fixed bin(35)),
      130 	hcs_$get_user_effmode	entry (char(*), char(*), char(*), fixed bin, fixed bin(5), fixed bin(35)),
      131          (hcs_$list_acl,
      132 	hcs_$list_dir_acl)		entry (char(*), char(*), ptr, ptr, ptr, fixed bin, fixed bin(35)),
      133 	lib_node_path_		entry (ptr, char(168) varying, char(32) varying),
      134          (msf_manager_$acl_add,
      135 	msf_manager_$acl_delete)	entry (ptr, ptr, fixed bin, fixed bin(35)),
      136 	msf_manager_$acl_list	entry (ptr, ptr, ptr, ptr, fixed bin, fixed bin(35)),
      137 	msf_manager_$close		entry (ptr),
      138 	msf_manager_$open		entry (char(*), char(*), ptr, fixed bin(35));
      139  
      140      dcl						/*	Static Variables			*/
      141 	False			bit(1) aligned int static options(constant) init ("0"b),
      142 	True			bit(1) aligned int static options(constant) init ("1"b),
      143          (error_table_$improper_data_format,
      144 	error_table_$link,
      145 	error_table_$out_of_sequence,
      146 	error_table_$user_not_found)	fixed bin(35) ext static,
      147 	ring			fixed bin int static init (8),
      148 	user			char(32) int static init ("");
      149 
      150 
      151 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      152 
      153 
      154 get:	entry	(Pnode, code);
      155 
      156 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      157 	/*									*/
      158 	/*  lib_access_mode_$get sets the node.Smode field of input mode current user's access	*/
      159 	/*  to the library entry associated with the node.				*/
      160 	/*									*/
      161 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      162 
      163 
      164 	if user = "" then user = get_group_id_();	/* initialize internal static values.		*/
      165 	if ring = 8  then ring = get_ring_();
      166 
      167 	code = 0;					/* initialize return code.			*/
      168 	if Svalid.mode then;			/* if mode already known, return.		*/
      169 	else if node.T = Tlink then do;		/* chase links to get associated access mode.	*/
      170 	     if Svalid.kids then do;
      171 		do PDnodes = node.PD repeat Dnodes.Pnext while (Dnodes.header.T ^= Tnodes);
      172 		     end;
      173 		if Dnodes.N ^= 1 then code = error_table_$link;
      174 		else do;
      175 		     call get (addr(Dnodes.nodes(1)), code);
      176 		     if code = 0 then do;
      177 			node.Smode = addr(Dnodes.nodes(1))->node.Smode;
      178 			Svalid.mode = True;
      179 			end;
      180 		     end;
      181 		end;
      182 	     else code = error_table_$link;
      183 	     end;
      184 	else if node.T = Tarchive_comp then do;		/* assoc access to containing archive with comp.	*/
      185 ARCH_COMP:     call get (node.Pparent, code);
      186 	     if code ^= 0 then do;
      187 		node.Smode = node.Pparent->node.Smode;
      188 		Svalid.mode = True;
      189 		end;
      190 	     end;
      191 	else if node.T = Tarchive & node.offset ^= 0 then	/* do same for archived archive.		*/
      192 	     go to ARCH_COMP;
      193 	else do;					/* get user's access to the library entry.	*/
      194 	     call lib_node_path_ (Pnode, dir, ent);
      195 	     call hcs_$get_user_effmode ((dir), (ent), user, ring, Nmode, code);
      196 	     if code = 0 then do;
      197 		Bmode = bit(Nmode,5);
      198 		if node.T = Tdirectory then do;	/* for directories:				*/
      199 		     substr (node.Smode, 1, 1) = substr (Bmode, 2, 1);
      200 		     substr (node.Smode, 2, 2) = substr (Bmode, 4, 2);
      201 		     end;				/*   map 'xsxma' into 'sma'.			*/
      202 		else if node.T = Tmsf then do;	/* for msfs:				*/
      203 		     substr (node.Smode, 1, 1) = substr (Bmode, 2, 1);
      204 		     substr (node.Smode, 2, 1) = "0"b;
      205 		     substr (node.Smode, 3, 1) = substr (Bmode, 4, 1);
      206 		     end;				/*   map 'xsxma' into 'rxw'.			*/
      207 		else				/* for segments:				*/
      208 		     substr (node.Smode, 1, 3) = substr (Bmode, 2, 3);
      209 		     				/*   map 'xrewx' into 'rew'.			*/
      210 		Svalid.mode = True;			/* mark access mode as being valid.		*/
      211 		end;
      212 	     end;
      213 	return;
      214 
      215 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      216 
      217 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      218 
      219 
      220 set:	entry	(Pnode, new_mode, unset_depth, code);
      221 
      222 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      223 	/*									*/
      224 	/* lib_access_mode_$set sets the user's access (person.proj.a) to a given library entry	*/
      225 	/* to a specified mode.  Information is returned to reverse the setting to the original	*/
      226 	/* ACL contents.								*/
      227 	/*									*/
      228 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      229 
      230 
      231 	if user = "" then user = get_group_id_();	/* initialize internal static values.		*/
      232 	if ring = 8  then ring = get_ring_();
      233 
      234 	code = 0;					/* initialize return code.			*/
      235 	unset_depth = 0;				/* to start with, no unsetting is required.	*/
      236 
      237 
      238 set_recurse:	entry	(Pnode, new_mode, unset_depth, code);
      239 
      240 	if Svalid.mode then;			/* get current mode, if not already known.	*/
      241 	else do;
      242 	     call get (Pnode, code);
      243 	     if code ^= 0 then return;
      244 	     end;
      245 
      246 	if (node.Smode & new_mode) = new_mode then 	/* do nothing if current mode sufficient to meet	*/
      247 	     Sunset_required = False;			/*   user's needs.				*/
      248 	else Sunset_required = True;
      249 
      250 	if Sunset_required then			/* cannot set ACL if previously set without unset	*/
      251 	     if Svalid.prev_mode then do;
      252 		code = error_table_$out_of_sequence;
      253 		Sunset_required = False;
      254 		end;
      255 
      256 	if Sunset_required then do;			/* must take positive action to set the ACL.	*/
      257 	     unset_depth = unset_depth + 1;		/* indicate taking another step up/down tree.	*/
      258 	     if node.T = Tlink then do;		/* chase links to set mode.			*/
      259 		if Svalid.kids then do;
      260 		     do PDnodes = node.PD repeat Dnodes.Pnext while (Dnodes.header.T ^= Tnodes);
      261 			end;
      262 		     if Dnodes.N ^= 1 then code = error_table_$link;
      263 		     else do;
      264 			call set_recurse (addr(Dnodes.nodes(1)), new_mode, unset_depth, code);
      265 			if code = 0 then do;
      266 			     node.Smode       = addr(Dnodes.nodes(1))->node.Smode;
      267 			     node.Sprev_mode  = addr(Dnodes.nodes(1))->node.Sprev_mode;
      268 			     Svalid.mode      = addr (addr(Dnodes.nodes(1))->node.Svalid)->Svalid.mode;
      269 			     Svalid.prev_mode = addr (addr(Dnodes.nodes(1))->node.Svalid)->Svalid.prev_mode;
      270 			     end;
      271 			end;
      272 		     end;
      273 		else code = error_table_$link;
      274 		end;
      275 	     else if node.T = Tarchive_comp then do;	/* set ACL on containing archive.		*/
      276 ARCH_COMP_ACL:	call set_recurse ((node.Pparent), new_mode, unset_depth, code);
      277 		if code = 0 then do;
      278 		     node.Smode       = node.Pparent->node.Smode;
      279 		     node.Sprev_mode  = node.Pparent->node.Sprev_mode;
      280 		     Svalid.mode      = addr(node.Pparent->node.Svalid)->Svalid.mode;
      281 		     Svalid.prev_mode = addr(node.Pparent->node.Svalid)->Svalid.prev_mode;
      282 		     end;
      283 		end;
      284 	     else if node.T = Tarchive & node.offset ^= 0 then
      285 		go to ARCH_COMP_ACL;		/* do same for archived archive.		*/
      286 	     else if node.T = Tmsf_comp then		/* do same for MSF component (must keep MSF ACL	*/
      287 		go to ARCH_COMP_ACL;		/*   consistent).				*/
      288 
      289 	     else do;
      290 		if node.Pparent ^= null then do;	/* make sure we have access to set access.	*/
      291 		     call set_recurse ((node.Pparent), "110"b, unset_depth, code);
      292 		     if code ^= 0 then return;
      293 		     end;
      294 		call lib_node_path_ (Pnode, dir, ent);	/* get pathname of entry being considered.	*/
      295 		if node.T = Tsegment then do;		/* set segment ACL.				*/
      296 SEG_ACL:		     acle.user = user;
      297 		     acle.mode = ""b;
      298 		     acle.pad  = ""b;
      299 		     acle.code = 0;
      300 		     call hcs_$list_acl ((dir), (ent), null, null, addr(acle), 1, code);
      301 		     if code ^= 0 then return;
      302 		     if acle.code = error_table_$user_not_found then
      303 			node.Sprev_mode = node.Smode;	/*     save user's prev mode, but do NOT mark	*/
      304 						/*       prev mode as valid;  this is reserved	*/
      305 						/*       for prev modes appearing in separate	*/
      306 						/*       ACL entry for user.			*/
      307 		     else do;
      308 			node.Sprev_mode = acle.mode;
      309 			Svalid.prev_mode = True;
      310 			end;
      311 		     acle.mode = new_mode;
      312 		     acle.code = 0;
      313 		     if node.rb(1) < ring then
      314 			call installation_tools_$add_acl_entries ((dir), (ent), addr(acle), 1, code);
      315 		     else call hcs_$add_acl_entries                ((dir), (ent), addr(acle), 1, code);
      316 		     end;
      317 		else if node.T = Tdirectory then do;	/* set directory ACL.			*/
      318 		     dir_acle.user = user;		/*     get current ACLe applying to person.proj.a	*/
      319 		     dir_acle.mode = ""b;
      320 		     dir_acle.code = 0;
      321 		     call hcs_$list_dir_acl ((dir), (ent), null, null, addr(dir_acle), 1, code);
      322 		     if code ^= 0 then return;
      323 		     if dir_acle.code = error_table_$user_not_found then
      324 			node.Sprev_mode = node.Smode;	/*     save user's prev mode, but do NOT mark	*/
      325 						/*       prev mode as valid;  this is reserved	*/
      326 						/*       for prev modes appearing in separate	*/
      327 						/*       ACL entry for user.			*/
      328 		     else do;
      329 			node.Sprev_mode = dir_acle.mode;
      330 			Svalid.prev_mode = True;
      331 			end;
      332 		     dir_acle.mode = new_mode;	/*     set the new mode.			*/
      333 		     dir_acle.code = 0;
      334 		     call hcs_$add_dir_acl_entries ((dir), (ent), addr(dir_acle), 1, code);
      335 		     end;
      336 
      337 		else if node.T = Tarchive then 	/* most archives can be handled like segments.	*/
      338 		     go to SEG_ACL;
      339 		else if node.T = Tmsf then do;	/* set MSF ACL.				*/
      340 		     acle.user = user;
      341 		     acle.mode = ""b;
      342 		     acle.pad  = ""b;
      343 		     acle.code = 0;
      344 		     Pmsf_fcb = null;
      345 		     on cleanup begin;
      346 			if Pmsf_fcb ^= null then
      347 			     call msf_manager_$close (Pmsf_fcb);
      348 			end;
      349 		     call msf_manager_$open ((dir), (ent), Pmsf_fcb, code);
      350 		     if code ^= 0 then return;
      351 		     call msf_manager_$acl_list (Pmsf_fcb, null, null, addr(acle), 1, code);
      352 		     if code ^= 0 then do;
      353 			call msf_manager_$close (Pmsf_fcb);
      354 			return;
      355 			end;
      356 		     if acle.code = error_table_$user_not_found then
      357 			node.Sprev_mode = node.Smode;	/*     save user's prev mode, but do NOT mark	*/
      358 						/*       prev mode as valid;  this is reserved	*/
      359 						/*       for prev modes appearing in separate	*/
      360 						/*       ACL entry for user.			*/
      361 		     else do;
      362 			node.Sprev_mode = acle.mode;
      363 			Svalid.prev_mode = True;
      364 			end;
      365 		     acle.mode = new_mode;
      366 		     acle.code = 0;
      367 		     call msf_manager_$acl_add (Pmsf_fcb, addr(acle), 1, code);
      368 		     call msf_manager_$close (Pmsf_fcb);
      369 		     revert cleanup;
      370 		     end;
      371 		end;
      372 	     end;
      373 	return;
      374 
      375 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      376 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      377 
      378 
      379 unset:	entry	(Pnode, unset_depth, code);
      380 
      381 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      382 	/*									*/
      383 	/* lib_access_mode_$unset reverts any access change made by the $set entry point.	*/
      384 	/*									*/
      385 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      386 
      387 
      388 	if user = "" then user = get_group_id_();	/* initialize internal static values.		*/
      389 	if ring = 8  then ring = get_ring_();
      390 
      391 	code = 0;					/* initialize return values.			*/
      392 
      393 	if unset_depth = 0 then return;		/* no unsetting required.			*/
      394 
      395 	unset_depth = unset_depth - 1;		/* for what we are about to do, count it.	*/
      396 
      397 	if node.T = Tlink then do;			/* link unsetting must be done to link kids.	*/
      398 	     if ^Svalid.mode then;			/*     must have gotten error setting; ignore	*/
      399 	     else if ^Svalid.kids then
      400 		code = error_table_$improper_data_format;
      401 	     else do;
      402 		do PDnodes = node.PD repeat Dnodes.Pnext while (Dnodes.header.T ^= Tnodes);
      403 		     end;
      404 		if Dnodes.N = 1 then
      405 		     code = error_table_$improper_data_format;
      406 		else do;
      407 		     call unset (addr(Dnodes.nodes(1)), unset_depth, code);
      408 		     node.Smode       = addr(Dnodes.nodes(1))->node.Smode;
      409 		     node.Sprev_mode  = addr(Dnodes.nodes(1))->node.Sprev_mode;
      410 		     Svalid.mode      = addr (addr(Dnodes.nodes(1))->node.Svalid)->Svalid.mode;
      411 		     Svalid.prev_mode = addr (addr(Dnodes.nodes(1))->node.Svalid)->Svalid.prev_mode;
      412 		     end;
      413 		end;
      414 	     end;
      415 
      416 	else do;					/* all other unsetting done to node and its parent*/
      417 	     call lib_node_path_ (Pnode, dir, ent);
      418 	     if node.T = Tsegment then do;		/* restore segment ACL			*/
      419 SEG_ACL_UNSET:	if Svalid.prev_mode then do;		/*     restore previous ACL entry mode.		*/
      420 		     acle.user = user;
      421 		     acle.mode = node.Sprev_mode;
      422 		     acle.pad  = ""b;
      423 		     acle.code = 0;
      424 		     if node.rb(1) < ring then
      425 			call installation_tools_$add_acl_entries ((dir), (ent), addr(acle), 1, code);
      426 		     else call hcs_$add_acl_entries                ((dir), (ent), addr(acle), 1, code);
      427 		     if code ^= 0 then;
      428 		     else do;
      429 			Svalid.prev_mode = False;
      430 			node.Smode = node.Sprev_mode;
      431 			end;
      432 		     end;
      433 		else do;				/*     delete ACL entry for user.		*/
      434 		     del_acle.user = user;
      435 		     del_acle.code = 0;
      436 		     if node.rb(1) < ring then
      437 			call installation_tools_$delete_acl_entries ((dir), (ent), addr(del_acle), 1, code);
      438 		     else call hcs_$delete_acl_entries                ((dir), (ent), addr(del_acle), 1, code);
      439 		     if code ^= 0 then;
      440 		     else node.Smode = node.Sprev_mode;
      441 		     end;
      442 		end;
      443 	     else if node.T = Tdirectory then do;	/* restore directory ACL.			*/
      444 		if Svalid.prev_mode then do;		/*     restore previous ACL entry mode.		*/
      445 		     dir_acle.user = user;
      446 		     dir_acle.mode = node.Sprev_mode;
      447 		     dir_acle.code = 0;
      448 		     call hcs_$add_dir_acl_entries ((dir), (ent), addr(dir_acle), 1, code);
      449 		     if code ^= 0 then;
      450 		     else do;
      451 			Svalid.prev_mode = False;
      452 			node.Smode = node.Sprev_mode;
      453 			end;
      454 		     end;
      455 	 	else do;				/*     delete ACL entry for user.		*/
      456 		     del_acle.user = user;
      457 		     del_acle.code = 0;
      458 		     call hcs_$delete_dir_acl_entries ((dir), (ent), addr(del_acle), 1, code);
      459 		     if code ^= 0 then;
      460 		     else node.Smode = node.Sprev_mode;
      461 		     end;
      462 		end;
      463 	     else if node.T = Tarchive then
      464 		if node.offset > 0 then
      465 		     go to ARCH_ACL_UNSET;
      466 		else go to SEG_ACL_UNSET;
      467 	     else if node.T = Tarchive_comp then do;	/* restore archive component ACL.		*/
      468 ARCH_ACL_UNSET:	call unset ((node.Pparent), unset_depth, code);
      469 		node.Smode       = node.Pparent->node.Smode;
      470 		node.Sprev_mode  = node.Pparent->node.Sprev_mode;
      471 		Svalid.mode      = addr(node.Pparent->node.Svalid)->Svalid.mode;
      472 		Svalid.prev_mode = addr(node.Pparent->node.Svalid)->Svalid.prev_mode;
      473 		end;
      474 
      475 	     else if node.T = Tmsf then do;		/* restore MSF ACL.				*/
      476 		Pmsf_fcb = null;
      477 		on cleanup begin;
      478 		     if Pmsf_fcb ^= null then
      479 			call msf_manager_$close (Pmsf_fcb);
      480 		     end;
      481 		call msf_manager_$open ((dir), (ent), Pmsf_fcb, code);
      482 		if code ^= 0 then return;
      483 		if Svalid.prev_mode then do;		/*     restore previous ACL entry mode.		*/
      484 		     acle.user = user;
      485 		     acle.mode = node.Sprev_mode;
      486 		     acle.pad  = ""b;
      487 		     acle.code = 0;
      488 		     call msf_manager_$acl_add (Pmsf_fcb, addr(acle), 1, code);
      489 		     if code ^= 0 then;
      490 		     else do;
      491 			Svalid.prev_mode = False;
      492 			node.Smode = node.Sprev_mode;
      493 			end;
      494 		     end;
      495 		else do;				/*     delete ACL entry for user.		*/
      496 		     del_acle.user = user;
      497 		     del_acle.code = 0;
      498 		     call msf_manager_$acl_delete (Pmsf_fcb, addr(del_acle), 1, code);
      499 		     if code ^= 0 then;
      500 		     else node.Smode = node.Sprev_mode;
      501 		     end;
      502 		call msf_manager_$close (Pmsf_fcb);
      503 		revert cleanup;
      504 		end;
      505 	     else if node.T = Tmsf_comp then
      506 		go to ARCH_ACL_UNSET;		/* unset MSF acl for MSF components.		*/
      507 	     if code = 0 then
      508 		if unset_depth > 0 then
      509 		     call unset ((node.Pparent), unset_depth, code);
      510 	     end;
      511 	return;
      512 
      513 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      514 
  1     1 /*  START OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* N__a_m_e:  lib_node_.incl.pl1							*/
  1     6 	/*									*/
  1     7 	/*      This include segment defines the structures which form the tree of status nodes	*/
  1     8 	/* created by lib_get_tree_.  Each node of the tree is associated with a directory	*/
  1     9 	/* entry or an archive component.  The node lists the attributes of that entry, which is	*/
  1    10 	/* called the node target.							*/
  1    11 	/*									*/
  1    12 	/* S__t_a_t_u_s									*/
  1    13 	/*									*/
  1    14 	/* 0) Created:  May, 1973 by G. C. Dixon					*/
  1    15 	/* 1) Modified: Aug, 1973 by G. C. Dixon - standardize descriptor format.		*/
  1    16 	/* 2) Modified: Oct, 1973 by G. C. Dixon - add object_info_ descriptor.		*/
  1    17 	/* 3) Modified: Apr, 1975 by G. C. Dixon - add ACL and IACL descriptors.		*/
  1    18 	/* 4) Modified: Oct, 1975 by G. C. Dixon - additional status info added.		*/
  1    19 	/*									*/
  1    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    21 
  1    22 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    23 	/*									*/
  1    24 	/*	The structure of each node whose target is a link is shown below.	The	*/
  1    25 	/* structure of nodes for other types of targets is shown on the next page.  Note that	*/
  1    26 	/* both types of nodes are the same length.					*/
  1    27 	/*									*/
  1    28 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    29 
  1    30      dcl  1 link_node		based (Pnode),	/* node of a status tree.			*/
  1    31 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  1    32 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  1    33 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  1    34 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  1    35 						/*             (= node.Svalid & Srequirements)	*/
  1    36 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  1    37 	  2 switches		unaligned,
  1    38 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  1    39 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  1    40 						/* 	     entry before lib_access_mode_$set.	*/
  1    41 	    3 pad			bit(22),
  1    42 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  1    43 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  1    44 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  1    45 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  1    46 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  1    47 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  1    48 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  1    49 						/*	     in this directory;  if off, records*/
  1    50 						/*	     charged against 1st superior	*/
  1    51 						/*	     directory with switch on.	*/
  1    52 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  1    53 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  1    54 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  1    55 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  1    56 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  1    57 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  1    58 
  1    59 						/* From here on, link_nodes differ from nodes	*/
  1    60 						/*  for other types of node targets.		*/
  1    61 	  2 link_target		char(168) varying;	/* attribute: target pathname of the link.	*/
  1    62 
  1    63 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    64 	/*									*/
  1    65 	/*	The structure of nodes for other types of node targets is shown below.	*/
  1    66 	/*									*/
  1    67 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    68 
  1    69      dcl  1 node			based (Pnode),	/* node of a status tree.			*/
  1    70 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  1    71 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  1    72 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  1    73 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  1    74 						/*             (= node.Svalid & Srequirements)	*/
  1    75 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  1    76 	  2 switches		unaligned,
  1    77 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  1    78 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  1    79 						/* 	     entry before lib_access_mode_$set.	*/
  1    80 	    3 pad			bit(22),
  1    81 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  1    82 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  1    83 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  1    84 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  1    85 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  1    86 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  1    87 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  1    88 						/*	     in this directory;  if off, records*/
  1    89 						/*	     charged against 1st superior	*/
  1    90 						/*	     directory with switch on.	*/
  1    91 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  1    92 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  1    93 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  1    94 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  1    95 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  1    96 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  1    97 
  1    98 						/* From here on, other nodes differ from	*/
  1    99 						/*  link_nodes.				*/
  1   100 	  2 dtm			bit(36),		/* attribute: date-time node target modified.	*/
  1   101 	  2 dtu			bit(36),		/* attribute: date-time node target last used.	*/
  1   102 	  2 rb (3)		fixed bin(3),	/* attribute: ring brackets.			*/
  1   103 	  2 pad1 (1)		fixed bin,
  1   104 	  2 access_class		bit(72) aligned,	/* attribute: access class assoc. with entry.	*/
  1   105 	  2 records_used		fixed bin(35),	/* attribute: storage used, in records.		*/
  1   106 	  2 current_length		fixed bin(35),	/* attribute: length, in records.		*/
  1   107 	  2 max_length		fixed bin(35),	/* attribute: maximum length.			*/
  1   108 	  2 msf_indicator		fixed bin(35),	/* attribute: msf indicator.			*/
  1   109 	  2 bit_count		fixed bin(35),	/* attribute: bit count.			*/
  1   110 	  2 bit_count_author	char(32) varying,	/* attribute: bit count/msf indicator author.	*/
  1   111 	  2 offset		fixed bin(35),	/* attribute: offset, in words, of an archive	*/
  1   112 						/*             component from the base of archive.*/
  1   113 	  2 entry_bound		fixed bin(35),	/* attribute: entry limit for calls to a gate.	*/
  1   114 	  2 segment,				/* group:  segment quota information for a dir.	*/
  1   115 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  1   116 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  1   117 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  1   118 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  1   119 						/*	     updated.			*/
  1   120 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  1   121 						/*	     directories with Sterminal_account	*/
  1   122 						/*	     on.				*/
  1   123 	  2 directory,				/* group:  directory quota information for a dir.	*/
  1   124 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  1   125 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  1   126 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  1   127 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  1   128 						/*	     updated.			*/
  1   129 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  1   130 						/*	     directories with Sterminal_account	*/
  1   131 						/*	     on.				*/
  1   132 	  2 pvid			bit(36),		/* attribute: physical volume id.		*/
  1   133 	  2 lvid			bit(36),		/* attribute: logical volume id.		*/
  1   134 	  2 pad2 (5)		fixed bin,
  1   135 	Pnode			ptr;		/* ptr to:    a tree node.			*/
  1   136 
  1   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   138 	/*									*/
  1   139 	/*      The descriptors attached to each node of the tree describe the variable-sized	*/
  1   140 	/* attributes of the directory entry or archive component associated with the node.	*/
  1   141 	/* Each descriptor must begin with a header shown in structure D below.  The following	*/
  1   142 	/* descriptors are the only ones that have been defined.				*/
  1   143 	/*									*/
  1   144 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   145 
  1   146      dcl	1 D			based (PD),	/* Header common to all descriptors.		*/
  1   147 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   148 	  2 version		fixed bin(17) unal,	/* descriptor: version number.		*/
  1   149 	  2 T			fixed bin,	/* descriptor: type of descriptor.		*/
  1   150 	  2 Pnext		ptr,			/* ptr to:    next descriptor attached to node.	*/
  1   151 	PD			ptr;		/* ptr to:    a descriptor.			*/
  1   152 
  1   153      dcl	1 Dacl			based (PDacl),	/* a segment ACL descriptor.			*/
  1   154 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   155 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   156 	  2 T			fixed bin,	/* descriptor: type = Tacl.			*/
  1   157 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   158 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   159 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   160 	  2 acls (Nacls refer (Dacl.N)),		/* attribute: ACL entries.			*/
  1   161 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   162 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   163 	    3 zero_pad		bit(36),
  1   164 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   165 	Nacls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  1   166 	PDacl			ptr,		/* ptr to:    a segment ACL descriptor.		*/
  1   167 	Vacl_1			fixed bin int static options(constant) init (1),
  1   168 						/* version:   version of ACL descriptor.	*/
  1   169 	Tacl			fixed bin int static options(constant) init (7);
  1   170 						/* attribute: type of a segment ACL descriptor.	*/
  1   171 
  1   172      dcl	1 Ddir_acl		based (PDdir_acl),	/* a directory ACL descriptor.		*/
  1   173 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   174 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   175 	  2 T			fixed bin,	/* descriptor: type = Tdir_acl.		*/
  1   176 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   177 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   178 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   179 	  2 acls (Ndir_acls refer (Ddir_acl.N)),	/* attribute: ACL entries.			*/
  1   180 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   181 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   182 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   183 	Ndir_acls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  1   184 	PDdir_acl			ptr,		/* ptr to:    a directory ACL descriptor.	*/
  1   185 	Vdir_acl_1		fixed bin int static options(constant) init (1),
  1   186 						/* version:   version of directory ACL descriptor.*/
  1   187 	Tdir_acl			fixed bin int static options(constant) init (8);
  1   188 						/* attribute: type of a directory ACL descriptor.	*/
  1   189 
  1   190      dcl	1 Ddir_iacl		based (PDdir_iacl),	/* a directory IACL descriptor.		*/
  1   191 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   192 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   193 	  2 T			fixed bin,	/* descriptor: type = Tdir_iacl.		*/
  1   194 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   195 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   196 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   197 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  1   198 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  1   199 	  2 acls (Ndir_iacls refer (Ddir_iacl.N)),	/* attribute: ACL entries.			*/
  1   200 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   201 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   202 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   203 	Ndir_iacls		fixed bin,	/* temporary: number of entries in IACL descriptor*/
  1   204 	PDdir_iacl		ptr,		/* ptr to:    a directory IACL descriptor.	*/
  1   205 	Vdir_iacl_1		fixed bin int static options(constant) init (1),
  1   206 						/* version:   version of dir IACL descriptor.	*/
  1   207 	Tdir_iacl			fixed bin int static options(constant) init (9);
  1   208 
  1   209      dcl	1 Diacl			based (PDiacl),	/* a segment IACL descriptor.			*/
  1   210 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   211 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   212 	  2 T			fixed bin,	/* descriptor: type = Tiacl.			*/
  1   213 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   214 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   215 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   216 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  1   217 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  1   218 	  2 acls (Niacls refer (Diacl.N)),		/* attribute: ACL entries.			*/
  1   219 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   220 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   221 	    3 zero_pad		bit(36),
  1   222 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   223 	Niacls			fixed bin,	/* temporary: number of entries in IACL descriptor*/
  1   224 	PDiacl			ptr,		/* ptr to:    a segment IACL descriptor.	*/
  1   225 	Viacl_1			fixed bin int static options(constant) init (1),
  1   226 						/* version:   version of segment IACL descriptor.	*/
  1   227 	Tiacl			fixed bin int static options(constant) init (10);
  1   228 						/* attribute: type of a segment IACL descriptor.	*/
  1   229 
  1   230      dcl	1 Dnames			based (PDnames),	/* name attribute descriptor.			*/
  1   231 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   232 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   233 	  2 T			fixed bin,	/* descriptor: type = Tnames.			*/
  1   234 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   235 	  2 N			fixed bin,	/* attribute: number of names.		*/
  1   236 	  2 names (Nnames refer (Dnames.N))
  1   237 				char(32),		/* attribute: names.			*/
  1   238 	Nnames			fixed bin,	/* temporary: number of names in name descriptor.	*/
  1   239 	PDnames			ptr,		/* ptr to:    a name descriptor.		*/
  1   240 	Vnames_1			fixed bin int static options(constant) init (1),
  1   241 						/* version:   version of names descriptor.	*/
  1   242 	Tnames			fixed bin int static options(constant) init (1);
  1   243 						/* attribute: type of a name descriptor.	*/
  1   244 
  1   245      dcl	1 Dnodes			based (PDnodes),	/* descriptor for array of immediately-inferior	*/
  1   246 						/* nodes.					*/
  1   247 	  2 header,
  1   248 	    3 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   249 	    3 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   250 	    3 T			fixed bin,	/* descriptor: type = Tnodes.			*/
  1   251 	    3 Pnext		ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   252 	    3 C			fixed bin(35),	/* attribute: error code from filling array.	*/
  1   253 	    3 N			fixed bin,	/* attribute: number of nodes in node array.	*/
  1   254 	  2 nodes (Nnodes refer (Dnodes.N))		/* attribute: node array			*/
  1   255 				like node,
  1   256 	Nnodes			fixed bin,	/* temporary: number of nodes in node array.	*/
  1   257 	PDnodes			ptr,		/* ptr to:    a node array descriptor.		*/
  1   258 	Vnodes_1			fixed bin int static options(constant) init (1),
  1   259 						/* version:   version of nodes descriptor.	*/
  1   260 	Tnodes			fixed bin int static options(constant) init (2);
  1   261 						/* attribute: type of a node descriptor.	*/
  1   262 
  1   263      dcl	1 Dobj			based (PDobj),	/* an object_info_ descriptor.		*/
  1   264 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   265 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   266 	  2 T			fixed bin,	/* descriptor: type = Tobj.			*/
  1   267 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   268 	  2 info,
  1   269 	    3 Otext		fixed bin(35),	/* attribute: offset of text.			*/
  1   270 	    3 Odefinitions		fixed bin(35),	/* attribute: offset of definitions.		*/
  1   271 	    3 Olink		fixed bin(35),	/* attribute: offset of linkage section.	*/
  1   272 	    3 Ostatic		fixed bin(35),	/* attribute: offset of static section.		*/
  1   273 	    3 Osymbols		fixed bin(35),	/* attribute: offset of symbol section.		*/
  1   274 	    3 Obreaks		fixed bin(35),	/* attribute: offset of break map.		*/
  1   275 	    3 Ltext		fixed bin(35),	/* attribute: length of text, in words.		*/
  1   276 	    3 Ldefinitions		fixed bin(35),	/* attribute: length of definitions, in words.	*/
  1   277 	    3 Llink		fixed bin(35),	/* attribute: length of linkage section, in words.*/
  1   278 	    3 Lstatic		fixed bin(35),	/* attribute: length of static section, in words.	*/
  1   279 	    3 Lsymbols		fixed bin(35),	/* attribute: length of symbol section, in words.	*/
  1   280 	    3 Lbreaks		fixed bin(35),	/* attribute: length of break map, in words.	*/
  1   281 	    3 format		aligned,
  1   282 	      4 old_format		bit(1) unal,	/* attribute: segment is in old format.		*/
  1   283 	      4 bound		bit(1) unal,	/* attribute: a bound segment.		*/
  1   284 	      4 relocatable		bit(1) unal,	/* attribute: object is relocatable.		*/
  1   285 	      4 procedure		bit(1) unal,	/* attribute: executable procedure.		*/
  1   286 	      4 standard		bit(1) unal,	/* attribute: standard object segment.		*/
  1   287 	      4 gate		bit(1) unal,	/* attribute: gate procedure.			*/
  1   288 	      4 separate_static	bit(1) unal,	/* attribute: proc has separate static section.	*/
  1   289 	      4 links_in_text	bit(1) unal,	/* attribute: proc has links in text section.	*/
  1   290 	      4 pad		bit(28) unal,
  1   291 	    3 entry_bound		fixed bin(35),	/* attribute: entry point bound for a gate.	*/
  1   292 	    3 Otext_links		fixed bin(35),	/* attribute: offset of first link in text section*/
  1   293 	    3 compiler		char(8),		/* attribute: compiler of this object segment.	*/
  1   294 	    3 compile_time		fixed bin(71),	/* attribute: date/time of compilation.		*/
  1   295 	    3 userid		char(32),		/* attribute: id of user who compiled segment.	*/
  1   296 	    3 cversion,				/* attribite: compiler version string.		*/
  1   297 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  1   298 	      4 L			fixed bin(17) unal,	/*	    length			*/
  1   299 	    3 comment,				/* attribute: compiler-generated comment.	*/
  1   300 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  1   301 	      4 L			fixed bin(17) unal,	/*	    length			*/
  1   302 	    3 Osource		fixed bin(35),	/* attribute: offset of source map.		*/
  1   303 	  2 cversion		char(64) varying,	/* attribute: compiler version number      	*/
  1   304 	  2 comment		char(64) varying,	/* attribute: compiler's comment info	   	*/
  1   305 	PDobj			ptr,		/* ptr to:    an object_info_ descriptor.	*/
  1   306 	Vobj_1			fixed bin int static options(constant) init (1),
  1   307 						/* version:   version of object_info_ descriptor.	*/
  1   308 	Tobj			fixed bin int static options(constant) init (3);
  1   309 						/* attribute: type of a node descriptor.	*/
  1   310 
  1   311      dcl	1 Dsearch_proc		based (PDsearch_proc),
  1   312 						/* library root search_proc attribute descriptor.	*/
  1   313 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   314 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   315 	  2 T			fixed bin,	/* descriptor: type = Tsearch_proc.		*/
  1   316 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   317 	  2 search_proc		char(65) varying,	/* attribute: name of library search procedure.	*/
  1   318 	PDsearch_proc		ptr,		/* ptr to:    a search_proc info descriptor.	*/
  1   319 	Vsearch_proc_1		fixed bin int static options(constant) init (1),
  1   320 						/* version:   version of search_proc info descrip.*/
  1   321 	Tsearch_proc		fixed bin int static options(constant) init (5);
  1   322 						/* attribute: type of a search_proc descriptor.	*/
  1   323 
  1   324      dcl	1 Duser			based (PDuser),	/* user attribute descriptor.			*/
  1   325 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   326 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   327 	  2 T			fixed bin,	/* descriptor: type = Tuser.			*/
  1   328 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   329 	  2 label			char(18),		/* attribute: label to be used for this field in	*/
  1   330 						/*            output.			*/
  1   331 	  2 L			fixed bin,	/* attribute: length of user info string.	*/
  1   332 	  2 info			char(Luser refer (Duser.L)),
  1   333 						/* attribute: user info string.		*/
  1   334 	Luser			fixed bin,	/* temporary: length of user info string.	*/
  1   335 	PDuser			ptr,		/* ptr to:    a user info descriptor.		*/
  1   336 	Vuser_1			fixed bin int static options(constant) init (1),
  1   337 						/* version:   version of user info descriptor.	*/
  1   338 	Tuser			fixed bin int static options(constant) init (6);
  1   339 						/* attribute: type of a user descriptor.	*/
  1   340 
  2     1 /* START OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 	/*									*/
  2     5 	/* N__a_m_e:  lib_Svalid_req_.incl.pl1						*/
  2     6 	/*									*/
  2     7 	/*      This include segment defines the switches which request/validate the fields	*/
  2     8 	/* in a status node produced by lib_get_tree_.  This segment, lib_Scontrol_.incl.pl1,	*/
  2     9 	/* and lib_args_.incl.pl1 define the complete set of structures required as input to	*/
  2    10 	/* the lib_descriptor_ subroutine.  This subroutine is called by all of the library	*/
  2    11 	/* descriptor commands to obtain information about entries in a library.		*/
  2    12 	/*									*/
  2    13 	/*      If a switch is on, then the corresponding information in the node is valid, or 	*/
  2    14 	/* is requested for output.							*/
  2    15 	/*									*/
  2    16 	/* S__t_a_t_u_s									*/
  2    17 	/*									*/
  2    18 	/* 0) Created on:   April 8, 1975  by  G. C. Dixon				*/
  2    19 	/*									*/
  2    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    21 
  2    22 
  2    23      dcl	1 Svalid_req		aligned based,
  2    24 	  2 primary_name		bit(1) unal,	/* switch: output includes primary name	   	*/
  2    25 	  2 matching_names		bit(1) unal,	/* switch: output includes matching names  	*/
  2    26 	  2 names			bit(1) unal,	/* switch: output includes all names	   	*/
  2    27 
  2    28 	  2 pathname		bit(1) unal,	/* switch: output include pathname of node target	*/
  2    29 	  2 kids			bit(1) unal,	/* switch: children nodes (inferior) exist	*/
  2    30 	  2 kids_error		bit(1) unal,	/* switch: error occurred obtaining kid's info	*/
  2    31 
  2    32 	  2 type			bit(1) unal,	/* switch: type 			   	*/
  2    33 	  2 mode			bit(1) unal,	/* switch: user's access mode to node target	*/
  2    34 	  2 safety		bit(1) unal,	/* switch: safety switch setting		*/
  2    35 
  2    36 	  2 aim			bit(1) unal,	/* switch: Access Isolation Mechanism switches	*/
  2    37 	  2 copy			bit(1) unal,	/* switch: copy-on-write switch setting		*/
  2    38 	  2 unique_id		bit(1) unal,	/* switch: unique identifier		   	*/
  2    39 
  2    40 	  2 author		bit(1) unal,	/* switch: author of node target		*/
  2    41 	  2 dtem			bit(1) unal,	/* switch: date attributes modified	   	*/
  2    42 	  2 dtd			bit(1) unal,	/* switch: date dumped		   	*/
  2    43 
  2    44 	  2 link_target		bit(1) unal,	/* switch: target pathname of link node		*/
  2    45 	  2 dtm			bit(1) unal,	/* switch: date modified		   	*/
  2    46 	  2 dtu			bit(1) unal,	/* switch: date used		   	*/
  2    47 
  2    48 	  2 rb			bit(1) unal,	/* switch: ring brackets		   	*/
  2    49 	  2 access_class		bit(1) unal,	/* switch: AIM access class		   	*/
  2    50 	  2 records_used		bit(1) unal,	/* switch: records used		   	*/
  2    51 
  2    52 	  2 current_length		bit(1) unal,	/* switch: current length		   	*/
  2    53 	  2 max_length		bit(1) unal,	/* switch: maximum length			*/
  2    54 	  2 msf_indicator		bit(1) unal,	/* switch: count of MSF components.		*/
  2    55 
  2    56 	  2 bit_count		bit(1) unal,	/* switch: bit count		   	*/
  2    57 	  2 bit_count_author	bit(1) unal,	/* switch: bit count author.			*/
  2    58 	  2 offset		bit(1) unal,	/* switch: offset from segment base	   	*/
  2    59 
  2    60 	  2 entry_bound		bit(1) unal,	/* switch: call limit for gate node		*/
  2    61 	  2 lvid			bit(1) unal,	/* switch: logical volume id	   		*/
  2    62 	  2 pvid			bit(1) unal,	/* switch: physical volume id			*/
  2    63 
  2    64 	  2 quota			bit(1) unal,	/* switch: directory quota information		*/
  2    65 	  2 acl			bit(1) unal,	/* switch: ACL			   	*/
  2    66 	  2 iacl			bit(1) unal,	/* switch: initial ACLs		   	*/
  2    67 
  2    68 	  2 dtc			bit(1) unal,	/* switch: date-time compiled      		*/
  2    69 	  2 compiler_name		bit(1) unal,	/* switch: name of compiler			*/
  2    70 	  2 compiler_version	bit(1) unal,	/* switch: compiler version number         	*/
  2    71 
  2    72 	  2 compiler_options	bit(1) unal,	/* switch: compiler options info	   	*/
  2    73 	  2 object_info		bit(1) unal,	/* switch: other object segment info       	*/
  2    74 	  2 not_ascii		bit(1) unal,	/* switch: contents is not printable       	*/
  2    75 
  2    76 	  2 user			bit(1) unal,	/* switch: user-defined node information	*/
  2    77 	  2 root_search_proc	bit(1) unal,	/* switch: root search procedure info.		*/
  2    78 	  2 prev_mode		bit(1) unal,	/* switch: user's previous acces mode set.	*/
  2    79 	  2 pad			bit(26) unal,
  2    80 
  2    81 	  2 delete		bit(1) unal,	/* switch: on (for lcln) if node to be deleted.	*/
  2    82 
  2    83 	  2 cross_ref		bit(1) unal,	/* switch: cross-reference all names       	*/
  2    84 	  2 level			bit(1) unal,	/* switch: output status tree level number	*/
  2    85 	  2 new_line		bit(1) unal;	/* switch: output begins with newline char	*/
  2    86 
  2    87 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    88 	/*									*/
  2    89 	/*      The following declarations define a series of bit strings to be overlaid by 	*/
  2    90 	/* structures which are exactly like Svalid_req above, except for their level 1 name.	*/
  2    91 	/* These structures are used throughout the library descriptor commands and subroutines.	*/
  2    92 	/*									*/
  2    93 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    94 
  2    95 
  2    96      dcl	1 S			aligned based (addr(Srequirements)) like Svalid_req,
  2    97 	Srequirements		bit(72) aligned;
  2    98 
  2    99 /* END OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1   341 
  1   342 
  1   343      dcl	1 Svalid			aligned based(addr(node.Svalid)) like Svalid_req,
  1   344 	1 Sreq			aligned based(addr(node.Sreq)) like Svalid_req;
  1   345 
  3     1 /* START OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* N__a_m_e:  lib_Scontrol_.incl.pl1						*/
  3     6 	/*									*/
  3     7 	/*      This include segment defines the control switches used by library descriptor	*/
  3     8 	/* commands and subroutines.  These switches control the amount of information which is	*/
  3     9 	/* attached to each node of the tree by lib_get_tree_.  This segment, lib_args_.incl.pl1,	*/
  3    10 	/* and lib_Svalid_req_.incl.pl1 define the complete set of structures required as input	*/
  3    11 	/* to the lib_descriptor_ subroutine.						*/
  3    12 	/*									*/
  3    13 	/* S__t_a_t_u_s									*/
  3    14 	/*									*/
  3    15 	/* 0) Created on:  April 8, 1975  by  G. C. Dixon					*/
  3    16 	/* 1) Modified on: October 24, 1983 by Jim Lippard to add page_length, first_match	*/
  3    17 	/*									*/
  3    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    19 
  3    20      dcl	1 Sc			aligned based (addr (Scontrol)),
  3    21 	  2 acl			bit(1) unal,	/* switch: return ACL for library entries.	*/
  3    22 	  2 all_status		bit(1) unal,	/* switch: return extra status information.	*/
  3    23 	  2 chase			bit(1) unal,	/* switch: link entries are to be chased.	*/
  3    24 
  3    25 	  2 check_archive		bit(1) unal,	/* switch: see if contents of entry is archive.	*/
  3    26 	  2 check_ascii		bit(1) unal,	/* switch: see if contents of entry is ascii.	*/
  3    27 	  2 components		bit(1) unal,	/* switch: return info about parent of terminal	*/
  3    28 						/*         nodes of the tree, and about all the	*/
  3    29 						/*	 nodes below the parent.		*/
  3    30 
  3    31 	  2 container		bit(1) unal,	/* switch: return info about parent of terminal	*/
  3    32 						/*         nodes of the tree.			*/
  3    33 	  2 default		bit(1) unal,	/* switch: use default requirement switch settings*/
  3    34 	  2 iacl			bit(1) unal,	/* switch: return initial ACLs for library entries*/
  3    35 
  3    36 	  2 object_info		bit(1) unal,	/* switch: return object info for object segments.*/
  3    37 	  2 quota			bit(1) unal,	/* switch: return quota information.		*/
  3    38 	  2 retain		bit(1) unal,	/* switch: print information about nodes awaiting	*/
  3    39 						/*         deletion.			*/
  3    40 
  3    41 	  2 pad			bit(10) unal,
  3    42 
  3    43 	  2 first_match		bit(1) unal,	/* switch: stop after first match		*/
  3    44 	  2 page_length		bit(1) unal,	/* switch: page length of output		*/
  3    45 
  3    46 	  2 delete		bit(1) unal,	/* switch: delete library entries		*/
  3    47 	  2 descriptor		bit(1) unal,	/* switch: library descriptor			*/
  3    48 	  2 exclude		bit(1) unal,	/* switch: exclusion search names.		*/
  3    49 
  3    50 	  2 footing		bit(1) unal,	/* switch: footing for output pages.		*/
  3    51 	  2 heading		bit(1) unal,	/* switch: heading for 1st output page.		*/
  3    52 	  2 into_path		bit(1) unal,	/* switch: path into which entries are fetched.	*/
  3    53 
  3    54 	  2 library		bit(1) unal,	/* switch: library names			*/
  3    55 	  2 list			bit(1) unal,	/* switch: list library entries		*/
  3    56 	  2 long			bit(1) unal,	/* switch: long output format required.		*/
  3    57 
  3    58 	  2 output_file		bit(1) unal,	/* switch: pathname of output file		*/
  3    59 	  2 search_names		bit(1) unal,	/* switch: search names			*/
  3    60 	  2 time			bit(1) unal,	/* switch: grace time for deletion of entries.	*/
  3    61 	Scontrol			bit(36) aligned;	/* switches: aligned copy of control switches.	*/
  3    62 
  3    63 /* END OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1   346 
  1   347 
  1   348 
  1   349 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   350 	/*									*/
  1   351 	/*      The following entry type attributes have been defined.  Note that the types 	*/
  1   352 	/* for segments, archive components, and msf components all have the characteristic	*/
  1   353 	/* that:		mod (type, 2) = 1;						*/
  1   354 	/*									*/
  1   355 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   356 
  1   357 
  1   358      dcl (Tlink			init (0),
  1   359 	Tsegment			init (1),
  1   360 	Tdirectory		init (2),
  1   361 	Tmsf			init (3),
  1   362 	Tmsf_comp			init (4),
  1   363 	Tarchive			init (5),
  1   364 	Tarchive_comp		init (6)) fixed bin(17) int static options(constant);
  1   365 
  1   366 
  1   367 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   368 	/*									*/
  1   369 	/*      The following character string arrays identify each entry type attribute by name.	*/
  1   370 	/* Both brief and long string arrays are provided.				*/
  1   371 	/*									*/
  1   372 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   373 
  1   374      dcl	node_type (0:6)		char(32) varying aligned int static options(constant) init (
  1   375 				"link",
  1   376 				"segment",
  1   377 				"directory",
  1   378 				"multisegment file",
  1   379 				"multi-segment file component",
  1   380 				"archive",
  1   381 				"archive component"),
  1   382 	brief_node_type (0:6)	char(12) varying aligned int static options(constant) init (
  1   383 				"link",
  1   384 				"segment",
  1   385 				"directory",
  1   386 				"msf",
  1   387 				"msf comp",
  1   388 				"archive",
  1   389 				"arch comp");
  1   390 
  1   391 
  1   392 /*  END OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      515 
      516 
      517 	end lib_access_mode_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/15/84  0749.8  lib_access_mode_.pl1              >special_ldd>on>6588>lib_access_mode_.pl1
515          1    08/16/79  1752.9  lib_node_.incl.pl1                >ldd>include>lib_node_.incl.pl1
1-341        2    02/28/77  1409.3  lib_Svalid_req_.incl.pl1          >ldd>include>lib_Svalid_req_.incl.pl1
1-346        3    02/15/84  0754.6  lib_Scontrol_.incl.pl1            >special_ldd>on>6588>lib_Scontrol_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Bmode                           000100 automatic       bit(5)                   unaligned dcl 95 set ref 197* 199 200 203 205 207
Dnodes                                 based           structure                level 1 unaligned dcl 1-245
False                                  constant        bit(1)                   initial dcl 140 ref 246 253 429 451 491
N                         5            based           fixed bin(17,0)          level 3 dcl 1-245 ref 173 262 404
Nmode                           000101 automatic       fixed bin(5,0)           dcl 95 set ref 195* 197
PD                        2            based           pointer                  level 2 dcl 1-69 ref 171 260 402
PDnodes                         000236 automatic       pointer                  dcl 1-245 set ref 171* 171* 172 173 175 175 177 260*
                                                                                  260* 261 262 264 264 266 267 268 269 402* 402* 403
                                                                                  404 407 407 408 409 410 411
Pmsf_fcb                        000102 automatic       pointer                  dcl 95 set ref 344* 346 346* 349* 351* 353* 367*
                                                                                  368* 476* 478 478* 481* 488* 498* 502*
Pnext                     2            based           pointer                  level 3 dcl 1-245 ref 172 261 403
Pnode                                  parameter       pointer                  dcl 1-69 set ref 154 168 169 170 171 177 178 184 185
                                                                                  187 187 188 191 191 194* 198 199 200 202 203 204
                                                                                  205 207 210 220 238 240 242* 246 250 258 259 260
                                                                                  266 267 268 269 275 276 278 278 279 279 280 280
                                                                                  281 281 284 284 286 290 291 294* 295 302 302 308
                                                                                  309 313 317 323 323 329 330 337 339 356 356 362
                                                                                  363 379 397 398 399 402 408 409 410 411 417* 418
                                                                                  419 421 424 429 430 430 436 440 440 443 444 446
                                                                                  451 452 452 460 460 463 463 467 468 469 469 470
                                                                                  470 471 471 472 472 475 483 485 491 492 492 500
                                                                                  500 505 507
Pparent                                based           pointer                  level 2 dcl 1-69 set ref 185* 187 276 278 279 280
                                                                                  281 290 291 468 469 470 471 472 507
Smode                    11            based           bit(3)                   level 3 packed unaligned dcl 1-69 set ref 177* 177
                                                                                  187* 187 199* 200* 203* 204* 205* 207* 246 266*
                                                                                  266 278* 278 302 323 356 408* 408 430* 440* 452*
                                                                                  460* 469* 469 492* 500*
Sprev_mode               11(03)        based           bit(3)                   level 3 packed unaligned dcl 1-69 set ref 267* 267
                                                                                  279* 279 302* 308* 323* 329* 356* 362* 409* 409
                                                                                  421 430 440 446 452 460 470* 470 485 492 500
Sunset_required                 000104 automatic       bit(1)                   dcl 95 set ref 246* 248* 250 253* 256
Svalid                    4            based           bit(72)                  level 2 in structure "node" dcl 1-69 in procedure
                                                                                  "lib_access_mode_" set ref 168 170 178 188 210 240
                                                                                  250 259 268 268 269 269 280 280 281 281 309 330
                                                                                  363 398 399 410 410 411 411 419 429 444 451 471
                                                                                  471 472 472 483 491
Svalid                                 based           structure                level 1 dcl 1-343 in procedure "lib_access_mode_"
Svalid_req                             based           structure                level 1 dcl 2-23
T                         1            based           fixed bin(17,0)          level 3 in structure "Dnodes" dcl 1-245 in procedure
                                                                                  "lib_access_mode_" ref 171 260 402
T                        10            based           fixed bin(35,0)          level 2 in structure "node" dcl 1-69 in procedure
                                                                                  "lib_access_mode_" ref 169 184 191 198 202 258 275
                                                                                  284 286 295 317 337 339 397 418 443 463 467 475
                                                                                  505
Tarchive                               constant        fixed bin(17,0)          initial dcl 1-358 ref 191 284 337 463
Tarchive_comp                          constant        fixed bin(17,0)          initial dcl 1-358 ref 184 275 467
Tdirectory                             constant        fixed bin(17,0)          initial dcl 1-358 ref 198 317 443
Tlink                                  constant        fixed bin(17,0)          initial dcl 1-358 ref 169 258 397
Tmsf                                   constant        fixed bin(17,0)          initial dcl 1-358 ref 202 339 475
Tmsf_comp                              constant        fixed bin(17,0)          initial dcl 1-358 ref 286 505
Tnodes                                 constant        fixed bin(17,0)          initial dcl 1-245 ref 171 260 402
True                                   constant        bit(1)                   initial dcl 140 ref 178 188 210 248 309 330 363
Tsegment                               constant        fixed bin(17,0)          initial dcl 1-358 ref 295 418
acle                            000105 automatic       structure                level 1 dcl 95 set ref 300 300 313 313 315 315 351
                                                                                  351 367 367 424 424 426 426 488 488
addr                                                   builtin function         dcl 115 ref 168 170 175 175 177 178 188 210 240 250
                                                                                  259 264 264 266 267 268 268 268 269 269 269 280
                                                                                  280 281 281 300 300 309 313 313 315 315 321 321
                                                                                  330 334 334 351 351 363 367 367 398 399 407 407
                                                                                  408 409 410 410 410 411 411 411 419 424 424 426
                                                                                  426 429 436 436 438 438 444 448 448 451 458 458
                                                                                  471 471 472 472 483 488 488 491 498 498
bit                                                    builtin function         dcl 115 ref 197
cleanup                         000230 stack reference condition                dcl 115 ref 345 369 477 503
code                     12     000105 automatic       fixed bin(35,0)          level 2 in structure "acle" dcl 95 in procedure
                                                                                  "lib_access_mode_" set ref 299* 302 312* 343* 356
                                                                                  366* 423* 487*
code                                   parameter       fixed bin(35,0)          dcl 90 in procedure "lib_access_mode_" set ref 154
                                                                                  167* 173* 175* 176 182* 185* 186 195* 196 220 234*
                                                                                  238 242* 243 252* 262* 264* 265 273* 276* 277 291*
                                                                                  292 300* 301 313* 315* 321* 322 334* 349* 350 351*
                                                                                  352 367* 379 391* 399* 404* 407* 424* 426* 427
                                                                                  436* 438* 439 448* 449 458* 459 468* 481* 482 488*
                                                                                  489 498* 499 507 507*
code                     10     000120 automatic       fixed bin(35,0)          level 2 in structure "del_acle" dcl 95 in procedure
                                                                                  "lib_access_mode_" set ref 435* 457* 497*
code                     11     000204 automatic       fixed bin(35,0)          level 2 in structure "dir_acle" dcl 95 in procedure
                                                                                  "lib_access_mode_" set ref 320* 323 333* 447*
del_acle                        000120 automatic       structure                level 1 dcl 95 set ref 436 436 438 438 458 458 498
                                                                                  498
dir                             000131 automatic       varying char(168)        dcl 95 set ref 194* 195 294* 300 313 315 321 334 349
                                                                                  417* 424 426 436 438 448 458 481
dir_acle                        000204 automatic       structure                level 1 dcl 95 set ref 321 321 334 334 448 448
ent                             000216 automatic       varying char(32)         dcl 95 set ref 194* 195 294* 300 313 315 321 334 349
                                                                                  417* 424 426 436 438 448 458 481
error_table_$improper_data_format
                                000064 external static fixed bin(35,0)          dcl 140 ref 399 404
error_table_$link               000066 external static fixed bin(35,0)          dcl 140 ref 173 182 262 273
error_table_$out_of_sequence    000070 external static fixed bin(35,0)          dcl 140 ref 252
error_table_$user_not_found     000072 external static fixed bin(35,0)          dcl 140 ref 302 323 356
get_group_id_                   000022 constant        entry                    external dcl 120 ref 164 231 388
get_ring_                       000024 constant        entry                    external dcl 120 ref 165 232 389
hcs_$add_acl_entries            000026 constant        entry                    external dcl 120 ref 315 426
hcs_$add_dir_acl_entries        000030 constant        entry                    external dcl 120 ref 334 448
hcs_$delete_acl_entries         000032 constant        entry                    external dcl 120 ref 438
hcs_$delete_dir_acl_entries     000034 constant        entry                    external dcl 120 ref 458
hcs_$get_user_effmode           000042 constant        entry                    external dcl 120 ref 195
hcs_$list_acl                   000044 constant        entry                    external dcl 120 ref 300
hcs_$list_dir_acl               000046 constant        entry                    external dcl 120 ref 321
header                                 based           structure                level 2 unaligned dcl 1-245
installation_tools_$add_acl_entries
                                000036 constant        entry                    external dcl 120 ref 313 424
installation_tools_$delete_acl_entries
                                000040 constant        entry                    external dcl 120 ref 436
kids                      0(04)        based           bit(1)                   level 2 packed unaligned dcl 1-343 ref 170 259 399
lib_node_path_                  000050 constant        entry                    external dcl 120 ref 194 294 417
mode                     10     000105 automatic       bit(36)                  level 2 in structure "acle" dcl 95 in procedure
                                                                                  "lib_access_mode_" set ref 297* 308 311* 341* 362
                                                                                  365* 421* 485*
mode                     10     000204 automatic       bit(36)                  level 2 in structure "dir_acle" dcl 95 in procedure
                                                                                  "lib_access_mode_" set ref 319* 329 332* 446*
mode                      0(07)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 1-343 in procedure "lib_access_mode_" set ref
                                                                                  168 178* 188* 210* 240 268* 268 280* 280 398 410*
                                                                                  410 471* 471
msf_manager_$acl_add            000052 constant        entry                    external dcl 120 ref 367 488
msf_manager_$acl_delete         000054 constant        entry                    external dcl 120 ref 498
msf_manager_$acl_list           000056 constant        entry                    external dcl 120 ref 351
msf_manager_$close              000060 constant        entry                    external dcl 120 ref 346 353 368 478 502
msf_manager_$open               000062 constant        entry                    external dcl 120 ref 349 481
new_mode                               parameter       bit(36)                  dcl 90 set ref 220 238 246 246 264* 276* 311 332 365
node                                   based           structure                level 1 unaligned dcl 1-69
nodes                     6            based           structure                array level 2 unaligned dcl 1-245 set ref 175 175
                                                                                  177 264 264 266 267 268 269 407 407 408 409 410
                                                                                  411
null                                                   builtin function         dcl 115 ref 290 300 300 300 300 321 321 321 321 344
                                                                                  346 351 351 351 351 476 478
offset                   55            based           fixed bin(35,0)          level 2 dcl 1-69 ref 191 284 463
pad                      11     000105 automatic       bit(36)                  level 2 dcl 95 set ref 298* 342* 422* 486*
prev_mode                 1(05)        based           bit(1)                   level 2 packed unaligned dcl 1-343 set ref 250 269*
                                                                                  269 281* 281 309* 330* 363* 411* 411 419 429* 444
                                                                                  451* 472* 472 483 491*
rb                       31            based           fixed bin(3,0)           array level 2 dcl 1-69 ref 313 424 436
ring                            000010 internal static fixed bin(17,0)          initial dcl 140 set ref 165 165* 195* 232 232* 313
                                                                                  389 389* 424 436
substr                                                 builtin function         dcl 115 set ref 199* 199 200* 200 203* 203 204* 205*
                                                                                  205 207* 207
switches                 11            based           structure                level 2 packed unaligned dcl 1-69
unset_depth                            parameter       fixed bin(17,0)          dcl 90 set ref 220 235* 238 257* 257 264* 276* 291*
                                                                                  379 393 395* 395 407* 468* 507 507*
user                            000120 automatic       char(32)                 level 2 in structure "del_acle" dcl 95 in procedure
                                                                                  "lib_access_mode_" set ref 434* 456* 496*
user                            000105 automatic       char(32)                 level 2 in structure "acle" dcl 95 in procedure
                                                                                  "lib_access_mode_" set ref 296* 340* 420* 484*
user                            000011 internal static char(32)                 initial unaligned dcl 140 in procedure
                                                                                  "lib_access_mode_" set ref 164 164* 195* 231 231*
                                                                                  296 318 340 388 388* 420 434 445 456 484 496
user                            000204 automatic       char(32)                 level 2 in structure "dir_acle" dcl 95 in procedure
                                                                                  "lib_access_mode_" set ref 318* 445*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
D                                      based           structure                level 1 unaligned dcl 1-146
Dacl                                   based           structure                level 1 unaligned dcl 1-153
Ddir_acl                               based           structure                level 1 unaligned dcl 1-172
Ddir_iacl                              based           structure                level 1 unaligned dcl 1-190
Diacl                                  based           structure                level 1 unaligned dcl 1-209
Dnames                                 based           structure                level 1 unaligned dcl 1-230
Dobj                                   based           structure                level 1 unaligned dcl 1-263
Dsearch_proc                           based           structure                level 1 unaligned dcl 1-311
Duser                                  based           structure                level 1 unaligned dcl 1-324
Luser                                  automatic       fixed bin(17,0)          dcl 1-324
Nacls                                  automatic       fixed bin(17,0)          dcl 1-153
Ndir_acls                              automatic       fixed bin(17,0)          dcl 1-172
Ndir_iacls                             automatic       fixed bin(17,0)          dcl 1-190
Niacls                                 automatic       fixed bin(17,0)          dcl 1-209
Nnames                                 automatic       fixed bin(17,0)          dcl 1-230
Nnodes                                 automatic       fixed bin(17,0)          dcl 1-245
PD                                     automatic       pointer                  dcl 1-146
PDacl                                  automatic       pointer                  dcl 1-153
PDdir_acl                              automatic       pointer                  dcl 1-172
PDdir_iacl                             automatic       pointer                  dcl 1-190
PDiacl                                 automatic       pointer                  dcl 1-209
PDnames                                automatic       pointer                  dcl 1-230
PDobj                                  automatic       pointer                  dcl 1-263
PDsearch_proc                          automatic       pointer                  dcl 1-311
PDuser                                 automatic       pointer                  dcl 1-324
S                                      based           structure                level 1 dcl 2-96
Sc                                     based           structure                level 1 dcl 3-20
Scontrol                               automatic       bit(36)                  dcl 3-20
Sreq                                   based           structure                level 1 dcl 1-343
Srequirements                          automatic       bit(72)                  dcl 2-96
Tacl                                   internal static fixed bin(17,0)          initial dcl 1-153
Tdir_acl                               internal static fixed bin(17,0)          initial dcl 1-172
Tdir_iacl                              internal static fixed bin(17,0)          initial dcl 1-190
Tiacl                                  internal static fixed bin(17,0)          initial dcl 1-209
Tnames                                 internal static fixed bin(17,0)          initial dcl 1-230
Tobj                                   internal static fixed bin(17,0)          initial dcl 1-263
Tsearch_proc                           internal static fixed bin(17,0)          initial dcl 1-311
Tuser                                  internal static fixed bin(17,0)          initial dcl 1-324
Vacl_1                                 internal static fixed bin(17,0)          initial dcl 1-153
Vdir_acl_1                             internal static fixed bin(17,0)          initial dcl 1-172
Vdir_iacl_1                            internal static fixed bin(17,0)          initial dcl 1-190
Viacl_1                                internal static fixed bin(17,0)          initial dcl 1-209
Vnames_1                               internal static fixed bin(17,0)          initial dcl 1-230
Vnodes_1                               internal static fixed bin(17,0)          initial dcl 1-245
Vobj_1                                 internal static fixed bin(17,0)          initial dcl 1-263
Vsearch_proc_1                         internal static fixed bin(17,0)          initial dcl 1-311
Vuser_1                                internal static fixed bin(17,0)          initial dcl 1-324
brief_node_type                        internal static varying char(12)         initial array dcl 1-374
link_node                              based           structure                level 1 unaligned dcl 1-30
node_type                              internal static varying char(32)         initial array dcl 1-374

NAMES DECLARED BY EXPLICIT CONTEXT.
ARCH_ACL_UNSET                  002710 constant        label                    dcl 468 ref 463 505
ARCH_COMP                       000162 constant        label                    dcl 185 ref 191
ARCH_COMP_ACL                   000626 constant        label                    dcl 276 ref 284 286
SEG_ACL                         000756 constant        label                    dcl 296 ref 337
SEG_ACL_UNSET                   002117 constant        label                    dcl 419 ref 466
get                             000027 constant        entry                    external dcl 154 ref 175 185 242
lib_access_mode_                000015 constant        entry                    external dcl 88
set                             000372 constant        entry                    external dcl 220
set_recurse                     000441 constant        entry                    external dcl 238 ref 264 276 291
unset                           001726 constant        entry                    external dcl 379 ref 407 468 507

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3552        3646    3240        3562
Length      4164    3240        74         301     312          12

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lib_access_mode_                    252 external procedure  is an external procedure.  
on unit on line 345                  68 on unit               
on unit on line 477                  68 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 ring                        lib_access_mode_
000011 user                        lib_access_mode_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lib_access_mode_         000100 Bmode                       lib_access_mode_
                         000101 Nmode                       lib_access_mode_
                         000102 Pmsf_fcb                    lib_access_mode_
                         000104 Sunset_required             lib_access_mode_
                         000105 acle                        lib_access_mode_
                         000120 del_acle                    lib_access_mode_
                         000131 dir                         lib_access_mode_
                         000204 dir_acle                    lib_access_mode_
                         000216 ent                         lib_access_mode_
                         000236 PDnodes                     lib_access_mode_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_in         call_ext_out_desc   call_ext_out        return              enable
shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_group_id_                 get_ring_                     hcs_$add_acl_entries          hcs_$add_dir_acl_entries
hcs_$delete_acl_entries       hcs_$delete_dir_acl_entries   hcs_$get_user_effmode         hcs_$list_acl
hcs_$list_dir_acl             installation_tools_$add_acl_entries
installation_tools_$delete_acl_entries                      lib_node_path_                msf_manager_$acl_add
msf_manager_$acl_delete       msf_manager_$acl_list         msf_manager_$close            msf_manager_$open

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$improper_data_format                           error_table_$link             error_table_$out_of_sequence
error_table_$user_not_found




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     88 000014       154 000022       164 000037       165 000051       167 000066       168 000067       169 000100
    170 000102       171 000105       172 000114       173 000117       175 000126       176 000140       177 000142
    178 000152       181 000154       182 000155       183 000157       184 000160       185 000162       186 000174
    187 000176       188 000207       190 000211       191 000212       194 000216       195 000230       196 000305
    197 000310       198 000315       199 000323       200 000330       201 000335       202 000336       203 000340
    204 000345       205 000347       206 000354       207 000355       210 000362       213 000364       220 000365
    231 000404       232 000417       234 000434       235 000435       238 000436       240 000453       242 000462
    243 000472       246 000474       248 000506       250 000510       252 000515       253 000520       256 000521
    257 000523       258 000524       259 000526       260 000531       261 000540       262 000543       264 000552
    265 000571       266 000573       267 000603       268 000607       269 000613       272 000617       273 000620
    274 000623       275 000624       276 000626       277 000647       278 000651       279 000662       280 000666
    281 000672       283 000676       284 000677       286 000703       290 000706       291 000712       292 000732
    294 000734       295 000750       296 000756       297 000762       298 000763       299 000764       300 000765
    301 001052       302 001055       308 001072       309 001102       311 001104       312 001106       313 001107
    315 001171       316 001246       317 001250       318 001252       319 001256       320 001257       321 001260
    322 001345       323 001350       329 001365       330 001375       332 001377       333 001401       334 001402
    335 001456       337 001460       339 001462       340 001464       341 001470       342 001471       343 001472
    344 001473       345 001475       346 001511       348 001524       349 001525       350 001572       351 001575
    352 001625       353 001627       354 001636       356 001637       362 001654       363 001664       365 001666
    366 001670       367 001671       368 001711       369 001720       373 001721       379 001722       388 001740
    389 001753       391 001770       393 001771       395 001773       397 001775       398 002002       399 002010
    402 002016       403 002024       404 002027       407 002036       408 002052       409 002062       410 002066
    411 002072       414 002076       417 002077       418 002111       419 002117       420 002125       421 002131
    422 002135       423 002136       424 002137       426 002217       427 002274       429 002300       430 002305
    432 002312       434 002313       435 002317       436 002320       438 002400       439 002455       440 002461
    442 002471       443 002472       444 002474       445 002477       446 002503       447 002507       448 002510
    449 002564       451 002570       452 002575       454 002602       456 002603       457 002607       458 002610
    459 002664       460 002670       462 002700       463 002701       466 002705       467 002706       468 002710
    469 002727       470 002740       471 002744       472 002750       473 002754       475 002755       476 002757
    477 002761       478 002775       480 003010       481 003011       482 003056       483 003061       484 003067
    485 003073       486 003077       487 003100       488 003101       489 003121       491 003124       492 003131
    494 003136       496 003137       497 003143       498 003144       499 003164       500 003167       502 003177
    503 003206       504 003207       505 003210       507 003212       511 003235


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
