	COMPILATION LISTING OF SEGMENT db_fnp_call_trace_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1614.9 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* DB_FNP_CALL_TRACE_ - A procedure to decode a subroutine calling chain in a FNP dump */
       12 /* Written Spetember 1978 by Larry Johnson */
       13 
       14 /* This module contains a great deal of imbedded knowledge about how the fnp procedure generate calls.
       15*   It uses a set of heuristics to search backwards from a given starting point to find
       16*   the object code generated by a 'subr' macro. */
       17 
       18 /* The following is a detailed description of the subr sequence:
       19*
       20*   .	name	ind	0		entry point, and return address word
       21*
       22*   .	*	If 'inh' is used, the following is generated
       23*
       24*   .		sti	namsi-*		save current indicators
       25*   .		inh			and mask interrupts
       26*
       27*   .	*	Next, individual registers are saved.
       28*   .	*	0-6 register saves may follow here selected from (a,q,x1,x2,x3,i)
       29*
       30*   .		sta	namsa-*
       31*   .		stx1	namsx1-*
       32*   .		stx3	namsx3-*
       33*
       34*   .	*	Now branch to body of subroutine.
       35*
       36*   .		tra	start-*
       37*
       38*   .	*	For the conveniece of the return macro, the subroutine exit
       39*   .	*	sequence is generated here. The return macro transfers
       40*   .	*	to this point.
       41*
       42*   .	*	First, reload all saved registers
       43*
       44*   .		lda	namsa-*
       45*   .		ldx1	namsx1-*
       46*   .		ldx3	namsx3-*
       47*   .		ldi	namsi-*
       48*
       49*   .	*	And return.
       50*
       51*   .		tra	name-*,*
       52*
       53*   .	*	Someday, a subroutine name may be stored here, in bcd. This is not
       54*   .	*	done now, but would appear as follows:
       55*
       56*   .		bci	6/name
       57*
       58*   .	*	Next follows save area for all saved registers
       59*
       60*   .	namsi	bss	1
       61*   .	namsa	bss	1
       62*   .	namsx1	bss	1
       63*   .	namsx3	bss	1
       64*
       65*   .	*	Next comes the body of the subroutine
       66*
       67*   .	start	null
       68**/
       69 
       70 db_fnp_call_trace_: proc (arg_corep, arg_fnp, arg_cmd_infop, arg_expr_infop);
       71 
       72 /* Parameters */
       73 
       74 dcl  arg_corep ptr;
       75 dcl  arg_fnp fixed bin;
       76 dcl  arg_cmd_infop ptr;
       77 dcl  arg_expr_infop ptr;
       78 
       79 /* Automatic */
       80 
       81 dcl  i fixed bin;
       82 dcl  code fixed bin (35);
       83 dcl  corep ptr;
       84 dcl  fnp fixed bin;
       85 dcl  debug_sw bit (1);				/* Set if -debug used */
       86 dcl  long_sw bit (1);				/* Set if -long used */
       87 dcl  trace_addr fixed bin;
       88 
       89 dcl  mem_buf (0:511) bit (18) unal;			/* To hold memory data */
       90 dcl  buf_org fixed bin;				/* Starting address of stuff in mem_buf */
       91 dcl  n_words_in_buf fixed bin;			/* Count of good words */
       92 
       93 /* Static */
       94 
       95 dcl  constants_setup bit (1) int static init ("0"b);	/* Set when static initialized */
       96 dcl  ld_opcodes (6) bit (18) unal int static;		/* Opcodes of load instruction */
       97 dcl  st_opcodes (6) bit (18) unal int static;		/* Opcodes of store instructions */
       98 dcl  tra bit (18) int static;				/* Opcode of tra instruction */
       99 dcl  inh bit (18) int static;				/* Opcode of inhibit instruction */
      100 
      101 /* Constants */
      102 
      103 dcl  name char (18) int static options (constant) init ("db_fnp_call_trace_");
      104 dcl  reg_names (6) char (2) int static options (constant) init ("i", "a", "q", "x1", "x2", "x3");
      105 dcl  opmask bit (18) int static options (constant) init ("077000"b3);
      106 
      107 /* External */
      108 
      109 dcl  ioa_ entry options (variable);
      110 dcl  com_err_ entry options (variable);
      111 dcl  db_fnp_eval_ entry (ptr, fixed bin, char (*), ptr, char (*), fixed bin, fixed bin (35));
      112 dcl  db_fnp_reader_$get_operand entry (ptr);
      113 dcl  db_fnp_edit_inst_$assemble entry (ptr, fixed bin, char (*), ptr, bit (18), fixed bin (35));
      114 dcl  sub_err_ entry options (variable);
      115 dcl  db_fnp_memory_$fetch entry (ptr, fixed bin, fixed bin, fixed bin, ptr, fixed bin (35));
      116 dcl  db_fnp_util_$edit_module_addr_paren entry (ptr, fixed bin, fixed bin, char (*) var, fixed bin (35));
      117 
      118 dcl (addr, bin, dim, hbound, max, min, null, string, unspec, substr) builtin;
      119 
      120 /* Copy arguments */
      121 
      122 	fnp = arg_fnp;
      123 	corep = arg_corep;
      124 	expr_infop = arg_expr_infop;
      125 	cmd_infop = arg_cmd_infop;
      126 	if ^constants_setup then call setup_constants;
      127 
      128 /* First argument is address to trace from */
      129 
      130 	call db_fnp_reader_$get_operand (cmd_infop);
      131 	if cmd_info.error then go to error_return;
      132 	if cmd_info.endline then do;
      133 	     call ioa_ ("Address missing.");
      134 	     go to error_return;
      135 	end;
      136 	call db_fnp_eval_ (corep, fnp, operand, expr_infop, "", trace_addr, code);
      137 	if code ^= 0 then go to error_return;
      138 
      139 /* Remaining arguments are control arguments */
      140 
      141 	debug_sw, long_sw = "0"b;
      142 	call db_fnp_reader_$get_operand (cmd_infop);
      143 	if cmd_info.error then go to error_return;
      144 	do while (^cmd_info.endline);
      145 	     if operand = "-long" | operand = "-lg" then long_sw = "1"b;
      146 	     else if operand = "-debug" | operand = "-db" then debug_sw = "1"b;
      147 	     else do;
      148 		call ioa_ ("Unrecognized operand: ^a", operand);
      149 		go to error_return;
      150 	     end;
      151 	     call db_fnp_reader_$get_operand (cmd_infop);
      152 	     if cmd_info.error then go to error_return;
      153 	end;
      154 
      155 /* Now loop backwards decoding subroutine levels */
      156 
      157 	call trace_level;
      158 	do while (trace_addr ^= 0);
      159 	     call trace_level;
      160 	end;
      161 
      162 	return;
      163 
      164 error_return:
      165 	cmd_info.flush = "1"b;
      166 	return;
      167 
      168 
      169 /* Procedure that does the  real work of finding a subr */
      170 
      171 trace_level: proc;
      172 
      173 dcl  i fixed bin;
      174 dcl  w bit (18);
      175 dcl  tra_addr fixed bin;				/* Address if the  second tra instruction */
      176 dcl  ca fixed bin;					/* Current address during scan */
      177 dcl  fb8 fixed bin (8) unal;				/* For bit->fixed conversions */
      178 dcl  st_found (6) bit (1) unal;			/* Mask saying which store instructions found */
      179 dcl  ld_found (6) bit (1) unal;			/* Mask saying which load instructions found */
      180 dcl  ld_target (6) fixed bin;				/* Targets of the ld instructuons */
      181 dcl  max_target fixed bin;
      182 dcl  n_loads fixed bin;
      183 dcl  target fixed bin;
      184 dcl  msg char (64) var;
      185 
      186 dcl 1 mi unal,					/* Machine instruction */
      187     2 i bit (1),					/* Indirect bit */
      188     2 x bit (2),					/* Index register */
      189     2 c bit (6),					/* Opcode */
      190     2 d bit (9);					/* Displacement */
      191 
      192 /* Start with address given */
      193 
      194 	     ca = trace_addr + 1;
      195 
      196 /* Look backwards for a tra instruction.  It must have indirection, no index register,
      197*   and a negative displacement. This the tra that returns from the subr. */
      198 
      199 tra_scan:	     ca = ca - 1;
      200 	     w = get_word (ca);			/* Read word */
      201 	     if (w & opmask) ^= tra then go to tra_scan;
      202 	     string (mi) = w;
      203 	     if ^mi.i then go to tra_scan;		/* No indirection */
      204 	     if mi.x then go to tra_scan;		/* Index present */
      205 	     if ^substr (mi.d, 1, 1) then go to tra_scan; /* Displacement not negative */
      206 
      207 	     tra_addr = ca;				/* Save address of tra */
      208 	     if debug_sw then call ioa_ ("Fould likely tra at ^a: ^.3b", ed (ca), w);
      209 
      210 /* The tra should be preceeded by 0-6 ldxx instructions. All should have no indirection,
      211*   no index register, and an effective address greater than the tra */
      212 
      213 	     string (st_found) = "0"b;
      214 	     string (ld_found) = "0"b;
      215 	     n_loads = 0;
      216 	     max_target = tra_addr;
      217 
      218 ldxx_scan:     ca = ca - 1;
      219 	     w = get_word (ca);
      220 	     do i = 1 to hbound (ld_opcodes, 1);	/* See if some kind of load */
      221 		if (w & opmask) = ld_opcodes (i) then do; /* Got it */
      222 		     string (mi) = w;
      223 		     if mi.i | mi.x then do;		/* These both should be zero */
      224 ldxx_scan_fail:		if debug_sw then call ioa_ ("ldxx scan failed at ^a: ^.3b", ed (ca), w);
      225 			ca = tra_addr;		/* Back to tra */
      226 			go to tra_scan;		/* And go look for new likely tra */
      227 		     end;
      228 		     if ld_found (i) then go to ldxx_scan_fail; /* Already had one of these */
      229 		     unspec (fb8) = mi.d;		/* Get  signed displacement */
      230 		     target = ca + fb8;		/* Effective address */
      231 		     if target <= tra_addr then go to ldxx_scan_fail;
      232 		     n_loads = n_loads + 1;		/* This is good load */
      233 		     ld_found (i) = "1"b;
      234 		     ld_target (i) = target;
      235 		     max_target = max (max_target, target);
      236 		     go to ldxx_scan;
      237 		end;
      238 	     end;
      239 
      240 /* Found a non-ldx opcode. This should be the entry sequence tra to max_target */
      241 
      242 	     if (w & opmask) ^= tra then go to ldxx_scan_fail; /* Not a tra */
      243 	     string (mi) = w;			/* To check other fields */
      244 	     if mi.i | mi.x then go to ldxx_scan_fail;
      245 	     unspec (fb8) = mi.d;
      246 	     target = ca + fb8;			/* Target of tra */
      247 	     if n_loads > 0 then			/* If there were loads, .. */
      248 		if target ^= (max_target + 1) then go to ldxx_scan_fail; /* Should point immiditely after save areas */
      249 		else;				/* It does, ok */
      250 	     else if target ^= max_target + 1 then	/* No loads, target should be here */
      251 		if target ^= max_target + 3 then	/* Or here, to allow for two word name someday */
      252 		     go to ldxx_scan_fail;		/* No good target */
      253 
      254 /* The middle tra is good. Need to check preceeding stxx instructions */
      255 
      256 stxx_scan:     ca = ca - 1;
      257 	     w = get_word (ca);
      258 	     if string (st_found) = string (ld_found) then go to stxx_scan_done; /* All loads have been matched by stores */
      259 	     do i = 1 to hbound (st_opcodes, 1);	/* Look up in store list */
      260 		if (w & opmask) = st_opcodes (i) then do; /* A match */
      261 		     string (mi) = w;		/* For further analysis */
      262 		     if mi.i | mi.x then do;		/* Can't have these */
      263 stxx_scan_fail:		if debug_sw then call ioa_ ("stxx scan failed at ^a: ^.3b", ed (ca), w);
      264 			ca = tra_addr;		/* Back to tra scanning */
      265 			go to tra_scan;
      266 		     end;
      267 		     unspec (fb8) = mi.d;
      268 		     target = ca + fb8;		/* Target of stxx */
      269 		     if ^ld_found (i) then go to stxx_scan_fail; /* No corresponding ldxx instruction */
      270 		     if ld_target (i) ^= target then go to stxx_scan_fail; /* Target must be same */
      271 		     if st_found (i) then go to stxx_scan_fail; /* Duplicate */
      272 		     st_found (i) = "1"b;
      273 		     go to stxx_scan;
      274 		end;
      275 	     end;
      276 
      277 /* All stxx instructions have been scanned. The only possible discrepency left between loads and stores,
      278*   is a missing sti, which will occur if 'inh' is used in subr */
      279 
      280 	     if string (st_found) ^= string (ld_found) then do; /* There is discrepency */
      281 		if (string (st_found) | "100000"b) ^= string (ld_found) then go to stxx_scan_fail; /* Not just missing sti */
      282 		if w ^= inh then go to stxx_scan_fail;	/* Expect inh instruction here */
      283 		ca = ca - 1;
      284 		w = get_word (ca);
      285 		if (w & opmask) ^= st_opcodes (1) then	/* This better be missing sti */
      286 		     go to stxx_scan_fail;		/* No, too bad */
      287 		ca = ca - 1;
      288 		w = get_word (ca);			/* Read retrun address word */
      289 	     end;
      290 
      291 stxx_scan_done:
      292 
      293 /* Scan is all done. current word is return address */
      294 
      295 	     i = trace_addr;			/* Hold starting addr */
      296 	     trace_addr = 0;
      297 	     if w = "000000"b3 then msg = "never called";
      298 	     else if w = "000001"b3 then do;
      299 		msg = "called form master dispatcher";
      300 		ca = ca + 3;			/* Space over dummy subr */
      301 	     end;
      302 	     else if w = "000002"b3 then do;
      303 		msg = "called from secondary dispatcher";
      304 		ca = ca + 3;
      305 	     end;
      306 	     else do;
      307 		trace_addr = bin (w);		/* For pervious level */
      308 		msg = "called from " || ed (trace_addr);
      309 	     end;
      310 
      311 	     call ioa_ ("^a in subr at ^a, ^a", ed (i), ed (ca), msg);
      312 
      313 	     if long_sw then do;
      314 		do i = 1 to hbound (reg_names, 1);
      315 		     if ld_found (i) then call ioa_ ("^-^4a^.3b", reg_names (i), get_word (ld_target (i)));
      316 		end;
      317 	     end;
      318 
      319 	     return;
      320 
      321 	end trace_level;
      322 
      323 /* Procedure to manage internal memory buffer. If the word requested is in the buffer, it is returned.
      324*   Otherwise, a new buffer is read with the current address near the end. This allows a small amount of forward scanning
      325*   and a large amount of backeards scanning before more memory must be read */
      326 
      327 get_word:	proc (ad) returns (bit (18));
      328 
      329 dcl  ad fixed bin;
      330 
      331 	     if n_words_in_buf = 0 then do;		/* Empty, must read */
      332 read_new_buf:	buf_org = (max (0, ad - (dim (mem_buf, 1) - 32)));
      333 		if debug_sw then call ioa_ ("Reading memory locations ^o-^o", buf_org, buf_org + hbound (mem_buf, 1));
      334 		call db_fnp_memory_$fetch (corep, fnp, buf_org, dim (mem_buf, 1), addr (mem_buf), code);
      335 		if code ^= 0 then do;
      336 		     call com_err_ (code, name, "Unable to read ^o-^o", buf_org, buf_org + hbound (mem_buf, 1));
      337 		     go to error_return;
      338 		end;
      339 		n_words_in_buf = dim (mem_buf, 1);
      340 	     end;
      341 
      342 	     if ad < buf_org | ad > buf_org + n_words_in_buf - 1 then /* Not in current window */
      343 		go to read_new_buf;
      344 
      345 	     return (mem_buf (ad - buf_org));
      346 
      347 	end get_word;
      348 
      349 /* Prccodure to return edited module address */
      350 
      351 ed:	proc (ad) returns (char (32) var);
      352 
      353 dcl  ad fixed bin;
      354 dcl  temp char (32) var;
      355 
      356 	     call db_fnp_util_$edit_module_addr_paren (corep, fnp, ad, temp, code);
      357 	     if code ^= 0 then do;
      358 		call com_err_ (code, name, "Unable to edit ^o.", ad);
      359 		go to error_return;
      360 	     end;
      361 
      362 	     return (temp);
      363 
      364 	end ed;
      365 
      366 /* Compute some baseic needed for life of process */
      367 
      368 setup_constants: proc;
      369 
      370 dcl  i fixed bin;
      371 
      372 	     inh = opc ("inh");			/* Inhibit instruction */
      373 	     tra = opc ("tra");			/* Tra instruction */
      374 	     do i = 1 to hbound (reg_names, 1);
      375 		st_opcodes (i) = opc ("st" || reg_names (i));
      376 		ld_opcodes (i) = opc ("ld" || reg_names (i));
      377 	     end;
      378 	     constants_setup = "1"b;
      379 	     return;
      380 
      381 	end setup_constants;
      382 
      383 opc:	proc (opname) returns (bit (18));
      384 
      385 dcl  opname char (*);
      386 dcl  inst bit (18);
      387 
      388 	     call db_fnp_edit_inst_$assemble (corep, fnp, opname, expr_infop, inst, code); /* "assemble" into instruction */
      389 	     if code ^= 0 then call sub_err_ (code, name, "s", null, (0), "Unable to get opcode for ""^a"".", opname);
      390 	     return (inst);
      391 
      392 	end opc;
      393 
  1     1 /* Begin include file ..... debug_fnp_data.incl.pl1 */
  1     2 
  1     3 /* Describes various structures used by the debug_fnp command */
  1     4 
  1     5 /* Written February 1977 by Larry Johnson */
  1     6 
  1     7 /* Structures describing a symbol table used by the debug_fnp command,
  1     8*   to find values for common FNP symbols. */
  1     9 
  1    10 dcl  db_fnp_symbols_$db_fnp_symbols_ ext;
  1    11 
  1    12 dcl  symbol_tablep ptr;
  1    13 
  1    14 dcl 1 symbol_table aligned based (symbol_tablep),
  1    15     2 cnt fixed bin,				/* Number of entries */
  1    16     2 maxcnt fixed bin,				/* Max count */
  1    17     2 entry (symbol_table.cnt) unal,
  1    18       3 one_symbol like sym unal;
  1    19 
  1    20 dcl  symp ptr;					/* Pointer to one symbol */
  1    21 
  1    22 dcl 1 sym unal based (symp),
  1    23     2 name char (6),
  1    24     2 value fixed bin (17),
  1    25     2 len fixed bin (17),				/* Number of words */
  1    26     2 reloc fixed bin (17),
  1    27     2 type fixed bin (17),
  1    28     2 flag_mem char (6),				/* If non blank, name of word in which this is a flag */
  1    29     2 explain bit (18),				/* Offset to explanation for symbol */
  1    30     2 pad bit (18);
  1    31 
  1    32 dcl  exptextp ptr;
  1    33 
  1    34 dcl 1 exptext aligned based (exptextp),			/* Symbol explanation entry */
  1    35     2 len fixed bin (8) unal,
  1    36     2 data char (exptext.len) unal;
  1    37 
  1    38 /* Values for sym.reloc, which is relocation required to find the symbol */
  1    39 
  1    40 dcl (reloc_abs init (0),				/* Value is absolute */
  1    41      reloc_tib init (1),				/* Value is relative to current tib addr */
  1    42      reloc_hwcm init (2),				/* Value is relative to current hwcm */
  1    43      reloc_sfcm init (3),				/* Value is relative to software comm region */
  1    44      reloc_meters init (4))				/* Value is relative to tib meters */
  1    45      int static options (constant);
  1    46 
  1    47 /* Values for sym.type, which is the mode to be used in displaying symbol */
  1    48 
  1    49 dcl (type_oct init (0),				/* Octal, default for most symbols */
  1    50      type_char init (1),				/* Ascii characters */
  1    51      type_addr init (2),				/* Address to be converted to mod|offset */
  1    52      type_clock init (3),				/* Multics clock value */
  1    53      type_inst init (4),				/* Machine instruction */
  1    54      type_op init (5),				/* Interpreter opblock format */
  1    55      type_dec init (6),				/* Decimal */
  1    56      type_bit init (7),				/* In bits */
  1    57      type_ebcdic init (8))				/* 8-bit ebcdic characters */
  1    58      int static options (constant);
  1    59 
  1    60 dcl  long_type_names (0:8) char (12) int static options (constant) init (
  1    61      "octal", "character", "address", "clock", "instruction", "opblock", "decimal", "bit", "ebcdic");
  1    62 dcl  short_type_names (0:8) char (4) int static options (constant) init (
  1    63      "oct", "ch", "addr", "ck", "inst", "op", "dec", "bit", "ebc");
  1    64 
  1    65 
  1    66 /* Structure of suplmental data used in evaluating expressions */
  1    67 
  1    68 dcl  expr_infop ptr;
  1    69 
  1    70 dcl 1 expr_info aligned based (expr_infop),
  1    71     2 flags,
  1    72       3 star_known bit (1) unal,			/* Value of "*" is known */
  1    73       3 tib_known bit (1) unal,			/* TIB addresses may be used */
  1    74       3 hwcm_known bit (1) unal,			/* HWCM address may be used */
  1    75       3 sfcm_known bit (1) unal,			/* SFCM address may be used */
  1    76       3 pad bit (32) unal,
  1    77     2 star_addr fixed bin,				/* Value of "*" */
  1    78     2 tib_addr fixed bin,				/* Address of TIB */
  1    79     2 hwcm_addr fixed bin,				/* Address of HWCM */
  1    80     2 sfcm_addr fixed bin,				/* Address of SFCM */
  1    81     2 type fixed bin,				/* Expression type (mode for printing) */
  1    82     2 len fixed bin,				/* Implied length of expression */
  1    83     2 user_tablep ptr;				/* Pointer to a user symbol table */
  1    84 
  1    85 
  1    86 /* Structure of opcode table of machine instructions */
  1    87 
  1    88 dcl  db_fnp_opcodes_$ ext;
  1    89 
  1    90 dcl  optablep ptr;
  1    91 
  1    92 dcl 1 optable aligned based (optablep),
  1    93     2 cnt fixed bin,
  1    94     2 entry (optable.cnt) unal,
  1    95       3 one_op like op;
  1    96 
  1    97 dcl  opp ptr;
  1    98 
  1    99 dcl 1 op unal based (opp),
  1   100     2 name char (6),				/* The mneumonic */
  1   101     2 code bit (12),				/* The  opcode */
  1   102     2 mask bit (12),				/* Mask that says where the opcode is */
  1   103     2 type fixed bin (11),				/* Type of display required */
  1   104     2 pad bit (18);
  1   105 
  1   106 /* Values for op.type are:
  1   107*   0 - storage reference
  1   108*   1 - non-storage reference (immediate),
  1   109*   2 - non-storage reference (iacxn only),
  1   110*   3 - non-storage reference (shifts),
  1   111*   4 - non-storage reference (no operands) */
  1   112 
  1   113 
  1   114 /* Stuctures used while parsing commands into operands */
  1   115 
  1   116 dcl  cmd_infop ptr;
  1   117 
  1   118 dcl 1 cmd_info aligned based (cmd_infop),
  1   119     2 inbuf char (256),				/* For reading lines */
  1   120     2 opbuf char (256),				/* Used for operand in undoubling quotes */
  1   121     2 commandp ptr,					/* Address of unparsed part of command */
  1   122     2 commandl fixed bin,				/* Length of unparsed part */
  1   123     2 operandp ptr,					/* Address of current operand */
  1   124     2 operandl fixed bin,				/* And its length */
  1   125     2 error bit (1),				/* Set if error parsing operand */
  1   126     2 endline bit (1),				/* Set if no more operands on line */
  1   127     2 opstring bit (1),				/* Set if operand was unquoted string */
  1   128     2 flush bit (1),				/* If set, rest of input line will be ignored */
  1   129     2 envp ptr;					/* Pointer to the debug_fnp environment structure */
  1   130 
  1   131 dcl  command char (cmd_info.commandl) based (cmd_info.commandp);
  1   132 dcl  operand char (cmd_info.operandl) based (cmd_info.operandp);
  1   133 
  1   134 /* The following structure describes the current debug_fnp environment. */
  1   135 /* It specifies whether we are working on a dump, fnp, core image, etc. */
  1   136 
  1   137 dcl  envp ptr;
  1   138 
  1   139 dcl 1 env aligned based (envp),
  1   140     2 corep ptr,					/* Ptr to current dump or core-image. Null means live FNP */
  1   141     2 fnp fixed bin,				/* Current fnp number */
  1   142     2 dump_dir char (168) unal,			/* Directory where dumps are found */
  1   143     2 dir char (168) unal,				/* Directory for current dump or core image */
  1   144     2 ename char (32) unal,				/* Ename for current dump or core image */
  1   145     2 tty_name char (32),				/* Name of current channel */
  1   146     2 segp ptr,					/* Pointer to base of current segment */
  1   147     2 flags unal,
  1   148       3 fnps_configured bit (8),			/* Says which FNP's appear in config deck */
  1   149       3 fnp_sw bit (1),				/* 1 if currently working on fnp */
  1   150       3 image_sw bit (1),				/* 1 if currently working on a core-image */
  1   151       3 dump_sw bit (1),				/* 1 if current working on a dump */
  1   152       3 fdump_sw bit (1),				/* 1 if current dump is a fdump */
  1   153       3 pad bit (24),
  1   154     2 dump_time fixed bin (71);			/* Clock time dump occured */
  1   155 
  1   156 /* Structure of data defining table of interpreter opblock names */
  1   157 
  1   158 dcl  db_fnp_opblocks_$ ext;
  1   159 
  1   160 dcl  opblock_tablep ptr;
  1   161 
  1   162 dcl 1 opblock_table aligned based (opblock_tablep),
  1   163     2 cnt fixed bin,
  1   164     2 name (0:opblock_table.cnt) char (6) unal;
  1   165 
  1   166 /* End include file ..... debug_fnp_data.incl.pl1 */
      394 
      395 
      396      end db_fnp_call_trace_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1501.4  db_fnp_call_trace_.pl1            >dumps>old>recomp>db_fnp_call_trace_.pl1
394          1    06/19/81  2115.0  debug_fnp_data.incl.pl1           >ldd>include>debug_fnp_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ad                                     parameter       fixed bin(17,0)          dcl 353 in procedure "ed" set ref 351 356* 358*
ad                                     parameter       fixed bin(17,0)          dcl 329 in procedure "get_word" ref 327 332 342 342
                                                                                  345
addr                                                   builtin function         dcl 118 ref 334 334
arg_cmd_infop                          parameter       pointer                  dcl 76 ref 70 125
arg_corep                              parameter       pointer                  dcl 74 ref 70 123
arg_expr_infop                         parameter       pointer                  dcl 77 ref 70 124
arg_fnp                                parameter       fixed bin(17,0)          dcl 75 ref 70 122
bin                                                    builtin function         dcl 118 ref 307
buf_org                         000510 automatic       fixed bin(17,0)          dcl 90 set ref 332* 333* 333 334* 336* 336 342 342
                                                                                  345
ca                              000527 automatic       fixed bin(17,0)          dcl 176 set ref 194* 199* 199 200* 207 208* 218* 218
                                                                                  219* 224* 225* 230 246 256* 256 257* 263* 264* 268
                                                                                  283* 283 284* 287* 287 288* 300* 300 304* 304 311*
cmd_info                               based           structure                level 1 dcl 1-118
cmd_infop                       000514 automatic       pointer                  dcl 1-116 set ref 125* 130* 131 132 136 136 136 142*
                                                                                  143 144 145 145 145 145 146 146 146 146 148 148
                                                                                  148 151* 152 164
code                            000100 automatic       fixed bin(35,0)          dcl 82 set ref 136* 137 334* 335 336* 356* 357 358*
                                                                                  388* 389 389*
com_err_                        000024 constant        entry                    external dcl 110 ref 336 358
constants_setup                 000010 internal static bit(1)                   initial unaligned dcl 95 set ref 126 378*
corep                           000102 automatic       pointer                  dcl 83 set ref 123* 136* 334* 356* 388*
d                         0(09) 000565 automatic       bit(9)                   level 2 packed unaligned dcl 186 set ref 205 229 245
                                                                                  267
db_fnp_edit_inst_$assemble      000032 constant        entry                    external dcl 113 ref 388
db_fnp_eval_                    000026 constant        entry                    external dcl 111 ref 136
db_fnp_memory_$fetch            000036 constant        entry                    external dcl 115 ref 334
db_fnp_reader_$get_operand      000030 constant        entry                    external dcl 112 ref 130 142 151
db_fnp_util_$edit_module_addr_paren
                                000040 constant        entry                    external dcl 116 ref 356
debug_sw                        000105 automatic       bit(1)                   unaligned dcl 85 set ref 141* 146* 208 224 263 333
dim                                                    builtin function         dcl 118 ref 332 334 334 339
endline                 210            based           bit(1)                   level 2 dcl 1-118 ref 132 144
error                   207            based           bit(1)                   level 2 dcl 1-118 ref 131 143 152
expr_infop                      000512 automatic       pointer                  dcl 1-68 set ref 124* 136* 388*
fb8                             000530 automatic       fixed bin(8,0)           unaligned dcl 177 set ref 229* 230 245* 246 267* 268
flush                   212            based           bit(1)                   level 2 dcl 1-118 set ref 164*
fnp                             000104 automatic       fixed bin(17,0)          dcl 84 set ref 122* 136* 334* 356* 388*
hbound                                                 builtin function         dcl 118 ref 220 259 314 333 336 374
i                               000565 automatic       bit(1)                   level 2 in structure "mi" packed unaligned dcl 186
                                                                                  in procedure "trace_level" set ref 203 223 244 262
i                               000524 automatic       fixed bin(17,0)          dcl 173 in procedure "trace_level" set ref 220* 221
                                                                                  228 233 234* 259* 260 269 270 271 272* 291* 311*
                                                                                  314* 315 315 315 315*
i                               000622 automatic       fixed bin(17,0)          dcl 370 in procedure "setup_constants" set ref 374*
                                                                                  375 375 376 376*
inh                             000020 internal static bit(18)                  unaligned dcl 99 set ref 282 372*
inst                            000632 automatic       bit(18)                  unaligned dcl 386 set ref 388* 390
ioa_                            000022 constant        entry                    external dcl 109 ref 133 148 208 224 263 311 315 333
ld_found                        000532 automatic       bit(1)                   array unaligned dcl 179 set ref 214* 228 233* 258
                                                                                  269 280 281 315
ld_opcodes                      000011 internal static bit(18)                  array unaligned dcl 96 set ref 220 221 376*
ld_target                       000533 automatic       fixed bin(17,0)          array dcl 180 set ref 234* 270 315* 315*
long_sw                         000106 automatic       bit(1)                   unaligned dcl 86 set ref 141* 145* 313
max                                                    builtin function         dcl 118 ref 235 332
max_target                      000541 automatic       fixed bin(17,0)          dcl 181 set ref 216* 235* 235 247 250 250
mem_buf                         000110 automatic       bit(18)                  array unaligned dcl 89 set ref 332 333 334 334 334
                                                                                  334 336 339 345
mi                              000565 automatic       structure                level 1 packed unaligned dcl 186 set ref 202* 222*
                                                                                  243* 261*
msg                             000544 automatic       varying char(64)         dcl 184 set ref 297* 299* 303* 308* 311*
n_loads                         000542 automatic       fixed bin(17,0)          dcl 182 set ref 215* 232* 232 247
n_words_in_buf                  000511 automatic       fixed bin(17,0)          dcl 91 set ref 331 339* 342
name                            000003 constant        char(18)                 initial unaligned dcl 103 set ref 336* 358* 389*
null                                                   builtin function         dcl 118 ref 389 389
op                                     based           structure                level 1 packed unaligned dcl 1-99
operand                                based           char                     unaligned dcl 1-132 set ref 136* 145 145 146 146
                                                                                  148*
operandl                206            based           fixed bin(17,0)          level 2 dcl 1-118 ref 136 136 145 145 146 146 148
                                                                                  148
operandp                204            based           pointer                  level 2 dcl 1-118 ref 136 145 145 146 146 148
opmask                                 constant        bit(18)                  initial unaligned dcl 105 ref 201 221 242 260 285
opname                                 parameter       char                     unaligned dcl 385 set ref 383 388* 389*
reg_names                       000000 constant        char(2)                  initial array unaligned dcl 104 set ref 314 315* 374
                                                                                  375 376
st_found                        000531 automatic       bit(1)                   array unaligned dcl 178 set ref 213* 258 271 272*
                                                                                  280 281
st_opcodes                      000014 internal static bit(18)                  array unaligned dcl 97 set ref 259 260 285 375*
string                                                 builtin function         dcl 118 set ref 202* 213* 214* 222* 243* 258 258
                                                                                  261* 280 280 281 281
sub_err_                        000034 constant        entry                    external dcl 114 ref 389
substr                                                 builtin function         dcl 118 ref 205
sym                                    based           structure                level 1 packed unaligned dcl 1-22
target                          000543 automatic       fixed bin(17,0)          dcl 183 set ref 230* 231 234 235 246* 247 250 250
                                                                                  268* 270
temp                            000602 automatic       varying char(32)         dcl 354 set ref 356* 362
tra                             000017 internal static bit(18)                  unaligned dcl 98 set ref 201 242 373*
tra_addr                        000526 automatic       fixed bin(17,0)          dcl 175 set ref 207* 216 225 231 264
trace_addr                      000107 automatic       fixed bin(17,0)          dcl 87 set ref 136* 158 194 291 296* 307* 308*
unspec                                                 builtin function         dcl 118 set ref 229* 245* 267*
w                               000525 automatic       bit(18)                  unaligned dcl 174 set ref 200* 201 202 208* 219* 221
                                                                                  222 224* 242 243 257* 260 261 263* 282 284* 285
                                                                                  288* 297 298 302 307
x                         0(01) 000565 automatic       bit(2)                   level 2 packed unaligned dcl 186 set ref 204 223 244
                                                                                  262

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
command                                based           char                     unaligned dcl 1-131
db_fnp_opblocks_$                      external static fixed bin(17,0)          dcl 1-158
db_fnp_opcodes_$                       external static fixed bin(17,0)          dcl 1-88
db_fnp_symbols_$db_fnp_symbols_        external static fixed bin(17,0)          dcl 1-10
env                                    based           structure                level 1 dcl 1-139
envp                                   automatic       pointer                  dcl 1-137
expr_info                              based           structure                level 1 dcl 1-70
exptext                                based           structure                level 1 dcl 1-34
exptextp                               automatic       pointer                  dcl 1-32
i                                      automatic       fixed bin(17,0)          dcl 81
long_type_names                        internal static char(12)                 initial array unaligned dcl 1-60
min                                                    builtin function         dcl 118
opblock_table                          based           structure                level 1 dcl 1-162
opblock_tablep                         automatic       pointer                  dcl 1-160
opp                                    automatic       pointer                  dcl 1-97
optable                                based           structure                level 1 dcl 1-92
optablep                               automatic       pointer                  dcl 1-90
reloc_abs                              internal static fixed bin(17,0)          initial dcl 1-40
reloc_hwcm                             internal static fixed bin(17,0)          initial dcl 1-40
reloc_meters                           internal static fixed bin(17,0)          initial dcl 1-40
reloc_sfcm                             internal static fixed bin(17,0)          initial dcl 1-40
reloc_tib                              internal static fixed bin(17,0)          initial dcl 1-40
short_type_names                       internal static char(4)                  initial array unaligned dcl 1-62
symbol_table                           based           structure                level 1 dcl 1-14
symbol_tablep                          automatic       pointer                  dcl 1-12
symp                                   automatic       pointer                  dcl 1-20
type_addr                              internal static fixed bin(17,0)          initial dcl 1-49
type_bit                               internal static fixed bin(17,0)          initial dcl 1-49
type_char                              internal static fixed bin(17,0)          initial dcl 1-49
type_clock                             internal static fixed bin(17,0)          initial dcl 1-49
type_dec                               internal static fixed bin(17,0)          initial dcl 1-49
type_ebcdic                            internal static fixed bin(17,0)          initial dcl 1-49
type_inst                              internal static fixed bin(17,0)          initial dcl 1-49
type_oct                               internal static fixed bin(17,0)          initial dcl 1-49
type_op                                internal static fixed bin(17,0)          initial dcl 1-49

NAMES DECLARED BY EXPLICIT CONTEXT.
db_fnp_call_trace_              000203 constant        entry                    external dcl 70
ed                              001516 constant        entry                    internal dcl 351 ref 208 224 263 308 311 311
error_return                    000441 constant        label                    dcl 164 ref 131 134 137 143 149 152 337 359
get_word                        001337 constant        entry                    internal dcl 327 ref 200 219 257 284 288 315 315
ldxx_scan                       000541 constant        label                    dcl 218 ref 236
ldxx_scan_fail                  000577 constant        label                    dcl 224 ref 228 231 242 244 247 250
opc                             001755 constant        entry                    internal dcl 383 ref 372 373 375 376
read_new_buf                    001343 constant        label                    dcl 332 set ref 342
setup_constants                 001620 constant        entry                    internal dcl 368 ref 126
stxx_scan                       000735 constant        label                    dcl 256 ref 273
stxx_scan_done                  001130 constant        label                    dcl 291 ref 258
stxx_scan_fail                  001002 constant        label                    dcl 263 ref 269 270 271 281 282 285
tra_scan                        000451 constant        label                    dcl 199 ref 201 203 204 205 226 265
trace_level                     000445 constant        entry                    internal dcl 171 ref 157 159

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2302        2344    2150        2312
Length      2560    2150        42         177     131          12

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
db_fnp_call_trace_                  670 external procedure  is an external procedure.  
trace_level                             internal procedure  shares stack frame of external procedure db_fnp_call_trace_.  
get_word                                internal procedure  shares stack frame of external procedure db_fnp_call_trace_.  
ed                                      internal procedure  shares stack frame of external procedure db_fnp_call_trace_.  
setup_constants                         internal procedure  shares stack frame of external procedure db_fnp_call_trace_.  
opc                                     internal procedure  shares stack frame of external procedure db_fnp_call_trace_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 constants_setup             db_fnp_call_trace_
000011 ld_opcodes                  db_fnp_call_trace_
000014 st_opcodes                  db_fnp_call_trace_
000017 tra                         db_fnp_call_trace_
000020 inh                         db_fnp_call_trace_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
db_fnp_call_trace_       000100 code                        db_fnp_call_trace_
                         000102 corep                       db_fnp_call_trace_
                         000104 fnp                         db_fnp_call_trace_
                         000105 debug_sw                    db_fnp_call_trace_
                         000106 long_sw                     db_fnp_call_trace_
                         000107 trace_addr                  db_fnp_call_trace_
                         000110 mem_buf                     db_fnp_call_trace_
                         000510 buf_org                     db_fnp_call_trace_
                         000511 n_words_in_buf              db_fnp_call_trace_
                         000512 expr_infop                  db_fnp_call_trace_
                         000514 cmd_infop                   db_fnp_call_trace_
                         000524 i                           trace_level
                         000525 w                           trace_level
                         000526 tra_addr                    trace_level
                         000527 ca                          trace_level
                         000530 fb8                         trace_level
                         000531 st_found                    trace_level
                         000532 ld_found                    trace_level
                         000533 ld_target                   trace_level
                         000541 max_target                  trace_level
                         000542 n_loads                     trace_level
                         000543 target                      trace_level
                         000544 msg                         trace_level
                         000565 mi                          trace_level
                         000602 temp                        ed
                         000622 i                           setup_constants
                         000632 inst                        opc

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      db_fnp_edit_inst_$assemble    db_fnp_eval_                  db_fnp_memory_$fetch
db_fnp_reader_$get_operand    db_fnp_util_$edit_module_addr_paren                         ioa_
sub_err_

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     70 000176       122 000210       123 000213       124 000216       125 000221       126 000224       130 000227
    131 000236       132 000241       133 000243       134 000260       136 000261       137 000323       141 000325
    142 000327       143 000336       144 000341       145 000344       146 000361       148 000374       149 000417
    151 000420       152 000427       153 000432       157 000433       158 000434       159 000436       160 000437
    162 000440       164 000441       166 000444       171 000445       194 000446       199 000451       200 000453
    201 000455       202 000466       203 000470       204 000473       205 000476       207 000501       208 000503
    213 000533       214 000535       215 000536       216 000537       218 000541       219 000543       220 000545
    221 000552       222 000565       223 000567       224 000577       225 000627       226 000631       228 000632
    229 000637       230 000642       231 000646       232 000650       233 000651       234 000654       235 000655
    236 000661       238 000662       242 000664       243 000675       244 000677       245 000707       246 000712
    247 000716       249 000724       250 000725       256 000735       257 000737       258 000741       259 000750
    260 000755       261 000770       262 000772       263 001002       264 001032       265 001034       267 001035
    268 001040       269 001044       270 001051       271 001053       272 001057       273 001062       275 001063
    280 001065       281 001074       282 001077       283 001107       284 001111       285 001113       287 001124
    288 001126       291 001130       296 001132       297 001133       298 001144       299 001147       300 001154
    301 001156       302 001157       303 001161       304 001166       305 001170       307 001171       308 001173
    309 001216       311 001217       313 001255       314 001257       315 001264       316 001334       319 001336
    327 001337       331 001341       332 001343       333 001354       334 001404       335 001431       336 001433
    337 001472       339 001473       342 001475       345 001506       351 001516       356 001520       357 001551
    358 001553       359 001607       362 001610       368 001620       372 001621       373 001640       374 001657
    375 001664       376 001716       377 001747       378 001751       379 001754       383 001755       388 001766
    389 002024       390 002101


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
