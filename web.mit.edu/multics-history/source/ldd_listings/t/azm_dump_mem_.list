	COMPILATION LISTING OF SEGMENT azm_dump_mem_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-17_1920.19_Mon_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 azm_dump_mem_:
        7      proc (P_amu_info_ptr, P_address, P_indx, P_segno, P_offset,
        8 	     P_scu, P_abs_w, P_paged, P_code);
        9 
       10 /*
       11*    Modified July 84 by B. Braun to add knowledge of unpaged_page_tables.    
       12*    Modified September 84 by B. Braun to add knowledge of int_unpaged_page_tables. Also, check all sdws whether 
       13*            cme.abs_w is true or not.
       14**/
       15 
       16 /* Parameters */
       17 
       18 dcl  P_amu_info_ptr ptr,
       19      P_address fixed bin (24),
       20      P_indx fixed bin,
       21      P_segno fixed bin,
       22      P_offset fixed bin (18),
       23      P_scu fixed bin,
       24      P_abs_w bit (1),
       25      P_paged bit (1),
       26      P_code fixed bin (35);
       27 
       28 /* Automatic */
       29 
       30 
       31 dcl  add_sdw fixed bin (24),
       32      add_ptw fixed bin (24),
       33      aste_size fixed bin (18),
       34      bd_sdw fixed bin (24),
       35      code fixed bin (35),
       36      contr_ptr ptr,
       37      cme_size fixed bin (18),
       38      dseg_no fixed bin,
       39      found bit(1),
       40      i fixed bin (18),
       41      ignore fixed bin (21),
       42      j fixed bin (18),
       43      k fixed bin,
       44      loop_exit bit (1),
       45      mem_address fixed bin (24),
       46      mem_base fixed bin (24),
       47      mem_config_sw bit (1) init("0"b),
       48      mem_max fixed bin (24),
       49      mem_config bit (1),
       50      offset fixed bin (18),
       51      pds_dstep ptr,
       52      page_no fixed bin (18),
       53      pt_offset fixed bin (18),
       54      pt_size fixed bin (18),
       55      seg_offset fixed bin(18),
       56      save_process_index fixed bin,
       57      seg_name char (32),
       58      seg_no fixed bin,
       59      sst_base fixed bin (24),
       60      sst_segno fixed bin,
       61      str_segno fixed bin,
       62      str_size fixed bin (18),
       63      temp_dstep bit (18),
       64      temp_indx fixed bin,
       65      temp_ptr ptr,
       66      word_no fixed bin;
       67 
       68 /* Structures */
       69 
       70 dcl 1 active_seg_table like aste;
       71 dcl 1 contr_data (0:7) like scs$controller_data;
       72 dcl 1 core_map like cme;
       73 dcl 1 hard_cur like hardcore_cur;
       74 dcl 1 ptw_a (0:255) like ptw;
       75 dcl 1 ptw_ab (0:255) like ptw based;
       76 dcl 1 page_table_word like ptw;
       77 dcl 1 seg_desc like sdw;
       78 dcl 1 seg_trailer like str;
       79 
       80 dcl 1 mem_conf_data (0:7),
       81     2 base fixed bin,
       82     2 data char (32);
       83 dcl 1 temp_conf like mem_conf_data;
       84 
       85 /* External */
       86 
       87 dcl  amu_$definition_ptr		entry (ptr, char (*), char (*), fixed bin (35)) returns (ptr);
       88 dcl  amu_$do_translation		entry (ptr, fixed bin, ptr, fixed bin (18), fixed bin (18), fixed bin (35));
       89 dcl  amu_$do_translation_by_ptr	entry (ptr, ptr, fixed bin (18), ptr, fixed bin (35));
       90 dcl  amu_$do_translation_hunt_ptr	entry (ptr, ptr, ptr, fixed bin(35));
       91 dcl  amu_$fdump_mpt_change_idx	entry (ptr, fixed bin);
       92 dcl  amu_$hardcore_info_set_cur_ptrs	entry (ptr, ptr);
       93 dcl  amu_$return_val_per_process	entry (ptr, fixed bin) returns (bit (1));
       94 dcl  amu_$slt_search_seg_num		entry (ptr, ptr, char (32), fixed bin, fixed bin (35));
       95 dcl (ioa_, ioa_$rsnnl)		entry () options (variable);
       96 
       97 dcl  amu_et_$free_core		fixed bin (35) ext static;
       98 dcl  amu_et_$non_existant_mem		fixed bin(35) ext static;
       99 dcl  amu_et_$proc_not_dumped		fixed bin (35) ext static;
      100 
      101 dcl  (addr, addrel, baseno, baseptr, 
      102       divide, fixed, hbound, mod,
      103       null, pointer, rel, 
      104       substr, size, unspec)		builtin;
      105 
      106 
      107 /* azm_dump_mem_ entry */
      108 
      109 /* This entry translate the absolute address to a virtual address by looking at all sdws.
      110*
      111*    P_amu_info_ptr             amu_info pointer (input),
      112*    P_address		 absolute memory address (input),
      113*    P_indx		 process index (output),
      114*    P_segno		 segno number of P_address (output),
      115*    P_offset		 segno offset (output),   
      116*    P_scu			 system controller unit (output), 
      117*    P_abs_w		 "1"b if wired segment (output),
      118*    P_paged		 "1"b if segment is paged (output),
      119*    P_code		 error code (output).
      120*
      121**/
      122 
      123     go to DUMP;
      124 
      125 
      126 azm_dump_mem_$mem_config: entry (P_amu_info_ptr, P_code);
      127 
      128 /*  Prints the memory configuration */
      129 
      130     mem_config_sw = "1"b;
      131     amu_info_ptr = P_amu_info_ptr;
      132     mem_address = 0;
      133     page_no = 0;
      134     word_no = 0;
      135     go to CONFIG;
      136 
      137 
      138 DUMP:	
      139     amu_info_ptr = P_amu_info_ptr;
      140     mem_address = P_address;
      141     P_abs_w = "0"b;
      142     P_paged = "1"b;
      143     page_no = divide (mem_address, 1024, 21);
      144     word_no = mod (mem_address, 1024);
      145 
      146 CONFIG:	
      147 
      148     code = 0;
      149     mem_config = "0"b;
      150     contr_ptr = addr (contr_data);
      151     temp_ptr = amu_$definition_ptr (amu_info_ptr, "scs", "controller_data", code);
      152     if code ^= 0 then do;
      153        P_code = code;
      154        return;
      155        end;
      156 
      157     call amu_$do_translation_by_ptr (amu_info_ptr, temp_ptr, size (contr_data), contr_ptr, code);
      158     if code ^= 0 then do;
      159        P_code = code;
      160        return;
      161        end;
      162 
      163     if mem_config_sw then go to MEM_CONF;
      164     do i = 0 to 7 while (^mem_config);
      165        if page_no >= contr_data (i).base then
      166           if page_no < (contr_data (i).base + contr_data (i).size) then
      167 	   if contr_data (i).info.online then
      168 		mem_config = "1"b;
      169        end;
      170 
      171     if ^(mem_config) then do;
      172        P_code = amu_et_$non_existant_mem;
      173        return;
      174        end;
      175 
      176     if mem_config_sw then do;
      177 MEM_CONF:
      178        call ioa_ ("Memory Configuration:");
      179        j = 0;
      180        do i = 0 to 7;
      181 	if contr_data (i).online  then do;
      182 	   mem_base = contr_data (i).base * 1024;
      183 	   mem_max = ((contr_data (i).size * 1024) -1) + mem_base;
      184 	   call ioa_$rsnnl ("^5xMem ^a ^8o to ^8o", mem_conf_data (j).data, ignore,
      185 		substr ("ABCDEFGH", i + 1, 1), mem_base, mem_max);
      186 	   mem_conf_data (j).base = contr_data (i).base;
      187 	   j = j + 1;
      188 	   end;
      189           end;
      190 	j = j - 1;
      191 	do k = 0 to j - 1;
      192 	   do i = k + 1 to j;
      193 	      if mem_conf_data (i).base < mem_conf_data (k).base then do;
      194 	         temp_conf = mem_conf_data (k);
      195 	         mem_conf_data (k) = mem_conf_data (i);
      196 	         mem_conf_data (i) = temp_conf;
      197 	         end;
      198 	      end;
      199 	   end;
      200 	   do i = 0 to j;
      201 	      call ioa_ ("^a", mem_conf_data (i).data);
      202 	      end;
      203 	      return;
      204 	   end;
      205 
      206 
      207 /* get ptr to unpaged_page_tables and set hardcore current pointers */
      208 
      209     hardcore_cur_ptr = addr (hard_cur);
      210     call amu_$hardcore_info_set_cur_ptrs (amu_info_ptr, hardcore_cur_ptr);
      211     upt_ptr = hardcore_cur.uptp;
      212 
      213 /* get the pointer to the core map */
      214 
      215     temp_ptr = amu_$definition_ptr (amu_info_ptr, "sst", "cmp", code);
      216     if code ^= 0 then do;
      217        P_code = code;
      218        return;
      219        end;
      220 
      221     seg_no = fixed (baseno (temp_ptr), 17);
      222     sst_segno = seg_no;
      223     offset = fixed (rel (temp_ptr), 17);
      224     cme_size = 4;
      225 
      226 /* now get the core_map ptr in temp_ptr */
      227 
      228     call amu_$do_translation (amu_info_ptr, seg_no, addr (temp_ptr), offset, 2, code);
      229     if code ^= 0 then do;
      230        P_code = code;
      231        return;
      232        end;
      233 
      234     offset = fixed (rel (temp_ptr), 18) + (page_no * cme_size);
      235     seg_no = fixed (baseno (temp_ptr), 17);
      236     cmep = addr (core_map);			/* now get the cme */
      237     call amu_$do_translation (amu_info_ptr, seg_no, cmep, offset, cme_size, code);
      238     if code ^= 0 then do;
      239        P_code = code;
      240        return;
      241        end;
      242 
      243     P_scu = fixed (cme.contr, 17);
      244     P_abs_w = cme.abs_w;
      245 						/* search this process */
      246 
      247        dseg_no = hardcore_info.segno.dseg;
      248        sdwp = addr (seg_desc);
      249        call amu_$do_translation (amu_info_ptr, dseg_no, sdwp, (sst_segno * 2), 2, code);
      250        if code ^= 0 then do;
      251 	P_code = code;
      252 	return;
      253 	end;
      254 
      255        sst_base = fixed (sdw.add, 24);
      256 
      257        do i = 0 by 2 to (hardcore_info.hcs_count * 2);
      258 	call amu_$do_translation (amu_info_ptr, dseg_no, sdwp, i, 2, code);
      259 	if code ^= 0 then do;
      260 	   P_code = code;
      261 	   return;
      262 	   end;
      263 	add_sdw = fixed (sdw.add, 24);
      264 	bd_sdw = fixed (sdw.bound, 24) * 16;
      265 	if sdw.unpaged  then do;
      266 	   if (mem_address >= add_sdw) then do;
      267 	      if mem_address <= add_sdw + bd_sdw then do;
      268 	         P_segno = divide (i, 2, 17);
      269 	         P_offset = mem_address - add_sdw;
      270 	         P_indx = amu_info.process_idx;
      271 	         P_paged = "0"b;
      272 	         P_code = 0;
      273 	         return;
      274 	         end;
      275  	      end;
      276 	   end;
      277           else do;
      278 	   pt_size = divide (bd_sdw, 1024, 18);
      279 	   call get_ptp(add_sdw, ptp);
      280 	   do j = 0 to pt_size;
      281 	      if ptwa (j).df  then do;
      282 	         add_ptw = (fixed (ptwa (j).add, 18) * 64);
      283 	         if (mem_address >= add_ptw) & (mem_address < add_ptw + 1024) then do;
      284 		  P_segno = divide (i, 2, 17);
      285 		  P_offset = (j * 1024) + word_no;
      286 		  P_indx = amu_info.process_idx;
      287 		  P_code = 0;
      288 		  return;
      289 		  end;
      290 	         end;
      291 	      end; 
      292 	   end;  /* if sdw is paged */
      293           end;   /* sdw loop */
      294 
      295 /* now look at the ptw to see if it is valid */
      296     if cme.ptwp = "0"b then do;
      297 
      298 /* no ptw pointer and not abs wired there for can not be in use */
      299        P_code = amu_et_$free_core;
      300        return;
      301        end;
      302 
      303     ptp = addr (page_table_word);
      304     offset = fixed (cme.ptwp, 18);
      305     call amu_$do_translation (amu_info_ptr, sst_segno, ptp, offset, 1, code);
      306     if code ^= 0 then do;
      307        P_code = code;
      308        return;
      309        end;
      310 
      311     if ^(ptw.df) then do; 			/* page not in code */
      312        P_code = amu_et_$free_core;
      313        return;
      314        end;
      315 					/* now get the aste */
      316     offset = fixed (cme.astep, 18);
      317     astep = addr (active_seg_table);
      318     aste_size = size (aste);
      319     call amu_$do_translation (amu_info_ptr, sst_segno, astep, offset, aste_size, code);
      320     if code ^= 0 then do;
      321        P_code = code;
      322        return;
      323        end;
      324 
      325     if aste.strp = "0"b then do;       /* segment not active */
      326        P_code = amu_et_$proc_not_dumped;
      327        call by_process_search;
      328        return;
      329        end;
      330 
      331 /* now get the str_seg data */
      332 
      333     seg_name = "str_seg";
      334     call amu_$slt_search_seg_num (hard_cur.sltp, hard_cur.sltntp, seg_name, str_segno, code);
      335     if code ^= 0 then do;
      336        P_code = code;
      337        return;
      338        end;
      339 
      340     offset = fixed (aste.strp, 18);
      341     str_size = size (str);
      342     strp = addr (seg_trailer);
      343     call amu_$do_translation (amu_info_ptr, str_segno, strp, offset, str_size, code);
      344     if code ^= 0 then do;
      345        P_code = code;
      346        return;
      347        end;
      348 				/* now find the first process that this seg known  */
      349     do while (str.bp ^= "0"b);
      350        offset = fixed (str.bp, 18);
      351        call amu_$do_translation (amu_info_ptr, str_segno, strp, offset, str_size, code);
      352        if code ^= 0 then do;
      353 	P_code = code;
      354 	return;
      355 	end;
      356        end;
      357 
      358     save_process_index = amu_info.process_idx;
      359     if amu_$return_val_per_process (amu_info_ptr, fixed (str.segno, 17)) then do;
      360        pds_dstep = amu_$definition_ptr (amu_info_ptr, "pds", "dstep", code);
      361        if code ^= 0 then do;
      362 	P_code = code;
      363 	return;
      364 	end;
      365        save_process_index = amu_info.process_idx;
      366 
      367 next_str:
      368        loop_exit = "0"b;
      369        do temp_indx = 0 to hbound (fdump_process_table.array, 1) while (^loop_exit);
      370 	call amu_$fdump_mpt_change_idx (amu_info_ptr, temp_indx);
      371 	call amu_$do_translation_by_ptr (amu_info_ptr, pds_dstep, 1, addr (temp_dstep), code);
      372 	if code ^= 0 then do;
      373 	   P_code = code;
      374 	   goto ERROR_EXIT;
      375 	   end;
      376 	if temp_dstep = str.dstep /* found a procsee */ then loop_exit = "1"b;
      377 	end;
      378        if (^loop_exit) & str.fp ^= "0"b then do;
      379           offset = fixed (str.fp, 18);
      380 	call amu_$do_translation (amu_info_ptr, str_segno, strp, offset, str_size, code);
      381 	if code ^= 0 then do;
      382 	   P_code = code;
      383 	   return;
      384 	   end;
      385 	goto next_str;
      386 	end;
      387        end;
      388     else loop_exit = "1"b;
      389     if ^(loop_exit) then P_code = amu_et_$proc_not_dumped;
      390     P_indx = amu_info.process_idx;
      391     P_segno = fixed (str.segno, 17);
      392     page_no = fixed (cme.ptwp, 18) - (fixed (cme.astep, 18) + aste_size);
      393     P_offset = word_no + (page_no * 1024);
      394     call amu_$fdump_mpt_change_idx (amu_info_ptr, save_process_index);
      395     return;
      396 
      397 ERROR_EXIT:
      398 
      399     P_code = code;
      400     call amu_$fdump_mpt_change_idx (amu_info_ptr, save_process_index);
      401     return;
      402 
      403 
      404 
      405 /* We failed to find the address so we have to try to do so the hard way */
      406 
      407 by_process_search: proc;
      408 
      409 dcl off18 fixed bin (18) aligned init (0);
      410 dcl last_seg fixed bin (35);
      411 dcl dsegp ptr;
      412 	         save_process_index = amu_info.process_idx;
      413 	         dumpptr = fdump_info.dump_seg_ptr (0);
      414 	         sstp = hardcore_cur.sstp;
      415 	         substr (unspec (off18), 19, 14) = substr (unspec (mem_address), 13, 14);
      416 
      417 	         do k = 0 to hbound (fdump_process_table.array, 1);
      418 		  call amu_$fdump_mpt_change_idx (amu_info_ptr, k);
      419 		  call amu_$do_translation_hunt_ptr (amu_info_ptr, pointer (baseptr (hardcore_info.dseg), 0), dsegp, code);
      420 		  if code ^= 0 then do;
      421 		     P_code = code;
      422 		     call amu_$fdump_mpt_change_idx (amu_info_ptr, save_process_index);
      423 		     return;
      424 		     end;
      425 		  
      426 		  fp_table_ptr = addr (fdump_process_table.array(k));
      427 		   last_seg = fixed (dump.segs (fp_table.first_seg).length, 18) * 64;
      428 		   last_seg = divide (last_seg, 2, 17, 0) - 1;
      429 		  do i = 0 to last_seg;
      430 		     sdwp = addrel (dsegp, i * 2);
      431 		     if sdw.df then do;
      432 		        add_sdw = fixed (sdw.add, 24);
      433 		        bd_sdw = fixed (sdw.bound, 24) * 16;
      434 		        if sdw.unpaged then do;
      435 			 j = ((fixed (sdw.bound, 14) + 1) * 16) -1;
      436 			 if mem_address >= add_sdw & mem_address <= add_sdw + j then do;
      437 			    P_segno = divide (i, 2, 17);
      438 			    P_offset = mem_address -add_sdw;
      439 			    P_indx = amu_info.process_idx;
      440 			    P_paged = "0"b;
      441 			    P_code = 0;
      442 			    goto RET;
      443 			    end;
      444 			 else go to next_lap;
      445 			 end;
      446 		        else do;
      447 			 ptp = addrel (sstp, add_sdw - fixed (sst.ptwbase, 18));
      448 			 pt_size = divide (bd_sdw, 1024, 18);
      449 			 astep = addrel (ptp, - (sst.astsize));
      450 			 do j = 0 to fixed (aste.csl, 9);
      451 			    if ^ptw.df then go to pt_lap;
      452 			    if fixed (ptw.add, 18) = off18 then do;
      453 			       P_segno = i;
      454 			       P_offset = j * 1024 + mod (mem_address, 1024);
      455 			       P_indx = amu_info.process_idx;
      456 			       P_code = 0;
      457 			       goto RET;
      458 			       end;
      459 pt_lap:			    ptp = addrel (ptp, 1);
      460 			    end;
      461 			 end;
      462 		        end;
      463 next_lap:		     end;
      464 		  end;
      465 	         
      466 RET:	         call amu_$fdump_mpt_change_idx (amu_info_ptr, save_process_index);
      467 	         return;
      468 
      469 	         end by_process_search;
      470 
      471 get_ptp: proc(add_sdw, ptp);
      472          
      473 /* Parameters */
      474 
      475 dcl add_sdw fixed bin(24);
      476 dcl ptp ptr;
      477 
      478 /*  This routine determines the page table pointer  .
      479*
      480*    add_sdw	the contents of a sdw address (input),
      481*    ptp		page table pointer (output),
      482**/
      483 
      484 dcl relative_offset fixed bin(26);
      485 dcl sdw_add fixed bin(26);
      486 dcl sst_ptr ptr;
      487 
      488 
      489     sst_ptr = hardcore_cur.sstp;
      490     sdw_add = fixed (add_sdw, 26);      /* want fixed bin(26) */
      491 
      492     if upt_ptr = null() then do;
      493        relative_offset = add_sdw - sst_base;
      494        ptp = addrel(sst_ptr, relative_offset);                
      495        end;
      496     else if (add_sdw > upt.upt_absloc & add_sdw < upt.upt_last_loc) then do;
      497        /* found in unpaged_page_tables */
      498        relative_offset = sdw_add - upt.upt_absloc;
      499        ptp = addrel(upt_ptr, relative_offset);  
      500        end;
      501     else if (add_sdw > upt.iupt_absloc & add_sdw < upt.iupt_last_loc) then do;
      502        /* found in int_unpaged_page_tables */
      503        relative_offset = sdw_add - upt.iupt_absloc;
      504        ptp = addrel(upt_ptr, relative_offset);  
      505        end;
      506     else do;
      507        /* found in sst_seg */
      508        relative_offset = sdw_add - upt.sst_absloc;
      509        ptp = addrel(sst_ptr, relative_offset);        
      510        end;
      511 
      512 end get_ptp;
      513 
  1     1 /*	BEGIN INCLUDE FILE amu_fdump_info.incl.pl1	*/
  1     2 
  1     3 dcl 1 fdump_info aligned based (amu_info.fdump_info_ptr),
  1     4     2 version char (8),
  1     5     2 ref_count fixed bin,				/* number of initiations */
  1     6 
  1     7     2 erf_name char (32),				/* ERF name for this dump */
  1     8     2 dump_dname char (168),				/* location of the dump */
  1     9     2 dump_ename char (32),				/* ename of component zero */
  1    10     2 system_id char (8),				/* the system_id of this erf */
  1    11     2 version_id char (8),				/* the version id of this erf */
  1    12     2 dump_seg_0_uid bit (36) aligned,			/* for determining EQ-ness and gullibility checking */
  1    13 
  1    14     2 n_dump_segs fixed bin,				/* number of real segs in the dump */
  1    15     2 copy_block_ptr pointer, 			/* pointer to chain of temp segment blocks */
  1    16 
  1    17     2 dump_seg_ptr (0:31) pointer,			/* pointer and length arrays */
  1    18     2 dump_seg_lth (0:31) fixed bin (18),
  1    19 
  1    20     2 fdump_process_table_ptr pointer;			/* pointer to array describing processes */
  1    21 
  1    22 
  1    23 dcl 1 fdump_process_table aligned based (fdump_info.fdump_process_table_ptr),
  1    24     2 size fixed bin,				/* number of entries */
  1    25 
  1    26     2 array (0:alloc_fdump_process_table_size - 1 refer (fdump_process_table.size)) like fp_table;
  1    27 
  1    28 dcl 1 fp_table based (fp_table_ptr),
  1    29       2 first_seg fixed bin,
  1    30       2 last_seg fixed bin,
  1    31       2 process_info_ptr pointer unaligned,		/* pointer to process_info structure, if filled in */
  1    32       2 dmp_seg_indx fixed bin,			/* dump seg index where process can be found */
  1    33       2 dmp_seg_offset fixed bin (24),			/* offset in the segment refered to by dmp_seg_indx where process starts */
  1    34       2 cpu_name char (1),
  1    35       2 dbr fixed bin (24),				/* address portion of DBR */
  1    36       2 apte_offset fixed bin (18);
  1    37 
  1    38 dcl fp_table_ptr ptr;
  1    39 
  1    40 dcl  alloc_fdump_process_table_size fixed bin;
  1    41 
  1    42 dcl  AMU_FDUMP_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_erf1");
  1    43 dcl  AMU_FDUMP_INFO_VERSION char (8) internal static options (constant) init ("amu_erf1");
  1    44 
  1    45 /*	END INCLUDE FILE amu_fdump_info.incl.pl1	*/
      514 
  2     1 /*	BEGIN INCLUDE FILE amu_hardcore_info.incl.pl1	*/
  2     2 
  2     3 /* This structure contains information about the hardcore supervisor address
  2     4*   space for an address translation. */
  2     5 
  2     6 dcl 1 hardcore_info aligned based (amu_info.hardcore_info_ptr),
  2     7 
  2     8     2 pointers,					/* assorted pointers to various useful items */
  2     9       3 slt aligned,				/* SLT */
  2    10         4 fptr pointer unaligned,			/* address in foreign address space */
  2    11         4 lptr pointer unaligned,			/* location in local address space */
  2    12       3 sltnt aligned like hardcore_info.slt,		/* SLT names segment */
  2    13       3 definitions aligned like hardcore_info.slt,	/* hardcore definitions_ segment */
  2    14 
  2    15       3 sst aligned like hardcore_info.slt,		/* SST */
  2    16       3 tc_data aligned like hardcore_info.slt,		/* TC_DATA */
  2    17       3 sstnt aligned like hardcore_info.slt,		/* SSTNT (if any -- foreign_ptr = null if not) */
  2    18       3 upt aligned like hardcore_info.slt,		/* unpaged_page_tables (if any -- foreign_ptr = null if not) */
  2    19 
  2    20     2 segno,					/* segment numbers of various per-process/per-processor segs */
  2    21       3 prds fixed bin (15),				/* segno of PRDS */
  2    22       3 dseg fixed bin (15),				/* DSEG */
  2    23       3 pds fixed bin (15),				/* PDS */
  2    24       3 kst fixed bin (15),				/* KST */
  2    25       3 stack_0 fixed bin (15),			/* segno of stack_0 -- first one in stack group */
  2    26       3 unpaged_page_tables fixed bin(15),		/* segno of unpaged_page_tables if it exists */
  2    27 
  2    28     2 apt,					/* information about the APT */
  2    29       3 foreign_ptr pointer unaligned,			/* foreign and local pointers to tcm.apt */
  2    30       3 local_ptr pointer unaligned,
  2    31       3 count fixed bin,				/* number of APTEs */
  2    32       3 size fixed bin,				/* size of a single APTE */
  2    33 
  2    34     2 hcs_count fixed bin,				/* highest hardcore segno */
  2    35 
  2    36     2 pad1 fixed bin;
  2    37 
  2    38 dcl hardcore_cur_ptr ptr;
  2    39 
  2    40 dcl 1 hardcore_cur based (hardcore_cur_ptr),
  2    41     2 sltp ptr,
  2    42     2 sltntp ptr,
  2    43     2 defp ptr,
  2    44     2 sstp ptr,
  2    45     2 tc_datap ptr,
  2    46     2 sstntp ptr,
  2    47     2 uptp ptr;
  2    48 	
  2    49     
  2    50 
  2    51 
  2    52 /*	END INCLUDE FILE amu_hardcore_info.incl.pl1	*/
      515 
  3     1 /*	BEGIN INCLUDE FILE amu_info.incl.pl1		*/
  3     2 
  3     3 dcl 1 amu_info aligned based (amu_info_ptr),
  3     4     2 version char (8) aligned,			/* AMU_INFO_VERSION */
  3     5     2 flags aligned,
  3     6       3 early_dump bit(1) unal,
  3     7       3 pad  bit(35) unal,
  3     8     2 type fixed bin unal,				/* One of the types below */
  3     9     2 time_created fixed bin (71) aligned,		/* time created -- for debugging purposes */
  3    10     2 chain,					/* a chain of all the amu_info's which exist */
  3    11       3 prev pointer unaligned,
  3    12       3 next pointer unaligned,
  3    13 
  3    14     2 area_ptr pointer,				/* pointer to area used for allocating things */
  3    15 
  3    16     2 translation_table_ptr pointer,			/* pointer to address map -- always present */
  3    17 						/*   SEE: amu_translation.incl.pl1 */
  3    18     2 fdump_info_ptr pointer, 			
  3    19 						/* pointer to FDUMP info, present if looking at an FDUMP */
  3    20 						/*   SEE: amu_fdump_info.incl.pl1 */
  3    21 						/* old_uid_table pointer if looking at a SAVED PROC. */
  3    22 						/* See: amu_old_uid_table			*/
  3    23 	
  3    24 
  3    25     2 hardcore_info_ptr pointer,			/* pointer to hardcore information -- always present */
  3    26 						/*   SEE: amu_hardcore_info.incl.pl1 */
  3    27     2 copy_chain pointer,				/* pointer to info about segment copies */
  3    28 						/*   SEE: amu_copy_info.incl.pl1 */
  3    29     2 process_info_ptr pointer,			/* pointer to process info for this translation */
  3    30 						/*   SEE: amu_process_info.incl.pl1 */
  3    31     2 process_idx fixed bin,				/* index of process in translation-specifc process table */
  3    32 
  3    33     2 proc_idx_hold fixed bin,			/* a place to keep the index when a changing to another proc */
  3    34 
  3    35     2 error_info,					/* various info about how amu_error_ is to behave */
  3    36       3 error_flags aligned,
  3    37         4 handler_exists bit (1) unaligned,		/* set to indicate existence of an amu_error handler */
  3    38         4 in_subsystem bit (1) unaligned,		/* This amu_info belongs to an ssu_ maintained subsystem */
  3    39         4 pad bit (34) unaligned,
  3    40       3 sci_ptr pointer,				/* sci_ptr for subsystem, if in_subsystem = "1"b */
  3    41     2 definitions_info_ptr ptr;
  3    42 
  3    43 dcl  amu_area area based (amu_info.area_ptr);
  3    44 
  3    45 dcl  amu_info_ptr pointer;
  3    46 
  3    47 dcl (FDUMP_TYPE		init (1037),		/* the various legitimate types of amu_info's */
  3    48      FDUMP_PROCESS_TYPE	init (1038),
  3    49      ONLINE_TYPE		init (1039),
  3    50      ONLINE_PROCESS_TYPE	init (1040),
  3    51      NETWORK_FDUMP_TYPE	init (1041),
  3    52      NETWORK_ONLINE_TYPE	init (1042),
  3    53      SAVED_PROC_TYPE	init (1043),
  3    54      INDIRECT_TYPE		init (1044)) fixed bin internal static options (constant);
  3    55 
  3    56 dcl  AMU_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_v1");
  3    57 dcl  AMU_INFO_VERSION char (8) internal static options (constant) init ("amu_v1");
  3    58 dcl  AMU_INFO_VERSION_2 char (8) internal static options (constant) init ("amu_v2");
  3    59 
  3    60 dcl  PDIR_SUFFIX		char(4) init("pdir") int static options(constant);
  3    61 
  3    62 /*	END INCLUDE FILE amu_info.incl.pl1		*/
      516 
  4     1 /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  4     2 
  4     3 /* Template for an AST entry. Length = 12 words. */
  4     4 
  4     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  4     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  4     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  4     8 
  4     9 dcl  astep ptr;
  4    10 
  4    11 dcl 1 aste based (astep) aligned,
  4    12 
  4    13     (2 fp bit (18),					/* forward  used list rel pointer */
  4    14     2 bp bit (18),					/* backward used list rel pointer */
  4    15 
  4    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  4    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  4    18 
  4    19     2 strp bit (18),				/* rel pointer to process trailer */
  4    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  4    21 
  4    22     2 uid bit (36),					/* segment unique id */
  4    23 
  4    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  4    25     2 pvtx fixed bin (8),				/* physical volume table index */
  4    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  4    27 
  4    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  4    29     2 init bit (1),					/* used bit - insure 1 lap */
  4    30     2 gtus bit (1),					/* global transparent usage switch */
  4    31     2 gtms bit (1),					/* global transparent modified switch */
  4    32     2 hc bit (1),					/* hard core segment */
  4    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  4    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  4    35     2 write_access_on bit (1),			/* any sdw allows write access */
  4    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  4    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  4    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  4    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  4    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  4    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  4    42     2 pad1 bit (2),					/* OO */
  4    43     2 dius bit (1),					/* dumper in use switch */
  4    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  4    45     2 dmpr_pad bit (1),
  4    46     2 ehs bit (1),					/* entry hold switch */
  4    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  4    48     2 dirsw bit (1),				/* directory switch */
  4    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  4    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  4    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  4    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  4    53 
  4    54     2 dtu bit (36),					/* date and time segment last used */
  4    55 
  4    56     2 dtm bit (36),					/* date and time segment last modified */
  4    57 
  4    58 
  4    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  4    60 
  4    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  4    62 
  4    63     2 csl bit (9),					/* current segment length in 1024 words units */
  4    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  4    65     2 fms bit (1),					/* file modified switch */
  4    66     2 npfs bit (1),					/* no page fault switch */
  4    67     2 gtpd bit (1),					/* global transparent paging device switch */
  4    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  4    69     2 per_process bit (1),				/* use master quota for this entry */
  4    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  4    71     2 pad2 bit (2),
  4    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  4    73     2 np bit (9),					/* number of pages in core */
  4    74 
  4    75 
  4    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  4    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  4    78     2 damaged bit (1),				/* PC declared segment unusable */
  4    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  4    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  4    81     2 pad3 bit (6),					/* OOOOOOOOO */
  4    82     2 ptsi bit (2),					/* page table size index */
  4    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  4    84 
  4    85 
  4    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  4    87 
  4    88 
  4    89 dcl 1 aste_part aligned based (astep),
  4    90 
  4    91     2 one bit (36) unaligned,				/* fp and bp */
  4    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  4    93     2 three bit (8) unaligned;			/* ptsi and marker */
  4    94 
  4    95 
  4    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  4    97     2 pad1 bit (8*36),
  4    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  4    99     2 pad2 bit (3*36);
  4   100 
  4   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      517 
  5     1 /* BEGIN INCLUDE FILE ... bos_dump.incl.pl1 ... */
  5     2 /* Modified 1 September 1976 */
  5     3 /* Modified 11/11/80 by J. A. Bush for the DPS8/70M CPU */
  5     4 /* Modified 6/12/81 by Rich Coppola to extend the dps8 extended fault reg to 
  5     5*   15 bits  */
  5     6 /* Modified 02/23/81, W. Olin Sibert, to describe old and new FDUMP styles */
  5     7 
  5     8 
  5     9 dcl  dumpptr ptr;					/* pointer to following structure */
  5    10 
  5    11 dcl 1 dump based (dumpptr) aligned,			/* header of dump by fdump */
  5    12     2 dump_header aligned like dump_header,
  5    13 
  5    14     2 segs (1008),					/* segment array */
  5    15       3 segno bit (18) unal,				/* segment number */
  5    16       3 length bit (18) unal, 			/* length of segment in sector sized blocks */
  5    17 
  5    18     2 amptwregs (0 : 63) bit (36),			/* assoc. mem. page table word regs */
  5    19     2 amptwptrs (0 : 63) bit (36),			/* assoc. mem. page table word pointers */
  5    20     2 amsdwregs (0 : 63) bit (72),			/* assoc. mem. segment descriptor word registers */
  5    21     2 amsdwptrs (0 : 63) bit (36),			/* assoc. mem. segment descriptor word pointers */
  5    22 
  5    23     2 ouhist (0 : 63) bit (72), 			/* operations unit history registers */
  5    24     2 cuhist (0 : 63) bit (72), 			/* control unit history registers */
  5    25     2 duhist (0 : 63) bit (72), 			/* decimal unit history registers */
  5    26     2 auhist (0 : 63) bit (72), 			/* appending unit history registers */
  5    27 
  5    28     2 prs (0 : 7) ptr,				/* pointer registers */
  5    29 
  5    30     2 regs aligned like dump_registers, 		/* assorted machine registers */
  5    31 
  5    32     2 low_order_port bit (3), 			/* from which clock is read */
  5    33     2 pad4 bit (36),
  5    34     2 mctime fixed bin (52),				/* time conditions were taken */
  5    35     2 pad5 (0 : 3) bit (36),
  5    36 
  5    37     2 misc_registers like dump_misc_registers,		/* Assorted registers & processor data */
  5    38 
  5    39     2 ptrlen (0 : 7) bit (36),			/* pointers and lengths for EIS */
  5    40 
  5    41     2 coreblocks (0 : 7),
  5    42       3 num_first bit (18) unal,			/* first addr in coreblock */
  5    43       3 num_blocks bit (18) unal,			/* number of blocks used */
  5    44     2 pad7 (112) fixed bin;
  5    45 
  5    46 
  5    47 dcl 1 dump_header aligned based,			/* Standard header for FDUMP */
  5    48     2 words_dumped fixed bin (35),			/* total words in dump */
  5    49     2 valid bit (1),				/* = 1 if there is a 6180 dump to be had */
  5    50     2 time fixed bin (71),				/* time of dump */
  5    51     2 erfno fixed bin (18),				/* Error Report Form Number */
  5    52     2 num_segs fixed bin,				/* number of segments dumped */
  5    53     2 valid_355 bit (1),				/* = 1 if there is a dn355 dump to be had */
  5    54     2 dumped_355s bit (4),				/* indicates which 355s were dumped */
  5    55     2 time_355 fixed bin (71),			/* time of 355 dump */
  5    56     2 version fixed bin,				/* currently 2 */
  5    57     2 pad0 (5) fixed bin;				/* pad0 to 16 words */
  5    58 
  5    59 dcl 1 dump_registers aligned based,			/* Standard (SREG) arrangement of registers in dump */
  5    60    (2 x (0 : 7) bit (18),				/* index registers */
  5    61     2 a bit (36),					/* the a register */
  5    62     2 q bit (36),					/* the q register */
  5    63     2 e bit (8),					/* the e register */
  5    64     2 pad2 bit (28),				/* pad */
  5    65     2 t bit (27),					/* timer register */
  5    66     2 pad3 bit (6), 				/* pad */
  5    67     2 ralr bit (3)) unaligned;			/* ring alarm register */
  5    68 
  5    69 dcl 1 dump_misc_registers aligned based,
  5    70     2 scu (0 : 7) bit (36),				/* from store control unit instr. */
  5    71     2 mcm (0 : 7) bit (72),				/* memory controller masks every 64 K */
  5    72     2 dbr bit (72), 				/* descriptor segment base register */
  5    73     2 intrpts bit (36),				/* interrupts */
  5    74     2 bar bit (36), 				/* base address register */
  5    75     2 modereg bit (36),				/* mode register */
  5    76     2 cmodereg bit (36),				/* cache mode register */
  5    77     2 faultreg bit (36),				/* fault register */
  5    78     2 ext_fault_reg bit (15) unaligned,			/* DPS8 extended fault register */
  5    79     2 pad6 bit (21) unaligned;
  5    80     
  5    81     
  5    82 
  5    83 dcl 1 v1_dump aligned based (dumpptr),			/* Old version of FDUMP (pre March, 1981) */
  5    84     2 dump_header aligned like dump_header,
  5    85 
  5    86     2 segs (688),					/* segment array */
  5    87       3 segno bit (18) unal,				/* segment number */
  5    88       3 length bit (18) unal, 			/* length of segment in sector sized blocks */
  5    89 
  5    90     2 amsdwregs (0 : 15) bit (72),			/* assoc. mem. segment descriptor word registers */
  5    91     2 amsdwptrs (0 : 15) bit (36),			/* assoc. mem. segment descriptor word pointers */
  5    92     2 amptwregs (0 : 15) bit (36),			/* assoc. mem. page table word regs */
  5    93     2 amptwptrs (0 : 15) bit (36),			/* assoc. mem. page table word pointers */
  5    94     2 pad1 (0 : 15) bit (36),
  5    95 
  5    96     2 ouhist (0 : 15) bit (72), 			/* operations unit history registers */
  5    97     2 cuhist (0 : 15) bit (72), 			/* control unit history registers */
  5    98     2 auhist (0 : 15) bit (72), 			/* appending unit history registers */
  5    99     2 duhist (0 : 15) bit (72), 			/* decimal unit history registers */
  5   100 
  5   101     2 prs (0 : 7) ptr,				/* pointer registers */
  5   102 
  5   103     2 regs aligned like dump_registers, 		/* assorted machine registers */
  5   104 
  5   105     2 mctime fixed bin (52),				/* time conditions were taken */
  5   106     2 pad4 (0 : 5) bit (36),
  5   107 
  5   108     2 misc_registers aligned like dump_misc_registers,	/* Assorted registers */
  5   109 
  5   110     2 pad5 bit (36),
  5   111     2 ptrlen (0 : 7) bit (36),			/* pointers and lengths for EIS */
  5   112     2 pad6 (15) bit (36),
  5   113     2 low_order_port bit (3), 			/* from which clock was read */
  5   114 
  5   115     2 coreblocks (0 : 7),
  5   116       3 num_first bit (18) unal,			/* first addr in coreblock */
  5   117       3 num_blocks bit (18) unal;			/* number of blocks used */
  5   118 
  5   119 
  5   120 dcl  DUMP_VERSION_1 fixed bin internal static options (constant) init (1);
  5   121 dcl  DUMP_VERSION_2 fixed bin internal static options (constant) init (2);
  5   122 
  5   123 /* END INCLUDE FILE ... bos_dump.incl.pl1 ... */
      518 
  6     1 /* BEGIN INCLUDE FILE cmp.incl.pl1 --- October 1982 */
  6     2 /* Note: This include file has an ALM counterpart NOT made with cif (for historical reasons). Keep it up to date */
  6     3 
  6     4 dcl  cmep ptr;					/* pointer to core map entry */
  6     5 
  6     6 dcl 1 cme based (cmep) aligned,			/* core map entry */
  6     7     2 fp bit (18) unaligned,				/* forward pointer to next entry */
  6     8     2 bp bit (18) unaligned,				/* backward pointer to previous entry */
  6     9 
  6    10     2 devadd bit (22) unaligned,			/* device address of page in the core block */
  6    11     2 pad5 bit (1) unaligned,
  6    12     2 synch_held bit (1) unaligned,			/* Page of synchronized seg held in memory */
  6    13     2 io bit (1) unaligned,				/* input/output indicator 1=output, 0=input */
  6    14     2 pad2 bit (1) unaligned,
  6    15     2 er bit (1) unaligned,				/* indicates error in previous IO activity */
  6    16     2 removing bit (1) unaligned,			/* core is being removed by reconfiguration */
  6    17     2 abs_w bit (1) unaligned,			/* absolute address must not be changed for page */
  6    18     2 abs_usable bit (1) unaligned,			/* page may be assigned with fixed absolute address */
  6    19     2 notify_requested bit (1) unaligned,		/* notify requested on I/O completion */
  6    20     2 pad3 bit (1) unaligned,
  6    21     2 phm_hedge bit (1) unaligned,			/* on => pc$flush_core ought write. */
  6    22     2 contr bit (3) unaligned,			/* controller in which core block is located */
  6    23 
  6    24     2 ptwp bit (18) unaligned,			/* pointer to page table word for the page */
  6    25     2 astep bit (18) unaligned,			/* relative AST entry pointer of page */
  6    26     2 pin_counter fixed bin (17) unaligned,		/* number of times to skip eviction */
  6    27     2 synch_page_entryp bit (18) unaligned;		/* relp to synch page entry */
  6    28 
  6    29 
  6    30 dcl 1 cma (0: 1) based aligned like cme;		/* Core map array */
  6    31 
  6    32 dcl 1 mcme based (cmep) aligned,			/* core map entry for extracting DID */
  6    33     2 pad bit (36) unaligned,
  6    34     2 record_no bit (18) unaligned,			/* record number of device */
  6    35     2 add_type bit (4) unaligned,			/* see add_type.incl.pl1 */
  6    36     2 flags bit (14) unal,
  6    37     2 pad1 bit (18) unal;
  6    38 
  6    39 
  6    40 /* END INCLUDE FILE  cmp.incl.pl1 */
      519 
  7     1 /* BEGIN INCLUDE FILE  ptw.incl.pl1  ---  09/13/74 for nss */
  7     2 
  7     3 dcl  ptp ptr;					/* pointer to either page table or page table word */
  7     4 
  7     5 dcl 1 ptw based (ptp) aligned,			/* page table word */
  7     6 
  7     7     (2 add bit (18),				/* address of page, type of which is defined by add_type */
  7     8     2 add_type bit (4),				/* 0000=null, 1000=core, 0100=disk, 0010=pd, 0001=swap */
  7     9     2 first bit (1),				/* the page has not yet been written out */
  7    10     2 processed bit (1),				/* temporary used during post-purging and error signalling */
  7    11     2 pad1 bit (1),
  7    12     2 unusable1 bit (1),				/* can't be used because hardware resets this bit */
  7    13     2 phu bit (1),					/* page has been used bit */
  7    14     2 phm1 bit (1),					/* Cumulative OR of hardware phm's */
  7    15     2 nypd bit (1),					/* must be moved to paging device */
  7    16     2 phm bit (1),					/* page has been modified bit */
  7    17     2 phu1 bit (1),					/* page has been used in the quantum */
  7    18     2 wired bit (1),				/* page is to remain in core */
  7    19     2 os bit (1),					/* page is out-of-service (I/O in progress) */
  7    20     2 df bit (1),					/* directed fault if this is 0 (page not in core) */
  7    21     2 df_no bit (2)) unaligned;			/* directed fault number for page faults */
  7    22 
  7    23 dcl 1 ptwa (0:255) based (ptp) aligned like ptw;		/* page table */
  7    24 
  7    25 dcl  ptwa_bits (0:255) based (ptp) bit (36) aligned;	/* page table array as raw bits */
  7    26 
  7    27 dcl 1 mptw based (ptp) aligned,			/* page table word while page is not in core */
  7    28     2 devadd bit (22) unaligned,			/* device address where page resides */
  7    29     2 pad bit (14) unaligned;
  7    30 
  7    31 dcl 1 mptwa (0 : 1) based (ptp) aligned,		/* page table while pages are not in core */
  7    32     2 devadd bit (22) unaligned,			/* device address where page resides */
  7    33     2 pad bit (14) unaligned;
  7    34 
  7    35 dcl 1 atptw based (ptp) aligned,			/* PL/I has problems on overlay-def based */
  7    36     2 add bit (18) unal,
  7    37     2 (core, disk, pd, reserved) bit (1) unal,		/* address types */
  7    38     2 pad bit (14) unal;
  7    39 
  7    40 dcl 1 atptwa (0:255) based (ptp) aligned like atptw;
  7    41 
  7    42 /* END INCLUDE FILE  ptw.incl.pl1 */
      520 
  8     1 /* BEGIN INCLUDE FILE scs.incl.pl1 ... March 1983 */
  8     2 /* format: style4 */
  8     3 
  8     4 /* Information about system controllers */
  8     5 
  8     6 dcl  1 scs$controller_data (0:7) aligned ext,		/* per-controller info */
  8     7        2 size fixed bin (17) unaligned,			/* size (in 1024 word blocks) of this controller */
  8     8        2 base fixed bin (17) unaligned,			/* abs address (0 mod 1024) for base of this controller */
  8     9        2 eima_data (4) unaligned,			/* EIMA information for this controller */
  8    10          3 mask_available bit (1) unaligned,		/* ON if corresponding mask exists */
  8    11          3 mask_assigned bit (1) unaligned,		/* ON if mask assigned to a port */
  8    12          3 mbz bit (3) unaligned,
  8    13          3 mask_assignment fixed bin (3) unaligned,	/* port to which mask is assigned */
  8    14        2 info aligned,
  8    15          3 online bit (1) unaligned,			/* ON if controller is online */
  8    16          3 offline bit (1) unaligned,			/* ON if controller is offline but can be added */
  8    17          3 store_a_online bit (1) unaligned,		/* ON if store A is online */
  8    18          3 store_a1_online bit (1) unaligned,		/* ON if store A1 is online */
  8    19          3 store_b_online bit (1) unaligned,		/* ON if store B is online */
  8    20          3 store_b1_online bit (1) unaligned,		/* ON if store B1 is online */
  8    21          3 store_b_is_lower bit (1) unaligned,		/* ON if store B is lower */
  8    22          3 ext_interlaced bit (1) unaligned,		/* ON if this SCU is interlaced with other SCU */
  8    23          3 int_interlaced bit (1) unaligned,		/* ON if this SCU is internally interlaced */
  8    24          3 four_word bit (1) unaligned,			/* ON if external interlace is 4-word */
  8    25          3 cyclic_priority (7) bit (1) unaligned,		/* Cyclic priority for adjacent ports */
  8    26          3 type bit (4) unaligned,			/* Model number for this controller */
  8    27          3 abs_wired bit (1) unaligned,			/* ON if controller can have abs_wired pages */
  8    28          3 program bit (1) unaligned,			/* PROGRAM/MANUAL switch setting */
  8    29          3 mbz bit (13) unaligned,
  8    30        2 lower_store_size fixed bin (17) unaligned,	/* size (in 1024 word blocks) of lower store */
  8    31        2 upper_store_size fixed bin (17) unaligned;	/* size (in 1024 word blocks) of upper store */
  8    32 
  8    33 /* Information about CPUs */
  8    34 
  8    35 dcl  1 scs$processor_data (0:7) aligned ext,		/* information about CPUs in the system */
  8    36        (
  8    37        2 online bit (1),				/* "1"b if CPU is online */
  8    38        2 offline bit (1),				/* "1"b if CPU is offline but can be added */
  8    39        2 release_mask bit (1),			/* "1"b is this CPU is to give up its mask */
  8    40        2 accept_mask bit (1),				/* "1"b if this CPU is to grap mask in idle loop */
  8    41        2 delete_cpu bit (1),				/* "1"b if this CPU is to delete itself */
  8    42        2 interrupt_cpu bit (1),			/* "1"b if this CPU takes hardware interrupts */
  8    43        2 halted_cpu bit (1),				/* "1"b if this CPU has stopped itself (going to BOS) */
  8    44        2 cpu_type fixed bin (2) unsigned,		/*  0 => DPS or L68, 1 => DPS8 */
  8    45        2 mbz1 bit (6),
  8    46        2 cache_size fixed bin (3) unsigned,		/* 0 = No cache; 1 = L68 2K cache;
  8    47*						   2 = DPS8 8K cache; 3 = DPS8 VS&SC 8K cache;
  8    48*						   4 = DPS8 VS&SC 16K cache; 5 = DPS8 VS&SC 32K cache
  8    49*						   7 = ignore cache size (set by ISOLTS reconfig) */
  8    50        2 mbz2 bit (12),
  8    51        2 expanded_port bit (1),			/* "1"b = on expanded port */
  8    52        2 expander_port fixed bin (2) unsigned,		/* The actual expander port */
  8    53        2 controller_port fixed bin (3) unsigned
  8    54        ) unaligned;					/* Port on controller */
  8    55 
  8    56 dcl  1 scs$port_data (0:7) aligned external static,	/* Info about what is connected to each SCU port */
  8    57        2 assigned fixed bin (4) unsigned unaligned,	/* Type of device on this port		*/
  8    58        2 expander_port bit (1) unaligned,		/* "1"b => this port has a port expander */
  8    59        2 expanded_cpu (0:3) bit (1) unaligned,		/* "1"b => this expander port has a CPU attached */
  8    60        2 iom_number fixed bin (3) unsigned unaligned,	/* IOM number of IOM attached to this port */
  8    61        2 cpu_number (0:3) fixed bin (3) unsigned unaligned, /* CPU number of CPU(s) attached to this port */
  8    62 						/* cpu_number (0) is only one if expander_port is "0"b */
  8    63        2 pad bit (12) unaligned;
  8    64 
  8    65 dcl  1 scs$cow (0:7) aligned external,			/* Actual connect words */
  8    66        2 pad bit (36) aligned,			/* Expander COW's must be odd-word */
  8    67        2 cow,
  8    68          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  8    69          3 mbz1 bit (13) unaligned,
  8    70          3 expander_command bit (3) unaligned,		/* Expander command. */
  8    71          3 mbz2 bit (2) unaligned,
  8    72          3 expanded_port bit (1) unaligned,		/* "1"b = on expanded port */
  8    73          3 expander_port fixed bin (3) unsigned unaligned,	/* Port on expander for cioc */
  8    74          3 mbz3 bit (3) unaligned,
  8    75          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  8    76 
  8    77 dcl  1 scs$cow_ptrs (0:7) external aligned,		/* Pointers to COW's */
  8    78        2 rel_cow_ptr bit (18) unal,			/* Relative pointer to COW */
  8    79        2 pad bit (12) unal,
  8    80        2 tag bit (6) unal;				/* Better be zero. */
  8    81 
  8    82 dcl  1 scs$reconfig_general_cow aligned external,		/* Used during reconfig ops. */
  8    83        2 pad bit (36) aligned,
  8    84        2 cow,					/* Connect operand word, in odd location. */
  8    85          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  8    86          3 mbz1 bit (13) unaligned,
  8    87          3 expander_command bit (3) unaligned,		/* Expander command. */
  8    88          3 mbz2 bit (9) unaligned,
  8    89          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  8    90 
  8    91 /* MASKS and PATTERNS */
  8    92 
  8    93 dcl  scs$sys_level bit (72) aligned ext;		/* mask used while handling I/O interrupts */
  8    94 dcl  scs$open_level bit (72) aligned ext;		/* mask used during normal operation */
  8    95 dcl  scs$processor_start_mask bit (72) aligned ext;	/* mask used when starting up a CPU */
  8    96 dcl  scs$cpu_test_mask bit (72) aligned ext;		/* mask used for ISOLTS CPU testing */
  8    97 dcl  scs$number_of_masks fixed bin ext;			/* number of masks (starting at sys_level) */
  8    98 dcl  scs$processor_start_pattern bit (36) aligned ext;	/* SMIC pattern used to send processor start interrupt */
  8    99 dcl  scs$cpu_test_pattern bit (36) aligned ext;		/* SMIC pattern used for ISOLTS processor testing */
  8   100 
  8   101 /* CAM and CACHE clear info */
  8   102 
  8   103 dcl  scs$cam_pair fixed bin (71) ext;			/* instructions XEDd when CAMing and clearing CACHE */
  8   104 dcl  scs$cam_wait bit (8) aligned ext;			/* Used when evicting pages from main memory */
  8   105 
  8   106 /* MASKING INSTRUCTIONS & POINTERS */
  8   107 
  8   108 dcl  scs$set_mask (0:7) bit (36) aligned ext;		/* instructions to set mask (STAQ or SMCM) */
  8   109 dcl  scs$read_mask (0:7) bit (36) aligned ext;		/* instructions to read mask (LDAQ or RMCM) */
  8   110 dcl  scs$mask_ptr (0:7) ptr unaligned ext;		/* pointers for real or simulated masks */
  8   111 
  8   112 /* MISCELLANEOUS */
  8   113 
  8   114 dcl  1 scs$processor_test_data aligned ext,		/* info used for cpu testing */
  8   115        (
  8   116        2 active bit (1),				/* = "1"b if cpu currently under test */
  8   117        2 scu_state bit (2),				/* state of scu being used for testing (see definition below) */
  8   118        2 pad1 bit (4),
  8   119        2 req_mem fixed bin (10),			/* dedicated memory required to test this cpu */
  8   120        2 cpu_tag fixed bin (5),			/* tag of cpu under test */
  8   121        2 scu_tag fixed bin (5),			/* tag of scu being used for cpu testing */
  8   122        2 mask_cpu fixed bin (5)
  8   123        ) unaligned;					/* tag of active cpu that has mask asigned to above scu */
  8   124 
  8   125 /* scu_state = "00"b => SCU defined by scs$processor_test_data.scu_tag not yet effected */
  8   126 /* scu_state = "01"b => all core removed from SCU, port mask not yet changed */
  8   127 /* scu_state = "10"b => all core removed from SCU, port mask changed */
  8   128 /* scu_state = "11"b => only 64k at base of SCU being used for testing, original port mask restored */
  8   129 
  8   130 dcl  scs$idle_aptep (0:7) ptr unaligned ext;		/* pointer to idle process APTE for each processor */
  8   131 
  8   132 dcl  scs$connect_lock bit (36) aligned ext;		/* lock for sending connects */
  8   133 dcl  scs$reconfig_lock bit (36) aligned ext;		/* Lock used during reconfiguration */
  8   134 dcl  scs$trouble_flags bit (8) aligned ext;		/* checkoff flags for sys_trouble stopping */
  8   135 dcl  scs$bos_restart_flags bit (8) aligned ext;		/* checkoff flags for restarting after sys_trouble */
  8   136 dcl  scs$nprocessors fixed bin ext;			/* number of runnung processors */
  8   137 dcl  scs$bos_processor_tag fixed bin (3) ext;		/* CPU tag of processor running BOS */
  8   138 dcl  scs$faults_initialized bit (1) aligned ext;		/* ON after faults have been enabled */
  8   139 dcl  scs$sys_trouble_pending bit (1) aligned ext;		/* sys_trouble event is pending in the system */
  8   140 dcl  scs$fast_cam_pending (0:7) bit (36) aligned ext;	/* checkoff cells for cam connect		*/
  8   141 dcl  scs$interrupt_controller fixed bin (3) ext;		/* port number of low order controller */
  8   142 dcl  scs$processor_start_int_no fixed bin (5) ext;	/* interrupt cell for starting a processor */
  8   143 dcl  scs$processor bit (8) aligned ext;			/* bits ON for online CPUs */
  8   144 dcl  scs$processor_start_wait bit (8) aligned ext;	/* checkoff flags for waiting for new processor */
  8   145 
  8   146 dcl  scs$trouble_dbrs (0:7) fixed bin (71);		/* DBR values at system crash time */
  8   147 
  8   148 dcl  scs$port_addressing_word (0:7) bit (3) aligned ext;	/* active module port number for each controller */
  8   149 
  8   150 dcl  scs$cfg_data (0:7) fixed bin (71) aligned ext;	/* RSCR-CFG data from each controller */
  8   151 
  8   152 dcl  scs$cfg_data_save fixed bin (71) aligned ext;	/* RSCR-CFG save area for ISOLTS CPU testing */
  8   153 
  8   154 dcl  scs$expanded_ports bit (1) unaligned dim (0:7) external;
  8   155 						/* Which ports have expanders */
  8   156 
  8   157 dcl  scs$processor_switch_data (0:4) bit (36) aligned ext;	/* raw data from RSW 0 thru 4 */
  8   158 dcl  scs$processor_switch_template (0:4) bit (36) aligned ext; /* expected data from RSW 0 thru 4 */
  8   159 dcl  scs$processor_switch_compare (0:4) bit (36) aligned ext; /* discrepancies from expected data */
  8   160 dcl  scs$processor_switch_mask (0:4) bit (36) aligned ext;	/* masks for comparing switch data */
  8   161 
  8   162 dcl  scs$processor_data_switch_value bit (36) aligned ext;	/* Correct value for CPU data switches */
  8   163 
  8   164 dcl  scs$controller_config_size (0:7) fixed bin (14) aligned ext;
  8   165 						/* Controller size on config card */
  8   166 
  8   167 dcl  scs$reconfig_locker_id char (32) aligned ext;	/* process group ID of process doing reconfiguration */
  8   168 
  8   169 dcl  scs$scas_page_table (0:31) bit (36) aligned external static;
  8   170 						/* PTWs for SCAS pages */
  8   171 
  8   172 dcl  scs$cycle_priority_template bit (7) aligned ext;	/* template for setting anti-hog switches	*/
  8   173 dcl  scs$set_cycle_switches bit (1) aligned ext;		/* flag to set ant-hog switches		*/
  8   174 
  8   175 
  8   176 dcl  (
  8   177      IOM_PORT init (1),
  8   178      CPU_PORT init (2),
  8   179      BULK_PORT init (3)
  8   180      ) fixed bin int static options (constant);		/* values for scs$port_data.assigned		*/
  8   181 
  8   182 
  8   183 /* END INCLUDE FILE scs.incl.pl1 */
      521 
  9     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  9     2 
  9     3 dcl  sdwp ptr;
  9     4 
  9     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  9     6 
  9     7    (2 add bit (24),					/* main memory address of page table */
  9     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  9     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  9    10     2 df_no bit (2),				/* directed fault number */
  9    11 
  9    12     2 pad1 bit (1),
  9    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  9    14     2 access,					/* access bits */
  9    15       3 read bit (1),				/* read permission bit */
  9    16       3 execute bit (1),				/* execute permission bit */
  9    17       3 write bit (1),				/* write permission bit */
  9    18       3 privileged bit (1),				/* privileged bit */
  9    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  9    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  9    21     2 cache bit (1),				/* cache enable bit */
  9    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  9    23 
  9    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  9    25 
  9    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      522 
 10     1 /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
 10     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
 10     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
 10     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
 10     5 
 10     6 dcl  sst_seg$ external;
 10     7 dcl  sstp ptr;
 10     8 
 10     9 dcl 1 sst based (sstp) aligned,
 10    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
 10    11 
 10    12 /* SST HEADER */
 10    13 
 10    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
 10    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
 10    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
 10    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
 10    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
 10    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
 10    20 
 10    21     2 ptl bit (36),					/* global page table loop lock */
 10    22     2 astl bit (36),				/* global ast allocation block lock */
 10    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
 10    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
 10    25     2 nused fixed bin,				/* number of pages on used list */
 10    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
 10    27     2 tfreep ptr,					/* pointer to first trailer on free list */
 10    28 
 10    29     2 astap ptr,					/* aste array pointer */
 10    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
 10    31     2 astsize fixed bin,				/* size of an AST entry */
 10    32     2 cmesize fixed bin,				/* size of a CME entry */
 10    33     2 root_astep ptr,				/* pointer to the root AST entry */
 10    34 
 10    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
 10    36     2 level (0:3),					/* per-list information about ASTE's */
 10    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
 10    38 
 10    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
 10    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
 10    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
 10    42     2 strsize fixed bin,				/* Trailer size in words. */
 10    43 
 10    44 /* CORE MAP HEADER */
 10    45 
 10    46     2 cmp ptr,					/* pointer to start of core map */
 10    47     2 usedp bit (18),				/* pointer to first used core block */
 10    48     2 wtct fixed bin,				/* count of pages being written */
 10    49 
 10    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
 10    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
 10    52 						/* MISC */
 10    53 
 10    54     2 double_write fixed bin,				/* trigger for store through scheme */
 10    55 						/* 0 = no double writes,
 10    56*						   1 = all non-pd pages get written,
 10    57*						   2 = all directories get written */
 10    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
 10    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
 10    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
 10    61 
 10    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
 10    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
 10    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
 10    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
 10    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
 10    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
 10    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
 10    69 
 10    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
 10    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
 10    72 
 10    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
 10    74 
 10    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
 10    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
 10    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
 10    78 
 10    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
 10    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
 10    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
 10    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
 10    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
 10    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
 10    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
 10    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
 10    87 
 10    88 
 10    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
 10    90 
 10    91     2 steps fixed bin,				/* number of steps taken around used list */
 10    92     2 needc fixed bin,				/* number of times core page needed */
 10    93     2 ceiling fixed bin,				/* number of times ceiling hit */
 10    94     2 ctwait fixed bin,				/* number of times write counter was full */
 10    95     2 wired fixed bin,				/* number of pages wired by pc */
 10    96     2 laps fixed bin,				/* number of times around used list */
 10    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
 10    98     2 skipu fixed bin,				/* because of being used */
 10    99 
 10   100     2 skipm fixed bin,				/* because of being modified */
 10   101     2 skipos fixed bin,				/* because out of service */
 10   102     2 aused fixed bin,				/* number of AST entries on used list */
 10   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
 10   104     2 deact_count fixed bin,				/* count of deactivations */
 10   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
 10   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
 10   107 
 10   108     2 reads (8) fixed bin,				/* number of reads for each did */
 10   109     2 writes (8) fixed bin,				/* number of writes for each did */
 10   110 
 10   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
 10   112     2 loop_locks fixed bin,				/* count of times locked PTL */
 10   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
 10   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
 10   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
 10   116     2 total_sf fixed bin,				/* total number of seg_faults */
 10   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
 10   118     2 post_list_size fixed bin,
 10   119     2 post_purgings fixed bin,			/* total number of post-purgings */
 10   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
 10   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
 10   122     2 pre_page_list_size fixed bin,
 10   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
 10   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
 10   125 
 10   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
 10   127 
 10   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
 10   129 
 10   130 /* MAIN MEMORY USAGE INFORMATION */
 10   131 
 10   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
 10   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
 10   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
 10   135     2 recopies fixed bin,				/* number of times recopied because modified */
 10   136     2 first_core_block fixed bin,			/* core map index for first block of core */
 10   137     2 last_core_block fixed bin,			/* core map index for last block of core */
 10   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
 10   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
 10   140 
 10   141 /*  AST METERS  */
 10   142 
 10   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
 10   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
 10   145 
 10   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
 10   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
 10   148     2 asearches fixed bin,				/* count of full searches made */
 10   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
 10   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
 10   151     2 acost fixed bin,				/* cumulative cost of deactivations */
 10   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
 10   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
 10   154 
 10   155     2 alaps fixed bin,				/* lap counter for AST list */
 10   156     2 updates fixed bin,				/* calls to updateb */
 10   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
 10   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
 10   159     2 total_bf fixed bin,				/* count of bound faults */
 10   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
 10   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
 10   162 
 10   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
 10   164 
 10   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
 10   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
 10   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
 10   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
 10   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
 10   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
 10   171 
 10   172 /* PRE-PAGE METERS */
 10   173 
 10   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
 10   175 
 10   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
 10   177 
 10   178 
 10   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
 10   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
 10   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
 10   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
 10   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
 10   184     2 claim_passed_used fixed bin,			/* Times used page seen */
 10   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
 10   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
 10   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
 10   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
 10   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
 10   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
 10   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
 10   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
 10   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
 10   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
 10   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
 10   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
 10   197     2 good_sgms fixed bin,				/* Seg moves that completed */
 10   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
 10   199     2 activations fixed bin,				/* total count of activations */
 10   200     2 dir_activations fixed bin,			/* count of directory activations */
 10   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
 10   202     2 hedge_writes fixed bin,				/* call in core flush writes */
 10   203     2 evict_recover_data,				/* see evict_page.alm */
 10   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
 10   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
 10   206 
 10   207 /* Data for metering force_write facility 08/19/78 */
 10   208 
 10   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
 10   210     2 force_pwrites fixed bin,			/* Mod pages so written */
 10   211     2 fw_none fixed bin,				/* Force write wrote none */
 10   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
 10   213 
 10   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
 10   215     2 pf_unlock_ptl_meterings fixed bin,
 10   216 
 10   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
 10   218     2 backup_activations fixed bin (35),		/* activations for backup */
 10   219     2 metering_flags aligned,				/* small chunks of misc. information */
 10   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
 10   221       3 pad bit (35) unal,
 10   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
 10   223 
 10   224 /* METERS FOR STACK TRUNCATION */
 10   225 
 10   226     2 (stk_truncate_should_didnt,			/* counts */
 10   227        stk_truncate_should_did,
 10   228        stk_truncate_shouldnt_didnt,
 10   229        stk_truncate_shouldnt_did) fixed bin (35),
 10   230     2 stk_pages_truncated fixed bin (35),
 10   231     2 stk_pages_truncated_in_core fixed bin (35),
 10   232 
 10   233 /* SUPPORT FOR PC SEGMOVES */
 10   234 
 10   235     2 segmove_lock aligned,
 10   236       3 pid bit (36) aligned,
 10   237       3 event bit (36) aligned,
 10   238       3 notify bit (1) aligned,
 10   239     2 segmove_io_limit fixed bin, /* max read aheads */
 10   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
 10   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
 10   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
 10   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
 10   244 
 10   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
 10   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
 10   247     2 segmove_vtocx fixed bin,			/* ditto */
 10   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
 10   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
 10   250 
 10   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
 10   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
 10   253     2 trace_sw aligned,				/* tracing control flags */
 10   254       3 pad_trace bit (32) unaligned,
 10   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
 10   256       3 tty_trace bit (1) unaligned,
 10   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
 10   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
 10   259     2 new_pages fixed bin,				/* newly created pages */
 10   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
 10   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
 10   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
 10   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
 10   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
 10   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
 10   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
 10   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
 10   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
 10   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
 10   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
 10   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
 10   272 
 10   273 /* END INCLUDE FILE sst.incl.pl1 */
      523 
 11     1 
 11     2 /*  BEGIN INCLUDE FILE ... str.incl.pl1 ... last modified March 1970 */
 11     3 
 11     4 dcl str_seg$ ext,
 11     5     strp ptr;
 11     6 
 11     7 dcl 1 str based (strp) aligned,		/* segment or process trailer declaration */
 11     8 
 11     9    (2 fp bit (18),				/* forward ast trailer rel pointer */
 11    10     2 bp bit (18),				/* backward ast trailer rel pointer*/
 11    11 
 11    12     2 segno bit (18),			/* segment number*/
 11    13     2 dstep bit (18)) unaligned;		/* rel pointer to ring 0 dste */
 11    14  
 11    15 dcl stra (0:8000) bit (72) based (strp) aligned;
 11    16 
 11    17 /*  END INCLUDE FILE ... str.incl.pl1 */
 11    18 
      524 
 12     1 /* BEGIN include file unpaged_page_tables.incl.pl1 */
 12     2 
 12     3 /* This include file describes the segments unpaged_page_tables and
 12     4*int_unpaged_page_tables.  These segments contain the page tables for
 12     5*segments that are paged and wired, those segments previously called
 12     6*unpaged.
 12     7*
 12     8*Written September 15, 1983 by Keith Loepere. */
 12     9 
 12    10 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
 12    11 
 12    12 dcl  upt_ptr		        ptr;
 12    13 dcl  1 upt		        aligned based (upt_ptr),
 12    14        2 sst_absloc		        fixed bin (26),	/* for dump analyzers */
 12    15        2 sst_last_loc	        fixed bin (26),
 12    16        2 upt_absloc		        fixed bin (26),
 12    17        2 upt_last_loc	        fixed bin (26),
 12    18        2 iupt_absloc	        fixed bin (26),
 12    19        2 iupt_last_loc	        fixed bin (26),
 12    20 
 12    21        2 current_length	        fixed bin,		/* number of words currently used */
 12    22        2 max_length		        fixed bin,		/* max number of words in memory allocated */
 12    23        2 first_entry	        like upt_entry;
 12    24 
 12    25 dcl  upt_entry_ptr		        ptr;
 12    26 dcl  1 upt_entry		        aligned based (upt_entry_ptr),
 12    27        2 size		        fixed bin,		/* number of page table words allocated */
 12    28        2 segno		        fixed bin,		/* of hardcore segment */
 12    29        2 ptws		        (0 refer (upt_entry.size)) bit (36) aligned;
 12    30 
 12    31 /* END include file unpaged_page_tables.incl.pl1 */
      525 
      526 
      527      end azm_dump_mem_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/17/00  1920.1  azm_dump_mem_.pl1                 >udd>sm>ds>w>ml>azm_dump_mem_.pl1
514          1    09/22/83  1202.5  amu_fdump_info.incl.pl1           >ldd>incl>amu_fdump_info.incl.pl1
515          2    11/20/84  0954.8  amu_hardcore_info.incl.pl1        >ldd>incl>amu_hardcore_info.incl.pl1
516          3    11/20/84  0956.1  amu_info.incl.pl1                 >ldd>incl>amu_info.incl.pl1
517          4    01/30/85  1623.9  aste.incl.pl1                     >ldd>incl>aste.incl.pl1
518          5    08/12/81  2125.8  bos_dump.incl.pl1                 >ldd>incl>bos_dump.incl.pl1
519          6    11/23/82  1053.7  cmp.incl.pl1                      >ldd>incl>cmp.incl.pl1
520          7    05/03/78  1522.1  ptw.incl.pl1                      >ldd>incl>ptw.incl.pl1
521          8    10/12/83  1043.5  scs.incl.pl1                      >ldd>incl>scs.incl.pl1
522          9    09/14/76  0859.8  sdw.incl.pl1                      >ldd>incl>sdw.incl.pl1
523         10    01/30/85  1623.9  sst.incl.pl1                      >ldd>incl>sst.incl.pl1
524         11    05/06/74  1851.6  str.incl.pl1                      >ldd>incl>str.incl.pl1
525         12    07/11/84  1037.3  unpaged_page_tables.incl.pl1      >ldd>incl>unpaged_page_tables.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_abs_w                                parameter       bit(1)                   packed unaligned dcl 18 set ref 6 141* 244*
P_address                              parameter       fixed bin(24,0)          dcl 18 ref 6 140
P_amu_info_ptr                         parameter       pointer                  dcl 18 ref 6 126 131 138
P_code                                 parameter       fixed bin(35,0)          dcl 18 set ref 6 126 153* 159* 172* 217* 230* 239*
                                                                                  251* 260* 272* 287* 299* 307* 312* 321* 326* 336*
                                                                                  345* 353* 362* 373* 382* 389* 397* 421* 441* 456*
P_indx                                 parameter       fixed bin(17,0)          dcl 18 set ref 6 270* 286* 390* 439* 455*
P_offset                               parameter       fixed bin(18,0)          dcl 18 set ref 6 269* 285* 393* 438* 454*
P_paged                                parameter       bit(1)                   packed unaligned dcl 18 set ref 6 142* 271* 440*
P_scu                                  parameter       fixed bin(17,0)          dcl 18 set ref 6 243*
P_segno                                parameter       fixed bin(17,0)          dcl 18 set ref 6 268* 284* 391* 437* 453*
abs_w                     1(28)        based           bit(1)                   level 2 packed packed unaligned dcl 6-6 ref 244
active_seg_table                000155 automatic       structure                level 1 packed packed unaligned dcl 70 set ref 317
add                                    based           bit(18)                  level 2 in structure "ptw" packed packed unaligned
                                                                                  dcl 7-5 in procedure "azm_dump_mem_" ref 452
add                                    based           bit(18)                  array level 2 in structure "ptwa" packed packed
                                                                                  unaligned dcl 7-23 in procedure "azm_dump_mem_"
                                                                                  ref 282
add                                    based           bit(24)                  level 2 in structure "sdw" packed packed unaligned
                                                                                  dcl 9-5 in procedure "azm_dump_mem_" ref 255 263
                                                                                  432
add_ptw                         000101 automatic       fixed bin(24,0)          dcl 31 set ref 282* 283 283
add_sdw                                parameter       fixed bin(24,0)          dcl 475 in procedure "get_ptp" ref 471 490 493 496
                                                                                  496 501 501
add_sdw                         000100 automatic       fixed bin(24,0)          dcl 31 in procedure "azm_dump_mem_" set ref 263* 266
                                                                                  267 269 279* 432* 436 436 438 447
addr                                                   builtin function         dcl 101 ref 150 209 228 228 236 248 303 317 342 371
                                                                                  371 426
addrel                                                 builtin function         dcl 101 ref 430 447 449 459 494 499 504 509
amu_$definition_ptr             000010 constant        entry                    external dcl 87 ref 151 215 360
amu_$do_translation             000012 constant        entry                    external dcl 88 ref 228 237 249 258 305 319 343 351
                                                                                  380
amu_$do_translation_by_ptr      000014 constant        entry                    external dcl 89 ref 157 371
amu_$do_translation_hunt_ptr    000016 constant        entry                    external dcl 90 ref 419
amu_$fdump_mpt_change_idx       000020 constant        entry                    external dcl 91 ref 370 394 400 418 422 466
amu_$hardcore_info_set_cur_ptrs 000022 constant        entry                    external dcl 92 ref 210
amu_$return_val_per_process     000024 constant        entry                    external dcl 93 ref 359
amu_$slt_search_seg_num         000026 constant        entry                    external dcl 94 ref 334
amu_et_$free_core               000034 external static fixed bin(35,0)          dcl 97 ref 299 312
amu_et_$non_existant_mem        000036 external static fixed bin(35,0)          dcl 98 ref 172
amu_et_$proc_not_dumped         000040 external static fixed bin(35,0)          dcl 99 ref 326 389
amu_info                               based           structure                level 1 dcl 3-3
amu_info_ptr                    000410 automatic       pointer                  dcl 3-45 set ref 131* 138* 151* 157* 210* 215* 228*
                                                                                  237* 247 249* 257 258* 270 286 305* 319* 343* 351*
                                                                                  358 359* 360* 365 369 370* 371* 380* 390 394* 400*
                                                                                  412 413 417 418* 419* 419 419 422* 426 439 455
                                                                                  466*
array                     1            based           structure                array level 2 dcl 1-23 set ref 369 417 426
aste                                   based           structure                level 1 dcl 4-11 ref 318
aste_size                       000102 automatic       fixed bin(18,0)          dcl 31 set ref 318* 319* 392
astep                           000412 automatic       pointer                  dcl 4-9 in procedure "azm_dump_mem_" set ref 317*
                                                                                  318 319* 325 340 449* 450
astep                     2(18)        based           bit(18)                  level 2 in structure "cme" packed packed unaligned
                                                                                  dcl 6-6 in procedure "azm_dump_mem_" ref 316 392
astsize                  33            based           fixed bin(17,0)          level 2 dcl 10-9 ref 449
atptw                                  based           structure                level 1 dcl 7-35
base                            000262 automatic       fixed bin(17,0)          array level 2 in structure "mem_conf_data" dcl 80
                                                                                  in procedure "azm_dump_mem_" set ref 186* 193 193
base                      0(18) 000171 automatic       fixed bin(17,0)          array level 2 in structure "contr_data" packed
                                                                                  packed unaligned dcl 71 in procedure
                                                                                  "azm_dump_mem_" set ref 165 165 182 186
baseno                                                 builtin function         dcl 101 ref 221 235
baseptr                                                builtin function         dcl 101 ref 419 419
bd_sdw                          000103 automatic       fixed bin(24,0)          dcl 31 set ref 264* 267 278 433* 448
bound                     1(01)        based           bit(14)                  level 2 packed packed unaligned dcl 9-5 ref 264 433
                                                                                  435
bp                        0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 11-7 ref 349 350
cme                                    based           structure                level 1 dcl 6-6
cme_size                        000110 automatic       fixed bin(18,0)          dcl 31 set ref 224* 234 237*
cmep                            000416 automatic       pointer                  dcl 6-4 set ref 236* 237* 243 244 296 304 316 392
                                                                                  392
code                            000104 automatic       fixed bin(35,0)          dcl 31 set ref 146* 151* 152 153 157* 158 159 215*
                                                                                  216 217 228* 229 230 237* 238 239 249* 250 251
                                                                                  258* 259 260 305* 306 307 319* 320 321 334* 335
                                                                                  336 343* 344 345 351* 352 353 360* 361 362 371*
                                                                                  372 373 380* 381 382 397 419* 420 421
contr                     1(33)        based           bit(3)                   level 2 packed packed unaligned dcl 6-6 ref 243
contr_data                      000171 automatic       structure                array level 1 unaligned dcl 71 set ref 150 157 157
contr_ptr                       000106 automatic       pointer                  dcl 31 set ref 150* 157*
core_map                        000231 automatic       structure                level 1 packed packed unaligned dcl 72 set ref 236
csl                      12            based           bit(9)                   level 2 packed packed unaligned dcl 4-11 ref 450
data                      1     000262 automatic       char(32)                 array level 2 packed packed unaligned dcl 80 set ref
                                                                                  184* 201*
df                        0(33)        based           bit(1)                   level 2 in structure "sdw" packed packed unaligned
                                                                                  dcl 9-5 in procedure "azm_dump_mem_" ref 431
df                        0(33)        based           bit(1)                   level 2 in structure "ptw" packed packed unaligned
                                                                                  dcl 7-5 in procedure "azm_dump_mem_" ref 311 451
df                        0(33)        based           bit(1)                   array level 2 in structure "ptwa" packed packed
                                                                                  unaligned dcl 7-23 in procedure "azm_dump_mem_"
                                                                                  ref 281
divide                                                 builtin function         dcl 101 ref 143 268 278 284 428 437 448
dseg                     17            based           fixed bin(15,0)          level 3 dcl 2-6 ref 247 419 419
dseg_no                         000111 automatic       fixed bin(17,0)          dcl 31 set ref 247* 249* 258*
dsegp                           000452 automatic       pointer                  dcl 411 set ref 419* 430
dstep                     1(18)        based           bit(18)                  level 2 packed packed unaligned dcl 11-7 ref 376
dump                                   based           structure                level 1 dcl 5-11
dump_header                            based           structure                level 1 dcl 5-47
dump_misc_registers                    based           structure                level 1 dcl 5-69
dump_registers                         based           structure                level 1 dcl 5-59
dump_seg_ptr            106            based           pointer                  array level 2 dcl 1-3 ref 413
dumpptr                         000414 automatic       pointer                  dcl 5-9 set ref 413* 427
fdump_info                             based           structure                level 1 dcl 1-3
fdump_info_ptr           14            based           pointer                  level 2 dcl 3-3 ref 369 413 417 426
fdump_process_table                    based           structure                level 1 dcl 1-23
fdump_process_table_ptr
                        246            based           pointer                  level 2 dcl 1-3 ref 369 417 426
first_seg                              based           fixed bin(17,0)          level 2 dcl 1-28 ref 427
fixed                                                  builtin function         dcl 101 ref 221 223 234 235 243 255 263 264 282 304
                                                                                  316 340 350 359 359 379 391 392 392 427 432 433
                                                                                  435 447 450 452 490
fp                                     based           bit(18)                  level 2 packed packed unaligned dcl 11-7 ref 378 379
fp_table                               based           structure                level 1 unaligned dcl 1-28
fp_table_ptr                    000404 automatic       pointer                  dcl 1-38 set ref 426* 427
hard_cur                        000236 automatic       structure                level 1 unaligned dcl 73 set ref 209
hardcore_cur                           based           structure                level 1 unaligned dcl 2-40
hardcore_cur_ptr                000406 automatic       pointer                  dcl 2-38 set ref 209* 210* 211 414 489
hardcore_info                          based           structure                level 1 dcl 2-6
hardcore_info_ptr        16            based           pointer                  level 2 dcl 3-3 ref 247 257 419 419
hbound                                                 builtin function         dcl 101 ref 369 417
hcs_count                30            based           fixed bin(17,0)          level 2 dcl 2-6 ref 257
i                               000112 automatic       fixed bin(18,0)          dcl 31 set ref 164* 165 165 165 165* 180* 181 182
                                                                                  183 184 184 186* 192* 193 195 196* 200* 201* 257*
                                                                                  258* 268 284* 429* 430 437 453*
ignore                          000113 automatic       fixed bin(21,0)          dcl 31 set ref 184*
info                      2     000171 automatic       structure                array level 2 dcl 71
ioa_                            000030 constant        entry                    external dcl 95 ref 177 201
ioa_$rsnnl                      000032 constant        entry                    external dcl 95 ref 184
iupt_absloc               4            based           fixed bin(26,0)          level 2 dcl 12-13 ref 501 503
iupt_last_loc             5            based           fixed bin(26,0)          level 2 dcl 12-13 ref 501
j                               000114 automatic       fixed bin(18,0)          dcl 31 set ref 179* 184 186 187* 187 190* 190 191
                                                                                  192 200 280* 281 282 285* 435* 436 450* 454*
k                               000115 automatic       fixed bin(17,0)          dcl 31 set ref 191* 192 193 194 195* 417* 418* 426*
last_seg                        000451 automatic       fixed bin(35,0)          dcl 410 set ref 427* 428* 428 429
length                   20(18)        based           bit(18)                  array level 3 packed packed unaligned dcl 5-11 ref
                                                                                  427
loop_exit                       000116 automatic       bit(1)                   packed unaligned dcl 31 set ref 367* 369 376* 378
                                                                                  388* 389
mem_address                     000117 automatic       fixed bin(24,0)          dcl 31 set ref 132* 140* 143 144 266 267 269 283 283
                                                                                  415 436 436 438 454
mem_base                        000120 automatic       fixed bin(24,0)          dcl 31 set ref 182* 183 184*
mem_conf_data                   000262 automatic       structure                array level 1 unaligned dcl 80 set ref 194 195* 195
                                                                                  196*
mem_config                      000123 automatic       bit(1)                   packed unaligned dcl 31 set ref 149* 164 165* 171
mem_config_sw                   000121 automatic       bit(1)                   initial packed unaligned dcl 31 set ref 31* 130* 163
                                                                                  176
mem_max                         000122 automatic       fixed bin(24,0)          dcl 31 set ref 183* 184*
mod                                                    builtin function         dcl 101 ref 144 454
null                                                   builtin function         dcl 101 ref 492
off18                           000450 automatic       fixed bin(18,0)          initial dcl 409 set ref 409* 415 452
offset                          000124 automatic       fixed bin(18,0)          dcl 31 set ref 223* 228* 234* 237* 304* 305* 316*
                                                                                  319* 340* 343* 350* 351* 379* 380*
online                    2     000171 automatic       bit(1)                   array level 3 packed packed unaligned dcl 71 set ref
                                                                                  165 181
page_no                         000130 automatic       fixed bin(18,0)          dcl 31 set ref 133* 143* 165 165 234 392* 393
page_table_word                 000254 automatic       structure                level 1 packed packed unaligned dcl 76 set ref 303
pds_dstep                       000126 automatic       pointer                  dcl 31 set ref 360* 371*
pointer                                                builtin function         dcl 101 ref 419 419
pointers                               based           structure                level 2 dcl 2-6
process_idx              24            based           fixed bin(17,0)          level 2 dcl 3-3 ref 270 286 358 365 390 412 439 455
pt_size                         000131 automatic       fixed bin(18,0)          dcl 31 set ref 278* 280 448*
ptp                             000420 automatic       pointer                  dcl 7-3 in procedure "azm_dump_mem_" set ref 279*
                                                                                  281 282 303* 305* 311 447* 449 451 452 459* 459
ptp                                    parameter       pointer                  dcl 476 in procedure "get_ptp" set ref 471 494* 499*
                                                                                  504* 509*
ptw                                    based           structure                level 1 dcl 7-5
ptwa                                   based           structure                array level 1 dcl 7-23
ptwbase                  25            based           fixed bin(24,0)          level 2 dcl 10-9 ref 447
ptwp                      2            based           bit(18)                  level 2 packed packed unaligned dcl 6-6 ref 296 304
                                                                                  392
rel                                                    builtin function         dcl 101 ref 223 234
relative_offset                 000466 automatic       fixed bin(26,0)          dcl 484 set ref 493* 494 498* 499 503* 504 508* 509
save_process_index              000132 automatic       fixed bin(17,0)          dcl 31 set ref 358* 365* 394* 400* 412* 422* 466*
scs$controller_data             000042 external static structure                array level 1 dcl 8-6
sdw                                    based           structure                level 1 dcl 9-5
sdw_add                         000467 automatic       fixed bin(26,0)          dcl 485 set ref 490* 498 503 508
sdwp                            000422 automatic       pointer                  dcl 9-3 set ref 248* 249* 255 258* 263 264 265 430*
                                                                                  431 432 433 434 435
seg_desc                        000256 automatic       structure                level 1 packed packed unaligned dcl 77 set ref 248
seg_name                        000133 automatic       char(32)                 packed unaligned dcl 31 set ref 333* 334*
seg_no                          000143 automatic       fixed bin(17,0)          dcl 31 set ref 221* 222 228* 235* 237*
seg_trailer                     000260 automatic       structure                level 1 packed packed unaligned dcl 78 set ref 342
segno                    16            based           structure                level 2 in structure "hardcore_info" dcl 2-6
                                                                                  in procedure "azm_dump_mem_"
segno                     1            based           bit(18)                  level 2 in structure "str" packed packed unaligned
                                                                                  dcl 11-7 in procedure "azm_dump_mem_" ref 359 359
                                                                                  391
segs                     20            based           structure                array level 2 dcl 5-11
size                            000171 automatic       fixed bin(17,0)          array level 2 in structure "contr_data" packed
                                                                                  packed unaligned dcl 71 in procedure
                                                                                  "azm_dump_mem_" set ref 165 183
size                                                   builtin function         dcl 101 in procedure "azm_dump_mem_" ref 157 157 318
                                                                                  341
size                                   based           fixed bin(17,0)          level 2 in structure "fdump_process_table" dcl 1-23
                                                                                  in procedure "azm_dump_mem_" ref 369 417
slt                                    based           structure                level 3 dcl 2-6
sltntp                    2     000236 automatic       pointer                  level 2 dcl 73 set ref 334*
sltp                            000236 automatic       pointer                  level 2 dcl 73 set ref 334*
sst                                    based           structure                level 1 dcl 10-9
sst_absloc                             based           fixed bin(26,0)          level 2 dcl 12-13 ref 508
sst_base                        000144 automatic       fixed bin(24,0)          dcl 31 set ref 255* 493
sst_ptr                         000470 automatic       pointer                  dcl 486 set ref 489* 494 509
sst_segno                       000145 automatic       fixed bin(17,0)          dcl 31 set ref 222* 249 305* 319*
sstp                      6            based           pointer                  level 2 in structure "hardcore_cur" dcl 2-40
                                                                                  in procedure "azm_dump_mem_" ref 414 489
sstp                            000424 automatic       pointer                  dcl 10-7 in procedure "azm_dump_mem_" set ref 414*
                                                                                  447 447 449
str                                    based           structure                level 1 dcl 11-7 ref 341
str_segno                       000146 automatic       fixed bin(17,0)          dcl 31 set ref 334* 343* 351* 380*
str_size                        000147 automatic       fixed bin(18,0)          dcl 31 set ref 341* 343* 351* 380*
strp                            000426 automatic       pointer                  dcl 11-4 in procedure "azm_dump_mem_" set ref 341
                                                                                  342* 343* 349 350 351* 359 359 376 378 379 380*
                                                                                  391
strp                      2            based           bit(18)                  level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 4-11 in procedure "azm_dump_mem_" ref 325 340
substr                                                 builtin function         dcl 101 set ref 184 184 415* 415
temp_conf                       000372 automatic       structure                level 1 unaligned dcl 83 set ref 194* 196
temp_dstep                      000150 automatic       bit(18)                  packed unaligned dcl 31 set ref 371 371 376
temp_indx                       000151 automatic       fixed bin(17,0)          dcl 31 set ref 369* 370*
temp_ptr                        000152 automatic       pointer                  dcl 31 set ref 151* 157* 215* 221 223 228 228 234
                                                                                  235
unpaged                   1(19)        based           bit(1)                   level 2 packed packed unaligned dcl 9-5 ref 265 434
unspec                                                 builtin function         dcl 101 ref 415 415
upt                                    based           structure                level 1 dcl 12-13
upt_absloc                2            based           fixed bin(26,0)          level 2 dcl 12-13 ref 496 498
upt_entry                              based           structure                level 1 dcl 12-26
upt_last_loc              3            based           fixed bin(26,0)          level 2 dcl 12-13 ref 496
upt_ptr                         000430 automatic       pointer                  dcl 12-12 set ref 211* 492 496 496 498 499 501 501
                                                                                  503 504 508
uptp                     14            based           pointer                  level 2 dcl 2-40 ref 211
word_no                         000154 automatic       fixed bin(17,0)          dcl 31 set ref 134* 144* 285 393

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AMU_FDUMP_INFO_VERSION                 internal static char(8)                  initial packed unaligned dcl 1-43
AMU_FDUMP_INFO_VERSION_1               internal static char(8)                  initial packed unaligned dcl 1-42
AMU_INFO_VERSION                       internal static char(8)                  initial packed unaligned dcl 3-57
AMU_INFO_VERSION_1                     internal static char(8)                  initial packed unaligned dcl 3-56
AMU_INFO_VERSION_2                     internal static char(8)                  initial packed unaligned dcl 3-58
BULK_PORT                              internal static fixed bin(17,0)          initial dcl 8-176
CPU_PORT                               internal static fixed bin(17,0)          initial dcl 8-176
DUMP_VERSION_1                         internal static fixed bin(17,0)          initial dcl 5-120
DUMP_VERSION_2                         internal static fixed bin(17,0)          initial dcl 5-121
FDUMP_PROCESS_TYPE                     internal static fixed bin(17,0)          initial dcl 3-47
FDUMP_TYPE                             internal static fixed bin(17,0)          initial dcl 3-47
INDIRECT_TYPE                          internal static fixed bin(17,0)          initial dcl 3-47
IOM_PORT                               internal static fixed bin(17,0)          initial dcl 8-176
NETWORK_FDUMP_TYPE                     internal static fixed bin(17,0)          initial dcl 3-47
NETWORK_ONLINE_TYPE                    internal static fixed bin(17,0)          initial dcl 3-47
ONLINE_PROCESS_TYPE                    internal static fixed bin(17,0)          initial dcl 3-47
ONLINE_TYPE                            internal static fixed bin(17,0)          initial dcl 3-47
PDIR_SUFFIX                            internal static char(4)                  initial packed unaligned dcl 3-60
SAVED_PROC_TYPE                        internal static fixed bin(17,0)          initial dcl 3-47
alloc_fdump_process_table_size         automatic       fixed bin(17,0)          dcl 1-40
amu_area                               based           area(1024)               dcl 3-43
asta                                   based           bit(432)                 array dcl 4-86
aste_part                              based           structure                level 1 dcl 4-89
atptwa                                 based           structure                array level 1 dcl 7-40
cma                                    based           structure                array level 1 dcl 6-30
found                                  automatic       bit(1)                   packed unaligned dcl 31
mcme                                   based           structure                level 1 dcl 6-32
mptw                                   based           structure                level 1 dcl 7-27
mptwa                                  based           structure                array level 1 dcl 7-31
pt_offset                              automatic       fixed bin(18,0)          dcl 31
ptw_a                                  automatic       structure                array level 1 packed packed unaligned dcl 74
ptw_ab                                 based           structure                array level 1 packed packed unaligned dcl 75
ptwa_bits                              based           bit(36)                  array dcl 7-25
scs$bos_processor_tag                  external static fixed bin(3,0)           dcl 8-137
scs$bos_restart_flags                  external static bit(8)                   dcl 8-135
scs$cam_pair                           external static fixed bin(71,0)          dcl 8-103
scs$cam_wait                           external static bit(8)                   dcl 8-104
scs$cfg_data                           external static fixed bin(71,0)          array dcl 8-150
scs$cfg_data_save                      external static fixed bin(71,0)          dcl 8-152
scs$connect_lock                       external static bit(36)                  dcl 8-132
scs$controller_config_size             external static fixed bin(14,0)          array dcl 8-164
scs$cow                                external static structure                array level 1 dcl 8-65
scs$cow_ptrs                           external static structure                array level 1 dcl 8-77
scs$cpu_test_mask                      external static bit(72)                  dcl 8-96
scs$cpu_test_pattern                   external static bit(36)                  dcl 8-99
scs$cycle_priority_template            external static bit(7)                   dcl 8-172
scs$expanded_ports                     external static bit(1)                   array packed unaligned dcl 8-154
scs$fast_cam_pending                   external static bit(36)                  array dcl 8-140
scs$faults_initialized                 external static bit(1)                   dcl 8-138
scs$idle_aptep                         external static pointer                  array packed unaligned dcl 8-130
scs$interrupt_controller               external static fixed bin(3,0)           dcl 8-141
scs$mask_ptr                           external static pointer                  array packed unaligned dcl 8-110
scs$nprocessors                        external static fixed bin(17,0)          dcl 8-136
scs$number_of_masks                    external static fixed bin(17,0)          dcl 8-97
scs$open_level                         external static bit(72)                  dcl 8-94
scs$port_addressing_word               external static bit(3)                   array dcl 8-148
scs$port_data                          external static structure                array level 1 dcl 8-56
scs$processor                          external static bit(8)                   dcl 8-143
scs$processor_data                     external static structure                array level 1 dcl 8-35
scs$processor_data_switch_value        external static bit(36)                  dcl 8-162
scs$processor_start_int_no             external static fixed bin(5,0)           dcl 8-142
scs$processor_start_mask               external static bit(72)                  dcl 8-95
scs$processor_start_pattern            external static bit(36)                  dcl 8-98
scs$processor_start_wait               external static bit(8)                   dcl 8-144
scs$processor_switch_compare           external static bit(36)                  array dcl 8-159
scs$processor_switch_data              external static bit(36)                  array dcl 8-157
scs$processor_switch_mask              external static bit(36)                  array dcl 8-160
scs$processor_switch_template          external static bit(36)                  array dcl 8-158
scs$processor_test_data                external static structure                level 1 dcl 8-114
scs$read_mask                          external static bit(36)                  array dcl 8-109
scs$reconfig_general_cow               external static structure                level 1 dcl 8-82
scs$reconfig_lock                      external static bit(36)                  dcl 8-133
scs$reconfig_locker_id                 external static char(32)                 dcl 8-167
scs$scas_page_table                    external static bit(36)                  array dcl 8-169
scs$set_cycle_switches                 external static bit(1)                   dcl 8-173
scs$set_mask                           external static bit(36)                  array dcl 8-108
scs$sys_level                          external static bit(72)                  dcl 8-93
scs$sys_trouble_pending                external static bit(1)                   dcl 8-139
scs$trouble_dbrs                       automatic       fixed bin(71,0)          array dcl 8-146
scs$trouble_flags                      external static bit(8)                   dcl 8-134
sdwa                                   based           structure                array level 1 dcl 9-24
seg_aste                               based           structure                level 1 dcl 4-96
seg_offset                             automatic       fixed bin(18,0)          dcl 31
sst_seg$                               external static fixed bin(17,0)          dcl 10-6
str_seg$                               external static fixed bin(17,0)          dcl 11-4
stra                                   based           bit(72)                  array dcl 11-15
upt_entry_ptr                          automatic       pointer                  dcl 12-25
v1_dump                                based           structure                level 1 dcl 5-83

NAMES DECLARED BY EXPLICIT CONTEXT.
CONFIG                          000153 constant        label                    dcl 146 ref 135
DUMP                            000127 constant        label                    dcl 138 ref 123
ERROR_EXIT                      001705 constant        label                    dcl 397 ref 374
MEM_CONF                        000314 constant        label                    dcl 177 ref 163
RET                             002215 constant        label                    dcl 466 ref 442 457
azm_dump_mem_                   000066 constant        entry                    external dcl 6
azm_dump_mem_$mem_config        000104 constant        entry                    external dcl 126
by_process_search               001717 constant        entry                    internal dcl 407 ref 327
get_ptp                         002227 constant        entry                    internal dcl 471 ref 279
next_lap                        002211 constant        label                    dcl 463 ref 436
next_str                        001514 constant        label                    dcl 367 ref 385
pt_lap                          002204 constant        label                    dcl 459 ref 451

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2544        2610    2317        2554
Length      3222    2317        44         376     224           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
azm_dump_mem_                       399 external procedure  is an external procedure.  
by_process_search                       internal procedure  shares stack frame of external procedure azm_dump_mem_.  
get_ptp                                 internal procedure  shares stack frame of external procedure azm_dump_mem_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
azm_dump_mem_            000100 add_sdw                     azm_dump_mem_
                         000101 add_ptw                     azm_dump_mem_
                         000102 aste_size                   azm_dump_mem_
                         000103 bd_sdw                      azm_dump_mem_
                         000104 code                        azm_dump_mem_
                         000106 contr_ptr                   azm_dump_mem_
                         000110 cme_size                    azm_dump_mem_
                         000111 dseg_no                     azm_dump_mem_
                         000112 i                           azm_dump_mem_
                         000113 ignore                      azm_dump_mem_
                         000114 j                           azm_dump_mem_
                         000115 k                           azm_dump_mem_
                         000116 loop_exit                   azm_dump_mem_
                         000117 mem_address                 azm_dump_mem_
                         000120 mem_base                    azm_dump_mem_
                         000121 mem_config_sw               azm_dump_mem_
                         000122 mem_max                     azm_dump_mem_
                         000123 mem_config                  azm_dump_mem_
                         000124 offset                      azm_dump_mem_
                         000126 pds_dstep                   azm_dump_mem_
                         000130 page_no                     azm_dump_mem_
                         000131 pt_size                     azm_dump_mem_
                         000132 save_process_index          azm_dump_mem_
                         000133 seg_name                    azm_dump_mem_
                         000143 seg_no                      azm_dump_mem_
                         000144 sst_base                    azm_dump_mem_
                         000145 sst_segno                   azm_dump_mem_
                         000146 str_segno                   azm_dump_mem_
                         000147 str_size                    azm_dump_mem_
                         000150 temp_dstep                  azm_dump_mem_
                         000151 temp_indx                   azm_dump_mem_
                         000152 temp_ptr                    azm_dump_mem_
                         000154 word_no                     azm_dump_mem_
                         000155 active_seg_table            azm_dump_mem_
                         000171 contr_data                  azm_dump_mem_
                         000231 core_map                    azm_dump_mem_
                         000236 hard_cur                    azm_dump_mem_
                         000254 page_table_word             azm_dump_mem_
                         000256 seg_desc                    azm_dump_mem_
                         000260 seg_trailer                 azm_dump_mem_
                         000262 mem_conf_data               azm_dump_mem_
                         000372 temp_conf                   azm_dump_mem_
                         000404 fp_table_ptr                azm_dump_mem_
                         000406 hardcore_cur_ptr            azm_dump_mem_
                         000410 amu_info_ptr                azm_dump_mem_
                         000412 astep                       azm_dump_mem_
                         000414 dumpptr                     azm_dump_mem_
                         000416 cmep                        azm_dump_mem_
                         000420 ptp                         azm_dump_mem_
                         000422 sdwp                        azm_dump_mem_
                         000424 sstp                        azm_dump_mem_
                         000426 strp                        azm_dump_mem_
                         000430 upt_ptr                     azm_dump_mem_
                         000450 off18                       by_process_search
                         000451 last_seg                    by_process_search
                         000452 dsegp                       by_process_search
                         000466 relative_offset             get_ptp
                         000467 sdw_add                     get_ptp
                         000470 sst_ptr                     get_ptp

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mdfx1               ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$definition_ptr           amu_$do_translation           amu_$do_translation_by_ptr    amu_$do_translation_hunt_ptr
amu_$fdump_mpt_change_idx     amu_$hardcore_info_set_cur_ptrs                             amu_$return_val_per_process
amu_$slt_search_seg_num       ioa_                          ioa_$rsnnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
amu_et_$free_core             amu_et_$non_existant_mem      amu_et_$proc_not_dumped       scs$controller_data




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     31 000054         6 000057       123 000077       126 000100       130 000115       131 000117       132 000123
    133 000124       134 000125       135 000126       138 000127       140 000133       141 000135       142 000141
    143 000145       144 000147       146 000153       149 000154       150 000155       151 000157       152 000215
    153 000217       154 000220       157 000221       158 000242       159 000244       160 000245       163 000246
    164 000250       165 000257       169 000302       171 000304       172 000306       173 000311       176 000312
    177 000314       179 000330       180 000331       181 000335       182 000342       183 000347       184 000356
    186 000430       187 000436       189 000437       190 000441       191 000443       192 000453       193 000463
    194 000475       195 000501       196 000506       198 000512       199 000514       200 000516       201 000525
    202 000545       203 000547       209 000550       210 000552       211 000563       215 000566       216 000621
    217 000623       218 000624       221 000625       222 000631       223 000632       224 000635       228 000637
    229 000664       230 000666       231 000667       234 000670       235 000677       236 000703       237 000705
    238 000726       239 000730       240 000731       243 000732       244 000737       247 000743       248 000747
    249 000751       250 000777       251 001001       252 001002       255 001003       257 001006       258 001017
    259 001042       260 001044       261 001045       263 001046       264 001051       265 001057       266 001062
    267 001065       268 001071       269 001075       270 001100       271 001103       272 001107       273 001110
    276 001111       278 001112       279 001114       280 001116       281 001125       282 001130       283 001134
    284 001141       285 001145       286 001151       287 001154       288 001155       291 001156       293 001160
    296 001163       299 001170       300 001173       303 001174       304 001176       305 001200       306 001223
    307 001225       308 001226       311 001227       312 001232       313 001235       316 001236       317 001242
    318 001244       319 001246       320 001267       321 001271       322 001272       325 001273       326 001277
    327 001302       328 001303       333 001304       334 001307       335 001326       336 001330       337 001331
    340 001332       341 001336       342 001340       343 001342       344 001363       345 001365       346 001366
    349 001367       350 001374       351 001376       352 001417       353 001421       354 001422       356 001423
    358 001424       359 001427       360 001451       361 001505       362 001507       363 001510       365 001511
    367 001514       369 001515       370 001527       371 001540       372 001563       373 001565       374 001566
    376 001567       377 001576       378 001600       379 001607       380 001611       381 001632       382 001634
    383 001635       385 001636       387 001637       388 001640       389 001642       390 001647       391 001653
    392 001657       393 001670       394 001673       395 001704       400 001705       401 001716       407 001717
    409 001720       412 001721       413 001724       414 001727       415 001732       417 001737       418 001745
    419 001756       420 002003       421 002005       422 002006       423 002017       426 002020       427 002027
    428 002035       429 002040       430 002045       431 002051       432 002054       433 002057       434 002066
    435 002071       436 002077       437 002106       438 002112       439 002115       440 002120       441 002124
    442 002125       447 002126       448 002136       449 002141       450 002145       451 002155       452 002160
    453 002164       454 002167       455 002177       456 002202       457 002203       459 002204       460 002207
    463 002211       464 002213       466 002215       467 002226       471 002227       489 002231       490 002234
    492 002236       493 002242       494 002245       495 002250       496 002251       498 002257       499 002262
    500 002265       501 002266       503 002272       504 002275       505 002300       508 002301       509 002304
    512 002307


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
