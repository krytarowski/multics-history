	COMPILATION LISTING OF SEGMENT backup_dump
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/30/87  1121.2 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(86-06-05,GWMay), approve(85-12-23,MCR7320), audit(86-11-19,GDixon),
       16*     install(86-11-21,MR12.0-1223):
       17*     Modified the process loop to abort when a fatal error is returned from the
       18*     recursive dump subroutine. This way the program will not continue dumping
       19*     with the next line in the control file. Added the entry
       20*     backup_dump$abort_on_tape_errors to provide a means of returning the
       21*     error code from a bad tape mount or write.
       22*  2) change(87-03-03,GWMay), approve(87-03-03,MCR7627), audit(87-03-13,Farley),
       23*     install(87-03-30,MR12.1-1018):
       24*     added switch in the condition handling routine so that when writing to
       25*     the map, all conditions are passed back to the default handler.
       26*                                                   END HISTORY COMMENTS */
       27 
       28 
       29 /* Hierarchy dumper */
       30 
       31 /* Created:  February 1969 by R. C. Daley */
       32 /* Modified: 29 June 1970 by R. H. Campbell */
       33 /* Modified: 6 May 1976 by R. Bratt for pv dump */
       34 /* Modified: 2 November 1977 by Steve Herbst to add backup_dump_ */
       35 /* Modified: 3 August 1979 by Steve Herbst to add bk_ss_$no_primary */
       36 /* Modified: 28 January 1980 by S. Herbst to add missing options to the map */
       37 /* Modified: 6 November 1980 by G. Palter for version 3 backup_control structure */
       38 /* Modified: 30 December 1980 by Steve Herbst to read control file and implement cross-dumping */
       39 /* Modified: 4 August 1981 by G. Palter to fix interaction of cross-dumping and incremental/catchup/complete dumper */
       40 /* Modified: July 1982 by G. Palter to add features for IMFT support of AIM: enforce a maximum access class for dumping,
       41*   refuse to dump upgraded directories, and check a user's effective access to each branch before dumping */
       42 /* Modified February 1983 by E. N. Kittlitz for 256K segs */
       43 /* Modified August 1983 by Robert Coren to enforce a minimum access class for dumping */
       44 /* Modified November 1983 by Robert Coren to copy "upgrade_to_user_auth" flag */
       45 /* Modified 1985-03-21, BIM: fixed prehistoric busted condition handler.
       46*   phx18650 -- does not reset transparency switches.
       47*   phx17329 -- mishandling empty acls.
       48*   phx17310 -- unitialized variables in cross-dumping.
       49*   phx16651 -- rqovers on the map do not always get to level 2.
       50*   phx13714 -- catching command_error conditions */
       51 
       52 
       53 /* format: style4,delnl,insnl,ifthenstmt,ifthen */
       54 
       55 
       56 backup_dump:
       57      procedure ();
       58 
       59 dcl  Sfatal_error bit (1) aligned;
       60 dcl  Stape_entry bit (1) aligned;
       61 dcl  (i, id_length, n) fixed bin,			/* Temporary storage. */
       62      (a_code, code, saved_code) fixed bin (35),		/* Status codes */
       63      (old_trans_sw, ts) fixed bin (2),			/* To save previous transparent switch settings. */
       64      vers char (13) init ("21 March 1985") aligned int static options (constant),
       65 						/* version of dumper */
       66      calendar char (16) aligned,			/* Temporary for time conversion. */
       67      ap ptr,					/* Pointer to argument list */
       68      p ptr,
       69      sp ptr,
       70      control_ptr ptr,				/* ptr to backup_dump_ control structure */
       71      path_index fixed bin,
       72      tchar (168) char (1) based,			/* test character array */
       73      saved_dtd fixed bin (52);
       74 
       75 dcl  old_256K_switch bit (2) aligned;
       76 dcl  (cross_dump_path, cross_dump_dn, dn, dump_dir, temp_dn) char (168);
       77 dcl  cross_dump_en char (32);
       78 dcl  text_line char (300);
       79 
       80 dcl  NL char (1) int static options (constant) init ("
       81 ");
       82 dcl  type fixed bin (2),
       83      btcnt fixed bin (24);				/* Arguments for status_minf call */
       84 
       85 dcl  init static bit (1) initial ("1"b),		/* Static storage. */
       86      control_file_sw bit (1),				/* Reading requests from a control file */
       87      linep static ptr;				/* Pointer to ID line buffer. */
       88 
       89 dcl  id static char (300);				/* Name, version of dumper and arguments. */
       90 
       91 dcl  error_table_$noaccess fixed bin (35) external;	/* Status */
       92 dcl  error_table_$noarg fixed bin (35) external;
       93 dcl  error_table_$no_s_permission fixed bin (35) external;
       94 dcl  error_table_$root fixed bin (35) external;
       95 dcl  sys_info$seg_size_256K fixed bin (19) external;
       96 
       97 dcl  backup_control_mgr_$initiate entry (pointer, fixed binary (35)),
       98      backup_control_mgr_$terminate entry (pointer),
       99      backup_dump_recurse entry (char (168), char (32), bit (1) aligned, bit (1) aligned, fixed bin (35)),
      100      backup_dump_recurse$set_directory_dtd entry (char (*) aligned, fixed bin (52)),
      101      backup_map_$beginning_line entry (fixed bin (52), ptr, fixed bin),
      102      backup_map_$fs_error_line entry (fixed bin (35), char (*), char (*), char (*)),
      103      backup_map_$directory_line entry (ptr, fixed bin),
      104      backup_map_$terminal_line entry (fixed bin (52), fixed bin (35)),
      105      backup_util$get_real_name entry (ptr, ptr, fixed bin, fixed bin (35)),
      106      bk_output$output_init entry (fixed bin, fixed bin (35)),
      107      bk_output$output_finish entry;
      108 
      109 dcl  absolute_pathname_ entry (char (*), char (*), fixed bin (35)),
      110      bk_arg_reader_$dump_arg_reader entry (fixed bin, ptr, fixed bin (35)),
      111      clock_ entry (fixed bin (52)),
      112      com_err_ entry options (variable),
      113      cu_$arg_count entry (fixed bin),
      114      cu_$arg_list_ptr entry (ptr),
      115      date_time_ entry (fixed bin (52), char (*) aligned),
      116      expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35)),
      117      hcs_$fs_search_get_wdir entry (ptr, fixed bin),
      118      hcs_$status_minf
      119 	entry (char (*) aligned, char (*) aligned, fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35)),
      120      hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
      121      hcs_$set_256K_switch entry (bit (2) aligned, bit (2) aligned, fixed bin (35)),
      122      hcs_$set_max_length_seg ext entry (ptr, fixed bin (19), fixed bin (35)),
      123      hcs_$terminate_noname entry (ptr, fixed bin (35)),
      124      hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35)),
      125      (ioa_$rs) entry options (variable);		/* Variable arguments. */
      126 
      127 dcl  ios_$attach entry (char (*), char (*), char (*), char (*), bit (72) aligned);
      128 dcl  ios_$detach entry (char (*), char (*), char (*), bit (72) aligned);
      129 dcl  ios_$read entry (char (*), ptr, fixed bin, fixed bin, fixed bin, bit (72) aligned);
      130 
      131 dcl  hphcs_$fs_get_trans_sw entry (fixed bin (2), fixed bin (2));
      132 
      133 dcl  (
      134      hphcs_$suspend_quota,
      135      hphcs_$restore_quota
      136      ) external entry;
      137 
      138 dcl  cleanup condition;
      139 dcl  any_other condition;
      140 
      141 dcl  (addr, index, length, max, min, null, reverse, rtrim, substr) builtin;
      142 
      143 /**/
      144 
  1     1 /* BEGIN INCLUDE FILE ... bk_ss_.incl.pl1 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(87-03-03,GWMay), approve(87-03-03,MCR7627), audit(87-03-13,Farley),
  1     6*     install(87-03-30,MR12.1-1018):
  1     7*     added a writing_map switch to indicate when the dump map is being written.
  1     8*                                                   END HISTORY COMMENTS */
  1     9 
  1    10 
  1    11 /* Modified: July 1982 by G. Palter to add data for true AIM support in IMFT */
  1    12 /* Modified: August 1983 by Robert Coren to add minimum access class */
  1    13 /* Modified: November 1983 by Robert Coren to add "upgrade_to_user_auth" flag */
  1    14 
  1    15 /* Hierarchy dumper/reloader static data */
  1    16 
  1    17 dcl (bk_ss_$allow_dir_overwrite bit (1) aligned,		/* ON => allow reloaded seg to overwrite dir */
  1    18      bk_ss_$areap pointer,				/* pointer to list dir area */
  1    19      bk_ss_$brief_mapsw bit (1) aligned,		/* no form-feed for each control file entry */
  1    20      bk_ss_$caller_handles_conditions bit (1) aligned,	/* ON => caller has an any_other handler (for IMFT Daemon) */
  1    21      bk_ss_$control_name char(168),			/* control file path for dumping */
  1    22      bk_ss_$control_ptr pointer,			/* Ptr to control structure for sub entries */
  1    23      bk_ss_$cross_retrievesw bit (1) aligned,		/* ON => cross-retrieving this entry */
  1    24      bk_ss_$data_iocb pointer,			/* IOCB for dumping/reloading if bk_ss_$preattached */
  1    25      bk_ss_$date fixed binary (52),			/* dump all modified since this date */
  1    26      bk_ss_$datesw bit (1) aligned,			/* Flags presence of a date input */
  1    27      bk_ss_$debugsw bit (1) aligned,			/* Flag to prevent calls to hphcs_ */
  1    28      bk_ss_$dir_trim bit (1) aligned,			/* Flag to allow deletion of directories */
  1    29      bk_ss_$dprint_destination char (24),		/* for start_dump and reload, -ds for dprinting maps */
  1    30      bk_ss_$dprint_destination_setsw bit (1) aligned,
  1    31      bk_ss_$dprint_heading char (64),			/* for start_dump and reload, -he for dprinting maps */
  1    32      bk_ss_$dprint_heading_setsw bit (1) aligned,
  1    33      bk_ss_$dprint_queue fixed bin,			/* Queue number for dprinting maps and error files */
  1    34      bk_ss_$dprint_request_type char (24),		/* for start_dump and reload, -rqt for dprinting maps */
  1    35      bk_ss_$dprint_request_type_setsw bit (1) aligned,
  1    36      bk_ss_$dprintsw bit (1) aligned,			/* Whether to dprint maps for start_dump and reload */
  1    37      bk_ss_$dtdsw bit (1) aligned,			/* Flag to check if modified since last dumped */
  1    38      bk_ss_$ename char(32) aligned,			/* Branch entry to dump */
  1    39      bk_ss_$err_label label,				/* Place to go to attempt error recovery */
  1    40      bk_ss_$err_onlinesw bit(1) aligned,		/* Flag error output to be online, default to a file */
  1    41      bk_ss_$error fixed binary,			/* Code for location from which signal expected */
  1    42      bk_ss_$holdsw bit(1) aligned,			/* controls dismounting of tape for dumper */
  1    43      bk_ss_$hp pointer,				/* Pointer to preamble header */
  1    44      bk_ss_$ignore_dates bit (1) aligned,		/* Flag to skip check if have older info on tape */
  1    45      bk_ss_$mapsw bit (1) aligned,			/* Flag map output */
  1    46      bk_ss_$myname char(16),				/* Name by which backup was called */
  1    47      bk_ss_$namesw bit (1) aligned,			/* Flag to dump named branch only */
  1    48      bk_ss_$no_contin bit (1) aligned,			/* Flag to end dump after catchup dump. */
  1    49      bk_ss_$no_output bit (1) aligned,			/* Flag test run or dbugging dumper.  No tape output.*/
  1    50      bk_ss_$no_primary bit (1) aligned,			/* Flag saying do not use primary pathnames */
  1    51      bk_ss_$no_reload bit (1) aligned,			/* Flag debuging reloader.  Do not write in hierarchy. */
  1    52      bk_ss_$no_setlvid bit (1) aligned,			/* Flag to surpress setting of sons lvid on reload */
  1    53      bk_ss_$ntapes fixed bin,				/* number of tape copies for dumper */
  1    54      bk_ss_$onlysw bit (1) aligned,			/* ON => disable hiearchy sweep (dumping) or stop when all
  1    55*						   requests satisfied (loading) */
  1    56      bk_ss_$operator char(32),			/* operator name */
  1    57      bk_ss_$path_index fixed bin,			/* index of entry in backup_control structure */
  1    58      bk_ss_$pathsw bit(1) aligned,			/* starting directory path given to dumper */
  1    59      bk_ss_$preattached bit(1) aligned,			/* ON => caller has setup I/O switch for dumping/reloading */
  1    60      bk_ss_$pvsw  bit(1) aligned,			/* Flag to enable physical volume recovery */
  1    61      bk_ss_$pvname char(32) aligned,			/* Physical volume name */
  1    62      bk_ss_$qchecksw bit(1) aligned,			/* Flag to prevent suspension of quota checking */
  1    63      bk_ss_$quotasw bit(1) aligned,			/* Flag to allow quota setting */
  1    64      bk_ss_$restart_dumpsw bit(1) aligned,		/* restarting complete or catchup from given point */
  1    65      bk_ss_$restart_path char(168) aligned,		/* where to restart complete or catchup dump */
  1    66      bk_ss_$restart_plen fixed bin,			/* length of restart pathname */
  1    67      bk_ss_$retrieval_index fixed bin,			/* Index of entry in bk_retrieve's structure */
  1    68      bk_ss_$retrievesw bit (1) aligned,			/* Flags retrieval */
  1    69      bk_ss_$rlen fixed bin,				/* Length if current restart dir for recursion */
  1    70      bk_ss_$rname char(168),				/* retrieval file name */
  1    71      bk_ss_$rsize fixed bin,				/* length of retrieval file name */
  1    72      bk_ss_$save_path char(168),			/* starting directory for dump */
  1    73      bk_ss_$save_plen fixed bin,			/* length of starting directory name */
  1    74      bk_ss_$save_time fixed bin(52),			/* date, time of start of dump */
  1    75      bk_ss_$segptr pointer,
  1    76      bk_ss_$set_dtd bit (1) aligned,			/* ON to always set dtd when dumping, OFF never */
  1    77      bk_ss_$set_dtd_explicit bit (1) aligned,		/* ON to follow bk_ss_$set_dtd, OFF usual algorithm */
  1    78      bk_ss_$sp pointer,
  1    79      bk_ss_$sub_entry bit(1) aligned,			/* ON for backup_dump_ and backup_load_ */
  1    80      bk_ss_$sub_entry_errfile bit(1) aligned,		/* ON => backup_dump_ and backup_load_ should create error files */
  1    81      bk_ss_$tapesw bit(1) aligned,			/* Flag to indicate tape output */
  1    82      bk_ss_$trimsw bit(1) aligned,			/* Flag to trim directories on reload */
  1    83      bk_ss_$volume_set_name char (32),			/* For future arg -volume_set_name */
  1    84      bk_ss_$wakeup_interval fixed bin(52),		/* interval between wakeups of dumper in micro secs. */
  1    85      bk_ss_$wasnt_known bit(1) aligned,			/* Flag for segment termination */
  1    86      bk_ss_$enforce_max_access_class bit (1) aligned,	/* ON => don't dump anything above give access class */
  1    87      bk_ss_$maximum_access_class bit (72) aligned,	/* the access class to enforce on all branches */
  1    88      bk_ss_$enforce_min_access_class bit (1) aligned,	/* ON => don't dump anything below give access class */
  1    89      bk_ss_$minimum_access_class bit (72) aligned,	/* the minimum access class to enforce on all branches */
  1    90      bk_ss_$dont_dump_upgraded_dirs bit (1) aligned,	/* ON => don't dump any directory above given access class */
  1    91      bk_ss_$maximum_dir_access_class bit (72) aligned,	/* the access class to enforce on directories */
  1    92      bk_ss_$check_effective_access bit (1) aligned,	/* ON => don't dump branches given user can't access */
  1    93      bk_ss_$upgrade_to_user_auth bit (1) aligned,		/* ON => set access class of branch being dumped to user's authorization */
  1    94      bk_ss_$user_id character (32) unaligned,		/* the user's Person.Project.tag */
  1    95      bk_ss_$user_authorization bit (72) aligned,		/* the user's process authorization */
  1    96      bk_ss_$user_ring fixed binary,			/* the user's ring of execution */
  1    97      bk_ss_$restore_access_class bit (1) aligned,		/* ON => restore access class even when debugging */
  1    98      bk_ss_$enforce_minimum_ring bit (1) aligned,		/* ON => don't give anything lower ring bracket */
  1    99      bk_ss_$minimum_ring fixed binary,			/* the minimum ring bracket to be used */
  1   100      bk_ss_$translate_access_class bit (1) aligned,	/* ON => translate access classes read from tape */
  1   101      bk_ss_$source_attributes_ptr pointer,		/* -> source system's AIM attributes */
  1   102      bk_ss_$target_attributes_ptr pointer,		/* -> target system's AIM attributes */
  1   103      bk_ss_$writing_map bit (1) aligned)                    /* ON => in backup_map$try_write */
  1   104 	external static;
  1   105 
  1   106 /* END INCLUDE FILE ... bk_ss_.incl.pl1 */
      145 
      146 
  2     1 
  2     2 /* Begin include file ... backup_preamble_header.incl.pl1 */
  2     3 /* Modified 1/29/73 by N. I. Morris */
  2     4 /* Modified 7/15/74 by R. E. Mullen */
  2     5 /* Modified 10/10/74 by A. Kobziar */
  2     6 
  2     7 dcl 1 h based aligned,				/* backup preamble (segment header) */
  2     8 
  2     9     2 dlen fixed binary,
  2    10     2 dname character (168),
  2    11     2 elen fixed binary,
  2    12     2 ename character (32),
  2    13     2 bitcnt fixed binary (24),
  2    14     2 record_type fixed binary,			/* Logical record type. */
  2    15     2 dtd fixed binary (52),				/* Date and time dump occurred. */
  2    16     2 dumper_id character (32),			/* Identification of dumper procedure. */
  2    17 
  2    18     2 bp bit (18),					/* Pointer to branches. */
  2    19     2 bc fixed binary,				/* Branch count. */
  2    20     2 lp bit (18),					/* Pointer to links. */
  2    21     2 lc fixed binary,				/* Link count. */
  2    22     2 aclp bit (18),				/* Pointer to ACL or CACL */
  2    23     2 aclc fixed binary,				/* ACL count. */
  2    24     2 actind bit (18),				/* File activity indicator */
  2    25     2 actime bit (36),				/* File activity time */
  2    26 
  2    27     2 quota fixed binary,				/* Record quota for directory_list record. */
  2    28     2 trp fixed binary (35),				/* Time-record product .. */
  2    29     2 tlu fixed binary (35),				/* Time last updated .. */
  2    30     2 inf_acct fixed binary,				/* Inferior account switch .. */
  2    31     2 term_acct fixed binary (1),			/* Terminal account switch .. */
  2    32     2 pad1 (3),					/* To even out area to 0 mod 8 */
  2    33 
  2    34     2 max_length fixed bin (18),			/* Max. length of segment */
  2    35     2 switches unal,
  2    36       3 safety_sw bit (1) unal,			/* Segment safety switch */
  2    37       3 entrypt_sw bit (1) unal,			/* "1"b -> call limiter enabled */
  2    38       3 security_oosw bit(1) unal,			/* security out-of-service */
  2    39       3 audit_flag bit(1) unal,			/* flag for seg reference auditing */
  2    40       3 multiple_class bit (1) unal,			/* system segment: access class may be higher than parent's */
  2    41       3 pad2 bit(2) unal,				/* =pad2 in dir_entry */
  2    42       3 master_dir bit (1) unal,			/* "1"b => was master dir */
  2    43       3 tpd bit (1) unal,				/* TRUE => never put on paging device */
  2    44       3 sw_pad bit (13) unal,				/* padding in this structure */
  2    45     2 entrypt_bound bit (14) unal,			/* Call limiter. */
  2    46     2 access_class bit(72),				/* access class of entry */
  2    47     2 spad bit(36),					/* last word of dir entry */
  2    48     2 status_version fixed bin,			/* version of status_for_backup struct */
  2    49     2 nss_info_relp bit (18) aligned,			/* NONZERO => NSS INFO */
  2    50     2 dq_info_relp bit (18) aligned,				/* NONZERO => DIRQUOTA INFO */
  2    51 
  2    52     2 inaclp (0:7) bit (18),				/* Pointer to initial ACL for each ring. */
  2    53     2 inaclc (0:7) fixed bin,				/* Initial ACL count for each ring. */
  2    54     2 dir_inaclp (0:7) bit (18),			/* Directory initial ACL pointer for each ring. */
  2    55     2 dir_inaclc (0:7) fixed bin,			/* Directory initial ACL count for each ring. */
  2    56 
  2    57     2 bitcount_author char (32),			/* last modifier of the bit count */
  2    58 
  2    59     2 list_area /* area */ (65408);			/* Area for list_dir and readacl. */
  2    60 
  2    61 dcl  author char (32) aligned based;			/* Author of entry */
  2    62 						/* N. B.  Author is an overlay starting at h.quota */
  2    63 
  2    64 /* End of include file ... backup_preamble_header.incl.pl1 */
  2    65 
      147 
      148 
  3     1 /* BEGIN INCLUDE FILE ... backup_control.incl.pl1 */
  3     2 /* Modified: July 1982 by G. Palter to add features for proper support of AIM in IMFT (version 4) */
  3     3 /* Modified: August 1983 by Robert Coren to add minimum access class enforcement */
  3     4 /* Modified: November 1983 by Robert Coren to add "upgrade_to_user_auth" flag */
  3     5 
  3     6 /* Hierarchy dumper/reloader subroutine control structure */
  3     7 
  3     8 dcl 1 backup_control aligned based (backup_control_ptr),
  3     9     2 header,					/* allows people to use like (!) */
  3    10       3 version character (8) unaligned,
  3    11       3 tape_entry entry (character (*)) variable,	/* returns next tape label */
  3    12       3 data_iocb pointer,				/* -> I/O switch to use for dumping/loading if preattached */
  3    13       3 maximum_access_class bit (72) aligned,		/* maximum access class for anything to be dumped */
  3    14       3 minimum_access_class bit (72) aligned,		/* minimum access class for anything to be dumped */
  3    15       3 maximum_dir_access_class bit (72) aligned,	/* no directory above this access class is dumped */
  3    16       3 user_for_access_check,			/* data required to validate user's access */
  3    17         4 id character (32) unaligned,			/* Person.Project.tag */
  3    18         4 authorization bit (72),			/* the user's process authorization */
  3    19         4 ring fixed binary,				/* the user's ring o execution */
  3    20       3 minimum_ring fixed binary,			/* no ring bracket is set below this value */
  3    21       3 aim_translations,				/* data required to translate AIM attributes on the tape */
  3    22         4 source_attributes_ptr pointer,
  3    23         4 target_attributes_ptr pointer,
  3    24       3 options aligned,
  3    25         4 map_sw  bit(1) unaligned,			/* ON to write map segment */
  3    26         4 debug_sw bit (1) unaligned,			/* ON to check quotas and not trim subtrees */
  3    27         4 no_reload_sw bit (1) unaligned,		/* ON to not load for backup_load_ */
  3    28         4 hold_sw bit (1) unaligned,			/* ON to not demount tape afterwards */
  3    29         4 preattached bit (1) unaligned,		/* ON => perform loading/dumping to supplied I/O switch */
  3    30         4 error_file bit (1) unaligned,			/* ON => generate an error file anyway */
  3    31         4 first bit (1) unaligned,			/* ON => for reload, stop after all requests satisfied */
  3    32         4 caller_handles_conditions bit (1) unaligned,	/* ON => caller of backup_dump_ handles faults */
  3    33         4 allow_dir_overwrite bit (1) unaligned,		/* ON => allow reloaded seg to overwrite a dir */
  3    34         4 enforce_max_access_class bit (1) unaligned,	/* ON => do not dump anything above given access class */
  3    35         4 dont_dump_upgraded_dirs bit (1) unaligned,	/* ON => do not dump directories above given access class */
  3    36         4 check_effective_access bit (1) unaligned,	/* ON => do not dump branches specified user can't touch */
  3    37         4 restore_access_class bit (1) unaligned,		/* ON => restore AIM attributes even in debug mode */
  3    38         4 enforce_minimum_ring bit (1) unaligned,		/* ON => do not give anything ring bracket below minimum */
  3    39         4 translate_access_class bit (1) unaligned,	/* ON => translate access classes read from tape */
  3    40         4 enforce_min_access_class bit (1) unaligned,	/* ON => do not dump anything below given access class */
  3    41         4 upgrade_to_user_auth bit (1) unaligned,		/* ON => set access class of branch being dumped to user's authorization */
  3    42         4 pad bit (19) unaligned,
  3    43       3 request_count fixed binary,			/* # of entries to load or dump */
  3    44     2 requests (backup_control_request_count refer (backup_control.request_count)),
  3    45       3 path character (168) unaligned,			/* pathname of object to be dumped/loaded */
  3    46       3 new_path character (168) unaligned,		/* pathname for object when reloading if not same as above */
  3    47       3 switches aligned,
  3    48         4 no_primary_sw bit (1) unaligned,		/* do not use primary pathname */
  3    49         4 trim_sw bit (1) unaligned,			/* trim target directories */
  3    50         4 pad bit (34) unaligned,
  3    51       3 found bit(1) aligned,				/* ON => found on tape by backup_load_ (output) */
  3    52       3 loaded bit (1) aligned,			/* ON => loaded by backup_load_ (output) */
  3    53       3 status_code fixed binary (35),			/* ON => per-entry status code (output) */
  3    54       3 error_name character (65) unaligned;		/* ON => some information about what happened (output) */
  3    55 
  3    56 dcl  backup_control_ptr pointer;
  3    57 
  3    58 dcl backup_control_request_count fixed binary;		/* for allocations */
  3    59 
  3    60 dcl BACKUP_CONTROL_VERSION_5 character (8) static options (constant) initial ("hbc_0005");
  3    61 
  3    62 /* END INCLUDE FILE ... backup_control.incl.pl1 */
      149 
      150 
  4     1 /* include io_status */
  4     2 dcl 1 status, 					/* I/O system status string. */
  4     3     2 code fixed binary,				/* Overall error code. */
  4     4     2 bits, 					/* Fine structure. */
  4     5       3 successful bit (4), 				/* Logical/physical initiation/termination. */
  4     6       3 transaction_terminated bit (1), 		/* No further status change. */
  4     7       3 unassigned bit (4),
  4     8       3 end_of_data bit (1), 				/* Obvious. */
  4     9       3 pad bit (5),
  4    10       3 ioname_detached bit (1), 			/* .. */
  4    11       3 pad2 bit (20),
  4    12      status_bits based (sp) bit (72) aligned; 		/* Overlay for IO calls. */
  4    13 						/* end io_status */
      151 
      152 
      153 /**/
      154 
      155 	bk_ss_$sub_entry = "0"b;
      156 	Stape_entry = "0"b;
      157 	if bk_ss_$myname = " " then bk_ss_$myname = "backup_dump";
      158 	go to common;
      159 
      160 abort_on_tape_errors:
      161      entry (tape_code);
      162 
      163 dcl  tape_code fixed bin;
      164 
      165 	tape_code = 0;
      166 	bk_ss_$sub_entry = "0"b;
      167 	Stape_entry = "1"b;
      168 	control_file_sw = "0"b;	/* control file is read by caller */
      169 	go to have_args;
      170 
      171 backup_dump_:
      172      entry (control_ptr, a_code);
      173 
      174 	bk_ss_$sub_entry = "1"b;
      175 	Stape_entry = "0"b;
      176 	a_code = 0;
      177 	
      178 	bk_ss_$control_ptr = null();
      179 	old_256K_switch = ""b;			/* initialize for cleanup */
      180 	old_trans_sw = -1;				/* leaves the switches alone */
      181 	on condition (cleanup)
      182 	     begin;
      183 	     call hcs_$set_256K_switch (old_256K_switch, (""b), (0));
      184 	     if ^bk_ss_$debugsw then do;
      185 	          call hphcs_$fs_get_trans_sw (old_trans_sw, (0));
      186 	          call hphcs_$restore_quota;		/* Restore the quota */
      187 	     end;
      188 	     if bk_ss_$control_ptr ^= null then
      189 	          call backup_control_mgr_$terminate (control_ptr);
      190           end;
      191 
      192 	call backup_control_mgr_$initiate (control_ptr, a_code);
      193 	if a_code ^= 0 then return;
      194 
      195 	if bk_ss_$control_ptr -> backup_control.debug_sw then do;
      196 	     bk_ss_$debugsw = "1"b;
      197 	     bk_ss_$trimsw = "0"b;
      198 	end;
      199 	else bk_ss_$debugsw = "0"b;
      200 	bk_ss_$mapsw = bk_ss_$control_ptr -> backup_control.map_sw;
      201 	bk_ss_$no_reload = bk_ss_$control_ptr -> backup_control.no_reload_sw;
      202 	bk_ss_$holdsw = bk_ss_$control_ptr -> backup_control.hold_sw;
      203 	bk_ss_$preattached = bk_ss_$control_ptr -> backup_control.preattached;
      204 	if bk_ss_$preattached then bk_ss_$data_iocb = bk_ss_$control_ptr -> backup_control.data_iocb;
      205 	bk_ss_$sub_entry_errfile = bk_ss_$control_ptr -> backup_control.error_file;
      206 	bk_ss_$caller_handles_conditions = bk_ss_$control_ptr -> backup_control.caller_handles_conditions;
      207 
      208 	bk_ss_$enforce_max_access_class = bk_ss_$control_ptr -> backup_control.enforce_max_access_class;
      209 	if bk_ss_$enforce_max_access_class then
      210 	     bk_ss_$maximum_access_class = bk_ss_$control_ptr -> backup_control.maximum_access_class;
      211 
      212 	bk_ss_$enforce_min_access_class = bk_ss_$control_ptr -> backup_control.enforce_min_access_class;
      213 	if bk_ss_$enforce_min_access_class then
      214 	     bk_ss_$minimum_access_class = bk_ss_$control_ptr -> backup_control.minimum_access_class;
      215 
      216 	bk_ss_$dont_dump_upgraded_dirs = bk_ss_$control_ptr -> backup_control.dont_dump_upgraded_dirs;
      217 	if bk_ss_$dont_dump_upgraded_dirs then
      218 	     bk_ss_$maximum_dir_access_class = bk_ss_$control_ptr -> backup_control.maximum_dir_access_class;
      219 
      220 	bk_ss_$check_effective_access = bk_ss_$control_ptr -> backup_control.check_effective_access;
      221 	if bk_ss_$check_effective_access then do;
      222 	     bk_ss_$user_id = bk_ss_$control_ptr -> backup_control.user_for_access_check.id;
      223 	     bk_ss_$user_authorization = bk_ss_$control_ptr -> backup_control.user_for_access_check.authorization;
      224 	     bk_ss_$user_ring = bk_ss_$control_ptr -> backup_control.user_for_access_check.ring;
      225 	end;
      226 
      227 	bk_ss_$upgrade_to_user_auth = bk_ss_$control_ptr -> backup_control.upgrade_to_user_auth;
      228 
      229 	do i = 1 to bk_ss_$control_ptr -> backup_control.request_count;
      230 	     bk_ss_$control_ptr -> backup_control.found (i) = "0"b;
      231 	     bk_ss_$control_ptr -> backup_control.loaded (i) = "0"b;
      232 	     bk_ss_$control_ptr -> backup_control.status_code (i) = 0;
      233 	     bk_ss_$control_ptr -> backup_control.error_name (i) = "";
      234 	end;
      235 
      236 	bk_ss_$myname = "backup_dump_";
      237 	go to common;
      238 
      239 
      240 idump:
      241      entry;
      242 
      243 	bk_ss_$sub_entry = "0"b;
      244 	Stape_entry = "0"b;
      245 	bk_ss_$myname = "idump";
      246 
      247 common:
      248 	cross_dump_path, cross_dump_dn, cross_dump_en = "";
      249 
      250 
      251 /*	read in arguments and set switches		*/
      252 
      253 	control_file_sw = "0"b;			/* not yet told of control file in our arguments */
      254 
      255 	if bk_ss_$sub_entry then do;			/* if backup_dump_, get first pathname */
      256 	     do i = 1 to bk_ss_$control_ptr -> backup_control.request_count;
      257 		call absolute_pathname_ (bk_ss_$control_ptr -> backup_control.path (i), dn, code);
      258 		if code = 0 & dn = ">" then code = error_table_$root;
      259 		if code ^= 0 then do;
      260 		     a_code, bk_ss_$control_ptr -> backup_control.status_code (i) = code;
      261 		     go to RETURN_FROM_BACKUP_DUMP;
      262 		end;
      263 	     end;
      264 	     bk_ss_$save_path = bk_ss_$control_ptr -> backup_control.path (1);
      265 	     path_index, bk_ss_$path_index = 1;
      266 	     bk_ss_$pathsw = "1"b;
      267 	     bk_ss_$save_plen = length (rtrim (bk_ss_$save_path));
      268 	end;
      269 	else do;					/* else read command argument */
      270 	     call cu_$arg_count (i);			/* Get the number of input arguments */
      271 	     if i ^= 0 then do;			/* Don't bother if no args */
      272 		call cu_$arg_list_ptr (ap);		/* Get pointer to argument list */
      273 		call bk_arg_reader_$dump_arg_reader (1, ap, code);
      274 						/* Do the work */
      275 		if code ^= 0 then return;
      276 		if bk_ss_$control_name ^= "" & bk_ss_$myname = "backup_dump" then do;
      277 		     call ios_$attach ("dump_control", "file_", bk_ss_$control_name, "r",
      278 			addr (status) -> status_bits);
      279 		     if status.code ^= 0 then do;
      280 			call com_err_ (status.code, bk_ss_$myname, "Attaching control file ^a", bk_ss_$control_name)
      281 			     ;
      282 			return;
      283 		     end;
      284 READ_CONTROL:
      285 		     call ios_$read ("dump_control", addr (dump_dir), 0, length (dump_dir), n,
      286 			addr (status) -> status_bits);
      287 		     if status.code ^= 0 then do;
      288 READ_ERROR:
      289 			call com_err_ (status.code, bk_ss_$myname, "Reading control file ^a", bk_ss_$control_name);
      290 			return;
      291 		     end;
      292 		     if substr (dump_dir, n, 1) = NL then
      293 			substr (dump_dir, n) = "";
      294 		     else substr (dump_dir, n + 1) = "";
      295 		     if substr (dump_dir, 1, 1) ^= ">" then
      296 			if status.end_of_data then
      297 			     return;
      298 			else go to READ_CONTROL;
      299 
      300 		     i = index (dump_dir, "=");
      301 		     if i ^= 0 then do;
      302 			cross_dump_path = substr (dump_dir, i + 1);
      303 			substr (dump_dir, i) = "";
      304 			if substr (cross_dump_path, 1, 1) ^= ">" then
      305 			     cross_dump_path =
      306 				substr (dump_dir, 1, length (dump_dir) + 1 - index (reverse (dump_dir), ">"))
      307 				|| cross_dump_path;
      308 			if bk_ss_$mapsw then
      309 			     text_line =
      310 				"(Cross-dumping " || rtrim (dump_dir) || " to " || rtrim (cross_dump_path) || ")";
      311 			call expand_pathname_ (cross_dump_path, cross_dump_dn, cross_dump_en, code);
      312 			if code ^= 0 then do;
      313 			     call com_err_ (code, bk_ss_$myname, "Cross-dump path ^a", cross_dump_path);
      314 			     return;
      315 			end;
      316 		     end;
      317 		     else cross_dump_path, cross_dump_dn, cross_dump_en = "";
      318 
      319 		     bk_ss_$pathsw = "1"b;
      320 		     bk_ss_$save_path = dump_dir;
      321 		     bk_ss_$save_plen = n;
      322 		     control_file_sw = "1"b;
      323 		end;
      324 
      325 		else if ^bk_ss_$pathsw then do;
      326 		     call com_err_ (error_table_$noarg, bk_ss_$myname, "No absolute pathname specified.");
      327 		     return;
      328 		end;
      329 		else do;
      330 have_args:
      331 		     cross_dump_path, cross_dump_dn, cross_dump_en = "";
      332 		     call absolute_pathname_ (substr (bk_ss_$save_path, 1, bk_ss_$save_plen), dn, code);
      333 		     if code = 0 & dn = ">" then code = error_table_$root;
      334 		     if code ^= 0 then do;
      335 			call com_err_ (code, "backup_dump", "^a", substr (bk_ss_$save_path, 1, bk_ss_$save_plen));
      336 			return;
      337 		     end;
      338 		end;
      339 	     end;
      340 	     else if bk_ss_$myname = "backup_dump" then do;
      341 		call com_err_ (error_table_$noarg, "backup_dump", "No pathname specified.");
      342 		return;
      343 	     end;
      344 	end;
      345 
      346 /*	initialization		*/
      347 
      348 	Sfatal_error = "0"b;
      349 	old_256K_switch = ""b;			/* initialize for cleanup */
      350 	old_trans_sw = -1;				/* passing this back in has no effect */
      351 	if ^bk_ss_$sub_entry then
      352 	     on cleanup
      353 		begin;				/* need a cleanup handler */
      354 		call hcs_$set_256K_switch (old_256K_switch, (""b), (0));
      355 						/* ignore code */
      356 		if ^bk_ss_$debugsw then do;
      357 		     call hphcs_$fs_get_trans_sw (old_trans_sw, (0));
      358 		     call hphcs_$restore_quota;		/* Restore the quota */
      359                     end;
      360 	     end;
      361 	call hcs_$set_256K_switch ("11"b, old_256K_switch, (0));
      362 						/* ignore code */
      363 	if init then do;
      364 	     call hcs_$make_seg ("", "dump_seg", "", 01011b, bk_ss_$sp, code);
      365 	     call hcs_$set_max_length_seg (bk_ss_$sp, sys_info$seg_size_256K, code);
      366 	     call hcs_$make_seg ("", "dump_area", "", 01011b, bk_ss_$areap, code);
      367 	     call hcs_$make_seg ("", "dump_preamble", "", 01011b, bk_ss_$hp, code);
      368 	     linep = addr (id);			/* Set up pointer to identification line. */
      369 	     bk_ss_$areap -> h.dumper_id,		/* Insert dumper ID into preamble headers. */
      370 		bk_ss_$hp -> h.dumper_id = "Backup_dump " || vers;
      371 	     init = ""b;
      372 	end;
      373 
      374 	if bk_ss_$restart_dumpsw then do;		/* Check for restart branch */
      375 	     call hcs_$status_minf (bk_ss_$restart_path, "", 0, type, btcnt, code);
      376 	     if code ^= 0 then do;
      377 		if bk_ss_$sub_entry then
      378 		     a_code = code;
      379 		else call com_err_ (code, bk_ss_$myname, "^a", bk_ss_$restart_path);
      380 		go to RETURN_FROM_BACKUP_DUMP;
      381 	     end;
      382 	end;
      383 
      384 /*	Start the dump .... first get absolute path name of starting directory 		*/
      385 
      386 start:    bk_ss_$writing_map = "0"b;
      387 	call clock_ (bk_ss_$save_time);		/* Get the current time. */
      388 
      389 	if ^bk_ss_$pathsw then do;			/* Was a path name supplied? */
      390 	     call hcs_$fs_search_get_wdir (addr (bk_ss_$save_path), bk_ss_$save_plen);
      391 	     if bk_ss_$save_plen = 0 then do;		/* Is there a current working directory? */
      392 		code = error_table_$noaccess;
      393 		if bk_ss_$sub_entry then
      394 		     a_code = code;
      395 		else call com_err_ (code, bk_ss_$myname, "working directory");
      396 						/* Gripe. */
      397 		go to RETURN_FROM_BACKUP_DUMP;
      398 	     end;
      399 	end;
      400 	if bk_ss_$sub_entry then
      401 	     bk_ss_$no_primary = bk_ss_$control_ptr -> backup_control.no_primary_sw (bk_ss_$path_index);
      402 
      403 	if ^bk_ss_$no_primary then do;
      404 	     call backup_util$get_real_name (addr (bk_ss_$save_path), addr (bk_ss_$save_path), bk_ss_$save_plen, code);
      405 	     if bk_ss_$restart_dumpsw then
      406 		call backup_util$get_real_name (addr (bk_ss_$restart_path), addr (bk_ss_$restart_path),
      407 		     bk_ss_$restart_plen, code);
      408 	end;
      409 
      410 	id_length = 0;
      411 
      412 /*	Report switch settings		*/
      413 
      414 	if bk_ss_$mapsw then do;			/* Is a map output desired? */
      415 	     call append (rtrim (bk_ss_$myname));	/* set name into id line */
      416 	     call append (vers);			/* and version */
      417 	     if bk_ss_$tapesw then			/* Report tape option. */
      418 		if bk_ss_$ntapes = 1 then
      419 		     call append ("1tape");		/* How many tapes? */
      420 		else call append ("2tapes");		/* Both. */
      421 	     else call append ("notape");		/* No tape output enabled. */
      422 	     call append ("map");			/* Report map option */
      423 	     if bk_ss_$holdsw then
      424 		call append ("hold");		/* Report tape hold option. */
      425 	     else call append ("nohold");
      426 	     if bk_ss_$onlysw then
      427 		call append ("only");		/* Report whether hierarchy dump */
      428 	     else call append ("sweep");
      429 	     if bk_ss_$dtdsw then call append ("dtd");	/* Report dtd setting. */
      430 	     if bk_ss_$datesw then do;		/* Report date value. */
      431 		call date_time_ (bk_ss_$date, calendar);/* Convert the time value. */
      432 		call append (calendar);
      433 	     end;
      434 	     if ^(bk_ss_$dtdsw | bk_ss_$datesw) then call append ("all");
      435 						/* Are both off? */
      436 	     if bk_ss_$debugsw then call append ("debug");/* Report debug mode setting */
      437 	     if bk_ss_$err_onlinesw then call append ("error_on");
      438 	     if bk_ss_$no_contin then call append ("nocontin");
      439 						/* stop after catchup dump */
      440 	     if bk_ss_$no_output then call append ("nooutput");
      441 						/* no tape or map (bug if ON) */
      442 	     if bk_ss_$no_primary then call append ("noprimary");
      443 						/* do not use primary paths */
      444 	     if bk_ss_$restart_dumpsw then call append ("restart");
      445 						/* restarting previous dump */
      446 	     if bk_ss_$pvsw then do;
      447 		call append ("pvname = " || rtrim (bk_ss_$pvname));
      448 	     end;
      449 	end;
      450 	if bk_ss_$tapesw then do;
      451 	     call bk_output$output_init (bk_ss_$ntapes, code);
      452 						/* initialize output if tape option ON */
      453 	     if code ^= 0 then do;
      454 		call backup_map_$fs_error_line (code, "bk_output$output_init", "Initialization", "");
      455 		if Stape_entry then tape_code = code;
      456 		else if bk_ss_$sub_entry then a_code = code;
      457 
      458 		go to RETURN_FROM_BACKUP_DUMP;
      459 	     end;
      460 	end;
      461 	call backup_map_$beginning_line (bk_ss_$save_time, linep, id_length);
      462 						/* Write and type the beginning time. */
      463 	if ^(bk_ss_$tapesw | bk_ss_$mapsw) then go to RETURN_FROM_BACKUP_DUMP;
      464 						/* OK? */
      465 
      466 /*	Dump header and first directory		*/
      467 
      468 	bk_ss_$namesw = "1"b;			/* tell dump to dump only this record */
      469 	if ^bk_ss_$debugsw then do;			/* for real not debug */
      470 	     call hphcs_$suspend_quota;		/* dumper runs quota inhibited */
      471 	     call hphcs_$fs_get_trans_sw (11b, old_trans_sw);
      472 						/* Transparent use, modification. */
      473 	end;
      474 	on any_other call idump_signal;
      475 
      476 /* First dump branch of starting directory to get names and ACLs */
      477 
      478 	do;
      479 	     p = addr (bk_ss_$save_path);		/* Get pointer to starting pathname */
      480 	     do i = bk_ss_$save_plen to 1 by -1 while (p -> tchar (i) ^= ">");
      481 	     end;					/* Find last ">" */
      482 	     bk_ss_$hp -> h.dname = substr (bk_ss_$save_path, 1, max (1, i - 1));
      483 	     bk_ss_$hp -> h.dlen = max (1, i - 1);
      484 	     bk_ss_$ename = substr (bk_ss_$save_path, i + 1, bk_ss_$save_plen - i);
      485 
      486 	     if bk_ss_$mapsw then do;
      487 		if cross_dump_path ^= "" then do;
      488 		     call backup_map_$directory_line (addr (text_line), length (rtrim (text_line)));
      489 		     temp_dn = cross_dump_dn;
      490 		end;
      491 		else temp_dn = bk_ss_$hp -> h.dname;
      492 		call backup_map_$directory_line (addr (temp_dn), length (rtrim (temp_dn)));
      493 	     end;
      494 	     if ^bk_ss_$pvsw then do;			/* dump branch - except in pv dump case */
      495 		call hcs_$status_minf (bk_ss_$hp -> h.dname, bk_ss_$ename, 1, type, btcnt, code);
      496 		if code ^= 0 & code ^= error_table_$no_s_permission then do;
      497 		     call backup_map_$fs_error_line (code, "status_minf", (bk_ss_$hp -> h.dname), (bk_ss_$ename));
      498 		     if bk_ss_$sub_entry then bk_ss_$control_ptr -> backup_control.status_code (path_index) = code;
      499 		     go to dumped;
      500 		end;
      501 		call backup_dump_recurse (cross_dump_dn, cross_dump_en, "1"b, Sfatal_error, code);
      502 		if Sfatal_error then go to error;	/* D U M P   T H E   B R A N C H */
      503 		if type = 1 then do;		/* If terminal node was a segment ... */
      504 		     if code = 1 then code = 0;	/* Code of 1 is normal return for single entry. */
      505 		     go to dumped;			/* Clean up and leave. */
      506 		end;
      507 	     end;
      508 	end;
      509 
      510 /*	Now dump the rest of the subtree		*/
      511 
      512 	if bk_ss_$sub_entry then saved_code = bk_ss_$control_ptr -> backup_control.status_code (path_index);
      513 
      514 	do;
      515 	     saved_dtd = bk_ss_$hp -> h.dtd;		/* needed to set DTD of the dir later (maybe) */
      516 	     bk_ss_$hp -> h.dname = bk_ss_$save_path;	/* Now dump everything else */
      517 	     bk_ss_$hp -> h.dlen = bk_ss_$save_plen;	/* .. */
      518 	     bk_ss_$namesw = ""b;			/* set for entire dump */
      519 	     if bk_ss_$restart_dumpsw then bk_ss_$rlen = bk_ss_$save_plen + 1;
      520 						/* Set starting length of name for recursion in restart */
      521 
      522 	     call backup_dump_recurse (cross_dump_dn, cross_dump_en, "0"b, Sfatal_error, code);
      523 	     if Sfatal_error then go to error;		/* D U M P   S U B T R E E */
      524 
      525 	     call backup_dump_recurse$set_directory_dtd (bk_ss_$hp -> h.dname, saved_dtd);
      526 	end;
      527 
      528 dumped:
      529 	if bk_ss_$sub_entry then do;			/* if backup_dump_, get the next pathname */
      530 	     if saved_code = 0 & bk_ss_$control_ptr -> backup_control.status_code (path_index) ^= 0 then
      531 		bk_ss_$control_ptr -> backup_control.error_name (path_index) =
      532 		     "(in subtree) " || 
      533 		     substr (bk_ss_$control_ptr -> backup_control.error_name (path_index), 1,
      534 		     length (bk_ss_$control_ptr -> backup_control.error_name (path_index)) - length ( "(in subtree)" ));
      535 	     path_index, bk_ss_$path_index = path_index + 1;
      536 	     if path_index <= bk_ss_$control_ptr -> backup_control.request_count then do;
      537 		bk_ss_$save_path = bk_ss_$control_ptr -> backup_control.path (path_index);
      538 		bk_ss_$save_plen = length (rtrim (bk_ss_$save_path));
      539 		cross_dump_path = bk_ss_$control_ptr -> backup_control.new_path (path_index);
      540 		revert any_other;
      541 		if ^bk_ss_$debugsw then do;			/* Turn on quota, turn off trans sw if possible */
      542 		     call hphcs_$restore_quota;		/* Restore the quota */
      543 		     call hphcs_$fs_get_trans_sw (old_trans_sw, ts); 
      544 						          /* Restore previous settings. */
      545 		end;
      546 		go to start;
      547 	     end;
      548 	end;
      549 	else if control_file_sw then			/* get next control file entry */
      550 	     if ^status.end_of_data then do;
      551 	          revert any_other;
      552 		if ^bk_ss_$debugsw then do;			/* Turn on quota, turn off trans sw if possible */
      553 		     call hphcs_$restore_quota;		/* Restore the quota */
      554 		     call hphcs_$fs_get_trans_sw (old_trans_sw, ts);
      555 						          /* Restore previous settings. */
      556 		end;
      557 		go to READ_CONTROL;
      558                end;
      559 	     else call ios_$detach ("dump_control", "", "", addr (status) -> status_bits);
      560 						/* Cleanup and exit		*/
      561 error:
      562 	if Sfatal_error then do;
      563 	     if Stape_entry then tape_code = code;
      564 
      565 	     if bk_ss_$sub_entry then
      566 		a_code = code;
      567 	     else call com_err_ (code, bk_ss_$myname, "
      568 Unable to continue dumping.");
      569 	end;
      570 
      571 	revert any_other;
      572 	if ^bk_ss_$debugsw then do;			/* Turn on quota, turn off trans sw if possible */
      573 	     call hphcs_$restore_quota;		/* Restore the quota */
      574 	     call hphcs_$fs_get_trans_sw (old_trans_sw, ts);
      575 						/* Restore previous settings. */
      576 	end;
      577 	if bk_ss_$tapesw then call bk_output$output_finish ();
      578 						/* Shutdown output proceedure */
      579 	call clock_ (bk_ss_$save_time);		/* Get time of stopping. */
      580 	call backup_map_$terminal_line (bk_ss_$save_time, code);
      581 						/* Write the trailer line. */
      582 	call hcs_$truncate_seg (bk_ss_$sp, 0, code);	/* Free unused pages in buffer segments. */
      583 	call hcs_$truncate_seg (bk_ss_$areap, 1023, code);/* Save first page of preamble segments. */
      584 	call hcs_$truncate_seg (bk_ss_$hp, 1023, code);	/* .. */
      585 	if (bk_ss_$myname = "backup_dump") | (bk_ss_$myname = "idump") then bk_ss_$myname = "";
      586 
      587 RETURN_FROM_BACKUP_DUMP:
      588 	call hcs_$set_256K_switch (old_256K_switch, (""b), (0));
      589 						/* ignore code */
      590 	if bk_ss_$sub_entry then			/* possibly copy info back to older structure */
      591 	     call backup_control_mgr_$terminate (control_ptr);
      592 	return;
      593 
      594 /**/
      595 
      596 append:
      597      procedure (string);				/* Append string to identification line. */
      598 
      599 dcl  string character (*) aligned;			/* What to append. */
      600 	if id_length < length (id) then do;		/* Is there room in buffer? */
      601 	     id_length = id_length + 1;		/* Count it. */
      602 	     substr (id, id_length, 1) = " ";		/* Prepend a blank. */
      603 	     i = min (length (id) - id_length, length (string));
      604 						/* Don't overflow. */
      605 	     substr (id, id_length + 1, i) = string;	/* Append this string. */
      606 	     id_length = id_length + i;		/* Count length. */
      607 	end;
      608      end append;
      609 
      610 /**/
      611 
      612 /* Entry upon recieving an unclaimed signal */
      613 
      614 idump_signal:
      615      procedure;
      616 
      617 dcl  save_error fixed binary,				/* Space to save error location code. */
      618      is_temp fixed bin,
      619      is_code fixed bin (35),
      620      is_linep pointer,				/* Pointer to line buffer. */
      621      is_line character (300);				/* Line for formatting output messages. */
      622 
      623 declare  continue_to_signal_ entry (fixed binary (35));
      624 declare  find_condition_info_ entry (pointer, pointer, fixed binary (35));
      625 declare  1 CI aligned like condition_info;
      626 
      627 	if bk_ss_$sub_entry & bk_ss_$caller_handles_conditions
      628 	   | bk_ss_$writing_map then do;
      629 	     call continue_to_signal_ ((0));
      630 	     return;
      631 	end;					/* caller has any_other handler (for IMFT daemon usage) */
      632 
      633 	CI.version = condition_info_version_1;
      634 	call find_condition_info_ (null (), addr (CI), (0));
      635 	if ^(CI.condition_name = "seg_fault_error" | CI.condition_name = "no_read_permission"
      636 	     | CI.condition_name = "record_quota_overflow"/* null pages ... */
      637 	     | CI.condition_name = "out_of_bounds"	/* joker changed maxl */
      638 	     | CI.condition_name = "not_in_read_bracket"	/* etc. */
      639 	     | CI.condition_name = "page_fault_error" /* disk problems */) then do;
      640 	     call continue_to_signal_ ((0));		/* Not our problem */
      641 	     return;
      642 	end;
      643 
      644 /**** If we get here, we have a condition that could possibly have
      645*      happened while referencing a segment that we were dumping.
      646*      Check to see if we were dumping a segment. (bk_ss_$error ^= 0)
      647*      If not, we continue to signal anyway, since it is a problem
      648*      with the dumper and not just a joker nailing a segment we are dumping. */
      649 
      650 	save_error = bk_ss_$error;			/* Save copy of error location code. */
      651 	bk_ss_$error = 0;				/* Indicate future errors fatal. */
      652 	is_linep = addr (is_line);			/* Get pointer to line buffer. */
      653 	if save_error ^= 0 then do;			/* If error is not fatal at this time */
      654 	     if bk_ss_$mapsw then do;			/* Are we to report in the map? */
      655 		call ioa_$rs ("Non-fatal ^a at ^d: ^a>^a", is_line, is_temp, CI.condition_name, save_error,
      656 		     bk_ss_$hp -> h.dname, bk_ss_$hp -> h.ename);
      657 		call backup_map_$directory_line (is_linep, is_temp);
      658 	     end;
      659 	     if bk_ss_$wasnt_known then do;		/* Should we terminate this segment? */
      660 		bk_ss_$wasnt_known = ""b;		/* Clear indicator for safety. */
      661 		bk_ss_$error = 1;			/* Enable error recovery attempt. */
      662 		call hcs_$terminate_noname (bk_ss_$segptr, is_code);
      663 						/* Terminate this segment. */
      664 		bk_ss_$error = 0;			/* Disable error recovery. */
      665 	     end;
      666 	     go to bk_ss_$err_label;			/* attempt to recover with non-local go to */
      667 	end;
      668 	call continue_to_signal_ ((0));		/* No internal error recovery */
      669 	return;
      670 
  5     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  5     2 
  5     3 /* Structure for find_condition_info_.
  5     4*
  5     5*   Written 1-Mar-79 by M. N. Davidoff.
  5     6**/
  5     7 
  5     8 /* automatic */
  5     9 
  5    10      declare condition_info_ptr     pointer;
  5    11 
  5    12 /* based */
  5    13 
  5    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  5    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  5    16 	     2 version	      fixed binary,		/* Must be 1 */
  5    17 	     2 condition_name     char (32) varying,	/* name of condition */
  5    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  5    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  5    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  5    21 	     2 flags	      unaligned,
  5    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  5    23 	       3 pad1	      bit (35),
  5    24 	     2 pad2	      bit (36),
  5    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  5    26 	     2 pad3	      (4) bit (36);
  5    27 
  5    28 /* internal static */
  5    29 
  5    30      declare condition_info_version_1
  5    31 			      fixed binary internal static options (constant) initial (1);
  5    32 
  5    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      671 
      672      end idump_signal;
      673 
      674      end backup_dump;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/30/87  1050.8  backup_dump.pl1                   >special_ldd>install>MR12.1-1018>backup_dump.pl1
145          1    03/30/87  1052.4  bk_ss_.incl.pl1                   >special_ldd>install>MR12.1-1018>bk_ss_.incl.pl1
147          2    04/29/76  1058.2  backup_preamble_header.incl.pl1   >ldd>include>backup_preamble_header.incl.pl1
149          3    11/21/83  1219.2  backup_control.incl.pl1           >ldd>include>backup_control.incl.pl1
151          4    05/06/74  1742.1  io_status.incl.pl1                >ldd>include>io_status.incl.pl1
671          5    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CI                              000230 automatic       structure                level 1 dcl 625 set ref 634 634
NL                              005006 constant        char(1)                  initial unaligned dcl 80 ref 292
Sfatal_error                    000100 automatic       bit(1)                   dcl 59 set ref 348* 501* 502 522* 523 561
Stape_entry                     000101 automatic       bit(1)                   dcl 60 set ref 156* 167* 175* 244* 455 563
a_code                                 parameter       fixed bin(35,0)          dcl 61 set ref 171 176* 192* 193 260* 377* 393* 456*
                                                                                  565*
absolute_pathname_              000170 constant        entry                    external dcl 109 ref 257 332
addr                                                   builtin function         dcl 141 ref 277 284 284 284 368 390 390 404 404 404
                                                                                  404 405 405 405 405 479 488 488 492 492 559 634
                                                                                  634 652
any_other                       000606 stack reference condition                dcl 139 ref 474 540 551 571
ap                              000116 automatic       pointer                  dcl 61 set ref 272* 273*
authorization            26            based           bit(72)                  level 4 dcl 3-8 ref 223
backup_control                         based           structure                level 1 dcl 3-8
backup_control_mgr_$initiate    000142 constant        entry                    external dcl 97 ref 192
backup_control_mgr_$terminate   000144 constant        entry                    external dcl 97 ref 188 590
backup_dump_recurse             000146 constant        entry                    external dcl 97 ref 501 522
backup_dump_recurse$set_directory_dtd
                                000150 constant        entry                    external dcl 97 ref 525
backup_map_$beginning_line      000152 constant        entry                    external dcl 97 ref 461
backup_map_$directory_line      000156 constant        entry                    external dcl 97 ref 488 492 657
backup_map_$fs_error_line       000154 constant        entry                    external dcl 97 ref 454 497
backup_map_$terminal_line       000160 constant        entry                    external dcl 97 ref 580
backup_util$get_real_name       000162 constant        entry                    external dcl 97 ref 404 405
bits                      1     000614 automatic       structure                level 2 packed unaligned dcl 4-2
bk_arg_reader_$dump_arg_reader  000172 constant        entry                    external dcl 109 ref 273
bk_output$output_finish         000166 constant        entry                    external dcl 97 ref 577
bk_output$output_init           000164 constant        entry                    external dcl 97 ref 451
bk_ss_$areap                    000244 external static pointer                  dcl 1-17 set ref 366* 369 583*
bk_ss_$caller_handles_conditions
                                000246 external static bit(1)                   dcl 1-17 set ref 206* 627
bk_ss_$check_effective_access   000406 external static bit(1)                   dcl 1-17 set ref 220* 221
bk_ss_$control_name             000250 external static char(168)                unaligned dcl 1-17 set ref 276 277* 280* 288*
bk_ss_$control_ptr              000252 external static pointer                  dcl 1-17 set ref 178* 188 195 200 201 202 203 204
                                                                                  205 206 208 209 212 213 216 217 220 222 223 224
                                                                                  227 229 230 231 232 233 256 257 260 264 400 498
                                                                                  512 530 530 530 530 536 537 539
bk_ss_$data_iocb                000254 external static pointer                  dcl 1-17 set ref 204*
bk_ss_$date                     000256 external static fixed bin(52,0)          dcl 1-17 set ref 431*
bk_ss_$datesw                   000260 external static bit(1)                   dcl 1-17 ref 430 434
bk_ss_$debugsw                  000262 external static bit(1)                   dcl 1-17 set ref 184 196* 199* 356 436 469 541 552
                                                                                  572
bk_ss_$dont_dump_upgraded_dirs  000402 external static bit(1)                   dcl 1-17 set ref 216* 217
bk_ss_$dtdsw                    000264 external static bit(1)                   dcl 1-17 ref 429 434
bk_ss_$ename                    000266 external static char(32)                 dcl 1-17 set ref 484* 495* 497
bk_ss_$enforce_max_access_class 000372 external static bit(1)                   dcl 1-17 set ref 208* 209
bk_ss_$enforce_min_access_class 000376 external static bit(1)                   dcl 1-17 set ref 212* 213
bk_ss_$err_label                000270 external static label variable           dcl 1-17 ref 666
bk_ss_$err_onlinesw             000272 external static bit(1)                   dcl 1-17 ref 437
bk_ss_$error                    000274 external static fixed bin(17,0)          dcl 1-17 set ref 650 651* 661* 664*
bk_ss_$holdsw                   000276 external static bit(1)                   dcl 1-17 set ref 202* 423
bk_ss_$hp                       000300 external static pointer                  dcl 1-17 set ref 367* 369 482 483 491 495 497 515
                                                                                  516 517 525 584* 655 655
bk_ss_$mapsw                    000302 external static bit(1)                   dcl 1-17 set ref 200* 308 414 463 486 654
bk_ss_$maximum_access_class     000374 external static bit(72)                  dcl 1-17 set ref 209*
bk_ss_$maximum_dir_access_class 000404 external static bit(72)                  dcl 1-17 set ref 217*
bk_ss_$minimum_access_class     000400 external static bit(72)                  dcl 1-17 set ref 213*
bk_ss_$myname                   000304 external static char(16)                 unaligned dcl 1-17 set ref 157 157* 236* 245* 276
                                                                                  280* 288* 313* 326* 340 379* 395* 415 415 567* 585
                                                                                  585 585*
bk_ss_$namesw                   000306 external static bit(1)                   dcl 1-17 set ref 468* 518*
bk_ss_$no_contin                000310 external static bit(1)                   dcl 1-17 ref 438
bk_ss_$no_output                000312 external static bit(1)                   dcl 1-17 ref 440
bk_ss_$no_primary               000314 external static bit(1)                   dcl 1-17 set ref 400* 403 442
bk_ss_$no_reload                000316 external static bit(1)                   dcl 1-17 set ref 201*
bk_ss_$ntapes                   000320 external static fixed bin(17,0)          dcl 1-17 set ref 417 451*
bk_ss_$onlysw                   000322 external static bit(1)                   dcl 1-17 ref 426
bk_ss_$path_index               000324 external static fixed bin(17,0)          dcl 1-17 set ref 265* 400 535*
bk_ss_$pathsw                   000326 external static bit(1)                   dcl 1-17 set ref 266* 319* 325 389
bk_ss_$preattached              000330 external static bit(1)                   dcl 1-17 set ref 203* 204
bk_ss_$pvname                   000334 external static char(32)                 dcl 1-17 ref 447
bk_ss_$pvsw                     000332 external static bit(1)                   dcl 1-17 ref 446 494
bk_ss_$restart_dumpsw           000336 external static bit(1)                   dcl 1-17 ref 374 405 444 519
bk_ss_$restart_path             000340 external static char(168)                dcl 1-17 set ref 375* 379* 405 405 405 405
bk_ss_$restart_plen             000342 external static fixed bin(17,0)          dcl 1-17 set ref 405*
bk_ss_$rlen                     000344 external static fixed bin(17,0)          dcl 1-17 set ref 519*
bk_ss_$save_path                000346 external static char(168)                unaligned dcl 1-17 set ref 264* 267 320* 332 332 335
                                                                                  335 390 390 404 404 404 404 479 482 484 516 537*
                                                                                  538
bk_ss_$save_plen                000350 external static fixed bin(17,0)          dcl 1-17 set ref 267* 321* 332 332 335 335 390* 391
                                                                                  404* 480 484 517 519 538*
bk_ss_$save_time                000352 external static fixed bin(52,0)          dcl 1-17 set ref 387* 461* 579* 580*
bk_ss_$segptr                   000354 external static pointer                  dcl 1-17 set ref 662*
bk_ss_$sp                       000356 external static pointer                  dcl 1-17 set ref 364* 365* 582*
bk_ss_$sub_entry                000360 external static bit(1)                   dcl 1-17 set ref 155* 166* 174* 243* 255 351 377 393
                                                                                  400 456 498 512 528 565 590 627
bk_ss_$sub_entry_errfile        000362 external static bit(1)                   dcl 1-17 set ref 205*
bk_ss_$tapesw                   000364 external static bit(1)                   dcl 1-17 ref 417 450 463 577
bk_ss_$trimsw                   000366 external static bit(1)                   dcl 1-17 set ref 197*
bk_ss_$upgrade_to_user_auth     000410 external static bit(1)                   dcl 1-17 set ref 227*
bk_ss_$user_authorization       000414 external static bit(72)                  dcl 1-17 set ref 223*
bk_ss_$user_id                  000412 external static char(32)                 unaligned dcl 1-17 set ref 222*
bk_ss_$user_ring                000416 external static fixed bin(17,0)          dcl 1-17 set ref 224*
bk_ss_$wasnt_known              000370 external static bit(1)                   dcl 1-17 set ref 659 660*
bk_ss_$writing_map              000420 external static bit(1)                   dcl 1-17 set ref 386* 627
btcnt                           000575 automatic       fixed bin(24,0)          dcl 82 set ref 375* 495*
calendar                        000111 automatic       char(16)                 dcl 61 set ref 431* 432*
caller_handles_conditions
                         36(07)        based           bit(1)                   level 4 packed unaligned dcl 3-8 ref 206
check_effective_access
                         36(11)        based           bit(1)                   level 4 packed unaligned dcl 3-8 ref 220
cleanup                         000600 stack reference condition                dcl 138 ref 181 351
clock_                          000174 constant        entry                    external dcl 109 ref 387 579
code                            000614 automatic       fixed bin(17,0)          level 2 in structure "status" dcl 4-2 in procedure
                                                                                  "backup_dump" set ref 279 280* 287 288*
code                            000105 automatic       fixed bin(35,0)          dcl 61 in procedure "backup_dump" set ref 257* 258
                                                                                  258* 259 260 273* 275 311* 312 313* 332* 333 333*
                                                                                  334 335* 364* 365* 366* 367* 375* 376 377 379*
                                                                                  392* 393 395* 404* 405* 451* 453 454* 455 456 495*
                                                                                  496 496 497* 498 501* 504 504* 522* 563 565 567*
                                                                                  580* 582* 583* 584*
com_err_                        000176 constant        entry                    external dcl 109 ref 280 288 313 326 335 341 379 395
                                                                                  567
condition_info                         based           structure                level 1 dcl 5-14
condition_info_version_1               constant        fixed bin(17,0)          initial dcl 5-30 ref 633
condition_name            3     000230 automatic       varying char(32)         level 2 dcl 625 set ref 635 635 635 635 635 635 655*
continue_to_signal_             000422 constant        entry                    external dcl 623 ref 629 640 668
control_file_sw                 000576 automatic       bit(1)                   unaligned dcl 85 set ref 168* 253* 322* 549
control_ptr                            parameter       pointer                  dcl 61 set ref 171 188* 192* 590*
cross_dump_dn                   000201 automatic       char(168)                unaligned dcl 76 set ref 247* 311* 317* 330* 489
                                                                                  501* 522*
cross_dump_en                   000451 automatic       char(32)                 unaligned dcl 77 set ref 247* 311* 317* 330* 501*
                                                                                  522*
cross_dump_path                 000127 automatic       char(168)                unaligned dcl 76 set ref 247* 302* 304 304* 304 308
                                                                                  311* 313* 317* 330* 487 539*
cu_$arg_count                   000200 constant        entry                    external dcl 109 ref 270
cu_$arg_list_ptr                000202 constant        entry                    external dcl 109 ref 272
data_iocb                 6            based           pointer                  level 3 dcl 3-8 ref 204
date_time_                      000204 constant        entry                    external dcl 109 ref 431
debug_sw                 36(01)        based           bit(1)                   level 4 packed unaligned dcl 3-8 ref 195
dlen                                   based           fixed bin(17,0)          level 2 dcl 2-7 set ref 483* 517*
dn                              000253 automatic       char(168)                unaligned dcl 76 set ref 257* 258 332* 333
dname                     1            based           char(168)                level 2 dcl 2-7 set ref 482* 491 495* 497 516* 525*
                                                                                  655*
dont_dump_upgraded_dirs
                         36(10)        based           bit(1)                   level 4 packed unaligned dcl 3-8 ref 216
dtd                      66            based           fixed bin(52,0)          level 2 dcl 2-7 ref 515
dump_dir                        000325 automatic       char(168)                unaligned dcl 76 set ref 284 284 284 284 292 292*
                                                                                  294* 295 300 302 303* 304 304 304 308 320
dumper_id                70            based           char(32)                 level 2 dcl 2-7 set ref 369* 369*
ename                    54            based           char(32)                 level 2 dcl 2-7 set ref 655*
end_of_data               1(09) 000614 automatic       bit(1)                   level 3 packed unaligned dcl 4-2 set ref 295 549
enforce_max_access_class
                         36(09)        based           bit(1)                   level 4 packed unaligned dcl 3-8 ref 208
enforce_min_access_class
                         36(15)        based           bit(1)                   level 4 packed unaligned dcl 3-8 ref 212
error_file               36(05)        based           bit(1)                   level 4 packed unaligned dcl 3-8 ref 205
error_name              170            based           char(65)                 array level 3 packed unaligned dcl 3-8 set ref 233*
                                                                                  530* 530 530
error_table_$no_s_permission    000134 external static fixed bin(35,0)          dcl 93 ref 496
error_table_$noaccess           000130 external static fixed bin(35,0)          dcl 91 ref 392
error_table_$noarg              000132 external static fixed bin(35,0)          dcl 92 set ref 326* 341*
error_table_$root               000136 external static fixed bin(35,0)          dcl 94 ref 258 333
expand_pathname_                000206 constant        entry                    external dcl 109 ref 311
find_condition_info_            000424 constant        entry                    external dcl 624 ref 634
found                   165            based           bit(1)                   array level 3 dcl 3-8 set ref 230*
h                                      based           structure                level 1 dcl 2-7
hcs_$fs_search_get_wdir         000210 constant        entry                    external dcl 109 ref 390
hcs_$make_seg                   000214 constant        entry                    external dcl 109 ref 364 366 367
hcs_$set_256K_switch            000216 constant        entry                    external dcl 109 ref 183 354 361 587
hcs_$set_max_length_seg         000220 constant        entry                    external dcl 109 ref 365
hcs_$status_minf                000212 constant        entry                    external dcl 109 ref 375 495
hcs_$terminate_noname           000222 constant        entry                    external dcl 109 ref 662
hcs_$truncate_seg               000224 constant        entry                    external dcl 109 ref 582 583 584
header                                 based           structure                level 2 dcl 3-8
hold_sw                  36(03)        based           bit(1)                   level 4 packed unaligned dcl 3-8 ref 202
hphcs_$fs_get_trans_sw          000236 constant        entry                    external dcl 131 ref 185 357 471 543 554 574
hphcs_$restore_quota            000242 constant        entry                    external dcl 133 ref 186 358 542 553 573
hphcs_$suspend_quota            000240 constant        entry                    external dcl 133 ref 470
i                               000102 automatic       fixed bin(17,0)          dcl 61 set ref 229* 230 231 232 233* 256* 257 260*
                                                                                  270* 271 300* 301 302 303 480* 480* 482 483 484
                                                                                  484 603* 605 606
id                              000014 internal static char(300)                unaligned dcl 89 in procedure "backup_dump" set ref
                                                                                  368 600 602* 603 605*
id                       16            based           char(32)                 level 4 in structure "backup_control" packed
                                                                                  unaligned dcl 3-8 in procedure "backup_dump" ref
                                                                                  222
id_length                       000103 automatic       fixed bin(17,0)          dcl 61 set ref 410* 461* 600 601* 601 602 603 605
                                                                                  606* 606
index                                                  builtin function         dcl 141 ref 300 304
init                            000010 internal static bit(1)                   initial unaligned dcl 85 set ref 363 371*
ioa_$rs                         000226 constant        entry                    external dcl 109 ref 655
ios_$attach                     000230 constant        entry                    external dcl 127 ref 277
ios_$detach                     000232 constant        entry                    external dcl 128 ref 559
ios_$read                       000234 constant        entry                    external dcl 129 ref 284
is_code                         000110 automatic       fixed bin(35,0)          dcl 617 set ref 662*
is_line                         000114 automatic       char(300)                unaligned dcl 617 set ref 652 655*
is_linep                        000112 automatic       pointer                  dcl 617 set ref 652* 657*
is_temp                         000107 automatic       fixed bin(17,0)          dcl 617 set ref 655* 657*
length                                                 builtin function         dcl 141 ref 267 284 284 304 488 488 492 492 530 530
                                                                                  538 600 603 603
linep                           000012 internal static pointer                  dcl 85 set ref 368* 461*
loaded                  166            based           bit(1)                   array level 3 dcl 3-8 set ref 231*
map_sw                   36            based           bit(1)                   level 4 packed unaligned dcl 3-8 ref 200
max                                                    builtin function         dcl 141 ref 482 483
maximum_access_class     10            based           bit(72)                  level 3 dcl 3-8 ref 209
maximum_dir_access_class
                         14            based           bit(72)                  level 3 dcl 3-8 ref 217
min                                                    builtin function         dcl 141 ref 603
minimum_access_class     12            based           bit(72)                  level 3 dcl 3-8 ref 213
n                               000104 automatic       fixed bin(17,0)          dcl 61 set ref 284* 292 292 294 321
new_path                112            based           char(168)                array level 3 packed unaligned dcl 3-8 ref 539
no_primary_sw           164            based           bit(1)                   array level 4 packed unaligned dcl 3-8 ref 400
no_reload_sw             36(02)        based           bit(1)                   level 4 packed unaligned dcl 3-8 ref 201
null                                                   builtin function         dcl 141 ref 178 188 634 634
old_256K_switch                 000126 automatic       bit(2)                   dcl 75 set ref 179* 183* 349* 354* 361* 587*
old_trans_sw                    000107 automatic       fixed bin(2,0)           dcl 61 set ref 180* 185* 350* 357* 471* 543* 554*
                                                                                  574*
options                  36            based           structure                level 3 dcl 3-8
p                               000120 automatic       pointer                  dcl 61 set ref 479* 480
path                     40            based           char(168)                array level 3 packed unaligned dcl 3-8 set ref 257*
                                                                                  264 537
path_index                      000122 automatic       fixed bin(17,0)          dcl 61 set ref 265* 498 512 530 530 530 530 535 535*
                                                                                  536 537 539
preattached              36(04)        based           bit(1)                   level 4 packed unaligned dcl 3-8 ref 203
request_count            37            based           fixed bin(17,0)          level 3 dcl 3-8 ref 229 256 536
requests                 40            based           structure                array level 2 dcl 3-8
reverse                                                builtin function         dcl 141 ref 304
ring                     30            based           fixed bin(17,0)          level 4 dcl 3-8 ref 224
rtrim                                                  builtin function         dcl 141 ref 267 308 308 415 415 447 488 488 492 492
                                                                                  538
save_error                      000106 automatic       fixed bin(17,0)          dcl 617 set ref 650* 653 655*
saved_code                      000106 automatic       fixed bin(35,0)          dcl 61 set ref 512* 530
saved_dtd                       000124 automatic       fixed bin(52,0)          dcl 61 set ref 515* 525*
status                          000614 automatic       structure                level 1 unaligned dcl 4-2 set ref 277 284 559
status_bits                            based           bit(72)                  dcl 4-2 set ref 277* 284* 559*
status_code             167            based           fixed bin(35,0)          array level 3 dcl 3-8 set ref 232* 260* 498* 512 530
string                                 parameter       char                     dcl 599 ref 596 603 605
substr                                                 builtin function         dcl 141 set ref 292 292* 294* 295 302 303* 304 304
                                                                                  332 332 335 335 482 484 530 602* 605*
switches                164            based           structure                array level 3 dcl 3-8
sys_info$seg_size_256K          000140 external static fixed bin(19,0)          dcl 95 set ref 365*
tape_code                              parameter       fixed bin(17,0)          dcl 163 set ref 160 165* 455* 563*
tchar                                  based           char(1)                  array unaligned dcl 61 ref 480
temp_dn                         000377 automatic       char(168)                unaligned dcl 76 set ref 489* 491* 492 492 492 492
text_line                       000461 automatic       char(300)                unaligned dcl 78 set ref 308* 488 488 488 488
ts                              000110 automatic       fixed bin(2,0)           dcl 61 set ref 543* 554* 574*
type                            000574 automatic       fixed bin(2,0)           dcl 82 set ref 375* 495* 503
upgrade_to_user_auth     36(16)        based           bit(1)                   level 4 packed unaligned dcl 3-8 ref 227
user_for_access_check
                         16            based           structure                level 3 dcl 3-8
vers                            000000 constant        char(13)                 initial dcl 61 set ref 369 416*
version                   2     000230 automatic       fixed bin(17,0)          level 2 dcl 625 set ref 633*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BACKUP_CONTROL_VERSION_5               internal static char(8)                  initial unaligned dcl 3-60
author                                 based           char(32)                 dcl 2-61
backup_control_ptr                     automatic       pointer                  dcl 3-56
backup_control_request_count           automatic       fixed bin(17,0)          dcl 3-58
bk_ss_$allow_dir_overwrite             external static bit(1)                   dcl 1-17
bk_ss_$brief_mapsw                     external static bit(1)                   dcl 1-17
bk_ss_$cross_retrievesw                external static bit(1)                   dcl 1-17
bk_ss_$dir_trim                        external static bit(1)                   dcl 1-17
bk_ss_$dprint_destination              external static char(24)                 unaligned dcl 1-17
bk_ss_$dprint_destination_setsw        external static bit(1)                   dcl 1-17
bk_ss_$dprint_heading                  external static char(64)                 unaligned dcl 1-17
bk_ss_$dprint_heading_setsw            external static bit(1)                   dcl 1-17
bk_ss_$dprint_queue                    external static fixed bin(17,0)          dcl 1-17
bk_ss_$dprint_request_type             external static char(24)                 unaligned dcl 1-17
bk_ss_$dprint_request_type_setsw       external static bit(1)                   dcl 1-17
bk_ss_$dprintsw                        external static bit(1)                   dcl 1-17
bk_ss_$enforce_minimum_ring            external static bit(1)                   dcl 1-17
bk_ss_$ignore_dates                    external static bit(1)                   dcl 1-17
bk_ss_$minimum_ring                    external static fixed bin(17,0)          dcl 1-17
bk_ss_$no_setlvid                      external static bit(1)                   dcl 1-17
bk_ss_$operator                        external static char(32)                 unaligned dcl 1-17
bk_ss_$qchecksw                        external static bit(1)                   dcl 1-17
bk_ss_$quotasw                         external static bit(1)                   dcl 1-17
bk_ss_$restore_access_class            external static bit(1)                   dcl 1-17
bk_ss_$retrieval_index                 external static fixed bin(17,0)          dcl 1-17
bk_ss_$retrievesw                      external static bit(1)                   dcl 1-17
bk_ss_$rname                           external static char(168)                unaligned dcl 1-17
bk_ss_$rsize                           external static fixed bin(17,0)          dcl 1-17
bk_ss_$set_dtd                         external static bit(1)                   dcl 1-17
bk_ss_$set_dtd_explicit                external static bit(1)                   dcl 1-17
bk_ss_$source_attributes_ptr           external static pointer                  dcl 1-17
bk_ss_$target_attributes_ptr           external static pointer                  dcl 1-17
bk_ss_$translate_access_class          external static bit(1)                   dcl 1-17
bk_ss_$volume_set_name                 external static char(32)                 unaligned dcl 1-17
bk_ss_$wakeup_interval                 external static fixed bin(52,0)          dcl 1-17
condition_info_ptr                     automatic       pointer                  dcl 5-10
sp                                     automatic       pointer                  dcl 61

NAMES DECLARED BY EXPLICIT CONTEXT.
READ_CONTROL                    001217 constant        label                    dcl 284 ref 295 557
READ_ERROR                      001265 constant        label                    dcl 288
RETURN_FROM_BACKUP_DUMP         004461 constant        label                    dcl 587 ref 261 380 397 458 463
abort_on_tape_errors            000347 constant        entry                    external dcl 160
append                          004513 constant        entry                    internal dcl 596 ref 415 416 417 420 421 422 423 425
                                                                                  426 428 429 432 434 436 437 438 440 442 444 447
backup_dump                     000324 constant        entry                    external dcl 56
backup_dump_                    000370 constant        entry                    external dcl 171
common                          000717 constant        label                    dcl 247 ref 158 237
dumped                          004065 constant        label                    dcl 528 ref 499 505
error                           004264 constant        label                    dcl 561 ref 502 523
have_args                       001670 constant        label                    dcl 330 ref 169
idump                           000703 constant        entry                    external dcl 240
idump_signal                    004556 constant        entry                    internal dcl 614 ref 474
start                           002462 constant        label                    dcl 386 ref 546

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6322        6750    5012        6332
Length      7552    5012       426         565    1307         120

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
backup_dump                         518 external procedure  is an external procedure.  
on unit on line 181                  74 on unit               
on unit on line 351                  74 on unit               
on unit on line 474                 226 on unit               
append                               65 internal procedure  is called during a stack extension.  
idump_signal                            internal procedure  shares stack frame of on unit on line 474.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 init                        backup_dump
000012 linep                       backup_dump
000014 id                          backup_dump

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
backup_dump              000100 Sfatal_error                backup_dump
                         000101 Stape_entry                 backup_dump
                         000102 i                           backup_dump
                         000103 id_length                   backup_dump
                         000104 n                           backup_dump
                         000105 code                        backup_dump
                         000106 saved_code                  backup_dump
                         000107 old_trans_sw                backup_dump
                         000110 ts                          backup_dump
                         000111 calendar                    backup_dump
                         000116 ap                          backup_dump
                         000120 p                           backup_dump
                         000122 path_index                  backup_dump
                         000124 saved_dtd                   backup_dump
                         000126 old_256K_switch             backup_dump
                         000127 cross_dump_path             backup_dump
                         000201 cross_dump_dn               backup_dump
                         000253 dn                          backup_dump
                         000325 dump_dir                    backup_dump
                         000377 temp_dn                     backup_dump
                         000451 cross_dump_en               backup_dump
                         000461 text_line                   backup_dump
                         000574 type                        backup_dump
                         000575 btcnt                       backup_dump
                         000576 control_file_sw             backup_dump
                         000614 status                      backup_dump
on unit on line 474      000106 save_error                  idump_signal
                         000107 is_temp                     idump_signal
                         000110 is_code                     idump_signal
                         000112 is_linep                    idump_signal
                         000114 is_line                     idump_signal
                         000230 CI                          idump_signal

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  return_mac
tra_ext_2           enable_op           shorten_stack       ext_entry           int_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            backup_control_mgr_$initiate  backup_control_mgr_$terminate backup_dump_recurse
backup_dump_recurse$set_directory_dtd                       backup_map_$beginning_line    backup_map_$directory_line
backup_map_$fs_error_line     backup_map_$terminal_line     backup_util$get_real_name
bk_arg_reader_$dump_arg_reader                              bk_output$output_finish       bk_output$output_init
clock_                        com_err_                      continue_to_signal_           cu_$arg_count
cu_$arg_list_ptr              date_time_                    expand_pathname_              find_condition_info_
hcs_$fs_search_get_wdir       hcs_$make_seg                 hcs_$set_256K_switch          hcs_$set_max_length_seg
hcs_$status_minf              hcs_$terminate_noname         hcs_$truncate_seg             hphcs_$fs_get_trans_sw
hphcs_$restore_quota          hphcs_$suspend_quota          ioa_$rs                       ios_$attach
ios_$detach                   ios_$read

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bk_ss_$areap                  bk_ss_$caller_handles_conditions                            bk_ss_$check_effective_access
bk_ss_$control_name           bk_ss_$control_ptr            bk_ss_$data_iocb              bk_ss_$date
bk_ss_$datesw                 bk_ss_$debugsw                bk_ss_$dont_dump_upgraded_dirs
bk_ss_$dtdsw                  bk_ss_$ename                  bk_ss_$enforce_max_access_class
bk_ss_$enforce_min_access_class                             bk_ss_$err_label              bk_ss_$err_onlinesw
bk_ss_$error                  bk_ss_$holdsw                 bk_ss_$hp                     bk_ss_$mapsw
bk_ss_$maximum_access_class   bk_ss_$maximum_dir_access_class                             bk_ss_$minimum_access_class
bk_ss_$myname                 bk_ss_$namesw                 bk_ss_$no_contin              bk_ss_$no_output
bk_ss_$no_primary             bk_ss_$no_reload              bk_ss_$ntapes                 bk_ss_$onlysw
bk_ss_$path_index             bk_ss_$pathsw                 bk_ss_$preattached            bk_ss_$pvname
bk_ss_$pvsw                   bk_ss_$restart_dumpsw         bk_ss_$restart_path           bk_ss_$restart_plen
bk_ss_$rlen                   bk_ss_$save_path              bk_ss_$save_plen              bk_ss_$save_time
bk_ss_$segptr                 bk_ss_$sp                     bk_ss_$sub_entry              bk_ss_$sub_entry_errfile
bk_ss_$tapesw                 bk_ss_$trimsw                 bk_ss_$upgrade_to_user_auth   bk_ss_$user_authorization
bk_ss_$user_id                bk_ss_$user_ring              bk_ss_$wasnt_known            bk_ss_$writing_map
error_table_$no_s_permission  error_table_$noaccess         error_table_$noarg            error_table_$root
sys_info$seg_size_256K




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     56 000323       155 000331       156 000332       157 000333       158 000343       160 000344       165 000354
    166 000356       167 000360       168 000362       169 000363       171 000364       174 000375       175 000400
    176 000401       178 000403       179 000405       180 000406       181 000410       183 000424       184 000442
    185 000445       186 000457       188 000464       190 000501       192 000502       193 000514       195 000517
    196 000525       197 000527       198 000530       199 000531       200 000532       201 000535       202 000541
    203 000545       204 000551       205 000554       206 000562       208 000566       209 000572       212 000600
    213 000604       216 000612       217 000616       220 000624       221 000630       222 000631       223 000635
    224 000642       227 000644       229 000650       230 000657       231 000664       232 000665       233 000666
    234 000672       236 000674       237 000701       240 000702       243 000710       244 000712       245 000713
    247 000717       253 000730       255 000731       256 000733       257 000745       258 000774       259 001005
    260 001007       261 001022       263 001023       264 001025       265 001034       266 001037       267 001041
    268 001053       270 001054       271 001062       272 001064       273 001073       275 001110       276 001112
    277 001125       279 001164       280 001166       282 001216       284 001217       287 001263       288 001265
    290 001320       292 001321       294 001337       295 001344       300 001354       301 001365       302 001366
    303 001374       304 001404       308 001440       311 001536       312 001562       313 001564       314 001614
    316 001615       317 001616       319 001627       320 001632       321 001636       322 001640       323 001641
    325 001642       326 001644       327 001667       330 001670       332 001701       333 001731       334 001743
    335 001745       336 002010       339 002012       340 002013       341 002021       342 002053       348 002054
    349 002055       350 002056       351 002060       354 002077       356 002115       357 002120       358 002132
    360 002137       361 002140       363 002156       364 002161       365 002220       366 002233       367 002276
    368 002340       369 002343       371 002363       374 002364       375 002366       376 002423       377 002425
    379 002433       380 002461       386 002462       387 002464       389 002472       390 002475       391 002507
    392 002512       393 002514       395 002521       397 002547       400 002550       403 002561       404 002563
    405 002603       410 002626       414 002627       415 002632       416 002664       417 002675       420 002716
    421 002731       422 002743       423 002755       425 002773       426 003005       428 003023       429 003035
    430 003052       431 003055       432 003071       434 003101       436 003120       437 003135       438 003152
    440 003167       442 003204       444 003224       446 003241       447 003244       448 003304       450 003305
    451 003310       453 003320       454 003322       455 003361       456 003367       458 003375       461 003376
    463 003411       468 003416       469 003420       470 003422       471 003426       474 003441       479 003457
    480 003462       481 003474       482 003477       483 003512       484 003513       486 003523       487 003525
    488 003531       489 003555       490 003560       491 003561       492 003564       494 003611       495 003614
    496 003654       497 003661       498 003723       499 003735       501 003736       502 003757       503 003762
    504 003765       505 003771       512 003772       515 004003       516 004007       517 004013       518 004015
    519 004016       522 004023       523 004043       525 004046       528 004065       530 004070       535 004127
    536 004134       537 004140       538 004146       539 004161       540 004165       541 004166       542 004170
    543 004174       546 004205       548 004206       549 004207       551 004214       552 004215       553 004217
    554 004223       557 004234       559 004235       561 004264       563 004267       565 004274       567 004303
    571 004326       572 004327       573 004332       574 004336       577 004347       579 004356       580 004365
    582 004376       583 004412       584 004427       585 004444       587 004461       590 004477       592 004511
    596 004512       600 004526       601 004532       602 004533       603 004537       605 004545       606 004554
    608 004555       614 004556       627 004557       629 004566       630 004575       633 004576       634 004600
    635 004617       640 004655       641 004665       650 004666       651 004671       652 004672       653 004674
    654 004675       655 004677       657 004743       659 004754       660 004757       661 004760       662 004762
    664 004772       666 004774       668 004776       669 005005


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
