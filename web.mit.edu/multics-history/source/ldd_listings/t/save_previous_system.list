	COMPILATION LISTING OF SEGMENT save_previous_system
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/15/84  0856.8 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 save_previous_system: sps:	proc;
       12 
       13 
       14 dcl
       15      AREA			char(8) init ("hardcore"),
       16      ROOT			char(168) aligned,
       17      LIBRARY_DIR		char(168) aligned,
       18      HOLD_DIR		char(168) aligned,
       19      SYSID_STAR		char(32) aligned,
       20      SYS_ID		char(8) init ("0.0"),
       21      UPDATING_DIR		char(168) aligned,
       22      Nargs		fixed bin,
       23      acode		fixed bin,
       24      area_ptr		ptr,
       25      arg			char(arg_len) based (arg_ptr),
       26      arg_len		fixed bin,
       27      arg_ptr		ptr,
       28      bitc			fixed bin(24),
       29      code			fixed bin(35),
       30      error		bit(1) init ("0"b),
       31      found		bit(1) init ("0"b),
       32      i			fixed bin,
       33      k			fixed bin,
       34      me			char(32) init ("save_previous_system"),
       35      restart_sw		bit(1) init ("0"b),
       36      rev_sw		bit(1) init ("0"b),
       37      ringbr (3)		fixed bin(3) init ( 7, 7, 7 ),
       38      segname		char(32) aligned,
       39      segptr		ptr;
       40 
       41 dcl  1  entries (entry_count) aligned based (entry_ptr),
       42        (2  type		bit(2),
       43         2  nnames		fixed bin(15),
       44         2  nindex		fixed bin(17) ) unaligned;
       45 
       46 dcl
       47      entry_count		fixed bin,
       48      entry_ptr		ptr,
       49      name_ptr		ptr,
       50      names (entry_count)	char(32) based (name_ptr);
       51 
       52 dcl ( rtrim, substr, addr, null, index )	builtin;
       53 
       54 dcl
       55      cu_$arg_count			entry returns (fixed bin),
       56      cu_$arg_ptr 			entry ( fixed bin, ptr, fixed bin, fixed bin(35)),
       57      get_group_id_$tag_star		entry returns (char(32)),
       58      get_system_free_area_		entry returns (ptr),
       59      hcs_$add_inacl_entries		entry ( char(*) aligned, char(*), ptr, fixed bin, fixed bin(3), fixed bin(35) ),
       60      hcs_$append_branchx		entry ( char(*) aligned, char(*), fixed bin(5), (3) fixed bin(3),
       61 				     char(*) aligned, fixed bin(1), fixed bin(1), fixed bin(24), fixed bin(35) ),
       62      hcs_$add_dir_acl_entries		entry ( char(*) aligned, char(*), ptr, fixed bin, fixed bin(35) ),
       63      hcs_$star_			entry ( char(*) aligned, char(*) aligned, fixed bin(2), ptr, fixed bin, ptr, ptr,
       64 				 fixed bin(35)),
       65      hcs_$terminate_noname		entry ( ptr, fixed bin(35)),
       66      hcs_$initiate_count		entry ( char(*) aligned, char(*), char(*), fixed bin(24),
       67 				     fixed bin(2), ptr, fixed bin(35)),
       68      com_err_			entry options (variable),
       69      archive_util_$first_disected
       70 				entry ( ptr, ptr, char(*) aligned, fixed bin(24), fixed bin),
       71      archive_util_$disected_element
       72 				entry ( ptr, ptr, char(*) aligned, fixed bin(24), fixed bin),
       73 	lib_fetch_		entry (ptr, ptr, ptr, bit(72) aligned, bit(36) aligned, ptr, fixed bin(35));
       74 
       75 
       76 
       77 dcl  1  dir_acl 		aligned,
       78         2  access_name	char(32),
       79         2  dir_modes	bit(36),
       80         2  code		fixed bin(35);
       81 dcl  1  segment_acl		aligned,
       82         2  access_name	char(32),
       83         2  modes		bit(36),
       84         2  pad		bit(36),
       85         2  code		fixed bin(35);
       86 
       87 
       88 dcl  error_table_$archive_fmt_err	ext fixed bin(35),
       89      error_table_$bad_arg		ext fixed bin(35),
       90      error_table_$namedup		ext fixed bin(35),
       91      error_table_$noarg		ext fixed bin(35),
       92      error_table_$argerr		ext fixed bin(35),
       93      error_table_$noentry		ext fixed bin(35),
       94      error_table_$no_dir		ext fixed bin(35);
       95 
       96      dcl						/*	automatic variables			*/
       97 	1 arg_struc_temp		like arg_struc;	/* storage for argument structure.		*/
       98 
       99 dcl  True			bit(1) aligned init ("1"b);
      100 
      101 dcl  cleanup		condition;
      102 
      103 	area_ptr = null;
      104 	entry_ptr = null;
      105 	name_ptr = null;
      106 	dir_acl.access_name = get_group_id_$tag_star();		/* ME */
      107 	dir_acl.dir_modes = "111"b;				/*  "sma"  */
      108 	dir_acl.code = 0;
      109 	segment_acl.access_name = "*.*.*";			/*  everyone  */
      110 	segment_acl.modes = "100"b;				/*  "r"  */
      111 	segment_acl.pad = "0"b;
      112 	segment_acl.code = 0;
      113 
      114 	Nargs = cu_$arg_count ();
      115 	if Nargs < 1 then do;				/* MUST give at least 1 argumment */
      116 	     call com_err_ ((error_table_$noarg), me,
      117 		"^/Usage is: ^a <system-id> {-library LIBRARY} {-restart}", me );
      118 	     return;
      119 	end;
      120 
      121 	call cu_$arg_ptr ( 1, arg_ptr, arg_len, code );		/* Get first argument. */
      122 	if code ^= 0 then do;				/* This MUST be the system-id. */
      123 	     call com_err_ ( code, me, "Processing argument #1." );
      124 	     return;
      125 	end;
      126 	if substr ( arg, 1, 1 ) = "-" then do;			/* control argument not allowed here */
      127 	     call com_err_ (0, me, """^a"" is an invalid system id", arg);
      128 	     return;
      129 	end;
      130 	if arg_len > 8 then do;
      131 	     call com_err_ ( error_table_$bad_arg, me,
      132 		"^/The <system-id> argument must be 8 characters or less:  ^a", arg );
      133 	     return;
      134 	end;
      135 	SYS_ID = arg;
      136 
      137 	i = 1;
      138 	do while ( i < Nargs );				/* Process rest of arguments */
      139 	     i = i + 1;
      140 	     call cu_$arg_ptr ( i, arg_ptr, arg_len, code );
      141 	     if code ^= 0 then do;
      142 		call com_err_ (code, me, "Processing argment # ^d", i);
      143 		return;
      144 	     end;
      145 
      146 	     else if arg = "-restart"
      147 		then restart_sw = "1"b;
      148 
      149 	     else if arg = "-library" then do;
      150 		i = i + 1;
      151 		call cu_$arg_ptr ( i, arg_ptr, arg_len, code );
      152 		if code ^= 0 then do;
      153 		     call com_err_ (code, me, "The ""-library"" control argument requires an argument." );
      154 		     error = "1"b;
      155 		     go to next_arg;
      156 		end;
      157 		if substr ( arg, 1, 1) = "-" then do;
      158 		     call com_err_ (error_table_$bad_arg, me,
      159 			"^/Incorrect argument following the ""-library"" control argument." );
      160 		     error = "1"b;
      161 		     go to next_arg;
      162 		end;
      163 		if ^VERIFY_AREA ( arg ) then do;		/* verify the area name		*/
      164 		     call com_err_ (error_table_$bad_arg, me,
      165 			"^/Incorrect area specified following the ""-library"" control argument.  ^a", arg  );
      166 		     error = "1"b;
      167 		     go to next_arg;
      168 		end;
      169 	     end;
      170 
      171 	     else do;
      172 		call com_err_(error_table_$bad_arg, me, "^/The ""^a"" argument is not implemented.", arg );
      173 		error = "1"b;
      174 	     end;
      175 
      176 next_arg:
      177 	end;
      178 
      179 	if error						/* ON if argument error.   */
      180 	     then return;					/* Already reported, so leave gracefully. */
      181 
      182 							/* build directory pathnames given system ID */
      183 	if AREA ^= "mcs"
      184 	     then ROOT = ">ldd>" || AREA;			/* e.g.  ">ldd>hardcore"		*/
      185 	     else ROOT = ">ldd>comm>fnp";			/* special case MCS dirs		*/
      186 
      187 	UPDATING_DIR = rtrim ( ROOT ) || ">" || SYS_ID;			/* e.g.  ">ldd>hardcore>34.21"	*/
      188 	LIBRARY_DIR  = rtrim ( ROOT ) || ">" || "source";			/* e.g.  ">ldd>hardcore>source"	*/
      189 	HOLD_DIR     = rtrim ( ROOT ) || ">" || rtrim ( SYS_ID ) || "hold";	/* e.g.  ">ldd>hardcore>34.21hold"	*/
      190 
      191 	area_ptr = get_system_free_area_ ();
      192 							/* get list of names in updating directory */
      193 	call hcs_$star_ ( UPDATING_DIR, "**", 2, area_ptr, entry_count, entry_ptr, name_ptr, code );
      194 	if code ^= 0 then do;
      195 		if code = error_table_$no_dir
      196 		     then call com_err_ ( code, me, "^/Updating directory ^a not found.", UPDATING_DIR );
      197 		     else call com_err_ ( code, me, "^a", UPDATING_DIR  );
      198 	     return;					/* if it ain't there, or can't get to it... */
      199 	end;
      200 	if entry_count = 0 then do;				/* no entries found ?? */
      201 	     call com_err_ ( error_table_$noentry, me, "^a", UPDATING_DIR );
      202 	     return;
      203 	end;
      204 
      205 	on cleanup call CLEANUP;				/* set up a cleanup handler	*/
      206 							/* create the "HOLD" directory for previous source */
      207 	call hcs_$append_branchx ( ROOT, (rtrim (SYS_ID)) || "hold", 01011b, ringbr, dir_acl.access_name, 1, 0, 0, code );
      208 	if code ^= 0
      209 	     then if code = error_table_$namedup then do;		/* it's already there, make sure we're on the ACL */
      210 		call hcs_$add_dir_acl_entries ( ROOT, (rtrim(SYS_ID)) || "hold", addr(dir_acl), 1, code );
      211 		if code ^= 0 then do;
      212 		     if code = error_table_$argerr
      213 			then code = dir_acl.code;
      214 		     call com_err_ ( code, me, "^/Unable to set access on ^a", HOLD_DIR );
      215 		     return;
      216 		end;
      217 	     end;
      218 	     else do;
      219 		call com_err_ ( code, me, "^/Unable to create save directory ^a", HOLD_DIR );
      220 		return;
      221 	     end;
      222 
      223 	call INIT;					/* initialize some variables for lib_fetch_. */
      224 							/* add initial ACL for "r *.*.*" */
      225 	call hcs_$add_inacl_entries ( ROOT, (rtrim(SYS_ID) || "hold"), addr(segment_acl), 1, 4, code );
      226 	if code ^= 0					/* this is not a fatal error */
      227 	     then call com_err_ ((segment_acl.code), me, "^/Warning: Unable to add initial ACL entry to ^a>^a",
      228 		ROOT, (rtrim(SYS_ID) || "hold") );
      229 
      230 	STARNAME.N = 1;					/* Initialize number of names. */
      231 
      232 	do i = 1 to entry_count;				/* for each entry... */
      233 
      234 	     k = entry_ptr -> entries(i).nindex;		/* set index into names array */
      235 
      236 	     call FETCH ( names(k) );				/* FETCH exercise the judgement */
      237 
      238 	end;
      239 
      240 	revert cleanup;					/* turn off handler */
      241 	call CLEANUP;					/* make sure we cleanup anyhow */
      242 	return;						/* NORMAL RETURN */
      243 
      244 FETCH:  procedure ( fetch_name );
      245 
      246 dcl
      247      fetch_name		char(*),				/* entry name from UPDATING_DIR */
      248      diff_names (1000)	char(32),				/* for comparison of archive entries */
      249      diff_count		fixed bin,			/* and the number of "diff_names" */
      250      i			fixed bin;
      251 
      252 
      253 	if index ( fetch_name, ".s.archive" ) ^= 0		/* special case source archives */
      254 	     then go to source_ac;
      255 
      256 	if ^STATUS ( LIBRARY_DIR, fetch_name )			/* if it's not there...	*/
      257 	     then return;
      258 
      259 	STARNAME.group(1).V = fetch_name;			/* fill in info for lib_fetch_ */
      260 	STARNAME.group(1).C = 0;				/* zero code */
      261 
      262 	if ^Sc.default & ^S.names & ^S.matching_names & ^S.primary_name then
      263 	     S.matching_names = True;				/* use matching names by default.		*/
      264 
      265 							/* CALL LIB_FETCH_				*/
      266 	call lib_fetch_ (addr(LIBRARY), addr(STARNAME), addr(EXCLUDE), Srequirements, Scontrol, addr(arg_struc), code);
      267 							/* all errors reported by lib_fetch_.		*/
      268 	return;						/* and return				*/
      269 
      270 source_ac:						/* SPECIAL CASE OF SOURCE ARCHIVES		*/
      271 							/* call subr. to get names of component changes	*/
      272 							/* A deletion, or a date-time-updated difference	*/
      273 							/* is assumed to be a change.			*/
      274 	call compare_archives_ ( LIBRARY_DIR, fetch_name, UPDATING_DIR, fetch_name, diff_names, diff_count );
      275 
      276 	if diff_count = 0 then do;				/* 0 = there were no changes made (??)		*/
      277 	     call com_err_ (0, me, "Warning: ^a>^a^/^5xis identical to ^a>^a.",
      278 		UPDATING_DIR, fetch_name, LIBRARY_DIR, fetch_name );
      279 		return;					/* warn user and continue			*/
      280 	end;
      281 
      282 	do i = 1 to diff_count;				/* and for each one of the changes... */
      283 	     call FETCH ( diff_names(i) );			/* recurse... */
      284 	end;
      285 	return;
      286 	end FETCH;
      287 
      288 
      289 STATUS:  proc ( path, entry ) returns ( bit(1) );
      290 
      291 dcl  path  char(168) aligned,
      292      entry char(*),
      293      status bit(144) aligned,
      294      hcs_$status_ entry ( char(*) aligned, char(*), fixed bin(1), ptr, ptr, fixed bin(35));
      295 
      296 	call hcs_$status_ ( path, entry, 1, addr(status), null, code );
      297 	if code ^= 0
      298 	     then return ("0"b);
      299 	     else return ("1"b);
      300 
      301 	end STATUS;
      302 
      303 
      304 
      305 CLEANUP:	procedure;
      306 
      307 	if entry_ptr ^= null					/* free up some space	*/
      308 	     then free entries;
      309 	entry_ptr = null;
      310 
      311 	if name_ptr ^= null
      312 	     then free names;
      313 	name_ptr = null;
      314 
      315 	return;
      316 end CLEANUP;
      317 
      318 VERIFY_AREA:  procedure ( system_name ) returns ( bit(1) );
      319 
      320 dcl
      321      system_name		char(*),					/* argument given by user		*/
      322      valid_names (6)	char(12) init				/* "legal" names			*/
      323 	( "hardcore", "hard", "supervisor", "sup", "bos", "mcs" ),
      324      area_index  (6)	fixed bin init
      325 	( 1, 1, 1, 1, 2, 3 ),
      326      proper_name (3)	char(8) init				/* proper name equivalent		*/
      327 	( "hardcore", "bos", "mcs" );
      328 
      329 	do i = 1 to dim ( valid_names, 1 );				/* check against "legal" names	*/
      330 	    if system_name = valid_names(i) then do;
      331 		AREA = proper_name ( area_index(i) );			/* set to proper name		*/
      332 		go to found_area;
      333 	     end;
      334 	end;
      335 								/* didn't find proper name		*/
      336 	return ("0"b);						/* return FALSE			*/
      337 
      338 found_area:
      339 	return ("1"b);						/* return TRUE			*/
      340 
      341 end VERIFY_AREA;
      342 
      343 INIT: proc;
      344 
      345 	Parg_struc = addr(arg_struc_temp);		/* Initialize argument processing structure.	*/
      346 	arg_struc.version = Varg_struc_1;
      347 	arg_struc.program = me;			/*  caller  */
      348 	arg_struc.put_error = com_err_;
      349 	arg_struc.descriptor = "";			/* use default library_descriptor */
      350 	arg_struc.into_path = rtrim (HOLD_DIR) || ">==";	/* where segments are to be put */
      351 	arg_struc.output_file = "";
      352 	LIBRARY.N = 1;				/* only search the source library for */
      353 	LIBRARY.group(1).V = rtrim(AREA) || ".s";	/* specified area.     */
      354 	LIBRARY.group(1).C = 0;			/* since we filled it in... */
      355 
      356 	STARNAME.N = 1;
      357 	arg_struc.Srequirements_allowed = ""b;
      358 	arg_struc.Srequirements_initial = ""b;
      359 	arg_struc.Scontrol_allowed = ""b;
      360 	arg_struc.Scontrol_initial = ""b;
      361 
      362 	Sreq_allowed.access_class        = True;	/* Mark Sreq bits-  show which output args allowed*/
      363 	Sreq_allowed.acl                 = True;
      364 	Sreq_allowed.aim                 = True;
      365 	Sreq_allowed.author              = True;
      366 	Sreq_allowed.bit_count           = True;
      367 	Sreq_allowed.bit_count_author    = True;
      368 	Sreq_allowed.compiler_name       = True;
      369 	Sreq_allowed.compiler_options    = True;
      370 	Sreq_allowed.compiler_version    = True;
      371 	Sreq_allowed.copy                = True;
      372 	Sreq_allowed.current_length      = True;
      373 	Sreq_allowed.dtc                 = True;
      374 	Sreq_allowed.dtd                 = True;
      375 	Sreq_allowed.dtem                = True;
      376 	Sreq_allowed.dtm                 = True;
      377 	Sreq_allowed.dtu                 = True;
      378 	Sreq_allowed.entry_bound         = True;
      379 	Sreq_allowed.iacl                = True;
      380 	Sreq_allowed.kids                = True;
      381 	Sreq_allowed.kids_error          = True;
      382 	Sreq_allowed.level               = True;
      383 	Sreq_allowed.link_target         = True;
      384 	Sreq_allowed.lvid                = True;
      385 	Sreq_allowed.matching_names      = True;
      386 	Sreq_allowed.max_length          = True;
      387 	Sreq_allowed.mode                = True;
      388 	Sreq_allowed.msf_indicator       = True;
      389 	Sreq_allowed.names               = True;
      390 	Sreq_allowed.new_line            = True;
      391 	Sreq_allowed.not_ascii           = True;
      392 	Sreq_allowed.object_info         = True;
      393 	Sreq_allowed.offset              = True;
      394 	Sreq_allowed.pathname            = True;
      395 	Sreq_allowed.primary_name        = True;
      396 	Sreq_allowed.pvid                = True;
      397 	Sreq_allowed.quota               = True;
      398 	Sreq_allowed.rb                  = True;
      399 	Sreq_allowed.records_used        = True;
      400 	Sreq_allowed.root_search_proc    = True;
      401 	Sreq_allowed.safety              = True;
      402 	Sreq_allowed.type                = True;
      403 	Sreq_allowed.unique_id           = True;
      404 	Sreq_allowed.user                = True;
      405 
      406 
      407 
      408 	Sreq_init.user		   = True;	/* Mark bits on by default.			*/
      409 
      410 	Sc_allowed.acl            = True;		/* Mark Sc bits- show which ctl args allowed.	*/
      411 	Sc_allowed.all_status     = True;
      412 	Sc_allowed.chase          = True;
      413 	Sc_allowed.check_archive  = True;
      414 	Sc_allowed.check_ascii    = True;
      415 	Sc_allowed.components     = True;
      416 	Sc_allowed.container      = True;
      417 	Sc_allowed.default        = True;
      418 	Sc_allowed.iacl           = True;
      419 	Sc_allowed.object_info    = True;
      420 	Sc_allowed.quota          = True;
      421 	Sc_allowed.retain         = True;
      422 	Sc_allowed.descriptor     = True;
      423 	Sc_allowed.into_path      = True;
      424 	Sc_allowed.long           = True;
      425 	Sc_allowed.library        = True;
      426 	Sc_allowed.output_file    = True;
      427 	Sc_allowed.search_names   = True;
      428 
      429 	Sc_init.into_path 	      = True;		/* Mark bits for ctl args supplied by default.	*/
      430 	Sc_init.default           = True;
      431 
      432 	end INIT;
      433 
      434 
      435 compare_archives_:	procedure ( first_dir, first_entry, second_dir, second_entry, return_array, return_count );
      436 
      437 dcl
      438      first_dir		char(*) aligned,
      439      second_dir		char(*) aligned,
      440      first_entry		char(*),
      441      second_entry		char(*),
      442      return_array (1000)	char(32),
      443      return_count		fixed bin;
      444 
      445 dcl
      446     (i, j, x)		fixed bin,
      447      head_ptr		ptr,
      448      save_ptr		ptr,
      449      seg_name		char(32),
      450      bit_count		fixed bin(24),
      451      bitc			fixed bin(24),
      452      acode		fixed bin,
      453      seg_ptr		ptr,
      454      first_count		fixed bin,
      455      second_count		fixed bin,
      456      code			fixed bin(35),
      457      error_table_$archive_fmt_err
      458 			ext fixed bin(35),
      459      null			builtin,
      460      index		builtin,
      461      me			char(2) init ("me");
      462 
      463 dcl
      464      com_err_			entry options (variable),
      465      hcs_$initiate_count		entry (char(*) aligned, char(*), char(*), fixed bin(24), fixed bin(2), ptr, fixed bin(35)),
      466      hcs_$terminate_noname		entry ( ptr, fixed bin(35)),
      467      archive_util_$first_disected	entry ( ptr, ptr, char(*), fixed bin(24), fixed bin),
      468      archive_util_$disected_element	entry ( ptr, ptr, char(*), fixed bin(24), fixed bin);
      469 
      470 dcl  1  archive_item aligned based (head_ptr),
      471       (2  header_begin	char(8),
      472        2  pad1		char(4),
      473        2  name		char(32),
      474        2  dtupd		char(16),
      475        2  mode		char(4),
      476        2  dtm		char(16),
      477        2  pad2		char(4),
      478        2  bitct		char(8),
      479        2  header_end	char(8) ) unal;
      480 
      481 
      482 dcl  1    first_array (1000)	aligned,
      483 	2  name		char(32),
      484 	2  date		char(16),
      485 	2  bitc		char(8);
      486 
      487 dcl  1    second_array (1000)	aligned,
      488 	2  name		char(32),
      489 	2  date		char(16),
      490 	2  bitc		char(8);
      491 
      492 	return_count = 0;						/* just in case we return abnormally	*/
      493 
      494 	head_ptr = null;						/* initiate the first archive		*/
      495 	call hcs_$initiate_count ( first_dir, first_entry, "", bit_count, 1, head_ptr, code );
      496 	if head_ptr = null then do;
      497 	     call com_err_ ( code, me, "^/Attempting to initiate ^a>^a", first_dir, first_entry);
      498 	     return;
      499 	end;
      500 
      501 	save_ptr = head_ptr;					/* save it's ptr for later termination	*/
      502 	acode, j, x = 0;
      503 								/* get the first component info	*/
      504 	call archive_util_$first_disected ( head_ptr, seg_ptr, seg_name, bitc, acode );
      505 
      506 	do while ( acode = 0 );					/* process each component		*/
      507 	     j = j + 1;
      508 	     first_array (j).name = seg_name;				/* name...			*/
      509 	     first_array (j).date = head_ptr -> archive_item.dtupd;		/* date-time-updated...		*/
      510 	     first_array (j).bitc = head_ptr -> archive_item.bitct;		/* bit-count...			*/
      511 
      512 								/* is there next component ??		*/
      513 	     call archive_util_$disected_element ( head_ptr, seg_ptr, seg_name, bitc, acode );
      514 								/* acode = 0 means there's next	*/
      515 	end;
      516 
      517 	first_count = j;						/* number in first archive		*/
      518 	call hcs_$terminate_noname ( save_ptr, code );			/* terminate it			*/
      519 	if acode = 2 then do;					/* was there a format error ??	*/
      520 	     call com_err_ ( error_table_$archive_fmt_err, me, "^/Referencing ^a>^a", first_dir, first_entry);
      521 	     return;
      522 	end;
      523 
      524 	head_ptr = null;						/* and do the same for the second	*/
      525 	call hcs_$initiate_count ( second_dir, second_entry, "", bit_count, 1, head_ptr, code );
      526 	if head_ptr = null then do;
      527 	     call com_err_ ( code, me, "^/Attempting to initiate ^a>^a", second_dir, second_entry);
      528 	     return;
      529 	end;
      530 
      531 	save_ptr = head_ptr;
      532 	acode, j = 0;
      533 								/* get first component info		*/
      534 	call archive_util_$first_disected ( head_ptr, seg_ptr, seg_name, bitc, acode );
      535 
      536 	do while ( acode = 0 );					/* and for each component...		*/
      537 	     j = j + 1;
      538 	     second_array (j).name = seg_name;				/* name...			*/
      539 	     second_array (j).date = head_ptr -> archive_item.dtupd;	/* date-time-updated...		*/
      540 	     second_array (j).bitc = head_ptr -> archive_item.bitct;	/* bit-count...			*/
      541 
      542 								/* is there a next ??		*/
      543 	     call archive_util_$disected_element ( head_ptr, seg_ptr, seg_name, bitc, acode );
      544 								/* acode = 0 means yes		*/
      545 	end;
      546 
      547 	second_count = j;						/* set number in second archive	*/
      548 	call hcs_$terminate_noname ( save_ptr, code );			/* and terminate it			*/
      549 	if acode = 2 then do;					/* format error occurred ??		*/
      550 	     call com_err_ ( error_table_$archive_fmt_err, me, "^/Referencing ^a>^a", second_dir, second_entry);
      551 	     return;
      552 	end;
      553 						/* If entry exists in the first archive, but not in the	*/
      554 						/* second one, put it into our return array.		*/
      555 	do i = 1 to first_count;			/* If the date-time-updated differs between the two for	*/
      556 	     do j = 1 to second_count;		/* a component, also put it into the list.		*/
      557 		if first_array (i).name = second_array (j).name then do;
      558 		     if first_array (i).date ^= second_array (j).date then do;
      559 			x = x + 1;				/* DIFFERENT date-time-updated	*/
      560 			return_array (x) = first_array (i).name;	/* ADD IT TO RETURN ARRAY		*/
      561 		     end;
      562 		     go to next_first;
      563 		end;
      564 	     end;
      565 	     x = x + 1;						/* NAME NOT FOUND IN SECOND ARCHIVE	*/
      566 	     return_array (x) = first_array (i).name;			/* ADD TO RETURN ARRAY		*/
      567 next_first:   
      568 	end;
      569 
      570 	return_count = x;						/* SET THE RETURN COUNT AND RETURN	*/
      571 	return;
      572 end compare_archives_;
      573 
  1     1 /* START OF	lib_arg_struc_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* NAME:  lib_arg_struc_.incl.pl1						*/
  1     6 	/*									*/
  1     7 	/*      This include segment defines structures used by the library maintenance tools	*/
  1     8 	/* to process their input arguments.  These structures are the arguments to the		*/
  1     9 	/* lib_args_ subroutine.							*/
  1    10 	/*									*/
  1    11 	/* STATUS									*/
  1    12 	/*									*/
  1    13 	/* 0) Created on:   May 25, 1976 by   Gary C. Dixon				*/
  1    14 	/* 1) Modified:     October 24, 1983 by Jim Lippard to add page_length		*/
  1    15 	/*									*/
  1    16 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    17 
  1    18 
  2     1 /* START OF:	lib_args_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 	/*									*/
  2     5 	/* N__a_m_e:  lib_args_.incl.pl1							*/
  2     6 	/*									*/
  2     7 	/*      This include segment defines structures for the arrays of library names and search*/
  2     8 	/* names used by library descriptor commands.  This segment, lib_Svalid_req_.incl.pl1,	*/
  2     9 	/* and lib_Scontrol_.incl.pl1 define the complete set of structures required as input	*/
  2    10 	/* to the lib_descriptor_ subroutine.						*/
  2    11 	/*									*/
  2    12 	/* S__t_a_t_u_s									*/
  2    13 	/*									*/
  2    14 	/* 0) Created on:   March 1, 1975 by  A. J. Scherer				*/
  2    15 	/* 1) Modified on:  April 8, 1975 by  G. C. Dixon					*/
  2    16 	/* 2) Modified on:  May 13, 1976 by  G. C. Dixon					*/
  2    17 	/* 3) Modified on:  January 17, 1984 by Jim Lippard to make structures aligned.		*/
  2    18 	/*									*/
  2    19 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    20 
  2    21 
  2    22      dcl	1 LIBRARY			aligned,		/* a structure containing names of libraries to	*/
  2    23 						/*   be searched.				*/
  2    24 	  2 N			fixed bin,	/*   attribute: number of library names in array.	*/
  2    25 	  2 group (100),				/*   attribute: array of library names		*/
  2    26 	    3 V			char(32) unal,	/*   attribute: a library name (value).		*/
  2    27 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  2    28 						/*     this library name.			*/
  2    29 
  2    30      dcl	1 STARNAME		aligned,		/* a structure containing names of library entries*/
  2    31 						/*   being searched for.			*/
  2    32 	  2 N			fixed bin,	/*   attribute: number of starnames in array.	*/
  2    33 	  2 group (1000),				/*   attribute: array of starnames		*/
  2    34 	    3 V			char(32) unal,	/*   attribute: a starname (value).		*/
  2    35 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  2    36 						/*     this starname.			*/
  2    37 
  2    38      dcl 	1 EXCLUDE			aligned like STARNAME;
  2    39 						/* structure containing names of library entries	*/
  2    40 						/*   to be excluded from a search.		*/
  2    41 
  2    42 /* END OF:	lib_args_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    19 
  1    20 
  1    21      dcl	Parg_struc		ptr;		/* ptr to the structure described below.	*/
  1    22 
  1    23      dcl	1 arg_struc		structure based (Parg_struc),
  1    24 	  2 version		fixed bin,	/* version number (currently 1).		*/
  1    25 	  2 program		char(32) varying,	/* name of calling program. 			*/
  1    26 	  2 Parg_list		ptr,		/* ptr to calling program's argument list. 	*/
  1    27 	  2 Iarg_list		fixed bin,	/* first arg of calling program's argument list	*/
  1    28 						/*   to be processed.			*/
  1    29 	  2 Larg_list		fixed bin,	/* total number of arguments in calling pgm's list*/
  1    30 	  2 put_error		entry options(variable),
  1    31 						/* program to call to output an error.		*/
  1    32 	  2 Srequirements_allowed	bit(72) aligned,	/* bits on if control argument associated with	*/
  1    33 						/*   that bit is acceptable to the program. 	*/
  1    34 	  2 Scontrol_allowed	bit(36) aligned,	/* bits on if control operation associated with	*/
  1    35 						/*   that bit is acceptable to the program. 	*/
  1    36 	  2 Srequirements_initial	bit(72) aligned,	/* bits on indicating initial settings for 	*/
  1    37 						/*   Srequirements. 			*/
  1    38 	  2 Scontrol_initial	bit(36) aligned,	/* bits on indicating initial settings for	*/
  1    39 						/*   Scontrol.  				*/
  1    40 	  2 descriptor		char(168) varying,	/* name of library descriptor to be used. 	*/
  1    41 	  2 footing		char(45) varying,	/* footing to be used on output pages. 		*/
  1    42 	  2 heading		char(120) varying,	/* heading to be used on 1st output page.	*/
  1    43 	  2 into_path		char(168) varying,	/* path into which library entries to be fetched.	*/
  1    44 	  2 output_file		char(168) varying,	/* path of output file to be written.		*/
  1    45 	  2 page_length		fixed bin,	/* length of output page			*/
  1    46 	  2 time			fixed bin;	/* grace period (in days) for library_cleanup.	*/
  1    47      dcl	1 Sreq_allowed		aligned like Svalid_req based (addr(arg_struc.Srequirements_allowed));
  1    48 						/* allowed requirements switches.		*/
  1    49      dcl	1 Sreq_init		aligned like Svalid_req based (addr(arg_struc.Srequirements_initial));
  1    50 						/* initial values for requirements switches.	*/
  1    51      dcl	1 Sc_allowed		aligned like Sc based (addr(arg_struc.Scontrol_allowed));
  1    52 						/* allowed control switches.			*/
  1    53      dcl	1 Sc_init			aligned like Sc based (addr(arg_struc.Scontrol_initial));
  1    54 						/* initial values for control switches.		*/
  1    55      dcl	Varg_struc_1		fixed bin int static init (1);
  1    56 
  1    57 /* END OF		lib_arg_struc_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      574 
      575 
  3     1 /* START OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* N__a_m_e:  lib_Svalid_req_.incl.pl1						*/
  3     6 	/*									*/
  3     7 	/*      This include segment defines the switches which request/validate the fields	*/
  3     8 	/* in a status node produced by lib_get_tree_.  This segment, lib_Scontrol_.incl.pl1,	*/
  3     9 	/* and lib_args_.incl.pl1 define the complete set of structures required as input to	*/
  3    10 	/* the lib_descriptor_ subroutine.  This subroutine is called by all of the library	*/
  3    11 	/* descriptor commands to obtain information about entries in a library.		*/
  3    12 	/*									*/
  3    13 	/*      If a switch is on, then the corresponding information in the node is valid, or 	*/
  3    14 	/* is requested for output.							*/
  3    15 	/*									*/
  3    16 	/* S__t_a_t_u_s									*/
  3    17 	/*									*/
  3    18 	/* 0) Created on:   April 8, 1975  by  G. C. Dixon				*/
  3    19 	/*									*/
  3    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    21 
  3    22 
  3    23      dcl	1 Svalid_req		aligned based,
  3    24 	  2 primary_name		bit(1) unal,	/* switch: output includes primary name	   	*/
  3    25 	  2 matching_names		bit(1) unal,	/* switch: output includes matching names  	*/
  3    26 	  2 names			bit(1) unal,	/* switch: output includes all names	   	*/
  3    27 
  3    28 	  2 pathname		bit(1) unal,	/* switch: output include pathname of node target	*/
  3    29 	  2 kids			bit(1) unal,	/* switch: children nodes (inferior) exist	*/
  3    30 	  2 kids_error		bit(1) unal,	/* switch: error occurred obtaining kid's info	*/
  3    31 
  3    32 	  2 type			bit(1) unal,	/* switch: type 			   	*/
  3    33 	  2 mode			bit(1) unal,	/* switch: user's access mode to node target	*/
  3    34 	  2 safety		bit(1) unal,	/* switch: safety switch setting		*/
  3    35 
  3    36 	  2 aim			bit(1) unal,	/* switch: Access Isolation Mechanism switches	*/
  3    37 	  2 copy			bit(1) unal,	/* switch: copy-on-write switch setting		*/
  3    38 	  2 unique_id		bit(1) unal,	/* switch: unique identifier		   	*/
  3    39 
  3    40 	  2 author		bit(1) unal,	/* switch: author of node target		*/
  3    41 	  2 dtem			bit(1) unal,	/* switch: date attributes modified	   	*/
  3    42 	  2 dtd			bit(1) unal,	/* switch: date dumped		   	*/
  3    43 
  3    44 	  2 link_target		bit(1) unal,	/* switch: target pathname of link node		*/
  3    45 	  2 dtm			bit(1) unal,	/* switch: date modified		   	*/
  3    46 	  2 dtu			bit(1) unal,	/* switch: date used		   	*/
  3    47 
  3    48 	  2 rb			bit(1) unal,	/* switch: ring brackets		   	*/
  3    49 	  2 access_class		bit(1) unal,	/* switch: AIM access class		   	*/
  3    50 	  2 records_used		bit(1) unal,	/* switch: records used		   	*/
  3    51 
  3    52 	  2 current_length		bit(1) unal,	/* switch: current length		   	*/
  3    53 	  2 max_length		bit(1) unal,	/* switch: maximum length			*/
  3    54 	  2 msf_indicator		bit(1) unal,	/* switch: count of MSF components.		*/
  3    55 
  3    56 	  2 bit_count		bit(1) unal,	/* switch: bit count		   	*/
  3    57 	  2 bit_count_author	bit(1) unal,	/* switch: bit count author.			*/
  3    58 	  2 offset		bit(1) unal,	/* switch: offset from segment base	   	*/
  3    59 
  3    60 	  2 entry_bound		bit(1) unal,	/* switch: call limit for gate node		*/
  3    61 	  2 lvid			bit(1) unal,	/* switch: logical volume id	   		*/
  3    62 	  2 pvid			bit(1) unal,	/* switch: physical volume id			*/
  3    63 
  3    64 	  2 quota			bit(1) unal,	/* switch: directory quota information		*/
  3    65 	  2 acl			bit(1) unal,	/* switch: ACL			   	*/
  3    66 	  2 iacl			bit(1) unal,	/* switch: initial ACLs		   	*/
  3    67 
  3    68 	  2 dtc			bit(1) unal,	/* switch: date-time compiled      		*/
  3    69 	  2 compiler_name		bit(1) unal,	/* switch: name of compiler			*/
  3    70 	  2 compiler_version	bit(1) unal,	/* switch: compiler version number         	*/
  3    71 
  3    72 	  2 compiler_options	bit(1) unal,	/* switch: compiler options info	   	*/
  3    73 	  2 object_info		bit(1) unal,	/* switch: other object segment info       	*/
  3    74 	  2 not_ascii		bit(1) unal,	/* switch: contents is not printable       	*/
  3    75 
  3    76 	  2 user			bit(1) unal,	/* switch: user-defined node information	*/
  3    77 	  2 root_search_proc	bit(1) unal,	/* switch: root search procedure info.		*/
  3    78 	  2 prev_mode		bit(1) unal,	/* switch: user's previous acces mode set.	*/
  3    79 	  2 pad			bit(26) unal,
  3    80 
  3    81 	  2 delete		bit(1) unal,	/* switch: on (for lcln) if node to be deleted.	*/
  3    82 
  3    83 	  2 cross_ref		bit(1) unal,	/* switch: cross-reference all names       	*/
  3    84 	  2 level			bit(1) unal,	/* switch: output status tree level number	*/
  3    85 	  2 new_line		bit(1) unal;	/* switch: output begins with newline char	*/
  3    86 
  3    87 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    88 	/*									*/
  3    89 	/*      The following declarations define a series of bit strings to be overlaid by 	*/
  3    90 	/* structures which are exactly like Svalid_req above, except for their level 1 name.	*/
  3    91 	/* These structures are used throughout the library descriptor commands and subroutines.	*/
  3    92 	/*									*/
  3    93 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    94 
  3    95 
  3    96      dcl	1 S			aligned based (addr(Srequirements)) like Svalid_req,
  3    97 	Srequirements		bit(72) aligned;
  3    98 
  3    99 /* END OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      576 
      577 
  4     1 /* START OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4     4 	/*									*/
  4     5 	/* N__a_m_e:  lib_Scontrol_.incl.pl1						*/
  4     6 	/*									*/
  4     7 	/*      This include segment defines the control switches used by library descriptor	*/
  4     8 	/* commands and subroutines.  These switches control the amount of information which is	*/
  4     9 	/* attached to each node of the tree by lib_get_tree_.  This segment, lib_args_.incl.pl1,	*/
  4    10 	/* and lib_Svalid_req_.incl.pl1 define the complete set of structures required as input	*/
  4    11 	/* to the lib_descriptor_ subroutine.						*/
  4    12 	/*									*/
  4    13 	/* S__t_a_t_u_s									*/
  4    14 	/*									*/
  4    15 	/* 0) Created on:  April 8, 1975  by  G. C. Dixon					*/
  4    16 	/* 1) Modified on: October 24, 1983 by Jim Lippard to add page_length, first_match	*/
  4    17 	/*									*/
  4    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    19 
  4    20      dcl	1 Sc			aligned based (addr (Scontrol)),
  4    21 	  2 acl			bit(1) unal,	/* switch: return ACL for library entries.	*/
  4    22 	  2 all_status		bit(1) unal,	/* switch: return extra status information.	*/
  4    23 	  2 chase			bit(1) unal,	/* switch: link entries are to be chased.	*/
  4    24 
  4    25 	  2 check_archive		bit(1) unal,	/* switch: see if contents of entry is archive.	*/
  4    26 	  2 check_ascii		bit(1) unal,	/* switch: see if contents of entry is ascii.	*/
  4    27 	  2 components		bit(1) unal,	/* switch: return info about parent of terminal	*/
  4    28 						/*         nodes of the tree, and about all the	*/
  4    29 						/*	 nodes below the parent.		*/
  4    30 
  4    31 	  2 container		bit(1) unal,	/* switch: return info about parent of terminal	*/
  4    32 						/*         nodes of the tree.			*/
  4    33 	  2 default		bit(1) unal,	/* switch: use default requirement switch settings*/
  4    34 	  2 iacl			bit(1) unal,	/* switch: return initial ACLs for library entries*/
  4    35 
  4    36 	  2 object_info		bit(1) unal,	/* switch: return object info for object segments.*/
  4    37 	  2 quota			bit(1) unal,	/* switch: return quota information.		*/
  4    38 	  2 retain		bit(1) unal,	/* switch: print information about nodes awaiting	*/
  4    39 						/*         deletion.			*/
  4    40 
  4    41 	  2 pad			bit(10) unal,
  4    42 
  4    43 	  2 first_match		bit(1) unal,	/* switch: stop after first match		*/
  4    44 	  2 page_length		bit(1) unal,	/* switch: page length of output		*/
  4    45 
  4    46 	  2 delete		bit(1) unal,	/* switch: delete library entries		*/
  4    47 	  2 descriptor		bit(1) unal,	/* switch: library descriptor			*/
  4    48 	  2 exclude		bit(1) unal,	/* switch: exclusion search names.		*/
  4    49 
  4    50 	  2 footing		bit(1) unal,	/* switch: footing for output pages.		*/
  4    51 	  2 heading		bit(1) unal,	/* switch: heading for 1st output page.		*/
  4    52 	  2 into_path		bit(1) unal,	/* switch: path into which entries are fetched.	*/
  4    53 
  4    54 	  2 library		bit(1) unal,	/* switch: library names			*/
  4    55 	  2 list			bit(1) unal,	/* switch: list library entries		*/
  4    56 	  2 long			bit(1) unal,	/* switch: long output format required.		*/
  4    57 
  4    58 	  2 output_file		bit(1) unal,	/* switch: pathname of output file		*/
  4    59 	  2 search_names		bit(1) unal,	/* switch: search names			*/
  4    60 	  2 time			bit(1) unal,	/* switch: grace time for deletion of entries.	*/
  4    61 	Scontrol			bit(36) aligned;	/* switches: aligned copy of control switches.	*/
  4    62 
  4    63 /* END OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      578 
      579 
      580 	end save_previous_system;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/15/84  0803.0  save_previous_system.pl1          >special_ldd>on>6588>save_previous_system.pl1
574          1    02/15/84  0754.7  lib_arg_struc_.incl.pl1           >special_ldd>on>6588>lib_arg_struc_.incl.pl1
1-19         2    02/15/84  0754.6  lib_args_.incl.pl1                >special_ldd>on>6588>lib_args_.incl.pl1
576          3    02/28/77  1409.3  lib_Svalid_req_.incl.pl1          >ldd>include>lib_Svalid_req_.incl.pl1
578          4    02/15/84  0754.6  lib_Scontrol_.incl.pl1            >special_ldd>on>6588>lib_Scontrol_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AREA                            000100 automatic       char(8)                  initial unaligned dcl 14 set ref 14* 183 183 331*
                                                                                  353
C                        11     000760 automatic       fixed bin(35,0)          array level 3 in structure "LIBRARY" dcl 2-22
                                                                                  in procedure "sps" set ref 354*
C                        11     002565 automatic       fixed bin(35,0)          array level 3 in structure "STARNAME" dcl 2-30
                                                                                  in procedure "sps" set ref 260*
EXCLUDE                         024236 automatic       structure                level 1 dcl 2-38 set ref 266 266
HOLD_DIR                        000226 automatic       char(168)                dcl 14 set ref 189* 214* 219* 350
LIBRARY                         000760 automatic       structure                level 1 dcl 2-22 set ref 266 266
LIBRARY_DIR                     000154 automatic       char(168)                dcl 14 set ref 188* 256* 270* 277*
N                               002565 automatic       fixed bin(17,0)          level 2 in structure "STARNAME" dcl 2-30
                                                                                  in procedure "sps" set ref 230* 356*
N                               000760 automatic       fixed bin(17,0)          level 2 in structure "LIBRARY" dcl 2-22 in procedure
                                                                                  "sps" set ref 352*
Nargs                           000354 automatic       fixed bin(17,0)          dcl 14 set ref 114* 115 138
Parg_struc                      045710 automatic       pointer                  dcl 1-21 set ref 266 266 345* 346 347 348 349 350
                                                                                  351 357 358 359 360 362 363 364 365 366 367 368
                                                                                  369 370 371 372 373 374 375 376 377 378 379 380
                                                                                  381 382 383 384 385 386 387 388 389 390 391 392
                                                                                  393 394 395 396 397 398 399 400 401 402 403 404
                                                                                  408 410 411 412 413 414 415 416 417 418 419 420
                                                                                  421 422 423 424 425 426 427 429 430
ROOT                            000102 automatic       char(168)                dcl 14 set ref 183* 185* 187 188 189 207* 210* 225*
                                                                                  226*
S                                      based           structure                level 1 dcl 3-96
STARNAME                        002565 automatic       structure                level 1 dcl 2-30 set ref 266 266
SYS_ID                          000300 automatic       char(8)                  initial unaligned dcl 14 set ref 14* 135* 187 189
                                                                                  207 210 225 226
Sc                                     based           structure                level 1 dcl 4-20
Sc_allowed                             based           structure                level 1 dcl 1-51
Sc_init                                based           structure                level 1 dcl 1-53
Scontrol                        045714 automatic       bit(36)                  dcl 4-20 set ref 262 266*
Scontrol_allowed         24            based           bit(36)                  level 2 dcl 1-23 set ref 359* 410 411 412 413 414
                                                                                  415 416 417 418 419 420 421 422 423 424 425 426
                                                                                  427
Scontrol_initial         27            based           bit(36)                  level 2 dcl 1-23 set ref 360* 429 430
Sreq_allowed                           based           structure                level 1 dcl 1-47
Sreq_init                              based           structure                level 1 dcl 1-49
Srequirements                   045712 automatic       bit(72)                  dcl 3-96 set ref 262 262 262 262 266*
Srequirements_allowed
                         22            based           bit(72)                  level 2 dcl 1-23 set ref 357* 362 363 364 365 366
                                                                                  367 368 369 370 371 372 373 374 375 376 377 378
                                                                                  379 380 381 382 383 384 385 386 387 388 389 390
                                                                                  391 392 393 394 395 396 397 398 399 400 401 402
                                                                                  403 404
Srequirements_initial
                         25            based           bit(72)                  level 2 dcl 1-23 set ref 358* 408
Svalid_req                             based           structure                level 1 dcl 3-23
True                            000751 automatic       bit(1)                   initial dcl 99 set ref 99* 262 362 363 364 365 366
                                                                                  367 368 369 370 371 372 373 374 375 376 377 378
                                                                                  379 380 381 382 383 384 385 386 387 388 389 390
                                                                                  391 392 393 394 395 396 397 398 399 400 401 402
                                                                                  403 404 408 410 411 412 413 414 415 416 417 418
                                                                                  419 420 421 422 423 424 425 426 427 429 430
UPDATING_DIR                    000302 automatic       char(168)                dcl 14 set ref 187* 193* 195* 197* 201* 270* 277*
V                         1     000760 automatic       char(32)                 array level 3 in structure "LIBRARY" packed
                                                                                  unaligned dcl 2-22 in procedure "sps" set ref 353*
V                         1     002565 automatic       char(32)                 array level 3 in structure "STARNAME" packed
                                                                                  unaligned dcl 2-30 in procedure "sps" set ref 259*
Varg_struc_1                           constant        fixed bin(17,0)          initial dcl 1-55 ref 346
access_class              0(19)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 362*
access_name                     000426 automatic       char(32)                 level 2 in structure "segment_acl" dcl 81
                                                                                  in procedure "sps" set ref 109*
access_name                     000414 automatic       char(32)                 level 2 in structure "dir_acl" dcl 77 in procedure
                                                                                  "sps" set ref 106* 207*
acl                       0(31)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "sps" set ref 363*
acl                                    based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "sps" set ref 410*
acode                           017646 automatic       fixed bin(17,0)          dcl 445 set ref 502* 504* 506 513* 519 532* 534* 536
                                                                                  543* 549
addr                                                   builtin function         dcl 52 ref 210 210 225 225 262 262 262 262 262 266
                                                                                  266 266 266 266 266 266 266 296 296 345 362 363
                                                                                  364 365 366 367 368 369 370 371 372 373 374 375
                                                                                  376 377 378 379 380 381 382 383 384 385 386 387
                                                                                  388 389 390 391 392 393 394 395 396 397 398 399
                                                                                  400 401 402 403 404 408 410 411 412 413 414 415
                                                                                  416 417 418 419 420 421 422 423 424 425 426 427
                                                                                  429 430
aim                       0(09)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 364*
all_status                0(01)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 411*
archive_item                           based           structure                level 1 dcl 470
archive_util_$disected_element  000064 constant        entry                    external dcl 463 ref 513 543
archive_util_$first_disected    000062 constant        entry                    external dcl 463 ref 504 534
area_index                      045750 automatic       fixed bin(17,0)          initial array dcl 320 set ref 320* 320* 320* 320*
                                                                                  320* 320* 331
area_ptr                        000356 automatic       pointer                  dcl 14 set ref 103* 191* 193*
arg                                    based           char                     unaligned dcl 14 set ref 126 127* 131* 135 146 149
                                                                                  157 163* 164* 172*
arg_len                         000360 automatic       fixed bin(17,0)          dcl 14 set ref 121* 126 127 127 130 131 131 135 140*
                                                                                  146 149 151* 157 163 163 164 164 172 172
arg_ptr                         000362 automatic       pointer                  dcl 14 set ref 121* 126 127 131 135 140* 146 149
                                                                                  151* 157 163 164 172
arg_struc                              based           structure                level 1 unaligned dcl 1-23 set ref 266 266
arg_struc_temp                  000442 automatic       structure                level 1 unaligned dcl 96 set ref 345
author                    0(12)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 365*
bit_count                 0(24)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "sps" set ref 366*
bit_count                       017644 automatic       fixed bin(24,0)          dcl 445 in procedure "compare_archives_" set ref
                                                                                  495* 525*
bit_count_author          0(25)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 367*
bitc                     14     017656 automatic       char(8)                  array level 2 in structure "first_array" dcl 482
                                                                                  in procedure "compare_archives_" set ref 510*
bitc                     14     053136 automatic       char(8)                  array level 2 in structure "second_array" dcl 487
                                                                                  in procedure "compare_archives_" set ref 540*
bitc                            017645 automatic       fixed bin(24,0)          dcl 445 in procedure "compare_archives_" set ref
                                                                                  504* 513* 534* 543*
bitct                    25            based           char(8)                  level 2 packed unaligned dcl 470 ref 510 540
chase                     0(02)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 412*
check_archive             0(03)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 413*
check_ascii               0(04)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 414*
cleanup                         000752 stack reference condition                dcl 101 ref 205 240
code                            000364 automatic       fixed bin(35,0)          dcl 14 in procedure "sps" set ref 121* 122 123* 140*
                                                                                  141 142* 151* 152 153* 193* 194 195 195* 197* 207*
                                                                                  208 208 210* 211 212 212* 214* 219* 225* 226 266*
                                                                                  296* 297
code                            017654 automatic       fixed bin(35,0)          dcl 445 in procedure "compare_archives_" set ref
                                                                                  495* 497* 518* 525* 527* 548*
code                     11     000414 automatic       fixed bin(35,0)          level 2 in structure "dir_acl" dcl 77 in procedure
                                                                                  "sps" set ref 108* 212
code                     12     000426 automatic       fixed bin(35,0)          level 2 in structure "segment_acl" dcl 81
                                                                                  in procedure "sps" set ref 112* 226
com_err_                        000054 constant        entry                    external dcl 463 in procedure "compare_archives_"
                                                                                  ref 497 520 527 550
com_err_                        000030 constant        entry                    external dcl 54 in procedure "sps" ref 116 123 127
                                                                                  131 142 153 158 164 172 195 197 201 214 219 226
                                                                                  277 348
compiler_name             0(34)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 368*
compiler_options          1            based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 369*
compiler_version          0(35)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 370*
components                0(05)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 415*
container                 0(06)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 416*
copy                      0(10)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 371*
cu_$arg_count                   000010 constant        entry                    external dcl 54 ref 114
cu_$arg_ptr                     000012 constant        entry                    external dcl 54 ref 121 140 151
current_length            0(21)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 372*
date                     10     017656 automatic       char(16)                 array level 2 in structure "first_array" dcl 482
                                                                                  in procedure "compare_archives_" set ref 509* 558
date                     10     053136 automatic       char(16)                 array level 2 in structure "second_array" dcl 487
                                                                                  in procedure "compare_archives_" set ref 539* 558
default                   0(07)        based           bit(1)                   level 2 in structure "Sc" packed unaligned dcl 4-20
                                                                                  in procedure "sps" ref 262
default                   0(07)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "sps" set ref 417*
default                   0(07)        based           bit(1)                   level 2 in structure "Sc_init" packed unaligned
                                                                                  dcl 1-53 in procedure "sps" set ref 430*
descriptor                0(25)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "sps" set ref 422*
descriptor               30            based           varying char(168)        level 2 in structure "arg_struc" dcl 1-23
                                                                                  in procedure "sps" set ref 349*
diff_count                      017600 automatic       fixed bin(17,0)          dcl 246 set ref 270* 276 282
diff_names                      000100 automatic       char(32)                 array unaligned dcl 246 set ref 270* 283*
dir_acl                         000414 automatic       structure                level 1 dcl 77 set ref 210 210
dir_modes                10     000414 automatic       bit(36)                  level 2 dcl 77 set ref 107*
dtc                       0(33)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 373*
dtd                       0(14)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 374*
dtem                      0(13)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 375*
dtm                       0(16)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 376*
dtu                       0(17)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 377*
dtupd                    13            based           char(16)                 level 2 packed unaligned dcl 470 ref 509 539
entries                                based           structure                array level 1 dcl 41 ref 307
entry                                  parameter       char                     unaligned dcl 291 set ref 289 296*
entry_bound               0(27)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 378*
entry_count                     000406 automatic       fixed bin(17,0)          dcl 46 set ref 193* 200 232 307 311
entry_ptr                       000410 automatic       pointer                  dcl 46 set ref 104* 193* 234 307 307 309*
error                           000365 automatic       bit(1)                   initial unaligned dcl 14 set ref 14* 154* 160* 166*
                                                                                  173* 179
error_table_$archive_fmt_err    000052 external static fixed bin(35,0)          dcl 445 set ref 520* 550*
error_table_$argerr             000042 external static fixed bin(35,0)          dcl 88 ref 212
error_table_$bad_arg            000034 external static fixed bin(35,0)          dcl 88 set ref 131* 158* 164* 172*
error_table_$namedup            000036 external static fixed bin(35,0)          dcl 88 ref 208
error_table_$no_dir             000046 external static fixed bin(35,0)          dcl 88 ref 195
error_table_$noarg              000040 external static fixed bin(35,0)          dcl 88 ref 116
error_table_$noentry            000044 external static fixed bin(35,0)          dcl 88 set ref 201*
fetch_name                             parameter       char                     unaligned dcl 246 set ref 244 253 256* 259 270* 270*
                                                                                  277* 277*
first_array                     017656 automatic       structure                array level 1 dcl 482
first_count                     017652 automatic       fixed bin(17,0)          dcl 445 set ref 517* 555
first_dir                              parameter       char                     dcl 437 set ref 435 495* 497* 520*
first_entry                            parameter       char                     unaligned dcl 437 set ref 435 495* 497* 520*
found                           000366 automatic       bit(1)                   initial unaligned dcl 14 set ref 14*
get_group_id_$tag_star          000014 constant        entry                    external dcl 54 ref 106
get_system_free_area_           000016 constant        entry                    external dcl 54 ref 191
group                     1     002565 automatic       structure                array level 2 in structure "STARNAME" dcl 2-30
                                                                                  in procedure "sps"
group                     1     000760 automatic       structure                array level 2 in structure "LIBRARY" dcl 2-22
                                                                                  in procedure "sps"
hcs_$add_dir_acl_entries        000024 constant        entry                    external dcl 54 ref 210
hcs_$add_inacl_entries          000020 constant        entry                    external dcl 54 ref 225
hcs_$append_branchx             000022 constant        entry                    external dcl 54 ref 207
hcs_$initiate_count             000056 constant        entry                    external dcl 463 ref 495 525
hcs_$star_                      000026 constant        entry                    external dcl 54 ref 193
hcs_$status_                    000050 constant        entry                    external dcl 291 ref 296
hcs_$terminate_noname           000060 constant        entry                    external dcl 463 ref 518 548
head_ptr                        017630 automatic       pointer                  dcl 445 set ref 494* 495* 496 501 504* 509 510 513*
                                                                                  524* 525* 526 531 534* 539 540 543*
i                               017624 automatic       fixed bin(17,0)          dcl 445 in procedure "compare_archives_" set ref
                                                                                  555* 557 558 560 566*
i                               000367 automatic       fixed bin(17,0)          dcl 14 in procedure "sps" set ref 137* 138 139* 139
                                                                                  140* 142* 150* 150 151* 232* 234* 329* 330 331*
i                               017601 automatic       fixed bin(17,0)          dcl 246 in procedure "FETCH" set ref 282* 283*
iacl                      0(08)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "sps" set ref 418*
iacl                      0(32)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "sps" set ref 379*
index                                                  builtin function         dcl 52 ref 253
into_path                 0(29)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "sps" set ref 423*
into_path               157            based           varying char(168)        level 2 in structure "arg_struc" dcl 1-23
                                                                                  in procedure "sps" set ref 350*
into_path                 0(29)        based           bit(1)                   level 2 in structure "Sc_init" packed unaligned
                                                                                  dcl 1-53 in procedure "sps" set ref 429*
j                               017625 automatic       fixed bin(17,0)          dcl 445 set ref 502* 507* 507 508 509 510 517 532*
                                                                                  537* 537 538 539 540 547 556* 557 558*
k                               000370 automatic       fixed bin(17,0)          dcl 14 set ref 234* 236
kids                      0(04)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 380*
kids_error                0(05)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 381*
level                     1(34)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 382*
lib_fetch_                      000032 constant        entry                    external dcl 54 ref 266
library                   0(30)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 425*
link_target               0(15)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 383*
long                      0(32)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 424*
lvid                      0(28)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 384*
matching_names            0(01)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "sps" set ref 385*
matching_names            0(01)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 3-96
                                                                                  in procedure "sps" set ref 262 262*
max_length                0(22)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 386*
me                              017655 automatic       char(2)                  initial unaligned dcl 445 in procedure
                                                                                  "compare_archives_" set ref 445* 497* 520* 527*
                                                                                  550*
me                              000371 automatic       char(32)                 initial unaligned dcl 14 in procedure "sps" set ref
                                                                                  14* 116* 116* 123* 127* 131* 142* 153* 158* 164*
                                                                                  172* 195* 197* 201* 214* 219* 226* 277* 347
mode                      0(07)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 387*
modes                    10     000426 automatic       bit(36)                  level 2 dcl 81 set ref 110*
msf_indicator             0(23)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 388*
name                            053136 automatic       char(32)                 array level 2 in structure "second_array" dcl 487
                                                                                  in procedure "compare_archives_" set ref 538* 557
name                            017656 automatic       char(32)                 array level 2 in structure "first_array" dcl 482
                                                                                  in procedure "compare_archives_" set ref 508* 557
                                                                                  560 566
name_ptr                        000412 automatic       pointer                  dcl 46 set ref 105* 193* 236 311 311 313*
names                     0(02)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "sps" set ref 389*
names                                  based           char(32)                 array unaligned dcl 46 in procedure "sps" set ref
                                                                                  236* 311
names                     0(02)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 3-96
                                                                                  in procedure "sps" ref 262
new_line                  1(35)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 390*
nindex                    0(18)        based           fixed bin(17,0)          array level 2 packed unaligned dcl 41 ref 234
not_ascii                 1(02)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 391*
null                                                   builtin function         dcl 445 in procedure "compare_archives_" ref 494 496
                                                                                  524 526
null                                                   builtin function         dcl 52 in procedure "sps" ref 103 104 105 296 296
                                                                                  307 309 311 313
object_info               0(09)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "sps" set ref 419*
object_info               1(01)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "sps" set ref 392*
offset                    0(26)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 393*
output_file             232            based           varying char(168)        level 2 in structure "arg_struc" dcl 1-23
                                                                                  in procedure "sps" set ref 351*
output_file               0(33)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "sps" set ref 426*
pad                      11     000426 automatic       bit(36)                  level 2 dcl 81 set ref 111*
path                                   parameter       char(168)                dcl 291 set ref 289 296*
pathname                  0(03)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 394*
primary_name                           based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "sps" set ref 395*
primary_name                           based           bit(1)                   level 2 in structure "S" packed unaligned dcl 3-96
                                                                                  in procedure "sps" ref 262
program                   1            based           varying char(32)         level 2 dcl 1-23 set ref 347*
proper_name                     045756 automatic       char(8)                  initial array unaligned dcl 320 set ref 320* 320*
                                                                                  320* 331
put_error                16            based           entry variable           level 2 dcl 1-23 set ref 348*
pvid                      0(29)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 396*
quota                     0(30)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "sps" set ref 397*
quota                     0(10)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "sps" set ref 420*
rb                        0(18)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 398*
records_used              0(20)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 399*
restart_sw                      000401 automatic       bit(1)                   initial unaligned dcl 14 set ref 14* 146*
retain                    0(11)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 421*
return_array                           parameter       char(32)                 array unaligned dcl 437 set ref 435 560* 566*
return_count                           parameter       fixed bin(17,0)          dcl 437 set ref 435 492* 570*
rev_sw                          000402 automatic       bit(1)                   initial unaligned dcl 14 set ref 14*
ringbr                          000403 automatic       fixed bin(3,0)           initial array dcl 14 set ref 14* 14* 14* 207*
root_search_proc          1(04)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 400*
rtrim                                                  builtin function         dcl 52 ref 187 188 189 189 207 210 225 226 350 353
safety                    0(08)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 401*
save_ptr                        017632 automatic       pointer                  dcl 445 set ref 501* 518* 531* 548*
search_names              0(34)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 427*
second_array                    053136 automatic       structure                array level 1 dcl 487
second_count                    017653 automatic       fixed bin(17,0)          dcl 445 set ref 547* 556
second_dir                             parameter       char                     dcl 437 set ref 435 525* 527* 550*
second_entry                           parameter       char                     unaligned dcl 437 set ref 435 525* 527* 550*
seg_name                        017634 automatic       char(32)                 unaligned dcl 445 set ref 504* 508 513* 534* 538
                                                                                  543*
seg_ptr                         017650 automatic       pointer                  dcl 445 set ref 504* 513* 534* 543*
segment_acl                     000426 automatic       structure                level 1 dcl 81 set ref 225 225
status                          017612 automatic       bit(144)                 dcl 291 set ref 296 296
substr                                                 builtin function         dcl 52 ref 126 157
system_name                            parameter       char                     unaligned dcl 320 ref 318 330
type                      0(06)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 402*
unique_id                 0(11)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 403*
user                      1(03)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "sps" set ref 404*
user                      1(03)        based           bit(1)                   level 2 in structure "Sreq_init" packed unaligned
                                                                                  dcl 1-49 in procedure "sps" set ref 408*
valid_names                     045726 automatic       char(12)                 initial array unaligned dcl 320 set ref 320* 320*
                                                                                  320* 320* 320* 320* 329 330
version                                based           fixed bin(17,0)          level 2 dcl 1-23 set ref 346*
x                               017626 automatic       fixed bin(17,0)          dcl 445 set ref 502* 559* 559 560 565* 565 566 570

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
SYSID_STAR                             automatic       char(32)                 dcl 14
acode                                  automatic       fixed bin(17,0)          dcl 14
archive_util_$disected_element  000000 constant        entry                    external dcl 54
archive_util_$first_disected    000000 constant        entry                    external dcl 54
bitc                                   automatic       fixed bin(24,0)          dcl 14
error_table_$archive_fmt_err           external static fixed bin(35,0)          dcl 88
hcs_$initiate_count             000000 constant        entry                    external dcl 54
hcs_$terminate_noname           000000 constant        entry                    external dcl 54
index                                                  builtin function         dcl 445
segname                                automatic       char(32)                 dcl 14
segptr                                 automatic       pointer                  dcl 14

NAMES DECLARED BY EXPLICIT CONTEXT.
CLEANUP                         003041 constant        entry                    internal dcl 305 ref 205 241
FETCH                           002446 constant        entry                    internal dcl 244 ref 236 283
INIT                            003325 constant        entry                    internal dcl 343 ref 223
STATUS                          002741 constant        entry                    internal dcl 289 ref 256
VERIFY_AREA                     003073 constant        entry                    internal dcl 318 ref 163
compare_archives_               004143 constant        entry                    internal dcl 435 ref 270
found_area                      003320 constant        label                    dcl 338 ref 332
next_arg                        001266 constant        label                    dcl 176 ref 155 161 167
next_first                      005121 constant        label                    dcl 567 ref 562
save_previous_system            000443 constant        entry                    external dcl 11
source_ac                       002603 constant        label                    dcl 270 ref 253
sps                             000433 constant        entry                    external dcl 11

NAME DECLARED BY CONTEXT OR IMPLICATION.
dim                                                    builtin function         ref 329

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5444        5532    5135        5454
Length      6062    5135        66         314     307           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
sps                               19621 external procedure  is an external procedure.  
on unit on line 205                  64 on unit               
FETCH                             36286 internal procedure  calls itself recursively.  
STATUS                                  internal procedure  shares stack frame of internal procedure FETCH.  
CLEANUP                              64 internal procedure  is called by several nonquick procedures.  
VERIFY_AREA                             internal procedure  shares stack frame of external procedure sps.  
INIT                                    internal procedure  shares stack frame of external procedure sps.  
compare_archives_                       internal procedure  shares stack frame of internal procedure FETCH.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
FETCH                    000100 diff_names                  FETCH
                         017600 diff_count                  FETCH
                         017601 i                           FETCH
                         017612 status                      STATUS
                         017624 i                           compare_archives_
                         017625 j                           compare_archives_
                         017626 x                           compare_archives_
                         017630 head_ptr                    compare_archives_
                         017632 save_ptr                    compare_archives_
                         017634 seg_name                    compare_archives_
                         017644 bit_count                   compare_archives_
                         017645 bitc                        compare_archives_
                         017646 acode                       compare_archives_
                         017650 seg_ptr                     compare_archives_
                         017652 first_count                 compare_archives_
                         017653 second_count                compare_archives_
                         017654 code                        compare_archives_
                         017655 me                          compare_archives_
                         017656 first_array                 compare_archives_
                         053136 second_array                compare_archives_
sps                      000100 AREA                        sps
                         000102 ROOT                        sps
                         000154 LIBRARY_DIR                 sps
                         000226 HOLD_DIR                    sps
                         000300 SYS_ID                      sps
                         000302 UPDATING_DIR                sps
                         000354 Nargs                       sps
                         000356 area_ptr                    sps
                         000360 arg_len                     sps
                         000362 arg_ptr                     sps
                         000364 code                        sps
                         000365 error                       sps
                         000366 found                       sps
                         000367 i                           sps
                         000370 k                           sps
                         000371 me                          sps
                         000401 restart_sw                  sps
                         000402 rev_sw                      sps
                         000403 ringbr                      sps
                         000406 entry_count                 sps
                         000410 entry_ptr                   sps
                         000412 name_ptr                    sps
                         000414 dir_acl                     sps
                         000426 segment_acl                 sps
                         000442 arg_struc_temp              sps
                         000751 True                        sps
                         000760 LIBRARY                     sps
                         002565 STARNAME                    sps
                         024236 EXCLUDE                     sps
                         045710 Parg_struc                  sps
                         045712 Srequirements               sps
                         045714 Scontrol                    sps
                         045726 valid_names                 VERIFY_AREA
                         045750 area_index                  VERIFY_AREA
                         045756 proper_name                 VERIFY_AREA

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other_desc call_int_other      return              enable              shorten_stack       ext_entry
int_entry           int_entry_desc      set_cs_eis          index_cs_eis        free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
archive_util_$disected_element                              archive_util_$first_disected  com_err_
com_err_                      cu_$arg_count                 cu_$arg_ptr                   get_group_id_$tag_star
get_system_free_area_         hcs_$add_dir_acl_entries      hcs_$add_inacl_entries        hcs_$append_branchx
hcs_$initiate_count           hcs_$star_                    hcs_$status_                  hcs_$terminate_noname
lib_fetch_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$archive_fmt_err  error_table_$argerr           error_table_$bad_arg          error_table_$namedup
error_table_$no_dir           error_table_$noarg            error_table_$noentry




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 000400        99 000426        11 000432       103 000451       104 000453       105 000454       106 000455
    107 000473       108 000475       109 000476       110 000501       111 000503       112 000504       114 000505
    115 000515       116 000520       118 000552       121 000553       122 000574       123 000576       124 000624
    126 000625       127 000632       128 000670       130 000671       131 000674       133 000730       135 000731
    137 000734       138 000736       139 000741       140 000742       141 000760       142 000762       143 001014
    146 001015       149 001026       150 001032       151 001033       152 001051       153 001053       154 001101
    155 001103       157 001104       158 001111       160 001137       161 001141       163 001142       164 001167
    166 001223       167 001225       169 001226       172 001227       173 001264       176 001266       179 001267
    183 001271       185 001312       187 001316       188 001356       189 001403       191 001453       193 001464
    194 001535       195 001537       197 001574       198 001624       200 001625       201 001627       202 001660
    205 001661       207 001703       208 002013       210 002021       211 002107       212 002112       214 002117
    215 002150       217 002151       219 002152       220 002203       223 002204       225 002205       226 002302
    230 002375       232 002400       234 002412       236 002417       238 002435       240 002437       241 002440
    242 002444       244 002445       253 002462       256 002471       259 002517       260 002526       262 002527
    266 002545       268 002602       270 002603       276 002640       277 002642       279 002713       282 002714
    283 002723       284 002736       285 002740       289 002741       296 002753       297 003021       299 003032
    305 003040       307 003046       309 003055       311 003060       313 003067       315 003072       318 003073
    320 003105       329 003256       330 003263       331 003276       332 003306       334 003307       336 003311
    338 003320       343 003325       345 003327       346 003331       347 003333       348 003340       349 003345
    350 003346       351 003400       352 003402       353 003404       354 003432       356 003434       357 003436
    358 003441       359 003443       360 003444       362 003445       363 003452       364 003457       365 003464
    366 003471       367 003476       368 003503       369 003510       370 003514       371 003521       372 003526
    373 003533       374 003540       375 003545       376 003552       377 003557       378 003564       379 003571
    380 003576       381 003603       382 003610       383 003615       384 003622       385 003627       386 003634
    387 003641       388 003646       389 003653       390 003660       391 003665       392 003672       393 003677
    394 003704       395 003711       396 003715       397 003722       398 003727       399 003734       400 003741
    401 003746       402 003753       403 003760       404 003765       408 003772       410 003777       411 004003
    412 004010       413 004015       414 004022       415 004027       416 004034       417 004041       418 004046
    419 004053       420 004060       421 004065       422 004072       423 004077       424 004104       425 004111
    426 004116       427 004123       429 004130       430 004135       432 004142       435 004143       445 004174
    492 004176       494 004200       495 004202       496 004247       497 004253       498 004313       501 004314
    502 004316       504 004321       506 004352       507 004354       508 004355       509 004363       510 004373
    513 004377       515 004430       517 004431       518 004433       519 004445       520 004450       521 004510
    524 004511       525 004513       526 004562       527 004566       528 004626       531 004627       532 004631
    534 004633       536 004664       537 004666       538 004667       539 004676       540 004705       543 004711
    545 004742       547 004743       548 004745       549 004757       550 004762       551 005022       555 005023
    556 005034       557 005044       558 005062       559 005070       560 005071       562 005101       564 005102
    565 005104       566 005105       567 005121       570 005123       571 005126


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
