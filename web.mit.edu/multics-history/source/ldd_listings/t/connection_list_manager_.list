	COMPILATION LISTING OF SEGMENT connection_list_manager_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 03/15/89  0828.6 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1987 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(85-05-01,Coren), approve(87-07-08,MCR7681), audit(87-03-26,GDixon),
       11*     install(87-08-04,MR12.1-1055):
       12*     Initial coding.
       13*  2) change(87-03-07,GDixon), approve(87-07-08,MCR7681),
       14*     audit(87-07-22,Hartogs), install(87-08-04,MR12.1-1055):
       15*      A) Correct coding standard violations.
       16*      B) Correct cleanup strategy.
       17*      C) Correct storing of service type in active_connection.service_type.
       18*      D) Thread entry back to owner when $priv_remove_user is called to
       19*         remove the connection from the user.
       20*      E) Remove $delete_name and $delete_offset entrypoints, which aren't
       21*         called by any gate and don't fit into the gate strategy.
       22*      F) Change $init to ignore all but the first call during a given
       23*         bootload.
       24*      G) Remove references to connection_manager_data_.
       25*      H) Add force_accounting_flush_entry parameter to $add entrypoint.  Return
       26*         this entry in the active_connection_info structure.
       27*  3) change(87-04-28,Brunelle), approve(87-07-08,MCR7681),
       28*     audit(87-07-22,Hartogs), install(87-08-04,MR12.1-1055):
       29*     Corrected Thread_user to correctly thread next_act_ptr entry back to this
       30*     entry.
       31*  4) change(87-05-06,GDixon), approve(87-07-08,MCR7681),
       32*     audit(87-07-22,Hartogs), install(87-08-04,MR12.1-1055):
       33*      A) Map error_table_$lock_wait_time_exceeded into
       34*         error_table_$already_initialized.
       35*      B) Use sys_info$system_control_dir to locate active_connection_list.
       36*  5) change(87-05-13,Brunelle), approve(87-07-08,MCR7681),
       37*     audit(87-07-22,Hartogs), install(87-08-04,MR12.1-1055):
       38*     Add .owner_group_id field to structure and change code to use it.  Added
       39*     check for the connection list not being initialized yet.  Pass back new
       40*  6) change(87-06-22,GDixon), approve(87-07-08,MCR7681),
       41*     audit(87-07-22,Hartogs), install(87-08-04,MR12.1-1055):
       42*      A) Add back the delete_offset entrypoint.
       43*  7) change(87-07-21,GDixon), approve(87-07-21,MCR7681),
       44*     audit(87-07-22,Hartogs), install(87-08-04,MR12.1-1055):
       45*      A) Sort parameter declarations.
       46*      B) Correct comments.
       47*                                                   END HISTORY COMMENTS */
       48 
       49 /* format: style4,delnl,insnl,^ifthendo */
       50 
       51 connection_list_manager_:
       52      procedure ();
       53 	return;					/* main entry is never called */
       54 
       55 /* This procedure contains a collection of entry points for managing the
       56*   system-wide list of active network connections.  This list is used, for
       57*   example, by the Answering Service when a user process terminates in order
       58*   to clean up any connections that were assigned to the process.
       59*
       60*   There is an entry for each established connection.  Each one has
       61*   associated with it an "owner" process (frequently a login server) and a
       62*   "user" process.
       63*
       64*   The table is maintained in ring 1, since it is potentially accessible by
       65*   all processes.
       66*
       67*   Entries in this procedure are called through one of three gates:
       68*
       69*   connection_list_:       process must be owner and user of connection
       70*   priv_connection_list_:  process must be owner, but need not be user
       71*   hpriv_connection_list_: process may manipulate connections of which it is
       72*   neither owner nor user
       73*
       74*   Further, some of the entries may be called by inner-ring network-management
       75*   programs.
       76**/
       77 
       78 /* NOTE: Someday there should be some code added to check that the list is
       79*   consistent, and take some appropriate action if it isn't. */
       80 
       81 /* DECLARATIONS */
       82 
       83 /* PARAMETERS */
       84 
       85 dcl  a_code fixed bin (35) parameter;
       86 dcl  a_connection_handle fixed bin (35) parameter;
       87 dcl  a_connection_info_ptr pointer parameter;
       88 dcl  a_connection_name char (*) parameter;
       89 dcl  a_force_accounting char (*) parameter;
       90 dcl  a_force_disconnect char (*) parameter;
       91 dcl  a_handle bit (72) aligned parameter;
       92 dcl  a_offset bit (18) parameter;
       93 dcl  a_owner_process_id bit (36) parameter;
       94 dcl  a_service_type char (*) parameter;
       95 dcl  a_terminate_event_channel fixed bin (71) parameter;
       96 dcl  a_usage_type fixed bin parameter;
       97 dcl  a_user_group_id char (*) parameter;
       98 dcl  a_user_process_id bit (36) parameter;
       99 
      100 
      101 /* AUTOMATIC */
      102 
      103 dcl  act_dir_name char (168);
      104 dcl  code fixed bin (35);
      105 dcl  connection_handle fixed bin (35);
      106 dcl  connection_name char (32);
      107 dcl  force_acct_entry char (64);
      108 dcl  force_disc_entry char (64);
      109 dcl  hash_index fixed bin;
      110 dcl  hash_size fixed bin;
      111 dcl  hpriv_entry bit (1);
      112 dcl  initializer_handle bit (72) aligned;
      113 dcl  locked bit (1);
      114 dcl  my_process_id bit (36);
      115 dcl  name_entry bit (1);
      116 dcl  next_act_ptr pointer;
      117 dcl  next_offset bit (18);
      118 dcl  offset bit (18);
      119 dcl  orig_level fixed bin;
      120 dcl  owner_process_id bit (36);
      121 dcl  priv_entry bit (1);
      122 dcl  service_type char (32);
      123 dcl  sys_high_auth bit (72) aligned;
      124 dcl  temp_lock_word bit (36) aligned;
      125 dcl  term_event_channel fixed bin (71);
      126 dcl  this_act_ptr pointer;
      127 dcl  this_ring fixed bin;
      128 dcl  usage_type fixed bin;
      129 dcl  user_group_id char (32);
      130 dcl  user_process_id bit (36);
      131 dcl  words_used fixed bin;
      132 
      133 
      134 /* AUTOMATIC STRUCTURES */
      135 
      136 dcl  1 auto_area_info aligned like area_info;
      137 dcl  1 auto_create_branch_info aligned like create_branch_info;
      138 
      139 
      140 /* ENTRIES */
      141 
      142 dcl  convert_authorization_$from_string entry (bit (72) aligned, char (*), fixed bin (35));
      143 dcl  cu_$level_get entry (fixed bin);
      144 dcl  cu_$level_set entry (fixed bin);
      145 dcl  define_area_ entry (ptr, fixed bin (35));
      146 dcl  get_group_id_ entry () returns (char (32));
      147 dcl  get_process_id_ entry () returns (bit (36));
      148 dcl  get_ring_ entry () returns (fixed bin (3));
      149 dcl  hash_index_ entry (pointer, fixed bin (21), fixed bin, fixed bin) returns (fixed bin);
      150 dcl  hcs_$create_branch_ entry (char (*), char (*), ptr, fixed bin (35));
      151 dcl  initiate_file_ entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
      152 dcl  set_lock_$lock entry (bit (36) aligned, fixed bin, fixed bin (35));
      153 dcl  set_lock_$unlock entry (bit (36) aligned, fixed bin (35));
      154 dcl  terminate_file_ entry (ptr, fixed bin (24), bit (*), fixed bin (35));
      155 
      156 
      157 /* EXTERNAL STATIC */
      158 
      159 dcl  (
      160      error_table_$already_initialized,
      161      error_table_$invalid_lock_reset,
      162      error_table_$lock_wait_time_exceeded,
      163      error_table_$locked_by_other_process,
      164      error_table_$locked_by_this_process,
      165      error_table_$namedup,
      166      error_table_$noentry,
      167      error_table_$not_initialized,
      168      error_table_$not_privileged,
      169      error_table_$unimplemented_version
      170      ) fixed bin (35) external static;
      171 
      172 dcl  sys_info$max_seg_size fixed bin (18) external static;
      173 dcl  sys_info$system_control_dir char (168) varying external static;
      174 
      175 
      176 /* INTERNAL STATIC */
      177 
      178 dcl  ACT_SEG_NAME char (32) internal static options (constant) init ("active_connection_list");
      179 dcl  LOCK_WAIT_TIME fixed bin internal static options (constant) init (10);
      180 dcl  static_connection_list_ptr pointer internal static init (null ());
      181 
      182 
      183 /* BUILTINS AND CONDITIONS */
      184 
      185 dcl  (addr, currentsize, length, mod, null, ptr, rel, string, unspec) builtin;
      186 dcl  cleanup condition;
      187 
      188 
      189 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      190 /*							       */
      191 /* add: entry to add a connection -- the caller is made both user and owner  */
      192 /*							       */
      193 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      194 
      195 add:
      196      entry (a_connection_name, a_connection_handle, a_service_type, a_force_disconnect, a_force_accounting, a_usage_type,
      197 	a_offset, a_code);
      198 
      199 	active_connection_list_ptr = null;
      200 	on cleanup call Unlock ();
      201 	call Setup ();
      202 
      203 	usage_type = a_usage_type;
      204 	force_disc_entry = a_force_disconnect;
      205 	force_acct_entry = a_force_accounting;
      206 	connection_name = a_connection_name;
      207 	connection_handle = a_connection_handle;
      208 	service_type = a_service_type;
      209 
      210 /* make sure we don't have one by this name already */
      211 
      212 	call Find (connection_name, hash_index, offset, code);
      213 	if code ^= 0
      214 	then go to EXIT;				/* failure to find isn't an error */
      215 
      216 	if offset ^= ""b
      217 	then do;					/* in fact, in this case... */
      218 	     code = error_table_$namedup;
      219 	     go to EXIT;
      220 	end;
      221 
      222 /* now make a new entry */
      223 
      224 	allocate active_connection in (active_connection_list.connection_area) set (act_ptr);
      225 
      226 	unspec (active_connection) = ""b;		/* start clean */
      227 
      228 	active_connection.version = ACT_VERSION_1;
      229 	active_connection.connection_name = connection_name;
      230 	active_connection.service_type = service_type;
      231 	active_connection.owner_process_id, active_connection.user_process_id = get_process_id_ ();
      232 	active_connection.owner_group_id, active_connection.user_group_id = get_group_id_ ();
      233 	active_connection.force_disconnect_entry = force_disc_entry;
      234 	active_connection.force_accounting_flush_entry = force_acct_entry;
      235 	active_connection.connection_handle = connection_handle;
      236 	active_connection.usage_type = usage_type;
      237 
      238 	call Thread ();				/* threads to full list, hash list, and owner chain */
      239 
      240 	call Thread_user ();
      241 
      242 	a_offset = rel (act_ptr);
      243 
      244 EXIT:
      245 	if locked
      246 	then call Unlock ();
      247 	a_code = code;
      248 	return;
      249 
      250 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      251 
      252 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      253 /*							       */
      254 /* (priv hpriv)_delete_(name offset), delete_offset:		       */
      255 /* The following group of entry points are used to delete a connection from  */
      256 /* the list.  This call may be privileged, or highly privileged; and the     */
      257 /* connection may be identified by either its name or its offset in the list */
      258 /* segment.						       */
      259 /*							       */
      260 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      261 
      262 priv_delete_name:
      263      entry (a_connection_name, a_code);
      264 
      265 	priv_entry = "1"b;
      266 	hpriv_entry = "0"b;
      267 	name_entry = "1"b;
      268 	go to DELETE_JOIN;
      269 
      270 
      271 priv_delete_offset:
      272      entry (a_offset, a_code);
      273 
      274 	priv_entry = "1"b;
      275 	hpriv_entry = "0"b;
      276 	name_entry = "0"b;
      277 	go to DELETE_JOIN;
      278 
      279 delete_offset:
      280      entry (a_offset, a_code);
      281 
      282 	priv_entry = "0"b;
      283 	hpriv_entry = "0"b;
      284 	name_entry = "0"b;
      285 	go to DELETE_JOIN;
      286 
      287 hpriv_delete_name:
      288      entry (a_connection_name, a_code);
      289 
      290 	priv_entry = "0"b;
      291 	hpriv_entry = "1"b;
      292 	name_entry = "1"b;
      293 	go to DELETE_JOIN;
      294 
      295 
      296 hpriv_delete_offset:
      297      entry (a_offset, a_code);
      298 
      299 	priv_entry = "0"b;
      300 	hpriv_entry = "1"b;
      301 	name_entry = "0"b;
      302 
      303 DELETE_JOIN:
      304 	active_connection_list_ptr = null;
      305 	on cleanup call Unlock ();
      306 	call Setup ();
      307 
      308 	my_process_id = get_process_id_ ();
      309 
      310 	if name_entry
      311 	then do;					/* given the name, must find it */
      312 	     connection_name = a_connection_name;
      313 	     call Find (connection_name, hash_index, offset, code);
      314 	     if code ^= 0
      315 	     then go to EXIT;
      316 	     if offset = ""b
      317 	     then do;
      318 		code = error_table_$noentry;
      319 		go to EXIT;
      320 	     end;
      321 	end;
      322 
      323 	else offset = a_offset;
      324 
      325 	act_ptr = ptr (active_connection_list_ptr, offset);
      326 
      327 	call Delete_one_entry ();			/* do it */
      328 	go to EXIT;
      329 
      330 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      331 
      332 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      333 /*							       */
      334 /* XXX_delete_all_for_user:					       */
      335 /* These two entry points delete all the connections of which a given	       */
      336 /* process is the user; they may be invoked when the process in question     */
      337 /* terminates.  The hpriv entry is called by a process other than the owner, */
      338 /* in the event that the owner has also terminated or is otherwise	       */
      339 /* unavailable.						       */
      340 /*							       */
      341 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      342 
      343 priv_delete_all_for_user:
      344      entry (a_user_process_id, a_code);
      345 
      346 	priv_entry = "1"b;
      347 	hpriv_entry = "0"b;
      348 	go to DELETE_ALL_JOIN;
      349 
      350 
      351 hpriv_delete_all_for_user:
      352      entry (a_user_process_id, a_code);
      353 
      354 	priv_entry = "0"b;
      355 	hpriv_entry = "1"b;
      356 
      357 DELETE_ALL_JOIN:
      358 	active_connection_list_ptr = null;
      359 	on cleanup call Unlock ();
      360 	call Setup ();
      361 
      362 	user_process_id = a_user_process_id;
      363 
      364 	next_act_ptr = Get_next_for_user (null (), user_process_id);
      365 						/* get first one */
      366 
      367 	do while (next_act_ptr ^= null ());
      368 	     this_act_ptr = next_act_ptr;
      369 	     next_act_ptr = Get_next_for_user (this_act_ptr, user_process_id);
      370 						/* have to get next one before we delete this one */
      371 
      372 	     act_ptr = this_act_ptr;			/* this little maneuver is required because */
      373 						/*   Get_next_for_owner plays with act_ptr. */
      374 	     call Delete_one_entry ();		/* to do the real work */
      375 	end;
      376 
      377 /* if Get_next_for_user returns null, there are no more */
      378 
      379 	go to EXIT;
      380 
      381 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      382 
      383 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      384 /*							       */
      385 /* priv_change_user:  this entry is called by the owner of a connection to   */
      386 /* assign it to a user process.				       */
      387 /*							       */
      388 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      389 
      390 priv_change_user:
      391      entry (a_offset, a_user_process_id, a_user_group_id, a_usage_type, a_terminate_event_channel, a_handle, a_code);
      392 
      393 	active_connection_list_ptr = null;
      394 	on cleanup call Unlock ();
      395 	call Setup ();
      396 
      397 	offset = a_offset;
      398 	user_process_id = a_user_process_id;
      399 	user_group_id = a_user_group_id;
      400 	usage_type = a_usage_type;
      401 	term_event_channel = a_terminate_event_channel;
      402 	initializer_handle = a_handle;
      403 	my_process_id = get_process_id_ ();
      404 
      405 	act_ptr = ptr (active_connection_list_ptr, offset);
      406 	if active_connection.version ^= ACT_VERSION_1
      407 	then do;					/* not really an entry */
      408 	     code = error_table_$noentry;
      409 	     go to EXIT;
      410 	end;
      411 
      412 	if active_connection.owner_process_id ^= my_process_id
      413 	then do;
      414 	     code = error_table_$not_privileged;	/* not one we control */
      415 	     go to EXIT;
      416 	end;
      417 
      418 	if active_connection.user_process_id ^= user_process_id
      419 						/* see if it already belongs to this user */
      420 	then do;
      421 	     if active_connection.user_process_id ^= ""b	/* does it belong to anyone? */
      422 	     then call Unthread_user ();		/* yes, unthread it from them */
      423 
      424 	     active_connection.user_process_id = user_process_id;
      425 	     call Thread_user ();
      426 	end;
      427 
      428 	active_connection.user_group_id = user_group_id;
      429 	active_connection.owner_terminate_event_channel = term_event_channel;
      430 	active_connection.owner_initializer_id = initializer_handle;
      431 	active_connection.usage_type = usage_type;
      432 	active_connection.delegated = "1"b;
      433 
      434 	go to EXIT;
      435 
      436 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      437 
      438 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      439 /*							       */
      440 /* priv_remove_user:  this entry is called by the owner of a connection to   */
      441 /* take it away from a user process without assigning it to a new one.       */
      442 /*							       */
      443 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      444 
      445 priv_remove_user:
      446      entry (a_offset, a_user_process_id, a_code);
      447 
      448 	active_connection_list_ptr = null;
      449 	on cleanup call Unlock ();
      450 	call Setup ();
      451 
      452 	offset = a_offset;
      453 	user_process_id = a_user_process_id;
      454 	my_process_id = get_process_id_ ();
      455 
      456 	act_ptr = ptr (active_connection_list_ptr, offset);
      457 	if active_connection.version ^= ACT_VERSION_1
      458 	then do;					/* not really an entry */
      459 	     code = error_table_$noentry;
      460 	     go to EXIT;
      461 	end;
      462 
      463 	if active_connection.owner_process_id ^= my_process_id
      464 	then do;
      465 	     code = error_table_$not_privileged;	/* not one we control */
      466 	     go to EXIT;
      467 	end;
      468 	if active_connection.user_process_id ^= user_process_id
      469 						/* doesn't belong to who we thought it did */
      470 	then do;
      471 	     code = error_table_$noentry;
      472 	     go to EXIT;
      473 	end;
      474 
      475 	call Unthread_user ();
      476 
      477 	active_connection.user_process_id = active_connection.owner_process_id;
      478 	active_connection.user_group_id = active_connection.owner_group_id;
      479 	active_connection.delegated = ""b;
      480 
      481 	call Thread_user ();
      482 
      483 	go to EXIT;
      484 
      485 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      486 
      487 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      488 /*							       */
      489 /* hpriv_get_next: This entry gets the next connection after the specified   */
      490 /* one (or the first one if the offset given is ""b).  It is used at	       */
      491 /* login_server initialization in order to find orphaned connections.	       */
      492 /*							       */
      493 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      494 
      495 hpriv_get_next:
      496      entry (a_offset, a_connection_info_ptr, a_code);
      497 
      498 	active_connection_list_ptr = null;
      499 	on cleanup call Unlock ();
      500 	call Setup ();
      501 
      502 	offset = a_offset;
      503 	active_connection_info_ptr = a_connection_info_ptr;
      504 	priv_entry = "0"b;
      505 	hpriv_entry = "1"b;
      506 
      507 	if offset = ""b
      508 	then next_offset = active_connection_list.first_connection_offset;
      509 
      510 	else do;
      511 	     act_ptr = ptr (active_connection_list_ptr, offset);
      512 	     next_offset = active_connection.next_connection;
      513 	end;
      514 
      515 	if next_offset = ""b
      516 	then code = error_table_$noentry;
      517 
      518 	else do;
      519 	     act_ptr = ptr (active_connection_list_ptr, next_offset);
      520 	     call Fill_info ();
      521 	end;
      522 
      523 	go to EXIT;
      524 
      525 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      526 
      527 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      528 /*							       */
      529 /* XXX_get_name:						       */
      530 /* These two entry points return information for the connection with the     */
      531 /* specified name.						       */
      532 /*							       */
      533 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      534 
      535 priv_get_name:
      536      entry (a_connection_name, a_connection_info_ptr, a_code);
      537 
      538 	priv_entry = "1"b;
      539 	hpriv_entry = "0"b;
      540 	go to GET_NAME_JOIN;
      541 
      542 
      543 hpriv_get_name:
      544      entry (a_connection_name, a_connection_info_ptr, a_code);
      545 
      546 	priv_entry = "0"b;
      547 	hpriv_entry = "1"b;
      548 
      549 GET_NAME_JOIN:
      550 	active_connection_list_ptr = null;
      551 	on cleanup call Unlock ();
      552 	call Setup ();
      553 
      554 	connection_name = a_connection_name;
      555 	active_connection_info_ptr = a_connection_info_ptr;
      556 
      557 	call Find (connection_name, hash_index, offset, code);
      558 	if code ^= 0
      559 	then go to EXIT;
      560 	if offset = ""b
      561 	then do;
      562 	     code = error_table_$noentry;
      563 	     go to EXIT;
      564 	end;
      565 
      566 	act_ptr = ptr (active_connection_list_ptr, offset);
      567 	call Fill_info ();
      568 	go to EXIT;
      569 
      570 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      571 
      572 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      573 /*							       */
      574 /* XXX_get_next_user:					       */
      575 /* The following entries return information about the next connection after  */
      576 /* the one with the specified offset with the same user, or the first for    */
      577 /* the given user if the offset is "0"b.			       */
      578 /*							       */
      579 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      580 
      581 priv_get_next_user:
      582      entry (a_user_process_id, a_offset, a_connection_info_ptr, a_code);
      583 
      584 	priv_entry = "1"b;
      585 	hpriv_entry = "0"b;
      586 	go to GET_NEXT_USER_JOIN;
      587 
      588 
      589 hpriv_get_next_user:
      590      entry (a_user_process_id, a_offset, a_connection_info_ptr, a_code);
      591 
      592 	priv_entry = "0"b;
      593 	hpriv_entry = "1"b;
      594 
      595 GET_NEXT_USER_JOIN:
      596 	active_connection_list_ptr = null;
      597 	on cleanup call Unlock ();
      598 	call Setup ();
      599 
      600 	user_process_id = a_user_process_id;
      601 	offset = a_offset;
      602 	active_connection_info_ptr = a_connection_info_ptr;
      603 
      604 	if offset = ""b
      605 	then act_ptr = null ();
      606 	else act_ptr = ptr (active_connection_list_ptr, offset);
      607 
      608 	act_ptr = Get_next_for_user (act_ptr, user_process_id);
      609 	if act_ptr ^= null ()
      610 	then call Fill_info ();
      611 	else code = error_table_$noentry;
      612 
      613 	go to EXIT;
      614 
      615 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      616 
      617 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      618 /*							       */
      619 /* XXX_get_next_owner:					       */
      620 /* The following entries return information about the next connection for    */
      621 /* which the calling process is the owner (or the first such if offset is    */
      622 /* "0"b).							       */
      623 /*							       */
      624 /* The highly privileged entrypoint returns information about a specified    */
      625 /* owner.							       */
      626 /*							       */
      627 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      628 
      629 priv_get_next_owner:
      630      entry (a_offset, a_connection_info_ptr, a_code);
      631 
      632 	priv_entry = "1"b;
      633 	hpriv_entry = "0"b;
      634 	owner_process_id = get_process_id_ ();
      635 
      636 	go to GET_NEXT_OWNER_JOIN;
      637 
      638 
      639 hpriv_get_next_owner:
      640      entry (a_offset, a_owner_process_id, a_connection_info_ptr, a_code);
      641 
      642 	priv_entry = "0"b;
      643 	hpriv_entry = "1"b;
      644 	owner_process_id = a_owner_process_id;
      645 
      646 GET_NEXT_OWNER_JOIN:
      647 	active_connection_list_ptr = null;
      648 	on cleanup call Unlock ();
      649 	call Setup ();
      650 
      651 	offset = a_offset;
      652 	active_connection_info_ptr = a_connection_info_ptr;
      653 
      654 	if offset = ""b
      655 	then act_ptr = null ();
      656 	else do;
      657 	     act_ptr = ptr (active_connection_list_ptr, offset);
      658 	     if active_connection.owner_process_id ^= owner_process_id
      659 						/* this isn't the right process to begin with */
      660 	     then do;
      661 		if hpriv_entry
      662 		then code = error_table_$noentry;
      663 		else code = error_table_$not_privileged;
      664 		go to EXIT;
      665 	     end;
      666 	end;
      667 
      668 	act_ptr = Get_next_for_owner (act_ptr, owner_process_id);
      669 
      670 	if act_ptr ^= null ()
      671 	then call Fill_info ();
      672 	else code = error_table_$noentry;
      673 	go to EXIT;
      674 
      675 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      676 
      677 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      678 /*							       */
      679 /* init:							       */
      680 /* This entry is called during system start up to create and initialize the  */
      681 /* segment that contains the active connection table. The directory in which */
      682 /* to create it is obtained from >sc1.  hash table size is a named constant  */
      683 /* from the include file.					       */
      684 /*							       */
      685 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      686 
      687 init:
      688      entry (a_code);
      689 
      690 	act_dir_name = sys_info$system_control_dir;
      691 	hash_size = ACT_HASH_TABLE_SIZE;
      692 
      693 	this_ring = get_ring_ ();
      694 	call cu_$level_get (orig_level);
      695 
      696 	on cleanup call cu_$level_set (orig_level);
      697 
      698 	call cu_$level_set (this_ring);		/* need lower-ring validation level for initiation or creation */
      699 
      700 	call initiate_file_ (act_dir_name, ACT_SEG_NAME, RW_ACCESS, active_connection_list_ptr, (0), code);
      701 
      702 	if code = error_table_$noentry
      703 	then do;					/* doesn't exist, we'll have to create it */
      704 
      705 	     auto_create_branch_info.version = create_branch_version_2;
      706 	     string (auto_create_branch_info.switches) = ""b;
      707 	     auto_create_branch_info.mode = RW_ACCESS;
      708 	     auto_create_branch_info.rings (*) = this_ring;
      709 	     auto_create_branch_info.userid = "*.*.*";
      710 	     auto_create_branch_info.bitcnt = 0;
      711 	     auto_create_branch_info.quota = 0;
      712 
      713 /* For debugging purposes, we will create the segment (in the user ring) at
      714*   system low, but in real life it should be system_high.
      715**/
      716 	     call convert_authorization_$from_string (sys_high_auth, "system_low" /* "system_high" */, code);
      717 	     if code ^= 0
      718 	     then go to INIT_EXIT;
      719 	     auto_create_branch_info.access_class = sys_high_auth;
      720 						/* make it multi-class */
      721 	     auto_create_branch_info.dir_quota = 0;
      722 
      723 	     call hcs_$create_branch_ (act_dir_name, ACT_SEG_NAME, addr (auto_create_branch_info), code);
      724 
      725 	     if code = 0
      726 	     then call initiate_file_ (act_dir_name, ACT_SEG_NAME, RW_ACCESS, active_connection_list_ptr, (0), code);
      727 	end;
      728 
      729 	call cu_$level_set (orig_level);		/* so's we don't forget */
      730 
      731 	if code = 0
      732 	then do;
      733 	     call set_lock_$lock (active_connection_list.initializer_of_list, 0, code);
      734 	     if code = error_table_$invalid_lock_reset
      735 	     then code = 0;
      736 	     else if code = error_table_$locked_by_other_process | code = error_table_$locked_by_this_process
      737 		| code = error_table_$lock_wait_time_exceeded
      738 	     then code = error_table_$already_initialized;
      739 	end;
      740 
      741 	if code = 0
      742 	then do;					/* created or otherwise, we have it now */
      743 
      744 /* initialize the contents */
      745 
      746 	     active_connection_list.version = ACTL_VERSION_1;
      747 	     active_connection_list.lock = ""b;
      748 	     active_connection_list.no_of_connections = 0;
      749 	     active_connection_list.first_connection_offset, active_connection_list.last_connection_offset = ""b;
      750 	     active_connection_list.hash_table.size, actl_hash_table_size = hash_size;
      751 	     active_connection_list.hash_table.entries (*) = ""b;
      752 
      753 	     connection_area_size = 0;		/* so we can use currentsize */
      754 	     words_used = currentsize (active_connection_list);
      755 	     words_used = words_used + mod (words_used, 2);
      756 						/* round up to even number */
      757 	     call terminate_file_ (addr (active_connection_list), words_used * BITS_PER_WORD, TERM_FILE_TRUNC, code);
      758 
      759 	     connection_area_size = sys_info$max_seg_size - words_used;
      760 						/* rest of segment is available for area */
      761 
      762 	     area_infop = addr (auto_area_info);
      763 
      764 	     area_info.version = 1;
      765 	     string (area_info.control) = ""b;
      766 	     area_info.owner = get_group_id_ ();
      767 	     area_info.size = connection_area_size;
      768 	     area_info.areap = addr (active_connection_list.connection_area);
      769 	     area_info.allocated_blocks, area_info.free_blocks, area_info.allocated_words, area_info.free_words = 0;
      770 
      771 	     call define_area_ (area_infop, code);
      772 	end;
      773 
      774 INIT_EXIT:
      775 	call cu_$level_set (orig_level);		/* in case we didn't do this before */
      776 
      777 	a_code = code;
      778 	return;
      779 
      780 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      781 
      782 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      783 /*							       */
      784 /* 		I N T E R N A L     P R O C E D U R E S		       */
      785 /*							       */
      786 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      787 
      788 
      789 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      790 /*							       */
      791 /* Delete_one_entry: deletes the connection list entry pointed to by	       */
      792 /* act_ptr.						       */
      793 /*							       */
      794 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      795 
      796 Delete_one_entry:
      797      procedure ();
      798 
      799 	if active_connection.version ^= ACT_VERSION_1
      800 	then do;
      801 	     if name_entry
      802 	     then code = error_table_$unimplemented_version;
      803 	     else code = error_table_$noentry;
      804 	     go to EXIT;
      805 	end;
      806 
      807 	if hpriv_entry
      808 	then ;
      809 	else if priv_entry
      810 	then if active_connection.owner_process_id ^= my_process_id
      811 	     then do;				/* we don't own this one */
      812 		code = error_table_$not_privileged;
      813 		go to EXIT;
      814 	     end;
      815 	     else ;
      816 
      817 	else if active_connection.user_process_id ^= my_process_id
      818 	then do;					/* no privileges, we should be user */
      819 	     code = error_table_$not_privileged;
      820 	     go to EXIT;
      821 	end;
      822 
      823 	call Unthread_user ();			/* take it out of user chain */
      824 	call Unthread ();				/* and others */
      825 
      826 	active_connection.version = "";		/* make sure it doesn't look like a good entry */
      827 	active_connection.connection_name = "";
      828 
      829 	free active_connection in (active_connection_list.connection_area);
      830 						/* get the space back */
      831 
      832      end Delete_one_entry;
      833 
      834 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      835 
      836 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      837 /*							       */
      838 /* Fill_info: fills in the active_connection_info structure for the current  */
      839 /* entry.							       */
      840 /*							       */
      841 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      842 
      843 Fill_info:
      844      procedure ();
      845 
      846 	if active_connection_info.version ^= ACT_INFO_VERSION_1
      847 	then do;
      848 	     code = error_table_$unimplemented_version;
      849 	     return;
      850 	end;
      851 
      852 	active_connection_info.connection_name = active_connection.connection_name;
      853 	active_connection_info.network_service_type = active_connection.service_type;
      854 	active_connection_info.user_process_id = active_connection.user_process_id;
      855 	active_connection_info.user_group_id = active_connection.user_group_id;
      856 	active_connection_info.owner_process_id = active_connection.owner_process_id;
      857 	active_connection_info.owner_group_id = active_connection.owner_group_id;
      858 	active_connection_info.terminate_event_channel = active_connection.owner_terminate_event_channel;
      859 	active_connection_info.owner_initializer_handle = active_connection.owner_initializer_id;
      860 	active_connection_info.force_disconnect_entry = active_connection.force_disconnect_entry;
      861 	active_connection_info.force_accounting_flush_entry = active_connection.force_accounting_flush_entry;
      862 	active_connection_info.connection_handle = active_connection.connection_handle;
      863 	active_connection_info.usage_type = active_connection.usage_type;
      864 	active_connection_info.flags.delegated = active_connection.flags.delegated;
      865 	active_connection_info.offset = rel (act_ptr);
      866 
      867 	return;
      868 
      869      end Fill_info;
      870 
      871 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      872 
      873 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      874 /*							       */
      875 /* Find:							       */
      876 /* Searches the list (using the hash table) for a connection with the	       */
      877 /* specified name, and returns its offset if one is found. Also returns the  */
      878 /* index to which the name hashes, for later use in threading/unthreading.   */
      879 /*							       */
      880 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      881 
      882 Find:
      883      procedure (a_connection_name, a_hash_index, a_offset, a_code);
      884 
      885 
      886 
      887 dcl  a_connection_name char (32) parameter;
      888 dcl  a_hash_index fixed bin parameter;
      889 dcl  a_offset bit (18) parameter;
      890 dcl  a_code fixed bin (35) parameter;
      891 
      892 dcl  hash_value fixed bin;
      893 dcl  connection_name char (32) aligned;
      894 dcl  offset bit (18);
      895 dcl  found bit (1);
      896 
      897 	connection_name = a_connection_name;
      898 	hash_value =
      899 	     hash_index_ (addr (connection_name), length (connection_name), (0), active_connection_list.hash_table.size)
      900 	     + 1;					/* our table is 1-based, but hash_index_'s result is 0-based */
      901 	offset = active_connection_list.hash_table.entries (hash_value);
      902 
      903 	if offset ^= ""b				/* if there are any names that hash to this value */
      904 	then do;
      905 	     found = "0"b;
      906 
      907 	     do while ((^found) & (offset ^= ""b));	/* find the one that actually has the same name */
      908 		act_ptr = ptr (active_connection_list_ptr, offset);
      909 		if active_connection.connection_name = connection_name
      910 		then found = "1"b;
      911 		else offset = active_connection.next_hash;
      912 						/* not this one, check next */
      913 	     end;
      914 	end;
      915 
      916 	a_offset = offset;				/* = ""b if name not found */
      917 	a_hash_index = hash_value;			/* valid in any case */
      918 	a_code = 0;				/* always */
      919 	return;
      920 
      921      end Find;
      922 
      923 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      924 
      925 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      926 /*							       */
      927 /* Get_next_for_user:					       */
      928 /* Returns a pointer to the next connection for the same user (and, if not   */
      929 /* the hpriv entry, the same owner) after the one input; or the first one if */
      930 /* a_act_ptr is null.					       */
      931 /*							       */
      932 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      933 
      934 Get_next_for_user:
      935      procedure (a_act_ptr, a_process_id) returns (pointer);
      936 
      937 dcl  a_act_ptr pointer parameter;
      938 dcl  a_process_id bit (36) parameter;
      939 
      940 dcl  found bit (1);
      941 dcl  my_process_id bit (36);
      942 dcl  next_offset bit (18);
      943 dcl  owner_process_id bit (36);
      944 dcl  user_process_id bit (36);
      945 
      946 	act_ptr = a_act_ptr;
      947 	user_process_id = a_process_id;
      948 	my_process_id = get_process_id_ ();
      949 
      950 	if act_ptr ^= null ()			/* we were given one, find next */
      951 	then do;
      952 	     next_offset = active_connection.next_connection_for_user;
      953 	     if next_offset = ""b			/* there isn't one */
      954 	     then return (null ());
      955 	     act_ptr = ptr (active_connection_list_ptr, next_offset);
      956 						/* this is the one we will consider */
      957 	end;
      958 
      959 	else do;					/* given nul pointer, we'll have to find first one */
      960 	     found = "0"b;
      961 	     do next_offset = active_connection_list.first_connection_offset
      962 		repeat (active_connection.next_connection) while ((next_offset ^= ""b) & (^found));
      963 		act_ptr = ptr (active_connection_list_ptr, next_offset);
      964 		if active_connection.user_process_id = user_process_id
      965 		then found = "1"b;
      966 	     end;
      967 
      968 	     if ^found
      969 	     then return (null ());			/* there weren't any */
      970 	end;
      971 
      972 /* if not privileged entry, make sure we're the owner */
      973 
      974 	if ^hpriv_entry
      975 	then do while (active_connection.owner_process_id ^= my_process_id);
      976 	     next_offset = active_connection.next_connection_for_user;
      977 	     if next_offset = ""b			/* we ran out */
      978 	     then return (null ());
      979 	     else act_ptr = ptr (active_connection_list_ptr, next_offset);
      980 	end;
      981 
      982 	return (act_ptr);				/* if we get to here, we've got the right one */
      983 
      984 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      985 
      986 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      987 /*							       */
      988 /* Get_next_for_owner:					       */
      989 /* Likewise, but returns a pointer to the next one for the given owner       */
      990 /* process.						       */
      991 /*							       */
      992 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      993 
      994 Get_next_for_owner:
      995      entry (a_act_ptr, a_process_id) returns (pointer);
      996 
      997 	act_ptr = a_act_ptr;
      998 	owner_process_id = a_process_id;
      999 
     1000 	if act_ptr ^= null ()			/* we were given one, find next */
     1001 	then do;
     1002 	     next_offset = active_connection.next_connection_for_owner;
     1003 	     act_ptr = ptr (active_connection_list_ptr, next_offset);
     1004 						/* this is the one we will consider */
     1005 	     if next_offset = ""b			/* there isn't one */
     1006 	     then return (null ());
     1007 	     else return (act_ptr);
     1008 	end;
     1009 
     1010 	else do;					/* have to find first one */
     1011 	     do next_offset = active_connection_list.first_connection_offset
     1012 		repeat (active_connection.next_connection) while (next_offset ^= ""b);
     1013 		act_ptr = ptr (active_connection_list_ptr, next_offset);
     1014 		if active_connection.owner_process_id = owner_process_id
     1015 		then return (act_ptr);		/* this is it */
     1016 	     end;
     1017 
     1018 	     return (null ());			/* there weren't any */
     1019 	end;
     1020 
     1021      end Get_next_for_user;
     1022 
     1023 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1024 
     1025 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1026 /*							       */
     1027 /* Lock:  lock the active connection table.			       */
     1028 /* Unlock: unlock it.					       */
     1029 /*							       */
     1030 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1031 
     1032 Lock:
     1033      procedure (a_code) returns (bit (1));
     1034 
     1035 dcl  a_code fixed bin (35) parameter;
     1036 
     1037 dcl  code fixed bin (35);
     1038 
     1039 	call set_lock_$lock (active_connection_list.lock, LOCK_WAIT_TIME, code);
     1040 
     1041 	if code = 0 | code = error_table_$invalid_lock_reset
     1042 	then do;
     1043 	     a_code = 0;
     1044 	     return ("1"b);
     1045 	end;
     1046 
     1047 	else do;
     1048 	     a_code = code;
     1049 	     return ("0"b);
     1050 	end;
     1051 
     1052      end Lock;
     1053 
     1054 
     1055 Unlock:
     1056      procedure ();
     1057 
     1058 dcl  code fixed bin (35);
     1059 
     1060 	if active_connection_list_ptr ^= null
     1061 	then call set_lock_$unlock (active_connection_list.lock, code);
     1062 	return;
     1063 
     1064      end Unlock;
     1065 
     1066 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1067 
     1068 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1069 /*							       */
     1070 /* Setup:							       */
     1071 /* 1) Initialize code variable to 0.				       */
     1072 /* 2) Get pointer to active_connection_list segment if we don't already have */
     1073 /*    a static copy.					       */
     1074 /* 3) Lock the connection table.				       */
     1075 /* 4) Make sure the table has been initialized this bootload.  If not,       */
     1076 /*    return error back to caller.				       */
     1077 /*							       */
     1078 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1079 
     1080 Setup:
     1081      procedure ();
     1082 
     1083 	act_dir_name = sys_info$system_control_dir;
     1084 	code = 0;
     1085 	locked = "0"b;
     1086 	if static_connection_list_ptr = null ()		/* first use in this process */
     1087 	then do;
     1088 	     call cu_$level_get (orig_level);
     1089 
     1090 	     on cleanup call cu_$level_set (orig_level);
     1091 
     1092 	     call cu_$level_set (get_ring_ ());		/* need lower-ring validation level for initiation or creation */
     1093 	     call initiate_file_ (act_dir_name, ACT_SEG_NAME, RW_ACCESS, static_connection_list_ptr, (0), code);
     1094 	     call cu_$level_set (orig_level);
     1095 	     if code ^= 0
     1096 	     then go to EXIT;
     1097 	end;
     1098 
     1099 	active_connection_list_ptr = static_connection_list_ptr;
     1100 
     1101 	locked = Lock (code);
     1102 	if code ^= 0
     1103 	then go to EXIT;
     1104 
     1105 /* make sure database has been initialized this bootload */
     1106 	temp_lock_word = active_connection_list.initializer_of_list;
     1107 	call set_lock_$lock (temp_lock_word, 0, code);
     1108 	if code = error_table_$invalid_lock_reset
     1109 	then do;
     1110 	     code = error_table_$not_initialized;
     1111 	     go to EXIT;
     1112 	end;
     1113 	else if code = error_table_$locked_by_other_process | code = error_table_$locked_by_this_process
     1114 	     | code = error_table_$lock_wait_time_exceeded
     1115 	then code = 0;
     1116 	if code ^= 0
     1117 	then go to EXIT;
     1118 	return;
     1119 
     1120      end Setup;
     1121 
     1122 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1123 
     1124 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1125 /*							       */
     1126 /* Thread: threads a connection into:				       */
     1127 /*  1) the list of all connections,				       */
     1128 /*  2) the threaded list by owner, and				       */
     1129 /*  3) the list sharing a hash index.				       */
     1130 /*							       */
     1131 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1132 
     1133 Thread:
     1134      procedure ();
     1135 
     1136 dcl  found bit (1);
     1137 dcl  hash_value fixed bin;
     1138 dcl  last_hash bit (18);
     1139 dcl  next_act_ptr pointer;
     1140 dcl  next_hash bit (18);
     1141 dcl  next_offset bit (18);
     1142 dcl  offset bit (18);
     1143 dcl  prev_act_ptr pointer;
     1144 dcl  prev_hash bit (18);
     1145 dcl  prev_offset bit (18);
     1146 dcl  temp_act_ptr pointer;
     1147 
     1148 	offset = rel (act_ptr);
     1149 	if active_connection_list.hash_table.entries (hash_index) = ""b
     1150 	then do;					/* this is the first one with this hash_index */
     1151 	     active_connection_list.hash_table.entries (hash_index) = offset;
     1152 	     active_connection.prev_hash = ""b;
     1153 	end;
     1154 
     1155 	else do;					/* hash slot occupied, thread it to hash list */
     1156 	     do last_hash = active_connection_list.hash_table.entries (hash_index) repeat (next_hash)
     1157 		while (last_hash ^= ""b);
     1158 		temp_act_ptr = ptr (active_connection_list_ptr, last_hash);
     1159 		next_hash = temp_act_ptr -> active_connection.next_hash;
     1160 		prev_hash = last_hash;
     1161 	     end;
     1162 
     1163 	     temp_act_ptr -> active_connection.next_hash = offset;
     1164 	     active_connection.prev_hash = prev_hash;
     1165 	end;
     1166 
     1167 	active_connection.next_hash = ""b;		/* in any case */
     1168 
     1169 /* now thread into owner list */
     1170 
     1171 	found = "0"b;
     1172 	do prev_offset = active_connection_list.last_connection_offset
     1173 	     repeat (temp_act_ptr -> active_connection.prev_connection) while ((prev_offset ^= ""b) & (^found));
     1174 	     temp_act_ptr = ptr (active_connection_list_ptr, prev_offset);
     1175 	     if temp_act_ptr -> active_connection.owner_process_id = active_connection.owner_process_id
     1176 	     then found = "1"b;			/* we found the end of the list for this owner */
     1177 	end;
     1178 
     1179 	if found
     1180 	then do;
     1181 	     active_connection.prev_connection_for_owner = rel (temp_act_ptr);
     1182 	     temp_act_ptr -> active_connection.next_connection_for_owner = offset;
     1183 	end;
     1184 
     1185 	else active_connection.prev_connection_for_owner = ""b;
     1186 						/* there aren't any others yet */
     1187 
     1188 	active_connection.next_connection_for_owner = ""b;/* in any case */
     1189 
     1190 /* now thread it onto end of list of all connections */
     1191 
     1192 	active_connection.prev_connection = active_connection_list.last_connection_offset;
     1193 	active_connection.next_connection = ""b;
     1194 
     1195 	if active_connection_list.last_connection_offset = ""b
     1196 	then do;					/* this is the very first one */
     1197 	     active_connection_list.first_connection_offset, active_connection_list.last_connection_offset = offset;
     1198 	end;
     1199 
     1200 	else do;
     1201 	     temp_act_ptr = ptr (active_connection_list_ptr, active_connection_list.last_connection_offset);
     1202 	     temp_act_ptr -> active_connection.next_connection = offset;
     1203 	     active_connection_list.last_connection_offset = offset;
     1204 	end;
     1205 
     1206 	active_connection_list.no_of_connections = active_connection_list.no_of_connections + 1;
     1207 	return;
     1208 
     1209 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1210 
     1211 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1212 /*							       */
     1213 /* Thread_user:						       */
     1214 /* threads a connection into the list by user.  It finds the previous one    */
     1215 /* for the same user by chasing back the global connection threads.	       */
     1216 /*							       */
     1217 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1218 
     1219 Thread_user:
     1220      entry ();
     1221 
     1222 	offset = rel (act_ptr);
     1223 	if active_connection.prev_connection = ""b
     1224 	then prev_act_ptr = null ();
     1225 
     1226 	else do;
     1227 	     found = "0"b;
     1228 	     do prev_offset = active_connection.prev_connection
     1229 		repeat (prev_act_ptr -> active_connection.prev_connection) while ((prev_offset ^= ""b) & (^found));
     1230 		prev_act_ptr = ptr (active_connection_list_ptr, prev_offset);
     1231 		if prev_act_ptr -> active_connection.user_process_id = active_connection.user_process_id
     1232 		then found = "1"b;
     1233 	     end;
     1234 
     1235 	     if ^found
     1236 	     then prev_act_ptr = null ();
     1237 	end;
     1238 
     1239 	if prev_act_ptr ^= null ()
     1240 	then do;
     1241 	     next_offset = prev_act_ptr -> active_connection.next_connection_for_user;
     1242 	     if next_offset = ""b
     1243 	     then next_act_ptr = null ();
     1244 	     else next_act_ptr = ptr (active_connection_list_ptr, next_offset);
     1245 	end;
     1246 
     1247 	else do;					/* none before it, find the first one after it */
     1248 	     if active_connection.next_connection = ""b
     1249 	     then next_act_ptr = null ();
     1250 
     1251 	     else do;
     1252 		found = "0"b;
     1253 		do next_offset = active_connection.next_connection
     1254 		     repeat (next_act_ptr -> active_connection.next_connection)
     1255 		     while ((next_offset ^= ""b) & (^found));
     1256 		     next_act_ptr = ptr (active_connection_list_ptr, next_offset);
     1257 		     if next_act_ptr -> active_connection.user_process_id = active_connection.user_process_id
     1258 		     then found = "1"b;
     1259 		end;
     1260 
     1261 		if ^found
     1262 		then next_act_ptr = null ();
     1263 	     end;
     1264 	end;
     1265 
     1266 /* Having found next and/or previous, do the actual threading */
     1267 
     1268 	if next_act_ptr = null ()
     1269 	then active_connection.next_connection_for_user = ""b;
     1270 
     1271 	else do;
     1272 	     active_connection.next_connection_for_user = rel (next_act_ptr);
     1273 	     next_act_ptr -> active_connection.prev_connection_for_user = offset;
     1274 	end;
     1275 
     1276 	if prev_act_ptr = null ()
     1277 	then active_connection.prev_connection_for_user = ""b;
     1278 
     1279 	else do;
     1280 	     active_connection.prev_connection_for_user = rel (prev_act_ptr);
     1281 	     prev_act_ptr -> active_connection.next_connection_for_user = offset;
     1282 	end;
     1283 
     1284 	return;
     1285 
     1286 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1287 
     1288 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1289 /*							       */
     1290 /* Unthread: removes a connection from:				       */
     1291 /*  1) the list of all connections,				       */
     1292 /*  2) the owner list, and					       */
     1293 /*  3) the list sharing a hash index.				       */
     1294 /*							       */
     1295 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1296 
     1297 Unthread:
     1298      entry ();
     1299 
     1300 /* Owner list first */
     1301 
     1302 	if active_connection.prev_connection_for_owner ^= ""b
     1303 	then do;
     1304 	     prev_act_ptr = ptr (active_connection_list_ptr, active_connection.prev_connection_for_owner);
     1305 	     prev_act_ptr -> active_connection.next_connection_for_owner = active_connection.next_connection_for_owner;
     1306 	end;
     1307 
     1308 	if active_connection.next_connection_for_owner ^= ""b
     1309 	then do;
     1310 	     next_act_ptr = ptr (active_connection_list_ptr, active_connection.next_connection_for_owner);
     1311 	     next_act_ptr -> active_connection.prev_connection_for_owner = active_connection.prev_connection_for_owner;
     1312 	end;
     1313 
     1314 /* now hash list */
     1315 
     1316 	if active_connection.next_hash ^= ""b
     1317 	then do;
     1318 	     next_act_ptr = ptr (active_connection_list_ptr, active_connection.next_hash);
     1319 	     next_act_ptr -> active_connection.prev_hash = active_connection.prev_hash;
     1320 	end;
     1321 
     1322 	if active_connection.prev_hash ^= ""b
     1323 	then do;
     1324 	     prev_act_ptr = ptr (active_connection_list_ptr, active_connection.prev_hash);
     1325 	     prev_act_ptr -> active_connection.next_hash = active_connection.next_hash;
     1326 	end;
     1327 
     1328 	else do;					/* this was first one in hash list, update hash table entry */
     1329 	     hash_value =
     1330 		hash_index_ (addr (active_connection.connection_name), length (active_connection.connection_name),
     1331 		(0), active_connection_list.hash_table.size) + 1;
     1332 						/* because our table is 1-based */
     1333 	     active_connection_list.hash_table.entries (hash_value) = active_connection.next_hash;
     1334 	end;
     1335 
     1336 	active_connection.prev_hash, active_connection.next_hash = ""b;
     1337 
     1338 /* now unthread it from list of all connections */
     1339 
     1340 	if active_connection.next_connection ^= ""b
     1341 	then do;
     1342 	     next_act_ptr = ptr (active_connection_list_ptr, active_connection.next_connection);
     1343 	     next_act_ptr -> active_connection.prev_connection = active_connection.prev_connection;
     1344 	end;
     1345 
     1346 	else active_connection_list.last_connection_offset = active_connection.prev_connection;
     1347 
     1348 	if active_connection.prev_connection ^= ""b
     1349 	then do;
     1350 	     prev_act_ptr = ptr (active_connection_list_ptr, active_connection.prev_connection);
     1351 	     prev_act_ptr -> active_connection.next_connection = active_connection.next_connection;
     1352 	end;
     1353 
     1354 	else active_connection_list.first_connection_offset = active_connection.next_connection;
     1355 
     1356 	active_connection.prev_connection, active_connection.next_connection = ""b;
     1357 
     1358 	active_connection_list.no_of_connections = active_connection_list.no_of_connections - 1;
     1359 	return;
     1360 
     1361 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1362 
     1363 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1364 /*							       */
     1365 /* Unthread_user:						       */
     1366 /* removes a connection from the list threaded by user.		       */
     1367 /*							       */
     1368 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1369 
     1370 Unthread_user:
     1371      entry ();
     1372 
     1373 	if active_connection.prev_connection_for_user ^= ""b
     1374 	then do;
     1375 	     prev_act_ptr = ptr (active_connection_list_ptr, active_connection.prev_connection_for_user);
     1376 	     prev_act_ptr -> active_connection.next_connection_for_user = active_connection.next_connection_for_user;
     1377 	end;
     1378 
     1379 	if active_connection.next_connection_for_user ^= ""b
     1380 	then do;
     1381 	     next_act_ptr = ptr (active_connection_list_ptr, active_connection.next_connection_for_user);
     1382 	     next_act_ptr -> active_connection.prev_connection_for_user = active_connection.prev_connection_for_user;
     1383 	end;
     1384 
     1385 	active_connection.prev_connection_for_user, active_connection.next_connection_for_user = ""b;
     1386 
     1387 	return;
     1388 
     1389      end Thread;
     1390 
     1391 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1392  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     1392 
     1393  /*  BEGIN:   active_connection_list.incl.pl1		  *  *  *  *  *  */
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(85-04-01,Coren), approve(87-06-24,MCR7681), audit(87-03-26,GDixon),
  2     5*     install(87-08-04,MR12.1-1056):
  2     6*     Initial coding.
  2     7*  2) change(87-03-31,GDixon), approve(87-06-24,MCR7681),
  2     8*     audit(87-06-24,Hartogs), install(87-08-04,MR12.1-1056):
  2     9*      A) Add CONNECTION_LIST_HASH_SIZE named constant.
  2    10*      B) Add initializer_of_list lock element to the table header.
  2    11*      C) Add force_accounting_flush_entry element to list entries.
  2    12*  3) change(87-05-13,Brunelle), approve(87-06-24,MCR7681),
  2    13*     audit(87-06-24,Hartogs), install(87-08-04,MR12.1-1056):
  2    14*     Add .owner_group_id field.
  2    15*                                                   END HISTORY COMMENTS */
  2    16 
  2    17 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    18 /*							       */
  2    19 /* This include file defines the inner-ring system-wide table of network     */
  2    20 /* connections that have been assigned to user processes, either by login    */
  2    21 /* servers or as a result of dial_out operations.  This table is maintained  */
  2    22 /* via gate entries: privileged ones, used by login servers, to add and      */
  2    23 /* delete connections assigned to user processes; and by highly privileged   */
  2    24 /* gates used by the Initializer to obtain connection data for all login     */
  2    25 /* servers.						       */
  2    26 /*							       */
  2    27 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    28 
  2    29 dcl active_connection_list_ptr pointer;
  2    30 dcl actl_hash_table_size fixed bin;
  2    31 
  2    32 dcl 1 active_connection_list aligned based (active_connection_list_ptr),
  2    33     2 header,
  2    34       3 version char (8),				/* "actlNNNN" */
  2    35       3 lock bit (36) aligned,			/* to guard against simultaneous updates */
  2    36       3 initializer_of_list bit (36) aligned,		/* lock ID of process which initialized the list. */
  2    37       3 no_of_connections fixed bin,
  2    38       3 first_connection_offset bit (18),
  2    39       3 last_connection_offset bit (18),
  2    40       3 header_pad (7) fixed bin (35),
  2    41     2 hash_table,
  2    42       3 size fixed bin,
  2    43       3 entries (actl_hash_table_size refer (active_connection_list.hash_table.size)) bit (18) unaligned,
  2    44     2 connection_area area (connection_area_size);	/* where connection entries are allocated */
  2    45 
  2    46 dcl connection_area_size fixed bin (18) unsigned;
  2    47 
  2    48 dcl act_ptr pointer;
  2    49 
  2    50 dcl 1 active_connection aligned based (act_ptr),
  2    51     2 version char (8),				/* "actNNNNN" */
  2    52     2 connection_name char (32),			/* ID of the connection */
  2    53     2 service_type char (32),				/* network service type of this connection */
  2    54     2 user_process_id bit (36) aligned,			/* process to which this connection is assigned */
  2    55     2 user_group_id char (32),			/* person.project.tag */
  2    56     2 owner_process_id bit (36) aligned,		/* login server process, if any */
  2    57     2 owner_group_id char (32),			/* person.project.tag */
  2    58     2 owner_terminate_event_channel fixed bin (71),	/* to wake up owner on process termination */
  2    59     2 owner_initializer_id bit (72) aligned,		/* for communicating with initializer on termination if owner is dead */
  2    60     2 force_disconnect_entry char (64),			/* name of the entrypoint used to force disconnection */
  2    61     2 force_accounting_flush_entry char (64),		/* name of the entrypoint used to force account update */
  2    62     2 connection_handle fixed bin (35),			/* handle used in calling service entries */
  2    63     2 prev_connection bit (18) unaligned,		/* offset of previous connection in list */
  2    64     2 next_connection bit (18) unaligned,		/* offset of next connection in list */
  2    65     2 prev_hash bit (18) unaligned,			/* offset of previous connection sharing hash table entry */
  2    66     2 next_hash bit (18) unaligned,			/* offset of next connection sharing hash table entry */
  2    67     2 prev_connection_for_user bit (18) unaligned,	/* offset of previous connection for this user */
  2    68     2 next_connection_for_user bit (18) unaligned,	/* offset of next connection for this user */
  2    69     2 prev_connection_for_owner bit (18) unaligned,	/* offset of previous connection for this owner */
  2    70     2 next_connection_for_owner bit (18) unaligned,	/* offset of next connection for this owner */
  2    71     2 usage_type fixed bin,				/* login, dial_out, etc. -- see ls_usage_types.incl.pl1 */
  2    72     2 flags,
  2    73       3 delegated bit (1) unaligned,			/* assigned to user by owner */
  2    74       3 mbz_bits bit (35) unaligned;
  2    75 
  2    76 dcl ACTL_VERSION_1 char (8) internal static options (constant) initial ("actl0001");
  2    77 dcl ACT_VERSION_1 char (8) internal static options (constant) initial ("act00001");
  2    78 dcl ACT_HASH_TABLE_SIZE fixed bin int static options(constant) init(23);
  2    79 						/* This constant must be odd, to cause allocation */
  2    80 						/* area to begin on a doubleword boundary. */
  2    81 
  2    82 
  2    83 /*  END OF:  active_connection_list.incl.pl1		  *  *  *  *  *  */
     1393 
     1394  /*  BEGIN:   active_connection_info.incl.pl1		  *  *  *  *  *  */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(86-06-30,Coren), approve(86-06-30,MCR7415),
  3     5*     audit(86-07-02,Margolin), install(86-07-11,MR12.0-1092):
  3     6*     Initial implementation.
  3     7*  2) change(87-04-07,GDixon), approve(87-06-24,MCR7681),
  3     8*     audit(87-06-24,Hartogs), install(87-08-04,MR12.1-1056):
  3     9*     Add .force_accounting_flush_entry element.
  3    10*  3) change(87-05-13,Brunelle), approve(87-06-24,MCR7681),
  3    11*     audit(87-06-24,Hartogs), install(87-08-04,MR12.1-1056):
  3    12*     Add .owner_group_id field.
  3    13*                                                   END HISTORY COMMENTS */
  3    14 
  3    15 /* Defines the information returned to the outer ring about a single entry in 
  3    16*   the active connection list */
  3    17 
  3    18 dcl active_connection_info_ptr pointer;
  3    19 
  3    20 dcl 1 active_connection_info aligned based (active_connection_info_ptr),
  3    21     2 version char (8),				/* "actiNNNN" */
  3    22     2 connection_name char (32),			/* name of the connection */
  3    23     2 network_service_type char (32),			/* name of service */
  3    24     2 user_process_id bit (36),			/* process assigned as the user */
  3    25     2 user_group_id char (32),			/* likewise */
  3    26     2 owner_process_id bit (36),			/* process that created the connection */
  3    27     2 owner_group_id char (32),			/* likewise */
  3    28     2 terminate_event_channel fixed bin (71),		/* channel to wake the owner if user process terminates */
  3    29     2 owner_initializer_handle bit (72),		/* handle for communicating with initializer */
  3    30     2 force_disconnect_entry char (64),			/* name of entry to call to force disconnection */
  3    31 						/*   (in case owner is gone)  */
  3    32     2 force_accounting_flush_entry char (64),		/* name of entry to call to force accounting flush */
  3    33     2 connection_handle fixed bin (35),			/* handle used in calling service entries */
  3    34     2 usage_type fixed bin,				/* login, etc. see ls_usage_types.incl.pl1 */
  3    35     2 flags,
  3    36       3 delegated bit (1) unaligned,			/* assigned to user by owner */
  3    37       3 mbz_bits bit (35) unaligned,
  3    38     2 offset bit (18);				/* offset of entry in connection list segment */
  3    39 
  3    40 dcl ACT_INFO_VERSION_1 char (8) internal static options (constant) initial ("acti0001");
  3    41 
  3    42 
  3    43 /*  END OF:  active_connection_info.incl.pl1		  *  *  *  *  *  */
     1394 
     1395  /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  4     2 
  4     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  4     4 
  4     5 dcl  area_infop ptr;
  4     6 
  4     7 dcl 1 area_info aligned based (area_infop),
  4     8     2 version fixed bin,				/* version number for this structure is 1 */
  4     9     2 control aligned like area_control,		/* control bits for the area */
  4    10     2 owner char (32) unal,				/* creator of the area */
  4    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  4    12     2 size fixed bin (18),				/* size of the area in words */
  4    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  4    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  4    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  4    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  4    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  4    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  4    19 
  4    20 dcl 1 area_control aligned based,
  4    21     2 extend bit (1) unal,				/* says area is extensible */
  4    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  4    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  4    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  4    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  4    26     2 system bit (1) unal,				/* says area is managed by system */
  4    27     2 pad bit (30) unal;
  4    28 
  4    29 /* END INCLUDE FILE area_info.incl.pl1 */
     1395 
     1396  /*  BEGIN INCLUDE FILE - - - create_branch_info.incl.pl1 - - - created January 1975 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(89-01-16,TLNguyen), approve(89-01-16,MCR8049),
  5     6*     audit(89-02-03,Parisek), install(89-03-15,MR12.3-1025):
  5     7*       1. Declare version constant properly.
  5     8*       2. Remove version 1 since it was never referenced and to force
  5     9*          callers to upgrade their programs.
  5    10*                                                   END HISTORY COMMENTS */
  5    11 
  5    12 
  5    13 /* Modified December 1984 for dir_quota, Keith Loepere. */
  5    14 
  5    15 /* this include files gives the argument structure for create_branch_ */
  5    16 
  5    17 dcl 1 create_branch_info aligned based,
  5    18     2 version fixed bin,				/* set this to the largest value given below */
  5    19     2 switches unaligned,
  5    20       3 dir_sw bit (1) unaligned,			/* if on, a directory branch is wanted */
  5    21       3 copy_sw bit (1) unaligned,			/* if on, initiating segment will be done by copying */
  5    22       3 chase_sw bit (1) unaligned,			/* if on, if pathname is a link, it will be chased */
  5    23       3 priv_upgrade_sw bit (1) unaligned,		/* privileged creation (ring 1) of upgraded object */
  5    24       3 parent_ac_sw bit (1) unaligned,			/* if on, use parent's access class for seg or dir created */
  5    25       3 mbz1 bit (31) unaligned,			/* pad to full word */
  5    26     2 mode bit (3) unaligned,				/* segment or directory for acl for userid */
  5    27     2 mbz2 bit (33) unaligned,			/* pad to full word */
  5    28     2 rings (3) fixed bin (3),			/* branch's ring brackets */
  5    29     2 userid char (32),				/* user's access control name */
  5    30     2 bitcnt fixed bin (24),				/* bit count of the segment */
  5    31     2 quota fixed bin (18),				/* for directories, this am't of quota will be moved to it */
  5    32     2 access_class bit (72),				/* is the access class of the body of the branch */
  5    33     2 dir_quota fixed bin (18);			/* for directories, this am't of dir quota will be moved to it */
  5    34 
  5    35 dcl  create_branch_version_2 fixed bin int static options (constant) init (2);
  5    36 
  5    37 /* END INCLUDE FILE - - - create_branch_info.incl.pl1 - - - */
  5    38 
     1396 
     1397  /* BEGIN INCLUDE FILE ... system_constants.incl.pl1 */
  6     2 
  6     3 /****^  HISTORY COMMENTS:
  6     4*  1) change(86-11-12,GWMay), approve(86-11-12,MCR7445), audit(86-11-19,GDixon),
  6     5*     install(86-11-21,MR12.0-1223):
  6     6*     created.
  6     7*                                                   END HISTORY COMMENTS */
  6     8 
  6     9 /* format: off */
  6    10 
  6    11 /* ************************************************************************ */
  6    12 /*							      */
  6    13 /* Function: Provides constants for commonly used Multics system values.    */
  6    14 /*							      */
  6    15 /* Usage: These values are available for use in place of "magic" numbers    */
  6    16 /*        (unexplained numbers) in programming applications.	      */
  6    17 /*							      */
  6    18 /* Definitions:						      */
  6    19 /*							      */
  6    20 /*   PER             bit     character/byte     word     page     segment   */
  6    21 /*		 					      */
  6    22 /*   bits              1            9             36     36864    9400320   */
  6    23 /*   characters/bytes	      1	           4      4096    1044480   */
  6    24 /*   words				 1      1024     261120   */
  6    25 /*   pages				           1        255   */
  6    26 /*   segments						  1   */
  6    27 /*							      */
  6    28 /*  The base values for a bit, char, word and page are determined by the    */
  6    29 /*  Multics hardware implementation.  The other values are calculated from  */
  6    30 /*  their relation to one another as shown in the matrix above.	      */
  6    31 /*							      */
  6    32 /*  BITS_PER_CHAR     = 9 (defined by the hardware)		      */
  6    33 /*  BITS_PER_WORD     = BITS_PER_CHAR * CHARS_PER_WORD		      */
  6    34 /*		  = 9 * 4					      */
  6    35 /*		  = 36					      */
  6    36 /*  BITS_PER_PAGE     = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE     */
  6    37 /*		  = 9 * 4 * 1024				      */
  6    38 /*		  = 36864					      */
  6    39 /*  BITS_PER_SEGMENT  = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE *   */
  6    40 /*		    PAGES_PER_SEGMENT			      */
  6    41 /*		  = 9 * 4 * 1024 * 255			      */
  6    42 /*		  = 9400320				      */
  6    43 /*							      */
  6    44 /*  CHARS_PER_WORD    = 4 (defined by the hardware)		      */
  6    45 /*  CHARS_PER_PAGE    = CHARS_PER_WORD * WORDS_PER_PAGE		      */
  6    46 /*		  = 4 * 1024				      */
  6    47 /*		  = 4096					      */
  6    48 /*  CHARS_PER_SEGMENT = CHARS_PER_WORD * WORDS_PER_PAGE * PAGES_PER_SEGMENT */
  6    49 /*		  = 4 * 1024 * 255				      */
  6    50 /*		  = 1044480				      */
  6    51 /*							      */
  6    52 /*  WORDS_PER_PAGE    = 1024 (defined by the hardware)		      */
  6    53 /*  WORDS_PER_SEGMENT = WORDS_PER_PAGE * PAGES_PER_SEGMENT		      */
  6    54 /*		  = 1024 * 255				      */
  6    55 /*		  = 261120				      */
  6    56 /*							      */
  6    57 /*  PAGES_PER_SEGMENT = 255 (defined by system standard)		      */
  6    58 /*							      */
  6    59 /* ************************************************************************ */
  6    60 
  6    61        declare BITS_PER_CHAR		fixed bin (4) internal static
  6    62 				options (constant) initial (9);
  6    63 
  6    64        declare BITS_PER_WORD		fixed bin (6) internal static
  6    65 				options (constant) initial (36);
  6    66 
  6    67        declare BITS_PER_PAGE		fixed bin (16) internal static
  6    68 				options (constant) initial (36864);
  6    69 
  6    70        declare BITS_PER_SEGMENT	fixed bin (24) internal static
  6    71 				options (constant) initial (9400320);
  6    72 
  6    73        declare CHARS_PER_WORD		fixed bin (3) internal static
  6    74 				options (constant) initial (4);
  6    75 
  6    76        declare CHARS_PER_PAGE		fixed bin (13) internal static
  6    77 				options (constant) initial (4096);
  6    78 
  6    79        declare CHARS_PER_SEGMENT	fixed bin (21) internal static
  6    80 				options (constant) initial (1044480);
  6    81 
  6    82        /* Note: WORDS_PER_PAGE should be equal to sys_info$max_page_size    */
  6    83 
  6    84        declare WORDS_PER_PAGE		fixed bin (11) internal static
  6    85 				options (constant) initial (1024);
  6    86 
  6    87        /* Note: WORDS_PER_SEGMENT should be equal to sys_info$max_seg_size  */
  6    88 
  6    89        declare WORDS_PER_SEGMENT	fixed bin (21) internal static
  6    90 				options (constant) initial (261120);
  6    91 
  6    92        declare PAGES_PER_SEGMENT	fixed bin (8) internal static
  6    93 				options (constant) initial (255);
  6    94 
  6    95 /* END INCLUDE FILE ... system_constants.incl.pl1 */
  6    96 
     1397 
     1398  /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  7     2 /* format: style2,^inddcls,idind32 */
  7     3 
  7     4 declare 1 terminate_file_switches	based,
  7     5 	2 truncate		bit (1) unaligned,
  7     6 	2 set_bc			bit (1) unaligned,
  7     7 	2 terminate		bit (1) unaligned,
  7     8 	2 force_write		bit (1) unaligned,
  7     9 	2 delete			bit (1) unaligned;
  7    10 
  7    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  7    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  7    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  7    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  7    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  7    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  7    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  7    18 
  7    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
     1398 
     1399 
     1400      end connection_list_manager_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/15/89  0800.0  connection_list_manager_.pl1      >special_ldd>install>MR12.3-1025>connection_list_manager_.pl1
1392         1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
1393         2    08/06/87  0913.4  active_connection_list.incl.pl1   >ldd>include>active_connection_list.incl.pl1
1394         3    08/06/87  0913.4  active_connection_info.incl.pl1   >ldd>include>active_connection_info.incl.pl1
1395         4    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
1396         5    03/15/89  0759.4  create_branch_info.incl.pl1       >special_ldd>install>MR12.3-1025>create_branch_info.incl.pl1
1397         6    11/24/86  1243.9  system_constants.incl.pl1         >ldd>include>system_constants.incl.pl1
1398         7    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTL_VERSION_1                  000004 constant        char(8)                  initial packed unaligned dcl 2-76 ref 746
ACT_HASH_TABLE_SIZE                    constant        fixed bin(17,0)          initial dcl 2-78 ref 691
ACT_INFO_VERSION_1              000000 constant        char(8)                  initial packed unaligned dcl 3-40 ref 846
ACT_SEG_NAME                    000010 constant        char(32)                 initial packed unaligned dcl 178 set ref 700* 723*
                                                                                  725* 1093*
ACT_VERSION_1                   000002 constant        char(8)                  initial packed unaligned dcl 2-77 ref 228 406 457
                                                                                  799
BITS_PER_WORD                          constant        fixed bin(6,0)           initial dcl 6-64 ref 757
LOCK_WAIT_TIME                  000007 constant        fixed bin(17,0)          initial dcl 179 set ref 1039*
RW_ACCESS                       000006 constant        bit(3)                   initial packed unaligned dcl 1-11 set ref 700* 707
                                                                                  725* 1093*
TERM_FILE_TRUNC                 000024 constant        bit(1)                   initial packed unaligned dcl 7-11 set ref 757*
a_act_ptr                              parameter       pointer                  dcl 937 ref 934 946 994 997
a_code                                 parameter       fixed bin(35,0)          dcl 85 in procedure "connection_list_manager_" set
                                                                                  ref 195 247* 262 271 279 287 296 343 351 390 445
                                                                                  495 535 543 581 589 629 639 687 777*
a_code                                 parameter       fixed bin(35,0)          dcl 890 in procedure "Find" set ref 882 918*
a_code                                 parameter       fixed bin(35,0)          dcl 1035 in procedure "Lock" set ref 1032 1043*
                                                                                  1048*
a_connection_handle                    parameter       fixed bin(35,0)          dcl 86 ref 195 207
a_connection_info_ptr                  parameter       pointer                  dcl 87 ref 495 503 535 543 555 581 589 602 629 639
                                                                                  652
a_connection_name                      parameter       char(32)                 packed unaligned dcl 887 in procedure "Find" ref 882
                                                                                  897
a_connection_name                      parameter       char                     packed unaligned dcl 88 in procedure
                                                                                  "connection_list_manager_" ref 195 206 262 287 312
                                                                                  535 543 554
a_force_accounting                     parameter       char                     packed unaligned dcl 89 ref 195 205
a_force_disconnect                     parameter       char                     packed unaligned dcl 90 ref 195 204
a_handle                               parameter       bit(72)                  dcl 91 ref 390 402
a_hash_index                           parameter       fixed bin(17,0)          dcl 888 set ref 882 917*
a_offset                               parameter       bit(18)                  packed unaligned dcl 92 in procedure
                                                                                  "connection_list_manager_" set ref 195 242* 271
                                                                                  279 296 323 390 397 445 452 495 502 581 589 601
                                                                                  629 639 651
a_offset                               parameter       bit(18)                  packed unaligned dcl 889 in procedure "Find" set ref
                                                                                  882 916*
a_owner_process_id                     parameter       bit(36)                  packed unaligned dcl 93 ref 639 644
a_process_id                           parameter       bit(36)                  packed unaligned dcl 938 ref 934 947 994 998
a_service_type                         parameter       char                     packed unaligned dcl 94 ref 195 208
a_terminate_event_channel              parameter       fixed bin(71,0)          dcl 95 ref 390 401
a_usage_type                           parameter       fixed bin(17,0)          dcl 96 ref 195 203 390 400
a_user_group_id                        parameter       char                     packed unaligned dcl 97 ref 390 399
a_user_process_id                      parameter       bit(36)                  packed unaligned dcl 98 ref 343 351 362 390 398 445
                                                                                  453 581 589 600
access_class             20     000326 automatic       bit(72)                  level 2 dcl 137 set ref 719*
act_dir_name                    000100 automatic       char(168)                packed unaligned dcl 103 set ref 690* 700* 723* 725*
                                                                                  1083* 1093*
act_ptr                         000364 automatic       pointer                  dcl 2-48 set ref 224* 226 228 229 230 231 231 232
                                                                                  232 233 234 235 236 242 325* 372* 405* 406 412 418
                                                                                  421 424 428 429 430 431 432 456* 457 463 468 477
                                                                                  477 478 478 479 511* 512 519* 566* 604* 606* 608*
                                                                                  608* 609 654* 657* 658 668* 668* 670 799 809 817
                                                                                  826 827 829 852 853 854 855 856 857 858 859 860
                                                                                  861 862 863 864 865 908* 909 911 946* 950 952 955*
                                                                                  963* 964 966 974 976 979* 982 997* 1000 1002 1003*
                                                                                  1007 1013* 1014 1014 1016 1148 1152 1164 1167 1175
                                                                                  1181 1185 1188 1192 1193 1222 1223 1228 1231 1248
                                                                                  1253 1257 1268 1272 1276 1280 1302 1304 1305 1308
                                                                                  1310 1311 1316 1318 1319 1322 1324 1325 1329 1329
                                                                                  1329 1329 1333 1336 1336 1340 1342 1343 1346 1348
                                                                                  1350 1351 1354 1356 1356 1373 1375 1376 1379 1381
                                                                                  1382 1385 1385
active_connection                      based           structure                level 1 dcl 2-50 set ref 224 226* 829
active_connection_info                 based           structure                level 1 dcl 3-20
active_connection_info_ptr      000366 automatic       pointer                  dcl 3-18 set ref 503* 555* 602* 652* 846 852 853 854
                                                                                  855 856 857 858 859 860 861 862 863 864 865
active_connection_list                 based           structure                level 1 dcl 2-32 set ref 754 757 757
active_connection_list_ptr      000360 automatic       pointer                  dcl 2-29 set ref 199* 224 303* 325 357* 393* 405
                                                                                  448* 456 498* 507 511 519 549* 566 595* 606 646*
                                                                                  657 700* 725* 733 746 747 748 749 749 750 751 754
                                                                                  757 757 768 829 898 901 908 955 961 963 979 1003
                                                                                  1011 1013 1039 1060 1060 1099* 1106 1149 1151 1156
                                                                                  1158 1172 1174 1192 1195 1197 1197 1201 1201 1203
                                                                                  1206 1206 1230 1244 1256 1304 1310 1318 1324 1329
                                                                                  1333 1342 1346 1350 1354 1358 1358 1375 1381
actl_hash_table_size            000362 automatic       fixed bin(17,0)          dcl 2-30 set ref 750*
addr                                                   builtin function         dcl 185 ref 723 723 757 757 762 768 898 898 1329
                                                                                  1329
allocated_blocks         20            based           fixed bin(17,0)          level 2 dcl 4-7 set ref 769*
allocated_words          22            based           fixed bin(30,0)          level 2 dcl 4-7 set ref 769*
area_control                           based           structure                level 1 dcl 4-20
area_info                              based           structure                level 1 dcl 4-7
area_infop                      000370 automatic       pointer                  dcl 4-5 set ref 762* 764 765 766 767 768 769 769 769
                                                                                  769 771*
areap                    16            based           pointer                  level 2 dcl 4-7 set ref 768*
auto_area_info                  000302 automatic       structure                level 1 dcl 136 set ref 762
auto_create_branch_info         000326 automatic       structure                level 1 dcl 137 set ref 723 723
bitcnt                   16     000326 automatic       fixed bin(24,0)          level 2 dcl 137 set ref 710*
cleanup                         000352 stack reference condition                dcl 186 ref 200 305 359 394 449 499 551 597 648 696
                                                                                  1090
code                            000152 automatic       fixed bin(35,0)          dcl 104 in procedure "connection_list_manager_" set
                                                                                  ref 212* 213 218* 247 313* 314 318* 408* 414* 459*
                                                                                  465* 471* 515* 557* 558 562* 611* 661* 663* 672*
                                                                                  700* 702 716* 717 723* 725 725* 731 733* 734 734*
                                                                                  736 736 736 736* 741 757* 771* 777 801* 803* 812*
                                                                                  819* 848* 1084* 1093* 1095 1101* 1102 1107* 1108
                                                                                  1110* 1113 1113 1113 1113* 1116
code                            000100 automatic       fixed bin(35,0)          dcl 1058 in procedure "Unlock" set ref 1060*
code                            000106 automatic       fixed bin(35,0)          dcl 1037 in procedure "Lock" set ref 1039* 1041 1041
                                                                                  1048
connection_area                        based           area                     level 2 dcl 2-32 set ref 224 768 829
connection_area_size            000363 automatic       fixed bin(18,0)          unsigned dcl 2-46 set ref 753* 754 759* 767
connection_handle       110            based           fixed bin(35,0)          level 2 in structure "active_connection_info"
                                                                                  dcl 3-20 in procedure "connection_list_manager_"
                                                                                  set ref 862*
connection_handle       110            based           fixed bin(35,0)          level 2 in structure "active_connection" dcl 2-50
                                                                                  in procedure "connection_list_manager_" set ref
                                                                                  235* 862
connection_handle               000153 automatic       fixed bin(35,0)          dcl 105 in procedure "connection_list_manager_" set
                                                                                  ref 207* 235
connection_name           2            based           char(32)                 level 2 in structure "active_connection_info"
                                                                                  dcl 3-20 in procedure "connection_list_manager_"
                                                                                  set ref 852*
connection_name                 000154 automatic       char(32)                 packed unaligned dcl 106 in procedure
                                                                                  "connection_list_manager_" set ref 206* 212* 229
                                                                                  312* 313* 554* 557*
connection_name           2            based           char(32)                 level 2 in structure "active_connection" dcl 2-50
                                                                                  in procedure "connection_list_manager_" set ref
                                                                                  229* 827* 852 909 1329 1329 1329 1329
connection_name                 000431 automatic       char(32)                 dcl 893 in procedure "Find" set ref 897* 898 898 898
                                                                                  898 909
control                   1            based           structure                level 2 dcl 4-7 set ref 765*
convert_authorization_$from_string
                                000012 constant        entry                    external dcl 142 ref 716
create_branch_info                     based           structure                level 1 dcl 5-17
create_branch_version_2                constant        fixed bin(17,0)          initial dcl 5-35 ref 705
cu_$level_get                   000014 constant        entry                    external dcl 143 ref 694 1088
cu_$level_set                   000016 constant        entry                    external dcl 144 ref 696 698 729 774 1090 1092 1094
currentsize                                            builtin function         dcl 185 ref 754
define_area_                    000020 constant        entry                    external dcl 145 ref 771
delegated               116            based           bit(1)                   level 3 in structure "active_connection" packed
                                                                                  packed unaligned dcl 2-50 in procedure
                                                                                  "connection_list_manager_" set ref 432* 479* 864
delegated               112            based           bit(1)                   level 3 in structure "active_connection_info" packed
                                                                                  packed unaligned dcl 3-20 in procedure
                                                                                  "connection_list_manager_" set ref 864*
dir_quota                22     000326 automatic       fixed bin(18,0)          level 2 dcl 137 set ref 721*
entries                  17            based           bit(18)                  array level 3 packed packed unaligned dcl 2-32 set
                                                                                  ref 751* 901 1149 1151* 1156 1333*
error_table_$already_initialized
                                000044 external static fixed bin(35,0)          dcl 159 ref 736
error_table_$invalid_lock_reset 000046 external static fixed bin(35,0)          dcl 159 ref 734 1041 1108
error_table_$lock_wait_time_exceeded
                                000050 external static fixed bin(35,0)          dcl 159 ref 736 1113
error_table_$locked_by_other_process
                                000052 external static fixed bin(35,0)          dcl 159 ref 736 1113
error_table_$locked_by_this_process
                                000054 external static fixed bin(35,0)          dcl 159 ref 736 1113
error_table_$namedup            000056 external static fixed bin(35,0)          dcl 159 ref 218
error_table_$noentry            000060 external static fixed bin(35,0)          dcl 159 ref 318 408 459 471 515 562 611 661 672 702
                                                                                  803
error_table_$not_initialized    000062 external static fixed bin(35,0)          dcl 159 ref 1110
error_table_$not_privileged     000064 external static fixed bin(35,0)          dcl 159 ref 414 465 663 812 819
error_table_$unimplemented_version
                                000066 external static fixed bin(35,0)          dcl 159 ref 801 848
first_connection_offset
                          5            based           bit(18)                  level 3 dcl 2-32 set ref 507 749* 961 1011 1197*
                                                                                  1354*
flags                   112            based           structure                level 2 in structure "active_connection_info"
                                                                                  dcl 3-20 in procedure "connection_list_manager_"
flags                   116            based           structure                level 2 in structure "active_connection" dcl 2-50
                                                                                  in procedure "connection_list_manager_"
force_accounting_flush_entry
                         70            based           char(64)                 level 2 in structure "active_connection_info"
                                                                                  dcl 3-20 in procedure "connection_list_manager_"
                                                                                  set ref 861*
force_accounting_flush_entry
                         70            based           char(64)                 level 2 in structure "active_connection" dcl 2-50
                                                                                  in procedure "connection_list_manager_" set ref
                                                                                  234* 861
force_acct_entry                000164 automatic       char(64)                 packed unaligned dcl 107 set ref 205* 234
force_disc_entry                000204 automatic       char(64)                 packed unaligned dcl 108 set ref 204* 233
force_disconnect_entry
                         50            based           char(64)                 level 2 in structure "active_connection" dcl 2-50
                                                                                  in procedure "connection_list_manager_" set ref
                                                                                  233* 860
force_disconnect_entry
                         50            based           char(64)                 level 2 in structure "active_connection_info"
                                                                                  dcl 3-20 in procedure "connection_list_manager_"
                                                                                  set ref 860*
found                           000466 automatic       bit(1)                   packed unaligned dcl 1136 in procedure "Thread" set
                                                                                  ref 1171* 1172 1175* 1179 1227* 1228 1231* 1235
                                                                                  1252* 1253 1257* 1261
found                           000442 automatic       bit(1)                   packed unaligned dcl 895 in procedure "Find" set ref
                                                                                  905* 907 909*
found                           000452 automatic       bit(1)                   packed unaligned dcl 940 in procedure
                                                                                  "Get_next_for_user" set ref 960* 961 964* 968
free_blocks              21            based           fixed bin(17,0)          level 2 dcl 4-7 set ref 769*
free_words               23            based           fixed bin(30,0)          level 2 dcl 4-7 set ref 769*
get_group_id_                   000022 constant        entry                    external dcl 146 ref 232 766
get_process_id_                 000024 constant        entry                    external dcl 147 ref 231 308 403 454 634 948
get_ring_                       000026 constant        entry                    external dcl 148 ref 693 1092 1092
hash_index                      000224 automatic       fixed bin(17,0)          dcl 109 set ref 212* 313* 557* 1149 1151 1156
hash_index_                     000030 constant        entry                    external dcl 149 ref 898 1329
hash_size                       000225 automatic       fixed bin(17,0)          dcl 110 set ref 691* 750
hash_table               16            based           structure                level 2 dcl 2-32
hash_value                      000467 automatic       fixed bin(17,0)          dcl 1137 in procedure "Thread" set ref 1329* 1333
hash_value                      000430 automatic       fixed bin(17,0)          dcl 892 in procedure "Find" set ref 898* 901 917
hcs_$create_branch_             000032 constant        entry                    external dcl 150 ref 723
header                                 based           structure                level 2 dcl 2-32
hpriv_entry                     000226 automatic       bit(1)                   packed unaligned dcl 111 set ref 266* 275* 283* 291*
                                                                                  300* 347* 355* 505* 539* 547* 585* 593* 633* 643*
                                                                                  661 807 974
initializer_handle              000230 automatic       bit(72)                  dcl 112 set ref 402* 430
initializer_of_list       3            based           bit(36)                  level 3 dcl 2-32 set ref 733* 1106
initiate_file_                  000034 constant        entry                    external dcl 151 ref 700 725 1093
last_connection_offset
                          6            based           bit(18)                  level 3 dcl 2-32 set ref 749* 1172 1192 1195 1197*
                                                                                  1201 1203* 1346*
last_hash                       000470 automatic       bit(18)                  packed unaligned dcl 1138 set ref 1156* 1156* 1158
                                                                                  1160*
length                                                 builtin function         dcl 185 ref 898 898 1329 1329
lock                      2            based           bit(36)                  level 3 dcl 2-32 set ref 747* 1039* 1060*
locked                          000232 automatic       bit(1)                   packed unaligned dcl 113 set ref 244 1085* 1101*
mod                                                    builtin function         dcl 185 ref 755
mode                      2     000326 automatic       bit(3)                   level 2 packed packed unaligned dcl 137 set ref 707*
my_process_id                   000233 automatic       bit(36)                  packed unaligned dcl 114 in procedure
                                                                                  "connection_list_manager_" set ref 308* 403* 412
                                                                                  454* 463 809 817
my_process_id                   000453 automatic       bit(36)                  packed unaligned dcl 941 in procedure
                                                                                  "Get_next_for_user" set ref 948* 974
name_entry                      000234 automatic       bit(1)                   packed unaligned dcl 115 set ref 267* 276* 284* 292*
                                                                                  301* 310 801
network_service_type     12            based           char(32)                 level 2 dcl 3-20 set ref 853*
next_act_ptr                    000236 automatic       pointer                  dcl 116 in procedure "connection_list_manager_" set
                                                                                  ref 364* 367 368 369*
next_act_ptr                    000472 automatic       pointer                  dcl 1139 in procedure "Thread" set ref 1242* 1244*
                                                                                  1248* 1256* 1257 1259 1261* 1268 1272 1273 1310*
                                                                                  1311 1318* 1319 1342* 1343 1381* 1382
next_connection         111(18)        based           bit(18)                  level 2 packed packed unaligned dcl 2-50 set ref 512
                                                                                  966 1016 1193* 1202* 1248 1253 1259 1340 1342
                                                                                  1351* 1351 1354 1356*
next_connection_for_owner
                        114(18)        based           bit(18)                  level 2 packed packed unaligned dcl 2-50 set ref
                                                                                  1002 1182* 1188* 1305* 1305 1308 1310
next_connection_for_user
                        113(18)        based           bit(18)                  level 2 packed packed unaligned dcl 2-50 set ref 952
                                                                                  976 1241 1268* 1272* 1281* 1376* 1376 1379 1381
                                                                                  1385*
next_hash                       000474 automatic       bit(18)                  packed unaligned dcl 1140 in procedure "Thread" set
                                                                                  ref 1159* 1161
next_hash               112(18)        based           bit(18)                  level 2 in structure "active_connection" packed
                                                                                  packed unaligned dcl 2-50 in procedure
                                                                                  "connection_list_manager_" set ref 911 1159 1163*
                                                                                  1167* 1316 1318 1325* 1325 1333 1336*
next_offset                     000475 automatic       bit(18)                  packed unaligned dcl 1141 in procedure "Thread" set
                                                                                  ref 1241* 1242 1244 1253* 1253* 1256*
next_offset                     000240 automatic       bit(18)                  packed unaligned dcl 117 in procedure
                                                                                  "connection_list_manager_" set ref 507* 512* 515
                                                                                  519
next_offset                     000454 automatic       bit(18)                  packed unaligned dcl 942 in procedure
                                                                                  "Get_next_for_user" set ref 952* 953 955 961* 961*
                                                                                  963* 976* 977 979 1002* 1003 1005 1011* 1011*
                                                                                  1013*
no_of_connections         4            based           fixed bin(17,0)          level 3 dcl 2-32 set ref 748* 1206* 1206 1358* 1358
null                                                   builtin function         dcl 185 ref 199 303 357 364 364 367 393 448 498 549
                                                                                  595 604 609 646 654 670 950 953 968 977 1000 1005
                                                                                  1018 1060 1086 1223 1235 1239 1242 1248 1261 1268
                                                                                  1276
offset                          000476 automatic       bit(18)                  packed unaligned dcl 1142 in procedure "Thread" set
                                                                                  ref 1148* 1151 1163 1182 1197 1202 1203 1222* 1273
                                                                                  1281
offset                          000241 automatic       bit(18)                  packed unaligned dcl 118 in procedure
                                                                                  "connection_list_manager_" set ref 212* 216 313*
                                                                                  316 323* 325 397* 405 452* 456 502* 507 511 557*
                                                                                  560 566 601* 604 606 651* 654 657
offset                          000441 automatic       bit(18)                  packed unaligned dcl 894 in procedure "Find" set ref
                                                                                  901* 903 907 908 911* 916
offset                  113            based           bit(18)                  level 2 in structure "active_connection_info"
                                                                                  dcl 3-20 in procedure "connection_list_manager_"
                                                                                  set ref 865*
orig_level                      000242 automatic       fixed bin(17,0)          dcl 119 set ref 694* 696* 729* 774* 1088* 1090*
                                                                                  1094*
owner                     2            based           char(32)                 level 2 packed packed unaligned dcl 4-7 set ref 766*
owner_group_id           34            based           char(32)                 level 2 in structure "active_connection" dcl 2-50
                                                                                  in procedure "connection_list_manager_" set ref
                                                                                  232* 478 857
owner_group_id           34            based           char(32)                 level 2 in structure "active_connection_info"
                                                                                  dcl 3-20 in procedure "connection_list_manager_"
                                                                                  set ref 857*
owner_initializer_handle
                         46            based           bit(72)                  level 2 dcl 3-20 set ref 859*
owner_initializer_id     46            based           bit(72)                  level 2 dcl 2-50 set ref 430* 859
owner_process_id         33            based           bit(36)                  level 2 in structure "active_connection" dcl 2-50
                                                                                  in procedure "connection_list_manager_" set ref
                                                                                  231* 412 463 477 658 809 856 974 1014 1175 1175
owner_process_id                000243 automatic       bit(36)                  packed unaligned dcl 120 in procedure
                                                                                  "connection_list_manager_" set ref 634* 644* 658
                                                                                  668*
owner_process_id         33            based           bit(36)                  level 2 in structure "active_connection_info"
                                                                                  dcl 3-20 in procedure "connection_list_manager_"
                                                                                  set ref 856*
owner_process_id                000455 automatic       bit(36)                  packed unaligned dcl 943 in procedure
                                                                                  "Get_next_for_user" set ref 998* 1014
owner_terminate_event_channel
                         44            based           fixed bin(71,0)          level 2 dcl 2-50 set ref 429* 858
prev_act_ptr                    000500 automatic       pointer                  dcl 1143 set ref 1223* 1230* 1231 1233 1235* 1239
                                                                                  1241 1276 1280 1281 1304* 1305 1324* 1325 1350*
                                                                                  1351 1375* 1376
prev_connection         111            based           bit(18)                  level 2 packed packed unaligned dcl 2-50 set ref
                                                                                  1177 1192* 1223 1228 1233 1343* 1343 1346 1348
                                                                                  1350 1356*
prev_connection_for_owner
                        114            based           bit(18)                  level 2 packed packed unaligned dcl 2-50 set ref
                                                                                  1181* 1185* 1302 1304 1311* 1311
prev_connection_for_user
                        113            based           bit(18)                  level 2 packed packed unaligned dcl 2-50 set ref
                                                                                  1273* 1276* 1280* 1373 1375 1382* 1382 1385*
prev_hash               112            based           bit(18)                  level 2 in structure "active_connection" packed
                                                                                  packed unaligned dcl 2-50 in procedure
                                                                                  "connection_list_manager_" set ref 1152* 1164*
                                                                                  1319* 1319 1322 1324 1336*
prev_hash                       000502 automatic       bit(18)                  packed unaligned dcl 1144 in procedure "Thread" set
                                                                                  ref 1160* 1164
prev_offset                     000503 automatic       bit(18)                  packed unaligned dcl 1145 set ref 1172* 1172* 1174*
                                                                                  1228* 1228* 1230*
priv_entry                      000244 automatic       bit(1)                   packed unaligned dcl 121 set ref 265* 274* 282* 290*
                                                                                  299* 346* 354* 504* 538* 546* 584* 592* 632* 642*
                                                                                  809
ptr                                                    builtin function         dcl 185 ref 325 405 456 511 519 566 606 657 908 955
                                                                                  963 979 1003 1013 1158 1174 1201 1230 1244 1256
                                                                                  1304 1310 1318 1324 1342 1350 1375 1381
quota                    17     000326 automatic       fixed bin(18,0)          level 2 dcl 137 set ref 711*
rel                                                    builtin function         dcl 185 ref 242 865 1148 1181 1222 1272 1280
rings                     3     000326 automatic       fixed bin(3,0)           array level 2 dcl 137 set ref 708*
service_type                    000245 automatic       char(32)                 packed unaligned dcl 122 in procedure
                                                                                  "connection_list_manager_" set ref 208* 230
service_type             12            based           char(32)                 level 2 in structure "active_connection" dcl 2-50
                                                                                  in procedure "connection_list_manager_" set ref
                                                                                  230* 853
set_lock_$lock                  000036 constant        entry                    external dcl 152 ref 733 1039 1107
set_lock_$unlock                000040 constant        entry                    external dcl 153 ref 1060
size                     16            based           fixed bin(17,0)          level 3 in structure "active_connection_list"
                                                                                  dcl 2-32 in procedure "connection_list_manager_"
                                                                                  set ref 224 750* 751 754 768 829 898* 1329*
size                     13            based           fixed bin(18,0)          level 2 in structure "area_info" dcl 4-7
                                                                                  in procedure "connection_list_manager_" set ref
                                                                                  767*
static_connection_list_ptr      000010 internal static pointer                  initial dcl 180 set ref 1086 1093* 1099
string                                                 builtin function         dcl 185 set ref 706* 765*
switches                  1     000326 automatic       structure                level 2 packed packed unaligned dcl 137 set ref 706*
sys_high_auth                   000256 automatic       bit(72)                  dcl 123 set ref 716* 719
sys_info$max_seg_size           000070 external static fixed bin(18,0)          dcl 172 ref 759
sys_info$system_control_dir     000072 external static varying char(168)        dcl 173 ref 690 1083
temp_act_ptr                    000504 automatic       pointer                  dcl 1146 set ref 1158* 1159 1163 1174* 1175 1177
                                                                                  1181 1182 1201* 1202
temp_lock_word                  000260 automatic       bit(36)                  dcl 124 set ref 1106* 1107*
term_event_channel              000262 automatic       fixed bin(71,0)          dcl 125 set ref 401* 429
terminate_event_channel
                         44            based           fixed bin(71,0)          level 2 dcl 3-20 set ref 858*
terminate_file_                 000042 constant        entry                    external dcl 154 ref 757
this_act_ptr                    000264 automatic       pointer                  dcl 126 set ref 368* 369* 372
this_ring                       000266 automatic       fixed bin(17,0)          dcl 127 set ref 693* 698* 708
unspec                                                 builtin function         dcl 185 set ref 226*
usage_type                      000267 automatic       fixed bin(17,0)          dcl 128 in procedure "connection_list_manager_" set
                                                                                  ref 203* 236 400* 431
usage_type              115            based           fixed bin(17,0)          level 2 in structure "active_connection" dcl 2-50
                                                                                  in procedure "connection_list_manager_" set ref
                                                                                  236* 431* 863
usage_type              111            based           fixed bin(17,0)          level 2 in structure "active_connection_info"
                                                                                  dcl 3-20 in procedure "connection_list_manager_"
                                                                                  set ref 863*
user_group_id            23            based           char(32)                 level 2 in structure "active_connection" dcl 2-50
                                                                                  in procedure "connection_list_manager_" set ref
                                                                                  232* 428* 478* 855
user_group_id                   000270 automatic       char(32)                 packed unaligned dcl 129 in procedure
                                                                                  "connection_list_manager_" set ref 399* 428
user_group_id            23            based           char(32)                 level 2 in structure "active_connection_info"
                                                                                  dcl 3-20 in procedure "connection_list_manager_"
                                                                                  set ref 855*
user_process_id          22            based           bit(36)                  level 2 in structure "active_connection" dcl 2-50
                                                                                  in procedure "connection_list_manager_" set ref
                                                                                  231* 418 421 424* 468 477* 817 854 964 1231 1231
                                                                                  1257 1257
user_process_id                 000456 automatic       bit(36)                  packed unaligned dcl 944 in procedure
                                                                                  "Get_next_for_user" set ref 947* 964
user_process_id          22            based           bit(36)                  level 2 in structure "active_connection_info"
                                                                                  dcl 3-20 in procedure "connection_list_manager_"
                                                                                  set ref 854*
user_process_id                 000300 automatic       bit(36)                  packed unaligned dcl 130 in procedure
                                                                                  "connection_list_manager_" set ref 362* 364* 369*
                                                                                  398* 418 424 453* 468 600* 608*
userid                    6     000326 automatic       char(32)                 level 2 dcl 137 set ref 709*
version                                based           char(8)                  level 2 in structure "active_connection" dcl 2-50
                                                                                  in procedure "connection_list_manager_" set ref
                                                                                  228* 406 457 799 826*
version                                based           fixed bin(17,0)          level 2 in structure "area_info" dcl 4-7
                                                                                  in procedure "connection_list_manager_" set ref
                                                                                  764*
version                                based           char(8)                  level 2 in structure "active_connection_info"
                                                                                  dcl 3-20 in procedure "connection_list_manager_"
                                                                                  ref 846
version                         000326 automatic       fixed bin(17,0)          level 2 in structure "auto_create_branch_info"
                                                                                  dcl 137 in procedure "connection_list_manager_"
                                                                                  set ref 705*
version                                based           char(8)                  level 3 in structure "active_connection_list"
                                                                                  dcl 2-32 in procedure "connection_list_manager_"
                                                                                  set ref 746*
words_used                      000301 automatic       fixed bin(17,0)          dcl 131 set ref 754* 755* 755 755 757 759

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
BITS_PER_CHAR                          internal static fixed bin(4,0)           initial dcl 6-61
BITS_PER_PAGE                          internal static fixed bin(16,0)          initial dcl 6-67
BITS_PER_SEGMENT                       internal static fixed bin(24,0)          initial dcl 6-70
CHARS_PER_PAGE                         internal static fixed bin(13,0)          initial dcl 6-76
CHARS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 6-79
CHARS_PER_WORD                         internal static fixed bin(3,0)           initial dcl 6-73
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
PAGES_PER_SEGMENT                      internal static fixed bin(8,0)           initial dcl 6-92
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
TERM_FILE_BC                           internal static bit(2)                   initial packed unaligned dcl 7-12
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 7-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 7-16
TERM_FILE_TERM                         internal static bit(3)                   initial packed unaligned dcl 7-14
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial packed unaligned dcl 7-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial packed unaligned dcl 7-15
WORDS_PER_PAGE                         internal static fixed bin(11,0)          initial dcl 6-84
WORDS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 6-89
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
area_info_version_1                    internal static fixed bin(17,0)          initial dcl 4-3
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 7-4

NAMES DECLARED BY EXPLICIT CONTEXT.
DELETE_ALL_JOIN                 000652 constant        label                    dcl 357 ref 348
DELETE_JOIN                     000513 constant        label                    dcl 303 ref 268 277 285 293
Delete_one_entry                002616 constant        entry                    internal dcl 796 ref 327 374
EXIT                            000342 constant        label                    dcl 244 ref 213 219 314 319 328 379 409 415 434 460
                                                                                  466 472 483 523 558 563 568 613 664 673 804 813
                                                                                  820 1095 1102 1111 1116
Fill_info                       002707 constant        entry                    internal dcl 843 ref 520 567 609 670
Find                            002771 constant        entry                    internal dcl 882 ref 212 313 557
GET_NAME_JOIN                   001446 constant        label                    dcl 549 ref 540
GET_NEXT_OWNER_JOIN             001755 constant        label                    dcl 646 ref 636
GET_NEXT_USER_JOIN              001602 constant        label                    dcl 595 ref 586
Get_next_for_owner              003216 constant        entry                    internal dcl 994 ref 668
Get_next_for_user               003073 constant        entry                    internal dcl 934 ref 364 369 608
INIT_EXIT                       002604 constant        label                    dcl 774 ref 717
Lock                            003277 constant        entry                    internal dcl 1032 ref 1101
Setup                           003367 constant        entry                    internal dcl 1080 ref 201 306 360 395 450 500 552
                                                                                  598 649
Thread                          003632 constant        entry                    internal dcl 1133 ref 238
Thread_user                     003776 constant        entry                    internal dcl 1219 ref 240 425 481
Unlock                          003342 constant        entry                    internal dcl 1055 ref 200 244 305 359 394 449 499
                                                                                  551 597 648
Unthread                        004162 constant        entry                    internal dcl 1297 ref 824
Unthread_user                   004335 constant        entry                    internal dcl 1370 ref 421 475 823
add                             000077 constant        entry                    external dcl 195
connection_list_manager_        000062 constant        entry                    external dcl 51
delete_offset                   000430 constant        entry                    external dcl 279
hpriv_delete_all_for_user       000635 constant        entry                    external dcl 351
hpriv_delete_name               000450 constant        entry                    external dcl 287
hpriv_delete_offset             000475 constant        entry                    external dcl 296
hpriv_get_name                  001423 constant        entry                    external dcl 543
hpriv_get_next                  001263 constant        entry                    external dcl 495
hpriv_get_next_owner            001731 constant        entry                    external dcl 639
hpriv_get_next_user             001561 constant        entry                    external dcl 589
init                            002062 constant        entry                    external dcl 687
priv_change_user                000735 constant        entry                    external dcl 390
priv_delete_all_for_user        000615 constant        entry                    external dcl 343
priv_delete_name                000360 constant        entry                    external dcl 262
priv_delete_offset              000407 constant        entry                    external dcl 271
priv_get_name                   001375 constant        entry                    external dcl 535
priv_get_next_owner             001675 constant        entry                    external dcl 629
priv_get_next_user              001535 constant        entry                    external dcl 581
priv_remove_user                001126 constant        entry                    external dcl 445

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5320        5414    4441        5330
Length      6116    4441        74         465     656           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
connection_list_manager_            412 external procedure  is an external procedure.  
on unit on line 200                  64 on unit               
on unit on line 305                  64 on unit               
on unit on line 359                  64 on unit               
on unit on line 394                  64 on unit               
on unit on line 449                  64 on unit               
on unit on line 499                  64 on unit               
on unit on line 551                  64 on unit               
on unit on line 597                  64 on unit               
on unit on line 648                  64 on unit               
on unit on line 696                  68 on unit               
Delete_one_entry                        internal procedure  shares stack frame of external procedure connection_list_manager_.  
Fill_info                               internal procedure  shares stack frame of external procedure connection_list_manager_.  
Find                                    internal procedure  shares stack frame of external procedure connection_list_manager_.  
Get_next_for_user                       internal procedure  shares stack frame of external procedure connection_list_manager_.  
Lock                                    internal procedure  shares stack frame of internal procedure Setup.  
Unlock                               72 internal procedure  is called by several nonquick procedures.  
Setup                               118 internal procedure  enables or reverts conditions.  
on unit on line 1090                 68 on unit               
Thread                                  internal procedure  shares stack frame of external procedure connection_list_manager_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 static_connection_list_ptr  connection_list_manager_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
Setup                    000106 code                        Lock
Unlock                   000100 code                        Unlock
connection_list_manager_ 000100 act_dir_name                connection_list_manager_
                         000152 code                        connection_list_manager_
                         000153 connection_handle           connection_list_manager_
                         000154 connection_name             connection_list_manager_
                         000164 force_acct_entry            connection_list_manager_
                         000204 force_disc_entry            connection_list_manager_
                         000224 hash_index                  connection_list_manager_
                         000225 hash_size                   connection_list_manager_
                         000226 hpriv_entry                 connection_list_manager_
                         000230 initializer_handle          connection_list_manager_
                         000232 locked                      connection_list_manager_
                         000233 my_process_id               connection_list_manager_
                         000234 name_entry                  connection_list_manager_
                         000236 next_act_ptr                connection_list_manager_
                         000240 next_offset                 connection_list_manager_
                         000241 offset                      connection_list_manager_
                         000242 orig_level                  connection_list_manager_
                         000243 owner_process_id            connection_list_manager_
                         000244 priv_entry                  connection_list_manager_
                         000245 service_type                connection_list_manager_
                         000256 sys_high_auth               connection_list_manager_
                         000260 temp_lock_word              connection_list_manager_
                         000262 term_event_channel          connection_list_manager_
                         000264 this_act_ptr                connection_list_manager_
                         000266 this_ring                   connection_list_manager_
                         000267 usage_type                  connection_list_manager_
                         000270 user_group_id               connection_list_manager_
                         000300 user_process_id             connection_list_manager_
                         000301 words_used                  connection_list_manager_
                         000302 auto_area_info              connection_list_manager_
                         000326 auto_create_branch_info     connection_list_manager_
                         000360 active_connection_list_ptr  connection_list_manager_
                         000362 actl_hash_table_size        connection_list_manager_
                         000363 connection_area_size        connection_list_manager_
                         000364 act_ptr                     connection_list_manager_
                         000366 active_connection_info_ptr  connection_list_manager_
                         000370 area_infop                  connection_list_manager_
                         000430 hash_value                  Find
                         000431 connection_name             Find
                         000441 offset                      Find
                         000442 found                       Find
                         000452 found                       Get_next_for_user
                         000453 my_process_id               Get_next_for_user
                         000454 next_offset                 Get_next_for_user
                         000455 owner_process_id            Get_next_for_user
                         000456 user_process_id             Get_next_for_user
                         000466 found                       Thread
                         000467 hash_value                  Thread
                         000470 last_hash                   Thread
                         000472 next_act_ptr                Thread
                         000474 next_hash                   Thread
                         000475 next_offset                 Thread
                         000476 offset                      Thread
                         000500 prev_act_ptr                Thread
                         000502 prev_hash                   Thread
                         000503 prev_offset                 Thread
                         000504 temp_act_ptr                Thread

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          tra_ext_1
mdfx1               enable_op           ext_entry           ext_entry_desc      int_entry           op_alloc_
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
convert_authorization_$from_string                          cu_$level_get                 cu_$level_set
define_area_                  get_group_id_                 get_process_id_               get_ring_
hash_index_                   hcs_$create_branch_           initiate_file_                set_lock_$lock
set_lock_$unlock              terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$already_initialized                            error_table_$invalid_lock_reset
error_table_$lock_wait_time_exceeded                        error_table_$locked_by_other_process
error_table_$locked_by_this_process                         error_table_$namedup          error_table_$noentry
error_table_$not_initialized  error_table_$not_privileged   error_table_$unimplemented_version
sys_info$max_seg_size         sys_info$system_control_dir




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     51 000061        53 000067       195 000070       199 000140       200 000142       201 000164       203 000170
    204 000172       205 000200       206 000205       207 000212       208 000214       212 000221       213 000223
    216 000225       218 000230       219 000233       224 000234       226 000253       228 000256       229 000261
    230 000264       231 000267       232 000302       233 000320       234 000323       235 000326       236 000330
    238 000332       240 000333       242 000334       244 000342       247 000351       248 000353       262 000354
    265 000376       266 000400       267 000401       268 000402       271 000403       274 000421       275 000423
    276 000424       277 000425       279 000426       282 000442       283 000443       284 000444       285 000445
    287 000446       290 000466       291 000467       292 000471       293 000472       296 000473       299 000507
    300 000510       301 000512       303 000513       305 000515       306 000537       308 000543       310 000552
    312 000554       313 000562       314 000564       316 000566       318 000571       319 000574       321 000575
    323 000576       325 000602       327 000607       328 000610       343 000611       346 000627       347 000631
    348 000632       351 000633       354 000647       355 000650       357 000652       359 000654       360 000676
    362 000702       364 000706       367 000712       368 000716       369 000720       372 000722       374 000724
    375 000725       379 000726       390 000727       393 000761       394 000763       395 001005       397 001011
    398 001015       399 001021       400 001027       401 001031       402 001033       403 001037       405 001046
    406 001053       408 001057       409 001062       412 001063       414 001066       415 001071       418 001072
    421 001075       424 001100       425 001103       428 001104       429 001110       430 001112       431 001115
    432 001117       434 001121       445 001122       448 001142       449 001144       450 001166       452 001172
    453 001176       454 001202       456 001211       457 001216       459 001222       460 001225       463 001226
    465 001231       466 001234       468 001235       471 001240       472 001243       475 001244       477 001245
    478 001250       479 001253       481 001255       483 001256       495 001257       498 001277       499 001301
    500 001323       502 001327       503 001333       504 001336       505 001337       507 001341       511 001350
    512 001354       515 001357       519 001364       520 001367       523 001370       535 001371       538 001415
    539 001417       540 001420       543 001421       546 001443       547 001444       549 001446       551 001450
    552 001472       554 001476       555 001504       557 001507       558 001511       560 001513       562 001516
    563 001521       566 001522       567 001526       568 001527       581 001530       584 001553       585 001555
    586 001556       589 001557       592 001577       593 001600       595 001602       597 001604       598 001626
    600 001632       601 001636       602 001642       604 001645       606 001653       608 001657       609 001661
    611 001667       613 001672       629 001673       632 001711       633 001713       634 001714       636 001723
    639 001724       642 001745       643 001746       644 001750       646 001755       648 001757       649 002001
    651 002005       652 002011       654 002014       657 002022       658 002026       661 002031       663 002037
    664 002042       668 002043       670 002045       672 002053       673 002056       687 002057       690 002072
    691 002100       693 002102       694 002112       696 002121       698 002145       700 002154       702 002212
    705 002216       706 002220       707 002221       708 002225       709 002237       710 002242       711 002243
    716 002244       717 002271       719 002273       721 002275       723 002276       725 002325       729 002365
    731 002374       733 002376       734 002413       736 002421       741 002431       746 002433       747 002437
    748 002440       749 002441       750 002443       751 002446       753 002462       754 002463       755 002475
    757 002500       759 002532       762 002536       764 002540       765 002542       766 002543       767 002551
    768 002554       769 002567       771 002573       774 002604       777 002613       778 002615       796 002616
    799 002617       801 002624       803 002632       804 002635       807 002636       809 002641       812 002646
    813 002651       815 002652       817 002653       819 002656       820 002661       823 002662       824 002663
    826 002664       827 002670       829 002673       832 002706       843 002707       846 002710       848 002715
    849 002720       852 002721       853 002725       854 002730       855 002732       856 002735       857 002737
    858 002742       859 002744       860 002750       861 002753       862 002756       863 002760       864 002762
    865 002766       867 002770       882 002771       897 002773       898 002777       901 003027       903 003035
    905 003037       907 003040       908 003044       909 003047       911 003056       913 003061       916 003062
    917 003067       918 003071       919 003072       934 003073       946 003075       947 003100       948 003104
    950 003113       952 003117       953 003123       955 003130       957 003133       960 003134       961 003135
    963 003146       964 003151       966 003156       968 003162       974 003170       976 003176       977 003201
    979 003206       980 003211       982 003212       994 003216       997 003220       998 003224      1000 003230
   1002 003234      1003 003237      1005 003242      1007 003246      1011 003250      1013 003256      1014 003261
   1016 003267      1018 003273      1032 003277      1039 003301      1041 003316      1043 003323      1044 003325
   1048 003332      1049 003334      1055 003341      1060 003347      1062 003365      1080 003366      1083 003374
   1084 003402      1085 003403      1086 003405      1088 003411      1090 003417      1092 003444      1093 003464
   1094 003523      1095 003533      1099 003541      1101 003545      1102 003555      1106 003563      1107 003567
   1108 003603      1110 003610      1111 003612      1113 003615      1116 003624      1118 003631      1133 003632
   1148 003633      1149 003635      1151 003646      1152 003651      1153 003654      1156 003655      1158 003660
   1159 003663      1160 003666      1161 003670      1163 003673      1164 003677      1167 003702      1171 003704
   1172 003705      1174 003714      1175 003720      1177 003726      1179 003732      1181 003734      1182 003737
   1183 003743      1185 003744      1188 003747      1192 003751      1193 003754      1195 003756      1197 003760
   1198 003763      1201 003764      1202 003767      1203 003772      1206 003774      1207 003775      1219 003776
   1222 003777      1223 004001      1227 004011      1228 004012      1230 004022      1231 004025      1233 004033
   1235 004037      1239 004043      1241 004047      1242 004053      1244 004057      1245 004062      1248 004063
   1252 004073      1253 004074      1256 004104      1257 004107      1259 004115      1261 004121      1268 004125
   1272 004135      1273 004141      1276 004144      1280 004153      1281 004155      1284 004161      1297 004162
   1302 004163      1304 004167      1305 004172      1308 004174      1310 004177      1311 004202      1316 004204
   1318 004207      1319 004212      1322 004214      1324 004220      1325 004223      1326 004225      1329 004226
   1333 004256      1336 004264      1340 004271      1342 004275      1343 004300      1344 004302      1346 004303
   1348 004307      1350 004313      1351 004316      1352 004320      1354 004321      1356 004325      1358 004331
   1359 004334      1370 004335      1373 004336      1375 004342      1376 004345      1379 004347      1381 004352
   1382 004355      1385 004357      1387 004363


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
