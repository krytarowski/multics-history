	COMPILATION LISTING OF SEGMENT azm_display_fdump_events
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/08/88  1126.2 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(86-06-09,Farley), approve(87-07-09,MCR7746),
       17*     audit(87-07-20,Fawcett), install(87-07-28,MR12.1-1049):
       18*     Corrected bug in setting exp_seg_name.
       19*  2) change(86-10-08,Farley), approve(87-07-09,MCR7746),
       20*     audit(87-07-20,Fawcett), install(87-07-28,MR12.1-1049):
       21*     Added quentry.used to diskq_data for flagging incomplete "(I)" I/O.
       22*  3) change(87-01-06,Parisek), approve(87-07-09,MCR7746),
       23*     audit(87-07-20,Fawcett), install(87-07-28,MR12.1-1049):
       24*     Add functionality of matching and excluding strings on event strings.
       25*  4) change(87-01-09,Parisek), approve(87-07-09,MCR7746),
       26*     audit(87-07-20,Fawcett), install(87-07-28,MR12.1-1049):
       27*     Check processor_tag value before referencing it in a function.  Previously
       28*     too large a value would cause an OOB error.
       29*  5) change(87-01-21,Parisek), approve(87-07-09,MCR7746),
       30*     audit(87-07-20,Fawcett), install(87-07-28,MR12.1-1049):
       31*     Check validity of disk device name and device number before assigning an
       32*     auto variable to them, then displaying such.
       33*  6) change(87-07-09,Parisek), approve(87-07-09,MCR7746),
       34*     audit(87-07-20,Fawcett), install(87-07-28,MR12.1-1049):
       35*     Changed declaration of proc_exists_mask from bit(36) to bit(8) to prevent
       36*     stringsize conditions.
       37*  7) change(88-04-04,Parisek), approve(88-04-21,MCR7877),
       38*     audit(88-07-08,Farley), install(88-07-12,MR12.2-1055):
       39*     Changed disk_queue event processing to only process events of interest
       40*     when processing by time.
       41*                                                   END HISTORY COMMENTS */
       42 
       43 
       44 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend */
       45 azm_display_fdump_events:
       46      proc (P_sci_ptr, P_amu_info_ptr, num_events, delta_time, long_report, match_info_ptr, code);
       47 
       48 
       49 
       50 /* Routine to scan an FDUMP for interesting time-stamped events,
       51*   sort these events by time (reverse order), and print them.
       52*
       53*   The following events are considered as interesting:
       54*
       55*   Machine Conditions (from BCE, prds, pds, mc_trace_buf)
       56*
       57*   Traffic Control State Change Time
       58*
       59*   Syserr Messages (from both syserr_data and syserr_log)
       60*
       61*   Fim Frames in any stack
       62*
       63*   Connects by device
       64*
       65*   Disk queues (long report only)
       66*
       67*   An array of pointers to FDUMP is passed as a parameter--this array
       68*   is in order by FDUMP component (0, 1, 2, ...).  Also passed
       69*   are pointers to copies of certain segments from the FDUMP (these
       70*   are not within the FDUMP itself, but copied from it.
       71*
       72*   Modification history:
       73*   81-03-15, J. Bongiovanni: Initial coding
       74*   81-04-21, Rich Coppola: Added expanded path name/rel offset
       75*   81-07-10, J. Bongiovanni; Added connects, by device
       76*   82-01-04, J. Bongiovanni: Added disk queues, mc_trace_buf
       77*   82-05-22, Rich Coppola: Modified for new ASTE
       78*   82-07-30, J. Bongiovanni: Modified for new time format in disk Q
       79*   82-11-13, Rich Coppola: Modified for analyze_multics
       80*   83-02-10, Rich Fawcett: Modified to reduce space used.
       81*   83-01-24, B. Braun: Modified for P. Farley's change to check that all eight 
       82*      words of SCU data are zero before assuming no scu data was stored. 
       83*   84-01-19, BLB: Fix so events request -last and -time work (phx16720)
       84*   84-10-01, R. A. Fawcett: Added fault_tag_1 handler to walk_stack
       85*   84-10-02, R. A. Fawcett: Changed to use the info from the "new" disk_dim. 
       86*   84-10-08, R. A. Fawcett: Changed walk_stack to use valid_fim_ptr
       87*   84-12-14, W. Olin Sibert: Converted syserr stuff for new format logs
       88**/
       89 
       90 /* Parameter */
       91 
       92 dcl  P_amu_info_ptr ptr;
       93 dcl  P_sci_ptr ptr;
       94 dcl  num_events fixed bin;				/* number of events to print			*/
       95 dcl  delta_time fixed bin (71);			/* interval of interest in microseconds		*/
       96 dcl  long_report bit (1);				/* ON=>long report format, OFF=>1 line/event	*/
       97 dcl  good_match bit (1);				/* used when calling mh_or_ex proc */
       98 dcl  match_info_ptr ptr;				/* ptr to match/exclude strings */
       99 dcl  temp_string char (128) varying;			/* temp for checking matches or exclusions */
      100 dcl  temp_time char (32) varying;			/* temp time stamp for matches or exclusions */
      101 dcl  tsl fixed bin (21);				/* length of temp_string */
      102 dcl  code fixed bin (35);
      103 dcl  new_disk_dim_sw bit (1);
      104 
      105      
      106 
      107 
      108 /* Automatic */
      109 
      110 dcl  apt_array_p ptr;
      111 dcl  apt_inx fixed bin;
      112 dcl  apt_proc_found bit (1);
      113 dcl  bmp ptr init (null);
      114 dcl  bound_interceptors_ptr ptr;
      115 dcl  cur_date_time char (17);
      116 dcl  definitions_ptr ptr;
      117 dcl  diskq_datap ptr;
      118 dcl  dom fixed bin;
      119 dcl  DOM pic "99";
      120 dcl  dow fixed bin;
      121 dcl  dump_ptrs ptr;
      122 dcl  dump_seginx fixed bin;
      123 dcl  dump_segno fixed bin;
      124 dcl  earliest_recorded_time fixed bin (71);
      125 dcl  earliest_time fixed bin (71);
      126 dcl  event_inx fixed bin;
      127 dcl  events_by_time bit(1);
      128 dcl  events_printed fixed bin;
      129 dcl  eventsp ptr;
      130 dcl  first_print bit (1);
      131 dcl  1 hard_ptr_space like hardcore_cur;
      132 dcl  hr fixed bin;
      133 dcl  HR pic "z9";
      134 dcl  1 interesting_segs (N_INTERESTING_SEGS) aligned,
      135        2 segno fixed bin (18) init ((N_INTERESTING_SEGS) - 1),
      136        2 process_this_seg bit (1) init ((N_INTERESTING_SEGS) (1)"1"b),
      137        2 handler entry  (bit (1) aligned) variable init (
      138                 process_prds, process_pds, process_tc_data,
      139                 process_syserr_data, setup_from_scs, process_inzr_stk0,
      140                 process_iom_data, process_disk_queue, copy_pvt,
      141                 process_mc_trace_buf);
      142      
      143 
      144 
      145 dcl  last_date_time char (17);
      146 dcl  last_sec fixed bin;
      147 dcl  last_segno fixed bin;
      148 dcl  micsec fixed bin (71);
      149 dcl  MICSEC pic "999999";
      150 dcl  minute fixed bin;
      151 dcl  MIN pic "99";
      152 dcl  mon fixed bin;
      153 dcl  MON pic "99";
      154 dcl  max_events fixed bin;
      155 dcl  nametbl_ptr ptr;
      156 dcl  prds_processor bit (8) unal;
      157 dcl  proc_no fixed bin;
      158 dcl  process_number fixed bin;
      159 dcl  range fixed bin (18);
      160 dcl sci_ptr ptr;
      161 dcl  sec fixed bin;
      162 dcl  SEC pic "99";
      163 dcl  seg_found bit (1);
      164 dcl  seginx fixed bin;
      165 dcl  segp ptr;
      166 dcl  sortp ptr;
      167 dcl  sortinx fixed bin;
      168 dcl  sortinx1 fixed bin;
      169 dcl  sortinxt fixed bin;
      170 dcl  stack_found bit (1);
      171 dcl  stack_inx fixed bin;
      172 dcl  stack_segs (0:7) fixed bin;
      173 dcl  temp_alloc_p ptr;
      174 dcl  temp_seg_data_p ptr;
      175 dcl 1 translation_space like translation;
      176 dcl  tsegp ptr;
      177 dcl  words_copied fixed bin (18);
      178 dcl  yr fixed bin;
      179 dcl  YR pic "99";
      180 
      181 
      182 /* Static */
      183 
      184 dcl  CPU_TAG char (8) init ("abcdefgh") int static options (constant);
      185 dcl  IOM_TAG char (4) init ("ABCD") int static options (constant);
      186 dcl  MYNAME char (24) init ("azm_display_fdump_events") int static options (constant);
      187 dcl  N_INTERESTING_SEGS fixed bin init (10) int static options (constant);
      188 dcl  MC_TRACE_BUF fixed bin init (10) int static options (constant);
      189 dcl  interesting_segname (N_INTERESTING_SEGS) char (32) int static options (constant) init (
      190                 "prds", "pds", "tc_data", "syserr_data", "scs", "inzr_stk0",
      191                 "iom_data", "disk_seg", "pvt", ""); 
      192 
      193 						/* Index of mc_trace_buf */
      194 
      195 
      196 /* Based */
      197 
      198 dcl  1 temp_seg_data aligned based (temp_seg_data_p),	/* info on temp segs allocated 		*/
      199        2 n_temp_segs fixed bin,			/* number temp segs allocated this way		*/
      200        2 temp_segp (0 refer (n_temp_segs)) ptr;		/* array of pointers to allocated temp segs	*/
      201 
      202 dcl  1 time_stamped_events aligned based (eventsp),	/* events of interest from FDUMP		*/
      203        2 n_events fixed bin,				/* number of events found			*/
      204        2 events (0 refer (n_events)),
      205          3 time_stamp fixed bin (71),			/* time of event				*/
      206          3 delete_on_duplicate_time bit (1),		/* ON => delete this event if time the same as another */
      207          3 deleted bit (1),				/* ON => this event deleted */
      208          3 event_struct_ptr ptr,			/* structure of interest to event		*/
      209          3 event_display entry (char (*), ptr, fixed bin) variable,
      210 						/* routine to print event	*/
      211          3 process_number fixed bin,			/* process number in FDUMP			*/
      212          3 apte_offset bit (18),			/* APTE offset or "0"b */
      213          3 added_info char (40) unal;			/* other data to be printed			*/
      214 
      215 dcl  1 apt_array aligned based (apt_array_p),		/* used to translate apte offset to proc number */
      216        2 n_aptes fixed bin,
      217        2 apt_desc (0 refer (n_aptes)) aligned,
      218          3 offset bit (18) unal,			/* offset of apte in tc_data			*/
      219          3 procn fixed bin (17) unal;			/* process number in FDUMP			*/
      220 
      221 
      222 
      223 dcl  1 diskq_data aligned based (diskq_datap),		/* extract of disk queue/devtab info */
      224        2 pvtx fixed bin,
      225        2 io_type fixed bin,
      226        2 coreadd fixed bin (25),
      227        2 sector fixed bin,
      228        2 cylinder fixed bin,
      229        2 used bit (1);
      230 
      231 dcl  1 indirect_sort_array aligned based (sortp),		/* used for sorting time_stamped_events		*/
      232        2 sort_index (262144) fixed bin (18);
      233 
      234 
      235 
      236 /* Entry */
      237 
      238 dcl  amu_$definition_offset entry (ptr, char (*), char (*), fixed bin (35)) returns (fixed bin (18));
      239 dcl  amu_$do_translation entry (ptr, fixed bin, ptr, fixed bin (18), fixed bin (18), fixed bin (35));
      240 dcl  amu_$error_for_caller entry () options (variable);
      241 dcl  amu_$fdump_mpt_temp_change_idx entry (ptr, fixed bin);
      242 dcl  amu_$fdump_mpt_revert_idx entry (ptr);
      243 dcl  amu_$get_name entry (ptr, ptr) returns (char (*));
      244 dcl  amu_$hardcore_info_set_cur_ptrs entry (ptr, ptr);
      245 dcl  amu_$return_val_per_process entry (ptr, fixed bin) returns (bit (1));
      246 dcl  amu_$slt_search_seg_ptr entry (ptr, ptr, char (32), ptr, fixed bin (35));
      247 dcl  match_strings_$free entry (ptr);
      248 dcl  match_strings_$test entry (ptr, char (*)) returns (bit (1) aligned);
      249 dcl  ssu_$get_temp_segment	entry (ptr, char(*), ptr);
      250 dcl  ssu_$print_message 	entry() options(variable);
      251 dcl  ssu_$release_temp_segment	entry (ptr, ptr);
      252 dcl  (
      253      ioa_,
      254      ioa_$nnl,
      255      ioa_$rsnnl
      256      ) entry options (variable);
      257 dcl  sys_info$max_seg_size fixed bin (35) ext static;
      258 dcl  decode_clock_value_$date_time
      259 	entry (fixed bin (71), fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin (71),
      260 	fixed bin, char (3), fixed bin (35));
      261 
      262 /* Condition */
      263 
      264 dcl  cleanup condition;
      265 
      266 
      267 /* Builtin */
      268 
      269 dcl  (addr,
      270       addrel,
      271       baseno,
      272       baseptr,
      273       bin,
      274       clock,
      275       convert,
      276       currentsize,
      277       divide,
      278       fixed,
      279       hbound,
      280       index,
      281       lbound,
      282       length,
      283       min,
      284       mod,
      285       null,
      286       pointer,
      287       ptr,
      288       rel,
      289       reverse,
      290       rtrim,
      291       size,
      292       string,
      293       substr,
      294       unspec)			builtin;
      295 
      296 
      297 /* Setup pointers and cleanup handler */
      298 
      299 	amu_info_ptr = P_amu_info_ptr;
      300 	sci_ptr = P_sci_ptr;
      301 	hardcore_cur_ptr = addr (hard_ptr_space);
      302 	call amu_$hardcore_info_set_cur_ptrs (amu_info_ptr, hardcore_cur_ptr);
      303 	dump_ptrs, dumpptr = fdump_info.dump_seg_ptr (0);
      304 	sltp = hardcore_cur.sltp;
      305 	nametbl_ptr = hardcore_cur.sltntp;
      306 	definitions_ptr = hardcore_cur.defp;
      307 	temp_alloc_p = null ();
      308 	temp_seg_data_p = null ();
      309 	eventsp, tsegp, pvtp = null ();
      310 	         temp_string, temp_time = "";
      311 	tsl = 0;
      312 	good_match = ""b;
      313 	on cleanup call cleanit;
      314 
      315 	/* Initialize temporary segment allocation */
      316 
      317 	call ssu_$get_temp_segment (sci_ptr, MYNAME, temp_seg_data_p);
      318 
      319 	eventsp = allocate_temp_seg ();
      320 	tsegp = allocate_temp_seg ();
      321 
      322 
      323 						/* Find segment numbers of all interesting segments */
      324 
      325 	do seginx = 1 to N_INTERESTING_SEGS;
      326 	     if interesting_segname (seginx) ^= "" then do;
      327 		call amu_$slt_search_seg_ptr (hardcore_cur.sltp, hardcore_cur.sltntp, interesting_segname (seginx), segp,
      328 		     code);
      329 		if code = 0
      330 		then interesting_segs.segno (seginx) = bin (baseno (segp), 18);
      331 		else call amu_$error_for_caller ((null ()), code, MYNAME, "^a not found in dump", interesting_segname (seginx));
      332 		end;
      333 	end;
      334 
      335 
      336 	prds_processor = "11111111"b;
      337 	call amu_$slt_search_seg_ptr (hardcore_cur.sltp, hardcore_cur.sltntp, "bound_interceptors",
      338 	     bound_interceptors_ptr, code);
      339 	if code ^= 0 then bound_interceptors_ptr = null ();
      340 	new_disk_dim_sw = "1"b;
      341 	stack_segs (*) = -1;
      342 
      343 	proc_no = 0;
      344 	last_segno = -1;
      345 	earliest_recorded_time = clock ();		/* dump must be earlier than this		*/
      346 
      347           if num_events = -1 then 
      348 	     events_by_time = "1"b;
      349 
      350 	else events_by_time = "0"b;
      351 
      352 	apt_array_p = allocate_temp_seg ();
      353 	apt_array.n_aptes = 0;
      354 
      355 /* First event is return to BCE								*/
      356 
      357           if events_by_time then do;
      358 	   if delta_time = 0 then earliest_time = 0;
      359 	   else earliest_time = dump.mctime - delta_time;
      360 	   end;
      361 
      362 	n_events = 0;
      363 
      364 	call add_an_event (bin (dump.mctime, 71), addr (dump.scu (0)), print_dump_mc, "RTB Machine Conditions", "0"b,
      365 	     "0"b);
      366 
      367 /* Go through segments dumped, building events in event array					*/
      368 	do proc_no = 0 to hbound (fdump_process_table.array, 1);
      369 	     call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, proc_no);
      370 	     stack_segs (*) = -1;
      371 /*	     do stack_inx = 0 to hbound (stack_segs, 1);
      372*		stack_segs (stack_inx) = -1;
      373*	     end;*/
      374 
      375 	     interesting_segs (MC_TRACE_BUF).process_this_seg = "0"b;
      376 						/* mc tracing is per-process */
      377 	     fp_table_ptr = addr (fdump_process_table.array (proc_no));
      378 	     do dump_seginx = fp_table.first_seg to fp_table.last_seg;
      379 		dump_segno = bin (dump.segs (dump_seginx).segno, 18);
      380 		if dump_segno <= slt.last_sup_seg	/* only hardcore segs are interesting		*/
      381 		     | interesting_segs (MC_TRACE_BUF).process_this_seg
      382 						/* unless tracing machine conditions */
      383 		then do;
      384 		     seg_found = "0"b;
      385 		     seginx = 1;
      386 		     do while (^seg_found & seginx <= N_INTERESTING_SEGS);
      387 			if dump_segno = interesting_segs.segno (seginx)
      388 			then seg_found = "1"b;
      389 			else seginx = seginx + 1;
      390 		     end;
      391 		     if seg_found & interesting_segs (seginx).process_this_seg then do;
      392 			call interesting_segs (seginx).handler  (interesting_segs (seginx).process_this_seg);
      393 			if code ^= 0 then do;
      394 COPY_ERR:
      395 			     call amu_$error_for_caller ((null ()), code, MYNAME, "seg index ^d", dump_seginx);
      396 			     call cleanit;
      397 			     return;
      398 			     end;
      399 			end;
      400 		     end;
      401 		stack_found = "0"b;
      402 		do stack_inx = 0 repeat stack_inx + 1 while (^stack_found & stack_inx <= hbound (stack_segs, 1));
      403 		     if stack_segs (stack_inx) = dump_segno then do;
      404 
      405 			call process_user_stack (stack_inx, dump_segno);
      406 			if code ^= 0 then goto COPY_ERR;
      407 
      408 			stack_found = "1"b;
      409 			end;
      410 		end;
      411 	     end;
      412 	end;
      413 
      414 /* Now extract messages from the syserr log which are within the interval of
      415*   interest; we must process each of the syserr log segments in turn. */
      416 
      417 	call process_syserr_log (earliest_recorded_time, tsegp, "syserr_log_laurel");
      418 	call process_syserr_log (earliest_recorded_time, tsegp, "syserr_log_hardy");
      419 
      420 
      421 
      422 
      423 /* Sort event array by time stamp (tag sort)							*/
      424 
      425 	sortp = allocate_temp_seg ();
      426 	do sortinx = 1 to n_events;
      427 	     sort_index (sortinx) = sortinx;
      428 	end;
      429 
      430 	do sortinx = 1 to n_events - 1;
      431 	     do sortinx1 = sortinx + 1 to n_events;
      432 		if events (sort_index (sortinx1)).time_stamp > events (sort_index (sortinx)).time_stamp then do;
      433 		     sortinxt = sort_index (sortinx1);	/* swap pointers 				*/
      434 		     sort_index (sortinx1) = sort_index (sortinx);
      435 		     sort_index (sortinx) = sortinxt;
      436 		     end;
      437 		else if events (sort_index (sortinx1)).time_stamp = events (sort_index (sortinx)).time_stamp then do;
      438 		     if events (sort_index (sortinx1)).delete_on_duplicate_time
      439 		     then events (sort_index (sortinx1)).deleted = "1"b;
      440 		     if events (sort_index (sortinx)).delete_on_duplicate_time
      441 		     then events (sort_index (sortinx)).deleted = "1"b;
      442 		     end;
      443 	     end;
      444 	end;
      445 
      446 
      447 
      448 /* Print the sorted events by calling the print routine for each,
      449*   passing the decoded time value								*/
      450 
      451 	first_print = "1"b;
      452 	last_date_time = " ";
      453 	last_sec = -1;
      454           events_printed = 1;
      455           if events_by_time then max_events = n_events;
      456 	else max_events = min (n_events, num_events);
      457 
      458 	do event_inx = 1 to n_events while (events_printed <= max_events);
      459 	     if ^events (sort_index (event_inx)).deleted then do;
      460 	          events_printed = events_printed + 1;
      461 		call decode_clock_value_$date_time (events (sort_index (event_inx)).time_stamp, mon, dom, yr, hr,
      462 		     minute, sec, micsec, dow, "", code);
      463 		if code = 0 then do;
      464 		     MON = mon;
      465 		     DOM = dom;
      466 		     YR = mod (yr, 100);
      467 		     HR = hr;
      468 		     MIN = minute;
      469 		     SEC = sec;
      470 		     MICSEC = micsec;
      471 		     cur_date_time = MON || "/" || DOM || "/" || YR || " " || HR || ":" || MIN;
      472 		     if cur_date_time ^= last_date_time
      473 		     then call ioa_ ("Events from ^a:^a.^a", cur_date_time, SEC, MICSEC);
      474 		     if first_print then do;
      475 			call ioa_ ("^4xTime^2xCPU Proc Event^27xCircumstances^/");
      476 			first_print = "0"b;
      477 			end;
      478 		     last_date_time = cur_date_time;
      479 		     if last_sec = sec
      480 		     then call ioa_$rsnnl ("  .^6a  ", temp_time, tsl, MICSEC);
      481 		     else call ioa_$rsnnl ("^2a.^6a  ", temp_time, tsl, SEC, MICSEC);
      482 		     last_sec = sec;
      483 		     if match_info_ptr = null () then call ioa_$nnl (temp_time);
      484 /* Find FDUMP Process Number if necessary */
      485 
      486 		     process_number = events (sort_index (event_inx)).process_number;
      487 
      488 		     if events (sort_index (event_inx)).apte_offset ^= "0"b then do;
      489 			apt_proc_found = "0"b;
      490 			apt_inx = 1;
      491 			do while (^apt_proc_found & apt_inx <= apt_array.n_aptes);
      492 			     if events (sort_index (event_inx)).apte_offset = apt_array.apt_desc (apt_inx).offset
      493 			     then do;
      494 				apt_proc_found = "1"b;
      495 				process_number = apt_array.apt_desc (apt_inx).procn;
      496 				end;
      497 			     else apt_inx = apt_inx + 1;
      498 			end;
      499 			end;
      500 
      501 
      502 		     call events (sort_index (event_inx))
      503 			.
      504 			event_display (events (sort_index (event_inx)).added_info,
      505 			events (sort_index (event_inx)).event_struct_ptr, process_number);
      506 		     end;
      507 		end;
      508 	end;
      509 
      510 
      511 GLOBAL_RETURN:
      512 	call cleanit;
      513 RETURN:
      514 	return;
      515 
      516 
      517 
      518 /* Internal procedure to add an event to the structure if its time
      519*   is within the range of interest								*/
      520 
      521 
      522 add_an_event:
      523      proc (etime, eptr, eroutine, eadded_info, delete_duplicate, apte_offset);
      524 
      525 
      526 dcl  etime fixed bin (71);				/* time of event				*/
      527 dcl  eptr ptr;					/* pointer to event structure			*/
      528 dcl  eroutine entry (char (*), ptr, fixed bin) variable;	/* routine to print event			*/
      529 dcl  eadded_info char (*);				/* clear-text info of interest		*/
      530 dcl  delete_duplicate bit (1) aligned;			/* ON => delete this event if duplicate times */
      531 dcl  apte_offset bit (18);				/* APTE offset or "0"b */
      532 
      533 
      534 	if events_by_time then if etime < earliest_time then return;
      535 	n_events = n_events + 1;
      536 	events (n_events).time_stamp = etime;
      537 	events (n_events).event_struct_ptr = eptr;
      538 	events (n_events).event_display = eroutine;
      539 	events (n_events).added_info = eadded_info;
      540 	events (n_events).process_number = proc_no;
      541 	events (n_events).apte_offset = apte_offset;
      542 	events (n_events).deleted = "0"b;
      543 	events (n_events).delete_on_duplicate_time = delete_duplicate;
      544 
      545 	if events_by_time then if etime < earliest_recorded_time & etime ^= 0 then earliest_recorded_time = etime;
      546 
      547      end add_an_event;
      548 
      549 
      550 
      551 
      552 
      553 
      554 
      555 
      556 
      557 /* Internal Procedure to allocate an additional temporary segment,
      558*   and return a pointer to same								*/
      559 
      560 
      561 allocate_temp_seg:
      562      proc returns (ptr);
      563 
      564 	call ssu_$get_temp_segment (sci_ptr, MYNAME, temp_segp (n_temp_segs + 1));
      565 	n_temp_segs = n_temp_segs + 1;
      566 
      567 	return (temp_segp (n_temp_segs));
      568 
      569 
      570      end allocate_temp_seg;
      571 
      572 
      573 
      574 
      575 /* Internal Procedure for Cleanup								*/
      576 
      577 
      578 cleanit:
      579      proc;
      580 
      581 dcl  i fixed bin;
      582 
      583 	if temp_seg_data_p ^= null () then do;
      584 	     do i = 0 to n_temp_segs;
      585 		if temp_segp (i) ^= null then call ssu_$release_temp_segment (sci_ptr, temp_segp (i));
      586 	     end;
      587 	     call ssu_$release_temp_segment (sci_ptr, temp_seg_data_p);
      588 	     temp_seg_data_p = null ();
      589 	     end;
      590 	if sortp ^= null then call ssu_$release_temp_segment (sci_ptr, sortp);
      591 	if tsegp ^= null then call ssu_$release_temp_segment (sci_ptr, tsegp);
      592 	if match_info_ptr ^= null then call match_strings_$free (match_info_ptr);
      593 
      594      end cleanit;
      595 
      596 
      597 /* Internal Procedure to copy the PVT to a temporary segment. This
      598*   is necessary to print some of the interesting stuff about disk
      599*   queues
      600**/
      601 
      602 copy_pvt:
      603      proc (process_it);
      604 
      605 dcl  process_it bit (1) aligned;
      606 
      607 	process_it = "1"b;				/* Only copy PVT once */
      608 	if ^long_report then return;
      609           pvtp = allocate_temp_seg ();
      610           words_copied = sys_info$max_seg_size;
      611           call get_data (pvtp,dump_segno, 0, words_copied, code);
      612 
      613      end copy_pvt;
      614 
      615 
      616 
      617 /* Internal Procedure to copy a part of a segment to a temporary segment.
      618*   Additional temporary segments are allocated as necessary, and a pointer
      619*   to the copy is returned									*/
      620 
      621 
      622 copy_to_temporary:
      623      proc (dptr, dlength) returns (ptr);
      624 
      625 
      626 dcl  dptr ptr;					/* pointer to part of segment to copy	*/
      627 dcl  dlength fixed bin (18);				/* number of words to copy			*/
      628 
      629 
      630 
      631 dcl  tlength fixed bin (18);
      632 dcl  tptr ptr;
      633 dcl  based_move (tlength) fixed bin (35) aligned based;
      634 
      635 
      636 	tlength = divide (dlength + 7, 8, 18) * 8;	/* Make modulo 8				*/
      637 	if temp_alloc_p = null ()			/* first time here				*/
      638 	then temp_alloc_p = allocate_temp_seg ();
      639 	else if bin (rel (temp_alloc_p), 18) + tlength > sys_info$max_seg_size then temp_alloc_p = allocate_temp_seg ();
      640 
      641 	tptr = temp_alloc_p;
      642 	temp_alloc_p = addrel (temp_alloc_p, tlength);
      643 	tptr -> based_move = dptr -> based_move;
      644 	return (tptr);
      645 
      646 
      647      end copy_to_temporary;
      648 
      649 /* Internal procedure to get data from a  dump */
      650 get_data:
      651      proc (data_ptr, seg, word, number, ecode);
      652 
      653 
      654 dcl  ecode fixed bin (35);
      655 dcl  data_ptr ptr;
      656 dcl  index_changed bit (1) init ("0"b);
      657 dcl  seg fixed bin;
      658 dcl  (word, number) fixed bin (18);
      659 
      660 	if ^amu_$return_val_per_process (amu_info_ptr, seg) then do;
      661 	     index_changed = "1"b;
      662 	     call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, lbound (fdump_process_table.array, 1));
      663 	     end;
      664 	call amu_$do_translation (amu_info_ptr, seg, data_ptr, word, number, ecode);
      665 	if index_changed = "1"b then do;
      666 	     call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      667 	     index_changed = "0"b;
      668 	     end;
      669      end get_data;
      670 
      671 
      672 
      673 get_trans:
      674            proc (segno) returns (ptr);
      675 dcl segno fixed bin;
      676 dcl t_ptr ptr;
      677 dcl amu_$translate_get entry (ptr, fixed bin, ptr, fixed bin(35));
      678 dcl amu_$fdump_translate_get_translation entry (ptr, ptr, ptr, fixed bin(35));
      679 
      680 	 call amu_$translate_get (amu_info_ptr,segno,t_ptr,code);
      681 	 if t_ptr ^= null () then return (t_ptr);
      682 	 else do;
      683 	      t_ptr = addr(translation_space);
      684 	      call amu_$fdump_translate_get_translation 
      685 		 (amu_info_ptr,baseptr(segno),t_ptr,code);
      686 	      if code ^= 0 then return (null ());
      687 	      else return (t_ptr);
      688 	 end;
      689       end get_trans;
      690       
      691 		 
      692 
      693 /* Internal Procedure to print apte								*/
      694 
      695 
      696 print_apte:
      697      proc (added_info, structp, process_n);
      698 
      699 
      700 dcl  added_info char (*);
      701 dcl  structp ptr;
      702 dcl  process_n fixed bin;
      703 dcl  state_name char (10);
      704 dcl  process_na pic "zz9";
      705 dcl  real_apte_offset fixed bin (18);
      706 
      707 dcl  STATE_NAMES (0:6) char (10) int static options (constant)
      708 	init ("Empty", "Running", "Ready", "Waiting", "Blocked", "Stopped", "ptlocking");
      709 dcl  WAITING fixed bin init (3) int static options (constant);
      710 
      711 	aptep = structp;
      712 	if bin (apte.state, 18) > hbound (STATE_NAMES, 1)
      713 	then state_name = "Invalid";
      714 	else state_name = STATE_NAMES (bin (apte.state, 18));
      715 
      716 	process_na = process_n;
      717 	real_apte_offset =
      718 	     fixed (rel(aptep),18) - fixed (rel(hardcore_cur.tc_datap),18);
      719 	
      720 
      721 /* Print the interesting information from the apte */
      722 
      723 	call ioa_$rsnnl ("^1a^2x^3a  APTE at ^6o changed to ^a^[ for ^w^;^s^]",
      724 	     temp_string, tsl, 
      725 	     substr (CPU_TAG, bin (apte.pr_tag, 3) + 1, 1),
      726 	     process_na, real_apte_offset, state_name,
      727 	     (bin (apte.state, 18) = WAITING), apte.wait_event);
      728 	
      729 	if match_info_ptr = null () then call ioa_ ("^a", temp_string);
      730 	else call mh_or_ex (""b);
      731 
      732      end print_apte;
      733 
      734 /* Internal Procedure to print Connect to Device information					*/
      735 
      736 
      737 print_device_data:
      738      proc (added_info, structp, process_n);
      739 
      740 dcl  added_info char (*);
      741 dcl  structp ptr;
      742 dcl  process_n fixed bin;				/* not meaningful for this data		*/
      743 
      744 dcl  1 iom_dev_data aligned like per_device based (structp);
      745 
      746 	call ioa_$rsnnl ("^8xConnect to ^1a ^2d", temp_string, tsl, substr (IOM_TAG, iom_dev_data.iom, 1), iom_dev_data.channel);
      747 	if match_info_ptr = null () then call ioa_ ("^a", temp_string);
      748 	else call mh_or_ex (""b);
      749 
      750      end print_device_data;
      751 
      752 
      753 /* Internam Procedure to print Disk Queue information */
      754 
      755 print_disk_queue:
      756      proc (info, dq_data_ptr, process_char);
      757 
      758 dcl  info char (*);
      759 dcl  dq_data_ptr ptr;
      760 dcl  process_char char (*);
      761 dcl  type_io fixed bin;
      762 dcl  dev_num char (2);
      763 dcl  diskadd fixed bin;
      764 dcl  fsx fixed bin;
      765 dcl  p99 pic "99";
      766 dcl  sect_sw bit (1);
      767 dcl  subsys_name char (4);
      768 dcl  DISK_IO_TYPE (0:6) char (7) static options(constant) init
      769 	        ("Page RD","Page WT","Vtoc RD",
      770 	         "Vtoc WT","Test","Boot RD","Boot WT");
      771 
      772 	diskq_datap = dq_data_ptr;
      773 	type_io = diskq_data.io_type;
      774 	if pvtp = null () then do;			/* PVT not in dump - not to worry */
      775 	     subsys_name = "dskX";
      776 	     dev_num = "NN";
      777 	     sect_sw = "1"b;			/* Can't translate to record */
      778 	     diskadd = diskq_data.sector;
      779 	     end;
      780 	else do;
      781 	     pvt_arrayp = addr (pvt.array);
      782 	     pvtep = addr (pvt_array (diskq_data.pvtx));
      783 	     if index (pvte.devname, "dsk") = 0 then subsys_name = "????";
      784 	     else subsys_name = pvte.devname;
      785 	     if pvte.logical_area_number < -99 | pvte.logical_area_number > 99 then pvte.logical_area_number = 0;
      786 	     dev_num = convert (p99, pvte.logical_area_number);
      787 	     sect_sw = sector_map (type_io);
      788 	     if sect_sw
      789 	     then diskadd = diskq_data.sector;
      790 	     else do;
      791 		fsx = pvte.device_type;
      792 		diskadd =
      793 		     diskq_data.cylinder * rec_per_cyl (fsx)
      794 		     + divide (diskq_data.sector - diskq_data.cylinder * sect_per_cyl (fsx), sect_per_rec (fsx), 17);
      795 		end;
      796 	     end;
      797 
      798 
      799 	call ioa_$rsnnl ("^8xDisk Queue: ^a_^a ^a ^[Sec^;Rec^] ^8o Mem ^8o^[ (I)^;^]",
      800 	   temp_string, tsl,  
      801 	   subsys_name, dev_num, DISK_IO_TYPE(type_io),
      802 	     sect_sw, diskadd, diskq_data.coreadd, diskq_data.used);
      803 	if match_info_ptr = null () then call ioa_ ("^a", temp_string);
      804 	else call mh_or_ex (""b);
      805 
      806      end print_disk_queue;
      807 
      808 
      809 
      810 /* Internal Procedure to print BCE machine conditions						*/
      811 
      812 
      813 print_dump_mc:
      814      proc (added_info, structp, process_n);
      815 
      816 
      817 dcl  added_info char (*);
      818 dcl  structp ptr;
      819 dcl  process_n fixed bin;				/* process number meaningless here		*/
      820 
      821 
      822 	call print_scu_data (structp, added_info, "   ");
      823 
      824 
      825      end print_dump_mc;
      826 
      827 
      828 
      829 /* Internal Procedure to print machine conditions 						*/
      830 
      831 print_mc:
      832      proc (added_info, structp, process_n);
      833 
      834 
      835 dcl  added_info char (*);
      836 dcl  structp ptr;
      837 dcl  process_n fixed bin;
      838 
      839 dcl  process_na pic "zz9";
      840 dcl  process_num char (3);
      841 
      842 	process_na = process_n;
      843 	process_num = process_na;
      844 	call print_scu_data (structp, added_info, process_num);
      845 
      846 
      847      end print_mc;
      848 
      849 /* Internal procedure to extract parameters from syserr_log event for printing				*/
      850 
      851 print_syserr_log:
      852      proc (added_info, structp, process_n);
      853 
      854 dcl  added_info char (*);
      855 dcl  structp ptr;
      856 dcl  process_n fixed bin;
      857 
      858 
      859 /* Really, this should be using format_log_message_ and doing things
      860*   right, but this should do for the moment. The conversion should be
      861*   finished, however, when and if syserr_data is converted to use new
      862*   format messages. */
      863 
      864 	log_message_ptr = structp;
      865 	call print_syserr_message (log_message.sequence, 
      866 	     (log_message.severity), "syserr_log", 
      867 	     length (log_message.text), addr (log_message.text));
      868 
      869 	return;
      870      end print_syserr_log;
      871 
      872 
      873 /* Internal procedure to print a syserr message							*/
      874 
      875 print_syserr_message:
      876      proc (sequence, severity, log_name, textl, textp);
      877 
      878 
      879 dcl  sequence fixed bin (35);				/* syserr sequence number			*/
      880 dcl  severity fixed bin;				/* syserr severity code			*/
      881 dcl  log_name char (*);				/* name of log where the message came from	*/
      882 dcl  textl fixed bin (21);				/* length of message is chars			*/
      883 dcl  textp ptr;					/* pointer to text of message			*/
      884 
      885 
      886 dcl  linel fixed bin (21);
      887 dcl  textl_done fixed bin (21);
      888 dcl  textl_total fixed bin (21);
      889 dcl  trim_eol fixed bin (21);
      890 
      891 
      892 dcl  1 message based (textp),
      893        2 pad char (textl_done),
      894        2 this_line char (linel),
      895        2 rest char (textl_total - linel - textl_done);
      896 
      897 
      898 dcl  LINE_MAX_LENGTH fixed bin init (59) int static options (constant);
      899 dcl  TEXT_MAX_LENGTH fixed bin init (200) int static options (constant);
      900 
      901 
      902 	call ioa_ ("^8xSyserr #^d (^a), severity ^d", sequence, log_name, severity);
      903 
      904 	textl_total = min (TEXT_MAX_LENGTH, textl);
      905 	textl_done = 0;
      906 	linel = textl_total;
      907 	if linel <= 0 then return;
      908 	do while (linel > 0);
      909 	     if linel > LINE_MAX_LENGTH then do;
      910 		linel = LINE_MAX_LENGTH;
      911 		trim_eol = index (substr (reverse (message.this_line), 1, 20), " ");
      912 		linel = linel - trim_eol;
      913 		end;
      914 	     call ioa_ ("^21x^a", message.this_line);
      915 	     textl_done = textl_done + linel;
      916 	     linel = textl_total - textl_done;
      917 	end;
      918 
      919 
      920      end print_syserr_message;
      921 
      922 /* Internal procedure to prepare a syserr message from the wired log for printing			*/
      923 
      924 print_wired_syserr:
      925      proc (added_info, structp, process_n);
      926 
      927 dcl  added_info char (*);
      928 dcl  structp ptr;
      929 dcl  process_n fixed bin;
      930 
      931 dcl  sequence fixed bin (35);
      932 dcl  severity fixed bin;
      933 dcl  textl fixed bin (21);
      934 dcl  textp ptr;
      935 
      936 
      937 	wmess_ptr = structp;
      938 	sequence = wmess.seq_num;
      939 	severity = wmess.code;
      940 	textl = wmess.text_len;
      941 	textp = addr (wmess.text);
      942 	call print_syserr_message (sequence, severity, "syserr_data", textl, textp);
      943 
      944      end print_wired_syserr;
      945 
      946 
      947 
      948 /* Internal procedure to print SCU data from machine conditions					*/
      949 
      950 print_scu_data:
      951      proc (scu_data_ptr, info, process_char);
      952 
      953 dcl  scu_data_ptr ptr;				/* pointer to scu data in machine conditions	*/
      954 dcl  info char (*);					/* additional information to print		*/
      955 dcl  process_char char (*);				/* process number printably			*/
      956 
      957 
      958 
      959 dcl  cpu_alph char (1);
      960 dcl  fault_no fixed bin;
      961 dcl  fault_sub_type bit (36);
      962 dcl  hardware_interrupt_level fixed bin;
      963 dcl  hardware_interrupt_no pic "99";
      964 dcl  interrupt_level pic "9";
      965 dcl  interrupt_no fixed bin;
      966 dcl  iom_number char (1);
      967 dcl  line1 char (80) varying;
      968 dcl  ptsr bit (1);
      969 dcl  exp_seg_name char (256) varying;
      970 dcl  seg_valid bit (1);
      971 dcl  sub_type_inx fixed bin;
      972 
      973 dcl  SR_IOA_STRING char (50) int static options (constant) init ("^21x^3a ^o|^o^[, ring ^1o^;^s^[ (^a)^;^s^]^]");
      974 dcl  FAULT_TYPES (0:31) char (4) int static options (constant)
      975 	init ("SDF", "STR", "MME", "FT1", "TRO", "CMD", "DRL", "LUF", "CON", "PAR", "IPR", "ONC", "SUF", "OFL", "DIV",
      976 	"EXF", "DF0", "DF1", "DF2", "DF3", "ACV", "MME2", "MME3", "MME4", "FT2", "FT3", "INV", "INV", "INV", "INV",
      977 	"INV", "TRB");
      978 dcl  FAULT_TSR_VALID bit (32) init ("01110111011101101111111111000001"b) int static options (constant);
      979 
      980 dcl  FAULT_MASK_INDEX (0:31) fixed bin int static options (constant) init (0, 1, (7) 0, 2, 3, 4, (8) 0, 5, (11) 0);
      981 dcl  FAULT_MASKS (5) bit (21) aligned int static options (constant) init ("4140000"b3,
      982 						/* Store					*/
      983 	"0000030"b3,				/* Parity					*/
      984 	"3600000"b3,				/* Illegal Procedure			*/
      985 	"0000006"b3,				/* Operation Not Complete			*/
      986 	"7777740"b3);				/* Access Violation				*/
      987 dcl  FAULT_SUB_TYPES (5, 21) char (5) int static options (constant) init ("ISN", (4) (3)" ", "NEA", "OOB", (14) (3)" ",
      988 						/* Store					*/
      989 	(16) (3)" ", "PARU", "PARL", (3) (3)" ",	/* Parity					*/
      990 	"   ", "IOC", "IA+IM", "ISP", "IPR", (16) (3)" ", /* Illegal Procedure			*/
      991 	(18) (3)" ", "ONC1", "ONC2", "   ",		/* Operation Not Complete			*/
      992 	"IRO", "OEB", "E-OFF", "ORB", "R-OFF", "OWB",	/* Access Violation				*/
      993 	"W-OFF", "NO GA", "OCB", "OCALL", "BOC", "INRET", /* Access Violation				*/
      994 	"CRT", "RALR", "AM-ER", "OOSB", (5) (1)" ");	/* Access Violation				*/
      995 
      996 
      997 	exp_seg_name = "";
      998 
      999 	scup = scu_data_ptr;
     1000 	cpu_alph = substr (CPU_TAG, bin (scu.cpu_no, 3) + 1, 1);
     1001 	if scu.fi_flag then do;			/* Fault					*/
     1002 	     fault_no = bin (scu.fi_num, 17);
     1003 	     line1 = "Fault:  " || FAULT_TYPES (fault_no);
     1004 	     ptsr = substr (FAULT_TSR_VALID, fault_no + 1, 1);
     1005 	     if FAULT_MASK_INDEX (fault_no) ^= 0 then do; /* subtype of fault				*/
     1006 		fault_sub_type = unspec (scu.fd) & FAULT_MASKS (FAULT_MASK_INDEX (fault_no));
     1007 		sub_type_inx = index (fault_sub_type, "1"b);
     1008 		if sub_type_inx ^= 0
     1009 		then line1 = line1 || " (" || rtrim (FAULT_SUB_TYPES (FAULT_MASK_INDEX (fault_no), sub_type_inx))
     1010 			|| ")";
     1011 		end;
     1012 	     end;
     1013 	else do;					/* Interrupt				*/
     1014 	     ptsr = "0"b;
     1015 	     interrupt_no = bin (scu.fi_num, 5);
     1016 	     hardware_interrupt_level = divide (interrupt_no, 4, 17);
     1017 	     if hardware_interrupt_level = 0 | hardware_interrupt_level = 6 then do;
     1018 		hardware_interrupt_no = interrupt_no;
     1019 		line1 = "Interrupt: Number " || hardware_interrupt_no;
     1020 		end;
     1021 	     else do;
     1022 		interrupt_level = hardware_interrupt_level + mod (hardware_interrupt_level + 1, 2);
     1023 		iom_number = substr (IOM_TAG, mod (interrupt_no, 4) + 1, 1);
     1024 		line1 = "Interrupt: IOM " || iom_number || ", Level " || interrupt_level;
     1025 		end;
     1026 	     end;
     1027 
     1028 	call ioa_$rsnnl ("^1a^2x^3a^2x^32a^a", temp_string, tsl, cpu_alph, process_char, line1, info);
     1029 	if match_info_ptr = null () then call ioa_ ("^a", temp_string);
     1030 	else call mh_or_ex (""b);
     1031 
     1032 	if long_report then do;
     1033 	     seg_valid = "0"b;
     1034 	     exp_seg_name =
     1035 		     amu_$get_name (amu_info_ptr, pointer (baseptr (bin (scu.ppr.psr, 15)), bin (scu.ilc, 18)));
     1036 	     if index (exp_seg_name, "CANNOT") = 0 then seg_valid = "1"b;
     1037 	     call ioa_$rsnnl (SR_IOA_STRING, temp_string, tsl, "by ",
     1038 		bin (scu.ppr.psr, 15), bin (scu.ilc, 18), scu.ppr.prr, scu.ppr.prr,
     1039 		seg_valid, exp_seg_name);
     1040 	     if match_info_ptr = null () then call ioa_ ("^a", temp_string);
     1041 	     else call mh_or_ex ("1"b);
     1042 
     1043 	     if ptsr then do;			/* print TSR/CA if valid			*/
     1044 
     1045 		seg_valid = "0"b;
     1046 		exp_seg_name =
     1047 			amu_$get_name (amu_info_ptr, pointer (baseptr (bin (scu.tpr.tsr, 15)), bin (scu.ca, 18)));
     1048 		if index (exp_seg_name, "CANNOT") = 0 then seg_valid = "1"b;
     1049 		call ioa_$rsnnl (SR_IOA_STRING, temp_string, tsl, "ref", bin (scu.tpr.tsr, 15), bin (scu.ca, 18), scu.tpr.trr, scu.tpr.trr,
     1050 		     seg_valid, exp_seg_name);
     1051 		if match_info_ptr = null () then call ioa_ ("^a", temp_string);
     1052 		else call mh_or_ex ("1"b);
     1053 		end;
     1054 	     end;
     1055 
     1056      end print_scu_data;
     1057 
     1058 /* Internal Procedure to scan disk_seg and extract all queue entries */
     1059 
     1060 process_disk_queue:
     1061      proc (process_it);
     1062 
     1063 dcl  disk_seg_ptr ptr;
     1064 dcl  process_it bit (1) aligned;
     1065 
     1066 dcl  qx fixed bin;
     1067 dcl  queue_time fixed bin (71);
     1068 dcl  1 diskq_temp aligned like diskq_data;
     1069           if ^new_disk_dim_sw then return;
     1070 	process_it = "0"b;
     1071 	if ^long_report then return;
     1072           words_copied = sys_info$max_seg_size;
     1073           call get_data (tsegp, dump_segno, 0, words_copied, code);
     1074 	if code ^= 0 then return;
     1075 	disk_seg_ptr = tsegp;
     1076 	disksp = disk_seg_ptr;
     1077 	if disk_data.array(1).mbz ^= "0"b then do;
     1078 	   new_disk_dim_sw = "0"b;
     1079 	   return;
     1080 	   end;
     1081 	do qx = 1 to disk_data.free_q_size;
     1082 	   qp = addr (disk_data.free_q_entries (qx));
     1083 	   if quentry.time ^= 0 then if
     1084 	        (^events_by_time | (events_by_time & quentry.time >= earliest_time)) then do;
     1085 	      diskq_temp.pvtx = quentry.pvtx;
     1086 	      diskq_temp.io_type = quentry.type;
     1087 	      diskq_temp.coreadd = bin (quentry.coreadd, 25);
     1088 	      diskq_temp.sector = bin (quentry.sector, 21);
     1089 	      diskq_temp.cylinder = quentry.cylinder;
     1090 	      diskq_temp.used = quentry.used;
     1091 	      queue_time =  quentry.time;
     1092 	      call add_an_event (queue_time, copy_to_temporary (addr (diskq_temp), size (diskq_temp)),
     1093 	         print_disk_queue, "Disk Queue", "0"b, "0"b);
     1094 	      end;
     1095 	   end;
     1096 
     1097 	end process_disk_queue;
     1098 
     1099 
     1100 
     1101 /* Internal Procedure to scan a per-process machine condition trace buffer
     1102*   for machine conditions */
     1103 
     1104 process_mc_trace_buf:
     1105      proc (process_it);
     1106 
     1107 dcl  mctbp ptr;
     1108 dcl  process_it bit (1) aligned;
     1109 
     1110 dcl  len fixed bin (21);
     1111 dcl  mcptr ptr;
     1112 dcl  mcx fixed bin;
     1113 dcl  mc_seg_offset char (30);
     1114 dcl  mct_scu_ptr ptr;
     1115      
     1116           words_copied = sys_info$max_seg_size;
     1117           call get_data (tsegp, dump_segno, 0, words_copied, code);
     1118 	if code ^= 0 then return;
     1119 	mctbp = tsegp;
     1120 
     1121 	process_it = "0"b;
     1122 	bp = mctbp;
     1123 
     1124 	do mcx = 1 to mc_trace_buf.mc_cnt;
     1125 	     mcptr = addr (mc_trace_buf.mach_cond (mcx));
     1126 	     if addr (mcptr -> mc.scu (0)) -> scu.ppr.psr ^= "0"b then do;
     1127 		call ioa_$rsnnl ("mc_trace_buf (^o|^o)", mc_seg_offset, len, dump_segno, bin (rel (mcptr)));
     1128 		mct_scu_ptr = copy_to_temporary
     1129 		     (addr(mcptr -> mc.scu), size (scu));
     1130 		call add_an_event (bin (mcptr -> mc.fault_time, 54),
     1131 		     mct_scu_ptr, print_mc,
     1132 		     mc_seg_offset, "1"b, "0"b);
     1133 		end;
     1134 	end;
     1135 
     1136      end process_mc_trace_buf;
     1137 
     1138 
     1139 
     1140 /* Internal procedure to setup call to scan inzr_stk0						*/
     1141 process_inzr_stk0:
     1142      proc (process_it);
     1143 
     1144 dcl  process_it bit (1) aligned;			/* flag to process segment again		*/
     1145 
     1146 dcl  code fixed bin (35);
     1147 dcl  segp ptr;
     1148 
     1149 	process_it = "0"b;				/* only come here once			*/
     1150 	call amu_$slt_search_seg_ptr (hardcore_cur.sltp, hardcore_cur.sltntp, "inzr_stk0", segp, code);
     1151 	if code ^= 0 then return;
     1152 	call walk_stack (bin (baseno (segp)), "inzr_stk0");
     1153 
     1154      end process_inzr_stk0;
     1155 
     1156 
     1157 /* Internal Procedure to scan iom_data for events of interest					*/
     1158 
     1159 process_iom_data:
     1160      proc  (process_it);
     1161 
     1162 dcl  iom_data_p ptr;
     1163 dcl  process_it bit (1) aligned;
     1164 
     1165 dcl  dev_no fixed bin;
     1166 dcl  per_device_p ptr;
     1167 
     1168           words_copied = sys_info$max_seg_size;
     1169           call get_data (tsegp, dump_segno, 0, words_copied, code);
     1170 	if code ^= 0 then return;
     1171 	iom_data_p = tsegp;
     1172 	
     1173 
     1174 	process_it = "0"b;				/* only come here once			*/
     1175 	iom_data_ptr = iom_data_p;
     1176 	if iom_data.n_devices > 0
     1177 	then do dev_no = 1 to iom_data.n_devices;
     1178 	     per_device_p = copy_to_temporary (addr (iom_data.per_device (dev_no)), size (per_device));
     1179 	     call add_an_event (iom_data.per_device (dev_no).connect_time, per_device_p, print_device_data,
     1180 		"per_device", "0"b, "0"b);
     1181 	end;
     1182 
     1183 
     1184      end process_iom_data;
     1185 
     1186 
     1187 
     1188 
     1189 /* Internal Procedure to scan the PDS for events of interest					*/
     1190 
     1191 process_pds:
     1192      proc (process_it);
     1193 
     1194 
     1195 dcl  pdsp ptr;					/* pointer to copied-out pds			*/
     1196 dcl  process_it bit (1) aligned;			/* flag to process this seg again		*/
     1197 
     1198 
     1199 
     1200 dcl  aptp ptr;
     1201 dcl  bpp ptr;
     1202 dcl  mcptr ptr;
     1203 dcl  mcp_scu_ptr ptr;
     1204 dcl  names_inx fixed bin;
     1205 dcl  pds_stacks_inx fixed bin;
     1206 dcl  pds_stacks_ptr ptr;
     1207 
     1208 
     1209 dcl  pds_names (3) char (32) int static options (constant) init ("page_fault_data", "fim_data", "signal_data");
     1210 
     1211 dcl  based_flag fixed bin (35) based;
     1212 dcl  based_ptr ptr aligned based;
     1213 dcl  based_ptr_packed ptr unaligned based;
     1214 dcl  pds_stacks (0:7) ptr aligned based (pds_stacks_ptr);
     1215 
     1216           words_copied = sys_info$max_seg_size;
     1217           call get_data (tsegp, dump_segno, 0, words_copied, code);
     1218 	if code ^= 0 then return;
     1219 	pdsp = tsegp;
     1220 	aptp = ptr (pdsp, amu_$definition_offset (amu_info_ptr, "pds", "apt_ptr", code));
     1221 	if code ^= 0 then do;
     1222 	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find pds$apt_ptr in dump.");
     1223 	     end;
     1224 
     1225 	if aptp = null () then return;
     1226 	if rel (aptp -> based_ptr) = "0"b then return;
     1227 
     1228 	apt_array.n_aptes = apt_array.n_aptes + 1;
     1229 	apt_array.apt_desc (n_aptes).offset = rel (aptp -> based_ptr);
     1230 	apt_array.apt_desc (n_aptes).procn = proc_no;
     1231 
     1232 
     1233 	do names_inx = 1 to hbound (pds_names, 1);
     1234 	     call validate_mc
     1235 		(pdsp, "pds", pds_names (names_inx),mcptr,mcp_scu_ptr);
     1236 	     if mcptr ^= null ()
     1237 	     then do;					/* machine condtions exist			*/
     1238 		call add_an_event (bin (mcptr -> mc.fault_time, 54),
     1239 		     mcp_scu_ptr, print_mc,
     1240 		     "pds$" || rtrim (pds_names (names_inx)), "0"b, "0"b);
     1241 		 end;
     1242 	end;
     1243 
     1244 /* Extract stack segment numbers from the pds							*/
     1245 
     1246 	pds_stacks_ptr = ptr (pdsp, amu_$definition_offset (amu_info_ptr, "pds", "stacks", code));
     1247 	if code ^= 0 then do;
     1248 	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find pds$stacks in dump.");
     1249 	     end;
     1250 	if fixed(rel(pds_stacks_ptr),18) >= words_copied then return;
     1251 	if pds_stacks_ptr = null () then return;
     1252 	do pds_stacks_inx = 0 to hbound (pds_stacks, 1);
     1253 	     if pds_stacks (pds_stacks_inx) ^= null ()
     1254 	     then stack_segs (pds_stacks_inx) = bin (baseno (pds_stacks (pds_stacks_inx)), 17);
     1255 	     else stack_segs (pds_stacks_inx) = -1;
     1256 	end;
     1257 
     1258 /* Check whether this process is tracing machine conditions */
     1259 
     1260 	bpp = ptr (pdsp, amu_$definition_offset (amu_info_ptr, "pds", "mc_trace_sw", code));
     1261 	if code ^= 0 then do;
     1262 	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find pds$mc_trace_sw in dump.");
     1263 	     end;
     1264 
     1265 	if bpp = null () then return;
     1266 	if bpp -> based_flag = 0 then return;
     1267 	bpp = ptr (pdsp, amu_$definition_offset (amu_info_ptr, "pds", "mc_trace_buf", code));
     1268 	if code ^= 0 then do;
     1269 	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find pds$mc_trace_buf in dump.");
     1270 	     end;
     1271 	if bpp = null () then return;
     1272 	interesting_segs (MC_TRACE_BUF).process_this_seg = "1"b;
     1273 	interesting_segs (MC_TRACE_BUF).segno = bin (baseno (bpp -> based_ptr_packed), 18);
     1274 
     1275 
     1276      end process_pds;
     1277 
     1278 
     1279 /* Internal procedure to scan prds for interesting events						*/
     1280 
     1281 process_prds:
     1282      proc (process_it);
     1283 
     1284 dcl  prdsp ptr;					/* pointer to copied-out prds			*/
     1285 dcl  process_it bit (1) aligned;			/* flag to process prds again			*/
     1286 
     1287 
     1288 
     1289 dcl  mcptr ptr;
     1290 dcl  mcp_scu_ptr ptr;
     1291 dcl  names_inx fixed bin;
     1292 dcl  processor_tag fixed bin;
     1293 dcl  prtag_based fixed bin aligned based;
     1294 dcl  prtagp ptr;
     1295      
     1296 
     1297 dcl  apte_offset bit (18);
     1298 dcl  bpp ptr;
     1299 dcl  based_ptr ptr based;
     1300 dcl  prds_names (3) char (32) int static options (constant) init ("sys_trouble_data", "interrupt_data", "fim_data");
     1301 
     1302           words_copied = sys_info$max_seg_size;
     1303           call get_data (tsegp, dump_segno, 0, words_copied, code);
     1304 	if code ^= 0 then return;
     1305 	prdsp = tsegp;
     1306 	prtagp = ptr (prdsp, amu_$definition_offset (amu_info_ptr, "prds", "processor_tag", code));
     1307 	if code ^= 0 then do;
     1308 	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find prds$processor_tag in dump.");
     1309 	     end;
     1310 	if prtagp = null () then return;
     1311 	processor_tag = prtagp -> prtag_based;
     1312 	if processor_tag > 7 then goto define_bpp;
     1313 
     1314 	if ^substr (prds_processor, processor_tag + 1, 1) /* seen this prds before			*/
     1315 	then return;
     1316 	substr (prds_processor, processor_tag + 1, 1) = "0"b;
     1317 	if prds_processor = "0"b then process_it = "0"b;	/* last prds on system			*/
     1318 define_bpp:
     1319 	bpp = ptr (prdsp, amu_$definition_offset (amu_info_ptr, "prds", "apt_ptr", code));
     1320 	if code ^= 0 then do;
     1321 	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find prds$apt_ptr in dump.");
     1322 	     end;
     1323 	if bpp = null ()
     1324 	then apte_offset = "0"b;
     1325 	else apte_offset = rel (bpp -> based_ptr);
     1326 
     1327 
     1328 	do names_inx = 1 to hbound (prds_names, 1);
     1329 	     call validate_mc
     1330 		(prdsp, "prds", prds_names (names_inx),mcptr,mcp_scu_ptr);
     1331 	     if mcptr ^= null () then do;
     1332 		call add_an_event (bin (mcptr -> mc.fault_time, 54),
     1333 		     mcp_scu_ptr, print_mc,
     1334 		     "prds$" || rtrim (prds_names (names_inx)),
     1335 		     (prds_names (names_inx) ^= "sys_trouble_data"),
     1336 		     apte_offset);
     1337 		end;
     1338 	end;
     1339 
     1340 
     1341      end process_prds;
     1342 
     1343 /* Internal procedure to extract messages from the wired syserr buffer				*/
     1344 
     1345 process_syserr_data:
     1346      proc (process_it);
     1347 
     1348 dcl  syserr_data_ptr ptr;				/* pointer to copy of syserr_data		*/
     1349 dcl  process_it bit (1) aligned;			/* flag to process this seg again		*/
     1350 
     1351 dcl  wlog_inx fixed bin;
     1352 dcl  wp ptr;
     1353 dcl  wtime fixed bin (71);
     1354           words_copied = sys_info$max_seg_size;
     1355           call get_data (tsegp, dump_segno, 0, words_copied, code);
     1356 	if code ^= 0 then return;
     1357 	syserr_data_ptr = tsegp;
     1358 	
     1359 
     1360 	process_it = "0"b;				/* only come here once			*/
     1361 
     1362 	wlog_ptr = ptr (syserr_data_ptr, amu_$definition_offset (amu_info_ptr, "syserr_data", "wired_log_area", code));
     1363 	if code ^= 0 then do;
     1364 	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find syserr_data$wired_log_area in dump.");
     1365 	     end;
     1366 
     1367 	if wlog_ptr = null () then return;
     1368 	wmess_ptr = addr (wlog.buffer);
     1369 
     1370 	if wlog.head.count < 1 then return;		/* no messages in buffer			*/
     1371 
     1372 	do wlog_inx = 1 to wlog.head.count;
     1373 	     wp = copy_to_temporary (wmess_ptr, divide (length (unspec (wmess)), 36, 18));
     1374 	     wtime = wmess.time;
     1375 	     call add_an_event (wtime, wp, print_wired_syserr, "syserr_data", "0"b, "0"b);
     1376 	     wmess_ptr = addrel (wmess_ptr, divide (length (unspec (wmess)), 36, 18));
     1377 	end;
     1378 
     1379 
     1380      end process_syserr_data;
     1381 
     1382 /* Internal procedure to scan syserr log for messages within interval of interest			*/
     1383 
     1384 process_syserr_log:
     1385      proc (low_time, temp_ptr, log_name);
     1386 
     1387 
     1388 dcl  low_time fixed bin (71);				/* earliest time of interest			*/
     1389 dcl  temp_ptr ptr;					/* temporary segment we can use		*/
     1390 dcl  log_name char (32);				/* name of syserr log segment (Laurel or Hardy)   */
     1391 
     1392 dcl  code fixed bin (35);
     1393 dcl  slog_p ptr;
     1394 dcl  slog_no fixed bin;
     1395 dcl  last_offset fixed bin (18);
     1396 dcl  first_time bit (1) aligned;
     1397 dcl  temp_message_ptr pointer;
     1398 
     1399 dcl  log_segment_$last_message_info entry (ptr, fixed bin(35), fixed bin(18), fixed bin(35));
     1400 dcl  log_position_$next_message entry (ptr, ptr, bit(1) aligned);
     1401 
     1402 /* Find syserr_log in the dump								*/
     1403 
     1404 	call amu_$slt_search_seg_ptr (hardcore_cur.sltp, hardcore_cur.sltntp, log_name, slog_p, code);
     1405 	if code ^= 0 then do;
     1406 SLOG_ERROR:
     1407 	     call amu_$error_for_caller ((null ()), code, MYNAME,
     1408 		"Error encountered processing ^a", log_name);
     1409 	     return;
     1410 	     end;
     1411 
     1412 	slog_no = bin (baseno (slog_p), 18);
     1413 
     1414 /* Copy the log_segment header */
     1415 
     1416 	range = size (log_segment_header);
     1417 	call get_data (temp_ptr, slog_no, 0, range, code);
     1418 
     1419 	if code ^= 0 | range = 0 then goto SLOG_ERROR;
     1420 
     1421 /* Find out how much was actually used in this segment, and copy out
     1422*   as much of the segment as that accounts for */
     1423 
     1424 	call log_segment_$last_message_info (temp_ptr, (0), last_offset, code);
     1425 	if (code ^= 0) then goto SLOG_ERROR;
     1426 
     1427 	range = last_offset;
     1428 	call get_data (temp_ptr, slog_no, 0, range, code);
     1429 
     1430 	if code ^= 0 | range = 0 then goto SLOG_ERROR;
     1431 
     1432 /* Romp through, picking out events within the interval of
     1433*   interest--i.e., times less than earliest one found elsewhere					*/
     1434 
     1435 	log_message_ptr = null ();
     1436 	log_segment_ptr = temp_ptr;
     1437 	first_time = "1"b;
     1438 
     1439 	do while (first_time | (log_message_ptr ^= null ()));
     1440 	     first_time = "0"b;
     1441 	     call log_position_$next_message (log_segment_ptr, log_message_ptr, ("0"b));
     1442 
     1443 /* If there was another message available, see if it's in the desired
     1444*   time range, and add it to the list.  NOTE: This used to check to see 
     1445*   whether the message came after the time of the dump, but that seemed
     1446*   like a pretty silly thing to be checking, since if there ARE any 
     1447*   "later" messages, we certainly would want to see them. */
     1448 
     1449 	     if (log_message_ptr ^= null ()) then
     1450 		if (log_message.time >= low_time) then do;
     1451 		     temp_message_ptr = copy_to_temporary (log_message_ptr, currentsize (log_message));
     1452 		     call add_an_event ((log_message.time), 
     1453 			temp_message_ptr, print_syserr_log,
     1454 			"syserr_log", "0"b, "0"b);
     1455 		     end;				/* of case of interesting message */
     1456 	     end;					/* of loop through log segment */
     1457 
     1458 	return;
     1459 
     1460      end process_syserr_log;
     1461 
     1462 
     1463 /* Internal procedure to scan tc_data for interesting events					*/
     1464 process_tc_data:
     1465      proc (process_it);
     1466 
     1467 dcl  process_it bit (1) aligned;
     1468 dcl  aptx fixed bin;
     1469 dcl  bp ptr;
     1470 dcl  num_aptes fixed bin;
     1471 dcl  size_of_apte fixed bin;
     1472 dcl  tp ptr;
     1473 dcl  tp_base fixed bin (35);
     1474 dcl  real_apte bit (18);
     1475 dcl  fixed_apte fixed bin (35);
     1476 dcl  EMPTY fixed bin init (0) int static options (constant);
     1477 dcl  based_fixed fixed bin (35) aligned based;
     1478 
     1479 	process_it = "0"b;				/* only process tc_data once			*/
     1480 
     1481 /* amu_$hardcore_info_fdump claims that tc_data is translated contiguous */
     1482 
     1483 	tp = hardcore_cur.tc_datap;
     1484 	tp_base = fixed (rel (tp),35);
     1485 	bp = addrel (tp, amu_$definition_offset (amu_info_ptr, "tc_data", "apt_size", code));
     1486 	if code ^= 0 then do;
     1487 	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find tc_data$apt_size in dump.");
     1488 	     end;
     1489 	if bp = null () then return;
     1490 	num_aptes = bp -> based_fixed;
     1491 	if num_aptes <= 0 then return;
     1492 	bp = addrel (tp, amu_$definition_offset (amu_info_ptr, "tc_data", "apt_entry_size", code));
     1493 	if code ^= 0 then do;
     1494 	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find tc_data$apt_entry_size in dump.");
     1495 	     end;
     1496 
     1497 	if bp = null () then return;
     1498 	size_of_apte = bp -> based_fixed;
     1499 	if size_of_apte <= 0 then return;
     1500 
     1501 
     1502 	aptep = addrel (tp, amu_$definition_offset (amu_info_ptr, "tc_data", "apt", code));
     1503 	if code ^= 0 then do;
     1504 	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find tc_data$apt in dump.");
     1505 	     end;
     1506 
     1507 	if aptep = null () then return;
     1508 
     1509 	do aptx = 1 to num_aptes;
     1510 	     if bin (apte.state, 18) ^= EMPTY & apte.state_change_time ^= 0
     1511 	     then do;
     1512 		fixed_apte = fixed (rel(aptep),35) - tp_base;
     1513 		real_apte = substr(unspec(fixed_apte),19,18);
     1514 		call add_an_event
     1515 		     (apte.state_change_time, aptep, print_apte,
     1516 		     "apte", "0"b, real_apte);
     1517 	     end;
     1518 	     aptep = addrel (aptep, size_of_apte);
     1519 	end;
     1520 
     1521 
     1522      end process_tc_data;
     1523 
     1524 /* Internal procedure to set up a stack for scanning						*/
     1525 
     1526 process_user_stack:
     1527      proc (ring_no, stack_seg_no);
     1528 
     1529 dcl  ring_no fixed bin;				/* ring number of stack in process		*/
     1530 
     1531 dcl  stack_seg_no fixed bin;				/* segment number of stack in process		*/
     1532 
     1533 dcl  ring_num pic "9";
     1534 
     1535 	ring_num = ring_no;
     1536 	call walk_stack (stack_seg_no, "stack_" || ring_num);
     1537 
     1538      end process_user_stack;
     1539 
     1540 /* Internal procedure to get interesting data from scs 						*/
     1541 
     1542 setup_from_scs:
     1543      proc (process_it);
     1544 
     1545 dcl  scs_ptr ptr;					/* pointer to copy of scs			*/
     1546 dcl  process_it bit (1) aligned;			/* flag to process segment again		*/
     1547 
     1548 dcl  proc_number fixed bin;
     1549 dcl  proc_exists_mask bit (8);
     1550 dcl  scs_proc_data_ptr ptr;
     1551 
     1552 dcl  1 pdata (0:7) aligned like scs$processor_data based (scs_proc_data_ptr);
     1553           words_copied = sys_info$max_seg_size;
     1554           call get_data (tsegp, dump_segno, 0, words_copied, code);
     1555 	if code ^= 0 then return;
     1556           scs_ptr = tsegp;
     1557 
     1558 	process_it = "0"b;				/* process scs but once			*/
     1559 	proc_exists_mask = "0"b;
     1560 	scs_proc_data_ptr = ptr (scs_ptr, amu_$definition_offset (amu_info_ptr, "scs", "processor_data", code));
     1561 	if code ^= 0 then do;
     1562 	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find scs$processor_data in dump.");
     1563 	     end;
     1564 
     1565 	if scs_proc_data_ptr = null () then return;
     1566 
     1567 	do proc_number = 0 to hbound (pdata, 1);	/* find all cpus which might have been active	*/
     1568 	     if pdata (proc_number).online | pdata (proc_number).offline
     1569 	     then substr (proc_exists_mask, proc_number + 1, 1) = "1"b;
     1570 	end;
     1571 	prds_processor = prds_processor & proc_exists_mask;
     1572 
     1573 
     1574      end setup_from_scs;
     1575 
     1576 
     1577 
     1578 /* Internal procedure to check a named location for valid machine conditions.
     1579*   If machine conditions are stored, they are copied to temporary storage,
     1580*   and a pointer to the temporary storage area is returned						*/
     1581 
     1582 validate_mc:
     1583      proc (segptr, segname, mc_name,a_mc_ptr, a_scu_ptr);
     1584 
     1585 dcl a_mc_ptr ptr;
     1586 dcl a_scu_ptr ptr;
     1587 dcl  segptr ptr;					/* pointer to base of copy of segment		*/
     1588 dcl  segname char (*);				/* segment name				*/
     1589 dcl  mc_name char (*);				/* entry name where machine conditions are stored */
     1590 
     1591 dcl  mcptr ptr;
     1592 
     1593 
     1594 	mcptr = ptr (segptr, amu_$definition_offset (amu_info_ptr, segname, mc_name, code));
     1595 	if code ^= 0 then do;
     1596 	     call amu_$error_for_caller ((null ()), code, MYNAME, "Cannot find ^a$^a in dump.", segname, mc_name);
     1597 	     end;
     1598 
     1599 	if mcptr = null () then goto mc_data_not_valid;
     1600 
     1601 	if string (mcptr -> mc.scu) = "0"b then goto mc_data_not_valid;
     1602 
     1603 	a_scu_ptr =  copy_to_temporary (addr(mcptr -> mc.scu), size (scu));
     1604 	a_mc_ptr = mcptr;
     1605 	return;
     1606 mc_data_not_valid:
     1607 	a_mc_ptr = null ();
     1608 	a_scu_ptr = null ();
     1609 
     1610 	
     1611 
     1612      end validate_mc;
     1613 
     1614 /* Internal procedure to validate a stack pointer and construct a pointer
     1615*   to it.  The pointer is checked to contain the segment number of the stack,
     1616*   to point to a mod-16 location, and to be within the bounds defined by
     1617*   the stack_end_ptr.  A pointer to the frame in the copy of the stack is constructed 			*/
     1618 
     1619 validate_stack_ptr:
     1620      proc (stack_ptr, seg_num, stack_base_ptr) returns (fixed bin (18));
     1621 
     1622 dcl  stack_ptr ptr;					/* stack pointer from FDUMP			*/
     1623 dcl  seg_num fixed bin;				/* segment number of stack in FDUMP		*/
     1624 dcl  stack_base_ptr ptr;				/* pointer to copy of stack			*/
     1625 
     1626 	if baseno (stack_ptr) = "077777"b3
     1627 	then					/* if null ptr */
     1628 	     return (-1);			/* return */
     1629 
     1630 
     1631 	if addr (stack_ptr) -> its.mod then return (-1);
     1632 						/* return */
     1633 	if addr (stack_ptr) -> its.bit_offset then return (-1);
     1634 						/* return */
     1635 	if addr (stack_ptr) -> its.its_mod ^= ITS_MODIFIER then return (-1);
     1636 
     1637 	if bin (baseno (stack_ptr)) ^= seg_num
     1638 	     | bin (rel (stack_ptr)) >= bin (rel (stack_base_ptr -> stack_header.stack_end_ptr))
     1639 	     | mod (bin (rel (stack_ptr)), 16) ^= 0
     1640 	     | bin (rel (stack_ptr)) < bin (rel (stack_base_ptr -> stack_header.stack_begin_ptr))
     1641 	     | rel (stack_ptr) = "0"b
     1642 	then return (-1);
     1643 	return (fixed (rel (stack_ptr),18));
     1644 
     1645 
     1646      end validate_stack_ptr;
     1647 
     1648 
     1649 /* Internal procedure to walk a stack looking for fim-frames
     1650*   the walk is done forward, and only frames within the current segment
     1651*   are considered (there really shouldn't be any outside of it)					*/
     1652 
     1653 walk_stack:
     1654      proc (stack_seg, stack_name);
     1655 
     1656 
     1657 dcl  stack_seg fixed bin;				/* segment number of stack			*/
     1658 dcl  stack_name char (*);				/* name of stack				*/
     1659 dcl  the_hard_way bit (1);
     1660 dcl  data1 char (d1_len) based;
     1661 dcl  data2 char (d2_len) based;
     1662 dcl  data3 char (d3_len) based;
     1663 dcl  (d1_len,d2_len,d3_len) fixed bin (21);
     1664 dcl  min_length fixed bin;
     1665 dcl  fm_scup ptr;
     1666 dcl  len fixed bin (21);
     1667 dcl  loop_count fixed bin;
     1668 dcl  next_frame_mc bit (1);
     1669 dcl  seg_offset char (13);
     1670 dcl  sp_offset fixed bin (18);
     1671 dcl  stack_frame_sw bit (1);
     1672 dcl  stack_frame_save (min_length) fixed bin (36) based (sp);
     1673 dcl  stack_header_sw bit (1);
     1674 dcl  (sp_save,sb_save) ptr;
     1675 dcl (illegal_modifier,fault_tag_1) condition;
     1676      
     1677 
     1678      on illegal_modifier begin;
     1679         goto stack_err_cond;
     1680         end;
     1681 
     1682      on fault_tag_1 begin;
     1683         goto stack_err_cond;
     1684         end;
     1685           code = 0;
     1686 	stack_header_sw,stack_frame_sw,the_hard_way = "0"b;
     1687 	translation_ptr = get_trans (stack_seg);
     1688 	if translation_ptr = null () then return;
     1689 	sb = translation.part1.ptr;
     1690 	if translation.flags.two_part then do;
     1691 	     if translation.part1.lth < size(stack_header) then do;
     1692 
     1693 		allocate stack_header in (amu_area) set (sb);
     1694 
     1695 		d1_len = translation.part1.lth * 4;
     1696 		d2_len = (size(stack_header) - translation.part1.lth) * 4;
     1697 		d3_len = size(stack_header) * 4;
     1698 		sb -> data3 = translation.part1.ptr -> data1 || translation.part2.ptr -> data2;
     1699 		sp_offset = validate_stack_ptr
     1700 		     (stack_header.stack_begin_ptr, stack_seg, sb);
     1701 		the_hard_way = "1"b;
     1702 		sb_save = sb;
     1703 		stack_header_sw = "1"b;
     1704 	     end;
     1705 	end;
     1706 	if ^stack_header_sw then sp_offset = validate_stack_ptr
     1707 	     (stack_header.stack_begin_ptr, stack_seg, sb);
     1708 	if sp_offset = -1 then goto stack_done;
     1709 
     1710 	loop_count = 1000;
     1711 	next_frame_mc = "0"b;
     1712 	min_length = stack_frame_min_length + size(mc);
     1713 	if the_hard_way then goto do_the_hard_way;
     1714 	do sp_offset = sp_offset repeat validate_stack_ptr (stack_frame.next_sp, stack_seg, sb)
     1715 	     while (sp_offset ^= -1 & loop_count > 0);
     1716 	     if translation.flags.two_part then
     1717 		if (sp_offset + min_length) > translation.part1.lth then
     1718 		 goto do_the_hard_way;
     1719 	     sp = addrel (sb,sp_offset);
     1720 	     mcp = null ();
     1721 	     if next_frame_mc | valid_fim_ptr (stack_frame.return_ptr) then do;
     1722 		mcp = addrel (sp, stack_frame_min_length);
     1723 		if addr (mc.scu (0)) -> scu.ppr.psr ^= "0"b then do;
     1724 		     call ioa_$rsnnl ("^a|^o", seg_offset, len,
     1725 			stack_name, sp_offset);
     1726 		     fm_scup = copy_to_temporary (addr(mc.scu), size (scu));
     1727 		     call add_an_event (bin (mc.fault_time, 71), fm_scup,
     1728 			print_mc, seg_offset, "0"b, "0"b);
     1729 		     end;
     1730 		end;
     1731 	     next_frame_mc = "0"b;
     1732 	     if stack_frame_flags.signaller then next_frame_mc = "1"b;
     1733 	     loop_count = loop_count - 1;
     1734 	end;
     1735 	goto stack_done;
     1736 do_the_hard_way:
     1737 	if sp_offset < translation.part1.lth then do;
     1738 
     1739 	     allocate stack_frame_save in (amu_area) set (sp);
     1740 
     1741 	     d3_len = min_length * 4;
     1742 	     d1_len = (translation.part1.lth - sp_offset) * 4;
     1743 	     d2_len = d3_len - d1_len;
     1744 	     sp -> data3 = addrel(translation.part1.ptr,sp_offset) -> data1 || translation.part2.ptr -> data2;
     1745 	     stack_frame_sw = "1"b;
     1746 	     sp_save = sp;
     1747 	     goto jump_in;
     1748 	end;
     1749 	
     1750 
     1751 	do sp_offset = sp_offset repeat validate_stack_ptr (stack_frame.next_sp, stack_seg, sb)
     1752 	     while (sp_offset ^= -1 & loop_count > 0);
     1753 
     1754 	     sp = addrel (translation.part2.ptr,(sp_offset - translation.part1.lth));
     1755 jump_in:	     
     1756 	     mcp = null ();
     1757 	     if next_frame_mc | valid_fim_ptr (stack_frame.return_ptr) then do;
     1758 		mcp = addrel (sp, stack_frame_min_length);
     1759 		if addr (mc.scu (0)) -> scu.ppr.psr ^= "0"b then do;
     1760 		     call ioa_$rsnnl ("^a|^o", seg_offset, len,
     1761 			stack_name,sp_offset);
     1762 		     fm_scup = copy_to_temporary (addr(mc.scu), size (scu));
     1763 		     call add_an_event (bin (mc.fault_time, 71), fm_scup,
     1764 			print_mc, seg_offset, "0"b, "0"b);
     1765 		     end;
     1766 		end;
     1767 	     next_frame_mc = "0"b;
     1768 	     if stack_frame_flags.signaller then next_frame_mc = "1"b;
     1769 	     loop_count = loop_count - 1;
     1770 	end;
     1771 
     1772 stack_done:
     1773           revert fault_tag_1;
     1774 	revert illegal_modifier;
     1775 	if stack_frame_sw then 
     1776 	     free sp_save -> stack_frame_save in (amu_area);
     1777 	if stack_header_sw then 
     1778 	     free sb_save -> stack_header in (amu_area);
     1779 	code = 0;
     1780 	return;
     1781 stack_err_cond:
     1782 	call ssu_$print_message (sci_ptr,0,
     1783 	   "The ^a in process ^d contains invalid data.",
     1784 	   stack_name, proc_no);
     1785 	goto stack_done;
     1786      end walk_stack;
     1787 
     1788 valid_fim_ptr:
     1789   proc (t_ptr) returns (bit (1));
     1790 
     1791 dcl t_ptr ptr;
     1792 dcl its_ptr ptr;
     1793 
     1794   if bound_interceptors_ptr = null () then return ("0"b);
     1795   its_ptr = addr(t_ptr);
     1796   if its_ptr -> its.its_mod ^= ITS_MODIFIER then return ("0"b);
     1797   if its_ptr -> its.mod ^= "0"b then return ("0"b);
     1798   if its_ptr -> its.segno ^= baseno(bound_interceptors_ptr) then return ("0"b);
     1799   return ("1"b);
     1800 
     1801   end valid_fim_ptr;
     1802 
     1803 mh_or_ex:
     1804      proc (long_data);
     1805 
     1806 dcl  long_data bit (1) parameter;
     1807 
     1808      if long_data then do;
     1809 	if (good_match) then call ioa_ ("^a", temp_string);
     1810 	return;
     1811      end;
     1812      temp_string = temp_time || temp_string;
     1813 
     1814      good_match = match_strings_$test (match_info_ptr, rtrim(temp_string));
     1815      if (good_match) then call ioa_ ("^a", temp_string);
     1816      else if num_events > -1 then
     1817 	events_printed = events_printed - 1;
     1818      return;
     1819   end mh_or_ex;
     1820 
  1     1 /*	BEGIN INCLUDE FILE amu_fdump_info.incl.pl1	*/
  1     2 
  1     3 dcl 1 fdump_info aligned based (amu_info.fdump_info_ptr),
  1     4     2 version char (8),
  1     5     2 ref_count fixed bin,				/* number of initiations */
  1     6 
  1     7     2 erf_name char (32),				/* ERF name for this dump */
  1     8     2 dump_dname char (168),				/* location of the dump */
  1     9     2 dump_ename char (32),				/* ename of component zero */
  1    10     2 system_id char (8),				/* the system_id of this erf */
  1    11     2 version_id char (8),				/* the version id of this erf */
  1    12     2 dump_seg_0_uid bit (36) aligned,			/* for determining EQ-ness and gullibility checking */
  1    13 
  1    14     2 n_dump_segs fixed bin,				/* number of real segs in the dump */
  1    15     2 copy_block_ptr pointer, 			/* pointer to chain of temp segment blocks */
  1    16 
  1    17     2 dump_seg_ptr (0:31) pointer,			/* pointer and length arrays */
  1    18     2 dump_seg_lth (0:31) fixed bin (18),
  1    19 
  1    20     2 fdump_process_table_ptr pointer;			/* pointer to array describing processes */
  1    21 
  1    22 
  1    23 dcl 1 fdump_process_table aligned based (fdump_info.fdump_process_table_ptr),
  1    24     2 size fixed bin,				/* number of entries */
  1    25 
  1    26     2 array (0:alloc_fdump_process_table_size - 1 refer (fdump_process_table.size)) like fp_table;
  1    27 
  1    28 dcl 1 fp_table based (fp_table_ptr),
  1    29       2 first_seg fixed bin,
  1    30       2 last_seg fixed bin,
  1    31       2 process_info_ptr pointer unaligned,		/* pointer to process_info structure, if filled in */
  1    32       2 dmp_seg_indx fixed bin,			/* dump seg index where process can be found */
  1    33       2 dmp_seg_offset fixed bin (24),			/* offset in the segment refered to by dmp_seg_indx where process starts */
  1    34       2 cpu_name char (1),
  1    35       2 dbr fixed bin (24),				/* address portion of DBR */
  1    36       2 apte_offset fixed bin (18);
  1    37 
  1    38 dcl fp_table_ptr ptr;
  1    39 
  1    40 dcl  alloc_fdump_process_table_size fixed bin;
  1    41 
  1    42 dcl  AMU_FDUMP_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_erf1");
  1    43 dcl  AMU_FDUMP_INFO_VERSION char (8) internal static options (constant) init ("amu_erf1");
  1    44 
  1    45 /*	END INCLUDE FILE amu_fdump_info.incl.pl1	*/
     1821 
     1822 
  2     1 /*	BEGIN INCLUDE FILE amu_hardcore_info.incl.pl1	*/
  2     2 
  2     3 /* This structure contains information about the hardcore supervisor address
  2     4*   space for an address translation. */
  2     5 
  2     6 dcl 1 hardcore_info aligned based (amu_info.hardcore_info_ptr),
  2     7 
  2     8     2 pointers,					/* assorted pointers to various useful items */
  2     9       3 slt aligned,				/* SLT */
  2    10         4 fptr pointer unaligned,			/* address in foreign address space */
  2    11         4 lptr pointer unaligned,			/* location in local address space */
  2    12       3 sltnt aligned like hardcore_info.slt,		/* SLT names segment */
  2    13       3 definitions aligned like hardcore_info.slt,	/* hardcore definitions_ segment */
  2    14 
  2    15       3 sst aligned like hardcore_info.slt,		/* SST */
  2    16       3 tc_data aligned like hardcore_info.slt,		/* TC_DATA */
  2    17       3 sstnt aligned like hardcore_info.slt,		/* SSTNT (if any -- foreign_ptr = null if not) */
  2    18       3 upt aligned like hardcore_info.slt,		/* unpaged_page_tables (if any -- foreign_ptr = null if not) */
  2    19 
  2    20     2 segno,					/* segment numbers of various per-process/per-processor segs */
  2    21       3 prds fixed bin (15),				/* segno of PRDS */
  2    22       3 dseg fixed bin (15),				/* DSEG */
  2    23       3 pds fixed bin (15),				/* PDS */
  2    24       3 kst fixed bin (15),				/* KST */
  2    25       3 stack_0 fixed bin (15),			/* segno of stack_0 -- first one in stack group */
  2    26       3 unpaged_page_tables fixed bin(15),		/* segno of unpaged_page_tables if it exists */
  2    27 
  2    28     2 apt,					/* information about the APT */
  2    29       3 foreign_ptr pointer unaligned,			/* foreign and local pointers to tcm.apt */
  2    30       3 local_ptr pointer unaligned,
  2    31       3 count fixed bin,				/* number of APTEs */
  2    32       3 size fixed bin,				/* size of a single APTE */
  2    33 
  2    34     2 hcs_count fixed bin,				/* highest hardcore segno */
  2    35 
  2    36     2 pad1 fixed bin;
  2    37 
  2    38 dcl hardcore_cur_ptr ptr;
  2    39 
  2    40 dcl 1 hardcore_cur based (hardcore_cur_ptr),
  2    41     2 sltp ptr,
  2    42     2 sltntp ptr,
  2    43     2 defp ptr,
  2    44     2 sstp ptr,
  2    45     2 tc_datap ptr,
  2    46     2 sstntp ptr,
  2    47     2 uptp ptr;
  2    48 	
  2    49     
  2    50 
  2    51 
  2    52 /*	END INCLUDE FILE amu_hardcore_info.incl.pl1	*/
     1823 
     1824 
  3     1 /*	BEGIN INCLUDE FILE amu_info.incl.pl1		*/
  3     2 
  3     3 dcl 1 amu_info aligned based (amu_info_ptr),
  3     4     2 version char (8) aligned,			/* AMU_INFO_VERSION */
  3     5     2 flags aligned,
  3     6       3 early_dump bit(1) unal,
  3     7       3 pad  bit(35) unal,
  3     8     2 type fixed bin unal,				/* One of the types below */
  3     9     2 time_created fixed bin (71) aligned,		/* time created -- for debugging purposes */
  3    10     2 chain,					/* a chain of all the amu_info's which exist */
  3    11       3 prev pointer unaligned,
  3    12       3 next pointer unaligned,
  3    13 
  3    14     2 area_ptr pointer,				/* pointer to area used for allocating things */
  3    15 
  3    16     2 translation_table_ptr pointer,			/* pointer to address map -- always present */
  3    17 						/*   SEE: amu_translation.incl.pl1 */
  3    18     2 fdump_info_ptr pointer, 			
  3    19 						/* pointer to FDUMP info, present if looking at an FDUMP */
  3    20 						/*   SEE: amu_fdump_info.incl.pl1 */
  3    21 						/* old_uid_table pointer if looking at a SAVED PROC. */
  3    22 						/* See: amu_old_uid_table			*/
  3    23 	
  3    24 
  3    25     2 hardcore_info_ptr pointer,			/* pointer to hardcore information -- always present */
  3    26 						/*   SEE: amu_hardcore_info.incl.pl1 */
  3    27     2 copy_chain pointer,				/* pointer to info about segment copies */
  3    28 						/*   SEE: amu_copy_info.incl.pl1 */
  3    29     2 process_info_ptr pointer,			/* pointer to process info for this translation */
  3    30 						/*   SEE: amu_process_info.incl.pl1 */
  3    31     2 process_idx fixed bin,				/* index of process in translation-specifc process table */
  3    32 
  3    33     2 proc_idx_hold fixed bin,			/* a place to keep the index when a changing to another proc */
  3    34 
  3    35     2 error_info,					/* various info about how amu_error_ is to behave */
  3    36       3 error_flags aligned,
  3    37         4 handler_exists bit (1) unaligned,		/* set to indicate existence of an amu_error handler */
  3    38         4 in_subsystem bit (1) unaligned,		/* This amu_info belongs to an ssu_ maintained subsystem */
  3    39         4 pad bit (34) unaligned,
  3    40       3 sci_ptr pointer,				/* sci_ptr for subsystem, if in_subsystem = "1"b */
  3    41     2 definitions_info_ptr ptr;
  3    42 
  3    43 dcl  amu_area area based (amu_info.area_ptr);
  3    44 
  3    45 dcl  amu_info_ptr pointer;
  3    46 
  3    47 dcl (FDUMP_TYPE		init (1037),		/* the various legitimate types of amu_info's */
  3    48      FDUMP_PROCESS_TYPE	init (1038),
  3    49      ONLINE_TYPE		init (1039),
  3    50      ONLINE_PROCESS_TYPE	init (1040),
  3    51      NETWORK_FDUMP_TYPE	init (1041),
  3    52      NETWORK_ONLINE_TYPE	init (1042),
  3    53      SAVED_PROC_TYPE	init (1043),
  3    54      INDIRECT_TYPE		init (1044)) fixed bin internal static options (constant);
  3    55 
  3    56 dcl  AMU_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_v1");
  3    57 dcl  AMU_INFO_VERSION char (8) internal static options (constant) init ("amu_v1");
  3    58 dcl  AMU_INFO_VERSION_2 char (8) internal static options (constant) init ("amu_v2");
  3    59 
  3    60 dcl  PDIR_SUFFIX		char(4) init("pdir") int static options(constant);
  3    61 
  3    62 /*	END INCLUDE FILE amu_info.incl.pl1		*/
     1825 
     1826 
  4     1 /*	BEGIN INCLUDE FILE amu_translation.incl.pl1	*/
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(87-01-16,Parisek), approve(87-07-16,MCR7746),
  4     7*     audit(87-07-16,Fawcett), install(87-07-28,MR12.1-1049):
  4     8*     Added the "replaced" field to record whether a segment was replaced by
  4     9*     another segment via the "replace" request.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 dcl 1 translation_table aligned based (amu_info.translation_table_ptr),
  4    14     2 n_entries fixed bin,
  4    15     2 max_entries fixed bin,
  4    16 
  4    17     2 valid_array aligned,				/* one bit for each valid segno */
  4    18       3 valid (0 : 4095) bit (1) unaligned,
  4    19     2 used_array aligned,				/* one bit for each existing translation */
  4    20       3 used (0 : 4095) bit (1) unaligned,
  4    21 
  4    22     2 array (alloc_translation_table_max_entries refer (translation_table.max_entries)) like translation;
  4    23 
  4    24 dcl 1 translation aligned based (translation_ptr),	/* a single translation */
  4    25     2 segno fixed bin (18) unsigned unaligned,		/* foreign segno for this translation */
  4    26     2 flags unaligned,
  4    27       3 two_part bit (1) unaligned,			/* segment is in two pieces -- from an FDUMP */
  4    28       3 in_dump bit (1) unaligned,			/* segment is part of an FDUMP image */
  4    29       3 in_temp_seg bit (1) unaligned,			/* segment is a copy at the base of a temp segment */
  4    30       3 in_perm_seg bit (1) unaligned,			/* segment is in the file system */
  4    31       3 in_dp_dir bit (1) unaligned,
  4    32       3 replaced bit (1) unaligned,
  4    33       3 pad bit (12) unaligned,
  4    34     2 part1,					/* pointer to first (possibly only) part of segment */
  4    35       3 ptr pointer unaligned,
  4    36       3 lth fixed bin (19),
  4    37     2 part2 like translation.part1;
  4    38 
  4    39 dcl  alloc_translation_table_max_entries fixed bin;
  4    40 dcl  translation_ptr pointer;
  4    41 
  4    42 /*	END INCLUDE FILE amu_translation.incl.pl1	*/
     1827 
     1828 
  5     1 /*  BEGIN INCLUDE FILE ... apte.incl.pl1 */
  5     2 
  5     3 /* Modified 1984-11-11 by E. Swenson for IPC event channel validation. */
  5     4 
  5     5 dcl  aptep pointer;
  5     6 
  5     7 dcl 1 apte based (aptep) aligned,			/* APT entry declaration for an active (known) process */
  5     8     2 thread unaligned,				/* List thread */
  5     9       3 fp bit (18),				/* Forward pointer */
  5    10       3 bp bit (18),				/* Backward pointer */
  5    11     2 flags unaligned,				/* Flags and miscellaneous */
  5    12       3 mbz bit (1),				/* This bit must be zero (sentinel bit) */
  5    13       3 wakeup_waiting bit (1),			/* ON if process has received wakeup */
  5    14       3 stop_pending bit (1),				/* ON if process has received stop connect */
  5    15       3 pre_empted bit (1),				/* ON if process is being pre-empted by get_processor */
  5    16       3 hproc bit (1),				/* ON if process is hardcore process */
  5    17       3 loaded bit (1),				/* ON if required per-process pages are in memory and wired */
  5    18       3 eligible bit (1),				/* ON if process is eligible */
  5    19       3 idle bit (1),				/* ON if  this is an idle process */
  5    20       3 interaction bit (1),				/* ON if process has interacted recently */
  5    21       3 pre_empt_pending bit (1),			/* ON if process has received pre-empt connect */
  5    22       3 default_procs_required bit (1),			/* ON if apte.procs_required is system default */
  5    23       3 realtime_burst bit (1),			/* ON if next eligibility is realtime */
  5    24       3 always_loaded bit (1),			/* ON if process is not to be unloaded */
  5    25       3 dbr_loaded bit (1),				/* ON if DBR is loaded on some CPU */
  5    26       3 being_loaded bit (1),				/* ON if somebody loading this process */
  5    27       3 shared_stack_0 bit (1),			/* ON if a shared stack_0 is assigned */
  5    28       3 page_wait_flag bit (1),			/* flag ON if waiting for page */
  5    29       3 firstsw bit (1),				/* OFF until process is intialized */
  5    30       3 state bit (18),				/* execution state */
  5    31     2 page_faults fixed bin (35),			/* total page faults for the process */
  5    32     2 processid bit (36),				/* bit 0-17: offset of ATPE */
  5    33 						/* bit 18-35: sequential number */
  5    34     2 te fixed bin (35),				/* virtual time since eligibility award */
  5    35     2 ts fixed bin (35),				/* virtual time since scheduling */
  5    36     2 ti fixed bin (35),				/* virtual time since interaction */
  5    37     2 timax fixed bin (35),				/* maximum value allowed for apte.ti */
  5    38 
  5    39 /* * * * * * * * */
  5    40 
  5    41     2 ipc_pointers unaligned,
  5    42       3 event_thread bit (18),			/* relative pointer to ITT list */
  5    43       3 pad3 bit (18),
  5    44     2 ips_message bit (36),				/* IPS signals pending */
  5    45     2 asteps unaligned,				/* relative ASTE pointers */
  5    46       3 pds bit (18),				/* PDS (per-process) */
  5    47       3 dseg bit (18),				/* DSEG (per-process) */
  5    48       3 prds bit (18),				/* PRDS (per-processor) */
  5    49     2 savex7 bit (18) unaligned,			/* x7 at call to getwork (return point in pxss) */
  5    50     2 term_processid bit (36),			/* process to send wakeup at temination */
  5    51     2 lock_id bit (36),				/* File System unqieu ID associated with process */
  5    52     2 time_used_clock fixed bin (71),			/* Total CPU time when process last lost CPU */
  5    53 
  5    54 /* * * * * * * * */
  5    55 
  5    56     2 wait_event bit (36) aligned,			/* Event ID process awaiting */
  5    57     2 wct_index bit (18) unaligned,			/* rel offset of WCTE */
  5    58     2 flags2 unaligned,
  5    59       3 priority_scheduling bit (1),			/* ON if guaranteed eligibility */
  5    60       3 special_wakeups bit (6),			/* Special wakeup channels */
  5    61       3 pad7 bit (7),
  5    62       3 batch bit (1),				/* ON if absentee */
  5    63       3 pr_tag bit (3),				/* CPU tag running or last run */
  5    64     2 state_change_time fixed bin (71),			/* Time apte.state last changed */
  5    65     2 alarm_event fixed bin (71),			/* wakeup event for alarm clock manager */
  5    66     2 alarm_time_thread bit (18) unaligned,		/* thread of processes with pending alarms */
  5    67     2 alarm_time bit (54) unaligned,			/* wakeup time for alarm */
  5    68 
  5    69 /* * * * * * */
  5    70 
  5    71     2 term_channel fixed bin (71),			/* wakeup event for account overflow */
  5    72     2 ws_size fixed bin,				/* working set estimate for the process */
  5    73     2 temax fixed bin (35),				/* maximum eligibility slice (vcpu) */
  5    74     2 deadline fixed bin (71),			/* time of next run */
  5    75     2 lock bit (18) unaligned,			/* 0 => APTE locked, unlocked => return point of last unlock */
  5    76     2 unusable bit (18) unaligned,			/* locking routines destroy */
  5    77     2 cpu_monitor fixed bin (35),			/* if not 0, send wakeup to term_processid when virtual cpu
  5    78*						/* reaches this (units = 1/1024 sec) */
  5    79     2 paging_measure fixed bin (71),			/* cumulative memory units */
  5    80     2 access_authorization bit (72),			/* authorization of this process */
  5    81     2 dbr fixed bin (71),				/* DBR value (constant since DSEG entry-held) */
  5    82 
  5    83     2 virtual_cpu_time fixed bin (71),			/* cumulative virtual CPU time for the process */
  5    84     2 ittes_sent fixed bin (18),			/* Unprocessed ITTs sent by this process */
  5    85     2 ittes_got fixed bin (18),			/* Unprocessed ITTs received by this process */
  5    86 
  5    87 /*  Cells used to drive and instrument finite-state model for response time
  5    88*    measurement. Maintained by meter_response_time */
  5    89 
  5    90     2 current_response_state fixed bin (17) unaligned,	/* Process state in modle */
  5    91     2 pad18 bit (18) unaligned,
  5    92     2 number_processing fixed bin (35),			/* Number interactions */
  5    93     2 last_response_state_time fixed bin (71),		/* Clock time at last response state change */
  5    94     2 total_processing_time fixed bin (71),		/* Total interaction processing time */
  5    95 
  5    96 /* * * * * * */
  5    97 
  5    98     2 begin_interaction_vcpu fixed bin (71),		/* Virtual cpu at beginning of last interaction */
  5    99 
  5   100 /*  End of cells for finite-state model */
  5   101 
  5   102     2 saved_temax fixed bin (35),			/* temax at eligibility award */
  5   103     2 procs_required bit (8) unaligned,			/* bit mask of CPUs this process can run */
  5   104     2 pad4 bit (28) unaligned,
  5   105     2 ipc_r_offset fixed bin (18) unsigned,
  5   106     2 ipc_r_factor fixed bin (35) unsigned,
  5   107     2 apad (10) fixed bin (35);
  5   108 
  5   109 /*  END INCLUDE FILE ... apte.incl.pl1 */
     1829 
     1830 
  6     1 	/* BEGIN INCLUDE SEGMENT ... bind_map.incl.pl1 Michael J. Spier, 4/29/71  */
  6     2 	/* last modified  April, 1972 by M. Weaver */
  6     3 
  6     4 declare	1 bindmap aligned based(bmp),
  6     5 
  6     6 	2 dcl_version fixed bin,		/* version number of this structure = 1 */
  6     7 	2 n_components fixed bin,		/* number of entries in this array */
  6     8 	2 component(0 refer(bindmap.n_components)) aligned,
  6     9 	  3 name,				/* objectname of component object */
  6    10 	    4 name_ptr bit(18) unaligned,	/* pointer to name string */
  6    11 	    4 name_lng bit(18) unaligned,	/* length of name string */
  6    12 	  3 comp_name char(8) aligned,	/* name of component's compiler */
  6    13 	  3 text_start bit(18) unaligned,	/* text section relocation counter */
  6    14 	  3 text_lng bit(18) unaligned,	/* length of text section */
  6    15 	  3 stat_start bit(18) unaligned,	/* internal static relocation counter */
  6    16 	  3 stat_lng bit(18) unaligned,	/* length of internal static */
  6    17 	  3 symb_start bit(18) unaligned,	/* symbol section relocation counter */
  6    18 	  3 symb_lng bit(18) unaligned,	/* length of symbol section */
  6    19 	  3 defblock_ptr bit(18) unaligned,	/* pointer to components definition block */
  6    20 	  3 n_blocks bit(18) unaligned,	/* number of symbol blocks the component has */
  6    21 	2 bf_name aligned,			/* name of bindfile */
  6    22 	  3 bf_name_ptr bit(18) unaligned,	/* pointer to name string */
  6    23 	  3 bf_name_lng bit(18) unaligned,	/* length of name string */
  6    24 	2 bf_date_up char(24),		/* date updated in archive */
  6    25 	2 bf_date_mod char(24);		/* date last modified */
  6    26 
  6    27 /* END INCLUDE SEGMENT ... bind_map.incl.pl1 */
     1831 
     1832 
  7     1 /* BEGIN INCLUDE FILE ... bos_dump.incl.pl1 ... */
  7     2 /* Modified 1 September 1976 */
  7     3 /* Modified 11/11/80 by J. A. Bush for the DPS8/70M CPU */
  7     4 /* Modified 6/12/81 by Rich Coppola to extend the dps8 extended fault reg to 
  7     5*   15 bits  */
  7     6 /* Modified 02/23/81, W. Olin Sibert, to describe old and new FDUMP styles */
  7     7 
  7     8 
  7     9 dcl  dumpptr ptr;					/* pointer to following structure */
  7    10 
  7    11 dcl 1 dump based (dumpptr) aligned,			/* header of dump by fdump */
  7    12     2 dump_header aligned like dump_header,
  7    13 
  7    14     2 segs (1008),					/* segment array */
  7    15       3 segno bit (18) unal,				/* segment number */
  7    16       3 length bit (18) unal, 			/* length of segment in sector sized blocks */
  7    17 
  7    18     2 amptwregs (0 : 63) bit (36),			/* assoc. mem. page table word regs */
  7    19     2 amptwptrs (0 : 63) bit (36),			/* assoc. mem. page table word pointers */
  7    20     2 amsdwregs (0 : 63) bit (72),			/* assoc. mem. segment descriptor word registers */
  7    21     2 amsdwptrs (0 : 63) bit (36),			/* assoc. mem. segment descriptor word pointers */
  7    22 
  7    23     2 ouhist (0 : 63) bit (72), 			/* operations unit history registers */
  7    24     2 cuhist (0 : 63) bit (72), 			/* control unit history registers */
  7    25     2 duhist (0 : 63) bit (72), 			/* decimal unit history registers */
  7    26     2 auhist (0 : 63) bit (72), 			/* appending unit history registers */
  7    27 
  7    28     2 prs (0 : 7) ptr,				/* pointer registers */
  7    29 
  7    30     2 regs aligned like dump_registers, 		/* assorted machine registers */
  7    31 
  7    32     2 low_order_port bit (3), 			/* from which clock is read */
  7    33     2 pad4 bit (36),
  7    34     2 mctime fixed bin (52),				/* time conditions were taken */
  7    35     2 pad5 (0 : 3) bit (36),
  7    36 
  7    37     2 misc_registers like dump_misc_registers,		/* Assorted registers & processor data */
  7    38 
  7    39     2 ptrlen (0 : 7) bit (36),			/* pointers and lengths for EIS */
  7    40 
  7    41     2 coreblocks (0 : 7),
  7    42       3 num_first bit (18) unal,			/* first addr in coreblock */
  7    43       3 num_blocks bit (18) unal,			/* number of blocks used */
  7    44     2 pad7 (112) fixed bin;
  7    45 
  7    46 
  7    47 dcl 1 dump_header aligned based,			/* Standard header for FDUMP */
  7    48     2 words_dumped fixed bin (35),			/* total words in dump */
  7    49     2 valid bit (1),				/* = 1 if there is a 6180 dump to be had */
  7    50     2 time fixed bin (71),				/* time of dump */
  7    51     2 erfno fixed bin (18),				/* Error Report Form Number */
  7    52     2 num_segs fixed bin,				/* number of segments dumped */
  7    53     2 valid_355 bit (1),				/* = 1 if there is a dn355 dump to be had */
  7    54     2 dumped_355s bit (4),				/* indicates which 355s were dumped */
  7    55     2 time_355 fixed bin (71),			/* time of 355 dump */
  7    56     2 version fixed bin,				/* currently 2 */
  7    57     2 pad0 (5) fixed bin;				/* pad0 to 16 words */
  7    58 
  7    59 dcl 1 dump_registers aligned based,			/* Standard (SREG) arrangement of registers in dump */
  7    60    (2 x (0 : 7) bit (18),				/* index registers */
  7    61     2 a bit (36),					/* the a register */
  7    62     2 q bit (36),					/* the q register */
  7    63     2 e bit (8),					/* the e register */
  7    64     2 pad2 bit (28),				/* pad */
  7    65     2 t bit (27),					/* timer register */
  7    66     2 pad3 bit (6), 				/* pad */
  7    67     2 ralr bit (3)) unaligned;			/* ring alarm register */
  7    68 
  7    69 dcl 1 dump_misc_registers aligned based,
  7    70     2 scu (0 : 7) bit (36),				/* from store control unit instr. */
  7    71     2 mcm (0 : 7) bit (72),				/* memory controller masks every 64 K */
  7    72     2 dbr bit (72), 				/* descriptor segment base register */
  7    73     2 intrpts bit (36),				/* interrupts */
  7    74     2 bar bit (36), 				/* base address register */
  7    75     2 modereg bit (36),				/* mode register */
  7    76     2 cmodereg bit (36),				/* cache mode register */
  7    77     2 faultreg bit (36),				/* fault register */
  7    78     2 ext_fault_reg bit (15) unaligned,			/* DPS8 extended fault register */
  7    79     2 pad6 bit (21) unaligned;
  7    80     
  7    81     
  7    82 
  7    83 dcl 1 v1_dump aligned based (dumpptr),			/* Old version of FDUMP (pre March, 1981) */
  7    84     2 dump_header aligned like dump_header,
  7    85 
  7    86     2 segs (688),					/* segment array */
  7    87       3 segno bit (18) unal,				/* segment number */
  7    88       3 length bit (18) unal, 			/* length of segment in sector sized blocks */
  7    89 
  7    90     2 amsdwregs (0 : 15) bit (72),			/* assoc. mem. segment descriptor word registers */
  7    91     2 amsdwptrs (0 : 15) bit (36),			/* assoc. mem. segment descriptor word pointers */
  7    92     2 amptwregs (0 : 15) bit (36),			/* assoc. mem. page table word regs */
  7    93     2 amptwptrs (0 : 15) bit (36),			/* assoc. mem. page table word pointers */
  7    94     2 pad1 (0 : 15) bit (36),
  7    95 
  7    96     2 ouhist (0 : 15) bit (72), 			/* operations unit history registers */
  7    97     2 cuhist (0 : 15) bit (72), 			/* control unit history registers */
  7    98     2 auhist (0 : 15) bit (72), 			/* appending unit history registers */
  7    99     2 duhist (0 : 15) bit (72), 			/* decimal unit history registers */
  7   100 
  7   101     2 prs (0 : 7) ptr,				/* pointer registers */
  7   102 
  7   103     2 regs aligned like dump_registers, 		/* assorted machine registers */
  7   104 
  7   105     2 mctime fixed bin (52),				/* time conditions were taken */
  7   106     2 pad4 (0 : 5) bit (36),
  7   107 
  7   108     2 misc_registers aligned like dump_misc_registers,	/* Assorted registers */
  7   109 
  7   110     2 pad5 bit (36),
  7   111     2 ptrlen (0 : 7) bit (36),			/* pointers and lengths for EIS */
  7   112     2 pad6 (15) bit (36),
  7   113     2 low_order_port bit (3), 			/* from which clock was read */
  7   114 
  7   115     2 coreblocks (0 : 7),
  7   116       3 num_first bit (18) unal,			/* first addr in coreblock */
  7   117       3 num_blocks bit (18) unal;			/* number of blocks used */
  7   118 
  7   119 
  7   120 dcl  DUMP_VERSION_1 fixed bin internal static options (constant) init (1);
  7   121 dcl  DUMP_VERSION_2 fixed bin internal static options (constant) init (2);
  7   122 
  7   123 /* END INCLUDE FILE ... bos_dump.incl.pl1 ... */
     1833 
     1834 
  8     1 /* Begin include file ...... dskdcl.incl.pl1 */
  8     2 
  8     3 /****^  HISTORY COMMENTS:
  8     4*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  8     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  8     6*     Support for FIPS dev 0.
  8     7*  2) change(88-05-10,Farley), approve(88-06-03,MCR7906),
  8     8*     audit(88-08-03,Fawcett), install(88-08-08,MR12.2-1080):
  8     9*     Added reconnect_announce_time to chantab to allow announcement of
  8    10*     reconnects at a throttled rate.  Otherwise only report them in the syserr
  8    11*     log.  Also added IO_TYPE constant array for displaying I/O type.
  8    12*                                                   END HISTORY COMMENTS */
  8    13 
  8    14 /* Structures used by the Disk DIM */
  8    15 
  8    16 /* Modified 84-03-21 by T. Oke for system wide free queue. */
  8    17 /* Modified 84-04-24 by T. Oke for dynamic channel table. */
  8    18 /* Modified 84-05-03 by T. Oke to hold sx for azm analysis. */
  8    19 /* Modified 84-05-14 by T. Oke for larger quentry and adaptive optimization. */
  8    20 /* Modifies 84-11-26 by R. A. Fawcett for device 0 (fips) */
  8    21 
  8    22 /* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
  8    23 
  8    24 dcl  disk_seg$ ext;					/* disk data segment */
  8    25 
  8    26 dcl  disksp ptr,					/* pointer to disk subsystem info */
  8    27      diskp ptr,					/* pointer to disk DIM info structure */
  8    28      optp ptr,					/* pointer to opt_info */
  8    29      sysp ptr;					/* pointer to sys_info */
  8    30 
  8    31 dcl  1 disk_data based (disksp) aligned,		/* disk subsystem information */
  8    32        2 subsystems fixed bin,			/* number of subsystems */
  8    33        2 free_offset bit (18),			/* offset of first unused location in segment */
  8    34        2 status_mask bit (36),			/* mask for checking for disk error */
  8    35        2 lock bit (36) unal,				/* disk_data lock */
  8    36        2 free_q like qht,				/* head/tail offsets */
  8    37        2 free_q_size fixed bin,			/* length of queue */
  8    38        2 array (32),				/* per subsystem info */
  8    39          (
  8    40          3 offset bit (18),				/* location of data for this subsystem */
  8    41          3 mbz bit (18),				/* low 18 of old  style indirect word */
  8    42          3 name char (4)
  8    43          ) unal,					/* name of subsystem */
  8    44        2 stagnate_time fixed bin (35),			/* stagnatation period */
  8    45        2 bail_outs fixed bin (35),			/* times ALM called PL1 */
  8    46        2 pad bit (36),				/* double word align */
  8    47        2 max_depth_reset_time fixed bin (71),		/* time max_reset done */
  8    48 						/* Upper bound is MAX_IO_TYPE, hard coded to avoid dynamic calculation */
  8    49        2 sys_info (0:6) like sys_info,			/* MUST BE DOUBLE WORD ALIGNED */
  8    50        2 free_q_entries (2 refer (disk_data.free_q_size)) like quentry;
  8    51 
  8    52 
  8    53 /* The following system table is used to hold the maximum queue loading
  8    54*   permitted system-wide for each IO type.  From the current loading and
  8    55*   the maximum loading a multiplier fraction is calculated.  These combine
  8    56*   to produce the final optimization multiplier to derive a Logcial Seek
  8    57*   from a Physical Seek. */
  8    58 
  8    59 dcl  1 sys_info aligned based (sysp),
  8    60        3 depth float bin (27),			/* current load */
  8    61        3 max_depth float bin (27),			/* max permissible */
  8    62        3 fraction float bin (27),			/* load fraction */
  8    63        3 depth_map bit (18) unaligned,			/* which depth counter */
  8    64        3 pad bit (18) unaligned;
  8    65 
  8    66 /* Maximum number of channels per sub-system.  Must be a power of two.  It must
  8    67*   be at or below the size of disk_init's chan_array size.  Shift factor is for
  8    68*   dctl's use. */
  8    69 
  8    70 dcl  dskdcl_chans_per_subsys fixed bin static options (constant) initial (32);
  8    71 dcl  dskdcl_chans_per_subsys_shift fixed bin static options (constant) initial (5);
  8    72 
  8    73 
  8    74 dcl  1 disktab based (diskp) aligned,			/* control structure for DIM's */
  8    75        2 lock bit (36) unal,				/* data base lock */
  8    76        2 nchan fixed bin,				/* number of disk channels */
  8    77        2 first_dev fixed bin unal,			/* frist device number  0 or 1 */
  8    78        2 last_dev fixed bin unal,			/* highest disk drive number */
  8    79        2 channels_online fixed bin,			/* number of disk channels actually in use */
  8    80        2 dev_busy bit (72),				/* busy bit for each device (only 0-63 used) */
  8    81        2 dev_queued bit (72),				/* requests queued bit for each device (only 0-63 used) */
  8    82        2 abs_mem_addr fixed bin (26) unsigned,		/* absolute memory address of this structure */
  8    83        2 channels bit (18) unal,			/* location of chantab for this subsystem */
  8    84        2 dev_index fixed bin (17) unal,			/* current device to check */
  8    85        2 errors fixed bin,				/* error count */
  8    86        2 ferrors fixed bin,				/* fatal error count */
  8    87        2 edac_errors fixed bin,			/* count of EDAC correctable errors */
  8    88        2 call_lock_meters like disk_lock_meters,		/* lock meters for call side of DIM */
  8    89        2 int_lock_meters like disk_lock_meters,		/* lock meters for interrupt side of DIM */
  8    90        2 alloc_wait_meters like disk_lock_meters,		/* meters for queue entry allocations */
  8    91        2 run_lock_meters like disk_lock_meters,		/* lock meters for run calls */
  8    92        2 devtab (0:0 refer (disktab.last_dev)) like devtab; /* device information table */
  8    93 
  8    94 dcl  1 disk_channel_table (1 refer (disktab.nchan)) like chantab based aligned;
  8    95 
  8    96 
  8    97 dcl  qp ptr,					/* pointer to queue entry */
  8    98      cp ptr;					/* pointer to channel information table */
  8    99 
  8   100 
  8   101 /* Queue entry, 6 words.  Cylinder and sector variables are over-size for
  8   102*   expansion space.  They will always be positive and upper bits can be
  8   103*   stolen for other fields.
  8   104*
  8   105*   Entries are forward and back linked to permit easy chasing and removal. */
  8   106 
  8   107 dcl  1 quentry based (qp) aligned,			/* queue entry */
  8   108 						/* WORD 1 */
  8   109        2 next bit (18) unaligned,			/* forward link */
  8   110        2 prev bit (18) unaligned,			/* back link */
  8   111 						/* WORD 2 */
  8   112        2 intrpt bit (1) unaligned,			/* completion interrupt desired */
  8   113        2 used bit (1) unaligned,			/* entry in use */
  8   114        2 type fixed bin (4) unsigned unaligned,		/* IO type */
  8   115        2 pad bit (6) unaligned,			/* future expansion */
  8   116        2 coreadd bit (24) unaligned,			/* main memory address */
  8   117 						/* WORD 3 */
  8   118        2 pvtx fixed bin (8) unsigned unaligned,		/* for AZM/ol_dump */
  8   119        2 pdi fixed bin (6) unsigned unaligned,		/* physical device */
  8   120        2 dev fixed bin (6) unsigned unaligned,		/* device in sub-sys */
  8   121        2 pad2 bit (5) unaligned,
  8   122        2 cylinder fixed bin (11) unsigned unaligned,	/* cylinder of request */
  8   123 						/* WORD 4 */
  8   124        2 n_sectors fixed bin (6) unsigned unaligned,	/* # sectors of IO */
  8   125        2 pad3 bit (9) unaligned,
  8   126        2 sector bit (21) unaligned,			/* device sector desired */
  8   127 						/* WORDS 5&6 */
  8   128        2 time fixed bin (71);				/* clock at queue */
  8   129 
  8   130 
  8   131 
  8   132 dcl  1 chantab based (cp) aligned,			/* channel information table */
  8   133        2 chx fixed bin (35),				/* io_manager channel index */
  8   134        2 ioi_ctx fixed bin (35),			/* ioi channel table index */
  8   135        2 statusp ptr,				/* pointer to hardware status word */
  8   136        2 chanid char (8),				/* channel name */
  8   137        (
  8   138        2 pad0 bit (18),
  8   139        2 in_use bit (1),				/* non-zero if channel being used */
  8   140        2 active bit (1),				/* non-zero if channel active */
  8   141        2 rsr bit (1),				/* non-zero if RSR in progress */
  8   142        2 ioi_use bit (1),				/* non-zero if channel usurped by IOI */
  8   143        2 inop bit (1),				/* non-zero if channel inoperative */
  8   144        2 broken bit (1),				/* non-zero if channel broken */
  8   145        2 action_code bit (2),				/* saved from status */
  8   146        2 pad1 bit (10)
  8   147        ) unal,
  8   148        (
  8   149        2 qrp bit (18),				/* rel ptr to queue entry */
  8   150        2 pad2 bit (3),
  8   151        2 command bit (6),				/* peripheral command */
  8   152        2 erct fixed bin (8)
  8   153        ) unal,					/* error retry count */
  8   154        2 select_data,				/* data passed to IOM on select */
  8   155          (
  8   156          3 limit bit (12),				/* limit on number of sectors */
  8   157          3 mbz bit (3),
  8   158          3 sector bit (21)
  8   159          ) unaligned,				/* sector address */
  8   160        2 reconnect_announce_time fixed bin (52),		/* reconnect announcement throttle */
  8   161        2 connect_time fixed bin (52),			/* time of last connect */
  8   162        2 connects fixed bin,				/* count of connects performed */
  8   163        2 detailed_status (0:17) bit (8) unal,		/* detailed status bytes */
  8   164        2 rstdcw bit (36),				/* restore command */
  8   165        2 scdcw bit (36),				/* select command */
  8   166        2 sddcw bit (36),				/* select data xfer */
  8   167        2 dcdcw bit (36),				/* command to read or write */
  8   168        2 dddcw bit (36),				/* data xfer DCW */
  8   169        2 dscdcw bit (36),				/* RSR command */
  8   170        2 dsddcw bit (36),				/* RSR data xfer */
  8   171        2 rssdcw bit (36),				/* RSS command */
  8   172        2 status bit (36) aligned,			/* saved status */
  8   173 						/* Lossage counters for interrupt loss. */
  8   174        2 no_io_terminate fixed bin (35),		/* no t bit from io_manager$get_status */
  8   175        2 terminate_not_active fixed bin (35),		/* terminate, but not active */
  8   176        2 no_status_terminate fixed bin (35),		/* interrupt with no terminate */
  8   177        2 status_from_run fixed bin (35);		/* status missed til run called */
  8   178 
  8   179 dcl  1 qht aligned based,				/* queue head/tail structure */
  8   180        2 sum fixed bin (35),				/* sum of depths */
  8   181        2 count fixed bin (35),			/* allocs */
  8   182        2 max_depth fixed bin (17) unaligned,		/* high water mark */
  8   183        2 depth fixed bin (17) unaligned,		/* current depth */
  8   184        2 head bit (18) unaligned,			/* queue head */
  8   185        2 tail bit (18) unaligned;			/* queue tail */
  8   186 
  8   187 dcl  dp ptr,					/* pointer to device information table */
  8   188      pvtdip ptr;					/* pointer to dim_info in PVT entry */
  8   189 
  8   190 dcl  1 devtab based (dp) aligned,			/* device information table */
  8   191        (
  8   192        2 pvtx fixed bin (8),				/* index of PVT entry for device */
  8   193        2 inop bit (1),				/* device inoperative */
  8   194        2 was_broken bit (1),				/* device previously broken */
  8   195        2 broken bit (1),				/* device down */
  8   196        2 abandoned bit (1),				/* device lost and gone forever */
  8   197        2 forward bit (1),				/* moving low->high */
  8   198        2 pad bit (10),
  8   199        2 buddy unsigned fixed bin (6),			/* other device on this spindle or 0 */
  8   200        2 pdi unsigned fixed bin (6)
  8   201        ) unal,					/* primary device index */
  8   202        2 cylinder fixed bin (35),			/* current cylinder position */
  8   203        2 comb fixed bin (35),				/* number of combs */
  8   204        2 pad1 fixed bin (35),
  8   205        2 time_inop fixed bin (52),			/* time drive became inoperative */
  8   206        2 wq like qht,				/* work queue */
  8   207 						/* Upper bound must be MAX_IO_TYPE, constant to avoid dynamic calculation. */
  8   208        2 opt_info (0:6) like opt_info;			/* optimizer */
  8   209 
  8   210 
  8   211 /* Optimizing table for device. Must be even multiple words long. */
  8   212 /* Slope and intercept define a straight line of y = intercept - slope*x
  8   213*   Multiplier is calculated from this and current system loading.
  8   214*
  8   215*   sys_info is the offset to the relevant system queue loading fraction. */
  8   216 
  8   217 dcl  1 opt_info aligned based (optp),
  8   218        3 multiplier float bin (27),			/* depth mult */
  8   219        3 slope float bin (27),			/* slope of line */
  8   220        3 intercept float bin (27),			/* Y intercept */
  8   221        3 sys_info bit (18) unaligned,			/* offset to sys_info */
  8   222        3 depth fixed bin (17) unaligned,		/* elements in queue */
  8   223        3 channel_wait fixed bin (52),			/* total channel time waiting */
  8   224        3 queue_wait fixed bin (52),			/* total queue time waiting */
  8   225        3 seek_sum fixed bin (35) unaligned,		/* sum of seeks */
  8   226        3 seek_count fixed bin (35) unaligned;		/* number of seeks */
  8   227 
  8   228 
  8   229 dcl  1 pvtdi based (pvtdip) aligned,			/* disk DIM info in PVT entry */
  8   230        (
  8   231        2 sx fixed bin (11),				/* structure index */
  8   232        2 usable_sect_per_cyl fixed bin (11),		/* # of usable sectors on disk cylinder */
  8   233        2 unused_sect_per_cyl fixed bin (11)
  8   234        ) unal;					/* # of unused sectors at end of cylinder */
  8   235 
  8   236 dcl  1 disk_lock_meters based aligned,			/* lock meters for disk DIM */
  8   237        2 count fixed bin,				/* total number of attempts */
  8   238        2 waits fixed bin,				/* number of attempts which required waiting */
  8   239        2 wait_time fixed bin (52);			/* total time spent waiting */
  8   240 
  8   241 dcl  (
  8   242      RST_LISTX init (1),				/* listx for restore */
  8   243      SC_LISTX init (2),				/* listx for select */
  8   244      DSC_LISTX init (6),				/* listx for RSR */
  8   245      RSS_LISTX init (8)
  8   246      ) fixed bin (12) static options (constant);		/* listx for RSS */
  8   247 
  8   248 /* IO types defined.  Value is also index of write_map to determine if
  8   249*   the IO type is a read or a write. */
  8   250 
  8   251 dcl  (
  8   252      PAGE_READ init (0),
  8   253      PAGE_WRITE init (1),
  8   254      VTOC_READ init (2),
  8   255      VTOC_WRITE init (3),
  8   256      TEST init (4),
  8   257      BOOTLOAD_READ init (5),
  8   258      BOOTLOAD_WRITE init (6),
  8   259      MAX_IO_TYPE init (6)
  8   260      ) fixed bin (4) static options (constant);
  8   261 
  8   262 dcl  IO_TYPE (0:6) char (16)
  8   263 	initial ("Page Read", "Page Write", "VTOC Read", "VTOC Write", "Test", "Bootload Read", "Bootload Write")
  8   264 	static options (constant);
  8   265 
  8   266 /* Map indexed by IO type to determine if operation is a read or write. */
  8   267 
  8   268 dcl  write_mapping bit (7) initial ("0101001"b) static options (constant);
  8   269 dcl  write_map (0:6) bit (1) defined (write_mapping);
  8   270 
  8   271 /* Map indexed by IO type to determine if operation is a sector IO. */
  8   272 
  8   273 dcl  sector_mapping bit (7) initial ("0011111"b) static options (constant);
  8   274 dcl  sector_map (0:6) bit (1) defined (sector_mapping);
  8   275 
  8   276 /* Map indexed by IO type to determine if operation is done on behalf of bce */
  8   277 
  8   278 dcl  bootload_mapping bit (7) initial ("0000011"b) static options (constant);
  8   279 dcl  bootload_map (0:6) bit (1) defined (bootload_mapping);
  8   280 
  8   281 /* End of include file ...... dskdcl.incl.pl1 */
     1835 
     1836 
  9     1 /* Begin include file ...... fs_dev_types.incl.pl1 */
  9     2 
  9     3 /****^  HISTORY COMMENTS:
  9     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  9     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  9     6*     Add support for FIPS
  9     7*     3380.
  9     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  9     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  9    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  9    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  9    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  9    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  9    14*                                                   END HISTORY COMMENTS */
  9    15 
  9    16 /* Modified 5/19/76 by N. I. Morris */
  9    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  9    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  9    19 /* Modified '82 by BIM for needs_alt_part */
  9    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  9    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  9    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  9    23*   volmap and record stock can be expanded. */
  9    24 
  9    25 /*
  9    26********************************************************************************
  9    27**							        *
  9    28**                           WARNING:                                          *
  9    29**							        *
  9    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  9    31**   type is added.						        *
  9    32**							        *
  9    33**   There are other include files that contain arrays indexed by the device   *
  9    34**   index obtained by references to MODELX or MODELN in this include file.    *
  9    35**   These must be modified when a new device type is added:		        *
  9    36**   disk_pack.incl.pl1					        *
  9    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  9    38**							        *
  9    39********************************************************************************
  9    40**/
  9    41 
  9    42 
  9    43 dcl (maxdevt init (9),				/* maximum legal devt */
  9    44      bulkdevt init (1),				/* bulk store devt */
  9    45      msu0500devt init (2),				/* MSU0500 device type */
  9    46      msu0451devt init (3),				/* MSU0451 device type */
  9    47      msu0450devt init (3),				/* MSU0450 device type */
  9    48      msu0400devt init (4),				/* MSU0400 device type */
  9    49      dsu191devt init (4),				/* DSU191 device type */
  9    50      dsu190devt init (5),				/* DSU190 device type */
  9    51      dsu181devt init (6),				/* DSU181 device type */
  9    52      msu0501devt init (7),				/* MSU0501 device type */
  9    53      fips3380devt init (8),				/* 3380D FIPS device type */
  9    54      fips3381devt init (9)				/* 3380E FIPS device type */
  9    55      ) fixed bin (4) static options (constant);
  9    56 
  9    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  9    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  9    59 
  9    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  9    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  9    62 
  9    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  9    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  9    65 
  9    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  9    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  9    68 
  9    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  9    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  9    71 
  9    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  9    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  9    74 
  9    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  9    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  9    77 
  9    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  9    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  9    80 
  9    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  9    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  9    83 
  9    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  9    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  9    86 
  9    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  9    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  9    89 
  9    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  9    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  9    92 
  9    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  9    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  9    95 
  9    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  9    97      ("abc");
  9    98 
  9    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  9   100      init ("a","b","c");
  9   101 
  9   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  9   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  9   104 
  9   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  9   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  9   107 
  9   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  9   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  9   110 
  9   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  9   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  9   113 
  9   114 
  9   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  9   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  9   117 
  9   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  9   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  9   120 
  9   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  9   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  9   123 
  9   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  9   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  9   126 
  9   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  9   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  9   129 
  9   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  9   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  9   132 
  9   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  9   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  9   135 
  9   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  9   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  9   138 
  9   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  9   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  9   141 
 10     1 /* Begin fs_dev_types_sector.incl.pl1 */
 10     2 
 10     3 
 10     4 /****^  HISTORY COMMENTS:
 10     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
 10     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
 10     7*     Add the sector differance for devices that do 64 word IO and devices that
 10     8*     do 512 word IO.
 10     9*                                                   END HISTORY COMMENTS */
 10    10 
 10    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
 10    12*	 need all the data in fs_dev_types. This is also included in
 10    13*	 fs_dev_types.incl.pl1  */
 10    14 
 10    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
 10    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
 10    17 
 10    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
 10    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
 10    20 
 10    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
 10    22  /* table of # of sectors per record on each device */
 10    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
 10    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
 10    25 
 10    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
 10    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
 10    28 	
 10    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
 10    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
 10    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
 10    32 
 10    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
 10    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
 10    35 
 10    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
 10    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
 10    38 
 10    39 /* End fs_dev_types_sector.incl.pl1 */
 10    40 
  9   142 
  9   143 
  9   144 /* End of include file ...... fs_dev_types.incl.pl1 */
     1837 
     1838 
 11     1 /* Begin include file ...... iom_data.incl.pl1
 11     2*   First written in August 1971 by R F Mabee.
 11     3*   Modified for paged IOM November 1980 by C. Hornig.
 11     4*   More IIOC changes by C. Hornig, June 1982.
 11     5*   Modified for channel reconfiguration by Chris Jones, January 1984.
 11     6*   Modified to remove support of non-paged IOMs by Chris Jones, August 1984.
 11     7*   Modified to add IMW read protocol flags by M. Pandolf, January 1985.
 11     8**/
 11     9 
 11    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
 11    11 dcl	iom_data$		   external;
 11    12 dcl	iom_mailbox$	   external;
 11    13 
 11    14 dcl	n_devices		   fixed bin;
 11    15 dcl	iom_data_ptr	   ptr;
 11    16 
 11    17 dcl	1 iom_data	   based (iom_data_ptr) aligned,
 11    18 	  2 n_devices	   fixed bin,		/* (0) Maximum number of channels. */
 11    19 	  2 stop_lpw	   bit (36),		/* (1) LPW pointing to stop_dcw. */
 11    20 	  2 stop_dcw	   bit (36),		/* (2) DCW to stop channel, probably storing bad status. */
 11    21 	  2 stop_scw	   bit (36),		/* (3) SCW for same */
 11    22 	  2 imw_lock	   fixed bin (35),		/* (4) Essentially a lock for iom switch checking: */
 11    23 						/* 1  : OK to poll IMW */
 11    24 						/* 0  : lock in transition */
 11    25 						/* -1 : DONT poll IMW */
 11    26 	  2 n_intr_procs fixed bin (35),		/* (5) Number of processors in interrupt handler */
 11    27 	  2 pad1		   (2) bit (36),
 11    28 	  2 stop_status	   bit (72),		/* (10) All unused channels store status here. */
 11    29 	  2 rfh1		   (6) bit (36),		/* can't use this */
 11    30 	  2 stop_ext_status	   bit (8 * 36),		/* (20) Unused channels' extended status */
 11    31 	  2 pad3		   (5) bit (36),
 11    32 	  2 invalid_interrupts fixed bin (35),		/* (35) interrupts on unused channels */
 11    33 	  2 null_interrupts	   fixed bin (35),		/* (36) spurious interrupts */
 11    34 	  2 multiple_interrupts
 11    35 			   fixed bin (35),		/* (37) several interrupts at a time */
 11    36 	  2 per_iom	   (4) like per_iom,	/* (40) for each IOM */
 11    37 	  2 per_device	   (n_devices refer (iom_data.n_devices)) like per_device;
 11    38 						/* (240) Data for assigned channels. */
 11    39 
 11    40 dcl	1 per_iom		   aligned based,
 11    41 	  2 lock		   bit (36),		/* (40) connect mailbox lock */
 11    42 	  2 flags,				/* (41) */
 11    43 	    3 configured	   bit (1) unal,		/* is configured */
 11    44 	    3 on_line	   bit (1) unal,		/* is ON */
 11    45 	    3 pad1	   bit (34) unal,
 11    46 	  2 model		   char (4),		/* (42) what kind of IOM */
 11    47 	  2 port		   fixed bin (3),		/* (43) SC port */
 11    48 	  2 connect_time	   fixed bin (71),		/* (44) time of last connect */
 11    49 	  2 connect_lpw	   bit (36),		/* (46) LPW for connect channel */
 11    50 	  2 cow		   bit (36),		/* (47) Connect Operand Word */
 11    51 	  2 special_chx	   fixed bin (35),		/* (50) chx of special status channel */
 11    52 	  2 fault_chx	   fixed bin (35),		/* (51) chx of system fault channel */
 11    53 	  2 pad2		   (4) bit (36),
 11    54 	  2 abandoned_connects fixed bin (35),		/* (56) times we couldn't get IOM to listen at all */
 11    55 	  2 reconnects	   fixed bin (35),		/* (57) times a connect was lost */
 11    56 	  2 chantab	   (0:63) uns fixed bin (9) unal;
 11    57 						/* (60) packed devtab indices */
 11    58 
 11    59 dcl	1 per_device	   aligned based,
 11    60 	  2 status	   bit (72),		/* (0) Status for channel is stored here. */
 11    61 	  2 rfh1		   (6) bit (36),
 11    62 	  2 ext_status	   bit (8 * 36),		/* (10) extended status stored by IIOC */
 11    63 	  2 iom		   uns fixed bin (3),	/* (20) IOM# (1-4) */
 11    64 	  2 channel	   uns fixed bin (6),	/* (21) channel # */
 11    65 	  2 handler	   entry (fixed bin (35), fixed bin (3), bit (36) aligned),
 11    66 						/* (22) Interrupt handler for device. */
 11    67 	  2 flags,				/* (26) */
 11    68 	    3 in_use	   bit (1) unal,		/* assigned */
 11    69 	    3 queue_status	   bit (1) unal,		/* maintain status queue */
 11    70 	    3 on_line	   bit (1) unal,		/* can be assigned */
 11    71 	  2 index		   fixed bin (35),		/* (27) Channel identification index. */
 11    72 	  2 pcw		   bit (72),		/* (30) Peripheral Control Word */
 11    73 	  2 lpw		   bit (72),		/* (32) List Pointer Word */
 11    74 	  2 scw		   bit (36),		/* (34) Status Control Word */
 11    75 	  2 pad1		   fixed bin (35),
 11    76 	  2 status_queue_ptr   ptr,			/* (36) Status queue */
 11    77 	  2 connect_time	   fixed bin (71),		/* (40) time of last connect */
 11    78 	  2 connects	   fixed bin (71),		/* (42) Total connects */
 11    79 	  2 interrupts	   fixed bin (71),		/* (44) Total number of interrupts for this channel. */
 11    80 	  2 interrupt_time	   fixed bin (71);		/* (46) Total interrupt time for this channel. */
 11    81 
 11    82 dcl	iom_mailbox_seg_ptr	   ptr;
 11    83 dcl	1 iom_mailbox_seg	   aligned based (iom_mailbox_seg_ptr),
 11    84 	  2 imw_array	   (0:31) bit (32),		/* Indexed by interrupt cell number. One bit for each channel. */
 11    85 	  2 system_fault	   (4) aligned like status_queue,
 11    86 						/* system faults store here (12 words/IOM) */
 11    87 	  2 special_status	   (4) aligned like status_queue,
 11    88 						/* special status words here (12 words/IOM) */
 11    89 	  2 iom_mailbox	   (4) like iom_mailbox;	/* Used to communicate with the IOM. */
 11    90 
 11    91 dcl	status_queue_ptr	   ptr;
 11    92 dcl	1 status_queue	   aligned based (status_queue_ptr),
 11    93 	  2 status	   (12) bit (36);
 11    94 
 11    95 dcl	1 iom_mailbox	   aligned based,
 11    96 	  2 channel_mailbox	   (0:63) like channel_mailbox;
 11    97 
 11    98 dcl	1 channel_mailbox	   aligned based,
 11    99 	  2 lpw		   bit (72),		/* List pointer word. Points to DCW list. */
 11   100 	  2 scw		   bit (36),		/* Status control word. Points to channel_table.status. */
 11   101 	  2 dcw		   bit (36);		/* Data control word. Primarily scratch space for IOM. */
 11   102 
 11   103 /* Defined channel numbers. */
 11   104 
 11   105 dcl	(
 11   106 	system_fault_channel   init (1),		/* Stores system fault words using LPW and DCW. */
 11   107 	connect_channel	   init (2),		/* Starts other channels using LPW pointing to PCW. */
 11   108 	special_status_channel init (6)		/* Stores special status using LPW and DCW. */
 11   109 	)		   fixed bin (6) static options (constant);
 11   110 
 11   111 /* End of include file ..... iom_data.incl.pl1 */
     1839 
     1840 
 12     1 /* BEGIN INCLUDE FILE its.incl.pl1
 12     2*   modified 27 July 79 by JRDavis to add its_unsigned
 12     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
 12     4 
 12     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
 12     6     2 pad1 bit (3) unaligned,
 12     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
 12     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
 12     9     2 pad2 bit (9) unaligned,
 12    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
 12    11 
 12    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
 12    13     2 pad3 bit (3) unaligned,
 12    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
 12    15     2 pad4 bit (3) unaligned,
 12    16     2 mod bit (6) unaligned;				/* further modification */
 12    17 
 12    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
 12    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
 12    20     2 pad1 bit (27) unaligned,
 12    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
 12    22 
 12    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
 12    24     2 pad2 bit (3) unaligned,
 12    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
 12    26     2 pad3 bit (3) unaligned,
 12    27     2 mod bit (6) unaligned;				/* further modification */
 12    28 
 12    29 
 12    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
 12    31     2 pad1 bit (3) unaligned,
 12    32     2 segno fixed bin (15) unsigned unaligned,
 12    33     2 ringno fixed bin (3) unsigned unaligned,
 12    34     2 pad2 bit (9) unaligned,
 12    35     2 its_mod bit (6) unaligned,
 12    36 
 12    37     2 offset fixed bin (18) unsigned unaligned,
 12    38     2 pad3 bit (3) unaligned,
 12    39     2 bit_offset fixed bin (6) unsigned unaligned,
 12    40     2 pad4 bit (3) unaligned,
 12    41     2 mod bit (6) unaligned;
 12    42 
 12    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
 12    44     2 pr_no fixed bin (3) unsigned unaligned,
 12    45     2 pad1 bit (27) unaligned,
 12    46     2 itp_mod bit (6) unaligned,
 12    47 
 12    48     2 offset fixed bin (18) unsigned unaligned,
 12    49     2 pad2 bit (3) unaligned,
 12    50     2 bit_offset fixed bin (6) unsigned unaligned,
 12    51     2 pad3 bit (3) unaligned,
 12    52     2 mod bit (6) unaligned;
 12    53 
 12    54 
 12    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
 12    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
 12    57 
 12    58 /* END INCLUDE FILE   its.incl.pl1 */
     1841 
     1842 
 13     1 /*  */
 13     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
 13     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
 13     4 /* Modified 07/07/76 by Morris for fault register data */
 13     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
 13     6 /* Modified '82 to make values constant */
 13     7 
 13     8 /* words 0-15 pointer registers */
 13     9 
 13    10 dcl  mcp ptr;
 13    11 
 13    12 dcl 1 mc based (mcp) aligned,
 13    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
 13    14    (2 regs,					/* registers */
 13    15       3 x (0:7) bit (18),				/* index registers */
 13    16       3 a bit (36),					/* accumulator */
 13    17       3 q bit (36),					/* q-register */
 13    18       3 e bit (8),					/* exponent */
 13    19       3 pad1 bit (28),
 13    20       3 t bit (27),					/* timer register */
 13    21       3 pad2 bit (6),
 13    22       3 ralr bit (3),				/* ring alarm register */
 13    23 
 13    24     2 scu (0:7) bit (36),
 13    25 
 13    26     2 mask bit (72),				/* mem controller mask at time of fault */
 13    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
 13    28     2 errcode fixed bin (35),				/* fault handler's error code */
 13    29     2 fim_temp,
 13    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
 13    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
 13    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
 13    33     2 fault_reg bit (36),				/* fault register */
 13    34     2 pad2 bit (1),
 13    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
 13    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
 13    37     2 fault_time bit (54),				/* time of fault */
 13    38 
 13    39     2 eis_info (0:7) bit (36)) unaligned;
 13    40 
 13    41 
 13    42 dcl (apx fixed bin init (0),
 13    43      abx fixed bin init (1),
 13    44      bpx fixed bin init (2),
 13    45      bbx fixed bin init (3),
 13    46      lpx fixed bin init (4),
 13    47      lbx fixed bin init (5),
 13    48      spx fixed bin init (6),
 13    49      sbx fixed bin init (7)) internal static options (constant);
 13    50 
 13    51 
 13    52 
 13    53 
 13    54 dcl  scup ptr;
 13    55 
 13    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
 13    57 
 13    58 
 13    59 /*	WORD (0)		*/
 13    60 
 13    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
 13    62       3 prr bit (3),				/* procedure ring register */
 13    63       3 psr bit (15),				/* procedure segment register */
 13    64       3 p bit (1),					/* procedure privileged bit */
 13    65 
 13    66     2 apu,					/* APPENDING UNIT STATUS */
 13    67       3 xsf bit (1),				/* ext seg flag - IT modification */
 13    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
 13    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
 13    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
 13    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
 13    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
 13    73       3 dsptw bit (1),				/* Fetch of DSPTW */
 13    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
 13    75       3 sdwp bit (1),				/* Fetch of SDW paged */
 13    76       3 ptw bit (1),				/* Fetch of PTW */
 13    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
 13    78       3 fap bit (1),				/* Fetch of final address paged */
 13    79       3 fanp bit (1),				/* Fetch of final address non-paged */
 13    80       3 fabs bit (1),				/* Fetch of final address absolute */
 13    81 
 13    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
 13    83 
 13    84 
 13    85 /*	WORD (1)		*/
 13    86 
 13    87     2 fd,						/* FAULT  DATA */
 13    88       3 iro bit (1),				/* illegal ring order */
 13    89       3 oeb bit (1),				/* out of execute bracket */
 13    90       3 e_off bit (1),				/* no execute */
 13    91       3 orb bit (1),				/* out of read bracket */
 13    92       3 r_off bit (1),				/* no read */
 13    93       3 owb bit (1),				/* out of write bracket */
 13    94       3 w_off bit (1),				/* no write */
 13    95       3 no_ga bit (1),				/* not a gate */
 13    96       3 ocb bit (1),				/* out of call bracket */
 13    97       3 ocall bit (1),				/* outward call */
 13    98       3 boc bit (1),				/* bad outward call */
 13    99       3 inret bit (1),				/* inward return */
 13   100       3 crt bit (1),				/* cross ring transfer */
 13   101       3 ralr bit (1),				/* ring alarm register */
 13   102       3 am_er bit (1),				/* associative memory fault */
 13   103       3 oosb bit (1),				/* out of segment bounds */
 13   104       3 paru bit (1),				/* processor parity upper */
 13   105       3 parl bit (1),				/* processor parity lower */
 13   106       3 onc_1 bit (1),				/* op not complete type 1 */
 13   107       3 onc_2 bit (1),				/* op not complete type 2 */
 13   108 
 13   109     2 port_stat,					/* PORT  STATUS */
 13   110       3 ial bit (4),				/* illegal action lines */
 13   111       3 iac bit (3),				/* illegal action channel */
 13   112       3 con_chan bit (3),				/* connect channel */
 13   113 
 13   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
 13   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
 13   116 
 13   117 
 13   118 /*	WORD (2)		*/
 13   119 
 13   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
 13   121       3 trr bit (3),				/* temporary ring register */
 13   122       3 tsr bit (15),				/* temporary segment register */
 13   123 
 13   124     2 pad2 bit (9),
 13   125 
 13   126     2 cpu_no bit (3),				/* CPU number */
 13   127 
 13   128     2 delta bit (6),				/* tally modification DELTA */
 13   129 
 13   130 
 13   131 /*	WORD (3)		*/
 13   132 
 13   133     2 word3 bit (18),
 13   134 
 13   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
 13   136       3 tsna,					/* Word 1 status */
 13   137         4 prn bit (3),				/* Word 1  PR  number */
 13   138         4 prv bit (1),				/* Word 1  PR  valid bit */
 13   139       3 tsnb,					/* Word 2  status */
 13   140         4 prn bit (3),				/* Word 2  PR  number */
 13   141         4 prv bit (1),				/* Word 2  PR  valid bit */
 13   142       3 tsnc,					/* Word 3  status */
 13   143         4 prn bit (3),				/* Word 3  PR  number */
 13   144         4 prv bit (1),				/* Word 3  PR  valid bit */
 13   145 
 13   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
 13   147 
 13   148 
 13   149 /* 	WORD (4)		*/
 13   150 
 13   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
 13   152 
 13   153     2 ir,						/* INDICATOR  REGISTERS */
 13   154       3 zero bit (1),				/* zero indicator */
 13   155       3 neg bit (1),				/* negative indicator */
 13   156       3 carry bit (1),				/* carryry indicator */
 13   157       3 ovfl bit (1),				/* overflow indicator */
 13   158       3 eovf bit (1),				/* eponent overflow */
 13   159       3 eufl bit (1),				/* exponent underflow */
 13   160       3 oflm bit (1),				/* overflow mask */
 13   161       3 tro bit (1),				/* tally runout */
 13   162       3 par bit (1),				/* parity error */
 13   163       3 parm bit (1),				/* parity mask */
 13   164       3 bm bit (1),					/* ^bar mode */
 13   165       3 tru bit (1),				/* truncation mode */
 13   166       3 mif bit (1),				/* multi-word instruction mode */
 13   167       3 abs bit (1),				/* absolute mode */
 13   168       3 hex bit (1),				/* hexadecimal exponent mode */
 13   169       3 pad bit (3),
 13   170 
 13   171 
 13   172 /*	WORD (5)		*/
 13   173 
 13   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
 13   175 
 13   176     2 cu,						/* CONTROL UNIT STATUS */
 13   177       3 rf bit (1),					/* on first cycle of repeat instr */
 13   178       3 rpt bit (1),				/* repeat instruction */
 13   179       3 rd bit (1),					/* repeat double instruction */
 13   180       3 rl bit (1),					/* repeat link instruciton */
 13   181       3 pot bit (1),				/* IT  modification */
 13   182       3 pon bit (1),				/* return type instruction */
 13   183       3 xde bit (1),				/* XDE from Even location */
 13   184       3 xdo bit (1),				/* XDE from Odd  location */
 13   185       3 poa bit (1),				/* operation preparation */
 13   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
 13   187       3 its bit (1),				/* ITS modification */
 13   188       3 if bit (1),					/* fault occured during instruction fetch */
 13   189 
 13   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
 13   191 
 13   192 
 13   193 /*	WORDS (6,7)	*/
 13   194 
 13   195     2 even_inst bit (36),				/* even instruction of faulting pair */
 13   196 
 13   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
 13   198 
 13   199 
 13   200 
 13   201 
 13   202 
 13   203 
 13   204 /*	ALTERNATE   SCU  DECLARATION		*/
 13   205 
 13   206 
 13   207 dcl 1 scux based (scup) aligned,
 13   208 
 13   209    (2 pad0 bit (36),
 13   210 
 13   211     2 fd,						/* GROUP II  FAULT DATA */
 13   212       3 isn bit (1),				/* illegal segment number */
 13   213       3 ioc bit (1),				/* illegal op  code  */
 13   214       3 ia_am bit (1),				/* illegal address - modifier */
 13   215       3 isp bit (1),				/* illegal slave  procedure */
 13   216       3 ipr bit (1),				/* illegal procedure */
 13   217       3 nea bit (1),				/* non existent address */
 13   218       3 oobb bit (1),				/* out of bounds */
 13   219       3 pad bit (29),
 13   220 
 13   221     2 pad2 bit (36),
 13   222 
 13   223     2 pad3a bit (18),
 13   224 
 13   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
 13   226       3 prn bit (3),				/* PR  number */
 13   227       3 prv bit (1),				/* PR  valid bit */
 13   228 
 13   229     2 pad3b bit (6)) unaligned,
 13   230 
 13   231     2 pad45 (0:1) bit (36),
 13   232 
 13   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
 13   234 
 13   235 
 13   236 
 13   237 /*  END INCLUDE FILE   mc.incl.pl1 */
     1843 
     1844 
 14     1 
 14     2 /* Begin include file mc_trace_buf.incl.pl1 */
 14     3 
 14     4 /* Created in April 1977 by James A. Bush to define the contents of the machine condition trace buffer */
 14     5 
 14     6 dcl  bp ptr;					/* pointer to M. C. buffer */
 14     7 
 14     8 dcl 1 mc_trace_buf based (bp) aligned,			/* trace buffer template */
 14     9     2 mc_lim fixed bin unal,				/* end of machine condition storage area */
 14    10     2 mc_nxtad fixed bin unal,			/* the nxt avail. location for M. C. storage */
 14    11     2 mc_strt fixed bin unal,				/* the beginning of the M. C. storage area */
 14    12     2 mc_cnt fixed bin unal,				/* number of M. C.'s that can be stored */
 14    13     2 hr_lim fixed bin unal,				/* end of history register storage */
 14    14     2 hr_nxtad fixed bin unal,			/* the nxt avail. location for history register storage */
 14    15     2 hr_strt fixed bin unal,				/* the beginning of the H. R. storage area */
 14    16     2 hr_cnt fixed bin unal,				/* number of H. R.'s that can be stored */
 14    17     2 pad (4) fixed bin,				/* pad to start of history register area */
 14    18     2 h_regs (hr_cnt),				/* array of history register blocks */
 14    19       3 ou_hr (16) bit (72),				/* operations unit history registers */
 14    20       3 cu_hr (16) bit (72),				/* control unit history registers */
 14    21       3 du_hr (16) bit (72),				/* decimal unit history registers */
 14    22       3 au_hr (16) bit (72),				/* appending unit history registers */
 14    23     2 mach_cond (mc_cnt),				/* array of machine conditions */
 14    24       3 spri_dta (8) ptr,				/* pointer register storage */
 14    25       3 sreg_dta (8) bit (36),			/* processor register storage */
 14    26       3 scu_dta (8) bit (36),				/* SCU data  storage */
 14    27       3 sw_dta (8) bit (36),				/* software data storage */
 14    28       3 spl_dta (8) bit (36);				/* EIS ptrs and lengths data */
 14    29 
 14    30 dcl  mc_size fixed bin int static options (constant) init (48); /* size of M. C. block in words */
 14    31 dcl  hr_size fixed bin int static options (constant) init (128); /* size of history register block */
 14    32 dcl  max_buf_size fixed bin int static options (constant) init (16); /* max size of M. C. buffer in K */
 14    33 dcl  buf_init bit (36) int static options (constant) init ("525252525252"b3); /* buffer init. constant */
 14    34 
 14    35 /* End include file mc_trace_buf.incl.pl1 */
 14    36 
     1845 
     1846 
 15     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
 15     2*coded February 8, 1972 by Michael J. Spier	*/
 15     3 /* modified May 26, 1972 by M. Weaver */
 15     4 /* modified 15 April, 1975 by M. Weaver */
 15     5 
 15     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
 15     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
 15     8 	2 textp pointer,			/* pointer to beginning of text section */
 15     9 	2 defp pointer,			/* pointer to beginning of definition section */
 15    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
 15    11 	2 statp pointer,			/* pointer to beginning of static section */
 15    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
 15    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
 15    14 	2 tlng fixed bin,			/* length in words of text section */
 15    15 	2 dlng fixed bin,			/* length in words of definition section */
 15    16 	2 llng fixed bin,			/* length in words of linkage section */
 15    17 	2 ilng fixed bin,			/* length in words of static section */
 15    18 	2 slng fixed bin,			/* length in words of symbol section */
 15    19 	2 blng fixed bin,			/* length in words of break map */
 15    20 	2 format,				/* word containing bit flags about object type */
 15    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
 15    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
 15    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
 15    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
 15    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
 15    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
 15    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
 15    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
 15    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
 15    30 	  3 pad bit(27) unaligned,
 15    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
 15    32 	2 textlinkp pointer,		/* ptr to first link in text */
 15    33 
 15    34 	/* LIMIT OF BRIEF STRUCTURE */
 15    35 
 15    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
 15    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
 15    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
 15    39 	2 cvers aligned,			/* generator version name in printable char string form */
 15    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
 15    41 	  3 length bit(18) unaligned,		/* length of name in characters */
 15    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
 15    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
 15    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
 15    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
 15    46 
 15    47 	/* LIMIT OF DISPLAY STRUCTURE */
 15    48 
 15    49 	2 rel_text pointer,			/* pointer to text section relocation info */
 15    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
 15    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
 15    52 	2 rel_static pointer,		/* pointer to static section relocation info */
 15    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
 15    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
 15    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
 15    56 					/* currently not used by system */
 15    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
 15    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
 15    59 
 15    60 declare	object_info_version_2 fixed bin int static init(2);
 15    61 
 15    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
     1847 
     1848 
 16     1 /*	BEGIN INCLUDE FILE ... pvt.incl.pl1 ... last modified January 1982 */
 16     2 
 16     3 
 16     4 /* The physical volume table (PVT) is a wired-down table.
 16     5*   It has one entry for each spindle present, be it for
 16     6*   Storage System or "I/O" use.
 16     7**/
 16     8 
 16     9      dcl	   pvt$		      ext,
 16    10 	   pvtp		      ptr;
 16    11 
 16    12 
 16    13      dcl	   1 pvt		      based (pvtp) aligned,
 16    14 
 16    15 	     2 n_entries	      fixed bin (17),	/* number of PVT entries */
 16    16 	     2 max_n_entries      fixed bin (17),	/* max number of PVT entries */
 16    17 	     2 n_in_use	      fixed bin (17),	/* number of PVT entries in use */
 16    18 	     2 rwun_pvtx	      fixed bin,		/* rewind_unloading pvtx */
 16    19 	     2 shutdown_state     fixed bin,		/* state of previous shutdown */
 16    20 	     2 esd_state	      fixed bin,		/* state of ESD, >0 iff in ESD */
 16    21 	     2 prev_shutdown_state fixed bin,		/* shutdown state of previous bootload */
 16    22 	     2 prev_esd_state     fixed bin,		/* ESD state of previous bootload */
 16    23 
 16    24 	     2 time_of_bootload fixed bin (71),		/* Time of bootload */
 16    25 	     2 root_lvid	      bit (36) aligned,	/* Logical volume ID of Root Logical Volume (RLV) */
 16    26 	     2 root_pvid	      bit (36) aligned,	/* Physical volume ID of Root Physical Volume (RPV) */
 16    27 	     2 root_pvtx	      fixed bin,		/* Index to PVTE for Root Physical Volume (RPV) */
 16    28 	     2 root_vtocx	      fixed bin,		/* VTOCE index for root (>) */
 16    29 	     2 disk_table_vtocx   fixed bin,		/* VTOCE index for disk table on RPV */
 16    30 	     2 disk_table_uid     bit (36) aligned,	/* File System UID for disk_table */
 16    31 
 16    32 	     2 rpvs_requested     bit (1) aligned,	/* RPVS keyword given on BOOT */
 16    33 	     2 rpv_needs_salv     bit (1) aligned,	/* RPV required (not requested) salvage */
 16    34 	     2 rlv_needs_salv     bit (1) aligned,	/* RLV required (not requested) salvage */
 16    35 	     2 volmap_lock_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
 16    36 	     2 volmap_idle_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
 16    37 	     2 vtoc_map_lock_wait_constant bit (36) aligned, /* For constructing wait event: OR pvte_rel into lower */
 16    38 	     2 n_volmap_locks_held fixed bin (17),	/* Current number of volmap locks held */
 16    39 	     2 n_vtoc_map_locks_held fixed bin (17),	/* Current number of VTOC Map locks held */
 16    40 
 16    41 	     2 last_volmap_time   fixed bin (71),	/* Time a volmap was last locked/unlocked */
 16    42 	     2 last_vtoc_map_time fixed bin (71),	/* Time a VTOC Map was last locked/unlocked */
 16    43 	     2 total_volmap_lock_time fixed bin (71),	/* Total time volmap's were locked (integral) */
 16    44 	     2 total_vtoc_map_lock_time fixed bin (71),	/* Total time VTOC Maps were locked (integral) */
 16    45 
 16    46 	     2 n_volmap_locks     fixed bin (35),	/* Number times a volmap was locked */
 16    47 	     2 n_vtoc_map_locks   fixed bin (35),	/* Number times a vtoc_map was locked */
 16    48 	     2 volmap_lock_nowait_calls fixed bin (35),	/* Number calls to lock volmap, no wait */
 16    49 	     2 volmap_lock_nowait_fails fixed bin (35),	/* Number times lock failed */
 16    50 	     2 volmap_lock_wait_calls fixed bin (35),	/* Number calls to lock volmap, wait */
 16    51 	     2 volmap_lock_wait_fails fixed bin (35),	/* Number times lock failed */
 16    52 	     2 pad (2) bit (36) aligned,
 16    53 
 16    54 	     2 array	      fixed bin (71);	/* Array of PVTE's -- must be double-word aligned */
 16    55 
 16    56 
 16    57 
 16    58 /*	END INCLUDE FILE ...pvt.incl.pl1 */
     1849 
     1850 
 17     1 /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 17     2 
 17     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
 17     4 
 17     5 /****^  HISTORY COMMENTS:
 17     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
 17     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
 17     8*     Add the support for subvolumes
 17     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
 17    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
 17    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
 17    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
 17    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
 17    14*     Added inconsistent_dbm bit for determining the status of volume
 17    15*     dumper bit maps.
 17    16*                                                   END HISTORY COMMENTS */
 17    17 
 17    18      dcl	   pvt$array	      aligned external;
 17    19      dcl	   pvt$max_n_entries      fixed bin external;
 17    20 
 17    21      dcl	   pvt_arrayp	      ptr;
 17    22      dcl	   pvtep		      ptr;
 17    23 
 17    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
 17    25 
 17    26      dcl	   1 pvte		      based (pvtep) aligned,
 17    27 
 17    28 	     2 pvid	      bit (36),		/* physical volume ID */
 17    29 
 17    30 	     2 lvid	      bit (36),		/* logical volume ID */
 17    31 
 17    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
 17    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
 17    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
 17    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
 17    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
 17    37 	     2 pad3	      bit (2) unaligned,
 17    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
 17    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
 17    40 
 17    41 
 17    42 
 17    43 	     2 devname	      char (4),		/* device name */
 17    44 
 17    45 	     (2 device_type	      fixed bin (8),	/* device type */
 17    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
 17    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
 17    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
 17    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
 17    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
 17    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
 17    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
 17    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
 17    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
 17    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
 17    56 	     2 scav_check_address
 17    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
 17    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
 17    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
 17    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
 17    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
 17    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
 17    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
 17    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
 17    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
 17    66 
 17    67 
 17    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
 17    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
 17    70 
 17    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
 17    72 
 17    73 	     2 nleft	      fixed bin (17),	/* number of records left */
 17    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
 17    75 
 17    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
 17    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
 17    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
 17    79 	     2 records_per_cyl    fixed bin,
 17    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
 17    81 	     2 sv_name            char (2) aligned,
 17    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
 17    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
 17    84 
 17    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
 17    86 	     2 pad2	      bit (18) unaligned,
 17    87 
 17    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
 17    89 
 17    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
 17    91 
 17    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
 17    93 
 17    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
 17    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
 17    96 
 17    97 
 17    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
 17    99 
 17   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
 17   101 
 17   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
 17   103 
 17   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
 17   105 
 17   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
 17   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
 17   108 
 17   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
 17   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
 17   111 
 17   112 
 17   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
 17   114 	   VOLMAP_ASYNC_READ      init (1),
 17   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
 17   116 
 17   117 
 17   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1851 
     1852 
 18     1 /* BEGIN INCLUDE FILE scs.incl.pl1 ... March 1983 */
 18     2 /* format: style4 */
 18     3 
 18     4 /* Information about system controllers */
 18     5 
 18     6 dcl  1 scs$controller_data (0:7) aligned ext,		/* per-controller info */
 18     7        2 size fixed bin (17) unaligned,			/* size (in 1024 word blocks) of this controller */
 18     8        2 base fixed bin (17) unaligned,			/* abs address (0 mod 1024) for base of this controller */
 18     9        2 eima_data (4) unaligned,			/* EIMA information for this controller */
 18    10          3 mask_available bit (1) unaligned,		/* ON if corresponding mask exists */
 18    11          3 mask_assigned bit (1) unaligned,		/* ON if mask assigned to a port */
 18    12          3 mbz bit (3) unaligned,
 18    13          3 mask_assignment fixed bin (3) unaligned,	/* port to which mask is assigned */
 18    14        2 info aligned,
 18    15          3 online bit (1) unaligned,			/* ON if controller is online */
 18    16          3 offline bit (1) unaligned,			/* ON if controller is offline but can be added */
 18    17          3 store_a_online bit (1) unaligned,		/* ON if store A is online */
 18    18          3 store_a1_online bit (1) unaligned,		/* ON if store A1 is online */
 18    19          3 store_b_online bit (1) unaligned,		/* ON if store B is online */
 18    20          3 store_b1_online bit (1) unaligned,		/* ON if store B1 is online */
 18    21          3 store_b_is_lower bit (1) unaligned,		/* ON if store B is lower */
 18    22          3 ext_interlaced bit (1) unaligned,		/* ON if this SCU is interlaced with other SCU */
 18    23          3 int_interlaced bit (1) unaligned,		/* ON if this SCU is internally interlaced */
 18    24          3 four_word bit (1) unaligned,			/* ON if external interlace is 4-word */
 18    25          3 cyclic_priority (7) bit (1) unaligned,		/* Cyclic priority for adjacent ports */
 18    26          3 type bit (4) unaligned,			/* Model number for this controller */
 18    27          3 abs_wired bit (1) unaligned,			/* ON if controller can have abs_wired pages */
 18    28          3 program bit (1) unaligned,			/* PROGRAM/MANUAL switch setting */
 18    29          3 mbz bit (13) unaligned,
 18    30        2 lower_store_size fixed bin (17) unaligned,	/* size (in 1024 word blocks) of lower store */
 18    31        2 upper_store_size fixed bin (17) unaligned;	/* size (in 1024 word blocks) of upper store */
 18    32 
 18    33 /* Information about CPUs */
 18    34 
 18    35 dcl  1 scs$processor_data (0:7) aligned ext,		/* information about CPUs in the system */
 18    36        (
 18    37        2 online bit (1),				/* "1"b if CPU is online */
 18    38        2 offline bit (1),				/* "1"b if CPU is offline but can be added */
 18    39        2 release_mask bit (1),			/* "1"b is this CPU is to give up its mask */
 18    40        2 accept_mask bit (1),				/* "1"b if this CPU is to grap mask in idle loop */
 18    41        2 delete_cpu bit (1),				/* "1"b if this CPU is to delete itself */
 18    42        2 interrupt_cpu bit (1),			/* "1"b if this CPU takes hardware interrupts */
 18    43        2 halted_cpu bit (1),				/* "1"b if this CPU has stopped itself (going to BOS) */
 18    44        2 cpu_type fixed bin (2) unsigned,		/*  0 => DPS or L68, 1 => DPS8 */
 18    45        2 mbz1 bit (6),
 18    46        2 cache_size fixed bin (3) unsigned,		/* 0 = No cache; 1 = L68 2K cache;
 18    47*						   2 = DPS8 8K cache; 3 = DPS8 VS&SC 8K cache;
 18    48*						   4 = DPS8 VS&SC 16K cache; 5 = DPS8 VS&SC 32K cache
 18    49*						   7 = ignore cache size (set by ISOLTS reconfig) */
 18    50        2 mbz2 bit (12),
 18    51        2 expanded_port bit (1),			/* "1"b = on expanded port */
 18    52        2 expander_port fixed bin (2) unsigned,		/* The actual expander port */
 18    53        2 controller_port fixed bin (3) unsigned
 18    54        ) unaligned;					/* Port on controller */
 18    55 
 18    56 dcl  1 scs$port_data (0:7) aligned external static,	/* Info about what is connected to each SCU port */
 18    57        2 assigned fixed bin (4) unsigned unaligned,	/* Type of device on this port		*/
 18    58        2 expander_port bit (1) unaligned,		/* "1"b => this port has a port expander */
 18    59        2 expanded_cpu (0:3) bit (1) unaligned,		/* "1"b => this expander port has a CPU attached */
 18    60        2 iom_number fixed bin (3) unsigned unaligned,	/* IOM number of IOM attached to this port */
 18    61        2 cpu_number (0:3) fixed bin (3) unsigned unaligned, /* CPU number of CPU(s) attached to this port */
 18    62 						/* cpu_number (0) is only one if expander_port is "0"b */
 18    63        2 pad bit (12) unaligned;
 18    64 
 18    65 dcl  1 scs$cow (0:7) aligned external,			/* Actual connect words */
 18    66        2 pad bit (36) aligned,			/* Expander COW's must be odd-word */
 18    67        2 cow,
 18    68          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
 18    69          3 mbz1 bit (13) unaligned,
 18    70          3 expander_command bit (3) unaligned,		/* Expander command. */
 18    71          3 mbz2 bit (2) unaligned,
 18    72          3 expanded_port bit (1) unaligned,		/* "1"b = on expanded port */
 18    73          3 expander_port fixed bin (3) unsigned unaligned,	/* Port on expander for cioc */
 18    74          3 mbz3 bit (3) unaligned,
 18    75          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
 18    76 
 18    77 dcl  1 scs$cow_ptrs (0:7) external aligned,		/* Pointers to COW's */
 18    78        2 rel_cow_ptr bit (18) unal,			/* Relative pointer to COW */
 18    79        2 pad bit (12) unal,
 18    80        2 tag bit (6) unal;				/* Better be zero. */
 18    81 
 18    82 dcl  1 scs$reconfig_general_cow aligned external,		/* Used during reconfig ops. */
 18    83        2 pad bit (36) aligned,
 18    84        2 cow,					/* Connect operand word, in odd location. */
 18    85          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
 18    86          3 mbz1 bit (13) unaligned,
 18    87          3 expander_command bit (3) unaligned,		/* Expander command. */
 18    88          3 mbz2 bit (9) unaligned,
 18    89          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
 18    90 
 18    91 /* MASKS and PATTERNS */
 18    92 
 18    93 dcl  scs$sys_level bit (72) aligned ext;		/* mask used while handling I/O interrupts */
 18    94 dcl  scs$open_level bit (72) aligned ext;		/* mask used during normal operation */
 18    95 dcl  scs$processor_start_mask bit (72) aligned ext;	/* mask used when starting up a CPU */
 18    96 dcl  scs$cpu_test_mask bit (72) aligned ext;		/* mask used for ISOLTS CPU testing */
 18    97 dcl  scs$number_of_masks fixed bin ext;			/* number of masks (starting at sys_level) */
 18    98 dcl  scs$processor_start_pattern bit (36) aligned ext;	/* SMIC pattern used to send processor start interrupt */
 18    99 dcl  scs$cpu_test_pattern bit (36) aligned ext;		/* SMIC pattern used for ISOLTS processor testing */
 18   100 
 18   101 /* CAM and CACHE clear info */
 18   102 
 18   103 dcl  scs$cam_pair fixed bin (71) ext;			/* instructions XEDd when CAMing and clearing CACHE */
 18   104 dcl  scs$cam_wait bit (8) aligned ext;			/* Used when evicting pages from main memory */
 18   105 
 18   106 /* MASKING INSTRUCTIONS & POINTERS */
 18   107 
 18   108 dcl  scs$set_mask (0:7) bit (36) aligned ext;		/* instructions to set mask (STAQ or SMCM) */
 18   109 dcl  scs$read_mask (0:7) bit (36) aligned ext;		/* instructions to read mask (LDAQ or RMCM) */
 18   110 dcl  scs$mask_ptr (0:7) ptr unaligned ext;		/* pointers for real or simulated masks */
 18   111 
 18   112 /* MISCELLANEOUS */
 18   113 
 18   114 dcl  1 scs$processor_test_data aligned ext,		/* info used for cpu testing */
 18   115        (
 18   116        2 active bit (1),				/* = "1"b if cpu currently under test */
 18   117        2 scu_state bit (2),				/* state of scu being used for testing (see definition below) */
 18   118        2 pad1 bit (4),
 18   119        2 req_mem fixed bin (10),			/* dedicated memory required to test this cpu */
 18   120        2 cpu_tag fixed bin (5),			/* tag of cpu under test */
 18   121        2 scu_tag fixed bin (5),			/* tag of scu being used for cpu testing */
 18   122        2 mask_cpu fixed bin (5)
 18   123        ) unaligned;					/* tag of active cpu that has mask asigned to above scu */
 18   124 
 18   125 /* scu_state = "00"b => SCU defined by scs$processor_test_data.scu_tag not yet effected */
 18   126 /* scu_state = "01"b => all core removed from SCU, port mask not yet changed */
 18   127 /* scu_state = "10"b => all core removed from SCU, port mask changed */
 18   128 /* scu_state = "11"b => only 64k at base of SCU being used for testing, original port mask restored */
 18   129 
 18   130 dcl  scs$idle_aptep (0:7) ptr unaligned ext;		/* pointer to idle process APTE for each processor */
 18   131 
 18   132 dcl  scs$connect_lock bit (36) aligned ext;		/* lock for sending connects */
 18   133 dcl  scs$reconfig_lock bit (36) aligned ext;		/* Lock used during reconfiguration */
 18   134 dcl  scs$trouble_flags bit (8) aligned ext;		/* checkoff flags for sys_trouble stopping */
 18   135 dcl  scs$bos_restart_flags bit (8) aligned ext;		/* checkoff flags for restarting after sys_trouble */
 18   136 dcl  scs$nprocessors fixed bin ext;			/* number of runnung processors */
 18   137 dcl  scs$bos_processor_tag fixed bin (3) ext;		/* CPU tag of processor running BOS */
 18   138 dcl  scs$faults_initialized bit (1) aligned ext;		/* ON after faults have been enabled */
 18   139 dcl  scs$sys_trouble_pending bit (1) aligned ext;		/* sys_trouble event is pending in the system */
 18   140 dcl  scs$fast_cam_pending (0:7) bit (36) aligned ext;	/* checkoff cells for cam connect		*/
 18   141 dcl  scs$interrupt_controller fixed bin (3) ext;		/* port number of low order controller */
 18   142 dcl  scs$processor_start_int_no fixed bin (5) ext;	/* interrupt cell for starting a processor */
 18   143 dcl  scs$processor bit (8) aligned ext;			/* bits ON for online CPUs */
 18   144 dcl  scs$processor_start_wait bit (8) aligned ext;	/* checkoff flags for waiting for new processor */
 18   145 
 18   146 dcl  scs$trouble_dbrs (0:7) fixed bin (71);		/* DBR values at system crash time */
 18   147 
 18   148 dcl  scs$port_addressing_word (0:7) bit (3) aligned ext;	/* active module port number for each controller */
 18   149 
 18   150 dcl  scs$cfg_data (0:7) fixed bin (71) aligned ext;	/* RSCR-CFG data from each controller */
 18   151 
 18   152 dcl  scs$cfg_data_save fixed bin (71) aligned ext;	/* RSCR-CFG save area for ISOLTS CPU testing */
 18   153 
 18   154 dcl  scs$expanded_ports bit (1) unaligned dim (0:7) external;
 18   155 						/* Which ports have expanders */
 18   156 
 18   157 dcl  scs$processor_switch_data (0:4) bit (36) aligned ext;	/* raw data from RSW 0 thru 4 */
 18   158 dcl  scs$processor_switch_template (0:4) bit (36) aligned ext; /* expected data from RSW 0 thru 4 */
 18   159 dcl  scs$processor_switch_compare (0:4) bit (36) aligned ext; /* discrepancies from expected data */
 18   160 dcl  scs$processor_switch_mask (0:4) bit (36) aligned ext;	/* masks for comparing switch data */
 18   161 
 18   162 dcl  scs$processor_data_switch_value bit (36) aligned ext;	/* Correct value for CPU data switches */
 18   163 
 18   164 dcl  scs$controller_config_size (0:7) fixed bin (14) aligned ext;
 18   165 						/* Controller size on config card */
 18   166 
 18   167 dcl  scs$reconfig_locker_id char (32) aligned ext;	/* process group ID of process doing reconfiguration */
 18   168 
 18   169 dcl  scs$scas_page_table (0:31) bit (36) aligned external static;
 18   170 						/* PTWs for SCAS pages */
 18   171 
 18   172 dcl  scs$cycle_priority_template bit (7) aligned ext;	/* template for setting anti-hog switches	*/
 18   173 dcl  scs$set_cycle_switches bit (1) aligned ext;		/* flag to set ant-hog switches		*/
 18   174 
 18   175 
 18   176 dcl  (
 18   177      IOM_PORT init (1),
 18   178      CPU_PORT init (2),
 18   179      BULK_PORT init (3)
 18   180      ) fixed bin int static options (constant);		/* values for scs$port_data.assigned		*/
 18   181 
 18   182 
 18   183 /* END INCLUDE FILE scs.incl.pl1 */
     1853 
     1854 
 19     1 /* BEGIN INCLUDE FILE slt.incl.pl1 --- Last modified 2/76 SHW */
 19     2 
 19     3 /* Declarations for Segment Loading Table header and array.
 19     4*
 19     5*   Used by Initialization and MST Checker subroutines */
 19     6 
 19     7 dcl sltp ptr,					/* pointer to base of SLT segment */
 19     8     names_ptr ptr,					/* pointer to base of SLT names segment */
 19     9     namep ptr,					/* pointer to segment name list block */
 19    10     pathp ptr,					/* pointer to segment's directory path name */
 19    11     aclp ptr;					/* pointer to acl structure */
 19    12 
 19    13 declare 1 slt based (sltp) aligned,			/* declaration of Segment Loading Table (SLT) */
 19    14 	2 name_seg_ptr ptr,				/* words 0-1, pointer (ITS pair) to name segment */
 19    15 	2 free_core_start fixed bin (24),		/* word 2, start of free core after perm-wired */
 19    16 	2 first_sup_seg fixed bin (18),		/* word 3, first supervisor segment number */
 19    17 	2 last_sup_seg fixed bin (18), 		/* word 4, last supervisor segment number */
 19    18 	2 first_init_seg fixed bin (18),		/* word 5, first initializer segment number */
 19    19 	2 last_init_seg fixed bin (18),		/* word 6, last initializer segment number */
 19    20 	2 free_core_size fixed bin (24),		/* size (in words) of free core after perm-wired */
 19    21 	2 seg (0:8191) aligned,			/* segment entries (4 words each) */
 19    22 	  3 slte (4) fixed bin (35);			/* Space for SLT entries */
 19    23 
 19    24 /* auxiliary segment of SLT for storing of segment names and directory path names */
 19    25 
 19    26 declare 1 name_seg based (names_ptr) aligned,		/* name segment header */
 19    27 	2 pad bit (18) unal,
 19    28 	2 next_loc bit (18) unal,			/* Next available free location in name seg */
 19    29 	2 ht (0:127) bit (18) aligned;		/* Names hash table */
 19    30 
 19    31 declare 1 segnam based (namep) aligned,			/* declaration for segment name block */
 19    32 	2 count fixed bin (17),			/* number of segment names in this block */
 19    33 	2 names (50 refer (segnam.count)),		/* segment name array */
 19    34 	  3 hp bit (18) unal,			/* hash thread pointer */
 19    35 	  3 ref bit (1) unal,			/* "1"b if name referenced */
 19    36 	  3 pad bit (5) unal,
 19    37 	  3 segno bit (12) unal,			/* segment number associated with this name */
 19    38 	  3 name char (32) unal;			/* space for name (max 32 characters) */
 19    39 
 19    40 declare 1 path based (pathp) aligned,			/* declaration for directory path name */
 19    41 	2 size fixed bin (17),			/* length of pathname */
 19    42 	2 name char (168 refer (path.size)) unal,	/* directory path name */
 19    43 	2 acls fixed bin;				/* ACL list starts here */
 19    44 
 19    45 declare 1 acls based (aclp) aligned,			/* declaration for acl list */
 19    46 	2 count fixed bin,				/* number of entries in acl list */
 19    47 	2 acl (50 refer (acls.count)),		/* array of acl entries */
 19    48 	  3 userid char (32),			/* user specification */
 19    49 	  3 mode bit (36) aligned,			/* mode for the specified user */
 19    50 	  3 pad bit (36) aligned,
 19    51 	  3 code fixed bin;
 19    52 
 19    53 
 19    54 /* END INCLUDE FILE slt.incl.pl1 */
     1855 
     1856 
 20     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
 20     2 
 20     3 /* format: off */
 20     4 
 20     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
 20     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
 20     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
 20     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
 20     9 
 20    10 
 20    11 /****^  HISTORY COMMENTS:
 20    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
 20    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
 20    14*     Modified to add constants for the translator_id field in the stack_frame
 20    15*     structure.
 20    16*                                                   END HISTORY COMMENTS */
 20    17 
 20    18 
 20    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
 20    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
 20    21 						/* with indicators (nonzero for Fortran hexfp caller) */
 20    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
 20    23 
 20    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
 20    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
 20    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
 20    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
 20    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
 20    29 
 20    30 
 20    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
 20    32 
 20    33 dcl  stack_frame_min_length fixed bin static init(48);
 20    34 
 20    35 
 20    36 dcl 1 stack_frame based(sp) aligned,
 20    37     2 pointer_registers(0 : 7) ptr,
 20    38     2 prev_sp pointer,
 20    39     2 next_sp pointer,
 20    40     2 return_ptr pointer,
 20    41     2 entry_ptr pointer,
 20    42     2 operator_and_lp_ptr ptr,			/* serves as both */
 20    43     2 arg_ptr pointer,
 20    44     2 static_ptr ptr unaligned,
 20    45     2 support_ptr ptr unal, /* only used by fortran I/O */
 20    46     2 on_unit_relp1 bit(18) unaligned,
 20    47     2 on_unit_relp2 bit(18) unaligned,
 20    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
 20    49*						   0 => PL/I version II
 20    50*						   1 => ALM
 20    51*						   2 => PL/I version I   
 20    52*						   3 => signal caller frame
 20    53*						   4 => signaller frame */
 20    54     2 operator_return_offset bit(18) unaligned,
 20    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
 20    56     2 a bit(36),					/* accumulator */
 20    57     2 q bit(36),					/* q-register */
 20    58     2 e bit(36),					/* exponent */
 20    59     2 timer bit(27) unaligned,				/* timer */
 20    60     2 pad bit(6) unaligned,
 20    61     2 ring_alarm_reg bit(3) unaligned;
 20    62 
 20    63 
 20    64 dcl 1 stack_frame_flags based(sp) aligned,
 20    65     2 pad(0 : 7) bit(72),				/* skip over prs */
 20    66     2 xx0 bit(22) unal,
 20    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
 20    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
 20    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
 20    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
 20    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
 20    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
 20    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
 20    74     2 condition bit(1) unal,				/* on if condition established in this frame */
 20    75     2 xx0a bit(6) unal,
 20    76     2 xx1 fixed bin,
 20    77     2 xx2 fixed bin,
 20    78     2 xx3 bit(25) unal,
 20    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
 20    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
 20    81     2 xx3a bit(9) unaligned,
 20    82     2 xx4(9) bit(72) aligned,
 20    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
 20    84*						*  operator puts a pointer to the base of
 20    85*						*  the calling procedure here. (text base ptr)  */
 20    86     2 xx5 bit(72) aligned,
 20    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
 20    88 
 20    89 /* format: on */
 20    90 
 20    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
     1857 
     1858 
 21     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
 21     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
 21     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
 21     4 /*	Modified April 1983 by C. Hornig for tasking */
 21     5 
 21     6 /****^  HISTORY COMMENTS:
 21     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
 21     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
 21     9*     added the heap_header_ptr definition.
 21    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
 21    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
 21    12*     Modified to support control point management.  These changes were actually
 21    13*     made in February 1985 by G. Palter.
 21    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
 21    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
 21    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
 21    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
 21    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
 21    19*     (ITS pair).
 21    20*                                                   END HISTORY COMMENTS */
 21    21 
 21    22 /* format: style2 */
 21    23 
 21    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
 21    25 
 21    26      dcl	   1 stack_header	      based (sb) aligned,
 21    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
 21    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
 21    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
 21    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
 21    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
 21    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
 21    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
 21    34 	     2 pad4	      bit (2) unal,
 21    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
 21    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
 21    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
 21    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
 21    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
 21    40 	     2 null_ptr	      ptr,		/*  (16)  */
 21    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
 21    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
 21    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
 21    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
 21    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
 21    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
 21    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
 21    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
 21    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
 21    50 	     2 return_no_pop_op_ptr
 21    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
 21    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
 21    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
 21    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
 21    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
 21    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
 21    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
 21    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
 21    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
 21    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
 21    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
 21    62 	     2 trace,
 21    63 	       3 frames,
 21    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
 21    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
 21    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
 21    67 	     2 pad2	      bit (36),		/*  (61) */
 21    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
 21    69 
 21    70 /*	The following offset refers to a table within the  pl1  operator table.  */
 21    71 
 21    72      dcl	   tv_offset	      fixed bin init (361) internal static;
 21    73 						/* (551) octal */
 21    74 
 21    75 
 21    76 /*	The following constants are offsets within this transfer vector table.  */
 21    77 
 21    78      dcl	   (
 21    79 	   call_offset	      fixed bin init (271),
 21    80 	   push_offset	      fixed bin init (272),
 21    81 	   return_offset	      fixed bin init (273),
 21    82 	   return_no_pop_offset   fixed bin init (274),
 21    83 	   entry_offset	      fixed bin init (275)
 21    84 	   )		      internal static;
 21    85 
 21    86 
 21    87 
 21    88 
 21    89 
 21    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
 21    91*	move the whole stack header should use this overlay.
 21    92**/
 21    93 
 21    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
 21    95 
 21    96 
 21    97 
 21    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
     1859 
     1860 
 22     1 /* BEGIN INCLUDE FILE  syserr_data.incl.pl1 */
 22     2 
 22     3 /* Created by  Bill Silver  on 01/03/73. */
 22     4 /* Modified September 1975 by Larry Johnson to add binary data */
 22     5 /* Modified March 1976 by Steve Webber for use with cds */
 22     6 /* Modified 1985-01-21 by EJ Sharpe: added wmess.process_id */
 22     7 /* Modified 1985-02-18 by Keith Loepere to break out headers. */
 22     8 
 22     9 /* This include file defines the syserr and log areas found in  syserr_data.cds
 22    10*   There is one lock that coordinates the use of all the data found in
 22    11*   syserr_data.cds.  NOTE, if this include file changes, syserr_data.cds
 22    12*   may also have to be changed. */
 22    13 
 22    14 dcl  syserr_data$syserr_area char (1) aligned external,
 22    15      syserr_data$wired_log_area char (1) aligned external;
 22    16 
 22    17 dcl  sd_ptr ptr,					/* Pointer to beginning of syserr_area. */
 22    18      wlog_ptr ptr,					/* Pointer to beginning of wired_log_area. */
 22    19      wmess_ptr ptr;					/* Pointer to a message entry in the wired log. */
 22    20 
 22    21 dcl 1 sd based (sd_ptr) aligned,			/* Overlay of syserr_data$syserr_area. */
 22    22     2 lock bit (36),				/* Locks all the data in syserr_data. */
 22    23     2 log_flag bit (1) unal,				/* ON => logging mechanism enabled. */
 22    24     2 char_type_flag bit (1) unal,			/* ON => ASCII,  OFF => BCD. */
 22    25     2 ocdcm_init_flag bit (1) unal,			/* ON => ocdcm_ has been initialized. */
 22    26     2 pad bit (33) unal,
 22    27     2 prev_text_written char (80);			/* Text of last message written */
 22    28 
 22    29 dcl 1 wlog based (wlog_ptr) aligned,			/* Overlay of syserr_data$wired_log_area. */
 22    30     2 head like wlog_header,				/* Wired log header. */
 22    31     2 buffer (wlog.head.bsize) bit (36);		/* Wired log buffer. */
 22    32 
 22    33 dcl 1 wlog_header based aligned,			/* WIRED LOG HEADER */
 22    34     2 bsize fixed bin,				/* Size of the wired log buffer in words.
 22    35*						   Defined in syserr_data.cds. */
 22    36     2 count fixed bin,				/* Num of message entries in wired log. */
 22    37     2 slog_ptr ptr,					/* Pointer to the paged log segment: syserr_log. */
 22    38     2 seq_num fixed bin (35),				/* Sequence number of last message logged. */
 22    39     2 next bit (18) unal,				/* Offset relative to base syserr_data */
 22    40 						/* Where next entry will go in wired log. */
 22    41     2 pad bit (18) unal;
 22    42 
 22    43 
 22    44 /* This is an overlay of a message entry that goes into the wired log.  Each message
 22    45*   entry corresponds to one syserr message. */
 22    46 
 22    47 dcl 1 wmess based (wmess_ptr) aligned,
 22    48     2 header aligned like wmess_header,
 22    49     2 text char (0 refer (wmess.text_len)),		/* Text of expanded message - kept in ASCII. */
 22    50     2 data (0 refer (wmess.data_size)) bit (36);		/* Binary data area */
 22    51 
 22    52 dcl 1 wmess_header based aligned,
 22    53     2 seq_num fixed bin (35),				/* Sequence number of this message. */
 22    54     2 time fixed bin (71) unal,			/* Time message logged at */
 22    55     2 code fixed bin (11) unal,			/* Syserr code associated with this message. */
 22    56     2 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
 22    57     2 data_size fixed bin (11) unal,			/* Size of binary data */
 22    58     2 data_code fixed bin (11) unal,			/* Data code */
 22    59     2 pad bit (24) unal,
 22    60     2 process_id bit (36);				/* ID of process which wrote message */
 22    61 
 22    62 /* END INCLUDE FILE syserr_data.incl.pl1 */
     1861 
     1862 
 23     1 /* BEGIN INCLUDE FILE ... log_message.incl.pl1 ... 84-04-25 ... W. Olin Sibert */
 23     2 
 23     3 declare 1 log_message_header  aligned based,                /* Items marked "(SET)" are set by $create_message */
 23     4           2 sentinel          bit (36) aligned,             /* Proper value declared in log_segment.incl.pl1 */
 23     5           2 sequence          fixed bin (35),               /* Sequence number for this message (SET) */
 23     6           2 severity          fixed bin (8) unaligned,      /* Severity of message */
 23     7           2 data_class_lth    fixed bin (9) unaligned unsigned, /* Length of data class-- 0 to 16 (SET) */
 23     8           2 time              fixed bin (53) unaligned,     /* Time message originated */
 23     9           2 text_lth          fixed bin (17) unaligned,     /* Length of message text. Must be nonzero (SET) */
 23    10           2 data_lth          fixed bin (17) unaligned,     /* Length of binary data. May be zero (SET) */
 23    11           2 process_id        bit (36) aligned;             /* Process id of process writing message */
 23    12 
 23    13 declare 1 log_message         aligned based (log_message_ptr),
 23    14           2 header            aligned like log_message_header,
 23    15           2 text              char (log_message_text_lth         refer (log_message.text_lth)) unaligned,
 23    16           2 data_class        char (log_message_data_class_lth   refer (log_message.data_class_lth)) unaligned,
 23    17           2 data              dim (log_message_data_lth          refer (log_message.data_lth)) bit (36) aligned;
 23    18 
 23    19 declare   log_message_ptr pointer;
 23    20 declare   log_message_text_lth fixed bin;
 23    21 declare   log_message_data_class_lth fixed bin;
 23    22 declare   log_message_data_lth fixed bin;
 23    23 
 23    24 /* END INCLUDE FILE ... log_message.incl.pl1 */
     1863 
     1864  
 24     1 /* BEGIN INCLUDE FILE ... log_segment.incl.pl1 ... 84-05-03 ... W. Olin Sibert */
 24     2 
 24     3 declare   log_segment_ptr               pointer;
 24     4 declare   log_segment_max_size          fixed bin (18);
 24     5 declare   LOG_SEGMENT_VERSION_1         char (8) internal static options (constant) init ("SysLog01");
 24     6 
 24     7 
 24     8 declare 1 log_segment                   aligned based (log_segment_ptr),
 24     9           2 header                      aligned like log_segment_header,
 24    10           2 data                        dim (log_segment_max_size refer (log_segment.max_size)) bit (36) aligned;
 24    11 
 24    12 
 24    13 declare 1 log_segment_header            aligned based,
 24    14           2 version                     char (8) unaligned, /* LOG_SEGMENT_VERSION_1 */
 24    15           2 time_created                fixed bin (71),     /* When the segment header was initialized */
 24    16           2 previous_log_dir            char (168) unaligned, /* Directory containing previous log segment */
 24    17 
 24    18           2 limits,
 24    19             3 first_sequence            fixed bin (35),     /* First and last sequence numbers / time stamps */
 24    20             3 last_sequence             fixed bin (35),     /* of messages in the log. These may be slightly */
 24    21             3 first_time                fixed bin (71),     /* incorrect due to lockless updating strategy */
 24    22             3 last_time                 fixed bin (71),
 24    23 
 24    24           2 alloc_info,                                     /* Complex STACQ hack for allocating and assigning */
 24    25             3 word_1                    fixed bin (18),     /* sequence numbers locklessly. See log_segment_ */
 24    26             3 word_2                    bit (36) aligned,   /* for details of strategy */
 24    27           2 max_size                    fixed bin (18),     /* Total words in data area */
 24    28 
 24    29           2 listeners_registered        bit (1) aligned,    /* Set if ANY processes were ever registered-- it's only */
 24    30           2 listener_bootload_time      fixed bin (71),     /* kept here for efficiency. The bootload time is used to */
 24    31                                                             /* detect all the dead listeners after a reboot */
 24    32           2 listener (25),                                  /* Processes waiting for messages in the log */
 24    33             3 process_id                bit (36) aligned,
 24    34             3 event_channel             fixed bin (71) unaligned, /* Saves space-- allows 3-word entries */
 24    35 
 24    36           2 last_wakeup_time            fixed bin (71),     /* When last wakeup was sent */
 24    37           2 wakeup_delta                fixed bin (71),     /* Wakeups sent no more than once per this interval */
 24    38 
 24    39           2 pad (6)                     fixed bin (71);     /* Pad header to 150 words */
 24    40 
 24    41 
 24    42 declare   LOG_SEGMENT_NEW_MESSAGE           init ("777111555333"b3) bit (36) aligned internal static options (constant);
 24    43 declare   LOG_SEGMENT_COMPLETE_MESSAGE      init ("666000444222"b3) bit (36) aligned internal static options (constant);
 24    44 
 24    45 /* END INCLUDE FILE ... log_segment.incl.pl1 */
     1865 
     1866 
     1867      end azm_display_fdump_events;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/08/88  1115.1  azm_display_fdump_events.pl1      >special_ldd>install>MR12.2-1080>azm_display_fdump_events.pl1
1821         1    09/22/83  1102.5  amu_fdump_info.incl.pl1           >ldd>include>amu_fdump_info.incl.pl1
1823         2    11/20/84  0854.8  amu_hardcore_info.incl.pl1        >ldd>include>amu_hardcore_info.incl.pl1
1825         3    11/20/84  0856.1  amu_info.incl.pl1                 >ldd>include>amu_info.incl.pl1
1827         4    07/28/87  0943.5  amu_translation.incl.pl1          >ldd>include>amu_translation.incl.pl1
1829         5    01/06/85  1422.2  apte.incl.pl1                     >ldd>include>apte.incl.pl1
1831         6    09/18/74  1700.9  bind_map.incl.pl1                 >ldd>include>bind_map.incl.pl1
1833         7    08/12/81  2025.8  bos_dump.incl.pl1                 >ldd>include>bos_dump.incl.pl1
1835         8    08/08/88  1111.3  dskdcl.incl.pl1                   >special_ldd>install>MR12.2-1080>dskdcl.incl.pl1
1837         9    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
9-142       10    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
1839        11    04/11/85  1452.4  iom_data.incl.pl1                 >ldd>include>iom_data.incl.pl1
1841        12    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
1843        13    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
1845        14    08/18/77  0953.5  mc_trace_buf.incl.pl1             >ldd>include>mc_trace_buf.incl.pl1
1847        15    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
1849        16    05/27/82  1525.8  pvt.incl.pl1                      >ldd>include>pvt.incl.pl1
1851        17    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
1853        18    10/12/83  0943.5  scs.incl.pl1                      >ldd>include>scs.incl.pl1
1855        19    05/24/82  1005.0  slt.incl.pl1                      >ldd>include>slt.incl.pl1
1857        20    11/07/86  1550.3  stack_frame.incl.pl1              >ldd>include>stack_frame.incl.pl1
1859        21    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
1861        22    03/08/85  0852.7  syserr_data.incl.pl1              >ldd>include>syserr_data.incl.pl1
1863        23    01/21/85  0912.2  log_message.incl.pl1              >ldd>include>log_message.incl.pl1
1865        24    12/04/84  2124.9  log_segment.incl.pl1              >ldd>include>log_segment.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CPU_TAG                         000632 constant        char(8)                  initial packed unaligned dcl 184 ref 723 723 1000
DISK_IO_TYPE                    000407 constant        char(7)                  initial array packed unaligned dcl 768 set ref 799*
DOM                             000201 automatic       picture(2)               packed unaligned dcl 119 set ref 465* 471
EMPTY                                  constant        fixed bin(17,0)          initial dcl 1476 ref 1510
FAULT_MASKS                     000264 constant        bit(21)                  initial array dcl 981 ref 1006
FAULT_MASK_INDEX                000271 constant        fixed bin(17,0)          initial array dcl 980 ref 1005 1006 1008
FAULT_SUB_TYPES                 000060 constant        char(5)                  initial array packed unaligned dcl 987 ref 1008
FAULT_TSR_VALID                 000331 constant        bit(32)                  initial packed unaligned dcl 978 ref 1004
FAULT_TYPES                     000332 constant        char(4)                  initial array packed unaligned dcl 974 ref 1003
HR                              000243 automatic       picture(2)               packed unaligned dcl 133 set ref 467* 471
IOM_TAG                         000630 constant        char(4)                  initial packed unaligned dcl 185 ref 746 746 1023
ITS_MODIFIER                           constant        bit(6)                   initial packed unaligned dcl 12-55 ref 1635 1796
LINE_MAX_LENGTH                        constant        fixed bin(17,0)          initial dcl 898 ref 909 910
MC_TRACE_BUF                           constant        fixed bin(17,0)          initial dcl 188 ref 375 380 1272 1273
MICSEC                          000256 automatic       picture(6)               packed unaligned dcl 149 set ref 470* 472* 479* 481*
MIN                             000261 automatic       picture(2)               packed unaligned dcl 151 set ref 468* 471
MON                             000263 automatic       picture(2)               packed unaligned dcl 153 set ref 464* 471
MYNAME                          000622 constant        char(24)                 initial packed unaligned dcl 186 set ref 317* 331*
                                                                                  394* 564* 1222* 1248* 1262* 1269* 1308* 1321*
                                                                                  1364* 1406* 1487* 1494* 1504* 1562* 1596*
N_INTERESTING_SEGS                     constant        fixed bin(17,0)          initial dcl 187 ref 134 134 134 189 325 386
P_amu_info_ptr                         parameter       pointer                  dcl 92 ref 45 299
P_sci_ptr                              parameter       pointer                  dcl 93 ref 45 300
SEC                             000277 automatic       picture(2)               packed unaligned dcl 162 set ref 469* 472* 481*
SR_IOA_STRING                   000372 constant        char(50)                 initial packed unaligned dcl 973 set ref 1037* 1049*
STATE_NAMES                     000424 constant        char(10)                 initial array packed unaligned dcl 707 ref 712 714
TEXT_MAX_LENGTH                        constant        fixed bin(17,0)          initial dcl 899 ref 904
WAITING                                constant        fixed bin(17,0)          initial dcl 709 ref 723
YR                              000342 automatic       picture(2)               packed unaligned dcl 179 set ref 466* 471
a_mc_ptr                               parameter       pointer                  dcl 1585 set ref 1582 1604* 1606*
a_scu_ptr                              parameter       pointer                  dcl 1586 set ref 1582 1603* 1608*
added_info                             parameter       char                     packed unaligned dcl 700 in procedure "print_apte"
                                                                                  ref 696
added_info                             parameter       char                     packed unaligned dcl 927 in procedure
                                                                                  "print_wired_syserr" ref 924
added_info                             parameter       char                     packed unaligned dcl 740 in procedure
                                                                                  "print_device_data" ref 737
added_info                             parameter       char                     packed unaligned dcl 835 in procedure "print_mc" set
                                                                                  ref 831 844*
added_info               16            based           char(40)                 array level 3 in structure "time_stamped_events"
                                                                                  packed packed unaligned dcl 202 in procedure
                                                                                  "azm_display_fdump_events" set ref 502* 539*
added_info                             parameter       char                     packed unaligned dcl 854 in procedure
                                                                                  "print_syserr_log" ref 851
added_info                             parameter       char                     packed unaligned dcl 817 in procedure
                                                                                  "print_dump_mc" set ref 813 822*
addr                                                   builtin function         dcl 269 ref 301 364 364 377 683 781 782 865 865 941
                                                                                  1082 1092 1092 1092 1092 1125 1126 1128 1128 1178
                                                                                  1178 1368 1603 1603 1631 1633 1635 1723 1726 1726
                                                                                  1759 1762 1762 1795
addrel                                                 builtin function         dcl 269 ref 642 1376 1485 1492 1502 1518 1719 1722
                                                                                  1744 1754 1758
amu_$definition_offset          000010 constant        entry                    external dcl 238 ref 1220 1246 1260 1267 1306 1318
                                                                                  1362 1485 1492 1502 1560 1594
amu_$do_translation             000012 constant        entry                    external dcl 239 ref 664
amu_$error_for_caller           000014 constant        entry                    external dcl 240 ref 331 394 1222 1248 1262 1269
                                                                                  1308 1321 1364 1406 1487 1494 1504 1562 1596
amu_$fdump_mpt_revert_idx       000020 constant        entry                    external dcl 242 ref 666
amu_$fdump_mpt_temp_change_idx  000016 constant        entry                    external dcl 241 ref 369 662
amu_$fdump_translate_get_translation
                                000062 constant        entry                    external dcl 678 ref 684
amu_$get_name                   000022 constant        entry                    external dcl 243 ref 1034 1046
amu_$hardcore_info_set_cur_ptrs 000024 constant        entry                    external dcl 244 ref 302
amu_$return_val_per_process     000026 constant        entry                    external dcl 245 ref 660
amu_$slt_search_seg_ptr         000030 constant        entry                    external dcl 246 ref 327 337 1150 1404
amu_$translate_get              000060 constant        entry                    external dcl 677 ref 680
amu_area                               based           area(1024)               dcl 3-43 ref 1693 1739 1775 1777
amu_info                               based           structure                level 1 dcl 3-3
amu_info_ptr                    000356 automatic       pointer                  dcl 3-45 set ref 299* 302* 303 368 369* 377 660*
                                                                                  662* 662 662 664* 666* 680* 684* 1034* 1046* 1220*
                                                                                  1246* 1260* 1267* 1306* 1318* 1362* 1485* 1492*
                                                                                  1502* 1560* 1594* 1693 1739 1775 1777
apt_array                              based           structure                level 1 dcl 215
apt_array_p                     000156 automatic       pointer                  dcl 110 set ref 352* 353 491 492 495 1228 1228 1229
                                                                                  1229 1230 1230
apt_desc                  1            based           structure                array level 2 dcl 215
apt_inx                         000160 automatic       fixed bin(17,0)          dcl 111 set ref 490* 491 492 495 497* 497
apt_proc_found                  000161 automatic       bit(1)                   packed unaligned dcl 112 set ref 489* 491 494*
apte                                   based           structure                level 1 dcl 5-7
apte_offset              15            based           bit(18)                  array level 3 in structure "time_stamped_events"
                                                                                  dcl 202 in procedure "azm_display_fdump_events"
                                                                                  set ref 488 492 541*
apte_offset                     000112 automatic       bit(18)                  packed unaligned dcl 1297 in procedure
                                                                                  "process_prds" set ref 1323* 1325* 1332*
apte_offset                            parameter       bit(18)                  packed unaligned dcl 531 in procedure "add_an_event"
                                                                                  ref 522 541
aptep                           000362 automatic       pointer                  dcl 5-5 set ref 711* 712 714 717 723 723 723 723
                                                                                  1502* 1507 1510 1510 1512 1514 1514* 1518* 1518
aptp                            000102 automatic       pointer                  dcl 1200 set ref 1220* 1225 1226 1229
aptx                            000100 automatic       fixed bin(17,0)          dcl 1468 set ref 1509*
area_ptr                 10            based           pointer                  level 2 dcl 3-3 ref 1693 1739 1775 1777
array                    50            based           fixed bin(71,0)          level 2 in structure "pvt" dcl 16-13 in procedure
                                                                                  "azm_display_fdump_events" set ref 781
array                    11            based           structure                array level 2 in structure "disk_data" dcl 8-31
                                                                                  in procedure "azm_display_fdump_events"
array                     1            based           structure                array level 2 in structure "fdump_process_table"
                                                                                  dcl 1-23 in procedure "azm_display_fdump_events"
                                                                                  set ref 368 377 662 662
based_fixed                            based           fixed bin(35,0)          dcl 1477 ref 1490 1498
based_flag                             based           fixed bin(35,0)          dcl 1211 ref 1266
based_move                             based           fixed bin(35,0)          array dcl 633 set ref 643* 643
based_ptr                              based           pointer                  dcl 1299 in procedure "process_prds" ref 1325
based_ptr                              based           pointer                  dcl 1212 in procedure "process_pds" ref 1226 1229
based_ptr_packed                       based           pointer                  packed unaligned dcl 1213 ref 1273
baseno                                                 builtin function         dcl 269 ref 329 1152 1152 1253 1273 1412 1626 1637
                                                                                  1798
baseptr                                                builtin function         dcl 269 ref 684 684 1034 1034 1046 1046
bin                                                    builtin function         dcl 269 ref 329 364 364 379 639 712 714 723 723 723
                                                                                  1000 1002 1015 1034 1034 1034 1034 1037 1037 1037
                                                                                  1037 1046 1046 1046 1046 1049 1049 1049 1049 1087
                                                                                  1088 1127 1127 1130 1130 1152 1152 1238 1238 1253
                                                                                  1273 1332 1332 1412 1510 1637 1637 1637 1637 1637
                                                                                  1637 1727 1727 1763 1763
bit_offset                1(21)        based           bit(6)                   level 2 packed packed unaligned dcl 12-5 ref 1633
bmp                             000162 automatic       pointer                  initial dcl 113 set ref 113*
bound_interceptors_ptr          000164 automatic       pointer                  dcl 114 set ref 337* 339* 1794 1798
bp                              000102 automatic       pointer                  dcl 1469 in procedure "process_tc_data" set ref
                                                                                  1485* 1489 1490 1492* 1497 1498
bp                              000402 automatic       pointer                  dcl 14-6 in procedure "azm_display_fdump_events" set
                                                                                  ref 1122* 1124 1125 1125
bpp                             000114 automatic       pointer                  dcl 1298 in procedure "process_prds" set ref 1318*
                                                                                  1323 1325
bpp                             000104 automatic       pointer                  dcl 1201 in procedure "process_pds" set ref 1260*
                                                                                  1265 1266 1267* 1271 1273
buffer                    6            based           bit(36)                  array level 2 dcl 22-29 set ref 1368
ca                        5            based           bit(18)                  level 2 packed packed unaligned dcl 13-56 ref 1046
                                                                                  1046 1049 1049
channel                  21            based           fixed bin(6,0)           level 2 unsigned dcl 744 set ref 746*
channel_mailbox                        based           structure                level 1 dcl 11-98
chantab                                based           structure                level 1 dcl 8-132
cleanup                         000344 stack reference condition                dcl 264 ref 313
clock                                                  builtin function         dcl 269 ref 345
code                      3            based           fixed bin(11,0)          level 3 in structure "wmess" packed packed unaligned
                                                                                  dcl 22-47 in procedure "azm_display_fdump_events"
                                                                                  ref 939
code                            000460 automatic       fixed bin(35,0)          dcl 1392 in procedure "process_syserr_log" set ref
                                                                                  1404* 1405 1406* 1417* 1419 1424* 1425 1428* 1430
code                                   parameter       fixed bin(35,0)          dcl 102 in procedure "azm_display_fdump_events" set
                                                                                  ref 45 327* 329 331* 337* 339 393 394* 406 461*
                                                                                  463 611* 680* 684* 686 1073* 1074 1117* 1118 1169*
                                                                                  1170 1217* 1218 1220* 1221 1222* 1246* 1247 1248*
                                                                                  1260* 1261 1262* 1267* 1268 1269* 1303* 1304 1306*
                                                                                  1307 1308* 1318* 1320 1321* 1355* 1356 1362* 1363
                                                                                  1364* 1485* 1486 1487* 1492* 1493 1494* 1502* 1503
                                                                                  1504* 1554* 1555 1560* 1561 1562* 1594* 1595 1596*
                                                                                  1685* 1779*
code                            000100 automatic       fixed bin(35,0)          dcl 1146 in procedure "process_inzr_stk0" set ref
                                                                                  1150* 1151
connect_time            300            based           fixed bin(71,0)          array level 3 dcl 11-17 set ref 1179*
convert                                                builtin function         dcl 269 ref 786
coreadd                   2     000106 automatic       fixed bin(25,0)          level 2 in structure "diskq_temp" dcl 1068
                                                                                  in procedure "process_disk_queue" set ref 1087*
coreadd                   2            based           fixed bin(25,0)          level 2 in structure "diskq_data" dcl 223
                                                                                  in procedure "azm_display_fdump_events" set ref
                                                                                  799*
coreadd                   1(12)        based           bit(24)                  level 2 in structure "quentry" packed packed
                                                                                  unaligned dcl 8-107 in procedure
                                                                                  "azm_display_fdump_events" ref 1087
count                     1            based           fixed bin(17,0)          level 3 dcl 22-29 ref 1370 1372
cpu_alph                        000100 automatic       char(1)                  packed unaligned dcl 959 set ref 1000* 1028*
cpu_no                    2(27)        based           bit(3)                   level 2 packed packed unaligned dcl 13-56 ref 1000
cur_date_time                   000166 automatic       char(17)                 packed unaligned dcl 115 set ref 471* 472 472* 478
currentsize                                            builtin function         dcl 269 ref 1451 1451
cylinder                  4            based           fixed bin(17,0)          level 2 in structure "diskq_data" dcl 223
                                                                                  in procedure "azm_display_fdump_events" ref 792
                                                                                  792
cylinder                  2(25)        based           fixed bin(11,0)          level 2 in structure "quentry" packed packed
                                                                                  unsigned unaligned dcl 8-107 in procedure
                                                                                  "azm_display_fdump_events" ref 1089
cylinder                  4     000106 automatic       fixed bin(17,0)          level 2 in structure "diskq_temp" dcl 1068
                                                                                  in procedure "process_disk_queue" set ref 1089*
d1_len                          000117 automatic       fixed bin(21,0)          dcl 1663 set ref 1695* 1698 1742* 1743 1744
d2_len                          000120 automatic       fixed bin(21,0)          dcl 1663 set ref 1696* 1698 1743* 1744
d3_len                          000121 automatic       fixed bin(21,0)          dcl 1663 set ref 1697* 1698 1741* 1743 1744
data1                                  based           char                     packed unaligned dcl 1660 ref 1698 1744
data2                                  based           char                     packed unaligned dcl 1661 ref 1698 1744
data3                                  based           char                     packed unaligned dcl 1662 set ref 1698* 1744*
data_class_lth            2(09)        based           fixed bin(9,0)           level 3 packed packed unsigned unaligned dcl 23-13
                                                                                  ref 1451 1451
data_lth                  4(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 23-13 ref 1451
                                                                                  1451
data_ptr                               parameter       pointer                  dcl 655 set ref 650 664*
data_size                 3(24)        based           fixed bin(11,0)          level 3 packed packed unaligned dcl 22-47 ref 1373
                                                                                  1373 1376
decode_clock_value_$date_time   000054 constant        entry                    external dcl 258 ref 461
definitions_ptr                 000174 automatic       pointer                  dcl 116 set ref 306*
defp                      4            based           pointer                  level 2 dcl 2-40 ref 306
delete_duplicate                       parameter       bit(1)                   dcl 530 ref 522 543
delete_on_duplicate_time
                          4            based           bit(1)                   array level 3 dcl 202 set ref 438 440 543*
deleted                   5            based           bit(1)                   array level 3 dcl 202 set ref 438* 440* 459 542*
delta_time                             parameter       fixed bin(71,0)          dcl 95 ref 45 358 359
dev_no                          000102 automatic       fixed bin(17,0)          dcl 1165 set ref 1176* 1178 1178 1179*
dev_num                         000101 automatic       char(2)                  packed unaligned dcl 762 set ref 776* 786* 799*
device_type               4            based           fixed bin(8,0)           level 2 packed packed unaligned dcl 17-26 ref 791
devname                   3            based           char(4)                  level 2 dcl 17-26 ref 783 784
devtab                                 based           structure                level 1 dcl 8-190
disk_data                              based           structure                level 1 dcl 8-31
disk_lock_meters                       based           structure                level 1 dcl 8-236
disk_seg_ptr                    000100 automatic       pointer                  dcl 1063 set ref 1075* 1076
diskadd                         000102 automatic       fixed bin(17,0)          dcl 763 set ref 778* 788* 792* 799*
diskq_data                             based           structure                level 1 dcl 223
diskq_datap                     000176 automatic       pointer                  dcl 117 set ref 772* 773 778 782 788 792 792 792 799
                                                                                  799
diskq_temp                      000106 automatic       structure                level 1 dcl 1068 set ref 1092 1092 1092 1092 1092
                                                                                  1092 1092 1092
disksp                          000366 automatic       pointer                  dcl 8-26 set ref 1076* 1077 1081 1082
divide                                                 builtin function         dcl 269 ref 636 792 1016 1373 1373 1376
dlength                                parameter       fixed bin(18,0)          dcl 627 ref 622 636
dom                             000200 automatic       fixed bin(17,0)          dcl 118 set ref 461* 465
dow                             000202 automatic       fixed bin(17,0)          dcl 120 set ref 461*
dptr                                   parameter       pointer                  dcl 626 ref 622 643
dq_data_ptr                            parameter       pointer                  dcl 759 ref 755 772
dump                                   based           structure                level 1 dcl 7-11
dump_header                            based           structure                level 1 dcl 7-47
dump_misc_registers                    based           structure                level 1 dcl 7-69
dump_ptrs                       000204 automatic       pointer                  dcl 121 set ref 303*
dump_registers                         based           structure                level 1 dcl 7-59
dump_seg_ptr            106            based           pointer                  array level 2 dcl 1-3 ref 303
dump_seginx                     000206 automatic       fixed bin(17,0)          dcl 122 set ref 378* 379 394*
dump_segno                      000207 automatic       fixed bin(17,0)          dcl 123 set ref 379* 380 387 403 405* 611* 1073*
                                                                                  1117* 1127* 1169* 1217* 1303* 1355* 1554*
dumpptr                         000364 automatic       pointer                  dcl 7-9 set ref 303* 359 364 364 364 364 379
eadded_info                            parameter       char                     packed unaligned dcl 529 ref 522 539
earliest_recorded_time          000210 automatic       fixed bin(71,0)          dcl 124 set ref 345* 417* 418* 545 545*
earliest_time                   000212 automatic       fixed bin(71,0)          dcl 125 set ref 358* 359* 534 1083
ecode                                  parameter       fixed bin(35,0)          dcl 654 set ref 650 664*
eptr                                   parameter       pointer                  dcl 527 ref 522 537
eroutine                               parameter       entry variable           dcl 528 ref 522 538
etime                                  parameter       fixed bin(71,0)          dcl 526 ref 522 534 536 545 545 545
event_display            10            based           entry variable           array level 3 dcl 202 set ref 502 538*
event_inx                       000214 automatic       fixed bin(17,0)          dcl 126 set ref 458* 459 461 486 488 492 502 502
                                                                                  502*
event_struct_ptr          6            based           pointer                  array level 3 dcl 202 set ref 502* 537*
events                    2            based           structure                array level 2 dcl 202
events_by_time                  000215 automatic       bit(1)                   packed unaligned dcl 127 set ref 347* 350* 357 455
                                                                                  534 545 1083 1083
events_printed                  000216 automatic       fixed bin(17,0)          dcl 128 set ref 454* 458 460* 460 1816* 1816
eventsp                         000220 automatic       pointer                  dcl 129 set ref 309* 319* 362 426 430 431 432 432
                                                                                  437 437 438 438 440 440 455 456 458 459 461 486
                                                                                  488 492 502 502 502 535 535 536 536 537 537 538
                                                                                  538 539 539 540 540 541 541 542 542 543 543
exp_seg_name                    000136 automatic       varying char(256)        dcl 969 set ref 997* 1034* 1036 1037* 1046* 1048
                                                                                  1049*
fault_no                        000101 automatic       fixed bin(17,0)          dcl 960 set ref 1002* 1003 1004 1005 1006 1008
fault_sub_type                  000102 automatic       bit(36)                  packed unaligned dcl 961 set ref 1006* 1007
fault_tag_1                     000152 stack reference condition                dcl 1675 ref 1682 1772
fault_time               46(18)        based           bit(54)                  level 2 packed packed unaligned dcl 13-12 ref 1130
                                                                                  1130 1238 1238 1332 1332 1727 1727 1763 1763
fd                        1            based           structure                level 2 packed packed unaligned dcl 13-56 ref 1006
fdump_info                             based           structure                level 1 dcl 1-3
fdump_info_ptr           14            based           pointer                  level 2 dcl 3-3 ref 303 368 377 662 662
fdump_process_table                    based           structure                level 1 dcl 1-23
fdump_process_table_ptr
                        246            based           pointer                  level 2 dcl 1-3 ref 368 377 662 662
fi_flag                   1(35)        based           bit(1)                   level 2 packed packed unaligned dcl 13-56 ref 1001
fi_num                    1(30)        based           bit(5)                   level 2 packed packed unaligned dcl 13-56 ref 1002
                                                                                  1015
first_print                     000222 automatic       bit(1)                   packed unaligned dcl 130 set ref 451* 474 476*
first_seg                              based           fixed bin(17,0)          level 2 dcl 1-28 ref 378
first_time                      000466 automatic       bit(1)                   dcl 1396 set ref 1437* 1439 1440*
fixed                                                  builtin function         dcl 269 ref 717 717 1250 1484 1512 1643
fixed_apte                      000112 automatic       fixed bin(35,0)          dcl 1475 set ref 1512* 1513
flags                     1            based           structure                level 2 in structure "apte" packed packed unaligned
                                                                                  dcl 5-7 in procedure "azm_display_fdump_events"
flags                     0(18)        based           structure                level 2 in structure "translation" packed packed
                                                                                  unaligned dcl 4-24 in procedure
                                                                                  "azm_display_fdump_events"
flags2                   21(18)        based           structure                level 2 packed packed unaligned dcl 5-7
fm_scup                         000124 automatic       pointer                  dcl 1665 set ref 1726* 1727* 1762* 1763*
fp_table                               based           structure                level 1 unaligned dcl 1-28
fp_table_ptr                    000352 automatic       pointer                  dcl 1-38 set ref 377* 378 378
free_q_entries          152            based           structure                array level 2 dcl 8-31 set ref 1082
free_q_size              10            based           fixed bin(17,0)          level 2 dcl 8-31 ref 1081
fsx                             000103 automatic       fixed bin(17,0)          dcl 764 set ref 791* 792 792 792
good_match                      000100 automatic       bit(1)                   packed unaligned dcl 97 set ref 312* 1809 1814* 1815
handler                   2     000244 automatic       entry variable           initial array level 2 dcl 134 set ref 134* 134* 134*
                                                                                  134* 134* 134* 134* 134* 134* 134* 392
hard_ptr_space                  000224 automatic       structure                level 1 unaligned dcl 131 set ref 301
hardcore_cur                           based           structure                level 1 unaligned dcl 2-40
hardcore_cur_ptr                000354 automatic       pointer                  dcl 2-38 set ref 301* 302* 304 305 306 327 327 337
                                                                                  337 717 1150 1150 1404 1404 1483
hardcore_info                          based           structure                level 1 dcl 2-6
hardware_interrupt_level        000103 automatic       fixed bin(17,0)          dcl 962 set ref 1016* 1017 1017 1022 1022
hardware_interrupt_no           000104 automatic       picture(2)               packed unaligned dcl 963 set ref 1018* 1019
hbound                                                 builtin function         dcl 269 ref 368 402 712 1233 1252 1328 1567
head                                   based           structure                level 2 dcl 22-29
header                                 based           structure                level 2 in structure "log_message" dcl 23-13
                                                                                  in procedure "azm_display_fdump_events"
header                                 based           structure                level 2 in structure "wmess" dcl 22-47 in procedure
                                                                                  "azm_display_fdump_events"
hr                              000242 automatic       fixed bin(17,0)          dcl 132 set ref 461* 467
hr_cnt                    3(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 14-8 ref 1125
i                               000100 automatic       fixed bin(17,0)          dcl 581 set ref 584* 585 585*
ilc                       4            based           bit(18)                  level 2 packed packed unaligned dcl 13-56 ref 1034
                                                                                  1034 1037 1037
illegal_modifier                000144 stack reference condition                dcl 1675 ref 1678 1774
index                                                  builtin function         dcl 269 ref 783 911 1007 1036 1048
index_changed                   000100 automatic       bit(1)                   initial packed unaligned dcl 656 set ref 656* 661*
                                                                                  665 667*
indirect_sort_array                    based           structure                level 1 dcl 231
info                                   parameter       char                     packed unaligned dcl 758 in procedure
                                                                                  "print_disk_queue" ref 755
info                                   parameter       char                     packed unaligned dcl 954 in procedure
                                                                                  "print_scu_data" set ref 950 1028*
interesting_segname             000502 constant        char(32)                 initial array packed unaligned dcl 189 set ref 326
                                                                                  327* 331*
interesting_segs                000244 automatic       structure                array level 1 dcl 134
interrupt_level                 000105 automatic       picture(1)               packed unaligned dcl 964 set ref 1022* 1024
interrupt_no                    000106 automatic       fixed bin(17,0)          dcl 965 set ref 1015* 1016 1018 1023
io_type                   1     000106 automatic       fixed bin(17,0)          level 2 in structure "diskq_temp" dcl 1068
                                                                                  in procedure "process_disk_queue" set ref 1086*
io_type                   1            based           fixed bin(17,0)          level 2 in structure "diskq_data" dcl 223
                                                                                  in procedure "azm_display_fdump_events" ref 773
ioa_                            000044 constant        entry                    external dcl 252 ref 472 475 729 747 803 902 914
                                                                                  1029 1040 1051 1809 1815
ioa_$nnl                        000046 constant        entry                    external dcl 252 ref 483
ioa_$rsnnl                      000050 constant        entry                    external dcl 252 ref 479 481 723 746 799 1028 1037
                                                                                  1049 1127 1724 1760
iom                      20            based           fixed bin(3,0)           level 2 unsigned dcl 744 ref 746 746
iom_data                               based           structure                level 1 dcl 11-17
iom_data_p                      000100 automatic       pointer                  dcl 1162 set ref 1171* 1175
iom_data_ptr                    000374 automatic       pointer                  dcl 11-15 set ref 1175* 1176 1176 1178 1178 1179
iom_dev_data                           based           structure                level 1 dcl 744
iom_mailbox                            based           structure                level 1 dcl 11-95
iom_number                      000107 automatic       char(1)                  packed unaligned dcl 966 set ref 1023* 1024
its                                    based           structure                level 1 dcl 12-5
its_mod                   0(30)        based           bit(6)                   level 2 packed packed unaligned dcl 12-5 ref 1635
                                                                                  1796
its_ptr                         000166 automatic       pointer                  dcl 1792 set ref 1795* 1796 1797 1798
last_date_time                  000244 automatic       char(17)                 packed unaligned dcl 145 set ref 452* 472 478*
last_offset                     000465 automatic       fixed bin(18,0)          dcl 1395 set ref 1424* 1427
last_sec                        000251 automatic       fixed bin(17,0)          dcl 146 set ref 453* 479 482*
last_seg                  1            based           fixed bin(17,0)          level 2 dcl 1-28 ref 378
last_segno                      000252 automatic       fixed bin(17,0)          dcl 147 set ref 344*
last_sup_seg              4            based           fixed bin(18,0)          level 2 dcl 19-13 ref 380
lbound                                                 builtin function         dcl 269 ref 662 662
len                             000102 automatic       fixed bin(21,0)          dcl 1110 in procedure "process_mc_trace_buf" set ref
                                                                                  1127*
len                             000126 automatic       fixed bin(21,0)          dcl 1666 in procedure "walk_stack" set ref 1724*
                                                                                  1760*
length                                                 builtin function         dcl 269 ref 865 865 1373 1373 1376
line1                           000110 automatic       varying char(80)         dcl 967 set ref 1003* 1008* 1008 1019* 1024* 1028*
linel                           000100 automatic       fixed bin(21,0)          dcl 886 set ref 906* 907 908 909 910* 911 912* 912
                                                                                  914 914 915 916*
log_message                            based           structure                level 1 dcl 23-13 set ref 1451 1451
log_message_header                     based           structure                level 1 dcl 23-3
log_message_ptr                 000424 automatic       pointer                  dcl 23-19 set ref 864* 865 865 865 865 865 865 1435*
                                                                                  1439 1441* 1449 1449 1451* 1451 1451 1452
log_name                               parameter       char                     packed unaligned dcl 881 in procedure
                                                                                  "print_syserr_message" set ref 875 902*
log_name                               parameter       char(32)                 packed unaligned dcl 1390 in procedure
                                                                                  "process_syserr_log" set ref 1384 1404* 1406*
log_position_$next_message      000066 constant        entry                    external dcl 1400 ref 1441
log_segment_$last_message_info  000064 constant        entry                    external dcl 1399 ref 1424
log_segment_header                     based           structure                level 1 dcl 24-13 ref 1416
log_segment_ptr                 000426 automatic       pointer                  dcl 24-3 set ref 1436* 1441*
logical_area_number       4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 17-26 set ref
                                                                                  785 785 785* 786
long_data                              parameter       bit(1)                   packed unaligned dcl 1806 ref 1803 1808
long_report                            parameter       bit(1)                   packed unaligned dcl 96 ref 45 608 1032 1071
loop_count                      000127 automatic       fixed bin(17,0)          dcl 1667 set ref 1710* 1714 1733* 1733 1751 1769*
                                                                                  1769
low_time                               parameter       fixed bin(71,0)          dcl 1388 ref 1384 1449
lth                       2            based           fixed bin(19,0)          level 3 dcl 4-24 ref 1691 1695 1696 1716 1736 1742
                                                                                  1754
mach_cond                              based           structure                array level 2 dcl 14-8 set ref 1125
match_info_ptr                         parameter       pointer                  dcl 98 set ref 45 483 592 592* 729 747 803 1029 1040
                                                                                  1051 1814*
match_strings_$free             000032 constant        entry                    external dcl 247 ref 592
match_strings_$test             000034 constant        entry                    external dcl 248 ref 1814
max_events                      000264 automatic       fixed bin(17,0)          dcl 154 set ref 455* 456* 458
mbz                      11(18)        based           bit(18)                  array level 3 packed packed unaligned dcl 8-31 ref
                                                                                  1077
mc                                     based           structure                level 1 dcl 13-12 set ref 1712
mc_cnt                    1(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 14-8 ref 1124
mc_name                                parameter       char                     packed unaligned dcl 1589 set ref 1582 1594* 1596*
mc_seg_offset                   000107 automatic       char(30)                 packed unaligned dcl 1113 set ref 1127* 1130*
mc_trace_buf                           based           structure                level 1 dcl 14-8
mcp                             000376 automatic       pointer                  dcl 13-10 set ref 1712 1720* 1722* 1723 1726 1726
                                                                                  1727 1727 1755* 1758* 1759 1762 1762 1763 1763
mcp_scu_ptr                     000110 automatic       pointer                  dcl 1203 in procedure "process_pds" set ref 1234*
                                                                                  1238*
mcp_scu_ptr                     000104 automatic       pointer                  dcl 1290 in procedure "process_prds" set ref 1329*
                                                                                  1332*
mcptr                           000100 automatic       pointer                  dcl 1591 in procedure "validate_mc" set ref 1594*
                                                                                  1599 1601 1603 1603 1604
mcptr                           000102 automatic       pointer                  dcl 1289 in procedure "process_prds" set ref 1329*
                                                                                  1331 1332 1332
mcptr                           000106 automatic       pointer                  dcl 1202 in procedure "process_pds" set ref 1234*
                                                                                  1236 1238 1238
mcptr                           000104 automatic       pointer                  dcl 1111 in procedure "process_mc_trace_buf" set ref
                                                                                  1125* 1126 1127 1127 1128 1128 1130 1130
mct_scu_ptr                     000120 automatic       pointer                  dcl 1114 set ref 1128* 1130*
mctbp                           000100 automatic       pointer                  dcl 1107 set ref 1119* 1122
mctime                 3532            based           fixed bin(52,0)          level 2 dcl 7-11 ref 359 364 364
mcx                             000106 automatic       fixed bin(17,0)          dcl 1112 set ref 1124* 1125*
message                                based           structure                level 1 packed packed unaligned dcl 892
micsec                          000254 automatic       fixed bin(71,0)          dcl 148 set ref 461* 470
min                                                    builtin function         dcl 269 ref 456 904
min_length                      000122 automatic       fixed bin(17,0)          dcl 1664 set ref 1712* 1716 1739 1741 1775
minute                          000260 automatic       fixed bin(17,0)          dcl 150 set ref 461* 468
misc_registers         3540            based           structure                level 2 dcl 7-11
mod                                                    builtin function         dcl 269 in procedure "azm_display_fdump_events" ref
                                                                                  466 1022 1023 1637
mod                       1(30)        based           bit(6)                   level 2 in structure "its" packed packed unaligned
                                                                                  dcl 12-5 in procedure "azm_display_fdump_events"
                                                                                  ref 1631 1797
mon                             000262 automatic       fixed bin(17,0)          dcl 152 set ref 461* 464
n_aptes                                based           fixed bin(17,0)          level 2 dcl 215 set ref 353* 491 1228* 1228 1229
                                                                                  1230
n_devices                              based           fixed bin(17,0)          level 2 dcl 11-17 ref 1176 1176
n_events                               based           fixed bin(17,0)          level 2 dcl 202 set ref 362* 426 430 431 455 456 458
                                                                                  535* 535 536 537 538 539 540 541 542 543
n_temp_segs                            based           fixed bin(17,0)          level 2 dcl 198 set ref 564 565* 565 567 584
names_inx                       000112 automatic       fixed bin(17,0)          dcl 1204 in procedure "process_pds" set ref 1233*
                                                                                  1234 1238*
names_inx                       000106 automatic       fixed bin(17,0)          dcl 1291 in procedure "process_prds" set ref 1328*
                                                                                  1329 1332 1332*
nametbl_ptr                     000266 automatic       pointer                  dcl 155 set ref 305*
new_disk_dim_sw                 000154 automatic       bit(1)                   packed unaligned dcl 103 set ref 340* 1069 1078*
next_frame_mc                   000130 automatic       bit(1)                   packed unaligned dcl 1668 set ref 1711* 1721 1731*
                                                                                  1732* 1757 1767* 1768*
next_sp                  22            based           pointer                  level 2 dcl 20-36 set ref 1734* 1770*
null                                                   builtin function         dcl 269 ref 113 307 308 309 331 339 394 483 583 585
                                                                                  588 590 591 592 637 681 686 729 747 774 803 1029
                                                                                  1040 1051 1222 1225 1236 1248 1251 1253 1262 1265
                                                                                  1269 1271 1308 1310 1321 1323 1331 1364 1367 1406
                                                                                  1435 1439 1449 1487 1489 1494 1497 1504 1507 1562
                                                                                  1565 1596 1599 1606 1608 1688 1720 1755 1794
num_aptes                       000104 automatic       fixed bin(17,0)          dcl 1470 set ref 1490* 1491 1509
num_events                             parameter       fixed bin(17,0)          dcl 94 ref 45 347 456 1816
number                                 parameter       fixed bin(18,0)          dcl 658 set ref 650 664*
offline                   0(01)        based           bit(1)                   array level 2 packed packed unaligned dcl 1552 ref
                                                                                  1568
offset                    1            based           bit(18)                  array level 3 packed packed unaligned dcl 215 set
                                                                                  ref 492 1229*
online                                 based           bit(1)                   array level 2 packed packed unaligned dcl 1552 ref
                                                                                  1568
opt_info                               based           structure                level 1 dcl 8-217
p99                                    automatic       picture(2)               packed unaligned dcl 765 ref 786
part1                     1     000330 automatic       structure                level 2 in structure "translation_space" unaligned
                                                                                  dcl 175 in procedure "azm_display_fdump_events"
part1                     1            based           structure                level 2 in structure "translation" dcl 4-24
                                                                                  in procedure "azm_display_fdump_events"
part1                   347            based           structure                array level 3 in structure "translation_table"
                                                                                  dcl 4-13 in procedure "azm_display_fdump_events"
part2                     3            based           structure                level 2 dcl 4-24
pdata                                  based           structure                array level 1 dcl 1552 ref 1567
pds_names                       000030 constant        char(32)                 initial array packed unaligned dcl 1209 set ref 1233
                                                                                  1234* 1238
pds_stacks                             based           pointer                  array dcl 1214 ref 1252 1253 1253
pds_stacks_inx                  000113 automatic       fixed bin(17,0)          dcl 1205 set ref 1252* 1253 1253 1253 1255*
pds_stacks_ptr                  000114 automatic       pointer                  dcl 1206 set ref 1246* 1250 1251 1252 1253 1253
pdsp                            000100 automatic       pointer                  dcl 1195 set ref 1219* 1220 1234* 1246 1260 1267
per_device                             based           structure                level 1 dcl 11-59 in procedure
                                                                                  "azm_display_fdump_events" ref 1178 1178
per_device              240            based           structure                array level 2 in structure "iom_data" dcl 11-17
                                                                                  in procedure "azm_display_fdump_events" set ref
                                                                                  1178 1178
per_device_p                    000104 automatic       pointer                  dcl 1166 set ref 1178* 1179*
per_iom                                based           structure                level 1 dcl 11-40
pointer                                                builtin function         dcl 269 ref 1034 1034 1046 1046
pointers                               based           structure                level 2 dcl 2-6
ppr                                    based           structure                level 2 packed packed unaligned dcl 13-56
pr_tag                   21(33)        based           bit(3)                   level 3 packed packed unaligned dcl 5-7 ref 723 723
prds_names                      000000 constant        char(32)                 initial array packed unaligned dcl 1300 set ref 1328
                                                                                  1329* 1332 1332
prds_processor                  000270 automatic       bit(8)                   packed unaligned dcl 156 set ref 336* 1314 1316*
                                                                                  1317 1571* 1571
prdsp                           000100 automatic       pointer                  dcl 1284 set ref 1305* 1306 1318 1329*
proc_exists_mask                000103 automatic       bit(8)                   packed unaligned dcl 1549 set ref 1559* 1568* 1571
proc_no                         000271 automatic       fixed bin(17,0)          dcl 157 set ref 343* 368* 369* 377* 540 1230 1781*
proc_number                     000102 automatic       fixed bin(17,0)          dcl 1548 set ref 1567* 1568 1568 1568*
process_char                           parameter       char                     packed unaligned dcl 760 in procedure
                                                                                  "print_disk_queue" ref 755
process_char                           parameter       char                     packed unaligned dcl 955 in procedure
                                                                                  "print_scu_data" set ref 950 1028*
process_it                             parameter       bit(1)                   dcl 1349 in procedure "process_syserr_data" set ref
                                                                                  1345 1360*
process_it                             parameter       bit(1)                   dcl 1467 in procedure "process_tc_data" set ref 1464
                                                                                  1479*
process_it                             parameter       bit(1)                   dcl 1108 in procedure "process_mc_trace_buf" set ref
                                                                                  1104 1121*
process_it                             parameter       bit(1)                   dcl 1196 in procedure "process_pds" ref 1191
process_it                             parameter       bit(1)                   dcl 1546 in procedure "setup_from_scs" set ref 1542
                                                                                  1558*
process_it                             parameter       bit(1)                   dcl 605 in procedure "copy_pvt" set ref 602 607*
process_it                             parameter       bit(1)                   dcl 1064 in procedure "process_disk_queue" set ref
                                                                                  1060 1070*
process_it                             parameter       bit(1)                   dcl 1163 in procedure "process_iom_data" set ref
                                                                                  1159 1174*
process_it                             parameter       bit(1)                   dcl 1285 in procedure "process_prds" set ref 1281
                                                                                  1317*
process_it                             parameter       bit(1)                   dcl 1144 in procedure "process_inzr_stk0" set ref
                                                                                  1141 1149*
process_n                              parameter       fixed bin(17,0)          dcl 819 in procedure "print_dump_mc" ref 813
process_n                              parameter       fixed bin(17,0)          dcl 702 in procedure "print_apte" ref 696 716
process_n                              parameter       fixed bin(17,0)          dcl 856 in procedure "print_syserr_log" ref 851
process_n                              parameter       fixed bin(17,0)          dcl 837 in procedure "print_mc" ref 831 842
process_n                              parameter       fixed bin(17,0)          dcl 742 in procedure "print_device_data" ref 737
process_n                              parameter       fixed bin(17,0)          dcl 929 in procedure "print_wired_syserr" ref 924
process_na                      000103 automatic       picture(3)               packed unaligned dcl 704 in procedure "print_apte"
                                                                                  set ref 716* 723*
process_na                      000100 automatic       picture(3)               packed unaligned dcl 839 in procedure "print_mc" set
                                                                                  ref 842* 843
process_num                     000101 automatic       char(3)                  packed unaligned dcl 840 set ref 843* 844*
process_number           14            based           fixed bin(17,0)          array level 3 in structure "time_stamped_events"
                                                                                  dcl 202 in procedure "azm_display_fdump_events"
                                                                                  set ref 486 540*
process_number                  000272 automatic       fixed bin(17,0)          dcl 158 in procedure "azm_display_fdump_events" set
                                                                                  ref 486* 495* 502*
process_this_seg          1     000244 automatic       bit(1)                   initial array level 2 dcl 134 set ref 134* 375* 380
                                                                                  391 392* 1272*
processor_tag                   000107 automatic       fixed bin(17,0)          dcl 1292 set ref 1311* 1312 1314 1316
procn                     1(18)        based           fixed bin(17,0)          array level 3 packed packed unaligned dcl 215 set
                                                                                  ref 495 1230*
prr                                    based           bit(3)                   level 3 packed packed unaligned dcl 13-56 set ref
                                                                                  1037* 1037*
prtag_based                            based           fixed bin(17,0)          dcl 1293 ref 1311
prtagp                          000110 automatic       pointer                  dcl 1294 set ref 1306* 1310 1311
psr                       0(03)        based           bit(15)                  level 3 packed packed unaligned dcl 13-56 ref 1034
                                                                                  1034 1037 1037 1126 1723 1759
ptr                                                    builtin function         dcl 269 in procedure "azm_display_fdump_events" ref
                                                                                  1220 1246 1260 1267 1306 1318 1362 1560 1594
ptr                       3            based           pointer                  level 3 in structure "translation" packed packed
                                                                                  unaligned dcl 4-24 in procedure
                                                                                  "azm_display_fdump_events" ref 1698 1744 1754
ptr                       1            based           pointer                  level 3 in structure "translation" packed packed
                                                                                  unaligned dcl 4-24 in procedure
                                                                                  "azm_display_fdump_events" ref 1689 1698 1744
ptsr                            000135 automatic       bit(1)                   packed unaligned dcl 968 set ref 1004* 1014* 1043
pvt                                    based           structure                level 1 dcl 16-13
pvt_array                              based           structure                array level 1 dcl 17-24 set ref 782
pvt_arrayp                      000406 automatic       pointer                  dcl 17-21 set ref 781* 782
pvte                                   based           structure                level 1 dcl 17-26
pvtep                           000410 automatic       pointer                  dcl 17-22 set ref 782* 783 784 785 785 785 786 791
pvtp                            000404 automatic       pointer                  dcl 16-9 set ref 309* 609* 611* 774 781
pvtx                      2            based           fixed bin(8,0)           level 2 in structure "quentry" packed packed
                                                                                  unsigned unaligned dcl 8-107 in procedure
                                                                                  "azm_display_fdump_events" ref 1085
pvtx                                   based           fixed bin(17,0)          level 2 in structure "diskq_data" dcl 223
                                                                                  in procedure "azm_display_fdump_events" ref 782
pvtx                            000106 automatic       fixed bin(17,0)          level 2 in structure "diskq_temp" dcl 1068
                                                                                  in procedure "process_disk_queue" set ref 1085*
qht                                    based           structure                level 1 dcl 8-179
qp                              000370 automatic       pointer                  dcl 8-97 set ref 1082* 1083 1083 1085 1086 1087 1088
                                                                                  1089 1090 1091
quentry                                based           structure                level 1 dcl 8-107
queue_time                      000104 automatic       fixed bin(71,0)          dcl 1067 set ref 1091* 1092*
qx                              000102 automatic       fixed bin(17,0)          dcl 1066 set ref 1081* 1082*
range                           000273 automatic       fixed bin(18,0)          dcl 159 set ref 1416* 1417* 1419 1427* 1428* 1430
real_apte                       000111 automatic       bit(18)                  packed unaligned dcl 1474 set ref 1513* 1514*
real_apte_offset                000104 automatic       fixed bin(18,0)          dcl 705 set ref 717* 723*
rec_per_cyl                     000470 constant        fixed bin(17,0)          initial array dcl 9-108 ref 792
rel                                                    builtin function         dcl 269 ref 639 717 717 1127 1127 1226 1229 1250
                                                                                  1325 1484 1512 1637 1637 1637 1637 1637 1637 1643
return_ptr               24            based           pointer                  level 2 dcl 20-36 set ref 1721* 1757*
reverse                                                builtin function         dcl 269 ref 911
ring_no                                parameter       fixed bin(17,0)          dcl 1529 ref 1526 1535
ring_num                        000500 automatic       picture(1)               packed unaligned dcl 1533 set ref 1535* 1536
rtrim                                                  builtin function         dcl 269 ref 1008 1238 1332 1814 1814
sb                              000416 automatic       pointer                  dcl 21-24 set ref 1689* 1691 1693* 1696 1697 1698
                                                                                  1699 1699* 1702 1706 1706* 1719 1734* 1770*
sb_save                         000142 automatic       pointer                  dcl 1674 set ref 1702* 1777
sci_ptr                         000274 automatic       pointer                  dcl 160 set ref 300* 317* 564* 585* 587* 590* 591*
                                                                                  1781*
scs$processor_data              000056 external static structure                array level 1 dcl 18-35
scs_proc_data_ptr               000104 automatic       pointer                  dcl 1550 set ref 1560* 1565 1567 1568 1568
scs_ptr                         000100 automatic       pointer                  dcl 1545 set ref 1556* 1560
scu                                    based           structure                level 1 dcl 13-56 in procedure
                                                                                  "azm_display_fdump_events" set ref 1128 1128 1603
                                                                                  1603 1726 1726 1762 1762
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed packed
                                                                                  unaligned dcl 13-12 in procedure
                                                                                  "azm_display_fdump_events" set ref 1126 1128 1128
                                                                                  1601 1603 1603 1723 1726 1726 1759 1762 1762
scu                    3540            based           bit(36)                  array level 3 in structure "dump" dcl 7-11
                                                                                  in procedure "azm_display_fdump_events" set ref
                                                                                  364 364
scu_data_ptr                           parameter       pointer                  dcl 953 ref 950 999
scup                            000400 automatic       pointer                  dcl 13-54 set ref 999* 1000 1001 1002 1006 1015 1034
                                                                                  1034 1034 1034 1037 1037 1037 1037 1037 1037 1046
                                                                                  1046 1046 1046 1049 1049 1049 1049 1049 1049 1128
                                                                                  1128 1603 1603 1726 1726 1762 1762
sec                             000276 automatic       fixed bin(17,0)          dcl 161 set ref 461* 469 479 482
sect_per_cyl                    000457 constant        fixed bin(17,0)          initial array dcl 10-15 ref 792
sect_per_rec                    000446 constant        fixed bin(17,0)          initial array dcl 10-21 ref 792
sect_sw                         000104 automatic       bit(1)                   packed unaligned dcl 766 set ref 777* 787* 788 799*
sector                    3(15)        based           bit(21)                  level 2 in structure "quentry" packed packed
                                                                                  unaligned dcl 8-107 in procedure
                                                                                  "azm_display_fdump_events" ref 1088
sector                    3            based           fixed bin(17,0)          level 2 in structure "diskq_data" dcl 223
                                                                                  in procedure "azm_display_fdump_events" ref 778
                                                                                  788 792
sector                    3     000106 automatic       fixed bin(17,0)          level 2 in structure "diskq_temp" dcl 1068
                                                                                  in procedure "process_disk_queue" set ref 1088*
sector_map                             defined         bit(1)                   array packed unaligned dcl 8-274 ref 787
sector_mapping                  000501 constant        bit(7)                   initial packed unaligned dcl 8-273 ref 787 787
seek_command                    000372 automatic       bit(6)                   initial array packed unaligned dcl 9-84 set ref
                                                                                  9-84* 9-84* 9-84* 9-84* 9-84* 9-84* 9-84* 9-84*
                                                                                  9-84*
seg                                    parameter       fixed bin(17,0)          dcl 657 set ref 650 660* 664*
seg_found                       000300 automatic       bit(1)                   packed unaligned dcl 163 set ref 384* 386 387* 391
seg_num                                parameter       fixed bin(17,0)          dcl 1623 ref 1619 1637
seg_offset                      000131 automatic       char(13)                 packed unaligned dcl 1669 set ref 1724* 1727* 1760*
                                                                                  1763*
seg_valid                       000237 automatic       bit(1)                   packed unaligned dcl 970 set ref 1033* 1036* 1037*
                                                                                  1045* 1048* 1049*
seginx                          000301 automatic       fixed bin(17,0)          dcl 164 set ref 325* 326 327 329 331* 385* 386 387
                                                                                  389* 389 391 392 392
segname                                parameter       char                     packed unaligned dcl 1588 set ref 1582 1594* 1596*
segno                    20            based           bit(18)                  array level 3 in structure "dump" packed packed
                                                                                  unaligned dcl 7-11 in procedure
                                                                                  "azm_display_fdump_events" ref 379
segno                     0(03)        based           bit(15)                  level 2 in structure "its" packed packed unaligned
                                                                                  dcl 12-5 in procedure "azm_display_fdump_events"
                                                                                  ref 1798
segno                                  parameter       fixed bin(17,0)          dcl 675 in procedure "get_trans" set ref 673 680*
                                                                                  684 684
segno                           000244 automatic       fixed bin(18,0)          initial array level 2 in structure
                                                                                  "interesting_segs" dcl 134 in procedure
                                                                                  "azm_display_fdump_events" set ref 134* 329* 387
                                                                                  1273*
segp                            000302 automatic       pointer                  dcl 165 in procedure "azm_display_fdump_events" set
                                                                                  ref 327* 329
segp                            000102 automatic       pointer                  dcl 1147 in procedure "process_inzr_stk0" set ref
                                                                                  1150* 1152 1152
segptr                                 parameter       pointer                  dcl 1587 ref 1582 1594
segs                     20            based           structure                array level 2 dcl 7-11
seq_num                                based           fixed bin(35,0)          level 3 dcl 22-47 ref 938
sequence                               parameter       fixed bin(35,0)          dcl 879 in procedure "print_syserr_message" set ref
                                                                                  875 902*
sequence                        000100 automatic       fixed bin(35,0)          dcl 931 in procedure "print_wired_syserr" set ref
                                                                                  938* 942*
sequence                  1            based           fixed bin(35,0)          level 3 in structure "log_message" dcl 23-13
                                                                                  in procedure "azm_display_fdump_events" set ref
                                                                                  865*
severity                        000101 automatic       fixed bin(17,0)          dcl 932 in procedure "print_wired_syserr" set ref
                                                                                  939* 942*
severity                               parameter       fixed bin(17,0)          dcl 880 in procedure "print_syserr_message" set ref
                                                                                  875 902*
severity                  2            based           fixed bin(8,0)           level 3 in structure "log_message" packed packed
                                                                                  unaligned dcl 23-13 in procedure
                                                                                  "azm_display_fdump_events" ref 865
signaller                20(26)        based           bit(1)                   level 2 packed packed unaligned dcl 20-64 ref 1732
                                                                                  1768
size                                                   builtin function         dcl 269 in procedure "azm_display_fdump_events" ref
                                                                                  1092 1092 1092 1092 1128 1128 1178 1178 1416 1603
                                                                                  1603 1691 1696 1697 1712 1726 1726 1762 1762
size                                   based           fixed bin(17,0)          level 2 in structure "fdump_process_table" dcl 1-23
                                                                                  in procedure "azm_display_fdump_events" ref 368
size_of_apte                    000105 automatic       fixed bin(17,0)          dcl 1471 set ref 1498* 1499 1518
slog_no                         000464 automatic       fixed bin(17,0)          dcl 1394 set ref 1412* 1417* 1428*
slog_p                          000462 automatic       pointer                  dcl 1393 set ref 1404* 1412
slt                                    based           structure                level 3 in structure "hardcore_info" dcl 2-6
                                                                                  in procedure "azm_display_fdump_events"
slt                                    based           structure                level 1 dcl 19-13 in procedure
                                                                                  "azm_display_fdump_events"
sltntp                    2            based           pointer                  level 2 dcl 2-40 set ref 305 327* 337* 1150* 1404*
sltp                            000412 automatic       pointer                  dcl 19-7 in procedure "azm_display_fdump_events" set
                                                                                  ref 304* 380
sltp                                   based           pointer                  level 2 in structure "hardcore_cur" dcl 2-40
                                                                                  in procedure "azm_display_fdump_events" set ref
                                                                                  304 327* 337* 1150* 1404*
sort_index                             based           fixed bin(18,0)          array level 2 dcl 231 set ref 427* 432 432 433 434*
                                                                                  434 435* 437 437 438 438 440 440 459 461 486 488
                                                                                  492 502 502 502
sortinx                         000306 automatic       fixed bin(17,0)          dcl 167 set ref 426* 427 427* 430* 431 432 434 435
                                                                                  437 440 440*
sortinx1                        000307 automatic       fixed bin(17,0)          dcl 168 set ref 431* 432 433 434 437 438 438*
sortinxt                        000310 automatic       fixed bin(17,0)          dcl 169 set ref 433* 435
sortp                           000304 automatic       pointer                  dcl 166 set ref 425* 427 432 432 433 434 434 435 437
                                                                                  437 438 438 440 440 459 461 486 488 492 502 502
                                                                                  502 590 590*
sp                              000414 automatic       pointer                  dcl 20-31 set ref 1719* 1721 1722 1732 1734 1739*
                                                                                  1744 1746 1754* 1757 1758 1768 1770
sp_offset                       000135 automatic       fixed bin(18,0)          dcl 1670 set ref 1699* 1706* 1708 1714* 1714 1714*
                                                                                  1716 1719 1724* 1736 1742 1744 1751* 1751 1751*
                                                                                  1754 1760*
sp_save                         000140 automatic       pointer                  dcl 1674 set ref 1746* 1775
ssu_$get_temp_segment           000036 constant        entry                    external dcl 249 ref 317 564
ssu_$print_message              000040 constant        entry                    external dcl 250 ref 1781
ssu_$release_temp_segment       000042 constant        entry                    external dcl 251 ref 585 587 590 591
stack_base_ptr                         parameter       pointer                  dcl 1624 ref 1619 1637 1637
stack_begin_ptr          22            based           pointer                  level 2 dcl 21-26 set ref 1637 1699* 1706*
stack_end_ptr            24            based           pointer                  level 2 dcl 21-26 ref 1637
stack_found                     000311 automatic       bit(1)                   packed unaligned dcl 170 set ref 401* 402 408*
stack_frame                            based           structure                level 1 dcl 20-36
stack_frame_flags                      based           structure                level 1 dcl 20-64
stack_frame_min_length                 constant        fixed bin(17,0)          initial dcl 20-33 ref 1712 1722 1758
stack_frame_save                       based           fixed bin(36,0)          array dcl 1672 ref 1739 1775
stack_frame_sw                  000136 automatic       bit(1)                   packed unaligned dcl 1671 set ref 1686* 1745* 1775
stack_header                           based           structure                level 1 dcl 21-26 set ref 1691 1693 1696 1697 1777
stack_header_sw                 000137 automatic       bit(1)                   packed unaligned dcl 1673 set ref 1686* 1703* 1706
                                                                                  1777
stack_inx                       000312 automatic       fixed bin(17,0)          dcl 171 set ref 402* 402* 403 405* 410
stack_name                             parameter       char                     packed unaligned dcl 1658 set ref 1653 1724* 1760*
                                                                                  1781*
stack_ptr                              parameter       pointer                  dcl 1622 set ref 1619 1626 1631 1633 1635 1637 1637
                                                                                  1637 1637 1637 1643
stack_seg                              parameter       fixed bin(17,0)          dcl 1657 set ref 1653 1687* 1699* 1706* 1734* 1770*
stack_seg_no                           parameter       fixed bin(17,0)          dcl 1531 set ref 1526 1536*
stack_segs                      000313 automatic       fixed bin(17,0)          array dcl 172 set ref 341* 370* 402 403 1253* 1255*
state                     1(18)        based           bit(18)                  level 3 packed packed unaligned dcl 5-7 ref 712 714
                                                                                  723 1510
state_change_time        22            based           fixed bin(71,0)          level 2 dcl 5-7 set ref 1510 1514*
state_name                      000100 automatic       char(10)                 packed unaligned dcl 703 set ref 712* 714* 723*
status_queue                           based           structure                level 1 dcl 11-92
string                                                 builtin function         dcl 269 ref 1601
structp                                parameter       pointer                  dcl 741 in procedure "print_device_data" ref 737 746
                                                                                  746 746
structp                                parameter       pointer                  dcl 836 in procedure "print_mc" set ref 831 844*
structp                                parameter       pointer                  dcl 855 in procedure "print_syserr_log" ref 851 864
structp                                parameter       pointer                  dcl 701 in procedure "print_apte" ref 696 711
structp                                parameter       pointer                  dcl 818 in procedure "print_dump_mc" set ref 813
                                                                                  822*
structp                                parameter       pointer                  dcl 928 in procedure "print_wired_syserr" ref 924
                                                                                  937
sub_type_inx                    000240 automatic       fixed bin(17,0)          dcl 971 set ref 1007* 1008 1008
substr                                                 builtin function         dcl 269 set ref 723 723 746 746 911 1000 1004 1023
                                                                                  1314 1316* 1513 1568*
subsys_name                     000105 automatic       char(4)                  packed unaligned dcl 767 set ref 775* 783* 784* 799*
sys_info                               based           structure                level 1 dcl 8-59
sys_info$max_seg_size           000052 external static fixed bin(35,0)          dcl 257 ref 610 639 1072 1116 1168 1216 1302 1354
                                                                                  1553
syserr_data_ptr                 000100 automatic       pointer                  dcl 1348 set ref 1357* 1362
t_ptr                                  parameter       pointer                  dcl 1791 in procedure "valid_fim_ptr" set ref 1788
                                                                                  1795
t_ptr                           000106 automatic       pointer                  dcl 676 in procedure "get_trans" set ref 680* 681
                                                                                  681 683* 684* 687
tc_datap                 10            based           pointer                  level 2 dcl 2-40 ref 717 1483
temp_alloc_p                    000324 automatic       pointer                  dcl 173 set ref 307* 637 637* 639 639* 641 642* 642
temp_message_ptr                000470 automatic       pointer                  dcl 1397 set ref 1451* 1452*
temp_ptr                               parameter       pointer                  dcl 1389 set ref 1384 1417* 1424* 1428* 1436
temp_seg_data                          based           structure                level 1 dcl 198
temp_seg_data_p                 000326 automatic       pointer                  dcl 174 set ref 308* 317* 564 564 565 565 567 567
                                                                                  583 584 585 585 587* 588*
temp_segp                 2            based           pointer                  array level 2 dcl 198 set ref 564* 567 585 585*
temp_string                     000101 automatic       varying char(128)        dcl 99 set ref 310* 723* 729* 746* 747* 799* 803*
                                                                                  1028* 1029* 1037* 1040* 1049* 1051* 1809* 1812*
                                                                                  1812 1814 1814 1815*
temp_time                       000142 automatic       varying char(32)         dcl 100 set ref 310* 479* 481* 483* 1812
text                      6            based           char                     level 2 in structure "wmess" dcl 22-47 in procedure
                                                                                  "azm_display_fdump_events" set ref 941
text                      6            based           char                     level 2 in structure "log_message" packed packed
                                                                                  unaligned dcl 23-13 in procedure
                                                                                  "azm_display_fdump_events" set ref 865 865 865 865
text_len                  3(12)        based           fixed bin(11,0)          level 3 packed packed unaligned dcl 22-47 ref 940
                                                                                  941 1373 1373 1376
text_lth                  4            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 23-13 ref 865
                                                                                  865 865 865 1451 1451
textl                           000102 automatic       fixed bin(21,0)          dcl 933 in procedure "print_wired_syserr" set ref
                                                                                  940* 942*
textl                                  parameter       fixed bin(21,0)          dcl 882 in procedure "print_syserr_message" ref 875
                                                                                  904
textl_done                      000101 automatic       fixed bin(21,0)          dcl 887 set ref 905* 911 914 915* 915 916
textl_total                     000102 automatic       fixed bin(21,0)          dcl 888 set ref 904* 906 916
textp                           000104 automatic       pointer                  dcl 934 in procedure "print_wired_syserr" set ref
                                                                                  941* 942*
textp                                  parameter       pointer                  dcl 883 in procedure "print_syserr_message" ref 875
                                                                                  911 914
the_hard_way                    000116 automatic       bit(1)                   packed unaligned dcl 1659 set ref 1686* 1701* 1713
this_line                              based           char                     level 2 packed packed unaligned dcl 892 set ref 911
                                                                                  914*
time                      4            based           fixed bin(71,0)          level 2 in structure "quentry" dcl 8-107
                                                                                  in procedure "azm_display_fdump_events" ref 1083
                                                                                  1083 1091
time                      1            based           fixed bin(71,0)          level 3 in structure "wmess" packed packed unaligned
                                                                                  dcl 22-47 in procedure "azm_display_fdump_events"
                                                                                  ref 1374
time                      2(18)        based           fixed bin(53,0)          level 3 in structure "log_message" packed packed
                                                                                  unaligned dcl 23-13 in procedure
                                                                                  "azm_display_fdump_events" ref 1449 1452
time_stamp                2            based           fixed bin(71,0)          array level 3 dcl 202 set ref 432 432 437 437 461*
                                                                                  536*
time_stamped_events                    based           structure                level 1 dcl 202
tlength                         000100 automatic       fixed bin(18,0)          dcl 631 set ref 636* 639 642 643
tp                              000106 automatic       pointer                  dcl 1472 set ref 1483* 1484 1485 1492 1502
tp_base                         000110 automatic       fixed bin(35,0)          dcl 1473 set ref 1484* 1512
tpr                       2            based           structure                level 2 packed packed unaligned dcl 13-56
tptr                            000102 automatic       pointer                  dcl 632 set ref 641* 643 644
translation                            based           structure                level 1 dcl 4-24
translation_ptr                 000360 automatic       pointer                  dcl 4-40 set ref 1687* 1688 1689 1690 1691 1695 1696
                                                                                  1698 1698 1716 1716 1736 1742 1744 1744 1754 1754
translation_space               000330 automatic       structure                level 1 unaligned dcl 175 set ref 683
trim_eol                        000103 automatic       fixed bin(21,0)          dcl 889 set ref 911* 912
trr                       2            based           bit(3)                   level 3 packed packed unaligned dcl 13-56 set ref
                                                                                  1049* 1049*
tsegp                           000336 automatic       pointer                  dcl 176 set ref 309* 320* 417* 418* 591 591* 1073*
                                                                                  1075 1117* 1119 1169* 1171 1217* 1219 1303* 1305
                                                                                  1355* 1357 1554* 1556
tsl                             000153 automatic       fixed bin(21,0)          dcl 101 set ref 311* 479* 481* 723* 746* 799* 1028*
                                                                                  1037* 1049*
tsr                       2(03)        based           bit(15)                  level 3 packed packed unaligned dcl 13-56 ref 1046
                                                                                  1046 1049 1049
two_part                  0(18)        based           bit(1)                   level 3 packed packed unaligned dcl 4-24 ref 1690
                                                                                  1716
type                      1(02)        based           fixed bin(4,0)           level 2 packed packed unsigned unaligned dcl 8-107
                                                                                  ref 1086
type_io                         000100 automatic       fixed bin(17,0)          dcl 761 set ref 773* 787 799
unspec                                                 builtin function         dcl 269 ref 1006 1373 1373 1376 1513
used                      5     000106 automatic       bit(1)                   level 2 in structure "diskq_temp" dcl 1068
                                                                                  in procedure "process_disk_queue" set ref 1090*
used                      1(01)        based           bit(1)                   level 2 in structure "quentry" packed packed
                                                                                  unaligned dcl 8-107 in procedure
                                                                                  "azm_display_fdump_events" ref 1090
used                      5            based           bit(1)                   level 2 in structure "diskq_data" dcl 223
                                                                                  in procedure "azm_display_fdump_events" set ref
                                                                                  799*
wait_event               20            based           bit(36)                  level 2 dcl 5-7 set ref 723*
wlog                                   based           structure                level 1 dcl 22-29
wlog_header                            based           structure                level 1 dcl 22-33
wlog_inx                        000102 automatic       fixed bin(17,0)          dcl 1351 set ref 1372*
wlog_ptr                        000420 automatic       pointer                  dcl 22-17 set ref 1362* 1367 1368 1370 1372
wmess                                  based           structure                level 1 dcl 22-47 set ref 1373 1373 1376
wmess_header                           based           structure                level 1 dcl 22-52
wmess_ptr                       000422 automatic       pointer                  dcl 22-17 set ref 937* 938 939 940 941 1368* 1373*
                                                                                  1373 1373 1374 1376* 1376 1376
word                                   parameter       fixed bin(18,0)          dcl 658 set ref 650 664*
words_copied                    000340 automatic       fixed bin(18,0)          dcl 177 set ref 610* 611* 1072* 1073* 1116* 1117*
                                                                                  1168* 1169* 1216* 1217* 1250 1302* 1303* 1354*
                                                                                  1355* 1553* 1554*
wp                              000104 automatic       pointer                  dcl 1352 set ref 1373* 1375*
wtime                           000106 automatic       fixed bin(71,0)          dcl 1353 set ref 1374* 1375*
yr                              000341 automatic       fixed bin(17,0)          dcl 178 set ref 461* 466

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AMU_FDUMP_INFO_VERSION                 internal static char(8)                  initial packed unaligned dcl 1-43
AMU_FDUMP_INFO_VERSION_1               internal static char(8)                  initial packed unaligned dcl 1-42
AMU_INFO_VERSION                       internal static char(8)                  initial packed unaligned dcl 3-57
AMU_INFO_VERSION_1                     internal static char(8)                  initial packed unaligned dcl 3-56
AMU_INFO_VERSION_2                     internal static char(8)                  initial packed unaligned dcl 3-58
BOOTLOAD_READ                          internal static fixed bin(4,0)           initial dcl 8-251
BOOTLOAD_WRITE                         internal static fixed bin(4,0)           initial dcl 8-251
BULK_PORT                              internal static fixed bin(17,0)          initial dcl 18-176
CPU_PORT                               internal static fixed bin(17,0)          initial dcl 18-176
DSC_LISTX                              internal static fixed bin(12,0)          initial dcl 8-241
DUMP_VERSION_1                         internal static fixed bin(17,0)          initial dcl 7-120
DUMP_VERSION_2                         internal static fixed bin(17,0)          initial dcl 7-121
FDUMP_PROCESS_TYPE                     internal static fixed bin(17,0)          initial dcl 3-47
FDUMP_TYPE                             internal static fixed bin(17,0)          initial dcl 3-47
INDIRECT_TYPE                          internal static fixed bin(17,0)          initial dcl 3-47
IOM_PORT                               internal static fixed bin(17,0)          initial dcl 18-176
IO_TYPE                                internal static char(16)                 initial array packed unaligned dcl 8-262
ITP_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 12-56
LOG_SEGMENT_COMPLETE_MESSAGE           internal static bit(36)                  initial dcl 24-43
LOG_SEGMENT_NEW_MESSAGE                internal static bit(36)                  initial dcl 24-42
LOG_SEGMENT_VERSION_1                  internal static char(8)                  initial packed unaligned dcl 24-5
MAX_IO_TYPE                            internal static fixed bin(4,0)           initial dcl 8-251
MODEL                                  internal static fixed bin(17,0)          initial array dcl 9-57
MODELN                                 internal static fixed bin(17,0)          initial array dcl 9-63
MODELX                                 internal static fixed bin(17,0)          initial array dcl 9-60
NETWORK_FDUMP_TYPE                     internal static fixed bin(17,0)          initial dcl 3-47
NETWORK_ONLINE_TYPE                    internal static fixed bin(17,0)          initial dcl 3-47
ONLINE_PROCESS_TYPE                    internal static fixed bin(17,0)          initial dcl 3-47
ONLINE_TYPE                            internal static fixed bin(17,0)          initial dcl 3-47
PAGE_READ                              internal static fixed bin(4,0)           initial dcl 8-251
PAGE_WRITE                             internal static fixed bin(4,0)           initial dcl 8-251
PDIR_SUFFIX                            internal static char(4)                  initial packed unaligned dcl 3-60
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 20-19
RSS_LISTX                              internal static fixed bin(12,0)          initial dcl 8-241
RST_LISTX                              internal static fixed bin(12,0)          initial dcl 8-241
SAVED_PROC_TYPE                        internal static fixed bin(17,0)          initial dcl 3-47
SC_LISTX                               internal static fixed bin(12,0)          initial dcl 8-241
TEST                                   internal static fixed bin(4,0)           initial dcl 8-251
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 20-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 20-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 20-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 20-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 20-27
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 17-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 17-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 17-113
VTOC_READ                              internal static fixed bin(4,0)           initial dcl 8-251
VTOC_WRITE                             internal static fixed bin(4,0)           initial dcl 8-251
abx                                    internal static fixed bin(17,0)          initial dcl 13-42
aclp                                   automatic       pointer                  dcl 19-7
acls                                   based           structure                level 1 dcl 19-45
alloc_fdump_process_table_size         automatic       fixed bin(17,0)          dcl 1-40
alloc_translation_table_max_entries    automatic       fixed bin(17,0)          dcl 4-39
apx                                    internal static fixed bin(17,0)          initial dcl 13-42
bbx                                    internal static fixed bin(17,0)          initial dcl 13-42
bindmap                                based           structure                level 1 dcl 6-4
bootload_map                           defined         bit(1)                   array packed unaligned dcl 8-279
bootload_mapping                       internal static bit(7)                   initial packed unaligned dcl 8-278
bpx                                    internal static fixed bin(17,0)          initial dcl 13-42
buf_init                               internal static bit(36)                  initial packed unaligned dcl 14-33
bulkdevt                               internal static fixed bin(4,0)           initial dcl 9-43
call_offset                            internal static fixed bin(17,0)          initial dcl 21-78
connect_channel                        internal static fixed bin(6,0)           initial dcl 11-105
cp                                     automatic       pointer                  dcl 8-97
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 9-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 9-105
dev_time                               internal static float bin(27)            initial array dcl 9-139
device_names                           internal static char(4)                  initial array dcl 9-66
disk_channel_table                     based           structure                array level 1 dcl 8-94
disk_seg$                              external static fixed bin(17,0)          dcl 8-24
diskp                                  automatic       pointer                  dcl 8-26
disktab                                based           structure                level 1 dcl 8-74
dp                                     automatic       pointer                  dcl 8-187
dskdcl_chans_per_subsys                internal static fixed bin(17,0)          initial dcl 8-70
dskdcl_chans_per_subsys_shift          internal static fixed bin(17,0)          initial dcl 8-71
dsu181devt                             internal static fixed bin(4,0)           initial dcl 9-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 9-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 9-43
entry_offset                           internal static fixed bin(17,0)          initial dcl 21-78
fips3380devt                           internal static fixed bin(4,0)           initial dcl 9-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 9-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 9-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 9-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 9-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 9-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 9-124
hr_size                                internal static fixed bin(17,0)          initial dcl 14-31
iom_data$                              external static fixed bin(17,0)          dcl 11-11
iom_mailbox$                           external static fixed bin(17,0)          dcl 11-12
iom_mailbox_seg                        based           structure                level 1 dcl 11-83
iom_mailbox_seg_ptr                    automatic       pointer                  dcl 11-82
itp                                    based           structure                level 1 dcl 12-18
itp_unsigned                           based           structure                level 1 dcl 12-43
its_unsigned                           based           structure                level 1 dcl 12-30
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 9-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 9-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 9-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 9-127
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 9-121
lbx                                    internal static fixed bin(17,0)          initial dcl 13-42
log_message_data_class_lth             automatic       fixed bin(17,0)          dcl 23-21
log_message_data_lth                   automatic       fixed bin(17,0)          dcl 23-22
log_message_text_lth                   automatic       fixed bin(17,0)          dcl 23-20
log_segment                            based           structure                level 1 dcl 24-8
log_segment_max_size                   automatic       fixed bin(18,0)          dcl 24-4
lpx                                    internal static fixed bin(17,0)          initial dcl 13-42
max_buf_size                           internal static fixed bin(17,0)          initial dcl 14-32
maxdevt                                internal static fixed bin(4,0)           initial dcl 9-43
mc_size                                internal static fixed bin(17,0)          initial dcl 14-30
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 9-75
msu0400devt                            internal static fixed bin(4,0)           initial dcl 9-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 9-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 9-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 9-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 9-43
n_devices                              automatic       fixed bin(17,0)          dcl 11-14
name_seg                               based           structure                level 1 dcl 19-26
namep                                  automatic       pointer                  dcl 19-7
names_ptr                              automatic       pointer                  dcl 19-7
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 9-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 9-93
object_info                            based           structure                level 1 dcl 15-6
object_info_version_2                  internal static fixed bin(17,0)          initial dcl 15-60
optp                                   automatic       pointer                  dcl 8-26
path                                   based           structure                level 1 dcl 19-40
pathp                                  automatic       pointer                  dcl 19-7
push_offset                            internal static fixed bin(17,0)          initial dcl 21-78
pvt$                                   external static fixed bin(17,0)          dcl 16-9
pvt$array                              external static fixed bin(17,0)          dcl 17-18
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 17-19
pvtdi                                  based           structure                level 1 dcl 8-229
pvtdip                                 automatic       pointer                  dcl 8-187
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 9-87
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 9-90
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 21-78
return_offset                          internal static fixed bin(17,0)          initial dcl 21-78
sbx                                    internal static fixed bin(17,0)          initial dcl 13-42
scs$bos_processor_tag                  external static fixed bin(3,0)           dcl 18-137
scs$bos_restart_flags                  external static bit(8)                   dcl 18-135
scs$cam_pair                           external static fixed bin(71,0)          dcl 18-103
scs$cam_wait                           external static bit(8)                   dcl 18-104
scs$cfg_data                           external static fixed bin(71,0)          array dcl 18-150
scs$cfg_data_save                      external static fixed bin(71,0)          dcl 18-152
scs$connect_lock                       external static bit(36)                  dcl 18-132
scs$controller_config_size             external static fixed bin(14,0)          array dcl 18-164
scs$controller_data                    external static structure                array level 1 dcl 18-6
scs$cow                                external static structure                array level 1 dcl 18-65
scs$cow_ptrs                           external static structure                array level 1 dcl 18-77
scs$cpu_test_mask                      external static bit(72)                  dcl 18-96
scs$cpu_test_pattern                   external static bit(36)                  dcl 18-99
scs$cycle_priority_template            external static bit(7)                   dcl 18-172
scs$expanded_ports                     external static bit(1)                   array packed unaligned dcl 18-154
scs$fast_cam_pending                   external static bit(36)                  array dcl 18-140
scs$faults_initialized                 external static bit(1)                   dcl 18-138
scs$idle_aptep                         external static pointer                  array packed unaligned dcl 18-130
scs$interrupt_controller               external static fixed bin(3,0)           dcl 18-141
scs$mask_ptr                           external static pointer                  array packed unaligned dcl 18-110
scs$nprocessors                        external static fixed bin(17,0)          dcl 18-136
scs$number_of_masks                    external static fixed bin(17,0)          dcl 18-97
scs$open_level                         external static bit(72)                  dcl 18-94
scs$port_addressing_word               external static bit(3)                   array dcl 18-148
scs$port_data                          external static structure                array level 1 dcl 18-56
scs$processor                          external static bit(8)                   dcl 18-143
scs$processor_data_switch_value        external static bit(36)                  dcl 18-162
scs$processor_start_int_no             external static fixed bin(5,0)           dcl 18-142
scs$processor_start_mask               external static bit(72)                  dcl 18-95
scs$processor_start_pattern            external static bit(36)                  dcl 18-98
scs$processor_start_wait               external static bit(8)                   dcl 18-144
scs$processor_switch_compare           external static bit(36)                  array dcl 18-159
scs$processor_switch_data              external static bit(36)                  array dcl 18-157
scs$processor_switch_mask              external static bit(36)                  array dcl 18-160
scs$processor_switch_template          external static bit(36)                  array dcl 18-158
scs$processor_test_data                external static structure                level 1 dcl 18-114
scs$read_mask                          external static bit(36)                  array dcl 18-109
scs$reconfig_general_cow               external static structure                level 1 dcl 18-82
scs$reconfig_lock                      external static bit(36)                  dcl 18-133
scs$reconfig_locker_id                 external static char(32)                 dcl 18-167
scs$scas_page_table                    external static bit(36)                  array dcl 18-169
scs$set_cycle_switches                 external static bit(1)                   dcl 18-173
scs$set_mask                           external static bit(36)                  array dcl 18-108
scs$sys_level                          external static bit(72)                  dcl 18-93
scs$sys_trouble_pending                external static bit(1)                   dcl 18-139
scs$trouble_dbrs                       automatic       fixed bin(71,0)          array dcl 18-146
scs$trouble_flags                      external static bit(8)                   dcl 18-134
scux                                   based           structure                level 1 dcl 13-207
sd                                     based           structure                level 1 dcl 22-21
sd_ptr                                 automatic       pointer                  dcl 22-17
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 10-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 10-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 10-26
segnam                                 based           structure                level 1 dcl 19-31
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 9-78
special_status_channel                 internal static fixed bin(6,0)           initial dcl 11-105
spx                                    internal static fixed bin(17,0)          initial dcl 13-42
stack_header_overlay                   based           fixed bin(17,0)          array dcl 21-94
status_queue_ptr                       automatic       pointer                  dcl 11-91
syserr_data$syserr_area                external static char(1)                  dcl 22-14
syserr_data$wired_log_area             external static char(1)                  dcl 22-14
sysp                                   automatic       pointer                  dcl 8-26
system_fault_channel                   internal static fixed bin(6,0)           initial dcl 11-105
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 9-111
translation_table                      based           structure                level 1 dcl 4-13
tv_offset                              internal static fixed bin(17,0)          initial dcl 21-72
v1_dump                                based           structure                level 1 dcl 7-83
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 9-99
valid_sv_string                        internal static char(3)                  initial packed unaligned dcl 9-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 10-29
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 10-36
write_map                              defined         bit(1)                   array packed unaligned dcl 8-269
write_mapping                          internal static bit(7)                   initial packed unaligned dcl 8-268

NAMES DECLARED BY EXPLICIT CONTEXT.
COPY_ERR                        002512 constant        label                    dcl 394 ref 406
GLOBAL_RETURN                   003505 constant        label                    dcl 511
RETURN                          003511 constant        label                    dcl 513
SLOG_ERROR                      011706 constant        label                    dcl 1406 ref 1419 1425 1430
add_an_event                    003513 constant        entry                    internal dcl 522 ref 364 1092 1130 1179 1238 1332
                                                                                  1375 1452 1514 1727 1763
allocate_temp_seg               003623 constant        entry                    internal dcl 561 ref 319 320 352 425 609 637 639
azm_display_fdump_events        001464 constant        entry                    external dcl 45
cleanit                         003670 constant        entry                    internal dcl 578 ref 313 396 511
copy_pvt                        004023 constant        entry                    internal dcl 602 ref 134
copy_to_temporary               004100 constant        entry                    internal dcl 622 ref 1092 1092 1128 1178 1373 1451
                                                                                  1603 1726 1762
define_bpp                      011032 constant        label                    dcl 1318 ref 1312
do_the_hard_way                 014140 constant        label                    dcl 1736 ref 1713 1716
get_data                        004166 constant        entry                    internal dcl 650 ref 611 1073 1117 1169 1217 1303
                                                                                  1355 1417 1428 1554
get_trans                       004270 constant        entry                    internal dcl 673 ref 1687
jump_in                         014250 constant        label                    dcl 1755 ref 1747
mc_data_not_valid               013336 constant        label                    dcl 1606 ref 1599 1601
mh_or_ex                        014625 constant        entry                    internal dcl 1803 ref 730 748 804 1030 1041 1052
print_apte                      004366 constant        entry                    internal dcl 696 ref 1514 1514
print_device_data               004573 constant        entry                    internal dcl 737 ref 1179 1179
print_disk_queue                004716 constant        entry                    internal dcl 755 ref 1092 1092
print_dump_mc                   005223 constant        entry                    internal dcl 813 ref 364 364
print_mc                        005264 constant        entry                    internal dcl 831 ref 1130 1130 1238 1238 1332 1332
                                                                                  1727 1727 1763 1763
print_scu_data                  005667 constant        entry                    internal dcl 950 ref 822 844
print_syserr_log                005336 constant        entry                    internal dcl 851 ref 1452 1452
print_syserr_message            005425 constant        entry                    internal dcl 875 ref 865 942
print_wired_syserr              005573 constant        entry                    internal dcl 924 ref 1375 1375
process_disk_queue              006743 constant        entry                    internal dcl 1060 ref 134
process_inzr_stk0               007430 constant        entry                    internal dcl 1141 ref 134
process_iom_data                007514 constant        entry                    internal dcl 1159 ref 134
process_mc_trace_buf            007174 constant        entry                    internal dcl 1104 ref 134
process_pds                     007676 constant        entry                    internal dcl 1191 ref 134
process_prds                    010643 constant        entry                    internal dcl 1281 ref 134
process_syserr_data             011327 constant        entry                    internal dcl 1345 ref 134
process_syserr_log              011661 constant        entry                    internal dcl 1384 ref 417 418
process_tc_data                 012232 constant        entry                    internal dcl 1464 ref 134
process_user_stack              012712 constant        entry                    internal dcl 1526 ref 405
setup_from_scs                  012750 constant        entry                    internal dcl 1542 ref 134
stack_done                      014462 constant        label                    dcl 1772 ref 1708 1735 1785
stack_err_cond                  014502 constant        label                    dcl 1781 ref 1679 1683
valid_fim_ptr                   014543 constant        entry                    internal dcl 1788 ref 1721 1757
validate_mc                     013151 constant        entry                    internal dcl 1582 ref 1234 1329
validate_stack_ptr              013343 constant        entry                    internal dcl 1619 ref 1699 1706 1734 1770
walk_stack                      013450 constant        entry                    internal dcl 1653 ref 1152 1536

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     15740       16030   15050       15750
Length     17062   15050        70        1016     667           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
azm_display_fdump_events            482 external procedure  is an external procedure.  
on unit on line 313                  64 on unit               
add_an_event                         66 internal procedure  is called during a stack extension.  
allocate_temp_seg                    80 internal procedure  is called by several nonquick procedures.  
cleanit                              74 internal procedure  is called by several nonquick procedures.  
copy_pvt                             86 internal procedure  is assigned to an entry variable.  
copy_to_temporary                    74 internal procedure  is called by several nonquick procedures.  
get_data                             88 internal procedure  is called by several nonquick procedures.  
get_trans                               internal procedure  shares stack frame of internal procedure walk_stack.  
print_apte                          124 internal procedure  is assigned to an entry variable.  
print_device_data                    94 internal procedure  is assigned to an entry variable.  
print_disk_queue                    132 internal procedure  is assigned to an entry variable.  
print_dump_mc                        82 internal procedure  is assigned to an entry variable.  
print_mc                             84 internal procedure  is assigned to an entry variable.  
print_syserr_log                     98 internal procedure  is assigned to an entry variable.  
print_syserr_message                 98 internal procedure  is called by several nonquick procedures.  
print_wired_syserr                  100 internal procedure  is assigned to an entry variable.  
print_scu_data                      252 internal procedure  is called by several nonquick procedures.  
process_disk_queue                  128 internal procedure  is assigned to an entry variable.  
process_mc_trace_buf                168 internal procedure  is assigned to an entry variable.  
process_inzr_stk0                    89 internal procedure  is assigned to an entry variable.  
process_iom_data                    122 internal procedure  is assigned to an entry variable.  
process_pds                         174 internal procedure  is assigned to an entry variable.  
process_prds                        176 internal procedure  is assigned to an entry variable.  
process_syserr_data                 146 internal procedure  is assigned to an entry variable.  
process_syserr_log                      internal procedure  shares stack frame of external procedure azm_display_fdump_events.  
process_tc_data                     150 internal procedure  is assigned to an entry variable.  
process_user_stack                      internal procedure  shares stack frame of external procedure azm_display_fdump_events.  
setup_from_scs                      110 internal procedure  is assigned to an entry variable.  
validate_mc                         120 internal procedure  is called by several nonquick procedures.  
validate_stack_ptr                      internal procedure  shares stack frame of internal procedure walk_stack.  
walk_stack                          219 internal procedure  enables or reverts conditions.  
on unit on line 1678                 64 on unit               
on unit on line 1682                 64 on unit               
valid_fim_ptr                           internal procedure  shares stack frame of internal procedure walk_stack.  
mh_or_ex                             94 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
azm_display_fdump_events 000100 good_match                  azm_display_fdump_events
                         000101 temp_string                 azm_display_fdump_events
                         000142 temp_time                   azm_display_fdump_events
                         000153 tsl                         azm_display_fdump_events
                         000154 new_disk_dim_sw             azm_display_fdump_events
                         000156 apt_array_p                 azm_display_fdump_events
                         000160 apt_inx                     azm_display_fdump_events
                         000161 apt_proc_found              azm_display_fdump_events
                         000162 bmp                         azm_display_fdump_events
                         000164 bound_interceptors_ptr      azm_display_fdump_events
                         000166 cur_date_time               azm_display_fdump_events
                         000174 definitions_ptr             azm_display_fdump_events
                         000176 diskq_datap                 azm_display_fdump_events
                         000200 dom                         azm_display_fdump_events
                         000201 DOM                         azm_display_fdump_events
                         000202 dow                         azm_display_fdump_events
                         000204 dump_ptrs                   azm_display_fdump_events
                         000206 dump_seginx                 azm_display_fdump_events
                         000207 dump_segno                  azm_display_fdump_events
                         000210 earliest_recorded_time      azm_display_fdump_events
                         000212 earliest_time               azm_display_fdump_events
                         000214 event_inx                   azm_display_fdump_events
                         000215 events_by_time              azm_display_fdump_events
                         000216 events_printed              azm_display_fdump_events
                         000220 eventsp                     azm_display_fdump_events
                         000222 first_print                 azm_display_fdump_events
                         000224 hard_ptr_space              azm_display_fdump_events
                         000242 hr                          azm_display_fdump_events
                         000243 HR                          azm_display_fdump_events
                         000244 last_date_time              azm_display_fdump_events
                         000244 interesting_segs            azm_display_fdump_events
                         000251 last_sec                    azm_display_fdump_events
                         000252 last_segno                  azm_display_fdump_events
                         000254 micsec                      azm_display_fdump_events
                         000256 MICSEC                      azm_display_fdump_events
                         000260 minute                      azm_display_fdump_events
                         000261 MIN                         azm_display_fdump_events
                         000262 mon                         azm_display_fdump_events
                         000263 MON                         azm_display_fdump_events
                         000264 max_events                  azm_display_fdump_events
                         000266 nametbl_ptr                 azm_display_fdump_events
                         000270 prds_processor              azm_display_fdump_events
                         000271 proc_no                     azm_display_fdump_events
                         000272 process_number              azm_display_fdump_events
                         000273 range                       azm_display_fdump_events
                         000274 sci_ptr                     azm_display_fdump_events
                         000276 sec                         azm_display_fdump_events
                         000277 SEC                         azm_display_fdump_events
                         000300 seg_found                   azm_display_fdump_events
                         000301 seginx                      azm_display_fdump_events
                         000302 segp                        azm_display_fdump_events
                         000304 sortp                       azm_display_fdump_events
                         000306 sortinx                     azm_display_fdump_events
                         000307 sortinx1                    azm_display_fdump_events
                         000310 sortinxt                    azm_display_fdump_events
                         000311 stack_found                 azm_display_fdump_events
                         000312 stack_inx                   azm_display_fdump_events
                         000313 stack_segs                  azm_display_fdump_events
                         000324 temp_alloc_p                azm_display_fdump_events
                         000326 temp_seg_data_p             azm_display_fdump_events
                         000330 translation_space           azm_display_fdump_events
                         000336 tsegp                       azm_display_fdump_events
                         000340 words_copied                azm_display_fdump_events
                         000341 yr                          azm_display_fdump_events
                         000342 YR                          azm_display_fdump_events
                         000352 fp_table_ptr                azm_display_fdump_events
                         000354 hardcore_cur_ptr            azm_display_fdump_events
                         000356 amu_info_ptr                azm_display_fdump_events
                         000360 translation_ptr             azm_display_fdump_events
                         000362 aptep                       azm_display_fdump_events
                         000364 dumpptr                     azm_display_fdump_events
                         000366 disksp                      azm_display_fdump_events
                         000370 qp                          azm_display_fdump_events
                         000372 seek_command                azm_display_fdump_events
                         000374 iom_data_ptr                azm_display_fdump_events
                         000376 mcp                         azm_display_fdump_events
                         000400 scup                        azm_display_fdump_events
                         000402 bp                          azm_display_fdump_events
                         000404 pvtp                        azm_display_fdump_events
                         000406 pvt_arrayp                  azm_display_fdump_events
                         000410 pvtep                       azm_display_fdump_events
                         000412 sltp                        azm_display_fdump_events
                         000414 sp                          azm_display_fdump_events
                         000416 sb                          azm_display_fdump_events
                         000420 wlog_ptr                    azm_display_fdump_events
                         000422 wmess_ptr                   azm_display_fdump_events
                         000424 log_message_ptr             azm_display_fdump_events
                         000426 log_segment_ptr             azm_display_fdump_events
                         000460 code                        process_syserr_log
                         000462 slog_p                      process_syserr_log
                         000464 slog_no                     process_syserr_log
                         000465 last_offset                 process_syserr_log
                         000466 first_time                  process_syserr_log
                         000470 temp_message_ptr            process_syserr_log
                         000500 ring_num                    process_user_stack
cleanit                  000100 i                           cleanit
copy_to_temporary        000100 tlength                     copy_to_temporary
                         000102 tptr                        copy_to_temporary
get_data                 000100 index_changed               get_data
print_apte               000100 state_name                  print_apte
                         000103 process_na                  print_apte
                         000104 real_apte_offset            print_apte
print_disk_queue         000100 type_io                     print_disk_queue
                         000101 dev_num                     print_disk_queue
                         000102 diskadd                     print_disk_queue
                         000103 fsx                         print_disk_queue
                         000104 sect_sw                     print_disk_queue
                         000105 subsys_name                 print_disk_queue
print_mc                 000100 process_na                  print_mc
                         000101 process_num                 print_mc
print_scu_data           000100 cpu_alph                    print_scu_data
                         000101 fault_no                    print_scu_data
                         000102 fault_sub_type              print_scu_data
                         000103 hardware_interrupt_level    print_scu_data
                         000104 hardware_interrupt_no       print_scu_data
                         000105 interrupt_level             print_scu_data
                         000106 interrupt_no                print_scu_data
                         000107 iom_number                  print_scu_data
                         000110 line1                       print_scu_data
                         000135 ptsr                        print_scu_data
                         000136 exp_seg_name                print_scu_data
                         000237 seg_valid                   print_scu_data
                         000240 sub_type_inx                print_scu_data
print_syserr_message     000100 linel                       print_syserr_message
                         000101 textl_done                  print_syserr_message
                         000102 textl_total                 print_syserr_message
                         000103 trim_eol                    print_syserr_message
print_wired_syserr       000100 sequence                    print_wired_syserr
                         000101 severity                    print_wired_syserr
                         000102 textl                       print_wired_syserr
                         000104 textp                       print_wired_syserr
process_disk_queue       000100 disk_seg_ptr                process_disk_queue
                         000102 qx                          process_disk_queue
                         000104 queue_time                  process_disk_queue
                         000106 diskq_temp                  process_disk_queue
process_inzr_stk0        000100 code                        process_inzr_stk0
                         000102 segp                        process_inzr_stk0
process_iom_data         000100 iom_data_p                  process_iom_data
                         000102 dev_no                      process_iom_data
                         000104 per_device_p                process_iom_data
process_mc_trace_buf     000100 mctbp                       process_mc_trace_buf
                         000102 len                         process_mc_trace_buf
                         000104 mcptr                       process_mc_trace_buf
                         000106 mcx                         process_mc_trace_buf
                         000107 mc_seg_offset               process_mc_trace_buf
                         000120 mct_scu_ptr                 process_mc_trace_buf
process_pds              000100 pdsp                        process_pds
                         000102 aptp                        process_pds
                         000104 bpp                         process_pds
                         000106 mcptr                       process_pds
                         000110 mcp_scu_ptr                 process_pds
                         000112 names_inx                   process_pds
                         000113 pds_stacks_inx              process_pds
                         000114 pds_stacks_ptr              process_pds
process_prds             000100 prdsp                       process_prds
                         000102 mcptr                       process_prds
                         000104 mcp_scu_ptr                 process_prds
                         000106 names_inx                   process_prds
                         000107 processor_tag               process_prds
                         000110 prtagp                      process_prds
                         000112 apte_offset                 process_prds
                         000114 bpp                         process_prds
process_syserr_data      000100 syserr_data_ptr             process_syserr_data
                         000102 wlog_inx                    process_syserr_data
                         000104 wp                          process_syserr_data
                         000106 wtime                       process_syserr_data
process_tc_data          000100 aptx                        process_tc_data
                         000102 bp                          process_tc_data
                         000104 num_aptes                   process_tc_data
                         000105 size_of_apte                process_tc_data
                         000106 tp                          process_tc_data
                         000110 tp_base                     process_tc_data
                         000111 real_apte                   process_tc_data
                         000112 fixed_apte                  process_tc_data
setup_from_scs           000100 scs_ptr                     setup_from_scs
                         000102 proc_number                 setup_from_scs
                         000103 proc_exists_mask            setup_from_scs
                         000104 scs_proc_data_ptr           setup_from_scs
validate_mc              000100 mcptr                       validate_mc
walk_stack               000106 t_ptr                       get_trans
                         000116 the_hard_way                walk_stack
                         000117 d1_len                      walk_stack
                         000120 d2_len                      walk_stack
                         000121 d3_len                      walk_stack
                         000122 min_length                  walk_stack
                         000124 fm_scup                     walk_stack
                         000126 len                         walk_stack
                         000127 loop_count                  walk_stack
                         000130 next_frame_mc               walk_stack
                         000131 seg_offset                  walk_stack
                         000135 sp_offset                   walk_stack
                         000136 stack_frame_sw              walk_stack
                         000137 stack_header_sw             walk_stack
                         000140 sp_save                     walk_stack
                         000142 sb_save                     walk_stack
                         000166 its_ptr                     valid_fim_ptr

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ent_var
call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other
return_mac          move_label_var      make_label_var      tra_ext_1           alloc_auto_adj      mdfx1
mdfx3               enable_op           shorten_stack       ext_entry           int_entry           int_entry_desc
reverse_cs          set_chars_eis       index_chars_eis     index_bs_1_eis      divide_fx3          op_alloc_
op_freen_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$definition_offset        amu_$do_translation           amu_$error_for_caller         amu_$fdump_mpt_revert_idx
amu_$fdump_mpt_temp_change_idx                              amu_$fdump_translate_get_translation
amu_$get_name                 amu_$hardcore_info_set_cur_ptrs                             amu_$return_val_per_process
amu_$slt_search_seg_ptr       amu_$translate_get            decode_clock_value_$date_time ioa_
ioa_$nnl                      ioa_$rsnnl                    log_position_$next_message
log_segment_$last_message_info                              match_strings_$free           match_strings_$test
ssu_$get_temp_segment         ssu_$print_message            ssu_$release_temp_segment

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
scs$processor_data            sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     45 001456       113 001471       134 001473    9   84 001631       299 001720       300 001724       301 001727
    302 001731       303 001742       304 001747       305 001752       306 001755       307 001760       308 001762
    309 001763       310 001767       311 001771       312 001772       313 001773       317 002015       319 002035
    320 002043       325 002051       326 002061       327 002067       329 002110       331 002124       333 002164
    336 002166       337 002170       339 002214       340 002221       341 002223       343 002235       344 002236
    345 002240       347 002242       350 002251       352 002252       353 002260       357 002261       358 002263
    359 002271       362 002275       364 002276       368 002354       369 002365       370 002376       375 002407
    377 002412       378 002421       379 002431       380 002435       384 002445       385 002446       386 002450
    387 002455       389 002466       390 002467       391 002470       392 002500       393 002507       394 002512
    396 002552       397 002556       401 002557       402 002560       403 002567       405 002572       406 002574
    408 002577       410 002601       411 002603       412 002605       417 002607       418 002614       425 002621
    426 002627       427 002637       428 002641       430 002643       431 002653       432 002663       433 002701
    434 002704       435 002706       436 002710       437 002711       438 002712       440 002716       443 002722
    444 002724       451 002726       452 002730       453 002733       454 002735       455 002737       456 002744
    458 002752       459 002764       460 002773       461 002774       463 003032       464 003035       465 003045
    466 003055       467 003071       468 003101       469 003111       470 003121       471 003131       472 003205
    474 003245       475 003247       476 003263       478 003264       479 003272       481 003325       482 003363
    483 003365       486 003403       488 003413       489 003415       490 003416       491 003420       492 003425
    494 003440       495 003442       496 003446       497 003447       498 003450       502 003451       508 003503
    511 003505       513 003511       522 003512       534 003526       535 003536       536 003537       537 003546
    538 003551       539 003561       540 003567       541 003573       542 003603       543 003605       545 003611
    547 003621       561 003622       564 003630       565 003656       567 003660       578 003667       583 003675
    584 003702       585 003711       586 003732       587 003734       588 003746       590 003751       591 003766
    592 004004       594 004021       602 004022       607 004030       608 004033       609 004042       610 004051
    611 004055       613 004076       622 004077       636 004105       637 004113       639 004130       641 004144
    642 004147       643 004153       644 004163       650 004165       656 004173       660 004174       661 004213
    662 004215       664 004230       665 004253       666 004256       667 004266       669 004267       673 004270
    680 004272       681 004312       683 004322       684 004325       686 004351       687 004361       696 004365
    711 004401       712 004406       714 004417       716 004423       717 004434       723 004444       729 004532
    730 004560       732 004571       737 004572       746 004606       747 004655       748 004703       750 004714
    755 004715       772 004736       773 004743       774 004745       775 004751       776 004753       777 004755
    778 004757       779 004761       781 004762       782 004765       783 004771       784 005003       785 005005
    786 005017       787 005035       788 005041       791 005050       792 005053       799 005077       803 005162
    804 005210       806 005221       813 005222       822 005236       825 005262       831 005263       842 005277
    843 005311       844 005313       847 005334       851 005335       864 005351       865 005356       869 005423
    875 005424       902 005440       904 005470       905 005476       906 005477       907 005500       908 005502
    909 005504       910 005506       911 005510       912 005532       914 005535       915 005563       916 005565
    917 005570       920 005571       924 005572       937 005606       938 005613       939 005615       940 005620
    941 005624       942 005626       944 005665       950 005666       997 005707       999 005710      1000 005715
   1001 005724      1002 005727      1003 005733      1004 005751      1005 005756      1006 005760      1007 005765
   1008 005772      1011 006061      1012 006062      1014 006063      1015 006064      1016 006070      1017 006072
   1018 006075      1019 006105      1020 006121      1022 006123      1023 006140      1024 006147      1025 006176
   1028 006177      1029 006247      1030 006275      1032 006306      1033 006315      1034 006316      1036 006364
   1037 006376      1040 006465      1041 006513      1043 006524      1045 006526      1046 006530      1048 006601
   1049 006613      1051 006702      1052 006730      1056 006741      1060 006742      1069 006750      1070 006753
   1071 006755      1072 006763      1073 006765      1074 007005      1075 007011      1076 007013      1077 007015
   1078 007021      1079 007022      1081 007023      1082 007033      1083 007041      1085 007051      1086 007054
   1087 007060      1088 007063      1089 007066      1090 007071      1091 007075      1092 007077      1095 007170
   1097 007172      1104 007173      1116 007201      1117 007204      1118 007225      1119 007231      1121 007233
   1122 007235      1124 007237      1125 007251      1126 007267      1127 007272      1128 007331      1130 007351
   1134 007424      1136 007426      1141 007427      1149 007435      1150 007437      1151 007462      1152 007464
   1154 007512      1159 007513      1168 007521      1169 007524      1170 007545      1171 007551      1174 007553
   1175 007555      1176 007557      1178 007567      1179 007611      1181 007672      1184 007674      1191 007675
   1216 007703      1217 007706      1218 007727      1219 007733      1220 007735      1221 007776      1222 010002
   1225 010034      1226 010040      1228 010044      1229 010046      1230 010052      1233 010055      1234 010063
   1236 010115      1238 010121      1241 010231      1242 010232      1246 010234      1247 010277      1248 010303
   1250 010335      1251 010342      1252 010346      1253 010353      1255 010373      1256 010377      1260 010401
   1261 010447      1262 010453      1265 010505      1266 010511      1267 010513      1268 010561      1269 010565
   1271 010617      1272 010623      1273 010630      1276 010641      1281 010642      1302 010650      1303 010653
   1304 010674      1305 010700      1306 010702      1307 010747      1308 010753      1310 011005      1311 011011
   1312 011013      1314 011015      1316 011022      1317 011025      1318 011032      1320 011075      1321 011101
   1323 011133      1325 011141      1328 011145      1329 011153      1331 011205      1332 011211      1337 011322
   1338 011323      1341 011325      1345 011326      1354 011334      1355 011337      1356 011360      1357 011364
   1360 011366      1362 011370      1363 011441      1364 011444      1367 011476      1368 011503      1370 011506
   1372 011513      1373 011521      1374 011554      1375 011562      1376 011635      1377 011656      1380 011660
   1384 011661      1404 011663      1405 011704      1406 011706      1409 011745      1412 011746      1416 011752
   1417 011754      1419 011774      1424 012000      1425 012017      1427 012021      1428 012023      1430 012043
   1435 012047      1436 012051      1437 012055      1439 012057      1440 012066      1441 012067      1449 012104
   1451 012120      1452 012152      1456 012227      1458 012230      1464 012231      1479 012237      1483 012241
   1484 012245      1485 012250      1486 012312      1487 012316      1489 012350      1490 012354      1491 012356
   1492 012357      1493 012426      1494 012432      1497 012464      1498 012470      1499 012472      1502 012473
   1503 012537      1504 012542      1507 012574      1509 012601      1510 012611      1512 012620      1513 012631
   1514 012634      1518 012702      1519 012707      1522 012711      1526 012712      1535 012714      1536 012725
   1538 012746      1542 012747      1553 012755      1554 012760      1555 013001      1556 013005      1558 013007
   1559 013011      1560 013012      1561 013057      1562 013063      1565 013115      1567 013121      1568 013125
   1570 013133      1571 013135      1574 013147      1582 013150      1594 013171      1595 013232      1596 013236
   1599 013301      1601 013305      1603 013312      1604 013332      1605 013335      1606 013336      1608 013341
   1612 013342      1619 013343      1626 013345      1631 013357      1633 013367      1635 013375      1637 013404
   1643 013443      1653 013447      1678 013463      1679 013477      1682 013502      1683 013516      1685 013521
   1686 013524      1687 013527      1688 013540      1689 013545      1690 013550      1691 013553      1693 013557
   1695 013567      1696 013573      1697 013577      1698 013601      1699 013625      1701 013643      1702 013645
   1703 013650      1706 013651      1708 013672      1710 013675      1711 013677      1712 013700      1713 013702
   1714 013704      1716 013713      1719 013724      1720 013730      1721 013732      1722 013746      1723 013752
   1724 013755      1726 014012      1727 014033      1731 014107      1732 014110      1733 014117      1734 014121
   1735 014137      1736 014140      1739 014145      1741 014156      1742 014161      1743 014166      1744 014171
   1745 014222      1746 014226      1747 014227      1751 014230      1754 014237      1755 014250      1757 014254
   1758 014271      1759 014275      1760 014300      1762 014335      1763 014356      1767 014432      1768 014433
   1769 014442      1770 014444      1772 014462      1774 014463      1775 014464      1777 014472      1779 014476
   1780 014501      1781 014502      1785 014542      1788 014543      1794 014545      1795 014557      1796 014561
   1797 014572      1798 014602      1799 014617      1803 014624      1808 014632      1809 014640      1810 014661
   1812 014662      1814 014706      1815 014755      1816 015000      1818 015006


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
