	COMPILATION LISTING OF SEGMENT test_dcw
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/18/86  1354.9 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(86-06-04,Hartogs), approve(86-06-04,MCR7383),
       15*     audit(86-06-05,Coppola), install(86-07-18,MR12.0-1098):
       16*     Changed to user version constants in rcp_disk_info.incl.pl1,
       17*     rcp_device_info.incl.pl1, and rcp_printer_info.incl.pl1.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* TEST_DCW: a program to build dcw lists to test an I/O device */
       22 
       23 /* Written in bits and pieces from 1975 to March 1977 by Larry Johnson */
       24 /* Modified August 1977 by Larry Johnson to automatically supply device address in idcws */
       25 /* Modified December 1978 by Michael R. Jordan for version 2 tape info */
       26 /* Modified January 1980 by Larry Johnson for get_detailed_status and get_spacial_status commands */
       27 
       28 test_dcw: proc;
       29 
       30 /* Automatic storage */
       31 
       32 dcl  dcw_list (32, 32) bit (36);			/* A table of 32 different lists */
       33 dcl  pcw_list (32) bit (36);				/* One PCW for each list */
       34 dcl  list fixed bin init (1);				/* The "current" list */
       35 dcl  idx fixed bin init (1);				/* Position in the current list */
       36 dcl  dcw_len (32) fixed bin;				/* Length of each list */
       37 dcl  input_line char (132);				/* A command line read from the terminal */
       38 dcl  input_len fixed bin (21);			/* The actual length of that line */
       39 dcl  input_pos fixed bin;				/* The current char position in scanning input_line */
       40 dcl  word char (132);				/* A word extracted from the input line */
       41 dcl  code fixed bin (35);				/* A standard system status code */
       42 dcl  temp_char char (1);				/* To hold 1 character */
       43 dcl (i, j) fixed bin;				/* A temporary index */
       44 dcl  end_line bit (1);				/* Set when end of line reached */
       45 dcl  octal_word bit (1);				/* Set if current word will convert to octal */
       46 dcl  octal_val fixed bin (35);			/* Value of current word if converted to octal */
       47 dcl  dec_word bit (1);				/* Set if word will convert to decimal */
       48 dcl  dec_val fixed bin (35);				/* Value if convert to decimal */
       49 dcl  insert_mode bit (1) init ("0"b);			/* Set if insert mode, reset if replace mode */
       50 dcl  output_line char (128) var;			/* For building line to print */
       51 dcl  out_temp char (64) var;				/* Temp area for building output strings */
       52 dcl  pcw_sw bit (1);				/* Set if pcw is being built */
       53 dcl  devx fixed bin init (-1);			/* Ioi device index */
       54 dcl  exec_rept_cnt fixed bin;				/* Count of repeated executions */
       55 dcl (dp_loc, dp_len, dp_rpt) fixed bin;			/* Indexes for dumps and patches */
       56 dcl  dp_byte bit (1);				/* Set when dumping binary bytes */
       57 dcl  arg_cnt fixed bin;				/* Number of command arguments */
       58 dcl  arg_ptr ptr;					/* A pointer to a command argument */
       59 dcl  arg_len fixed bin;				/* The length of that argument */
       60 dcl  arg char (arg_len) based (arg_ptr);		/* Hence, this is the argument */
       61 dcl  survey_ptr ptr;				/* Pointer to survey devices data */
       62 dcl  time_limit fixed bin (52);			/* Connect time limit - 30 seconds initially */
       63 dcl  dev_name char (16) varying;			/* This will be name of device assigned */
       64 dcl  dev_type char (16) varying;			/* Generic device type */
       65 dcl  id_name char (16) varying;			/* This will be the pack id or tape volume */
       66 dcl  priv_sw bit (1) init ("0"b);			/* Will be 1 if -priv specified */
       67 dcl  write_sw bit (1) init ("1"b);			/* Will be "0" if -read specified */
       68 dcl  debug_sw bit (1) init ("0"b);			/* Set if -db used */
       69 dcl  prompt_msg char (10) varying init ("");		/* Promt character for command input */
       70 dcl  rcp_id bit (36) aligned init ("0"b);		/* RCP_ attachment id */
       71 dcl  rcp_state fixed bin;				/* State code returned by rcp_$check_attach */
       72 dcl  max_time fixed bin (71);				/* Max time limit for connects */
       73 dcl  max_work fixed bin (19);				/* Max buffer size supported by ioi_ */
       74 dcl  rcp_info_ptr ptr;				/* Pointer to the rcp info block being used */
       75 dcl  sys_sw bit (1) init ("0"b);			/* Set if -sys control argument specified */
       76 dcl  list_name (32) char (8);				/* Names of dcs lists */
       77 dcl  new_name char (8);
       78 dcl  dcw_word bit (36) aligned;			/* Dcws are built here */
       79 dcl  something_printed bit (1);
       80 dcl  track_sw bit (1) aligned init ("0"b);		/* "1"b if -7track specified */
       81 dcl  exec_spec_sw bit (1);				/* Set when exec command requires special */
       82 dcl  exec_no_err_sw bit (1);				/* Set when exec command to ignore error */
       83 dcl  exec_rept_sw bit (1);				/* Set when executing in repeat mode */
       84 dcl  iom fixed bin (3);				/* Required iom number if chan command used */
       85 dcl  chan fixed bin (6);				/* Required channel if chan command used */
       86 dcl  ptr_array (1) ptr init (null);			/* For get temp segments */
       87 dcl  new_work_size fixed bin (18);
       88 dcl  flush_sw bit (1);
       89 dcl  dir char (168);
       90 dcl  unsuffixed_ename char (32);
       91 dcl  ename char (32);
       92 dcl  time_string char (24);
       93 dcl  status_tablep ptr;				/* Address of appropriate status table */
       94 dcl  status_mode fixed bin init (1);			/* 1=brief, 2=long, 3=edited */
       95 dcl  save_status_mode fixed bin;
       96 dcl  default_device bit (6);				/* Device number to put in all idcws */
       97 dcl  stat_found bit (1) aligned;
       98 dcl  spec_status bit (36) aligned;
       99 dcl  detailed_status bit (6*36);
      100 dcl  detailed_status_array (1:27) bit (8) unal based (addr (detailed_status));
      101 
      102 dcl 1 my_tape_info like tape_info aligned automatic;	/* Copy of rcp_tape_info in my stack */
      103 dcl 1 my_disk_info like disk_info aligned automatic;	/* Copy of rcp_disk_info in my stack */
      104 dcl 1 my_printer_info like printer_info aligned automatic;	/* Copy of rcp_printer_info in my stack */
      105 dcl 1 my_device_info like device_info aligned automatic;	/* Copy of rcp_device_info in my stack */
      106 
      107 /* Format of detailed status returned by mtc500 handler */
      108 
      109 dcl  dtstp ptr;					/* Pointer to the structure */
      110 
      111 dcl 1 dt_stat aligned based (dtstp),			/* The detailed status structure */
      112 						/* ... Byte # 0 ... */
      113    (2 devflt bit (1),				/* Device Fault */
      114     2 ccerr bit (1),				/* Command code error */
      115     2 rawerr bit (1),				/* Read-after_write error */
      116     2 mbot bit (1),					/* Multiple BOTs */
      117     2 bot bit (1),					/* BOT */
      118     2 eot bit (1),					/* EOT */
      119     2 standby bit (1),				/* Standby state */
      120     2 marg bit (1),					/* Marginal condition */
      121 						/* ... Byte # 1 ... */
      122     2 loaded bit (1),				/* Loaded (standby) */
      123     2 lcw bit (1),					/* Last command write */
      124     2 lcf bit (1),					/* Last command forward */
      125     2 rewind bit (1),				/* Rewinding */
      126     2 wpr bit (1),					/* Write permit ring */
      127     2 spr bit (1),					/* Software write permit */
      128     2 diag bit (1),					/* Diagnostic mode */
      129     2 ccpe bit (1),					/* Command code parity even */
      130 						/* ... Byte # 2 ... */
      131     2 denr bit (3),					/* Density return */
      132     2 lowt bit (1),					/* Low threshold */
      133     2 denc bit (4),					/* Recording capability */
      134 						/* ... Byte # 3 ... */
      135     2 speed bit (5),				/* Device speed */
      136     2 track bit (1),				/* 7/9 channel */
      137     2 nsbot bit (1),				/* Non-standard BOT */
      138     2 mbz1 bit (1),					/* Must be zero */
      139 						/* ... Byte # 4 ... */
      140     2 dms bit (1),					/* Device multiple select */
      141     2 mbz2 bit (2),					/* Must be zero */
      142     2 addr bit (5)) unal;				/* Physical device address */
      143 
      144 dcl  speed_constant (0:15) char (5) var int static options (constant) init ("16", "18.75", "24", "25", "35", "37.5",
      145      "45", "48", "70", "75", "80", "105", "120", "125", "150", "200");
      146 
      147 dcl 1 survey_table (16) unaligned based (survey_ptr),	/* Tape data returned by survey devices */
      148    (2 pad1 bit (1),
      149     2 hand_resv bit (1),				/* Handler reserved */
      150     2 hand_op bit (1),				/* Handler operational */
      151     2 hand_ready bit (1),				/* Handler ready */
      152     2 hand_addr bit (5),				/* Handler address */
      153     2 pad2 bit (1),
      154     2 hand_speed bit (3),				/* Handler speed */
      155     2 hand_track bit (1),				/* 7/9 track code */
      156     2 hand_record bit (4)) unaligned;			/* Handler recording capability */
      157 
      158 /* Ioi buffer area */
      159 
      160 dcl  workp ptr;					/* Pointer to it */
      161 dcl  work_size fixed bin (18) init (1024);		/* Size of segment */
      162 dcl  work_seg (work_size) bit (36) aligned based (workp);	/* The ioi workspace buffer */
      163 						/* Words 1 to 32 reserved for dcw list */
      164 						/* Words 33 to 64 reserved for status queue */
      165 
      166 dcl  byte_ptr ptr;					/* Pointer to bytes in work area */
      167 dcl  nbytes fixed bin;				/* Number of bytes in question */
      168 
      169 dcl 1 bin_bytes aligned based (byte_ptr),
      170     2 bbyte (nbytes) bit (8) unaligned;			/* An array of bytes */
      171 
      172 dcl 1 event_list,					/* A list of ipc events */
      173     2 ev_count fixed bin init (1),			/* Always 1 entry */
      174     2 ev_chan fixed bin (71) init (-1);			/* And this is it */
      175 
      176 dcl 1 event_info,					/* Structure returned by ipc */
      177     2 channel_id fixed bin (71),
      178     2 message fixed bin (71),
      179     2 sender bit (36),
      180     2 origin,
      181       3 dev_signal bit (18) unaligned,
      182       3 ring bit (18) unaligned,
      183     2 channel_index fixed bin;
      184 
      185 
      186 /* Structure define a segment where test_dcw data is saved */
      187 
      188 dcl  save_segp ptr init (null);
      189 
      190 dcl 1 save_seg aligned based (save_segp),
      191     2 version fixed bin,
      192     2 code char (16),
      193     2 time fixed bin (71),
      194     2 pcw_list (32) bit (36) aligned,
      195     2 dcw_len (32) fixed bin,
      196     2 list_name (32) char (8),
      197     2 dcw_list (32, 32) bit (36) aligned;
      198 
      199 dcl  save_seg_code char (16) int static options (constant) init ("*test_dcw data*");
      200 
  1     1 
  1     2 /* Begin include file ...... ioi_stat.incl.pl1 */
  1     3 /* Last modified 3/24/75 by Noel I. Morris */
  1     4 
  1     5 dcl  isp ptr;					/* pointer to status structure */
  1     6 
  1     7 dcl 1 istat based (isp) aligned,			/* I/O Interfacer status structure */
  1     8     2 completion,					/* completion flags */
  1     9      (3 st bit (1),					/* "1"b if status returned */
  1    10       3 er bit (1),					/* "1"b if status indicates error condition */
  1    11       3 run bit (1),				/* "1"b if channel still running */
  1    12       3 time_out bit (1)) unal,			/* "1"b if time-out occurred */
  1    13     2 level fixed bin (3),				/* IOM interrupt level */
  1    14     2 offset fixed bin (18),				/* DCW list offset */
  1    15     2 absaddr fixed bin (24),				/* absolute address of workspace */
  1    16     2 iom_stat bit (72),				/* IOM status */
  1    17     2 lpw bit (72);					/* LPW residue */
  1    18 
  1    19 dcl  imp ptr;					/* pointer to message structure */
  1    20 
  1    21 dcl 1 imess based (imp) aligned,			/* I/O Interfacer event message structure */
  1    22    (2 completion like istat.completion,			/* completion flags */
  1    23     2 pad bit (11),
  1    24     2 level bit (3),				/* interrupt level */
  1    25     2 offset bit (18),				/* DCW list offset */
  1    26     2 status bit (36)) unal;				/* first 36 bits of status */
  1    27 
  1    28 /* End of include file ...... ioi_stat.incl.pl1 */
  1    29 
      201 
      202 
      203 /* Areas for handling status */
      204 
      205 dcl 1 stat like istat aligned automatic;		/* Ioi_stat structure in my stack */
      206 dcl 1 status_queue (4) like istat aligned based (sqptr);	/* Status queue in ioi buffer */
      207 dcl  sqptr ptr;					/* Pointer to status queue */
      208 dcl  status_index fixed bin;				/* Current status queue entry */
      209 
      210 
  2     1 
  2     2 /* Begin include file ...... iom_stat.incl.pl1 */
  2     3 /* Last modified on 10/31/74 by Noel I. Morris */
  2     4 
  2     5 dcl  statp ptr;					/* pointer to status */
  2     6 
  2     7 dcl 1 status based (statp) aligned,			/* IOM status information */
  2     8      (2 t bit (1),					/* set to "1"b by IOM */
  2     9       2 power bit (1),				/* non-zero if peripheral absent or power off */
  2    10       2 major bit (4),				/* major status */
  2    11       2 sub bit (6),				/* substatus */
  2    12       2 eo bit (1),					/* even/odd bit */
  2    13       2 marker bit (1),				/* non-zero if marker status */
  2    14       2 soft bit (2),				/* software status */
  2    15       2 initiate bit (1),				/* initiate bit */
  2    16       2 abort bit (1),				/* software abort bit */
  2    17       2 channel_stat bit (3),				/* IOM channel status */
  2    18       2 central_stat bit (3),				/* IOM central status */
  2    19       2 mbz bit (6),
  2    20       2 rcount bit (6),				/* record count residue */
  2    21       2 address bit (18),				/* DCW address residue */
  2    22       2 char_pos bit (3),				/* character position residue */
  2    23       2 r bit (1),					/* non-zero if reading */
  2    24       2 type bit (2),				/* type of last DCW */
  2    25       2 tally bit (12)) unal;				/* DCW tally residue */
  2    26 
  2    27 dcl 1 faultword based (statp) aligned,			/* system fault word */
  2    28      (2 mbz1 bit (9),
  2    29       2 channel bit (9),				/* channel number */
  2    30       2 serv_req bit (5),				/* service request */
  2    31       2 mbz2 bit (3),
  2    32       2 controller_fault bit (4),			/* system controller fault code */
  2    33       2 io_fault bit (6)) unal;			/* I/O fault code */
  2    34 
  2    35 dcl 1 special_status based (statp) aligned,		/* special status from PSIA */
  2    36    (2 t bit (1),					/* entry present bit */
  2    37     2 channel bit (8),				/* channel number */
  2    38     2 pad1 bit (3),
  2    39     2 device bit (6),				/* device address */
  2    40     2 pad2 bit (1),
  2    41     2 byte2 bit (8),				/* device dependent information */
  2    42     2 pad3 bit (1),
  2    43     2 byte3 bit (8)) unal;				/* device dependent information */
  2    44 
  2    45 /* End of include file iom_stat.incl.pl1 */
  2    46 
      211 
      212 
      213 
  3     1 /*	Begin  include file rcp_tape_info.incl.pl1
  3     2*   *
  3     3*   *	Created on 12/16/74 by Bill Silver.
  3     4*   *	Modified on 11/17/78 by Michael R. Jordan to add speed qualifier.
  3     5*   *	Modified on 09/30/82 by J. A. Bush for version 3 structure info
  3     6*   *	This include file defines the RCP device info structure for tapes.
  3     7**/
  3     8 /* format: style4 */
  3     9 
  3    10 dcl  tape_info_ptr ptr;				/* Pointer to tape device info structure. */
  3    11 
  3    12 dcl  tape_info_version_2 fixed bin internal static options (constant) init (2);
  3    13 dcl  tape_info_version_3 fixed bin internal static options (constant) init (3);
  3    14 
  3    15 dcl  1 tape_info based (tape_info_ptr) aligned,		/* RCP device info structure for tapes. */
  3    16        2 version_num fixed bin,			/* Version number of this structure. */
  3    17        2 usage_time fixed bin,			/* Number of minutes drive will/may be used. */
  3    18        2 wait_time fixed bin,				/* Number of minutes user will/must wait. */
  3    19        2 system_flag bit (1),				/* ON => user wants to be a system process. */
  3    20        2 device_name char (8),			/* Tape drive name. */
  3    21        2 model fixed bin,				/* Tape drive model number. */
  3    22        2 tracks fixed bin,				/* Track type, 7 or 9. */
  3    23        2 density bit (36),				/* Density capability: 200, 556, 800, 1600, 6250. */
  3    24        2 speed bit (36),				/* Speed: 75, 125, 200. */
  3    25        2 unused_qualifier bit (36),			/* Unused qualifier (must be "0"b). */
  3    26        2 volume_name char (32),			/* Tape reel name. */
  3    27        2 write_flag bit (1),				/* ON => writing on tape reel. */
  3    28        2 position_index fixed bin (35),			/* Counter used to determine tape reel position. */
  3    29 
  3    30 /* Limit of version 2 structure, info below returned if version 3 or greater */
  3    31 
  3    32        2 volume_type fixed bin,			/* Use rcp_volume_formats.incl.pl1 for decodes */
  3    33        2 volume_density fixed bin,			/* 1 - 5 = 200, 556, 800, 1600, or 6250 BPI */
  3    34        2 opr_auth bit (1);				/* "1"b => Operator Authentication was required */
  3    35 
  3    36 /*	End of include file ... rcp_tape_info.incl.pl1	*/
      214 
      215 
  4     1 /*	Begin  include file rcp_disk_info.incl.pl1
  4     2**
  4     3**	Created on 03/31/74 by Bill Silver.
  4     4**	This include file defines the RCP device info structure for disks.
  4     5**/
  4     6 
  4     7 
  4     8 
  4     9 
  4    10 /****^  HISTORY COMMENTS:
  4    11*  1) change(86-06-03,Hartogs), approve(86-06-03,MCR7383),
  4    12*     audit(86-06-06,GWMay), install(86-07-18,MR12.0-1098):
  4    13*     Added DISK_INFO_VERSION_1 constant.
  4    14*                                                   END HISTORY COMMENTS */
  4    15 
  4    16 
  4    17 dcl	disk_info_ptr	ptr;		/* Pointer to disk device info structure. */
  4    18 
  4    19 dcl    1	disk_info based(disk_info_ptr) aligned,	/* RCP device info structure for disks. */
  4    20 	2  version_num	fixed bin,	/* Version number of this structure. */
  4    21 	2  usage_time	fixed bin,	/* Number of minutes drive will/may be used. */
  4    22 	2  wait_time	fixed bin,	/* Number of minutes user will/must wait. */
  4    23 	2  system_flag	bit(1),		/* ON => user wants to be a system process. */
  4    24 	2  device_name	char(8),		/* Disk drive name. */
  4    25 	2  model		fixed bin,	/* Disk drive model number. */
  4    26 	2  volume_name	char(32),		/* Disk pack name. */
  4    27 	2  write_flag	bit(1);		/* ON => writing on disk pack. */
  4    28 
  4    29 dcl       DISK_INFO_VERSION_1 fixed bin int static options (constant) init (1);
  4    30 
  4    31 /*	End of include file ... rcp_disk_info.incl.pl1	*/
      216 
      217 
  5     1 /*	Begin  include file rcp_printer_info.incl.pl1
  5     2**
  5     3**	Created on 01/08/75 by Bill Silver.
  5     4**	This include file defines the RCP device info structure for printers.
  5     5**/
  5     6 
  5     7 
  5     8 /****^  HISTORY COMMENTS:
  5     9*  1) change(86-06-04,Hartogs), approve(86-06-04,MCR7383),
  5    10*     audit(86-06-05,Coppola), install(86-07-18,MR12.0-1098):
  5    11*     Added version constant PRINTER_INFO_VERSION_1.
  5    12*                                                   END HISTORY COMMENTS */
  5    13 
  5    14 
  5    15 dcl	printer_info_ptr	ptr;		/* Pointer to printer device info structure. */
  5    16 
  5    17 dcl    1	printer_info based(printer_info_ptr) aligned,  /* RCP device info structure for printers. */
  5    18 	2  version_num	fixed bin,	/* Version number of this structure. */
  5    19 	2  usage_time	fixed bin,	/* Number of minutes printer will/may be used. */
  5    20 	2  wait_time	fixed bin,	/* Number of minutes user will/must wait. */
  5    21 	2  system_flag	bit(1),		/* ON => user wants to be a system process. */
  5    22 	2  device_name	char(8),		/* Printer name. */
  5    23 	2  model		fixed bin,	/* Printer model number. */
  5    24 	2  print_train	fixed bin,	/* Print train type. */
  5    25 	2  line_length	fixed bin;	/* Printer line length.  -1 => not specified. */
  5    26 
  5    27 dcl PRINTER_INFO_VERSION_1 fixed bin int static options (constant) init (1);
  5    28 
  5    29 /*	End of include file ... rcp_printer_info.incl.pl1	*/
      218 
      219 
  6     1 /*	Begin include file ... rcp_resource_types.incl.pl1
  6     2*   *
  6     3*   *	Created 3/79 by Michael R. Jordan for MR7.0R
  6     4*   *
  6     5*   *	This include file defines the official RCP resource types.
  6     6*   *	The array of names is indexed by the corresponding device type.
  6     7*   *      MOD by RAF for MCA
  6     8**/
  6     9 
  6    10 
  6    11 
  6    12 /****^  HISTORY COMMENTS:
  6    13*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  6    14*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  6    15*     Support of MCA.
  6    16*                                                   END HISTORY COMMENTS */
  6    17 
  6    18 dcl  DEVICE_TYPE (8) char (32)
  6    19 	internal static options (constant)
  6    20 	init ("tape_drive", "disk_drive", "console", "printer", "punch", "reader", "special", "mca");
  6    21 
  6    22 dcl  NUM_QUALIFIERS (8) fixed bin			/* Number of qualifiers for each device type. */
  6    23 	internal static init (3, 0, 0, 2, 0, 0, 0, 0);
  6    24 
  6    25 dcl  VOLUME_TYPE (8) char (32)
  6    26 	internal static options (constant)
  6    27 	init ("tape_vol", "disk_vol", "", "", "", "", "", "");
  6    28 
  6    29 dcl  TAPE_DRIVE_DTYPEX fixed bin static internal options (constant) init (1);
  6    30 dcl  DISK_DRIVE_DTYPEX fixed bin static internal options (constant) init (2);
  6    31 dcl  CONSOLE_DTYPEX fixed bin static internal options (constant) init (3);
  6    32 dcl  PRINTER_DTYPEX fixed bin static internal options (constant) init (4);
  6    33 dcl  PUNCH_DTYPEX fixed bin static internal options (constant) init (5);
  6    34 dcl  READER_DTYPEX fixed bin static internal options (constant) init (6);
  6    35 dcl  SPECIAL_DTYPEX fixed bin static internal options (constant) init (7);
  6    36 dcl  MCA_DTYPEX fixed bin static internal options (constant) init (8);
  6    37 dcl  TAPE_VOL_VTYPEX fixed bin static internal options (constant) init (1);
  6    38 dcl  DISK_VOL_VTYPEX fixed bin static internal options (constant) init (2);
  6    39 
  6    40 
  6    41 /*	End include file ... rcp_resource_types.incl.pl1 */
      220 
      221 
  7     1 /*	Begin  include file rcp_device_info.incl.pl1
  7     2**
  7     3**	Created on 01/08/75 by Bill Silver.
  7     4**	This include file defines the RCP device info structure for a general device.
  7     5**/
  7     6 
  7     7 
  7     8 /****^  HISTORY COMMENTS:
  7     9*  1) change(86-06-04,Hartogs), approve(86-06-04,MCR7383),
  7    10*     audit(86-06-05,Coppola), install(86-07-18,MR12.0-1098):
  7    11*     Added DEVICE_INFO_VERSION_1 constant.
  7    12*                                                   END HISTORY COMMENTS */
  7    13 
  7    14 
  7    15 dcl	device_info_ptr	ptr;		/* Pointer to general device info structure. */
  7    16 
  7    17 dcl    1	device_info based(device_info_ptr) aligned,  /* RCP device info structure for any device. */
  7    18 	2  version_num	fixed bin,	/* Version number of this structure. */
  7    19 	2  usage_time	fixed bin,	/* Number of minutes device will/may be used. */
  7    20 	2  wait_time	fixed bin,	/* Number of minutes user will/must wait. */
  7    21 	2  system_flag	bit(1),		/* ON => user wants to be a system process. */
  7    22 	2  device_name	char(8),		/* Device name. */
  7    23 	2  model		fixed bin,	/* Device model number. */
  7    24 	2  qualifiers(4)	fixed bin(35);	/* Qualifying characteristics. */
  7    25 
  7    26 dcl DEVICE_INFO_VERSION_1 fixed bin int static options (constant) init (1);
  7    27 
  7    28 /*	End of include file ... rcp_device_info.incl.pl1	*/
      222 
      223 
  8     1 
  8     2 /* Begin include file ...... iom_pcw.incl.pl1 */
  8     3 
  8     4 dcl  pcwp ptr;					/* pointer to PCW */
  8     5 
  8     6 dcl 1 pcw based (pcwp) aligned,			/* Peripheral Control Word */
  8     7      (2 command bit (6),				/* device command */
  8     8       2 device bit (6),				/* device code */
  8     9       2 ext bit (6),				/* address extension */
  8    10       2 code bit (3),				/* should be "111"b for PCW */
  8    11       2 mask bit (1),				/* channel mask bit */
  8    12       2 control bit (2),				/* terminate/proceed and marker control bits */
  8    13       2 chan_cmd bit (6),				/* type of I/O operation */
  8    14       2 count bit (6),				/* record count or control character */
  8    15       2 mbz1 bit (3),
  8    16       2 channel bit (6),				/* channel number */
  8    17       2 mbz2 bit (27)) unal;
  8    18 
  8    19 dcl  idcwp ptr;					/* pointer to IDCW */
  8    20 
  8    21 dcl 1 idcw based (idcwp) aligned,			/* Instruction DCW */
  8    22      (2 command bit (6),				/* device command */
  8    23       2 device bit (6),				/* device code */
  8    24       2 ext bit (6),				/* address extension */
  8    25       2 code bit (3),				/* should be "111"b for PCW */
  8    26       2 ext_ctl bit (1),				/* "1"b if address extension to be used */
  8    27       2 control bit (2),				/* terminate/proceed and marker control bits */
  8    28       2 chan_cmd bit (6),				/* type of I/O operation */
  8    29       2 count bit (6)) unal;				/* record count or control character */
  8    30 
  8    31 /* End include file ...... iom_pcw.incl.pl1 */
  8    32 
      224 
  9     1 
  9     2 /* Begin include file ...... iom_dcw.incl.pl1 */
  9     3 
  9     4 dcl  dcwp ptr,					/* pointer to DCW */
  9     5      tdcwp ptr;					/* pointer to TDCW */
  9     6 
  9     7 dcl 1 dcw based (dcwp) aligned,			/* Data Control Word */
  9     8      (2 address bit (18),				/* address for data transfer */
  9     9       2 char_pos bit (3),				/* character position */
  9    10       2 m64 bit (1),				/* non-zero for mod 64 address */
  9    11       2 type bit (2),				/* DCW type */
  9    12       2 tally bit (12)) unal;				/* tally for data transfer */
  9    13 
  9    14 dcl 1 tdcw based (tdcwp) aligned,			/* Transfer DCW */
  9    15      (2 address bit (18),				/* address to transfer to */
  9    16       2 mbz1 bit (4),
  9    17       2 type bit (2),				/* should be "10"b for TDCW */
  9    18       2 mbz2 bit (9),
  9    19       2 ec bit (1),					/* non-zero to set LPW AE bit */
  9    20       2 res bit (1),				/* non-zero to restrict further use of IDCW */
  9    21       2 rel bit (1)) unal;				/* non-zero to set relative mode after transfer */
  9    22 
  9    23 /* End of include file ...... iom_dcw.incl.pl1 */
  9    24 
      225 
      226 
      227 /* Constants */
      228 
      229 dcl  new_line char (1) static init ("
      230 ");						/* A new_line character */
      231 dcl  tab char (1) static init ("	");			/* A tab character */
      232 dcl  cmd_name char (8) init ("test_dcw");		/* The name of this thing */
      233 
      234 /* Entry constants */
      235 
      236 dcl  com_err_ entry options (variable);
      237 dcl  convert_ipc_code_ entry (fixed bin (35));
      238 dcl  cu_$arg_count entry (fixed bin);
      239 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
      240 dcl  cv_dec_check_ entry (char (*), fixed bin) returns (fixed bin (35));
      241 dcl  cv_oct_check_ entry (char (*), fixed bin) returns (fixed bin (35));
      242 dcl  ioa_ entry options (variable);
      243 dcl  ioa_$nnl entry options (variable);
      244 dcl  ioa_$rsnnl entry options (variable);
      245 dcl  ioi_$connect entry (fixed bin, fixed bin, fixed bin (35));
      246 dcl  ioi_$connect_pcw entry (fixed bin, fixed bin, bit (36), fixed bin (35));
      247 dcl  ioi_$set_status entry (fixed bin, fixed bin (18), fixed bin (8), fixed bin (35));
      248 dcl  ioi_$timeout entry (fixed bin, fixed bin (52), fixed bin (35));
      249 dcl  ioi_$workspace entry (fixed bin, ptr, fixed bin (18), fixed bin (35));
      250 dcl  iox_$get_line entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      251 dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
      252 dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
      253 dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
      254 dcl  ipc_$read_ev_chn entry (fixed bin (71), fixed bin, ptr, fixed bin (35));
      255 dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
      256 dcl  ioi_$release_devices entry (fixed bin, fixed bin (35));
      257 dcl  ioi_$get_detailed_status entry (fixed bin, bit (1) aligned, bit (216), fixed bin (35));
      258 dcl  ioi_$get_special_status entry (fixed bin, bit (1) aligned, bit (36) aligned, fixed bin (35));
      259 dcl  ioi_$set_channel_required entry (fixed bin, fixed bin (3), fixed bin (6), fixed bin (35));
      260 dcl  ioi_$suspend_devices entry (fixed bin, fixed bin (35));
      261 dcl  rcp_$attach entry (char (*), ptr, fixed bin (71), char (*), bit (36) aligned, fixed bin (35));
      262 dcl  rcp_$check_attach entry (bit (36) aligned, ptr, char (*), fixed bin, fixed bin (19), fixed bin (71),
      263      fixed bin, fixed bin (35));
      264 dcl  rcp_$detach entry (bit (36) aligned, bit (*), fixed bin, char (*), fixed bin (35));
      265 dcl  rcp_priv_$attach entry (char (*), ptr, fixed bin (71), char (*), bit (36) aligned, fixed bin (35));
      266 dcl  get_temp_segments_ entry (char (*), dim (*) ptr, fixed bin (35));
      267 dcl  release_temp_segments_ entry (char (*), dim (*) ptr, fixed bin (35));
      268 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
      269 dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      270 dcl  suffixed_name_$make entry (char (*), char (*), char (32), fixed bin (35));
      271 dcl  date_time_ entry (fixed bin (71), char (*));
      272 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
      273 dcl  adjust_bit_count_ entry (char (168), char (32), bit (1) aligned, fixed bin (24), fixed bin (35));
      274 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      275 dcl  analyze_device_stat_$rsnnl entry (char (*) var, ptr, bit (72) aligned, bit (18) aligned);
      276 dcl  parse_io_channel_name_ entry (char (*), fixed bin (3), fixed bin (6), fixed bin (35));
      277 
      278 /* External symbols */
      279 
      280 dcl  iox_$user_input ext pointer;
      281 dcl  sys_info$max_seg_size ext fixed bin (18);
      282 
      283 dcl  disk_status_table_$disk_status_table_ ext;
      284 dcl  tape_status_table_$tape_status_table_ ext;
      285 dcl  prt_status_table_$prt_status_table_ ext;
      286 dcl  cpz_status_table_$cpz_status_table_ ext;
      287 dcl  crz_status_table_$crz_status_table_ ext;
      288 dcl  imp_status_table_$imp_status_table_ ext;
      289 
      290 dcl  error_table_$badopt ext fixed bin (35);
      291 dcl  error_table_$request_not_recognized ext fixed bin (35);
      292 
      293 /* Built in functions */
      294 
      295 dcl (addr, before, bin, binary, bit, clock, divide, hbound, length, max, min, null, string, substr, unspec) builtin;
      296 
      297 dcl (cleanup, program_interrupt) condition;
      298 
      299 /* Initialize some stuff first */
      300 
      301 	dcw_list = "0"b;				/* Reset all dcw */
      302 	pcw_list = "0"b;				/* Reset all pcws */
      303 	dcw_len = 0;				/* And their lengths */
      304 	list_name = "";				/* No lists have names */
      305 	pcwp, idcwp, dcwp, tdcwp = addr (dcw_word);
      306 
      307 	on cleanup call clean_up;
      308 
      309 /* Scan argument list */
      310 
      311 	call cu_$arg_count (arg_cnt);			/* First find out how many */
      312 	dev_name = "";				/* Device is unknown now */
      313 	id_name = "";				/* Pack or volume unknown */
      314 	do i = 1 to arg_cnt;
      315 	     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      316 	     if code ^= 0 then do;
      317 		call com_err_ (code, cmd_name, "Arg ^d", i);
      318 		go to quit;
      319 	     end;
      320 	     if substr (arg, 1, 1) ^= "-" then do;	/* If not control arg */
      321 		if dev_name = "" then dev_name = arg;	/* If no device specified yet */
      322 		else if id_name = "" then id_name = arg; /* May be id name */
      323 		else do;
      324 		     code = error_table_$request_not_recognized; /* Multiple devices */
      325 arg_err:		     call com_err_ (code, cmd_name, "^a", arg);
      326 		     go to quit;
      327 		end;
      328 	     end;
      329 	     else if arg = "-priv" then priv_sw = "1"b;	/* If request for privileged attach */
      330 	     else if arg = "-read" then write_sw = "0"b;	/* Switch to read-only mode */
      331 	     else if arg = "-7tr" | arg = "-7track" then track_sw = "1"b;
      332 	     else if arg = "-sys" then sys_sw = "1"b;
      333 	     else if arg = "-debug" | arg = "-db" then debug_sw = "1"b;
      334 	     else do;				/* Nothing else I recognize */
      335 		code = error_table_$badopt;
      336 		go to arg_err;
      337 	     end;
      338 	end;
      339 	if dev_name = "" then dev_name = "tap";		/* Default device is tape */
      340 	if debug_sw then do;
      341 	     call get_temp_segments_ (cmd_name, ptr_array, code); /* Get segment for work area */
      342 	     if code ^= 0 then do;
      343 		call com_err_ (code, cmd_name, "Unable to allocate temp segment.");
      344 		go to quit;
      345 	     end;
      346 	     workp = ptr_array (1);
      347 	     max_work = sys_info$max_seg_size;
      348 	     default_device = "0"b;
      349 	     go to ready;
      350 	end;
      351 
      352 /* Now determine the device type to be assigned */
      353 
      354 	if dev_name = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) | dev_name = DEVICE_TYPE (DISK_DRIVE_DTYPEX) then /* Any tape, or any disk */
      355 	     dev_type = dev_name;
      356 	else if dev_name = "tap" then
      357 	     dev_type, dev_name = DEVICE_TYPE (TAPE_DRIVE_DTYPEX);
      358 	else if dev_name = "dsk" then			/* Alternate form of any disk */
      359 	     dev_type, dev_name = DEVICE_TYPE (DISK_DRIVE_DTYPEX);
      360 	else if dev_name = DEVICE_TYPE (PRINTER_DTYPEX) | dev_name = "prt" then /* Any printer */
      361 	     dev_name, dev_type = DEVICE_TYPE (PRINTER_DTYPEX);
      362 	else if dev_name = DEVICE_TYPE (READER_DTYPEX) | dev_name = "rdr" then /* Any reader */
      363 	     dev_name, dev_type = DEVICE_TYPE (READER_DTYPEX);
      364 	else if dev_name = DEVICE_TYPE (PUNCH_DTYPEX) | dev_name = "pun" then /* Any punch */
      365 	     dev_name, dev_type = DEVICE_TYPE (PUNCH_DTYPEX);
      366 	else if length (dev_name) > 3 then do;		/* May be specific device */
      367 	     if substr (dev_name, 1, 3) = "prt" then	/* Specific printer */
      368 		dev_type = DEVICE_TYPE (PRINTER_DTYPEX);
      369 	     else if substr (dev_name, 1, 3) = "rdr" then /* Specific reader */
      370 		dev_type = DEVICE_TYPE (READER_DTYPEX);
      371 	     else if substr (dev_name, 1, 3) = "pun" then /* Specific punch */
      372 		dev_type = DEVICE_TYPE (PUNCH_DTYPEX);
      373 	     else if substr (dev_name, 1, 3) = "tap" then do; /* Specific tape */
      374 		dev_type = DEVICE_TYPE (TAPE_DRIVE_DTYPEX);
      375 		if length (dev_name) >= 7 then if substr (dev_name, 6, 2) = "00" then /* Tape mpc */
      376 			dev_type = DEVICE_TYPE (SPECIAL_DTYPEX);
      377 	     end;
      378 	     else if substr (dev_name, 1, 3) = "dsk" then do; /* Specific disk */
      379 		dev_type = DEVICE_TYPE (DISK_DRIVE_DTYPEX);
      380 		if length (dev_name) >= 7 then if substr (dev_name, 6, 2) = "00" then /* New form disk mpc */
      381 			dev_type = DEVICE_TYPE (SPECIAL_DTYPEX);
      382 	     end;
      383 	     else dev_type = DEVICE_TYPE (SPECIAL_DTYPEX); /* Don't recognize it */
      384 	end;
      385 	else dev_type = DEVICE_TYPE (SPECIAL_DTYPEX);	/* Don't recognize it */
      386 
      387 /* Now assign some device as specified in the command */
      388 
      389 	call ipc_$create_ev_chn (ev_chan, code);	/* First, I need a channel for interrupts */
      390 	if code ^= 0 then do;
      391 	     call convert_ipc_code_ (code);
      392 	     call com_err_ (code, cmd_name, "Unable to create event channel");
      393 	     go to quit;
      394 	end;
      395 
      396 	if dev_type = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) then do; /* If tape requested */
      397 	     tape_info_ptr = addr (my_tape_info);	/* Use my tape info block */
      398 	     tape_info.version_num = tape_info_version_2; /* And initialize it */
      399 	     tape_info.usage_time = 0;
      400 	     tape_info.wait_time = 0;
      401 	     tape_info.system_flag = sys_sw;
      402 	     if dev_name = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) then tape_info.device_name = ""; /* No specific drive requested */
      403 	     else tape_info.device_name = dev_name;	/* Ask for specific name */
      404 	     tape_info.model = 0;
      405 	     if track_sw then tape_info.tracks = 7;	/* 7 track drive requested */
      406 	     else tape_info.tracks = 9;
      407 	     tape_info.density = "0"b;
      408 	     tape_info.speed = "0"b;			/* And initialize this also */
      409 	     tape_info.unused_qualifier = "0"b;
      410 	     if id_name = "" then tape_info.volume_name = "scratch"; /* If no volume requested */
      411 	     else tape_info.volume_name = id_name;	/* Otherwise, use name requested */
      412 	     tape_info.write_flag = write_sw;
      413 	     tape_info.position_index = 0;
      414 	     rcp_info_ptr = tape_info_ptr;		/* This is info block to use */
      415 	end;
      416 
      417 	else if dev_type = DEVICE_TYPE (DISK_DRIVE_DTYPEX) then do; /* If attaching a disk */
      418 	     disk_info_ptr = addr (my_disk_info);	/* Get pointer to my disk info block */
      419 	     disk_info.version_num = DISK_INFO_VERSION_1;
      420 	     disk_info.usage_time = 0;
      421 	     disk_info.wait_time = 0;
      422 	     disk_info.model = 0;
      423 	     disk_info.system_flag = sys_sw;
      424 	     if dev_name = DEVICE_TYPE (DISK_DRIVE_DTYPEX) then disk_info.device_name = ""; /* If any disk will do */
      425 	     else disk_info.device_name = dev_name;	/* Use name requested */
      426 	     if id_name = "" then disk_info.volume_name = "scratch"; /* Use scratch if no volume given */
      427 	     else disk_info.volume_name = id_name;	/* Otherwise use what was requested */
      428 	     disk_info.write_flag = write_sw;
      429 	     rcp_info_ptr = disk_info_ptr;		/* This the rcp block being used */
      430 	end;
      431 
      432 	else if dev_type = DEVICE_TYPE (PRINTER_DTYPEX) then do;
      433 	     printer_info_ptr = addr (my_printer_info);	/* Use my printer block */
      434 	     printer_info.version_num = PRINTER_INFO_VERSION_1;
      435 	     printer_info.usage_time = 0;
      436 	     printer_info.wait_time = 0;
      437 	     printer_info.system_flag = sys_sw;
      438 	     if dev_name = DEVICE_TYPE (PRINTER_DTYPEX) then printer_info.device_name = ""; /* If any printer will do */
      439 	     else printer_info.device_name = dev_name;
      440 	     printer_info.model = 0;
      441 	     printer_info.print_train = 0;
      442 	     rcp_info_ptr = printer_info_ptr;		/* Remember control block address */
      443 	end;
      444 
      445 	else do;					/* Some other device type */
      446 	     device_info_ptr = addr (my_device_info);	/* Use my device info block */
      447 	     device_info.version_num = DEVICE_INFO_VERSION_1;
      448 	     device_info.usage_time = 0;
      449 	     device_info.wait_time = 0;
      450 	     device_info.system_flag = sys_sw;
      451 	     if dev_name = dev_type then device_info.device_name = ""; /* No special device requested */
      452 	     else device_info.device_name = dev_name;
      453 	     device_info.model = 0;
      454 	     rcp_info_ptr = device_info_ptr;
      455 	end;
      456 
      457 /* The rcp control block has been set up, so now do the attachment */
      458 
      459 	if priv_sw then				/* If privileged */
      460 	     call rcp_priv_$attach ((dev_type), rcp_info_ptr, ev_chan, "", rcp_id, code); /* Do privileged attachment */
      461 	else call rcp_$attach ((dev_type), rcp_info_ptr, ev_chan, "", rcp_id, code);
      462 	if code ^= 0 then do;
      463 dev_err:	     call com_err_ (code, cmd_name, "^a", dev_name);
      464 	     go to quit;
      465 	end;
      466 
      467 rcp_loop:	call rcp_$check_attach (rcp_id, rcp_info_ptr, word, devx, max_work, max_time, rcp_state, code);
      468 	if rcp_state = 3 then go to dev_err;		/* Fatal error occured */
      469 	if rcp_state = 0 then go to begin;		/* Attachment succeeded */
      470 	if rcp_state = 1 then do;			/* Short wait code */
      471 	     if word ^= "" then			/* If comment from somebody */
      472 		call ioa_ ("^a: RCP indicates short wait for attachment. ^a", cmd_name, word);
      473 	     call ipc_$block (addr (event_list), addr (event_info), code); /* Wait for attachment */
      474 	     if code ^= 0 then do;
      475 		call convert_ipc_code_ (code);
      476 		call com_err_ (code, cmd_name, "While waiting for attachment.");
      477 		go to quit;
      478 	     end;
      479 	     go to rcp_loop;			/* Check attachment again */
      480 	end;
      481 
      482 	call com_err_ (0, cmd_name, "RCP indicates long wait for attachment. ^a", word);
      483 	go to quit;				/* I don't want to wait */
      484 
      485 
      486 begin:	if dev_type = DEVICE_TYPE (DISK_DRIVE_DTYPEX) then dev_name = disk_info.device_name;
      487 	else if dev_type = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) then dev_name = tape_info.device_name;
      488 	else if dev_type = DEVICE_TYPE (PRINTER_DTYPEX) then dev_name = printer_info.device_name;
      489 	else dev_name = device_info.device_name;
      490 	call ioa_ ("Device ^a assigned.", dev_name);
      491 
      492 	if dev_type = DEVICE_TYPE (DISK_DRIVE_DTYPEX) | dev_type = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) then default_device = bit (bin (substr (dev_name, 6, 2), 6), 6);
      493 	else if dev_type = DEVICE_TYPE (SPECIAL_DTYPEX) then default_device = "00"b3;
      494 	else default_device = "01"b3;
      495 
      496 	call ipc_$drain_chn (ev_chan, code);		/* Don't leave stay events around */
      497 
      498 	if substr (dev_name, 1, 3) = "dsk" then status_tablep = addr (disk_status_table_$disk_status_table_);
      499 	else if substr (dev_name, 1, 3) = "tap" then status_tablep = addr (tape_status_table_$tape_status_table_);
      500 	else if substr (dev_name, 1, 3) = "prt" then status_tablep = addr (prt_status_table_$prt_status_table_);
      501 	else if substr (dev_name, 1, 3) = "rdr" then status_tablep = addr (crz_status_table_$crz_status_table_);
      502 	else if substr (dev_name, 1, 3) = "pun" then status_tablep = addr (cpz_status_table_$cpz_status_table_);
      503 	else if substr (dev_name, 1, 3) = "imp" then status_tablep = addr (imp_status_table_$imp_status_table_);
      504 	else status_tablep = null;
      505 
      506 /* Set up work space */
      507 
      508 	call ioi_$workspace (devx, workp, work_size, code); /* Get work area */
      509 	if code ^= 0 then do;
      510 	     call com_err_ (code, cmd_name, "Unable to allocate workspace of ^d words.", work_size);
      511 	     go to quit;
      512 	end;
      513 
      514 /* Initialize status queue */
      515 
      516 	call ioi_$set_status (devx, 32, 4, code);	/* Define status queue */
      517 	if code ^= 0 then do;
      518 	     call com_err_ (code, cmd_name, "Unable to allocate status queue.");
      519 	     go to quit;
      520 	end;
      521 	sqptr = addr (work_seg (33));			/* Status queue is here */
      522 	status_queue.completion.st = "0"b;		/* Reset all status present bits */
      523 	stat.completion.st = "0"b;
      524 	status_index = 1;				/* This is the first entry to use */
      525 
      526 	time_limit = max_time;			/* Set time limit to max */
      527 	call ioi_$timeout (devx, time_limit, code);	/* Set time limit */
      528 	if code ^= 0 then
      529 	     call com_err_ (code, cmd_name, "Unable to set time limit to ^d seconds.",
      530 	     divide (time_limit, 1000000, 17, 0));
      531 
      532 /* Enable program interrupt as a way to escape from being blocked when no event is coming */
      533 
      534 ready:	on program_interrupt begin;			/* By getting a command when it happens */
      535 	     if debug_sw then go to next;
      536 	     flush_sw = "1"b;
      537 	     go to get_stat;			/* Flush out last status */
      538 	end;
      539 
      540 /* Read next command line */
      541 
      542 next:	if prompt_msg ^= "" then call ioa_$nnl ("^a", prompt_msg);
      543 	call iox_$get_line (iox_$user_input, addr (input_line), length (input_line), input_len, code);
      544 	if code ^= 0 then do;
      545 	     call com_err_ (code, cmd_name, "Reading for user_input");
      546 	     go to next;
      547 	end;
      548 	if input_len > 0 then if substr (input_line, input_len, 1) = new_line then /* If line ends in a nl */
      549 		input_len = input_len - 1;		/* Then truncate it */
      550 	input_pos = 1;				/* Current position */
      551 
      552 /* Analyze first word for command type */
      553 
      554 	call next_word;				/* First get the next word */
      555 	if end_line then go to next;			/* Some sort of null line  */
      556 	dcw_word = "0"b;				/* Start with empty dcw */
      557 	pcw_sw = "0"b;				/* Not now building a pcw */
      558 	exec_spec_sw, exec_rept_sw, exec_no_err_sw = "0"b; /* Not in any special mode now */
      559 	flush_sw = "0"b;
      560 
      561 	if word = "tdcw" then go to b_tdcw;
      562 	if word = "iotp" then go to b_iotp;
      563 	if word = "iontp" then go to b_iontp;
      564 	if word = "iotd" then go to b_iotd;
      565 	if word = "idcw" then go to b_idcw;
      566 	if word = "nidcw" then go to b_nidcw;
      567 	if word = "pcw" then go to b_pcw;
      568 	if word = "odcw" then go to b_oct;
      569 	if word = "opcw" then go to b_opcw;
      570 	if word = "print" | word = "p" then go to print;
      571 	if word = "edit" | word = "e" then go to edit;
      572 	if word = "name" then go to set_name;
      573 	if word = "insert" | word = "i" then go to insert;
      574 	if word = "update" | word = "u" then go to update;
      575 	if word = "quit" | word = "q" then go to quit;
      576 	if word = "delete" | word = "dl" | word = "d" then go to delete;
      577 	if word = "execute" | word = "x" then go to execute;
      578 	if word = "xs" then go to exec_spec;
      579 	if word = "xr" then go to exec_rept;
      580 	if word = "xre" then go to exec_rept_no_err;
      581 	if word = "getstat" | word = "g" then go to get_stat;
      582 	if word = "block" | word = "b" then go to block;
      583 	if word = "dump" then go to dump;
      584 	if word = "dumpb" then go to dumpb;
      585 	if word = "patch" then go to patch;
      586 	if word = "survey" then go to dump_survey;
      587 	if word = "dtstat" then go to dump_dtstat;
      588 	if word = "time" then go to set_time;
      589 	if word = "work" then go to set_work;
      590 	if word = "chan" then go to set_chan;
      591 	if word = "susp" then go to susp_dev;
      592 	if word = "rel" then go to rel_dev;
      593 	if word = "prompt" then go to set_prompt;
      594 	if word = "pattern" then go to set_pattern;
      595 	if word = "save" then go to save_segment;
      596 	if word = "restore" then go to restore_segment;
      597 	if word = "reprint_status" | word = "rs" then go to reprint_status;
      598 	if word = "status" | word = "st" then go to status_command;
      599 	if word = "get_special" | word = "get_special_status" then go to get_special_status;
      600 	if word = "get_detail" | word = "get_detailed_status" then go to get_detailed_status;
      601 
      602 /* More possible requests */
      603 
      604 	if word = "." then do;			/* If requested to identify my self */
      605 	     call ioa_ ("^a", cmd_name);		/* Its me!!! */
      606 	     go to next;
      607 	end;
      608 	if word = "?" then do;			/* If request for current status */
      609 	     if insert_mode then out_temp = "insert"; else out_temp = "update";
      610 	     call ioa_ ("Current list: ^d^[ (^a)^;^s^], dcw: ^d, mode: ^a", list, (list_name (list) ^= ""),
      611 		list_name (list), idx-1, out_temp);
      612 	     go to next;
      613 	end;
      614 
      615 std_err:	call ioa_ ("invalid word: ^a", word);
      616 	go to next;
      617 
      618 quit:	call clean_up;
      619 	return;
      620 
      621 /* Come here after dcw is built to update the correct dcw list */
      622 
      623 store:	if pcw_sw then pcw_list (list) = dcw_word;	/* Pcw goes here */
      624 
      625 	else do;
      626 	     if insert_mode then do;			/* If in insert mode, list must be moved */
      627 		i = dcw_len (list);			/* End of current list */
      628 		do while (i >= idx);
      629 		     j = i+1;			/* Destination word */
      630 		     if j <= 32 then dcw_list (list, j) = dcw_list (list, i); /* Move it, but don't go off end */
      631 		     i = i-1;
      632 		end;
      633 		dcw_len (list) = min (32, dcw_len (list)+1); /* Calc new length */
      634 	     end;
      635 	     dcw_list (list, idx) = dcw_word;		/* Copy in new word */
      636 	     dcw_len (list) = max (dcw_len (list), idx);	/* Adjust count */
      637 	     idx = min (32, idx+1);
      638 	end;
      639 	go to next;
      640 
      641 /* Routine to build a TDCW */
      642 
      643 b_tdcw:	tdcw.type = "10"b;				/* This makes it a TDCW */
      644 	call next_word;				/* Get the next word */
      645 	if end_line then go to store;			/* If all done */
      646 	if octal_word then do;			/* If octal, then this is the address */
      647 	     tdcw.address = bit (binary (octal_val, 18, 0)); /* So store it */
      648 	     go to b_tdcw2;
      649 	end;
      650 b_tdcw1:	if word = "ec" then tdcw.ec = "1"b;		/* If ec bit needed */
      651 	else if word = "res" then tdcw.res = "1"b;	/* If res bit wanted */
      652 	else if word = "rel" then tdcw.rel = "1"b;	/* If rel bit wanted */
      653 	else go to std_err;				/* Don't recognize it */
      654 b_tdcw2:	call next_word;				/* Get next word */
      655 	if end_line then go to store;
      656 	else go to b_tdcw1;
      657 
      658 /* Routine to build an IDCW */
      659 
      660 b_idcw:	idcw.code = "111"b;				/* This makes it an IDCW */
      661 	idcw.device = default_device;
      662 	call next_word;
      663 	if end_line then go to store;
      664 	if octal_word then do;			/* Must be inst code */
      665 	     idcw.command = bit (binary (octal_val, 6, 0)); /* So store it */
      666 	     go to b_idcw2;
      667 	end;
      668 
      669 b_idcw1:	if word = "da" then idcw.device = bit6 ();	/* Device addrss follows */
      670 	else if word = "ae" then idcw.ext = bit6 ();	/* Address extension follows */
      671 	else if word = "ci" then idcw.chan_cmd = bit6 (); /* Channel instruction follows */
      672 	else if word = "t" then idcw.count = bit6 ();	/* Tally follows */
      673 	else if word = "ec" then idcw.ext_ctl = "1"b;
      674 	else if word = "cont" then substr (idcw.control, 1, 1) = "1"b;
      675 	else if word = "mark" then substr (idcw.control, 2, 1) = "1"b;
      676 	else if word = "mask" then pcw.mask = "1"b;
      677 	else if word = "reset" & pcw_sw then do;
      678 	     pcw.mask = "1"b;
      679 	     pcw.control = "11"b;
      680 	end;
      681 	else go to std_err;				/* No more things to test */
      682 
      683 b_idcw2:	call next_word;				/* On to next one */
      684 	if ^end_line then go to b_idcw1;
      685 	else go to store;
      686 
      687 /* Simple command for setting up a non-data transfer IDCW */
      688 
      689 b_nidcw:	idcw.count = "000001"b;			/* Set tally = 1 */
      690 	idcw.chan_cmd = "000010"b;			/* Non-data transfer code */
      691 	go to b_idcw;				/* Otherwise, just like a regular IDCW */
      692 
      693 /* Build a PCW, which is a lot like a IDCW */
      694 
      695 b_pcw:	pcw_sw = "1"b;
      696 	go to b_idcw;				/* Use the IDCW routine */
      697 
      698 /* Build IOTP, IOTD, or IONTP dcw */
      699 
      700 b_iotd:	dcw.type = "00"b;				/* Start here for IOTD */
      701 	go to b_iodcw;
      702 
      703 b_iotp:	dcw.type = "01"b;				/* Start here for IOTP */
      704 	go to b_iodcw;
      705 
      706 b_iontp:	dcw.type = "11"b;				/* Start here for IONTP */
      707 
      708 b_iodcw:	call next_word;				/* This should be address */
      709 	if end_line then go to store;
      710 	if ^octal_word then go to std_err;
      711 	dcw.address = bit (binary (octal_val, 18, 0));
      712 
      713 	call next_word;				/* This should be tally */
      714 	if end_line then go to store;
      715 	if ^octal_word then go to std_err;
      716 	dcw.tally = bit (binary (octal_val, 12, 0));
      717 
      718 	call next_word;				/* This should be char pos */
      719 	if end_line then go to store;
      720 	if ^octal_word then go to std_err;
      721 	dcw.char_pos = bit (binary (octal_val, 3, 0));
      722 
      723 	go to store;				/* Done */
      724 
      725 /* Store a dcw entered in octal */
      726 
      727 b_oct:	call next_word;
      728 	if end_line then go to store;			/* Just store zero */
      729 	if ^octal_word then go to std_err;		/* Must be in octal */
      730 	dcw_word = unspec (octal_val);
      731 	go to store;
      732 
      733 /* Build a pcw entered in octal */
      734 
      735 b_opcw:	pcw_sw = "1"b;				/* Remember that this is pcw */
      736 	go to b_oct;				/* And use octal routine */
      737 
      738 /* Edit command which changes the dcw list being edited */
      739 
      740 edit:	call next_word;				/* See if arg given */
      741 	if ^end_line then do;
      742 	     if word = "*" then do;			/* Any empty list */
      743 		do i = 1 to 32;			/* Check all lists */
      744 		     if empty_list (i) & list_name (i) = "" then do;
      745 			call ioa_ ("Using list #^d.", i);
      746 			list = i;
      747 			go to edit1;
      748 		     end;
      749 		end;
      750 		call ioa_ ("No empty lists.");
      751 		go to next;
      752 	     end;
      753 	     else call check_list_num;		/* See if valid number or name */
      754 	     list = dec_val;
      755 edit1:	     call next_word;			/* See if name given */
      756 	     if end_line then new_name = "";
      757 	     else new_name = word;
      758 	end;
      759 	idx = 1;
      760 	insert_mode = "0"b;
      761 	if new_name ^= "" then go to set_name2;
      762 	else go to next;
      763 
      764 /* Update command, which turns off insert mode, and may change the current position */
      765 
      766 update:	call get_dcw_num;
      767 	insert_mode = "0"b;
      768 	go to next;
      769 
      770 /* Insert command, which turns on insert mode, and may change the current position */
      771 
      772 insert:	call get_dcw_num;
      773 	insert_mode = "1"b;
      774 	go to next;
      775 
      776 /* Routine to delete a word from a dcw list */
      777 
      778 delete:	call get_dcw_num;
      779 	i = idx;					/* Target word */
      780 delete1:	j = i+1;					/* Source word to move from */
      781 	if j > dcw_len (list) then do;		/* If reached end */
      782 	     dcw_len (list) = max (dcw_len (list)-1, 0);	/* Adjust length */
      783 	     go to next;
      784 	end;
      785 	dcw_list (list, i) = dcw_list (list, j);	/* Move word */
      786 	i = i+1;					/* Next target word */
      787 	go to delete1;
      788 
      789 /* Routine to give a dcw list a name */
      790 
      791 set_name:	call next_word;
      792 	if end_line then new_name = "";
      793 	else new_name = word;
      794 set_name2:
      795 	if new_name ^= "" then do i = 1 to 32;		/* Be sure name is not used elsewhere */
      796 	     if list_name (i) = new_name then list_name (i) = "";
      797 	end;
      798 	list_name (list) = new_name;
      799 	go to next;
      800 
      801 /* Routine to set the time limit for connects */
      802 
      803 set_time:	call debug_check;
      804 	call next_word;				/* Get the next word */
      805 	if end_line then do;			/* If nothing, then just print current time limit */
      806 	     call ioa_ ("Time limit is ^d seconds", divide (time_limit, 1000000, 17, 0));
      807 	     call ioa_ ("Max time limit is ^d seconds", divide (max_time, 1000000, 17, 0));
      808 	     go to next;
      809 	end;
      810 	if ^dec_word then go to std_err;		/* Should be limit in seconds */
      811 	time_limit = 1000000*dec_val;			/* Convert to micro seconds */
      812 	call ioi_$timeout (devx, time_limit, code);
      813 	if code ^= 0 then call com_err_ (code, cmd_name);
      814 	go to next;
      815 
      816 /* Command to change the size of the work space */
      817 
      818 set_work:	call debug_check;
      819 	call next_word;				/* Get next word */
      820 	if end_line then do;			/* If no param, just print current size */
      821 	     call ioa_ ("Buffer size is ^d words", work_size);
      822 	     call ioa_ ("Max buffer size is ^d words", max_work);
      823 	     go to next;
      824 	end;
      825 	if ^dec_word then go to std_err;		/* If specified, must be decimal */
      826 	new_work_size = max (512, dec_val);		/* Save new size */
      827 	call ioi_$workspace (devx, workp, new_work_size, code); /* Change size */
      828 	if code ^= 0 then do;
      829 	     call com_err_ (code, cmd_name, "Setting workspace to ^d words.");
      830 	     go to next;
      831 	end;
      832 	work_size = new_work_size;
      833 	go to next;
      834 
      835 /* Command to change the prompt message */
      836 
      837 set_prompt: call next_word;
      838 	if end_line then prompt_msg = "";		/* If null, set to no prompt */
      839 	else prompt_msg = before (word, " ");		/* Otherwise get rest of word */
      840 	go to next;
      841 
      842 /* Command to set a channel required for I/O */
      843 
      844 set_chan:	call debug_check;
      845 	call next_word;
      846 	if end_line then do;			/* No arguments means reset this feature */
      847 	     call ioi_$set_channel_required (devx, 0, 0, code);
      848 	     if code ^= 0 then call com_err_ (code, cmd_name);
      849 	     go to next;
      850 	end;
      851 
      852 	call parse_io_channel_name_ (word, iom, chan, code);
      853 	if code ^= 0 then do;
      854 	     call com_err_ (code, cmd_name, "^a", word);
      855 	     go to next;
      856 	end;
      857 
      858 	call ioi_$set_channel_required (devx, iom, chan, code);
      859 	if code ^= 0 then call com_err_ (code, cmd_name);
      860 	go to next;
      861 
      862 /* Suspend io on all devices on the mpc */
      863 
      864 susp_dev:	call debug_check;
      865 	call ioi_$suspend_devices (devx, code);
      866 	if code ^= 0 then call com_err_ (code, cmd_name);
      867 	go to next;
      868 
      869 /* Release io on all devices on the mpc */
      870 
      871 rel_dev:	call debug_check;
      872 	call ioi_$release_devices (devx, code);
      873 	if code ^= 0 then call com_err_ (code, cmd_name);
      874 	go to next;
      875 
      876 /* Commands for special and detailed status */
      877 
      878 get_special_status:
      879 	call debug_check;
      880 	call ioi_$get_special_status (devx, stat_found, spec_status, code);
      881 	if code ^= 0 then call com_err_ (code, cmd_name);
      882 	else if ^stat_found then call ioa_ ("No special status stored.");
      883 	else call ioa_ ("special status: ^w", spec_status);
      884 	go to next;
      885 
      886 get_detailed_status:
      887 	call debug_check;
      888 	call ioi_$get_detailed_status (devx, stat_found, detailed_status, code);
      889 	if code ^= 0 then call com_err_ (code, cmd_name);
      890 	else if ^stat_found then call ioa_ ("No detailed status from previous I/O.");
      891 	else do;
      892 	     do i = 27 to 2 by -1 while (detailed_status_array (i) = "0"b);
      893 	     end;
      894 	     call ioa_ ("Detailed status : ^v(^.4b ^)", i, detailed_status_array);
      895 	end;
      896 	go to next;
      897 
      898 /* Routine to execute the dcw list */
      899 
      900 execute:	exec_spec_sw = "0"b;			/* This is normal start */
      901 	exec_rept_sw = "0"b;			/* Set  to execute once */
      902 	exec_no_err_sw = "0"b;			/* Do not ignore errors */
      903 	go to ex_join;
      904 
      905 exec_spec: exec_spec_sw = "1"b;			/* Enter here if special interrupt required */
      906 	exec_rept_sw = "0"b;
      907 	exec_no_err_sw = "0"b;
      908 	go to ex_join;
      909 
      910 exec_rept_no_err:
      911 	exec_no_err_sw = "1"b;			/* Going to ignore errors. */
      912 	go to repeat;
      913 
      914 exec_rept: exec_no_err_sw = "0"b;
      915 repeat:	exec_spec_sw = "0"b;			/* No special wait */
      916 	exec_rept_sw = "1"b;			/* But doing repeats */
      917 ex_join:	exec_rept_cnt = 0;
      918 
      919 	call debug_check;
      920 	call get_list_num;
      921 	if dec_val > 0 then do;			/* New list number */
      922 	     list = dec_val;
      923 	     idx = 1;
      924 	     insert_mode = "0"b;
      925 	end;
      926 
      927 	if dcw_len (list) = 0 then do;		/* If list is empty */
      928 	     call ioa_ ("List ^d^[ (^a)^] is empty.", list, list_name (list) ^= "", list_name (list));
      929 	     go to next;
      930 	end;
      931 
      932 	do i = 1 to hbound (dcw_list, 2);		/* Copy list to work space */
      933 	     if i <= dcw_len (list) then work_seg (i) = dcw_list (list, i);
      934 	     else work_seg (i) = "0"b;
      935 	end;
      936 
      937 xagain:	if pcw_list (list) then call ioi_$connect_pcw (devx, 0, pcw_list (list), code); /* If i have a pcw */
      938 	else call ioi_$connect (devx, 0, code);
      939 	if code ^= 0 then do;
      940 	     call com_err_ (code, cmd_name, "Issuing connect");
      941 	     go to next;
      942 	end;
      943 
      944 block:	call debug_check;
      945 	call ipc_$block (addr (event_list), addr (event_info), code); /* Wait for interrupt */
      946 	if code ^= 0 then do;
      947 	     call convert_ipc_code_ (code);
      948 	     call com_err_ (code, cmd_name, "While blocking for interrupt.");
      949 	     go to next;
      950 	end;
      951 
      952 /* Analyze status */
      953 
      954 gstat:	imp = addr (event_info.message);		/* Get pointer to ioi message */
      955 
      956 	if imess.level = "111"b then do;		/* If special status */
      957 	     if flush_sw then go to get_stat;
      958 	     unspec (stat) = "0"b;			/* Cons up a status queue entry */
      959 	     stat.level = 7;
      960 	     stat.iom_stat = imess.status;
      961 	     stat.completion.st = "1"b;
      962 	     call print_status;
      963 	     go to next;
      964 	end;
      965 
      966 	isp = addr (status_queue (status_index));	/* Current status entry */
      967 	if ^istat.completion.st then do;
      968 	     if flush_sw then go to get_stat;
      969 	     call print_status;
      970 	     go to next;
      971 	end;
      972 
      973 	stat = istat;				/* Copy status to my automatic area */
      974 	istat.completion.st = "0"b;			/* Status no longer present in buffer */
      975 	status_index = status_index+1;		/* Index for next status */
      976 	if status_index > 4 then status_index = 1;
      977 	if flush_sw then go to get_stat;
      978 
      979 	if stat.completion.time_out then do;		/* If event due to time out */
      980 	     call print_status;
      981 	     go to next;
      982 	end;
      983 
      984 	statp = addr (stat.iom_stat);			/* Get pointer to iom stat area */
      985 
      986 	if exec_rept_sw then do;			/* If doing repeatedly */
      987 	     if exec_no_err_sw then go to xagain;	/* Forget about errors. */
      988 	     if stat.level ^= 3 then go to pr_stat;	/* If not terminate */
      989 	     if stat.completion.er then go to pr_stat;	/* If status indicates any error */
      990 	     exec_rept_cnt = exec_rept_cnt + 1;
      991 	     go to xagain;				/* Otherwise do it again */
      992 	end;
      993 
      994 pr_stat:	call print_status;
      995 
      996 	if stat.completion.run then go to block;	/* If still running, wait for more status */
      997 	if exec_spec_sw then go to block;		/* If a special needed.. */
      998 	if exec_rept_sw then call ioa_ ("^d operations suceeded.", exec_rept_cnt);
      999 	go to next;
     1000 
     1001 /* Routine to force ioi get status call to check for any status */
     1002 
     1003 get_stat:	call debug_check;
     1004 	call ipc_$read_ev_chn (ev_chan, i, addr (event_info), code); /* Check for event */
     1005 	if code ^= 0 then do;
     1006 	     call convert_ipc_code_ (code);
     1007 	     call com_err_ (code, cmd_name, "Reading event channel.");
     1008 	     go to next;
     1009 	end;
     1010 	if i ^= 0 then go to gstat;			/* Status has occured */
     1011 	if ^flush_sw then call ioa_ ("No events");	/* Nothing has happened */
     1012 	go to next;
     1013 
     1014 /* Command to reprint the last_status */
     1015 
     1016 reprint_status:
     1017 	save_status_mode = status_mode;		/* Reember current mode */
     1018 	call next_word;
     1019 	if end_line then status_mode = 3;		/* Default is edited */
     1020 	else call check_status_mode;
     1021 	call print_status;
     1022 	status_mode = save_status_mode;
     1023 	go to next;
     1024 
     1025 /* Command to set the status mode */
     1026 
     1027 status_command:
     1028 	call next_word;
     1029 	if end_line then call ioa_ ("Status mode is ^[brief^;long^;edited^]", status_mode);
     1030 	else call check_status_mode;
     1031 	go to next;
     1032 
     1033 /* Procedure to print status */
     1034 
     1035 print_status: proc;
     1036 
     1037 dcl  bstat (8) bit (36) aligned based (addr (stat));
     1038 
     1039 	     if ^stat.completion.st then do;
     1040 		call ioa_ ("No status available.");
     1041 		return;
     1042 	     end;
     1043 
     1044 	     if status_mode = 2 then do;		/* Long mode */
     1045 		call ioa_ ("^(^w ^)", bstat);
     1046 		return;
     1047 	     end;
     1048 
     1049 	     if stat.level = 1 | stat.level = 7 then do;
     1050 		call ioa_ ("^d ^.3b", stat.level, substr (stat.iom_stat, 1, 36));
     1051 		return;
     1052 	     end;
     1053 
     1054 	     if stat.completion.time_out then do;
     1055 		call ioa_ ("Channel timed out.");
     1056 		return;
     1057 	     end;
     1058 
     1059 	     if status_mode = 3 then do;
     1060 		call analyze_device_stat_$rsnnl (output_line, status_tablep, stat.iom_stat, "0"b);
     1061 		call ioa_ ("^a", output_line);
     1062 		return;
     1063 	     end;
     1064 
     1065 	     call ioa_ ("^d ^w ^w maj=^b sub=^b", stat.level,
     1066 		substr (stat.iom_stat, 1, 36), substr (stat.iom_stat, 37, 36),
     1067 		addr (stat.iom_stat) -> status.major,
     1068 		addr (stat.iom_stat) -> status.sub);
     1069 	     return;
     1070 
     1071 	end print_status;
     1072 
     1073 /* Procedure to check a word for a valid status mode */
     1074 
     1075 check_status_mode: proc;
     1076 
     1077 	     if word = "brief" | word = "bf" then status_mode = 1;
     1078 	     else if word = "long" | word = "lg" then status_mode = 2;
     1079 	     else if word = "edited" | word = "ed" then status_mode = 3;
     1080 	     else do;
     1081 		call ioa_ ("Invalid status mode: ^a", word);
     1082 		go to next;
     1083 	     end;
     1084 	     return;
     1085 
     1086 	end check_status_mode;
     1087 
     1088 /* Routine to print a dcw list */
     1089 
     1090 print:	call next_word;
     1091 	if ^end_line then do;			/* There is an arg */
     1092 	     if word = "all" then do;
     1093 		something_printed = "0"b;
     1094 		do i = 1 to 32;
     1095 		     if ^empty_list (i) then do;	/* List in use */
     1096 			call ioa_ ("List #^d ^[(^a)^]", i, (list_name (i) ^= ""), list_name (i));
     1097 			call print_subr (i);
     1098 			something_printed = "1"b;
     1099 		     end;
     1100 		end;
     1101 		if ^something_printed then call ioa_ ("No dcw lists defined");
     1102 		go to next;
     1103 	     end;
     1104 	     else if word = "names" then do;		/* Request for list of names */
     1105 		something_printed = "0"b;
     1106 		do i = 1 to 32;
     1107 		     if (list_name (i) ^= "") | ^empty_list (i) then do;
     1108 			call ioa_ ("^2d ^[*noname*^s^;^a^] ^[(empty)^]", i, (list_name (i) = ""), list_name (i),
     1109 			     empty_list (i));
     1110 			something_printed = "1"b;
     1111 		     end;
     1112 		end;
     1113 		if ^something_printed then call ioa_ ("No dcw lists defined.");
     1114 		go to next;
     1115 	     end;
     1116 	     call check_list_num;			/* Check for valid arg */
     1117 	     list = dec_val;
     1118 	     idx = 1;
     1119 	     insert_mode = "0"b;
     1120 	end;
     1121 
     1122 	if empty_list (list) then call ioa_ ("List #^d ^[(^a) ^]empty.", list, list_name (list) ^= "",
     1123 	     list_name (list));
     1124 	else call print_subr (list);
     1125 	go to next;
     1126 
     1127 /* Subroutine to print 1 dcw list */
     1128 
     1129 print_subr: proc (listnum);
     1130 
     1131 dcl  listnum fixed bin;
     1132 dcl  i fixed bin;
     1133 
     1134 	     do i = 0 to dcw_len (listnum);		/* Loop thru current list */
     1135 		output_line = "";			/* Start with null line */
     1136 
     1137 		if i = 0 then do;			/* Special case to print the pcw */
     1138 		     if pcw_list (listnum) then do;	/* If there is one */
     1139 			dcw_word = pcw_list (listnum); /* Get it */
     1140 			output_line = "pcw   ";
     1141 			go to print_pcw;
     1142 		     end;
     1143 		end;
     1144 
     1145 		else do;
     1146 		     dcw_word = dcw_list (listnum, i);	/* Copy the current word */
     1147 
     1148 		     if idcw.code = "111"b then do;	/* If an IDCW */
     1149 			output_line = "idcw  ";
     1150 print_pcw:		call oct (2, binary (idcw.command)); /* Get device instruction */
     1151 			if idcw.device then do;	/* If an address is present */
     1152 			     output_line = output_line || " da=";
     1153 			     call oct (2, binary (idcw.device));
     1154 			end;
     1155 			if idcw.ext then do;	/* If address extension present */
     1156 			     output_line = output_line || " ae=";
     1157 			     call oct (2, binary (idcw.device));
     1158 			end;
     1159 			if idcw.chan_cmd then do;	/* If channel instruction present */
     1160 			     output_line = output_line || " ci=";
     1161 			     call oct (2, binary (idcw.chan_cmd));
     1162 			end;
     1163 			if idcw.count then do;	/* If a tally is present */
     1164 			     output_line = output_line || " t=";
     1165 			     call oct (2, binary (idcw.count));
     1166 			end;
     1167 			if idcw.ext_ctl then if i = 0 then output_line = output_line || " mask";
     1168 			     else output_line = output_line || " ec";
     1169 			if substr (idcw.control, 1, 1) then output_line = output_line || " cont";
     1170 			if substr (idcw.control, 2, 1) then output_line = output_line || " mark";
     1171 		     end;
     1172 
     1173 		     else if tdcw.type = "10"b then do; /* If a TDCW */
     1174 			output_line = "tdcw  ";
     1175 			call oct (6, binary (tdcw.address)); /* Convert address */
     1176 			if tdcw.ec then output_line = output_line || " ec";
     1177 			if tdcw.res then output_line = output_line || " res";
     1178 			if tdcw.rel then output_line = output_line || " rel";
     1179 		     end;
     1180 
     1181 		     else do;			/* Some type of IODCW */
     1182 			if dcw.type = "00"b then output_line = "iotd  "; /* Get type first */
     1183 			else if dcw.type = "01"b then output_line = "iotp  ";
     1184 			else output_line = "iontp ";	/* Only one left */
     1185 			call oct (6, binary (dcw.address)); /* Data address first */
     1186 			output_line = output_line || " ";
     1187 			call oct (4, binary (dcw.tally));
     1188 			if dcw.char_pos then do;	/* If character pos present */
     1189 			     output_line = output_line || " cp=";
     1190 			     call oct (1, binary (dcw.char_pos));
     1191 			end;
     1192 		     end;
     1193 
     1194 		     call ioa_$rsnnl ("^w", word, (0), dcw_word); /* Unpack the word */
     1195 		     if i = 0 then call ioa_ ("    ^a ^a  ^a", substr (word, 1, 6), substr (word, 7, 12),
     1196 			output_line);
     1197 		     else call ioa_ ("^2o^[*^; ^] ^a ^a  ^a", i-1, (i = idx & list = listnum), substr (word, 1, 6),
     1198 			substr (word, 7, 6), output_line);
     1199 		end;
     1200 	     end;
     1201 
     1202 	     return;
     1203 
     1204 	end print_subr;
     1205 
     1206 /* Command to dump contents of ioi work space segment */
     1207 
     1208 dumpb:	dp_byte = "1"b;				/* Dump is in bytes */
     1209 	go to dp_join;
     1210 
     1211 dump:	dp_byte = "0"b;				/* Dump is in words */
     1212 dp_join:	dp_loc = 65;				/* Default location */
     1213 	dp_len = 8;				/* Default word count */
     1214 
     1215 	call next_word;
     1216 	if end_line then go to dump_go;		/* Use defaults */
     1217 	if ^octal_word then go to std_err;
     1218 	dp_loc = octal_val + 1;
     1219 	call next_word;
     1220 	if end_line then go to dump_go;
     1221 	if ^octal_word then go to std_err;
     1222 	dp_len = octal_val;				/* This is word count */
     1223 
     1224 dump_go:	i = 0;					/* This will count words on current print line */
     1225 	output_line = "";
     1226 
     1227 	if ^dp_byte then do dp_loc = dp_loc to (dp_loc+dp_len-1); /* If dump is in words */
     1228 
     1229 dp_nl:	     if i = 0 then do;			/* If line is empty */
     1230 		call ioa_$rsnnl ("^4o", word, (0), dp_loc-1); /* Edit address */
     1231 		output_line = substr (word, 1, 4) || " ";
     1232 	     end;
     1233 	     i = i + 1;				/* Count another word on the line */
     1234 	     if i > 8 then do;			/* If no room for another line */
     1235 		call ioa_ ("^a", output_line);	/* Dump current */
     1236 		i = 0;
     1237 		go to dp_nl;			/* And start another */
     1238 	     end;
     1239 	     call ioa_$rsnnl ("^w", word, (0), work_seg (dp_loc)); /* Edit a word */
     1240 	     output_line = output_line || " " || substr (word, 1, 12);
     1241 	end;
     1242 
     1243 	else do;					/* Dump is in binary bytes */
     1244 	     byte_ptr = addr (work_seg (dp_loc));	/* Get array pointer */
     1245 	     nbytes = dp_len;			/* Number of bytes to dump */
     1246 	     do j = 1 to nbytes;
     1247 		i = i + 1;			/* Count entry on line */
     1248 		if i > 10 then do;			/* If line full */
     1249 		     call ioa_ ("^a", output_line);
     1250 		     i = 1;
     1251 		     output_line = "";
     1252 		end;
     1253 		call ioa_$rsnnl ("^b", word, (0), bbyte (j)); /* Format new word */
     1254 		output_line = output_line || " " || substr (word, 1, 8);
     1255 	     end;
     1256 	end;
     1257 
     1258 	call ioa_ ("^a", output_line);		/* Dump last line */
     1259 	go to next;
     1260 
     1261 /* Command to patch data into ioi buffer */
     1262 
     1263 patch:	call next_word;				/* Get address */
     1264 	if end_line then do;
     1265 	     call ioa_ ("Address missing");
     1266 	     go to next;
     1267 	end;
     1268 	if ^octal_word then go to std_err;
     1269 	dp_loc = octal_val + 1;			/* First word to patch */
     1270 
     1271 	call next_word;				/* First data word */
     1272 	if end_line then do;
     1273 	     call ioa_ ("Data missing");
     1274 	     go to next;
     1275 	end;
     1276 
     1277 	do while (^end_line);			/* Do for rest of input line */
     1278 	     if ^octal_word then go to std_err;		/* Only octal allowed */
     1279 	     work_seg (dp_loc) = unspec (octal_val);	/* Store whole word */
     1280 	     dp_loc = dp_loc + 1;			/* Step to next word */
     1281 	     call next_word;			/* Fetch next arg */
     1282 	end;
     1283 	go to next;
     1284 
     1285 /* Command to repeat a data pattern in the buffer */
     1286 
     1287 set_pattern:
     1288 	call next_word;				/* Address */
     1289 	if end_line then do;
     1290 	     call ioa_ ("Address missing");
     1291 	     go to next;
     1292 	end;
     1293 	if ^octal_word then go to std_err;
     1294 	dp_loc = octal_val + 1;			/* Start address */
     1295 
     1296 	call next_word;				/* Count */
     1297 	if end_line then do;
     1298 	     call ioa_ ("Count missing");
     1299 	     go to next;
     1300 	end;
     1301 	if ^octal_word then go to std_err;
     1302 	dp_rpt = octal_val;
     1303 
     1304 	dp_len = 0;
     1305 	call next_word;
     1306 	do while (^end_line);			/* Scan rest of command */
     1307 	     if ^octal_word then go to std_err;
     1308 	     work_seg (dp_loc) = unspec (octal_val);
     1309 	     dp_len = dp_len + 1;
     1310 	     dp_loc = dp_loc + 1;
     1311 	     call next_word;
     1312 	end;
     1313 
     1314 	if dp_len = 0 then do;
     1315 	     call ioa_ ("No data");
     1316 	     go to next;
     1317 	end;
     1318 
     1319 	do dp_rpt = dp_rpt-1 by -1 while (dp_rpt > 0);
     1320 	     do i = 1 to dp_len;
     1321 		work_seg (dp_loc) = work_seg (dp_loc - dp_len);
     1322 		dp_loc = dp_loc + 1;
     1323 	     end;
     1324 	end;
     1325 	go to next;
     1326 
     1327 /* Dump data returned by survey devices is readable format */
     1328 
     1329 dump_survey: dp_loc = 65;				/* Default location of data */
     1330 	call next_word;				/* See if location given */
     1331 	if ^end_line then do;			/* If it was */
     1332 	     if ^octal_word then go to std_err;
     1333 	     else dp_loc = octal_val + 1;		/* Use this loc */
     1334 	end;
     1335 
     1336 	survey_ptr = addr (work_seg (dp_loc));		/* This locates the data */
     1337 
     1338 	do i = 1 to 16 while (string (survey_table (i))); /* Do until all devices done */
     1339 	     call ioa_$rsnnl ("handler ^d:", out_temp, (0), binary (hand_addr (i)));
     1340 	     output_line = out_temp;			/* This starts the line */
     1341 	     if hand_resv (i) then output_line = output_line || " reserved";
     1342 	     if hand_op (i) then output_line = output_line || " operational";
     1343 	     if hand_ready (i) then output_line = output_line || " ready";
     1344 	     if hand_track (i) then output_line = output_line || " 9 track";
     1345 	     else output_line = output_line || " 7 track";
     1346 	     if hand_speed (i) = "001"b then output_line = output_line || " 75 ips";
     1347 	     else if hand_speed (i) = "010"b then output_line = output_line || " 125 ips";
     1348 	     else if hand_speed (i) = "100"b then output_line = output_line || " 200 ips";
     1349 	     else do;				/* Some unusual speed code */
     1350 		call ioa_$rsnnl (" speed code=^b", out_temp, (0), hand_speed (i));
     1351 		output_line = output_line || out_temp;
     1352 	     end;
     1353 	     if hand_record (i) = "0000"b then output_line = output_line || " 1600 bpi";
     1354 	     else if hand_record (i) = "0001"b then output_line = output_line || " 200,556,800 bpi";
     1355 	     else if hand_record (i) = "0100"b then output_line = output_line || " 200,556,800,1600 bpi";
     1356 	     else do;				/* Some other strange code */
     1357 		call ioa_$rsnnl (" density code=^b", out_temp, (0), hand_record (i));
     1358 		output_line = output_line || out_temp;
     1359 	     end;
     1360 
     1361 	     call ioa_ ("^a", output_line);
     1362 	end;
     1363 
     1364 	go to next;
     1365 
     1366 /* Command to display detailed tape status */
     1367 
     1368 dump_dtstat: dp_loc = 65;				/* Default location */
     1369 	call next_word;
     1370 	if ^end_line then do;
     1371 	     if ^octal_word then go to std_err;
     1372 	     dp_loc = octal_val + 1;
     1373 	end;
     1374 
     1375 	dtstp = addr (work_seg (dp_loc));		/* Get pointer to detailed status */
     1376 
     1377 	output_line = "Byte 0:";
     1378 	if dt_stat.devflt then output_line = output_line || "  device-fault";
     1379 	if dt_stat.ccerr then output_line = output_line || "  command-code-error";
     1380 	if dt_stat.rawerr then output_line = output_line || "  read-after-write-error";
     1381 	if dt_stat.mbot then output_line = output_line || "  multiple BOTs";
     1382 	if dt_stat.bot then output_line = output_line || "  BOT";
     1383 	if dt_stat.eot then output_line = output_line || "  EOT";
     1384 	if dt_stat.standby then output_line = output_line || "  standby";
     1385 	if dt_stat.marg then output_line = output_line || "  marginal-condition";
     1386 	call ioa_ ("^a", output_line);
     1387 
     1388 	output_line = "Byte 1:";
     1389 	if dt_stat.loaded then output_line = output_line || "  loaded";
     1390 	if dt_stat.lcw then output_line = output_line || "  last-command-write";
     1391 	if dt_stat.lcf then output_line = output_line || "  last-command-forward";
     1392 	if dt_stat.rewind then output_line = output_line || "  rewinding";
     1393 	if dt_stat.wpr then output_line = output_line || "  write-permit-ring";
     1394 	if dt_stat.spr then output_line = output_line || "  software-write-permit";
     1395 	if dt_stat.diag then output_line = output_line || "  diagnostic-mode";
     1396 	if dt_stat.ccpe then output_line = output_line || "  command-code-parity-even";
     1397 	call ioa_ ("^a", output_line);
     1398 
     1399 	output_line = "Byte 2:";
     1400 	output_line = output_line || "  density=";
     1401 	if dt_stat.denr = "000"b then output_line = output_line || "1600";
     1402 	else if dt_stat.denr = "001"b then output_line = output_line || "3200";
     1403 	else if dt_stat.denr = "100"b then output_line = output_line || "800";
     1404 	else if dt_stat.denr = "101"b then output_line = output_line || "1200";
     1405 	else if dt_stat.denr = "110"b then output_line = output_line || "200";
     1406 	else if dt_stat.denr = "111"b then output_line = output_line || "556";
     1407 	else do;
     1408 	     call ioa_$rsnnl ("(^b)", out_temp, (0), dt_stat.denr);
     1409 	     output_line = output_line || out_temp;
     1410 	end;
     1411 	if dt_stat.lowt then output_line = output_line || "  low-threshold";
     1412 	output_line = output_line || "  recording=";
     1413 	if dt_stat.denc = "0000"b then output_line = output_line || "1600";
     1414 	else if dt_stat.denc = "0001"b then output_line = output_line || "1600,800,556,200";
     1415 	else if dt_stat.denc = "0010"b then output_line = output_line || "1200,800,556,200";
     1416 	else if dt_stat.denc = "0011"b then output_line = output_line || "1200";
     1417 	else if dt_stat.denc = "0100"b then output_line = output_line || "800,556,200";
     1418 	else if dt_stat.denc = "0101"b then output_line = output_line || "556,200";
     1419 	else if dt_stat.denc = "0110"b then output_line = output_line || "200";
     1420 	else if dt_stat.denc = "0111"b then output_line = output_line || "3200";
     1421 	else do;
     1422 	     call ioa_$rsnnl ("(^b)", out_temp, (0), dt_stat.denc);
     1423 	     output_line = output_line || out_temp;
     1424 	end;
     1425 	call ioa_ ("^a", output_line);
     1426 
     1427 	output_line = "Byte 3:";
     1428 	i = bin (dt_stat.speed);
     1429 	output_line = output_line || "  speed=";
     1430 	if i <= 15 then output_line = output_line || speed_constant (i);
     1431 	else do;
     1432 	     call ioa_$rsnnl ("(^b)", out_temp, (0), dt_stat.speed);
     1433 	     output_line = output_line || out_temp;
     1434 	end;
     1435 	if dt_stat.track then output_line = output_line || "  9-channel";
     1436 	else output_line = output_line || "  7-channel";
     1437 	if dt_stat.nsbot then output_line = output_line || "  non-stanard-BOT";
     1438 	call ioa_ ("^a", output_line);
     1439 
     1440 	output_line = "Byte 4:";
     1441 	if dt_stat.dms then output_line = output_line || "  device-multiple-select";
     1442 	output_line = output_line || "  address=";
     1443 	call ioa_$rsnnl ("^d", out_temp, (0), bin (dt_stat.addr));
     1444 	output_line = output_line || out_temp;
     1445 	call ioa_ ("^a", output_line);
     1446 
     1447 	go to next;
     1448 
     1449 /* Save dcw lists in a segment */
     1450 
     1451 save_segment:
     1452 	call save_seg_util ("1"b);			/* Find and/or make segment */
     1453 
     1454 	save_seg.version = 1;
     1455 	save_seg.code = save_seg_code;
     1456 	save_seg.time = clock ();
     1457 	save_seg.pcw_list = pcw_list;
     1458 	save_seg.dcw_len = dcw_len;
     1459 	save_seg.list_name = list_name;
     1460 	save_seg.dcw_list = dcw_list;
     1461 	call adjust_bit_count_ (dir, ename, "0"b, (0), code);
     1462 	if code ^= 0 then call com_err_ (code, cmd_name, "Setting bit_count");
     1463 	call hcs_$terminate_noname (save_segp, code);
     1464 	save_segp = null;
     1465 	go to next;
     1466 
     1467 /* Restore dcw lists from a segment */
     1468 
     1469 restore_segment:
     1470 	call save_seg_util ("0"b);			/* Find segment */
     1471 
     1472 	if (save_seg.code ^= save_seg_code) | (save_seg.version ^= 1) then do;
     1473 	     call ioa_ ("not a test_dcw data segment");
     1474 	     call hcs_$terminate_noname (save_segp, code);
     1475 	     save_segp = null;
     1476 	     go to next;
     1477 	end;
     1478 
     1479 	call date_time_ (save_seg.time, time_string);
     1480 	call ioa_ ("Segment saved at ^a", time_string);
     1481 	pcw_list = save_seg.pcw_list;
     1482 	dcw_len = save_seg.dcw_len;
     1483 	list_name = save_seg.list_name;
     1484 	dcw_list = save_seg.dcw_list;
     1485 	call hcs_$terminate_noname (save_segp, code);
     1486 	save_segp = null;
     1487 	insert_mode = "0"b;
     1488 	idx, list = 1;
     1489 	if ^debug_sw then do i = 1 to 32;		/* Loop thru and fix device addresses */
     1490 	     if pcw_list (i) ^= "0"b then addr (pcw_list (i)) -> pcw.device = default_device;
     1491 	     do j = 1 to dcw_len (i);
     1492 		if addr (dcw_list (i, j)) -> idcw.code = "111"b then
     1493 		     addr (dcw_list (i, j)) -> idcw.device = default_device;
     1494 	     end;
     1495 	end;
     1496 	go to next;
     1497 
     1498 
     1499 /* Procedure for initiating or making the save segment */
     1500 
     1501 save_seg_util: proc (make_sw);
     1502 
     1503 dcl  make_sw bit (1);				/* Says whether to call make_seg or initiate */
     1504 
     1505 	     call next_word;
     1506 	     if end_line then do;
     1507 		call ioa_ ("Path missing");
     1508 		go to next;
     1509 	     end;
     1510 	     call expand_pathname_ (word, dir, unsuffixed_ename, code);
     1511 	     if code ^= 0 then do;
     1512 		call com_err_ (code, cmd_name, "^a", word);
     1513 		go to next;
     1514 	     end;
     1515 	     call suffixed_name_$make (unsuffixed_ename, cmd_name, ename, code);
     1516 	     if code ^= 0 then do;
     1517 		call com_err_ (code, cmd_name, "^a", unsuffixed_ename);
     1518 		go to next;
     1519 	     end;
     1520 	     if make_sw then call hcs_$make_seg (dir, ename, "", 01010b, save_segp, code);
     1521 	     else call hcs_$initiate (dir, ename, "", 0, 0, save_segp, code);
     1522 	     if save_segp = null then do;
     1523 		call com_err_ (code, cmd_name, "^a^[>^]^a", dir, dir ^= ">", ename);
     1524 		go to next;
     1525 	     end;
     1526 
     1527 	     return;
     1528 
     1529 	end save_seg_util;
     1530 
     1531 /* Internal procedure to extract the next word from the input line */
     1532 
     1533 next_word: proc;
     1534 
     1535 	     end_line = "0"b;			/* Reset the end of line flag */
     1536 nw_loop:	     if input_pos > input_len then do;		/* Past end of line */
     1537 		end_line = "1"b;			/* Set end of line flag */
     1538 		return;				/* And exit */
     1539 	     end;
     1540 	     temp_char = substr (input_line, input_pos, 1); /* Get next char */
     1541 	     if temp_char = " " | temp_char = tab then do; /* If white space */
     1542 		input_pos = input_pos + 1;		/* Ignore it */
     1543 		go to nw_loop;
     1544 	     end;
     1545 
     1546 	     i = input_pos;				/* Current position */
     1547 nw_scan:	     i = i + 1;				/* Next position */
     1548 	     if i > input_len then go to nw_found;	/* Word is ended by the end of the line */
     1549 	     temp_char = substr (input_line, i, 1);	/* Get next char */
     1550 	     if ^(temp_char = " " | temp_char = tab) then go to nw_scan; /* If a meaningful character */
     1551 nw_found:	     word = substr (input_line, input_pos, i-input_pos); /* Extract the word */
     1552 	     input_pos = i;				/* Update position */
     1553 
     1554 	     octal_val = cv_oct_check_ (word, i);	/* Test it */
     1555 	     octal_word = (i = 0);			/* Set octal flag if no errors */
     1556 	     dec_val = cv_dec_check_ (word, i);		/* Attempt the conversion */
     1557 	     dec_word = (i = 0);			/* Set decimal flag if no errors */
     1558 
     1559 	     return;
     1560 
     1561 	end next_word;
     1562 
     1563 /* Routines to convert numbers to octal char strings */
     1564 
     1565 oct:	proc (l, val);
     1566 
     1567 dcl  l fixed bin;					/* Length of string */
     1568 dcl  val fixed bin (35);				/* Value to convert */
     1569 
     1570 	     call ioa_$rsnnl ("^w", word, (0), val);	/* Get octal version of word */
     1571 	     output_line = output_line || substr (word, 13-l, l);
     1572 
     1573 	end oct;
     1574 
     1575 /* Fuction which returns the next word on the input line as a bit string */
     1576 
     1577 bit6:	proc returns (bit (6));
     1578 
     1579 	     call next_word;			/* Get next word */
     1580 	     if end_line then go to store;
     1581 	     if ^octal_word then go to std_err;
     1582 	     return (bit (binary (octal_val, 6, 0)));
     1583 
     1584 	end bit6;
     1585 
     1586 
     1587 /* Called by commands which are not allowed in debug mode */
     1588 
     1589 debug_check: proc;
     1590 
     1591 	     if ^debug_sw then return;
     1592 
     1593 	     call ioa_ ("Command not allowed in debug mode");
     1594 	     go to next;
     1595 
     1596 	end debug_check;
     1597 
     1598 /* Routine to get next word as a list number */
     1599 
     1600 get_list_num: proc;
     1601 
     1602 	     dec_val = -1;
     1603 	     call next_word;
     1604 	     if end_line then return;
     1605 check_list_num: entry;
     1606 	     if dec_word then do;
     1607 		if dec_val < 1 | dec_val > 32 then do;
     1608 		     call ioa_ ("Invalid dcw list number: ^d", dec_val);
     1609 		     go to next;
     1610 		end;
     1611 		else return;
     1612 	     end;
     1613 	     do i = 1 to 32;
     1614 		if list_name (i) = word then do;
     1615 		     dec_val = i;
     1616 		     return;
     1617 		end;
     1618 	     end;
     1619 	     call ioa_ ("No dcw list named ^a", word);
     1620 	     go to next;
     1621 
     1622 	end get_list_num;
     1623 
     1624 /* Function which tests for an empty DCW list */
     1625 
     1626 empty_list: proc (l) returns (bit (1));
     1627 
     1628 dcl  l fixed bin;
     1629 
     1630 	     return ((pcw_list (l) = "0"b) & (dcw_len (l) = 0));
     1631 
     1632 	end empty_list;
     1633 
     1634 /* Routine to return the next word as a dcw number */
     1635 
     1636 get_dcw_num: proc;
     1637 
     1638 	     call next_word;
     1639 	     if end_line then return;			/* If no more, don't change num */
     1640 	     if ^octal_word then go to std_err;
     1641 	     if octal_val < 0 | octal_val > 31 then go to std_err;
     1642 	     idx = octal_val + 1;
     1643 	     return;
     1644 
     1645 	end get_dcw_num;
     1646 
     1647 /* Cleanup handler */
     1648 
     1649 clean_up:	proc;
     1650 
     1651 	     if rcp_id ^= "0"b then do;		/* If device attached thru rcp */
     1652 		call rcp_$detach (rcp_id, "0"b, 0, "", code);
     1653 		rcp_id = "0"b;
     1654 	     end;
     1655 
     1656 	     if ev_chan ^= -1 then do;		/* If event channel created */
     1657 		call ipc_$delete_ev_chn (ev_chan, code);
     1658 		ev_chan = -1;
     1659 	     end;
     1660 
     1661 	     if ptr_array (1) ^= null then do;
     1662 		call release_temp_segments_ (cmd_name, ptr_array, code);
     1663 		ptr_array = null;
     1664 	     end;
     1665 
     1666 	     if save_segp ^= null then do;
     1667 		call hcs_$terminate_noname (save_segp, code);
     1668 		save_segp = null;
     1669 	     end;
     1670 
     1671 	     return;
     1672 
     1673 	end clean_up;
     1674 
     1675      end test_dcw;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/18/86  1230.0  test_dcw.pl1                      >spec>install>1098>test_dcw.pl1
201          1    08/17/79  2215.0  ioi_stat.incl.pl1                 >ldd>include>ioi_stat.incl.pl1
211          2    01/10/75  1343.6  iom_stat.incl.pl1                 >ldd>include>iom_stat.incl.pl1
214          3    04/05/83  0853.0  rcp_tape_info.incl.pl1            >ldd>include>rcp_tape_info.incl.pl1
216          4    07/18/86  1218.4  rcp_disk_info.incl.pl1            >spec>install>1098>rcp_disk_info.incl.pl1
218          5    07/18/86  1218.3  rcp_printer_info.incl.pl1         >spec>install>1098>rcp_printer_info.incl.pl1
220          6    03/27/86  1120.0  rcp_resource_types.incl.pl1       >ldd>include>rcp_resource_types.incl.pl1
222          7    07/18/86  1218.3  rcp_device_info.incl.pl1          >spec>install>1098>rcp_device_info.incl.pl1
224          8    05/06/74  1742.1  iom_pcw.incl.pl1                  >ldd>include>iom_pcw.incl.pl1
225          9    11/12/74  1550.1  iom_dcw.incl.pl1                  >ldd>include>iom_dcw.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DEVICE_INFO_VERSION_1                  constant        fixed bin(17,0)          initial dcl 7-26 ref 447
DEVICE_TYPE                     000000 constant        char(32)                 initial array unaligned dcl 6-18 ref 354 354 356 358
                                                                                  360 360 362 362 364 364 367 369 371 374 375 379
                                                                                  380 383 385 396 402 417 424 432 438 486 487 488
                                                                                  492 492 493
DISK_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 6-30 ref 354 358 379 417 424 486 492
DISK_INFO_VERSION_1                    constant        fixed bin(17,0)          initial dcl 4-29 ref 419
PRINTER_DTYPEX                         constant        fixed bin(17,0)          initial dcl 6-32 ref 360 360 367 432 438 488
PRINTER_INFO_VERSION_1                 constant        fixed bin(17,0)          initial dcl 5-27 ref 434
PUNCH_DTYPEX                           constant        fixed bin(17,0)          initial dcl 6-33 ref 364 364 371
READER_DTYPEX                          constant        fixed bin(17,0)          initial dcl 6-34 ref 362 362 369
SPECIAL_DTYPEX                         constant        fixed bin(17,0)          initial dcl 6-35 ref 375 380 383 385 493
TAPE_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 6-29 ref 354 356 374 396 402 487 492
addr                      0(35)        based           bit(5)                   level 2 in structure "dt_stat" packed unaligned
                                                                                  dcl 111 in procedure "test_dcw" ref 1443 1443
addr                                                   builtin function         dcl 295 in procedure "test_dcw" ref 305 397 418 433
                                                                                  446 473 473 473 473 498 499 500 501 502 503 521
                                                                                  543 543 892 894 945 945 945 945 954 966 984 1004
                                                                                  1004 1045 1065 1065 1244 1336 1375 1490 1492 1492
address                                based           bit(18)                  level 2 in structure "tdcw" packed unaligned
                                                                                  dcl 9-14 in procedure "test_dcw" set ref 647* 1175
                                                                                  1175
address                                based           bit(18)                  level 2 in structure "dcw" packed unaligned dcl 9-7
                                                                                  in procedure "test_dcw" set ref 711* 1185 1185
adjust_bit_count_               000120 constant        entry                    external dcl 273 ref 1461
analyze_device_stat_$rsnnl      000124 constant        entry                    external dcl 275 ref 1060
arg                                    based           char                     unaligned dcl 60 set ref 320 321 322 325* 329 330
                                                                                  331 331 332 333 333
arg_cnt                         002411 automatic       fixed bin(17,0)          dcl 57 set ref 311* 314
arg_len                         002414 automatic       fixed bin(17,0)          dcl 59 set ref 315* 320 321 322 325 325 329 330 331
                                                                                  331 332 333 333
arg_ptr                         002412 automatic       pointer                  dcl 58 set ref 315* 320 321 322 325 329 330 331 331
                                                                                  332 333 333
bbyte                                  based           bit(8)                   array level 2 packed unaligned dcl 169 set ref 1253*
before                                                 builtin function         dcl 295 ref 839
bin                                                    builtin function         dcl 295 ref 492 1428 1443 1443
bin_bytes                              based           structure                level 1 dcl 169
binary                                                 builtin function         dcl 295 ref 647 665 711 716 721 1150 1150 1153 1153
                                                                                  1157 1157 1161 1161 1165 1165 1175 1175 1185 1185
                                                                                  1187 1187 1190 1190 1339 1339 1582
bit                                                    builtin function         dcl 295 ref 492 647 665 711 716 721 1582
bot                       0(04)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1382
bstat                                  based           bit(36)                  array dcl 1037 set ref 1045*
byte_ptr                        003020 automatic       pointer                  dcl 166 set ref 1244* 1253
ccerr                     0(01)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1379
ccpe                      0(15)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1396
chan                            002573 automatic       fixed bin(6,0)           dcl 85 set ref 852* 858*
chan_cmd                  0(24)        based           bit(6)                   level 2 packed unaligned dcl 8-21 set ref 671* 690*
                                                                                  1159 1161 1161
char_pos                  0(18)        based           bit(3)                   level 2 packed unaligned dcl 9-7 set ref 721* 1188
                                                                                  1190 1190
cleanup                         003106 stack reference condition                dcl 297 ref 307
clock                                                  builtin function         dcl 295 ref 1456
cmd_name                        003104 automatic       char(8)                  initial unaligned dcl 232 set ref 232* 317* 325*
                                                                                  341* 343* 392* 463* 471* 476* 482* 510* 518* 528*
                                                                                  545* 605* 813* 829* 848* 854* 859* 866* 873* 881*
                                                                                  889* 940* 948* 1007* 1462* 1512* 1515* 1517* 1523*
                                                                                  1662*
code                      1            based           char(16)                 level 2 in structure "save_seg" dcl 190 in procedure
                                                                                  "test_dcw" set ref 1455* 1472
code                      0(18)        based           bit(3)                   level 2 in structure "idcw" packed unaligned
                                                                                  dcl 8-21 in procedure "test_dcw" set ref 660* 1148
                                                                                  1492
code                            002306 automatic       fixed bin(35,0)          dcl 41 in procedure "test_dcw" set ref 315* 316 317*
                                                                                  324* 325* 335* 341* 342 343* 389* 390 391* 392*
                                                                                  459* 461* 462 463* 467* 473* 474 475* 476* 496*
                                                                                  508* 509 510* 516* 517 518* 527* 528 528* 543* 544
                                                                                  545* 812* 813 813* 827* 828 829* 847* 848 848*
                                                                                  852* 853 854* 858* 859 859* 865* 866 866* 872* 873
                                                                                  873* 880* 881 881* 888* 889 889* 937* 938* 939
                                                                                  940* 945* 946 947* 948* 1004* 1005 1006* 1007*
                                                                                  1461* 1462 1462* 1463* 1474* 1485* 1510* 1511
                                                                                  1512* 1515* 1516 1517* 1520* 1521* 1523* 1652*
                                                                                  1657* 1662* 1667*
com_err_                        000010 constant        entry                    external dcl 236 ref 317 325 343 392 463 476 482 510
                                                                                  518 528 545 813 829 848 854 859 866 873 881 889
                                                                                  940 948 1007 1462 1512 1517 1523
command                                based           bit(6)                   level 2 packed unaligned dcl 8-21 set ref 665* 1150
                                                                                  1150
completion                      003046 automatic       structure                level 2 in structure "stat" dcl 205 in procedure
                                                                                  "test_dcw"
completion                             based           structure                level 2 in structure "istat" dcl 1-7 in procedure
                                                                                  "test_dcw"
completion                             based           structure                array level 2 in structure "status_queue" dcl 206
                                                                                  in procedure "test_dcw"
control                   0(22)        based           bit(2)                   level 2 in structure "idcw" packed unaligned
                                                                                  dcl 8-21 in procedure "test_dcw" set ref 674* 675*
                                                                                  1169 1170
control                   0(22)        based           bit(2)                   level 2 in structure "pcw" packed unaligned dcl 8-6
                                                                                  in procedure "test_dcw" set ref 679*
convert_ipc_code_               000012 constant        entry                    external dcl 237 ref 391 475 947 1006
count                     0(30)        based           bit(6)                   level 2 packed unaligned dcl 8-21 set ref 672* 689*
                                                                                  1163 1165 1165
cpz_status_table_$cpz_status_table_
                                000142 external static fixed bin(17,0)          dcl 286 set ref 502
crz_status_table_$crz_status_table_
                                000144 external static fixed bin(17,0)          dcl 287 set ref 501
cu_$arg_count                   000014 constant        entry                    external dcl 238 ref 311
cu_$arg_ptr                     000016 constant        entry                    external dcl 239 ref 315
cv_dec_check_                   000020 constant        entry                    external dcl 240 ref 1556
cv_oct_check_                   000022 constant        entry                    external dcl 241 ref 1554
date_time_                      000114 constant        entry                    external dcl 271 ref 1479
dcw                                    based           structure                level 1 dcl 9-7
dcw_len                  50            based           fixed bin(17,0)          array level 2 in structure "save_seg" dcl 190
                                                                                  in procedure "test_dcw" set ref 1458* 1482
dcw_len                         002142 automatic       fixed bin(17,0)          array dcl 36 in procedure "test_dcw" set ref 303*
                                                                                  627 633* 633 636* 636 781 782* 782 927 933 1134
                                                                                  1458 1482* 1491 1630
dcw_list                        000100 automatic       bit(36)                  array unaligned dcl 32 in procedure "test_dcw" set
                                                                                  ref 301* 630* 630 635* 785* 785 932 933 1146 1460
                                                                                  1484* 1492 1492
dcw_list                210            based           bit(36)                  array level 2 in structure "save_seg" dcl 190
                                                                                  in procedure "test_dcw" set ref 1460* 1484
dcw_word                        002564 automatic       bit(36)                  dcl 78 set ref 305 556* 623 635 730* 1139* 1146*
                                                                                  1194*
dcwp                            003100 automatic       pointer                  dcl 9-4 set ref 305* 700 703 706 711 716 721 1182
                                                                                  1183 1185 1185 1187 1187 1188 1190 1190
debug_sw                        002443 automatic       bit(1)                   initial unaligned dcl 68 set ref 68* 333* 340 535
                                                                                  1489 1591
dec_val                         002316 automatic       fixed bin(35,0)          dcl 48 set ref 754 811 826 921 922 1117 1556* 1602*
                                                                                  1607 1607 1608* 1615*
dec_word                        002315 automatic       bit(1)                   unaligned dcl 47 set ref 810 825 1557* 1606
default_device                  002704 automatic       bit(6)                   unaligned dcl 96 set ref 348* 492* 493* 494* 661
                                                                                  1490 1492
denc                      0(20)        based           bit(4)                   level 2 packed unaligned dcl 111 set ref 1413 1414
                                                                                  1415 1416 1417 1418 1419 1420 1422*
denr                      0(16)        based           bit(3)                   level 2 packed unaligned dcl 111 set ref 1401 1402
                                                                                  1403 1404 1405 1406 1408*
density                  10            based           bit(36)                  level 2 dcl 3-15 set ref 407*
detailed_status                 002707 automatic       bit(216)                 unaligned dcl 99 set ref 888* 892 894
detailed_status_array                  based           bit(8)                   array unaligned dcl 100 set ref 892 894*
dev_name                        002422 automatic       varying char(16)         dcl 63 set ref 312* 321 321* 339 339* 354 354 354
                                                                                  356 356* 358 358* 360 360 360* 362 362 362* 364
                                                                                  364 364* 366 367 369 371 373 375 375 378 380 380
                                                                                  402 403 424 425 438 439 451 452 463* 486* 487*
                                                                                  488* 489* 490* 492 498 499 500 501 502 503
dev_type                        002427 automatic       varying char(16)         dcl 64 set ref 354* 356* 358* 360* 362* 364* 367*
                                                                                  369* 371* 374* 375* 379* 380* 383* 385* 396 417
                                                                                  432 451 459 461 486 487 488 492 492 493
devflt                                 based           bit(1)                   level 2 packed unaligned dcl 111 ref 1378
device                    0(06)        based           bit(6)                   level 2 in structure "idcw" packed unaligned
                                                                                  dcl 8-21 in procedure "test_dcw" set ref 661* 669*
                                                                                  1151 1153 1153 1157 1157 1492*
device                    0(06)        based           bit(6)                   level 2 in structure "pcw" packed unaligned dcl 8-6
                                                                                  in procedure "test_dcw" set ref 1490*
device_info                            based           structure                level 1 dcl 7-17
device_info_ptr                 003072 automatic       pointer                  dcl 7-15 set ref 446* 447 448 449 450 451 452 453
                                                                                  454 489
device_name               4            based           char(8)                  level 2 in structure "printer_info" dcl 5-17
                                                                                  in procedure "test_dcw" set ref 438* 439* 488
device_name               4            based           char(8)                  level 2 in structure "tape_info" dcl 3-15
                                                                                  in procedure "test_dcw" set ref 402* 403* 487
device_name               4            based           char(8)                  level 2 in structure "device_info" dcl 7-17
                                                                                  in procedure "test_dcw" set ref 451* 452* 489
device_name               4            based           char(8)                  level 2 in structure "disk_info" dcl 4-19
                                                                                  in procedure "test_dcw" set ref 424* 425* 486
devx                            002403 automatic       fixed bin(17,0)          initial dcl 53 set ref 53* 467* 508* 516* 527* 812*
                                                                                  827* 847* 858* 865* 872* 880* 888* 937* 938*
diag                      0(14)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1395
dir                             002600 automatic       char(168)                unaligned dcl 89 set ref 1461* 1510* 1520* 1521*
                                                                                  1523* 1523
disk_info                              based           structure                level 1 dcl 4-19
disk_info_ptr                   003066 automatic       pointer                  dcl 4-17 set ref 418* 419 420 421 422 423 424 425
                                                                                  426 427 428 429 486
disk_status_table_$disk_status_table_
                                000134 external static fixed bin(17,0)          dcl 283 set ref 498
divide                                                 builtin function         dcl 295 ref 528 528 806 806 807 807
dms                       0(32)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1441
dp_byte                         002410 automatic       bit(1)                   unaligned dcl 56 set ref 1208* 1211* 1227
dp_len                          002406 automatic       fixed bin(17,0)          dcl 55 set ref 1213* 1222* 1227 1245 1304* 1309*
                                                                                  1309 1314 1320 1321
dp_loc                          002405 automatic       fixed bin(17,0)          dcl 55 set ref 1212* 1218* 1227* 1227 1227* 1230
                                                                                  1239* 1244 1269* 1279 1280* 1280 1294* 1308 1310*
                                                                                  1310 1321 1321 1322* 1322 1329* 1333* 1336 1368*
                                                                                  1372* 1375
dp_rpt                          002407 automatic       fixed bin(17,0)          dcl 55 set ref 1302* 1319* 1319 1319*
dt_stat                                based           structure                level 1 dcl 111
dtstp                           003012 automatic       pointer                  dcl 109 set ref 1375* 1378 1379 1380 1381 1382 1383
                                                                                  1384 1385 1389 1390 1391 1392 1393 1394 1395 1396
                                                                                  1401 1402 1403 1404 1405 1406 1408 1411 1413 1414
                                                                                  1415 1416 1417 1418 1419 1420 1422 1428 1432 1435
                                                                                  1437 1441 1443 1443
ec                        0(33)        based           bit(1)                   level 2 packed unaligned dcl 9-14 set ref 650* 1176
ename                           002662 automatic       char(32)                 unaligned dcl 91 set ref 1461* 1515* 1520* 1521*
                                                                                  1523*
end_line                        002312 automatic       bit(1)                   unaligned dcl 44 set ref 555 645 655 663 684 709 714
                                                                                  719 728 741 756 792 805 820 838 846 1019 1029 1091
                                                                                  1216 1220 1264 1272 1277 1289 1297 1306 1331 1370
                                                                                  1506 1535* 1537* 1580 1604 1639
eot                       0(05)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1383
er                        0(01) 003046 automatic       bit(1)                   level 3 packed unaligned dcl 205 set ref 989
error_table_$badopt             000150 external static fixed bin(35,0)          dcl 290 ref 335
error_table_$request_not_recognized
                                000152 external static fixed bin(35,0)          dcl 291 ref 324
ev_chan                   2     003024 automatic       fixed bin(71,0)          initial level 2 dcl 172 set ref 172* 389* 459* 461*
                                                                                  496* 1004* 1656 1657* 1658*
ev_count                        003024 automatic       fixed bin(17,0)          initial level 2 dcl 172 set ref 172*
event_info                      003030 automatic       structure                level 1 unaligned dcl 176 set ref 473 473 945 945
                                                                                  1004 1004
event_list                      003024 automatic       structure                level 1 unaligned dcl 172 set ref 473 473 945 945
exec_no_err_sw                  002570 automatic       bit(1)                   unaligned dcl 82 set ref 558* 902* 907* 910* 914*
                                                                                  987
exec_rept_cnt                   002404 automatic       fixed bin(17,0)          dcl 54 set ref 917* 990* 990 998*
exec_rept_sw                    002571 automatic       bit(1)                   unaligned dcl 83 set ref 558* 901* 906* 916* 986 998
exec_spec_sw                    002567 automatic       bit(1)                   unaligned dcl 81 set ref 558* 900* 905* 915* 997
expand_pathname_                000106 constant        entry                    external dcl 268 ref 1510
ext                       0(12)        based           bit(6)                   level 2 packed unaligned dcl 8-21 set ref 670* 1155
ext_ctl                   0(21)        based           bit(1)                   level 2 packed unaligned dcl 8-21 set ref 673* 1167
flush_sw                        002577 automatic       bit(1)                   unaligned dcl 88 set ref 536* 559* 957 968 977 1011
get_temp_segments_              000102 constant        entry                    external dcl 266 ref 341
hand_addr                 0(04)        based           bit(5)                   array level 2 packed unaligned dcl 147 ref 1339 1339
hand_op                   0(02)        based           bit(1)                   array level 2 packed unaligned dcl 147 ref 1342
hand_ready                0(03)        based           bit(1)                   array level 2 packed unaligned dcl 147 ref 1343
hand_record               0(14)        based           bit(4)                   array level 2 packed unaligned dcl 147 set ref 1353
                                                                                  1354 1355 1357*
hand_resv                 0(01)        based           bit(1)                   array level 2 packed unaligned dcl 147 ref 1341
hand_speed                0(10)        based           bit(3)                   array level 2 packed unaligned dcl 147 set ref 1346
                                                                                  1347 1348 1350*
hand_track                0(13)        based           bit(1)                   array level 2 packed unaligned dcl 147 ref 1344
hbound                                                 builtin function         dcl 295 ref 932
hcs_$initiate                   000110 constant        entry                    external dcl 269 ref 1521
hcs_$make_seg                   000122 constant        entry                    external dcl 274 ref 1520
hcs_$terminate_noname           000116 constant        entry                    external dcl 272 ref 1463 1474 1485 1667
i                               002310 automatic       fixed bin(17,0)          dcl 43 in procedure "test_dcw" set ref 314* 315*
                                                                                  317* 627* 628 629 630 631* 631 743* 744* 744 745*
                                                                                  746* 779* 780 785 786* 786 794* 796 796* 892* 892*
                                                                                  894* 932* 933 933 933 934* 1004* 1010 1094* 1095*
                                                                                  1096* 1096 1096 1097* 1106* 1107 1107* 1108* 1108
                                                                                  1108 1108* 1108* 1224* 1229 1233* 1233 1234 1236*
                                                                                  1247* 1247 1248 1250* 1320* 1338* 1338* 1339 1339
                                                                                  1341 1342 1343 1344 1346 1347 1348 1350 1353 1354
                                                                                  1355 1357* 1428* 1430 1430 1489* 1490 1490 1491
                                                                                  1492 1492* 1546* 1547* 1547 1548 1549 1551 1552
                                                                                  1554* 1555 1556* 1557 1613* 1614 1615*
i                               003154 automatic       fixed bin(17,0)          dcl 1132 in procedure "print_subr" set ref 1134*
                                                                                  1137 1146 1167 1195 1197 1197*
id_name                         002434 automatic       varying char(16)         dcl 65 set ref 313* 322 322* 410 411 426 427
idcw                                   based           structure                level 1 dcl 8-21
idcwp                           003076 automatic       pointer                  dcl 8-19 set ref 305* 660 661 665 669 670 671 672
                                                                                  673 674 675 689 690 1148 1150 1150 1151 1153 1153
                                                                                  1155 1157 1157 1159 1161 1161 1163 1165 1165 1167
                                                                                  1169 1170
idx                             002141 automatic       fixed bin(17,0)          initial dcl 35 set ref 35* 610 628 635 636 637* 637
                                                                                  759* 779 923* 1118* 1197 1488* 1642*
imess                                  based           structure                level 1 dcl 1-21
imp                             003044 automatic       pointer                  dcl 1-19 set ref 954* 956 960
imp_status_table_$imp_status_table_
                                000146 external static fixed bin(17,0)          dcl 288 set ref 503
input_len                       002243 automatic       fixed bin(21,0)          dcl 38 set ref 543* 548 548 548* 548 1536 1548
input_line                      002202 automatic       char(132)                unaligned dcl 37 set ref 543 543 543 543 548 1540
                                                                                  1549 1551
input_pos                       002244 automatic       fixed bin(17,0)          dcl 39 set ref 550* 1536 1540 1542* 1542 1546 1551
                                                                                  1551 1552*
insert_mode                     002317 automatic       bit(1)                   initial unaligned dcl 49 set ref 49* 609 626 760*
                                                                                  767* 773* 924* 1119* 1487*
ioa_                            000024 constant        entry                    external dcl 242 ref 471 490 605 610 615 745 750 806
                                                                                  807 821 822 882 883 890 894 928 998 1011 1029 1040
                                                                                  1045 1050 1055 1061 1065 1081 1096 1101 1108 1113
                                                                                  1122 1195 1197 1235 1249 1258 1265 1273 1290 1298
                                                                                  1315 1361 1386 1397 1425 1438 1445 1473 1480 1507
                                                                                  1593 1608 1619
ioa_$nnl                        000026 constant        entry                    external dcl 243 ref 542
ioa_$rsnnl                      000030 constant        entry                    external dcl 244 ref 1194 1230 1239 1253 1339 1350
                                                                                  1357 1408 1422 1432 1443 1570
ioi_$connect                    000032 constant        entry                    external dcl 245 ref 938
ioi_$connect_pcw                000034 constant        entry                    external dcl 246 ref 937
ioi_$get_detailed_status        000062 constant        entry                    external dcl 257 ref 888
ioi_$get_special_status         000064 constant        entry                    external dcl 258 ref 880
ioi_$release_devices            000060 constant        entry                    external dcl 256 ref 872
ioi_$set_channel_required       000066 constant        entry                    external dcl 259 ref 847 858
ioi_$set_status                 000036 constant        entry                    external dcl 247 ref 516
ioi_$suspend_devices            000070 constant        entry                    external dcl 260 ref 865
ioi_$timeout                    000040 constant        entry                    external dcl 248 ref 527 812
ioi_$workspace                  000042 constant        entry                    external dcl 249 ref 508 827
iom                             002572 automatic       fixed bin(3,0)           dcl 84 set ref 852* 858*
iom_stat                  4     003046 automatic       bit(72)                  level 2 dcl 205 set ref 960* 984 1050 1050 1060*
                                                                                  1065 1065 1065 1065 1065 1065
iox_$get_line                   000044 constant        entry                    external dcl 250 ref 543
iox_$user_input                 000130 external static pointer                  dcl 280 set ref 543*
ipc_$block                      000046 constant        entry                    external dcl 251 ref 473 945
ipc_$create_ev_chn              000050 constant        entry                    external dcl 252 ref 389
ipc_$delete_ev_chn              000052 constant        entry                    external dcl 253 ref 1657
ipc_$drain_chn                  000056 constant        entry                    external dcl 255 ref 496
ipc_$read_ev_chn                000054 constant        entry                    external dcl 254 ref 1004
isp                             003042 automatic       pointer                  dcl 1-5 set ref 966* 967 973 974
istat                                  based           structure                level 1 dcl 1-7 set ref 973
j                               002311 automatic       fixed bin(17,0)          dcl 43 set ref 629* 630 630 780* 781 785 1246* 1253*
                                                                                  1491* 1492 1492*
l                                      parameter       fixed bin(17,0)          dcl 1567 in procedure "oct" ref 1565 1571 1571
l                                      parameter       fixed bin(17,0)          dcl 1628 in procedure "empty_list" ref 1626 1630
                                                                                  1630
lcf                       0(10)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1391
lcw                       0(09)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1390
length                                                 builtin function         dcl 295 ref 366 375 380 543 543
level                     0(15)        based           bit(3)                   level 2 in structure "imess" packed unaligned
                                                                                  dcl 1-21 in procedure "test_dcw" ref 956
level                     1     003046 automatic       fixed bin(3,0)           level 2 in structure "stat" dcl 205 in procedure
                                                                                  "test_dcw" set ref 959* 988 1049 1049 1050* 1065*
list                            002140 automatic       fixed bin(17,0)          initial dcl 34 set ref 34* 610* 610 610 623 627 630
                                                                                  630 633 633 635 636 636 746* 754* 781 782 782 785
                                                                                  785 798 922* 927 928* 928 928 933 933 937 937
                                                                                  1117* 1122* 1122* 1122 1122 1124* 1197 1488*
list_name                       002461 automatic       char(8)                  array unaligned dcl 76 in procedure "test_dcw" set
                                                                                  ref 304* 610 610* 744 796 796* 798* 928 928* 1096
                                                                                  1096* 1107 1108 1108* 1122 1122* 1459 1483* 1614
list_name               110            based           char(8)                  array level 2 in structure "save_seg" dcl 190
                                                                                  in procedure "test_dcw" set ref 1459* 1483
listnum                                parameter       fixed bin(17,0)          dcl 1131 ref 1129 1134 1138 1139 1146 1197
loaded                    0(08)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1389
lowt                      0(19)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1411
major                     0(02)        based           bit(4)                   level 2 packed unaligned dcl 2-7 set ref 1065*
make_sw                                parameter       bit(1)                   unaligned dcl 1503 ref 1501 1520
marg                      0(07)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1385
mask                      0(21)        based           bit(1)                   level 2 packed unaligned dcl 8-6 set ref 676* 678*
max                                                    builtin function         dcl 295 ref 636 782 826
max_time                        002452 automatic       fixed bin(71,0)          dcl 72 set ref 467* 526 807 807
max_work                        002454 automatic       fixed bin(19,0)          dcl 73 set ref 347* 467* 822*
mbot                      0(03)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1381
message                   2     003030 automatic       fixed bin(71,0)          level 2 dcl 176 set ref 954
min                                                    builtin function         dcl 295 ref 633 637
model                     6            based           fixed bin(17,0)          level 2 in structure "disk_info" dcl 4-19
                                                                                  in procedure "test_dcw" set ref 422*
model                     6            based           fixed bin(17,0)          level 2 in structure "tape_info" dcl 3-15
                                                                                  in procedure "test_dcw" set ref 404*
model                     6            based           fixed bin(17,0)          level 2 in structure "device_info" dcl 7-17
                                                                                  in procedure "test_dcw" set ref 453*
model                     6            based           fixed bin(17,0)          level 2 in structure "printer_info" dcl 5-17
                                                                                  in procedure "test_dcw" set ref 440*
my_device_info                  002776 automatic       structure                level 1 dcl 105 set ref 446
my_disk_info                    002745 automatic       structure                level 1 dcl 103 set ref 418
my_printer_info                 002765 automatic       structure                level 1 dcl 104 set ref 433
my_tape_info                    002715 automatic       structure                level 1 dcl 102 set ref 397
nbytes                          003022 automatic       fixed bin(17,0)          dcl 167 set ref 1245* 1246
new_line                        016060 constant        char(1)                  initial unaligned dcl 229 ref 548
new_name                        002562 automatic       char(8)                  unaligned dcl 77 set ref 756* 757* 761 792* 793* 794
                                                                                  796 798
new_work_size                   002576 automatic       fixed bin(18,0)          dcl 87 set ref 826* 827* 832
nsbot                     0(30)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1437
null                                                   builtin function         dcl 295 ref 86 188 504 1464 1475 1486 1522 1661 1663
                                                                                  1666 1668
octal_val                       002314 automatic       fixed bin(35,0)          dcl 46 set ref 647 665 711 716 721 730 1218 1222
                                                                                  1269 1279 1294 1302 1308 1333 1372 1554* 1582 1641
                                                                                  1641 1642
octal_word                      002313 automatic       bit(1)                   unaligned dcl 45 set ref 646 664 710 715 720 729
                                                                                  1217 1221 1268 1278 1293 1301 1307 1332 1371 1555*
                                                                                  1581 1640
out_temp                        002361 automatic       varying char(64)         dcl 51 set ref 609* 609* 610* 1339* 1340 1350* 1351
                                                                                  1357* 1358 1408* 1409 1422* 1423 1432* 1433 1443*
                                                                                  1444
output_line                     002320 automatic       varying char(128)        dcl 50 set ref 1060* 1061* 1135* 1140* 1149* 1152*
                                                                                  1152 1156* 1156 1160* 1160 1164* 1164 1167* 1167
                                                                                  1168* 1168 1169* 1169 1170* 1170 1174* 1176* 1176
                                                                                  1177* 1177 1178* 1178 1182* 1183* 1184* 1186* 1186
                                                                                  1189* 1189 1195* 1197* 1225* 1231* 1235* 1240*
                                                                                  1240 1249* 1251* 1254* 1254 1258* 1340* 1341* 1341
                                                                                  1342* 1342 1343* 1343 1344* 1344 1345* 1345 1346*
                                                                                  1346 1347* 1347 1348* 1348 1351* 1351 1353* 1353
                                                                                  1354* 1354 1355* 1355 1358* 1358 1361* 1377* 1378*
                                                                                  1378 1379* 1379 1380* 1380 1381* 1381 1382* 1382
                                                                                  1383* 1383 1384* 1384 1385* 1385 1386* 1388* 1389*
                                                                                  1389 1390* 1390 1391* 1391 1392* 1392 1393* 1393
                                                                                  1394* 1394 1395* 1395 1396* 1396 1397* 1399* 1400*
                                                                                  1400 1401* 1401 1402* 1402 1403* 1403 1404* 1404
                                                                                  1405* 1405 1406* 1406 1409* 1409 1411* 1411 1412*
                                                                                  1412 1413* 1413 1414* 1414 1415* 1415 1416* 1416
                                                                                  1417* 1417 1418* 1418 1419* 1419 1420* 1420 1423*
                                                                                  1423 1425* 1427* 1429* 1429 1430* 1430 1433* 1433
                                                                                  1435* 1435 1436* 1436 1437* 1437 1438* 1440* 1441*
                                                                                  1441 1442* 1442 1444* 1444 1445* 1571* 1571
parse_io_channel_name_          000126 constant        entry                    external dcl 276 ref 852
pcw                                    based           structure                level 1 dcl 8-6
pcw_list                 10            based           bit(36)                  array level 2 in structure "save_seg" dcl 190
                                                                                  in procedure "test_dcw" set ref 1457* 1481
pcw_list                        002100 automatic       bit(36)                  array unaligned dcl 33 in procedure "test_dcw" set
                                                                                  ref 302* 623* 937 937* 1138 1139 1457 1481* 1490
                                                                                  1490 1630
pcw_sw                          002402 automatic       bit(1)                   unaligned dcl 52 set ref 557* 623 677 695* 735*
pcwp                            003074 automatic       pointer                  dcl 8-4 set ref 305* 676 678 679
position_index           24            based           fixed bin(35,0)          level 2 dcl 3-15 set ref 413*
print_train               7            based           fixed bin(17,0)          level 2 dcl 5-17 set ref 441*
printer_info                           based           structure                level 1 dcl 5-17
printer_info_ptr                003070 automatic       pointer                  dcl 5-15 set ref 433* 434 435 436 437 438 439 440
                                                                                  441 442 488
priv_sw                         002441 automatic       bit(1)                   initial unaligned dcl 66 set ref 66* 329* 459
program_interrupt               003114 stack reference condition                dcl 297 ref 534
prompt_msg                      002444 automatic       varying char(10)         initial dcl 69 set ref 69* 542 542* 838* 839*
prt_status_table_$prt_status_table_
                                000140 external static fixed bin(17,0)          dcl 285 set ref 500
ptr_array                       002574 automatic       pointer                  initial array dcl 86 set ref 86* 341* 346 1661 1662*
                                                                                  1663*
rawerr                    0(02)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1380
rcp_$attach                     000072 constant        entry                    external dcl 261 ref 461
rcp_$check_attach               000074 constant        entry                    external dcl 262 ref 467
rcp_$detach                     000076 constant        entry                    external dcl 264 ref 1652
rcp_id                          002450 automatic       bit(36)                  initial dcl 70 set ref 70* 459* 461* 467* 1651 1652*
                                                                                  1653*
rcp_info_ptr                    002456 automatic       pointer                  dcl 74 set ref 414* 429* 442* 454* 459* 461* 467*
rcp_priv_$attach                000100 constant        entry                    external dcl 265 ref 459
rcp_state                       002451 automatic       fixed bin(17,0)          dcl 71 set ref 467* 468 469 470
rel                       0(35)        based           bit(1)                   level 2 packed unaligned dcl 9-14 set ref 652* 1178
release_temp_segments_          000104 constant        entry                    external dcl 267 ref 1662
res                       0(34)        based           bit(1)                   level 2 packed unaligned dcl 9-14 set ref 651* 1177
rewind                    0(11)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1392
run                       0(02) 003046 automatic       bit(1)                   level 3 packed unaligned dcl 205 set ref 996
save_seg                               based           structure                level 1 dcl 190
save_seg_code                   000100 constant        char(16)                 initial unaligned dcl 199 ref 1455 1472
save_segp                       003040 automatic       pointer                  initial dcl 188 set ref 188* 1454 1455 1456 1457
                                                                                  1458 1459 1460 1463* 1464* 1472 1472 1474* 1475*
                                                                                  1479 1481 1482 1483 1484 1485* 1486* 1520* 1521*
                                                                                  1522 1666 1667* 1668*
save_status_mode                002703 automatic       fixed bin(17,0)          dcl 95 set ref 1016* 1022
something_printed               002565 automatic       bit(1)                   unaligned dcl 79 set ref 1093* 1098* 1101 1105*
                                                                                  1110* 1113
spec_status                     002706 automatic       bit(36)                  dcl 98 set ref 880* 883*
speed                    11            based           bit(36)                  level 2 in structure "tape_info" dcl 3-15
                                                                                  in procedure "test_dcw" set ref 408*
speed                     0(24)        based           bit(5)                   level 2 in structure "dt_stat" packed unaligned
                                                                                  dcl 111 in procedure "test_dcw" set ref 1428 1432*
speed_constant                  000104 constant        varying char(5)          initial array dcl 144 ref 1430
spr                       0(13)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1394
sqptr                           003056 automatic       pointer                  dcl 207 set ref 521* 522 966
st                              003046 automatic       bit(1)                   level 3 in structure "stat" packed unaligned dcl 205
                                                                                  in procedure "test_dcw" set ref 523* 961* 1039
st                                     based           bit(1)                   level 3 in structure "istat" packed unaligned
                                                                                  dcl 1-7 in procedure "test_dcw" set ref 967 974*
st                                     based           bit(1)                   array level 3 in structure "status_queue" packed
                                                                                  unaligned dcl 206 in procedure "test_dcw" set ref
                                                                                  522*
standby                   0(06)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1384
stat                            003046 automatic       structure                level 1 dcl 205 set ref 958* 973* 1045
stat_found                      002705 automatic       bit(1)                   dcl 97 set ref 880* 882 888* 890
statp                           003062 automatic       pointer                  dcl 2-5 set ref 984*
status                    1            based           bit(36)                  level 2 in structure "imess" packed unaligned
                                                                                  dcl 1-21 in procedure "test_dcw" ref 960
status                                 based           structure                level 1 dcl 2-7 in procedure "test_dcw"
status_index                    003060 automatic       fixed bin(17,0)          dcl 208 set ref 524* 966 975* 975 976 976*
status_mode                     002702 automatic       fixed bin(17,0)          initial dcl 94 set ref 94* 1016 1019* 1022* 1029*
                                                                                  1044 1059 1077* 1078* 1079*
status_queue                           based           structure                array level 1 dcl 206 set ref 966
status_tablep                   002700 automatic       pointer                  dcl 93 set ref 498* 499* 500* 501* 502* 503* 504*
                                                                                  1060*
string                                                 builtin function         dcl 295 ref 1338
sub                       0(06)        based           bit(6)                   level 2 packed unaligned dcl 2-7 set ref 1065*
substr                                                 builtin function         dcl 295 set ref 320 367 369 371 373 375 378 380 492
                                                                                  498 499 500 501 502 503 548 674* 675* 1050 1050
                                                                                  1065 1065 1065 1065 1169 1170 1195 1195 1195 1195
                                                                                  1197 1197 1197 1197 1231 1240 1254 1540 1549 1551
                                                                                  1571
suffixed_name_$make             000112 constant        entry                    external dcl 270 ref 1515
survey_ptr                      002416 automatic       pointer                  dcl 61 set ref 1336* 1338 1339 1339 1341 1342 1343
                                                                                  1344 1346 1347 1348 1350 1353 1354 1355 1357
survey_table                           based           structure                array level 1 packed unaligned dcl 147 set ref 1338
sys_info$max_seg_size           000132 external static fixed bin(18,0)          dcl 281 ref 347
sys_sw                          002460 automatic       bit(1)                   initial unaligned dcl 75 set ref 75* 332* 401 423
                                                                                  437 450
system_flag               3            based           bit(1)                   level 2 in structure "disk_info" dcl 4-19
                                                                                  in procedure "test_dcw" set ref 423*
system_flag               3            based           bit(1)                   level 2 in structure "printer_info" dcl 5-17
                                                                                  in procedure "test_dcw" set ref 437*
system_flag               3            based           bit(1)                   level 2 in structure "device_info" dcl 7-17
                                                                                  in procedure "test_dcw" set ref 450*
system_flag               3            based           bit(1)                   level 2 in structure "tape_info" dcl 3-15
                                                                                  in procedure "test_dcw" set ref 401*
tab                                    constant        char(1)                  initial unaligned dcl 231 ref 1541 1550
tally                     0(24)        based           bit(12)                  level 2 packed unaligned dcl 9-7 set ref 716* 1187
                                                                                  1187
tape_info                              based           structure                level 1 dcl 3-15
tape_info_ptr                   003064 automatic       pointer                  dcl 3-10 set ref 397* 398 399 400 401 402 403 404
                                                                                  405 406 407 408 409 410 411 412 413 414 487
tape_info_version_2                    constant        fixed bin(17,0)          initial dcl 3-12 ref 398
tape_status_table_$tape_status_table_
                                000136 external static fixed bin(17,0)          dcl 284 set ref 499
tdcw                                   based           structure                level 1 dcl 9-14
tdcwp                           003102 automatic       pointer                  dcl 9-4 set ref 305* 643 647 650 651 652 1173 1175
                                                                                  1175 1176 1177 1178
temp_char                       002307 automatic       char(1)                  unaligned dcl 42 set ref 1540* 1541 1541 1549* 1550
                                                                                  1550
time                      6            based           fixed bin(71,0)          level 2 dcl 190 set ref 1456* 1479*
time_limit                      002420 automatic       fixed bin(52,0)          dcl 62 set ref 526* 527* 528 528 806 806 811* 812*
time_out                  0(03) 003046 automatic       bit(1)                   level 3 packed unaligned dcl 205 set ref 979 1054
time_string                     002672 automatic       char(24)                 unaligned dcl 92 set ref 1479* 1480*
track                     0(29)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1435
track_sw                        002566 automatic       bit(1)                   initial dcl 80 set ref 80* 331* 405
tracks                    7            based           fixed bin(17,0)          level 2 dcl 3-15 set ref 405* 406*
type                      0(22)        based           bit(2)                   level 2 in structure "dcw" packed unaligned dcl 9-7
                                                                                  in procedure "test_dcw" set ref 700* 703* 706*
                                                                                  1182 1183
type                      0(22)        based           bit(2)                   level 2 in structure "tdcw" packed unaligned
                                                                                  dcl 9-14 in procedure "test_dcw" set ref 643* 1173
unspec                                                 builtin function         dcl 295 set ref 730 958* 1279 1308
unsuffixed_ename                002652 automatic       char(32)                 unaligned dcl 90 set ref 1510* 1515* 1517*
unused_qualifier         12            based           bit(36)                  level 2 dcl 3-15 set ref 409*
usage_time                1            based           fixed bin(17,0)          level 2 in structure "disk_info" dcl 4-19
                                                                                  in procedure "test_dcw" set ref 420*
usage_time                1            based           fixed bin(17,0)          level 2 in structure "printer_info" dcl 5-17
                                                                                  in procedure "test_dcw" set ref 435*
usage_time                1            based           fixed bin(17,0)          level 2 in structure "tape_info" dcl 3-15
                                                                                  in procedure "test_dcw" set ref 399*
usage_time                1            based           fixed bin(17,0)          level 2 in structure "device_info" dcl 7-17
                                                                                  in procedure "test_dcw" set ref 448*
val                                    parameter       fixed bin(35,0)          dcl 1568 set ref 1565 1570*
version                                based           fixed bin(17,0)          level 2 dcl 190 set ref 1454* 1472
version_num                            based           fixed bin(17,0)          level 2 in structure "device_info" dcl 7-17
                                                                                  in procedure "test_dcw" set ref 447*
version_num                            based           fixed bin(17,0)          level 2 in structure "disk_info" dcl 4-19
                                                                                  in procedure "test_dcw" set ref 419*
version_num                            based           fixed bin(17,0)          level 2 in structure "printer_info" dcl 5-17
                                                                                  in procedure "test_dcw" set ref 434*
version_num                            based           fixed bin(17,0)          level 2 in structure "tape_info" dcl 3-15
                                                                                  in procedure "test_dcw" set ref 398*
volume_name              13            based           char(32)                 level 2 in structure "tape_info" dcl 3-15
                                                                                  in procedure "test_dcw" set ref 410* 411*
volume_name               7            based           char(32)                 level 2 in structure "disk_info" dcl 4-19
                                                                                  in procedure "test_dcw" set ref 426* 427*
wait_time                 2            based           fixed bin(17,0)          level 2 in structure "printer_info" dcl 5-17
                                                                                  in procedure "test_dcw" set ref 436*
wait_time                 2            based           fixed bin(17,0)          level 2 in structure "disk_info" dcl 4-19
                                                                                  in procedure "test_dcw" set ref 421*
wait_time                 2            based           fixed bin(17,0)          level 2 in structure "tape_info" dcl 3-15
                                                                                  in procedure "test_dcw" set ref 400*
wait_time                 2            based           fixed bin(17,0)          level 2 in structure "device_info" dcl 7-17
                                                                                  in procedure "test_dcw" set ref 449*
word                            002245 automatic       char(132)                unaligned dcl 40 set ref 467* 471 471* 482* 561 562
                                                                                  563 564 565 566 567 568 569 570 570 571 571 572
                                                                                  573 573 574 574 575 575 576 576 576 577 577 578
                                                                                  579 580 581 581 582 582 583 584 585 586 587 588
                                                                                  589 590 591 592 593 594 595 596 597 597 598 598
                                                                                  599 599 600 600 604 608 615* 650 651 652 669 670
                                                                                  671 672 673 674 675 676 677 742 757 793 839 852*
                                                                                  854* 1077 1077 1078 1078 1079 1079 1081* 1092 1104
                                                                                  1194* 1195 1195 1195 1195 1197 1197 1197 1197
                                                                                  1230* 1231 1239* 1240 1253* 1254 1510* 1512* 1551*
                                                                                  1554* 1556* 1570* 1571 1614 1619*
work_seg                               based           bit(36)                  array dcl 162 set ref 521 933* 934* 1239* 1244 1279*
                                                                                  1308* 1321* 1321 1336 1375
work_size                       003016 automatic       fixed bin(18,0)          initial dcl 161 set ref 161* 508* 510* 821* 832*
workp                           003014 automatic       pointer                  dcl 160 set ref 346* 508* 521 827* 933 934 1239 1244
                                                                                  1279 1308 1321 1321 1336 1375
wpr                       0(12)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 1393
write_flag               23            based           bit(1)                   level 2 in structure "tape_info" dcl 3-15
                                                                                  in procedure "test_dcw" set ref 412*
write_flag               17            based           bit(1)                   level 2 in structure "disk_info" dcl 4-19
                                                                                  in procedure "test_dcw" set ref 428*
write_sw                        002442 automatic       bit(1)                   initial unaligned dcl 67 set ref 67* 330* 412 428

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CONSOLE_DTYPEX                         internal static fixed bin(17,0)          initial dcl 6-31
DISK_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 6-38
MCA_DTYPEX                             internal static fixed bin(17,0)          initial dcl 6-36
NUM_QUALIFIERS                         internal static fixed bin(17,0)          initial array dcl 6-22
TAPE_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 6-37
VOLUME_TYPE                            internal static char(32)                 initial array unaligned dcl 6-25
faultword                              based           structure                level 1 dcl 2-27
special_status                         based           structure                level 1 dcl 2-35
tape_info_version_3                    internal static fixed bin(17,0)          initial dcl 3-13

NAMES DECLARED BY EXPLICIT CONTEXT.
arg_err                         002046 constant        label                    dcl 325 ref 336
b_idcw                          005220 constant        label                    dcl 660 ref 565 691 696
b_idcw1                         005242 constant        label                    dcl 669 ref 684
b_idcw2                         005374 constant        label                    dcl 683 ref 666
b_iodcw                         005424 constant        label                    dcl 708 ref 701 704
b_iontp                         005422 constant        label                    dcl 706 ref 563
b_iotd                          005412 constant        label                    dcl 700 ref 564
b_iotp                          005415 constant        label                    dcl 703 ref 562
b_nidcw                         005400 constant        label                    dcl 689 ref 566
b_oct                           005470 constant        label                    dcl 727 ref 568 736
b_opcw                          005500 constant        label                    dcl 735 ref 569
b_pcw                           005407 constant        label                    dcl 695 ref 567
b_tdcw                          005150 constant        label                    dcl 643 ref 561
b_tdcw1                         005170 constant        label                    dcl 650 ref 656
b_tdcw2                         005214 constant        label                    dcl 654 ref 648
begin                           003523 constant        label                    dcl 486 ref 469
bit6                            015415 constant        entry                    internal dcl 1577 ref 669 670 671 672
block                           007124 constant        label                    dcl 944 ref 582 996 997
check_list_num                  015470 constant        entry                    internal dcl 1605 ref 753 1116
check_status_mode               013722 constant        entry                    internal dcl 1075 ref 1020 1030
clean_up                        015626 constant        entry                    internal dcl 1649 ref 307 618
debug_check                     015437 constant        entry                    internal dcl 1589 ref 803 818 844 864 871 878 886
                                                                                  919 944 1003
delete                          005636 constant        label                    dcl 778 ref 576
delete1                         005641 constant        label                    dcl 780 ref 787
dev_err                         003260 constant        label                    dcl 463 ref 468
dp_join                         010045 constant        label                    dcl 1212 ref 1209
dp_nl                           010107 constant        label                    dcl 1229 ref 1237
dump                            010044 constant        label                    dcl 1211 ref 583
dump_dtstat                     011402 constant        label                    dcl 1368 ref 587
dump_go                         010071 constant        label                    dcl 1224 ref 1216 1220
dump_survey                     010700 constant        label                    dcl 1329 ref 586
dumpb                           010041 constant        label                    dcl 1208 ref 584
edit                            005503 constant        label                    dcl 740 ref 571
edit1                           005606 constant        label                    dcl 755 ref 747
empty_list                      015566 constant        entry                    internal dcl 1626 ref 744 1095 1107 1108 1108 1122
ex_join                         006732 constant        label                    dcl 917 ref 903 908
exec_rept                       006726 constant        label                    dcl 914 ref 579
exec_rept_no_err                006723 constant        label                    dcl 910 ref 580
exec_spec                       006716 constant        label                    dcl 905 ref 578
execute                         006712 constant        label                    dcl 900 ref 577
get_dcw_num                     015605 constant        entry                    internal dcl 1636 ref 766 772 778
get_detailed_status             006572 constant        label                    dcl 886 ref 600
get_list_num                    015460 constant        entry                    internal dcl 1600 ref 920
get_special_status              006473 constant        label                    dcl 878 ref 599
get_stat                        007337 constant        label                    dcl 1003 ref 537 581 957 968 977
gstat                           007202 constant        label                    dcl 954 ref 1010
insert                          005632 constant        label                    dcl 772 ref 573
next                            004235 constant        label                    dcl 542 ref 535 546 555 606 612 616 639 751 762 768
                                                                                  774 783 799 808 814 823 830 833 840 849 855 860
                                                                                  867 874 884 896 929 941 949 963 970 981 999 1008
                                                                                  1012 1023 1031 1082 1102 1114 1125 1259 1266 1274
                                                                                  1283 1291 1299 1316 1325 1364 1447 1465 1476 1496
                                                                                  1508 1513 1518 1524 1594 1609 1620
next_word                       015222 constant        entry                    internal dcl 1533 ref 554 644 654 662 683 708 713
                                                                                  718 727 740 755 791 804 819 837 845 1018 1027 1090
                                                                                  1215 1219 1263 1271 1281 1287 1296 1305 1311 1330
                                                                                  1369 1505 1579 1603 1638
nw_found                        015263 constant        label                    dcl 1551 ref 1548
nw_loop                         015224 constant        label                    dcl 1536 ref 1543
nw_scan                         015246 constant        label                    dcl 1547 ref 1550
oct                             015343 constant        entry                    internal dcl 1565 ref 1150 1153 1157 1161 1165 1175
                                                                                  1185 1187 1190
patch                           010453 constant        label                    dcl 1263 ref 585
pr_stat                         007303 constant        label                    dcl 994 ref 988 989
print                           007506 constant        label                    dcl 1090 ref 570
print_pcw                       014062 constant        label                    dcl 1150 ref 1141
print_status                    013453 constant        entry                    internal dcl 1035 ref 962 969 980 994 1021
print_subr                      014011 constant        entry                    internal dcl 1129 ref 1097 1124
quit                            005054 constant        label                    dcl 618 ref 318 326 344 393 464 477 483 511 519 575
rcp_loop                        003310 constant        label                    dcl 467 ref 479
ready                           004205 constant        label                    dcl 534 ref 349
rel_dev                         006441 constant        label                    dcl 871 ref 592
repeat                          006727 constant        label                    dcl 915 ref 912
reprint_status                  007443 constant        label                    dcl 1016 ref 597
restore_segment                 013207 constant        label                    dcl 1469 ref 596
save_seg_util                   014654 constant        entry                    internal dcl 1501 ref 1451 1469
save_segment                    013022 constant        label                    dcl 1451 ref 595
set_chan                        006230 constant        label                    dcl 844 ref 590
set_name                        005671 constant        label                    dcl 791 ref 572
set_name2                       005702 constant        label                    dcl 794 ref 761
set_pattern                     010540 constant        label                    dcl 1287 ref 594
set_prompt                      006206 constant        label                    dcl 837 ref 593
set_time                        005736 constant        label                    dcl 803 ref 588
set_work                        006060 constant        label                    dcl 818 ref 589
status_command                  007460 constant        label                    dcl 1027 ref 598
std_err                         005032 constant        label                    dcl 615 ref 652 677 710 715 720 729 810 825 1217
                                                                                  1221 1268 1278 1293 1301 1307 1332 1371 1581 1640
                                                                                  1641
store                           005061 constant        label                    dcl 623 ref 645 655 663 685 709 714 719 723 728 731
                                                                                  1580
susp_dev                        006407 constant        label                    dcl 864 ref 591
test_dcw                        001537 constant        entry                    external dcl 28
update                          005627 constant        label                    dcl 766 ref 574
xagain                          007036 constant        label                    dcl 937 ref 987 991

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     16734       17110   16115       16744
Length     17664   16115       154         540     617           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
test_dcw                           2281 external procedure  is an external procedure.  
on unit on line 307                  64 on unit               
on unit on line 534                  64 on unit               
print_status                            internal procedure  shares stack frame of external procedure test_dcw.  
check_status_mode                       internal procedure  shares stack frame of external procedure test_dcw.  
print_subr                              internal procedure  shares stack frame of external procedure test_dcw.  
save_seg_util                           internal procedure  shares stack frame of external procedure test_dcw.  
next_word                               internal procedure  shares stack frame of external procedure test_dcw.  
oct                                     internal procedure  shares stack frame of external procedure test_dcw.  
bit6                                    internal procedure  shares stack frame of external procedure test_dcw.  
debug_check                             internal procedure  shares stack frame of external procedure test_dcw.  
get_list_num                            internal procedure  shares stack frame of external procedure test_dcw.  
empty_list                              internal procedure  shares stack frame of external procedure test_dcw.  
get_dcw_num                             internal procedure  shares stack frame of external procedure test_dcw.  
clean_up                             90 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
test_dcw                 000100 dcw_list                    test_dcw
                         002100 pcw_list                    test_dcw
                         002140 list                        test_dcw
                         002141 idx                         test_dcw
                         002142 dcw_len                     test_dcw
                         002202 input_line                  test_dcw
                         002243 input_len                   test_dcw
                         002244 input_pos                   test_dcw
                         002245 word                        test_dcw
                         002306 code                        test_dcw
                         002307 temp_char                   test_dcw
                         002310 i                           test_dcw
                         002311 j                           test_dcw
                         002312 end_line                    test_dcw
                         002313 octal_word                  test_dcw
                         002314 octal_val                   test_dcw
                         002315 dec_word                    test_dcw
                         002316 dec_val                     test_dcw
                         002317 insert_mode                 test_dcw
                         002320 output_line                 test_dcw
                         002361 out_temp                    test_dcw
                         002402 pcw_sw                      test_dcw
                         002403 devx                        test_dcw
                         002404 exec_rept_cnt               test_dcw
                         002405 dp_loc                      test_dcw
                         002406 dp_len                      test_dcw
                         002407 dp_rpt                      test_dcw
                         002410 dp_byte                     test_dcw
                         002411 arg_cnt                     test_dcw
                         002412 arg_ptr                     test_dcw
                         002414 arg_len                     test_dcw
                         002416 survey_ptr                  test_dcw
                         002420 time_limit                  test_dcw
                         002422 dev_name                    test_dcw
                         002427 dev_type                    test_dcw
                         002434 id_name                     test_dcw
                         002441 priv_sw                     test_dcw
                         002442 write_sw                    test_dcw
                         002443 debug_sw                    test_dcw
                         002444 prompt_msg                  test_dcw
                         002450 rcp_id                      test_dcw
                         002451 rcp_state                   test_dcw
                         002452 max_time                    test_dcw
                         002454 max_work                    test_dcw
                         002456 rcp_info_ptr                test_dcw
                         002460 sys_sw                      test_dcw
                         002461 list_name                   test_dcw
                         002562 new_name                    test_dcw
                         002564 dcw_word                    test_dcw
                         002565 something_printed           test_dcw
                         002566 track_sw                    test_dcw
                         002567 exec_spec_sw                test_dcw
                         002570 exec_no_err_sw              test_dcw
                         002571 exec_rept_sw                test_dcw
                         002572 iom                         test_dcw
                         002573 chan                        test_dcw
                         002574 ptr_array                   test_dcw
                         002576 new_work_size               test_dcw
                         002577 flush_sw                    test_dcw
                         002600 dir                         test_dcw
                         002652 unsuffixed_ename            test_dcw
                         002662 ename                       test_dcw
                         002672 time_string                 test_dcw
                         002700 status_tablep               test_dcw
                         002702 status_mode                 test_dcw
                         002703 save_status_mode            test_dcw
                         002704 default_device              test_dcw
                         002705 stat_found                  test_dcw
                         002706 spec_status                 test_dcw
                         002707 detailed_status             test_dcw
                         002715 my_tape_info                test_dcw
                         002745 my_disk_info                test_dcw
                         002765 my_printer_info             test_dcw
                         002776 my_device_info              test_dcw
                         003012 dtstp                       test_dcw
                         003014 workp                       test_dcw
                         003016 work_size                   test_dcw
                         003020 byte_ptr                    test_dcw
                         003022 nbytes                      test_dcw
                         003024 event_list                  test_dcw
                         003030 event_info                  test_dcw
                         003040 save_segp                   test_dcw
                         003042 isp                         test_dcw
                         003044 imp                         test_dcw
                         003046 stat                        test_dcw
                         003056 sqptr                       test_dcw
                         003060 status_index                test_dcw
                         003062 statp                       test_dcw
                         003064 tape_info_ptr               test_dcw
                         003066 disk_info_ptr               test_dcw
                         003070 printer_info_ptr            test_dcw
                         003072 device_info_ptr             test_dcw
                         003074 pcwp                        test_dcw
                         003076 idcwp                       test_dcw
                         003100 dcwp                        test_dcw
                         003102 tdcwp                       test_dcw
                         003104 cmd_name                    test_dcw
                         003154 i                           print_subr

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return              tra_ext             enable              shorten_stack
ext_entry           int_entry           any_to_any_tr       divide_fx3          clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_bit_count_             analyze_device_stat_$rsnnl    com_err_                      convert_ipc_code_
cu_$arg_count                 cu_$arg_ptr                   cv_dec_check_                 cv_oct_check_
date_time_                    expand_pathname_              get_temp_segments_            hcs_$initiate
hcs_$make_seg                 hcs_$terminate_noname         ioa_                          ioa_$nnl
ioa_$rsnnl                    ioi_$connect                  ioi_$connect_pcw              ioi_$get_detailed_status
ioi_$get_special_status       ioi_$release_devices          ioi_$set_channel_required     ioi_$set_status
ioi_$suspend_devices          ioi_$timeout                  ioi_$workspace                iox_$get_line
ipc_$block                    ipc_$create_ev_chn            ipc_$delete_ev_chn            ipc_$drain_chn
ipc_$read_ev_chn              parse_io_channel_name_        rcp_$attach                   rcp_$check_attach
rcp_$detach                   rcp_priv_$attach              release_temp_segments_        suffixed_name_$make

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cpz_status_table_$cpz_status_table_                         crz_status_table_$crz_status_table_
disk_status_table_$disk_status_table_                       error_table_$badopt
error_table_$request_not_recognized                         imp_status_table_$imp_status_table_
iox_$user_input               prt_status_table_$prt_status_table_                         sys_info$max_seg_size
tape_status_table_$tape_status_table_




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     28 001536        34 001544        35 001546        49 001547        53 001550        66 001552        67 001553
     68 001555        69 001556        70 001557        75 001560        80 001561        86 001562        94 001571
    161 001573       172 001575       188 001601       232 001603       301 001605       302 001626       303 001636
    304 001646       305 001662       307 001670       311 001712       312 001721       313 001722       314 001723
    315 001733       316 001750       317 001752       318 002001       320 002002       321 002007       322 002025
    324 002043       325 002046       326 002100       328 002101       329 002102       330 002112       331 002120
    332 002133       333 002142       335 002155       336 002160       338 002161       339 002163       340 002174
    341 002176       342 002217       343 002221       344 002245       346 002246       347 002250       348 002253
    349 002254       354 002255       356 002304       358 002326       360 002350       362 002402       364 002434
    366 002466       367 002471       369 002504       371 002514       373 002524       374 002526       375 002534
    377 002554       378 002555       379 002557       380 002564       382 002604       383 002605       384 002615
    385 002616       389 002626       390 002637       391 002641       392 002650       393 002674       396 002675
    397 002705       398 002707       399 002711       400 002712       401 002713       402 002715       403 002726
    404 002732       405 002733       406 002740       407 002742       408 002743       409 002744       410 002745
    411 002756       412 002762       413 002764       414 002765       415 002766       417 002767       418 002777
    419 003001       420 003003       421 003004       422 003005       423 003006       424 003010       425 003021
    426 003025       427 003036       428 003042       429 003044       430 003045       432 003046       433 003056
    434 003060       435 003062       436 003063       437 003064       438 003066       439 003077       440 003103
    441 003104       442 003105       443 003106       446 003107       447 003111       448 003113       449 003114
    450 003115       451 003117       452 003131       453 003135       454 003136       459 003137       461 003207
    462 003255       463 003260       464 003307       467 003310       468 003354       469 003357       470 003361
    471 003363       473 003413       474 003432       475 003434       476 003443       477 003467       479 003470
    482 003471       483 003522       486 003523       487 003542       488 003561       489 003600       490 003607
    492 003632       493 003671       494 003702       496 003704       498 003715       499 003726       500 003734
    501 003742       502 003750       503 003756       504 003764       508 003766       509 004003       510 004005
    511 004035       516 004036       517 004057       518 004061       519 004105       521 004106       522 004111
    523 004125       524 004127       526 004131       527 004133       528 004146       534 004205       535 004221
    536 004227       537 004232       542 004235       543 004261       544 004304       545 004306       546 004335
    548 004336       550 004346       554 004350       555 004351       556 004353       557 004354       558 004355
    559 004360       561 004361       562 004365       563 004371       564 004375       565 004401       566 004405
    567 004411       568 004415       569 004421       570 004425       571 004435       572 004445       573 004451
    574 004461       575 004471       576 004501       577 004515       578 004525       579 004531       580 004535
    581 004541       582 004551       583 004561       584 004565       585 004571       586 004575       587 004601
    588 004605       589 004611       590 004615       591 004621       592 004625       593 004631       594 004635
    595 004641       596 004645       597 004651       598 004661       599 004671       600 004701       604 004711
    605 004715       606 004734       608 004735       609 004741       609 004750       610 004754       612 005031
    615 005032       616 005053       618 005054       619 005060       623 005061       626 005067       627 005071
    628 005074       629 005077       630 005101       631 005114       632 005116       633 005117       635 005126
    636 005133       637 005141       639 005147       643 005150       644 005154       645 005155       646 005157
    647 005161       648 005167       650 005170       651 005177       652 005206       654 005214       655 005215
    656 005217       660 005220       661 005222       662 005226       663 005227       664 005231       665 005233
    666 005241       669 005242       670 005257       671 005274       672 005311       673 005326       674 005335
    675 005344       676 005353       677 005362       678 005370       679 005372       683 005374       684 005375
    685 005377       689 005400       690 005403       691 005406       695 005407       696 005411       700 005412
    701 005414       703 005415       704 005421       706 005422       708 005424       709 005425       710 005427
    711 005431       713 005437       714 005440       715 005442       716 005444       718 005452       719 005453
    720 005455       721 005457       723 005467       727 005470       728 005471       729 005473       730 005475
    731 005477       735 005500       736 005502       740 005503       741 005504       742 005506       743 005512
    744 005517       745 005537       746 005560       747 005562       749 005563       750 005565       751 005602
    753 005603       754 005604       755 005606       756 005607       757 005614       759 005617       760 005621
    761 005622       762 005626       766 005627       767 005630       768 005631       772 005632       773 005633
    774 005635       778 005636       779 005637       780 005641       781 005644       782 005647       783 005655
    785 005656       786 005667       787 005670       791 005671       792 005672       793 005677       794 005702
    796 005713       797 005725       798 005727       799 005735       803 005736       804 005737       805 005740
    806 005742       807 005772       808 006017       810 006020       811 006022       812 006025       813 006040
    814 006057       818 006060       819 006061       820 006062       821 006064       822 006107       823 006127
    825 006130       826 006132       827 006137       828 006154       829 006156       830 006202       832 006203
    833 006205       837 006206       838 006207       839 006213       840 006227       844 006230       845 006231
    846 006232       847 006234       848 006253       849 006272       852 006273       853 006320       854 006322
    855 006351       858 006352       859 006367       860 006406       864 006407       865 006410       866 006421
    867 006440       871 006441       872 006442       873 006453       874 006472       878 006473       880 006474
    881 006511       882 006531       883 006551       884 006571       886 006572       888 006573       889 006610
    890 006630       892 006650       893 006662       894 006665       896 006711       900 006712       901 006713
    902 006714       903 006715       905 006716       906 006720       907 006721       908 006722       910 006723
    912 006725       914 006726       915 006727       916 006730       917 006732       919 006733       920 006734
    921 006735       922 006737       923 006740       924 006742       927 006743       928 006746       929 007010
    932 007011       933 007017       934 007032       935 007034       937 007036       938 007060       939 007074
    940 007076       941 007123       944 007124       945 007125       946 007144       947 007146       948 007155
    949 007201       954 007202       956 007204       957 007211       958 007213       959 007216       960 007220
    961 007223       962 007225       963 007226       966 007227       967 007234       968 007237       969 007241
    970 007242       973 007243       974 007246       975 007250       976 007251       977 007256       979 007260
    980 007263       981 007264       984 007265       986 007267       987 007271       988 007273       989 007276
    990 007301       991 007302       994 007303       996 007304       997 007307       998 007311       999 007336
   1003 007337      1004 007340      1005 007357      1006 007361      1007 007370      1008 007417      1010 007420
   1011 007422      1012 007442      1016 007443      1018 007445      1019 007446      1020 007453      1021 007454
   1022 007455      1023 007457      1027 007460      1029 007461      1030 007504      1031 007505      1090 007506
   1091 007507      1092 007511      1093 007515      1094 007516      1095 007523      1096 007530      1097 007575
   1098 007577      1100 007601      1101 007603      1102 007621      1104 007622      1105 007626      1106 007627
   1107 007635      1108 007656      1110 007727      1112 007731      1113 007733      1114 007754      1116 007755
   1117 007756      1118 007760      1119 007762      1122 007763      1124 010036      1125 010040      1208 010041
   1209 010043      1211 010044      1212 010045      1213 010047      1215 010051      1216 010052      1217 010054
   1218 010056      1219 010062      1220 010063      1221 010065      1222 010067      1224 010071      1225 010072
   1227 010073      1229 010107      1230 010111      1231 010144      1233 010152      1234 010153      1235 010156
   1236 010175      1237 010176      1239 010177      1240 010233      1241 010266      1244 010272      1245 010276
   1246 010300      1247 010307      1248 010310      1249 010313      1250 010332      1251 010334      1253 010335
   1254 010375      1255 010430      1258 010433      1259 010452      1263 010453      1264 010454      1265 010456
   1266 010473      1268 010474      1269 010476      1271 010502      1272 010503      1273 010505      1274 010522
   1277 010523      1278 010526      1279 010530      1280 010534      1281 010535      1282 010536      1283 010537
   1287 010540      1289 010541      1290 010543      1291 010560      1293 010561      1294 010563      1296 010567
   1297 010570      1298 010572      1299 010607      1301 010610      1302 010612      1304 010614      1305 010615
   1306 010616      1307 010620      1308 010622      1309 010626      1310 010627      1311 010630      1312 010631
   1314 010632      1315 010634      1316 010647      1319 010650      1320 010654      1321 010663      1322 010671
   1323 010672      1324 010674      1325 010677      1329 010700      1330 010702      1331 010703      1332 010705
   1333 010707      1336 010713      1338 010717      1339 010733      1340 010775      1341 011002      1342 011024
   1343 011043      1344 011061      1345 011100      1346 011112      1347 011133      1348 011150      1350 011165
   1351 011221      1353 011233      1354 011257      1355 011274      1357 011311      1358 011346      1361 011360
   1362 011377      1364 011401      1368 011402      1369 011404      1370 011405      1371 011407      1372 011411
   1375 011415      1377 011421      1378 011426      1379 011443      1380 011460      1381 011475      1382 011512
   1383 011527      1384 011544      1385 011561      1386 011576      1388 011615      1389 011622      1390 011637
   1391 011654      1392 011671      1393 011706      1394 011723      1395 011740      1396 011755      1397 011772
   1399 012011      1400 012016      1401 012030      1402 012050      1403 012065      1404 012102      1405 012117
   1406 012134      1408 012151      1409 012203      1411 012215      1412 012232      1413 012244      1414 012264
   1415 012301      1416 012316      1417 012333      1418 012350      1419 012365      1420 012402      1422 012417
   1423 012451      1425 012463      1427 012502      1428 012507      1429 012513      1430 012525      1432 012546
   1433 012600      1435 012612      1436 012630      1437 012642      1438 012657      1440 012676      1441 012703
   1442 012720      1443 012732      1444 012770      1445 013002      1447 013021      1451 013022      1454 013026
   1455 013030      1456 013037      1457 013042      1458 013054      1459 013057      1460 013076      1461 013120
   1462 013142      1463 013173      1464 013204      1465 013206      1469 013207      1472 013213      1473 013223
   1474 013237      1475 013250      1476 013252      1479 013253      1480 013270      1481 013310      1482 013322
   1483 013325      1484 013344      1485 013366      1486 013377      1487 013401      1488 013402      1489 013405
   1490 013413      1491 013421      1492 013431      1494 013446      1495 013450      1496 013452      1035 013453
   1039 013454      1040 013457      1041 013476      1044 013477      1045 013502      1046 013521      1049 013522
   1050 013527      1051 013554      1054 013555      1055 013560      1056 013574      1059 013575      1060 013600
   1061 013627      1062 013646      1065 013647      1069 013721      1075 013722      1077 013723      1078 013736
   1079 013751      1081 013764      1082 014007      1084 014010      1129 014011      1134 014013      1135 014023
   1137 014024      1138 014026      1139 014032      1140 014033      1141 014040      1143 014041      1146 014042
   1148 014050      1149 014055      1150 014062      1151 014071      1152 014075      1153 014107      1155 014115
   1156 014120      1157 014132      1159 014142      1160 014146      1161 014160      1163 014166      1164 014171
   1165 014203      1167 014211      1168 014231      1169 014243      1170 014260      1171 014275      1173 014276
   1174 014303      1175 014310      1176 014317      1177 014334      1178 014351      1179 014366      1182 014367
   1183 014402      1184 014412      1185 014417      1186 014426      1187 014435      1188 014444      1189 014450
   1190 014462      1194 014470      1195 014520      1197 014563      1200 014651      1202 014653      1501 014654
   1505 014656      1506 014657      1507 014661      1508 014677      1510 014700      1511 014725      1512 014727
   1513 014756      1515 014757      1516 015003      1517 015005      1518 015034      1520 015035      1521 015103
   1522 015146      1523 015152      1524 015220      1527 015221      1533 015222      1535 015223      1536 015224
   1537 015227      1538 015231      1540 015232      1541 015236      1542 015243      1543 015244      1546 015245
   1547 015246      1548 015247      1549 015252      1550 015256      1551 015263      1552 015270      1554 015272
   1555 015313      1556 015316      1557 015337      1559 015342      1565 015343      1570 015345      1571 015376
   1573 015414      1577 015415      1579 015417      1580 015420      1581 015422      1582 015424      1589 015437
   1591 015440      1593 015443      1594 015457      1600 015460      1602 015461      1603 015463      1604 015464
   1605 015467      1606 015471      1607 015473      1608 015500      1609 015520      1611 015521      1613 015522
   1614 015527      1615 015535      1616 015537      1618 015540      1619 015542      1620 015565      1626 015566
   1630 015570      1636 015605      1638 015606      1639 015607      1640 015612      1641 015614      1642 015620
   1643 015624      1649 015625      1651 015633      1652 015636      1653 015671      1656 015673      1657 015700
   1658 015711      1661 015714      1662 015720      1663 015741      1666 015756      1667 015762      1668 015773
   1671 015776


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
