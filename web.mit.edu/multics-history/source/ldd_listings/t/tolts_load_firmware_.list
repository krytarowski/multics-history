	COMPILATION LISTING OF SEGMENT tolts_load_firmware_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/09/86  1528.0 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 /*   Initial coding 79/03/05 By J. A. Bush
       13*   Modified 10/84 to add delay for a dc_reset of the DAU.
       14**/
       15 
       16 
       17 
       18 
       19 /****^  HISTORY COMMENTS:
       20*  1) change(85-08-01,Fakoury), approve(86-08-22,MCR7514),
       21*     audit(86-11-25,Martinson), install(86-12-04,MR12.0-1235):
       22*     to correct a stringrange error.
       23*                                                   END HISTORY COMMENTS */
       24 
       25 
       26 
       27 
       28 
       29 /* tolts_load_firmware_ - subroutine to load mpc firmware for all mpc types,
       30*   after ITRs have been run on that mpc, and is called from MME RELEAS   */
       31 
       32 
       33 /* format: style4,ifthenstmt,ifthen,ind3,ll125,lineconind1 */
       34 tolts_load_firmware_: proc (px, a_error);
       35 
       36 
       37 /* Entry parameters */
       38 
       39 dcl  px fixed bin;					/* test page index */
       40 dcl  a_error fixed bin (35);				/* return error code */
       41 
       42 /* External entries */
       43 
       44 dcl  ioi_$connect_pcw entry (fixed bin (12), fixed bin (18), bit (36), fixed bin (35));
       45 dcl  ioi_$release_devices entry (fixed bin (12), fixed bin (35));
       46 dcl  ioi_$workspace entry (fixed bin (12), ptr, fixed bin, fixed bin (35));
       47 dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
       48 dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
       49 dcl  (ioa_$rsnnl, tolts_qttyio_$rs, opr_query_) entry options (variable);
       50 dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
       51 dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
       52 dcl  tolts_util_$search entry (ptr, char (32), ptr, fixed bin, fixed bin (35));
       53 dcl  gload_ entry (ptr, ptr, fixed bin (18), ptr, fixed bin (35));
       54 dcl  tolts_qttyio_ entry (char (*), fixed bin);
       55 dcl  com_err_$convert_status_code_ entry (fixed bin (35), char (*), char (*));
       56 
       57 /* Automatic */
       58 
       59 dcl  (catx, cxs, i, j, l, c_len, css, csl, rws, rwl) fixed bin;
       60 dcl  tio_off fixed bin (18);
       61 dcl  error fixed bin (35);
       62 dcl  (err, term) bit (1);
       63 dcl  (t_ptr, l_ptr, idbp, top) ptr;
       64 dcl  shortinfo char (8);
       65 dcl  ov_name char (17);
       66 dcl  longinfo char (100);
       67 
       68 /* structures and based variables */
       69 
       70 dcl  1 event_out static,
       71        2 causing_event fixed bin (71),
       72        2 message fixed bin (71),
       73        2 sender bit (36),
       74        2 origin,
       75          3 signal bit (18) unaligned,
       76          3 ring bit (18) unaligned,
       77        2 in_data_pointer ptr;
       78 
       79 dcl  1 cata based (io_info.catp) aligned,		/* template for deckfile catalog */
       80        2 n fixed bin,				/* number of entries */
       81        2 key (1 refer (cata.n)) char (24);		/* array of key names */
       82 
       83 dcl  1 id_blk based (idbp) aligned,			/* template for an mpc deck id block */
       84        (2 id_name bit (36),				/* BCD id name */
       85        2 rev_level bit (36),				/* BCD revision */
       86        2 dk_purpose bit (36),				/* BCD deck purpose */
       87        2 pad1 bit (36),
       88        2 rw_start fixed bin (18) unsigned,		/* offset of read/write overlay */
       89        2 pad2 bit (18),
       90        2 hx_cs_st fixed bin (18) unsigned,		/* rel. start of control store in hex words */
       91        2 hx_rw_st fixed bin (18) unsigned,		/* rel. start of read/write overlay in hex words */
       92        2 pad3 (3) bit (36),
       93        2 mpcbot bit (36)) unaligned;			/* = "MPCBOT" in BCD */
       94 
       95 dcl  buffer (fixed (gload_data.text_len)) bit (36) based (top); /* for moving data to ioi buffer */
       96 dcl  f_wd (10240) bit (36) based (l_ptr);		/* for moving data from temp buffer */
       97 
       98 /* constants */
       99 
      100 dcl  (addr, addrel, bin, bit, fixed, index, rel, string, substr) builtin;
      101 dcl  error_table_$action_not_performed fixed bin (35) ext;
      102 dcl  ipcw bit (36) int static options (constant) init ("000000770000"b3);
      103 dcl  pcwa bit (36) int static options (constant) init ("000000700000"b3);
      104 
      105       a_error = 0;					/* preset return code to 0 */
      106       io_info_ptr = addr (pages (px));			/* get ptr to this test page */
      107       io_info.io_type = 4;				/* set type for interrupt processor */
      108       ioi_wksp = io_info.workspace_ptr;			/* get ptr to our workspace */
      109       tio_off = fixed (rel (addr (tolts_workspace.p_idcw)));/* get buffer offset for ioi */
      110       l_ptr = addr (tolts_info.firm_buf);		/* place to temp load firmware */
      111       top = addr (tolts_workspace.data_buf);		/* set ptr to move firmware */
      112       do catx = 1 to cata.n while (index (cata.key (catx), ".") < 6); /* find first fw module */
      113       end;
      114       call fw_load;					/* go load deck in temp buffer */
      115       if error ^= 0 then do;				/* if some problem, return */
      116 err_1:   a_error = error;
      117          return;
      118       end;
      119       call dc_reset;				/* go send initialize pcw to mpc */
      120       if error ^= 0 then go to err_1;
      121       call copy_cs (0, err);				/* copy control store overlay */
      122       if err then do;				/* if any error ocurred */
      123 err_2:   a_error = error_table_$action_not_performed;	/* set an apropriate error code */
      124          return;
      125       end;
      126       call run_dcw;					/* execute dcw list */
      127       if error ^= 0 then go to err_1;
      128       call copy_rw (err);				/* copy read/write overlay */
      129       if err then go to err_2;
      130       call run_dcw;					/* execute dcw list */
      131       if error ^= 0 then go to err_1;			/* get out on error */
      132       call fw_load_mess;				/* let user and operator know what has been loaded */
      133       if io_info.mpc_dev_cnt ^= 0 then do;		/* if urcmpc, load device overlays  */
      134          cxs = catx + 1;				/* save catalog index + 1 */
      135          do l = 1 to io_info.mpc_dev_cnt;		/* load each overlay type */
      136 	  term = "0"b;				/* reset terminate condition */
      137 	  do catx = cxs to cata.n while (^term);	/* find each key */
      138 	     if substr (cata.key (catx), 15, 4) = io_info.dev_firm (l).edit_name then do; /* found it */
      139 	        term = "1"b;			/* set terminate condition */
      140 	        call fw_load;			/* go copy firmware overlay into temp storage */
      141 	        if error ^= 0 then go to err_1;
      142 	        call copy_cs (1, err);		/* copy control store (offset by 1 word */
      143 	        if err then go to err_2;
      144 	        idcw.command = "36"b3;		/* set overlay command */
      145 	        idcw.device = "01"b3;			/* device code of 1 for device overlays */
      146 	        idcw.chan_cmd = "40"b3;		/* special controller command */
      147 	        buffer (1) = io_info.dev_firm (l).mask;	/* set in port mask */
      148 	        call run_dcw;			/* execute overlay */
      149 	        if error ^= 0 then go to err_1;
      150 	        call fw_load_mess;			/* let user and operator know what has been loaded */
      151 	     end;
      152 	  end;
      153          end;
      154       end;
      155       call ioi_$release_devices (io_info.device_index, error); /* can let ioi do other io now */
      156       if error ^= 0 then do;				/* can't win */
      157          call output_status_code (error, "calling ioi_$release_devices");
      158          go to err_1;
      159       end;
      160       io_info.chan_suspended = "0"b;			/* channel is no longer suspended */
      161       return;
      162 
      163 
      164 /* fw_load - internal procedure to find requested deck in deckfile and load core image */
      165 
      166 fw_load: proc;
      167 
      168 /* find firmware deck in the deckfile */
      169 
      170       call tolts_util_$search (tolts_info.df_iocbp, (cata.key (catx)), t_ptr, c_len, error);
      171       if error ^= 0 then do;				/* if we couldn't find module */
      172          call output_status_code (error, "searching for " || cata.key (catx));
      173          return;
      174       end;
      175 
      176 /* now load core image into temp buffer */
      177 
      178       call gload_ (t_ptr, l_ptr, 0, addr (gload_data), error); /* load it */
      179       if error ^= 0 then do;
      180          call output_status_code (error, gload_data.diagnostic || " loading module " || cata.key (catx));
      181          return;					/* and return */
      182       end;
      183       idbp = addrel (l_ptr, fixed (gload_data.text_len) - 10); /* get ptr to id blk */
      184       css = 1;					/* control store starts at 1 */
      185       rws = id_blk.rw_start;				/* set start of read/write memory */
      186       if rws = 0 then do;				/* if read/write overlay non-existant... */
      187          csl = fixed (gload_data.text_len) - 10;		/* set cs length to loaded blk minus id blk */
      188          rwl = 0;					/* no read/write overlay */
      189       end;
      190       else do;
      191          csl = rws;
      192          rwl = fixed (gload_data.text_len) - rws - 10;	/* set lengths */
      193          rws = rws + 1;
      194       end;
      195 
      196    end fw_load;
      197 
      198 
      199 /* output_status_code - internal procedure to queue up a status message */
      200 
      201 output_status_code: proc (ecode, mess);
      202 
      203 dcl  ecode fixed bin (35);
      204 dcl  mess char (*);
      205 
      206       call com_err_$convert_status_code_ (ecode, shortinfo, longinfo);
      207       call tolts_qttyio_$rs (0, "^as: ^a^/^a", tolts_info.exec, longinfo, mess);
      208    end output_status_code;
      209 
      210 /* Procedure to dc reset of an mpc by isuing a reset pcw */
      211 
      212 dc_reset: proc;
      213 
      214       idcwp = addr (tolts_workspace.p_idcw);		/* Set up IDCW, although it wont be executed */
      215       string (idcw) = "0"b;
      216       idcw.code = "7"b3;
      217       idcw.chan_cmd = "02"b3;
      218 
      219       call ioi_$connect_pcw (io_info.device_index, tio_off, ipcw, error); /* Do connect */
      220       if error ^= 0 then do;
      221          call output_status_code (error, "issuing initialize pcw");
      222          return;
      223       end;
      224       tolts_info.glob_int_cnt = tolts_info.glob_int_cnt + 1;/* increment global IO count */
      225       io_info.io_in_progress = "1"b;			/* set flag */
      226       do while (io_info.io_in_progress);		/* make sure we only take interrupt wakeup */
      227          call ipc_$block (addr (tolts_info.wait_list), addr (event_out), error);
      228          if error ^= 0 then do;
      229 	  call output_status_code (error, "waiting for ioi timeout from initialize pcw");
      230 	  return;
      231          end;
      232       end;
      233       if tolts_workspace.status.level ^= 3 | ^tolts_workspace.status.timeout then do;
      234          call tolts_qttyio_$rs (0, "^a No ioi timeout after issuing initialize pcw", io_info.test_hdr);
      235          error = error_table_$action_not_performed;	/* set phony error */
      236          return;
      237       end;
      238 
      239 /* Since time out was only simulated by ioi, a real delay must be done to allow the mpc to reset */
      240 
      241       call timer_manager_$reset_alarm_wakeup (tolts_info.gewake_event); /* Be sure no alarm already set */
      242       call ipc_$drain_chn (tolts_info.gewake_event, error); /* In case event occured */
      243       if error ^= 0 then do;
      244          call output_status_code (error, "calling ipc_$drain_chn durring dc_reset");
      245          return;
      246       end;
      247       if io_info.cat_name = "itr.msp800" then
      248          call timer_manager_$alarm_wakeup (20, "11"b, tolts_info.gewake_event); /* Set 1 second timer */
      249       else call timer_manager_$alarm_wakeup (1, "11"b, tolts_info.gewake_event); /* Set 1 second timer */
      250       tolts_info.gewake_active = "1"b;			/* set flag */
      251       do while (tolts_info.gewake_active);		/* make sure we only take alarm wakeup */
      252          call ipc_$block (addr (tolts_info.wait_list), addr (event_out), error); /* Wait for a second */
      253          if error ^= 0 then do;
      254 	  call output_status_code (error, "waiting for dc_reset");
      255 	  return;
      256          end;
      257       end;
      258 
      259    end dc_reset;
      260 
      261 /* run_dcw - subroutine to do the actual I/O */
      262 
      263 run_dcw: proc;
      264 
      265       call ioi_$connect_pcw (io_info.device_index, tio_off, pcwa, error); /* Do connect */
      266       if error ^= 0 then do;
      267          call output_status_code (error, "attempting connect");
      268          return;
      269       end;
      270       tolts_info.glob_int_cnt = tolts_info.glob_int_cnt + 1;/* increment global IO count */
      271       io_info.io_in_progress = "1"b;			/* set flag */
      272       do while (io_info.io_in_progress);		/* make sure we only take interrupt wakeup */
      273          call ipc_$block (addr (tolts_info.wait_list), addr (event_out), error);
      274          if error ^= 0 then do;
      275 	  call output_status_code (error, "waiting for terminate interrupt");
      276 	  return;
      277          end;
      278       end;
      279       if tolts_workspace.status.level ^= 3 then do;	/* looking for terminate */
      280          call tolts_qttyio_$rs (0, "^a Unexpected level ^d interrupt while waiting for terminate",
      281 	io_info.test_hdr, tolts_workspace.status.level);
      282          error = error_table_$action_not_performed;	/* set phony error code */
      283          return;
      284       end;
      285       if tolts_workspace.status.timeout then do;		/* not good */
      286          call tolts_qttyio_$rs (0, "^a ioi timeout while waiting for terminate", io_info.test_hdr);
      287          error = error_table_$action_not_performed;	/* set phony error code */
      288          return;
      289       end;
      290       statp = addr (tolts_workspace.status.iom_status);	/* set status ptr */
      291       if status.power then do;			/* power off status */
      292          call tolts_qttyio_$rs (0, "^a Unexpected power off status, check MPC",
      293 	io_info.test_hdr);
      294          error = error_table_$action_not_performed;
      295          return;
      296       end;
      297       if status.major | status.sub | status.channel_stat | status.central_stat then do; /* If any other error */
      298          call tolts_qttyio_$rs (0, "^a Unexpected IOM status: ^12.3b ^12.3b",
      299 	io_info.test_hdr, substr (tolts_workspace.iom_status, 1, 36),
      300 	substr (tolts_workspace.iom_status, 37, 36));
      301          error = error_table_$action_not_performed;	/* set phoney error code */
      302          return;
      303       end;
      304 
      305    end run_dcw;
      306 
      307 /* copy_cs - subroutine to copy control store overlay from temp buf to ioi workspace */
      308 
      309 copy_cs: proc (buf_off, err_bit);
      310 
      311 dcl  err_bit bit (1);
      312 dcl  buf_off fixed bin;
      313 
      314       err_bit = "0"b;				/* reset error flag */
      315       ov_name = "control store";			/* set overlay name */
      316       call make_dcw ("10"b3, (csl - css + 1) + buf_off, err_bit); /* set up dcw list */
      317       if ^err_bit then				/* if no error... */
      318          call copy (css, csl, buf_off, err_bit);		/* go copy the data */
      319 
      320    end copy_cs;
      321 
      322 /* copy_rw - subroutine to copy read/write memory overlay from temp buf to ioi workspace */
      323 
      324 copy_rw: proc (err_bit);
      325 
      326 dcl  err_bit bit (1);
      327 
      328       err_bit = "0"b;				/* reset error flag */
      329       ov_name = "read/write memory";
      330       call make_dcw ("11"b3, rwl, err_bit);		/* set up dcw list */
      331       if ^err_bit then				/* if no error... */
      332          call copy (rws, rws + rwl - 1, 0, err_bit);	/* go copy the data */
      333 
      334    end copy_rw;
      335 
      336 /* fw_load_mess - subroutine to put out message telling the operator and user that firmware has been loaded */
      337 
      338 fw_load_mess: proc;
      339 
      340       call ioa_$rsnnl ("^/^a ^as has loaded ^a firmware ^a rev. ^a", longinfo, c_len,
      341        io_info.test_hdr, tolts_info.exec, substr (cata.key (catx), 8, 6),
      342        substr (cata.key (catx), 15, 4), substr (cata.key (catx), 20, 2));
      343       opr_query_info.q_sw = "0"b;			/* we don't want operator response */
      344       call opr_query_ (addr (opr_query_info), substr (longinfo, 1, c_len)); /* tell operator */
      345       if ^tolts_info.finish_cond then do;		/* only output message if we still have terminal */
      346          call tolts_qttyio_ (substr (longinfo, 1, c_len), 0); /* and ourselves what we are loading */
      347          do while (tolts_info.term_io_req_cnt ^= 0);	/* wait for message to be output */
      348 	  call ipc_$block (addr (tolts_info.wait_list), addr (event_out), error); /* Wait for a second */
      349 	  if error ^= 0 then do;
      350 	     call output_status_code (error, "waiting for firmware load message");
      351 	     return;
      352 	  end;
      353          end;
      354       end;
      355 
      356    end fw_load_mess;
      357 
      358 /* make_dcw - subroutine to set up dcw list */
      359 
      360 make_dcw: proc (op_code, dlen, err_bit);
      361 
      362 dcl  op_code bit (6);
      363 dcl  (dlen, dleft, ovh) fixed bin;
      364 dcl  err_bit bit (1);
      365 
      366       ovh = bin (rel (addr (tolts_workspace.data_buf))) + 2;/* compute overhead length of ioi buf */
      367       idcwp = addr (tolts_workspace.p_idcw);		/* get ptr to primary idcw loc */
      368       string (idcw) = "0"b;				/* initialize */
      369       idcw.command = op_code;				/* copy command */
      370       idcw.code = "7"b3;				/* this must be set for an idcw */
      371       dcwp = addr (tolts_workspace.dcw_list (1));		/* set up 1st dcw */
      372       string (dcw) = "0"b;				/* initialize 1st dcw */
      373       dcw.address = rel (addr (tolts_workspace.data_buf));	/* set dcw address */
      374       dleft = dlen;					/* start with entire length */
      375       do while (dleft > 4096);			/* set up as many dcws as neccessary */
      376          dcw.type = "01"b;				/* set type to iotp */
      377          dcw.tally = "0000"b3;			/* 0 = tally of 4096 */
      378          if io_info.cur_wks_sz < dlen + ovh then		/* if our workspace is to small */
      379 	  if tolts_info.max_wks_sz < dlen + ovh then do;	/* and we can't get enough */
      380 	     err_bit = "1"b;			/* set error indicator */
      381 	     call tolts_qttyio_$rs (0, "^a max workspace size of ^d is less than ^a overlay length of ^d",
      382 	      io_info.test_hdr, tolts_info.max_wks_sz, ov_name, dlen);
      383 	     return;				/* return and report error */
      384 	  end;
      385 	  else do;
      386 	     if io_info.cur_wks_sz + 4096 > tolts_info.max_wks_sz then /* if current + 4k is > max */
      387 	        io_info.cur_wks_sz = tolts_info.max_wks_sz; /* set current size to max */
      388 	     else io_info.cur_wks_sz = io_info.cur_wks_sz + 4096; /* increse by 4k */
      389 	     call ioi_$workspace (io_info.device_index, ioi_wksp, io_info.cur_wks_sz, error);
      390 	     if error ^= 0 then do;			/* ioi_ didn't like it */
      391 	        call output_status_code (error, "setting max workspace size");
      392 	        err_bit = "1"b;			/* set error indicator */
      393 	        return;
      394 	     end;
      395 	  end;
      396          tdcwp = dcwp;				/* save current dcw ptr */
      397          dcwp = addrel (dcwp, 1);			/* go to next dcw */
      398          string (dcw) = "0"b;				/* initialize dcw */
      399          dcw.address = bit (bin (bin (tdcwp -> dcw.address) + 4096, 18));
      400          dleft = dleft - 4096;			/* decrement data left */
      401       end;
      402       dcw.type = "00"b;				/* last dcw is iotd */
      403       dcw.tally = bit (bin (dleft, 12));		/* set tally */
      404       tolts_workspace.buf_size = dlen;			/* set buffer size */
      405 
      406    end make_dcw;
      407 
      408 /* This procedure actually copies the firmware data */
      409 
      410 copy: proc (start, stop, b_off, err_bit);
      411 
      412 dcl  (start, stop, b_off) fixed bin;			/* The range of words to be copied */
      413 dcl  err_bit bit (1);				/* An error code */
      414 dcl  ck_sum fixed bin (35) init (0);			/* To do check sum calculations */
      415 dcl  ck_bit bit (36) based (addr (ck_sum));		/* Another way of looking at ck_sum */
      416 
      417       j = 1 + b_off;				/* start at one plus offset */
      418       do i = start to stop;				/* Copy it all */
      419          buffer (j) = f_wd (i);			/* This moves a word */
      420          if i < stop then do;				/* If not last word, do checksum calc */
      421 	  call ch_add (ck_sum, bin (substr (f_wd (i), 2, 8) || substr (f_wd (i), 11, 8)));
      422 	  call ch_add (ck_sum, bin (substr (f_wd (i), 20, 8) || substr (f_wd (i), 29, 8)));
      423          end;
      424          j = j + 1;
      425       end;
      426 
      427       ck_sum = -ck_sum;				/* Get complement of check sum */
      428 
      429       if "0"b || substr (ck_bit, 21, 8) || "0"b || substr (ck_bit, 29, 8) ^=
      430        substr (f_wd (stop), 1, 18) then do;
      431          call tolts_qttyio_$rs (0, "^a check sum error detected in ^a overlay of ^a firmware - ^a",
      432 	io_info.test_hdr, ov_name, substr (cata.key (catx), 8, 6),
      433 	substr (cata.key (catx), 15, 4));
      434          err_bit = "1"b;
      435       end;
      436 
      437       return;
      438 
      439    end copy;
      440 
      441 
      442 /* This subroutine does 16 bit addition with end around carry to validate check sums */
      443 
      444 ch_add: proc (sum, add_val);
      445 
      446 dcl  sum fixed bin (35);				/* The accumulated sum */
      447 dcl  add_val fixed bin (16);				/* New value to add */
      448 
      449       sum = sum + add_val;				/* Do the add */
      450 carry: if sum > 1111111111111111b then do;		/* If overflow into 17th bit */
      451          sum = sum - 10000000000000000b;		/* Subtract it out */
      452          sum = sum + 1;				/* Do end-around carry */
      453          go to carry;				/* Check again */
      454       end;
      455       return;
      456 
      457    end ch_add;
      458 
  1     1 
  1     2 /* BEGIN INCLUDE FILE gload_data.incl.pl1 */
  1     3 /* created 9/29/78 by James A. Bush */
  1     4 
  1     5 dcl 1 gload_data aligned,				/* pertinent info  generated from gload_ */
  1     6    (2 deck_name char (4),				/* name from columns 73-76 of $ object card */
  1     7     2 deck_type bit (1),				/* "0"b = absolute, "1"b = relocatable */
  1     8     2 sym_cnt fixed bin (16),				/* count of valid symbols */
  1     9     2 text_len bit (18),				/* length in words including load offset */
  1    10     2 checksum bit (36),				/* checksum of loaded deck */
  1    11     2 diagnostic char (200),				/* loader diagnostic */
  1    12     2 definition (128),				/* array of definitions */
  1    13       3 symbol char (6),				/* symbol name */
  1    14       3 pad1 bit (18),
  1    15       3 offset bit (18),				/* symbol offset in text */
  1    16       3 pad2 bit (14),
  1    17       3 sym_type fixed bin (3)) unaligned;		/* type of symbol (0 - 7) */
  1    18 
  1    19 /* END INCLUDE FILE gload_data.incl.pl1 */
  1    20 
      459 
      460 
  2     1 
  2     2 /* Begin include file ...... iom_stat.incl.pl1 */
  2     3 /* Last modified on 10/31/74 by Noel I. Morris */
  2     4 
  2     5 dcl  statp ptr;					/* pointer to status */
  2     6 
  2     7 dcl 1 status based (statp) aligned,			/* IOM status information */
  2     8      (2 t bit (1),					/* set to "1"b by IOM */
  2     9       2 power bit (1),				/* non-zero if peripheral absent or power off */
  2    10       2 major bit (4),				/* major status */
  2    11       2 sub bit (6),				/* substatus */
  2    12       2 eo bit (1),					/* even/odd bit */
  2    13       2 marker bit (1),				/* non-zero if marker status */
  2    14       2 soft bit (2),				/* software status */
  2    15       2 initiate bit (1),				/* initiate bit */
  2    16       2 abort bit (1),				/* software abort bit */
  2    17       2 channel_stat bit (3),				/* IOM channel status */
  2    18       2 central_stat bit (3),				/* IOM central status */
  2    19       2 mbz bit (6),
  2    20       2 rcount bit (6),				/* record count residue */
  2    21       2 address bit (18),				/* DCW address residue */
  2    22       2 char_pos bit (3),				/* character position residue */
  2    23       2 r bit (1),					/* non-zero if reading */
  2    24       2 type bit (2),				/* type of last DCW */
  2    25       2 tally bit (12)) unal;				/* DCW tally residue */
  2    26 
  2    27 dcl 1 faultword based (statp) aligned,			/* system fault word */
  2    28      (2 mbz1 bit (9),
  2    29       2 channel bit (9),				/* channel number */
  2    30       2 serv_req bit (5),				/* service request */
  2    31       2 mbz2 bit (3),
  2    32       2 controller_fault bit (4),			/* system controller fault code */
  2    33       2 io_fault bit (6)) unal;			/* I/O fault code */
  2    34 
  2    35 dcl 1 special_status based (statp) aligned,		/* special status from PSIA */
  2    36    (2 t bit (1),					/* entry present bit */
  2    37     2 channel bit (8),				/* channel number */
  2    38     2 pad1 bit (3),
  2    39     2 device bit (6),				/* device address */
  2    40     2 pad2 bit (1),
  2    41     2 byte2 bit (8),				/* device dependent information */
  2    42     2 pad3 bit (1),
  2    43     2 byte3 bit (8)) unal;				/* device dependent information */
  2    44 
  2    45 /* End of include file iom_stat.incl.pl1 */
  2    46 
      461 
      462 
  3     1 /* Begin mca_data_area.incl.pl1 */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(86-03-19,Fawcett), approve(86-03-19,MCR7374),
  3     5*     audit(86-04-28,Lippard), install(86-09-16,MR12.0-1159):
  3     6*     Created for control of the MCA. This is a template for the ioi workspace
  3     7*     needed for the MCA communications.
  3     8*                                                   END HISTORY COMMENTS */
  3     9 
  3    10 /* Created Sept 84 by R. A. Fawcett from information in
  3    11*   "EPS-1 DIPPER Maintainability" REV A (MAY 3, 1983) */
  3    12 
  3    13 
  3    14 
  3    15 dcl  data_header_ptr ptr;
  3    16 
  3    17 dcl  (data_size_1, data_size_2) fixed bin (21) init (0);
  3    18 
  3    19 dcl  io_param_blk_ptr ptr;
  3    20 
  3    21 dcl  mca_dcw_list_ptr ptr;
  3    22 
  3    23 dcl  mca_work_space_ptr ptr;
  3    24 
  3    25 dcl  1 mca_work_space based (mca_work_space_ptr),
  3    26        2 list_of_dcw like mca_dcw_list,
  3    27        2 status_area like istat,
  3    28 
  3    29        2 data_header_1 aligned like data_header,
  3    30        2 data_1 char (data_size_1),
  3    31        2 data_header_2 aligned like data_header,
  3    32        2 data_2 char (data_size_2);
  3    33 
  3    34 
  3    35 dcl  1 data_header based (data_header_ptr) aligned,
  3    36        2 type bit (9) unal,				/* must be equal to "000"b3 (MBZ) */
  3    37        2 definer fixed bin (9) unal unsigned,		/* defines type of info in header */
  3    38        2 ctl_sw bit (18) unal,			/* "currently undfined" mbz  = "000000"b3 */
  3    39 
  3    40        2 host_sts_ign1 bit (1) unal,
  3    41        2 host_sts_msb bit (8) unal,
  3    42        2 host_sts_ign2 bit (1) unal,
  3    43        2 host_sts_lsb bit (8) unal,
  3    44 
  3    45        2 rd_flpy fixed bin (9) unal unsigned,		/* 0 = data files from host */
  3    46 						/* 1 = data files from flopy */
  3    47        2 io_param_blk like io_parameter_block unal;
  3    48 
  3    49 
  3    50 dcl  1 io_parameter_block based (io_param_blk_ptr) unal,
  3    51        2 open fixed bin (9) unal unsigned,
  3    52        2 cmd bit (18),
  3    53        2 sts_ptr bit (18),				/* Unused */
  3    54        2 file_name char (8),				/* file name for this request */
  3    55        2 options bit (18),				/* Unused */
  3    56        2 source_ptr bit (18),				/* Unused */
  3    57        2 source_len,
  3    58 						/* data_size = source_len_msb||source_len_lsb MCA to HOST */
  3    59          3 source_len_ign1 bit (1),
  3    60          3 source_len_msb bit (8),
  3    61          3 source_len_ign2 bit (1),
  3    62          3 source_len_lsb bit (8),
  3    63        2 dest_ptr bit (18),				/* Unused */
  3    64        2 blk_ct,
  3    65 						/* if MCA to HOST blk_ct_msb||blk_ct_lsb = MAX number of 256 byte BLOCKS  */
  3    66 						/* else not used */
  3    67          3 blk_ct_ign1 bit (1),
  3    68          3 blk_ct_msb bit (8),
  3    69          3 blk_ct_ign2 bit (1),
  3    70          3 blk_ct_lsb bit (8),
  3    71        2 dest_len,
  3    72 						/* supplied by host as the number of bytes in data_field max value is 16128 */
  3    73 						/* dest_len_msb = substr(unspec(data_size),21,8) */
  3    74 						/* dest_len_lsb = substr(unspec(data_size),29,8) */
  3    75          3 dest_len_ign1 bit (1),
  3    76          3 dest_len_msb bit (8),
  3    77          3 dest_len_ign2 bit (1),
  3    78          3 dest_len_lsb bit (8);
  3    79 
  3    80 
  3    81 dcl  1 mca_dcw_list based (mca_dcw_list_ptr),
  3    82        2 idcw1 like idcw,
  3    83        2 dcw1 like dcw,
  3    84        2 idcw2 like idcw,
  3    85        2 dcw2 like dcw;
  3    86 
  3    87 
  4     1 
  4     2 /* Begin include file ...... iom_dcw.incl.pl1 */
  4     3 
  4     4 dcl  dcwp ptr,					/* pointer to DCW */
  4     5      tdcwp ptr;					/* pointer to TDCW */
  4     6 
  4     7 dcl 1 dcw based (dcwp) aligned,			/* Data Control Word */
  4     8      (2 address bit (18),				/* address for data transfer */
  4     9       2 char_pos bit (3),				/* character position */
  4    10       2 m64 bit (1),				/* non-zero for mod 64 address */
  4    11       2 type bit (2),				/* DCW type */
  4    12       2 tally bit (12)) unal;				/* tally for data transfer */
  4    13 
  4    14 dcl 1 tdcw based (tdcwp) aligned,			/* Transfer DCW */
  4    15      (2 address bit (18),				/* address to transfer to */
  4    16       2 mbz1 bit (4),
  4    17       2 type bit (2),				/* should be "10"b for TDCW */
  4    18       2 mbz2 bit (9),
  4    19       2 ec bit (1),					/* non-zero to set LPW AE bit */
  4    20       2 res bit (1),				/* non-zero to restrict further use of IDCW */
  4    21       2 rel bit (1)) unal;				/* non-zero to set relative mode after transfer */
  4    22 
  4    23 /* End of include file ...... iom_dcw.incl.pl1 */
  4    24 
  3    88 




  3    89 
  5     1 
  5     2 /* Begin include file ...... iom_pcw.incl.pl1 */
  5     3 
  5     4 dcl  pcwp ptr;					/* pointer to PCW */
  5     5 
  5     6 dcl 1 pcw based (pcwp) aligned,			/* Peripheral Control Word */
  5     7      (2 command bit (6),				/* device command */
  5     8       2 device bit (6),				/* device code */
  5     9       2 ext bit (6),				/* address extension */
  5    10       2 code bit (3),				/* should be "111"b for PCW */
  5    11       2 mask bit (1),				/* channel mask bit */
  5    12       2 control bit (2),				/* terminate/proceed and marker control bits */
  5    13       2 chan_cmd bit (6),				/* type of I/O operation */
  5    14       2 count bit (6),				/* record count or control character */
  5    15       2 mbz1 bit (3),
  5    16       2 channel bit (6),				/* channel number */
  5    17       2 mbz2 bit (27)) unal;
  5    18 
  5    19 dcl  idcwp ptr;					/* pointer to IDCW */
  5    20 
  5    21 dcl 1 idcw based (idcwp) aligned,			/* Instruction DCW */
  5    22      (2 command bit (6),				/* device command */
  5    23       2 device bit (6),				/* device code */
  5    24       2 ext bit (6),				/* address extension */
  5    25       2 code bit (3),				/* should be "111"b for PCW */
  5    26       2 ext_ctl bit (1),				/* "1"b if address extension to be used */
  5    27       2 control bit (2),				/* terminate/proceed and marker control bits */
  5    28       2 chan_cmd bit (6),				/* type of I/O operation */
  5    29       2 count bit (6)) unal;				/* record count or control character */
  5    30 
  5    31 /* End include file ...... iom_pcw.incl.pl1 */
  5    32 
  3    90 




  3    91 
  6     1 
  6     2 /* Begin include file ...... ioi_stat.incl.pl1 */
  6     3 /* Last modified 3/24/75 by Noel I. Morris */
  6     4 
  6     5 dcl  isp ptr;					/* pointer to status structure */
  6     6 
  6     7 dcl 1 istat based (isp) aligned,			/* I/O Interfacer status structure */
  6     8     2 completion,					/* completion flags */
  6     9      (3 st bit (1),					/* "1"b if status returned */
  6    10       3 er bit (1),					/* "1"b if status indicates error condition */
  6    11       3 run bit (1),				/* "1"b if channel still running */
  6    12       3 time_out bit (1)) unal,			/* "1"b if time-out occurred */
  6    13     2 level fixed bin (3),				/* IOM interrupt level */
  6    14     2 offset fixed bin (18),				/* DCW list offset */
  6    15     2 absaddr fixed bin (24),				/* absolute address of workspace */
  6    16     2 iom_stat bit (72),				/* IOM status */
  6    17     2 lpw bit (72);					/* LPW residue */
  6    18 
  6    19 dcl  imp ptr;					/* pointer to message structure */
  6    20 
  6    21 dcl 1 imess based (imp) aligned,			/* I/O Interfacer event message structure */
  6    22    (2 completion like istat.completion,			/* completion flags */
  6    23     2 pad bit (11),
  6    24     2 level bit (3),				/* interrupt level */
  6    25     2 offset bit (18),				/* DCW list offset */
  6    26     2 status bit (36)) unal;				/* first 36 bits of status */
  6    27 
  6    28 /* End of include file ...... ioi_stat.incl.pl1 */
  6    29 
  3    92 




  3    93 
  3    94 /* Constants used for data_header.definer */
  3    95 
  3    96 dcl  DATA_FROM_HOST
  3    97 	fixed bin (9) unsigned init (0) static options (constant);
  3    98 dcl  WRITE_CONSOLE
  3    99 	fixed bin (9) unsigned init (1) static options (constant);
  3   100 dcl  WRITE_READ_CONSOLE
  3   101 	fixed bin (9) unsigned init (2) static options (constant);
  3   102 dcl  DATA_FROM_MCA
  3   103 	fixed bin (9) unsigned init (3) static options (constant);
  3   104 dcl  REQ_DATA_FROM_HOST
  3   105 	fixed bin (9) unsigned init (4) static options (constant);
  3   106 dcl  STATUS_FROM_MCA
  3   107 	fixed bin (9) unsigned init (5) static options (constant);
  3   108 dcl  SEEK
  3   109 	fixed bin (9) unsigned init (6) static options (constant);
  3   110 dcl  CON_DATA_FROM_HOST
  3   111 	fixed bin (9) unsigned init (7) static options (constant);
  3   112 dcl  BIN_DATA_FROM_HOST
  3   113 	fixed bin (9) unsigned init (8) static options (constant);
  3   114 dcl  ABORT_SES_FROM_HOST
  3   115 	fixed bin (9) unsigned init (9) static options (constant);
  3   116 
  3   117 
  3   118 /* End mca_data_area.incl.pl1 */
  3   119 
      463 
      464 
  7     1 
  7     2 /* BEGIN INCLUDE FILE opr_query_info.incl.pl1 */
  7     3 
  7     4 /* created 10/20/78 by J. A. Bush. 
  7     5*   Modified by Rick Fakoury to increase size of the allowable answer.
  7     6**/
  7     7 
  7     8 dcl 1 opr_query_info aligned,				/* info structure for the opr_query_ subroutine */
  7     9     2 version fixed bin,				/* version of this structure, currently = to 1 */
  7    10     2 q_sw bit (1) aligned,				/* = "1"b if aswer is expected from operator */
  7    11     2 prim char (8),				/* primary expected operators response */
  7    12     2 alt char (8),					/* alternate expected operator response */
  7    13     2 answer char (80) varying,				/* operators answer */
  7    14     2 r_comment char (64),				/* comment to be output with respond message */
  7    15     2 err_code fixed bin (35);			/* standard system status code */
  7    16 
  7    17 /* END INCLUDE FILE opr_query_info.incl.pl1 */
  7    18 
      465 
      466 
  8     1 /*        BEGIN INCLUDE FILE tolts_info.incl.pl1     */
  8     2 
  8     3    
  8     4 
  8     5 
  8     6 
  8     7 
  8     8 
  8     9 /****^  HISTORY COMMENTS:
  8    10*  1) change(80-03-24,Fakoury), approve(), audit(86-11-25,Martinson),
  8    11*     install(86-12-04,MR12.0-1235):
  8    12*     to add second sct for 500/501 MTAR
  8    13*  2) change(80-09-01,Fakoury), approve(), audit(86-11-25,Martinson),
  8    14*     install(86-12-04,MR12.0-1235):
  8    15*     to init rcp_area and alt_rcp_area to 0.
  8    16*  3) change(81-09-01,Fakoury), approve(), audit(86-11-25,Martinson),
  8    17*     install(86-12-04,MR12.0-1235):
  8    18*     to add new statements for colts.
  8    19*  4) change(81-09-01,Fakoury), approve(), audit(86-11-25,Martinson),
  8    20*     install(86-12-04,MR12.0-1235):
  8    21*     to increase the dcw_list size.
  8    22*  5) change(82-04-01,Fakoury), approve(), audit(86-11-25,Martinson),
  8    23*     install(86-12-04,MR12.0-1235):
  8    24*     to add crcst and redefine devsct.
  8    25*  6) change(82-09-01,Fakoury), approve(), audit(86-11-25,Martinson),
  8    26*     install(86-12-04,MR12.0-1235):
  8    27*     to increase the console buffer size for mtar.
  8    28*  7) change(82-11-01,Fakoury), approve(), audit(86-11-25,Martinson),
  8    29*     install(86-12-04,MR12.0-1235):
  8    30*     for 128chan support.
  8    31*  8) change(83-07-01,Fakoury), approve(), audit(86-11-25,Martinson),
  8    32*     install(86-12-04,MR12.0-1235):
  8    33*     to increase the dcw_list size for mtar perm file track repair.
  8    34*  9) change(84-04-10,Fakoury), approve(86-08-21,MCR7514),
  8    35*     audit(86-11-25,Martinson), install(86-12-04,MR12.0-1235):
  8    36*     to add sct_info needed to support the DAU & DIPPER.
  8    37* 10) change(85-02-21,Fakoury), approve(86-08-21,MCR7514),
  8    38*     audit(86-11-25,Martinson), install(86-12-04,MR12.0-1235):
  8    39*      2/85 to support test nio request.
  8    40* 11) change(85-04-01,Fakoury), approve(86-08-21,MCR7514),
  8    41*     audit(86-11-25,Martinson), install(86-12-04,MR12.0-1235):
  8    42*     for extended status store.
  8    43* 12) change(85-12-21,Fakoury), approve(86-08-21,MCR7514),
  8    44*     audit(86-11-25,Martinson), install(86-12-04,MR12.0-1235):
  8    45*     for Colts Responder changes.
  8    46* 13) change(86-02-01,Fakoury), approve(86-08-20,MCR7514),
  8    47*     audit(86-11-25,Martinson), install(86-12-04,MR12.0-1235):
  8    48*      implement the test nio request.
  8    49*      support of a Colts responder test request.
  8    50*                                                   END HISTORY COMMENTS */
  8    51 
  8    52 
  8    53 
  8    54 
  8    55 
  8    56 
  8    57 /* format: style4,ifthenstmt,ifthen,ind3,ll125,lineconind1 */
  8    58 
  8    59 dcl  polt_io_type fixed bin int static options (constant) init (0);
  8    60 dcl  itr_io_type fixed bin int static options (constant) init (1);
  8    61 dcl  mdr_io_type fixed bin int static options (constant) init (2);
  8    62 dcl  mtar_io_type fixed bin int static options (constant) init (3);
  8    63 dcl  firm_ld_io_type fixed bin int static options (constant) init (4);
  8    64 dcl  mtc_io_type fixed bin int static options (constant) init (5);
  8    65 dcl  mtg_io_type fixed bin int static options (constant) init (6);
  8    66 dcl  mdc_io_type fixed bin int static options (constant) init (7);
  8    67 dcl  mhp_io_type fixed bin int static options (constant) init (8);
  8    68 dcl  mca_io_type fixed bin int static options (constant) init (9);
  8    69 dcl  rspd_io_type fixed bin int static options (constant) init (10);
  8    70 
  8    71 dcl  tolts_infop ptr external static;			/* ext static ptr to tolts_info structure */
  8    72 dcl  colts_info_ptr ptr;				/* ptr to individual test page data */
  8    73 dcl  io_info_ptr ptr;				/* ptr to individual test page data */
  8    74 dcl  dmap ptr;					/* pointer to dial_manager_arg */
  8    75 dcl  1 tolts_info based (tolts_infop) aligned,		/* data structure used for tolts routines */
  8    76        2 cdtptr ptr,
  8    77        2 df_iocbp ptr,				/* deckfile iocb ptr */
  8    78        2 dm_event fixed bin (71),			/* dial_manager event_channel */
  8    79        2 exec char (4),				/* executive name (polt, molt, colt etc) */
  8    80        2 exec_dta_cnt fixed bin,			/* inter slave request count */
  8    81        2 exec_page_count fixed bin,			/* number of test pages active */
  8    82        2 exec_term_io_wait bit (1),			/* waiting for io to complete for exec termination */
  8    83        2 execp ptr,					/* ptr to slave polt or molt segment */
  8    84        2 file_attach bit (1),				/* = "1"b if print file attached */
  8    85        2 file_open bit (1),				/* = "1"b if print file open */
  8    86        2 finish_cond bit (1),				/* = "1"b if finish condition has been signaled */
  8    87        2 first_request_done bit (1),			/* first terminal io request complete */
  8    88        2 gc_date bit (36),				/* gcos 6 char bcd date (set at init time, updated at rollover) */
  8    89        2 gewake_active bit (1),			/* = "1"b if gewake alarm timer is active */
  8    90        2 gewake_event fixed bin (71),			/* gewake alarm timer event channel id */
  8    91        2 glob_int_cnt fixed bin,			/*  total number of outstanding test IOs */
  8    92        2 hdir char (168),				/* users home directory pathname */
  8    93        2 init_time fixed bin (71),			/* gcos time of executive initialize (mme poinit) */
  8    94        2 max_to fixed bin (71),			/* max ioi timeout ( from rcp_$check_attach) */
  8    95        2 max_wks_sz fixed bin (19),			/* max ioi wkspace size (from rcp_$check_attach) */
  8    96        2 micro_time fixed bin (71),			/* time at midnight in usecs. (set at init time, updated at rollover */
  8    97        2 optflag fixed bin,				/* option request flag */
  8    98        2 padx (2) fixed bin,				/* reserved area */
  8    99        2 pf_iocbp ptr,				/* print file iocb ptr */
  8   100        2 pf_name char (32),				/* seg name of print file */
  8   101        2 process bit (36),				/* T & D users process id */
  8   102        2 quith_event fixed bin (71),			/* quit handler event call channel id */
  8   103        2 special_fault bit (1),			/* error on reconnect after special int */
  8   104        2 term_io_in_prog bit (1),			/* terminal io in progress */
  8   105        2 term_io_req_cnt fixed bin,			/* outstanding terminal io requests */
  8   106        2 tty_ccc_event fixed bin (71),			/* term io courtesy call event call channel id */
  8   107        2 tty_display_event fixed bin (71),		/* term io display event channel id */
  8   108        2 tty_issue_event fixed bin (71),		/* term io issue event call channel id */
  8   109        2 wks_sz fixed bin,				/* workspace size in words (4096 for polts, 6144 for molts) */
  8   110        2 exec_dta (16),				/* inter slave request queue */
  8   111          3 word (4) bit (36),				/* inter slave data */
  8   112        2 ccc_queue,					/* courtesy call queue */
  8   113          3 ccc_requests fixed bin,			/* courtesy call requests */
  8   114          3 icivlu (16) bit (36),			/* ic and ind of courtesy call routine */
  8   115        2 isc_queue,					/* interslave communication queue */
  8   116          3 icivlu bit (36),				/* ic and i of queue entry */
  8   117          3 status_add fixed bin,			/*  :: */
  8   118          3 data_add fixed bin,			/* :: */
  8   119 
  8   120        2 tadio (8),					/* T & D user io rqt queue */
  8   121          3 optrd bit (1),				/* = "1"b if options are to be read */
  8   122          3 inuse bit (1),				/* = "1"b if queue entry in use */
  8   123          3 return_word (3) bit (36),			/* data returned from mme tadiod */
  8   124          3 option bit (6 * 84),			/* bcd option string */
  8   125        2 wait_list,					/* wait list for dispatcher block */
  8   126          3 nchan fixed bin,				/* number of event wait channels  */
  8   127          3 wait_pad fixed bin,			/* will make wait_event_id on even boundary */
  8   128          3 wait_event_id (2) fixed bin (71),		/* dispatcher event wait chan id */
  8   129        2 clt_sw char (32),
  8   130        2 att_desc char (32),
  8   131        2 cdt_pointer ptr,				/* save pointer to cdt */
  8   132        2 fnp_exec_cnt fixed bin init (0),
  8   133        2 fnp (0:7),
  8   134          3 exec_active bit (1) init ("0"b),
  8   135          3 exec_chan char (32),
  8   136          3 status_word bit (36) init ("0"b),
  8   137          3 fnp_execp ptr,
  8   138          3 type fixed bin,
  8   139          3 exec_type_code bit (6) init ("0"b),
  8   140          3 cdt_name (8) char (32) init ("empty"),		/* cdt name built from test request */
  8   141          3 dm_arg like dial_manager_arg,
  8   142        2 mess_buf,					/* terminal io message buffers */
  8   143          3 first ptr,				/* ptr to start of message buffer */
  8   144          3 nxt ptr,					/* ptr to nxt queue entry */
  8   145          3 term_queue (8192) fixed bin,			/* message queu as fixed bin */
  8   146          3 q_end bit (0),				/* to find end of queue */
  8   147          3 q_pad (1024) fixed bin,			/* padding area */
  8   148          3 mult_ans char (28) varying,			/* answer to local Multics question */
  8   149          3 cv_buf char (4000) varying,			/* temporary conversion storage */
  8   150        2 colts_pages (8) like colts_info,
  8   151        2 pages (8) like io_info,			/* test pages (8 posible) */
  8   152        2 firm_buf (10240) fixed bin;			/* storage for loading firmware */
  8   153 
  8   154 
  8   155 dcl  1 io_info based (io_info_ptr) aligned,		/* this maps test pages in tolts_info */
  8   156        2 alloc_wait bit (1),				/* = "1"b if waiting  for delayed allocation */
  8   157        2 allocated bit (1),				/* = "1"b if device allocated to this page */
  8   158        2 alt_dev_flag bit (1),			/* = "1"b if 2nd logical device configured (MTAR 500/501 only */
  8   159        2 alt_device_index fixed bin (12),		/* ioi device index */
  8   160        2 alt_device_name char (8),			/* alternate allocated device name */
  8   161        2 alt_rcp_area (24) fixed bin init (0),		/* alternate device rcp */
  8   162        2 alt_rcp_id bit (36) aligned,			/* rcp id for alternate attach/check_attach */
  8   163        2 attach_err fixed bin (35),			/* error code returned durning attach */
  8   164        2 cata_cycle bit (1),				/* cycle check for cata */
  8   165        2 cat_name char (10),				/* itr or mdr catalog suffix */
  8   166        2 n_keys fixed bin aligned,			/* number of catalog keys below */
  8   167        2 cata_keys (10) char (24) aligned,		/* array of catalog keys */
  8   168        2 catp ptr,					/* ptr to itr or mdr catalog in deckfile */
  8   169        2 catx fixed bin,				/* current cata_info.index */
  8   170        2 ccu_pun bit (1),				/* = "1"b if ccu to be used as punch */
  8   171        2 chan_suspended bit (1),			/* = "1"b if channel has been suspended */
  8   172        2 chan_time fixed bin (35),			/* channel time (in 1/64th miliseconds) */
  8   173        2 con_time fixed bin (35),			/* abs time of connect (in 1/64 th miliseconds) */
  8   174        2 cur_wks_sz fixed bin,			/* current size of ioi workspace (normally tolts_info.wks_sz) */
  8   175        2 dcw_list (330) bit (36),			/* test page dcw list in unaltered form */
  8   176        2 dev_busy bit (1),				/* = "1"b  if device busy before */
  8   177        2 device_index fixed bin (12),			/* ioi device index */
  8   178        2 device_name char (8),			/* allocated device name (in ascii) */
  8   179        2 ev_ch_ass bit (1),				/* = "1"b if status event chan assigned to this page */
  8   180        2 ext_status_add fixed bin,			/* extended status store address */
  8   181        2 fnp_num fixed bin,
  8   182        2 fpinfo_ptr ptr,				/* ptr to rspd info table */
  8   183        2 ignore_term bit (1),				/* = "1"b if term int to be ignored, wait for special (ITR) */
  8   184        2 in_use bit (1),				/* = "1"b if this test page in use */
  8   185        2 int_time fixed bin (35),			/* abs time of interrupt (in 1/64 th miliseconds) */
  8   186        2 io_in_progress bit (1),			/* = "1"b if io in progress for this page */
  8   187        2 io_trc_flag bit (1),				/* = "1"b if io is being traced */
  8   188        2 io_type fixed bin,				/* 0 = polt, 1 = ITR, 2 = MDR, 3 = MTAR, 4 = firmware load */
  8   189        2 iocp ptr,
  8   190        2 ipc_attached bit (1),
  8   191        2 ipc_id char (3),
  8   192        2 ipc_number fixed bin,
  8   193        2 lostit_time fixed bin (35),			/* lost interrupt time in 1/64 th miliseconds */
  8   194        2 mca_attach_state fixed bin,
  8   195        2 mcata_idx fixed bin,				/* mca catalog indexer */
  8   196        2 mcata_nkeys fixed bin aligned,			/* no of keys in a mca catalog */
  8   197        2 mcata_keys (100) char (24) aligned,		/* mca catalog entries */
  8   198        2 mca_ioi_idx fixed bin,			/* ioi index of attached mca /
  8   199*       2 mca_iop ptr,				/* mca io ptr */
  8   200        2 mca_workspace_ptr ptr,
  8   201        2 mpc_dev_cnt fixed bin,			/* if urmpc to be booted, # of devices */
  8   202        2 nff bit (1),				/* = "1"b new format flag */
  8   203        2 num_connects fixed bin,			/* number of connects issued by this page */
  8   204        2 p2_att bit (1),				/* ="1"b if alternate device is attached (MTAR 500/501 only) */
  8   205        2 p_att bit (1),				/* = "1"b if perp. device attached to this page */
  8   206        2 page_base fixed bin (18) uns,			/* base of this test page in slave seg */
  8   207        2 pcwa bit (36),				/* pcw */
  8   208        2 rcp_area (24) fixed bin init (0),		/* storage for rcp device info */
  8   209        2 rcp_id bit (36) aligned,			/* rcp id for attach/check_attach */
  8   210        2 rcp_name char (32),				/* rcp name for this device */
  8   211        2 rcp_state fixed bin,				/* rcp attach state flag */
  8   212        2 release_chan bit (1),			/* = "1"b if ioi_$release devices to be called */
  8   213        2 rew_wait bit (1),				/* = "1"b if waiting for special on rewind complete */
  8   214        2 sp_flag bit (1),				/* = "1"b if special status available */
  8   215        2 sp_status bit (36),				/* special interrupt status storage */
  8   216        2 spare1 bit (1),
  8   217        2 status_add fixed bin,			/* address to store status in test page */
  8   218        2 status_event fixed bin (71),			/* io completion status event call channel id */
  8   219        2 suspend_chan bit (1),			/* = "1"b if ioi_$suspend devices to be called */
  8   220        2 tolts_rspd_wksp ptr,
  8   221        2 test_hdr char (16),				/* test header used for Multics local messages */
  8   222        2 tio_off fixed bin (18),			/* dcw list offset for ioi */
  8   223        2 to_no_cc bit (1),				/* = "1"b if timeout expected (set after mme ipcw) */
  8   224        2 workspace_ptr ptr,				/* ioi workspace ptr */
  8   225        2 altsct,					/* sct for MTAR alternate device */
  8   226 	 (3 w1,					/* device sct word 1 */
  8   227 	 4 type_code bit (6),			/* gcos 3 type code (see dd14 app. a) */
  8   228 	 4 device_no bit (6),			/* device number */
  8   229 	 4 com_prph bit (1),			/* = "1"b if common perph. device */
  8   230 	 4 hi_speed bit (1),			/* = "1"b if hi speed printer */
  8   231 	 4 ll160 bit (1),				/* = "1"b if 160 collum printer */
  8   232 	 4 pad1 bit (2),
  8   233 	 4 cr501_pr54 bit (1),			/* either a cr501 or pr54 device */
  8   234 	 4 icc bit (11),				/* iom and channel (true channel index) */
  8   235 	 4 pad2 bit (7),
  8   236          3 w2,					/* device sct word 2 */
  8   237 	 4 ptrain fixed bin (14),			/* print train number */
  8   238 	 4 nmods bit (3),				/* not used in Multics */
  8   239 	 4 pad4 bit (3),
  8   240 	 4 den_cap bit (4),				/* density capability for tapes */
  8   241 	 4 pad5 bit (11)) unaligned,
  8   242        2 crcst,					/* controller sct */
  8   243          (3 pad1 bit (1),
  8   244          3 volatile bit (1),				/* reloadable firmware */
  8   245          3 mpc bit (1),				/* = "1"b if mpc */
  8   246          3 pad2 bit (4),
  8   247          3 ms500 bit (1),				/* = "1"b if mss500 device */
  8   248          3 mtp610 bit (1),				/* = "1"b if mtp 610 device */
  8   249          3 pad3 bit (27)) unaligned,
  8   250        2 dev_firm (4),				/* storage for device firmware edit names */
  8   251          3 edit_name char (4),			/* for urmpc firmware */
  8   252          3 mask bit (36),				/* port mask for this firmware */
  8   253        2 devsct,					/* 2 word device sct entry */
  8   254 	 (3 w1,					/* device sct word 1 */
  8   255 	 4 type_code bit (6),			/* gcos 3 type code (see dd14 app. a) */
  8   256 	 4 device_no bit (6),			/* device number */
  8   257 	 4 com_prph bit (1),			/* = "1"b if common perph. device */
  8   258 	 4 hi_speed bit (1),			/* = "1"b if hi speed printer */
  8   259 	 4 ll160 bit (1),				/* = "1"b if 160 collum printer */
  8   260 	 4 pad1 bit (2),
  8   261 	 4 cr501_pr54 bit (1),			/* either a cr501 or pr54 device */
  8   262 	 4 icc bit (11),				/* iom and channel (true channel index) */
  8   263 	 4 pad2 bit (7),
  8   264          3 w2,					/* device sct word 2 */
  8   265 	 4 ptrain fixed bin (14),			/* print train number */
  8   266 	 4 nmods bit (3),				/* not used in Multics */
  8   267 	 4 pad4 bit (3),
  8   268 	 4 den_cap bit (4),				/* density capability for tapes */
  8   269 	 4 pad5 bit (11)) unaligned,
  8   270        2 icivlu,					/* ic and i for courtesy call on io completion */
  8   271          3 ic bit (18) unaligned,			/* instruction counter */
  8   272          3 ind bit (18) unaligned,			/* indicator register */
  8   273        2 sct_info,
  8   274          (3 cntsct bit (18),				/* unchanged from before */
  8   275          3 ioc_type bit (4),				/* 0 = IOM, 1 = IMU, 2 = IOX */
  8   276          3 cnt_type bit (4),				/* 0 = MPC, 1 = DAU, 2 = EURC, 3 = FIPS */
  8   277          3 pad1 bit (1),
  8   278          3 xioc_type bit (4),				/* not used in Multics */
  8   279          3 xcnt_type bit (4),				/* not used in Multics */
  8   280          3 pad2 bit (1)) unaligned,
  8   281        2 test_req aligned,
  8   282          (3 fnccss bit (18),
  8   283          3 tt bit (6),
  8   284          3 pad1 bit (6)) unaligned;
  8   285 
  8   286 
  8   287 dcl  1 colts_info aligned based (colts_info_ptr),
  8   288        2 cdt_name char (32),
  8   289        2 chanp pointer,				/* iox pointer to chan under test */
  8   290        2 dm_arg aligned like dial_manager_arg,
  8   291        2 fnp_num fixed bin (4),
  8   292        2 in_use bit (1) unaligned init ("0"b),
  8   293        2 status_word bit (36) aligned init ("0"b),
  8   294        2 type_code bit (6) unaligned init ("0"b);
  8   295 
  8   296 
  8   297 
  8   298 
  9     1 /* BEGIN INCLUDE FILE ... dial_manager_arg.incl.pl1 */
  9     2 
  9     3 /* Modified by E. N. Kittlitz 11/80 to add reservation string, move dial-out
  9     4*   destination from dial_qualifier, add dial_message.
  9     5*   Modified by Robert Coren 4/83 to add required access class stuff.
  9     6*   Modified 1984-08-27 BIM for V4, privileged_operation.
  9     7**/
  9     8 
  9     9 
  9    10 dcl  dial_manager_arg_version_2 fixed bin internal static initial (2) options (constant);
  9    11 dcl  dial_manager_arg_version_3 fixed bin internal static initial (3) options (constant);
  9    12 dcl  dial_manager_arg_version_4 fixed bin internal static initial (4) options (constant);
  9    13 
  9    14 dcl 1 dial_manager_arg based aligned,
  9    15     2 version fixed bin,				/* = 4 */
  9    16     2 dial_qualifier char (22),			/* identify different processes with same process group id */
  9    17     2 dial_channel fixed bin (71),			/* event wait channel */
  9    18     2 channel_name char (32),				/* channel name for privileged attach */
  9    19 						/* limit of version 1 structure */
  9    20     2 dial_out_destination char (32),			/* dial-out destination (e.g. phone_no) */
  9    21     2 reservation_string char (256),			/* reservation string */
  9    22     2 dial_message fixed bin (71),			/* OUTPUT: A.S. message received by dial_manager_ */
  9    23 						/* limit of version 2 structure */
  9    24     2 access_class bit (72),				/* access class to be associated with the attachment */
  9    25     2 flags aligned,
  9    26      3 access_class_required bit (1) unaligned,		/* indicates whether to enforce access_class */
  9    27      3 privileged_operation bit (1) unaligned,		/* for accept_dials, accepts dials from */
  9    28 						/* system_low:access_class */
  9    29 						/* no effect on other operations yet. */
  9    30      3 mbz bit (34) unaligned;			/* must be zero */
  9    31 
  9    32 /* END INCLUDE FILE ... dial_manager_arg.incl.pl1 */
  8   299 
  8   300 
  8   301 
  8   302 
  8   303 
  8   304 /* END INCLUDE FILE tolts_info.incl.pl1  */
      467 
      468 
 10     1 
 10     2 
 10     3 /* BEGIN INCLUDE FILE tolts_workspace.incl.pl1 */
 10     4 
 10     5 /* created 10/6/78 by J. A. Bush to define the ioi workspace as used by TOLTS 
 10     6*   Modified b R. Fakoury 8106 & 8201 to increase dcw_list size for mtar linked io.
 10     7*  Modified by R. Fakoury 8206 to force the data buffer to an even location for eurc itr test 1.
 10     8*  Modified by R. Fakoury 7/83 to increase the dcw_list size for mtar perm file track repair.
 10     9**/
 10    10 
 10    11 dcl  ioi_wksp ptr;					/* ptr to workspace */
 10    12 
 10    13 dcl 1 tolts_workspace based (ioi_wksp) aligned,
 10    14     2 status,					/* ioi status structure */
 10    15       3 completion,					/* completion flags */
 10    16        (4 st bit (1),				/* "1"b if status returned */
 10    17         4 er bit (1),				/* "1"b if status indicates error */
 10    18         4 run bit (1),				/* "1"b if channel still running */
 10    19         4 timeout bit (1)) unaligned,			/* "1"b if io timeout */
 10    20       3 level fixed bin (3),				/* IOM interrupt level */
 10    21       3 offset fixed bin (18),			/* dcw list offset for connect */
 10    22       3 absaddr fixed bin (24),			/* absolute address of workspace */
 10    23       3 iom_status bit (72),				/* IOM status storage */
 10    24       3 lpw (2) bit (36),				/* LPW residue */
 10    25     2 buf_size fixed bin,				/* current length of data buffer */
 10    26     2 seek_add bit (36),				/* seek address for disk I/O */
 10    27     2 seek_idcw bit (36),				/* seek idcw for disk I/O */
 10    28     2 seek_dcw bit (36),				/* seek dcw for disk I/O */
 10    29     2 p_idcw bit (36),				/* primary idcw, secondary for disk I/O */
 10    30     2 dcw_list (330) bit (36),			/* test page dcw list */
 10    31     2 pad bit (36),					/* force the buffer to begin on an even address */
 10    32     2 l_pad,					/* pad area of lower buffer */
 10    33       3 e bit (36),
 10    34       3 o bit (36),
 10    35     2 data_buf (buf_size) fixed bin (35),		/* data buffer */
 10    36     2 h_pad,					/* pad area of upper buffer */
 10    37       3 e bit (36),
 10    38       3 o bit (36);
 10    39 
 10    40 dcl  wks_init char (165 * 4) based (ioi_wksp);		/* used to initialize control word area of ioiworkspace */
 10    41 
 10    42 /* END INCLUDE FILE tolts_workspace.incl.pl1 */
 10    43 
      469 
      470 
      471 
      472    end tolts_load_firmware_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/09/86  1520.9  tolts_load_firmware_.pl1          >special_ldd>install>MR12.0-1235>tolts_load_firmware_.pl1
459          1    05/23/79  1612.1  gload_data.incl.pl1               >ldd>include>gload_data.incl.pl1
461          2    01/10/75  1343.6  iom_stat.incl.pl1                 >ldd>include>iom_stat.incl.pl1
463          3    09/18/86  1317.5  mca_data_area.incl.pl1            >ldd>include>mca_data_area.incl.pl1
3-88         4    11/12/74  1550.1  iom_dcw.incl.pl1                  >ldd>include>iom_dcw.incl.pl1
3-90         5    05/06/74  1742.1  iom_pcw.incl.pl1                  >ldd>include>iom_pcw.incl.pl1
3-92         6    08/17/79  2215.0  ioi_stat.incl.pl1                 >ldd>include>ioi_stat.incl.pl1
465          7    06/09/83  1430.8  opr_query_info.incl.pl1           >ldd>include>opr_query_info.incl.pl1
467          8    12/09/86  1521.3  tolts_info.incl.pl1               >special_ldd>install>MR12.0-1235>tolts_info.incl.pl1
8-299        9    09/13/84  0921.5  dial_manager_arg.incl.pl1         >ldd>include>dial_manager_arg.incl.pl1
469         10    10/11/83  1240.7  tolts_workspace.incl.pl1          >ldd>include>tolts_workspace.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_error                                parameter       fixed bin(35,0)          dcl 40 set ref 34 105* 116* 123*
add_val                                parameter       fixed bin(16,0)          dcl 447 ref 444 449
addr                                                   builtin function         dcl 100 ref 106 109 110 111 178 178 214 227 227 227
                                                                                  227 252 252 252 252 273 273 273 273 290 344 344
                                                                                  348 348 348 348 366 367 371 373 429 429
addrel                                                 builtin function         dcl 100 ref 183 397
address                                based           bit(18)                  level 2 packed unaligned dcl 4-7 set ref 373* 399*
                                                                                  399
b_off                                  parameter       fixed bin(17,0)          dcl 412 ref 410 417
bin                                                    builtin function         dcl 100 ref 366 399 399 403 421 421 422 422
bit                                                    builtin function         dcl 100 ref 399 403
buf_off                                parameter       fixed bin(17,0)          dcl 312 set ref 309 316 317*
buf_size                 10            based           fixed bin(17,0)          level 2 dcl 10-13 set ref 404*
buffer                                 based           bit(36)                  array unaligned dcl 95 set ref 147* 419*
c_len                           000105 automatic       fixed bin(17,0)          dcl 59 set ref 170* 340* 344 344 346 346
cat_name                 41            based           char(10)                 level 2 dcl 8-155 ref 247
cata                                   based           structure                level 1 dcl 79
catp                    142            based           pointer                  level 2 dcl 8-155 ref 112 112 137 138 170 172 180
                                                                                  340 340 340 340 340 340 431 431 431 431
catx                            000100 automatic       fixed bin(17,0)          dcl 59 set ref 112* 112* 134 137* 138* 170 172 180
                                                                                  340 340 340 340 340 340 431 431 431 431
central_stat              0(21)        based           bit(3)                   level 2 packed unaligned dcl 2-7 ref 297
chan_cmd                  0(24)        based           bit(6)                   level 2 packed unaligned dcl 5-21 set ref 146* 217*
chan_suspended          146            based           bit(1)                   level 2 dcl 8-155 set ref 160*
channel_stat              0(18)        based           bit(3)                   level 2 packed unaligned dcl 2-7 ref 297
ck_bit                                 based           bit(36)                  unaligned dcl 415 ref 429 429
ck_sum                          001242 automatic       fixed bin(35,0)          initial dcl 414 set ref 414* 421* 422* 427* 427 429
                                                                                  429
code                      0(18)        based           bit(3)                   level 2 packed unaligned dcl 5-21 set ref 216* 370*
colts_info                             based           structure                level 1 dcl 8-287
com_err_$convert_status_code_   000052 constant        entry                    external dcl 55 ref 206
command                                based           bit(6)                   level 2 packed unaligned dcl 5-21 set ref 144* 369*
completion                4            based           structure                level 3 in structure "mca_work_space" packed
                                                                                  unaligned dcl 3-25 in procedure
                                                                                  "tolts_load_firmware_"
completion                             based           structure                level 2 in structure "istat" dcl 6-7 in procedure
                                                                                  "tolts_load_firmware_"
completion                             based           structure                level 3 in structure "tolts_workspace" dcl 10-13
                                                                                  in procedure "tolts_load_firmware_"
csl                             000107 automatic       fixed bin(17,0)          dcl 59 set ref 187* 191* 316 317*
css                             000106 automatic       fixed bin(17,0)          dcl 59 set ref 184* 316 317*
cur_wks_sz              151            based           fixed bin(17,0)          level 2 dcl 8-155 set ref 378 386 386* 388* 388 389*
cxs                             000101 automatic       fixed bin(17,0)          dcl 59 set ref 134* 137
data_buf                532            based           fixed bin(35,0)          array level 2 dcl 10-13 set ref 111 366 373
data_header                            based           structure                level 1 dcl 3-35
data_size_1                     001056 automatic       fixed bin(21,0)          initial dcl 3-17 set ref 3-17*
data_size_2                     001057 automatic       fixed bin(21,0)          initial dcl 3-17 set ref 3-17*
dcw                                    based           structure                level 1 dcl 4-7 set ref 372* 398*
dcw_list                 15            based           bit(36)                  array level 2 dcl 10-13 set ref 371
dcwp                            001060 automatic       pointer                  dcl 4-4 set ref 371* 372 373 376 377 396 397* 397
                                                                                  398 399 402 403
dev_firm               2151            based           structure                array level 2 dcl 8-155
device                    0(06)        based           bit(6)                   level 2 packed unaligned dcl 5-21 set ref 145*
device_index            665            based           fixed bin(12,0)          level 2 dcl 8-155 set ref 155* 219* 265* 389*
df_iocbp                  2            based           pointer                  level 2 dcl 8-75 set ref 170*
diagnostic                3     000166 automatic       char(200)                level 2 packed unaligned dcl 1-5 set ref 180
dial_manager_arg                       based           structure                level 1 dcl 9-14
dleft                           001232 automatic       fixed bin(17,0)          dcl 363 set ref 374* 375 400* 400 403
dlen                                   parameter       fixed bin(17,0)          dcl 363 set ref 360 374 378 378 381* 404
ecode                                  parameter       fixed bin(35,0)          dcl 203 set ref 201 206*
edit_name              2151            based           char(4)                  array level 3 dcl 8-155 ref 138
err                             000114 automatic       bit(1)                   unaligned dcl 62 set ref 121* 122 128* 129 142* 143
err_bit                                parameter       bit(1)                   unaligned dcl 326 in procedure "copy_rw" set ref 324
                                                                                  328* 330* 331 331*
err_bit                                parameter       bit(1)                   unaligned dcl 311 in procedure "copy_cs" set ref 309
                                                                                  314* 316* 317 317*
err_bit                                parameter       bit(1)                   unaligned dcl 364 in procedure "make_dcw" set ref
                                                                                  360 380* 392*
err_bit                                parameter       bit(1)                   unaligned dcl 413 in procedure "copy" set ref 410
                                                                                  434*
error                           000113 automatic       fixed bin(35,0)          dcl 61 set ref 115 116 120 127 131 141 149 155* 156
                                                                                  157* 170* 171 172* 178* 179 180* 219* 220 221*
                                                                                  227* 228 229* 235* 242* 243 244* 252* 253 254*
                                                                                  265* 266 267* 273* 274 275* 282* 287* 294* 301*
                                                                                  348* 349 350* 389* 390 391*
error_table_$action_not_performed
                                000054 external static fixed bin(35,0)          dcl 101 ref 123 235 282 287 294 301
event_out                       000010 internal static structure                level 1 unaligned dcl 70 set ref 227 227 252 252 273
                                                                                  273 348 348
exec                      6            based           char(4)                  level 2 dcl 8-75 set ref 207* 340*
f_wd                                   based           bit(36)                  array unaligned dcl 96 ref 419 421 421 421 421 422
                                                                                  422 422 422 429
finish_cond              16            based           bit(1)                   level 2 dcl 8-75 ref 345
firm_buf              52762            based           fixed bin(17,0)          array level 2 dcl 8-75 set ref 110
fixed                                                  builtin function         dcl 100 ref 109 183 187 192
gewake_active            21            based           bit(1)                   level 2 dcl 8-75 set ref 250* 251
gewake_event             22            based           fixed bin(71,0)          level 2 dcl 8-75 set ref 241* 242* 247* 249*
gload_                          000046 constant        entry                    external dcl 53 ref 178
gload_data                      000166 automatic       structure                level 1 dcl 1-5 set ref 178 178
glob_int_cnt             24            based           fixed bin(17,0)          level 2 dcl 8-75 set ref 224* 224 270* 270
i                               000102 automatic       fixed bin(17,0)          dcl 59 set ref 418* 419 420 421 421 421 421 422 422
                                                                                  422 422*
id_blk                                 based           structure                level 1 dcl 83
idbp                            000122 automatic       pointer                  dcl 63 set ref 183* 185
idcw                                   based           structure                level 1 dcl 5-21 set ref 215* 368*
idcwp                           001064 automatic       pointer                  dcl 5-19 set ref 144 145 146 214* 215 216 217 367*
                                                                                  368 369 370
index                                                  builtin function         dcl 100 ref 112
io_in_progress          701            based           bit(1)                   level 2 dcl 8-155 set ref 225* 226 271* 272
io_info                                based           structure                level 1 dcl 8-155
io_info_ptr                     001142 automatic       pointer                  dcl 8-73 set ref 106* 107 108 112 112 133 135 137
                                                                                  138 138 147 155 160 170 172 180 219 225 226 234
                                                                                  247 265 271 272 280 286 292 298 340 340 340 340
                                                                                  340 340 340 378 381 386 386 388 388 389 389 431
                                                                                  431 431 431 431
io_parameter_block                     based           structure                level 1 packed unaligned dcl 3-50
io_type                 703            based           fixed bin(17,0)          level 2 dcl 8-155 set ref 107*
ioa_$rsnnl                      000032 constant        entry                    external dcl 49 ref 340
ioi_$connect_pcw                000020 constant        entry                    external dcl 44 ref 219 265
ioi_$release_devices            000022 constant        entry                    external dcl 45 ref 155
ioi_$workspace                  000024 constant        entry                    external dcl 46 ref 389
ioi_wksp                        001144 automatic       pointer                  dcl 10-11 set ref 108* 109 111 214 233 233 279 280
                                                                                  285 290 298 298 298 298 366 367 371 373 389* 404
iom_status                4            based           bit(72)                  level 3 dcl 10-13 set ref 290 298 298 298 298
ipc_$block                      000026 constant        entry                    external dcl 47 ref 227 252 273 348
ipc_$drain_chn                  000030 constant        entry                    external dcl 48 ref 242
ipcw                            000001 constant        bit(36)                  initial unaligned dcl 102 set ref 219*
istat                                  based           structure                level 1 dcl 6-7
j                               000103 automatic       fixed bin(17,0)          dcl 59 set ref 417* 419 424* 424
key                       1            based           char(24)                 array level 2 dcl 79 ref 112 138 170 172 180 340 340
                                                                                  340 340 340 340 431 431 431 431
l                               000104 automatic       fixed bin(17,0)          dcl 59 set ref 135* 138 147*
l_ptr                           000120 automatic       pointer                  dcl 63 set ref 110* 178* 183 419 421 421 421 421 422
                                                                                  422 422 422 429
level                     1            based           fixed bin(3,0)           level 3 dcl 10-13 set ref 233 279 280*
longinfo                        000135 automatic       char(100)                unaligned dcl 66 set ref 206* 207* 340* 344 344 346
                                                                                  346
major                     0(02)        based           bit(4)                   level 2 packed unaligned dcl 2-7 ref 297
mask                   2152            based           bit(36)                  array level 3 dcl 8-155 ref 147
max_wks_sz              104            based           fixed bin(19,0)          level 2 dcl 8-75 set ref 378 381* 386 386
mca_dcw_list                           based           structure                level 1 packed unaligned dcl 3-81
mess                                   parameter       char                     unaligned dcl 204 set ref 201 207*
mpc_dev_cnt            2050            based           fixed bin(17,0)          level 2 dcl 8-155 ref 133 135
n                                      based           fixed bin(17,0)          level 2 dcl 79 ref 112 137
op_code                                parameter       bit(6)                   unaligned dcl 362 ref 360 369
opr_query_                      000036 constant        entry                    external dcl 49 ref 344
opr_query_info                  001066 automatic       structure                level 1 dcl 7-8 set ref 344 344
ov_name                         000130 automatic       char(17)                 unaligned dcl 65 set ref 315* 329* 381* 431*
ovh                             001233 automatic       fixed bin(17,0)          dcl 363 set ref 366* 378 378
p_idcw                   14            based           bit(36)                  level 2 dcl 10-13 set ref 109 214 367
pages                 31102            based           structure                array level 2 dcl 8-75 set ref 106
pcwa                            000000 constant        bit(36)                  initial unaligned dcl 103 set ref 265*
power                     0(01)        based           bit(1)                   level 2 packed unaligned dcl 2-7 ref 291
px                                     parameter       fixed bin(17,0)          dcl 39 ref 34 106
q_sw                      1     001066 automatic       bit(1)                   level 2 dcl 7-8 set ref 343*
rel                                                    builtin function         dcl 100 ref 109 366 373
rw_start                  4            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 83 ref 185
rwl                             000111 automatic       fixed bin(17,0)          dcl 59 set ref 188* 192* 330* 331
rws                             000110 automatic       fixed bin(17,0)          dcl 59 set ref 185* 186 191 192 193* 193 331* 331
shortinfo                       000126 automatic       char(8)                  unaligned dcl 64 set ref 206*
start                                  parameter       fixed bin(17,0)          dcl 412 ref 410 418
statp                           001054 automatic       pointer                  dcl 2-5 set ref 290* 291 297 297 297 297
status                                 based           structure                level 2 in structure "tolts_workspace" dcl 10-13
                                                                                  in procedure "tolts_load_firmware_"
status                                 based           structure                level 1 dcl 2-7 in procedure "tolts_load_firmware_"
stop                                   parameter       fixed bin(17,0)          dcl 412 ref 410 418 420 429
string                                                 builtin function         dcl 100 set ref 215* 368* 372* 398*
sub                       0(06)        based           bit(6)                   level 2 packed unaligned dcl 2-7 ref 297
substr                                                 builtin function         dcl 100 ref 138 298 298 298 298 340 340 340 340 340
                                                                                  340 344 344 346 346 421 421 421 421 422 422 422
                                                                                  422 429 429 429 431 431 431 431
sum                                    parameter       fixed bin(35,0)          dcl 446 set ref 444 449* 449 450 451* 451 452* 452
t_ptr                           000116 automatic       pointer                  dcl 63 set ref 170* 178*
tally                     0(24)        based           bit(12)                  level 2 packed unaligned dcl 4-7 set ref 377* 403*
tdcwp                           001062 automatic       pointer                  dcl 4-4 set ref 396* 399
term                            000115 automatic       bit(1)                   unaligned dcl 62 set ref 136* 137 139*
term_io_req_cnt         134            based           fixed bin(17,0)          level 2 dcl 8-75 ref 347
test_hdr               2136            based           char(16)                 level 2 dcl 8-155 set ref 234* 280* 286* 292* 298*
                                                                                  340* 381* 431*
text_len                  1(18) 000166 automatic       bit(18)                  level 2 packed unaligned dcl 1-5 set ref 183 187 192
timeout                   0(03)        based           bit(1)                   level 4 packed unaligned dcl 10-13 ref 233 285
timer_manager_$alarm_wakeup     000040 constant        entry                    external dcl 50 ref 247 249
timer_manager_$reset_alarm_wakeup
                                000042 constant        entry                    external dcl 51 ref 241
tio_off                         000112 automatic       fixed bin(18,0)          dcl 60 set ref 109* 219* 265*
tolts_info                             based           structure                level 1 dcl 8-75
tolts_infop                     000056 external static pointer                  dcl 8-71 ref 106 110 170 207 224 224 227 227 241 242
                                                                                  247 249 250 251 252 252 270 270 273 273 340 345
                                                                                  347 348 348 378 381 386 386
tolts_qttyio_                   000050 constant        entry                    external dcl 54 ref 346
tolts_qttyio_$rs                000034 constant        entry                    external dcl 49 ref 207 234 280 286 292 298 381 431
tolts_util_$search              000044 constant        entry                    external dcl 52 ref 170
tolts_workspace                        based           structure                level 1 dcl 10-13
top                             000124 automatic       pointer                  dcl 63 set ref 111* 147 419
type                      0(22)        based           bit(2)                   level 2 packed unaligned dcl 4-7 set ref 376* 402*
wait_list               522            based           structure                level 2 dcl 8-75 set ref 227 227 252 252 273 273 348
                                                                                  348
workspace_ptr          2144            based           pointer                  level 2 dcl 8-155 ref 108

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABORT_SES_FROM_HOST                    internal static fixed bin(9,0)           initial unsigned dcl 3-114
BIN_DATA_FROM_HOST                     internal static fixed bin(9,0)           initial unsigned dcl 3-112
CON_DATA_FROM_HOST                     internal static fixed bin(9,0)           initial unsigned dcl 3-110
DATA_FROM_HOST                         internal static fixed bin(9,0)           initial unsigned dcl 3-96
DATA_FROM_MCA                          internal static fixed bin(9,0)           initial unsigned dcl 3-102
REQ_DATA_FROM_HOST                     internal static fixed bin(9,0)           initial unsigned dcl 3-104
SEEK                                   internal static fixed bin(9,0)           initial unsigned dcl 3-108
STATUS_FROM_MCA                        internal static fixed bin(9,0)           initial unsigned dcl 3-106
WRITE_CONSOLE                          internal static fixed bin(9,0)           initial unsigned dcl 3-98
WRITE_READ_CONSOLE                     internal static fixed bin(9,0)           initial unsigned dcl 3-100
colts_info_ptr                         automatic       pointer                  dcl 8-72
data_header_ptr                        automatic       pointer                  dcl 3-15
dial_manager_arg_version_2             internal static fixed bin(17,0)          initial dcl 9-10
dial_manager_arg_version_3             internal static fixed bin(17,0)          initial dcl 9-11
dial_manager_arg_version_4             internal static fixed bin(17,0)          initial dcl 9-12
dmap                                   automatic       pointer                  dcl 8-74
faultword                              based           structure                level 1 dcl 2-27
firm_ld_io_type                        internal static fixed bin(17,0)          initial dcl 8-63
imess                                  based           structure                level 1 dcl 6-21
imp                                    automatic       pointer                  dcl 6-19
io_param_blk_ptr                       automatic       pointer                  dcl 3-19
isp                                    automatic       pointer                  dcl 6-5
itr_io_type                            internal static fixed bin(17,0)          initial dcl 8-60
mca_dcw_list_ptr                       automatic       pointer                  dcl 3-21
mca_io_type                            internal static fixed bin(17,0)          initial dcl 8-68
mca_work_space                         based           structure                level 1 unaligned dcl 3-25
mca_work_space_ptr                     automatic       pointer                  dcl 3-23
mdc_io_type                            internal static fixed bin(17,0)          initial dcl 8-66
mdr_io_type                            internal static fixed bin(17,0)          initial dcl 8-61
mhp_io_type                            internal static fixed bin(17,0)          initial dcl 8-67
mtar_io_type                           internal static fixed bin(17,0)          initial dcl 8-62
mtc_io_type                            internal static fixed bin(17,0)          initial dcl 8-64
mtg_io_type                            internal static fixed bin(17,0)          initial dcl 8-65
pcw                                    based           structure                level 1 dcl 5-6
pcwp                                   automatic       pointer                  dcl 5-4
polt_io_type                           internal static fixed bin(17,0)          initial dcl 8-59
rspd_io_type                           internal static fixed bin(17,0)          initial dcl 8-69
special_status                         based           structure                level 1 dcl 2-35
tdcw                                   based           structure                level 1 dcl 4-14
wks_init                               based           char(660)                unaligned dcl 10-40

NAMES DECLARED BY EXPLICIT CONTEXT.
carry                           003013 constant        label                    dcl 450 ref 453
ch_add                          003005 constant        entry                    internal dcl 444 ref 421 422
copy                            002573 constant        entry                    internal dcl 410 ref 317 331
copy_cs                         001775 constant        entry                    internal dcl 309 ref 121 142
copy_rw                         002053 constant        entry                    internal dcl 324 ref 128
dc_reset                        001135 constant        entry                    internal dcl 212 ref 119
err_1                           000453 constant        label                    dcl 116 ref 120 127 131 141 149 158
err_2                           000470 constant        label                    dcl 123 ref 129 143
fw_load                         000652 constant        entry                    internal dcl 166 ref 114 140
fw_load_mess                    002131 constant        entry                    internal dcl 338 ref 132 150
make_dcw                        002350 constant        entry                    internal dcl 360 ref 316 330
output_status_code              001036 constant        entry                    internal dcl 201 ref 157 172 180 221 229 244 254 267
                                                                                  275 350 391
run_dcw                         001455 constant        entry                    internal dcl 263 ref 126 130 148
tolts_load_firmware_            000361 constant        entry                    external dcl 34

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3460        3540    3236        3470
Length      4176    3236        60         422     222          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tolts_load_firmware_               1138 external procedure  is an external procedure.  
fw_load                                 internal procedure  shares stack frame of external procedure tolts_load_firmware_.  
output_status_code                      internal procedure  shares stack frame of external procedure tolts_load_firmware_.  
dc_reset                                internal procedure  shares stack frame of external procedure tolts_load_firmware_.  
run_dcw                                 internal procedure  shares stack frame of external procedure tolts_load_firmware_.  
copy_cs                                 internal procedure  shares stack frame of external procedure tolts_load_firmware_.  
copy_rw                                 internal procedure  shares stack frame of external procedure tolts_load_firmware_.  
fw_load_mess                            internal procedure  shares stack frame of external procedure tolts_load_firmware_.  
make_dcw                                internal procedure  shares stack frame of external procedure tolts_load_firmware_.  
copy                                    internal procedure  shares stack frame of external procedure tolts_load_firmware_.  
ch_add                                  internal procedure  shares stack frame of external procedure tolts_load_firmware_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 event_out                   tolts_load_firmware_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
tolts_load_firmware_     000100 catx                        tolts_load_firmware_
                         000101 cxs                         tolts_load_firmware_
                         000102 i                           tolts_load_firmware_
                         000103 j                           tolts_load_firmware_
                         000104 l                           tolts_load_firmware_
                         000105 c_len                       tolts_load_firmware_
                         000106 css                         tolts_load_firmware_
                         000107 csl                         tolts_load_firmware_
                         000110 rws                         tolts_load_firmware_
                         000111 rwl                         tolts_load_firmware_
                         000112 tio_off                     tolts_load_firmware_
                         000113 error                       tolts_load_firmware_
                         000114 err                         tolts_load_firmware_
                         000115 term                        tolts_load_firmware_
                         000116 t_ptr                       tolts_load_firmware_
                         000120 l_ptr                       tolts_load_firmware_
                         000122 idbp                        tolts_load_firmware_
                         000124 top                         tolts_load_firmware_
                         000126 shortinfo                   tolts_load_firmware_
                         000130 ov_name                     tolts_load_firmware_
                         000135 longinfo                    tolts_load_firmware_
                         000166 gload_data                  tolts_load_firmware_
                         001054 statp                       tolts_load_firmware_
                         001056 data_size_1                 tolts_load_firmware_
                         001057 data_size_2                 tolts_load_firmware_
                         001060 dcwp                        tolts_load_firmware_
                         001062 tdcwp                       tolts_load_firmware_
                         001064 idcwp                       tolts_load_firmware_
                         001066 opr_query_info              tolts_load_firmware_
                         001142 io_info_ptr                 tolts_load_firmware_
                         001144 ioi_wksp                    tolts_load_firmware_
                         001232 dleft                       make_dcw
                         001233 ovh                         make_dcw
                         001242 ck_sum                      copy

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_$convert_status_code_ gload_                        ioa_$rsnnl                    ioi_$connect_pcw
ioi_$release_devices          ioi_$workspace                ipc_$block                    ipc_$drain_chn
opr_query_                    timer_manager_$alarm_wakeup   timer_manager_$reset_alarm_wakeup
tolts_qttyio_                 tolts_qttyio_$rs              tolts_util_$search

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           tolts_infop




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     34 000355    3   17 000366       105 000370       106 000372       107 000400       108 000402       109 000404
    110 000410       111 000415       112 000417       113 000446       114 000450       115 000451       116 000453
    117 000456       119 000457       120 000460       121 000462       122 000465       123 000470       124 000474
    126 000475       127 000476       128 000500       129 000502       130 000505       131 000506       132 000510
    133 000511       134 000514       135 000517       136 000527       137 000530       138 000543       139 000557
    140 000561       141 000562       142 000564       143 000570       144 000573       145 000576       146 000601
    147 000604       148 000614       149 000615       150 000617       152 000620       153 000622       155 000624
    156 000636       157 000640       158 000646       160 000647       161 000651       166 000652       170 000653
    171 000705       172 000707       173 000724       178 000725       179 000747       180 000751       181 000776
    183 001000       184 001011       185 001014       186 001017       187 001020       188 001022       189 001023
    191 001024       192 001025       193 001034       196 001035       201 001036       206 001047       207 001071
    208 001134       212 001135       214 001136       215 001141       216 001142       217 001144       219 001146
    220 001164       221 001166       222 001174       224 001175       225 001201       226 001204       227 001207
    228 001230       229 001232       230 001240       232 001241       233 001242       234 001251       235 001276
    236 001301       241 001302       242 001313       243 001326       244 001330       245 001336       247 001337
    249 001366       250 001407       251 001414       252 001421       253 001437       254 001441       255 001452
    257 001453       259 001454       263 001455       265 001456       266 001474       267 001476       268 001504
    270 001505       271 001511       272 001514       273 001517       274 001540       275 001542       276 001550
    278 001551       279 001552       280 001556       282 001607       283 001612       285 001613       286 001616
    287 001643       288 001646       290 001647       291 001651       292 001654       294 001701       295 001704
    297 001705       298 001730       301 001770       302 001773       305 001774       309 001775       314 001777
    315 002003       316 002006       317 002030       320 002052       324 002053       328 002055       329 002061
    330 002064       331 002101       334 002130       338 002131       340 002132       343 002230       344 002231
    345 002257       346 002265       347 002311       348 002317       349 002335       350 002337       351 002345
    353 002346       356 002347       360 002350       366 002352       367 002360       368 002363       369 002364
    370 002370       371 002372       372 002375       373 002376       374 002400       375 002402       376 002405
    377 002411       378 002413       380 002426       381 002432       383 002472       386 002473       388 002502
    389 002504       390 002520       391 002522       392 002530       393 002535       396 002536       397 002540
    398 002542       399 002543       400 002553       401 002555       402 002556       403 002560       404 002566
    406 002572       410 002573       414 002575       417 002576       418 002601       419 002611       420 002621
    421 002624       422 002643       424 002663       425 002664       427 002666       429 002670       431 002717
    434 002777       437 003004       444 003005       449 003007       450 003013       451 003017       452 003025
    453 003031       455 003032


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
