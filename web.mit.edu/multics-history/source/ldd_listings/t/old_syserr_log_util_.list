	COMPILATION LISTING OF SEGMENT old_syserr_log_util_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/25/85  0847.0 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *						 *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *						 *
        5*   * Copyright (c) 1972 by Massachusetts Institute of	 *
        6*   * Technology and Honeywell Information Systems, Inc.	 *
        7*   *						 *
        8*   *********************************************************** */
        9 
       10 
       11 /* SYSERR_LOG_UTIL_ - Procedure to search and read the "syserr log" composed of a ring 4 vfile_ in >system_control_1
       12*   and a ring 0 threaded list */
       13 
       14 /* Written late 1975 by Lee Scheffler */
       15 /* Modified January 1976 by Larry Johnson to fix some bugs */
       16 /* Modified April 1976 by Larry Johnson to fix some bugs */
       17 /* Modified October 1982 by E. N. Kittlitz to add open_path, trim_path */
       18 /* 84-10-04, WOS: Converted to old_syserr_log_util_ for new logging migration */
       19 
       20 /* format: style4 */
       21 old_syserr_log_util_: proc ();
       22 
       23 /* Entries */
       24 
       25 dcl  absolute_pathname_ entry (char (*), char (*), fixed bin (35));
       26 dcl  audit_gate_$copy_syserr_log entry (bit (18) aligned, pointer, fixed bin (24), fixed bin (24));
       27 dcl  delete_$path entry (char (*), char (*), bit (6), char (*), fixed bin (35));
       28 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
       29 dcl  get_pdir_ entry () returns (char (168));
       30 dcl  get_temp_segments_ entry (char (*), dim (*) ptr, fixed bin (35));
       31 dcl  release_temp_segments_ entry (char (*), dim (*) ptr, fixed bin (35));
       32 dcl  hcs_$set_safety_sw entry (char (*), char (*), bit (1), fixed bin (35));
       33 dcl  iox_$attach_ioname entry (char (*), pointer, char (*), fixed bin (35));
       34 dcl  iox_$close entry (pointer, fixed bin (35));
       35 dcl  iox_$control entry (pointer, char (*), pointer, fixed bin (35));
       36 dcl  iox_$delete_record entry (pointer, fixed bin (35));
       37 dcl  iox_$detach_iocb entry (pointer, fixed bin (35));
       38 dcl  iox_$find_iocb entry (char (*), pointer, fixed bin (35));
       39 dcl  iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35));
       40 dcl  iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35));
       41 dcl  iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35));
       42 dcl  iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35));
       43 dcl  iox_$seek_key entry (pointer, char (256) varying, fixed bin, fixed bin (35));
       44 dcl  iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35));
       45 dcl  pathname_ entry (char (*), char (*)) returns (char (168));
       46 dcl  sub_err_ entry () options (variable);
       47 dcl  unique_bits_ entry returns (bit (71));
       48 dcl  unique_chars_ entry (bit (*)) returns (char (15));
       49 
       50 /* Builtin */
       51 
       52 declare  (addr, addrel, bin, divide, fixed, null, ptr, rel, rtrim, substr, unspec) builtin;
       53 
       54 /* Status codes */
       55 
       56 dcl  error_table_$bad_arg fixed bin (35) external;
       57 dcl  error_table_$end_of_info fixed bin (35) external;
       58 dcl  error_table_$file_busy fixed bin (35) external;
       59 dcl  error_table_$key_duplication fixed bin (35) external;
       60 dcl  error_table_$key_order fixed bin (35) external;
       61 dcl  error_table_$moderr fixed bin (35) external;
       62 dcl  error_table_$no_record fixed bin (35) external;
       63 dcl  error_table_$not_detached fixed bin (35) external;
       64 dcl  error_table_$not_open fixed bin (35) external;
       65 
       66 /* Constants */
       67 
       68 dcl  R0_VFILE char (13) internal static initial ("r0_syserr_log");
       69 dcl  R0_SW char (13) internal static initial ("r0_syserr_i/o");
       70 dcl  R4_SW char (13) internal static initial ("r4_syserr_i/o");
       71 dcl  R4_PATH char (168) internal static initial (">system_control_1>perm_syserr_log");
       72 dcl  (NO init ("0"b), YES init ("1"b)) bit (1) internal static;
       73 dcl  (KSI initial (8), KSO initial (9), KSU initial (10)) fixed bin internal static; /* Opening modes */
       74 dcl  (EOF initial (+1), BOF initial (-1), SKIP initial (0)) fixed bin internal static; /* For iox_$position */
       75 
       76 
       77 /* Statics */
       78 
       79 dcl  iop (2) pointer internal static initial ((2) null ()); /* iop (1) -> IOCB (r0 log in process dir) */
       80 						/* iop (2) -> IOCB (r4 log in >sc1) */
       81 dcl  curlog fixed bin (2) internal static initial (0);	/* index into iop of log piece
       82*						   containing "current messagee" */
       83 dcl  OPEN bit (1) aligned internal static initial ("0"b);	/* ON iff log is open */
       84 
       85 /* Miscellaneous */
       86 
       87 dcl  r0_vfile char (32) internal static;		/* Unique name of vfile in process dir holding r0 log */
       88 dcl  r0_vpath char (168) varying;			/* Pathnaame of same */
       89 dcl  r4_dir char (168);
       90 dcl  r4_entry char (32);
       91 dcl  r4_path char (168);				/* Pathname of ring 4 perm-syserr-log vfile */
       92 dcl  ec fixed bin (35);				/* Ubiquitous status code */
       93 dcl  log_len fixed bin (24);				/* Length of ring 0 syserr log */
       94 dcl  key char (256) varying;				/* iox_ record key */
       95 dcl  keybits bit (9 * 16);				/* Used to convert fixed bins to char keys */
       96 dcl  keychars char (16) based (addr (keybits));
       97 dcl  (off, nextoff, prevoff) bit (18);			/* Used in searching r0 syserr log */
       98 dcl  time fixed bin (71);				/* Message time */
       99 dcl  linkage_error condition;				/* Signalled when user has no access to r0 log */
      100 dcl  key_dup bit (1) aligned;
      101 dcl  seg_array (1) ptr;				/* array of pointers for temp seg manager */
      102 
      103 /* Entry to attach and open the "syserr log" for searching */
      104 /* This entry first opens the ring 4 syserr log vfile_, creates a virgin temporary vfile_
      105*   in the process directory, copies the ring 0 syserr log into a temp in the process directory,
      106*   copies all messages from the ring 0 log not already in the ring 4 log into the temp vfile,
      107*   then views the two vfiles as one "log" */
      108 
      109 old_syserr_log_util_$open: entry (access, ec);
      110 
      111 dcl  access bit (36) aligned parameter;			/* "1X"b if ring 0 log is available
      112*						   "X1"b if ring 4 log is available */
      113 dcl  r4_ec fixed bin (35);				/* Status code for ring 4 log opening */
      114 
      115 	r4_path = R4_PATH;
      116 	go to open_join;
      117 
      118 old_syserr_log_util_$open_path: entry (a_open_path, access, ec);
      119 
      120 dcl  a_open_path char (*);				/* pathname of perm-syserr-log */
      121 
      122 	r4_path = a_open_path;			/* user tells us where */
      123 	if r4_path = "" then			/* oops, got lazy */
      124 	     r4_path = R4_PATH;			/* use the default */
      125 
      126 open_join:
      127 	OPEN = NO;				/* Let's get one thing straight: WE ARE NOT OPEN YET */
      128 	curlog = 0;				/* Also, we have not yet established our position yet */
      129 	access = "00"b;				/* In case we abort */
      130 	iop (1), iop (2) = null ();			/* Make sure we redo these pointers on every open */
      131 
      132 	call ATTACH_AND_OPEN ((R4_SW), ("vfile_ " || rtrim (r4_path)), iop (2), (KSI), r4_ec); /* Open the ring 4 log for
      133*						   keyed-sequential input, no extension */
      134 	if r4_ec = 0 then access = access | "01"b;	/* Ring 4 log is accessible */
      135 	else do;
      136 	     ec = r4_ec;				/* In case we return now */
      137 	     call CLOSE_AND_DETACH (iop (2), 0);	/* Close it if we did open it */
      138 	     if r4_ec = error_table_$file_busy then return; /* A put-off: user has access, but its busy */
      139 	end;
      140 
      141 get_r0_log:
      142 	slog_ptr = null ();				/* In case of abort */
      143 	r0_vfile = R0_VFILE || "." || unique_chars_ (unique_bits_ ()); /* Get unique name for temp seg */
      144 	r0_vpath = rtrim (get_pdir_ ()) || ">" || r0_vfile;
      145 
      146 	call ATTACH_AND_OPEN ((R0_SW), "vfile_ " || r0_vpath || " -extend", iop (1), (KSO), ec);
      147 						/* Open previously non-existent vfile_
      148*						   in process dir. (Do this first to make sure we have room) */
      149 	if ec ^= 0 then go to r4_only;
      150 
      151 	call get_temp_segments_ ("old_syserr_log_util_", seg_array, ec); /* get a temp seg */
      152 	if ec ^= 0 then go to r4_only;
      153 	slog_ptr = seg_array (1);			/* this will be used to reference log */
      154 
      155 	on linkage_error begin;
      156 		log_len = 0;			/* no data */
      157 		go to no_r0_access;
      158 	     end;
      159 
      160 	call audit_gate_$copy_syserr_log ("0"b, slog_ptr, fixed (rel (addr (slog.buffer)), 17), log_len);
      161 						/* Copy header of ring 0 log from ring 0 */
      162 no_r0_access:
      163 	revert linkage_error;
      164 	if log_len = 0 then do;			/* Don't know why, but no luck */
      165 	     ec = error_table_$moderr;
      166 	     go to r4_only;
      167 	end;
      168 
      169 	time = 0;
      170 	if iop (2) ^= null () then do;		/* If we have  the ring 4 log, get time of last mess */
      171 
      172 	     call iox_$position (iop (2), (EOF), 0, ec);	/* Position to end-of-file in ring 4 log */
      173 	     if ec ^= 0 then do;
      174 r0_only:
      175 		call CLOSE_AND_DETACH (iop (2), 0);	/* Problems, punt */
      176 		go to copy_whole_r0_log;
      177 	     end;
      178 
      179 	     call iox_$position (iop (2), (SKIP), -1, ec);/* Move to last msg in r4 log */
      180 	     if ec ^= 0 then go to r0_only;
      181 
      182 	     call iox_$read_key (iop (2), key, 0, ec);	/* Read its key */
      183 	     if ec ^= 0 then go to r0_only;
      184 
      185 	     call DECODE_KEY (key, time, 0);		/* Pull msg time out of key */
      186 	end;
      187 
      188 	if time = 0 then go to copy_whole_r0_log;	/* Need whole thing */
      189 
      190 	if slog.last_copied = slog.last then do;	/* No need to do anything */
      191 	     access = access | "10"b;			/* R0 log accessiblke, but null */
      192 	     go to r4_only;
      193 	end;
      194 
      195 	if slog.last_copied = "0"b then do;		/* Need it all */
      196 copy_whole_r0_log:
      197 	     call audit_gate_$copy_syserr_log ("0"b, slog_ptr, slog.len + 4 * bin (rel (addr (slog.buffer))), log_len);
      198 
      199 	     if time = 0 then do;			/* No r4 log */
      200 		off = slog.first;
      201 		prevoff = "0"b;
      202 		go to fill_r0_vfile;		/* Fill in vfile */
      203 	     end;
      204 
      205 	     else do;				/* We have some searching to do */
      206 		off = slog.last;
      207 		nextoff = "0"b;
      208 
      209 		do while (off ^= "0"b & nextoff ^= slog.first); /* Cover both intermediate threading states */
      210 		     smess_ptr = addrel (slog_ptr, off);
      211 		     if smess.time <= time		/* Found overlap point between both logs */
      212 		     then go to found_msg;
      213 		     nextoff = off;
      214 		     off = smess.prev;
      215 		end;
      216 found_msg:
      217 		prevoff = off;
      218 		off = nextoff;
      219 		go to fill_r0_vfile;
      220 	     end;
      221 	end;
      222 
      223 	if slog.last_copied < slog.last then do;	/* Unwrapped, partially copied log */
      224 	     call audit_gate_$copy_syserr_log (slog.last_copied, ptr (slog_ptr, slog.last_copied),
      225 		4 * (bin (slog.last) - bin (slog.last_copied) + 512), log_len); /* 512 extra words to get last message for sure */
      226 set_off:
      227 	     if time ^= ptr (slog_ptr, slog.last_copied) -> smess.time
      228 	     then go to copy_whole_r0_log;		/* Oh well. We tried */
      229 
      230 	     off = rel (addr (ptr (slog_ptr, slog.last_copied) -> smess.next_smess)); /* First message for vfile */
      231 						/* Since we are only going forward,
      232*						   there is no need to make slog.first
      233*						   and the first message back pointer
      234*						   consistent */
      235 	     prevoff = "0"b;
      236 	     go to fill_r0_vfile;
      237 	end;
      238 
      239 	else do;					/* Wrapped log, have to copy two pieces */
      240 	     call audit_gate_$copy_syserr_log (slog.last_copied, ptr (slog_ptr, slog.last_copied),
      241 		4 * (bin (rel (addr (slog.end_point))) - bin (slog.last_copied)), log_len); /* Copy bottom piece */
      242 	     call audit_gate_$copy_syserr_log (rel (addr (slog.buffer)), addr (slog.buffer),
      243 		4 * (bin (slog.last) - bin (rel (addr (slog.buffer))) + 512), log_len);
      244 	     go to set_off;
      245 	end;
      246 
      247 
      248 fill_r0_vfile:
      249 	do while (off ^= "0"b & prevoff ^= slog.last);	/* Cover both intermediate threading cases */
      250 
      251 	     smess_ptr = addrel (slog_ptr, off);
      252 	     key_dup = "0"b;			/* No key duplication yet */
      253 compute_key:
      254 	     keybits = unspec (smess.time) || unspec (smess.seq_num) || unspec (smess.code); /* Concoct key for insertion */
      255 	     key = keychars;			/* Set into the right size variable */
      256 set_key:
      257 	     call iox_$seek_key (iop (1), key, 0, ec);	/* Set key for insertion */
      258 	     if ec = error_table_$key_order then do;	/* Keys not in order (clock messed up?) */
      259 		call iox_$close (iop (1), ec);	/* Close it... */
      260 		if ec ^= 0 then go to r4_only;
      261 		call iox_$open (iop (1), (KSU), "0"b, ec); /* Open for update, so keys can be out of order */
      262 		if ec ^= 0 then go to r4_only;
      263 		go to set_key;
      264 	     end;
      265 	     if ec = error_table_$key_duplication then do;
      266 		if key_dup then go to next_mess;	/* Try once, then give up */
      267 		key_dup = "1"b;
      268 		smess.time = smess.time + 1;		/* Change key enough to get in */
      269 		go to compute_key;
      270 	     end;
      271 	     if ec ^= error_table_$no_record then go to r4_only; /* Shouldn't be there yet */
      272 
      273 	     call iox_$write_record (iop (1), addr (smess.seq_num),
      274 		4 * (bin (rel (addr (smess.next_smess))) - bin (rel (addr (smess.seq_num)))), ec);
      275 						/* Record for vfile log does not include threading */
      276 	     if ec ^= 0 then go to r4_only;
      277 next_mess:
      278 	     prevoff = off;
      279 	     off = smess.next;
      280 	end;
      281 
      282 	call CLOSE_AND_DETACH (iop (1), 0);		/* Close and re-open for efficiency */
      283 
      284 	call ATTACH_AND_OPEN ((R0_SW), "vfile_ " || r0_vpath, iop (1), (KSI), ec);
      285 	if ec = 0 then access = access | "10"b;		/* R0 log is available */
      286 	else
      287 r4_only:
      288 	     call CLOSE_R0_LOG (0);			/* Come here if r0 log not accessible, or null */
      289 	if slog_ptr ^= null then do;			/* if temp segment gotten */
      290 	     slog_ptr = null;
      291 	     call release_temp_segments_ ("old_syserr_log_util_", seg_array, 0);
      292 	end;
      293 	if ec = 0 then if iop (2) = null then ec = r4_ec; /* if ring0 ok, return possible ring4 error code */
      294 	OPEN = (iop (1) ^= null) | (iop (2) ^= null);	/* open only if at least 1 iocb is ok */
      295 	return;
      296 
      297 /* Entry closes up shop after all searching/reading */
      298 
      299 old_syserr_log_util_$close: entry (ec);
      300 
      301 	if ^OPEN then do;
      302 	     ec = error_table_$not_open;
      303 	     return;
      304 	end;
      305 	OPEN = NO;				/* No longer there */
      306 
      307 	if iop (2) ^= null () then call CLOSE_AND_DETACH (iop (2), 0); /* Close and detach ring 4 log */
      308 
      309 	if iop (1) ^= null () then call CLOSE_R0_LOG (0); /* Close, detach, and delete r0 vfile */
      310 
      311 	curlog = 0;				/* Haven't got a position any more */
      312 	ec = 0;
      313 
      314 	return;
      315 
      316 /* Entry to trim back the ring  4 syserr log */
      317 
      318 old_syserr_log_util_$trim: entry (ttime, ec);
      319 
      320 dcl  ttime fixed bin (71) parameter;			/* Trim time */
      321 dcl  iocbp pointer;					/* Points to I/O control block for ring 4 log */
      322 dcl  deltime fixed bin (71);
      323 
      324 	r4_path = R4_PATH;
      325 	go to trim_join;
      326 
      327 old_syserr_log_util_$trim_path: entry (a_trim_path, ttime, ec);
      328 
      329 dcl  a_trim_path char (*);
      330 
      331 	r4_path = a_trim_path;			/* user tells us where */
      332 	if r4_path = "" then			/* oops, got lazy */
      333 	     r4_path = R4_PATH;			/* use the default */
      334 
      335 trim_join:
      336 	call expand_pathname_ (r4_path, r4_dir, r4_entry, ec);
      337 	if ec ^= 0 then
      338 	     call sub_err_ (ec, "old_syserr_log_util_", ACTION_CANT_RESTART, null (), (0), "Unexpected error with path ^a.", r4_path);
      339 	call hcs_$set_safety_sw (r4_dir, r4_entry, "0"b, ec); /* Have to turn off safety switch */
      340 	if ec ^= 0 then return;			/* No access probably */
      341 
      342 	call ATTACH_AND_OPEN ((R4_SW), ("vfile_ " || rtrim (r4_path)), iocbp, (KSU), ec); /* Open permanent log for update */
      343 	if ec ^= 0 then go to trim_done;
      344 
      345 /* before deleting any records, check to see if the break will leave an "=" as the first message.
      346*   If so, adjust the break slightly */
      347 
      348 	begin;
      349 
      350 dcl  buffer (512) bit (36) aligned;			/* read messages here */
      351 
      352 	     deltime = ttime;			/* default break time is time given */
      353 	     syserr_msgp = addr (buffer);
      354 	     seek_info.relation = 1;			/* set up seek head order */
      355 	     seek_info.nchars = 8;
      356 	     unspec (seek_info.search_key) = unspec (ttime);
      357 	     call iox_$control (iocbp, "seek_head", addr (seek_info), ec);
      358 	     if ec ^= 0 then go to trim_position;	/* give up */
      359 trim_backup:
      360 	     call iox_$read_record (iocbp, syserr_msgp, 2048, (0), ec);
      361 	     if ec ^= 0 then go to trim_position;
      362 	     if syserr_msg.text ^= "=" then do;		/* found good break */
      363 		deltime = syserr_msg.time;
      364 		go to trim_position;
      365 	     end;
      366 	     call iox_$position (iocbp, 0, -2, ec);	/* back to previous record */
      367 	     if ec = 0 then go to trim_backup;
      368 	     if ec ^= error_table_$end_of_info then go to trim_position;
      369 	     call iox_$control (iocbp, "seek_head", addr (seek_info), ec); /* back to origional break */
      370 	     if ec ^= 0 then go to trim_position;
      371 trim_forward:
      372 	     call iox_$read_record (iocbp, syserr_msgp, 2048, (0), ec); /* read forward for break */
      373 	     if ec ^= 0 then go to trim_position;
      374 	     if syserr_msg.text ^= "=" then do;
      375 		deltime = syserr_msg.time;
      376 		go to trim_position;
      377 	     end;
      378 	     else go to trim_forward;
      379 	end;
      380 
      381 /* now ready to delete */
      382 
      383 trim_position:
      384 	call iox_$position (iocbp, -1, 0, ec);
      385 	if ec ^= 0 then go to trim_done;
      386 
      387 trim_read_key:
      388 	call iox_$read_key (iocbp, key, 0 /* don't care */, ec);
      389 	if ec ^= 0 then do;
      390 	     if ec = error_table_$end_of_info then ec = 0;/* We are done */
      391 	     go to trim_done;
      392 	end;
      393 
      394 	call DECODE_KEY (key, time, 0);
      395 	if deltime <= time				/* If msg time later than trim time we are done */
      396 	then go to trim_done;
      397 
      398 	call iox_$delete_record (iocbp, ec);		/* ZAP */
      399 	if ec ^= 0 then go to trim_done;
      400 
      401 	go to trim_read_key;
      402 
      403 trim_done:
      404 	call hcs_$set_safety_sw (r4_dir, r4_entry, "1"b, 0); /* Turn safety switch back on */
      405 
      406 	call CLOSE_AND_DETACH (iocbp, 0);
      407 
      408 	return;
      409 
      410 /* Entry searches for the first syserr message logged after a given time */
      411 
      412 old_syserr_log_util_$search: entry (search_time, rtime, rseq, ec);
      413 
      414 dcl  search_time fixed bin (71) parameter;		/* Time for searching, in microseconds */
      415 dcl  rtime fixed bin (71) parameter;			/* Logging time of message found */
      416 dcl  rseq fixed bin (35) parameter;			/* Sequence number of message found */
      417 
      418 dcl  1 seek_info aligned,				/* Structure for "seek_head" control call */
      419        2 relation fixed bin,				/* Search for mess-time >= search_time */
      420        2 nchars fixed bin,				/* unspec (fixed bin (71)) is 8 chars */
      421        2 search_key char (8);				/* Actual key used */
      422 
      423 	rtime = -1;				/* In case of abort */
      424 	rseq = -1;
      425 
      426 	if ^OPEN then do;
      427 not_open:	     ec = error_table_$not_open;
      428 	     return;
      429 	end;
      430 
      431 	if search_time = 0 then do;			/* Special value, search to BOF */
      432 	     if iop (2) = null () then curlog = 1;	/* Nor r4 log, give r0 log */
      433 	     else curlog = 2;
      434 	     call iox_$position (iop (curlog), (BOF), 0, 0); /* Position to  first (oldest) message */
      435 	     go to search_get_time;
      436 	end;
      437 
      438 	if search_time = -1 then do;			/* Special value, search to EOF */
      439 eof:
      440 	     if iop (1) = null () then curlog = 2;	/* Nor r0 log, go to r4 log */
      441 	     else curlog = 1;
      442 	     call iox_$position (iop (curlog), (EOF), 0, 0); /* Move to end-of-file */
      443 	     call iox_$position (iop (curlog), (SKIP), -1, 0); /* Move back one to last message */
      444 	     go to search_get_time;
      445 	end;
      446 
      447 	if search_time < -1 then do;			/* What do you think this is? A time machine? */
      448 	     ec = error_table_$bad_arg;
      449 	     return;
      450 	end;
      451 
      452 	seek_info.relation = 1;			/* head >= search_key */
      453 	seek_info.nchars = 8;			/* To save prologue */
      454 	substr (unspec (seek_info.search_key), 1, 72) = unspec (search_time); /* fb(71) time is 8 chars */
      455 
      456 	do curlog = 2, 1;				/* Try r4 log first */
      457 	     if iop (curlog) ^= null then do;
      458 		call iox_$control (iop (curlog), "seek_head", addr (seek_info), ec);
      459 		if ec = 0 then go to search_get_time;
      460 	     end;
      461 	end;
      462 	go to eof;				/* Not in either log, return last message */
      463 
      464 search_get_time:
      465 	call iox_$read_key (iop (curlog), key, 0, ec);	/* Read the key of the message found */
      466 	if ec ^= 0 then return;
      467 get_time:
      468 	call DECODE_KEY (key, rtime, rseq);		/* Decode into its component parts */
      469 
      470 	return;
      471 
      472 /* Entry positions n messages forward or backward, crossing logs as necessary */
      473 
      474 old_syserr_log_util_$position: entry (n, rtime, rseq, ec);
      475 
      476 dcl  n fixed bin (21) parameter;			/* No of messages forward (n>_0) or back (n<0) to move */
      477 dcl  moven fixed bin (21);
      478 dcl  move fixed bin;
      479 
      480 dcl  1 iox_status aligned,				/* Structure returned by iox_$control "error_status" */
      481        2 version fixed bin,				/* vfile version number */
      482        2 type fixed bin,				/* Type of operation this is status for */
      483        2 to_move fixed bin,				/* How many records we wanted to position */
      484        2 moved fixed bin;				/* How many records we actually positioned (signed) */
      485 
      486 	rtime = -1;				/* In case of abort */
      487 	rseq = -1;
      488 
      489 	if ^OPEN then go to not_open;
      490 
      491 	if curlog = 0 then do;			/* No call to search yet */
      492 	     ec = error_table_$no_record;
      493 	     return;
      494 	end;
      495 
      496 	moven = n;
      497 position:
      498 	if moven = 0 then go to pos_get_time;		/* No work to do */
      499 	call iox_$position (iop (curlog), (SKIP), moven, ec); /* Position in current log */
      500 	if ec = error_table_$end_of_info then do;	/* Ooops! Ran off end */
      501 	     iox_status.version = 1;
      502 	     call iox_$control (iop (curlog), "error_status", addr (iox_status), ec); /* Find out how much we missed by */
      503 	     if ec ^= 0 then return;
      504 
      505 	     moven = n - iox_status.moved;		/* Correct for overrun */
      506 	     if n > 0 & curlog = 2 & iop (1) ^= null () then do; /* Have to switch to r0 piece */
      507 switch_to_r0:
      508 		curlog = 1;
      509 		move = BOF;
      510 	     end;
      511 
      512 	     else if n < 0 & curlog = 1 & iop (2) ^= null then do; /* Have to switch to r4 piece */
      513 		curlog = 2;
      514 		move = EOF;
      515 	     end;
      516 
      517 	     else do;
      518 		ec = error_table_$end_of_info;
      519 		return;
      520 	     end;
      521 
      522 	     call iox_$position (iop (curlog), move, 0, ec); /* Move to start or end of other piece */
      523 	     if ec ^= 0 then return;
      524 
      525 	     go to position;
      526 	end;
      527 
      528 	if ec ^= 0 then return;			/* Don't know what's wrong */
      529 pos_get_time:
      530 	call iox_$read_key (iop (curlog), key, 0, ec);	/* See if this is a real record or EOF */
      531 	if ec = error_table_$end_of_info		/* Moved fwd to EOF */
      532 	then if curlog = 2				/* If in ring 4 piece */
      533 	     then do;				/* See if we can/should switch log pieces */
      534 		if iop (1) = null () then return;	/* No r0 piece, we at end */
      535 		moven = 0;			/* No more moving to do */
      536 		go to switch_to_r0;
      537 	     end;
      538 	     else do;				/* curlog = 1; we are in ring 0 piece */
      539 		call iox_$position (iop (curlog), (SKIP), -1, ec); /* Move back one to last real record */
      540 		if ec ^= 0 then return;		/* I give up */
      541 		go to pos_get_time;
      542 	     end;
      543 
      544 	if ec = 0 then go to get_time;		/* Success at last */
      545 	else return;
      546 
      547 /* Entry reads the current syserr message, updates the current message to the next message, and switches logs if necessary */
      548 
      549 old_syserr_log_util_$read: entry (bufp, bufl, messl, ec);
      550 
      551 dcl  bufp pointer parameter;				/* Points to caller-supplied buffer */
      552 dcl  bufl fixed bin (21) parameter;			/* Length of caller-supplied buffer */
      553 dcl  messl fixed bin (21) parameter;			/* Actual length of this message, even if >buffl */
      554 dcl  retlen fixed bin (21);				/* length in chars returned by iox */
      555 
      556 	if ^OPEN then go to not_open;
      557 
      558 	if curlog = 0 then do;			/* No call to search yet */
      559 	     ec = error_table_$no_record;
      560 	     messl = 0;
      561 	     return;
      562 	end;
      563 
      564 read:
      565 	call iox_$read_record (iop (curlog), bufp, 4 * bufl, retlen, ec); /* Read the record */
      566 	if ec = error_table_$end_of_info		/* If at end of this vfile_ ... */
      567 	then if curlog = 2				/* Cross boundaries */
      568 	     then if iop (1) ^= null () then do;
      569 		     curlog = 1;			/* Switch to ring 0 piece */
      570 		     call iox_$position (iop (1), (BOF), 0, ec); /* Position to first message in ring 0 piece */
      571 		     go to read;
      572 		end;
      573 	messl = divide (retlen, 4, 21, 0);		/* compute length in words */
      574 
      575 	return;
      576 
      577 /* Entry returns a status structure, currently including only a version number constant */
      578 
      579 old_syserr_log_util_$status: entry (status_p, ec);
      580 
      581 dcl  status_p pointer parameter;			/* Points to user-supplied structure */
      582 
      583 dcl  1 slu_status aligned based (status_p),		/* Ain't much to it yet */
      584        2 version fixed bin;
      585 
      586 	slu_status.version = 1;
      587 	ec = 0;
      588 	return;
      589 
      590 /* Internal procedure to attach and open a log with a given attach description and opening  mode */
      591 
      592 ATTACH_AND_OPEN: proc (switch, atd, iocbp, omode, ec);
      593 
      594 dcl  switch char (*) parameter;			/* Switch being attached */
      595 dcl  atd char (*) parameter;				/* Attach description */
      596 dcl  iocbp pointer parameter;				/* Pointer to created io control block */
      597 dcl  omode fixed bin parameter;			/* Opening mode */
      598 dcl  ec fixed bin (35) parameter;			/* Status code */
      599 dcl  ec1 fixed bin (35);
      600 
      601 attach:
      602 	call iox_$attach_ioname (switch, iocbp, atd, ec);
      603 	if ec ^= 0 then do;				/* Somebody forgot to turn out the light */
      604 	     if ec = error_table_$not_detached then do;
      605 		call iox_$find_iocb (switch, iocbp, ec1); /* Pick up ptr to it if it exists */
      606 		if ec1 ^= 0 then return;		/* Well, we tried */
      607 		call CLOSE_AND_DETACH (iocbp, ec1);	/* Chec1k the gas while you're at it */
      608 		if ec1 = 0 then go to attach;		/* Try again */
      609 	     end;
      610 	     return;
      611 	end;
      612 
      613 open:
      614 	call iox_$open (iocbp, omode, "0"b, ec);
      615 
      616 	return;
      617 
      618      end ATTACH_AND_OPEN;
      619 
      620 /* Internal procedure to close and detach */
      621 
      622 CLOSE_AND_DETACH: proc (iocbp, ec);
      623 
      624 dcl  iocbp pointer parameter;
      625 dcl  ec fixed bin (35) parameter;
      626 
      627 	call iox_$close (iocbp, ec);
      628 	call iox_$detach_iocb (iocbp, ec);
      629 	iocbp = null ();
      630 	return;
      631      end CLOSE_AND_DETACH;
      632 
      633 /* Internal procedure to close and detach the ring 0 log and clean up */
      634 
      635 CLOSE_R0_LOG: proc (ec);
      636 
      637 dcl  ec fixed bin (35) parameter;
      638 
      639 	call CLOSE_AND_DETACH (iop (1), ec);
      640 
      641 	call delete_$path (get_pdir_ (), r0_vfile, "000100"b, "", ec);
      642 
      643 	return;
      644      end CLOSE_R0_LOG;
      645 
      646 /* Internal procedure to decode a record key */
      647 /* Record keys are simply a bit string of concatenated message time, sequence number, and syserr code */
      648 
      649 DECODE_KEY: proc (key, time, seq);
      650 
      651 dcl  key char (256) varying parameter;
      652 dcl  time fixed bin (71) parameter;
      653 dcl  seq fixed bin (35) parameter;
      654 
      655 dcl  keybits bit (9 * 16) aligned;			/* Overlay to pick out bit fields */
      656 dcl  keychars char (16) based (addr (keybits));
      657 
      658 	keychars = key;				/* Copy out of varying string because we aren't
      659*						   supposed to know how varying strings are stored */
      660 
      661 	time = fixed (substr (keybits, 1, 72), 71);
      662 	seq = fixed (substr (keybits, 73, 36), 35);
      663 
      664 	return;
      665      end DECODE_KEY;
      666 
      667 /* special debugging entry that stores the vfile_ attach description in static */
      668 
      669 debug: entry (arg_dir, arg_ename);
      670 
      671 dcl  (arg_dir, arg_ename) char (*);
      672 
      673 	call absolute_pathname_ (pathname_ (arg_dir, arg_ename), r4_path, ec);
      674 	if ec ^= 0 then
      675 	     call sub_err_ (ec, "old_syserr_log_util_$debug", ACTION_CANT_RESTART, null (), (0), "Bad pathname from ^a, ^a", arg_dir, arg_ename);
      676 	R4_PATH = r4_path;
      677 	return;
      678 
  1     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  1     2 /* format: style3 */
  1     3 
  1     4 /* These constants are to be used for the flags argument of sub_err_ */
  1     5 /* They are just "string (condition_info_header.action_flags)" */
  1     6 
  1     7 declare	(
  1     8 	ACTION_CAN_RESTART	init (""b),
  1     9 	ACTION_CANT_RESTART init ("1"b),
  1    10 	ACTION_DEFAULT_RESTART
  1    11 			init ("01"b),
  1    12 	ACTION_QUIET_RESTART
  1    13 			init ("001"b),
  1    14 	ACTION_SUPPORT_SIGNAL
  1    15 			init ("0001"b)
  1    16 	)		bit (36) aligned internal static options (constant);
  1    17 
  1    18 /* End include file */
      679 
      680 
  2     1 /* Begin include file ... syserr_log.incl.pl1 */
  2     2 
  2     3 /* Created by Bill Silver on 08/11/73 */
  2     4 
  2     5 /* Modified 11/12/74 by Lee Scheffler to add log copying information. */
  2     6 /* Modified November 1975 by Larry Johnson for new message format */
  2     7 
  2     8 
  2     9 dcl  slog_ptr ptr,					/* Pointer to base of syserr_log segment.  */
  2    10      smess_ptr ptr;					/* Pointer to a message entry. */
  2    11 
  2    12 dcl 1 slog based (slog_ptr) aligned,			/* PAGED SYSERR LOG SEGMENT */
  2    13     2 head like slog_header,				/* Header */
  2    14     2 buffer char (0 refer (slog.head.len)),		/* Paged syserr log buffer. */
  2    15     2 end_point char (1);				/* Dummy for referencing end of log */
  2    16 
  2    17 dcl 1 slog_header based aligned,			/* LOG HEADER */
  2    18     2 len fixed bin (35),				/* Length of the BUFFER in CHARACTERS. */
  2    19     2 lock bit (36),				/* Locks the whole syserr log segment. */
  2    20     2 init_word char (4),				/* "INIT" => log already initialized. */
  2    21     2 first bit (18),				/* Relative offset of the first message entry. */
  2    22     2 last bit (18),				/* Relative offset of the last  message entry. */
  2    23     2 last_copied bit (18),				/* Relative offset of last message entry
  2    24*						   copied into hierarchy */
  2    25 						/* If 0, entire log is uncopied */
  2    26     2 copy_threshold fixed bin (18),			/* Initializer is woken up when the number of
  2    27*						   as-yet-uncopied characters in the log
  2    28*						   exceeds this number */
  2    29     2 copy_pending bit (1),				/* ON if wakeup for log copying has been sent,
  2    30*						   but log not yet copied */
  2    31     2 copy_channel fixed bin (71),			/* Channel over which Initializer is awakened */
  2    32     2 copy_process_id bit (36),			/* Process id of process to which log copying
  2    33*						   wakeup will go */
  2    34     2 version fixed bin,				/* Version number of log and message format */
  2    35     2 event_id fixed bin (35),			/* Event id for locking log */
  2    36     2 wrap_count fixed bin,				/* Count if times log has wrapped */
  2    37     2 error_offset bit (18),				/* Set by syserr_log_check to location of error */
  2    38     2 reserved (17) bit (36);				/* Reserved for future use. */
  2    39 
  2    40 
  2    41 /* This is an overlay of a message entry that goes into the paged syserr log.
  2    42*   Each message entry corresponds to one syserr message. */
  2    43 
  2    44 dcl 1 smess based (smess_ptr) aligned,			/* MESSAGE ENTRY */
  2    45     2 next bit (18) unal,				/* Relative offset of next message entry. */
  2    46     2 prev bit (18) unal,				/* Relative offset of previous message entry. */
  2    47     2 seq_num fixed bin (35),				/* Sequence number of this message. */
  2    48     2 time fixed bin (71) unal,			/* Time message logged at */
  2    49     2 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  2    50     2 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  2    51     2 data_size fixed bin (11) unal,			/* Size of binary data */
  2    52     2 data_code fixed bin (11) unal,			/* Data code */
  2    53     2 pad bit (60) unal,
  2    54     2 text char (0 refer (smess.text_len)),		/* Text of expanded message */
  2    55     2 data (0 refer (smess.data_size)) bit (36),		/* Binary portion of message */
  2    56     2 next_smess char (1);				/* Dummy used to calculate next message addrss */
  2    57 
  2    58 /*	End of include file ... syserr_log.incl.pl1	*/
      681 
      682 
  3     1 /* Begin include file ..... syserr_message.incl.pl1 */
  3     2 
  3     3 /* Format of a syserr message */
  3     4 
  3     5 /* Created October 1975 by Larry Johnson */
  3     6 
  3     7 dcl  syserr_msgp ptr;				/* Base for include file */
  3     8 
  3     9 dcl 1 syserr_msg based (syserr_msgp) aligned,
  3    10     2 seq_num fixed bin (35),				/* Sequence number of this message. */
  3    11     2 time fixed bin (71) unal,			/* Time message logged at */
  3    12     2 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  3    13     2 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  3    14     2 data_size fixed bin (11) unal,			/* Size of binary data */
  3    15     2 data_code fixed bin (11) unal,			/* Code identifying message type. */
  3    16     2 pad bit (60) unal,				/* RESERVED! */
  3    17     2 text char (0 refer (syserr_msg.text_len)),		/* Text of expanded message - kept in ASCII. */
  3    18     2 data (0 refer (syserr_msg.data_size)) bit (36);	/* Binary data area */
  3    19 
  3    20 
  3    21 /* End include file ..... syserr_message.incl.pl1 */
      683 
      684 
      685 
      686      end old_syserr_log_util_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/25/85  0847.1  old_syserr_log_util_.pl1          >spec>t>41-5>old_syserr_log_util_.pl1
679          1    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
681          2    01/25/85  0846.1  syserr_log.incl.pl1               >spec>t>41-5>syserr_log.incl.pl1
683          3    08/18/77  1118.1  syserr_message.incl.pl1           >ldd>include>syserr_message.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000027 constant        bit(36)                  initial dcl 1-7 set ref 337* 674*
BOF                                    constant        fixed bin(17,0)          initial dcl 74 ref 434 509 570
EOF                                    constant        fixed bin(17,0)          initial dcl 74 ref 172 442 514
KSI                                    constant        fixed bin(17,0)          initial dcl 73 ref 132 284
KSO                                    constant        fixed bin(17,0)          initial dcl 73 ref 146
KSU                                    constant        fixed bin(17,0)          initial dcl 73 ref 261 342
NO                                     constant        bit(1)                   initial unaligned dcl 72 ref 126 305
OPEN                            000067 internal static bit(1)                   initial dcl 83 set ref 126* 294* 301 305* 426 489
                                                                                  556
R0_SW                           000004 constant        char(13)                 initial unaligned dcl 69 ref 146 284
R0_VFILE                        000010 constant        char(13)                 initial unaligned dcl 68 ref 143
R4_PATH                         000010 internal static char(168)                initial unaligned dcl 71 set ref 115 123 324 332
                                                                                  676*
R4_SW                           000000 constant        char(13)                 initial unaligned dcl 70 ref 132 342
SKIP                                   constant        fixed bin(17,0)          initial dcl 74 ref 179 443 499 539
a_open_path                            parameter       char                     unaligned dcl 120 ref 118 122
a_trim_path                            parameter       char                     unaligned dcl 329 ref 327 331
absolute_pathname_              000100 constant        entry                    external dcl 25 ref 673
access                                 parameter       bit(36)                  dcl 111 set ref 109 118 129* 134* 134 191* 191 285*
                                                                                  285
addr                                                   builtin function         dcl 52 ref 160 160 196 230 240 242 242 242 242 242
                                                                                  255 273 273 273 273 353 357 357 369 369 458 458
                                                                                  502 502 658
addrel                                                 builtin function         dcl 52 ref 210 251
arg_dir                                parameter       char                     unaligned dcl 671 set ref 669 673* 673* 674*
arg_ename                              parameter       char                     unaligned dcl 671 set ref 669 673* 673* 674*
atd                                    parameter       char                     unaligned dcl 595 set ref 592 601*
audit_gate_$copy_syserr_log     000102 constant        entry                    external dcl 26 ref 160 196 224 240 242
bin                                                    builtin function         dcl 52 ref 196 224 224 240 240 242 242 273 273
buffer                          000474 automatic       bit(36)                  array dcl 350 in begin block on line 348 set ref 353
buffer                   40            based           char                     level 2 in structure "slog" dcl 2-12 in procedure
                                                                                  "old_syserr_log_util_" set ref 160 160 196 242 242
                                                                                  242 242 242
bufl                                   parameter       fixed bin(21,0)          dcl 552 ref 549 564
bufp                                   parameter       pointer                  dcl 551 set ref 549 564*
code                      4            based           fixed bin(11,0)          level 2 packed unaligned dcl 2-44 ref 253
curlog                          000066 internal static fixed bin(2,0)           initial dcl 81 set ref 128* 311* 432* 433* 434 439*
                                                                                  441* 442 443 456* 457 458* 464 491 499 502 506
                                                                                  507* 512 513* 522 529 531 539 558 564 566 569*
data_size                 4(24)        based           fixed bin(11,0)          level 2 packed unaligned dcl 2-44 ref 230 273
delete_$path                    000104 constant        entry                    external dcl 27 ref 641
deltime                         000440 automatic       fixed bin(71,0)          dcl 322 set ref 352* 363* 375* 395
divide                                                 builtin function         dcl 52 ref 573
ec                                     parameter       fixed bin(35,0)          dcl 637 in procedure "CLOSE_R0_LOG" set ref 635 639*
                                                                                  641*
ec                                     parameter       fixed bin(35,0)          dcl 92 in procedure "old_syserr_log_util_" set ref
                                                                                  109 118 136* 146* 149 151* 152 165* 172* 173 179*
                                                                                  180 182* 183 256* 258 259* 260 261* 262 265 271
                                                                                  273* 276 284* 285 293 293* 299 302* 312* 318 327
                                                                                  335* 337 337* 339* 340 342* 343 357* 358 359* 361
                                                                                  366* 367 368 369* 370 371* 373 383* 385 387* 389
                                                                                  390 390* 398* 399 412 427* 448* 458* 459 464* 466
                                                                                  474 492* 499* 500 502* 503 518* 522* 523 528 529*
                                                                                  531 539* 540 544 549 559* 564* 566 570* 579 587*
                                                                                  673* 674 674*
ec                                     parameter       fixed bin(35,0)          dcl 598 in procedure "ATTACH_AND_OPEN" set ref 592
                                                                                  601* 603 604 613*
ec                                     parameter       fixed bin(35,0)          dcl 625 in procedure "CLOSE_AND_DETACH" set ref 622
                                                                                  627* 628*
ec1                             000100 automatic       fixed bin(35,0)          dcl 599 set ref 605* 606 607* 608
end_point                              based           char(1)                  level 2 dcl 2-12 set ref 240
error_table_$bad_arg            000160 external static fixed bin(35,0)          dcl 56 ref 448
error_table_$end_of_info        000162 external static fixed bin(35,0)          dcl 57 ref 368 390 500 518 531 566
error_table_$file_busy          000164 external static fixed bin(35,0)          dcl 58 ref 138
error_table_$key_duplication    000166 external static fixed bin(35,0)          dcl 59 ref 265
error_table_$key_order          000170 external static fixed bin(35,0)          dcl 60 ref 258
error_table_$moderr             000172 external static fixed bin(35,0)          dcl 61 ref 165
error_table_$no_record          000174 external static fixed bin(35,0)          dcl 62 ref 271 492 559
error_table_$not_detached       000176 external static fixed bin(35,0)          dcl 63 ref 604
error_table_$not_open           000200 external static fixed bin(35,0)          dcl 64 ref 302 427
expand_pathname_                000106 constant        entry                    external dcl 28 ref 335
first                     3            based           bit(18)                  level 3 dcl 2-12 ref 200 209
fixed                                                  builtin function         dcl 52 ref 160 160 661 662
get_pdir_                       000110 constant        entry                    external dcl 29 ref 144 641 641
get_temp_segments_              000112 constant        entry                    external dcl 30 ref 151
hcs_$set_safety_sw              000116 constant        entry                    external dcl 32 ref 339 403
head                                   based           structure                level 2 dcl 2-12
iocbp                           000436 automatic       pointer                  dcl 321 in procedure "old_syserr_log_util_" set ref
                                                                                  342* 357* 359* 366* 369* 371* 383* 387* 398* 406*
iocbp                                  parameter       pointer                  dcl 624 in procedure "CLOSE_AND_DETACH" set ref 622
                                                                                  627* 628* 629*
iocbp                                  parameter       pointer                  dcl 596 in procedure "ATTACH_AND_OPEN" set ref 592
                                                                                  601* 605* 607* 613*
iop                             000062 internal static pointer                  initial array dcl 79 set ref 130* 130* 132* 137*
                                                                                  146* 170 172* 174* 179* 182* 256* 259* 261* 273*
                                                                                  282* 284* 293 294 294 307 307* 309 432 434* 439
                                                                                  442* 443* 457 458* 464* 499* 502* 506 512 522*
                                                                                  529* 534 539* 564* 566 570* 639*
iox_$attach_ioname              000120 constant        entry                    external dcl 33 ref 601
iox_$close                      000122 constant        entry                    external dcl 34 ref 259 627
iox_$control                    000124 constant        entry                    external dcl 35 ref 357 369 458 502
iox_$delete_record              000126 constant        entry                    external dcl 36 ref 398
iox_$detach_iocb                000130 constant        entry                    external dcl 37 ref 628
iox_$find_iocb                  000132 constant        entry                    external dcl 38 ref 605
iox_$open                       000134 constant        entry                    external dcl 39 ref 261 613
iox_$position                   000136 constant        entry                    external dcl 40 ref 172 179 366 383 434 442 443 499
                                                                                  522 539 570
iox_$read_key                   000140 constant        entry                    external dcl 41 ref 182 387 464 529
iox_$read_record                000142 constant        entry                    external dcl 42 ref 359 371 564
iox_$seek_key                   000144 constant        entry                    external dcl 43 ref 256
iox_$write_record               000146 constant        entry                    external dcl 44 ref 273
iox_status                      000450 automatic       structure                level 1 dcl 480 set ref 502 502
key                             000310 automatic       varying char(256)        dcl 94 in procedure "old_syserr_log_util_" set ref
                                                                                  182* 185* 255* 256* 387* 394* 464* 467* 529*
key                                    parameter       varying char(256)        dcl 651 in procedure "DECODE_KEY" ref 649 658
key_dup                         000430 automatic       bit(1)                   dcl 100 set ref 252* 266 267*
keybits                         000411 automatic       bit(144)                 unaligned dcl 95 in procedure "old_syserr_log_util_"
                                                                                  set ref 253* 255
keybits                         001510 automatic       bit(144)                 dcl 655 in procedure "DECODE_KEY" set ref 658 661
                                                                                  662
keychars                               based           char(16)                 unaligned dcl 656 in procedure "DECODE_KEY" set ref
                                                                                  658*
keychars                               based           char(16)                 unaligned dcl 96 in procedure "old_syserr_log_util_"
                                                                                  ref 255
last                      4            based           bit(18)                  level 3 dcl 2-12 ref 190 206 223 224 242 248
last_copied               5            based           bit(18)                  level 3 dcl 2-12 set ref 190 195 223 224* 224 224
                                                                                  224 226 230 240* 240 240 240
len                                    based           fixed bin(35,0)          level 3 dcl 2-12 ref 160 160 196 196 240 242 242 242
                                                                                  242 242
linkage_error                   000422 stack reference condition                dcl 99 ref 155 162
log_len                         000307 automatic       fixed bin(24,0)          dcl 93 set ref 156* 160* 164 196* 224* 240* 242*
messl                                  parameter       fixed bin(21,0)          dcl 553 set ref 549 560* 573*
move                            000447 automatic       fixed bin(17,0)          dcl 478 set ref 509* 514* 522*
moved                     3     000450 automatic       fixed bin(17,0)          level 2 dcl 480 set ref 505
moven                           000446 automatic       fixed bin(21,0)          dcl 477 set ref 496* 497 499* 505* 535*
n                                      parameter       fixed bin(21,0)          dcl 476 ref 474 496 505 506 512
nchars                    1     000442 automatic       fixed bin(17,0)          level 2 dcl 418 set ref 355* 453*
next                                   based           bit(18)                  level 2 packed unaligned dcl 2-44 ref 279
next_smess                             based           char(1)                  level 2 dcl 2-44 set ref 230 273
nextoff                         000416 automatic       bit(18)                  unaligned dcl 97 set ref 207* 209 213* 218
null                                                   builtin function         dcl 52 ref 130 141 170 289 290 293 294 294 307 309
                                                                                  337 337 432 439 457 506 512 534 566 629 674 674
off                             000415 automatic       bit(18)                  unaligned dcl 97 set ref 200* 206* 209 210 213 214*
                                                                                  216 218* 230* 248 251 277 279*
omode                                  parameter       fixed bin(17,0)          dcl 597 set ref 592 613*
pathname_                       000150 constant        entry                    external dcl 45 ref 673 673
prev                      0(18)        based           bit(18)                  level 2 packed unaligned dcl 2-44 ref 214
prevoff                         000417 automatic       bit(18)                  unaligned dcl 97 set ref 201* 216* 235* 248 277*
ptr                                                    builtin function         dcl 52 ref 224 224 226 230 240 240
r0_vfile                        000070 internal static char(32)                 unaligned dcl 87 set ref 143* 144 641*
r0_vpath                        000100 automatic       varying char(168)        dcl 88 set ref 144* 146 284
r4_dir                          000153 automatic       char(168)                unaligned dcl 89 set ref 335* 339* 403*
r4_ec                           000434 automatic       fixed bin(35,0)          dcl 113 set ref 132* 134 136 138 293
r4_entry                        000225 automatic       char(32)                 unaligned dcl 90 set ref 335* 339* 403*
r4_path                         000235 automatic       char(168)                unaligned dcl 91 set ref 115* 122* 123 123* 132 324*
                                                                                  331* 332 332* 335* 337* 342 673* 676
rel                                                    builtin function         dcl 52 ref 160 160 196 230 240 242 242 242 273 273
relation                        000442 automatic       fixed bin(17,0)          level 2 dcl 418 set ref 354* 452*
release_temp_segments_          000114 constant        entry                    external dcl 31 ref 291
retlen                          000454 automatic       fixed bin(21,0)          dcl 554 set ref 564* 573
rseq                                   parameter       fixed bin(35,0)          dcl 416 set ref 412 424* 467* 474 487*
rtime                                  parameter       fixed bin(71,0)          dcl 415 set ref 412 423* 467* 474 486*
rtrim                                                  builtin function         dcl 52 ref 132 144 342
search_key                2     000442 automatic       char(8)                  level 2 dcl 418 set ref 356* 454
search_time                            parameter       fixed bin(71,0)          dcl 414 ref 412 431 438 447 454
seek_info                       000442 automatic       structure                level 1 dcl 418 set ref 357 357 369 369 458 458
seg_array                       000432 automatic       pointer                  array dcl 101 set ref 151* 153 291*
seq                                    parameter       fixed bin(35,0)          dcl 653 set ref 649 662*
seq_num                   1            based           fixed bin(35,0)          level 2 dcl 2-44 set ref 253 273 273 273
slog                                   based           structure                level 1 dcl 2-12
slog_header                            based           structure                level 1 dcl 2-17
slog_ptr                        000456 automatic       pointer                  dcl 2-9 set ref 141* 153* 160* 160 160 190 190 195
                                                                                  196* 196 196 200 206 209 210 223 223 224 224 224
                                                                                  224 224 224 224 226 226 230 230 240 240 240 240
                                                                                  240 240 240 242 242 242 242 242 242 248 251 289
                                                                                  290*
slu_status                             based           structure                level 1 dcl 583
smess                                  based           structure                level 1 dcl 2-44
smess_ptr                       000460 automatic       pointer                  dcl 2-9 set ref 210* 211 214 251* 253 253 253 268
                                                                                  268 273 273 273 273 279
status_p                               parameter       pointer                  dcl 581 ref 579 586
sub_err_                        000152 constant        entry                    external dcl 46 ref 337 674
substr                                                 builtin function         dcl 52 set ref 454* 661 662
switch                                 parameter       char                     unaligned dcl 594 set ref 592 601* 605*
syserr_msg                             based           structure                level 1 dcl 3-9
syserr_msgp                     000462 automatic       pointer                  dcl 3-7 set ref 353* 359* 362 363 371* 374 375
text                      6            based           char                     level 2 dcl 3-9 ref 362 374
text_len                  3(12)        based           fixed bin(11,0)          level 2 in structure "syserr_msg" packed unaligned
                                                                                  dcl 3-9 in procedure "old_syserr_log_util_" ref
                                                                                  362 374
text_len                  4(12)        based           fixed bin(11,0)          level 2 in structure "smess" packed unaligned
                                                                                  dcl 2-44 in procedure "old_syserr_log_util_" ref
                                                                                  230 273
time                      2            based           fixed bin(71,0)          level 2 in structure "smess" packed unaligned
                                                                                  dcl 2-44 in procedure "old_syserr_log_util_" set
                                                                                  ref 211 226 253 268* 268
time                            000420 automatic       fixed bin(71,0)          dcl 98 in procedure "old_syserr_log_util_" set ref
                                                                                  169* 185* 188 199 211 226 394* 395
time                      1            based           fixed bin(71,0)          level 2 in structure "syserr_msg" packed unaligned
                                                                                  dcl 3-9 in procedure "old_syserr_log_util_" ref
                                                                                  363 375
time                                   parameter       fixed bin(71,0)          dcl 652 in procedure "DECODE_KEY" set ref 649 661*
ttime                                  parameter       fixed bin(71,0)          dcl 320 ref 318 327 352 356
unique_bits_                    000154 constant        entry                    external dcl 47 ref 143 143
unique_chars_                   000156 constant        entry                    external dcl 48 ref 143
unspec                                                 builtin function         dcl 52 set ref 253 253 253 356* 356 454 454
version                                based           fixed bin(17,0)          level 2 in structure "slu_status" dcl 583
                                                                                  in procedure "old_syserr_log_util_" set ref 586*
version                         000450 automatic       fixed bin(17,0)          level 2 in structure "iox_status" dcl 480
                                                                                  in procedure "old_syserr_log_util_" set ref 501*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 1-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 1-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 1-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 1-7
YES                                    internal static bit(1)                   initial unaligned dcl 72

NAMES DECLARED BY EXPLICIT CONTEXT.
ATTACH_AND_OPEN                 004026 constant        entry                    internal dcl 592 ref 132 146 284 342
CLOSE_AND_DETACH                004164 constant        entry                    internal dcl 622 ref 137 174 282 307 406 607 639
CLOSE_R0_LOG                    004220 constant        entry                    internal dcl 635 ref 286 309
DECODE_KEY                      004300 constant        entry                    internal dcl 649 ref 185 394 467
attach                          004046 constant        label                    dcl 601 ref 608
compute_key                     001317 constant        label                    dcl 253 ref 269
copy_whole_r0_log               001012 constant        label                    dcl 196 ref 176 188 226
debug                           003652 constant        entry                    external dcl 669
eof                             002762 constant        label                    dcl 439 ref 462
fill_r0_vfile                   001302 constant        label                    dcl 248 ref 202 219 236
found_msg                       001105 constant        label                    dcl 216 ref 211
get_r0_log                      000343 constant        label                    dcl 141
get_time                        003164 constant        label                    dcl 467 ref 544
next_mess                       001523 constant        label                    dcl 277 ref 266
no_r0_access                    000655 constant        label                    dcl 162 ref 157
not_open                        002713 constant        label                    dcl 427 ref 489 556
old_syserr_log_util_            000131 constant        entry                    external dcl 21
old_syserr_log_util_$close      001717 constant        entry                    external dcl 299
old_syserr_log_util_$open       000143 constant        entry                    external dcl 109
old_syserr_log_util_$open_path  000165 constant        entry                    external dcl 118
old_syserr_log_util_$position   003205 constant        entry                    external dcl 474
old_syserr_log_util_$read       003512 constant        entry                    external dcl 549
old_syserr_log_util_$search     002673 constant        entry                    external dcl 412
old_syserr_log_util_$status     003630 constant        entry                    external dcl 579
old_syserr_log_util_$trim       001773 constant        entry                    external dcl 318
old_syserr_log_util_$trim_path  002016 constant        entry                    external dcl 327
open                            004143 constant        label                    dcl 613
open_join                       000223 constant        label                    dcl 126 ref 116
pos_get_time                    003420 constant        label                    dcl 529 ref 497 541
position                        003234 constant        label                    dcl 497 ref 525
r0_only                         000714 constant        label                    dcl 174 ref 180 183
r4_only                         001625 constant        label                    dcl 286 ref 149 152 166 192 260 262 271 276
read                            003534 constant        label                    dcl 564 ref 571
search_get_time                 003142 constant        label                    dcl 464 ref 435 444 459
set_key                         001346 constant        label                    dcl 256 ref 263
set_off                         001147 constant        label                    dcl 226 ref 244
switch_to_r0                    003343 constant        label                    dcl 507 ref 536
trim_backup                     002350 constant        label                    dcl 359 ref 367
trim_done                       002624 constant        label                    dcl 403 set ref 343 385 391 395 399
trim_forward                    002472 constant        label                    dcl 371 ref 374
trim_join                       002054 constant        label                    dcl 335 set ref 325
trim_position                   002533 constant        label                    dcl 383 ref 358 361 364 368 370 373 376
trim_read_key                   002555 constant        label                    dcl 387 ref 401

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5174        5376    4345        5204
Length      6016    4345       202         404     627          70

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
old_syserr_log_util_               1064 external procedure  is an external procedure.  
on unit on line 155                  64 on unit               
begin block on line 348                 begin block         shares stack frame of external procedure old_syserr_log_util_.  
ATTACH_AND_OPEN                      86 internal procedure  is called during a stack extension.  
CLOSE_AND_DETACH                     70 internal procedure  is called by several nonquick procedures.  
CLOSE_R0_LOG                            internal procedure  shares stack frame of external procedure old_syserr_log_util_.  
DECODE_KEY                              internal procedure  shares stack frame of external procedure old_syserr_log_util_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 R4_PATH                     old_syserr_log_util_
000062 iop                         old_syserr_log_util_
000066 curlog                      old_syserr_log_util_
000067 OPEN                        old_syserr_log_util_
000070 r0_vfile                    old_syserr_log_util_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ATTACH_AND_OPEN          000100 ec1                         ATTACH_AND_OPEN
old_syserr_log_util_     000100 r0_vpath                    old_syserr_log_util_
                         000153 r4_dir                      old_syserr_log_util_
                         000225 r4_entry                    old_syserr_log_util_
                         000235 r4_path                     old_syserr_log_util_
                         000307 log_len                     old_syserr_log_util_
                         000310 key                         old_syserr_log_util_
                         000411 keybits                     old_syserr_log_util_
                         000415 off                         old_syserr_log_util_
                         000416 nextoff                     old_syserr_log_util_
                         000417 prevoff                     old_syserr_log_util_
                         000420 time                        old_syserr_log_util_
                         000430 key_dup                     old_syserr_log_util_
                         000432 seg_array                   old_syserr_log_util_
                         000434 r4_ec                       old_syserr_log_util_
                         000436 iocbp                       old_syserr_log_util_
                         000440 deltime                     old_syserr_log_util_
                         000442 seek_info                   old_syserr_log_util_
                         000446 moven                       old_syserr_log_util_
                         000447 move                        old_syserr_log_util_
                         000450 iox_status                  old_syserr_log_util_
                         000454 retlen                      old_syserr_log_util_
                         000456 slog_ptr                    old_syserr_log_util_
                         000460 smess_ptr                   old_syserr_log_util_
                         000462 syserr_msgp                 old_syserr_log_util_
                         000474 buffer                      begin block on line 348
                         001510 keybits                     DECODE_KEY

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_cs            alloc_bs            cat_realloc_cs      cat_realloc_bs      call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       call_int_other      return              tra_ext
mpfx2               enable              shorten_stack       ext_entry           ext_entry_desc      int_entry
int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            audit_gate_$copy_syserr_log   delete_$path                  expand_pathname_
get_pdir_                     get_temp_segments_            hcs_$set_safety_sw            iox_$attach_ioname
iox_$close                    iox_$control                  iox_$delete_record            iox_$detach_iocb
iox_$find_iocb                iox_$open                     iox_$position                 iox_$read_key
iox_$read_record              iox_$seek_key                 iox_$write_record             pathname_
release_temp_segments_        sub_err_                      unique_bits_                  unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$end_of_info      error_table_$file_busy        error_table_$key_duplication
error_table_$key_order        error_table_$moderr           error_table_$no_record        error_table_$not_detached
error_table_$not_open




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     21 000130       109 000136       115 000155       116 000160       118 000161       122 000205       123 000213
    126 000223       128 000225       129 000226       130 000227       132 000232       134 000316       136 000324
    137 000325       138 000337       141 000343       143 000345       144 000412       146 000465       149 000551
    151 000554       152 000603       153 000605       155 000607       156 000623       157 000625       160 000630
    162 000655       164 000656       165 000660       166 000663       169 000664       170 000666       172 000673
    173 000712       174 000714       176 000726       179 000727       180 000750       182 000752       183 000770
    185 000772       188 000775       190 000777       191 001005       192 001007       195 001010       196 001012
    199 001044       200 001046       201 001051       202 001052       206 001053       207 001056       209 001057
    210 001066       211 001072       213 001077       214 001101       215 001104       216 001105       218 001107
    219 001111       223 001112       224 001114       226 001147       230 001161       235 001177       236 001200
    240 001201       242 001240       244 001301       248 001302       251 001312       252 001316       253 001317
    255 001340       256 001346       258 001364       259 001370       260 001400       261 001402       262 001423
    263 001425       265 001426       266 001430       267 001432       268 001434       269 001443       271 001444
    273 001446       276 001521       277 001523       279 001525       280 001530       282 001531       284 001543
    285 001617       286 001625       289 001630       290 001634       291 001636       293 001666       294 001677
    295 001713       299 001714       301 001727       302 001732       303 001734       305 001735       307 001736
    309 001753       311 001763       312 001765       314 001766       318 001767       324 002005       325 002011
    327 002012       331 002036       332 002044       335 002054       337 002100       339 002157       340 002206
    342 002210       343 002274       352 002277       353 002301       354 002303       355 002305       356 002307
    357 002313       358 002346       359 002350       361 002372       362 002374       363 002404       364 002410
    366 002411       367 002431       368 002433       369 002436       370 002470       371 002472       373 002514
    374 002516       375 002526       376 002532       383 002533       385 002553       387 002555       389 002573
    390 002575       391 002601       394 002602       395 002605       398 002610       399 002621       401 002623
    403 002624       406 002654       408 002665       412 002666       423 002703       424 002706       426 002710
    427 002713       428 002716       431 002717       432 002721       433 002730       434 002732       435 002754
    438 002755       439 002762       441 002772       442 002774       443 003016       444 003043       447 003044
    448 003045       449 003047       452 003050       453 003052       454 003054       456 003060       457 003064
    458 003074       459 003130       461 003132       462 003141       464 003142       466 003162       467 003164
    470 003177       474 003200       486 003215       487 003220       489 003222       491 003225       492 003227
    493 003231       496 003232       497 003234       499 003236       500 003260       501 003264       502 003266
    503 003323       505 003325       506 003331       507 003343       509 003346       510 003350       512 003351
    513 003363       514 003365       515 003367       518 003370       519 003373       522 003374       523 003413
    525 003415       528 003416       529 003420       531 003440       534 003447       535 003453       536 003454
    539 003455       540 003477       541 003501       544 003502       545 003504       549 003505       556 003522
    558 003525       559 003527       560 003531       561 003533       564 003534       566 003562       569 003575
    570 003577       571 003616       573 003617       575 003623       579 003624       586 003640       587 003644
    588 003645       669 003646       673 003672       674 003736       676 004020       677 004024       592 004025
    601 004046       603 004075       604 004100       605 004103       606 004124       607 004126       608 004140
    610 004142       613 004143       616 004162       622 004163       627 004171       628 004202       629 004214
    630 004217       635 004220       639 004222       641 004234       643 004277       649 004300       658 004302
    661 004307       662 004311       664 004314


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
