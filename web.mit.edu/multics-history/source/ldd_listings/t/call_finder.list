	COMPILATION LISTING OF SEGMENT call_finder
	Compiled by: Multics PL/I Compiler, Release 28b, of April 11, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 06/03/83  1334.7 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 call_finder: proc;
       12 
       13 /* Finds all calls to entries with a given segment name
       14*
       15*   Written by:	Richard A. Barnes 24 January 1974	*/
       16 
       17 /*  Modified on 4 June 1975 by J. C. Whitmore to attempt use of system privilege initiate */
       18 
       19 /*  Modified 11/10/82 by R. Holmstedt to use the new object_info include file */
       20 /* Changed to use interpret_link_info.incl.pl1 05/12/83 S. Herbst */
       21 
       22 
       23 dcl (alen, i, nargs, nentry, ncompilers, total) fixed bin;
       24 dcl (aptr, sptr) ptr;
       25 dcl (all, added_access) bit (1) aligned;
       26 
       27 dcl  root char (168) aligned init (">");
       28 dcl  dir char (168);				/* full directory name */
       29 dcl  ename char (32);				/* entry name */
       30 dcl  target char (32) aligned;
       31 
       32 dcl 1 entry (256),
       33     2 name char (65),
       34     2 refs fixed bin;
       35 
       36 dcl 1 compiler_table (32),
       37     2 cname char (8),
       38     2 segs fixed bin,
       39     2 uses fixed bin;
       40 
       41 dcl  arg char (alen) based (aptr);
       42 
       43 dcl  have_priv bit (1) int static init ("1"b);		/* assume we have privileges for now */
       44 dcl  code fixed bin (35);
       45 dcl  me char (11) int static init ("call_finder");
       46 dcl  nl char (1) int static init ("
       47 ");
       48 dcl  ftotal float bin;
       49 dcl  total_object_segs fixed bin init (0);
       50 dcl  total_segs_with_call fixed bin init (0);
       51 
       52 dcl 1 segment_acl aligned,
       53     2 access_name char (32),
       54     2 modes bit (36) init ("1"b),			/* r */
       55     2 zero_pad bit (36) init ("0"b),
       56     2 status_code fixed bin (35);
       57 
       58 dcl 1 delete_acl aligned,
       59     2 access_name char (32),
       60     2 status_code fixed bin (35);
       61 
       62 dcl  error_table_$moderr fixed bin (35) ext;
       63 
       64 dcl  cleanup condition;
       65 
       66 dcl (addr, addrel, divide, fixed, float, hbound, index, ltrim, null, rtrim, substr) builtin;
       67 
       68 dcl  com_err_ entry options (variable);
       69 dcl  cu_$arg_count entry (fixed bin);
       70 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
       71 dcl  expand_path_ entry (ptr, fixed bin, ptr, ptr, fixed bin (35));
       72 dcl  get_group_id_ entry () returns (char (32) aligned);
       73 dcl  hcs_$add_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
       74 dcl  hcs_$delete_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
       75 dcl  hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
       76 dcl  system_privilege_$initiate_count entry
       77 	(char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
       78 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
       79 dcl  interpret_link_ entry (ptr, ptr, fixed bin (35));
       80 dcl  ioa_ entry options (variable);
       81 dcl  ios_$write_ptr entry (ptr, fixed bin, fixed bin (7));
       82 dcl  object_info_$display entry (ptr, fixed bin (24), ptr, fixed bin (35));
       83 dcl  sweep_disk_ entry (char (168) aligned, entry);
       84 
       85 
       86 
       87 	all = "0"b;
       88 	nentry, ncompilers = 0;
       89 	call cu_$arg_count (nargs);
       90 
       91 /* get name of target */
       92 
       93 	call cu_$arg_ptr (1, aptr, alen, code);
       94 
       95 	if code ^= 0
       96 	then do;
       97 err:	     call com_err_ (code, me,
       98 		"^/Usage: call_finder entry {-all, path}, ^/^-The root is default starting node for path.");
       99 	     return;
      100 	end;
      101 	if substr (arg, 1, 1) = "-" then goto err;
      102 	target = arg;
      103 
      104 /* get other 2 args */
      105 	if nargs > 3 then goto err;
      106 	do i = 2 to nargs;
      107 	     call cu_$arg_ptr (i, aptr, alen, code);
      108 
      109 	     if substr (arg, 1, 1) = "-" then do;
      110 		if arg = "-all" | arg = "-a" then do;
      111 		     if all = "1"b then goto err;
      112 				/* if all true then second time thru */
      113 		     all = "1"b;
      114 		end;
      115 		else goto err;
      116 	     end;
      117 
      118 	     else do;
      119 		call expand_path_ (aptr, alen, addr (root), null, code);
      120 		if code ^= 0 then go to err;
      121 	     end;
      122 	end;
      123 
      124 /* Now call the sweeper program */
      125 
      126 	segment_acl.access_name,
      127 	     delete_acl.access_name = get_group_id_ ();
      128 	sptr = null;
      129 	added_access = "0"b;
      130 	on condition (cleanup) call clean_up;
      131 
      132 	call sweep_disk_ (root, counter);
      133 
      134 /* now print out totals */
      135 
      136 sum:	total = 0;
      137 	do i = 1 to nentry;
      138 	     total = total + refs (i);
      139 	end;
      140 
      141 	ftotal = total;
      142 
      143 	call ioa_ ("^/^d total object segments searched^/^d segments call ^a with ^d calls^/",
      144 	     total_object_segs, total_segs_with_call, target, total);
      145 
      146 	do i = 1 to nentry;
      147 	     call ioa_ ("^a^65t^4d^70t^7.2f%", name (i), refs (i), 100.0 * (float (refs (i))/ftotal));
      148 	end;
      149 
      150 	call ioa_ ("");
      151 	do i = 1 to ncompilers;
      152 	     call ioa_ ("^8a^8d^10d", compiler_table (i).cname, compiler_table (i).segs, compiler_table (i).uses);
      153 	end;
      154 	return;
      155 	
      156 counter:	proc (superior, parent, levels, pename, bptr, nptr);
      157 
      158 dcl  superior char (168) aligned,			/* superior directory path */
      159      parent char (32) aligned,			/* parent directory name */
      160      levels fixed bin,				/* distance from root */
      161      pename char (32) aligned,			/* entry name */
      162      bptr ptr,					/* ptr to branch structure */
      163      nptr ptr;					/* ptr to names area */
      164 
      165 dcl (i, j, n) fixed bin;
      166 dcl (lptr, liptr) ptr;
      167 dcl  reference char (68) varying aligned;
      168 dcl  nbits fixed bin (24);
      169 dcl (first, firstlink) bit (1) aligned;
      170 dcl  code fixed bin (35);
      171 dcl  line char (80);
      172 dcl  written fixed bin (7);
      173 
      174 dcl  segment_type bit (2) int static init ("01"b);
      175 
      176 dcl 1 branch based aligned,
      177     2 type bit (2) unal,
      178     2 nnames bit (16) unal,
      179     2 nindex bit (18) unal;
      180 
      181 dcl 1 link_header based aligned,
      182     2 object_seg fixed bin,
      183     2 def_section bit (18) unal,
      184     2 first_reference bit (18) unal,
      185     2 section_thread ptr,
      186     2 linkage_ptr ptr,
      187     2 begin_links bit (18) unal,
      188     2 section_length bit (18) unal,
      189     2 obj_seg bit (18) unal,
      190     2 combined_length bit (18) unal;
      191 
      192 dcl 1 linkword based aligned,
      193     2 pad bit (30) unal,
      194     2 ft2 bit (6) unal;
      195 
      196 dcl 1 auto_interpret_link_info aligned like interpret_link_info;
      197 
      198 dcl (no_read_permission, not_in_read_bracket, seg_fault_error, program_interrupt, record_quota_overflow,
      199      linkage_error) condition;
      200 
      201 dcl  length builtin;
      202 
  1     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  1     2*coded February 8, 1972 by Michael J. Spier	*/
  1     3 /* modified May 26, 1972 by M. Weaver */
  1     4 /* modified 15 April, 1975 by M. Weaver */
  1     5 
  1     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  1     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  1     8 	2 textp pointer,			/* pointer to beginning of text section */
  1     9 	2 defp pointer,			/* pointer to beginning of definition section */
  1    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  1    11 	2 statp pointer,			/* pointer to beginning of static section */
  1    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  1    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  1    14 	2 tlng fixed bin,			/* length in words of text section */
  1    15 	2 dlng fixed bin,			/* length in words of definition section */
  1    16 	2 llng fixed bin,			/* length in words of linkage section */
  1    17 	2 ilng fixed bin,			/* length in words of static section */
  1    18 	2 slng fixed bin,			/* length in words of symbol section */
  1    19 	2 blng fixed bin,			/* length in words of break map */
  1    20 	2 format,				/* word containing bit flags about object type */
  1    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  1    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  1    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  1    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  1    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  1    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  1    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  1    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  1    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  1    30 	  3 pad bit(27) unaligned,
  1    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  1    32 	2 textlinkp pointer,		/* ptr to first link in text */
  1    33 
  1    34 	/* LIMIT OF BRIEF STRUCTURE */
  1    35 
  1    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  1    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  1    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  1    39 	2 cvers aligned,			/* generator version name in printable char string form */
  1    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  1    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  1    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  1    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  1    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  1    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  1    46 
  1    47 	/* LIMIT OF DISPLAY STRUCTURE */
  1    48 
  1    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  1    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  1    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  1    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  1    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  1    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  1    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  1    56 					/* currently not used by system */
  1    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  1    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  1    59 
  1    60 declare	object_info_version_2 fixed bin int static init(2);
  1    61 
  1    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      203 
      204 
      205 dcl  1 obj_info like object_info;
      206 
      207 
  2     1 /*  BEGIN INCLUDE FILE interpret_link_info.incl.pl1  */
  2     2 
  2     3 /* Written 05/12/83 by S. Herbst */
  2     4 
  2     5 dcl 1 interpret_link_info aligned based (interpret_link_info_ptr),
  2     6    2 version char (8),
  2     7    2 segment_name char (32) aligned,
  2     8    2 entry_point_name char (260) aligned,
  2     9    2 expression char (8) aligned,
  2    10    2 modifier char (4) aligned,
  2    11    2 trap char (48) aligned;
  2    12 
  2    13 dcl INTERPRET_LINK_INFO_VERSION_1 char (8) int static options (constant) init ("ILI 1.0");
  2    14 
  2    15 dcl interpret_link_info_ptr ptr;
  2    16 
  2    17 /* END INCLUDE FILE interpret_link_info.incl.pl1  */
      208 
      209 
      210 /* first, see if we could have an object segment */
      211                obj_info.version_number = object_info_version_2;
      212 	     if bptr -> branch.type ^= segment_type then return;
      213 
      214 	     ename = pename;
      215 	     if index (ename, ".") ^= 0 then return;
      216 	     if substr (ename, 1, 1) = "!" then return;
      217 
      218 /* we might have one, so let's initiate it */
      219 
      220 	     if superior ^= ""
      221 	     then dir = rtrim (superior) || ">" || parent;
      222 	     else dir = parent;
      223 
      224 	     on linkage_error begin;
      225 		have_priv = "0"b;
      226 		go to init_seg;
      227 	     end;
      228 
      229 init_seg:
      230 
      231 	     if have_priv
      232 	     then call system_privilege_$initiate_count (dir, ename, "", nbits, 1, sptr, code);
      233 	     else call hcs_$initiate_count (dir, ename, "", nbits, 1, sptr, code);
      234 
      235 	     revert linkage_error;			/* we have the privilege we need */
      236 
      237 	     if sptr = null
      238 	     then if code = error_table_$moderr
      239 		then do;
      240 		     call hcs_$add_acl_entries (dir, ename, addr (segment_acl), 1, code);
      241 		     if code ^= 0 then return;
      242 		     added_access = "1"b;
      243 		     if have_priv
      244 		     then call system_privilege_$initiate_count (dir, ename, "", nbits, 1, sptr, code);
      245 		     else call hcs_$initiate_count (dir, ename, "", nbits, 1, sptr, code);
      246 		     if sptr = null then go to finish;
      247 		end;
      248 		else return;
      249 
      250 /* prepare for somebody's interfering with us */
      251 
      252 	     on condition (cleanup) call clean_up;
      253 	     on condition (record_quota_overflow) go to finish;
      254 	     on condition (program_interrupt) go to finish;
      255 	     on condition (seg_fault_error) go to finish;
      256 	     on condition (no_read_permission) go to finish;
      257 	     on condition (not_in_read_bracket) go to finish;
      258 
      259 /* object_info_ will tell us about the object segment */
      260 
      261 	     call object_info_$display (sptr, nbits, addr (obj_info), code);
      262 	     if code ^= 0 then go to finish;
      263 
      264 	     total_object_segs = total_object_segs + 1;
      265 
      266 /* record count of compiler names. */
      267 
      268 	     do j = 1 to ncompilers while (compiler_table (j).cname ^= obj_info.compiler);
      269 	     end;
      270 	     if j <= ncompilers then compiler_table (j).segs = compiler_table (j).segs + 1;
      271 	     else if j <= hbound (compiler_table, 1) then do;
      272 		ncompilers = j;
      273 		compiler_table (j).cname = obj_info.compiler;
      274 		compiler_table (j).segs = 1;
      275 		compiler_table (j).uses = 0;
      276 	     end;
      277 	     else do;
      278 		call com_err_ (0, me, "compiler table full");
      279 		call clean_up;
      280 		go to sum;
      281 	     end;
      282 
      283 /* now, we have to look at the links */
      284 
      285 	     first, firstlink = "1"b;
      286 	     lptr = addrel (obj_info.linkp, obj_info.linkp -> link_header.begin_links);
      287 	     n = divide (obj_info.llng - fixed (obj_info.linkp -> link_header.begin_links, 18), 2, 17, 0);
      288 
      289 
      290 	     do i = 1 to n;
      291 		if lptr -> linkword.ft2 = "100110"b	/* fault 2 tag */
      292 		then do;
      293 
      294 /* we have a link, see if it points at target seg */
      295 
      296 		     auto_interpret_link_info.version = INTERPRET_LINK_INFO_VERSION_1;
      297 
      298 		     call interpret_link_ (addr (auto_interpret_link_info), lptr, code);
      299 		     if code ^= 0 then go to finish;
      300 
      301 		     if auto_interpret_link_info.segment_name = target
      302 		     then do;
      303 
      304 /* PAYDIRT! */
      305 
      306 			if firstlink then do;
      307 			     firstlink = "0"b;
      308 			     total_segs_with_call = total_segs_with_call + 1;
      309 			     compiler_table (j).uses = compiler_table (j).uses + 1;
      310 			end;
      311 
      312 			reference = rtrim (auto_interpret_link_info.segment_name) ||
      313 			     rtrim (auto_interpret_link_info.entry_point_name) || " ";
      314 
      315 /* put entry into table */
      316 
      317 			do j = 1 to nentry while (entry (j).name ^= reference);
      318 			end;
      319 
      320 			if j <= nentry
      321 			then entry (j).refs = entry (j).refs + 1;
      322 			else if j <= hbound (entry, 1)
      323 			then do;
      324 			     nentry = j;
      325 			     entry (j).name = reference;
      326 			     entry (j).refs = 1;
      327 			end;
      328 			else do;
      329 			     call com_err_ (0, me, "table_overflow");
      330 			     call clean_up;
      331 			     go to sum;
      332 			end;
      333 
      334 /* print out information */
      335 
      336 			if all then do;
      337 			     if first then do;
      338 				call ioa_ ("^/>^a>^a (^a)", ltrim(dir,">"), ename, obj_info.compiler);
      339 				first = "0"b;
      340 				line = " ";
      341 				written = 1;
      342 			     end;
      343 
      344 			     if length (reference) + written >= length (line)
      345 			     then call write;
      346 
      347 			     substr (line, written+1, length (reference)) = reference;
      348 			     written = written + length (reference);
      349 			end;
      350 		     end;
      351 		end;
      352 
      353 		lptr = addrel (lptr, 2);
      354 	     end;
      355 
      356 /* write list line */
      357 
      358 	     if ^ first then call write;
      359 
      360 /* CLEAN UP! */
      361 
      362 clean_up:	     entry;
      363 
      364 finish:
      365 	     if sptr ^= null
      366 	     then do;
      367 		call hcs_$terminate_noname (sptr, code);
      368 		sptr = null;
      369 	     end;
      370 
      371 	     if added_access
      372 	     then do;
      373 		call hcs_$delete_acl_entries (dir, ename, addr (delete_acl), 1, code);
      374 		added_access = "0"b;
      375 	     end;
      376 
      377 	     return;
      378 
      379 
      380 write:	     proc;
      381 
      382 		written = written + 1;
      383 		substr (line, written, 1) = nl;
      384 		call ios_$write_ptr (addr (line), 0, written);
      385 		written = 1;
      386 
      387 	     end;
      388 
      389 	end;
      390 
      391      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/03/83  1330.4  call_finder.pl1                   >special_ldd>on>06/03/83-1>call_finder.pl1
203          1    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
208          2    06/03/83  1330.6  interpret_link_info.incl.pl1      >special_ldd>on>06/03/83-1>interpret_link_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
INTERPRET_LINK_INFO_VERSION_1   000000 constant        char(8)                  initial unaligned dcl 2-13 ref 296
access_name                     011464 automatic       char(32)                 level 2 in structure "segment_acl" dcl 52
                                                                                  in procedure "call_finder" set ref 126*
access_name                     011477 automatic       char(32)                 level 2 in structure "delete_acl" dcl 58
                                                                                  in procedure "call_finder" set ref 126*
added_access                    000113 automatic       bit(1)                   dcl 25 set ref 129* 242* 371 374*
addr                                                   builtin function         dcl 66 ref 119 119 240 240 261 261 298 298 373 373
                                                                                  384 384
addrel                                                 builtin function         dcl 66 ref 286 353
alen                            000100 automatic       fixed bin(17,0)          dcl 23 set ref 93* 101 102 107* 109 110 110 119*
all                             000112 automatic       bit(1)                   dcl 25 set ref 87* 111 113* 336
aptr                            000106 automatic       pointer                  dcl 24 set ref 93* 101 102 107* 109 110 110 119*
arg                                    based           char                     unaligned dcl 41 ref 101 102 109 110 110
auto_interpret_link_info        000161 automatic       structure                level 1 dcl 196 set ref 298 298
begin_links               6            based           bit(18)                  level 2 packed unaligned dcl 181 ref 286 287
bptr                                   parameter       pointer                  dcl 158 ref 156 212
branch                                 based           structure                level 1 dcl 176
cleanup                         011510 stack reference condition                dcl 64 ref 130 252
cname                           011260 automatic       char(8)                  array level 2 packed unaligned dcl 36 set ref 152*
                                                                                  268 273*
code                            011460 automatic       fixed bin(35,0)          dcl 44 in procedure "call_finder" set ref 93* 95 97*
                                                                                  107* 119* 120
code                            000133 automatic       fixed bin(35,0)          dcl 170 in procedure "counter" set ref 229* 233* 237
                                                                                  240* 241 243* 245* 261* 262 298* 299 367* 373*
com_err_                        000016 constant        entry                    external dcl 68 ref 97 278 329
compiler                 30     000360 automatic       char(8)                  level 2 dcl 205 set ref 268 273 338*
compiler_table                  011260 automatic       structure                array level 1 unaligned dcl 36 set ref 271
cu_$arg_count                   000020 constant        entry                    external dcl 69 ref 89
cu_$arg_ptr                     000022 constant        entry                    external dcl 70 ref 93 107
delete_acl                      011477 automatic       structure                level 1 dcl 58 set ref 373 373
dir                             000166 automatic       char(168)                unaligned dcl 28 set ref 220* 222* 229* 233* 240*
                                                                                  243* 245* 338 338 373*
divide                                                 builtin function         dcl 66 ref 287
ename                           000240 automatic       char(32)                 unaligned dcl 29 set ref 214* 215 216 229* 233* 240*
                                                                                  243* 245* 338* 373*
entry                           000260 automatic       structure                array level 1 unaligned dcl 32 set ref 322
entry_point_name         12     000161 automatic       char(260)                level 2 dcl 196 set ref 312
error_table_$moderr             000014 external static fixed bin(35,0)          dcl 62 ref 237
expand_path_                    000024 constant        entry                    external dcl 71 ref 119
first                           000131 automatic       bit(1)                   dcl 169 set ref 285* 337 339* 358
firstlink                       000132 automatic       bit(1)                   dcl 169 set ref 285* 306 307*
fixed                                                  builtin function         dcl 66 ref 287
float                                                  builtin function         dcl 66 ref 147
ft2                       0(30)        based           bit(6)                   level 2 packed unaligned dcl 192 ref 291
ftotal                          011461 automatic       float bin(27)            dcl 48 set ref 141* 147
get_group_id_                   000026 constant        entry                    external dcl 72 ref 126
have_priv                       000010 internal static bit(1)                   initial unaligned dcl 43 set ref 225* 229 243
hbound                                                 builtin function         dcl 66 ref 271 322
hcs_$add_acl_entries            000030 constant        entry                    external dcl 73 ref 240
hcs_$delete_acl_entries         000032 constant        entry                    external dcl 74 ref 373
hcs_$initiate_count             000034 constant        entry                    external dcl 75 ref 233 245
hcs_$terminate_noname           000040 constant        entry                    external dcl 78 ref 367
i                               000101 automatic       fixed bin(17,0)          dcl 23 in procedure "call_finder" set ref 106* 107*
                                                                                  137* 138* 146* 147 147 147* 151* 152 152 152*
i                               000100 automatic       fixed bin(17,0)          dcl 165 in procedure "counter" set ref 290*
index                                                  builtin function         dcl 66 ref 215
interpret_link_                 000042 constant        entry                    external dcl 79 ref 298
interpret_link_info                    based           structure                level 1 dcl 2-5
ioa_                            000044 constant        entry                    external dcl 80 ref 143 147 150 152 338
ios_$write_ptr                  000046 constant        entry                    external dcl 81 ref 384
j                               000101 automatic       fixed bin(17,0)          dcl 165 set ref 268* 268* 270 270 270 271 272 273
                                                                                  274 275 309 309 317* 317* 320 320 320 322 324 325
                                                                                  326
length                                                 builtin function         dcl 201 ref 344 344 347 348
levels                                 parameter       fixed bin(17,0)          dcl 158 ref 156
line                            000134 automatic       char(80)                 unaligned dcl 171 set ref 340* 344 347* 383* 384 384
link_header                            based           structure                level 1 dcl 181
linkage_error                   000352 stack reference condition                dcl 198 ref 224 235
linkp                     6     000360 automatic       pointer                  level 2 dcl 205 set ref 286 286 287
linkword                               based           structure                level 1 dcl 192
llng                     20     000360 automatic       fixed bin(17,0)          level 2 dcl 205 set ref 287
lptr                            000104 automatic       pointer                  dcl 166 set ref 286* 291 298* 353* 353
ltrim                                                  builtin function         dcl 66 ref 338 338
me                              000011 internal static char(11)                 initial unaligned dcl 45 set ref 97* 278* 329*
modes                    10     011464 automatic       bit(36)                  initial level 2 dcl 52 set ref 52*
n                               000102 automatic       fixed bin(17,0)          dcl 165 set ref 287* 290
name                            000260 automatic       char(65)                 array level 2 packed unaligned dcl 32 set ref 147*
                                                                                  317 325*
nargs                           000102 automatic       fixed bin(17,0)          dcl 23 set ref 89* 105 106
nbits                           000130 automatic       fixed bin(24,0)          dcl 168 set ref 229* 233* 243* 245* 261*
ncompilers                      000104 automatic       fixed bin(17,0)          dcl 23 set ref 88* 151 268 270 272*
nentry                          000103 automatic       fixed bin(17,0)          dcl 23 set ref 88* 137 146 317 320 324*
nl                                     constant        char(1)                  initial unaligned dcl 46 ref 383
no_read_permission              000314 stack reference condition                dcl 198 ref 256
not_in_read_bracket             000322 stack reference condition                dcl 198 ref 257
nptr                                   parameter       pointer                  dcl 158 ref 156
null                                                   builtin function         dcl 66 ref 119 119 128 237 246 364 368
obj_info                        000360 automatic       structure                level 1 unaligned dcl 205 set ref 261 261
object_info                            based           structure                level 1 dcl 1-6
object_info_$display            000050 constant        entry                    external dcl 82 ref 261
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 1-60 ref 211
parent                                 parameter       char(32)                 dcl 158 ref 156 220 222
pename                                 parameter       char(32)                 dcl 158 ref 156 214
program_interrupt               000336 stack reference condition                dcl 198 ref 254
record_quota_overflow           000344 stack reference condition                dcl 198 ref 253
reference                       000106 automatic       varying char(68)         dcl 167 set ref 312* 317 325 344 347 347 348
refs                     21     000260 automatic       fixed bin(17,0)          array level 2 dcl 32 set ref 138 147* 147 320* 320
                                                                                  326*
root                            000114 automatic       char(168)                initial dcl 27 set ref 27* 119 119 132*
rtrim                                                  builtin function         dcl 66 ref 220 312 312
seg_fault_error                 000330 stack reference condition                dcl 198 ref 255
segment_acl                     011464 automatic       structure                level 1 dcl 52 set ref 240 240
segment_name              2     000161 automatic       char(32)                 level 2 dcl 196 set ref 301 312
segment_type                           constant        bit(2)                   initial unaligned dcl 174 ref 212
segs                      2     011260 automatic       fixed bin(17,0)          array level 2 dcl 36 set ref 152* 270* 270 274*
sptr                            000110 automatic       pointer                  dcl 24 set ref 128* 229* 233* 237 243* 245* 246 261*
                                                                                  364 367* 368*
substr                                                 builtin function         dcl 66 set ref 101 109 216 347* 383*
superior                               parameter       char(168)                dcl 158 ref 156 220 220
sweep_disk_                     000052 constant        entry                    external dcl 83 ref 132
system_privilege_$initiate_count
                                000036 constant        entry                    external dcl 76 ref 229 243
target                          000250 automatic       char(32)                 dcl 30 set ref 102* 143* 301
total                           000105 automatic       fixed bin(17,0)          dcl 23 set ref 136* 138* 138 141 143*
total_object_segs               011462 automatic       fixed bin(17,0)          initial dcl 49 set ref 49* 143* 264* 264
total_segs_with_call            011463 automatic       fixed bin(17,0)          initial dcl 50 set ref 50* 143* 308* 308
type                                   based           bit(2)                   level 2 packed unaligned dcl 176 ref 212
uses                      3     011260 automatic       fixed bin(17,0)          array level 2 dcl 36 set ref 152* 275* 309* 309
version                         000161 automatic       char(8)                  level 2 dcl 196 set ref 296*
version_number                  000360 automatic       fixed bin(17,0)          level 2 dcl 205 set ref 211*
written                         000160 automatic       fixed bin(7,0)           dcl 172 set ref 341* 344 347 348* 348 382* 382 383
                                                                                  384* 385*
zero_pad                 11     011464 automatic       bit(36)                  initial level 2 dcl 52 set ref 52*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
interpret_link_info_ptr                automatic       pointer                  dcl 2-15
liptr                                  automatic       pointer                  dcl 166

NAMES DECLARED BY EXPLICIT CONTEXT.
call_finder                     000171 constant        entry                    external dcl 11
clean_up                        002171 constant        entry                    internal dcl 362 ref 130 252 279 330
counter                         000657 constant        entry                    internal dcl 156 ref 132 132
err                             000240 constant        label                    dcl 97 ref 101 105 110 111 120
finish                          002176 constant        label                    dcl 364 ref 246 253 254 255 256 257 262 299
init_seg                        001011 constant        label                    dcl 229 ref 226
sum                             000455 constant        label                    dcl 136 ref 280 331
write                           002261 constant        entry                    internal dcl 380 ref 344 358

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2636        2712    2314        2646
Length      3174    2314        54         245     321           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
call_finder                        5024 external procedure  is an external procedure.  
on unit on line 130                  64 on unit               
counter                             370 internal procedure  is assigned to an entry variable, and enables or reverts conditions.  
on unit on line 224                  64 on unit               
on unit on line 252                  64 on unit               
on unit on line 253                  64 on unit               
on unit on line 254                  64 on unit               
on unit on line 255                  64 on unit               
on unit on line 256                  64 on unit               
on unit on line 257                  64 on unit               
write                                   internal procedure  shares stack frame of internal procedure counter.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 have_priv                   call_finder
000011 me                          call_finder

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
call_finder              000100 alen                        call_finder
                         000101 i                           call_finder
                         000102 nargs                       call_finder
                         000103 nentry                      call_finder
                         000104 ncompilers                  call_finder
                         000105 total                       call_finder
                         000106 aptr                        call_finder
                         000110 sptr                        call_finder
                         000112 all                         call_finder
                         000113 added_access                call_finder
                         000114 root                        call_finder
                         000166 dir                         call_finder
                         000240 ename                       call_finder
                         000250 target                      call_finder
                         000260 entry                       call_finder
                         011260 compiler_table              call_finder
                         011460 code                        call_finder
                         011461 ftotal                      call_finder
                         011462 total_object_segs           call_finder
                         011463 total_segs_with_call        call_finder
                         011464 segment_acl                 call_finder
                         011477 delete_acl                  call_finder
counter                  000100 i                           counter
                         000101 j                           counter
                         000102 n                           counter
                         000104 lptr                        counter
                         000106 reference                   counter
                         000130 nbits                       counter
                         000131 first                       counter
                         000132 firstlink                   counter
                         000133 code                        counter
                         000134 line                        counter
                         000160 written                     counter
                         000161 auto_interpret_link_info    counter
                         000360 obj_info                    counter

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_other
return              tra_ext             enable              shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   expand_path_
get_group_id_                 hcs_$add_acl_entries          hcs_$delete_acl_entries       hcs_$initiate_count
hcs_$terminate_noname         interpret_link_               ioa_                          ios_$write_ptr
object_info_$display          sweep_disk_                   system_privilege_$initiate_count

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$moderr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000170        27 000176        49 000201        50 000202        52 000203        87 000206        88 000207
     89 000211        93 000217        95 000236        97 000240        99 000264       101 000265       102 000272
    105 000276       106 000301       107 000307       109 000324       110 000331       111 000342       113 000345
    116 000347       119 000350       120 000373       122 000375       126 000377       128 000414       129 000416
    130 000417       132 000441       136 000455       137 000456       138 000465       139 000470       141 000472
    143 000475       146 000527       147 000537       148 000577       150 000601       151 000612       152 000621
    153 000653       154 000655       156 000656       211 000664       212 000666       214 000674       215 000701
    216 000712       220 000716       222 000764       224 000771       225 001005       226 001006       229 001011
    233 001060       235 001123       237 001124       240 001135       241 001171       242 001173       243 001176
    245 001244       246 001306       247 001313       248 001314       252 001315       253 001337       254 001356
    255 001375       256 001414       257 001433       261 001452       262 001472       264 001474       268 001476
    269 001513       270 001515       271 001524       272 001526       273 001527       274 001534       275 001536
    276 001537       278 001540       279 001565       280 001572       285 001575       286 001600       287 001606
    290 001614       291 001623       296 001627       298 001632       299 001647       301 001651       306 001656
    307 001660       308 001661       309 001662       312 001665       317 001744       318 001765       320 001767
    322 001776       324 002000       325 002001       326 002007       327 002012       329 002013       330 002043
    331 002050       336 002053       337 002055       338 002057       339 002133       340 002135       341 002140
    344 002142       347 002147       348 002155       353 002157       354 002162       358 002164       362 002167
    364 002176       367 002203       368 002214       371 002217       373 002221       374 002256       377 002260
    380 002261       382 002262       383 002263       384 002267       385 002305       387 002307


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
