	COMPILATION LISTING OF SEGMENT log_limit_scan_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 02/27/89  1053.1 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1989                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(89-01-16,TLNguyen), approve(89-01-16,MCR8046),
       12*     audit(89-02-03,Parisek), install(89-02-27,MR12.3-1015):
       13*     Set sci_ptr value before referencing the it.
       14*                                                   END HISTORY COMMENTS */
       15 
       16 
       17 log_limit_scan_:
       18      procedure (P_caller_sci_ptr, P_log_limit_info_ptr, 
       19 	      P_reverse_sw, P_log_read_ptr);
       20 
       21 /* *	LOG_LIMIT_SCAN_
       22*   *
       23*   *	This procedure is used by log-scanning programs to implement the 
       24*   *	-to / -from / -for / -last control arguments. See print_sys_log
       25*   *	for an example of its use. 
       26*   *
       27*   *	Modification history:
       28*   *	84-08-23, W. Olin Sibert: Initial coding
       29*   *      1984-12-10, BIM: remove the entry variables, convert to ssu_.
       30*   *      1984-12-16, BIM: added hold/free message calls for inner ring logs.
       31*   *	1985-03-11, Steve Herbst: Fixed to say "Log is empty." if so.
       32*   *	1985-04-04, Steve Herbst: Fixed -from N, -to N to allow for
       33*   *		missing sequence numbers in log.
       34*   *	1985-05-01, Steve Herbst: Fixed bug that returned the msgs before
       35*   *		and after the range if none in range.
       36*   */
       37 
       38 declare	P_caller_sci_ptr pointer;
       39 declare	P_log_limit_info_ptr pointer parameter;
       40 declare	P_reverse_sw bit (1) aligned parameter;
       41 declare	P_log_read_ptr pointer parameter;
       42 
       43 declare	(FROM_TYPE init (1), TO_TYPE init (2)) fixed bin int static options (constant);
       44 
       45 declare	code fixed bin (35);
       46 declare   sci_ptr pointer;
       47 declare	log_read_ptr pointer;
       48 
       49 declare 1 opt aligned automatic,
       50 	2 to_number fixed bin (35),
       51 	2 from_number fixed bin (35),
       52 	2 for_number fixed bin (35),
       53 	2 last_number fixed bin (35),
       54 	2 to_time fixed bin (71),
       55 	2 from_time fixed bin (71),
       56 	2 for_time fixed bin (71),
       57 	2 last_time fixed bin (71);
       58 
       59 declare	to_given bit (1) aligned;
       60 declare	from_given bit (1) aligned;
       61 declare	for_given bit (1) aligned;
       62 declare	last_given bit (1) aligned;
       63 declare	none_given bit (1) aligned;
       64 
       65 declare	error_table_$bad_conversion fixed bin (35) external static;
       66 declare	error_table_$inconsistent fixed bin (35) external static;
       67 declare	error_table_$no_log_message fixed bin (35) external static;
       68 declare   error_table_$unimplemented_version fixed bin(35) ext static;
       69 
       70 declare	cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
       71 declare	convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
       72 declare	convert_date_to_binary_$relative entry (char (*), fixed bin (71), fixed bin (71), fixed bin (35));
       73 
       74 declare   log_read_$free_message entry (pointer, pointer);
       75 declare   log_read_$hold_message entry (pointer, pointer);
       76 declare   log_read_$position_sequence entry (pointer, fixed binary (35), bit (1) aligned, pointer,
       77 	fixed binary (35));
       78 declare   log_read_$position_time entry (pointer, fixed binary (71), bit (1) aligned, pointer, fixed binary (35));
       79 declare	log_format_time_ entry (fixed bin (71)) returns (char (32) varying);
       80 declare   ssu_$abort_line entry options(variable);
       81 
       82 declare	AFTER init (1) fixed bin internal static options (constant);
       83 declare	BEFORE init (-1) fixed bin internal static options (constant);
       84 
       85 declare  (clock, max, null) builtin;
       86 
       87 /* */
       88 
       89 	log_limit_info_ptr = P_log_limit_info_ptr;
       90 	log_read_ptr = P_log_read_ptr;
       91 	sci_ptr = P_caller_sci_ptr;
       92 
       93 	if log_limit_info.version ^= LOG_LIMIT_INFO_VERSION_1
       94 	then call ssu_$abort_line (sci_ptr, error_table_$unimplemented_version, "Invalid version ^a in call to log_limit_scan_.", log_limit_info.version);
       95 
       96 	call get_time_or_number ("-from", log_limit_info.from_opt, opt.from_time, opt.from_number);
       97 	call get_time_or_number ("-to", log_limit_info.to_opt, opt.to_time, opt.to_number);
       98 	call get_time_or_number ("-for", log_limit_info.for_opt, opt.for_time, opt.for_number);
       99 	call get_time_or_number ("-last", log_limit_info.last_opt, opt.last_time, opt.last_number);
      100 
      101 	call check_consistency ();
      102 
      103 	call find_message_limits ();
      104 
      105 MAIN_RETURN:
      106 	return;
      107 
      108 /* */
      109 
      110 check_consistency:
      111      procedure ();
      112 
      113 /* The get_time_or_number procedure has already made sure that only one of each of these is true */
      114 
      115 	to_given = (opt.to_number >= 0) | (opt.to_time >= 0);
      116 	from_given = (opt.from_number >= 0) | (opt.from_time >= 0);
      117 	for_given = (opt.for_number >= 0) | (opt.for_time >= 0);
      118 	last_given = (opt.last_number >= 0) | (opt.last_time >= 0);
      119 	none_given = ^(to_given | from_given | for_given | last_given);
      120 
      121 /* Reject the impossible combinations of control arguments */
      122 
      123 	if to_given & for_given then call inconsistent ("-to and -for");
      124 	if to_given & last_given then call inconsistent ("-to and -last");
      125 	if from_given & last_given then call inconsistent ("-from and -last");
      126 	if for_given & last_given then call inconsistent ("-for and -last");
      127 	if for_given & ^from_given then call inconsistent ("-for and not -from");
      128 
      129 /* There are six valid combinations remaining after this filtering:
      130*       1) No specifiers at all     - Whole log
      131*       2) -to      alone	     - Beginning up to limit
      132*       3) -from    alone	     - Limit up to now
      133*       4) -last    alone	     - Now minus limit until now
      134*       5) -from    and     -to     - Limit-1 to Limit-2
      135*       6) -from    and     -for    - Limit-1 to Limit-1 plus Limit-2
      136*   This is additionally complicated by cases 4 & 6, which must count *matching*
      137*   messages, rather than simply doing arithmetic on message numbers.
      138*   */
      139 
      140 	return;
      141 	end check_consistency;
      142 
      143 /* */
      144 
      145 find_message_limits:
      146      procedure ();
      147 
      148 declare	from_relative_time fixed bin (71);
      149 declare	last_time_delta fixed bin (71);
      150 declare	exchange_ptr pointer;
      151 
      152 declare 1 first_message aligned like log_message.header based (log_limit_info.first_msg);
      153 declare 1 last_message aligned like log_message.header based (log_limit_info.last_msg);
      154 
      155 
      156 	log_limit_info.first_msg = null ();
      157 	log_limit_info.last_msg = null ();
      158 	log_limit_info.msg_count = -1;
      159 
      160 /* First, see if we have absolute numeric or time values for any of the limits,
      161*   and find the appropriate messages for the limits. */
      162 
      163 	if (opt.to_number >= 0) then do;
      164 	     call free_message (log_limit_info.last_msg);
      165 	     log_limit_info.last_msg = find_message_number (opt.to_number, TO_TYPE);
      166 	     call hold_message (log_limit_info.last_msg);
      167 	end;
      168 
      169 	if (opt.from_number >= 0) then do;
      170 	     call free_message (log_limit_info.first_msg);
      171 	     log_limit_info.first_msg = find_message_number (opt.from_number, FROM_TYPE);
      172 	     call hold_message (log_limit_info.first_msg);
      173 	end;
      174 
      175 	if (opt.to_number >= 0) & (opt.from_number >= 0) &
      176 	     (log_limit_info.last_msg ^= null) & (log_limit_info.first_msg ^= null) then
      177 		if log_limit_info.first_msg -> log_message.time > log_limit_info.last_msg -> log_message.time then
      178 		     call ssu_$abort_line (sci_ptr, 0, "No messages within specified sequence range.");
      179 
      180 /* And now the time range */
      181 	     
      182 	if (opt.to_time >= 0) then do;
      183 	     call free_message (log_limit_info.last_msg);
      184 	     log_limit_info.last_msg = find_message_time (opt.to_time, BEFORE);
      185 	     call hold_message (log_limit_info.last_msg);
      186 	end;
      187 
      188 	if (opt.from_time >= 0) then do;
      189 	     call free_message (log_limit_info.first_msg);
      190 	     log_limit_info.first_msg = find_message_time (opt.from_time, AFTER);
      191 	     call hold_message (log_limit_info.first_msg);
      192 	end;
      193 
      194 	if (opt.to_time >= 0) & (opt.from_time >= 0) &
      195 	     (log_limit_info.last_msg ^= null) & (log_limit_info.first_msg ^= null) then
      196 		if log_limit_info.first_msg -> log_message.time > log_limit_info.last_msg -> log_message.time then
      197 		     call ssu_$abort_line (sci_ptr, 0, "No messages within specified time range.");
      198 
      199 /* Second, calculate any of the implied absolute limits */
      200 
      201 	if none_given then do;			/* These calls are guaranteed to succeed */
      202 	     call free_message (log_limit_info.first_msg);
      203 	     call free_message (log_limit_info.last_msg);
      204 	     log_limit_info.first_msg = find_message_time (0, AFTER);
      205 	     log_limit_info.last_msg = find_message_time (clock (), BEFORE);
      206 	     call hold_message (log_limit_info.first_msg);
      207 	     call hold_message (log_limit_info.last_msg);
      208 	end;
      209 
      210 	if from_given & ^(to_given | for_given) then do;
      211 	     call free_message (log_limit_info.last_msg);
      212 	     log_limit_info.last_msg = find_message_time (clock (), BEFORE);
      213 	     call hold_message (log_limit_info.last_msg);
      214 	end;
      215 
      216 	if to_given & ^from_given then do;
      217 	     call free_message (log_limit_info.first_msg);
      218 	     log_limit_info.first_msg = find_message_time (0, AFTER);
      219 	     call hold_message (log_limit_info.first_msg);
      220 	end;
      221 
      222 /* Third, if we have relative limit numbers, set the limit counter to so indicate */
      223 
      224 	if (opt.last_number > 0) then do;
      225 	     log_limit_info.msg_count = opt.last_number;
      226 	     call free_message (log_limit_info.last_msg);
      227 	     log_limit_info.last_msg = find_message_time (clock (), BEFORE);
      228 	     call hold_message (log_limit_info.last_msg);
      229 	     end;
      230 
      231 	if (opt.for_number > 0) then
      232 	     log_limit_info.msg_count = opt.for_number;
      233 
      234 /* Finally, handle the relative limits: -for TIME and -last TIME; these must be
      235*   recalculated explicitly now that we know the relevant message start limits.
      236*   Note that this is why we squirreled away the character representations of the
      237*   argument for -for. */
      238 
      239 	if (opt.for_time >= 0) then do;		/* Turn -for into a relative time if appropriate */
      240 	     if (opt.from_time >= 0) then		/* We are guaranteed to have a -from time or message number */
      241 		from_relative_time = opt.from_time;	/* here, and therefore to have a valid first_message ptr */
      242 	     else from_relative_time = first_message.time;
      243 						/* If it's a message number we have */
      244 
      245 						/* we get the time out of the message. */
      246 
      247                call convert_date_to_binary_$relative ((log_limit_info.for_opt), opt.for_time, from_relative_time, code);
      248 	     if (code ^= 0) then 	/* Shouldn't happen, since it worked before */
      249 		call ssu_$abort_line (sci_ptr, code, "-for ^a after ^a",
      250 		     log_limit_info.for_opt, log_format_time_ (from_relative_time));
      251 
      252 	     call free_message (log_limit_info.last_msg);
      253 	     log_limit_info.last_msg = find_message_time (opt.for_time, BEFORE);
      254 	     call hold_message (log_limit_info.last_msg);
      255 	     end;
      256 
      257 	if (opt.last_time >= 0) then do;		/* Turn -last into backwards offset from now */
      258 	     from_relative_time = clock ();		/* We have to subtract it from the one we have */
      259 	     call free_message (log_limit_info.last_msg);
      260 	     log_limit_info.last_msg = find_message_time (from_relative_time, BEFORE);
      261 	     call hold_message (log_limit_info.last_msg);
      262 	     last_time_delta = max (0, (opt.last_time - from_relative_time));
      263 	     call free_message (log_limit_info.first_msg);
      264 	     log_limit_info.first_msg = find_message_time ((from_relative_time - last_time_delta), BEFORE);
      265 	     call hold_message (log_limit_info.first_msg);
      266 	     end;
      267 
      268 /* We also must exchange the limits in case something is out of sequence */
      269 
      270 	if (log_limit_info.first_msg ^= null ()) then
      271 	     if (log_limit_info.last_msg ^= null ()) then
      272 		if (first_message.sequence > last_message.sequence) then
      273 		     if (first_message.time > last_message.time) then do;
      274 			exchange_ptr = log_limit_info.first_msg;
      275 			log_limit_info.first_msg = log_limit_info.last_msg;
      276 			log_limit_info.last_msg = exchange_ptr;
      277 			end;
      278 
      279 /* Some validity checks in case the amazing mess above does not, in fact, work. */
      280 
      281 	if (log_limit_info.first_msg = null ()) & (log_limit_info.last_msg = null ()) then 
      282 	     call ssu_$abort_line (sci_ptr, 0, "Internal error in log_limit_scan_: first and last message pointers are both null.");
      283 
      284 	if ((log_limit_info.first_msg = null ()) | (log_limit_info.last_msg = null ())) & (log_limit_info.msg_count < 0) then 
      285 	     call ssu_$abort_line (sci_ptr, 0, "Internal error in log_limit_scan_: null first/last message pointer and no limit count.");
      286 
      287 /* NOTE: THESE TESTS REMOVED 84-09-30 BECAUSE THEY SEEMED LIKE A POOR IDEA
      288*	if (log_limit_info.first_msg = null ()) & ^P_reverse_sw then
      289*	     call inconsistent ("No initial message specified and not -reverse.");
      290*
      291*	if (log_limit_info.last_msg = null ()) & P_reverse_sw then
      292*	     call inconsistent ("No final message specified and -reverse.");
      293********/
      294 
      295 	return;
      296 	end find_message_limits;
      297 
      298 /* */
      299 
      300 find_message_number:
      301      procedure (P_number, P_arg_type) returns (pointer);
      302 
      303 declare	(P_number, number) fixed bin (35);
      304 declare	(P_arg_type, i) fixed bin;
      305 
      306 declare	msg_ptr pointer;
      307 
      308 
      309 	number = P_number;
      310 	code = 1;
      311 
      312 	do i = 1 to 20 while (code ^= 0);		/* allow 20 missing sequence numbers in log */
      313 
      314 	     call log_read_$position_sequence (log_read_ptr, number, "0"b, msg_ptr, code);
      315 
      316 	     if (code = 0) then			/* Require an exact match for this subroutine */
      317 		if (msg_ptr -> log_message.sequence ^= number) then
      318 		     code = error_table_$no_log_message;
      319 
      320 	     if (code ^= 0) then			/* might be due to a missing sequence number */
      321 		if P_arg_type = TO_TYPE then number = number - 1;  /* settle for message before that */
      322 		else number = number + 1;		/* or, for -from, the one after that */
      323 	end;
      324 
      325 	if (code ^= 0) then 
      326 	     call ssu_$abort_line (sci_ptr, code, "Cannot find message at or ^[before^;after^] #^d",
      327 		P_arg_type = TO_TYPE, P_number);
      328 
      329 	return (msg_ptr);
      330 	end find_message_number;
      331 
      332 
      333 
      334 find_message_time:
      335      procedure (P_time, P_direction) returns (pointer);
      336 
      337 declare	P_time fixed bin (71);
      338 declare	P_direction fixed bin;
      339 
      340 declare	msg_ptr pointer;
      341 
      342 
      343 	call log_read_$position_time (log_read_ptr, P_time, (P_direction = AFTER), msg_ptr, code);
      344 
      345 	if (code ^= 0) then
      346 	     if P_time = 0 then call ssu_$abort_line (sci_ptr, code, "Log is empty.");
      347 	     else call ssu_$abort_line (sci_ptr, code, "Cannot find message ^[after^;before^] ^a",
      348 		(P_direction = AFTER), log_format_time_ (P_time));
      349 
      350 	return (msg_ptr);
      351 	end find_message_time;
      352 
      353 /* */
      354 
      355 get_time_or_number:
      356      procedure (P_arg_name, P_arg, P_time, P_number);
      357 
      358 declare	P_arg_name char (10) parameter;
      359 declare	P_arg char (50) varying parameter;
      360 declare	P_time fixed bin (71) parameter;
      361 declare	P_number fixed bin (35) parameter;
      362 
      363 declare	time fixed bin (71);
      364 declare	number fixed bin (35);
      365 
      366 
      367 	P_time = -1;
      368 	P_number = -1;
      369 
      370 	if (P_arg = "") then return;			/* This argument not specified */
      371 
      372           number = cv_dec_check_ ((P_arg), code);
      373 	if (code = 0) then do;
      374 	     if (number <= 0) then 
      375 		call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
      376 		"Message number for ^a must be > 0: ^a", P_arg_name, P_arg);
      377 	     
      378 	     P_number = number;
      379 	     return;
      380 	end;
      381 
      382           call convert_date_to_binary_ ((P_arg), time, code);
      383 	if (code ^= 0) then 
      384 	     call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
      385 		"Invalid ^a message number/time: ^a", P_arg_name, P_arg);
      386 
      387 	P_time = time;				/* It's a time value, instead */
      388 	return;
      389 
      390 	end get_time_or_number;
      391 
      392 /* */
      393 
      394 inconsistent:
      395      procedure (P_message);
      396 
      397 declare	P_message char (*) parameter;
      398 
      399 
      400 	call ssu_$abort_line (sci_ptr, error_table_$inconsistent, "^a", P_message);
      401 
      402 	end inconsistent;
      403 
      404 free_message:
      405 	procedure (P_message_ptr);
      406 declare P_message_ptr pointer;
      407 
      408 	if P_message_ptr = null () then return;
      409 	call log_read_$free_message (log_read_ptr, P_message_ptr);
      410 	P_message_ptr = null ();
      411 	return;
      412 	end free_message;
      413 
      414 
      415 hold_message:
      416 	procedure (P_message_ptr);
      417 declare P_message_ptr pointer;
      418 
      419 	call log_read_$hold_message (log_read_ptr, P_message_ptr);
      420 	return;
      421 	end hold_message;
      422 
      423        
      424 
      425  /* BEGIN INCLUDE FILE ... log_message.incl.pl1 ... 84-04-25 ... W. Olin Sibert */
  1     2 
  1     3 declare 1 log_message_header  aligned based,                /* Items marked "(SET)" are set by $create_message */
  1     4           2 sentinel          bit (36) aligned,             /* Proper value declared in log_segment.incl.pl1 */
  1     5           2 sequence          fixed bin (35),               /* Sequence number for this message (SET) */
  1     6           2 severity          fixed bin (8) unaligned,      /* Severity of message */
  1     7           2 data_class_lth    fixed bin (9) unaligned unsigned, /* Length of data class-- 0 to 16 (SET) */
  1     8           2 time              fixed bin (53) unaligned,     /* Time message originated */
  1     9           2 text_lth          fixed bin (17) unaligned,     /* Length of message text. Must be nonzero (SET) */
  1    10           2 data_lth          fixed bin (17) unaligned,     /* Length of binary data. May be zero (SET) */
  1    11           2 process_id        bit (36) aligned;             /* Process id of process writing message */
  1    12 
  1    13 declare 1 log_message         aligned based (log_message_ptr),
  1    14           2 header            aligned like log_message_header,
  1    15           2 text              char (log_message_text_lth         refer (log_message.text_lth)) unaligned,
  1    16           2 data_class        char (log_message_data_class_lth   refer (log_message.data_class_lth)) unaligned,
  1    17           2 data              dim (log_message_data_lth          refer (log_message.data_lth)) bit (36) aligned;
  1    18 
  1    19 declare   log_message_ptr pointer;
  1    20 declare   log_message_text_lth fixed bin;
  1    21 declare   log_message_data_class_lth fixed bin;
  1    22 declare   log_message_data_lth fixed bin;
  1    23 
  1    24 /* END INCLUDE FILE ... log_message.incl.pl1 */
      425 
      426  /* BEGIN INCLUDE FILE ... log_limit_info.incl.pl1 ... 84-07-04 ... W. Olin Sibert */
  2     2 /* Modified 1984-12-16, BIM: for a version number */
  2     3 
  2     4 declare   log_limit_info_ptr pointer;
  2     5 
  2     6 declare 1 log_limit_info      aligned based (log_limit_info_ptr),
  2     7           2 version           char (8) aligned,
  2     8           2 to_opt            char (50) varying,            /* Input: options supplied after control */
  2     9           2 from_opt          char (50) varying,            /* argument of this name */
  2    10           2 for_opt           char (50) varying,
  2    11           2 last_opt          char (50) varying,
  2    12 
  2    13           2 first_msg         pointer,                      /* Output: results of successful processing */
  2    14           2 last_msg          pointer,                      /* of above options */
  2    15           2 msg_count         fixed bin (35);
  2    16 
  2    17 declare LOG_LIMIT_INFO_VERSION_1 char (8) init ("lliv0001") internal static options (constant);
  2    18 
  2    19 /* END INCLUDE FILE ... log_limit_info.incl.pl1 ... 84-07-04 ... W. Olin Sibert */
      426 
      427 
      428 	end log_limit_scan_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/27/89  1051.0  log_limit_scan_.pl1               >spec>install>1015>log_limit_scan_.pl1
425          1    01/21/85  0912.2  log_message.incl.pl1              >ldd>include>log_message.incl.pl1
426          2    01/21/85  0912.2  log_limit_info.incl.pl1           >ldd>include>log_limit_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AFTER                           000040 constant        fixed bin(17,0)          initial dcl 82 set ref 190* 204* 218* 343 347
BEFORE                          000022 constant        fixed bin(17,0)          initial dcl 83 set ref 184* 205* 212* 227* 253* 260*
                                                                                  264*
FROM_TYPE                       000040 constant        fixed bin(17,0)          initial dcl 43 set ref 171*
LOG_LIMIT_INFO_VERSION_1        000000 constant        char(8)                  initial packed unaligned dcl 2-17 ref 93
P_arg                                  parameter       varying char(50)         dcl 359 set ref 355 370 372 374* 382 383*
P_arg_name                             parameter       char(10)                 packed unaligned dcl 358 set ref 355 374* 383*
P_arg_type                             parameter       fixed bin(17,0)          dcl 304 ref 300 320 325
P_caller_sci_ptr                       parameter       pointer                  dcl 38 ref 17 91
P_direction                            parameter       fixed bin(17,0)          dcl 338 ref 334 343 347
P_log_limit_info_ptr                   parameter       pointer                  dcl 39 ref 17 89
P_log_read_ptr                         parameter       pointer                  dcl 41 ref 17 90
P_message                              parameter       char                     packed unaligned dcl 397 set ref 394 400*
P_message_ptr                          parameter       pointer                  dcl 406 in procedure "free_message" set ref 404 408
                                                                                  409* 410*
P_message_ptr                          parameter       pointer                  dcl 417 in procedure "hold_message" set ref 415 419*
P_number                               parameter       fixed bin(35,0)          dcl 303 in procedure "find_message_number" set ref
                                                                                  300 309 325*
P_number                               parameter       fixed bin(35,0)          dcl 361 in procedure "get_time_or_number" set ref
                                                                                  355 368* 378*
P_reverse_sw                           parameter       bit(1)                   dcl 40 ref 17
P_time                                 parameter       fixed bin(71,0)          dcl 360 in procedure "get_time_or_number" set ref
                                                                                  355 367* 387*
P_time                                 parameter       fixed bin(71,0)          dcl 337 in procedure "find_message_time" set ref 334
                                                                                  343* 345 347*
TO_TYPE                         000037 constant        fixed bin(17,0)          initial dcl 43 set ref 165* 320 325
clock                                                  builtin function         dcl 85 ref 205 205 212 212 227 227 258
code                            000100 automatic       fixed bin(35,0)          dcl 45 set ref 247* 248 248* 310* 312 314* 316 316*
                                                                                  320 325 325* 343* 345 345* 347* 372* 373 382* 383
convert_date_to_binary_         000022 constant        entry                    external dcl 71 ref 382
convert_date_to_binary_$relative
                                000024 constant        entry                    external dcl 72 ref 247
cv_dec_check_                   000020 constant        entry                    external dcl 70 ref 372
error_table_$bad_conversion     000010 external static fixed bin(35,0)          dcl 65 set ref 374* 383*
error_table_$inconsistent       000012 external static fixed bin(35,0)          dcl 66 set ref 400*
error_table_$no_log_message     000014 external static fixed bin(35,0)          dcl 67 ref 316
error_table_$unimplemented_version
                                000016 external static fixed bin(35,0)          dcl 68 set ref 93*
exchange_ptr                    000152 automatic       pointer                  dcl 150 set ref 274* 276
first_message                          based           structure                level 1 dcl 152
first_msg                72            based           pointer                  level 2 dcl 2-6 set ref 156* 170* 171* 172* 175 175
                                                                                  189* 190* 191* 194 194 202* 204* 206* 217* 218*
                                                                                  219* 242 263* 264* 265* 270 270 270 274 275* 281
                                                                                  284
for_given                       000124 automatic       bit(1)                   dcl 61 set ref 117* 119 123 126 127 210
for_number                2     000106 automatic       fixed bin(35,0)          level 2 dcl 49 set ref 98* 117 231 231
for_opt                  36            based           varying char(50)         level 2 dcl 2-6 set ref 98* 247 248*
for_time                 10     000106 automatic       fixed bin(71,0)          level 2 dcl 49 set ref 98* 117 239 247* 253*
from_given                      000123 automatic       bit(1)                   dcl 60 set ref 116* 119 125 127 210 216
from_number               1     000106 automatic       fixed bin(35,0)          level 2 dcl 49 set ref 96* 116 169 171* 175
from_opt                 20            based           varying char(50)         level 2 dcl 2-6 set ref 96*
from_relative_time              000146 automatic       fixed bin(71,0)          dcl 148 set ref 240* 242* 247* 248* 258* 260* 262
                                                                                  264
from_time                 6     000106 automatic       fixed bin(71,0)          level 2 dcl 49 set ref 96* 116 188 190* 194 240 240
header                                 based           structure                level 2 dcl 1-13
i                               000163 automatic       fixed bin(17,0)          dcl 304 set ref 312*
last_given                      000125 automatic       bit(1)                   dcl 62 set ref 118* 119 124 125 126
last_message                           based           structure                level 1 dcl 153
last_msg                 74            based           pointer                  level 2 dcl 2-6 set ref 157* 164* 165* 166* 175 175
                                                                                  183* 184* 185* 194 194 203* 205* 207* 211* 212*
                                                                                  213* 226* 227* 228* 252* 253* 254* 259* 260* 261*
                                                                                  270 270 270 275 276* 281 284
last_number               3     000106 automatic       fixed bin(35,0)          level 2 dcl 49 set ref 99* 118 224 225
last_opt                 54            based           varying char(50)         level 2 dcl 2-6 set ref 99*
last_time                12     000106 automatic       fixed bin(71,0)          level 2 dcl 49 set ref 99* 118 257 262
last_time_delta                 000150 automatic       fixed bin(71,0)          dcl 149 set ref 262* 264
log_format_time_                000036 constant        entry                    external dcl 79 ref 248 347
log_limit_info                         based           structure                level 1 dcl 2-6
log_limit_info_ptr              000130 automatic       pointer                  dcl 2-4 set ref 89* 93 93 96 97 98 99 156 157 158
                                                                                  164 165 166 170 171 172 175 175 175 175 183 184
                                                                                  185 189 190 191 194 194 194 194 202 203 204 205
                                                                                  206 207 211 212 213 217 218 219 225 226 227 228
                                                                                  231 242 247 248 252 253 254 259 260 261 263 264
                                                                                  265 270 270 270 270 270 270 274 275 275 276 281
                                                                                  281 284 284 284
log_message                            based           structure                level 1 dcl 1-13
log_message_header                     based           structure                level 1 dcl 1-3
log_read_$free_message          000026 constant        entry                    external dcl 74 ref 409
log_read_$hold_message          000030 constant        entry                    external dcl 75 ref 419
log_read_$position_sequence     000032 constant        entry                    external dcl 76 ref 314
log_read_$position_time         000034 constant        entry                    external dcl 78 ref 343
log_read_ptr                    000104 automatic       pointer                  dcl 47 set ref 90* 314* 343* 409* 419*
max                                                    builtin function         dcl 85 ref 262
msg_count                76            based           fixed bin(35,0)          level 2 dcl 2-6 set ref 158* 225* 231* 284
msg_ptr                         000174 automatic       pointer                  dcl 340 in procedure "find_message_time" set ref
                                                                                  343* 350
msg_ptr                         000164 automatic       pointer                  dcl 306 in procedure "find_message_number" set ref
                                                                                  314* 316 329
none_given                      000126 automatic       bit(1)                   dcl 63 set ref 119* 201
null                                                   builtin function         dcl 85 ref 156 157 175 175 194 194 270 270 281 281
                                                                                  284 284 408 410
number                          000206 automatic       fixed bin(35,0)          dcl 364 in procedure "get_time_or_number" set ref
                                                                                  372* 374 378
number                          000162 automatic       fixed bin(35,0)          dcl 303 in procedure "find_message_number" set ref
                                                                                  309* 314* 316 320* 320 322* 322
opt                             000106 automatic       structure                level 1 dcl 49
sci_ptr                         000102 automatic       pointer                  dcl 46 set ref 91* 93* 175* 194* 248* 281* 284* 325*
                                                                                  345* 347* 374* 383* 400*
sequence                  1            based           fixed bin(35,0)          level 2 in structure "last_message" dcl 153
                                                                                  in procedure "find_message_limits" ref 270
sequence                  1            based           fixed bin(35,0)          level 2 in structure "first_message" dcl 152
                                                                                  in procedure "find_message_limits" ref 270
sequence                  1            based           fixed bin(35,0)          level 3 in structure "log_message" dcl 1-13
                                                                                  in procedure "log_limit_scan_" ref 316
ssu_$abort_line                 000040 constant        entry                    external dcl 80 ref 93 175 194 248 281 284 325 345
                                                                                  347 374 383 400
time                      2(18)        based           fixed bin(53,0)          level 3 in structure "log_message" packed packed
                                                                                  unaligned dcl 1-13 in procedure "log_limit_scan_"
                                                                                  ref 175 175 194 194
time                      2(18)        based           fixed bin(53,0)          level 2 in structure "first_message" packed packed
                                                                                  unaligned dcl 152 in procedure
                                                                                  "find_message_limits" ref 242 270
time                      2(18)        based           fixed bin(53,0)          level 2 in structure "last_message" packed packed
                                                                                  unaligned dcl 153 in procedure
                                                                                  "find_message_limits" ref 270
time                            000204 automatic       fixed bin(71,0)          dcl 363 in procedure "get_time_or_number" set ref
                                                                                  382* 387
to_given                        000122 automatic       bit(1)                   dcl 59 set ref 115* 119 123 124 210 216
to_number                       000106 automatic       fixed bin(35,0)          level 2 dcl 49 set ref 97* 115 163 165* 175
to_opt                    2            based           varying char(50)         level 2 dcl 2-6 set ref 97*
to_time                   4     000106 automatic       fixed bin(71,0)          level 2 dcl 49 set ref 97* 115 182 184* 194
version                                based           char(8)                  level 2 dcl 2-6 set ref 93 93*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
log_message_data_class_lth             automatic       fixed bin(17,0)          dcl 1-21
log_message_data_lth                   automatic       fixed bin(17,0)          dcl 1-22
log_message_ptr                        automatic       pointer                  dcl 1-19
log_message_text_lth                   automatic       fixed bin(17,0)          dcl 1-20

NAMES DECLARED BY EXPLICIT CONTEXT.
MAIN_RETURN                     000456 constant        label                    dcl 105
check_consistency               000457 constant        entry                    internal dcl 110 ref 101
find_message_limits             000617 constant        entry                    internal dcl 145 ref 103
find_message_number             002004 constant        entry                    internal dcl 300 ref 165 171
find_message_time               002144 constant        entry                    internal dcl 334 ref 184 190 204 205 212 218 227 253
                                                                                  260 264
free_message                    002561 constant        entry                    internal dcl 404 ref 164 170 183 189 202 203 211 217
                                                                                  226 252 259 263
get_time_or_number              002304 constant        entry                    internal dcl 355 ref 96 97 98 99
hold_message                    002606 constant        entry                    internal dcl 415 ref 166 172 185 191 206 207 213 219
                                                                                  228 254 261 265
inconsistent                    002516 constant        entry                    internal dcl 394 ref 123 124 125 126 127
log_limit_scan_                 000302 constant        entry                    external dcl 17

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3060        3122    2662        3070
Length      3354    2662        42         216     175           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
log_limit_scan_                     448 external procedure  is an external procedure.  
check_consistency                       internal procedure  shares stack frame of external procedure log_limit_scan_.  
find_message_limits                     internal procedure  shares stack frame of external procedure log_limit_scan_.  
find_message_number                     internal procedure  shares stack frame of external procedure log_limit_scan_.  
find_message_time                       internal procedure  shares stack frame of external procedure log_limit_scan_.  
get_time_or_number                      internal procedure  shares stack frame of external procedure log_limit_scan_.  
inconsistent                            internal procedure  shares stack frame of external procedure log_limit_scan_.  
free_message                            internal procedure  shares stack frame of external procedure log_limit_scan_.  
hold_message                            internal procedure  shares stack frame of external procedure log_limit_scan_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
log_limit_scan_          000100 code                        log_limit_scan_
                         000102 sci_ptr                     log_limit_scan_
                         000104 log_read_ptr                log_limit_scan_
                         000106 opt                         log_limit_scan_
                         000122 to_given                    log_limit_scan_
                         000123 from_given                  log_limit_scan_
                         000124 for_given                   log_limit_scan_
                         000125 last_given                  log_limit_scan_
                         000126 none_given                  log_limit_scan_
                         000130 log_limit_info_ptr          log_limit_scan_
                         000146 from_relative_time          find_message_limits
                         000150 last_time_delta             find_message_limits
                         000152 exchange_ptr                find_message_limits
                         000162 number                      find_message_number
                         000163 i                           find_message_number
                         000164 msg_ptr                     find_message_number
                         000174 msg_ptr                     find_message_time
                         000204 time                        get_time_or_number
                         000206 number                      get_time_or_number

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ge_a              alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac
shorten_stack       ext_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
convert_date_to_binary_       convert_date_to_binary_$relative                            cv_dec_check_
log_format_time_              log_read_$free_message        log_read_$hold_message        log_read_$position_sequence
log_read_$position_time       ssu_$abort_line

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_conversion   error_table_$inconsistent     error_table_$no_log_message
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     17 000275        89 000307        90 000313        91 000316        93 000321        96 000354        97 000374
     98 000414        99 000434       101 000454       103 000455       105 000456       110 000457       115 000460
    116 000467       117 000476       118 000505       119 000514       123 000522       124 000535       125 000552
    126 000567       127 000604       140 000616       145 000617       156 000620       157 000623       158 000624
    163 000626       164 000630       165 000636       166 000651       169 000660       170 000662       171 000671
    172 000704       175 000713       182 000772       183 000774       184 001003       185 001016       188 001025
    189 001027       190 001036       191 001051       194 001060       201 001137       202 001141       203 001150
    204 001157       205 001174       206 001211       207 001220       210 001227       211 001235       212 001244
    213 001261       216 001270       217 001274       218 001303       219 001320       224 001327       225 001331
    226 001333       227 001341       228 001356       231 001365       239 001371       240 001373       242 001377
    247 001406       248 001443       252 001517       253 001526       254 001541       257 001550       258 001552
    259 001554       260 001563       261 001576       262 001605       263 001616       264 001625       265 001643
    270 001652       274 001703       275 001704       276 001705       281 001706       284 001743       295 002003
    300 002004       309 002006       310 002010       312 002012       314 002021       316 002042       320 002053
    322 002070       323 002074       325 002076       329 002140       334 002144       343 002146       345 002172
    347 002227       350 002300       355 002304       367 002306       368 002310       370 002312       372 002321
    373 002351       374 002354       378 002413       379 002416       382 002417       383 002452       387 002512
    388 002515       394 002516       400 002527       402 002560       404 002561       408 002563       409 002570
    410 002602       411 002605       415 002606       419 002610       420 002622


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
