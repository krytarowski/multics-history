	COMPILATION LISTING OF SEGMENT lib_next_name_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/15/84  0857.4 mst Wed
	    Options: optimize map

        1 /* ***************************************************************
        2*   *                                                             *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982     *
        4*   *                                                             *
        5*   * Copyright (c) 1975 by Massachusetts Institute of Technology *
        6*   *                                                             *
        7*   * Copyright (c) 1972 by Massachusetts Institute of            *
        8*   * Technology and Honeywell Information Systems, Inc.          *
        9*   *                                                             *
       10*   *************************************************************** */
       11 
       12 
       13 
       14 
       15 lib_next_name_:	procedure (Srequirements, PDnames, Iname, Pstarname)
       16 		returns (char(32));
       17 
       18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       19 	/*									*/
       20 	/* This procedure is part of the library maintenance subsystem of tools.  Documentation of*/
       21 	/* the complete subsystem is available in AN-80, Library Maintenance.			*/
       22 	/* This procedure, when given node requirements bits, a pointer to the names descriptor,	*/
       23 	/* a name index, and an array of starnames, returns the next name in the descriptor which	*/
       24 	/* meets the name requirements.  Three cases are considered:			*/
       25 	/*									*/
       26 	/*     1) the first name is required.						*/
       27 	/*     2) names which match one of the starnames are required.			*/
       28 	/*     3) all names are required.						*/
       29 	/*									*/
       30 	/* Any combination of cases is allowed.  If there are no remaining names which meet one	*/
       31 	/* of the requirements, then a null character string is returned.			*/
       32 	/*									*/
       33 	/* S__t_a_t_u_s									*/
       34 	/*									*/
       35 	/* 0) Created by:   G. C. Dixon,  May 16, 1975					*/
       36 	/*									*/
       37 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       38 
       39      dcl						/*	Parameters			*/
       40 /*	PDnames			ptr,		/* ptr to a names descriptor. (In)		*/
       41 	Iname			fixed bin;	/* index into name array of next name to be	*/
       42 						/*   checked.  For the first call to process a	*/
       43 						/*   given name descriptor, this should be set to	*/
       44 						/*   0. (In)				*/
       45 						/* index of last name checked.  For subsequent	*/
       46 						/*   calls to process a given name descriptor, 	*/
       47 						/*   this output value should be used as input.	*/
       48 						/*   (Out)				*/
       49 
       50      dcl	blank_name		char(32) aligned int static init ((32)" "),
       51 						/* a blank name or null string.		*/
       52 	code			fixed bin(35),	/* a status code.				*/
       53 	i			fixed bin;	/* a do-group index.			*/
       54 
       55      dcl	addr			builtin;
       56 
       57      dcl	match_star_name_		entry (char(*), char(*), fixed bin(35));
       58 
       59 
       60 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       61 
       62  	Iname = Iname + 1;				/* get index of next name.			*/
       63 	if Iname > Dnames.N then			/* name array exhausted?  Return blank name.	*/
       64 	     return (blank_name);
       65 	if S.names then				/* return all names.			*/
       66 	     return (Dnames.names(Iname));
       67 	if S.primary_name then			/* return first name.			*/
       68 	     if Iname = 1 then
       69 		return (Dnames.names(Iname));
       70 	if S.matching_names then do;			/* return next name matching a starname.	*/
       71 	     do Iname = Iname to Dnames.N;		/*   scan thru remaining names.		*/
       72 		do i = 1 to starname.N;		/*     for each name, compare with each starname.	*/
       73 		     go to check (starname.C(i));
       74 
       75 check(0):		     if Dnames.names(Iname) = starname.V(i) then
       76 			return (Dnames.names(Iname));
       77 		     go to nomatch;
       78 
       79 check(1):		     call match_star_name_ (Dnames.names(Iname), starname.V(i), code);
       80 		     if code = 0 then return (Dnames.names(Iname));
       81 		     go to nomatch;
       82 
       83 check(2):		     return (Dnames.names(Iname));
       84 
       85 nomatch:		     end;
       86 		end;
       87 	     end;
       88 
       89 	return (blank_name);			/* if none of remaining names meet requirements,	*/
       90 						/*   return a blank name (null string).		*/
       91 
       92 
  1     1 /*  START OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* N__a_m_e:  lib_node_.incl.pl1							*/
  1     6 	/*									*/
  1     7 	/*      This include segment defines the structures which form the tree of status nodes	*/
  1     8 	/* created by lib_get_tree_.  Each node of the tree is associated with a directory	*/
  1     9 	/* entry or an archive component.  The node lists the attributes of that entry, which is	*/
  1    10 	/* called the node target.							*/
  1    11 	/*									*/
  1    12 	/* S__t_a_t_u_s									*/
  1    13 	/*									*/
  1    14 	/* 0) Created:  May, 1973 by G. C. Dixon					*/
  1    15 	/* 1) Modified: Aug, 1973 by G. C. Dixon - standardize descriptor format.		*/
  1    16 	/* 2) Modified: Oct, 1973 by G. C. Dixon - add object_info_ descriptor.		*/
  1    17 	/* 3) Modified: Apr, 1975 by G. C. Dixon - add ACL and IACL descriptors.		*/
  1    18 	/* 4) Modified: Oct, 1975 by G. C. Dixon - additional status info added.		*/
  1    19 	/*									*/
  1    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    21 
  1    22 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    23 	/*									*/
  1    24 	/*	The structure of each node whose target is a link is shown below.	The	*/
  1    25 	/* structure of nodes for other types of targets is shown on the next page.  Note that	*/
  1    26 	/* both types of nodes are the same length.					*/
  1    27 	/*									*/
  1    28 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    29 
  1    30      dcl  1 link_node		based (Pnode),	/* node of a status tree.			*/
  1    31 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  1    32 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  1    33 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  1    34 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  1    35 						/*             (= node.Svalid & Srequirements)	*/
  1    36 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  1    37 	  2 switches		unaligned,
  1    38 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  1    39 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  1    40 						/* 	     entry before lib_access_mode_$set.	*/
  1    41 	    3 pad			bit(22),
  1    42 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  1    43 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  1    44 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  1    45 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  1    46 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  1    47 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  1    48 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  1    49 						/*	     in this directory;  if off, records*/
  1    50 						/*	     charged against 1st superior	*/
  1    51 						/*	     directory with switch on.	*/
  1    52 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  1    53 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  1    54 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  1    55 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  1    56 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  1    57 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  1    58 
  1    59 						/* From here on, link_nodes differ from nodes	*/
  1    60 						/*  for other types of node targets.		*/
  1    61 	  2 link_target		char(168) varying;	/* attribute: target pathname of the link.	*/
  1    62 
  1    63 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    64 	/*									*/
  1    65 	/*	The structure of nodes for other types of node targets is shown below.	*/
  1    66 	/*									*/
  1    67 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    68 
  1    69      dcl  1 node			based (Pnode),	/* node of a status tree.			*/
  1    70 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  1    71 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  1    72 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  1    73 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  1    74 						/*             (= node.Svalid & Srequirements)	*/
  1    75 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  1    76 	  2 switches		unaligned,
  1    77 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  1    78 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  1    79 						/* 	     entry before lib_access_mode_$set.	*/
  1    80 	    3 pad			bit(22),
  1    81 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  1    82 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  1    83 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  1    84 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  1    85 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  1    86 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  1    87 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  1    88 						/*	     in this directory;  if off, records*/
  1    89 						/*	     charged against 1st superior	*/
  1    90 						/*	     directory with switch on.	*/
  1    91 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  1    92 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  1    93 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  1    94 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  1    95 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  1    96 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  1    97 
  1    98 						/* From here on, other nodes differ from	*/
  1    99 						/*  link_nodes.				*/
  1   100 	  2 dtm			bit(36),		/* attribute: date-time node target modified.	*/
  1   101 	  2 dtu			bit(36),		/* attribute: date-time node target last used.	*/
  1   102 	  2 rb (3)		fixed bin(3),	/* attribute: ring brackets.			*/
  1   103 	  2 pad1 (1)		fixed bin,
  1   104 	  2 access_class		bit(72) aligned,	/* attribute: access class assoc. with entry.	*/
  1   105 	  2 records_used		fixed bin(35),	/* attribute: storage used, in records.		*/
  1   106 	  2 current_length		fixed bin(35),	/* attribute: length, in records.		*/
  1   107 	  2 max_length		fixed bin(35),	/* attribute: maximum length.			*/
  1   108 	  2 msf_indicator		fixed bin(35),	/* attribute: msf indicator.			*/
  1   109 	  2 bit_count		fixed bin(35),	/* attribute: bit count.			*/
  1   110 	  2 bit_count_author	char(32) varying,	/* attribute: bit count/msf indicator author.	*/
  1   111 	  2 offset		fixed bin(35),	/* attribute: offset, in words, of an archive	*/
  1   112 						/*             component from the base of archive.*/
  1   113 	  2 entry_bound		fixed bin(35),	/* attribute: entry limit for calls to a gate.	*/
  1   114 	  2 segment,				/* group:  segment quota information for a dir.	*/
  1   115 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  1   116 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  1   117 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  1   118 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  1   119 						/*	     updated.			*/
  1   120 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  1   121 						/*	     directories with Sterminal_account	*/
  1   122 						/*	     on.				*/
  1   123 	  2 directory,				/* group:  directory quota information for a dir.	*/
  1   124 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  1   125 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  1   126 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  1   127 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  1   128 						/*	     updated.			*/
  1   129 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  1   130 						/*	     directories with Sterminal_account	*/
  1   131 						/*	     on.				*/
  1   132 	  2 pvid			bit(36),		/* attribute: physical volume id.		*/
  1   133 	  2 lvid			bit(36),		/* attribute: logical volume id.		*/
  1   134 	  2 pad2 (5)		fixed bin,
  1   135 	Pnode			ptr;		/* ptr to:    a tree node.			*/
  1   136 
  1   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   138 	/*									*/
  1   139 	/*      The descriptors attached to each node of the tree describe the variable-sized	*/
  1   140 	/* attributes of the directory entry or archive component associated with the node.	*/
  1   141 	/* Each descriptor must begin with a header shown in structure D below.  The following	*/
  1   142 	/* descriptors are the only ones that have been defined.				*/
  1   143 	/*									*/
  1   144 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   145 
  1   146      dcl	1 D			based (PD),	/* Header common to all descriptors.		*/
  1   147 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   148 	  2 version		fixed bin(17) unal,	/* descriptor: version number.		*/
  1   149 	  2 T			fixed bin,	/* descriptor: type of descriptor.		*/
  1   150 	  2 Pnext		ptr,			/* ptr to:    next descriptor attached to node.	*/
  1   151 	PD			ptr;		/* ptr to:    a descriptor.			*/
  1   152 
  1   153      dcl	1 Dacl			based (PDacl),	/* a segment ACL descriptor.			*/
  1   154 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   155 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   156 	  2 T			fixed bin,	/* descriptor: type = Tacl.			*/
  1   157 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   158 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   159 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   160 	  2 acls (Nacls refer (Dacl.N)),		/* attribute: ACL entries.			*/
  1   161 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   162 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   163 	    3 zero_pad		bit(36),
  1   164 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   165 	Nacls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  1   166 	PDacl			ptr,		/* ptr to:    a segment ACL descriptor.		*/
  1   167 	Vacl_1			fixed bin int static options(constant) init (1),
  1   168 						/* version:   version of ACL descriptor.	*/
  1   169 	Tacl			fixed bin int static options(constant) init (7);
  1   170 						/* attribute: type of a segment ACL descriptor.	*/
  1   171 
  1   172      dcl	1 Ddir_acl		based (PDdir_acl),	/* a directory ACL descriptor.		*/
  1   173 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   174 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   175 	  2 T			fixed bin,	/* descriptor: type = Tdir_acl.		*/
  1   176 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   177 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   178 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   179 	  2 acls (Ndir_acls refer (Ddir_acl.N)),	/* attribute: ACL entries.			*/
  1   180 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   181 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   182 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   183 	Ndir_acls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  1   184 	PDdir_acl			ptr,		/* ptr to:    a directory ACL descriptor.	*/
  1   185 	Vdir_acl_1		fixed bin int static options(constant) init (1),
  1   186 						/* version:   version of directory ACL descriptor.*/
  1   187 	Tdir_acl			fixed bin int static options(constant) init (8);
  1   188 						/* attribute: type of a directory ACL descriptor.	*/
  1   189 
  1   190      dcl	1 Ddir_iacl		based (PDdir_iacl),	/* a directory IACL descriptor.		*/
  1   191 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   192 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   193 	  2 T			fixed bin,	/* descriptor: type = Tdir_iacl.		*/
  1   194 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   195 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   196 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   197 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  1   198 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  1   199 	  2 acls (Ndir_iacls refer (Ddir_iacl.N)),	/* attribute: ACL entries.			*/
  1   200 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   201 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   202 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   203 	Ndir_iacls		fixed bin,	/* temporary: number of entries in IACL descriptor*/
  1   204 	PDdir_iacl		ptr,		/* ptr to:    a directory IACL descriptor.	*/
  1   205 	Vdir_iacl_1		fixed bin int static options(constant) init (1),
  1   206 						/* version:   version of dir IACL descriptor.	*/
  1   207 	Tdir_iacl			fixed bin int static options(constant) init (9);
  1   208 
  1   209      dcl	1 Diacl			based (PDiacl),	/* a segment IACL descriptor.			*/
  1   210 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   211 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   212 	  2 T			fixed bin,	/* descriptor: type = Tiacl.			*/
  1   213 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   214 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   215 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   216 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  1   217 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  1   218 	  2 acls (Niacls refer (Diacl.N)),		/* attribute: ACL entries.			*/
  1   219 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   220 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   221 	    3 zero_pad		bit(36),
  1   222 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   223 	Niacls			fixed bin,	/* temporary: number of entries in IACL descriptor*/
  1   224 	PDiacl			ptr,		/* ptr to:    a segment IACL descriptor.	*/
  1   225 	Viacl_1			fixed bin int static options(constant) init (1),
  1   226 						/* version:   version of segment IACL descriptor.	*/
  1   227 	Tiacl			fixed bin int static options(constant) init (10);
  1   228 						/* attribute: type of a segment IACL descriptor.	*/
  1   229 
  1   230      dcl	1 Dnames			based (PDnames),	/* name attribute descriptor.			*/
  1   231 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   232 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   233 	  2 T			fixed bin,	/* descriptor: type = Tnames.			*/
  1   234 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   235 	  2 N			fixed bin,	/* attribute: number of names.		*/
  1   236 	  2 names (Nnames refer (Dnames.N))
  1   237 				char(32),		/* attribute: names.			*/
  1   238 	Nnames			fixed bin,	/* temporary: number of names in name descriptor.	*/
  1   239 	PDnames			ptr,		/* ptr to:    a name descriptor.		*/
  1   240 	Vnames_1			fixed bin int static options(constant) init (1),
  1   241 						/* version:   version of names descriptor.	*/
  1   242 	Tnames			fixed bin int static options(constant) init (1);
  1   243 						/* attribute: type of a name descriptor.	*/
  1   244 
  1   245      dcl	1 Dnodes			based (PDnodes),	/* descriptor for array of immediately-inferior	*/
  1   246 						/* nodes.					*/
  1   247 	  2 header,
  1   248 	    3 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   249 	    3 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   250 	    3 T			fixed bin,	/* descriptor: type = Tnodes.			*/
  1   251 	    3 Pnext		ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   252 	    3 C			fixed bin(35),	/* attribute: error code from filling array.	*/
  1   253 	    3 N			fixed bin,	/* attribute: number of nodes in node array.	*/
  1   254 	  2 nodes (Nnodes refer (Dnodes.N))		/* attribute: node array			*/
  1   255 				like node,
  1   256 	Nnodes			fixed bin,	/* temporary: number of nodes in node array.	*/
  1   257 	PDnodes			ptr,		/* ptr to:    a node array descriptor.		*/
  1   258 	Vnodes_1			fixed bin int static options(constant) init (1),
  1   259 						/* version:   version of nodes descriptor.	*/
  1   260 	Tnodes			fixed bin int static options(constant) init (2);
  1   261 						/* attribute: type of a node descriptor.	*/
  1   262 
  1   263      dcl	1 Dobj			based (PDobj),	/* an object_info_ descriptor.		*/
  1   264 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   265 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   266 	  2 T			fixed bin,	/* descriptor: type = Tobj.			*/
  1   267 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   268 	  2 info,
  1   269 	    3 Otext		fixed bin(35),	/* attribute: offset of text.			*/
  1   270 	    3 Odefinitions		fixed bin(35),	/* attribute: offset of definitions.		*/
  1   271 	    3 Olink		fixed bin(35),	/* attribute: offset of linkage section.	*/
  1   272 	    3 Ostatic		fixed bin(35),	/* attribute: offset of static section.		*/
  1   273 	    3 Osymbols		fixed bin(35),	/* attribute: offset of symbol section.		*/
  1   274 	    3 Obreaks		fixed bin(35),	/* attribute: offset of break map.		*/
  1   275 	    3 Ltext		fixed bin(35),	/* attribute: length of text, in words.		*/
  1   276 	    3 Ldefinitions		fixed bin(35),	/* attribute: length of definitions, in words.	*/
  1   277 	    3 Llink		fixed bin(35),	/* attribute: length of linkage section, in words.*/
  1   278 	    3 Lstatic		fixed bin(35),	/* attribute: length of static section, in words.	*/
  1   279 	    3 Lsymbols		fixed bin(35),	/* attribute: length of symbol section, in words.	*/
  1   280 	    3 Lbreaks		fixed bin(35),	/* attribute: length of break map, in words.	*/
  1   281 	    3 format		aligned,
  1   282 	      4 old_format		bit(1) unal,	/* attribute: segment is in old format.		*/
  1   283 	      4 bound		bit(1) unal,	/* attribute: a bound segment.		*/
  1   284 	      4 relocatable		bit(1) unal,	/* attribute: object is relocatable.		*/
  1   285 	      4 procedure		bit(1) unal,	/* attribute: executable procedure.		*/
  1   286 	      4 standard		bit(1) unal,	/* attribute: standard object segment.		*/
  1   287 	      4 gate		bit(1) unal,	/* attribute: gate procedure.			*/
  1   288 	      4 separate_static	bit(1) unal,	/* attribute: proc has separate static section.	*/
  1   289 	      4 links_in_text	bit(1) unal,	/* attribute: proc has links in text section.	*/
  1   290 	      4 pad		bit(28) unal,
  1   291 	    3 entry_bound		fixed bin(35),	/* attribute: entry point bound for a gate.	*/
  1   292 	    3 Otext_links		fixed bin(35),	/* attribute: offset of first link in text section*/
  1   293 	    3 compiler		char(8),		/* attribute: compiler of this object segment.	*/
  1   294 	    3 compile_time		fixed bin(71),	/* attribute: date/time of compilation.		*/
  1   295 	    3 userid		char(32),		/* attribute: id of user who compiled segment.	*/
  1   296 	    3 cversion,				/* attribite: compiler version string.		*/
  1   297 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  1   298 	      4 L			fixed bin(17) unal,	/*	    length			*/
  1   299 	    3 comment,				/* attribute: compiler-generated comment.	*/
  1   300 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  1   301 	      4 L			fixed bin(17) unal,	/*	    length			*/
  1   302 	    3 Osource		fixed bin(35),	/* attribute: offset of source map.		*/
  1   303 	  2 cversion		char(64) varying,	/* attribute: compiler version number      	*/
  1   304 	  2 comment		char(64) varying,	/* attribute: compiler's comment info	   	*/
  1   305 	PDobj			ptr,		/* ptr to:    an object_info_ descriptor.	*/
  1   306 	Vobj_1			fixed bin int static options(constant) init (1),
  1   307 						/* version:   version of object_info_ descriptor.	*/
  1   308 	Tobj			fixed bin int static options(constant) init (3);
  1   309 						/* attribute: type of a node descriptor.	*/
  1   310 
  1   311      dcl	1 Dsearch_proc		based (PDsearch_proc),
  1   312 						/* library root search_proc attribute descriptor.	*/
  1   313 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   314 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   315 	  2 T			fixed bin,	/* descriptor: type = Tsearch_proc.		*/
  1   316 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   317 	  2 search_proc		char(65) varying,	/* attribute: name of library search procedure.	*/
  1   318 	PDsearch_proc		ptr,		/* ptr to:    a search_proc info descriptor.	*/
  1   319 	Vsearch_proc_1		fixed bin int static options(constant) init (1),
  1   320 						/* version:   version of search_proc info descrip.*/
  1   321 	Tsearch_proc		fixed bin int static options(constant) init (5);
  1   322 						/* attribute: type of a search_proc descriptor.	*/
  1   323 
  1   324      dcl	1 Duser			based (PDuser),	/* user attribute descriptor.			*/
  1   325 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   326 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   327 	  2 T			fixed bin,	/* descriptor: type = Tuser.			*/
  1   328 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   329 	  2 label			char(18),		/* attribute: label to be used for this field in	*/
  1   330 						/*            output.			*/
  1   331 	  2 L			fixed bin,	/* attribute: length of user info string.	*/
  1   332 	  2 info			char(Luser refer (Duser.L)),
  1   333 						/* attribute: user info string.		*/
  1   334 	Luser			fixed bin,	/* temporary: length of user info string.	*/
  1   335 	PDuser			ptr,		/* ptr to:    a user info descriptor.		*/
  1   336 	Vuser_1			fixed bin int static options(constant) init (1),
  1   337 						/* version:   version of user info descriptor.	*/
  1   338 	Tuser			fixed bin int static options(constant) init (6);
  1   339 						/* attribute: type of a user descriptor.	*/
  1   340 
  2     1 /* START OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 	/*									*/
  2     5 	/* N__a_m_e:  lib_Svalid_req_.incl.pl1						*/
  2     6 	/*									*/
  2     7 	/*      This include segment defines the switches which request/validate the fields	*/
  2     8 	/* in a status node produced by lib_get_tree_.  This segment, lib_Scontrol_.incl.pl1,	*/
  2     9 	/* and lib_args_.incl.pl1 define the complete set of structures required as input to	*/
  2    10 	/* the lib_descriptor_ subroutine.  This subroutine is called by all of the library	*/
  2    11 	/* descriptor commands to obtain information about entries in a library.		*/
  2    12 	/*									*/
  2    13 	/*      If a switch is on, then the corresponding information in the node is valid, or 	*/
  2    14 	/* is requested for output.							*/
  2    15 	/*									*/
  2    16 	/* S__t_a_t_u_s									*/
  2    17 	/*									*/
  2    18 	/* 0) Created on:   April 8, 1975  by  G. C. Dixon				*/
  2    19 	/*									*/
  2    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    21 
  2    22 
  2    23      dcl	1 Svalid_req		aligned based,
  2    24 	  2 primary_name		bit(1) unal,	/* switch: output includes primary name	   	*/
  2    25 	  2 matching_names		bit(1) unal,	/* switch: output includes matching names  	*/
  2    26 	  2 names			bit(1) unal,	/* switch: output includes all names	   	*/
  2    27 
  2    28 	  2 pathname		bit(1) unal,	/* switch: output include pathname of node target	*/
  2    29 	  2 kids			bit(1) unal,	/* switch: children nodes (inferior) exist	*/
  2    30 	  2 kids_error		bit(1) unal,	/* switch: error occurred obtaining kid's info	*/
  2    31 
  2    32 	  2 type			bit(1) unal,	/* switch: type 			   	*/
  2    33 	  2 mode			bit(1) unal,	/* switch: user's access mode to node target	*/
  2    34 	  2 safety		bit(1) unal,	/* switch: safety switch setting		*/
  2    35 
  2    36 	  2 aim			bit(1) unal,	/* switch: Access Isolation Mechanism switches	*/
  2    37 	  2 copy			bit(1) unal,	/* switch: copy-on-write switch setting		*/
  2    38 	  2 unique_id		bit(1) unal,	/* switch: unique identifier		   	*/
  2    39 
  2    40 	  2 author		bit(1) unal,	/* switch: author of node target		*/
  2    41 	  2 dtem			bit(1) unal,	/* switch: date attributes modified	   	*/
  2    42 	  2 dtd			bit(1) unal,	/* switch: date dumped		   	*/
  2    43 
  2    44 	  2 link_target		bit(1) unal,	/* switch: target pathname of link node		*/
  2    45 	  2 dtm			bit(1) unal,	/* switch: date modified		   	*/
  2    46 	  2 dtu			bit(1) unal,	/* switch: date used		   	*/
  2    47 
  2    48 	  2 rb			bit(1) unal,	/* switch: ring brackets		   	*/
  2    49 	  2 access_class		bit(1) unal,	/* switch: AIM access class		   	*/
  2    50 	  2 records_used		bit(1) unal,	/* switch: records used		   	*/
  2    51 
  2    52 	  2 current_length		bit(1) unal,	/* switch: current length		   	*/
  2    53 	  2 max_length		bit(1) unal,	/* switch: maximum length			*/
  2    54 	  2 msf_indicator		bit(1) unal,	/* switch: count of MSF components.		*/
  2    55 
  2    56 	  2 bit_count		bit(1) unal,	/* switch: bit count		   	*/
  2    57 	  2 bit_count_author	bit(1) unal,	/* switch: bit count author.			*/
  2    58 	  2 offset		bit(1) unal,	/* switch: offset from segment base	   	*/
  2    59 
  2    60 	  2 entry_bound		bit(1) unal,	/* switch: call limit for gate node		*/
  2    61 	  2 lvid			bit(1) unal,	/* switch: logical volume id	   		*/
  2    62 	  2 pvid			bit(1) unal,	/* switch: physical volume id			*/
  2    63 
  2    64 	  2 quota			bit(1) unal,	/* switch: directory quota information		*/
  2    65 	  2 acl			bit(1) unal,	/* switch: ACL			   	*/
  2    66 	  2 iacl			bit(1) unal,	/* switch: initial ACLs		   	*/
  2    67 
  2    68 	  2 dtc			bit(1) unal,	/* switch: date-time compiled      		*/
  2    69 	  2 compiler_name		bit(1) unal,	/* switch: name of compiler			*/
  2    70 	  2 compiler_version	bit(1) unal,	/* switch: compiler version number         	*/
  2    71 
  2    72 	  2 compiler_options	bit(1) unal,	/* switch: compiler options info	   	*/
  2    73 	  2 object_info		bit(1) unal,	/* switch: other object segment info       	*/
  2    74 	  2 not_ascii		bit(1) unal,	/* switch: contents is not printable       	*/
  2    75 
  2    76 	  2 user			bit(1) unal,	/* switch: user-defined node information	*/
  2    77 	  2 root_search_proc	bit(1) unal,	/* switch: root search procedure info.		*/
  2    78 	  2 prev_mode		bit(1) unal,	/* switch: user's previous acces mode set.	*/
  2    79 	  2 pad			bit(26) unal,
  2    80 
  2    81 	  2 delete		bit(1) unal,	/* switch: on (for lcln) if node to be deleted.	*/
  2    82 
  2    83 	  2 cross_ref		bit(1) unal,	/* switch: cross-reference all names       	*/
  2    84 	  2 level			bit(1) unal,	/* switch: output status tree level number	*/
  2    85 	  2 new_line		bit(1) unal;	/* switch: output begins with newline char	*/
  2    86 
  2    87 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    88 	/*									*/
  2    89 	/*      The following declarations define a series of bit strings to be overlaid by 	*/
  2    90 	/* structures which are exactly like Svalid_req above, except for their level 1 name.	*/
  2    91 	/* These structures are used throughout the library descriptor commands and subroutines.	*/
  2    92 	/*									*/
  2    93 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    94 
  2    95 
  2    96      dcl	1 S			aligned based (addr(Srequirements)) like Svalid_req,
  2    97 	Srequirements		bit(72) aligned;
  2    98 
  2    99 /* END OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1   341 
  1   342 
  1   343      dcl	1 Svalid			aligned based(addr(node.Svalid)) like Svalid_req,
  1   344 	1 Sreq			aligned based(addr(node.Sreq)) like Svalid_req;
  1   345 
  3     1 /* START OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* N__a_m_e:  lib_Scontrol_.incl.pl1						*/
  3     6 	/*									*/
  3     7 	/*      This include segment defines the control switches used by library descriptor	*/
  3     8 	/* commands and subroutines.  These switches control the amount of information which is	*/
  3     9 	/* attached to each node of the tree by lib_get_tree_.  This segment, lib_args_.incl.pl1,	*/
  3    10 	/* and lib_Svalid_req_.incl.pl1 define the complete set of structures required as input	*/
  3    11 	/* to the lib_descriptor_ subroutine.						*/
  3    12 	/*									*/
  3    13 	/* S__t_a_t_u_s									*/
  3    14 	/*									*/
  3    15 	/* 0) Created on:  April 8, 1975  by  G. C. Dixon					*/
  3    16 	/* 1) Modified on: October 24, 1983 by Jim Lippard to add page_length, first_match	*/
  3    17 	/*									*/
  3    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    19 
  3    20      dcl	1 Sc			aligned based (addr (Scontrol)),
  3    21 	  2 acl			bit(1) unal,	/* switch: return ACL for library entries.	*/
  3    22 	  2 all_status		bit(1) unal,	/* switch: return extra status information.	*/
  3    23 	  2 chase			bit(1) unal,	/* switch: link entries are to be chased.	*/
  3    24 
  3    25 	  2 check_archive		bit(1) unal,	/* switch: see if contents of entry is archive.	*/
  3    26 	  2 check_ascii		bit(1) unal,	/* switch: see if contents of entry is ascii.	*/
  3    27 	  2 components		bit(1) unal,	/* switch: return info about parent of terminal	*/
  3    28 						/*         nodes of the tree, and about all the	*/
  3    29 						/*	 nodes below the parent.		*/
  3    30 
  3    31 	  2 container		bit(1) unal,	/* switch: return info about parent of terminal	*/
  3    32 						/*         nodes of the tree.			*/
  3    33 	  2 default		bit(1) unal,	/* switch: use default requirement switch settings*/
  3    34 	  2 iacl			bit(1) unal,	/* switch: return initial ACLs for library entries*/
  3    35 
  3    36 	  2 object_info		bit(1) unal,	/* switch: return object info for object segments.*/
  3    37 	  2 quota			bit(1) unal,	/* switch: return quota information.		*/
  3    38 	  2 retain		bit(1) unal,	/* switch: print information about nodes awaiting	*/
  3    39 						/*         deletion.			*/
  3    40 
  3    41 	  2 pad			bit(10) unal,
  3    42 
  3    43 	  2 first_match		bit(1) unal,	/* switch: stop after first match		*/
  3    44 	  2 page_length		bit(1) unal,	/* switch: page length of output		*/
  3    45 
  3    46 	  2 delete		bit(1) unal,	/* switch: delete library entries		*/
  3    47 	  2 descriptor		bit(1) unal,	/* switch: library descriptor			*/
  3    48 	  2 exclude		bit(1) unal,	/* switch: exclusion search names.		*/
  3    49 
  3    50 	  2 footing		bit(1) unal,	/* switch: footing for output pages.		*/
  3    51 	  2 heading		bit(1) unal,	/* switch: heading for 1st output page.		*/
  3    52 	  2 into_path		bit(1) unal,	/* switch: path into which entries are fetched.	*/
  3    53 
  3    54 	  2 library		bit(1) unal,	/* switch: library names			*/
  3    55 	  2 list			bit(1) unal,	/* switch: list library entries		*/
  3    56 	  2 long			bit(1) unal,	/* switch: long output format required.		*/
  3    57 
  3    58 	  2 output_file		bit(1) unal,	/* switch: pathname of output file		*/
  3    59 	  2 search_names		bit(1) unal,	/* switch: search names			*/
  3    60 	  2 time			bit(1) unal,	/* switch: grace time for deletion of entries.	*/
  3    61 	Scontrol			bit(36) aligned;	/* switches: aligned copy of control switches.	*/
  3    62 
  3    63 /* END OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1   346 
  1   347 
  1   348 
  1   349 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   350 	/*									*/
  1   351 	/*      The following entry type attributes have been defined.  Note that the types 	*/
  1   352 	/* for segments, archive components, and msf components all have the characteristic	*/
  1   353 	/* that:		mod (type, 2) = 1;						*/
  1   354 	/*									*/
  1   355 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   356 
  1   357 
  1   358      dcl (Tlink			init (0),
  1   359 	Tsegment			init (1),
  1   360 	Tdirectory		init (2),
  1   361 	Tmsf			init (3),
  1   362 	Tmsf_comp			init (4),
  1   363 	Tarchive			init (5),
  1   364 	Tarchive_comp		init (6)) fixed bin(17) int static options(constant);
  1   365 
  1   366 
  1   367 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   368 	/*									*/
  1   369 	/*      The following character string arrays identify each entry type attribute by name.	*/
  1   370 	/* Both brief and long string arrays are provided.				*/
  1   371 	/*									*/
  1   372 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   373 
  1   374      dcl	node_type (0:6)		char(32) varying aligned int static options(constant) init (
  1   375 				"link",
  1   376 				"segment",
  1   377 				"directory",
  1   378 				"multisegment file",
  1   379 				"multi-segment file component",
  1   380 				"archive",
  1   381 				"archive component"),
  1   382 	brief_node_type (0:6)	char(12) varying aligned int static options(constant) init (
  1   383 				"link",
  1   384 				"segment",
  1   385 				"directory",
  1   386 				"msf",
  1   387 				"msf comp",
  1   388 				"archive",
  1   389 				"arch comp");
  1   390 
  1   391 
  1   392 /*  END OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       93 
       94 
  4     1 /* START OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4     4 	/*									*/
  4     5 	/* N__a_m_e:  lib_based_args_.incl.pl1						*/
  4     6 	/*									*/
  4     7 	/*      This include segment defines structures for the arrays of library names and search*/
  4     8 	/* names used by library descriptor commands.  This segment, lib_Svalid_req_.incl.pl1,	*/
  4     9 	/* and lib_Scontrol_.incl.pl1 define the complete set of structures required as input	*/
  4    10 	/* to the lib_descriptor_ subroutine.						*/
  4    11 	/*									*/
  4    12 	/* S__t_a_t_u_s									*/
  4    13 	/*									*/
  4    14 	/* 0) Created on:   March 1, 1975 by  A. J. Scherer				*/
  4    15 	/* 1) Modified on:  April 8, 1975 by  G. C. Dixon					*/
  4    16 	/* 2) Modified on:  May 13, 1976 by  G. C. Dixon					*/
  4    17 	/* 3) Modified on:  November 2, 1983 by Jim Lippard to align structures		*/
  4    18 	/*									*/
  4    19 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    20 
  4    21 
  4    22      dcl	1 library			aligned based (Plibrary),
  4    23 						/* a structure containing names of libraries to	*/
  4    24 						/*   be searched.				*/
  4    25 	  2 N			fixed bin,	/*   attribute: number of library names in array.	*/
  4    26 	  2 group (0 refer (library.N)),		/*   attribute: array of library names		*/
  4    27 	    3 V			char(32) unal,	/*   attribute: a library name (value).		*/
  4    28 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  4    29      dcl	Plibrary			ptr;		/* ptr to:  library structure.		*/
  4    30 						/*     this library name.			*/
  4    31 
  4    32      dcl	1 starname		aligned based (Pstarname),
  4    33 						/* a structure containing names of library entries*/
  4    34 						/*   being searched for.			*/
  4    35 	  2 N			fixed bin,	/*   attribute: number of starnames in array.	*/
  4    36 	  2 group (0 refer (starname.N)),		/*   attribute: array of starnames		*/
  4    37 	    3 V			char(32) unal,	/*   attribute: a starname (value).		*/
  4    38 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  4    39 						/*     this starname.			*/
  4    40      dcl	Pstarname			ptr;		/* ptr to:  starname structure.		*/
  4    41 
  4    42      dcl	1 exclude			aligned based (Pexclude),
  4    43 						/* a structure containing names of library entries*/
  4    44 						/*   being excluded from the search.		*/
  4    45 	  2 N			fixed bin,	/*   attribute: number of excludes in array.	*/
  4    46 	  2 group (0 refer (exclude.N)),		/*   attribute: array of excludes		*/
  4    47 	    3 V			char(32) unal,	/*   attribute: an exclude (value).		*/
  4    48 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  4    49 						/*     this exclude.			*/
  4    50      dcl	Pexclude			ptr;		/* ptr to:  exclude structure.		*/
  4    51 
  4    52 /* END OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       95 
       96 
       97 	end lib_next_name_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/15/84  0819.0  lib_next_name_.pl1                >special_ldd>on>6588>lib_next_name_.pl1
93           1    08/16/79  1752.9  lib_node_.incl.pl1                >ldd>include>lib_node_.incl.pl1
1-341        2    02/28/77  1409.3  lib_Svalid_req_.incl.pl1          >ldd>include>lib_Svalid_req_.incl.pl1
1-346        3    02/15/84  0754.6  lib_Scontrol_.incl.pl1            >special_ldd>on>6588>lib_Scontrol_.incl.pl1
95           4    02/15/84  0754.6  lib_based_args_.incl.pl1          >special_ldd>on>6588>lib_based_args_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
C                        11            based           fixed bin(35,0)          array level 3 dcl 4-32 ref 73
Dnames                                 based           structure                level 1 unaligned dcl 1-230
Iname                                  parameter       fixed bin(17,0)          dcl 39 set ref 15 62* 62 63 65 67 67 71* 71* 75 75
                                                                                  79 80 83*
N                                      based           fixed bin(17,0)          level 2 in structure "starname" dcl 4-32
                                                                                  in procedure "lib_next_name_" ref 72
N                         4            based           fixed bin(17,0)          level 2 in structure "Dnames" dcl 1-230 in procedure
                                                                                  "lib_next_name_" ref 63 71
PDnames                                parameter       pointer                  dcl 1-230 ref 15 63 65 67 71 75 75 79 80 83
Pstarname                              parameter       pointer                  dcl 4-40 ref 15 72 73 75 79
S                                      based           structure                level 1 dcl 2-96
Srequirements                          parameter       bit(72)                  dcl 2-96 set ref 15 65 67 70
Svalid_req                             based           structure                level 1 dcl 2-23
V                         1            based           char(32)                 array level 3 packed unaligned dcl 4-32 set ref 75
                                                                                  79*
addr                                                   builtin function         dcl 55 ref 65 67 70
blank_name                             constant        char(32)                 initial dcl 50 ref 63 89
code                            000100 automatic       fixed bin(35,0)          dcl 50 set ref 79* 80
group                     1            based           structure                array level 2 dcl 4-32
i                               000101 automatic       fixed bin(17,0)          dcl 50 set ref 72* 73 75 79*
match_star_name_                000010 constant        entry                    external dcl 57 ref 79
matching_names            0(01)        based           bit(1)                   level 2 packed unaligned dcl 2-96 ref 70
names                     0(02)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 2-96
                                                                                  in procedure "lib_next_name_" ref 65
names                     5            based           char(32)                 array level 2 in structure "Dnames" packed unaligned
                                                                                  dcl 1-230 in procedure "lib_next_name_" set ref 65
                                                                                  67 75 75 79* 80 83
node                                   based           structure                level 1 unaligned dcl 1-69
primary_name                           based           bit(1)                   level 2 packed unaligned dcl 2-96 ref 67
starname                               based           structure                level 1 dcl 4-32

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
D                                      based           structure                level 1 unaligned dcl 1-146
Dacl                                   based           structure                level 1 unaligned dcl 1-153
Ddir_acl                               based           structure                level 1 unaligned dcl 1-172
Ddir_iacl                              based           structure                level 1 unaligned dcl 1-190
Diacl                                  based           structure                level 1 unaligned dcl 1-209
Dnodes                                 based           structure                level 1 unaligned dcl 1-245
Dobj                                   based           structure                level 1 unaligned dcl 1-263
Dsearch_proc                           based           structure                level 1 unaligned dcl 1-311
Duser                                  based           structure                level 1 unaligned dcl 1-324
Luser                                  automatic       fixed bin(17,0)          dcl 1-324
Nacls                                  automatic       fixed bin(17,0)          dcl 1-153
Ndir_acls                              automatic       fixed bin(17,0)          dcl 1-172
Ndir_iacls                             automatic       fixed bin(17,0)          dcl 1-190
Niacls                                 automatic       fixed bin(17,0)          dcl 1-209
Nnames                                 automatic       fixed bin(17,0)          dcl 1-230
Nnodes                                 automatic       fixed bin(17,0)          dcl 1-245
PD                                     automatic       pointer                  dcl 1-146
PDacl                                  automatic       pointer                  dcl 1-153
PDdir_acl                              automatic       pointer                  dcl 1-172
PDdir_iacl                             automatic       pointer                  dcl 1-190
PDiacl                                 automatic       pointer                  dcl 1-209
PDnodes                                automatic       pointer                  dcl 1-245
PDobj                                  automatic       pointer                  dcl 1-263
PDsearch_proc                          automatic       pointer                  dcl 1-311
PDuser                                 automatic       pointer                  dcl 1-324
Pexclude                               automatic       pointer                  dcl 4-50
Plibrary                               automatic       pointer                  dcl 4-29
Pnode                                  automatic       pointer                  dcl 1-69
Sc                                     based           structure                level 1 dcl 3-20
Scontrol                               automatic       bit(36)                  dcl 3-20
Sreq                                   based           structure                level 1 dcl 1-343
Svalid                                 based           structure                level 1 dcl 1-343
Tacl                                   internal static fixed bin(17,0)          initial dcl 1-153
Tarchive                               internal static fixed bin(17,0)          initial dcl 1-358
Tarchive_comp                          internal static fixed bin(17,0)          initial dcl 1-358
Tdir_acl                               internal static fixed bin(17,0)          initial dcl 1-172
Tdir_iacl                              internal static fixed bin(17,0)          initial dcl 1-190
Tdirectory                             internal static fixed bin(17,0)          initial dcl 1-358
Tiacl                                  internal static fixed bin(17,0)          initial dcl 1-209
Tlink                                  internal static fixed bin(17,0)          initial dcl 1-358
Tmsf                                   internal static fixed bin(17,0)          initial dcl 1-358
Tmsf_comp                              internal static fixed bin(17,0)          initial dcl 1-358
Tnames                                 internal static fixed bin(17,0)          initial dcl 1-230
Tnodes                                 internal static fixed bin(17,0)          initial dcl 1-245
Tobj                                   internal static fixed bin(17,0)          initial dcl 1-263
Tsearch_proc                           internal static fixed bin(17,0)          initial dcl 1-311
Tsegment                               internal static fixed bin(17,0)          initial dcl 1-358
Tuser                                  internal static fixed bin(17,0)          initial dcl 1-324
Vacl_1                                 internal static fixed bin(17,0)          initial dcl 1-153
Vdir_acl_1                             internal static fixed bin(17,0)          initial dcl 1-172
Vdir_iacl_1                            internal static fixed bin(17,0)          initial dcl 1-190
Viacl_1                                internal static fixed bin(17,0)          initial dcl 1-209
Vnames_1                               internal static fixed bin(17,0)          initial dcl 1-230
Vnodes_1                               internal static fixed bin(17,0)          initial dcl 1-245
Vobj_1                                 internal static fixed bin(17,0)          initial dcl 1-263
Vsearch_proc_1                         internal static fixed bin(17,0)          initial dcl 1-311
Vuser_1                                internal static fixed bin(17,0)          initial dcl 1-324
brief_node_type                        internal static varying char(12)         initial array dcl 1-374
exclude                                based           structure                level 1 dcl 4-42
library                                based           structure                level 1 dcl 4-22
link_node                              based           structure                level 1 unaligned dcl 1-30
node_type                              internal static varying char(32)         initial array dcl 1-374

NAMES DECLARED BY EXPLICIT CONTEXT.
check                           000000 constant        label                    array(0:2) dcl 75 ref 73
lib_next_name_                  000015 constant        entry                    external dcl 15
nomatch                         000226 constant        label                    dcl 85 ref 77 81

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       276         310     240         306
Length       544     240        12         220      35           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lib_next_name_                       88 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lib_next_name_           000100 code                        lib_next_name_
                         000101 i                           lib_next_name_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
match_star_name_

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     15 000010        62 000022        63 000024        65 000036        67 000052        70 000066        71 000071
     72 000102        73 000113        75 000121        77 000143        79 000144        80 000176        81 000213
     83 000214        85 000226        86 000230        89 000233


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
