	COMPILATION LISTING OF SEGMENT record_to_vtocx
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/20/88  1041.1 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(86-01-16,Fawcett), approve(86-04-10,MCR7383),
       13*     audit(86-05-15,Martinson), install(86-07-18,MR12.0-1098):
       14*     Add support for 512_WORD_IO devices, 3380 and 3390.
       15*                                                   END HISTORY COMMENTS */
       16 
       17 
       18 record_to_vtocx:
       19      procedure () options (variable);
       20 
       21 /* adapted from adopt_seg  Bernard Greenberg 09/05/77 */
       22 /* modified for -pathname, to print the path of segment owning the address, E. A. Ranzenbach 06/05/80   */
       23 /* Modified to fix loop bug, increase max number of records, 04/17/81, W. Olin Sibert */
       24 /* Modified to use a temp segment for the disk table, 07/11/81, Art Beattie */
       25 /* Modified for -all, 9 August 1981, WOS */
       26 /* Modified for new PVTE and to check address against paging region, March 1982, J. Bongiovanni */
       27 
       28 dcl  nargs fixed bin;
       29 dcl  argno fixed bin;
       30 dcl  arg char (argl) based (argp);
       31 dcl  argl fixed bin (21);
       32 dcl  argp ptr;
       33 
       34 dcl  recnoa (MAX_RECORDS) fixed bin;
       35 dcl  found_address (MAX_RECORDS) bit (1) unaligned;
       36 
       37 dcl  recno fixed bin;
       38 dcl  naddrs fixed bin;
       39 dcl  highest_vtocx fixed bin;
       40 
       41 dcl  addrno fixed bin;
       42 dcl  pageno fixed bin;
       43 dcl  last_page fixed bin;
       44 dcl  addrs_left fixed bin;
       45 dcl (r, s) fixed bin;
       46 dcl  dev_type fixed bin;
       47 dcl  pvname char (32);
       48 dcl  pvt_size fixed bin (19);
       49 dcl  code fixed bin (35);
       50 dcl  pathname char (168);
       51 dcl (pvtx, vtocx) fixed bin;
       52 dcl  pvid bit (36) aligned;
       53 
       54 dcl  all_sw bit (1) aligned;
       55 dcl  path_sw bit (1) aligned;
       56 dcl  sector_sw bit (1) aligned;
       57 
       58 dcl  1 local_vtoce aligned like vtoce;
       59 
       60 dcl  error_table_$badopt fixed bin (35) external static;
       61 dcl  error_table_$noarg fixed bin (35) external static;
       62 dcl  error_table_$too_many_args fixed bin (35) external static;
       63 
       64 dcl  com_err_ entry options (variable);
       65 dcl  cu_$arg_count entry (fixed bin, fixed bin (35));
       66 dcl  cu_$arg_ptr entry (fixed bin, pointer, fixed bin (21), fixed bin (35));
       67 dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
       68 dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
       69 dcl  ioa_ entry options (variable);
       70 dcl  phcs_$get_vtoce entry (fixed bin, fixed bin, ptr, fixed bin (35));
       71 dcl  pvname_to_pvtx_ entry (char (*), fixed bin, bit (36) aligned, fixed bin (35));
       72 dcl  release_temp_segment_ entry (char (*), ptr, fixed bin (35));
       73 dcl  ring_zero_peek_$get_max_length entry (char(*), fixed bin(19), fixed bin(35));
       74 dcl  ring_zero_peek_$by_name entry (char(*), fixed bin(18), ptr, fixed bin(19), fixed bin(35));
       75 dcl  vpn_cv_uid_path_$ent entry (ptr, char (*), bit (36), fixed bin (35));
       76 
       77 dcl  MAX_RECORDS fixed bin internal static options (constant) init (500);
       78 dcl  myname char (32) init ("record_to_vtocx") internal static options (constant);
       79 
       80 dcl  cleanup condition;
       81 
       82 dcl (addr, binary, char, divide, hbound, null) builtin;
       83 
       84 /*  */
       85 
       86 	path_sw = "0"b;
       87 	all_sw = "0"b;
       88 	pvtp = null;
       89 
       90 	on condition (cleanup) begin;
       91 	     if pvtp ^= null () then call release_temp_segment_ (myname, pvtp, (0));
       92 	     end;
       93 
       94 	call cu_$arg_count (nargs, code);
       95 	if code ^= 0 then go to USAGE;
       96 
       97 	if nargs < 1 then do;
       98 USAGE_NOARG:   code = error_table_$noarg;
       99 USAGE:	     call com_err_ (code, myname,
      100 		"^/Usage:^-^a pvname rec_no1 {... rec_no^d} {-sector NNN} {-pathname}",
      101 		myname, hbound (recnoa, 1));
      102 	     return;
      103 	     end;
      104 
      105 	call cu_$arg_ptr (1, argp, argl, code);
      106 	pvname = arg;
      107 	call pvname_to_pvtx_ (pvname, pvtx, pvid, code);
      108 	if code ^= 0 then do;
      109 	     call com_err_ (code, myname, pvname);
      110 	     go to MAIN_RETURN;
      111 	     end;
      112 
      113 	call get_temp_segment_ (myname, pvtp, code);
      114 	if code ^= 0 then do;
      115 CANNOT_GET_PVT:
      116 	     call com_err_ (code, myname, "Cannot get ring zero PVT");
      117 	     goto MAIN_RETURN;
      118 	     end;
      119 
      120 	call ring_zero_peek_$get_max_length ("pvt", pvt_size, code);
      121 	if code ^= 0 then goto CANNOT_GET_PVT;
      122 	
      123 	call ring_zero_peek_$by_name ("pvt", 0, pvtp, pvt_size, code);
      124 	if code ^= 0 then goto CANNOT_GET_PVT;
      125 	
      126 	pvt_arrayp = addr (pvt.array);
      127 	
      128 	
      129 
      130 /*  */
      131 
      132 	naddrs = 0;				/* Number of record arguments */
      133 	sector_sw = "0"b;
      134 	dev_type = pvt_array (pvtx).device_type;
      135 
      136 	do argno = 2 to nargs;
      137 	     call cu_$arg_ptr (argno, argp, argl, (0));
      138 
      139 	     if (arg = "-pathname") | (arg = "-pn") then path_sw = "1"b;
      140 	     else if (arg = "-all") | (arg = "-a") then all_sw = "1"b;
      141 	     else if (arg = "-sector") then sector_sw = "1"b; /* Next number is a sector number */
      142 	     else if char (arg, 1) = "-" then do;
      143 		call com_err_ (error_table_$badopt, myname, "^a", arg);
      144 		goto MAIN_RETURN;
      145 		end;
      146 
      147 	     else do;
      148 		recno = cv_oct_check_ (arg, code);
      149 		if code ^= 0 then do;
      150 		     call com_err_ (0, myname, "Invalid octal address ^a", arg);
      151 		     go to MAIN_RETURN;
      152 		     end;
      153 
      154 		if sector_sw then do;		/* Preceded by -sector, so must convert */
      155 		     s = sect_per_cyl (dev_type);
      156 		     r = divide (recno, s, 17, 0) *
      157 		        (s - divide (s, sect_per_rec (dev_type), 17, 0) *
      158 		        sect_per_rec (dev_type));
      159 		     recno = divide (recno - r, sect_per_rec (dev_type), 17, 0);
      160 		     end;
      161 
      162 		if (recno < pvt_array (pvtx).baseadd)
      163 		     | (recno >= pvt_array (pvtx).baseadd + pvt_array (pvtx).totrec)
      164 		     then do;
      165 		     call com_err_ (0, myname, "^[Sector^;Record^] address ^a is outside of Paging Region",
      166 			sector_sw, arg);
      167 		     goto MAIN_RETURN;
      168 		     end;
      169 
      170 		naddrs = naddrs + 1;
      171 		if naddrs > hbound (recnoa, 1) then do;
      172 		     call com_err_ (error_table_$too_many_args, myname, "Too many record numbers. Max is ^d",
      173 			hbound (recnoa, 1));
      174 		     goto MAIN_RETURN;
      175 		     end;
      176 
      177 		sector_sw = "0"b;			/* Turn it off after collecting the argument */
      178 		recnoa (naddrs) = recno;
      179 		end;
      180 	     end;
      181 
      182 	if sector_sw then do;			/* If still set, something was missing */
      183 	     call com_err_ (error_table_$noarg, myname, "Octal sector number after -sector");
      184 	     goto MAIN_RETURN;
      185 	     end;
      186 
      187 	if naddrs = 0 then goto USAGE_NOARG;
      188 
      189 /*  */
      190 
      191 	addrs_left = naddrs;
      192 	found_address (*) = "0"b;
      193 	highest_vtocx = pvt_array (pvtx).n_vtoce - 1;	/* Zero origin */
      194 
      195 	vtocep = addr (local_vtoce);
      196 
      197 	do vtocx = 0 to highest_vtocx;
      198 	     call phcs_$get_vtoce (pvtx, vtocx, vtocep, code);
      199 	     if code ^= 0 then do;
      200 		call com_err_ (code, myname, "Error reading vtocx ^o", vtocx);
      201 		goto NEXT_VTOCE;
      202 		end;
      203 
      204 	     if (vtoce.uid = ""b) then goto NEXT_VTOCE;
      205 
      206 	     if all_sw then
      207 		last_page = 255;
      208 	     else last_page = binary (vtoce.csl, 9) - 1;
      209 
      210 	     do pageno = 0 to last_page;
      211 		do addrno = 1 to naddrs;
      212 		     if ^all_sw then
      213 			if found_address (addrno) then
      214 			     goto NEXT_ADDRESS;
      215 
      216 		     if recnoa (addrno) = binary (vtoce.fm (pageno), 18) then do;
      217 			call ioa_ ("Address ^o = page ^d of VTOC index ^o", recnoa (addrno), pageno, vtocx);
      218 
      219 			if path_sw then do;
      220 			     call vpn_cv_uid_path_$ent (addr (vtoce.uid_path), pathname, vtoce.uid, code);
      221 			     if code ^= 0 then
      222 				call com_err_ (code, myname, "Cannot get path of vtocx ^o on ^a",
      223 				     vtocx, pvname);
      224 
      225 			     else call ioa_ ("^5xvtocx ^o is ^a", vtocx, pathname);
      226 			     end;
      227 
      228 			else call ioa_ ("^5xUID ^w, ^a", vtoce.uid, vtoce.primary_name);
      229 
      230 			found_address (addrno) = "1"b; /* Remember that we have found it */
      231 
      232 			if ^all_sw then do; 	/* Make sure it doesn't get used again */
      233 			     recnoa (addrno) = -1;	/* This will cause further comparisons to fail */
      234 			     addrs_left = addrs_left - 1;
      235 			     if addrs_left = 0 then go to MAIN_RETURN;
      236 			     end;
      237 
      238 			goto NEXT_PAGE;
      239 			end;			/* of case for matching address */
      240 NEXT_ADDRESS:	     end; 			/* Of loop through addresses in the list */
      241 NEXT_PAGE:	end;				/* Of loop through pages in a vtoce */
      242 NEXT_VTOCE:    end; 				/* Of loop through VTOCEs */
      243 
      244 
      245 	do addrno = 1 to naddrs;
      246 	     if ^found_address (addrno) then
      247 		call com_err_ (0, myname, "Address ^o not found.", recnoa (addrno));
      248 	     end;
      249 
      250 MAIN_RETURN:
      251 	if pvtp ^= null () then call release_temp_segment_ (myname, pvtp, (0));
      252 	return;
      253 
      254  /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
  1     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
  1     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
  1     4 
  1     5 dcl  vtocep ptr;
  1     6 
  1     7 dcl 1 vtoce based (vtocep) aligned,
  1     8 
  1     9 
  1    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
  1    11 
  1    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
  1    13 
  1    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    15     2 csl bit (9),					/* current segment length - in 1024 word units */
  1    16     2 records bit (9),				/* number of records used by the seg in second storage */
  1    17     2 pad2 bit (9),
  1    18 
  1    19     2 dtu bit (36),					/* date and time segment was last used */
  1    20 
  1    21     2 dtm bit (36),					/* date and time segment was last modified */
  1    22 
  1    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    24     2 deciduous bit (1),				/* true if hc_sdw */
  1    25     2 nid bit (1),					/* no incremental dump switch */
  1    26     2 dnzp bit (1),					/* Dont null zero pages */
  1    27     2 gtpd bit (1),					/* Global transparent paging device */
  1    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
  1    29     2 damaged bit (1),				/* TRUE if contents damaged */
  1    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
  1    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
  1    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
  1    33     2 pad3 bit (8),
  1    34     2 dirsw bit (1),				/* directory switch */
  1    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
  1    36     2 pad4 bit (16)) unaligned,			/* not used */
  1    37 
  1    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
  1    39 
  1    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    41 
  1    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    43 
  1    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
  1    45 
  1    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
  1    47 
  1    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
  1    49 
  1    50 
  1    51 
  1    52 
  1    53 
  1    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
  1    55 
  1    56     2 pad6 (10) bit (36),				/* not used */
  1    57 
  1    58     2 ncd bit (1),					/* no complete dump switch */
  1    59     2 pad7 bit (17),
  1    60     2 pad8 bit (18),
  1    61 
  1    62     2 dtd bit (36),					/* date-time-dumped */
  1    63 
  1    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
  1    65 
  1    66     2 master_dir_uid bit (36),			/* superior master directory uid */
  1    67 
  1    68 
  1    69 
  1    70 
  1    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
  1    72 
  1    73     2 primary_name char (32),				/* primary name of the segment */
  1    74 
  1    75     2 time_created bit (36),				/* time the segment was created */
  1    76 
  1    77     2 par_pvid bit (36),				/* physical volume id of the parent */
  1    78 
  1    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
  1    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
  1    81 
  1    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
  1    83 
  1    84     2 access_class bit (72),				/* access class in branch */
  1    85     2 perm_flags aligned,
  1    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
  1    87       3 pad9 bit (35) unal,
  1    88     2 owner bit (36);				/* pvid of this volume */
  1    89 
  1    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
  1    91 
  1    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
  1    93     2 pad1 bit (7*36),
  1    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    95     2 pad2 bit (184*36);
  1    96 
  1    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      254 
      255  /*	BEGIN INCLUDE FILE ... pvt.incl.pl1 ... last modified January 1982 */
  2     2 
  2     3 
  2     4 /* The physical volume table (PVT) is a wired-down table.
  2     5*   It has one entry for each spindle present, be it for
  2     6*   Storage System or "I/O" use.
  2     7**/
  2     8 
  2     9      dcl	   pvt$		      ext,
  2    10 	   pvtp		      ptr;
  2    11 
  2    12 
  2    13      dcl	   1 pvt		      based (pvtp) aligned,
  2    14 
  2    15 	     2 n_entries	      fixed bin (17),	/* number of PVT entries */
  2    16 	     2 max_n_entries      fixed bin (17),	/* max number of PVT entries */
  2    17 	     2 n_in_use	      fixed bin (17),	/* number of PVT entries in use */
  2    18 	     2 rwun_pvtx	      fixed bin,		/* rewind_unloading pvtx */
  2    19 	     2 shutdown_state     fixed bin,		/* state of previous shutdown */
  2    20 	     2 esd_state	      fixed bin,		/* state of ESD, >0 iff in ESD */
  2    21 	     2 prev_shutdown_state fixed bin,		/* shutdown state of previous bootload */
  2    22 	     2 prev_esd_state     fixed bin,		/* ESD state of previous bootload */
  2    23 
  2    24 	     2 time_of_bootload fixed bin (71),		/* Time of bootload */
  2    25 	     2 root_lvid	      bit (36) aligned,	/* Logical volume ID of Root Logical Volume (RLV) */
  2    26 	     2 root_pvid	      bit (36) aligned,	/* Physical volume ID of Root Physical Volume (RPV) */
  2    27 	     2 root_pvtx	      fixed bin,		/* Index to PVTE for Root Physical Volume (RPV) */
  2    28 	     2 root_vtocx	      fixed bin,		/* VTOCE index for root (>) */
  2    29 	     2 disk_table_vtocx   fixed bin,		/* VTOCE index for disk table on RPV */
  2    30 	     2 disk_table_uid     bit (36) aligned,	/* File System UID for disk_table */
  2    31 
  2    32 	     2 rpvs_requested     bit (1) aligned,	/* RPVS keyword given on BOOT */
  2    33 	     2 rpv_needs_salv     bit (1) aligned,	/* RPV required (not requested) salvage */
  2    34 	     2 rlv_needs_salv     bit (1) aligned,	/* RLV required (not requested) salvage */
  2    35 	     2 volmap_lock_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
  2    36 	     2 volmap_idle_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
  2    37 	     2 vtoc_map_lock_wait_constant bit (36) aligned, /* For constructing wait event: OR pvte_rel into lower */
  2    38 	     2 n_volmap_locks_held fixed bin (17),	/* Current number of volmap locks held */
  2    39 	     2 n_vtoc_map_locks_held fixed bin (17),	/* Current number of VTOC Map locks held */
  2    40 
  2    41 	     2 last_volmap_time   fixed bin (71),	/* Time a volmap was last locked/unlocked */
  2    42 	     2 last_vtoc_map_time fixed bin (71),	/* Time a VTOC Map was last locked/unlocked */
  2    43 	     2 total_volmap_lock_time fixed bin (71),	/* Total time volmap's were locked (integral) */
  2    44 	     2 total_vtoc_map_lock_time fixed bin (71),	/* Total time VTOC Maps were locked (integral) */
  2    45 
  2    46 	     2 n_volmap_locks     fixed bin (35),	/* Number times a volmap was locked */
  2    47 	     2 n_vtoc_map_locks   fixed bin (35),	/* Number times a vtoc_map was locked */
  2    48 	     2 volmap_lock_nowait_calls fixed bin (35),	/* Number calls to lock volmap, no wait */
  2    49 	     2 volmap_lock_nowait_fails fixed bin (35),	/* Number times lock failed */
  2    50 	     2 volmap_lock_wait_calls fixed bin (35),	/* Number calls to lock volmap, wait */
  2    51 	     2 volmap_lock_wait_fails fixed bin (35),	/* Number times lock failed */
  2    52 	     2 pad (2) bit (36) aligned,
  2    53 
  2    54 	     2 array	      fixed bin (71);	/* Array of PVTE's -- must be double-word aligned */
  2    55 
  2    56 
  2    57 
  2    58 /*	END INCLUDE FILE ...pvt.incl.pl1 */
      255 
      256  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  3     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  3     8*     Add the support for subvolumes
  3     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  3    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  3    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  3    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  3    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  3    14*     Added inconsistent_dbm bit for determining the status of volume
  3    15*     dumper bit maps.
  3    16*                                                   END HISTORY COMMENTS */
  3    17 
  3    18      dcl	   pvt$array	      aligned external;
  3    19      dcl	   pvt$max_n_entries      fixed bin external;
  3    20 
  3    21      dcl	   pvt_arrayp	      ptr;
  3    22      dcl	   pvtep		      ptr;
  3    23 
  3    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  3    25 
  3    26      dcl	   1 pvte		      based (pvtep) aligned,
  3    27 
  3    28 	     2 pvid	      bit (36),		/* physical volume ID */
  3    29 
  3    30 	     2 lvid	      bit (36),		/* logical volume ID */
  3    31 
  3    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  3    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  3    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  3    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  3    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  3    37 	     2 pad3	      bit (2) unaligned,
  3    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  3    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  3    40 
  3    41 
  3    42 
  3    43 	     2 devname	      char (4),		/* device name */
  3    44 
  3    45 	     (2 device_type	      fixed bin (8),	/* device type */
  3    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  3    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  3    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  3    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  3    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  3    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  3    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  3    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  3    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  3    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  3    56 	     2 scav_check_address
  3    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  3    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  3    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  3    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  3    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  3    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  3    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  3    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  3    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  3    66 
  3    67 
  3    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  3    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  3    70 
  3    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  3    72 
  3    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  3    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  3    75 
  3    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  3    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  3    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  3    79 	     2 records_per_cyl    fixed bin,
  3    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  3    81 	     2 sv_name            char (2) aligned,
  3    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  3    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  3    84 
  3    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  3    86 	     2 pad2	      bit (18) unaligned,
  3    87 
  3    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  3    89 
  3    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  3    91 
  3    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  3    93 
  3    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  3    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  3    96 
  3    97 
  3    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  3    99 
  3   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  3   101 
  3   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  3   103 
  3   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  3   105 
  3   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  3   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  3   108 
  3   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  3   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  3   111 
  3   112 
  3   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  3   114 	   VOLMAP_ASYNC_READ      init (1),
  3   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  3   116 
  3   117 
  3   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      256 
      257  /* Begin include file ...... fs_dev_types.incl.pl1 */
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  4     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  4     6*     Add support for FIPS
  4     7*     3380.
  4     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  4     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  4    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  4    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  4    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  4    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  4    14*                                                   END HISTORY COMMENTS */
  4    15 
  4    16 /* Modified 5/19/76 by N. I. Morris */
  4    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  4    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  4    19 /* Modified '82 by BIM for needs_alt_part */
  4    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  4    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  4    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  4    23*   volmap and record stock can be expanded. */
  4    24 
  4    25 /*
  4    26********************************************************************************
  4    27**							        *
  4    28**                           WARNING:                                          *
  4    29**							        *
  4    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  4    31**   type is added.						        *
  4    32**							        *
  4    33**   There are other include files that contain arrays indexed by the device   *
  4    34**   index obtained by references to MODELX or MODELN in this include file.    *
  4    35**   These must be modified when a new device type is added:		        *
  4    36**   disk_pack.incl.pl1					        *
  4    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  4    38**							        *
  4    39********************************************************************************
  4    40**/
  4    41 
  4    42 
  4    43 dcl (maxdevt init (9),				/* maximum legal devt */
  4    44      bulkdevt init (1),				/* bulk store devt */
  4    45      msu0500devt init (2),				/* MSU0500 device type */
  4    46      msu0451devt init (3),				/* MSU0451 device type */
  4    47      msu0450devt init (3),				/* MSU0450 device type */
  4    48      msu0400devt init (4),				/* MSU0400 device type */
  4    49      dsu191devt init (4),				/* DSU191 device type */
  4    50      dsu190devt init (5),				/* DSU190 device type */
  4    51      dsu181devt init (6),				/* DSU181 device type */
  4    52      msu0501devt init (7),				/* MSU0501 device type */
  4    53      fips3380devt init (8),				/* 3380D FIPS device type */
  4    54      fips3381devt init (9)				/* 3380E FIPS device type */
  4    55      ) fixed bin (4) static options (constant);
  4    56 
  4    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  4    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  4    59 
  4    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  4    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  4    62 
  4    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  4    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  4    65 
  4    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  4    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  4    68 
  4    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  4    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  4    71 
  4    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  4    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  4    74 
  4    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  4    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  4    77 
  4    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  4    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  4    80 
  4    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  4    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  4    83 
  4    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  4    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  4    86 
  4    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  4    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  4    89 
  4    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  4    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  4    92 
  4    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  4    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  4    95 
  4    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  4    97      ("abc");
  4    98 
  4    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  4   100      init ("a","b","c");
  4   101 
  4   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  4   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  4   104 
  4   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  4   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  4   107 
  4   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  4   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  4   110 
  4   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  4   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  4   113 
  4   114 
  4   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  4   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  4   117 
  4   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  4   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  4   120 
  4   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  4   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  4   123 
  4   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  4   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  4   126 
  4   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  4   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  4   129 
  4   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  4   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  4   132 
  4   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  4   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  4   135 
  4   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  4   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  4   138 
  4   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  4   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  4   141 
  5     1 /* Begin fs_dev_types_sector.incl.pl1 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  5     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  5     7*     Add the sector differance for devices that do 64 word IO and devices that
  5     8*     do 512 word IO.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  5    12*	 need all the data in fs_dev_types. This is also included in
  5    13*	 fs_dev_types.incl.pl1  */
  5    14 
  5    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  5    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  5    17 
  5    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  5    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  5    20 
  5    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  5    22  /* table of # of sectors per record on each device */
  5    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  5    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  5    25 
  5    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  5    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  5    28 	
  5    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  5    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  5    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  5    32 
  5    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  5    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  5    35 
  5    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  5    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  5    38 
  5    39 /* End fs_dev_types_sector.incl.pl1 */
  5    40 
  4   142 
  4   143 
  4   144 /* End of include file ...... fs_dev_types.incl.pl1 */
      257 
      258 
      259 	end record_to_vtocx;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/19/88  1533.3  record_to_vtocx.pl1               >special_ldd>install>MR12.2-1061>record_to_vtocx.pl1
254          1    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
255          2    05/27/82  1525.8  pvt.incl.pl1                      >ldd>include>pvt.incl.pl1
256          3    07/19/88  1523.2  pvte.incl.pl1                     >special_ldd>install>MR12.2-1061>pvte.incl.pl1
257          4    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
4-142        5    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
MAX_RECORDS                            constant        fixed bin(17,0)          initial dcl 77 ref 34 35
addr                                                   builtin function         dcl 82 ref 126 195 220 220
addrno                          000111 automatic       fixed bin(17,0)          dcl 41 set ref 211* 212 216 217 230 233* 245* 246
                                                                                  246*
addrs_left                      000114 automatic       fixed bin(17,0)          dcl 44 set ref 191* 234* 234 235
all_sw                          000207 automatic       bit(1)                   dcl 54 set ref 87* 140* 206 212 232
arg                                    based           char                     packed unaligned dcl 30 set ref 106 139 139 140 140
                                                                                  141 142 143* 148* 150* 165*
argl                            000102 automatic       fixed bin(21,0)          dcl 31 set ref 105* 106 137* 139 139 140 140 141 142
                                                                                  143 143 148 148 150 150 165 165
argno                           000101 automatic       fixed bin(17,0)          dcl 29 set ref 136* 137*
argp                            000104 automatic       pointer                  dcl 32 set ref 105* 106 137* 139 139 140 140 141 142
                                                                                  143 148 150 165
array                    50            based           fixed bin(71,0)          level 2 dcl 2-13 set ref 126
baseadd                  20            based           fixed bin(18,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 3-24 ref 162 162
binary                                                 builtin function         dcl 82 ref 208 216
char                                                   builtin function         dcl 82 ref 142
cleanup                         000512 stack reference condition                dcl 80 ref 90
code                            000131 automatic       fixed bin(35,0)          dcl 49 set ref 94* 95 98* 99* 105* 107* 108 109*
                                                                                  113* 114 115* 120* 121 123* 124 148* 149 198* 199
                                                                                  200* 220* 221 221*
com_err_                        000016 constant        entry                    external dcl 64 ref 99 109 115 143 150 165 172 183
                                                                                  200 221 246
csl                       2(09)        based           bit(9)                   level 2 packed packed unaligned dcl 1-7 ref 208
cu_$arg_count                   000020 constant        entry                    external dcl 65 ref 94
cu_$arg_ptr                     000022 constant        entry                    external dcl 66 ref 105 137
cv_oct_check_                   000024 constant        entry                    external dcl 67 ref 148
dev_type                        000117 automatic       fixed bin(17,0)          dcl 46 set ref 134* 155 156 156 159
device_type               4            based           fixed bin(8,0)           array level 2 packed packed unaligned dcl 3-24 ref
                                                                                  134
divide                                                 builtin function         dcl 82 ref 156 156 159
error_table_$badopt             000010 external static fixed bin(35,0)          dcl 60 set ref 143*
error_table_$noarg              000012 external static fixed bin(35,0)          dcl 61 set ref 98 183*
error_table_$too_many_args      000014 external static fixed bin(35,0)          dcl 62 set ref 172*
fm                       20            based           bit(18)                  array level 2 packed packed unaligned dcl 1-7 ref
                                                                                  216
found_address                   000106 automatic       bit(1)                   array packed unaligned dcl 35 set ref 192* 212 230*
                                                                                  246
get_temp_segment_               000026 constant        entry                    external dcl 68 ref 113
hbound                                                 builtin function         dcl 82 ref 99 99 171 172 172
highest_vtocx                   000110 automatic       fixed bin(17,0)          dcl 39 set ref 193* 197
ioa_                            000030 constant        entry                    external dcl 69 ref 217 225 228
last_page                       000113 automatic       fixed bin(17,0)          dcl 43 set ref 206* 208* 210
local_vtoce                     000212 automatic       structure                level 1 dcl 58 set ref 195
myname                          000022 constant        char(32)                 initial packed unaligned dcl 78 set ref 91* 99* 99*
                                                                                  109* 113* 115* 143* 150* 165* 172* 183* 200* 221*
                                                                                  246* 250*
n_vtoce                  17(18)        based           fixed bin(17,0)          array level 2 packed packed unaligned dcl 3-24 ref
                                                                                  193
naddrs                          000107 automatic       fixed bin(17,0)          dcl 38 set ref 132* 170* 170 171 178 187 191 211 245
nargs                           000100 automatic       fixed bin(17,0)          dcl 28 set ref 94* 97 136
null                                                   builtin function         dcl 82 ref 88 91 250
pageno                          000112 automatic       fixed bin(17,0)          dcl 42 set ref 210* 216 217*
path_sw                         000210 automatic       bit(1)                   dcl 55 set ref 86* 139* 219
pathname                        000132 automatic       char(168)                packed unaligned dcl 50 set ref 220* 225*
phcs_$get_vtoce                 000032 constant        entry                    external dcl 70 ref 198
primary_name            260            based           char(32)                 level 2 packed packed unaligned dcl 1-7 set ref 228*
pvid                            000206 automatic       bit(36)                  dcl 52 set ref 107*
pvname                          000120 automatic       char(32)                 packed unaligned dcl 47 set ref 106* 107* 109* 221*
pvname_to_pvtx_                 000034 constant        entry                    external dcl 71 ref 107
pvt                                    based           structure                level 1 dcl 2-13
pvt_array                              based           structure                array level 1 dcl 3-24
pvt_arrayp                      000524 automatic       pointer                  dcl 3-21 set ref 126* 134 162 162 162 193
pvt_size                        000130 automatic       fixed bin(19,0)          dcl 48 set ref 120* 123*
pvte                                   based           structure                level 1 dcl 3-26
pvtp                            000522 automatic       pointer                  dcl 2-9 set ref 88* 91 91* 113* 123* 126 250 250*
pvtx                            000204 automatic       fixed bin(17,0)          dcl 51 set ref 107* 134 162 162 162 193 198*
r                               000115 automatic       fixed bin(17,0)          dcl 45 set ref 156* 159
recno                           000106 automatic       fixed bin(17,0)          dcl 37 set ref 148* 156 159* 159 162 162 178
recnoa                          000106 automatic       fixed bin(17,0)          array dcl 34 set ref 99 99 171 172 172 178* 216 217*
                                                                                  233* 246*
release_temp_segment_           000036 constant        entry                    external dcl 72 ref 91 250
ring_zero_peek_$by_name         000042 constant        entry                    external dcl 74 ref 123
ring_zero_peek_$get_max_length  000040 constant        entry                    external dcl 73 ref 120
s                               000116 automatic       fixed bin(17,0)          dcl 45 set ref 155* 156 156 156
sect_per_cyl                    000011 constant        fixed bin(17,0)          initial array dcl 5-15 ref 155
sect_per_rec                    000000 constant        fixed bin(17,0)          initial array dcl 5-21 ref 156 156 159
sector_sw                       000211 automatic       bit(1)                   dcl 56 set ref 133* 141* 154 165* 177* 182
seek_command                    000526 automatic       bit(6)                   initial array packed unaligned dcl 4-84 set ref
                                                                                  4-84* 4-84* 4-84* 4-84* 4-84* 4-84* 4-84* 4-84*
                                                                                  4-84*
totrec                    7(18)        based           fixed bin(17,0)          array level 2 packed packed unaligned dcl 3-24 ref
                                                                                  162
uid                       1            based           bit(36)                  level 2 packed packed unaligned dcl 1-7 set ref 204
                                                                                  220* 228*
uid_path                240            based           bit(36)                  array level 2 packed packed unaligned dcl 1-7 set
                                                                                  ref 220 220
vpn_cv_uid_path_$ent            000044 constant        entry                    external dcl 75 ref 220
vtoce                                  based           structure                level 1 dcl 1-7
vtocep                          000520 automatic       pointer                  dcl 1-5 set ref 195* 198* 204 208 216 220 220 220
                                                                                  228 228
vtocx                           000205 automatic       fixed bin(17,0)          dcl 51 set ref 197* 198* 200* 217* 221* 225*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
MODEL                                  internal static fixed bin(17,0)          initial array dcl 4-57
MODELN                                 internal static fixed bin(17,0)          initial array dcl 4-63
MODELX                                 internal static fixed bin(17,0)          initial array dcl 4-60
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 3-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 3-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 3-113
bulkdevt                               internal static fixed bin(4,0)           initial dcl 4-43
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 4-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 4-105
dev_time                               internal static float bin(27)            initial array dcl 4-139
device_names                           internal static char(4)                  initial array dcl 4-66
dsu181devt                             internal static fixed bin(4,0)           initial dcl 4-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 4-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 4-43
fips3380devt                           internal static fixed bin(4,0)           initial dcl 4-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 4-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 4-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 4-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 4-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 4-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 4-124
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 4-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 4-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 4-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 4-127
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 4-121
maxdevt                                internal static fixed bin(4,0)           initial dcl 4-43
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 4-75
msu0400devt                            internal static fixed bin(4,0)           initial dcl 4-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 4-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 4-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 4-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 4-43
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 4-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 4-93
pvt$                                   external static fixed bin(17,0)          dcl 2-9
pvt$array                              external static fixed bin(17,0)          dcl 3-18
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 3-19
pvtep                                  automatic       pointer                  dcl 3-22
rec_per_cyl                            internal static fixed bin(17,0)          initial array dcl 4-108
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 4-87
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 4-90
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 5-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 5-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 5-26
seg_vtoce                              based           structure                level 1 dcl 1-92
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 4-78
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 4-111
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 4-99
valid_sv_string                        internal static char(3)                  initial packed unaligned dcl 4-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 5-29
vtoce_parts                            based           bit(2304)                array dcl 1-90
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 5-36

NAMES DECLARED BY EXPLICIT CONTEXT.
CANNOT_GET_PVT                  000624 constant        label                    dcl 115 ref 121 124
MAIN_RETURN                     002062 constant        label                    dcl 250 ref 110 117 144 151 167 174 184 235
NEXT_ADDRESS                    002000 constant        label                    dcl 240 ref 212
NEXT_PAGE                       002002 constant        label                    dcl 241 ref 238
NEXT_VTOCE                      002004 constant        label                    dcl 242 ref 201 204
USAGE                           000447 constant        label                    dcl 99 ref 95
USAGE_NOARG                     000444 constant        label                    dcl 98 ref 187
record_to_vtocx                 000246 constant        entry                    external dcl 18

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2324        2372    2114        2334
Length      2704    2114        46         275     207           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
record_to_vtocx                     410 external procedure  is an external procedure.  
on unit on line 90                   80 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
record_to_vtocx          000100 nargs                       record_to_vtocx
                         000101 argno                       record_to_vtocx
                         000102 argl                        record_to_vtocx
                         000104 argp                        record_to_vtocx
                         000106 found_address               record_to_vtocx
                         000106 recno                       record_to_vtocx
                         000106 recnoa                      record_to_vtocx
                         000107 naddrs                      record_to_vtocx
                         000110 highest_vtocx               record_to_vtocx
                         000111 addrno                      record_to_vtocx
                         000112 pageno                      record_to_vtocx
                         000113 last_page                   record_to_vtocx
                         000114 addrs_left                  record_to_vtocx
                         000115 r                           record_to_vtocx
                         000116 s                           record_to_vtocx
                         000117 dev_type                    record_to_vtocx
                         000120 pvname                      record_to_vtocx
                         000130 pvt_size                    record_to_vtocx
                         000131 code                        record_to_vtocx
                         000132 pathname                    record_to_vtocx
                         000204 pvtx                        record_to_vtocx
                         000205 vtocx                       record_to_vtocx
                         000206 pvid                        record_to_vtocx
                         000207 all_sw                      record_to_vtocx
                         000210 path_sw                     record_to_vtocx
                         000211 sector_sw                   record_to_vtocx
                         000212 local_vtoce                 record_to_vtocx
                         000520 vtocep                      record_to_vtocx
                         000522 pvtp                        record_to_vtocx
                         000524 pvt_arrayp                  record_to_vtocx
                         000526 seek_command                record_to_vtocx

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          alloc_auto_adj      mpfx2               enable_op
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   cv_oct_check_
get_temp_segment_             ioa_                          phcs_$get_vtoce               pvname_to_pvtx_
release_temp_segment_         ring_zero_peek_$by_name       ring_zero_peek_$get_max_length
vpn_cv_uid_path_$ent

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$noarg            error_table_$too_many_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 000245        34 000253        35 000257    4   84 000266       217 000355        86 000357        87 000360
     88 000361        90 000363        91 000377        92 000425        94 000426        95 000437        97 000441
     98 000444        99 000447       102 000504       105 000505       106 000524       107 000531       108 000556
    109 000560       110 000600       113 000601       114 000622       115 000624       117 000653       120 000654
    121 000677       123 000701       124 000735       126 000737       132 000742       133 000743       134 000744
    136 000751       137 000761       139 000777       140 001014       141 001027       142 001036       143 001045
    144 001077       148 001100       149 001124       150 001126       151 001165       154 001166       155 001171
    156 001174       159 001212       162 001216       165 001236       167 001276       170 001277       171 001300
    172 001303       174 001334       177 001335       178 001336       180 001342       182 001344       183 001347
    184 001373       187 001374       191 001376       192 001377       193 001413       195 001423       197 001425
    198 001433       199 001450       200 001452       201 001505       204 001506       206 001511       208 001516
    210 001523       211 001531       212 001541       216 001550       217 001564       219 001613       220 001615
    221 001646       225 001704       226 001730       228 001731       230 001761       232 001766       233 001770
    234 001773       235 001775       238 001777       240 002000       241 002002       242 002004       245 002006
    246 002015       248 002060       250 002062       252 002110


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
