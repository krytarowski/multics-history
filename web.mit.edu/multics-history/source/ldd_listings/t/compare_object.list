	COMPILATION LISTING OF SEGMENT compare_object
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/15/84  1043.0 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /*
       12*	 Written:	20 Sept 1972 by Richard A. Barnes
       13*	Modified:	4 May 1977 by RAB for get_temp_segments_
       14*	Modified: 17 August 1977 by MBW for perprocess static switch	
       15*	Err msgs fixed to contain target pathname S. Herbst 07/23/79
       16*	Usage message added 10/03/79 S. Herbst
       17*	Utilize date_time_$format("date_time" 06/19/84 J A Falksen */
       18 compare_object:	cob:	procedure;
       19 dcl	alen fixed bin(17);
       20 dcl	aptr pointer;
       21 dcl	arg char(alen) unaligned based(aptr);
       22 dcl	arg_num fixed bin(17) init(3);
       23 dcl	code fixed bin(35);		/* error code */
       24 dcl	command bit(1) aligned;	/*  "1"b if invoked as command */
       25 dcl	command_error condition;
       26 dcl	dname(2) char(168);		/* directory pathname */
       27 dcl	ename(2) char(32);		/* entry name */
       28 dcl	have_ptrs bit(1) aligned;	/* "1"b if object ptrs provided */
       29 dcl	(i,j) fixed bin;
       30 dcl	line char(80) varying aligned;
       31 dcl	isparm bit(1) init("1"b);
       32 dcl	nbits(2) fixed bin(24);
       33 dcl	oip ptr;
       34 dcl	1 parm,
       35 		2 brief bit(1) unaligned init("0"b),
       36 		2 all unaligned,
       37 		 (3 text bit (1),
       38 		 3 defs bit(1),
       39 		 3 link bit(1),
       40 		 3 static bit(1),
       41 		 3 symbol bit(1))  init ("0"b);
       42 dcl	path (2) char(168);
       43 dcl	qual bit(1) init("0"b);
       44 dcl	1 relinfo based aligned,
       45 	2 decl_vers fixed bin,
       46 	2 n_bits fixed bin,
       47 	2 relbits bit(0 refer(relinfo.n_bits));
       48 dcl	serious bit(1) aligned;
       49 dcl	time char(64)var;
       50 dcl	segp ptr;
       51 dcl	1 seg,
       52 		2 p(2) pointer init ((2) null),	/* segment pointers */
       53 		2 scratch(2) pointer init((2) null),	/* scratch for relocation bits */
       54 		2 sname(2) char(200);	/* segment names */
       55 dcl	1 result,
       56 		(2 text,
       57 		2 defs,
       58 		2 link,
       59 		2 static,
       60 		2 symbol,
       61 		2 perprocess_static,
       62 		2 length) bit(1) unaligned init ("0"b);
       63 dcl	rslt(7) bit(1) defined(result);
       64 dcl	keyword(14) char(8) aligned static init("-brief","-text","-defs","-link","-static","-symbol",
       65 		 "-all", "-bf"," "," ", "-lk","-stat","-sym","-a") options (constant);
       66 dcl	nparm fixed bin(17) init(divide(hbound(keyword,1),2,17,0));
       67 dcl	bits(6) bit(1) defined (parm);
       68 dcl	token char(8);
       69 dcl	error_table_$badopt external fixed bin(35);
       70 dcl	rname char(14) init("compare_object") static options(constant);
       71 dcl	word char(14) varying;
  1     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  1     2*coded February 8, 1972 by Michael J. Spier	*/
  1     3 /* modified May 26, 1972 by M. Weaver */
  1     4 /* modified 15 April, 1975 by M. Weaver */
  1     5 
  1     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  1     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  1     8 	2 textp pointer,			/* pointer to beginning of text section */
  1     9 	2 defp pointer,			/* pointer to beginning of definition section */
  1    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  1    11 	2 statp pointer,			/* pointer to beginning of static section */
  1    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  1    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  1    14 	2 tlng fixed bin,			/* length in words of text section */
  1    15 	2 dlng fixed bin,			/* length in words of definition section */
  1    16 	2 llng fixed bin,			/* length in words of linkage section */
  1    17 	2 ilng fixed bin,			/* length in words of static section */
  1    18 	2 slng fixed bin,			/* length in words of symbol section */
  1    19 	2 blng fixed bin,			/* length in words of break map */
  1    20 	2 format,				/* word containing bit flags about object type */
  1    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  1    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  1    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  1    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  1    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  1    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  1    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  1    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  1    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  1    30 	  3 pad bit(27) unaligned,
  1    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  1    32 	2 textlinkp pointer,		/* ptr to first link in text */
  1    33 
  1    34 	/* LIMIT OF BRIEF STRUCTURE */
  1    35 
  1    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  1    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  1    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  1    39 	2 cvers aligned,			/* generator version name in printable char string form */
  1    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  1    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  1    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  1    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  1    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  1    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  1    46 
  1    47 	/* LIMIT OF DISPLAY STRUCTURE */
  1    48 
  1    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  1    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  1    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  1    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  1    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  1    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  1    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  1    56 					/* currently not used by system */
  1    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  1    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  1    59 
  1    60 declare	object_info_version_2 fixed bin int static init(2);
  1    61 
  1    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
       72 
       73 
       74 dcl	1 oi(2) aligned like object_info;
       75 
       76 /*  function declarations */
       77 
       78 dcl	date_time_$format entry (char(*), fixed bin(71), char(*), char(*)) returns(char(250) var);
       79 dcl	cu_$arg_ptr entry(fixed bin,ptr,fixed bin,fixed bin(35));
       80 dcl	expand_pathname_ entry(char(*),char(*),char(*),fixed bin(35));
       81 dcl	get_equal_name_ entry(char(*),char(*),char(*),fixed bin(35));
       82 dcl	hcs_$initiate_count entry(char(*),char(*),char(*),fixed bin(24),fixed bin(12),
       83 		ptr,fixed bin(35));
       84 dcl	(get_temp_segments_, release_temp_segments_) entry(char(*),(*) ptr,fixed bin(35));
       85 dcl	object_info_$long entry(ptr,fixed bin(24),ptr,fixed bin(35));
       86 dcl	(com_err_, com_err_$suppress_name) entry options(variable);
       87 dcl	ioa_ entry options(variable);
       88 dcl	compare_text_ entry(ptr,bit(1),bit(1),ptr);
       89 dcl	compare_defs_ entry (ptr,bit(1),bit(1),ptr);
       90 dcl	compare_link_ entry (ptr,bit(1),bit(1),ptr);
       91 dcl	compare_static_ entry (ptr,bit(1),bit(1),ptr);
       92 dcl	hcs_$terminate_noname entry(ptr,fixed bin(35));
       93 
       94 dcl (addr, divide, hbound, mod, null, rtrim, string, substr) builtin;
       95 
       96 dcl	cleanup condition;
       97 
       98 	command = "1"b;
       99 	have_ptrs = "0"b;
      100 	go to join;
      101 
      102 compare_object_$ptr:	entry(ptr1,len1,ptr2,len2) returns(bit(1) aligned);
      103 
      104 dcl	ptr1 ptr,		/* ptr to first object segment */
      105 	len1 fixed bin(24),	/* bit_count of first object segment */
      106 	ptr2 ptr,		/* ptr to second object segment */
      107 	len2 fixed bin(24);	/* bit_count of second object segment */
      108 
      109 	have_ptrs = "1"b;
      110 	p(1) = ptr1;
      111 	p(2) = ptr2;
      112 	nbits(1) = len1;
      113 	nbits(2) = len2;
      114 	sname(1) = " ";
      115 	sname(2) = " ";
      116 	go to not_command;
      117 
      118 compare_object_:	entry(P_path1,P_path2) returns(bit(1) aligned);
      119 
      120 dcl	(P_path1,P_path2) char(*);	/* pathnames of segs to be compared */
      121 
      122 	have_ptrs = "0"b;
      123 	path(1) = P_path1;
      124 	path(2) = P_path2;
      125 
      126 not_command:
      127 	command = "0"b;
      128 	parm.brief = "1"b;
      129 	isparm = "0"b;
      130 	on condition(command_error) string(result) = "111111"b;
      131 
      132 /* set up 2 segments for comparison */
      133 
      134 join:
      135 	oip = addr(oi);
      136 	segp = addr(seg);
      137 
      138 	on condition(cleanup) call clean_up;
      139 
      140 	do j= 1 to 2;
      141 	     if ^ have_ptrs
      142 	     then do;
      143 		if command
      144 		then do;
      145 		     call cu_$arg_ptr(j,aptr,alen,code);
      146 		     if code ^= 0 then do;
      147 			call com_err_$suppress_name (0, "compare_object",
      148 			     "Usage:  compare_object oldpath newpath {-control_args}");
      149 			return;
      150 		     end;
      151 		     path(j) = arg;
      152 		     end;
      153 		call expand_pathname_(path(j),dname(j),ename(j),code);
      154 		if code ^= 0 then call error(path(j));
      155 		if j = 2 then
      156 		do;
      157 			call get_equal_name_(ename(1),(ename(2)),ename(2),code);
      158 			if code ^= 0 then call error(ename(2));
      159 		end;
      160 		sname(j) = rtrim(dname(j)) || ">" || ename(j);
      161 		call hcs_$initiate_count(dname(j),ename(j),"",nbits(j),1,p(j),code);
      162 		if p(j)=null then call error(sname(j));
      163 		end;
      164 
      165 	     /* get object information */
      166 
      167 	     oi(j).version_number = object_info_version_2;
      168 
      169 
      170 	     call object_info_$long(p(j),nbits(j),addr(oi(j)),code);
      171 	     if code ^= 0 then call error(sname(j));
      172 
      173 
      174 	end;
      175 
      176 /* Check for consistency of type for the 2 segments */
      177 
      178 	if oi.old_format(1) ^= oi.old_format(2) then call error
      179 		("Cannot compare old format segment with new format segment.");
      180 
      181 	if oi.separate_static(1) ^= oi.separate_static(2)
      182 	     then call error("Cannot compare separate static segment with non separate static segment.");
      183 
      184 	if oi.compiler(1) ^= oi.compiler(2)
      185 	     then call error("The 2 segments were compiled by incompatible compilers.");
      186 
      187 	if oi.relocatable(1) ^= oi.relocatable(2)
      188 	     then call error("Cannot compare relocatable with nonrelocatable object segment.");
      189 
      190 	if oi.perprocess_static(1) ^= oi.perprocess_static(2)
      191 	     then do;
      192 		result.perprocess_static = "1"b;
      193 		if ^brief then call ioa_ ("The 2 segments have different perprocess static attributes.");
      194 	     end;
      195 
      196 
      197 /* Get the parameters */
      198 
      199 	do while (isparm);
      200 		call cu_$arg_ptr(arg_num,aptr,alen,code);
      201 		if code ^= 0 then isparm = "0"b;
      202 		else
      203 		do;
      204 			token=arg;
      205 			do i= 1 to hbound(keyword,1) while(token^=keyword(i));
      206 			end;
      207 			if i <= hbound(keyword,1) then
      208 			do;
      209 				i = mod(i-1,nparm) + 1;
      210 				if i=nparm then string(all)="11111"b;
      211 				else
      212 				do;
      213 					bits(i) = "1"b;
      214 					if i >= 2 then qual = "1"b;
      215 				end;
      216 			end;
      217 			else
      218 			do;
      219 				code = error_table_$badopt;
      220 				call error(token);
      221 			end;
      222 		end;
      223 		arg_num = arg_num + 1;
      224 	end;
      225 	if ^qual then string(all) = "11111"b;
      226 
      227 	if ^oi.separate_static(1)
      228 	then if parm.static
      229 	     then do;
      230 		parm.link = "1"b;
      231 		parm.static = "0"b;
      232 		end;
      233 
      234 /* display information about the segment */
      235 
      236 	if ^brief
      237 	then do j = 1 to 2;
      238 		call ioa_("^/^a:  (segment ^d)",sname(j),j);
      239 		time = date_time_$format ("date_time",oi(j).compile_time,"","");
      240 		call ioa_("^a^4x^a^/",time,oi(j).compiler);
      241 	     end;
      242 
      243 /* Compare lengths returned by object_info_ */
      244 
      245 	if oi.tlng(1) ^= oi.tlng(2) then call badlen("text",oi.tlng);
      246 	if oi.dlng(1) ^= oi.dlng(2) then call badlen("defs",oi.dlng);
      247 	if oi.llng(1) ^= oi.llng(2) then call badlen("link",oi.llng);
      248 	if oi.ilng(1) ^= oi.ilng(2) then call badlen("stat",oi.ilng);
      249 	if oi.slng(1) ^= oi.slng(2) 
      250 	then do;
      251 		call badlen("symb",oi.slng);
      252 		if ^brief & oi.relocatable(1)
      253 		then do;
      254 		     serious = "1"b;
      255 		     if oi.rel_def(1) -> relinfo.n_bits = oi.rel_def(2) -> relinfo.n_bits
      256 		     then if oi.rel_text(1) -> relinfo.n_bits = oi.rel_text(2) -> relinfo.n_bits
      257 			then if oi.rel_link(1) -> relinfo.n_bits = oi.rel_link(2) -> relinfo.n_bits
      258 			     then if oi.rel_link(1) -> relinfo.relbits = oi.rel_link(2) -> relinfo.relbits
      259 				then if oi.rel_text(1) -> relinfo.relbits = oi.rel_text(2) -> relinfo.relbits
      260 				     then serious = "0"b;
      261 		     if serious
      262 			then word = "may be serious";
      263 			else word = "is trivial";
      264 
      265 		     call ioa_("The discrepancy ^a",word);
      266 		     end;
      267 	     end;
      268 
      269 /* Set up scratch segment for relocation bits */
      270 
      271 	call get_temp_segments_(rname,scratch,code);
      272 	if code ^= 0
      273 	     then call error("scratch seg for relocation bits");
      274 
      275 /* DO TEXT COMPARISON */
      276 
      277 	if parm.text then call compare_text_(oip,result.text,parm.brief,segp);
      278 
      279 /* DO DEFS COMPARISON */
      280 
      281 	if parm.defs then call compare_defs_(oip,result.defs,parm.brief,segp);
      282 
      283 /* DO LINK COMPARISON */
      284 
      285 	if parm.link then call compare_link_(oip,result.link,parm.brief,segp);
      286 
      287 /* DO STATIC COMPARISON */
      288 
      289 	if parm.static then call compare_static_(oip,result.static,parm.brief,segp);
      290 
      291 /*  RETURN SECTION */
      292 
      293 
      294 	if command
      295 	then do;
      296 		if string(result) then
      297 		do;
      298 			call ioa_
      299 ("^/The following sections or attributes of the object segments do not match:");
      300 			line = "^/";
      301 			if result.length then line = "length  ";
      302 			if result.perprocess_static then line = line || "perprocess_static ";
      303 			do j = 1 to hbound(rslt,1)-2;
      304 				if rslt(j) then line = line || substr(keyword(j+1),2);
      305 			end;
      306 			call ioa_(line);
      307 		end;
      308 		else call ioa_("The 2 segments match.");
      309 	     end;
      310 
      311 return:	call clean_up;
      312 	if command
      313 	     then return;
      314 	     else return(substr(string(result),1,4) = "0000"b);
      315 
      316 
      317 clean_up:	proc;
      318 
      319 	do j = 1 to 2;
      320 		if p(j) ^= null
      321 		then do;
      322 		     if ^ have_ptrs
      323 		     then do;
      324 			call hcs_$terminate_noname(p(j),code);
      325 			p(j) = null;
      326 			end;
      327 		     end;
      328 	end;
      329 
      330 	call release_temp_segments_(rname,scratch,code);
      331 
      332 end;
      333 
      334 /* ERROR SECTION */
      335 
      336 error:	proc (msg);
      337 dcl	msg char(*);
      338 	if command
      339 	     then call com_err_(code,rname,msg);
      340 	     else string(result) = "1111111"b;
      341 	go to return;
      342 end;
      343 
      344 badlen:	proc (type,array);
      345 dcl	type char(4);
      346 dcl	array(*) fixed bin(17);
      347 	if ^brief then call ioa_("Lengths of the ^a section of the 2 segments do not agree. ^/^a : ^d ^/^a : ^d",
      348 		type,sname(1),array(1),sname(2),array(2));
      349 	result.length = "1"b;
      350 	return;
      351 end;
      352 
      353 end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/15/84  1024.1  compare_object.pl1                >spec>on>6962>compare_object.pl1
72           1    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_path1                                parameter       char                     unaligned dcl 120 ref 118 123
P_path2                                parameter       char                     unaligned dcl 120 ref 118 124
addr                                                   builtin function         dcl 94 ref 134 136 170 170
alen                            000100 automatic       fixed bin(17,0)          dcl 19 set ref 145* 151 200* 204
all                       0(01) 000320 automatic       structure                level 2 packed unaligned dcl 34 set ref 210* 225*
aptr                            000102 automatic       pointer                  dcl 20 set ref 145* 151 200* 204
arg                                    based           char                     unaligned dcl 21 ref 151 204
arg_num                         000104 automatic       fixed bin(17,0)          initial dcl 22 set ref 22* 200* 223* 223
array                                  parameter       fixed bin(17,0)          array dcl 346 set ref 344 347* 347*
bits                                   defined         bit(1)                   array unaligned dcl 67 set ref 213*
brief                           000320 automatic       bit(1)                   initial level 2 packed unaligned dcl 34 set ref 34*
                                                                                  128* 193 236 252 277* 281* 285* 289* 347
cleanup                         001034 stack reference condition                dcl 96 ref 138
code                            000105 automatic       fixed bin(35,0)          dcl 23 set ref 145* 146 153* 154 157* 158 161* 170*
                                                                                  171 200* 201 219* 271* 272 324* 330* 338*
com_err_                        000032 constant        entry                    external dcl 86 ref 338
com_err_$suppress_name          000034 constant        entry                    external dcl 86 ref 147
command                         000106 automatic       bit(1)                   dcl 24 set ref 98* 126* 143 294 312 338
command_error                   000110 stack reference condition                dcl 25 ref 130
compare_defs_                   000042 constant        entry                    external dcl 89 ref 281
compare_link_                   000044 constant        entry                    external dcl 90 ref 285
compare_static_                 000046 constant        entry                    external dcl 91 ref 289
compare_text_                   000040 constant        entry                    external dcl 88 ref 277
compile_time             32     000660 automatic       fixed bin(71,0)          array level 2 dcl 74 set ref 239*
compiler                 30     000660 automatic       char(8)                  array level 2 dcl 74 set ref 184 184 240*
cu_$arg_ptr                     000014 constant        entry                    external dcl 79 ref 145 200
date_time_$format               000012 constant        entry                    external dcl 78 ref 239
defs                      0(01) 000646 automatic       bit(1)                   initial level 2 in structure "result" packed
                                                                                  unaligned dcl 55 in procedure "cob" set ref 55*
                                                                                  281*
defs                      0(02) 000320 automatic       bit(1)                   initial level 3 in structure "parm" packed unaligned
                                                                                  dcl 34 in procedure "cob" set ref 34* 281
divide                                                 builtin function         dcl 94 ref 66
dlng                     17     000660 automatic       fixed bin(17,0)          array level 2 dcl 74 set ref 246 246 246*
dname                           000116 automatic       char(168)                array unaligned dcl 26 set ref 153* 160 161*
ename                           000242 automatic       char(32)                 array unaligned dcl 27 set ref 153* 157* 157 157*
                                                                                  158* 160 161*
error_table_$badopt             000010 external static fixed bin(35,0)          dcl 69 ref 219
expand_pathname_                000016 constant        entry                    external dcl 80 ref 153
format                   24     000660 automatic       structure                array level 2 dcl 74
get_equal_name_                 000020 constant        entry                    external dcl 81 ref 157
get_temp_segments_              000024 constant        entry                    external dcl 84 ref 271
have_ptrs                       000262 automatic       bit(1)                   dcl 28 set ref 99* 109* 122* 141 322
hbound                                                 builtin function         dcl 94 ref 66 205 207 303
hcs_$initiate_count             000022 constant        entry                    external dcl 82 ref 161
hcs_$terminate_noname           000050 constant        entry                    external dcl 92 ref 324
i                               000263 automatic       fixed bin(17,0)          dcl 29 set ref 205* 205* 207 209* 209 210 213 214
ilng                     21     000660 automatic       fixed bin(17,0)          array level 2 dcl 74 set ref 248 248 248*
ioa_                            000036 constant        entry                    external dcl 87 ref 193 238 240 265 298 306 308 347
isparm                          000312 automatic       bit(1)                   initial unaligned dcl 31 set ref 31* 129* 199 201*
j                               000264 automatic       fixed bin(17,0)          dcl 29 set ref 140* 145* 151 153 153 153 154 155 160
                                                                                  160 160 161 161 161 161 162 162 167 170 170 170
                                                                                  170 171* 236* 238 238* 239 240* 303* 304 304* 319*
                                                                                  320 324 325*
keyword                         000004 constant        char(8)                  initial array dcl 64 ref 66 205 205 207 304
len1                                   parameter       fixed bin(24,0)          dcl 104 ref 102 112
len2                                   parameter       fixed bin(24,0)          dcl 104 ref 102 113
length                    0(06) 000646 automatic       bit(1)                   initial level 2 packed unaligned dcl 55 set ref 55*
                                                                                  301 349*
line                            000265 automatic       varying char(80)         dcl 30 set ref 300* 301* 302* 302 304* 304 306*
link                      0(03) 000320 automatic       bit(1)                   initial level 3 in structure "parm" packed unaligned
                                                                                  dcl 34 in procedure "cob" set ref 34* 230* 285
link                      0(02) 000646 automatic       bit(1)                   initial level 2 in structure "result" packed
                                                                                  unaligned dcl 55 in procedure "cob" set ref 55*
                                                                                  285*
llng                     20     000660 automatic       fixed bin(17,0)          array level 2 dcl 74 set ref 247 247 247*
mod                                                    builtin function         dcl 94 ref 209
msg                                    parameter       char                     unaligned dcl 337 set ref 336 338*
n_bits                    1            based           fixed bin(17,0)          level 2 dcl 44 ref 255 255 255 255 255 255 255 255
                                                                                  255 255
nbits                           000314 automatic       fixed bin(24,0)          array dcl 32 set ref 112* 113* 161* 170*
nparm                           000647 automatic       fixed bin(17,0)          initial dcl 66 set ref 66* 209 210
null                                                   builtin function         dcl 94 ref 51 51 51 51 162 320 325
object_info                            based           structure                level 1 dcl 1-6
object_info_$long               000030 constant        entry                    external dcl 85 ref 170
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 1-60 ref 167
oi                              000660 automatic       structure                array level 1 dcl 74 set ref 134 170 170
oip                             000316 automatic       pointer                  dcl 33 set ref 134* 277* 281* 285* 289*
old_format               24     000660 automatic       bit(1)                   array level 3 packed unaligned dcl 74 set ref 178
                                                                                  178
p                               000472 automatic       pointer                  initial array level 2 dcl 51 set ref 51* 51* 110*
                                                                                  111* 161* 162 170* 320 324* 325*
parm                            000320 automatic       structure                level 1 packed unaligned dcl 34 set ref 213* 213
path                            000321 automatic       char(168)                array unaligned dcl 42 set ref 123* 124* 151* 153*
                                                                                  154*
perprocess_static         0(05) 000646 automatic       bit(1)                   initial level 2 in structure "result" packed
                                                                                  unaligned dcl 55 in procedure "cob" set ref 55*
                                                                                  192* 302
perprocess_static        24(08) 000660 automatic       bit(1)                   array level 3 in structure "oi" packed unaligned
                                                                                  dcl 74 in procedure "cob" set ref 190 190
ptr1                                   parameter       pointer                  dcl 104 ref 102 110
ptr2                                   parameter       pointer                  dcl 104 ref 102 111
qual                            000445 automatic       bit(1)                   initial unaligned dcl 43 set ref 43* 214* 225
rel_def                  52     000660 automatic       pointer                  array level 2 dcl 74 set ref 255 255
rel_link                 54     000660 automatic       pointer                  array level 2 dcl 74 set ref 255 255 255 255
rel_text                 50     000660 automatic       pointer                  array level 2 dcl 74 set ref 255 255 255 255
relbits                   2            based           bit                      level 2 dcl 44 ref 255 255 255 255
release_temp_segments_          000026 constant        entry                    external dcl 84 ref 330
relinfo                                based           structure                level 1 dcl 44
relocatable              24(02) 000660 automatic       bit(1)                   array level 3 packed unaligned dcl 74 set ref 187
                                                                                  187 252
result                          000646 automatic       structure                level 1 packed unaligned dcl 55 set ref 130* 296 303
                                                                                  303 304 304 314 340*
rname                           000000 constant        char(14)                 initial unaligned dcl 70 set ref 271* 330* 338*
rslt                                   defined         bit(1)                   array unaligned dcl 63 ref 303 304
rtrim                                                  builtin function         dcl 94 ref 160
scratch                   4     000472 automatic       pointer                  initial array level 2 dcl 51 set ref 51* 51* 271*
                                                                                  330*
seg                             000472 automatic       structure                level 1 unaligned dcl 51 set ref 136
segp                            000470 automatic       pointer                  dcl 50 set ref 136* 277* 281* 285* 289*
separate_static          24(06) 000660 automatic       bit(1)                   array level 3 packed unaligned dcl 74 set ref 181
                                                                                  181 227
serious                         000446 automatic       bit(1)                   dcl 48 set ref 254* 255* 261
slng                     22     000660 automatic       fixed bin(17,0)          array level 2 dcl 74 set ref 249 249 251*
sname                    10     000472 automatic       char(200)                array level 2 packed unaligned dcl 51 set ref 114*
                                                                                  115* 160* 162* 171* 238* 347* 347*
static                    0(04) 000320 automatic       bit(1)                   initial level 3 in structure "parm" packed unaligned
                                                                                  dcl 34 in procedure "cob" set ref 34* 227 231* 289
static                    0(03) 000646 automatic       bit(1)                   initial level 2 in structure "result" packed
                                                                                  unaligned dcl 55 in procedure "cob" set ref 55*
                                                                                  289*
string                                                 builtin function         dcl 94 set ref 130* 210* 225* 296 314 340*
substr                                                 builtin function         dcl 94 ref 304 314
symbol                    0(05) 000320 automatic       bit(1)                   initial level 3 in structure "parm" packed unaligned
                                                                                  dcl 34 in procedure "cob" set ref 34*
symbol                    0(04) 000646 automatic       bit(1)                   initial level 2 in structure "result" packed
                                                                                  unaligned dcl 55 in procedure "cob" set ref 55*
text                            000646 automatic       bit(1)                   initial level 2 in structure "result" packed
                                                                                  unaligned dcl 55 in procedure "cob" set ref 55*
                                                                                  277*
text                      0(01) 000320 automatic       bit(1)                   initial level 3 in structure "parm" packed unaligned
                                                                                  dcl 34 in procedure "cob" set ref 34* 277
time                            000447 automatic       varying char(64)         dcl 49 set ref 239* 240*
tlng                     16     000660 automatic       fixed bin(17,0)          array level 2 dcl 74 set ref 245 245 245*
token                           000650 automatic       char(8)                  unaligned dcl 68 set ref 204* 205 220*
type                                   parameter       char(4)                  unaligned dcl 345 set ref 344 347*
version_number                  000660 automatic       fixed bin(17,0)          array level 2 dcl 74 set ref 167*
word                            000652 automatic       varying char(14)         dcl 71 set ref 261* 263* 265*

NAMES DECLARED BY EXPLICIT CONTEXT.
badlen                          002616 constant        entry                    internal dcl 344 ref 245 246 247 248 251
clean_up                        002463 constant        entry                    internal dcl 317 ref 138 311
cob                             000527 constant        entry                    external dcl 18
compare_object                  000541 constant        entry                    external dcl 18
compare_object_                 000624 constant        entry                    external dcl 118
compare_object_$ptr             000562 constant        entry                    external dcl 102
error                           002554 constant        entry                    internal dcl 336 ref 154 158 162 171 178 181 184 187
                                                                                  220 272
join                            000713 constant        label                    dcl 134 ref 100
not_command                     000665 constant        label                    dcl 126 ref 116
return                          002431 constant        label                    dcl 311 ref 341

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3350        3422    3052        3360
Length      3662    3052        52         224     276           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cob                                 792 external procedure  is an external procedure.  
on unit on line 130                  64 on unit               
on unit on line 138                  64 on unit               
clean_up                             86 internal procedure  is called by several nonquick procedures.  
error                                   internal procedure  shares stack frame of external procedure cob.  
badlen                                  internal procedure  shares stack frame of external procedure cob.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cob                      000100 alen                        cob
                         000102 aptr                        cob
                         000104 arg_num                     cob
                         000105 code                        cob
                         000106 command                     cob
                         000116 dname                       cob
                         000242 ename                       cob
                         000262 have_ptrs                   cob
                         000263 i                           cob
                         000264 j                           cob
                         000265 line                        cob
                         000312 isparm                      cob
                         000314 nbits                       cob
                         000316 oip                         cob
                         000320 parm                        cob
                         000321 path                        cob
                         000445 qual                        cob
                         000446 serious                     cob
                         000447 time                        cob
                         000470 segp                        cob
                         000472 seg                         cob
                         000646 result                      cob
                         000647 nparm                       cob
                         000650 token                       cob
                         000652 word                        cob
                         000660 oi                          cob

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return              mod_fx1             signal              enable              shorten_stack
ext_entry           ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      com_err_$suppress_name        compare_defs_                 compare_link_
compare_static_               compare_text_                 cu_$arg_ptr                   date_time_$format
expand_pathname_              get_equal_name_               get_temp_segments_            hcs_$initiate_count
hcs_$terminate_noname         ioa_                          object_info_$long             release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     22 000430        31 000432        34 000434        43 000450        51 000451        55 000503        66 000521
     18 000526        98 000551        99 000553       100 000554       102 000555       109 000574       110 000576
    111 000602       112 000605       113 000607       114 000611       115 000614       116 000617       118 000620
    122 000651       123 000652       124 000660       126 000665       128 000666       129 000670       130 000671
    134 000713       136 000715       138 000717       140 000741       141 000747       143 000751       145 000753
    146 000770       147 000772       149 001025       151 001034       153 001044       154 001075       155 001111
    157 001114       158 001143       160 001150       161 001227       162 001277       167 001317       170 001324
    171 001346       174 001362       178 001364       181 001401       184 001420       187 001431       190 001450
    192 001461       193 001463       199 001502       200 001504       201 001521       204 001525       205 001532
    206 001546       207 001550       209 001553       210 001560       213 001565       214 001570       216 001574
    219 001575       220 001600       223 001603       224 001604       225 001605       227 001611       230 001617
    231 001621       236 001623       238 001633       239 001661       240 001727       241 001757       245 001761
    246 001771       247 002001       248 002011       249 002021       251 002024       252 002031       254 002037
    255 002041       261 002074       263 002104       265 002111       271 002134       272 002155       277 002165
    281 002205       285 002227       289 002251       294 002273       296 002275       298 002300       300 002314
    301 002320       302 002327       303 002344       304 002353       305 002376       306 002400       307 002411
    308 002412       311 002431       312 002435       314 002446       317 002462       319 002470       320 002500
    322 002506       324 002510       325 002522       328 002530       330 002532       332 002553       336 002554
    338 002565       340 002613       341 002615       344 002616       347 002622       349 002702       350 002704


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
