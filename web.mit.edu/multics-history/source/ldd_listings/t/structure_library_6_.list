	COMPILATION LISTING OF SEGMENT !BBBJWhKzLfGMGZ
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 08/04/87  1334.7 mst Tue
	    Options: table map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*   *                                                         *
        5*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 
       10 
       11 /* HISTORY COMMENTS:
       12*  1) change(87-06-10,GDixon), approve(87-07-10,MCR7681),
       13*     audit(87-07-10,Parisek), install(87-08-04,MR12.1-1055):
       14*     Added cpm_ data.
       15*                                                   END HISTORY COMMENTS */
       16 
       17 
       18 /* format: off */
       19 
       20 /* Created:  March 1985 by G. Palter to hold new structure that would not
       21*      fit into the other structure_library_N_ modules */
       22 
       23 structure_library_6_:
       24      procedure ();
       25 
       26 /* First come all the structures */
       27 
       28 begin; /* to avoid possible conflicts */
       29    /* BEGIN INCLUDE FILE ... cpm_control_point_data.incl.pl1 */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  1     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  1     6*     Written to support control point management in March 1985 by G. Palter.
  1     7*                                                   END HISTORY COMMENTS */
  1     8 
  1     9 /* format: style3,linecom,idind22 */
  1    10 
  1    11 /* NOTE: This include file references structures contained in the following independent include files --
  1    12*	cpm_ctrl_pt_meters.incl.pl1		process_usage.incl.pl1	*/
  1    13 
  1    14 
  1    15 /* Definition of a single control point in the process */
  1    16 
  1    17 dcl	1 control_point_data  aligned based (cpd_ptr),
  1    18 	  2 id		  bit (36) aligned,		/* unique ID of this control point */
  1    19 	  2 group_id	  bit (36) aligned,		/* unique ID of containing group of control points */
  1    20 	  2 state		  fixed binary,		/* scheduling state (see below) */
  1    21 	  2 flags,
  1    22 	    3 preferred	  bit (1) unaligned,	/* ON => this is the preferred task (infinite priority) */
  1    23 	    3 swapped_switches			/* ON => this control point's switches were swapped ... */
  1    24 			  bit (1) unaligned,	/* ... with the root's during an unclaimed signal */
  1    25 	    3 pad		  bit (34) unaligned,
  1    26 	  2 priority	  fixed binary,		/* scheduling priority */
  1    27 	  2 pad		  bit (36) aligned,
  1    28 	  2 stack_ptr	  pointer,		/* -> the stack used by this control point */
  1    29 	  2 last_frame_ptr	  pointer,		/* -> last frame in said stack where control is to resume */
  1    30 	  2 destroy	  label,			/* transferring to this label will kill the control point */
  1    31 	  2 parent	  pointer,		/* -> defintion of this control point's parent */
  1    32 	  2 peers,				/* linked list of this control point's peers */
  1    33 	    3 prev_peer	  pointer,
  1    34 	    3 next_peer	  pointer,
  1    35 	  2 children,				/* linked list of this control point's children */
  1    36 	    3 first_child	  pointer,
  1    37 	    3 last_child	  pointer,
  1    38 	  2 ready_queue,				/* ordered list of control points in the ready state */
  1    39 	    3 prev_ready	  pointer,
  1    40 	    3 next_ready	  pointer,
  1    41 	  2 user_cl_intermediary			/* procedure to be called by cpm_overseer_$cl_intermediary */
  1    42 			  entry (bit (1) aligned),
  1    43 	  2 comment	  character (64),		/* a description of this control point */
  1    44 	  2 saved_environment,			/* data saved when the control point stops running ... */
  1    45 	    3 ips_mask	  bit (36) aligned,		/* ... IPS mask when it stopped running */
  1    46 	    3 privileges	  bit (36) aligned,		/* ... system privileges */
  1    47 	    3 cl_intermediary entry (bit (36) aligned),	/* ... CL intermediary */
  1    48 	    3 io_switches,				/* ... standard I/O switches */
  1    49 	      4 user_io	  pointer,
  1    50 	      4 user_input	  pointer,
  1    51 	      4 user_output	  pointer,
  1    52 	      4 error_output  pointer,
  1    53 	  2 meters	  like control_point_meters;	/* per control point metering data */
  1    54 
  1    55 dcl	cpd_ptr		  pointer;
  1    56 
  1    57 
  1    58 /* Scheduler states for a control point */
  1    59 
  1    60 dcl	(
  1    61 	CPM_DESTROYED	  initial (0),		/* waiting to be deleted */
  1    62 	CPM_STOPPED	  initial (1),		/* can not run without an explicit cpm_$start */
  1    63 	CPM_BLOCKED	  initial (2),		/* blocked on an IPC event channel */
  1    64 	CPM_READY		  initial (3)		/* eligible to run on next call to cpm_$scheduler */
  1    65 	)		  fixed binary static options (constant);
  1    66 
  1    67 /* END INCLUDE FILE ... cpm_control_point_data.incl.pl1 */
       29 
       30    /* BEGIN INCLUDE FILE ... cpm_ctrl_pt_meters.incl.pl1 */
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  2     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  2     6*     Written to support control point management in March 1985 by G. Palter.
  2     7*                                                   END HISTORY COMMENTS */
  2     8 
  2     9 /* format: style3,linecom */
  2    10 
  2    11 /* NOTE: The include file references structures contained in the following independent include file --
  2    12*	process_usage.incl.pl1	*/
  2    13 
  2    14 
  2    15 /* Definition of control point metering data -- A set of metering data is kept independently for each control point which
  2    16*   provides usage statistics for that control point.  In addition, another set of metering data is kept to record the
  2    17*   overhead involved in the control point scheduler */
  2    18 
  2    19 dcl	1 control_point_meters
  2    20 			aligned based (cpm_ptr),
  2    21 	  2 n_schedules	fixed binary,		/* # of times the control point has been run or
  2    22*						   # of times the scheduler has been invoked */
  2    23 	  2 pad		fixed binary,
  2    24 	  2 real_time	fixed binary (71),		/* ... real time used by the control point or scheduler */
  2    25 	  2 usage		like process_usage;		/* ... CPU, memory, etc. */
  2    26 
  2    27 dcl	cpm_ptr		pointer;
  2    28 
  2    29 
  2    30 /* Definition of the structure used in calls to cpm_$get_control_point_meters and cpm_$get_scheduler_meters */
  2    31 
  2    32 dcl	1 control_point_meters_argument
  2    33 			aligned based (cpma_ptr),
  2    34 	  2 version	character (8) unaligned,
  2    35 	  2 meters	like control_point_meters;
  2    36 
  2    37 dcl	CONTROL_POINT_METERS_ARGUMENT_VERSION_1
  2    38 			character (8) static options (constant) initial ("cpma_001");
  2    39 
  2    40 dcl	MAX_NUMBER_OF_METERS
  2    41 			fixed bin internal static options (constant) init (9);
  2    42 
  2    43 dcl	cpma_ptr		pointer;
  2    44 
  2    45 /* END INCLUDE FILE ... cpm_ctrl_pt_meters.incl.pl1 */
       30 
       31    /* BEGIN INCLUDE FILE process_usage.incl.pl1 WRITTEN 09/17/76 BY Richard Bratt */
  3     2 
  3     3 declare
  3     4          process_usage_pointer pointer,
  3     5          1 process_usage based (process_usage_pointer),
  3     6          2 number_wanted fixed bin,			/* max number of entries to be returned */
  3     7          2 number_can_return fixed bin,			/* the number of entries currently returnable */
  3     8          2 cpu_time fixed bin (71),
  3     9          2 paging_measure fixed bin (71),
  3    10          2 page_faults fixed bin (34),
  3    11          2 pd_faults fixed bin (34),
  3    12          2 virtual_cpu_time fixed bin (71),
  3    13          2 segment_faults fixed bin (34),
  3    14          2 bounds_faults fixed bin (34),
  3    15          2 vtoc_reads fixed bin (34),
  3    16          2 vtoc_writes fixed bin (34);
  3    17 
  3    18 /* END INCLUDE FILE process_usage.incl.pl1      */
       31 
       32       call add ("control_point_data", addr (p -> control_point_data));
       33    end;
       34 
  4     1 /*  BEGIN  Mailbox Message Include File  (mail_format.incl.pl1) */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-01-09,Herbst), approve(86-03-25,MCR7367),
  4     6*     audit(86-04-28,Margolin), install(86-05-22,MR12.0-1059):
  4     7*     Added "seen" switch.
  4     8*  2) change(86-06-02,Herbst), approve(86-06-02,MCR7367), audit(86-06-30,Wong),
  4     9*     install(86-06-30,MR12.0-1080):
  4    10*     Updated to version 4 for seen switch.
  4    11*                                                   END HISTORY COMMENTS */
  4    12 
  4    13 /*  Last modified by K. T. Pogran, 3/6/75  */
  4    14 /*  Modified by D. M. Wells, August 10, 1977 for v4 message segments. */
  4    15 /* Modified: 3 June 1981 by G. Palter for mail system subroutine interface */
  4    16 
  4    17 declare	mail_format_ptr pointer aligned;
  4    18 
  4    19 declare   MAIL_FORMAT_VERSION_4 initial (4)
  4    20                fixed bin internal static options (constant);
  4    21 
  4    22 declare	text_length fixed bin (21);
  4    23 
  4    24 declare	1 mail_format aligned based (mail_format_ptr),
  4    25 	  2 header,
  4    26 	    3 version	fixed bin (17),
  4    27 	    3 sent_from	char (32) aligned,
  4    28 	    3 lines	fixed bin (17),
  4    29 	    3 text_len	fixed bin (21),
  4    30 	    3 switches aligned,
  4    31 	      4 wakeup	bit (1) unaligned,
  4    32 	      4 urgent	bit (1) unaligned,
  4    33 	      4 notify      bit (1) unaligned,
  4    34 	      4 acknowledge	bit (1) unaligned,
  4    35 	      4 obsolete	bit (1) unaligned,
  4    36 	      4 canonical	bit (1) unaligned,
  4    37 	      4 seen	bit (1) unaligned,
  4    38 	      4 others	bit (65) unaligned,
  4    39 	  2 text char(text_length refer (mail_format.header.text_len)) aligned;
  4    40 
  4    41 /*  END  Mailbox Message Include File  (mail_format.incl.pl1) */
       35 
       36    text_length = 0; /* avoid WARNING 307 */
       37    call add ("mail_format", addr (p -> mail_format));
       38 
  5     1 /* BEGIN INCLUDE FILE ... mseg_message.incl.pl1 */
  5     2 /* Created:  April 1985 by G. Palter from ms_block_hdr.incl.pl1 and ms_block_trailer.incl.pl1 */
  5     3 
  5     4 /* format: style3,linecom */
  5     5 
  5     6 /* NOTE: This include file references components of the mseg_segment structure which is defined separately in
  5     7*   mseg_segment.incl.pl1.  Programs which use this include file must also include mseg_segment.incl.pl1 to prevent
  5     8*   compilation errors. */
  5     9 
  5    10 
  5    11 /* Definition of the structure of a message stored in a message segment --
  5    12*
  5    13*   When a message is added to a message segment, it is split into one or more fixed sized blocks.  These blocks are then
  5    14*   allocated in the blocks space of the message segment.  (See mseg_message.incl.pl1 and mseg_message_.pl1 for more
  5    15*   information).  Each block includes a header which records where the next block of the message, if any, resides and how
  5    16*   many bits of data is actually recorded in the block.
  5    17*
  5    18*   In addition, the first block allocated for a message always includes a message descriptor.  This descriptor includes
  5    19*   various pieces of information about the message such as its total length, access class, author, etc. */
  5    20 
  5    21 
  5    22 /* Definition of the header found in all message blocks */
  5    23 
  5    24 declare	1 message_block_header
  5    25 			aligned based (mb_ptr),
  5    26 	  2 next_block	fixed binary (18) unaligned unsigned,
  5    27 	  2 descriptor_present			/* ON => a descriptor is in the last 22 words of the block */
  5    28 			bit (1) unaligned,
  5    29 	  2 data_lth				/* ... in bits */
  5    30 			fixed binary (17) unaligned unsigned;
  5    31 
  5    32 declare	mb_ptr		pointer;
  5    33 
  5    34 
  5    35 /* Definition of the descriptor for a message recorded in the first block of the message */
  5    36 
  5    37 declare	1 message_descriptor
  5    38 			aligned based (md_ptr),
  5    39 	  2 sentinel	bit (36) aligned,		/* proves that this is a message descriptor */
  5    40 	  2 message_chain,				/* the chronological chain of messages in the segment */
  5    41 	    3 next_message	fixed binary (18) unaligned unsigned,
  5    42 	    3 prev_message	fixed binary (18) unaligned unsigned,
  5    43 	  2 sender_level	fixed binary (3) unaligned unsigned,
  5    44 	  2 pad1		bit (5) unaligned,
  5    45 	  2 prev_message_in_hash_chain
  5    46 			fixed binary (18) unaligned unsigned,
  5    47 	  2 pad2		bit (10) unaligned,
  5    48 	  2 ms_id		bit (72) aligned,
  5    49 	  2 ms_len	fixed binary (24) unaligned unsigned,
  5    50 	  2 pad3		bit (12) unaligned,
  5    51 	  2 sender_id	char (32) aligned,
  5    52 	  2 sender_authorization
  5    53 			bit (72) aligned,
  5    54 	  2 ms_access_class bit (72) aligned,
  5    55 	  2 sender_max_authorization
  5    56 			bit (72) aligned,
  5    57 	  2 sender_process_id
  5    58 			bit (36) aligned,
  5    59 	  2 sender_audit	bit (36) aligned;
  5    60 
  5    61 declare	md_ptr		pointer;
  5    62 
  5    63 declare	MESSAGE_DESCRIPTOR_SENTINEL
  5    64 			bit (36) aligned static options (constant) initial ("777777777777"b3);
  5    65 
  5    66 
  5    67 /* Definition of the first block allocated for a message in a message segment */
  5    68 
  5    69 declare	1 first_message_block
  5    70 			aligned based (mb_ptr),
  5    71 	  2 header	aligned like message_block_header,
  5    72 	  2 data_space,
  5    73 	    3 data	bit (0 refer (first_message_block.data_lth)) unaligned,
  5    74 	    3 pad		bit (36
  5    75 			* (mseg_segment.block_size - currentsize (message_block_header)
  5    76 			- currentsize (message_descriptor)) - first_message_block.data_lth) unaligned,
  5    77 	  2 descriptor	aligned like message_descriptor;
  5    78 
  5    79 
  5    80 /* Definition of all but the first block allocated for a message in a message segment */
  5    81 
  5    82 declare	1 other_message_block
  5    83 			aligned based (mb_ptr),
  5    84 	  2 header	aligned like message_block_header,
  5    85 	  2 data_space,
  5    86 	    3 data	bit (0 refer (other_message_block.data_lth)) unaligned,
  5    87 	    3 pad		bit (36 * (mseg_segment.block_size - currentsize (message_block_header))
  5    88 			- other_message_block.data_lth) unaligned;
  5    89 
  5    90 /* END INCLUDE FILE ... mseg_message.incl.pl1 */
       39 
       40    call add ("message_block_header", addr (p -> message_block_header));
       41    call add ("message_descriptor", addr (p -> message_descriptor));
       42    call add ("first_message_block", addr (p -> first_message_block));
       43    call add ("other_message_block", addr (p -> other_message_block));
       44 
  6     1 /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  6     2 /* format: style3,idind30 */
  6     3 
  6     4 /* structure returned when message is read from a message segment */
  6     5 
  6     6 
  6     7 dcl	mseg_message_info_ptr	pointer;
  6     8 
  6     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  6    10 	  2 version		char (8) aligned,
  6    11 	  2 message_code		fixed bin,
  6    12 	  2 control_flags		unaligned,
  6    13 	    3 own			bit (1),
  6    14 	    3 delete		bit (1),
  6    15 	    3 pad			bit (34),
  6    16 	  2 ms_ptr		ptr,		/* pointer to message */
  6    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  6    18 	  2 ms_id			bit (72),		/* unique ID of message */
  6    19 						/* input in some cases */
  6    20 	  2 ms_access_class		bit (72),		/* message access class */
  6    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  6    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  6    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  6    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  6    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  6    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  6    27 
  6    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  6    29 
  6    30 declare	(
  6    31 	MSEG_READ_FIRST		init (1),
  6    32 	MSEG_READ_LAST		init (2),
  6    33 	MSEG_READ_SPECIFIED		init (3),
  6    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  6    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  6    36 	fixed bin int static options (constant);
  6    37 
  6    38 declare  (MSEG_READ_OWN		init ("1"b),
  6    39 	MSEG_READ_DELETE		init ("01"b)
  6    40 	)			bit (36) aligned internal static options (constant);
  6    41 
  6    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
       45 
       46    call add ("mseg_message_info", addr (p -> mseg_message_info));
       47 
  7     1 /* BEGIN INCLUDE FILE . . . mseg_return_args.incl.pl1 */
  7     2 
  7     3 
  7     4 /* structure returned when message is read from a message segment */
  7     5 
  7     6 
  7     7 dcl  ms_arg_ptr ptr;
  7     8 
  7     9 dcl 1 mseg_return_args based (ms_arg_ptr) aligned,
  7    10     2 ms_ptr ptr,					/* pointer to message */
  7    11     2 ms_len fixed bin (24),				/* length of message  in bits */
  7    12     2 sender_id char (32) unaligned,				/* process-group ID of sender */
  7    13     2 level fixed bin,				/* validation level of sender */
  7    14     2 ms_id bit (72),				/* unique ID of message */
  7    15     2 sender_authorization bit (72),			/* access authorization of message sender */
  7    16     2 access_class bit (72);				/* message access class */
  7    17 
  7    18 
  7    19 /* END INCLUDE FILE . . . mseg_return_args.incl.pl1 */
       48 
       49    call add ("mseg_return_args", addr (p -> mseg_return_args));
       50 
  8     1 /* BEGIN INCLUDE FILE ... mseg_segment.incl.pl1 */
  8     2 /* Created:  April 1985 by G. Palter from msg_hdr.incl.pl1 */
  8     3 
  8     4 /* format: style3,linecom */
  8     5 
  8     6 /* NOTE: This include file references the mseg_wakeup_state structure which is defined separately in
  8     7*   mseg_wakeup_state.incl.pl1.  Programs which use this include file must also include mseg_wakeup_state.incl.pl1 to
  8     8*   prevent compilation errors. */
  8     9 
  8    10 
  8    11 /* Definition of the structure of a message segment --
  8    12*
  8    13*   A message segment is composed of three sections -- the header, the block map, and the blocks space.
  8    14*
  8    15*   In addition to the message ID hash table and the head&tail of the chronological message chain, the message header also
  8    16*   contains the state of wakeup acceptance for this segment.  In order to maintain compatibility with early version 5
  8    17*   message segments, the wakeup state is maintained in a 64 word area of the header which had been known as the "header
  8    18*   message".  See mseg_wakeup_state.incl.pl1 for additional information.
  8    19*
  8    20*   The entire message segment, including the header and block map, is treated as an array of fixed size blocks.  The block
  8    21*   map contains a bit for each block in the message which indicates whether that block is in use.  (The blocks which
  8    22*   overlay the header and block map are always marked as being in use).  The size of the block map is based on the
  8    23*   maxlength of the message segment in order to provide more free space in very small message segments.
  8    24*
  8    25*   When a message is added to a message segment, its content is split into blocks which are allocated in the blocks space.
  8    26*   The blocks space starts with the first block after the block map and occupies the remainder of the segment. */
  8    27 
  8    28 declare	1 mseg_segment	aligned based (mseg_ptr),
  8    29 	  2 header	aligned,
  8    30 	    3 lock	bit (36) aligned,
  8    31 	    3 sentinel	bit (36) aligned,		/* proves that this segment is a message segment */
  8    32 	    3 reserved	bit (72) aligned,		/* ... for compatibility with early version 5 segments */
  8    33 	    3 date_time_last_salvaged
  8    34 			fixed binary (71),
  8    35 	    3 pad		(2) bit (36) aligned,
  8    36 	    3 message_chain,			/* the chronological chain of messages in the segment ... */
  8    37 	      4 first_message			/* ... the first (oldest) message */
  8    38 			fixed binary (18) unaligned unsigned,
  8    39 	      4 pad1	bit (18) unaligned,
  8    40 	      4 last_message			/* ... the last (youngest) message */
  8    41 			fixed binary (18) unaligned unsigned,
  8    42 	      4 pad2	bit (18) unaligned,
  8    43 	    3 n_blocks_allocated			/* total # of blocks available in this message segment ... */
  8    44 			fixed binary (18),		/* ... including space occupied by the header and block map */
  8    45 	    3 n_blocks_unused
  8    46 			fixed binary (18),
  8    47 	    3 n_messages	fixed binary (18),
  8    48 	    3 block_size	fixed binary,		/* ... in words */
  8    49 	    3 flags,
  8    50 	      4 modification_in_progress
  8    51 			bit (1) unaligned,
  8    52 	      4 salvaged	bit (1) unaligned,		/* ON => the message segment had been salvaged earlier */
  8    53 	      4 wakeup_state_set
  8    54 			bit (1) unaligned,
  8    55 	      4 salvage_in_progress
  8    56 			bit (1) unaligned,
  8    57 	      4 pad	bit (32) unaligned,
  8    58 	    3 version	fixed binary,
  8    59 	    3 wakeup_state	aligned,
  8    60 	      4 state	aligned like mseg_wakeup_state,
  8    61 	      4 pad	(64 - 10) bit (36) aligned,	/* ... for compatibility with early version 5 segments */
  8    62 	    3 hash_table	aligned,			/* ... based on the low order 9 bits of the message ID */
  8    63 	      4 last_message
  8    64 			(0:511) fixed binary (18) unaligned unsigned,
  8    65 	  2 block_map	aligned,			/* ON => the block is in use */
  8    66 	    3 map		bit (0 refer (mseg_segment.n_blocks_allocated)) unaligned;
  8    67 
  8    68 declare	mseg_ptr		pointer;
  8    69 
  8    70 declare	MSEG_SEGMENT_VERSION_5			/* presently supported version */
  8    71 			fixed binary static options (constant) initial (5);
  8    72 
  8    73 declare	MSEG_SEGMENT_SENTINEL
  8    74 			bit (36) aligned static options (constant) initial ("252525252525"b3);
  8    75 
  8    76 
  8    77 /* Redefinitions required to access the wakeup_state of the segment in early version 5 message segments */
  8    78 
  8    79 declare	header_msg_access_class
  8    80 			bit (72) aligned defined (mseg_segment.reserved);
  8    81 
  8    82 declare	header_msg_present	bit (1) unaligned defined (mseg_segment.wakeup_state_set);
  8    83 
  8    84 declare	header_msg	(64) bit (36) aligned based (addr (mseg_segment.wakeup_state));
  8    85 
  8    86 /* END INCLUDE FILE ... mseg_segment.incl.pl1 */
       51 
  9     1 /* BEGIN INCLUDE FILE ... mseg_wakeup_state.incl.pl1 */
  9     2 /* Created:  April 1985 by G. Palter */
  9     3 
  9     4 /* format: style3,linecom */
  9     5 
  9     6 /* Description of the wakeup state of a message segment --
  9     7*
  9     8*   The wakeup state defines which process, if any, is willing to receive normal or urgent IPC wakeups when a message which
  9     9*   requests such a wakeup is added to a message segment.  The process is allowed to separately accept or defer normal and
  9    10*   urgent wakeups.  Note that deferring a wakeup is not the same as not accepting wakeups.  A process is not allowed to
  9    11*   stop accepting wakeups once it has accepted them as to do so would introduce a relatively high badnwidth covert
  9    12*   channel.  (In the present implementation, urgent wakeups are really no different from normal wakeups.  Eventually,
  9    13*   urgent wakeups should be implemented using an IPS signal along with the IPC wakeup).
  9    14*
  9    15*   mseg_$get_wakeup_state_seg requires that the caller supply the proper value for mseg_wakeup_state.version in the
  9    16*   mseg_operation.  If there is no wakeup state recorded in the message segment, mseg_$get_wakeup_state_seg will return
  9    17*   the status code error_table_$messages_off.
  9    18*
  9    19*   mseg_$set_wakeup_state_seg ignores the values of the access_class, process_id, and lock_id elements supplied by the
  9    20*   caller in the mseg_operation.  mseg_$set_wakeup_state_seg will, instead, furnish the values of the process making the
  9    21*   call for these elements and will return these values to its caller.  In other words, mseg_$set_wakeup_state_seg can not
  9    22*   be used by one process to accept/defer wakeups on behalf of another process. */
  9    23 
  9    24 declare	1 mseg_wakeup_state aligned based (mseg_wakeup_state_ptr),
  9    25 	  2 version	character (8) unaligned,
  9    26 	  2 flags		aligned,
  9    27 	    3 accepting_normal_wakeups		/* ON => process has accepted normal wakeups */
  9    28 			bit (1) unaligned,		/* OFF => process has deferred normal wakeups */
  9    29 	    3 accepting_urgent_wakeups		/* ON => process has accepted urgent wakeups */
  9    30 			bit (1) unaligned,		/* OFF => process has deferred urgent wakeups */
  9    31 	    3 pad		bit (34) unaligned,
  9    32 	  2 pad		bit (36) aligned,
  9    33 	  2 event_channel	fixed binary (71),		/* IPC event channel on which to send normal/urgent wakeups */
  9    34 	  2 access_class	bit (72) aligned,		/* AIM access class of the process accepting wakeups */
  9    35 	  2 process_id	bit (36) aligned,		/* ID of the process accepting wakeups */
  9    36 	  2 lock_id	bit (36) aligned;		/* lock ID used to test if said process is still alive */
  9    37 
  9    38 declare	mseg_wakeup_state_ptr
  9    39 			pointer;
  9    40 
  9    41 declare	MSEG_WAKEUP_STATE_VERSION_1
  9    42 			character (8) static options (constant) initial ("msegwkp1");
  9    43 
  9    44 /* END INCLUDE FILE ... mseg_wakeup_state.incl.pl1 */
       52 
       53    call add ("mseg_segment", addr (p -> mseg_segment));
       54 
 10     1 /* BEGIN INCLUDE FILE ... _ssu_sci.incl.pl1 */
 10     2 /* Created:  31 April 1980 by W. Olin Sibert */
 10     3 /* Modified: 17 November 1981 by Jay Pattin to add info_prefix */
 10     4 /* Modified: 10 December 1981 by G. Palter to make arg_count, arg_ptr, return_arg, and arg_list_ptr replaceable */
 10     5 /* Modified: 10 February 1982 by G. Palter to reorganize and make changes required for installation */
 10     6 /* Modified: June 1982 by G. Palter for version 2 (new request processor options and replaceable procedures) */
 10     7 /* Modified: 6 November 1984 by G. Palter for version 3 (get_subsystem_and_request_name is now replaceable) */
 10     8 
 10     9 /* format: style4,^delnl */
 10    10 
 10    11 
 10    12 /* Structure used internally by subsystem utilities to contain control information about a single invocation */
 10    13 
 10    14 dcl  1 sci aligned based (sci_ptr),
 10    15        2 version character (8),
 10    16        2 parent_area_ptr pointer,			/* -> area holding this data and referenced structures */
 10    17 
 10    18        2 global_info,				/* global information about this subsystem ... */
 10    19          3 subsystem_name char (32) unaligned,		/* ... its name (eg: read_mail) */
 10    20          3 subsystem_version char (32) unaligned,		/* ... its version numer (eg: 4.3j) */
 10    21          3 info_ptr pointer,				/* ... -> data maintained by the subsystem */
 10    22          3 standalone_abort_entry entry () variable,	/* ... for standalone invocations: called by ssu_$abort_* */
 10    23          3 flags,
 10    24 	 4 standalone_invocation bit (1) unaligned,	/* ... ON => ssu_$standalone_invocation was used */
 10    25 	 4 in_listener bit (1) unaligned,		/* ... ON => in subsystem listener loop */
 10    26 	 4 executing_request bit (1) unaligned,		/* ... ON => executing a request */
 10    27 	 4 debug_mode bit (1) unaligned,		/* ... ON => debugging the subsystem */
 10    28 	 4 pad bit (32) unaligned,
 10    29 
 10    30        2 recursion_info,				/* describes relationship of this invocation to other active
 10    31*						   invocations of the same subsystem ... */
 10    32          3 invocation_data_idx fixed binary,		/* ... locates the list of active invocations */
 10    33          3 level fixed binary,			/* ... # of active invocations when this one created + 1 */
 10    34          3 previous_sci_ptr pointer,			/* ... -> description of previous invocation */
 10    35          3 next_sci_ptr pointer,			/* ... -> description of next invocation */
 10    36 
 10    37        2 request_processor_info,			/* information related to request line processing ... */
 10    38          3 request_tables_ptr pointer,			/* ... -> list of request tables in use */
 10    39          3 rp_options_ptr pointer,			/* ... -> options controlling the processor */
 10    40          3 abort_line_label label variable,
 10    41          3 request_data_ptr pointer,			/* ... -> request_data structure for current request */
 10    42 
 10    43        2 prompt_and_ready_info,			/* information related to prompts and ready messages ... */
 10    44          3 prompt character (64) varying,		/* the prompt (if any): an ioa_ control string */
 10    45          3 prompt_mode,				/* controls prompting ... */
 10    46 	 4 dont_prompt bit (1) unaligned,		/* ... ON => never prompt */
 10    47 	 4 prompt_after_null_lines bit (1) unaligned,	/* ... ON => prompt after a blank line if prompts enabled */
 10    48 	 4 dont_prompt_if_typeahead bit (1) unaligned,	/* ... ON => suppress prompts if request line available */
 10    49 	 4 pad bit (33) unaligned,
 10    50          3 ready_enabled bit (1) aligned,		/* ... ON => ready procedure should be invoked */
 10    51 
 10    52        2 listener_info,				/* information used by the listener ... */
 10    53          3 abort_subsystem_label label variable,
 10    54          3 temp_seg_ptr pointer,			/* ... -> temporary segment used for long request lines */
 10    55 
 10    56        2 temp_info_ptr pointer,			/* pointer to data used by ssu_temp_mgr_ */
 10    57 
 10    58        2 info_info,					/* information related to self-documentation ... */
 10    59          3 info_dirs_ptr pointer,			/* ... -> list of info directories */
 10    60          3 info_prefix character (32),			/* ... prefix used to form info segment names */
 10    61 
 10    62        2 ec_info,					/* data for subsystem exec_com processing ... */
 10    63          3 ec_suffix char (32) unaligned,		/* ... suffix of exec_com segments */
 10    64          3 ec_search_list char (32) unaligned,		/* ... search list used to find exec_coms */
 10    65          3 subsystem_dir_ptr pointer,			/* ... defines referencing_dir rule for above search list */
 10    66 
 10    67        2 entries,					/* all replaceable entries ... */
 10    68          (
 10    69          3 abort_line,				/* ... invoked by ssu_$abort_line */
 10    70          3 abort_subsystem,				/* ... invoked by ssu_$abort_subsystem */
 10    71          3 print_message,				/* ... invoked by ssu_$print_message */
 10    72          3 program_interrupt,				/* ... cannot be called externally */
 10    73          3 pre_request_line,				/* ... cannot be called externally */
 10    74          3 post_request_line,				/* ... cannot be called externally */
 10    75          3 ready,					/* ... invoked by ssu_$ready_proc */
 10    76          3 cpescape,				/* ... cannot be called externally */
 10    77          3 unknown_request,				/* ... invoked by ssu_$unknown_request */
 10    78          3 listen,					/* ... invoked by ssu_$listen */
 10    79          3 execute_line,				/* ... invoked by ssu_$execute_line */
 10    80          3 evaluate_active_string,			/* ... invoked by ssu_$evaluate_active_string */
 10    81          3 invoke_request,				/* ... invoked by ssu_$invoke_request */
 10    82          3 locate_request,				/* ... invoked by ssu_$locate_request */
 10    83          3 arg_count,				/* ... invoked by ssu_$arg_count */
 10    84          3 arg_ptr,					/* ... invoked by ssu_$arg_ptr */
 10    85          3 return_arg,				/* ... invoked by ssu_$return_arg */
 10    86          3 arg_list_ptr,				/* ... invoked by ssu_$arg_list_ptr */
 10    87          3 get_default_rp_options,			/* ... invoked by ssu_$get_default_rp_options */
 10    88          3 get_rp_options,				/* ... invoked by ssu_$get_request_processor_options */
 10    89          3 set_rp_options,				/* ... invoked by ssu_$set_request_processor_options */
 10    90          3 reset_rp_options,				/* ... invoked by ssu_$reset_request_processor_options */
 10    91          3 get_subsys_and_request_name			/* ... invoked by ssu_$get_subsystem_and_request_name */
 10    92          ) entry () variable options (variable);
 10    93 
 10    94 dcl  sci_ptr pointer;
 10    95 
 10    96 dcl  sci_parent_area area based (sci.parent_area_ptr);
 10    97 
 10    98 dcl  SCI_VERSION_3 character (8) static options (constant) init ("sci_0003");
 10    99 
 10   100 /* END INCLUDE FILE ... _ssu_sci.incl.pl1 */
       55 
       56    call add ("sci", addr (p -> sci));
       57 
       58 begin; /* both tty_ and tc_io_ use the same name for the attach data */
       59    /* BEGIN INCLUDE FILE tc_io_attach_data_.incl.pl1 */
 11     2 
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(86-07-21,LJAdams), approve(86-11-11,MCR7485),
 11     6*     audit(86-12-16,Margolin), install(87-01-06,MR12.0-1255):
 11     7*     Added field to hold ptr to MOWSE terminal switch.
 11     8*  2) change(86-11-26,LJAdams), approve(86-11-26,MCR7584),
 11     9*     audit(86-12-16,Margolin), install(87-01-06,MR12.0-1255):
 11    10*     tty_handle component has been added for DSA.
 11    11*                                                   END HISTORY COMMENTS */
 11    12 
 11    13 
 11    14 /* Written BIM 1981-1-1 */
 11    15 /* Modified DEC 1985 by R. Negaret to add network_type and tty_handle */
 11    16 /* format: style2,linecom,^indnoniterdo,indcomtxt,^inditerdo,dclind5,idind25 */
 11    17 /* INTERNAL INTERFACE -- SUBJECT TO CHANGE */
 11    18 
 11    19      dcl	attach_data_ptr	     pointer;
 11    20      dcl	1 attach_data	     aligned based (attach_data_ptr),
 11    21 	  2 tc_info_ptr	     pointer,		/* data block managed by terminal control */
 11    22 	  2 mowse_terminal_iocb_ptr
 11    23 			     pointer,		/* pointer to the MOWSE terminal switch   */
 11    24 	  2 attach_descrip	     character (128) varying,
 11    25 	  2 open_descrip	     character (64) varying,
 11    26 	  2 device_id	     character (32) unaligned,/* given in atd */
 11    27 	  2 device_used	     character (32) unaligned,/* aquired by dm_ */
 11    28 	  2 terminal_type	     character (32) unaligned,
 11    29 	  2 dial_phone	     character (64) varying,
 11    30 	  2 resource_desc	     character (256) unaligned,
 11    31 	  2 network_type	     fixed bin,
 11    32 	  2 tty_index	     fixed bin,
 11    33 	  2 tty_handle	     fixed bin (35),
 11    34 	  2 operation_hlock	     fixed bin,		/* if this is nonzero detach may not free this structure */
 11    35 	  2 flags		     aligned,
 11    36 	    3 assigned_ev_channel
 11    37 			     bit (1) unaligned,	/* we got the channel as fast channel */
 11    38 	    3 created_ev_channel bit (1) unaligned,	/* we got it as slow channel */
 11    39 	    3 have_ev_channel			/* there is a channel to use */
 11    40 			     bit (1) unaligned,
 11    41 	    3 login_channel	     bit (1) unaligned,	/* we are login channel */
 11    42 	    3 phone_given	     bit (1) unaligned,	/* dial_out */
 11    43 	    3 must_release	     bit (1) unaligned,	/* we must call release channel */
 11    44 	    3 no_block	     bit (1) unaligned,	/* never block */
 11    45 	    3 async_detach	     bit (1) unaligned,	/* detach_iocb with hlock nonzero */
 11    46 	    3 hangup	     bit (1) unaligned,
 11    47 	    3 debug	     bit (1) unaligned,
 11    48 	    3 pad		     bit (26) unaligned,
 11    49 	  2 dial_manager_event   aligned like event_wait_channel,
 11    50 						/* so we can do set_hangup_proc */
 11    51 	  2 event_wait	     aligned like event_wait_channel;
 11    52 						/* init attributes and all */
 11    53 
 12     1 /* BEGIN INCLUDE FILE ... event_wait_channel.incl.pl1 */
 12     2 
 12     3 /* ipc_$block wait list with one channel
 12     4*
 12     5*   Written 9-May-79 by M. N. Davidoff.
 12     6**/
 12     7 
 12     8      declare 1 event_wait_channel   aligned,
 12     9 	     2 n_channels	      fixed bin initial (1),	/* number of channels */
 12    10 	     2 pad	      bit (36),
 12    11 	     2 channel_id	      (1) fixed bin (71);	/* event channel to wait on */
 12    12 
 12    13 /* END INCLUDE FILE ... event_wait_channel.incl.pl1 */
 11    54 
 11    55 
 11    56 /* END INCLUDE FILE tc_io_attach_data_.incl.pl1 */
       59 
       60       dcl 1 tc_io_attach_data aligned like attach_data based;
       61       call add ("tc_io_attach_data", addr (p -> tc_io_attach_data));
       62    end;
       63 
       64 begin; /* both tty_ and tc_io_ use the same name for the attach data */
       65    /*  BEGIN:   tty_attach_data_.incl.pl1			  *  *  *  *  *  */
 13     2 
 13     3 
 13     4 /****^  HISTORY COMMENTS:
 13     5*  1) change(81-01-01,Margulies), approve(), audit(), install():
 13     6*     Created from internal declarations.
 13     7*  2) change(85-12-01,Negaret), approve(87-07-23,MCR7742),
 13     8*     audit(87-07-23,GDixon), install(87-08-04,MR12.1-1056):
 13     9*     Add network_type and tty_handle.
 13    10*                                                   END HISTORY COMMENTS */
 13    11 
 13    12 
 13    13 /* format: style2 */
 13    14 
 13    15 /* INTERNAL INTERFACE -- SUBJECT TO CHANGE */
 13    16 
 13    17      dcl	   attach_data_ptr	      pointer;
 13    18      dcl	   1 attach_data	      aligned based (attach_data_ptr),
 13    19 	     2 attach_descrip     character (128) varying,
 13    20 	     2 open_descrip	      character (64) varying,
 13    21 	     2 device_id	      character (32) unaligned,
 13    22 						/* given in atd */
 13    23 	     2 device_used	      character (32) unaligned,
 13    24 						/* aquired by dm_ */
 13    25 	     2 dial_phone	      character (64) varying,
 13    26 	     2 dial_id	      character (32) unaligned,
 13    27 	     2 resource_desc      character (256) unaligned,
 13    28 	     2 network_type	      fixed bin,
 13    29 	     2 tty_index	      fixed bin,
 13    30 	     2 tty_handle	      fixed bin (35),
 13    31 	     2 operation_hlock    fixed bin,		/* if this is nonzero detach may not free this structure */
 13    32 	     2 flags	      aligned,
 13    33 	       3 assigned_ev_channel
 13    34 			      bit (1) unaligned,	/* we got the channel as fast channel */
 13    35 	       3 created_ev_channel
 13    36 			      bit (1) unaligned,	/* we got it as slow channel */
 13    37 	       3 have_ev_channel  bit (1) unaligned,	/* there is a channel to use */
 13    38 	       3 login_channel    bit (1) unaligned,	/* we are login channel */
 13    39 	       3 phone_given      bit (1) unaligned,	/* dial_out */
 13    40 	       3 accept_dial      bit (1) unaligned,	/* wait for terminal to dial */
 13    41 	       3 must_release     bit (1) unaligned,	/* we must call release channel */
 13    42 	       3 no_block	      bit (1) unaligned,	/* never block */
 13    43 	       3 async_close      bit (1) unaligned,	/* close with hlock nonzero */
 13    44 	       3 async_detach     bit (1) unaligned,	/* detach_iocb with hlock nonzero */
 13    45 	       3 hangup	      bit (1) unaligned,
 13    46 	       3 async_hangup     bit (1) unaligned,	/* channel was hungup (and released) by AS */
 13    47 	       3 have_user_hangup_proc
 13    48 			      bit (1) unaligned,	/* user has supplied a hangup procedure */
 13    49 	       3 pad	      bit (23) unaligned,
 13    50 	     2 dial_manager_event aligned like event_wait_channel,
 13    51 	     2 event_wait	      aligned like event_wait_channel,
 13    52 	     2 user_hangup_proc,			/* user supplied hangup procedure */
 13    53 	       3 procedure	      entry (pointer) variable,
 13    54 	       3 data_ptr	      pointer,
 13    55 	     2 mode_string_info   aligned,
 13    56 	       3 max_mode_length  fixed bin (35),
 13    57 	       3 mode_string      char (tty_max_mode_length refer (attach_data.max_mode_length)) unaligned,
 13    58 	     2 temp_mode_string   char (tty_max_mode_length refer (attach_data.max_mode_length)) unaligned;
 13    59 
 13    60      declare tty_max_mode_length    fixed bin (21);
 13    61 
 14     1 /* BEGIN INCLUDE FILE ... event_wait_channel.incl.pl1 */
 14     2 
 14     3 /* ipc_$block wait list with one channel
 14     4*
 14     5*   Written 9-May-79 by M. N. Davidoff.
 14     6**/
 14     7 
 14     8      declare 1 event_wait_channel   aligned,
 14     9 	     2 n_channels	      fixed bin initial (1),	/* number of channels */
 14    10 	     2 pad	      bit (36),
 14    11 	     2 channel_id	      (1) fixed bin (71);	/* event channel to wait on */
 14    12 
 14    13 /* END INCLUDE FILE ... event_wait_channel.incl.pl1 */
 13    62 
 13    63 
 13    64 /*  END OF:  tty_attach_data_.incl.pl1			  *  *  *  *  *  */
       65 
       66       dcl 1 tty_attach_data aligned like attach_data based;
       67       call add ("tty_attach_data", addr (p -> tty_attach_data));
       68    end;
       69 
       70 /* Followed by the include file containing the code to do the work */
       71 
       72 dcl  WHOAMI char (32) internal static options (constant) init ("structure_library_6_");
       73 
       74 /* Builtins */
       75 
       76 dcl  (currentsize, divide, hbound, pointer) builtin;
       77 
 15     1 
 15     2 
 15     3 /* *  	STRUCTURE_LIBRARY_CODE.INCL.PL1
 15     4*   *
 15     5*   *	This procedure generates the default library segment for the
 15     6*   *      structure display system.  The way it operates is hardly what one
 15     7*   *      would call normal, however. It has to do a number of rather unclean
 15     8*   *      things, and modifications must be made carefully following these
 15     9*   *      conventions:
 15    10*   * 
 15    11*   *      Because the compiler insists on actually having a structure appear
 15    12*   *      in some reference context for it to appear in the symbol table,
 15    13*   *      regardless of options, every structure defined herein must be
 15    14*   *      referenced somehow. This is accomplished with the calls to the
 15    15*   *      "add" procedure. The first argument to the "add" procedure is the
 15    16*   *      name of the structure, put there so it can be added to the table
 15    17*   *      of contents for the segment.
 15    18*   *
 15    19*   *      The second argument to the add procedure is a pointer, which must
 15    20*   *      always be of the form "addr (p -> structure)".  This is done to 
 15    21*   *      that the structure will be referenced, while at the same time 
 15    22*   *      avoiding any reference to its implicit base, or to other values
 15    23*   *      which must be initialized to avoid warnings.  
 15    24*   *
 15    25*   *      Finally, this program compiles and runs itself using 
 15    26*   *      create_data_segment; this is done both to ensure that it gets
 15    27*   *      compiled with a symbol table, and to make it possible copy the 
 15    28*   *      object segment and write into the internal static options (constant)
 15    29*   *      array that is the table of structures. All in all, it's pretty 
 15    30*   *      complicated.
 15    31*   *
 15    32*   *      The code for this program is in an include file in order to ease
 15    33*   *	the construction of user-defined structure libraries. In order to
 15    34*   *      use this code, one must create a program looking like this:
 15    35*   *
 15    36*   *	structure_library_7_:
 15    37*   *	     procedure ();
 15    38*   *
 15    39*   *		< %include statements, calls to add >
 15    40*   *
 15    41*   *       dcl  WHOAMI char (32) internal static options (constant) init ("structure_library_7_");
 15    42*   *	%include structure_library_code;
 15    43*   *	          end structure_library_7_;
 15    44*   *
 15    45*   *	The standard structure libraries (structure_library_1_.cds,
 15    46*   *	for example, provide a good example of this.
 15    47*   *	
 15    48*   *      30 May 1983, W. Olin Sibert
 15    49*   */
 15    50 
 15    51 /*  */
 15    52 
 15    53 /* Now come the more ordinary parts of code that usually appear in a program */
 15    54 
 15    55 dcl  code	fixed binary (35);
 15    56 dcl  severity_ptr pointer;
 15    57 dcl  severity_value fixed bin (35) based (severity_ptr);
 15    58 dcl  answer bit (1) aligned;
 15    59 dcl  new_segp pointer;
 15    60 dcl  old_segp pointer;
 15    61 dcl  bitcount fixed bin (24);
 15    62 dcl  n_words fixed bin (18);
 15    63 dcl  based_words (n_words) bit (36) aligned based;
 15    64 
 15    65 dcl  p pointer init (null ());			/* our general-purpose base */
 15    66 
 15    67 dcl  com_err_ entry options (variable);
 15    68 dcl  command_query_$yes_no entry options (variable);
 15    69 dcl  get_external_variable_ entry (char (*), pointer, fixed bin (19), pointer, fixed bin (35));
 15    70 dcl  get_wdir_ entry () returns (char (168));
 15    71 dcl  hcs_$make_seg entry (char (*), char (*), char (*), 
 15    72      fixed bin (5), pointer, fixed bin (35));
 15    73 dcl  hcs_$set_bc_seg entry (pointer, fixed bin (24), fixed bin (35));
 15    74 dcl  hcs_$status_mins entry 
 15    75     (pointer, fixed bin (2), fixed bin (24), fixed bin (35));
 15    76 dcl  hcs_$terminate_noname entry (pointer, fixed bin (35));
 15    77 dcl  nothing entry options (variable);
 15    78 
 15    79 dcl  INITIALIZED bit (1) aligned internal static options (constant) init ("0"b);
 15    80 dcl  initialized_bit bit (1) aligned based;
 15    81 
 15    82 /* The following array is important: it defines the "table of contents"
 15    83*   for the structure library segment.  It is declared and initialized to
 15    84*   empty, but when the object segment is copied into the library segment, 
 15    85*   it is filled in with the actual names of all the structures, which were
 15    86*   collected by all the calls to "add", above. */
 15    87 
 15    88 dcl  STRUCTURES (200) char (32) unaligned internal static options (constant) 
 15    89      init ((200)(32)"");
 15    90 
 15    91 /* This is the automatic array where the data is collected, and the based
 15    92*   overlay used later on to copy it into the new segment */
 15    93 
 15    94 dcl  based_structures (n_structures) char (32) unaligned based;
 15    95 dcl  structures (hbound (STRUCTURES, 1)) char (32) unaligned automatic;
 15    96 dcl  n_structures fixed bin init (0);
 15    97 
 15    98 dcl (addr, codeptr, null, rel, size, unspec) builtin;
 15    99 
 15   100 /**/
 15   101 
 15   102 /* Finally, the real code, which copies one segment onto the other and
 15   103*   updates the structures arrays. */
 15   104 
 15   105 	if INITIALIZED then do;
 15   106 	     call com_err_ (0, WHOAMI, "This program is a data segment, and may not be executed.");
 15   107 	     return;
 15   108 	     end;
 15   109 
 15   110 	call get_external_variable_ ("pl1_severity_", severity_ptr, (0), (null ()), code);
 15   111 	if (code ^= 0) then do;
 15   112 	     call com_err_ (code,  WHOAMI, "Cannot determine severity for compilation of ^a.", WHOAMI);
 15   113 	     return;
 15   114 	     end;
 15   115 
 15   116 	if (severity_value = 2) then do;
 15   117 	     call command_query_$yes_no (answer, 0, WHOAMI, 
 15   118 
 15   119 "ERROR 366 means that the program is too large to construct a symbol table;
 15   120 this quite commonly happens to structure libraries because of their enormous
 15   121 symbol tables. You may be able to fix the error by rearranging some of the
 15   122 include files.",
 15   123 
 15   124 "Warning: A severity two PL/I error has occurred. 
 15   125 If it is ERROR 366, the result of this compilation will be partially invalid.
 15   126 Do you wish to continue and generate the library segment anyway?");
 15   127 
 15   128 	     if ^answer then return;
 15   129 	     end;
 15   130 
 15   131 	old_segp = pointer (addr (STRUCTURES), 0);
 15   132 
 15   133 	call hcs_$status_mins (old_segp, (0), bitcount, code);
 15   134 	if (code ^= 0) then do;
 15   135 	     call com_err_ (code, WHOAMI, 
 15   136 		"Cannot get bitcount of original segment.");
 15   137 	     return;
 15   138 	     end;
 15   139 
 15   140 	call hcs_$make_seg ((get_wdir_ ()), WHOAMI, "", 01010b, new_segp, code);
 15   141 	if (new_segp = null ()) then do;
 15   142 	     call com_err_ (code, WHOAMI, "Cannot create [wd]>^a", WHOAMI);
 15   143 	     return;
 15   144 	     end;
 15   145 
 15   146 	n_words = divide (bitcount, 36, 18, 0);
 15   147 	new_segp -> based_words = old_segp -> based_words;
 15   148 
 15   149 	call hcs_$set_bc_seg (new_segp, bitcount, code);
 15   150 	if (code ^= 0) then do;
 15   151 	     call com_err_ (code, WHOAMI,
 15   152 		"Cannot set bitcount on [wd]>^a", WHOAMI);
 15   153 	     return;
 15   154 	     end;
 15   155 
 15   156 /* Finally, copy in the structure list */
 15   157 
 15   158 	pointer (new_segp, rel (addr (STRUCTURES))) -> based_structures
 15   159 	     = addr (structures) -> based_structures;
 15   160 	pointer (new_segp, rel (addr (INITIALIZED))) -> initialized_bit = "1"b;
 15   161 
 15   162 	call hcs_$terminate_noname (new_segp, (0));
 15   163 
 15   164 ERROR_RETURN:
 15   165 	return;
 15   166 
 15   167 /*  */
 15   168 
 15   169 /* This is called once for each structure which goes in the table of contents.
 15   170*   It adds the structure to the automatic array, and increments the count. */
 15   171 
 15   172 add:
 15   173 addx:
 15   174      procedure (name, useless_pointer);
 15   175 
 15   176 dcl  name char (32);
 15   177 dcl  useless_pointer pointer;
 15   178 
 15   179 /* The bounds check is against hbound - 1, since it is necessary to always
 15   180*   leave at least one blank entry in the table of contents to show where
 15   181*   the last valid entry is. */
 15   182 
 15   183 
 15   184 	if (n_structures >= (hbound (STRUCTURES, 1) - 1)) then do;
 15   185 	     call com_err_ (0, WHOAMI, 
 15   186 		"Too many structures defined. Max is ^d.^/^3xChange the dimension of the STRUCTURES array and recompile.",
 15   187 		hbound (STRUCTURES, 1));
 15   188 	     goto ERROR_RETURN;
 15   189 	     end;
 15   190 
 15   191 	n_structures = n_structures + 1;
 15   192 	structures (n_structures) = name;
 15   193 	structures (n_structures + 1) = "";
 15   194 	return;
 15   195 	end add;
       78 
       79 
       80 	end structure_library_6_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/04/87  1222.0  !BBBJWhKzLfGMGZ.pl1               >special_ldd>install>MR12.1-1054>structure_library_6_.cds
29           1    11/07/86  1550.3  cpm_control_point_data.incl.pl1   >ldd>include>cpm_control_point_data.incl.pl1
30           2    11/07/86  1550.3  cpm_ctrl_pt_meters.incl.pl1       >ldd>include>cpm_ctrl_pt_meters.incl.pl1
31           3    10/26/76  1333.6  process_usage.incl.pl1            >ldd>include>process_usage.incl.pl1
35           4    06/30/86  2023.8  mail_format.incl.pl1              >ldd>include>mail_format.incl.pl1
39           5    05/17/85  0615.6  mseg_message.incl.pl1             >ldd>include>mseg_message.incl.pl1
45           6    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
48           7    05/17/82  1411.5  mseg_return_args.incl.pl1         >ldd>include>mseg_return_args.incl.pl1
51           8    05/17/85  0615.7  mseg_segment.incl.pl1             >ldd>include>mseg_segment.incl.pl1
52           9    05/17/85  0615.7  mseg_wakeup_state.incl.pl1        >ldd>include>mseg_wakeup_state.incl.pl1
55          10    01/21/85  0912.2  _ssu_sci.incl.pl1                 >ldd>include>_ssu_sci.incl.pl1
59          11    01/06/87  1357.0  tc_io_attach_data_.incl.pl1       >ldd>include>tc_io_attach_data_.incl.pl1
11-54       12    06/29/79  1728.0  event_wait_channel.incl.pl1       >ldd>include>event_wait_channel.incl.pl1
65          13    08/04/87  1138.8  tty_attach_data_.incl.pl1         >spec>install>1056>tty_attach_data_.incl.pl1
13-62       14    06/29/79  1728.0  event_wait_channel.incl.pl1       >ldd>include>event_wait_channel.incl.pl1
78          15    09/12/84  2307.0  structure_library_code.incl.pl1   >ldd>include>structure_library_code.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
INITIALIZED                     000033 constant        bit(1)                   initial dcl 15-79 set ref 15-105 15-160
STRUCTURES                      002706 constant        char(32)                 initial array unaligned dcl 15-88 set ref 15-95
                                                                                  15-131 15-158 15-184 15-185 15-185
WHOAMI                          000000 constant        char(32)                 initial unaligned dcl 72 set ref 15-106* 15-112*
                                                                                  15-112* 15-117* 15-135* 15-140* 15-142* 15-142*
                                                                                  15-151* 15-151* 15-185*
addr                                                   builtin function         dcl 15-98 ref 37 37 40 40 41 41 42 42 43 43 46 46 49
                                                                                  49 53 53 56 56 15-131 15-158 15-158 15-160 32 32
                                                                                  61 61 67 67
answer                          000126 automatic       bit(1)                   dcl 15-58 set ref 15-117* 15-128
attach_data                            based           structure                level 1 dcl 11-20 in begin block on line 58
attach_data                            based           structure                level 1 dcl 13-18 in begin block on line 64
attach_data_ptr                 000156 automatic       pointer                  dcl 11-19 in begin block on line 58 ref 11-20 11-20
                                                                                  11-20 11-20 11-20 11-20 11-20 11-20 11-20 11-20
                                                                                  11-20 11-20 11-20 11-20 11-20 11-20 11-20 11-20
                                                                                  11-20 11-20 11-20 11-20 11-20 11-20 11-20 11-20
                                                                                  11-20 11-20 11-20 11-20 11-20 11-20 11-20 11-20
attach_data_ptr                 000164 automatic       pointer                  dcl 13-17 in begin block on line 64 ref 13-18 13-18
                                                                                  13-18 13-18 13-18 13-18 13-18 13-18 13-18 13-18
                                                                                  13-18 13-18 13-18 13-18 13-18 13-18 13-18 13-18
                                                                                  13-18 13-18 13-18 13-18 13-18 13-18 13-18 13-18
                                                                                  13-18 13-18 13-18 13-18 13-18 13-18 13-18 13-18
                                                                                  13-18 13-18 13-18 13-18 13-18 13-18 13-18 13-18
based_structures                       based           char(32)                 array unaligned dcl 15-94 set ref 15-158* 15-158
based_words                            based           bit(36)                  array dcl 15-63 set ref 15-147* 15-147
bitcount                        000134 automatic       fixed bin(24,0)          dcl 15-61 set ref 15-133* 15-146 15-149*
block_size               15            based           fixed bin(17,0)          level 3 dcl 8-28 set ref 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-82
code                            000122 automatic       fixed bin(35,0)          dcl 15-55 set ref 15-110* 15-111 15-112* 15-133*
                                                                                  15-134 15-135* 15-140* 15-142* 15-149* 15-150
                                                                                  15-151*
com_err_                        000012 constant        entry                    external dcl 15-67 ref 15-106 15-112 15-135 15-142
                                                                                  15-151 15-185
command_query_$yes_no           000014 constant        entry                    external dcl 15-68 ref 15-117
control_point_data                     based           structure                level 1 dcl 1-17 set ref 32 32
control_point_meters                   based           structure                level 1 dcl 2-19
cpd_ptr                         000146 automatic       pointer                  dcl 1-55 ref 1-17 1-17 1-17 1-17 1-17 1-17 1-17 1-17
                                                                                  1-17 1-17 1-17 1-17 1-17 1-17 1-17 1-17 1-17 1-17
                                                                                  1-17 1-17 1-17 1-17 1-17 1-17 1-17 1-17 1-17 1-17
                                                                                  1-17 1-17 1-17 1-17 1-17 1-17 1-17 1-17 1-17 1-17
                                                                                  1-17 1-17 1-17 1-17 1-17 1-17 1-17 1-17 1-17 1-17
                                                                                  1-17 1-17
cpm_ptr                         000150 automatic       pointer                  dcl 2-27 ref 2-19 2-19 2-19 2-19 2-19 2-19 2-19 2-19
                                                                                  2-19 2-19 2-19 2-19 2-19 2-19 2-19 2-19
currentsize                                            builtin function         dcl 76 ref 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-82
data_lth                  0(19)        based           fixed bin(17,0)          level 3 in structure "first_message_block" packed
                                                                                  unsigned unaligned dcl 5-69 in procedure
                                                                                  "structure_library_6_" set ref 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69
data_lth                  0(19)        based           fixed bin(17,0)          level 3 in structure "other_message_block" packed
                                                                                  unsigned unaligned dcl 5-82 in procedure
                                                                                  "structure_library_6_" set ref 5-82 5-82 5-82
divide                                                 builtin function         dcl 76 ref 15-146
event_wait_channel              000160 automatic       structure                level 1 dcl 12-8 in begin block on line 58
event_wait_channel              000170 automatic       structure                level 1 dcl 14-8 in begin block on line 64
first_message_block                    based           structure                level 1 dcl 5-69 set ref 42 42
get_external_variable_          000016 constant        entry                    external dcl 15-69 ref 15-110
get_wdir_                       000020 constant        entry                    external dcl 15-70 ref 15-140
hbound                                                 builtin function         dcl 76 ref 15-95 15-184 15-185 15-185
hcs_$make_seg                   000022 constant        entry                    external dcl 15-71 ref 15-140
hcs_$set_bc_seg                 000024 constant        entry                    external dcl 15-73 ref 15-149
hcs_$status_mins                000026 constant        entry                    external dcl 15-74 ref 15-133
hcs_$terminate_noname           000030 constant        entry                    external dcl 15-76 ref 15-162
header                                 based           structure                level 2 in structure "first_message_block" dcl 5-69
                                                                                  in procedure "structure_library_6_"
header                                 based           structure                level 2 in structure "other_message_block" dcl 5-82
                                                                                  in procedure "structure_library_6_"
header                                 based           structure                level 2 in structure "mail_format" dcl 4-24
                                                                                  in procedure "structure_library_6_"
header                                 based           structure                level 2 in structure "mseg_segment" dcl 8-28
                                                                                  in procedure "structure_library_6_"
initialized_bit                        based           bit(1)                   dcl 15-80 set ref 15-160*
mail_format                            based           structure                level 1 dcl 4-24 set ref 37 37
mail_format_ptr                 000100 automatic       pointer                  dcl 4-17 ref 4-24 4-24 4-24 4-24 4-24 4-24 4-24 4-24
                                                                                  4-24 4-24 4-24 4-24 4-24 4-24 4-24 4-24
max_mode_length         256            based           fixed bin(35,0)          level 3 dcl 13-18 ref 13-18 13-18 13-18 66 66 66
mb_ptr                          000104 automatic       pointer                  dcl 5-32 ref 5-24 5-24 5-24 5-24 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-82 5-82 5-82 5-82 5-82 5-82 5-82 5-82
md_ptr                          000106 automatic       pointer                  dcl 5-61 ref 5-37 5-37 5-37 5-37 5-37 5-37 5-37 5-37
                                                                                  5-37 5-37 5-37 5-37 5-37 5-37 5-37 5-37 5-37 5-37
message_block_header                   based           structure                level 1 dcl 5-24 set ref 40 40 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69 5-82
message_descriptor                     based           structure                level 1 dcl 5-37 set ref 41 41 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69
mode_string_info        256            based           structure                level 2 dcl 13-18
ms_arg_ptr                      000112 automatic       pointer                  dcl 7-7 ref 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9
mseg_message_info                      based           structure                level 1 dcl 6-9 set ref 46 46
mseg_message_info_ptr           000110 automatic       pointer                  dcl 6-7 ref 6-9 6-9 6-9 6-9 6-9 6-9 6-9 6-9 6-9 6-9
                                                                                  6-9 6-9 6-9 6-9 6-9 6-9 6-9
mseg_ptr                        000114 automatic       pointer                  dcl 8-68 ref 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69 5-69
                                                                                  5-69 5-82 8-28 8-28 8-28 8-28 8-28 8-28 8-28 8-28
                                                                                  8-28 8-28 8-28 8-28 8-28 8-28 8-28 8-28 8-28 8-28
                                                                                  8-28 8-28 8-28 8-28 8-28 8-28 8-28 8-28 8-28 8-28
                                                                                  8-28 8-28 8-28 8-28 8-28 8-28 8-28 8-28 8-28 8-28
                                                                                  8-28 8-28
mseg_return_args                       based           structure                level 1 dcl 7-9 set ref 49 49
mseg_segment                           based           structure                level 1 dcl 8-28 set ref 53 53
mseg_wakeup_state                      based           structure                level 1 dcl 9-24
mseg_wakeup_state_ptr           000116 automatic       pointer                  dcl 9-38 ref 9-24 9-24 9-24 9-24 9-24 9-24 9-24 9-24
                                                                                  9-24 9-24 9-24
n_blocks_allocated       12            based           fixed bin(18,0)          level 3 dcl 8-28 set ref 8-28
n_channels                      000160 automatic       fixed bin(17,0)          initial level 2 in structure "event_wait_channel"
                                                                                  dcl 12-8 in begin block on line 58 set ref 12-8*
n_channels                      000170 automatic       fixed bin(17,0)          initial level 2 in structure "event_wait_channel"
                                                                                  dcl 14-8 in begin block on line 64 set ref 14-8*
n_structures                    000140 automatic       fixed bin(17,0)          initial dcl 15-96 set ref 15-94 15-96* 15-158 15-158
                                                                                  15-158 15-184 15-191* 15-191 15-192 15-193
n_words                         000135 automatic       fixed bin(18,0)          dcl 15-62 set ref 15-63 15-146* 15-147
name                                   parameter       char(32)                 unaligned dcl 15-176 ref 15-172 15-172 15-192
new_segp                        000130 automatic       pointer                  dcl 15-59 set ref 15-140* 15-141 15-147 15-149*
                                                                                  15-158 15-160 15-162*
null                                                   builtin function         dcl 15-98 ref 15-65 15-110 15-141
old_segp                        000132 automatic       pointer                  dcl 15-60 set ref 15-131* 15-133* 15-147
other_message_block                    based           structure                level 1 dcl 5-82 set ref 43 43
p                               000136 automatic       pointer                  initial dcl 15-65 set ref 37 37 40 40 41 41 42 42 43
                                                                                  43 46 46 49 49 53 53 56 56 15-65* 32 32 61 61 67
                                                                                  67
pointer                                                builtin function         dcl 76 ref 15-131 15-158 15-160
process_usage                          based           structure                level 1 unaligned dcl 3-3
process_usage_pointer           000154 automatic       pointer                  dcl 3-3 ref 3-3 3-3 3-3 3-3 3-3 3-3 3-3 3-3 3-3 3-3
                                                                                  3-3 3-3
rel                                                    builtin function         dcl 15-98 ref 15-158 15-160
sci                                    based           structure                level 1 dcl 10-14 set ref 56 56
sci_ptr                         000120 automatic       pointer                  dcl 10-94 ref 10-14 10-14 10-14 10-14 10-14 10-14
                                                                                  10-14 10-14 10-14 10-14 10-14 10-14 10-14 10-14
                                                                                  10-14 10-14 10-14 10-14 10-14 10-14 10-14 10-14
                                                                                  10-14 10-14 10-14 10-14 10-14 10-14 10-14 10-14
                                                                                  10-14 10-14 10-14 10-14 10-14 10-14 10-14 10-14
                                                                                  10-14 10-14 10-14 10-14 10-14 10-14 10-14 10-14
                                                                                  10-14 10-14 10-14 10-14 10-14 10-14 10-14 10-14
                                                                                  10-14 10-14 10-14 10-14 10-14 10-14 10-14 10-14
                                                                                  10-14 10-14 10-14 10-14 10-14
severity_ptr                    000124 automatic       pointer                  dcl 15-56 set ref 15-57 15-110* 15-116
severity_value                         based           fixed bin(35,0)          dcl 15-57 ref 15-116
structures                      000140 automatic       char(32)                 array unaligned dcl 15-95 set ref 15-158 15-192*
                                                                                  15-193*
tc_io_attach_data                      based           structure                level 1 dcl 60 set ref 61 61
text_len                 12            based           fixed bin(21,0)          level 3 dcl 4-24 set ref 4-24
text_length                     000102 automatic       fixed bin(21,0)          dcl 4-22 set ref 36*
tty_attach_data                        based           structure                level 1 dcl 66 set ref 67 67
useless_pointer                        parameter       pointer                  dcl 15-177 ref 15-172 15-172

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CONTROL_POINT_METERS_ARGUMENT_VERSION_1
                                       constant        char(8)                  initial unaligned dcl 2-37
CPM_BLOCKED                            constant        fixed bin(17,0)          initial dcl 1-60
CPM_DESTROYED                          constant        fixed bin(17,0)          initial dcl 1-60
CPM_READY                              constant        fixed bin(17,0)          initial dcl 1-60
CPM_STOPPED                            constant        fixed bin(17,0)          initial dcl 1-60
MAIL_FORMAT_VERSION_4                  constant        fixed bin(17,0)          initial dcl 4-19
MAX_NUMBER_OF_METERS                   constant        fixed bin(17,0)          initial dcl 2-40
MESSAGE_DESCRIPTOR_SENTINEL            constant        bit(36)                  initial dcl 5-63
MSEG_MESSAGE_INFO_V1                   constant        char(8)                  initial dcl 6-28
MSEG_READ_AFTER_SPECIFIED              constant        fixed bin(17,0)          initial dcl 6-30
MSEG_READ_BEFORE_SPECIFIED             constant        fixed bin(17,0)          initial dcl 6-30
MSEG_READ_DELETE                       constant        bit(36)                  initial dcl 6-38
MSEG_READ_FIRST                        constant        fixed bin(17,0)          initial dcl 6-30
MSEG_READ_LAST                         constant        fixed bin(17,0)          initial dcl 6-30
MSEG_READ_OWN                          constant        bit(36)                  initial dcl 6-38
MSEG_READ_SPECIFIED                    constant        fixed bin(17,0)          initial dcl 6-30
MSEG_SEGMENT_SENTINEL                  constant        bit(36)                  initial dcl 8-73
MSEG_SEGMENT_VERSION_5                 constant        fixed bin(17,0)          initial dcl 8-70
MSEG_WAKEUP_STATE_VERSION_1            constant        char(8)                  initial unaligned dcl 9-41
SCI_VERSION_3                          constant        char(8)                  initial unaligned dcl 10-98
codeptr                                                builtin function         dcl 15-98
control_point_meters_argument          based           structure                level 1 dcl 2-32
cpma_ptr                        000152 automatic       pointer                  dcl 2-43
header_msg                             based           bit(36)                  array dcl 8-84
header_msg_access_class                defined         bit(72)                  dcl 8-79
header_msg_present                     defined         bit(1)                   unaligned dcl 8-82
nothing                         000000 constant        entry                    external dcl 15-77
sci_parent_area                        based           area(1024)               dcl 10-96
size                                                   builtin function         dcl 15-98
tty_max_mode_length             000166 automatic       fixed bin(21,0)          dcl 13-60
unspec                                                 builtin function         dcl 15-98

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_RETURN                    002571 constant        label                    dcl 15-164 set ref 15-188
add                             002575 constant        entry                    internal dcl 15-172 ref 32 37 40 41 42 43 46 49 53
                                                                                  56 61 67
addx                            002572 constant        entry                    internal dcl 15-172
structure_library_6_            001726 constant        entry                    external dcl 23

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6136        6170    6006        6146
Length     17306    6006        32       11102     130           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
structure_library_6_                382 external procedure  is an external procedure.  
begin block on line 28                  begin block         shares stack frame of external procedure structure_library_6_.  
begin block on line 58                  begin block         shares stack frame of external procedure structure_library_6_.  
begin block on line 64                  begin block         shares stack frame of external procedure structure_library_6_.  
addx                                    internal procedure  shares stack frame of external procedure structure_library_6_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
structure_library_6_     000100 mail_format_ptr             structure_library_6_
                         000102 text_length                 structure_library_6_
                         000104 mb_ptr                      structure_library_6_
                         000106 md_ptr                      structure_library_6_
                         000110 mseg_message_info_ptr       structure_library_6_
                         000112 ms_arg_ptr                  structure_library_6_
                         000114 mseg_ptr                    structure_library_6_
                         000116 mseg_wakeup_state_ptr       structure_library_6_
                         000120 sci_ptr                     structure_library_6_
                         000122 code                        structure_library_6_
                         000124 severity_ptr                structure_library_6_
                         000126 answer                      structure_library_6_
                         000130 new_segp                    structure_library_6_
                         000132 old_segp                    structure_library_6_
                         000134 bitcount                    structure_library_6_
                         000135 n_words                     structure_library_6_
                         000136 p                           structure_library_6_
                         000140 structures                  structure_library_6_
                         000140 n_structures                structure_library_6_
                         000146 cpd_ptr                     begin block on line 28
                         000150 cpm_ptr                     begin block on line 28
                         000152 cpma_ptr                    begin block on line 28
                         000154 process_usage_pointer       begin block on line 28
                         000156 attach_data_ptr             begin block on line 58
                         000160 event_wait_channel          begin block on line 58
                         000164 attach_data_ptr             begin block on line 64
                         000166 tty_max_mode_length         begin block on line 64
                         000170 event_wait_channel          begin block on line 64

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_temp          call_ext_out_desc   call_ext_out        return_mac          alloc_auto_adj      shorten_stack
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      command_query_$yes_no         get_external_variable_        get_wdir_
hcs_$make_seg                 hcs_$set_bc_seg               hcs_$status_mins              hcs_$terminate_noname

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     23 001725   15   65 001733   15   95 001735   15   96 001744        32 001745        36 001754        37 001755
     40 001764        41 001773        42 002002        43 002011        46 002020        49 002027        53 002036
     56 002045   12    8 002054        61 002056   14    8 002065        67 002067   15  105 002076   15  106 002100
15  107 002125   15  110 002126   15  111 002165   15  112 002167   15  113 002216   15  116 002217   15  117 002222
15  128 002262   15  131 002265   15  133 002270   15  134 002307   15  135 002311   15  137 002335   15  140 002336
15  141 002404   15  142 002410   15  143 002437   15  146 002440   15  147 002443   15  149 002451   15  150 002464
15  151 002466   15  153 002515   15  158 002516   15  160 002546   15  162 002555   15  164 002571   15  172 002572
15  184 002577   15  185 002602   15  188 002635   15  191 002636   15  192 002637   15  193 002647   15  194 002655


Object Segment >special_ldd>install>MR12.1-1054>structure_library_6_
Created on 08/04/87  1334.7 mst Tue
by GJohnson.SysMaint.a
using Multics PL/I Compiler, Release 29, of July 28, 1986

        Object    Text    Defs    Link    Symb  Static
Start        0       0    6006    6136    6170    6146
Length   17306    6006     130      32   11102       0


3 Definitions:


segname:    !BBBJWhKzLfGMGZ

text|1726       structure_library_6_            Entrypoint
symb|0          symbol_table


9 Links:

link|10     *symbol|0
link|12     com_err_
link|14     command_query_$yes_no
link|16     get_external_variable_
link|20     get_wdir_
link|30     hcs_$terminate_noname
link|26     hcs_$status_mins
link|24     hcs_$set_bc_seg
link|22     hcs_$make_seg





                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
