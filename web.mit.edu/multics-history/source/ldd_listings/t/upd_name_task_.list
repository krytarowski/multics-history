	COMPILATION LISTING OF SEGMENT upd_name_task_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1724.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 upd_name_task_:	procedure
       12 		options ( rename (( alloc_, smart_alloc_)) );
       13 
       14 /*
       15*
       16*	This procedure includes all name task primitives for the Multics Online
       17*	Updater; the following are entries:
       18*
       19*		upd_name_task_$list		list names on branch
       20*		upd_name_task_$list_archive	list archive component names
       21*		upd_name_task_$add		add names
       22*		upd_name_task_$delete	delete names
       23*		upd_name_task_$free		transform (name -> name.1 -> name.2 ...)
       24*					for primary name on segment; otherwise delete name
       25*
       26*	Calling sequences are identical for all entries, being:
       27*
       28*	     call upd_name_task_$xxx (ctlw, areap, parentp, acode, asev, taskp, seqno,
       29*		dir, seg, uid, np, nn);
       30*
       31*	     (1)	ctlw	bit(36) aligned	updater task control word
       32*	     (2)	areap	ptr		caller area pointer
       33*	     (3)	parentp	ptr		parent arglist pointer
       34*	     (4)	acode	fixed bin(35)	status code
       35*	     (5)	asev	fixed bin		severity code
       36*	     (6)	taskp	ptr		task pointer
       37*	     (7)	seqno	fixed bin		task sequence no.
       38*	     (8)	dir	char(168)		dirname of affected segment
       39*	     (9)	seg	char(32)		entryname of segment
       40*	    (10)	msgseg	char(32)		entryname of segment for use in messages
       41*	    (11)	uid	bit(36) aligned	unique id of segment (may be ""b)
       42*	    (12)	np	ptr		pointer to names structure
       43*	    (13)	nn	fixed bin		count of names in structure
       44*
       45*	These entry points are restartable, e.g. after a system or process failure,
       46*	and are also invertible, i.e. by repeating the call with c.rsw set, all
       47*	processing which was done may be undone, even after an abnormal termination.
       48*	In order that these functions may operate correctly, it is necessary that
       49*	"acode", "asev", and "taskp" be initialized to "0", "0", and "null",
       50*	respectively, and that for the "add", "delete", and "free" entry points,
       51*	names(i).pcode be initialized to error_table_$not_done, and names(i).rcode
       52*	to "0".  The "list" and "list_archive" entry points properly initialize
       53*	the latter two in "names" arrays output by them.  These two entry points
       54*	additionally require that "np" be initially null.
       55*
       56*	P. Bos, May 1972
       57*
       58*     Modified: 09/04/81 by GA Texada to call appropriate hcs_ entries on likage_error.
       59*
       60**/
       61 /**/
       62 
       63 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       64 
       65 
       66      dcl	ctlw			bit(36) aligned,	/* updater control word */
       67 	areap			ptr,		/* caller-supplied area */
       68 	parentp			ptr,		/* parent arglist pointer */
       69 	acode			fixed bin(35),	/* status code */
       70 	asev			fixed bin,	/* severity code */
       71 	taskp			ptr,		/* task pointer */
       72 	seqno			fixed bin,	/* task sequence no. */
       73 	dir			char(168),	/* dirname of affected segment */
       74 	seg			char(32),		/* entryname of segment */
       75 	msgseg			char(32),		/* entryname of segment for use in messages */
       76 	uid			bit(36) aligned,	/* unique id of segment */
       77 	np			ptr,		/* pointer to names array */
       78 	nn			fixed bin;	/* count */
       79 
       80      dcl	archive_util_$disected_element entry (ptr, ptr, char(32) aligned, fixed bin(24), fixed bin(35)),
       81 	archive_util_$first_disected	entry (ptr, ptr, char(32) aligned, fixed bin(24), fixed bin(35)),
       82 	chname_file_entry		entry (char(*), char(*), char(*), char(*), fixed bin(35))variable,
       83 	cu_$arg_list_ptr		entry (ptr),
       84 	hcs_$chname_file		entry (char(*), char(*), char(*), char(*), fixed bin(35)),
       85 	hcs_$initiate		entry (char(*), char(*), char(*), fixed bin(1), fixed bin(2), ptr, fixed bin(35)),
       86 	hcs_$terminate_noname	entry (ptr, fixed bin(35)),
       87 	ioa_$ioa_stream		entry options (variable),
       88 	upd_add_task_		entry (char(*), ptr),
       89 	upd_free_name_		entry (char(*), char(*), fixed bin(35)),
       90 	upd_free_name_$restore	entry (char(*), char(*), fixed bin(35)),
       91 	installation_tools_$chname_file	entry (char(*), char(*), char(*), char(*), fixed bin(35)),
       92 	upd_print_err_		entry options (variable),
       93 	upd_print_names_		entry (ptr, fixed bin, bit(*)),
       94 	upd_status_		entry (char(*), char(*), fixed bin(1), ptr, ptr, fixed bin(35)),
       95 	upd_status_$long		entry (char(*), char(*), fixed bin(1), ptr, ptr, fixed bin(35)),
       96 	upd_task_err_		entry options (variable);
       97 
       98      dcl (addr, fixed, null, ptr)	builtin;
       99 
      100      dcl linkage_error		condition;
      101 
      102      dcl (error_table_$archive_fmt_err,
      103 	error_table_$namedup,
      104 	error_table_$nonamerr,
      105 	error_table_$not_done,
      106 	error_table_$oldnamerr,
      107 	error_table_$segknown,
      108 	error_table_$segnamedup,
      109 	error_table_$too_many_names,
      110 	error_table_$non_matching_uid,
      111 	error_table_$zero_length_seg)	ext fixed bin(35);
      112 
      113      dcl	aname			char(32) aligned,	/* name arg for archive_util_ */
      114 	entry (5)			char(32) int static init (
      115 				"upd_name_task_$list",
      116 				"upd_name_task_$list_archive",
      117 				"upd_name_task_$add",
      118 				"upd_name_task_$delete",
      119 				"upd_name_task_$free"),
      120 						/* name of entry which was called */
      121 	name			char(32) based (nmp),	/* for name changes */
      122 	name_array (n)		char(32) based (p);	/* temp name array (for status_, etc.) */
      123 
      124      dcl	msg (5)			char(15) aligned int static init ("Get names",
      125 				"Get comp names", "Add names", "Delete names", "Free names");
      126 
      127      dcl	argp			ptr,		/* arglist pointer */
      128 	cdp			ptr,		/* base pointer for "cd" */
      129 	cp			ptr,		/* control word pointer */
      130 	nmp			ptr,		/* base pointer for "name" */
      131          (p, q, r)			ptr,		/* random */
      132 	savep			ptr,		/* copy of archive pointer */
      133 	temp			ptr;		/* random */
      134 
      135      dcl	bc			fixed bin(24),	/* bitcount */
      136 	cc			fixed bin,	/* index for "call" vector */
      137 	cd			fixed bin(35) based (cdp),	/* status code overlaid on "names" element */
      138 	code			fixed bin(35),	/* random status code */
      139 	e			fixed bin,	/* entry switch */
      140          (i, j, n)			fixed bin,	/* random */
      141 	sev			fixed bin,	/* severity code for name change functions */
      142 	tcode			fixed bin(35);	/* status code */
      143 
      144      dcl	initsw			bit(1) aligned int static init ("0"b),	/* non-zero when "ctable" set up */
      145 	logsw			bit(1) aligned,	/* c.logsw | (c.errsw & asev ^= 0) */
      146 	rsw			bit(1) aligned,	/* copy of c.rsw */
      147 	runsw			bit(1) aligned,	/* c.runsw | c.trunsw */
      148 	sws			bit(2);		/* option bits for upd_print_names_ */
      149 
      150      dcl	area			area based (areap);	/* caller-supplied area */
      151 
      152      dcl	ctable (4)		fixed bin(35) int static,	/* used by name change functions */
      153 	stable (4, 4)		fixed bin int static init (	/* severity matrix to match */
      154 				1, 3, 2, 2,	/* segnamedup */
      155 				2, 3, 2, 2,	/* namedup */
      156 				3, 1, 2, 2,	/* oldnamerr */
      157 				3, 2, 2, 2);	/* nonamerr */
      158 
      159      dcl	1 c			aligned based (cp),	/* exploded control word */
      160 	 (2 rsw			bit(1),		/* non-zero if in reverse mode */
      161 	  2 tasksw		bit(1),		/* non-zero if to set up task */
      162 	  2 compsw		bit(1),		/* non-zero if compile-only task */
      163 	  2 runsw			bit(1),		/* non-zero if call to be processed immediately */
      164 	  2 trunsw		bit(1),		/* non-zero if subtask list to be processed */
      165 	  2 logsw			bit(1),		/* non-zero if in print mode */
      166 	  2 errsw			bit(1),		/* non-zero if to print error tasks only */
      167 	  2 briefsw		bit(1),		/* ignored */
      168 	  2 detailsw		bit(1),		/* non-zero if to list names when logsw is non-zero */
      169 	  2 clear_code_sw		bit(1),		/* non-zero if error codes in name list to be cleared */
      170 	  2 clear_uid_sw		bit(1)) unal;	/* non-zero if segment uid's to be cleared */
      171 
      172      dcl	1 names (n)		aligned based (np),	/* updater-format names array */
      173 	  2 name			char(32) unal,	/* fudge alignment for pl1 */
      174 	  2 pcode			fixed bin(35),	/* process code */
      175 	  2 rcode			fixed bin(35);	/* restore code */
      176 
      177      dcl	1 stat			aligned,		/* data structure for status_ */
      178 	 (2 type			bit(2),		/* entry type */
      179 	  2 nnames		bit(16),		/* number of names returned */
      180 	  2 nrp			bit(18),		/* rel pointer to name array */
      181 	  2 dtm			bit(36),		/* date/time modified */
      182 	  2 dtu			bit(36),		/* date/time used */
      183 	  2 mode			bit(5),		/* t, r, e, w, a */
      184 	  2 pad			bit(13),		/* unused */
      185 	  2 recs			bit(18),		/* pages used */
      186 	  2 dtd			bit(36),		/* date/time dumped */
      187 	  2 dtem			bit(36),		/* date/time entry modified */
      188 	  2 acct			bit(36),		/* accounting data */
      189 	  2 curlen		bit(12),		/* length of segment */
      190 	  2 bitcnt		bit(24),		/* bitcount of segment */
      191 	  2 did			bit(4),		/* device id */
      192 	  2 mdid			bit(4),		/* ? */
      193 	  2 copysw		bit(1),		/* segment copy switch */
      194 	  2 pad2			bit(9),		/* unused */
      195 	  2 rbs (0:2)		bit(6),		/* ring brackets */
      196 	  2 uid			bit(36)) unal;	/* unique id */
      197 
      198 
      199 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      200 
      201 
      202 list:		entry (ctlw, areap, parentp, acode, asev, taskp, seqno, dir, seg, msgseg, uid, np, nn);
      203 
      204 	if ctlw & "10000000011"b then			/* this entry doesn't run in "reverse" or */
      205 	     return;				/* "clear" modes */
      206 	e = 1;					/* set transfer vector index */
      207 	sws = "00"b;				/* don't want to interpret status codes when printing */
      208 	go to common;				/* join common code */
      209 
      210 
      211 list_archive:	entry (ctlw, areap, parentp, acode, asev, taskp, seqno, dir, seg, msgseg, uid, np, nn);
      212 
      213 	if ctlw & "10000000011"b then			/* this entry doesn't run in "reverse" or */
      214 	     return;				/* "clear" modes */
      215 	e = 2;					/* t.v. index */
      216 	sws = "00"b;				/* options for printing */
      217 	go to common;				/* skip */
      218 
      219 
      220 add:		entry (ctlw, areap, parentp, acode, asev, taskp, seqno, dir, seg, msgseg, uid, np, nn);
      221 
      222 	e = 3;					/* t.v. index */
      223 	sws = "11"b;				/* want to print everything */
      224 	go to common;				/* skip to common code */
      225 
      226 
      227 delete:		entry (ctlw, areap, parentp, acode, asev, taskp, seqno, dir, seg, msgseg, uid, np, nn);
      228 
      229 	e = 4;					/* transfer vector index */
      230 	sws = "11"b;				/* want it all */
      231 	go to common;				/* skip */
      232 
      233 
      234 free:		entry (ctlw, areap, parentp, acode, asev, taskp, seqno, dir, seg, msgseg, uid, np, nn);
      235 
      236 	e = 5;					/* set t.v. index */
      237 	sws = "11"b;				/* want status codes interpreted */
      238 
      239 common:	cp = addr (ctlw);				/* overlay control word with bit structure "c" */
      240 	if c.clear_uid_sw then			/* none of the entries runs in "clear uid" mode */
      241 	     return;
      242 	call cu_$arg_list_ptr (argp);			/* get arglist pointer */
      243 	rsw = c.rsw;				/* it gets used a lot */
      244 	logsw = c.logsw;				/* non-zero if printing */
      245 	if c.errsw then if asev = 0 then		/* errors only? */
      246 	     logsw = "0"b;				/* sure thing */
      247 	runsw = c.runsw | c.trunsw;			/* non-zero if processing */
      248 	if c.clear_code_sw then			/* clear error codes in name lists, if asked */
      249 	     if np ^= null then do i = 1 to nn;
      250 		names(i).pcode = error_table_$not_done;
      251 		names(i).rcode = 0;
      252 	    	end;
      253 
      254 	if c.tasksw then				/* is this a task call? */
      255 	     call upd_add_task_((entry(e)), argp);
      256 
      257 	if logsw then do;				/* are we talking to him? */
      258 	     if seg = msgseg then
      259 		call ioa_$ioa_stream ("installation_list_", "^5x^R^14a^B ^a>^a", (msg(e)), dir, seg);
      260 	     else
      261 		call ioa_$ioa_stream ("installation_list_", "^5x^R^14a^B ^a>^a  (^a)", (msg(e)), dir, seg, msgseg);
      262 	     if asev ^= 0 then			/* has an error occurred? */
      263 		call upd_print_err_(acode, asev);	/* yes, tell user */
      264 	     end;
      265 
      266 	if runsw then do;				/* are we to process it now? */
      267 	     if uid ^= ""b then do;			/* should we verify unique id? */
      268 		if e = 1 then			/* don't waste call to status_ */
      269 		     temp = areap;			/* if "list" function, get names also */
      270 		else				/* but don't waste effort either */
      271 		     temp = null;			/* any other function, skip the names */
      272 		call upd_status_$long (dir, seg, 1, addr (stat), temp, code);
      273 		if code = 0 then if uid ^= stat.uid then	/* does it match? */
      274 		     code = error_table_$non_matching_uid;	/* no, set error code */
      275 		if code ^= 0 then			/* did we get it? */
      276 		     go to error;			/* no, go complain */
      277 		end;
      278 	     go to lbl(e);				/* skip to proper function */
      279 	     end;
      280 
      281 prnames:	if logsw then				/* reentry after processing */
      282 	     if (c.detailsw | c.errsw) then		/* print names if user wants them */
      283 		call upd_print_names_(np, nn, sws);
      284 	return;					/* all done, exit */
      285 
      286 
      287 error:	if seg = msgseg then
      288 	     call upd_task_err_ (code, 3, argp, (entry(e)),
      289 		"^/Referencing ^R^a>^a^B .", dir, seg);
      290 	else
      291 	     call upd_task_err_ (code, 3, argp, (entry(e)),
      292 		"^/Referencing ^R^a>^a^B^/(^a>^a).", dir, seg, dir, msgseg);
      293 	return;					/* can't go no farther */
      294 
      295 
      296 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      297 
      298 
      299 lbl(1):	if np ^= null then				/* "list" function, see if already done */
      300 	     go to prnames;				/* yes, don't repeat */
      301 	if uid = ""b then do;			/* call status_ if we didn't */
      302 	     call upd_status_(dir, seg, 0, addr (stat), areap, code);
      303 	     if code ^= 0 then			/* error? */
      304 		go to error;			/* yes, skip */
      305 	     end;
      306 	n = fixed (stat.nnames);			/* get count of names returned */
      307 	p = ptr (areap, stat.nrp);			/* get pointer to name array */
      308 	go to common1;				/* join common code */
      309 
      310 
      311 lbl(2):	if np ^= null then				/* "list_archive" function, see if we did it */
      312 	     go to prnames;				/* yes, don't process again */
      313 	call hcs_$initiate (dir, seg, "", 0, 0, r, code);	/* initiate archive segment */
      314 	if code ^= 0 then if code ^= error_table_$segknown then
      315 	     go to error;				/* trouble, can't initiate it */
      316 	savep = r;				/* copy archive pointer; archive_util_ clobbers it */
      317 	call archive_util_$first_disected (r, q, aname, bc, code);	/* get name of first component */
      318 	if code ^= 0 then do;			/* something amiss? */
      319 	     if code = 1 then			/* archive_util_ has funny error codes */
      320 		code = error_table_$zero_length_seg;	/* fix it up for other people */
      321 	     else if code = 2 then			/* format error in archive */
      322 fmterr:		code = error_table_$archive_fmt_err;	/* get standard code for him too */
      323 acerr:	     call hcs_$terminate_noname (savep, tcode);	/* terminate archive segment, don't destroy code */
      324 	     go to error;				/* and go complain */
      325 	     end;
      326 	i = 1;					/* starting on first name */
      327 	n = 1000;					/* have to have a limit somewhere */
      328 	allocate name_array in (area);		/* get space to collect names */
      329 	go to next1;				/* join loop to insert first name */
      330 next:	call archive_util_$disected_element (r, q, aname, bc, code);	/* get next component */
      331 	if code = 0 then do;			/* got him */
      332 	     if i = 1000 then do;			/* hath our cup run over? */
      333 		if seg = msgseg then
      334 		     call upd_task_err_ (error_table_$too_many_names, 0, argp, (entry(e)),
      335 			"^/For ^R^a>^a^B^/only the first 1000 component names will be listed.", dir, seg);
      336 		else
      337 		     call upd_task_err_ (error_table_$too_many_names, 0, argp, (entry(e)),
      338 			"^/For ^R^a>^a^B^/(^a>^a)^/only the first 1000 component names will be listed.",
      339 			dir, seg, dir, msgseg);
      340 		go to last;			/* exit from loop */
      341 		end;
      342 	     i = i + 1;				/* still room, bump index */
      343 next1:	     name_array(i) = aname;			/* add name to list */
      344 	     go to next;				/* go get next one */
      345 	     end;
      346 	else if code = 1 then do;			/* end of archive reached */
      347 last:	     n = i;				/* set count of names found */
      348 	     call hcs_$terminate_noname (savep, code);	/* terminate archive segment */
      349 	     go to common1;				/* join common code */
      350 	     end;
      351 	else if code = 2 then			/* format error in archive */
      352 	     go to fmterr;				/* go get standard error code */
      353 	else					/* some other error */
      354 	     go to acerr;				/* go terminate seg and exit */
      355 
      356 common1:	allocate names in (area) set (q);		/* allocate updater-format names array */
      357 	do i = 1 to n;				/* copy names into it */
      358 	     q -> names(i).name = name_array(i);	/* the name */
      359 	     q -> names(i).pcode = error_table_$not_done;	/* initialize process code */
      360 	     q -> names(i).rcode = 0;			/* restore code */
      361 	     end;
      362 	free name_array in (area);			/* free temporary name array */
      363 	nn = n;					/* set array count */
      364 	np = q;					/* and pointer (pointer must be set last) */
      365 	go to prnames;				/* skip to common exit */
      366 
      367 
      368 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      369 
      370 
      371 lbl(3):	if ^rsw then				/* "add" function, select proper call */
      372 	     cc = 1;				/* adding name */
      373 	else					/* restore mode, */
      374 	     cc = 2;				/* removing name */
      375 	go to common2;				/* join common code */
      376 
      377 
      378 lbl(4):	if ^rsw then				/* "delete" function */
      379 	     cc = 2;				/* removing name */
      380 	else					/* restore mode, */
      381 	     cc = 1;				/* putting it back */
      382 	go to common2;				/* skip */
      383 
      384 
      385 lbl(5):	if ^rsw then				/* "free" function */
      386 	     cc = 3;				/* calling free_name */
      387 	else					/* restore mode */
      388 	     cc = 4;				/* restore_name */
      389 
      390 common2:	if ^initsw then do;				/* initialize int static error code table */
      391 	     ctable(1) = error_table_$segnamedup;
      392 	     ctable(2) = error_table_$namedup;
      393 	     ctable(3) = error_table_$oldnamerr;
      394 	     ctable(4) = error_table_$nonamerr;
      395 	     initsw = "1"b;				/* don't do it again */
      396 	     end;
      397 
      398 	on linkage_error begin;
      399 	     chname_file_entry = hcs_$chname_file;
      400 	     goto revert_linkage_error;
      401 	     end;
      402 	chname_file_entry = installation_tools_$chname_file;
      403 revert_linkage_error:
      404 	revert linkage_error;
      405 
      406 	do i = 1 to nn;				/* hardcore puts names on in right order now */
      407 	     if ^rsw then				/* select proper status code in names array */
      408 		cdp = addr (names(i).pcode);		/* "pcode" if in process mode */
      409 	     else
      410 		cdp = addr (names(i).rcode);		/* "rcode" if in restore mode */
      411 	     if cd ^= 0 then do;			/* if it hasn't been done yet, do it */
      412 		if ^rsw then			/* if processing, */
      413 		     names(i).rcode = error_table_$not_done;	/* initialize restore code */
      414 		else if names(i).pcode ^= 0 then	/* if in restore mode, must have processed it ok */
      415 		     go to skip;			/* skip this name if not */
      416 		nmp = addr (names(i).name);		/* get pointer to this name */
      417 		go to call(cc);			/* select proper call */
      418 call(1):		call chname_file_entry (dir, seg, "", name, cd);	/* adding name */
      419 		go to rejoin;
      420 call(2):		call chname_file_entry (dir, seg, name, "", cd);	/* removing name */
      421 		go to rejoin;
      422 call(3):		if i = 1 then			/* if this is the primary name of segment */
      423 		     call upd_free_name_(dir, name, cd); /* free name by renaming to backup name */
      424 		else				/* if not primary name, then		*/
      425 		     call chname_file_entry ( dir, seg, name, "", cd); /* delete the name */
      426 		go to rejoin;
      427 call(4):		if i = 1 then			/* if primary name, then reverse fxn is to rename it */
      428 		     call upd_free_name_$restore (dir, name, cd); /* inverse of upd_free_name_ */
      429 		else				/* otherwise, we have to put name back on seg */
      430 		     call chname_file_entry ( dir, seg, "", name, cd);
      431 rejoin:		if cd ^= 0 then do;			/* error? */
      432 		     do j = 1 to 4;			/* see if it's one we know about */
      433 			if cd = ctable(j) then do;	/* look up in table */
      434 			     sev = stable(j, cc);	/* found it, get severity code */
      435 			     go to err;		/* skip */
      436 			     end;
      437 			end;
      438 		     sev = 3;			/* unknown error, severity 3 */
      439 err:		     if seg = msgseg then
      440 			call upd_task_err_ (cd, sev, argp, (entry(e)),
      441 			     "^R^a^B^/Referencing ^R^a>^a^B .", name, dir, seg);
      442 		     else
      443 			call upd_task_err_ (cd, sev, argp, (entry(e)),
      444 			     "^R^a^R^/Referencing ^R^a>^a^B^/(^a>^a).", name, dir, seg, dir, msgseg);
      445 		     end;
      446 		else if rsw then			/* successful restore, reinitialize process code */
      447 		     names(i).pcode = error_table_$not_done;	/* so we can repeat task if desired */
      448 skip:		end;				/* here if restore skipped */
      449 	     end;
      450 
      451 	go to prnames;				/* done, go to common exit */
      452 
      453 
      454 	end upd_name_task_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1514.4  upd_name_task_.pl1                >dumps>old>recomp>upd_name_task_.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
acode                                  parameter       fixed bin(35,0)          dcl 66 set ref 202 211 220 227 234 262*
addr                                                   builtin function         dcl 98 ref 239 272 272 302 302 407 409 416
aname                           000112 automatic       char(32)                 dcl 113 set ref 317* 330* 343
archive_util_$disected_element  000022 constant        entry                    external dcl 80 ref 330
archive_util_$first_disected    000024 constant        entry                    external dcl 80 ref 317
area                                   based           area(1024)               dcl 150 ref 328 356 362
areap                                  parameter       pointer                  dcl 66 set ref 202 211 220 227 234 268 302* 307 328
                                                                                  356 362
argp                            000122 automatic       pointer                  dcl 127 set ref 242* 254* 287* 290* 333* 336* 439*
                                                                                  442*
asev                                   parameter       fixed bin(17,0)          dcl 66 set ref 202 211 220 227 234 245 262 262*
bc                              000144 automatic       fixed bin(24,0)          dcl 135 set ref 317* 330*
c                                      based           structure                level 1 dcl 159
cc                              000145 automatic       fixed bin(17,0)          dcl 135 set ref 371* 373* 378* 380* 385* 387* 417
                                                                                  434
cd                                     based           fixed bin(35,0)          dcl 135 set ref 411 418* 420* 422* 424* 427* 429*
                                                                                  431 433 439* 442*
cdp                             000124 automatic       pointer                  dcl 127 set ref 407* 409* 411 418 420 422 424 427
                                                                                  429 431 433 439 442
chname_file_entry               000100 automatic       entry variable           dcl 80 set ref 399* 402* 418 420 424 429
clear_code_sw             0(09)        based           bit(1)                   level 2 packed unaligned dcl 159 ref 248
clear_uid_sw              0(10)        based           bit(1)                   level 2 packed unaligned dcl 159 ref 240
code                            000146 automatic       fixed bin(35,0)          dcl 135 set ref 272* 273 273* 275 287* 290* 302* 303
                                                                                  313* 314 314 317* 318 319 319* 321 321* 330* 331
                                                                                  346 348* 351
cp                              000126 automatic       pointer                  dcl 127 set ref 239* 240 243 244 245 247 247 248 254
                                                                                  281 281
ctable                          000011 internal static fixed bin(35,0)          array dcl 152 set ref 391* 392* 393* 394* 433
ctlw                                   parameter       bit(36)                  dcl 66 set ref 202 204 211 213 220 227 234 239
cu_$arg_list_ptr                000026 constant        entry                    external dcl 80 ref 242
detailsw                  0(08)        based           bit(1)                   level 2 packed unaligned dcl 159 ref 281
dir                                    parameter       char(168)                unaligned dcl 66 set ref 202 211 220 227 234 258*
                                                                                  260* 272* 287* 290* 290* 302* 313* 333* 336* 336*
                                                                                  418* 420* 422* 424* 427* 429* 439* 442* 442*
e                               000147 automatic       fixed bin(17,0)          dcl 135 set ref 206* 215* 222* 229* 236* 254 258 260
                                                                                  268 278 287 290 333 336 439 442
entry                           000055 constant        char(32)                 initial array unaligned dcl 113 ref 254 287 290 333
                                                                                  336 439 442
error_table_$archive_fmt_err    000062 external static fixed bin(35,0)          dcl 102 ref 321
error_table_$namedup            000064 external static fixed bin(35,0)          dcl 102 ref 392
error_table_$non_matching_uid   000102 external static fixed bin(35,0)          dcl 102 ref 273
error_table_$nonamerr           000066 external static fixed bin(35,0)          dcl 102 ref 394
error_table_$not_done           000070 external static fixed bin(35,0)          dcl 102 ref 250 359 412 446
error_table_$oldnamerr          000072 external static fixed bin(35,0)          dcl 102 ref 393
error_table_$segknown           000074 external static fixed bin(35,0)          dcl 102 ref 314
error_table_$segnamedup         000076 external static fixed bin(35,0)          dcl 102 ref 391
error_table_$too_many_names     000100 external static fixed bin(35,0)          dcl 102 set ref 333* 336*
error_table_$zero_length_seg    000104 external static fixed bin(35,0)          dcl 102 ref 319
errsw                     0(06)        based           bit(1)                   level 2 packed unaligned dcl 159 ref 245 281
fixed                                                  builtin function         dcl 98 ref 306
hcs_$chname_file                000030 constant        entry                    external dcl 80 ref 399
hcs_$initiate                   000032 constant        entry                    external dcl 80 ref 313
hcs_$terminate_noname           000034 constant        entry                    external dcl 80 ref 323 348
i                               000150 automatic       fixed bin(17,0)          dcl 135 set ref 248* 250 251* 326* 332 342* 342 343
                                                                                  347 357* 358 358 359 360* 406* 407 409 412 414 416
                                                                                  422 427 446*
initsw                          000010 internal static bit(1)                   initial dcl 144 set ref 390 395*
installation_tools_$chname_file 000046 constant        entry                    external dcl 80 ref 402
ioa_$ioa_stream                 000036 constant        entry                    external dcl 80 ref 258 260
j                               000151 automatic       fixed bin(17,0)          dcl 135 set ref 432* 433 434*
linkage_error                   000104 stack reference condition                dcl 100 ref 398 403
logsw                           000155 automatic       bit(1)                   dcl 144 in procedure "upd_name_task_" set ref 244*
                                                                                  245* 257 281
logsw                     0(05)        based           bit(1)                   level 2 in structure "c" packed unaligned dcl 159
                                                                                  in procedure "upd_name_task_" ref 244
msg                             000031 constant        char(15)                 initial array dcl 124 ref 258 260
msgseg                                 parameter       char(32)                 unaligned dcl 66 set ref 202 211 220 227 234 258
                                                                                  260* 287 290* 333 336* 439 442*
n                               000152 automatic       fixed bin(17,0)          dcl 135 set ref 306* 327* 328 347* 356 357 362 363
name                                   based           char(32)                 array level 2 in structure "names" packed unaligned
                                                                                  dcl 172 in procedure "upd_name_task_" set ref 358*
                                                                                  416
name                                   based           char(32)                 unaligned dcl 113 in procedure "upd_name_task_" set
                                                                                  ref 418* 420* 422* 424* 427* 429* 439* 442*
name_array                             based           char(32)                 array unaligned dcl 113 set ref 328 343* 358 362
names                                  based           structure                array level 1 dcl 172 set ref 356
nmp                             000130 automatic       pointer                  dcl 127 set ref 416* 418 420 422 424 427 429 439 442
nn                                     parameter       fixed bin(17,0)          dcl 66 set ref 202 211 220 227 234 248 281* 363* 406
nnames                    0(02) 000161 automatic       bit(16)                  level 2 packed unaligned dcl 177 set ref 306
np                                     parameter       pointer                  dcl 66 set ref 202 211 220 227 234 248 250 251 281*
                                                                                  299 311 364* 407 409 412 414 416 446
nrp                       0(18) 000161 automatic       bit(18)                  level 2 packed unaligned dcl 177 set ref 307
null                                                   builtin function         dcl 98 ref 248 270 299 311
p                               000132 automatic       pointer                  dcl 127 set ref 307* 328* 343 358 362
parentp                                parameter       pointer                  dcl 66 ref 202 211 220 227 234
pcode                    10            based           fixed bin(35,0)          array level 2 dcl 172 set ref 250* 359* 407 414 446*
ptr                                                    builtin function         dcl 98 ref 307
q                               000134 automatic       pointer                  dcl 127 set ref 317* 330* 356* 358 359 360 364
r                               000136 automatic       pointer                  dcl 127 set ref 313* 316 317* 330*
rcode                    11            based           fixed bin(35,0)          array level 2 dcl 172 set ref 251* 360* 409 412*
rsw                             000156 automatic       bit(1)                   dcl 144 in procedure "upd_name_task_" set ref 243*
                                                                                  371 378 385 407 412 446
rsw                                    based           bit(1)                   level 2 in structure "c" packed unaligned dcl 159
                                                                                  in procedure "upd_name_task_" ref 243
runsw                     0(03)        based           bit(1)                   level 2 in structure "c" packed unaligned dcl 159
                                                                                  in procedure "upd_name_task_" ref 247
runsw                           000157 automatic       bit(1)                   dcl 144 in procedure "upd_name_task_" set ref 247*
                                                                                  266
savep                           000140 automatic       pointer                  dcl 127 set ref 316* 323* 348*
seg                                    parameter       char(32)                 unaligned dcl 66 set ref 202 211 220 227 234 258
                                                                                  258* 260* 272* 287 287* 290* 302* 313* 333 333*
                                                                                  336* 418* 420* 424* 429* 439 439* 442*
seqno                                  parameter       fixed bin(17,0)          dcl 66 ref 202 211 220 227 234
sev                             000153 automatic       fixed bin(17,0)          dcl 135 set ref 434* 438* 439* 442*
stable                          000011 constant        fixed bin(17,0)          initial array dcl 152 ref 434
stat                            000161 automatic       structure                level 1 dcl 177 set ref 272 272 302 302
sws                             000160 automatic       bit(2)                   unaligned dcl 144 set ref 207* 216* 223* 230* 237*
                                                                                  281*
taskp                                  parameter       pointer                  dcl 66 ref 202 211 220 227 234
tasksw                    0(01)        based           bit(1)                   level 2 packed unaligned dcl 159 ref 254
tcode                           000154 automatic       fixed bin(35,0)          dcl 135 set ref 323*
temp                            000142 automatic       pointer                  dcl 127 set ref 268* 270* 272*
trunsw                    0(04)        based           bit(1)                   level 2 packed unaligned dcl 159 ref 247
uid                                    parameter       bit(36)                  dcl 66 in procedure "upd_name_task_" ref 202 211 220
                                                                                  227 234 267 273 301
uid                      11     000161 automatic       bit(36)                  level 2 in structure "stat" packed unaligned dcl 177
                                                                                  in procedure "upd_name_task_" set ref 273
upd_add_task_                   000040 constant        entry                    external dcl 80 ref 254
upd_free_name_                  000042 constant        entry                    external dcl 80 ref 422
upd_free_name_$restore          000044 constant        entry                    external dcl 80 ref 427
upd_print_err_                  000050 constant        entry                    external dcl 80 ref 262
upd_print_names_                000052 constant        entry                    external dcl 80 ref 281
upd_status_                     000054 constant        entry                    external dcl 80 ref 302
upd_status_$long                000056 constant        entry                    external dcl 80 ref 272
upd_task_err_                   000060 constant        entry                    external dcl 80 ref 287 290 333 336 439 442

NAMES DECLARED BY EXPLICIT CONTEXT.
acerr                           001431 constant        label                    dcl 323 ref 353
add                             000370 constant        entry                    external dcl 220
call                            000005 constant        label                    array(4) dcl 418 ref 417
common                          000431 constant        label                    dcl 239 ref 208 217 224 231
common1                         001714 constant        label                    dcl 356 ref 308 349
common2                         002046 constant        label                    dcl 390 ref 375 382
delete                          000404 constant        entry                    external dcl 227
err                             002440 constant        label                    dcl 439 ref 435
error                           001063 constant        label                    dcl 287 ref 275 303 314 324
fmterr                          001426 constant        label                    dcl 321 ref 351
free                            000420 constant        entry                    external dcl 234
last                            001675 constant        label                    dcl 347 ref 340
lbl                             000000 constant        label                    array(5) dcl 299 ref 278
list                            000331 constant        entry                    external dcl 202
list_archive                    000350 constant        entry                    external dcl 211
next                            001471 constant        label                    dcl 330 ref 344
next1                           001663 constant        label                    dcl 343 ref 329
prnames                         001033 constant        label                    dcl 281 ref 299 311 365 451
rejoin                          002412 constant        label                    dcl 431 ref 419 421 426
revert_linkage_error            002114 constant        label                    dcl 403 ref 400
skip                            002624 constant        label                    dcl 448 ref 414
upd_name_task_                  000312 constant        entry                    external dcl 11

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3226        3334    2633        3236
Length      3602    2633       106         232     373           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
upd_name_task_                      312 external procedure  is an external procedure.  
on unit on line 398                  64 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 initsw                      upd_name_task_
000011 ctable                      upd_name_task_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
upd_name_task_           000100 chname_file_entry           upd_name_task_
                         000112 aname                       upd_name_task_
                         000122 argp                        upd_name_task_
                         000124 cdp                         upd_name_task_
                         000126 cp                          upd_name_task_
                         000130 nmp                         upd_name_task_
                         000132 p                           upd_name_task_
                         000134 q                           upd_name_task_
                         000136 r                           upd_name_task_
                         000140 savep                       upd_name_task_
                         000142 temp                        upd_name_task_
                         000144 bc                          upd_name_task_
                         000145 cc                          upd_name_task_
                         000146 code                        upd_name_task_
                         000147 e                           upd_name_task_
                         000150 i                           upd_name_task_
                         000151 j                           upd_name_task_
                         000152 n                           upd_name_task_
                         000153 sev                         upd_name_task_
                         000154 tcode                       upd_name_task_
                         000155 logsw                       upd_name_task_
                         000156 rsw                         upd_name_task_
                         000157 runsw                       upd_name_task_
                         000160 sws                         upd_name_task_
                         000161 stat                        upd_name_task_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_var_desc       call_ext_out_desc   call_ext_out        return              tra_ext             enable
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
archive_util_$disected_element                              archive_util_$first_disected  cu_$arg_list_ptr
freen_                        hcs_$chname_file              hcs_$initiate                 hcs_$terminate_noname
installation_tools_$chname_file                             ioa_$ioa_stream               smart_alloc_
upd_add_task_                 upd_free_name_                upd_free_name_$restore        upd_print_err_
upd_print_names_              upd_status_                   upd_status_$long              upd_task_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$archive_fmt_err  error_table_$namedup          error_table_$non_matching_uid error_table_$nonamerr
error_table_$not_done         error_table_$oldnamerr        error_table_$segknown         error_table_$segnamedup
error_table_$too_many_names   error_table_$zero_length_seg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000311       202 000317       204 000336       206 000342       207 000344       208 000345       211 000346
    213 000355       215 000361       216 000363       217 000365       220 000366       222 000375       223 000377
    224 000401       227 000402       229 000411       230 000413       231 000415       234 000416       236 000425
    237 000427       239 000431       240 000434       242 000437       243 000446       244 000451       245 000455
    247 000464       248 000475       250 000514       251 000524       252 000525       254 000527       257 000555
    258 000557       260 000642       262 000720       266 000740       267 000742       268 000745       270 000754
    272 000756       273 001016       275 001027       278 001031       281 001033       284 001062       287 001063
    290 001147       293 001231       299 001232       301 001237       302 001241       303 001300       306 001302
    307 001306       308 001315       311 001316       313 001323       314 001366       316 001373       317 001375
    318 001414       319 001416       321 001424       323 001431       324 001442       326 001443       327 001445
    328 001447       329 001470       330 001471       331 001510       332 001512       333 001515       336 001600
    340 001661       342 001662       343 001663       344 001672       346 001673       347 001675       348 001677
    349 001710       351 001711       353 001713       356 001714       357 001736       358 001745       359 001760
    360 001764       361 001765       362 001767       363 002011       364 002014       365 002016       371 002017
    373 002024       375 002026       378 002027       380 002034       382 002036       385 002037       387 002044
    390 002046       391 002051       392 002053       393 002055       394 002057       395 002061       398 002063
    399 002077       400 002104       402 002107       403 002114       406 002115       407 002125       409 002140
    411 002146       412 002150       414 002163       416 002171       417 002177       418 002201       419 002230
    420 002231       421 002260       422 002261       424 002306       426 002335       427 002336       429 002363
    431 002412       432 002414       433 002421       434 002426       435 002433       437 002434       438 002436
    439 002440       442 002525       445 002610       446 002611       449 002624       451 002626


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
