	COMPILATION LISTING OF SEGMENT mc_trace
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1636.7 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 mc_trace: mct: proc;
       12 
       13 /* mc_trace - machine condition trace, initially coded March 1977 by James A. Bush
       14*   taken from original idea by Bernie Greenberg and Steve Webber
       15*   Modified 780327 by J. A. Bush to add -all and -hc control args
       16*   Modified Oct 1982 by Rich Coppola to disable tracing when displaying
       17*   MCs or hregs. Also corrected hreg headers when hregs are from a DPS8 CPU.
       18**/
       19 
       20 
       21 dcl  cu_$cp entry (ptr, fixed bin, fixed bin (35));
       22 dcl  cu_$arg_count entry (fixed bin);
       23 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
       24 dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
       25 dcl  phcs_$trace_buffer_init entry (ptr, bit (1) aligned, fixed bin, ptr, fixed bin (35));
       26 dcl  phcs_$hc_trace_on_off entry (bit (1) aligned, fixed bin (35));
       27 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
       28 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
       29 dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
       30 dcl (ioa_, com_err_, ioa_$ioa_switch, ioa_$ioa_switch_nnl) entry options (variable);
       31 dcl  iox_$get_line entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
       32 dcl  prtscu_$on_line entry (ptr, ptr, bit (1));
       33 dcl  dump_machine_cond_$mc_only entry (ptr, char (32));
       34 dcl  get_line_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin);
       35 dcl  find_condition_info_ entry (ptr, ptr, fixed bin (35));
       36 dcl  ring0_get_$segptr entry (char (*), char (*), ptr, fixed bin (35));
       37 dcl  ring0_get_$name entry (char (*), char (*), ptr, fixed bin (35));
       38 dcl  continue_to_signal_ entry (fixed bin (35));
       39 dcl  hran_$hrlgnd entry (ptr);
       40 dcl  hran_$hranl entry (ptr, ptr, bit (1));
       41 
       42 dcl (null, fixed, addr, addrel, divide, baseno, baseptr, length, substr, rel, ltrim, search) builtin;
       43 
       44 dcl (iox_$user_input, iox_$error_output) ptr ext;
       45 dcl (any_other, cleanup) condition;
       46 dcl  dir_name char (168);
       47 dcl  ename char (32);
       48 dcl  com_string char (132) aligned;
       49 dcl  arg char (al) based (ap);
       50 dcl (code, lp_cnt) fixed bin (35);
       51 dcl (i, j, k, acnt, al, lp) fixed bin;
       52 dcl (ap, sp, mcp, scup) ptr;
       53 dcl  mc_pos (260) fixed bin unaligned;
       54 dcl  p_name char (8) init ("mc_trace");
       55 dcl  ll fixed bin (21);
       56 dcl  buf_size fixed bin init (5);			/* default buffer size */
       57 dcl (trace_on, brief, lo, path_sw, buf_sw, hc_all, hc_sw) bit (1) unaligned init ("0"b);
       58 dcl  WS char (2) int static options (constant) init (" 	");
       59 
       60 
  1     1 
  1     2 /* Begin include file mc_trace_buf.incl.pl1 */
  1     3 
  1     4 /* Created in April 1977 by James A. Bush to define the contents of the machine condition trace buffer */
  1     5 
  1     6 dcl  bp ptr;					/* pointer to M. C. buffer */
  1     7 
  1     8 dcl 1 mc_trace_buf based (bp) aligned,			/* trace buffer template */
  1     9     2 mc_lim fixed bin unal,				/* end of machine condition storage area */
  1    10     2 mc_nxtad fixed bin unal,			/* the nxt avail. location for M. C. storage */
  1    11     2 mc_strt fixed bin unal,				/* the beginning of the M. C. storage area */
  1    12     2 mc_cnt fixed bin unal,				/* number of M. C.'s that can be stored */
  1    13     2 hr_lim fixed bin unal,				/* end of history register storage */
  1    14     2 hr_nxtad fixed bin unal,			/* the nxt avail. location for history register storage */
  1    15     2 hr_strt fixed bin unal,				/* the beginning of the H. R. storage area */
  1    16     2 hr_cnt fixed bin unal,				/* number of H. R.'s that can be stored */
  1    17     2 pad (4) fixed bin,				/* pad to start of history register area */
  1    18     2 h_regs (hr_cnt),				/* array of history register blocks */
  1    19       3 ou_hr (16) bit (72),				/* operations unit history registers */
  1    20       3 cu_hr (16) bit (72),				/* control unit history registers */
  1    21       3 du_hr (16) bit (72),				/* decimal unit history registers */
  1    22       3 au_hr (16) bit (72),				/* appending unit history registers */
  1    23     2 mach_cond (mc_cnt),				/* array of machine conditions */
  1    24       3 spri_dta (8) ptr,				/* pointer register storage */
  1    25       3 sreg_dta (8) bit (36),			/* processor register storage */
  1    26       3 scu_dta (8) bit (36),				/* SCU data  storage */
  1    27       3 sw_dta (8) bit (36),				/* software data storage */
  1    28       3 spl_dta (8) bit (36);				/* EIS ptrs and lengths data */
  1    29 
  1    30 dcl  mc_size fixed bin int static options (constant) init (48); /* size of M. C. block in words */
  1    31 dcl  hr_size fixed bin int static options (constant) init (128); /* size of history register block */
  1    32 dcl  max_buf_size fixed bin int static options (constant) init (16); /* max size of M. C. buffer in K */
  1    33 dcl  buf_init bit (36) int static options (constant) init ("525252525252"b3); /* buffer init. constant */
  1    34 
  1    35 /* End include file mc_trace_buf.incl.pl1 */
  1    36 
       61 
       62 
       63 /*  */
       64 
       65 /* process arguments */
       66 
       67 	call cu_$arg_count (acnt);			/* get no of args */
       68 	if acnt = 0 then do;			/* tell user what to do */
       69 arger:
       70 	     call com_err_ (0, p_name, "Usage: ^a path {-brief | -bf} {-buffer <size> | -buf <size>}", p_name);
       71 	     return;
       72 	end;
       73 	do i = 1 to acnt;				/* process arguments */
       74 	     call cu_$arg_ptr (i, ap, al, code);	/* get arg */
       75 	     if code ^= 0 then do;			/* some days you can't win */
       76 		call com_err_ (code, p_name, "getting arg");
       77 		return;
       78 	     end;
       79 	     if arg = "-all" | arg = "-hc" then do;	/* if special trace */
       80 		hc_all, path_sw = "1"b;
       81 		if arg = "-all" then		/* if tracing all faults and interrupts */
       82 		     sp = baseptr (0);		/* set indicator for hardcore */
       83 		else hc_sw = "1"b;			/* tracing hardcore seg */
       84 	     end;
       85 	     else if ^path_sw then do;		/* if not special trace, pathname arg must be first */
       86 		path_sw = "1"b;
       87 		call expand_pathname_ (arg, dir_name, ename, code);
       88 		if code ^= 0 then do;		/* some problem with pathname */
       89 		     call com_err_ (code, p_name, "expanding pathname ^a", arg);
       90 		     return;
       91 		end;
       92 	     end;
       93 	     else if hc_sw then do;			/* user wants to trace hard core seg */
       94 		hc_sw = "0"b;
       95 		lp_cnt = cv_oct_check_ (arg, code);	/* convert to seg number */
       96 		if code ^= 0 then do;		/* might be name */
       97 		     call ring0_get_$segptr ("", arg, sp, code);
       98 		     if code ^= 0 then do;		/* user got something wrong */
       99 			call com_err_ (code, p_name, "getting hardcore segment ^a", arg);
      100 			return;			/* let him re-enter */
      101 		     end;
      102 		end;
      103 		else do;				/* user entered number, verify */
      104 		     sp = baseptr (lp_cnt);		/* that it is a valid hc seg */
      105 		     call ring0_get_$name ("", ename, sp, code);
      106 		     if code ^= 0 then do;		/* not a valid hc seg */
      107 			call com_err_ (code, p_name, "getting hardcore segment ^o", lp_cnt);
      108 			return;			/* return and make him get it right */
      109 		     end;
      110 		end;
      111 		if fixed (baseno (sp)) = 0 then	/* tracing dseg will get all faults and ints. */
      112 		     call com_err_ (0, p_name, "Warning tracing segment # 0 will result in tracing all faults and interrupts");
      113 	     end;
      114 	     else if buf_sw then do;			/* got buffer size arg */
      115 		buf_sw = "0"b;			/* don't want to come here again */
      116 		lp_cnt = cv_dec_check_ (arg, code);
      117 		buf_size = lp_cnt;
      118 		if code ^= 0 | buf_size > max_buf_size | buf_size <= 0 then do; /* user goofed */
      119 		     call com_err_ (0, p_name, "buffer size arg ^a invalid or too big", arg);
      120 		     return;
      121 		end;
      122 	     end;
      123 	     else if arg = "-buffer" | arg = "-buf" then	/* user wants a bigger buffer */
      124 		buf_sw = "1"b;
      125 	     else if arg = "-brief" | arg = "-bf" then	/* user does not want prompt */
      126 		brief = "1"b;			/* set brief switch */
      127 	     else do;
      128 		call com_err_ (0, p_name, "Invalid argument ^a", arg);
      129 		go to arger;
      130 	     end;
      131 	end;
      132 
      133 
      134 /* initiate object segment to trace */
      135 
      136 	if ^hc_all then do;				/*  if ring 4 segment to be traced */
      137 	     call hcs_$initiate (dir_name, ename, "", 0, 0, sp, code);
      138 	     if sp = null then do;			/* can't find it */
      139 		call com_err_ (code, p_name, "initiating object segment ^a>^a", dir_name, ename);
      140 		return;
      141 	     end;
      142 	end;
      143 
      144 /* Now we are ready to start the hardcore trace */
      145 
      146 	call phcs_$trace_buffer_init (sp, "1"b, buf_size, bp, code);
      147 	if code ^= 0 then do;			/* must have had problem starting trace */
      148 	     call com_err_ (code, p_name, "attempting to initialize hardcore tracing");
      149 	     return;
      150 	end;
      151 	trace_on = "1"b;				/* set switch to indicate we are traceing */
      152 
      153 	on any_other begin;
      154 	     call cond_hand;			/* set up condition handler */
      155 	     call phcs_$hc_trace_on_off ("0"b, code);	/* turn off hardcore tracing mechanism */
      156 	end;
      157 
      158 	on cleanup call clean;			/* set up condition handler for cleanup condition */
      159 
      160 /* Now we are ready to ask user for input to trace something */
      161 
      162 request:
      163 	com_string = "";				/* clear out last command */
      164 	if ^brief then				/*  if not in brief mode */
      165 	     call ioa_$ioa_switch_nnl (iox_$error_output, "--> "); /* print out prompt for user */
      166 	call iox_$get_line (iox_$user_input, addr (com_string), length (com_string), ll, code);
      167 	if code ^= 0 then do;			/* error reading from  terminal */
      168 	     call com_err_ (code, p_name, "reading input from user_input");
      169 	     go to request;
      170 	end;
      171 	ll = ll - 1;				/* adjust line length to ignor the N. L. char */
      172 	if ll = 0 then go to request;			/* ignor white space */
      173 
      174 /* strip off leading white space */
      175 
      176 	i = length (ltrim (substr (com_string, 1, ll), WS));
      177 	j = (ll - i) + 1;				/* get start of good data */
      178 	substr (com_string, 1, i) = substr (com_string, j, ll);
      179 	substr (com_string, i + 1) = "";		/* pad rest of line with blanks */
      180 
      181 /* Process requests */
      182 
      183 	if substr (com_string, 1, 1) ^= "." then do;	/* user made syntax error */
      184 errsp:
      185 	     call com_err_ (0, p_name, "Invalid response ^a, reenter", com_string);
      186 	     go to request;
      187 	end;
      188 	ll = i;					/* copy new line length */
      189 	if ll = 1 then				/* user wants to know where he is at */
      190 	     call ioa_ ("^a", p_name);		/* so tell him */
      191 	else if substr (com_string, 1, ll) = ".q" then do; /* user wants to quit */
      192 	     call clean;				/* clean up */
      193 	     return;
      194 	end;					/* and exit */
      195 	else if substr (com_string, 1, 2) = ".." then do; /* user wants to execute Multics cmd */
      196 	     substr (com_string, 1, ll - 2) = substr (com_string, 3, ll - 2); /* adjust cmd in buffer */
      197 	     call phcs_$hc_trace_on_off ("1"b, code);	/* turn on hardcore tracing mechanism */
      198 	     if code ^= 0 then do;			/* can't turn trace on */
      199 		call com_err_ (code, p_name, "attempting to turn trace on");
      200 		go to request;
      201 	     end;
      202 	     call cu_$cp (addr (com_string), ll - 2, code); /* and execute cmd */
      203 	     call phcs_$hc_trace_on_off ("0"b, code);	/* turn off hardcore tracing mechanism */
      204 	end;
      205 	else if substr (com_string, 1, 4) = ".rpt" then do; /* user wants to repeat cmd */
      206 	     lp = 5;				/* set line position */
      207 	     lp_cnt = parse ();			/* get the loop count arg */
      208 	     if lp_cnt = -1 then			/* user goofed typing in */
      209 		go to errsp;
      210 	     j = ll - lp + 1;
      211 	     substr (com_string, 1, j) = substr (com_string, lp, j); /* adjust cmd */
      212 	     call phcs_$hc_trace_on_off ("1"b, code);	/* turn on hardcore tracing mechanism */
      213 	     if code ^= 0 then do;			/* can't turn trace on */
      214 		call com_err_ (code, p_name, "attempting to turn trace on");
      215 		go to request;
      216 	     end;
      217 	     do i = 1 to lp_cnt;			/* execute cmd requested number of times */
      218 		call cu_$cp (addr (com_string), j, code);
      219 	     end;
      220 	     call phcs_$hc_trace_on_off ("0"b, code);	/* turn off hardcore tracing mechanism */
      221 	end;
      222 	else if substr (com_string, 1, 5) = ".pmc " then	/* user wants to print M. C. */
      223 	     call display_mc (5, 1);			/* display M. C. in octal */
      224 	else if substr (com_string, 1, 5) = ".pmci" then	/* user wants interpreted M. C. */
      225 	     call display_mc (6, 2);			/* display M. C. interpreted */
      226 	else if substr (com_string, 1, 5) = ".pscu" then	/* user wants only scu data */
      227 	     call display_mc (6, 3);			/* Display M. C. scu data only */
      228 	else if substr (com_string, 1, 4) = ".hr " then	/* User wants to see history regs in octal */
      229 	     call display_hregs (4, 1, "1"b);		/* display all history regs */
      230 	else if substr (com_string, 1, 5) = ".hrou" then	/* user wants only OU history regs */
      231 	     call display_hregs (6, 1, "0"b);
      232 	else if substr (com_string, 1, 5) = ".hrcu" then	/* user only wants to see CU histroy regs */
      233 	     call display_hregs (6, 2, "0"b);
      234 	else if substr (com_string, 1, 5) = ".hrdu" then	/* user wants to see DU history regs */
      235 	     call display_hregs (6, 3, "0"b);
      236 	else if substr (com_string, 1, 5) = ".hrau" then	/* user wants to see APU History regs */
      237 	     call display_hregs (6, 4, "0"b);
      238 	else if substr (com_string, 1, 6) = ".hranl" then /* user wants analisis of history regs */
      239 	     call display_hregs (7, 5, "0"b);
      240 	else if substr (com_string, 1, 6) = ".hrlgd" then do; /* user wants to know what abrevs mean */
      241 	     call ioa_ ("^/Abbreviations used in History Register Analysis^/");
      242 	     call hran_$hrlgnd (null);
      243 	end;
      244 	else go to errsp;				/* invalid request */
      245 	go to request;				/* get nxt request */
      246 
      247 
      248 /* display_mc - internal procedure to display requested number of Machine Conditions from the M. C. buffer */
      249 
      250 display_mc: proc (line_pos, type);
      251 dcl (line_pos, type, count, limit) fixed bin;
      252 
      253 	     call phcs_$hc_trace_on_off ("0"b, code);	/* turn off hardcore tracing mechanism */
      254 
      255 	     j = mc_trace_buf.mc_nxtad;		/* start with next avail location */
      256 	     if j = mc_trace_buf.mc_strt then		/* if at beginning of buffer */
      257 		if mach_cond (1).scu_dta (1) = buf_init then do; /* no M. C. stored */
      258 		     call ioa_ ("Machine Condition buffer empty");
      259 		     return;
      260 		end;
      261 	     call get_args (line_pos, count, limit);	/* get further args */
      262 	     if count = 0 then			/* No args set count to display entire buffer */
      263 		count = mc_trace_buf.mc_cnt;
      264 
      265 /* first get cronilogical order of M. C.'s, last to first */
      266 	     do i = 1 to count;			/* get each requested M. C. */
      267 		if j = mc_trace_buf.mc_strt then	/* if at beginning of buffer */
      268 		     j = (mc_cnt - 1) * mc_size + mc_trace_buf.mc_strt; /* set to last M. C. */
      269 		else j = j - mc_size;		/* just decrement to nxt M. C. */
      270 		k = divide ((j + mc_size) - mc_trace_buf.mc_strt, mc_size, 17, 0); /* get array index */
      271 		if mach_cond (k).scu_dta (1) ^= buf_init then mc_pos (i) = k; /* if M. C. valid */
      272 		else go to too_many;		/* if not valid, exit */
      273 	     end;
      274 too_many:
      275 	     if i - 1 ^= count then do;		/* if not all requested M. C.'s valid */
      276 		call ioa_ ("Only ^d sets of Machine Conditions are valid", i - 1);
      277 		count = i - 1;			/* adjust count */
      278 	     end;
      279 	     call set_line_length;			/* set up output length parameters */
      280 	     if limit = 0 | limit > count then		/* set up defaults */
      281 		limit = 1;
      282 	     else limit = count - (limit - 1);
      283 	     do i = count to limit by -1;		/* this  is really forward */
      284 		j = mc_pos (i);
      285 		mcp = addr (mc_trace_buf.mach_cond (j)); /* form ptr to machine condition */
      286 		call ioa_ ("^/^/*****Machine Conditions at mc_trace_buffer|^o*****",
      287 		     fixed (rel (mcp)));
      288 		go to mc_prt (type);		/* print  M. C.'s in requested form */
      289 mc_prt (1):					/* display M. C.'s in octal format */
      290 		call ioa_ ("^/Pointer Registers");
      291 		call display_oct (addr (mach_cond (j).spri_dta (1)), 2); /* print in octal format */
      292 		call ioa_ ("^/Processor Registers");
      293 		call display_oct (addr (mach_cond (j).sreg_dta (1)), 1); /* print in octal format */
      294 		call ioa_ ("^/SCU Data");
      295 		call display_oct (addr (mach_cond (j).scu_dta (1)), 1); /* print in octal format */
      296 		call ioa_ ("^/Software Data");
      297 		call display_oct (addr (mach_cond (j).sw_dta (1)), 1); /* print in octal format */
      298 		call ioa_ ("^/EIS Pointers and Lengths");
      299 		call display_oct (addr (mach_cond (j).spl_dta (1)), 1); /* print in octal format */
      300 		go to p_nxt;			/* go print next M. C. */
      301 mc_prt (2):					/* display M. C.'s in interpreted form */
      302 		call ioa_ (" ");
      303 		call dump_machine_cond_$mc_only (mcp, "user_output"); /* that was simple */
      304 		go to p_nxt;			/* go print next M.C. */
      305 mc_prt (3):					/* display SCU data only */
      306 		scup = addr (mc_trace_buf.mach_cond (j).scu_dta (1)); /* set up ptr first */
      307 		call ioa_ ("^/SCU data at mc_trace_buffer|^o^/", fixed (rel (scup)));
      308 		call prtscu_$on_line (null, scup, "1"b); /* interpret scu data */
      309 p_nxt:
      310 	     end;
      311 	end display_mc;
      312 
      313 /* parse - internal procedure to parse cmd line for numerical string and return as decimal constant */
      314 
      315 parse:	proc returns (fixed bin (35));
      316 dcl  count fixed bin (35);
      317 
      318 	     if lp > ll then			/* if at end of line */
      319 		return (-1);
      320 	     i = length (ltrim (substr (com_string, lp, ll - lp), WS)); /* strip off leading white space */
      321 	     lp = lp + ((ll - lp) - i);		/* update line position */
      322 	     i = search (substr (com_string, lp), WS);	/* find end of string */
      323 	     count = cv_dec_check_ (substr (com_string, lp, i - 1), code); /* convert to decimal */
      324 	     if code ^= 0 then			/* not decimal number return w/error */
      325 		return (-1);
      326 	     lp = lp + i;				/* update line position */
      327 	     return (count);
      328 	end parse;
      329 
      330 /* clean - internal procedure to turn off trace and unwire trace buffer */
      331 
      332 clean:	proc;
      333 
      334 	     if trace_on then do;			/* turn trace off if on */
      335 		call phcs_$trace_buffer_init (sp, "0"b, buf_size, bp, code);
      336 		if code ^= 0 then
      337 		     call com_err_ (code, p_name, "attempting to turn trace off");
      338 		trace_on = "0"b;
      339 	     end;
      340 	end clean;
      341 
      342 /* set_line_length - internal procedure to set output length parameters based on the terminal line length */
      343 
      344 set_line_length: proc;
      345 	     i = get_line_length_$switch (null, code);	/* get terminal line length */
      346 	     if i < 104 & code = 0 then
      347 		lo = "0"b;
      348 	     else lo = "1"b;
      349 	end set_line_length;
      350 
      351 /*  */
      352 
      353 /* display_hregs - internal procedure to display requested number of history registers */
      354 
      355 display_hregs: proc (line_pos, type, cont);
      356 dcl  cont bit (1);
      357 dcl (line_pos, type, count, limit, cpu_type) fixed bin;
      358 
      359 	     call phcs_$hc_trace_on_off ("0"b, code);	/* turn off hardcore tracing mechanism */
      360 
      361 	     j = mc_trace_buf.hr_nxtad;		/* start with next avail location */
      362 	     if j = mc_trace_buf.hr_strt then		/* if at beginning of buffer */
      363 		if substr (h_regs (1).ou_hr (1), 1, 36) = buf_init then do; /* no H. R. stored */
      364 		     call ioa_ ("History Register buffer empty");
      365 		     return;
      366 		end;
      367 	     call get_args (line_pos, count, limit);	/* get further args */
      368 	     if count = 0 then			/* No args set count to display entire buffer */
      369 		count = mc_trace_buf.hr_cnt;
      370 
      371 /* first get cronilogical order of H. R.'s, last to first */
      372 	     do i = 1 to count;			/* get each requested H. R. */
      373 		if j = mc_trace_buf.hr_strt then	/* if at beginning of buffer */
      374 		     j = (hr_cnt - 1) * hr_size + mc_trace_buf.hr_strt; /* set to last H. R. */
      375 		else j = j - hr_size;		/* just decrement to nxt H. R. */
      376 		k = divide ((j + hr_size) - mc_trace_buf.hr_strt, hr_size, 17, 0); /* get array index */
      377 		if substr (h_regs (k).ou_hr (1), 1, 36) ^= buf_init then mc_pos (i) = k; /* if H. R. valid */
      378 		else go to too_many2;		/* if not valid, exit */
      379 	     end;
      380 too_many2:
      381 	     if i - 1 ^= count then do;		/* if not all requested H. R.'s valid */
      382 		call ioa_ ("Only ^d sets of History Registers are valid", i - 1);
      383 		count = i - 1;			/* adjust count */
      384 	     end;
      385 	     call set_line_length;			/* set up output length parameters */
      386 	     if limit = 0 | limit > count then		/* set up defaults */
      387 		limit = 1;
      388 	     else limit = count - (limit - 1);
      389 	     do i = count to limit by -1;		/* this  is really forward */
      390 		j = mc_pos (i);
      391 		call ioa_ ("^2/*****History Registers at mc_trace_buffer|^o*****",
      392 		     fixed (rel (addr (mc_trace_buf.h_regs (j)))));
      393 		if substr (h_regs (j).du_hr (1), 72, 1) = "1"b then
      394 		     cpu_type = 0;			/* its a l68 */
      395 		go to dhr (type);			/* display requested history reg */
      396 
      397 dhr (1):						/* label for OU history register display */
      398 		if cpu_type = 0 then
      399 		     call ioa_ ("^/Operations Unit (OU) History Registers");
      400 		else call ioa_ ("^/Decimal Unit/Operations Unit (DU/OU) History Registers");
      401 		call display_oct (addr (h_regs (j).ou_hr (1)), 4); /* print out octal history regs */
      402 		if ^cont then go to p_nxt1;		/* user wants OU history regs only */
      403 dhr (2):						/* label for CU History Registers */
      404 		call ioa_ ("^/Control Unit (CU) History Registers");
      405 		call display_oct (addr (h_regs (j).cu_hr (1)), 4); /* print out octal history regs */
      406 		if ^cont then go to p_nxt1;		/* user wants CU history regs only */
      407 dhr (3):						/* label for DU history reg display */
      408 		if cpu_type = 0 then
      409 		     call ioa_ ("^/Decimal Unit (DU) History Registers");
      410 		else call ioa_ ("^/Appending Unit #2 (AU2) History Registers");
      411 		call display_oct (addr (h_regs (j).du_hr (1)), 4); /* print out octal history regs */
      412 		if ^cont then go to p_nxt1;		/* user wants du history regs only */
      413 dhr (4):						/* label for APU history reg display */
      414 		if cpu_type = 0 then
      415 		     call ioa_ ("^/Appending Unit (AU) History Registers");
      416 		else call ioa_ ("^/Appending Unit #1 (AU1) History Registers");
      417 		call display_oct (addr (h_regs (j).au_hr (1)), 4); /* print out octal history regs */
      418 		go to p_nxt1;
      419 dhr (5):
      420 		call ioa_ ("^/Composite Analysis of History Registers^/");
      421 		call hran_$hranl (addr (h_regs (j).ou_hr (1)), null, lo);
      422 p_nxt1:
      423 	     end;
      424 	end display_hregs;
      425 
      426 
      427 /* display_oct - internal procedure for displaying a requested number of 8 word blocks in octal to stream user_output */
      428 
      429 display_oct: proc (iwp, sets);
      430 
      431 dcl (iwp, wp) ptr;
      432 dcl (sets, i) fixed bin;
      433 
      434 dcl  w (8) fixed bin based (wp);
      435 
      436 	     wp = iwp;				/* copy pointer */
      437 	     do i = 1 to sets;			/* iterate requested number of times */
      438 		call ioa_ ("^4(^w ^)^[^;^/^]^4(^w ^)",
      439 		     w (1), w (2), w (3), w (4), lo, w (5), w (6), w (7), w (8));
      440 		wp = addrel (wp, 8);		/* increment pointer */
      441 	     end;
      442 	end display_oct;
      443 
      444 /* get_args - internal procedure to get numerical args from cmd line and return count and limit values */
      445 
      446 get_args:	proc (init_lp, cnt, lmt);
      447 dcl (init_lp, cnt, lmt) fixed bin;
      448 
      449 	     cnt, lmt = 0;				/* initially set returns to 0 */
      450 	     if init_lp >= ll then			/* no further args */
      451 		return;
      452 	     lp = init_lp;				/* set up line position */
      453 	     lp_cnt = parse ();			/* get count arg */
      454 	     if lp_cnt = -1 then			/* conversion error */
      455 		go to errsp;			/* no local goto */
      456 	     cnt = lp_cnt;				/* conversion ok set return count parameter */
      457 	     lp_cnt = parse ();
      458 	     if lp_cnt ^= -1 then			/* set limit only if valid */
      459 		lmt = lp_cnt;
      460 	end get_args;
      461 
      462 /*  */
      463 
      464 /* cond_hand - internal procedure to implement the "any_other" condition handler */
      465 
      466 cond_hand: proc;
      467 dcl  ec fixed bin (35);
      468 dcl 1 condinfo aligned,
  2     1 	/* BEGIN INCLUDE FILE ... cond_info.incl.pl1
  2     2*	   coded by M. Weaver 12 July 1973 */
  2     3 
  2     4 	  2 mcptr ptr,				/* ptr to machine conditions at time of fault */
  2     5 	  2 version fixed bin,			/* version of this structure (now=1) */
  2     6 	  2 condition_name char(32) var,		/* name of condition */
  2     7 	  2 infoptr ptr,				/* ptr to software info structure */
  2     8 	  2 wcptr ptr,				/* ptr to wall crossing machine conditions */
  2     9 	  2 loc_ptr ptr,				/* ptr to location where condition occurred */
  2    10 	  2 flags aligned,
  2    11 	    3 crawlout bit(1) unal,			/* = "1"b if condition occurred in inner ring */
  2    12 	    3 pad1 bit(35) unal,
  2    13 	  2 pad_word bit(36) aligned,
  2    14 	  2 user_loc_ptr ptr,			/* ptr to last non-support loc before condition */
  2    15 	  2 pad (4) bit(36) aligned;
  2    16 
  2    17 	/* END INCLUDE FILE ... cond_info.incl.pl1 */
      469 
      470 
      471      call find_condition_info_ (null, addr (condinfo), ec); /* get  some info about condition */
      472 
      473 /* pass on any condition we can not handle */
      474 
      475 	     if condition_name = "alrm" then go to cts;
      476 	     if condition_name = "cput" then go to cts;
      477 	     if condition_name = "program_interrupt" then go to cts;
      478 	     if condition_name = "mme2" then go to cts;
      479 	     if condition_name = "stack" then go to cts;
      480 	     if condition_name = "command_error" then go to cts;
      481 	     if condition_name = "finish" | condition_name = "cleanup" then do;
      482 		call clean;
      483 cts:
      484 		call continue_to_signal_ (ec);
      485 		return;
      486 	     end;
      487 	     call phcs_$hc_trace_on_off ("0"b, ec);	/* turn off hardcore tracing mechanism */
      488 	     call ioa_$ioa_switch (iox_$error_output, "^a condition raised, enter command",
      489 		condition_name);
      490 	     go to request;
      491 	end cond_hand;
      492 
      493      end mc_trace;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1450.1  mc_trace.pl1                      >dumps>old>recomp>mc_trace.pl1
61           1    08/18/77  0953.5  mc_trace_buf.incl.pl1             >ldd>include>mc_trace_buf.incl.pl1
469          2    05/06/74  1741.0  cond_info.incl.pl1                >ldd>include>cond_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
WS                                     constant        char(2)                  initial unaligned dcl 58 ref 176 320 322
acnt                            000244 automatic       fixed bin(17,0)          dcl 51 set ref 67* 68 73
addr                                                   builtin function         dcl 42 ref 166 166 202 202 218 218 285 291 291 293
                                                                                  293 295 295 297 297 299 299 305 391 391 401 401
                                                                                  405 405 411 411 417 417 421 421 471 471
addrel                                                 builtin function         dcl 42 ref 440
al                              000245 automatic       fixed bin(17,0)          dcl 51 set ref 74* 79 79 81 87 87 89 89 95 95 97 97
                                                                                  99 99 116 116 119 119 123 123 125 125 128 128
any_other                       000100 stack reference condition                dcl 45 ref 153
ap                              000250 automatic       pointer                  dcl 52 set ref 74* 79 79 81 87 89 95 97 99 116 119
                                                                                  123 123 125 125 128
arg                                    based           char                     unaligned dcl 49 set ref 79 79 81 87* 89* 95* 97*
                                                                                  99* 116* 119* 123 123 125 125 128*
au_hr                   150            based           bit(72)                  array level 3 dcl 1-8 set ref 417 417
baseno                                                 builtin function         dcl 42 ref 111
baseptr                                                builtin function         dcl 42 ref 81 104
bp                              000476 automatic       pointer                  dcl 1-6 set ref 146* 255 256 256 256 262 267 267 267
                                                                                  270 271 271 285 285 291 291 291 291 293 293 293
                                                                                  293 295 295 295 295 297 297 297 297 299 299 299
                                                                                  299 305 305 335* 361 362 362 368 373 373 373 376
                                                                                  377 391 391 393 401 401 405 405 411 411 417 417
                                                                                  421 421
brief                           000467 automatic       bit(1)                   initial unaligned dcl 57 set ref 57* 125* 164
buf_init                        000010 constant        bit(36)                  initial unaligned dcl 1-33 ref 256 271 362 377
buf_size                        000465 automatic       fixed bin(17,0)          initial dcl 56 set ref 56* 117* 118 118 146* 335*
buf_sw                          000472 automatic       bit(1)                   initial unaligned dcl 57 set ref 57* 114 115* 123*
cleanup                         000106 stack reference condition                dcl 45 ref 158
cnt                                    parameter       fixed bin(17,0)          dcl 447 set ref 446 449* 456*
code                            000237 automatic       fixed bin(35,0)          dcl 50 set ref 74* 75 76* 87* 88 89* 95* 96 97* 98
                                                                                  99* 105* 106 107* 116* 118 137* 139* 146* 147 148*
                                                                                  155* 166* 167 168* 197* 198 199* 202* 203* 212*
                                                                                  213 214* 218* 220* 253* 323* 324 335* 336 336*
                                                                                  345* 346 359*
com_err_                        000034 constant        entry                    external dcl 30 ref 69 76 89 99 107 111 119 128 139
                                                                                  148 168 184 199 214 336
com_string                      000176 automatic       char(132)                dcl 48 set ref 162* 166 166 166 166 176 178* 178
                                                                                  179* 183 184* 191 195 196* 196 202 202 205 211*
                                                                                  211 218 218 222 224 226 228 230 232 234 236 238
                                                                                  240 320 322 323 323
condinfo                        000110 automatic       structure                level 1 dcl 468 set ref 471 471
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 468 set ref 475 476 477 478 479 480 481
                                                                                  481 488*
cont                                   parameter       bit(1)                   unaligned dcl 356 ref 355 402 406 412
continue_to_signal_             000060 constant        entry                    external dcl 38 ref 483
count                           000522 automatic       fixed bin(35,0)          dcl 316 in procedure "parse" set ref 323* 327
count                           000510 automatic       fixed bin(17,0)          dcl 251 in procedure "display_mc" set ref 261* 262
                                                                                  262* 266 274 277* 280 282 283
count                           000540 automatic       fixed bin(17,0)          dcl 357 in procedure "display_hregs" set ref 367*
                                                                                  368 368* 372 380 383* 386 388 389
cpu_type                        000542 automatic       fixed bin(17,0)          dcl 357 set ref 393* 397 407 413
cu_$arg_count                   000012 constant        entry                    external dcl 22 ref 67
cu_$arg_ptr                     000014 constant        entry                    external dcl 23 ref 74
cu_$cp                          000010 constant        entry                    external dcl 21 ref 202 218
cu_hr                    50            based           bit(72)                  array level 3 dcl 1-8 set ref 405 405
cv_dec_check_                   000026 constant        entry                    external dcl 28 ref 116 323
cv_oct_check_                   000030 constant        entry                    external dcl 29 ref 95
dir_name                        000114 automatic       char(168)                unaligned dcl 46 set ref 87* 137* 139*
divide                                                 builtin function         dcl 42 ref 270 376
du_hr                   110            based           bit(72)                  array level 3 dcl 1-8 set ref 393 411 411
dump_machine_cond_$mc_only      000046 constant        entry                    external dcl 33 ref 303
ec                              000106 automatic       fixed bin(35,0)          dcl 467 set ref 471* 483* 487*
ename                           000166 automatic       char(32)                 unaligned dcl 47 set ref 87* 105* 137* 139*
expand_pathname_                000024 constant        entry                    external dcl 27 ref 87
find_condition_info_            000052 constant        entry                    external dcl 35 ref 471
fixed                                                  builtin function         dcl 42 ref 111 286 286 307 307 391 391
get_line_length_$switch         000050 constant        entry                    external dcl 34 ref 345
h_regs                   10            based           structure                array level 2 dcl 1-8 set ref 391 391
hc_all                          000473 automatic       bit(1)                   initial unaligned dcl 57 set ref 57* 80* 136
hc_sw                           000474 automatic       bit(1)                   initial unaligned dcl 57 set ref 57* 83* 93 94*
hcs_$initiate                   000016 constant        entry                    external dcl 24 ref 137
hr_cnt                    3(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-8 ref 256 271 285 291
                                                                                  291 293 293 295 295 297 297 299 299 305 368 373
hr_nxtad                  2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-8 ref 361
hr_size                                constant        fixed bin(17,0)          initial dcl 1-31 ref 373 375 376 376
hr_strt                   3            based           fixed bin(17,0)          level 2 packed unaligned dcl 1-8 ref 362 373 373 376
hran_$hranl                     000064 constant        entry                    external dcl 40 ref 421
hran_$hrlgnd                    000062 constant        entry                    external dcl 39 ref 242
i                               000241 automatic       fixed bin(17,0)          dcl 51 in procedure "mct" set ref 73* 74* 176* 177
                                                                                  178 179 188 217* 266* 271* 274 276 277 283* 284*
                                                                                  320* 321 322* 323 323 326 345* 346 372* 377* 380
                                                                                  382 383 389* 390*
i                               000556 automatic       fixed bin(17,0)          dcl 432 in procedure "display_oct" set ref 437*
init_lp                                parameter       fixed bin(17,0)          dcl 447 ref 446 450 452
ioa_                            000032 constant        entry                    external dcl 30 ref 189 241 258 276 286 289 292 294
                                                                                  296 298 301 307 364 382 391 397 400 403 407 410
                                                                                  413 416 419 438
ioa_$ioa_switch                 000036 constant        entry                    external dcl 30 ref 488
ioa_$ioa_switch_nnl             000040 constant        entry                    external dcl 30 ref 164
iox_$error_output               000070 external static pointer                  dcl 44 set ref 164* 488*
iox_$get_line                   000042 constant        entry                    external dcl 31 ref 166
iox_$user_input                 000066 external static pointer                  dcl 44 set ref 166*
iwp                                    parameter       pointer                  dcl 431 ref 429 436
j                               000242 automatic       fixed bin(17,0)          dcl 51 set ref 177* 178 210* 211 211 218* 255* 256
                                                                                  267 267* 269* 269 270 284* 285 291 291 293 293 295
                                                                                  295 297 297 299 299 305 361* 362 373 373* 375* 375
                                                                                  376 390* 391 391 393 401 401 405 405 411 411 417
                                                                                  417 421 421
k                               000243 automatic       fixed bin(17,0)          dcl 51 set ref 270* 271 271 376* 377 377
length                                                 builtin function         dcl 42 ref 166 166 176 320
limit                           000541 automatic       fixed bin(17,0)          dcl 357 in procedure "display_hregs" set ref 367*
                                                                                  386 386 386* 388* 388 389
limit                           000511 automatic       fixed bin(17,0)          dcl 251 in procedure "display_mc" set ref 261* 280
                                                                                  280 280* 282* 282 283
line_pos                               parameter       fixed bin(17,0)          dcl 357 in procedure "display_hregs" set ref 355
                                                                                  367*
line_pos                               parameter       fixed bin(17,0)          dcl 251 in procedure "display_mc" set ref 250 261*
ll                              000464 automatic       fixed bin(21,0)          dcl 55 set ref 166* 171* 171 172 176 177 178 188*
                                                                                  189 191 196 196 202 210 318 320 321 450
lmt                                    parameter       fixed bin(17,0)          dcl 447 set ref 446 449* 458*
lo                              000470 automatic       bit(1)                   initial unaligned dcl 57 set ref 57* 346* 348* 421*
                                                                                  438*
lp                              000246 automatic       fixed bin(17,0)          dcl 51 set ref 206* 210 211 318 320 320 321* 321 321
                                                                                  322 323 323 326* 326 452*
lp_cnt                          000240 automatic       fixed bin(35,0)          dcl 50 set ref 95* 104 107* 116* 117 207* 208 217
                                                                                  453* 454 456 457* 458 458
ltrim                                                  builtin function         dcl 42 ref 176 320
mach_cond                              based           structure                array level 2 dcl 1-8 set ref 285
max_buf_size                           constant        fixed bin(17,0)          initial dcl 1-32 ref 118
mc_cnt                    1(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-8 ref 262 267
mc_nxtad                  0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-8 ref 255
mc_pos                          000260 automatic       fixed bin(17,0)          array unaligned dcl 53 set ref 271* 284 377* 390
mc_size                                constant        fixed bin(17,0)          initial dcl 1-30 ref 267 269 270 270
mc_strt                   1            based           fixed bin(17,0)          level 2 packed unaligned dcl 1-8 ref 256 267 267 270
mc_trace_buf                           based           structure                level 1 dcl 1-8
mcp                             000254 automatic       pointer                  dcl 52 set ref 285* 286 286 303*
null                                                   builtin function         dcl 42 ref 138 242 242 308 308 345 345 421 421 471
                                                                                  471
ou_hr                    10            based           bit(72)                  array level 3 dcl 1-8 set ref 362 377 401 401 421
                                                                                  421
p_name                          000462 automatic       char(8)                  initial unaligned dcl 54 set ref 54* 69* 69* 76* 89*
                                                                                  99* 107* 111* 119* 128* 139* 148* 168* 184* 189*
                                                                                  199* 214* 336*
path_sw                         000471 automatic       bit(1)                   initial unaligned dcl 57 set ref 57* 80* 85 86*
phcs_$hc_trace_on_off           000022 constant        entry                    external dcl 26 ref 155 197 203 212 220 253 359 487
phcs_$trace_buffer_init         000020 constant        entry                    external dcl 25 ref 146 335
prtscu_$on_line                 000044 constant        entry                    external dcl 32 ref 308
rel                                                    builtin function         dcl 42 ref 286 286 307 307 391 391
ring0_get_$name                 000056 constant        entry                    external dcl 37 ref 105
ring0_get_$segptr               000054 constant        entry                    external dcl 36 ref 97
scu_dta                                based           bit(36)                  array level 3 dcl 1-8 set ref 256 271 295 295 305
scup                            000256 automatic       pointer                  dcl 52 set ref 305* 307 307 308*
search                                                 builtin function         dcl 42 ref 322
sets                                   parameter       fixed bin(17,0)          dcl 432 ref 429 437
sp                              000252 automatic       pointer                  dcl 52 set ref 81* 97* 104* 105* 111 137* 138 146*
                                                                                  335*
spl_dta                                based           bit(36)                  array level 3 dcl 1-8 set ref 299 299
spri_dta                               based           pointer                  array level 3 dcl 1-8 set ref 291 291
sreg_dta                               based           bit(36)                  array level 3 dcl 1-8 set ref 293 293
substr                                                 builtin function         dcl 42 set ref 176 178* 178 179* 183 191 195 196*
                                                                                  196 205 211* 211 222 224 226 228 230 232 234 236
                                                                                  238 240 320 322 323 323 362 377 393
sw_dta                                 based           bit(36)                  array level 3 dcl 1-8 set ref 297 297
trace_on                        000466 automatic       bit(1)                   initial unaligned dcl 57 set ref 57* 151* 334 338*
type                                   parameter       fixed bin(17,0)          dcl 251 in procedure "display_mc" ref 250 288
type                                   parameter       fixed bin(17,0)          dcl 357 in procedure "display_hregs" ref 355 395
w                                      based           fixed bin(17,0)          array dcl 434 set ref 438* 438* 438* 438* 438* 438*
                                                                                  438* 438*
wp                              000554 automatic       pointer                  dcl 431 set ref 436* 438 438 438 438 438 438 438 438
                                                                                  440* 440

NAMES DECLARED BY EXPLICIT CONTEXT.
arger                           000741 constant        label                    dcl 69 ref 129
clean                           003731 constant        entry                    internal dcl 332 ref 158 192 482
cond_hand                       004745 constant        entry                    internal dcl 466 ref 154
cts                             005042 constant        label                    dcl 483 ref 475 476 477 478 479 480
dhr                             000003 constant        label                    array(5) dcl 397 ref 395
display_hregs                   004044 constant        entry                    internal dcl 355 ref 228 230 232 234 236 238
display_mc                      002724 constant        entry                    internal dcl 250 ref 222 224 226
display_oct                     004621 constant        entry                    internal dcl 429 ref 291 293 295 297 299 401 405 411
                                                                                  417
errsp                           002203 constant        label                    dcl 184 ref 208 240 454
get_args                        004715 constant        entry                    internal dcl 446 ref 261 367
mc_prt                          000000 constant        label                    array(3) dcl 289 set ref 288
mc_trace                        000722 constant        entry                    external dcl 11
mct                             000712 constant        entry                    external dcl 11
p_nxt                           003605 constant        label                    dcl 309 ref 300 304
p_nxt1                          004615 constant        label                    dcl 422 ref 402 406 412 418
parse                           003611 constant        entry                    internal dcl 315 ref 207 453 457
request                         002045 constant        label                    dcl 162 ref 169 172 186 200 215 245 490
set_line_length                 004013 constant        entry                    internal dcl 344 ref 279 385
too_many                        003107 constant        label                    dcl 274 ref 271
too_many2                       004206 constant        label                    dcl 380 ref 377

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6126        6220    5574        6136
Length      6520    5574        72         263     332           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mct                                 668 external procedure  is an external procedure.  
on unit on line 153                 144 on unit               
on unit on line 158                  64 on unit               
display_mc                              internal procedure  shares stack frame of external procedure mct.  
parse                                   internal procedure  shares stack frame of external procedure mct.  
clean                                92 internal procedure  is called by several nonquick procedures.  
set_line_length                         internal procedure  shares stack frame of external procedure mct.  
display_hregs                           internal procedure  shares stack frame of external procedure mct.  
display_oct                             internal procedure  shares stack frame of external procedure mct.  
get_args                                internal procedure  shares stack frame of external procedure mct.  
cond_hand                               internal procedure  shares stack frame of on unit on line 153.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mct                      000114 dir_name                    mct
                         000166 ename                       mct
                         000176 com_string                  mct
                         000237 code                        mct
                         000240 lp_cnt                      mct
                         000241 i                           mct
                         000242 j                           mct
                         000243 k                           mct
                         000244 acnt                        mct
                         000245 al                          mct
                         000246 lp                          mct
                         000250 ap                          mct
                         000252 sp                          mct
                         000254 mcp                         mct
                         000256 scup                        mct
                         000260 mc_pos                      mct
                         000462 p_name                      mct
                         000464 ll                          mct
                         000465 buf_size                    mct
                         000466 trace_on                    mct
                         000467 brief                       mct
                         000470 lo                          mct
                         000471 path_sw                     mct
                         000472 buf_sw                      mct
                         000473 hc_all                      mct
                         000474 hc_sw                       mct
                         000476 bp                          mct
                         000510 count                       display_mc
                         000511 limit                       display_mc
                         000522 count                       parse
                         000540 count                       display_hregs
                         000541 limit                       display_hregs
                         000542 cpu_type                    display_hregs
                         000554 wp                          display_oct
                         000556 i                           display_oct
on unit on line 153      000106 ec                          cond_hand
                         000110 condinfo                    cond_hand

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
tra_ext             enable              shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      continue_to_signal_           cu_$arg_count                 cu_$arg_ptr
cu_$cp                        cv_dec_check_                 cv_oct_check_                 dump_machine_cond_$mc_only
expand_pathname_              find_condition_info_          get_line_length_$switch       hcs_$initiate
hran_$hranl                   hran_$hrlgnd                  ioa_                          ioa_$ioa_switch
ioa_$ioa_switch_nnl           iox_$get_line                 phcs_$hc_trace_on_off         phcs_$trace_buffer_init
prtscu_$on_line               ring0_get_$name               ring0_get_$segptr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$error_output             iox_$user_input




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     54 000674        56 000676        57 000700        11 000711        67 000730        68 000737        69 000741
     71 000771        73 000772        74 001000        75 001015        76 001017        77 001044        79 001045
     80 001057        81 001062        83 001073        84 001074        85 001075        86 001077        87 001101
     88 001131        89 001133        90 001166        92 001167        93 001170        94 001172        95 001173
     96 001216        97 001220        98 001250        99 001252       100 001305       102 001306       104 001307
    105 001313       106 001340       107 001342       108 001371       111 001372       113 001423       114 001424
    115 001426       116 001427       117 001452       118 001454       119 001463       120 001517       122 001520
    123 001521       125 001534       128 001547       129 001606       131 001607       136 001611       137 001613
    138 001656       139 001662       140 001716       146 001717       147 001740       148 001742       149 001766
    151 001767       153 001771       154 002005       155 002006       156 002022       158 002023       162 002045
    164 002050       166 002071       167 002114       168 002116       169 002142       171 002143       172 002145
    176 002147       177 002161       178 002165       179 002172       183 002177       184 002203       186 002234
    188 002235       189 002237       191 002261       192 002265       193 002271       195 002272       196 002276
    197 002303       198 002316       199 002320       200 002344       202 002345       203 002365       204 002400
    205 002401       206 002404       207 002406       208 002410       210 002413       211 002417       212 002423
    213 002436       214 002440       215 002464       217 002465       218 002474       219 002511       220 002513
    221 002526       222 002527       224 002543       226 002554       228 002565       230 002601       232 002615
    234 002630       236 002643       238 002656       240 002674       241 002676       242 002712       245 002723
    250 002724       253 002726       255 002741       256 002745       258 002764       259 003000       261 003001
    262 003014       266 003023       267 003031       269 003047       270 003051       271 003056       273 003105
    274 003107       276 003113       277 003136       279 003141       280 003142       282 003151       283 003156
    284 003164       285 003173       286 003210       288 003233       289 003236       291 003252       292 003274
    293 003310       294 003333       295 003351       296 003374       297 003411       298 003434       299 003450
    300 003473       301 003474       303 003507       304 003523       305 003524       307 003543       308 003566
    309 003605       311 003610       315 003611       318 003613       320 003621       321 003637       322 003643
    323 003663       324 003713       326 003722       327 003724       332 003730       334 003736       335 003741
    336 003761       338 004010       340 004012       344 004013       345 004014       346 004031       348 004041
    349 004043       355 004044       359 004046       361 004061       362 004066       364 004075       365 004111
    367 004112       368 004125       372 004134       373 004142       375 004160       376 004162       377 004167
    379 004204       380 004206       382 004212       383 004235       385 004240       386 004241       388 004250
    389 004255       390 004263       391 004272       393 004320       395 004330       397 004333       400 004352
    401 004366       402 004377       403 004405       405 004421       406 004432       407 004440       410 004457
    411 004473       412 004504       413 004512       416 004531       417 004545       418 004556       419 004557
    421 004573       422 004615       424 004620       429 004621       436 004623       437 004626       438 004635
    440 004707       441 004712       442 004714       446 004715       449 004717       450 004721       452 004725
    453 004726       454 004730       456 004733       457 004735       458 004737       460 004744       466 004745
    471 004746       475 004765       476 004772       477 004777       478 005004       479 005011       480 005016
    481 005023       482 005035       483 005042       485 005051       487 005052       488 005065       490 005111


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
