	COMPILATION LISTING OF SEGMENT heals_collect_data_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 09/27/84  0744.5 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* This routine copies selected syserr_log messages
        7*   into the Heals log.  Record selection is based upon
        8*   a time range, as well as a data type.
        9*   Coded by A. Downing Feb. 1976.
       10**/
       11 /* Modified Feb. 1979 by A. Downing in preparation
       12*   of MR7.0; several bug fixes and some code clarification made.
       13**/
       14 heals_collect_data_: proc (datap, code);
  1     1 /* heals_arg_info.incl.pl1 contains the declaration
  1     2*   of the argument structure passed between heals releated utilities.
  1     3*   Created January 1976 by A. R. Downing */
  1     4 dcl 1 heals_arg_info aligned,
  1     5     2 iocbp ptr,
  1     6     2 report_iocbp ptr,
  1     7     2 err_nb fixed bin (35),
  1     8     2 info_selection bit (72) unal,
  1     9     2 report_name char (64) varying,
  1    10     2 heals_log_path_name char (168),			/* path name of the heals log */
  1    11     2 system_id char (32) varying,
  1    12     2 installation_id char (32) varying,
  1    13     2 from_seq fixed bin (35),			/* beginning seq_num */
  1    14     2 to_seq fixed bin (35),				/* ending seq_num */
  1    15     2 from_time fixed bin (71),			/* beginning of desired time period */
  1    16     2 to_time fixed bin (71);				/* end of desired time period */
  1    17 						/* end heals_arg_info. */
       15 
  2     1 /* begin heals_message.incl.pl1 */
  2     2 /* Produced March 1976 by A. Downing. */
  2     3 dcl 1 heals_message based (heals_message_p) aligned,
  2     4     2 tally fixed bin (35),
  2     5     2 rest_of_record aligned,
  2     6       3 seq_num fixed bin (35),			/* Sequence number of this message. */
  2     7       3 time fixed bin (71) unal,			/* Time message logged at */
  2     8       3 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  2     9       3 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  2    10       3 data_size fixed bin (11) unal,			/* Size of binary data */
  2    11       3 data_code fixed bin (11) unal,			/* format type code */
  2    12       3 pad bit (60) unal,
  2    13       3 text char (0 refer (heals_message.text_len)),	/* Text of expanded message - kept in ASCII. */
  2    14       3 data (0 refer (heals_message.data_size)) bit (36);	/* Binary data area */
  2    15 dcl  heals_message_p ptr;
  2    16 						/* end heals_message.incl.pl1 */
       16 
  3     1 /* begin heals_state.incl.pl1 */
  3     2 /* Produced March 1976 by A. Downing. */
  3     3 
  3     4 dcl 1 heals_state aligned based (heals_state_p),
  3     5     2 last_message_time fixed bin (71),
  3     6     2 last_message_seq_num fixed bin (35),
  3     7     2 busy bit (36) aligned;
  3     8 dcl  heals_state_p ptr;
  3     9 dcl  heals_log_info$ ext static fixed bin (35) aligned dim (64000);
  3    10 						/* end heals_state.incl.pl1 */
       17 
  4     1 /* Begin include file ..... syserr_message.incl.pl1 */
  4     2 
  4     3 /* Format of a syserr message */
  4     4 
  4     5 /* Created October 1975 by Larry Johnson */
  4     6 
  4     7 dcl  syserr_msgp ptr;				/* Base for include file */
  4     8 
  4     9 dcl 1 syserr_msg based (syserr_msgp) aligned,
  4    10     2 seq_num fixed bin (35),				/* Sequence number of this message. */
  4    11     2 time fixed bin (71) unal,			/* Time message logged at */
  4    12     2 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  4    13     2 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  4    14     2 data_size fixed bin (11) unal,			/* Size of binary data */
  4    15     2 data_code fixed bin (11) unal,			/* Code identifying message type. */
  4    16     2 pad bit (60) unal,				/* RESERVED! */
  4    17     2 text char (0 refer (syserr_msg.text_len)),		/* Text of expanded message - kept in ASCII. */
  4    18     2 data (0 refer (syserr_msg.data_size)) bit (36);	/* Binary data area */
  4    19 
  4    20 
  4    21 /* End include file ..... syserr_message.incl.pl1 */
       18 
  5     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  5     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  5     3*      version number to IOX2. */
  5     4 /* format: style2 */
  5     5 
  5     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  5     7 	     2 version	      character (4) aligned,	/* IOX2 */
  5     8 	     2 name	      char (32),		/* I/O name of this block. */
  5     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  5    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  5    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  5    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  5    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  5    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  5    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  5    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  5    17 						/* open(p,mode,not_used,s) */
  5    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  5    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  5    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  5    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    24 						/* put_chars(p,bufptr,buflen,s) */
  5    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  5    26 						/* modes(p,newmode,oldmode,s) */
  5    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  5    28 						/* position(p,u1,u2,s) */
  5    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  5    30 						/* control(p,order,infptr,s) */
  5    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  5    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    34 						/* write_record(p,bufptr,buflen,s) */
  5    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  5    36 						/* rewrite_record(p,bufptr,buflen,s) */
  5    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  5    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    39 						/* seek_key(p,key,len,s) */
  5    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    41 						/* read_key(p,key,len,s) */
  5    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  5    43 						/* read_length(p,len,s) */
  5    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  5    45 						/* open_file(p,mode,desc,not_used,s) */
  5    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  5    47 						/* close_file(p,desc,s) */
  5    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  5    49 						/* detach(p,desc,s) */
  5    50 
  5    51      declare iox_$iocb_version_sentinel
  5    52 			      character (4) aligned external static;
  5    53 
  5    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
       19 
       20 dcl 1 arg_info like heals_arg_info based (datap);
       21 dcl  datap ptr;
       22 dcl  qip ptr;
       23 dcl 1 query_info aligned,
       24     2 version fixed bin init (1),
       25     2 yes_or_no_sw bit (1) unal init ("1"b),		/* Require "yes" or "no" answer. */
       26     2 suppress_name_sw bit (1) unal init ("0"b),		/* Print name with question. */
       27     2 status_code fixed bin (35),			/* Set to code of error prompting question. */
       28     2 query_code fixed bin (35) init (0);
       29 dcl  sysmsgp ptr;
       30 dcl  code fixed bin (35);
       31 dcl  i fixed bin (21);
       32 dcl  log_code fixed bin (35);				/* code for syserr_log_util_ calls. */
       33 dcl  no_of_recs_copied fixed bin (35) init (0);
       34 dcl  answer char (8) init ("");
       35 dcl (error_table_$no_record, error_table_$key_duplication, error_table_$key_order) ext static fixed bin (35);
       36 dcl  error_table_$bad_arg ext static fixed bin (35);
       37 dcl  error_table_$file_busy ext static fixed bin (35);
       38 dcl (error_table_$not_open, error_table_$not_closed, error_table_$not_attached)
       39      ext static fixed bin (35);
       40 dcl  error_table_$end_of_info ext static fixed bin (35);
       41 dcl  last_msg_tallied fixed bin (35);
       42 dcl  last_msg_tallied_time fixed bin (71);
       43 dcl  m_len fixed bin (21);
       44 dcl  input_record char (2048) init ("");
       45 dcl  output_record char (2048) init ("");
       46 dcl  io_data bit (1) unal defined arg_info.info_selection pos (1);
       47 dcl  mpc_data bit (1) unal defined arg_info.info_selection pos (2);
       48 dcl  cpu_data bit (1) unal defined arg_info.info_selection pos (3);
       49 dcl  mos_edac_data bit (1) unal defined arg_info.info_selection pos (4);
       50 dcl  sorted_io_data bit (1) unal defined arg_info.info_selection pos (5);
       51 dcl  disk_data bit (1) unal defined arg_info.info_selection pos (6);
       52 dcl  bulk_data bit (1) unal defined arg_info.info_selection pos (7);
       53 dcl  command_query_ entry options (variable);
       54 dcl (com_err_, ioa_) entry options (variable);
       55 dcl  hcs_$initiate entry (char (*), char (*), char (*),
       56      fixed bin (1), fixed bin (2), ptr, fixed bin (35));
       57 dcl  syserr_log_util_$status entry (ptr, fixed bin (35));
       58 dcl  syserr_log_util_$read entry (ptr, fixed bin (21), fixed bin (21), fixed bin (35));
       59 dcl  syserr_log_util_$close entry (fixed bin (35));
       60 dcl  syserr_log_util_$search entry (fixed bin (71), fixed bin (71), fixed bin (35), fixed bin (35));
       61 dcl  syserr_log_util_$open entry (bit (36) aligned, fixed bin (35));
       62 dcl  syserr_log_util_$position entry (fixed bin (24), fixed bin (71), fixed bin (35), fixed bin (35));
       63 dcl  buffering bit (1) aligned init ("0"b);
       64 dcl  first_record bit (1) init ("1"b);
       65 dcl (ioi_type, rcp_type, cpu_type, mos_type, disk_type,
       66      dn355_type, iom_type, bulk_type) bit (1) aligned;
       67 dcl  keyed_sequential_output fixed bin int static init (9); /* iox value */
       68 dcl  last_message_copied bit (1) init ("0"b) aligned;
       69 dcl (cleanup, record_quota_overflow) condition;
       70 dcl (addr, bin, index, null, reverse, substr) builtin;
       71 dcl  slu_statusp ptr;
       72 dcl 1 slu_status aligned,
       73     2 version fixed bin;				/* thats it for now */
       74 dcl  open_status bit (36) aligned;
       75 dcl (search_time, rtime) fixed bin (71);
       76 dcl  rseq fixed bin (35);
       77 
       78 	arg_info.err_nb = -1;			/* if we abort without satisfaction */
       79 	qip = addr (query_info);
       80 	i = index (reverse (arg_info.heals_log_path_name), ">");
       81 	i = length (arg_info.heals_log_path_name) - i;
       82 	call hcs_$initiate
       83 	  (substr (arg_info.heals_log_path_name, 1, i), "heals_log_info", "",
       84 	  0, 0, heals_state_p, code);
       85 	if heals_state_p = null () then signal cleanup;
       86 	code = 0;
       87 	log_code = 0;
       88 	if arg_info.from_time > arg_info.to_time then do;
       89 	  code = error_table_$bad_arg;
       90 	  call com_err_ (code, "heals_collect_data_", "the time range for data processing is incompatible.");
       91 	  return;
       92 	end;
       93 	slu_statusp = addr (slu_status);
       94 	call syserr_log_util_$status (slu_statusp, log_code);
       95 	if log_code ^= 0 then do;
       96 	  call com_err_ (log_code, "heals_collect_data_", "error while obtaining syserr_log status.");
       97 	  code = error_table_$not_attached;
       98 	  return;
       99 	end;
      100 	syserr_msgp = addr (input_record);
      101 	heals_message_p = addr (output_record);
      102 	on condition (record_quota_overflow) begin;
      103 	  call com_err_ (0, "heals_collect_data_",
      104 	    "There is not enough quota on the directory containing the heals log to permit its extention.");
      105 	  call syserr_log_util_$close (log_code);
      106 	  arg_info.err_nb = -1;
      107 	  go to ret;
      108 	end;
      109 
      110 open_syserr_log:
      111 	call syserr_log_util_$open (open_status, log_code);
      112 	if log_code ^= 0 then do;
      113 	  if log_code = error_table_$not_closed then do;
      114 	    call syserr_log_util_$close (log_code);
      115 	    go to open_syserr_log;
      116 	  end;
      117 	  if open_status = "0"b then
      118 	    call com_err_ (log_code, "heals_collect_data_", "error while opening syserr_log");
      119 	  else go to syserr_log_is_open;		/* we have something */
      120 	  go to early_return;
      121 	end;
      122 syserr_log_is_open:
      123 	if substr (open_status, 1, 2) ^= "11"b then
      124 	  call com_err_ (0, "heals_collect_data_",
      125 	  "part of the syserr_log is unavailable, processing will continue with the available part.");
      126 	call syserr_log_util_$search
      127 	  (arg_info.from_time, rtime, rseq, log_code);
      128 	if log_code ^= 0 then do;
      129 	  call com_err_ (log_code, "heals_collect_data_", "could not read syserr_log.");
      130 early_return:
      131 	  arg_info.err_nb = 1;
      132 	  call syserr_log_util_$close (log_code);
      133 	  code = log_code;
      134 	  return;
      135 	end;
      136 
      137 	if rseq < heals_state.last_message_seq_num |
      138 	rtime < heals_state.last_message_time then do;
      139 	  query_info.status_code = 0;			/* init */
      140 get_answer: call command_query_ (qip, answer, "heals_collect_data_",
      141 	    "The syserr_log may have been reinitialized,
      142    do you want to continue copying messages?	");
      143 	  if substr (answer, 1, 3) = "yes" then go to continue_to_copy;
      144 	  else go to early_return;
      145 	end;
      146 
      147 	if rseq < heals_state.last_message_seq_num then
      148 	  call ioa_
      149 	  ("the syserr_log may have been reinitialized after seq_num ^d; copying continues.",
      150 	  last_message_seq_num);
      151 
      152 continue_to_copy:
      153 	call datap -> arg_info.iocbp -> iocb.open (
      154 	  datap -> arg_info.iocbp, (keyed_sequential_output), "0"b, code);
      155 	if code ^= 0 then
      156 	  if code = error_table_$file_busy then do;
      157 	    call com_err_ (code, "heals_collect_data_", "The permanent heals log is being updated.");
      158 	    call syserr_log_util_$close (log_code);
      159 	    return;
      160 	  end;
      161 	  else do;
      162 	    call syserr_log_util_$close (log_code);
      163 	    return;
      164 	  end;
      165 
      166 
      167 copy_data: begin;
  6     1 /* Begin include file ..... io_syserr_msg.incl.pl1 */
  6     2 
  6     3 /* Created October 1975 by Larry Johnson */
  6     4 /* Modified 11/11/76 by Noel I. Morris */
  6     5 /* Modified November 1979 by Larry Johnson for detailed status */
  6     6 /* Modified February 1981 by Chris Jones to use channel names */
  6     7 
  6     8 /* This include file defines the format of the syserr message generated for I/O errors. */
  6     9 /* This message is also defined (size and type) by the "io_msg" and "io_msg_detail"
  6    10*   constants in syserr_binary_def.incl.pl1 */
  6    11 
  6    12 dcl  io_msgp ptr;					/* Pointer to syserr message structure */
  6    13 
  6    14 dcl  1 io_msg aligned based (io_msgp),
  6    15        (
  6    16        2 level bit (3),				/* Level of interrupt being logged */
  6    17        2 fill1 bit (9),
  6    18        2 device bit (6),				/* Device which caused error */
  6    19        2 time_out bit (1),				/* Set if error caused by channel timeout */
  6    20        2 type bit (2),				/* Type of last DCW */
  6    21        2 command bit (6),				/* Command being executed by device */
  6    22        2 fill2 bit (3),
  6    23        2 count bit (6)
  6    24        ) unal,					/* Count of message repetitions */
  6    25        2 channel char (8),				/* Channel over which interrupt came */
  6    26        2 status bit (36),				/* First word of IOM status */
  6    27        2 devname char (4),				/* Device name */
  6    28        2 detailed_status bit (216);			/* Optional detailed device status */
  6    29 
  6    30 /* End include file ..... io_syserr_msg.incl.pl1 */
      168 
      169 dcl  message_length fixed bin (21);
      170 dcl  copy_this_one bit (1) aligned;
      171 copy_loop:  do while ("1"b);
      172 	    call syserr_log_util_$read
      173 	      (addr (input_record), size (input_record), message_length, log_code);
      174 	    if log_code ^= 0 then
      175 	      if log_code ^= error_table_$end_of_info then do;
      176 	        call com_err_ (log_code, "heals_collect_data_", "error while reading syserr_log.");
      177 	        call syserr_log_util_$close (code);
      178 	        return;
      179 	      end;
      180 	      else go to finish;
      181 	    else;
      182 	    if syserr_msg.time > arg_info.to_time then go to finish;
      183 	    if syserr_msg.time >= arg_info.from_time then do;
      184 	      copy_this_one, ioi_type, disk_type, rcp_type,
      185 	        bulk_type, mos_type, cpu_type, dn355_type, iom_type = "0"b;
      186 	      if io_data | sorted_io_data then do;
      187 	        if index (syserr_msg.text, "RCP:") > 0 then rcp_type = "1"b;
      188 	        else if index (syserr_msg.text, "dn355:") > 0 then dn355_type = "1"b;
      189 	        else if index (syserr_msg.text, "iom_manager:") > 0 then iom_type = "1"b;
      190 	        else if index (syserr_msg.text, "ioi_") > 0 then ioi_type = "1"b;
      191 	        else if index (syserr_msg.text, "ocdcm_:") > 0 then ioi_type = "1"b;
      192 	        io_msgp = addr (syserr_msg.data (1));
      193 	      end;
      194 	      if cpu_data then
      195 	        if index (syserr_msg.text, "hardware_fault:") > 0 then do;
      196 		cpu_type = "1"b;			/* a cpu record of some sort */
      197 	        end;
      198 	      if mos_edac_data then
      199 	        if index (syserr_msg.text, "mos_memory_check:") > 0 then do;
      200 		mos_type = "1"b;
      201 	        end;
      202 	      if disk_data then
      203 	        if index (syserr_msg.text, "disk_control") > 0 then do;
      204 		disk_type = "1"b;
      205 	        end;
      206 	      if bulk_data then
      207 	        if index (syserr_msg.text, "bulk_store_control:") > 0 then do;
      208 		bulk_type = "1"b;
      209 	        end;
      210 
      211 have_rec_type:
      212 	      if first_record then do;
      213 	        first_record = "0"b;
      214 	        buffering = "0"b;
      215 	        last_message_copied = "0"b;
      216 
      217 /* initialize this first heals_message for later comparison with syserr_msg values */
      218 	        heals_message.data_size = syserr_msg.data_size;
      219 	        heals_message.text_len = syserr_msg.text_len;
      220 	        unspec (heals_message.rest_of_record) = ""b; /* zero every field out */
      221 	        heals_message.text = "";
      222 	        heals_message.data (*) = ""b;
      223 	        heals_message.tally = 0;
      224 	        m_len = message_length * 4 +4;
      225 	      end;
      226 	      if cpu_type | ioi_type | bulk_type | disk_type | dn355_type | mos_type | iom_type | rcp_type
      227 	      then copy_this_one = "1"b;
      228 	      if copy_this_one then
      229 	        if last_message_copied then do;
      230 
      231 
      232 /* check for message tallying */
      233 		if syserr_msg.text = heals_message.text then
      234 		  if syserr_msg.data_size = heals_message.data_size then do;
      235 		    if ioi_type then
      236 		      if (substr (unspec (heals_message.data), 1, 30) ||
      237 		      substr (unspec (heals_message.data), 37, 72)) =
      238 		      (substr (unspec (syserr_msg.data), 1, 30) ||
      239 		      substr (unspec (syserr_msg.data), 37, 72)) then do;
      240 		        heals_message.tally =
      241 			heals_message.tally + bin (count, 6, 0) + 1;
      242 		        go to keep_text;
      243 		      end;
      244 		      else;
      245 		    else if unspec (heals_message.data) =
      246 		    unspec (syserr_msg.data) then do;	/* compare octal data for similarity */
      247 		      heals_message.tally = heals_message.tally + 1;
      248 		      go to keep_text;
      249 		    end;
      250 		  end;
      251 		  else;
      252 		else;
      253 
      254 /* must not be similar to last record */
      255 		if buffering then call copy_message;	/* write old rec */
      256 		if ioi_type then heals_message.tally =
      257 		  bin (count, 6, 0) + 1;
      258 		else heals_message.tally = 1;
      259 		m_len = message_length * 4 +4;
      260 		heals_message.seq_num = syserr_msg.seq_num;
      261 		heals_message.time = syserr_msg.time;
      262 		heals_message.code = syserr_msg.code;
      263 		heals_message.data_size = syserr_msg.data_size;
      264 		heals_message.text_len = syserr_msg.text_len;
      265 		heals_message.data (*) = syserr_msg.data (*);
      266 		heals_message.text = syserr_msg.text;
      267 keep_text:
      268 		buffering = "1"b;
      269 		last_message_copied = "1"b;
      270 		last_msg_tallied = syserr_msg.seq_num;
      271 		last_msg_tallied_time = syserr_msg.time;
      272 	        end;				/* end of last_message_copied being true */
      273 	        else do;				/* last_message_copied was false */
      274 		if buffering then
      275 		  call copy_message;
      276 		buffering = "1"b;
      277 		heals_message.data_size = syserr_msg.data_size; /* because of refer option */
      278 		heals_message.text_len = syserr_msg.text_len; /* because of refer option */
      279 		heals_message.rest_of_record = syserr_msg;
      280 		m_len = message_length * 4 +4;
      281 		if ioi_type then heals_message.tally = bin (count, 6, 0) + 1;
      282 		else heals_message.tally = 1;
      283 		last_message_copied = "1"b;
      284 	        end;				/* end of last_message_copied being false */
      285 	      else do;				/* copy_this_one is false */
      286 	        last_message_copied = "0"b;
      287 	        last_msg_tallied = syserr_msg.seq_num;
      288 	        last_msg_tallied_time = syserr_msg.time;
      289 	        if buffering then do;
      290 		call copy_message;
      291 		buffering = "0"b;
      292 	        end;
      293 	      end;
      294 	    end;
      295 	  end copy_loop;
      296 	end copy_data;
      297 finish:
      298 	if arg_info.err_nb = 0 then
      299 	  if buffering then
      300 	    call copy_message;
      301 	if no_of_recs_copied > 0 then
      302 	  call ioa_
      303 	  ("^5x^d message^v(s^) copied into:^/^a",
      304 	  no_of_recs_copied, bin (no_of_recs_copied > 1, 1, 0),
      305 	  before (arg_info.heals_log_path_name, " "));
      306 	call datap -> arg_info.iocbp -> iocb.close (
      307 	  datap -> arg_info.iocbp, code);
      308 	call syserr_log_util_$close (code);
      309 	if code ^= 0 then
      310 ret:	  return;
      311 	arg_info.err_nb = 0;			/* indicate satisfactory return */
      312 	return;
      313 
      314 /* proc to copy heals messages. */
      315 copy_message: proc;
      316 dcl  based_key char (8) based (addr (heals_message.time));
      317 dcl  key char (256) varying;
      318 	  key = based_key;				/* for seek_key operation */
      319 	  call arg_info.iocbp -> iocb.seek_key
      320 	    (arg_info.iocbp, key, 0, code);
      321 	  if code = error_table_$no_record then do;
      322 	    call arg_info.iocbp -> iocb.write_record (arg_info.iocbp,
      323 	      heals_message_p, m_len, code);
      324 	    if code = 0 then do;
      325 	      no_of_recs_copied = no_of_recs_copied + 1;
      326 	      heals_state.last_message_seq_num = last_msg_tallied;
      327 	      heals_state.last_message_time = last_msg_tallied_time;
      328 	    end;
      329 	    else do;
      330 	      call com_err_
      331 	        (code, "heals_collect_data_",
      332 	        "error writing record ^d into heals_log.", heals_message.seq_num);
      333 copy_error:
      334 	      arg_info.err_nb = -1;
      335 	      go to finish;
      336 	    end;
      337 	  end;
      338 	  else if code ^= error_table_$key_order
      339 	  then do;				/* bad code from seek_key operation above. */
      340 	    call com_err_ (code, "heals_collect_data_", "could not create a key for message ^d.",
      341 	      heals_message.seq_num);
      342 	    go to copy_error;
      343 	  end;
      344 	  heals_message.tally = 0;			/* reset it */
      345 	  if heals_message.data_size > 0 then
      346 	    heals_message.data (*) = "0"b;
      347 	  return;
      348 	end copy_message;
      349         end heals_collect_data_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/27/84  0744.1  heals_collect_data_.pl1           >spec>on>heals>heals_collect_data_.pl1
15           1    11/02/76  1752.0  heals_arg_info.incl.pl1           >ldd>include>heals_arg_info.incl.pl1
16           2    10/25/77  1258.3  heals_message.incl.pl1            >ldd>include>heals_message.incl.pl1
17           3    11/10/82  1749.8  heals_state.incl.pl1              >ldd>include>heals_state.incl.pl1
18           4    08/18/77  1118.1  syserr_message.incl.pl1           >ldd>include>syserr_message.incl.pl1
19           5    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
168          6    08/10/81  1843.6  io_syserr_msg.incl.pl1            >ldd>include>io_syserr_msg.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 70 ref 79 93 100 101 172 172 192 318
answer                          000252 automatic       char(8)                  initial unaligned dcl 34 set ref 34* 140* 143
arg_info                               based           structure                level 1 unaligned dcl 20
based_key                              based           char(8)                  unaligned dcl 316 ref 318
bin                                                    builtin function         dcl 70 ref 240 256 281 301 301
buffering                       002261 automatic       bit(1)                   initial dcl 63 set ref 63* 214* 255 267* 274 276*
                                                                                  289 291* 297
bulk_data                              defined         bit(1)                   unaligned dcl 52 ref 206
bulk_type                       002272 automatic       bit(1)                   dcl 65 set ref 184* 208* 226
cleanup                         002274 stack reference condition                dcl 69 ref 85
close                    36            based           entry variable           level 2 dcl 5-6 ref 306
code                                   parameter       fixed bin(35,0)          dcl 30 in procedure "heals_collect_data_" set ref 14
                                                                                  82* 86* 89* 90* 97* 133* 152* 155 155 157* 177*
                                                                                  306* 308* 309 319* 321 322* 324 330* 338 340*
code                      3            based           fixed bin(11,0)          level 2 in structure "syserr_msg" packed unaligned
                                                                                  dcl 4-9 in procedure "heals_collect_data_" ref 262
code                      4            based           fixed bin(11,0)          level 3 in structure "heals_message" packed
                                                                                  unaligned dcl 2-3 in procedure
                                                                                  "heals_collect_data_" set ref 262*
com_err_                        000030 constant        entry                    external dcl 54 ref 90 96 103 117 122 129 157 176
                                                                                  330 340
command_query_                  000026 constant        entry                    external dcl 53 ref 140
copy_this_one                   002323 automatic       bit(1)                   dcl 170 set ref 184* 226* 228
count                     0(30)        based           bit(6)                   level 2 packed unaligned dcl 6-14 ref 240 256 281
cpu_data                               defined         bit(1)                   unaligned dcl 48 ref 194
cpu_type                        002265 automatic       bit(1)                   dcl 65 set ref 184* 196* 226
data                                   based           bit(36)                  array level 2 in structure "syserr_msg" dcl 4-9
                                                                                  in procedure "heals_collect_data_" set ref 192 235
                                                                                  235 245 265
data                                   based           bit(36)                  array level 3 in structure "heals_message" dcl 2-3
                                                                                  in procedure "heals_collect_data_" set ref 222*
                                                                                  235 235 245 265* 345*
data_size                 4(24)        based           fixed bin(11,0)          level 3 in structure "heals_message" packed
                                                                                  unaligned dcl 2-3 in procedure
                                                                                  "heals_collect_data_" set ref 218* 220 222 233 235
                                                                                  235 245 263* 265 277* 279 345 345
data_size                 3(24)        based           fixed bin(11,0)          level 2 in structure "syserr_msg" packed unaligned
                                                                                  dcl 4-9 in procedure "heals_collect_data_" ref 218
                                                                                  233 235 235 245 263 265 277 279
datap                                  parameter       pointer                  dcl 21 ref 14 78 80 81 82 82 88 88 106 126 130 152
                                                                                  152 182 183 186 186 194 198 202 206 297 301 301
                                                                                  306 306 311 319 319 322 322 333
disk_data                              defined         bit(1)                   unaligned dcl 51 ref 202
disk_type                       002267 automatic       bit(1)                   dcl 65 set ref 184* 204* 226
dn355_type                      002270 automatic       bit(1)                   dcl 65 set ref 184* 188* 226
err_nb                    4            based           fixed bin(35,0)          level 2 dcl 20 set ref 78* 106* 130* 297 311* 333*
error_table_$bad_arg            000014 external static fixed bin(35,0)          dcl 36 ref 89
error_table_$end_of_info        000024 external static fixed bin(35,0)          dcl 40 ref 174
error_table_$file_busy          000016 external static fixed bin(35,0)          dcl 37 ref 155
error_table_$key_order          000012 external static fixed bin(35,0)          dcl 35 ref 338
error_table_$no_record          000010 external static fixed bin(35,0)          dcl 35 ref 321
error_table_$not_attached       000022 external static fixed bin(35,0)          dcl 38 ref 97
error_table_$not_closed         000020 external static fixed bin(35,0)          dcl 38 ref 113
first_record                    002262 automatic       bit(1)                   initial unaligned dcl 64 set ref 64* 211 213*
from_time               126            based           fixed bin(71,0)          level 2 dcl 20 set ref 88 126* 183
hcs_$initiate                   000034 constant        entry                    external dcl 55 ref 82
heals_arg_info                  000100 automatic       structure                level 1 dcl 1-4
heals_log_path_name      30            based           char(168)                level 2 packed unaligned dcl 20 ref 80 81 82 82 301
                                                                                  301
heals_message                          based           structure                level 1 dcl 2-3
heals_message_p                 000232 automatic       pointer                  dcl 2-15 set ref 101* 218 219 220 221 222 223 233
                                                                                  233 235 235 240 240 245 247 247 256 258 260 261
                                                                                  262 263 264 265 266 277 278 279 281 282 318 322*
                                                                                  330 340 344 345 345
heals_state                            based           structure                level 1 dcl 3-4
heals_state_p                   000234 automatic       pointer                  dcl 3-8 set ref 82* 85 137 137 147 147 326 327
i                               000246 automatic       fixed bin(21,0)          dcl 31 set ref 80* 81* 81 82 82
index                                                  builtin function         dcl 70 ref 80 187 188 189 190 191 194 198 202 206
info_selection            5            based           bit(72)                  level 2 packed unaligned dcl 20 ref 186 186 186 186
                                                                                  194 194 198 198 202 202 206 206
input_record                    000261 automatic       char(2048)               initial unaligned dcl 44 set ref 44* 100 172 172 172
                                                                                  172
io_data                                defined         bit(1)                   unaligned dcl 46 ref 186
io_msg                                 based           structure                level 1 dcl 6-14
io_msgp                         002320 automatic       pointer                  dcl 6-12 set ref 192* 240 256 281
ioa_                            000032 constant        entry                    external dcl 54 ref 147 301
iocb                                   based           structure                level 1 dcl 5-6
iocbp                                  based           pointer                  level 2 dcl 20 set ref 152 152* 306 306* 319 319*
                                                                                  322 322*
ioi_type                        002263 automatic       bit(1)                   dcl 65 set ref 184* 190* 191* 226 235 256 281
iom_type                        002271 automatic       bit(1)                   dcl 65 set ref 184* 189* 226
key                             002334 automatic       varying char(256)        dcl 317 set ref 318* 319*
keyed_sequential_output                constant        fixed bin(17,0)          initial dcl 67 ref 152
last_message_copied             002273 automatic       bit(1)                   initial dcl 68 set ref 68* 215* 228 269* 283* 286*
last_message_seq_num      2            based           fixed bin(35,0)          level 2 dcl 3-4 set ref 137 147 147* 326*
last_message_time                      based           fixed bin(71,0)          level 2 dcl 3-4 set ref 137 327*
last_msg_tallied                000254 automatic       fixed bin(35,0)          dcl 41 set ref 270* 287* 326
last_msg_tallied_time           000256 automatic       fixed bin(71,0)          dcl 42 set ref 271* 288* 327
log_code                        000247 automatic       fixed bin(35,0)          dcl 32 set ref 87* 94* 95 96* 105* 110* 112 113 114*
                                                                                  117* 126* 128 129* 132* 133 158* 162* 172* 174 174
                                                                                  176*
m_len                           000260 automatic       fixed bin(21,0)          dcl 43 set ref 224* 259* 280* 322*
message_length                  002322 automatic       fixed bin(21,0)          dcl 169 set ref 172* 224 259 280
mos_edac_data                          defined         bit(1)                   unaligned dcl 49 ref 198
mos_type                        002266 automatic       bit(1)                   dcl 65 set ref 184* 200* 226
no_of_recs_copied               000250 automatic       fixed bin(35,0)          initial dcl 33 set ref 33* 301 301* 301 301 325* 325
null                                                   builtin function         dcl 70 ref 85
open                     32            based           entry variable           level 2 dcl 5-6 ref 152
open_status                     002313 automatic       bit(36)                  dcl 74 set ref 110* 117 122
output_record                   001261 automatic       char(2048)               initial unaligned dcl 45 set ref 45* 101
qip                             000240 automatic       pointer                  dcl 22 set ref 79* 140*
query_code                3     000242 automatic       fixed bin(35,0)          initial level 2 dcl 23 set ref 23*
query_info                      000242 automatic       structure                level 1 dcl 23 set ref 79
rcp_type                        002264 automatic       bit(1)                   dcl 65 set ref 184* 187* 226
record_quota_overflow           002302 stack reference condition                dcl 69 ref 102
rest_of_record            1            based           structure                level 2 dcl 2-3 set ref 220* 279*
reverse                                                builtin function         dcl 70 ref 80
rseq                            002316 automatic       fixed bin(35,0)          dcl 76 set ref 126* 137 147
rtime                           002314 automatic       fixed bin(71,0)          dcl 75 set ref 126* 137
seek_key                112            based           entry variable           level 2 dcl 5-6 ref 319
seq_num                   1            based           fixed bin(35,0)          level 3 in structure "heals_message" dcl 2-3
                                                                                  in procedure "heals_collect_data_" set ref 260*
                                                                                  330* 340*
seq_num                                based           fixed bin(35,0)          level 2 in structure "syserr_msg" dcl 4-9
                                                                                  in procedure "heals_collect_data_" ref 260 270 287
slu_status                      002312 automatic       structure                level 1 dcl 72 set ref 93
slu_statusp                     002310 automatic       pointer                  dcl 71 set ref 93* 94*
sorted_io_data                         defined         bit(1)                   unaligned dcl 50 ref 186
status_code               2     000242 automatic       fixed bin(35,0)          level 2 dcl 23 set ref 139*
substr                                                 builtin function         dcl 70 ref 82 82 122 143 235 235 235 235
suppress_name_sw          1(01) 000242 automatic       bit(1)                   initial level 2 packed unaligned dcl 23 set ref 23*
syserr_log_util_$close          000042 constant        entry                    external dcl 59 ref 105 114 132 158 162 177 308
syserr_log_util_$open           000046 constant        entry                    external dcl 61 ref 110
syserr_log_util_$read           000040 constant        entry                    external dcl 58 ref 172
syserr_log_util_$search         000044 constant        entry                    external dcl 60 ref 126
syserr_log_util_$status         000036 constant        entry                    external dcl 57 ref 94
syserr_msg                             based           structure                level 1 dcl 4-9 set ref 279
syserr_msgp                     000236 automatic       pointer                  dcl 4-7 set ref 100* 182 183 187 188 189 190 191 192
                                                                                  194 198 202 206 218 219 233 233 235 235 245 260
                                                                                  261 262 263 264 265 266 270 271 277 278 279 287
                                                                                  288
tally                                  based           fixed bin(35,0)          level 2 dcl 2-3 set ref 223* 240* 240 247* 247 256*
                                                                                  258* 281* 282* 344*
text                      7            based           char                     level 3 in structure "heals_message" dcl 2-3
                                                                                  in procedure "heals_collect_data_" set ref 221*
                                                                                  233 266*
text                      6            based           char                     level 2 in structure "syserr_msg" dcl 4-9
                                                                                  in procedure "heals_collect_data_" ref 187 188 189
                                                                                  190 191 194 198 202 206 233 266
text_len                  4(12)        based           fixed bin(11,0)          level 3 in structure "heals_message" packed
                                                                                  unaligned dcl 2-3 in procedure
                                                                                  "heals_collect_data_" set ref 219* 220 221 222 233
                                                                                  235 235 245 264* 265 266 278* 279 279 345
text_len                  3(12)        based           fixed bin(11,0)          level 2 in structure "syserr_msg" packed unaligned
                                                                                  dcl 4-9 in procedure "heals_collect_data_" ref 187
                                                                                  188 189 190 191 192 194 198 202 206 219 233 235
                                                                                  235 245 264 265 266 278 279 279
time                      2            based           fixed bin(71,0)          level 3 in structure "heals_message" packed
                                                                                  unaligned dcl 2-3 in procedure
                                                                                  "heals_collect_data_" set ref 261* 318
time                      1            based           fixed bin(71,0)          level 2 in structure "syserr_msg" packed unaligned
                                                                                  dcl 4-9 in procedure "heals_collect_data_" ref 182
                                                                                  183 261 271 288
to_time                 130            based           fixed bin(71,0)          level 2 dcl 20 ref 88 182
version                         000242 automatic       fixed bin(17,0)          initial level 2 dcl 23 set ref 23*
write_record             76            based           entry variable           level 2 dcl 5-6 ref 322
yes_or_no_sw              1     000242 automatic       bit(1)                   initial level 2 packed unaligned dcl 23 set ref 23*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
error_table_$key_duplication           external static fixed bin(35,0)          dcl 35
error_table_$not_open                  external static fixed bin(35,0)          dcl 38
heals_log_info$                        external static fixed bin(35,0)          array dcl 3-9
iox_$iocb_version_sentinel             external static char(4)                  dcl 5-51
mpc_data                               defined         bit(1)                   unaligned dcl 47
search_time                            automatic       fixed bin(71,0)          dcl 75
syserr_log_util_$position       000000 constant        entry                    external dcl 62
sysmsgp                                automatic       pointer                  dcl 29

NAMES DECLARED BY EXPLICIT CONTEXT.
continue_to_copy                001257 constant        label                    dcl 152 ref 143
copy_data                       001361 constant        label                    dcl 167
copy_error                      002722 constant        label                    dcl 333 ref 342
copy_loop                       001361 constant        label                    dcl 171
copy_message                    002572 constant        entry                    internal dcl 315 ref 255 274 290 297
early_return                    001141 constant        label                    dcl 130 ref 120 144
finish                          002447 constant        label                    dcl 297 ref 174 182 335
get_answer                      001171 constant        label                    dcl 140
have_rec_type                   001667 constant        label                    dcl 211
heals_collect_data_             000371 constant        entry                    external dcl 14
keep_text                       002263 constant        label                    dcl 267 ref 242 248
open_syserr_log                 000745 constant        label                    dcl 110 ref 115
ret                             002565 constant        label                    dcl 309 ref 107
syserr_log_is_open              001026 constant        label                    dcl 122 ref 117

NAMES DECLARED BY CONTEXT OR IMPLICATION.
before                                                 builtin function         ref 301 301
length                                                 builtin function         ref 81
size                                                   builtin function         ref 172 172
unspec                                                 builtin function         ref 220 235 235 235 235 245 245

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3230        3300    3023        3240
Length      3622    3023        50         305     205           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
heals_collect_data_                1477 external procedure  is an external procedure.  
on unit on line 102                 110 on unit               
begin block on line 167                 begin block         shares stack frame of external procedure heals_collect_data_.  
copy_message                            internal procedure  shares stack frame of external procedure heals_collect_data_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
heals_collect_data_      000100 heals_arg_info              heals_collect_data_
                         000232 heals_message_p             heals_collect_data_
                         000234 heals_state_p               heals_collect_data_
                         000236 syserr_msgp                 heals_collect_data_
                         000240 qip                         heals_collect_data_
                         000242 query_info                  heals_collect_data_
                         000246 i                           heals_collect_data_
                         000247 log_code                    heals_collect_data_
                         000250 no_of_recs_copied           heals_collect_data_
                         000252 answer                      heals_collect_data_
                         000254 last_msg_tallied            heals_collect_data_
                         000256 last_msg_tallied_time       heals_collect_data_
                         000260 m_len                       heals_collect_data_
                         000261 input_record                heals_collect_data_
                         001261 output_record               heals_collect_data_
                         002261 buffering                   heals_collect_data_
                         002262 first_record                heals_collect_data_
                         002263 ioi_type                    heals_collect_data_
                         002264 rcp_type                    heals_collect_data_
                         002265 cpu_type                    heals_collect_data_
                         002266 mos_type                    heals_collect_data_
                         002267 disk_type                   heals_collect_data_
                         002270 dn355_type                  heals_collect_data_
                         002271 iom_type                    heals_collect_data_
                         002272 bulk_type                   heals_collect_data_
                         002273 last_message_copied         heals_collect_data_
                         002310 slu_statusp                 heals_collect_data_
                         002312 slu_status                  heals_collect_data_
                         002313 open_status                 heals_collect_data_
                         002314 rtime                       heals_collect_data_
                         002316 rseq                        heals_collect_data_
                         002320 io_msgp                     begin block on line 167
                         002322 message_length              begin block on line 167
                         002323 copy_this_one               begin block on line 167
                         002334 key                         copy_message

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               alloc_cs            alloc_bs            call_var            call_ext_out_desc   call_ext_out
begin_return        return              tra_ext             bound_check_signal  signal              enable
shorten_stack       ext_entry           int_entry           set_cs_eis          index_cs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      command_query_                hcs_$initiate                 ioa_
syserr_log_util_$close        syserr_log_util_$open         syserr_log_util_$read         syserr_log_util_$search
syserr_log_util_$status

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$end_of_info      error_table_$file_busy        error_table_$key_order
error_table_$no_record        error_table_$not_attached     error_table_$not_closed




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 000365        23 000376        33 000405        34 000406        44 000410        45 000413        63 000416
     64 000417        68 000421        78 000422        79 000427        80 000431        81 000442        82 000444
     85 000521        86 000531        87 000533        88 000534        89 000541        90 000544        91 000575
     93 000576        94 000600        95 000611        96 000613        97 000645        98 000651       100 000652
    101 000654       102 000656       103 000672       105 000724       106 000734       107 000742       110 000745
    112 000756       113 000760       114 000763       115 000771       117 000772       120 001025       122 001026
    126 001065       128 001105       129 001107       130 001141       132 001146       133 001155       134 001160
    137 001161       139 001170       140 001171       143 001227       144 001233       147 001234       152 001257
    155 001303       157 001311       158 001342       159 001351       162 001352       163 001360       171 001361
    172 001362       174 001403       176 001410       177 001441       178 001451       182 001453       183 001464
    184 001466       186 001477       187 001506       188 001523       189 001535       190 001547       191 001561
    192 001572       194 001577       196 001613       198 001615       200 001631       202 001633       204 001647
    206 001651       208 001665       211 001667       213 001671       214 001672       215 001673       218 001674
    219 001677       220 001701       221 001722       222 001730       223 001753       224 001754       226 001760
    228 002002       233 002006       235 002037       240 002077       242 002107       244 002110       245 002111
    247 002136       248 002142       255 002143       256 002146       258 002155       259 002157       260 002163
    261 002166       262 002174       263 002176       264 002200       265 002202       266 002251       267 002263
    269 002265       270 002266       271 002270       272 002275       274 002276       276 002301       277 002303
    278 002307       279 002311       280 002415       281 002421       282 002430       283 002432       284 002434
    286 002435       287 002436       288 002440       289 002442       290 002444       291 002445       295 002446
    297 002447       301 002457       306 002535       308 002552       309 002562       311 002566       312 002571
    315 002572       318 002573       319 002602       321 002623       322 002630       324 002647       325 002652
    326 002656       327 002661       328 002663       330 002664       333 002722       335 002727       337 002730
    338 002731       340 002733       342 002770       344 002771       345 002772       347 003021


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
