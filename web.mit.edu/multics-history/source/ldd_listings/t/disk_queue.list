	COMPILATION LISTING OF SEGMENT disk_queue
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/08/88  1127.8 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1987 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-11-10,Fawcett), approve(86-11-10,MCR7125),
       12*     audit(87-01-08,Farley), install(87-01-09,MR12.0-1266):
       13*     Changed / Rewritten by Tom Oke. Modified by RAF to use copy_erf_seg_
       14*     instead of copy_out_. copy_out_ was never installed in the system
       15*     libraries. This version calls get_vol_list_ for device and pv names.
       16*  2) change(88-02-22,Parisek), approve(88-02-22,MCR7753),
       17*     audit(88-02-23,Fawcett), install(88-03-01,MR12.2-1031):
       18*     Remove the "-interpret" and "-no_interpret" control arguments and
       19*     remove all references to interpret_sw which is set by these control
       20*     arguments.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 disk_queue:
       25 dq:  proc () options (variable);
       26 
       27 /* coded 12/17/70 by Noel I. Morris
       28*   revised 4/16/71 by Noel I. Morris
       29*   revised 7/25/72 by Lee J. Scheffler to handle new DSU_170 DIM and
       30*   DSU-181 version I DIM
       31*   Re-coded 04/02/80 W. Olin Sibert, to add FDUMP support, pathname interpretation, many features.
       32*   Modified for new adaptive disk dim modifications and to remove
       33*	paging device support, T. Oke 84-09-24.
       34*   84-12-10 by T. Oke, modified to use get_vol_list_ for volume names and
       35*          release database segments on erf or -rl.
       36**/
       37 
       38 	dcl     areas		 area based;
       39 
       40 	dcl     (argno, nargs)	 fixed bin;
       41 	dcl     ap		 ptr;
       42 	dcl     al		 fixed bin (21);
       43 	dcl     arg		 char (al) based (ap);
       44 	dcl     code		 fixed bin (35);
       45 	dcl     cmpp		 ptr;
       46 	dcl     subsystem_name	 char (4) aligned;
       47 	dcl     subsystem_found	 bit (1) aligned;
       48 	dcl     erf_name		 char (32);
       49 	dcl     erf_sw		 bit (1);
       50 	dcl     seg_len		 fixed bin (19) uns;
       51 	dcl     (long_sw, all_sw, live_sw) bit (1) aligned;
       52 	dcl     (sector_sw, record_sw, read_sw, write_sw) bit (1) aligned;
       53 	dcl     entry_count		 fixed bin;
       54 	dcl     idx		 fixed bin;
       55 
       56 
       57 	dcl     com_err_		 entry options (variable);
       58 	dcl     copy_erf_seg_$name	 entry (char (*), char (*), ptr, uns fixed bin (19), fixed bin (35));
       59 	dcl     cu_$arg_count	 entry (fixed bin);
       60 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
       61 	dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
       62 	dcl     date_time_		 entry (fixed bin (71), char (*));
       63 	dcl     get_vol_list_	 entry (ptr, ptr, ptr, char (8), fixed bin (35));
       64 	dcl     ioa_		 entry options (variable);
       65 	dcl     (get_temp_segment_, release_temp_segment_) entry (char (*), ptr, fixed bin (35));
       66 	dcl     request_id_		 entry (fixed bin (71)) returns (char (19));
       67 
       68 	dcl     (error_table_$badopt,
       69 	        error_table_$bad_conversion,
       70 	        error_table_$inconsistent,
       71 	        error_table_$noarg)	 fixed bin (35) external static;
       72 
       73 	dcl     WHOAMI		 char (32) internal static options (constant) init ("disk_queue");
       74 
       75 	dcl     cleanup		 condition;
       76 
       77 	dcl     (addr, binary, hbound, lbound, null, ptr, substr) builtin;
       78 
       79 /*  */
       80 	disksp, cmpp, sstp, pv_list_ptr, lv_list_ptr = null ();
       81 	all_sw, live_sw, long_sw = "0"b;
       82 	sector_sw, record_sw, read_sw, write_sw = "0"b;
       83 	entry_count = -1;
       84 	erf_name = "-1";
       85 	erf_sw = "0"b;
       86 	subsystem_name = "";
       87 	code = 0;
       88 
       89 	on cleanup call clean_up_segs;
       90 
       91 	call cu_$arg_count (nargs);
       92 	do argno = 1 to nargs;
       93 	     call cu_$arg_ptr (argno, ap, al, (0));
       94 	     if substr (arg, 1, 1) ^= "-" then do;	/* the subsystem name */
       95 		     if subsystem_name ^= "" then do;
       96 			     call com_err_ (0, WHOAMI, "Only one subsystem name may be supplied. ^a", arg);
       97 			     goto MAIN_RETURN;
       98 			end;
       99 
      100 		     subsystem_name = arg;
      101 		end;
      102 
      103 	     else if arg = "-all" | arg = "-a" then all_sw = "1"b;
      104 	     else if arg = "-live" then live_sw = "1"b;
      105 	     else if arg = "-brief" | arg = "-bf" then long_sw = "0"b;
      106 	     else if arg = "-long" | arg = "-lg" then long_sw = "1"b;
      107 	     else if arg = "-page" | arg = "-pg" | arg = "-record" | arg = "-rec" then record_sw = "1"b;
      108 	     else if arg = "-vtoc" | arg = "-sector" | arg = "-sec" then sector_sw = "1"b;
      109 	     else if arg = "-read" then read_sw = "1"b;
      110 	     else if arg = "-write" then write_sw = "1"b;
      111 
      112 	     else if arg = "-erf" then do;		/* pick up ERF number */
      113 		     if argno = nargs then do;
      114 ARG_MISSING:		     call com_err_ (error_table_$noarg, WHOAMI, "After ^a", arg);
      115 			     goto MAIN_RETURN;
      116 			end;
      117 
      118 		     argno = argno + 1;
      119 		     call cu_$arg_ptr (argno, ap, al, (0));
      120 
      121 		     if erf_sw then do;
      122 			     call com_err_ (0, WHOAMI, "Only one FDUMP name may be supplied. ^a", arg);
      123 			     goto MAIN_RETURN;
      124 			end;
      125 
      126 		     erf_name = arg;
      127 		     erf_sw = "1"b;
      128 		end;
      129 
      130 	     else if arg = "-last" | arg = "-lt" then do; /* last N finished queue entries */
      131 		     if argno = nargs then goto ARG_MISSING;
      132 
      133 		     argno = argno + 1;
      134 		     call cu_$arg_ptr (argno, ap, al, (0));
      135 		     entry_count = cv_dec_check_ (arg, code);
      136 		     if code ^= 0 then do;
      137 			     code = error_table_$bad_conversion;
      138 BAD_ENTRY_COUNT:		     call com_err_ (code, WHOAMI,
      139 				"-last must be followed by a positive, nonzero number, not ^a.", arg);
      140 			     goto MAIN_RETURN;
      141 			end;
      142 		end;				/* of processing for -last */
      143 
      144 	     else do;
      145 		     call com_err_ (error_table_$badopt, WHOAMI, "^a", arg);
      146 		     goto MAIN_RETURN;
      147 		end;
      148 	end;					/* argument loop */
      149 
      150 	if all_sw & (entry_count > 0) then do;
      151 		call com_err_ (error_table_$inconsistent, WHOAMI, "-all and -last");
      152 		goto MAIN_RETURN;
      153 	     end;
      154 
      155 	if all_sw & live_sw then do;
      156 		call com_err_ (error_table_$inconsistent, WHOAMI, "-all and -live");
      157 		goto MAIN_RETURN;
      158 	     end;
      159 
      160 	if (entry_count <= 0) & (^all_sw) & (^live_sw) then /* apply defaults */
      161 	     live_sw = "1"b;
      162 
      163 	if all_sw then /* translate into both */
      164 	     live_sw = "1"b;			/* and all the new ones besides */
      165 
      166 	if (sector_sw = "0"b) & (record_sw = "0"b) then
      167 	     sector_sw, record_sw = "1"b;
      168 
      169 	if (read_sw = "0"b) & (write_sw = "0"b) then
      170 	     read_sw, write_sw = "1"b;
      171 
      172 /*  */
      173 	call init_segs;
      174 	if code ^= 0 then do;
      175 		call com_err_ (code, WHOAMI);
      176 		goto MAIN_RETURN;
      177 	     end;
      178 
      179 	call copy_erf_seg_$name (erf_name, "disk_seg", disksp, seg_len, code);
      180 	if code ^= 0 then do;
      181 		call com_err_ (code, WHOAMI, "disk_seg");
      182 		goto MAIN_RETURN;
      183 	     end;
      184 
      185 	call get_vol_list_ (pv_list_ptr, lv_list_ptr, null (), get_vol_list_version, code);
      186 	if code ^= 0 then do;
      187 		call com_err_ (code, WHOAMI, "Cannot get volume data.");
      188 		goto MAIN_RETURN;
      189 	     end;
      190 
      191 	if all_sw then entry_count = disk_data.free_q_size;
      192 	subsystem_found = "0"b;
      193 	do idx = 1 to disk_data.subsystems;		/* Loop through all subsystems */
      194 	     diskp = ptr (disksp, disk_data.array (idx).offset); /* get pointer to disktab for this subsystem */
      195 	     if (subsystem_name = "") | (subsystem_name = disk_data.array (idx).name) then do; /* print it */
      196 		     call process_subsystem (disk_data.array (idx).name); /* if no name specified, process them all */
      197 		     subsystem_found = "1"b;		/* remember, so not to print error message */
      198 		end;
      199 	end;					/* of loop through subsystems */
      200 	call process_free_queue;
      201 
      202 	if ^subsystem_found then call com_err_
      203 		(0, WHOAMI, "Subsystem ^a not found^[ in ERF ^a^].",
      204 		subsystem_name, erf_sw, erf_name);
      205 
      206 MAIN_RETURN:
      207 	call clean_up_segs;				/* turf the space */
      208 	return;					/* all done */
      209 
      210 init_segs:
      211      proc;
      212 	if disksp = null () then
      213 	     call get_temp_segment_ (WHOAMI, disksp, code);
      214 	if code ^= 0 then return;
      215 
      216 	if sstp = null () then
      217 	     call get_temp_segment_ (WHOAMI, sstp, code);
      218 	if code ^= 0 then return;
      219 	if cmpp = null () then
      220 	     call get_temp_segment_ (WHOAMI, cmpp, code);
      221 	if code ^= 0 then return;
      222      end init_segs;
      223 
      224 
      225 
      226 clean_up_segs:
      227      proc;
      228 	if disksp ^= null () then
      229 	     call release_temp_segment_ (WHOAMI, disksp, code);
      230 	if sstp ^= null () then
      231 	     call release_temp_segment_ (WHOAMI, sstp, code);
      232 	if cmpp ^= null () then
      233 	     call release_temp_segment_ (WHOAMI, cmpp, code);
      234 
      235 	if pv_list_ptr ^= null () then
      236 	     free pv_list in (pv_list.area_ptr -> areas);
      237 
      238 
      239 	if lv_list_ptr ^= null () then
      240 	     free lv_list in (lv_list.area_ptr -> areas);
      241 
      242 	disksp, sstp, cmpp, lv_list_ptr, pv_list_ptr = null ();
      243 	return;
      244      end clean_up_segs;
      245 						/*  */
      246 
      247 process_subsystem: proc (p_subsystem_name) options (non_quick);
      248 
      249 /* This procedure processes a single subsystems worth of data. It expects diskp to
      250*   point to the disktab for the subsystem. */
      251 
      252 	dcl     p_subsystem_name	 char (*) parameter;
      253 	dcl     P_subsystem_name	 char (32);
      254 
      255 	dcl     last_time		 fixed bin (71);
      256 	dcl     first_sw		 bit (1) aligned;
      257 	dcl     dev		 fixed bin (17);
      258 	dcl     qrp		 bit (18) aligned;
      259 	dcl     qrp_count		 fixed bin;
      260 	dcl     matching_entries	 fixed bin;
      261 
      262 
      263 
      264 	P_subsystem_name = p_subsystem_name;
      265 	first_sw = "1"b;				/* first time around, print header -- do this only once, */
      266 	matching_entries = 0;			/* for both live and dead queue entries */
      267 	if live_sw then do;				/* print info about pending requests */
      268 		last_time = 0;			/* appear to cross a minute boundary on first time thru */
      269 
      270 		do dev = lbound (disktab.devtab, 1) to
      271 		     hbound (disktab.devtab, 1);
      272 		     dp = addr (disktab.devtab (dev));
      273 		     qrp = devtab.wq.head;		/* Get rel ptr to head of queue. */
      274 		     do while (qrp ^= ""b);		/* Search through the queue. */
      275 			qp = ptr (disksp, qrp);	/* and print all the live ones */
      276 			call print_queue_entry ();	/* print this one */
      277 			if quentry.used ^= "1"b then do; /* prospect for anomalies */
      278 				call ioa_ ("^4xLast queue entry at ^o is threaded, but not marked in-use.",
      279 				     qrp);
      280 				qrp = "0"b;	/* kill chain */
      281 			     end;
      282 			else qrp = quentry.next;	/* Get index of next queue entry. */
      283 		     end;
      284 		end;
      285 
      286 		if first_sw then /* if nothing was outstanding, say so */
      287 		     call ioa_ ("^/^a: Live queue empty.", P_subsystem_name);
      288 	     end;					/* of printing live queue entries & stuff */
      289 
      290 
      291 	if matching_entries = 0 then
      292 	     call ioa_ ("^a: No^[^s^s^;^[ read^]^[ write^]^] requests^[^s^s^; for^[ VTOC^]^[ page^] I/O^].",
      293 		P_subsystem_name,
      294 		(read_sw & write_sw), read_sw, write_sw, (record_sw & sector_sw), sector_sw, record_sw);
      295 
      296 	return;
      297 
      298 process_free_queue:
      299      entry;
      300 
      301 	P_subsystem_name = "Free";
      302 	if entry_count > 0 then do;			/* print most recent queue entries, too */
      303 		qrp = disk_data.free_q.tail;
      304 		qrp_count = 0;
      305 		last_time = 0;
      306 		first_sw = "1"b;
      307 		matching_entries = 0;
      308 
      309 		do while (qrp ^= ""b);		/* walk back through the queue, to reverse its order */
      310 		     qrp_count = qrp_count + 1;
      311 		     if qrp_count > disk_data.free_q_size then do; /* can't happen */
      312 			     call ioa_ ("Anomalous threading indicates more than ^d. entries in free queue.",
      313 				disk_data.free_q_size);
      314 			     qrp = ""b;		/* make sure we don't go through again */
      315 			end;
      316 
      317 		     else do;
      318 
      319 			     qp = ptr (disksp, qrp);
      320 			     call print_queue_entry ();
      321 			     if quentry.used ^= "0"b then /* prospect for anomalies */
      322 				call ioa_ ("^4xLast queue entry at ^o is free, but marked in-use.",
      323 				     qrp);
      324 			     if matching_entries = entry_count then qrp = ""b;
      325 						/* check if enough printed */
      326 			     else qrp = ptr (disksp, qrp) -> quentry.prev;
      327 			end;			/* of printing dead queue entries */
      328 		end;
      329 
      330 		if matching_entries = 0 then
      331 		     call ioa_ ("Free: No^[^s^s^;^[ read^]^[ write^]^] requests^[^s^s^; for^[ VTOC^]^[ page^] I/O^].",
      332 			(read_sw & write_sw), read_sw, write_sw, (record_sw & sector_sw), sector_sw, record_sw);
      333 
      334 	     end;
      335 	return;
      336 
      337 /*  */
      338 
      339 print_queue_entry: proc ();
      340 
      341 /* This procedure (internal to process_subsystem) prints out a single queue entry.
      342*   It prints the header, as well, the first time it is called. It expects to be
      343*   called with qp pointing to the desired entry. */
      344 
      345 	dcl     cyladd		 fixed bin (11);
      346 	dcl     devadd		 fixed bin (20);
      347 	dcl     coreadd		 fixed bin (24);
      348 	dcl     queued_time		 fixed bin (71);
      349 	dcl     (time_str_1, time_str_2) char (24);
      350 
      351 
      352 /* If we are not a read, and we want reads, or are not a write, and we want
      353*   write, then skip the entry.  Similarily for sector and record IO. */
      354 
      355 	if ^((read_sw & ^write_map (quentry.type)) |
      356 	     (write_sw & write_map (quentry.type)))
      357 	then return;				/* not desired */
      358 
      359 	if ^((sector_sw & sector_map (quentry.type)) |
      360 	     (record_sw & ^sector_map (quentry.type)))
      361 	then return;				/* not desired */
      362 
      363 	cyladd = binary (quentry.cylinder, 11);		/* extract some addresses from the queue entry */
      364 	devadd = binary (quentry.sector, 20);
      365 	coreadd = binary (quentry.coreadd, 24);
      366 	queued_time = binary (quentry.time, 71);
      367 
      368 
      369 	if first_sw then do;
      370 		if long_sw then
      371 		     call ioa_ ("^/^4a:^2xTime^5xIO Type^5xDev  PV^vx ^3xCyl^3xSector^2xMem Addr^2x(Flags)^/",
      372 			P_subsystem_name,
      373 			pv_list.pv_name_max_length - 4);
      374 		else call ioa_ ("^a:^/^2xIO Type^6xDV ^3xSector^7xMem^3x(Flags)^/",
      375 			P_subsystem_name);		/* Print header. */
      376 		first_sw = "0"b;
      377 	     end;
      378 
      379 	matching_entries = matching_entries + 1;
      380 
      381 	if long_sw then do;				/* include the time, among other things */
      382 		time_str_1 = request_id_ (last_time);	/* see if we cross a minute boundary here */
      383 		time_str_2 = request_id_ (queued_time);
      384 
      385 		if substr (time_str_1, 1, 10) ^= substr (time_str_2, 1, 10) then do; /* if MM/DD/YY HH:MM not same */
      386 			call date_time_ (queued_time, time_str_1);
      387 			call ioa_ ("Queued at ^8a ^2a:^2a:^8a --", /* print substrings from date_time */
      388 			     substr (time_str_1, 1, 8), substr (time_str_1, 11, 2),
      389 			     substr (time_str_1, 13, 2), substr (time_str_2, 11, 9));
      390 		     end;				/* of special processing for crossing a minute boundary */
      391 
      392 		call ioa_ ("^2x^9a^2x^10a^1x^8a ^va^2x^4o^2x^7o^2x^8o^[ intrpt^]^[ used^]",
      393 		     substr (time_str_2, 11, 9),	/* SS.mmmmmm -- time queued */
      394 		     io_name (quentry.type), pv_list.pv_info (quentry.pvtx).drive_name,
      395 		     pv_list.pv_name_max_length, pv_list.pv_info (quentry.pvtx).pvname,
      396 		     cyladd, devadd, coreadd, quentry.intrpt, quentry.used);
      397 
      398 		last_time = queued_time;		/* remember for next time through */
      399 	     end;
      400 
      401 	else do;					/* otherwise, just print brief stuff */
      402 		call ioa_ ("^10a^1x^8a  ^7o  ^8o^[ intrpt^]^[ used^]",
      403 		     io_name (quentry.type), pv_list.pv_info (quentry.pvtx).drive_name, devadd, coreadd, quentry.intrpt, quentry.used);
      404 	     end;
      405 
      406 	return;
      407      end print_queue_entry;				/* internal procedure print_queue_entry */
      408 
      409      end process_subsystem;				/* internal procedure process_subsystem */
      410 
      411 
  1     1 /* Begin include file ...... dskdcl.incl.pl1 */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  1     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  1     6*     Support for FIPS dev 0.
  1     7*  2) change(88-05-10,Farley), approve(88-06-03,MCR7906),
  1     8*     audit(88-08-03,Fawcett), install(88-08-08,MR12.2-1080):
  1     9*     Added reconnect_announce_time to chantab to allow announcement of
  1    10*     reconnects at a throttled rate.  Otherwise only report them in the syserr
  1    11*     log.  Also added IO_TYPE constant array for displaying I/O type.
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14 /* Structures used by the Disk DIM */
  1    15 
  1    16 /* Modified 84-03-21 by T. Oke for system wide free queue. */
  1    17 /* Modified 84-04-24 by T. Oke for dynamic channel table. */
  1    18 /* Modified 84-05-03 by T. Oke to hold sx for azm analysis. */
  1    19 /* Modified 84-05-14 by T. Oke for larger quentry and adaptive optimization. */
  1    20 /* Modifies 84-11-26 by R. A. Fawcett for device 0 (fips) */
  1    21 
  1    22 /* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
  1    23 
  1    24 dcl  disk_seg$ ext;					/* disk data segment */
  1    25 
  1    26 dcl  disksp ptr,					/* pointer to disk subsystem info */
  1    27      diskp ptr,					/* pointer to disk DIM info structure */
  1    28      optp ptr,					/* pointer to opt_info */
  1    29      sysp ptr;					/* pointer to sys_info */
  1    30 
  1    31 dcl  1 disk_data based (disksp) aligned,		/* disk subsystem information */
  1    32        2 subsystems fixed bin,			/* number of subsystems */
  1    33        2 free_offset bit (18),			/* offset of first unused location in segment */
  1    34        2 status_mask bit (36),			/* mask for checking for disk error */
  1    35        2 lock bit (36) unal,				/* disk_data lock */
  1    36        2 free_q like qht,				/* head/tail offsets */
  1    37        2 free_q_size fixed bin,			/* length of queue */
  1    38        2 array (32),				/* per subsystem info */
  1    39          (
  1    40          3 offset bit (18),				/* location of data for this subsystem */
  1    41          3 mbz bit (18),				/* low 18 of old  style indirect word */
  1    42          3 name char (4)
  1    43          ) unal,					/* name of subsystem */
  1    44        2 stagnate_time fixed bin (35),			/* stagnatation period */
  1    45        2 bail_outs fixed bin (35),			/* times ALM called PL1 */
  1    46        2 pad bit (36),				/* double word align */
  1    47        2 max_depth_reset_time fixed bin (71),		/* time max_reset done */
  1    48 						/* Upper bound is MAX_IO_TYPE, hard coded to avoid dynamic calculation */
  1    49        2 sys_info (0:6) like sys_info,			/* MUST BE DOUBLE WORD ALIGNED */
  1    50        2 free_q_entries (2 refer (disk_data.free_q_size)) like quentry;
  1    51 
  1    52 
  1    53 /* The following system table is used to hold the maximum queue loading
  1    54*   permitted system-wide for each IO type.  From the current loading and
  1    55*   the maximum loading a multiplier fraction is calculated.  These combine
  1    56*   to produce the final optimization multiplier to derive a Logcial Seek
  1    57*   from a Physical Seek. */
  1    58 
  1    59 dcl  1 sys_info aligned based (sysp),
  1    60        3 depth float bin (27),			/* current load */
  1    61        3 max_depth float bin (27),			/* max permissible */
  1    62        3 fraction float bin (27),			/* load fraction */
  1    63        3 depth_map bit (18) unaligned,			/* which depth counter */
  1    64        3 pad bit (18) unaligned;
  1    65 
  1    66 /* Maximum number of channels per sub-system.  Must be a power of two.  It must
  1    67*   be at or below the size of disk_init's chan_array size.  Shift factor is for
  1    68*   dctl's use. */
  1    69 
  1    70 dcl  dskdcl_chans_per_subsys fixed bin static options (constant) initial (32);
  1    71 dcl  dskdcl_chans_per_subsys_shift fixed bin static options (constant) initial (5);
  1    72 
  1    73 
  1    74 dcl  1 disktab based (diskp) aligned,			/* control structure for DIM's */
  1    75        2 lock bit (36) unal,				/* data base lock */
  1    76        2 nchan fixed bin,				/* number of disk channels */
  1    77        2 first_dev fixed bin unal,			/* frist device number  0 or 1 */
  1    78        2 last_dev fixed bin unal,			/* highest disk drive number */
  1    79        2 channels_online fixed bin,			/* number of disk channels actually in use */
  1    80        2 dev_busy bit (72),				/* busy bit for each device (only 0-63 used) */
  1    81        2 dev_queued bit (72),				/* requests queued bit for each device (only 0-63 used) */
  1    82        2 abs_mem_addr fixed bin (26) unsigned,		/* absolute memory address of this structure */
  1    83        2 channels bit (18) unal,			/* location of chantab for this subsystem */
  1    84        2 dev_index fixed bin (17) unal,			/* current device to check */
  1    85        2 errors fixed bin,				/* error count */
  1    86        2 ferrors fixed bin,				/* fatal error count */
  1    87        2 edac_errors fixed bin,			/* count of EDAC correctable errors */
  1    88        2 call_lock_meters like disk_lock_meters,		/* lock meters for call side of DIM */
  1    89        2 int_lock_meters like disk_lock_meters,		/* lock meters for interrupt side of DIM */
  1    90        2 alloc_wait_meters like disk_lock_meters,		/* meters for queue entry allocations */
  1    91        2 run_lock_meters like disk_lock_meters,		/* lock meters for run calls */
  1    92        2 devtab (0:0 refer (disktab.last_dev)) like devtab; /* device information table */
  1    93 
  1    94 dcl  1 disk_channel_table (1 refer (disktab.nchan)) like chantab based aligned;
  1    95 
  1    96 
  1    97 dcl  qp ptr,					/* pointer to queue entry */
  1    98      cp ptr;					/* pointer to channel information table */
  1    99 
  1   100 
  1   101 /* Queue entry, 6 words.  Cylinder and sector variables are over-size for
  1   102*   expansion space.  They will always be positive and upper bits can be
  1   103*   stolen for other fields.
  1   104*
  1   105*   Entries are forward and back linked to permit easy chasing and removal. */
  1   106 
  1   107 dcl  1 quentry based (qp) aligned,			/* queue entry */
  1   108 						/* WORD 1 */
  1   109        2 next bit (18) unaligned,			/* forward link */
  1   110        2 prev bit (18) unaligned,			/* back link */
  1   111 						/* WORD 2 */
  1   112        2 intrpt bit (1) unaligned,			/* completion interrupt desired */
  1   113        2 used bit (1) unaligned,			/* entry in use */
  1   114        2 type fixed bin (4) unsigned unaligned,		/* IO type */
  1   115        2 pad bit (6) unaligned,			/* future expansion */
  1   116        2 coreadd bit (24) unaligned,			/* main memory address */
  1   117 						/* WORD 3 */
  1   118        2 pvtx fixed bin (8) unsigned unaligned,		/* for AZM/ol_dump */
  1   119        2 pdi fixed bin (6) unsigned unaligned,		/* physical device */
  1   120        2 dev fixed bin (6) unsigned unaligned,		/* device in sub-sys */
  1   121        2 pad2 bit (5) unaligned,
  1   122        2 cylinder fixed bin (11) unsigned unaligned,	/* cylinder of request */
  1   123 						/* WORD 4 */
  1   124        2 n_sectors fixed bin (6) unsigned unaligned,	/* # sectors of IO */
  1   125        2 pad3 bit (9) unaligned,
  1   126        2 sector bit (21) unaligned,			/* device sector desired */
  1   127 						/* WORDS 5&6 */
  1   128        2 time fixed bin (71);				/* clock at queue */
  1   129 
  1   130 
  1   131 
  1   132 dcl  1 chantab based (cp) aligned,			/* channel information table */
  1   133        2 chx fixed bin (35),				/* io_manager channel index */
  1   134        2 ioi_ctx fixed bin (35),			/* ioi channel table index */
  1   135        2 statusp ptr,				/* pointer to hardware status word */
  1   136        2 chanid char (8),				/* channel name */
  1   137        (
  1   138        2 pad0 bit (18),
  1   139        2 in_use bit (1),				/* non-zero if channel being used */
  1   140        2 active bit (1),				/* non-zero if channel active */
  1   141        2 rsr bit (1),				/* non-zero if RSR in progress */
  1   142        2 ioi_use bit (1),				/* non-zero if channel usurped by IOI */
  1   143        2 inop bit (1),				/* non-zero if channel inoperative */
  1   144        2 broken bit (1),				/* non-zero if channel broken */
  1   145        2 action_code bit (2),				/* saved from status */
  1   146        2 pad1 bit (10)
  1   147        ) unal,
  1   148        (
  1   149        2 qrp bit (18),				/* rel ptr to queue entry */
  1   150        2 pad2 bit (3),
  1   151        2 command bit (6),				/* peripheral command */
  1   152        2 erct fixed bin (8)
  1   153        ) unal,					/* error retry count */
  1   154        2 select_data,				/* data passed to IOM on select */
  1   155          (
  1   156          3 limit bit (12),				/* limit on number of sectors */
  1   157          3 mbz bit (3),
  1   158          3 sector bit (21)
  1   159          ) unaligned,				/* sector address */
  1   160        2 reconnect_announce_time fixed bin (52),		/* reconnect announcement throttle */
  1   161        2 connect_time fixed bin (52),			/* time of last connect */
  1   162        2 connects fixed bin,				/* count of connects performed */
  1   163        2 detailed_status (0:17) bit (8) unal,		/* detailed status bytes */
  1   164        2 rstdcw bit (36),				/* restore command */
  1   165        2 scdcw bit (36),				/* select command */
  1   166        2 sddcw bit (36),				/* select data xfer */
  1   167        2 dcdcw bit (36),				/* command to read or write */
  1   168        2 dddcw bit (36),				/* data xfer DCW */
  1   169        2 dscdcw bit (36),				/* RSR command */
  1   170        2 dsddcw bit (36),				/* RSR data xfer */
  1   171        2 rssdcw bit (36),				/* RSS command */
  1   172        2 status bit (36) aligned,			/* saved status */
  1   173 						/* Lossage counters for interrupt loss. */
  1   174        2 no_io_terminate fixed bin (35),		/* no t bit from io_manager$get_status */
  1   175        2 terminate_not_active fixed bin (35),		/* terminate, but not active */
  1   176        2 no_status_terminate fixed bin (35),		/* interrupt with no terminate */
  1   177        2 status_from_run fixed bin (35);		/* status missed til run called */
  1   178 
  1   179 dcl  1 qht aligned based,				/* queue head/tail structure */
  1   180        2 sum fixed bin (35),				/* sum of depths */
  1   181        2 count fixed bin (35),			/* allocs */
  1   182        2 max_depth fixed bin (17) unaligned,		/* high water mark */
  1   183        2 depth fixed bin (17) unaligned,		/* current depth */
  1   184        2 head bit (18) unaligned,			/* queue head */
  1   185        2 tail bit (18) unaligned;			/* queue tail */
  1   186 
  1   187 dcl  dp ptr,					/* pointer to device information table */
  1   188      pvtdip ptr;					/* pointer to dim_info in PVT entry */
  1   189 
  1   190 dcl  1 devtab based (dp) aligned,			/* device information table */
  1   191        (
  1   192        2 pvtx fixed bin (8),				/* index of PVT entry for device */
  1   193        2 inop bit (1),				/* device inoperative */
  1   194        2 was_broken bit (1),				/* device previously broken */
  1   195        2 broken bit (1),				/* device down */
  1   196        2 abandoned bit (1),				/* device lost and gone forever */
  1   197        2 forward bit (1),				/* moving low->high */
  1   198        2 pad bit (10),
  1   199        2 buddy unsigned fixed bin (6),			/* other device on this spindle or 0 */
  1   200        2 pdi unsigned fixed bin (6)
  1   201        ) unal,					/* primary device index */
  1   202        2 cylinder fixed bin (35),			/* current cylinder position */
  1   203        2 comb fixed bin (35),				/* number of combs */
  1   204        2 pad1 fixed bin (35),
  1   205        2 time_inop fixed bin (52),			/* time drive became inoperative */
  1   206        2 wq like qht,				/* work queue */
  1   207 						/* Upper bound must be MAX_IO_TYPE, constant to avoid dynamic calculation. */
  1   208        2 opt_info (0:6) like opt_info;			/* optimizer */
  1   209 
  1   210 
  1   211 /* Optimizing table for device. Must be even multiple words long. */
  1   212 /* Slope and intercept define a straight line of y = intercept - slope*x
  1   213*   Multiplier is calculated from this and current system loading.
  1   214*
  1   215*   sys_info is the offset to the relevant system queue loading fraction. */
  1   216 
  1   217 dcl  1 opt_info aligned based (optp),
  1   218        3 multiplier float bin (27),			/* depth mult */
  1   219        3 slope float bin (27),			/* slope of line */
  1   220        3 intercept float bin (27),			/* Y intercept */
  1   221        3 sys_info bit (18) unaligned,			/* offset to sys_info */
  1   222        3 depth fixed bin (17) unaligned,		/* elements in queue */
  1   223        3 channel_wait fixed bin (52),			/* total channel time waiting */
  1   224        3 queue_wait fixed bin (52),			/* total queue time waiting */
  1   225        3 seek_sum fixed bin (35) unaligned,		/* sum of seeks */
  1   226        3 seek_count fixed bin (35) unaligned;		/* number of seeks */
  1   227 
  1   228 
  1   229 dcl  1 pvtdi based (pvtdip) aligned,			/* disk DIM info in PVT entry */
  1   230        (
  1   231        2 sx fixed bin (11),				/* structure index */
  1   232        2 usable_sect_per_cyl fixed bin (11),		/* # of usable sectors on disk cylinder */
  1   233        2 unused_sect_per_cyl fixed bin (11)
  1   234        ) unal;					/* # of unused sectors at end of cylinder */
  1   235 
  1   236 dcl  1 disk_lock_meters based aligned,			/* lock meters for disk DIM */
  1   237        2 count fixed bin,				/* total number of attempts */
  1   238        2 waits fixed bin,				/* number of attempts which required waiting */
  1   239        2 wait_time fixed bin (52);			/* total time spent waiting */
  1   240 
  1   241 dcl  (
  1   242      RST_LISTX init (1),				/* listx for restore */
  1   243      SC_LISTX init (2),				/* listx for select */
  1   244      DSC_LISTX init (6),				/* listx for RSR */
  1   245      RSS_LISTX init (8)
  1   246      ) fixed bin (12) static options (constant);		/* listx for RSS */
  1   247 
  1   248 /* IO types defined.  Value is also index of write_map to determine if
  1   249*   the IO type is a read or a write. */
  1   250 
  1   251 dcl  (
  1   252      PAGE_READ init (0),
  1   253      PAGE_WRITE init (1),
  1   254      VTOC_READ init (2),
  1   255      VTOC_WRITE init (3),
  1   256      TEST init (4),
  1   257      BOOTLOAD_READ init (5),
  1   258      BOOTLOAD_WRITE init (6),
  1   259      MAX_IO_TYPE init (6)
  1   260      ) fixed bin (4) static options (constant);
  1   261 
  1   262 dcl  IO_TYPE (0:6) char (16)
  1   263 	initial ("Page Read", "Page Write", "VTOC Read", "VTOC Write", "Test", "Bootload Read", "Bootload Write")
  1   264 	static options (constant);
  1   265 
  1   266 /* Map indexed by IO type to determine if operation is a read or write. */
  1   267 
  1   268 dcl  write_mapping bit (7) initial ("0101001"b) static options (constant);
  1   269 dcl  write_map (0:6) bit (1) defined (write_mapping);
  1   270 
  1   271 /* Map indexed by IO type to determine if operation is a sector IO. */
  1   272 
  1   273 dcl  sector_mapping bit (7) initial ("0011111"b) static options (constant);
  1   274 dcl  sector_map (0:6) bit (1) defined (sector_mapping);
  1   275 
  1   276 /* Map indexed by IO type to determine if operation is done on behalf of bce */
  1   277 
  1   278 dcl  bootload_mapping bit (7) initial ("0000011"b) static options (constant);
  1   279 dcl  bootload_map (0:6) bit (1) defined (bootload_mapping);
  1   280 
  1   281 /* End of include file ...... dskdcl.incl.pl1 */
      412 
  2     1 /* Begin include file ...... disk_tune.incl.pl1 84-05-16 */
  2     2 /* Structures used for passing tuning information to disk_control$tune. */
  2     3 
  2     4 /* Structure for sys_info operation. */
  2     5 
  2     6 /* type      - indicates which system information IO type is to be altered.
  2     7*   max_depth - is the maximum depth permissible before full optimizaiton. 
  2     8*   map	   - is the depth counter to utilize for determining depth.
  2     9**/
  2    10 
  2    11      dcl	   1 sys_info_tune	      aligned based,
  2    12 	     2 type	      fixed bin,
  2    13 	     2 max_depth	      fixed bin (35),
  2    14 	     2 map	      fixed bin;
  2    15 
  2    16      dcl	   SYS_TUNE	      char (8) static options (constant) initial ("sys_tune");
  2    17 
  2    18 /* Structure for optimizer tuning. */
  2    19 
  2    20 /* type	  - indicates which IO type is to be tuned.
  2    21*   sub_sys  - indicates which sub-system is to be tuned.
  2    22*   dev 	  - indicates the drive within the sub-system.
  2    23*   response - is the multiplier for maximum response.
  2    24*   load	  - is the fully optimized load point.
  2    25**/
  2    26 
  2    27      dcl	   1 opt_info_tune	      aligned based,
  2    28 	     2 type	      fixed bin,
  2    29 	     2 sub_sys	      char (4),
  2    30 	     2 dev	      fixed bin,
  2    31 	     2 response	      fixed bin (35),
  2    32 	     2 load	      fixed bin;
  2    33 
  2    34      dcl	   OPT_TUNE	      char (8) static options (constant) initial ("opt_tune");
  2    35      dcl	   STAGNATE_TIME	      char (8) static options (constant)
  2    36 			      initial ("stagnate");
  2    37      dcl	   RESET_SYS	      char (9) static options (constant)
  2    38 			      initial ("reset_sys");	/* reset sys_info.depth's */
  2    39      dcl	   RESET_MAX	      char (9) static options (constant)
  2    40 			      initial ("reset_max");	/* reset max_depth's */
  2    41 
  2    42 /* Define character array matching io_types. */
  2    43 
  2    44      dcl	   MAX_IO_NAME	      fixed bin static options (constant) initial (5);
  2    45 
  2    46      dcl	   io_name	      (0:4) char (10) static options (constant)
  2    47 			      initial ("page_read", "page_write", "vtoc_read", "vtoc_write", "test");
  2    48 
  2    49 /* Define error code type names. */
  2    50 
  2    51      dcl	   code_names	      (6) char (32) static options (constant)
  2    52 			      initial ("stagnate time range",
  2    53 			      "invalid IO TYPE",
  2    54 			      "invalid map IO TYPE",
  2    55 			      "unknown sub-system",
  2    56 			      "invalid device number",
  2    57 "response < 1");
  2    58 
  2    59 /* End of include file ...... disk_tune.incl.pl1 */
      413 
  3     1 /* BEGIN INCLUDE FILE - get_vol_list_.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(86-03-12,Fawcett), approve(86-05-13,MCR7383),
  3     7*     audit(86-05-27,Wallman), install(86-07-18,MR12.0-1098):
  3     8*     Add support for subvolumes.
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 
  3    12 /* Defines structure interface to the routine get_vol_list_, which acquires
  3    13*   information from the system disk_table on physical and logical volume
  3    14*   names allocates the structures if needed and returns control to the
  3    15*   caller.  The area_ptr in each structure is the area the structure was
  3    16*   allocated in, and can be used for freeing the structure. */
  3    17 
  3    18 /* Created November-22- 1984 by Tom Oke - MDC-ACTC. */
  3    19 
  3    20 /* December 17, 1984 by T. Oke, include version and area_ptr. */
  3    21 
  3    22      dcl	   (lv_list_ptr, pv_list_ptr) ptr;
  3    23 
  3    24      dcl	   get_vol_list_version   char (8) static options (constant) initial ("gvlist02");
  3    25 
  3    26      dcl	   1 pv_list	      based (pv_list_ptr),
  3    27 	     2 version	      char (8) unaligned,		/* struct version */
  3    28 	     2 area_ptr	      ptr,		/* area allocated in */
  3    29 	     2 pv_name_max_length fixed bin,
  3    30 	     2 pv_name_count      fixed bin,
  3    31 	     2 pv_info	      (1 refer (pv_list.pv_name_count)) aligned,
  3    32 	       3 used	      bit (1) unaligned,	/* entry in use */
  3    33 	       3 storage_system   bit (1) unaligned,	/* storage system */
  3    34 	       3 permanent	      bit (1) unaligned,	/* cannot demount */
  3    35 	       3 hc_accepted      bit (1) unaligned,	/* vol accpt ring 0 */
  3    36 	       3 rpv	      bit (1) unaligned,
  3    37 	       3 is_sub_vol	      bit (1) unaligned,
  3    38 	       3 pad	      bit (4) unaligned,
  3    39 	       3 device_type      fixed bin (8) unsigned unaligned,
  3    40 	       3 lvx	      fixed bin unaligned,	/* index in lv_list */
  3    41 	       3 drive_name	      char (8) unaligned,		/* like dska_01 */
  3    42 	       3 pvname	      char (32) unaligned,
  3    43 	       3 sv_num	      fixed bin (17),          /* if this is a subvolume then what number */
  3    44 	       3 num_of_sv	      fixed bin (17);	/* if this is a subvolume how many */
  3    45 
  3    46      dcl	   1 lv_list	      based (lv_list_ptr),
  3    47 	     2 version	      char (8) unaligned,		/* struct version */
  3    48 	     2 area_ptr	      ptr,		/* area allocated in */
  3    49 	     2 lv_name_max_length fixed bin,
  3    50 	     2 lv_name_count      fixed bin,
  3    51 	     2 lv_info	      (1 refer (lv_list.lv_name_count)) aligned,
  3    52 	       3 used	      bit (1) unaligned,	/* in use */
  3    53 	       3 hv_mounted	      bit (1) unaligned,	/* hvol OK */
  3    54 	       3 public	      bit (1) unaligned,	/* public use */
  3    55 	       3 mounting	      bit (1) unaligned,	/* mount in progress */
  3    56 	       3 demounting	      bit (1) unaligned,	/* demount in progress */
  3    57 	       3 pdirs_ok	      bit (1) unaligned,	/* can use pdirs */
  3    58 	       3 prev_bootload    bit (1) unaligned,	/* can auto-accept pvs */
  3    59 	       3 vacate_pdirs     bit (1) unaligned,	/* demand move pdirs */
  3    60 	       3 pad	      bit (26) unaligned,
  3    61 	       3 lvname	      char (32) unaligned;
  3    62 
  3    63 /* END INCLUDE FILE - get_vol_list_.incl.pl1 */
      414 
      415 
      416 
  4     1 /* BEGIN INCLUDE FILE cmp.incl.pl1 --- October 1982 */
  4     2 /* Note: This include file has an ALM counterpart NOT made with cif (for historical reasons). Keep it up to date */
  4     3 
  4     4 dcl  cmep ptr;					/* pointer to core map entry */
  4     5 
  4     6 dcl 1 cme based (cmep) aligned,			/* core map entry */
  4     7     2 fp bit (18) unaligned,				/* forward pointer to next entry */
  4     8     2 bp bit (18) unaligned,				/* backward pointer to previous entry */
  4     9 
  4    10     2 devadd bit (22) unaligned,			/* device address of page in the core block */
  4    11     2 pad5 bit (1) unaligned,
  4    12     2 synch_held bit (1) unaligned,			/* Page of synchronized seg held in memory */
  4    13     2 io bit (1) unaligned,				/* input/output indicator 1=output, 0=input */
  4    14     2 pad2 bit (1) unaligned,
  4    15     2 er bit (1) unaligned,				/* indicates error in previous IO activity */
  4    16     2 removing bit (1) unaligned,			/* core is being removed by reconfiguration */
  4    17     2 abs_w bit (1) unaligned,			/* absolute address must not be changed for page */
  4    18     2 abs_usable bit (1) unaligned,			/* page may be assigned with fixed absolute address */
  4    19     2 notify_requested bit (1) unaligned,		/* notify requested on I/O completion */
  4    20     2 pad3 bit (1) unaligned,
  4    21     2 phm_hedge bit (1) unaligned,			/* on => pc$flush_core ought write. */
  4    22     2 contr bit (3) unaligned,			/* controller in which core block is located */
  4    23 
  4    24     2 ptwp bit (18) unaligned,			/* pointer to page table word for the page */
  4    25     2 astep bit (18) unaligned,			/* relative AST entry pointer of page */
  4    26     2 pin_counter fixed bin (17) unaligned,		/* number of times to skip eviction */
  4    27     2 synch_page_entryp bit (18) unaligned;		/* relp to synch page entry */
  4    28 
  4    29 
  4    30 dcl 1 cma (0: 1) based aligned like cme;		/* Core map array */
  4    31 
  4    32 dcl 1 mcme based (cmep) aligned,			/* core map entry for extracting DID */
  4    33     2 pad bit (36) unaligned,
  4    34     2 record_no bit (18) unaligned,			/* record number of device */
  4    35     2 add_type bit (4) unaligned,			/* see add_type.incl.pl1 */
  4    36     2 flags bit (14) unal,
  4    37     2 pad1 bit (18) unal;
  4    38 
  4    39 
  4    40 /* END INCLUDE FILE  cmp.incl.pl1 */
      417 
      418 
      419 
      420 
  5     1 /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  5     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  5     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  5     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  5     5 
  5     6 dcl  sst_seg$ external;
  5     7 dcl  sstp ptr;
  5     8 
  5     9 dcl 1 sst based (sstp) aligned,
  5    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  5    11 
  5    12 /* SST HEADER */
  5    13 
  5    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  5    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  5    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  5    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  5    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  5    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  5    20 
  5    21     2 ptl bit (36),					/* global page table loop lock */
  5    22     2 astl bit (36),				/* global ast allocation block lock */
  5    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  5    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  5    25     2 nused fixed bin,				/* number of pages on used list */
  5    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  5    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  5    28 
  5    29     2 astap ptr,					/* aste array pointer */
  5    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  5    31     2 astsize fixed bin,				/* size of an AST entry */
  5    32     2 cmesize fixed bin,				/* size of a CME entry */
  5    33     2 root_astep ptr,				/* pointer to the root AST entry */
  5    34 
  5    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  5    36     2 level (0:3),					/* per-list information about ASTE's */
  5    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  5    38 
  5    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  5    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  5    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  5    42     2 strsize fixed bin,				/* Trailer size in words. */
  5    43 
  5    44 /* CORE MAP HEADER */
  5    45 
  5    46     2 cmp ptr,					/* pointer to start of core map */
  5    47     2 usedp bit (18),				/* pointer to first used core block */
  5    48     2 wtct fixed bin,				/* count of pages being written */
  5    49 
  5    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  5    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  5    52 						/* MISC */
  5    53 
  5    54     2 double_write fixed bin,				/* trigger for store through scheme */
  5    55 						/* 0 = no double writes,
  5    56*						   1 = all non-pd pages get written,
  5    57*						   2 = all directories get written */
  5    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  5    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  5    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  5    61 
  5    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  5    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  5    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  5    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  5    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  5    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  5    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  5    69 
  5    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  5    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  5    72 
  5    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  5    74 
  5    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  5    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  5    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  5    78 
  5    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  5    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  5    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  5    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  5    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  5    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  5    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  5    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  5    87 
  5    88 
  5    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  5    90 
  5    91     2 steps fixed bin,				/* number of steps taken around used list */
  5    92     2 needc fixed bin,				/* number of times core page needed */
  5    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  5    94     2 ctwait fixed bin,				/* number of times write counter was full */
  5    95     2 wired fixed bin,				/* number of pages wired by pc */
  5    96     2 laps fixed bin,				/* number of times around used list */
  5    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  5    98     2 skipu fixed bin,				/* because of being used */
  5    99 
  5   100     2 skipm fixed bin,				/* because of being modified */
  5   101     2 skipos fixed bin,				/* because out of service */
  5   102     2 aused fixed bin,				/* number of AST entries on used list */
  5   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  5   104     2 deact_count fixed bin,				/* count of deactivations */
  5   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  5   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  5   107 
  5   108     2 reads (8) fixed bin,				/* number of reads for each did */
  5   109     2 writes (8) fixed bin,				/* number of writes for each did */
  5   110 
  5   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  5   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  5   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  5   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  5   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  5   116     2 total_sf fixed bin,				/* total number of seg_faults */
  5   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  5   118     2 post_list_size fixed bin,
  5   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  5   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  5   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  5   122     2 pre_page_list_size fixed bin,
  5   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  5   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  5   125 
  5   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  5   127 
  5   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  5   129 
  5   130 /* MAIN MEMORY USAGE INFORMATION */
  5   131 
  5   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  5   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  5   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  5   135     2 recopies fixed bin,				/* number of times recopied because modified */
  5   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  5   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  5   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  5   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  5   140 
  5   141 /*  AST METERS  */
  5   142 
  5   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  5   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  5   145 
  5   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  5   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  5   148     2 asearches fixed bin,				/* count of full searches made */
  5   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  5   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  5   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  5   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  5   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  5   154 
  5   155     2 alaps fixed bin,				/* lap counter for AST list */
  5   156     2 updates fixed bin,				/* calls to updateb */
  5   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  5   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  5   159     2 total_bf fixed bin,				/* count of bound faults */
  5   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  5   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  5   162 
  5   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  5   164 
  5   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  5   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  5   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  5   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  5   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  5   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  5   171 
  5   172 /* PRE-PAGE METERS */
  5   173 
  5   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  5   175 
  5   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  5   177 
  5   178 
  5   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  5   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  5   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  5   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  5   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  5   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  5   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  5   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  5   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  5   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  5   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  5   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  5   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  5   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  5   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  5   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  5   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  5   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  5   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  5   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  5   199     2 activations fixed bin,				/* total count of activations */
  5   200     2 dir_activations fixed bin,			/* count of directory activations */
  5   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  5   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  5   203     2 evict_recover_data,				/* see evict_page.alm */
  5   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  5   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  5   206 
  5   207 /* Data for metering force_write facility 08/19/78 */
  5   208 
  5   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  5   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  5   211     2 fw_none fixed bin,				/* Force write wrote none */
  5   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  5   213 
  5   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  5   215     2 pf_unlock_ptl_meterings fixed bin,
  5   216 
  5   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  5   218     2 backup_activations fixed bin (35),		/* activations for backup */
  5   219     2 metering_flags aligned,				/* small chunks of misc. information */
  5   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  5   221       3 pad bit (35) unal,
  5   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  5   223 
  5   224 /* METERS FOR STACK TRUNCATION */
  5   225 
  5   226     2 (stk_truncate_should_didnt,			/* counts */
  5   227        stk_truncate_should_did,
  5   228        stk_truncate_shouldnt_didnt,
  5   229        stk_truncate_shouldnt_did) fixed bin (35),
  5   230     2 stk_pages_truncated fixed bin (35),
  5   231     2 stk_pages_truncated_in_core fixed bin (35),
  5   232 
  5   233 /* SUPPORT FOR PC SEGMOVES */
  5   234 
  5   235     2 segmove_lock aligned,
  5   236       3 pid bit (36) aligned,
  5   237       3 event bit (36) aligned,
  5   238       3 notify bit (1) aligned,
  5   239     2 segmove_io_limit fixed bin, /* max read aheads */
  5   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  5   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  5   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  5   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  5   244 
  5   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  5   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  5   247     2 segmove_vtocx fixed bin,			/* ditto */
  5   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  5   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  5   250 
  5   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  5   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  5   253     2 trace_sw aligned,				/* tracing control flags */
  5   254       3 pad_trace bit (32) unaligned,
  5   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  5   256       3 tty_trace bit (1) unaligned,
  5   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  5   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  5   259     2 new_pages fixed bin,				/* newly created pages */
  5   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  5   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  5   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  5   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  5   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  5   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  5   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  5   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  5   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  5   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  5   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  5   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  5   272 
  5   273 /* END INCLUDE FILE sst.incl.pl1 */
      421 
      422 
      423      end;						/* external procedure Disk_queue */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/08/88  1115.1  disk_queue.pl1                    >special_ldd>install>MR12.2-1080>disk_queue.pl1
412          1    08/08/88  1111.3  dskdcl.incl.pl1                   >special_ldd>install>MR12.2-1080>dskdcl.incl.pl1
413          2    10/02/84  0850.0  disk_tune.incl.pl1                >ldd>include>disk_tune.incl.pl1
414          3    07/24/86  2051.8  get_vol_list_.incl.pl1            >ldd>include>get_vol_list_.incl.pl1
417          4    11/23/82  0953.7  cmp.incl.pl1                      >ldd>include>cmp.incl.pl1
421          5    01/30/85  1523.9  sst.incl.pl1                      >ldd>include>sst.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_subsystem_name                000100 automatic       char(32)                 packed unaligned dcl 253 set ref 264* 286* 291* 301*
                                                                                  370* 374*
WHOAMI                          000021 constant        char(32)                 initial packed unaligned dcl 73 set ref 96* 114*
                                                                                  122* 138* 145* 151* 156* 175* 181* 187* 202* 212*
                                                                                  216* 219* 228* 230* 232*
addr                                                   builtin function         dcl 77 ref 272
al                              000104 automatic       fixed bin(21,0)          dcl 42 set ref 93* 94 96 96 100 103 103 104 105 105
                                                                                  106 106 107 107 107 107 108 108 108 109 110 112
                                                                                  114 114 119* 122 122 126 130 130 134* 135 135 138
                                                                                  138 145 145
all_sw                          000125 automatic       bit(1)                   dcl 51 set ref 81* 103* 150 155 160 163 191
ap                              000102 automatic       pointer                  dcl 41 set ref 93* 94 96 100 103 103 104 105 105 106
                                                                                  106 107 107 107 107 108 108 108 109 110 112 114
                                                                                  119* 122 126 130 130 134* 135 138 145
area_ptr                  2            based           pointer                  level 2 in structure "pv_list" dcl 3-26 in procedure
                                                                                  "dq" ref 235
area_ptr                  2            based           pointer                  level 2 in structure "lv_list" dcl 3-46 in procedure
                                                                                  "dq" ref 239
areas                                  based           area(1024)               dcl 38 ref 235 239
arg                                    based           char                     packed unaligned dcl 43 set ref 94 96* 100 103 103
                                                                                  104 105 105 106 106 107 107 107 107 108 108 108
                                                                                  109 110 112 114* 122* 126 130 130 135* 138* 145*
argno                           000100 automatic       fixed bin(17,0)          dcl 40 set ref 92* 93* 113 118* 118 119* 131 133*
                                                                                  133 134*
array                    11            based           structure                array level 2 dcl 1-31
binary                                                 builtin function         dcl 77 ref 363 364 365 366
chantab                                based           structure                level 1 dcl 1-132
cleanup                         000136 stack reference condition                dcl 75 ref 89
cme                                    based           structure                level 1 dcl 4-6
cmpp                            000106 automatic       pointer                  dcl 45 set ref 80* 219 219* 232 232* 242*
code                            000105 automatic       fixed bin(35,0)          dcl 44 set ref 87* 135* 136 137* 138* 174 175* 179*
                                                                                  180 181* 185* 186 187* 212* 214 216* 218 219* 221
                                                                                  228* 230* 232*
com_err_                        000010 constant        entry                    external dcl 57 ref 96 114 122 138 145 151 156 175
                                                                                  181 187 202
copy_erf_seg_$name              000012 constant        entry                    external dcl 58 ref 179
coreadd                   1(12)        based           bit(24)                  level 2 in structure "quentry" packed packed
                                                                                  unaligned dcl 1-107 in procedure "dq" ref 365
coreadd                         000130 automatic       fixed bin(24,0)          dcl 347 in procedure "print_queue_entry" set ref
                                                                                  365* 392* 402*
cu_$arg_count                   000014 constant        entry                    external dcl 59 ref 91
cu_$arg_ptr                     000016 constant        entry                    external dcl 60 ref 93 119 134
cv_dec_check_                   000020 constant        entry                    external dcl 61 ref 135
cyladd                          000126 automatic       fixed bin(11,0)          dcl 345 set ref 363* 392*
cylinder                  2(25)        based           fixed bin(11,0)          level 2 packed packed unsigned unaligned dcl 1-107
                                                                                  ref 363
date_time_                      000022 constant        entry                    external dcl 62 ref 386
dev                             000113 automatic       fixed bin(17,0)          dcl 257 set ref 270* 272*
devadd                          000127 automatic       fixed bin(20,0)          dcl 346 set ref 364* 392* 402*
devtab                   36            based           structure                array level 2 in structure "disktab" dcl 1-74
                                                                                  in procedure "dq" set ref 270 270 272
devtab                                 based           structure                level 1 dcl 1-190 in procedure "dq"
disk_data                              based           structure                level 1 dcl 1-31
disk_lock_meters                       based           structure                level 1 dcl 1-236
diskp                           000146 automatic       pointer                  dcl 1-26 set ref 194* 270 270 272
disksp                          000144 automatic       pointer                  dcl 1-26 set ref 80* 179* 191 193 194 194 195 196
                                                                                  212 212* 228 228* 242* 275 303 311 312 319 326
disktab                                based           structure                level 1 dcl 1-74
dp                              000152 automatic       pointer                  dcl 1-187 set ref 272* 273
drive_name                7            based           char(8)                  array level 3 packed packed unaligned dcl 3-26 set
                                                                                  ref 392* 402*
entry_count                     000133 automatic       fixed bin(17,0)          dcl 53 set ref 83* 135* 150 160 191* 302 324
erf_name                        000112 automatic       char(32)                 packed unaligned dcl 48 set ref 84* 126* 179* 202*
erf_sw                          000122 automatic       bit(1)                   packed unaligned dcl 49 set ref 85* 121 127* 202*
error_table_$bad_conversion     000040 external static fixed bin(35,0)          dcl 68 ref 137
error_table_$badopt             000036 external static fixed bin(35,0)          dcl 68 set ref 145*
error_table_$inconsistent       000042 external static fixed bin(35,0)          dcl 68 set ref 151* 156*
error_table_$noarg              000044 external static fixed bin(35,0)          dcl 68 set ref 114*
first_sw                        000112 automatic       bit(1)                   dcl 256 set ref 265* 286 306* 369 376*
free_q                    4            based           structure                level 2 dcl 1-31
free_q_size              10            based           fixed bin(17,0)          level 2 dcl 1-31 set ref 191 311 312*
get_temp_segment_               000030 constant        entry                    external dcl 65 ref 212 216 219
get_vol_list_                   000024 constant        entry                    external dcl 63 ref 185
get_vol_list_version            000000 constant        char(8)                  initial packed unaligned dcl 3-24 set ref 185*
hbound                                                 builtin function         dcl 77 ref 270
head                     11            based           bit(18)                  level 3 packed packed unaligned dcl 1-190 ref 273
idx                             000134 automatic       fixed bin(17,0)          dcl 54 set ref 193* 194 195 196*
intrpt                    1            based           bit(1)                   level 2 packed packed unaligned dcl 1-107 set ref
                                                                                  392* 402*
io_name                         000002 constant        char(10)                 initial array packed unaligned dcl 2-46 set ref 392*
                                                                                  402*
ioa_                            000026 constant        entry                    external dcl 64 ref 278 286 291 312 321 330 370 374
                                                                                  387 392 402
last_dev                  2(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-74 ref 270
last_time                       000110 automatic       fixed bin(71,0)          dcl 255 set ref 268* 305* 382* 398*
lbound                                                 builtin function         dcl 77 ref 270
live_sw                         000126 automatic       bit(1)                   dcl 51 set ref 81* 104* 155 160 160* 163* 267
long_sw                         000124 automatic       bit(1)                   dcl 51 set ref 81* 105* 106* 370 381
lv_list                                based           structure                level 1 unaligned dcl 3-46 ref 239
lv_list_ptr                     000154 automatic       pointer                  dcl 3-22 set ref 80* 185* 239 239 239 242*
lv_name_count             5            based           fixed bin(17,0)          level 2 dcl 3-46 ref 239
matching_entries                000116 automatic       fixed bin(17,0)          dcl 260 set ref 266* 291 307* 324 330 379* 379
name                     12            based           char(4)                  array level 3 packed packed unaligned dcl 1-31 set
                                                                                  ref 195 196*
nargs                           000101 automatic       fixed bin(17,0)          dcl 40 set ref 91* 92 113 131
next                                   based           bit(18)                  level 2 packed packed unaligned dcl 1-107 ref 282
null                                                   builtin function         dcl 77 ref 80 185 185 212 216 219 228 230 232 235
                                                                                  239 242
offset                   11            based           bit(18)                  array level 3 packed packed unaligned dcl 1-31 ref
                                                                                  194
opt_info                               based           structure                level 1 dcl 1-217
p_subsystem_name                       parameter       char                     packed unaligned dcl 252 ref 247 264
prev                      0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1-107 ref 326
ptr                                                    builtin function         dcl 77 ref 194 275 319 326
pv_info                   6            based           structure                array level 2 dcl 3-26
pv_list                                based           structure                level 1 unaligned dcl 3-26 set ref 235
pv_list_ptr                     000156 automatic       pointer                  dcl 3-22 set ref 80* 185* 235 235 235 242* 370 392
                                                                                  392 392 402
pv_name_count             5            based           fixed bin(17,0)          level 2 dcl 3-26 ref 235
pv_name_max_length        4            based           fixed bin(17,0)          level 2 dcl 3-26 set ref 370 392*
pvname                   11            based           char(32)                 array level 3 packed packed unaligned dcl 3-26 set
                                                                                  ref 392*
pvtx                      2            based           fixed bin(8,0)           level 2 packed packed unsigned unaligned dcl 1-107
                                                                                  ref 392 392 402
qht                                    based           structure                level 1 dcl 1-179
qp                              000150 automatic       pointer                  dcl 1-97 set ref 275* 277 282 319* 321 355 355 359
                                                                                  359 363 364 365 366 392 392 392 392 392 402 402
                                                                                  402 402
qrp                             000114 automatic       bit(18)                  dcl 258 set ref 273* 274 275 278* 280* 282* 303* 309
                                                                                  314* 319 321* 324* 326* 326
qrp_count                       000115 automatic       fixed bin(17,0)          dcl 259 set ref 304* 310* 310 311
quentry                                based           structure                level 1 dcl 1-107
queued_time                     000132 automatic       fixed bin(71,0)          dcl 348 set ref 366* 383* 386* 398
read_sw                         000131 automatic       bit(1)                   dcl 52 set ref 82* 109* 169 169* 291 291* 330 330*
                                                                                  355
record_sw                       000130 automatic       bit(1)                   dcl 52 set ref 82* 107* 166 166* 291 291* 330 330*
                                                                                  359
release_temp_segment_           000032 constant        entry                    external dcl 65 ref 228 230 232
request_id_                     000034 constant        entry                    external dcl 66 ref 382 383
sector                    3(15)        based           bit(21)                  level 2 packed packed unaligned dcl 1-107 ref 364
sector_map                             defined         bit(1)                   array packed unaligned dcl 1-274 ref 359 359
sector_mapping                  000017 constant        bit(7)                   initial packed unaligned dcl 1-273 ref 359 359 359
                                                                                  359
sector_sw                       000127 automatic       bit(1)                   dcl 52 set ref 82* 108* 166 166* 291 291* 330 330*
                                                                                  359
seg_len                         000123 automatic       fixed bin(19,0)          unsigned dcl 50 set ref 179*
sstp                            000160 automatic       pointer                  dcl 5-7 set ref 80* 216 216* 230 230* 242*
substr                                                 builtin function         dcl 77 ref 94 385 385 387 387 387 387 387 387 387
                                                                                  387 392 392
subsystem_found                 000111 automatic       bit(1)                   dcl 47 set ref 192* 197* 202
subsystem_name                  000110 automatic       char(4)                  dcl 46 set ref 86* 95 100* 195 195 202*
subsystems                             based           fixed bin(17,0)          level 2 dcl 1-31 ref 193
sys_info                               based           structure                level 1 dcl 1-59
tail                      7(18)        based           bit(18)                  level 3 packed packed unaligned dcl 1-31 ref 303
time                      4            based           fixed bin(71,0)          level 2 dcl 1-107 ref 366
time_str_1                      000134 automatic       char(24)                 packed unaligned dcl 349 set ref 382* 385 386* 387
                                                                                  387 387 387 387 387
time_str_2                      000142 automatic       char(24)                 packed unaligned dcl 349 set ref 383* 385 387 387
                                                                                  392 392
type                      1(02)        based           fixed bin(4,0)           level 2 packed packed unsigned unaligned dcl 1-107
                                                                                  ref 355 355 359 359 392 402
used                      1(01)        based           bit(1)                   level 2 packed packed unaligned dcl 1-107 set ref
                                                                                  277 321 392* 402*
wq                        6            based           structure                level 2 dcl 1-190
write_map                              defined         bit(1)                   array packed unaligned dcl 1-269 ref 355 355
write_mapping                   000020 constant        bit(7)                   initial packed unaligned dcl 1-268 ref 355 355 355
                                                                                  355
write_sw                        000132 automatic       bit(1)                   dcl 52 set ref 82* 110* 169 169* 291 291* 330 330*
                                                                                  355

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BOOTLOAD_READ                          internal static fixed bin(4,0)           initial dcl 1-251
BOOTLOAD_WRITE                         internal static fixed bin(4,0)           initial dcl 1-251
DSC_LISTX                              internal static fixed bin(12,0)          initial dcl 1-241
IO_TYPE                                internal static char(16)                 initial array packed unaligned dcl 1-262
MAX_IO_NAME                            internal static fixed bin(17,0)          initial dcl 2-44
MAX_IO_TYPE                            internal static fixed bin(4,0)           initial dcl 1-251
OPT_TUNE                               internal static char(8)                  initial packed unaligned dcl 2-34
PAGE_READ                              internal static fixed bin(4,0)           initial dcl 1-251
PAGE_WRITE                             internal static fixed bin(4,0)           initial dcl 1-251
RESET_MAX                              internal static char(9)                  initial packed unaligned dcl 2-39
RESET_SYS                              internal static char(9)                  initial packed unaligned dcl 2-37
RSS_LISTX                              internal static fixed bin(12,0)          initial dcl 1-241
RST_LISTX                              internal static fixed bin(12,0)          initial dcl 1-241
SC_LISTX                               internal static fixed bin(12,0)          initial dcl 1-241
STAGNATE_TIME                          internal static char(8)                  initial packed unaligned dcl 2-35
SYS_TUNE                               internal static char(8)                  initial packed unaligned dcl 2-16
TEST                                   internal static fixed bin(4,0)           initial dcl 1-251
VTOC_READ                              internal static fixed bin(4,0)           initial dcl 1-251
VTOC_WRITE                             internal static fixed bin(4,0)           initial dcl 1-251
bootload_map                           defined         bit(1)                   array packed unaligned dcl 1-279
bootload_mapping                       internal static bit(7)                   initial packed unaligned dcl 1-278
cma                                    based           structure                array level 1 dcl 4-30
cmep                                   automatic       pointer                  dcl 4-4
code_names                             internal static char(32)                 initial array packed unaligned dcl 2-51
cp                                     automatic       pointer                  dcl 1-97
disk_channel_table                     based           structure                array level 1 dcl 1-94
disk_seg$                              external static fixed bin(17,0)          dcl 1-24
dskdcl_chans_per_subsys                internal static fixed bin(17,0)          initial dcl 1-70
dskdcl_chans_per_subsys_shift          internal static fixed bin(17,0)          initial dcl 1-71
mcme                                   based           structure                level 1 dcl 4-32
opt_info_tune                          based           structure                level 1 dcl 2-27
optp                                   automatic       pointer                  dcl 1-26
pvtdi                                  based           structure                level 1 dcl 1-229
pvtdip                                 automatic       pointer                  dcl 1-187
sst                                    based           structure                level 1 dcl 5-9
sst_seg$                               external static fixed bin(17,0)          dcl 5-6
sys_info_tune                          based           structure                level 1 dcl 2-11
sysp                                   automatic       pointer                  dcl 1-26

NAMES DECLARED BY EXPLICIT CONTEXT.
ARG_MISSING                     001036 constant        label                    dcl 114 ref 131
BAD_ENTRY_COUNT                 001244 constant        label                    dcl 138
MAIN_RETURN                     001755 constant        label                    dcl 206 ref 97 115 123 140 146 152 157 176 182 188
clean_up_segs                   002075 constant        entry                    internal dcl 226 ref 89 206
disk_queue                      000512 constant        entry                    external dcl 24
dq                              000503 constant        entry                    external dcl 24
init_segs                       001762 constant        entry                    internal dcl 210 ref 173
print_queue_entry               002710 constant        entry                    internal dcl 339 ref 276 320
process_free_queue              002477 constant        entry                    internal dcl 298 ref 200
process_subsystem               002242 constant        entry                    internal dcl 247 ref 196

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3624        3672    3370        3634
Length      4214    3370        46         306     234           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dq                                  250 external procedure  is an external procedure.  
on unit on line 89                   64 on unit               
init_segs                               internal procedure  shares stack frame of external procedure dq.  
clean_up_segs                        80 internal procedure  is called by several nonquick procedures.  
process_subsystem                   294 internal procedure  is declared options(non_quick).  
print_queue_entry                       internal procedure  shares stack frame of internal procedure process_subsystem.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dq                       000100 argno                       dq
                         000101 nargs                       dq
                         000102 ap                          dq
                         000104 al                          dq
                         000105 code                        dq
                         000106 cmpp                        dq
                         000110 subsystem_name              dq
                         000111 subsystem_found             dq
                         000112 erf_name                    dq
                         000122 erf_sw                      dq
                         000123 seg_len                     dq
                         000124 long_sw                     dq
                         000125 all_sw                      dq
                         000126 live_sw                     dq
                         000127 sector_sw                   dq
                         000130 record_sw                   dq
                         000131 read_sw                     dq
                         000132 write_sw                    dq
                         000133 entry_count                 dq
                         000134 idx                         dq
                         000144 disksp                      dq
                         000146 diskp                       dq
                         000150 qp                          dq
                         000152 dp                          dq
                         000154 lv_list_ptr                 dq
                         000156 pv_list_ptr                 dq
                         000160 sstp                        dq
process_subsystem        000100 P_subsystem_name            process_subsystem
                         000110 last_time                   process_subsystem
                         000112 first_sw                    process_subsystem
                         000113 dev                         process_subsystem
                         000114 qrp                         process_subsystem
                         000115 qrp_count                   process_subsystem
                         000116 matching_entries            process_subsystem
                         000126 cyladd                      print_queue_entry
                         000127 devadd                      print_queue_entry
                         000130 coreadd                     print_queue_entry
                         000132 queued_time                 print_queue_entry
                         000134 time_str_1                  print_queue_entry
                         000142 time_str_2                  print_queue_entry

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other      return_mac
enable_op           ext_entry           int_entry           int_entry_desc      op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      copy_erf_seg_$name            cu_$arg_count                 cu_$arg_ptr
cv_dec_check_                 date_time_                    get_temp_segment_             get_vol_list_
ioa_                          release_temp_segment_         request_id_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_conversion   error_table_$badopt           error_table_$inconsistent     error_table_$noarg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     24 000502        80 000517        81 000525        82 000530        83 000534        84 000536        85 000541
     86 000542        87 000544        89 000545        91 000567        92 000576        93 000605        94 000623
     95 000630        96 000635        97 000671       100 000672       101 000676       103 000677       104 000713
    105 000722       106 000734       107 000747       108 000772       109 001011       110 001020       112 001027
    113 001033       114 001036       115 001070       118 001071       119 001072       121 001110       122 001113
    123 001147       126 001150       127 001155       128 001157       130 001160       131 001170       133 001173
    134 001174       135 001212       136 001237       137 001241       138 001244       140 001276       142 001277
    145 001300       146 001332       148 001333       150 001335       151 001341       152 001366       155 001367
    156 001373       157 001420       160 001421       163 001431       166 001435       169 001446       173 001457
    174 001460       175 001462       176 001477       179 001500       180 001533       181 001535       182 001560
    185 001561       186 001602       187 001604       188 001633       191 001634       192 001641       193 001642
    194 001651       195 001661       196 001672       197 001703       199 001705       200 001707       202 001713
    206 001755       208 001761       210 001762       212 001763       214 002010       216 002013       218 002040
    219 002043       221 002070       222 002073       226 002074       228 002102       230 002127       232 002155
    235 002203       239 002216       242 002231       243 002240       247 002241       264 002255       265 002262
    266 002264       267 002265       268 002270       270 002272       272 002303       273 002311       274 002314
    275 002317       276 002324       277 002325       278 002334       280 002354       281 002355       282 002356
    283 002361       284 002362       286 002364       291 002411       296 002475       298 002476       301 002504
    302 002507       303 002512       304 002516       305 002517       306 002521       307 002523       309 002524
    310 002527       311 002530       312 002535       314 002555       315 002556       319 002557       320 002563
    321 002564       324 002611       326 002617       328 002626       330 002627       335 002707       339 002710
    355 002711       359 002735       363 002753       364 002756       365 002761       366 002764       369 002766
    370 002770       374 003023       376 003043       379 003044       381 003045       382 003050       383 003064
    385 003100       386 003104       387 003121       392 003167       398 003277       399 003301       402 003302
    406 003364


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
