	COMPILATION LISTING OF SEGMENT meter_gate
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/22/85  1517.7 mst Tue
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style2,idind30,indcomtxt */
       12 
       13 /**** * METER_GATE - Print Out Metering Info from Gate Segment.
       14*
       15*      Date Last Modified and Reason
       16*
       17*      841113 MAP to include hc_lock.
       18*      831107 BIM for ring_alarms.
       19*      06/24/81 by J. Bongiovanni to eliminate restriction on number of gates
       20*      09/15/76 by Noel I. Morris to work with combined defs.
       21*      07/08/75 by S. Webber to work with combined linkage and to add reset capability
       22*      06/14/74 by R. A. Roach to eliminate calls to phcs_.
       23*      05/07/74 by R. B. Snyder to change arguments to meter_gate_.
       24*      11/27/73 by R. B. Snyder to add entry meter_gate_
       25*      10/27/73 Steve Webber to work with call limiter type gates
       26*      Originally written 1/27/70 by N. I. Morris
       27**/
       28 
       29 meter_gate:
       30 mg:
       31      procedure options (variable);
       32 
       33 /* Static */
       34 
       35 	dcl     tcdp0		        ptr static init (null ());
       36 						/* pointer to tc_data in ring 0 */
       37 	dcl     tempp		        (2) ptr int static init ((2) null ());
       38 						/* pointer to temp segments */
       39 	dcl     itimep0		        ptr static; /* pointer to tcm.initialize_time */
       40 	dcl     ptimep0		        ptr static; /* pointer to tcm.processor_time */
       41 	dcl     ltimep0		        ptr static; /* pointer to tcm.idle */
       42 	dcl     who_it_is		        char (10) int static options (constant) init ("meter_gate");
       43 
       44 /* Automatic */
       45 
       46 	dcl     argno		        fixed bin;
       47 	dcl     gi		        fixed bin;	/* index to gate_info for gate of interest */
       48 	dcl     avg		        float bin (27);
       49 	dcl     reset_sw		        bit (1) aligned;
       50 	dcl     no_report		        bit (1) aligned,
       51 	        namep		        ptr,	/* pointer to entry name */
       52 	        namel		        fixed bin,	/* length of entry name */
       53 	        code		        fixed bin (35),
       54 						/* error code */
       55 	        argp		        ptr,	/* pointer to argument */
       56 	        arglen		        fixed bin,	/* length of argument */
       57 	        segname		        char (32),	/* name of segment */
       58 	        entry		        char (32),	/* name of desired entry */
       59 	        sort		        fixed bin,	/* sorting function code */
       60 	        argument		        char (arglen) based (argp),
       61 						/* based argument */
       62 	        (i, j)		        fixed bin,	/* indices */
       63 	        nentries		        fixed bin,	/* number of gate entries */
       64 	        calls		        fixed bin,	/* number of calls to entry */
       65 	        totcalls		        fixed bin,	/* total calls through gate */
       66 	        itime		        fixed bin (71),
       67 						/* time Multics came up */
       68 	        timnow		        fixed bin (71),
       69 						/* time now */
       70 	        citime		        char (24),	/* converted system up time */
       71 	        ctimnow		        char (24),	/* converted current time */
       72 	        tottim		        fixed bin (71),
       73 						/* total time spent inside gate */
       74 	        total_ring_alarms	        fixed bin (35),
       75 						/* total polled ring alarms */
       76 	        hr		        fixed bin,	/* hours, for conversion */
       77 	        mn		        fixed bin,	/* minutes, for conversion */
       78 	        sc		        fixed bin,	/* seconds, for conversion */
       79 	        charged_time	        fixed bin (71),
       80 						/* total charged time */
       81 	        idle_time		        fixed bin (71),
       82 						/* total idle time */
       83 	        ctime		        fixed bin (71),
       84 	        ptime		        float bin,	/* time percentage */
       85 	        ppage		        float bin;	/* page waits per call */
       86 
       87 	dcl     1 table		        (512) aligned,
       88 						/* table pointing to info */
       89 		2 gate		        like gate_table aligned,
       90 						/* gate entry info */
       91 		2 avg		        float bin (27);
       92 						/* average time spent in entry */
       93 
       94 	dcl     1 temp_table	        like table aligned;
       95 						/* temporary for interchange sort */
       96 
       97 /* Entries */
       98 
       99 	dcl     com_err_		        entry options (variable);
      100 	dcl     cu_$arg_ptr		        ext entry (fixed bin, ptr, fixed bin, fixed bin (35));
      101 	dcl     ring_zero_peek_	        ext entry (ptr, ptr, fixed bin (18), fixed bin (35));
      102 	dcl     ring0_get_$segptr	        ext entry (char (*), char (*), ptr, fixed bin (35));
      103 	dcl     ioa_		        ext entry options (variable);
      104 	dcl     clock_		        ext entry returns (fixed bin (71));
      105 	dcl     date_time_		        ext entry (fixed bin (71), char (*));
      106 	dcl     cu_$arg_count	        entry returns (fixed bin);
      107 	dcl     get_gate_data_	        entry (char (*), 1 dim (*) like gate_table aligned, fixed bin, ptr,
      108 				        bit (1) aligned, fixed bin (35));
      109 	dcl     get_temp_segments_	        entry (char (*), dim (*) ptr, fixed bin (35));
      110 
      111 
      112 	dcl     1 gate_info_struct	        aligned based (tempp (2)),
      113 						/* structure of gates we're metering		*/
      114 		2 max_gates	        fixed bin,	/* number of gates				*/
      115 		2 gate_info	        (0 refer (max_gates)),
      116 		  3 name		        char (32),	/* name of gate */
      117 		  3 old_time	        fixed bin (71),
      118 						/* charged time at time of last reset */
      119 		  3 old_charged	        fixed bin (71);
      120 						/* charged time at time of last reset */
      121 
      122 	dcl     entryname		        char (namel) based (namep);
      123 						/* gate entry name */
      124 
      125 /* Builtin */
      126 
      127 	dcl     (addr, divide, float, mod, null)
      128 				        builtin;
      129 
      130 
      131 /**/
      132 
  1     1 
  1     2 /* Begin include file ...... gate_data.incl.pl1
  1     3*	Created 10/13/76 by Noel I. Morris	*/
  1     4 /* Modified 831107 for ring_alarms, Benson Margulies. */
  1     5 /* format: style3 */
  1     6 
  1     7 dcl	1 gate_table	aligned based,		/* gate information table */
  1     8 	  2 entryp	ptr unal,			/* pointer to entry name */
  1     9 	  2 entryl	fixed bin,		/* length of entry name */
  1    10 	  2 datap		ptr unal;			/* pointer to gate metering data */
  1    11 
  1    12 dcl	gate_datap	ptr;
  1    13 
  1    14 dcl	1 gate_entry_data	based (gate_datap) aligned,	/* gate data in gate segment */
  1    15 	  2 cpu_time	fixed bin (71),		/* total CPU time spent in entry (us) */
  1    16 	  2 vcpu_time	fixed bin (71),		/* virtual CPU time spent in entry (us) */
  1    17 	  2 page_waits	fixed bin (35),		/* number of page waits in entry */
  1    18 	  2 calls		fixed bin (35),		/* number of calls to entry */
  1    19 	  2 ring_alarms	fixed bin (35),		/* number of times RAR was nonzero on exit. */
  1    20 	  2 pad		fixed bin (35);		/* for future use */
  1    21 
  1    22 /* End of include file ...... gate_data.incl.pl1 */
  1    23 
      133 
      134 
      135 /**/
      136 
  2     1 /* BEGIN INCLUDE FILE ... tcm.incl.pl1 ... used to generate tc_data cds */
  2     2 /* NOTE -- This include file has TWO counterparts in ALM: tc_meters.incl.alm and */
  2     3 /* wcte.incl.alm. They cannot be produced with cif, and must be kept up to date manually. */
  2     4 /* Modified 830914 to replace tty_polling_time with opc_polling_time... -E. A. Ranzenbach */
  2     5 /* Modified 1984.05.21 by M. Pandolf to add tc_suspend_lock */
  2     6 /* Modified 1984.11.26 by Keith Loepere for uid_array. */
  2     7 /* Modified 1984.12.06 by Keith Loepere for page create delaying. */
  2     8 
  2     9 dcl  tcmp ptr;
  2    10 
  2    11 dcl 1 tcm aligned based (tcmp),
  2    12     2 tc_suspend_lock like lock,			/* when locked, tc is suspended */
  2    13     2 cid2 fixed bin (18),
  2    14     2 cid3 fixed bin (18),
  2    15     2 cid4 fixed bin (18),
  2    16     2 depth_count fixed bin (18),			/* depth last process run */
  2    17     2 loadings fixed bin (18),			/* number of process loadings */
  2    18 
  2    19     2 blocks fixed bin (18),				/* number of calls to block */
  2    20     2 wakeups fixed bin (18),				/* number of calls to wakeup */
  2    21     2 waits fixed bin (18),				/* number of calls to wait */
  2    22     2 notifies fixed bin (18),			/* number of calls to notify */
  2    23     2 schedulings fixed bin (18),
  2    24     2 interactions fixed bin (18),			/* number of interactive schedulings */
  2    25     2 avequeue fixed bin (35, 18),			/* recent time average of number in queue */
  2    26     2 te_wait fixed bin (18),				/* times te called from wait */
  2    27 
  2    28     2 te_block fixed bin (18),			/* times te updated from block */
  2    29     2 te_i_stop fixed bin (18),			/* times te updated from i_stop */
  2    30     2 te_pre_empt fixed bin (18),			/* times te updated from pre_empt */
  2    31     2 p_interactions fixed bin,			/* times interaction bit turned off because of high priority */
  2    32     2 idle fixed bin (71),				/* total idle time */
  2    33     2 mp_idle fixed bin (71),				/* multi-programming idle */
  2    34 
  2    35     2 nmp_idle fixed bin (71),			/* non-multi-programming idle time */
  2    36     2 zero_idle fixed bin (71),			/* zero idle time */
  2    37     2 last_time fixed bin (71),			/* last time a process was run */
  2    38     2 loop_locks fixed bin (18),			/* times looped on the APT lock */
  2    39     2 loop_lock_time fixed bin (18),			/* time looping on the APT lock */
  2    40     2 ave_eligible fixed bin (35, 18),			/* average length of eligible queue */
  2    41     2 sort_to_elhead fixed bin (18),			/* 0=> no one,1 => int've only, 2 => everybody */
  2    42     2 processor_time fixed bin (71),			/* total processor time on system */
  2    43     2 response_time fixed bin (71),			/* estimate of response time */
  2    44     2 eligible_time fixed bin (71),			/* estimate of eligible time */
  2    45     2 response_count fixed bin,			/* count of response meters */
  2    46     2 eligible_count fixed bin,			/* count of eligible meters */
  2    47     2 quit_counts (0:5) fixed bin,			/* array of buckets indexed by state */
  2    48     2 loading_idle fixed bin (71),			/* loading_idle time */
  2    49     2 delta_vcpu fixed bin (71),			/* delta virtual CPU time for the system */
  2    50     2 post_purge_switch fixed bin,			/* ON if post purging is to be done */
  2    51     2 time_out_severity fixed bin,			/* syserr first arg for notify time outs */
  2    52     2 notify_check fixed bin,				/* obsolete */
  2    53     2 quit_priority fixed bin,			/* factor for scheduler quit response */
  2    54     2 iobm_polling_time fixed bin (71),			/* time to poll iobm */
  2    55     2 end_of_time fixed bin (71),			/* very large time */
  2    56     2 gp_at_notify fixed bin (18),			/* 0 => just do get_idle_processor */
  2    57     2 gp_at_ptlnotify fixed bin (18),			/* 0 => just do get_idle_processor */
  2    58     2 int_q_enabled fixed bin (18),			/* 0 => no intv q in percent mode */
  2    59     2 fnp_buffer_threshold fixed bin (18),		/* if fewer free buffs then stingy alloc strategy */
  2    60 						/* set this to >= half n_ttylines/fnp for safety */
  2    61 
  2    62 /* 100 octal */
  2    63 
  2    64     2 depths (8) fixed bin (18),			/* histogram of run depths */
  2    65     2 tdepths (8) fixed bin (71),			/* histogram of times run per depth */
  2    66     2 pfdepth (8) fixed bin (18),			/* histogram of page faults per depth */
  2    67 
  2    68     2 ptl_not_waits fixed bin (18),			/* times ptl_wait noticed ptl was unlocked */
  2    69     2 gw_gp_window_count fixed bin (18),		/* times window noticed */
  2    70     2 metering_lock fixed bin (18),			/* 0=locked, else unlocked */
  2    71     2 ptl_waits fixed bin (18),			/* num calls to ptl_wait */
  2    72     2 gp_start_count fixed bin (18),			/*  to detect gw_gp window lossage */
  2    73     2 gp_done_count fixed bin (18),
  2    74     2 nto_check_time fixed bin (71),			/* next time at which nto code will be called */
  2    75     2 nto_delta fixed bin (35),			/* microsec between nto checks */
  2    76     2 nto_count fixed bin (18),			/* number of times nto detected */
  2    77     2 tcpu_scheduling fixed bin (18),			/* obsolete				*/
  2    78     2 nto_event bit (36),				/* last event which NTO'd */
  2    79     2 page_notifies fixed bin (18),
  2    80     2 notify_nobody_count fixed bin (18),
  2    81     2 notify_nobody_event bit (36),
  2    82     2 system_type fixed bin,				/* used to be tcm.inter */
  2    83 
  2    84     2 stat (0:15) fixed bin (18),			/* num apte's in each state */
  2    85 
  2    86 /* 200 octal */
  2    87 
  2    88     2 wait (8),
  2    89       3 time fixed bin (18),				/* histogram of page fault waiting times versus did */
  2    90       3 count fixed bin (18),
  2    91 
  2    92     2 ready (8),
  2    93       3 time fixed bin (18),				/* histogram of times in ready queue */
  2    94       3 count fixed bin (18),
  2    95 
  2    96     2 total_pf_time fixed bin (71),			/* total time spent from start to end of
  2    97*						   all page faults */
  2    98     2 total_pf_count fixed bin (18),			/* total number of page faults metered */
  2    99     2 auto_tune_ws fixed bin (18),			/* 0=> dont, atherwise compensate for quantum len */
  2   100     2 ocore_delta fixed bin (18),			/* number of pages reserved for int users */
  2   101     2 ws_sum fixed bin (18),				/* total of eligible's ws_sizes */
  2   102     2 nonidle_force_count fixed bin (18),		/* count of eligibilities forced */
  2   103     2 itt_list_lock bit (36) aligned,			/* Lock on ITT free list */
  2   104     2 cpu_pf_time fixed bin (71),			/* total cpu time spent handling page faults */
  2   105     2 cpu_pf_count fixed bin (18),			/* total count of cpu time meterings */
  2   106     2 special_offsets unaligned,
  2   107       3 apt_offset bit (18),
  2   108       3 pad bit (18),
  2   109     2 getwork_time fixed bin (71),			/* total time spent in getwork */
  2   110     2 getwork_count fixed bin (18),			/* total times through getwork */
  2   111     2 short_pf_count fixed bin (18),			/* number of short page faults */
  2   112     2 interrupt_time fixed bin (71),			/* total time spent in interrupt */
  2   113     2 interrupt_count fixed bin (71),			/* total number of metered interrupts */
  2   114     2 ocore fixed bin (35, 18),			/* fraction of core for int've users */
  2   115     2 pre_empt_flag bit (36) aligned,			/* controls whether preempting at done time */
  2   116     2 cumulative_memory_usage fixed binary (71),		/* total number of memory usage units */
  2   117     2 processor_time_at_define_wc fixed bin (71),		/* value of processor_time when WC's last defined */
  2   118     2 boost_priority fixed bin,			/* number of times priority process given high priority */
  2   119     2 lost_priority fixed bin,			/* number of times priority process lost eligibility */
  2   120     2 total_clock_lag fixed bin (71),			/* sum of all simulated clock delays */
  2   121     2 clock_simulations fixed bin,			/* number of times alarm clock interrupt was simulated */
  2   122     2 max_clock_lag fixed bin,			/* largest simulated alarm clock delay */
  2   123 
  2   124 /* 300 octal */
  2   125 
  2   126     2 pdscopyl fixed bin (18),			/* amount of pds to copy for new process */
  2   127     2 max_hproc_segno fixed bin,			/* largest allowed hardcore segment number */
  2   128     2 prds_length fixed bin (18),			/* length of PRDS */
  2   129     2 pds_length fixed bin (18),			/* length of PDS */
  2   130     2 lock fixed bin (18),				/* process id generator lock */
  2   131     2 id bit (36) aligned,				/* next uid to be added to uid_array */
  2   132     2 system_shutdown fixed bin (18),
  2   133     2 working_set_factor fixed bin (35, 18),		/* working set factor */
  2   134 
  2   135     2 ncpu fixed bin (18),				/* number of processors currently being used */
  2   136     2 last_eligible bit (18),				/* last process to gain eligibility */
  2   137     2 apt_lock fixed bin (35),			/* + write; 0 hidden; -1 unlocked; -(N+1) Nreaders */
  2   138     2 apt_size fixed bin (18),			/* number of APT entries */
  2   139     2 realtime_q aligned like based_sentinel,		/* processes with realtime deadlines */
  2   140     2 aht_size fixed bin (18),			/* APT hash table size */
  2   141     2 itt_size fixed bin (18),			/* number of ITT entries */
  2   142 
  2   143     2 dst_size fixed bin (18),			/* number of allowed DST entries */
  2   144     2 itt_free_list bit (18),				/* pointer to ITT free list */
  2   145     2 used_itt fixed bin (18),			/* number of used ITT entries */
  2   146     2 initializer_id bit (36) aligned,			/* process id of initializer */
  2   147     2 n_eligible fixed bin (18),			/* number of processes eligible */
  2   148     2 max_eligible fixed bin (30),			/* maximum allowed number of eligible processes */
  2   149     2 wait_enable fixed bin (18),			/* turned on when waiting mechanism works */
  2   150     2 apt_entry_size fixed bin (18),			/* size of an APT entry */
  2   151 
  2   152     2 interactive_q aligned like based_sentinel,		/* head of interactive queue */
  2   153     2 dst_ptr ptr,					/* pointer to device signal table */
  2   154     2 old_user ptr,					/* last process to run (apt ptr ) */
  2   155     2 initialize_time fixed bin (71),			/* time of initialization */
  2   156 
  2   157     2 init_event fixed bin (18),			/* wait event during initialization */
  2   158     2 oldt fixed bin (18),				/* timer reading from previous process */
  2   159     2 newt fixed bin (18),				/* timer setting for new process */
  2   160     2 tefirst fixed bin (30),				/* first eligible time */
  2   161     2 telast fixed bin (30),				/* last eligible time */
  2   162     2 timax fixed bin (35),				/* time in queue for lowest level */
  2   163     2 empty_q bit (18),				/* thread of empty APT entries */
  2   164     2 working_set_addend fixed bin (18),		/* additive working set parameter */
  2   165     2 ready_q_head bit (0) aligned,			/* for added segdef */
  2   166     2 eligible_q_head aligned like based_sentinel,	/* head of eligible queue */
  2   167     2 ready_q_tail bit (0) aligned,			/* for added segdef */
  2   168     2 eligible_q_tail aligned like based_sentinel,	/* tail of eligible queue */
  2   169     2 idle_tail aligned like based_sentinel,		/* tail of idle list */
  2   170     2 min_eligible fixed bin (30),
  2   171     2 alarm_timer_list bit (18) aligned,		/* rel pointer to apt entry for next alarm timer */
  2   172     2 guaranteed_elig_inc fixed bin (35),		/* amount of guaranteed eligibility time in microsecs. */
  2   173     2 priority_sched_inc fixed bin (35),		/* amount of block time before process is given priority */
  2   174     2 next_alarm_time fixed bin (71),			/* clock time for next alarm timer */
  2   175     2 priority_sched_time fixed bin (71),		/* time for priority process to be given priority */
  2   176     2 opc_polling_time fixed bin (71),			/* time to poll console DIM */
  2   177     2 disk_polling_time fixed bin (71),			/* time to poll disk DIM */
  2   178     2 tape_polling_time fixed bin (71),			/* time to poll tape DIM */
  2   179     2 imp_polling_time fixed bin (71),			/* time to poll imp */
  2   180     2 imp_polling_lock fixed bin (18),			/* do not poll if lock set */
  2   181     2 max_channels fixed bin (18),			/* num special channels per process */
  2   182 
  2   183 /* 400 octal */
  2   184 
  2   185     2 system_virtual_time fixed bin (71),		/* non-idle virtual time */
  2   186     2 credit_bank fixed bin (71),			/* credits not yet passed out */
  2   187     2 min_wct_index bit (18) aligned,			/* offset of initializer work class table entry */
  2   188     2 max_wct_index bit (18) aligned,			/* offset of highest wcte currently defined */
  2   189     2 delta_vt fixed bin (71),			/* temp used by pxss.compute_virtual_clocks */
  2   190     2 gross_idle_time fixed bin (71),			/* idle time_used_clock */
  2   191     2 credits_per_scatter fixed bin (35),		/* total number of credits awarded at once */
  2   192     2 best_credit_value fixed bin (18),			/* temp for pxss.find_next_eligible */
  2   193     2 define_wc_time fixed bin (71),			/* clock time when workclasses last degined */
  2   194     2 max_batch_elig fixed bin (35),
  2   195     2 num_batch_elig fixed bin (35),
  2   196     2 deadline_mode fixed bin (35),			/* 0=> ti sorts, else deadline sorts */
  2   197     2 credits_scattered fixed bin (35),
  2   198     2 max_max_eligible fixed bin (30),			/* Maximum of maxe */
  2   199     2 max_stopped_stack_0 fixed bin (35),		/* Maximum stack_0's suspended by stopped procs	*/
  2   200     2 stopped_stack_0 fixed bin (35),			/* Number stack_0's suspended by stopped procs	*/
  2   201     2 mos_polling_interval fixed bin (35),		/* for heals */
  2   202     2 mos_polling_time fixed bin (71),			/* for heals */
  2   203     2 vcpu_response_bounds (VCPU_RESPONSE_BOUNDS) fixed bin (35),
  2   204     2 vcpu_response_bounds_size fixed bin (35),
  2   205     2 meter_response_time_calls fixed bin (35),
  2   206     2 meter_response_time_invalid fixed bin (35),
  2   207     2 meter_response_time_overhead fixed bin (71),
  2   208     2 init_wait_time fixed bin (71),			/* used by wait/notify during initialization	*/
  2   209     2 init_wait_timeout fixed bin (71),			/* notify-timeout interval during initialization	*/
  2   210     2 init_timeout_severity fixed bin,			/* notify-timeout severity during initialization	*/
  2   211     2 init_timeout_recurse fixed bin,			/* count of NTO recursion during initialization	*/
  2   212     2 max_timer_register fixed bin (71),		/* max cpu burst = # cpus x pre_empt_sample_time	*/
  2   213     2 pre_empt_sample_time fixed bin (35),		/* tuning parameter - max time between samples	*/
  2   214     2 governing_credit_bank fixed bin (35),		/* used for limiting eligibility on governed work classes*/
  2   215     2 process_initial_quantum fixed bin (35),		/* eligibility quantum first eligibility	*/
  2   216     2 default_procs_required bit (8) aligned,		/* default mask of CPUs required */
  2   217     2 work_class_idle fixed bin (71),			/* idle time due to work class restrictions */
  2   218 
  2   219 /* Tuning Parameters for Stack Truncation */
  2   220 
  2   221     2 stk_truncate bit (1) aligned,
  2   222     2 stk_truncate_always bit (1) aligned,
  2   223     2 stk_trunc_avg_f1 fixed bin (35, 18),
  2   224     2 stk_trunc_avg_f2 fixed bin (35, 18),
  2   225     2 lock_error_severity fixed bin,                        /* syserr severity */
  2   226 
  2   227     2 gv_integration fixed bin (35),			/* Integration interval for governing */
  2   228     2 gv_integration_set bit (1) aligned,		/* ON => gv_integration set by ctp */
  2   229     2 pauses fixed bin (35),				/* Calls to pause (reschedule) */
  2   230     2 volmap_polling_time fixed bin (71),
  2   231     2 next_ring0_timer fixed bin (71),			/* next time that ring 0 timer goes off */
  2   232     2 realtime_io_priority_switch fixed bin,		/* 0 => give I/O interrupt wakeups realtime priotiry */
  2   233     2 realtime_io_deadline fixed bin (35),		/* Delta to clock for I/O realtime deadline */
  2   234     2 realtime_io_quantum fixed bin (35),		/* Quantum for I/O realtime burst */
  2   235     2 realtime_priorities fixed bin (35),		/* Count for metering */
  2   236     2 relinquishes fixed bin (35),			/* Calls to relinquish_priority */
  2   237     2 abort_ips_mask bit (36) aligned,			/* IPS mask for tc_util$check_abort */
  2   238 
  2   239 /* 500 octal */
  2   240 
  2   241     2 uid_array (0:15) bit (36) aligned,		/* array from which a uid is chosen (randomly) */
  2   242     2 pad5 (176) fixed bin (35),			/* room for expansion compatibly		*/
  2   243 
  2   244 /* 1000 octal */
  2   245 
  2   246     2 pad7 (64) fixed bin (35),
  2   247 
  2   248 /* 1100 octal */
  2   249 
  2   250     2 pad6 (8) fixed bin (35),
  2   251     2 work_class_table aligned,			/* array of per workclass information */
  2   252       3 wcte (0:16) aligned like wct_entry,
  2   253 
  2   254 /* 3000 octal */
  2   255 
  2   256     2 apt fixed bin;
  2   257 
  2   258 dcl  wctep ptr;
  2   259 
  2   260 dcl 1 wct_entry aligned based (wctep),			/* Work class entry */
  2   261     2 thread unaligned,				/* Ready list */
  2   262       3 fp bit (18),				/* Head of ready list */
  2   263       3 bp bit (18),				/* Tail of ready list */
  2   264     2 flags unaligned,
  2   265       3 mnbz bit (1),				/* Sentinel bit must not be zero. */
  2   266       3 defined bit (1),
  2   267       3 io_priority bit (1),
  2   268       3 governed bit (1),
  2   269       3 interactive_q bit (1),
  2   270       3 pad bit (31),
  2   271     2 credits fixed bin (35),				/* Current worthiness of group */
  2   272     2 minf fixed bin (35),				/* min fraction of cpu */
  2   273     2 pin_weight fixed bin (35),			/* number of cycles to pin pages */
  2   274     2 eligibilities fixed bin (35),			/* Count of eligibilities awarded */
  2   275     2 cpu_sum fixed bin (71),				/* CPU used by members */
  2   276     2 resp1 fixed bin (71),
  2   277     2 resp2 fixed bin (71),
  2   278     2 quantum1 fixed bin (35),
  2   279     2 quantum2 fixed bin (35),
  2   280     2 rmeter1 fixed bin (71),
  2   281     2 rmeter2 fixed bin (71),
  2   282     2 rcount1 fixed bin (35),
  2   283     2 rcount2 fixed bin (35),
  2   284     2 realtime fixed bin (35),
  2   285     2 purging fixed bin (35),
  2   286     2 maxel fixed bin (35),
  2   287     2 nel fixed bin (35),
  2   288     2 number_thinks fixed bin (35),			/* number times process entered "think" state	*/
  2   289     2 number_queues fixed bin (35),			/* number times process entered "queued" state	*/
  2   290     2 total_think_time fixed bin (71),
  2   291     2 total_queue_time fixed bin (71),
  2   292 
  2   293 /*  The next three arrays  correspond to the array vcpu_response_bounds				*/
  2   294 
  2   295     2 number_processing (VCPU_RESPONSE_BOUNDS+1) fixed bin (35), /* number times entered "processing" state	*/
  2   296     2 total_processing_time (VCPU_RESPONSE_BOUNDS+1) fixed bin (71),
  2   297     2 total_vcpu_time (VCPU_RESPONSE_BOUNDS+1) fixed bin (71),
  2   298     2 maxf fixed bin (35),				/* maximum fraction of cpu time		*/
  2   299     2 governing_credits fixed bin (35),			/* for limiting cpu resources			*/
  2   300     2 pad1 (4) fixed bin (35);
  2   301 	
  2   302 
  2   303 dcl 1 based_sentinel aligned based,			/* format of pxss-style sentinel */
  2   304     2 fp bit (18) unal,
  2   305     2 bp bit (18) unal,
  2   306     2 sentinel bit (36) aligned;
  2   307 
  2   308 dcl VCPU_RESPONSE_BOUNDS fixed bin init (3) int static options (constant);
  2   309 
  2   310 /* END INCLUDE FILE tcm.incl.pl1 */
      137 
      138 
      139 
  3     1 /* Begin include file hc_lock.incl.pl1 BIM 2/82 */
  3     2 /* Replaced by hc_fast_lock.incl.pl1 RSC 11/84 because name of structure
  3     3*   encourages name conflicts.
  3     4*   USE HC_FAST_LOCK INSTEAD!
  3     5**/
  3     6 
  3     7 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  3     8 
  3     9 /* format: style3 */
  3    10 
  3    11 declare	lock_ptr		pointer;
  3    12 declare	1 lock		aligned based (lock_ptr),
  3    13 	  2 pid		bit (36) aligned,		/* holder of lock */
  3    14 	  2 event		bit (36) aligned,		/* event associated with lock */
  3    15 	  2 flags		aligned,
  3    16 	    3 notify_sw	bit (1) unaligned,
  3    17 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  3    18 
  3    19 /* End include file hc_lock.incl.pl1 */
      140 
      141 
      142 
      143 	sort = 0;					/* default is not to sort */
      144 
      145 /* Pick up all arguments. */
      146 
      147 	call cu_$arg_ptr (1, argp, arglen, code);	/* Grab first argument. */
      148 	if code ^= 0
      149 	then do;
      150 		call com_err_ (code, who_it_is, "Gate name");
      151 		return;
      152 	     end;
      153 
      154 
      155 	segname = argument;				/* Get name of gate segment. */
      156 	no_report = "0"b;
      157 	reset_sw = "0"b;
      158 
      159 	do argno = 2 to cu_$arg_count ();		/* pick up control args */
      160 	     call cu_$arg_ptr (argno, argp, arglen, code);/* Grab second argument. */
      161 	     if argument = "-call" | argument = "-cl"
      162 	     then sort = 1;				/* sort by number of calls */
      163 	     else if argument = "-time" | argument = "-tm"
      164 	     then sort = 2;				/* sort by time used */
      165 	     else if argument = "-average" | argument = "-av"
      166 	     then sort = 3;				/* sort by average number of calls */
      167 	     else if argument = "-page" | argument = "-pg"
      168 	     then sort = 4;				/* sort by number of page faults */
      169 	     else if argument = "-reset" | argument = "-rs"
      170 	     then no_report, reset_sw = "1"b;		/* reset requested */
      171 	     else if argument = "-report_reset" | argument = "-rr"
      172 	     then reset_sw = "1"b;
      173 	     else do;
      174 		     entry = argument;
      175 		     sort = 5;			/* search for this entry */
      176 		end;
      177 	end;
      178 
      179 
      180 /* Check to see if we've set up our static variables */
      181 
      182 	if tcdp0 = null
      183 	then do;					/* not yet... */
      184 		call ring0_get_$segptr ("", "tc_data", tcdp0, code);
      185 		if code ^= 0
      186 		then do;
      187 			call com_err_ (code, who_it_is, "Cannot find tc_data");
      188 			return;
      189 		     end;
      190 		itimep0 = addr (tcdp0 -> tcm.initialize_time);
      191 		ptimep0 = addr (tcdp0 -> tcm.processor_time);
      192 		ltimep0 = addr (tcdp0 -> tcm.idle);
      193 		call get_temp_segments_ (who_it_is, tempp, code);
      194 		if code ^= 0
      195 		then do;
      196 			call com_err_ (code, who_it_is, "Getting temp segs");
      197 			return;
      198 		     end;
      199 	     end;
      200 
      201 /* Fill in static data for gate. */
      202 
      203 	do gi = 1 to max_gates;
      204 	     if gate_info (gi).name = segname
      205 	     then go to got_gate;
      206 	end;
      207 
      208 	max_gates = gi;
      209 	gate_info (gi).name = segname;
      210 	gate_info (gi).old_time = 0;
      211 	gate_info (gi).old_charged = 0;
      212 got_gate:						/* Now get data for gate. */
      213 	call get_gate_data_ (segname, table.gate, nentries, tempp (1), reset_sw, code);
      214 	if code ^= 0
      215 	then do;
      216 		call com_err_ (code, who_it_is, "Getting gate data");
      217 		return;
      218 	     end;
      219 
      220 
      221 /*  Now get current clock readings */
      222 
      223 	call ring_zero_peek_ (itimep0, addr (itime), 2, code);
      224 	call ring_zero_peek_ (ptimep0, addr (charged_time), 2, code);
      225 	call ring_zero_peek_ (ltimep0, addr (idle_time), 2, code);
      226 
      227 	charged_time = charged_time - idle_time;
      228 	if gate_info (gi).old_time > 0
      229 	then itime = gate_info (gi).old_time;
      230 	ctime = charged_time - gate_info (gi).old_charged;
      231 
      232 	timnow = clock_ ();				/* Get current time */
      233 
      234 	if ^no_report
      235 	then do;					/* only do the work if we have to */
      236 		i = 0;				/* Count iterations. */
      237 		tottim = 0;			/* Initialize total time count. */
      238 		totcalls = 0;			/* Initialize count of total calls. */
      239 		total_ring_alarms = 0;		/* Initialize RA count */
      240 
      241 
      242 /* Major information handling and sorting loop. */
      243 
      244 		do i = 1 to nentries;
      245 		     gate_datap = table (i).datap;	/* Copy the pointer. */
      246 		     namep = table (i).entryp;
      247 		     namel = table (i).entryl;
      248 
      249 		     calls = gate_entry_data.calls;	/* Extract count of calls to entry. */
      250 		     if calls ^= 0
      251 		     then /* Compute average and save. */
      252 			avg = float (gate_entry_data.vcpu_time, 27) / (1.e3 * float (gate_entry_data.calls, 27));
      253 		     else avg = 0.e0;
      254 		     table (i).avg = avg;
      255 
      256 		     if sort = 5
      257 		     then do;			/* if only want selected entry */
      258 			     if entryname = entry
      259 			     then do;		/* in single entry mode - match? */
      260 				     j = i;	/* Set loop variable */
      261 				     call print;	/* Go print the poop */
      262 				     go to finish;
      263 				end;
      264 			     else go to next;	/* Skip the sorting crap */
      265 			end;
      266 
      267 		     totcalls = totcalls + calls;	/* Compute total number of calls. */
      268 		     tottim = tottim + gate_entry_data.vcpu_time;
      269 						/* Compute total time spent inside gate. */
      270 		     total_ring_alarms = total_ring_alarms + gate_entry_data.ring_alarms;
      271 
      272 /* Perform sorting. */
      273 
      274 		     if sort ^= 0
      275 		     then do j = i - 1 to 1 by -1;	/* If sorting specified ... */
      276 
      277 			     if sort = 1
      278 			     then /* If sorting on number of calls ... */
      279 				if table (j).datap -> gate_entry_data.calls < gate_entry_data.calls
      280 				then go to next;
      281 				else ;
      282 
      283 			     else if sort = 2
      284 			     then /* If sorting on total time ... */
      285 				if table (j).datap -> gate_entry_data.vcpu_time < gate_entry_data.vcpu_time
      286 				then go to next;
      287 				else ;
      288 
      289 			     else if sort = 3
      290 			     then /* If sorting on average time ... */
      291 				if table (j).avg < avg
      292 				then go to next;
      293 				else ;
      294 
      295 			     else if sort = 4
      296 			     then /* If sorting on page waits ... */
      297 				if table (j).datap -> gate_entry_data.page_waits < gate_entry_data.page_waits
      298 				then go to next;
      299 				else ;
      300 
      301 			     temp_table = table (j + 1);
      302 			     table (j + 1) = table (j);
      303 			     table (j) = temp_table;
      304 
      305 			end;
      306 
      307 next:
      308 		end;
      309 
      310 
      311 /* Print out the accumulated and sorted information. */
      312 
      313 		if sort = 5
      314 		then do;				/* If searching for specific entry ... */
      315 			call ioa_ ("Entry ^a not found or not metered in gate ^a.", entry, segname);
      316 			return;
      317 		     end;
      318 
      319 		call date_time_ (itime, citime);
      320 		call date_time_ (timnow, ctimnow);
      321 
      322 
      323 		call comp_time (ctime);		/* Break down charged time. */
      324 
      325 		call ioa_ ("^/Metering since ^a.^/Total non-idle time at ^a = ^d hr. ^d min. ^d sec.", citime,
      326 		     ctimnow, hr, mn, sc);
      327 
      328 		if totcalls > 0
      329 		then do;				/* we have something to meter */
      330 
      331 			call ioa_ ("^/Gate meters for ^a: total calls = ^d, total ring alarms polled = ^d.", segname, totcalls, total_ring_alarms);
      332 						/* Print header. */
      333 
      334 			if ctime > 0
      335 			then ptime = (float (tottim, 63) / float (ctime, 63)) * 1.e2;
      336 						/* Compute percentage. */
      337 			else ptime = 0e0;
      338 			call comp_time (tottim);	/* Break down total time in gate. */
      339 
      340 			call ioa_ ("^d hr. ^d min. ^d sec. or ^6.3f% spent in calls through gate.", hr, mn, sc,
      341 			     ptime);
      342 
      343 			call ioa_ ("^/            ring                    page");
      344 			call ioa_ ("  calls   alarms   pcnt     avg   faults  entry name^/");
      345 
      346 			do j = nentries by -1 to 1;	/* Loop through information. */
      347 			     call print;
      348 			end;
      349 		     end;
      350 		else call ioa_ ("No calls through this gate.");
      351 
      352 		call ioa_ ("^/");
      353 	     end;
      354 
      355 finish:
      356 	if reset_sw
      357 	then do;
      358 		gate_info (gi).old_time = timnow;
      359 		gate_info (gi).old_charged = charged_time;
      360 	     end;
      361 
      362 
      363 	return;					/* Bye-bye. */
      364 
      365 
      366 /* Internal Procedure to Print Output Line. */
      367 
      368 print:
      369      proc;
      370 
      371 	gate_datap = table (j).datap;			/* Extract pointers. */
      372 	namep = table (j).entryp;			/* .. */
      373 	namel = table (j).entryl;			/* .. */
      374 	avg = table (j).avg;			/* .. */
      375 	if gate_entry_data.calls > 0
      376 	then do;
      377 		if ctime <= 0
      378 		then ptime = 0e0;			/* ctime may be zero .. */
      379 		else ptime = (float (gate_entry_data.vcpu_time, 63) / float (ctime, 63)) * 1.e2;
      380 						/* Compute percentage. */
      381 		ppage = float (gate_entry_data.page_waits, 27) / float (gate_entry_data.calls, 27);
      382 						/* Compute page waits per call. */
      383 		call ioa_ ("^7d  ^7d  ^5.2f ^8.2f  ^6.2f  ^a", gate_entry_data.calls, gate_entry_data.ring_alarms,
      384 		     ptime, avg, ppage, entryname);
      385 	     end;
      386 
      387 
      388      end;
      389 
      390 
      391 
      392 /* Internal Procedure to compute hours, minutes, and seconds. */
      393 
      394 comp_time:
      395      proc (a);
      396 
      397 	dcl     a			        fixed bin (71);
      398 						/* time in miscrseconds */
      399 
      400 
      401 	sc = divide (a, 1000000, 17, 0);		/* Compute seconds of time. */
      402 	mn = divide (sc, 60, 17, 0);			/* Compute minutes of time. */
      403 	hr = divide (mn, 60, 17, 0);			/* Compute hours of time. */
      404 	sc = mod (sc, 60);				/* Round the seconds. */
      405 	mn = mod (mn, 60);				/* And the minutes. */
      406 
      407 	return;
      408 
      409 
      410      end;
      411 
      412 
      413 
      414 
      415      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/22/85  1307.7  meter_gate.pl1                    >spec>temp>41-5>meter_gate.pl1
133          1    07/11/84  0937.3  gate_data.incl.pl1                >ldd>include>gate_data.incl.pl1
137          2    01/22/85  1321.5  tcm.incl.pl1                      >spec>temp>41-5>tcm.incl.pl1
140          3    01/06/85  1422.1  hc_lock.incl.pl1                  >ldd>include>hc_lock.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a                                      parameter       fixed bin(71,0)          dcl 397 ref 394 401
addr                                                   builtin function         dcl 127 ref 190 191 192 223 223 224 224 225 225
arglen                          000114 automatic       fixed bin(17,0)          dcl 50 set ref 147* 155 160* 161 161 163 163 165 165
                                                                                  167 167 169 169 171 171 174
argno                           000100 automatic       fixed bin(17,0)          dcl 46 set ref 159* 160*
argp                            000112 automatic       pointer                  dcl 50 set ref 147* 155 160* 161 161 163 163 165 165
                                                                                  167 167 169 169 171 171 174
argument                               based           char                     unaligned dcl 50 ref 155 161 161 163 163 165 165 167
                                                                                  167 169 169 171 171 174
avg                       3     000202 automatic       float bin(27)            array level 2 in structure "table" dcl 87
                                                                                  in procedure "mg" set ref 254* 289 374
avg                             000102 automatic       float bin(27)            dcl 48 in procedure "mg" set ref 250* 253* 254 289
                                                                                  374* 383*
based_sentinel                         based           structure                level 1 dcl 2-303
calls                           000141 automatic       fixed bin(17,0)          dcl 50 in procedure "mg" set ref 249* 250 267
calls                     5            based           fixed bin(35,0)          level 2 in structure "gate_entry_data" dcl 1-14
                                                                                  in procedure "mg" set ref 249 250 277 277 375 381
                                                                                  383*
charged_time                    000172 automatic       fixed bin(71,0)          dcl 50 set ref 224 224 227* 227 230 359
citime                          000150 automatic       char(24)                 unaligned dcl 50 set ref 319* 325*
clock_                          000036 constant        entry                    external dcl 104 ref 232
code                            000111 automatic       fixed bin(35,0)          dcl 50 set ref 147* 148 150* 160* 184* 185 187* 193*
                                                                                  194 196* 212* 214 216* 223* 224* 225*
com_err_                        000024 constant        entry                    external dcl 99 ref 150 187 196 216
ctime                           000176 automatic       fixed bin(71,0)          dcl 50 set ref 230* 323* 334 334 377 379
ctimnow                         000156 automatic       char(24)                 unaligned dcl 50 set ref 320* 325*
cu_$arg_count                   000042 constant        entry                    external dcl 106 ref 159
cu_$arg_ptr                     000026 constant        entry                    external dcl 100 ref 147 160
datap                     2     000202 automatic       pointer                  array level 3 packed unaligned dcl 87 set ref 245
                                                                                  277 283 295 371
date_time_                      000040 constant        entry                    external dcl 105 ref 319 320
divide                                                 builtin function         dcl 127 ref 401 402 403
entry                           000125 automatic       char(32)                 unaligned dcl 50 set ref 174* 258 315*
entryl                    1     000202 automatic       fixed bin(17,0)          array level 3 dcl 87 set ref 247 373
entryname                              based           char                     unaligned dcl 122 set ref 258 383*
entryp                          000202 automatic       pointer                  array level 3 packed unaligned dcl 87 set ref 246
                                                                                  372
float                                                  builtin function         dcl 127 ref 250 250 334 334 379 379 381 381
gate                            000202 automatic       structure                array level 2 dcl 87 set ref 212*
gate_datap                      004206 automatic       pointer                  dcl 1-12 set ref 245* 249 250 250 268 270 277 283
                                                                                  295 371* 375 379 381 381 383 383
gate_entry_data                        based           structure                level 1 dcl 1-14
gate_info                 2            based           structure                array level 2 dcl 112
gate_info_struct                       based           structure                level 1 dcl 112
gate_table                             based           structure                level 1 dcl 1-7
get_gate_data_                  000044 constant        entry                    external dcl 107 ref 212
get_temp_segments_              000046 constant        entry                    external dcl 109 ref 193
gi                              000101 automatic       fixed bin(17,0)          dcl 47 set ref 203* 204* 208 209 210 211 228 228 230
                                                                                  358 359
hr                              000167 automatic       fixed bin(17,0)          dcl 50 set ref 325* 340* 403*
i                               000136 automatic       fixed bin(17,0)          dcl 50 set ref 236* 244* 245 246 247 254 260 274*
idle                     24            based           fixed bin(71,0)          level 2 dcl 2-11 set ref 192
idle_time                       000174 automatic       fixed bin(71,0)          dcl 50 set ref 225 225 227
initialize_time         336            based           fixed bin(71,0)          level 2 dcl 2-11 set ref 190
ioa_                            000034 constant        entry                    external dcl 103 ref 315 325 331 340 343 344 350 352
                                                                                  383
itime                           000144 automatic       fixed bin(71,0)          dcl 50 set ref 223 223 228* 319*
itimep0                         000016 internal static pointer                  dcl 39 set ref 190* 223*
j                               000137 automatic       fixed bin(17,0)          dcl 50 set ref 260* 274* 277 283 289 295 301 302 302
                                                                                  303* 346* 371 372 373 374
lock                                   based           structure                level 1 dcl 3-12
ltimep0                         000022 internal static pointer                  dcl 41 set ref 192* 225*
max_gates                              based           fixed bin(17,0)          level 2 dcl 112 set ref 203 208*
mn                              000170 automatic       fixed bin(17,0)          dcl 50 set ref 325* 340* 402* 403 405* 405
mod                                                    builtin function         dcl 127 ref 404 405
name                      2            based           char(32)                 array level 3 dcl 112 set ref 204 209*
namel                           000110 automatic       fixed bin(17,0)          dcl 50 set ref 247* 258 373* 383 383
namep                           000106 automatic       pointer                  dcl 50 set ref 246* 258 372* 383
nentries                        000140 automatic       fixed bin(17,0)          dcl 50 set ref 212* 244 346
no_report                       000104 automatic       bit(1)                   dcl 50 set ref 156* 169* 234
null                                                   builtin function         dcl 127 ref 182
old_charged              14            based           fixed bin(71,0)          array level 3 dcl 112 set ref 211* 230 359*
old_time                 12            based           fixed bin(71,0)          array level 3 dcl 112 set ref 210* 228 228 358*
page_waits                4            based           fixed bin(35,0)          level 2 dcl 1-14 ref 295 295 381
ppage                           000201 automatic       float bin(27)            dcl 50 set ref 381* 383*
processor_time           42            based           fixed bin(71,0)          level 2 dcl 2-11 set ref 191
ptime                           000200 automatic       float bin(27)            dcl 50 set ref 334* 337* 340* 377* 379* 383*
ptimep0                         000020 internal static pointer                  dcl 40 set ref 191* 224*
reset_sw                        000103 automatic       bit(1)                   dcl 49 set ref 157* 169* 171* 212* 355
ring0_get_$segptr               000032 constant        entry                    external dcl 102 ref 184
ring_alarms               6            based           fixed bin(35,0)          level 2 dcl 1-14 set ref 270 383*
ring_zero_peek_                 000030 constant        entry                    external dcl 101 ref 223 224 225
sc                              000171 automatic       fixed bin(17,0)          dcl 50 set ref 325* 340* 401* 402 404* 404
segname                         000115 automatic       char(32)                 unaligned dcl 50 set ref 155* 204 209 212* 315* 331*
sort                            000135 automatic       fixed bin(17,0)          dcl 50 set ref 143* 161* 163* 165* 167* 175* 256 274
                                                                                  277 283 289 295 313
table                           000202 automatic       structure                array level 1 dcl 87 set ref 301 302* 302 303*
tcdp0                           000010 internal static pointer                  initial dcl 35 set ref 182 184* 190 191 192
tcm                                    based           structure                level 1 dcl 2-11
temp_table                      004202 automatic       structure                level 1 dcl 94 set ref 301* 303
tempp                           000012 internal static pointer                  initial array dcl 37 set ref 193* 203 204 208 209
                                                                                  210 211 212* 228 228 230 358 359
timnow                          000146 automatic       fixed bin(71,0)          dcl 50 set ref 232* 320* 358
total_ring_alarms               000166 automatic       fixed bin(35,0)          dcl 50 set ref 239* 270* 270 331*
totcalls                        000142 automatic       fixed bin(17,0)          dcl 50 set ref 238* 267* 267 328 331*
tottim                          000164 automatic       fixed bin(71,0)          dcl 50 set ref 237* 268* 268 334 338*
vcpu_time                 2            based           fixed bin(71,0)          level 2 dcl 1-14 ref 250 268 283 283 379
wct_entry                              based           structure                level 1 dcl 2-260
who_it_is                       000000 constant        char(10)                 initial unaligned dcl 42 set ref 150* 187* 193* 196*
                                                                                  216*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
VCPU_RESPONSE_BOUNDS                   internal static fixed bin(17,0)          initial dcl 2-308
lock_ptr                               automatic       pointer                  dcl 3-11
tcmp                                   automatic       pointer                  dcl 2-9
wctep                                  automatic       pointer                  dcl 2-258

NAMES DECLARED BY EXPLICIT CONTEXT.
comp_time                       002012 constant        entry                    internal dcl 394 ref 323 338
finish                          001665 constant        label                    dcl 355 ref 262
got_gate                        000751 constant        label                    dcl 212 ref 204
meter_gate                      000314 constant        entry                    external dcl 29
mg                              000305 constant        entry                    external dcl 29
next                            001346 constant        label                    dcl 307 ref 258 277 283 289 295
print                           001702 constant        entry                    internal dcl 368 ref 261 347

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2200        2250    2047        2210
Length      2514    2047        50         227     130          14

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mg                                 2312 external procedure  is an external procedure.  
print                                   internal procedure  shares stack frame of external procedure mg.  
comp_time                               internal procedure  shares stack frame of external procedure mg.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 tcdp0                       mg
000012 tempp                       mg
000016 itimep0                     mg
000020 ptimep0                     mg
000022 ltimep0                     mg

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mg                       000100 argno                       mg
                         000101 gi                          mg
                         000102 avg                         mg
                         000103 reset_sw                    mg
                         000104 no_report                   mg
                         000106 namep                       mg
                         000110 namel                       mg
                         000111 code                        mg
                         000112 argp                        mg
                         000114 arglen                      mg
                         000115 segname                     mg
                         000125 entry                       mg
                         000135 sort                        mg
                         000136 i                           mg
                         000137 j                           mg
                         000140 nentries                    mg
                         000141 calls                       mg
                         000142 totcalls                    mg
                         000144 itime                       mg
                         000146 timnow                      mg
                         000150 citime                      mg
                         000156 ctimnow                     mg
                         000164 tottim                      mg
                         000166 total_ring_alarms           mg
                         000167 hr                          mg
                         000170 mn                          mg
                         000171 sc                          mg
                         000172 charged_time                mg
                         000174 idle_time                   mg
                         000176 ctime                       mg
                         000200 ptime                       mg
                         000201 ppage                       mg
                         000202 table                       mg
                         004202 temp_table                  mg
                         004206 gate_datap                  mg

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          call_ext_out_desc   call_ext_out        return              mod_fx1             ext_entry
divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
clock_                        com_err_                      cu_$arg_count                 cu_$arg_ptr
date_time_                    get_gate_data_                get_temp_segments_            ioa_
ring0_get_$segptr             ring_zero_peek_

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.


CONSTANTS
002036  aa     000002000000
002037  aa     000000000000
002040  aa     600000000041
002041  aa     000164000000

002042  aa     000002000000
002043  aa     000000000000
002044  aa     600000000041
002045  aa     000176000000

000000  aa  155 145 164 145	mete
000001  aa  162 137 147 141	r_ga
000002  aa  164 145 000 000	te

002046  aa     000000000074

000003  aa     000003641100

000004  aa     526000000000

000005  aa     524000000040

000006  aa     524000000002

000007  aa     524000000033

000010  aa     524000000066

000011  aa     524000000052

000012  aa     414000000033

000013  aa     524000000075

000014  aa     524000000106

000015  aa     524000000110

000016  aa     526000000030

000017  aa     524000000055

000020  aa     514000000001

000021  aa     526000000040

000022  aa     524000000021

000023  aa     524000000023

000024  aa     464000000000

000025  aa     524000000007

000026  aa     524000000000

000027  aa  055 162 162 000	-rr

000030  aa  055 162 163 000	-rs

000031  aa  055 160 147 000	-pg

000032  aa  055 141 166 000	-av

000033  aa  055 164 155 000	-tm

000034  aa  055 143 154 000	-cl

000035  aa     524000000011

000036  aa     526000000012

000037  aa     404000000043

000040  aa     404000000021

000041  aa     410000000107

000042  aa     000000000000
000043  aa     000000000000

000044  aa  164 143 137 144	tc_d
000045  aa  141 164 141 000	ata

000046  aa     077777000043
000047  aa     000001000000

000050  aa  055 162 145 163	-res
000051  aa  145 164 000 000	et

000052  aa  055 160 141 147	-pag
000053  aa  145 000 000 000	e

000054  aa  055 141 166 145	-ave
000055  aa  162 141 147 145	rage

000056  aa  055 164 151 155	-tim
000057  aa  145 000 000 000	e

000060  aa  055 143 141 154	-cal
000061  aa  154 000 000 000	l

000062  aa  107 141 164 145	Gate
000063  aa  040 156 141 155	 nam
000064  aa  145 000 000 000	e

000065  aa     464100000000
000066  aa     000000000001
000067  aa     000000000002
000070  aa     000000000002

000071  aa  055 162 145 160	-rep
000072  aa  157 162 164 137	ort_
000073  aa  162 145 163 145	rese
000074  aa  164 000 000 000	t

000075  aa  107 145 164 164	Gett
000076  aa  151 156 147 040	ing 
000077  aa  147 141 164 145	gate
000100  aa  040 144 141 164	 dat
000101  aa  141 000 000 000	a

000102  aa  107 145 164 164	Gett
000103  aa  151 156 147 040	ing 
000104  aa  164 145 155 160	temp
000105  aa  040 163 145 147	 seg
000106  aa  163 000 000 000	s

000107  aa  103 141 156 156	Cann
000110  aa  157 164 040 146	ot f
000111  aa  151 156 144 040	ind 
000112  aa  164 143 137 144	tc_d
000113  aa  141 164 141 000	ata

000114  aa  116 157 040 143	No c
000115  aa  141 154 154 163	alls
000116  aa  040 164 150 162	 thr
000117  aa  157 165 147 150	ough
000120  aa  040 164 150 151	 thi
000121  aa  163 040 147 141	s ga
000122  aa  164 145 056 000	te.

000123  aa  136 067 144 040	^7d 
000124  aa  040 136 067 144	 ^7d
000125  aa  040 040 136 065	  ^5
000126  aa  056 062 146 040	.2f 
000127  aa  136 070 056 062	^8.2
000130  aa  146 040 040 136	f  ^
000131  aa  066 056 062 146	6.2f
000132  aa  040 040 136 141	  ^a

000133  aa  136 057 040 040	^/  
000134  aa  040 040 040 040	    
000135  aa  040 040 040 040	    
000136  aa  040 040 162 151	  ri
000137  aa  156 147 040 040	ng  
000140  aa  040 040 040 040	    
000141  aa  040 040 040 040	    
000142  aa  040 040 040 040	    
000143  aa  040 040 040 040	    
000144  aa  040 040 160 141	  pa
000145  aa  147 145 000 000	ge

000146  aa  105 156 164 162	Entr
000147  aa  171 040 136 141	y ^a
000150  aa  040 156 157 164	 not
000151  aa  040 146 157 165	 fou
000152  aa  156 144 040 157	nd o
000153  aa  162 040 156 157	r no
000154  aa  164 040 155 145	t me
000155  aa  164 145 162 145	tere
000156  aa  144 040 151 156	d in
000157  aa  040 147 141 164	 gat
000160  aa  145 040 136 141	e ^a
000161  aa  056 000 000 000	.

000162  aa  040 040 143 141	  ca
000163  aa  154 154 163 040	lls 
000164  aa  040 040 141 154	  al
000165  aa  141 162 155 163	arms
000166  aa  040 040 040 160	   p
000167  aa  143 156 164 040	cnt 
000170  aa  040 040 040 040	    
000171  aa  141 166 147 040	avg 
000172  aa  040 040 146 141	  fa
000173  aa  165 154 164 163	ults
000174  aa  040 040 145 156	  en
000175  aa  164 162 171 040	try 
000176  aa  156 141 155 145	name
000177  aa  136 057 000 000	^/

000200  aa  136 144 040 150	^d h
000201  aa  162 056 040 136	r. ^
000202  aa  144 040 155 151	d mi
000203  aa  156 056 040 136	n. ^
000204  aa  144 040 163 145	d se
000205  aa  143 056 040 157	c. o
000206  aa  162 040 136 066	r ^6
000207  aa  056 063 146 045	.3f%
000210  aa  040 163 160 145	 spe
000211  aa  156 164 040 151	nt i
000212  aa  156 040 143 141	n ca
000213  aa  154 154 163 040	lls 
000214  aa  164 150 162 157	thro
000215  aa  165 147 150 040	ugh 
000216  aa  147 141 164 145	gate
000217  aa  056 000 000 000	.

000220  aa     504100000003
000221  aa     000000000001
000222  aa     000000001000
000223  aa     000000000004
000224  aa     466100000000
000225  aa     000000000001
000226  aa     000000001000
000227  aa     000000000220
000230  aa     404100000021
000231  aa     000000000001
000232  aa     000000001000
000233  aa     000000000004
000234  aa     466100000000
000235  aa     000000000001
000236  aa     000000001000
000237  aa     000000000220

000240  aa  136 057 107 141	^/Ga
000241  aa  164 145 040 155	te m
000242  aa  145 164 145 162	eter
000243  aa  163 040 146 157	s fo
000244  aa  162 040 136 141	r ^a
000245  aa  072 040 164 157	: to
000246  aa  164 141 154 040	tal 
000247  aa  143 141 154 154	call
000250  aa  163 040 075 040	s = 
000251  aa  136 144 054 040	^d, 
000252  aa  164 157 164 141	tota
000253  aa  154 040 162 151	l ri
000254  aa  156 147 040 141	ng a
000255  aa  154 141 162 155	larm
000256  aa  163 040 160 157	s po
000257  aa  154 154 145 144	lled
000260  aa  040 075 040 136	 = ^
000261  aa  144 056 000 000	d.

000262  aa  136 057 115 145	^/Me
000263  aa  164 145 162 151	teri
000264  aa  156 147 040 163	ng s
000265  aa  151 156 143 145	ince
000266  aa  040 136 141 056	 ^a.
000267  aa  136 057 124 157	^/To
000270  aa  164 141 154 040	tal 
000271  aa  156 157 156 055	non-
000272  aa  151 144 154 145	idle
000273  aa  040 164 151 155	 tim
000274  aa  145 040 141 164	e at
000275  aa  040 136 141 040	 ^a 
000276  aa  075 040 136 144	= ^d
000277  aa  040 150 162 056	 hr.
000300  aa  040 136 144 040	 ^d 
000301  aa  155 151 156 056	min.
000302  aa  040 136 144 040	 ^d 
000303  aa  163 145 143 056	sec.

BEGIN PROCEDURE mg
ENTRY TO mg                                                 STATEMENT 1 ON LINE 29
meter_gate:
mg:
     procedure options (variable);

000304  da     000121240000
000305  aa   004420 6270 00	eax7 	2320
000306  aa  7 00034 3521 20	epp2 	pr7|28,*
000307  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000310  aa     000000000000
000311  aa     000000000000
000312  aa   000007 7100 04	tra  	7,ic		000321
ENTRY TO meter_gate                                         STATEMENT 1 ON LINE 29
meter_gate:
mg:
     procedure options (variable);

000313  da     000124240000
000314  aa   004420 6270 00	eax7 	2320
000315  aa  7 00034 3521 20	epp2 	pr7|28,*
000316  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000317  aa     000000000000
000320  aa     000000000000
						STATEMENT 1 ON LINE 143
	sort = 0;

000321  aa  6 00135 4501 00	stz  	pr6|93		sort
						STATEMENT 1 ON LINE 147
	call cu_$arg_ptr (1, argp, arglen, code);

000322  aa   000001 2360 07	ldq  	1,dl
000323  aa  6 04226 7561 00	stq  	pr6|2198
000324  aa  6 04226 3521 00	epp2 	pr6|2198
000325  aa  6 04232 2521 00	spri2	pr6|2202
000326  aa  6 00112 3521 00	epp2 	pr6|74		argp
000327  aa  6 04234 2521 00	spri2	pr6|2204
000330  aa  6 00114 3521 00	epp2 	pr6|76		arglen
000331  aa  6 04236 2521 00	spri2	pr6|2206
000332  aa  6 00111 3521 00	epp2 	pr6|73		code
000333  aa  6 04240 2521 00	spri2	pr6|2208
000334  aa  6 04230 6211 00	eax1 	pr6|2200
000335  aa   020000 4310 07	fld  	8192,dl
000336  la  4 00026 3521 20	epp2 	pr4|22,*		cu_$arg_ptr
000337  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 148
	if code ^= 0
	then do;

000340  aa  6 00111 2361 00	ldq  	pr6|73		code
000341  aa   000027 6000 04	tze  	23,ic		000370
						STATEMENT 1 ON LINE 150
		call com_err_ (code, who_it_is, "Gate name");

000342  aa   777520 2370 04	ldaq 	-176,ic		000062 = 107141164145 040156141155
000343  aa  6 04230 7571 00	staq 	pr6|2200
000344  aa   145000 2350 03	lda  	51712,du
000345  aa  6 04232 7551 00	sta  	pr6|2202
000346  aa  6 00111 3521 00	epp2 	pr6|73		code
000347  aa  6 04244 2521 00	spri2	pr6|2212
000350  aa   777430 3520 04	epp2 	-232,ic		000000 = 155145164145
000351  aa  6 04246 2521 00	spri2	pr6|2214
000352  aa  6 04230 3521 00	epp2 	pr6|2200
000353  aa  6 04250 2521 00	spri2	pr6|2216
000354  aa   777463 3520 04	epp2 	-205,ic		000037 = 404000000043
000355  aa  6 04252 2521 00	spri2	pr6|2218
000356  aa   777460 3520 04	epp2 	-208,ic		000036 = 526000000012
000357  aa  6 04254 2521 00	spri2	pr6|2220
000360  aa   777455 3520 04	epp2 	-211,ic		000035 = 524000000011
000361  aa  6 04256 2521 00	spri2	pr6|2222
000362  aa  6 04242 6211 00	eax1 	pr6|2210
000363  aa   014000 4310 07	fld  	6144,dl
000364  aa  6 00044 3701 20	epp4 	pr6|36,*
000365  la  4 00024 3521 20	epp2 	pr4|20,*		com_err_
000366  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 151
		return;

000367  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 152
	     end;

						STATEMENT 1 ON LINE 155
	segname = argument;

000370  aa  6 00112 3735 20	epp7 	pr6|74,*		argp
000371  aa  6 00114 7271 00	lxl7 	pr6|76		arglen
000372  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000373  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000374  aa  6 00115 00 0040	desc9a	pr6|77,32		segname
						STATEMENT 1 ON LINE 156
	no_report = "0"b;

000375  aa  6 00104 4501 00	stz  	pr6|68		no_report
						STATEMENT 1 ON LINE 157
	reset_sw = "0"b;

000376  aa  6 00103 4501 00	stz  	pr6|67		reset_sw
						STATEMENT 1 ON LINE 159
	do argno = 2 to cu_$arg_count ();

000377  aa  6 04226 3521 00	epp2 	pr6|2198
000400  aa  6 04232 2521 00	spri2	pr6|2202
000401  aa  6 04230 6211 00	eax1 	pr6|2200
000402  aa   004000 4310 07	fld  	2048,dl
000403  aa  6 00044 3701 20	epp4 	pr6|36,*
000404  la  4 00042 3521 20	epp2 	pr4|34,*		cu_$arg_count
000405  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000406  aa   000002 2360 07	ldq  	2,dl
000407  aa  6 00100 7561 00	stq  	pr6|64		argno
000410  aa  6 00100 2361 00	ldq  	pr6|64		argno
000411  aa  6 04226 1161 00	cmpq 	pr6|2198
000412  aa   000132 6054 04	tpnz 	90,ic		000544
						STATEMENT 1 ON LINE 160
	     call cu_$arg_ptr (argno, argp, arglen, code);

000413  aa  6 00100 3521 00	epp2 	pr6|64		argno
000414  aa  6 04232 2521 00	spri2	pr6|2202
000415  aa  6 00112 3521 00	epp2 	pr6|74		argp
000416  aa  6 04234 2521 00	spri2	pr6|2204
000417  aa  6 00114 3521 00	epp2 	pr6|76		arglen
000420  aa  6 04236 2521 00	spri2	pr6|2206
000421  aa  6 00111 3521 00	epp2 	pr6|73		code
000422  aa  6 04240 2521 00	spri2	pr6|2208
000423  aa  6 04230 6211 00	eax1 	pr6|2200
000424  aa   020000 4310 07	fld  	8192,dl
000425  aa  6 00044 3701 20	epp4 	pr6|36,*
000426  la  4 00026 3521 20	epp2 	pr4|22,*		cu_$arg_ptr
000427  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 161
	     if argument = "-call" | argument = "-cl"
	     then sort = 1;

000430  aa  6 00112 3735 20	epp7 	pr6|74,*		argp
000431  aa  6 00114 7271 00	lxl7 	pr6|76		arglen
000432  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000433  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000434  aa   777426 00 0005	desc9a	-234,5		000060 = 055143141154
000435  aa   000005 6000 04	tze  	5,ic		000442
000436  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000437  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000440  aa   777376 00 0003	desc9a	-258,3		000034 = 055143154000
000441  aa   000004 6010 04	tnz  	4,ic		000445
000442  aa   000001 2360 07	ldq  	1,dl
000443  aa  6 00135 7561 00	stq  	pr6|93		sort
000444  aa   000076 7100 04	tra  	62,ic		000542
						STATEMENT 1 ON LINE 163
	     else if argument = "-time" | argument = "-tm"
	     then sort = 2;

000445  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000446  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000447  aa   777411 00 0005	desc9a	-247,5		000056 = 055164151155
000450  aa   000005 6000 04	tze  	5,ic		000455
000451  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000452  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000453  aa   777362 00 0003	desc9a	-270,3		000033 = 055164155000
000454  aa   000004 6010 04	tnz  	4,ic		000460
000455  aa   000002 2360 07	ldq  	2,dl
000456  aa  6 00135 7561 00	stq  	pr6|93		sort
000457  aa   000063 7100 04	tra  	51,ic		000542
						STATEMENT 1 ON LINE 165
	     else if argument = "-average" | argument = "-av"
	     then sort = 3;

000460  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000461  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000462  aa   777374 00 0010	desc9a	-260,8		000054 = 055141166145
000463  aa   000005 6000 04	tze  	5,ic		000470
000464  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000465  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000466  aa   777346 00 0003	desc9a	-282,3		000032 = 055141166000
000467  aa   000004 6010 04	tnz  	4,ic		000473
000470  aa   000003 2360 07	ldq  	3,dl
000471  aa  6 00135 7561 00	stq  	pr6|93		sort
000472  aa   000050 7100 04	tra  	40,ic		000542
						STATEMENT 1 ON LINE 167
	     else if argument = "-page" | argument = "-pg"
	     then sort = 4;

000473  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000474  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000475  aa   777357 00 0005	desc9a	-273,5		000052 = 055160141147
000476  aa   000005 6000 04	tze  	5,ic		000503
000477  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000500  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000501  aa   777332 00 0003	desc9a	-294,3		000031 = 055160147000
000502  aa   000004 6010 04	tnz  	4,ic		000506
000503  aa   000004 2360 07	ldq  	4,dl
000504  aa  6 00135 7561 00	stq  	pr6|93		sort
000505  aa   000035 7100 04	tra  	29,ic		000542
						STATEMENT 1 ON LINE 169
	     else if argument = "-reset" | argument = "-rs"
	     then no_report, reset_sw = "1"b;

000506  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000507  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000510  aa   777342 00 0006	desc9a	-286,6		000050 = 055162145163
000511  aa   000005 6000 04	tze  	5,ic		000516
000512  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000513  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000514  aa   777316 00 0003	desc9a	-306,3		000030 = 055162163000
000515  aa   000005 6010 04	tnz  	5,ic		000522
000516  aa   400000 2350 03	lda  	131072,du
000517  aa  6 00104 7551 00	sta  	pr6|68		no_report
000520  aa  6 00103 7551 00	sta  	pr6|67		reset_sw
000521  aa   000021 7100 04	tra  	17,ic		000542
						STATEMENT 1 ON LINE 171
	     else if argument = "-report_reset" | argument = "-rr"
	     then reset_sw = "1"b;

000522  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000523  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000524  aa   777347 00 0015	desc9a	-281,13		000071 = 055162145160
000525  aa   000005 6000 04	tze  	5,ic		000532
000526  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000527  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000530  aa   777301 00 0003	desc9a	-319,3		000027 = 055162162000
000531  aa   000004 6010 04	tnz  	4,ic		000535
000532  aa   400000 2350 03	lda  	131072,du
000533  aa  6 00103 7551 00	sta  	pr6|67		reset_sw
000534  aa   000006 7100 04	tra  	6,ic		000542
						STATEMENT 1 ON LINE 173
	     else do;

						STATEMENT 1 ON LINE 174
		     entry = argument;

000535  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000536  aa  7 00000 00 0017	desc9a	pr7|0,x7		argument
000537  aa  6 00125 00 0040	desc9a	pr6|85,32		entry
						STATEMENT 1 ON LINE 175
		     sort = 5;

000540  aa   000005 2360 07	ldq  	5,dl
000541  aa  6 00135 7561 00	stq  	pr6|93		sort
						STATEMENT 1 ON LINE 176
		end;

						STATEMENT 1 ON LINE 177
	end;

000542  aa  6 00100 0541 00	aos  	pr6|64		argno
000543  aa   777645 7100 04	tra  	-91,ic		000410
						STATEMENT 1 ON LINE 182
	if tcdp0 = null
	then do;

000544  aa  6 00044 3701 20	epp4 	pr6|36,*
000545  ia  4 00010 2371 00	ldaq 	pr4|8		tcdp0
000546  aa   777300 6770 04	eraq 	-320,ic		000046 = 077777000043 000001000000
000547  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000550  aa   000142 6010 04	tnz  	98,ic		000712
						STATEMENT 1 ON LINE 184
		call ring0_get_$segptr ("", "tc_data", tcdp0, code);

000551  aa   777273 2370 04	ldaq 	-325,ic		000044 = 164143137144 141164141000
000552  aa  6 04260 7571 00	staq 	pr6|2224
000553  aa  6 04227 3521 00	epp2 	pr6|2199
000554  aa  6 04264 2521 00	spri2	pr6|2228
000555  aa  6 04260 3521 00	epp2 	pr6|2224
000556  aa  6 04266 2521 00	spri2	pr6|2230
000557  ia  4 00010 3521 00	epp2 	pr4|8		tcdp0
000560  aa  6 04270 2521 00	spri2	pr6|2232
000561  aa  6 00111 3521 00	epp2 	pr6|73		code
000562  aa  6 04272 2521 00	spri2	pr6|2234
000563  aa   777243 3520 04	epp2 	-349,ic		000026 = 524000000000
000564  aa  6 04274 2521 00	spri2	pr6|2236
000565  aa   777240 3520 04	epp2 	-352,ic		000025 = 524000000007
000566  aa  6 04276 2521 00	spri2	pr6|2238
000567  aa   777235 3520 04	epp2 	-355,ic		000024 = 464000000000
000570  aa  6 04300 2521 00	spri2	pr6|2240
000571  aa   777246 3520 04	epp2 	-346,ic		000037 = 404000000043
000572  aa  6 04302 2521 00	spri2	pr6|2242
000573  aa  6 04262 6211 00	eax1 	pr6|2226
000574  aa   020000 4310 07	fld  	8192,dl
000575  la  4 00032 3521 20	epp2 	pr4|26,*		ring0_get_$segptr
000576  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 185
		if code ^= 0
		then do;

000577  aa  6 00111 2361 00	ldq  	pr6|73		code
000600  aa   000026 6000 04	tze  	22,ic		000626
						STATEMENT 1 ON LINE 187
			call com_err_ (code, who_it_is, "Cannot find tc_data");

000601  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000602  aa   777306 00 0024	desc9a	-314,20		000107 = 103141156156
000603  aa  6 04230 00 0024	desc9a	pr6|2200,20
000604  aa  6 00111 3521 00	epp2 	pr6|73		code
000605  aa  6 04244 2521 00	spri2	pr6|2212
000606  aa   777172 3520 04	epp2 	-390,ic		000000 = 155145164145
000607  aa  6 04246 2521 00	spri2	pr6|2214
000610  aa  6 04230 3521 00	epp2 	pr6|2200
000611  aa  6 04250 2521 00	spri2	pr6|2216
000612  aa   777225 3520 04	epp2 	-363,ic		000037 = 404000000043
000613  aa  6 04252 2521 00	spri2	pr6|2218
000614  aa   777222 3520 04	epp2 	-366,ic		000036 = 526000000012
000615  aa  6 04254 2521 00	spri2	pr6|2220
000616  aa   777205 3520 04	epp2 	-379,ic		000023 = 524000000023
000617  aa  6 04256 2521 00	spri2	pr6|2222
000620  aa  6 04242 6211 00	eax1 	pr6|2210
000621  aa   014000 4310 07	fld  	6144,dl
000622  aa  6 00044 3701 20	epp4 	pr6|36,*
000623  la  4 00024 3521 20	epp2 	pr4|20,*		com_err_
000624  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 188
			return;

000625  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 189
		     end;

						STATEMENT 1 ON LINE 190
		itimep0 = addr (tcdp0 -> tcm.initialize_time);

000626  aa  6 00044 3701 20	epp4 	pr6|36,*
000627  ia  4 00010 3735 20	epp7 	pr4|8,*		tcdp0
000630  aa  7 00336 3735 00	epp7 	pr7|222		tcm.initialize_time
000631  ia  4 00016 6535 00	spri7	pr4|14		itimep0
						STATEMENT 1 ON LINE 191
		ptimep0 = addr (tcdp0 -> tcm.processor_time);

000632  ia  4 00010 3715 20	epp5 	pr4|8,*		tcdp0
000633  aa  5 00042 3715 00	epp5 	pr5|34		tcm.processor_time
000634  ia  4 00020 6515 00	spri5	pr4|16		ptimep0
						STATEMENT 1 ON LINE 192
		ltimep0 = addr (tcdp0 -> tcm.idle);

000635  ia  4 00010 3735 20	epp7 	pr4|8,*		tcdp0
000636  aa  7 00024 3735 00	epp7 	pr7|20		tcm.idle
000637  ia  4 00022 6535 00	spri7	pr4|18		ltimep0
						STATEMENT 1 ON LINE 193
		call get_temp_segments_ (who_it_is, tempp, code);

000640  aa   777140 3520 04	epp2 	-416,ic		000000 = 155145164145
000641  aa  6 04244 2521 00	spri2	pr6|2212
000642  ia  4 00012 3521 00	epp2 	pr4|10		tempp
000643  aa  6 04246 2521 00	spri2	pr6|2214
000644  aa  6 00111 3521 00	epp2 	pr6|73		code
000645  aa  6 04250 2521 00	spri2	pr6|2216
000646  aa   777170 3520 04	epp2 	-392,ic		000036 = 526000000012
000647  aa  6 04252 2521 00	spri2	pr6|2218
000650  aa   777215 3520 04	epp2 	-371,ic		000065 = 464100000000
000651  aa  6 04254 2521 00	spri2	pr6|2220
000652  aa   777165 3520 04	epp2 	-395,ic		000037 = 404000000043
000653  aa  6 04256 2521 00	spri2	pr6|2222
000654  aa  6 04242 6211 00	eax1 	pr6|2210
000655  aa   014000 4310 07	fld  	6144,dl
000656  la  4 00046 3521 20	epp2 	pr4|38,*		get_temp_segments_
000657  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 194
		if code ^= 0
		then do;

000660  aa  6 00111 2361 00	ldq  	pr6|73		code
000661  aa   000031 6000 04	tze  	25,ic		000712
						STATEMENT 1 ON LINE 196
			call com_err_ (code, who_it_is, "Getting temp segs");

000662  aa   777220 2370 04	ldaq 	-368,ic		000102 = 107145164164 151156147040
000663  aa  6 04230 7571 00	staq 	pr6|2200
000664  aa   777220 2370 04	ldaq 	-368,ic		000104 = 164145155160 040163145147
000665  aa  6 04232 7571 00	staq 	pr6|2202
000666  aa   163000 2350 03	lda  	58880,du
000667  aa  6 04234 7551 00	sta  	pr6|2204
000670  aa  6 00111 3521 00	epp2 	pr6|73		code
000671  aa  6 04244 2521 00	spri2	pr6|2212
000672  aa   777106 3520 04	epp2 	-442,ic		000000 = 155145164145
000673  aa  6 04246 2521 00	spri2	pr6|2214
000674  aa  6 04230 3521 00	epp2 	pr6|2200
000675  aa  6 04250 2521 00	spri2	pr6|2216
000676  aa   777141 3520 04	epp2 	-415,ic		000037 = 404000000043
000677  aa  6 04252 2521 00	spri2	pr6|2218
000700  aa   777136 3520 04	epp2 	-418,ic		000036 = 526000000012
000701  aa  6 04254 2521 00	spri2	pr6|2220
000702  aa   777120 3520 04	epp2 	-432,ic		000022 = 524000000021
000703  aa  6 04256 2521 00	spri2	pr6|2222
000704  aa  6 04242 6211 00	eax1 	pr6|2210
000705  aa   014000 4310 07	fld  	6144,dl
000706  aa  6 00044 3701 20	epp4 	pr6|36,*
000707  la  4 00024 3521 20	epp2 	pr4|20,*		com_err_
000710  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 197
			return;

000711  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 198
		     end;

						STATEMENT 1 ON LINE 199
	     end;

						STATEMENT 1 ON LINE 203
	do gi = 1 to max_gates;

000712  aa  6 00044 3701 20	epp4 	pr6|36,*
000713  ia  4 00014 2361 20	ldq  	pr4|12,*		gate_info_struct.max_gates
000714  aa  6 04210 7561 00	stq  	pr6|2184
000715  aa   000001 2360 07	ldq  	1,dl
000716  aa  6 00101 7561 00	stq  	pr6|65		gi
000717  aa   000000 0110 03	nop  	0,du
000720  aa  6 00101 2361 00	ldq  	pr6|65		gi
000721  aa  6 04210 1161 00	cmpq 	pr6|2184
000722  aa   000013 6054 04	tpnz 	11,ic		000735
						STATEMENT 1 ON LINE 204
	     if gate_info (gi).name = segname
	     then go to got_gate;

000723  aa   000014 4020 07	mpy  	12,dl
000724  aa  6 00044 3701 20	epp4 	pr6|36,*
000725  ia  4 00014 3735 20	epp7 	pr4|12,*		tempp
000726  aa  7 77766 3735 06	epp7 	pr7|-10,ql	gate_info_struct.name
000727  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
000730  aa  7 00000 00 0040	desc9a	pr7|0,32		gate_info_struct.name
000731  aa  6 00115 00 0040	desc9a	pr6|77,32		segname
000732  aa   000017 6000 04	tze  	15,ic		000751
						STATEMENT 1 ON LINE 206
	end;

000733  aa  6 00101 0541 00	aos  	pr6|65		gi
000734  aa   777764 7100 04	tra  	-12,ic		000720
						STATEMENT 1 ON LINE 208
	max_gates = gi;

000735  aa  6 00044 3701 20	epp4 	pr6|36,*
000736  ia  4 00014 7561 20	stq  	pr4|12,*		gate_info_struct.max_gates
						STATEMENT 1 ON LINE 209
	gate_info (gi).name = segname;

000737  aa   000014 4020 07	mpy  	12,dl
000740  ia  4 00014 3735 20	epp7 	pr4|12,*		tempp
000741  aa  7 77766 3715 06	epp5 	pr7|-10,ql	gate_info_struct.name
000742  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000743  aa  6 00115 00 0040	desc9a	pr6|77,32		segname
000744  aa  5 00000 00 0040	desc9a	pr5|0,32		gate_info_struct.name
						STATEMENT 1 ON LINE 210
	gate_info (gi).old_time = 0;

000745  aa   000000 6270 06	eax7 	0,ql
000746  aa   777074 2370 04	ldaq 	-452,ic		000042 = 000000000000 000000000000
000747  aa  7 77776 7571 17	staq 	pr7|-2,7		gate_info_struct.old_time
						STATEMENT 1 ON LINE 211
	gate_info (gi).old_charged = 0;

000750  aa  7 00000 7571 17	staq 	pr7|0,7		gate_info_struct.old_charged
						STATEMENT 1 ON LINE 212
got_gate:						/* Now get data for gate. */
	call get_gate_data_ (segname, table.gate, nentries, tempp (1), reset_sw, code);

000751  aa  6 00115 3521 00	epp2 	pr6|77		segname
000752  aa  6 04306 2521 00	spri2	pr6|2246
000753  aa  6 00202 3521 00	epp2 	pr6|130		table.gate
000754  aa  6 04310 2521 00	spri2	pr6|2248
000755  aa  6 00140 3521 00	epp2 	pr6|96		nentries
000756  aa  6 04312 2521 00	spri2	pr6|2250
000757  ia  4 00012 3521 00	epp2 	pr4|10		tempp
000760  aa  6 04314 2521 00	spri2	pr6|2252
000761  aa  6 00103 3521 00	epp2 	pr6|67		reset_sw
000762  aa  6 04316 2521 00	spri2	pr6|2254
000763  aa  6 00111 3521 00	epp2 	pr6|73		code
000764  aa  6 04320 2521 00	spri2	pr6|2256
000765  aa   777034 3520 04	epp2 	-484,ic		000021 = 526000000040
000766  aa  6 04322 2521 00	spri2	pr6|2258
000767  aa   777231 3520 04	epp2 	-359,ic		000220 = 504100000003
000770  aa  6 04324 2521 00	spri2	pr6|2260
000771  aa   777047 3520 04	epp2 	-473,ic		000040 = 404000000021
000772  aa  6 04326 2521 00	spri2	pr6|2262
000773  aa   777031 3520 04	epp2 	-487,ic		000024 = 464000000000
000774  aa  6 04330 2521 00	spri2	pr6|2264
000775  aa   777023 3520 04	epp2 	-493,ic		000020 = 514000000001
000776  aa  6 04332 2521 00	spri2	pr6|2266
000777  aa   777040 3520 04	epp2 	-480,ic		000037 = 404000000043
001000  aa  6 04334 2521 00	spri2	pr6|2268
001001  aa  6 04304 6211 00	eax1 	pr6|2244
001002  aa   030000 4310 07	fld  	12288,dl
001003  la  4 00044 3521 20	epp2 	pr4|36,*		get_gate_data_
001004  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 214
	if code ^= 0
	then do;

001005  aa  6 00111 2361 00	ldq  	pr6|73		code
001006  aa   000026 6000 04	tze  	22,ic		001034
						STATEMENT 1 ON LINE 216
		call com_err_ (code, who_it_is, "Getting gate data");

001007  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001010  aa   777066 00 0024	desc9a	-458,20		000075 = 107145164164
001011  aa  6 04230 00 0024	desc9a	pr6|2200,20
001012  aa  6 00111 3521 00	epp2 	pr6|73		code
001013  aa  6 04244 2521 00	spri2	pr6|2212
001014  aa   776764 3520 04	epp2 	-524,ic		000000 = 155145164145
001015  aa  6 04246 2521 00	spri2	pr6|2214
001016  aa  6 04230 3521 00	epp2 	pr6|2200
001017  aa  6 04250 2521 00	spri2	pr6|2216
001020  aa   777017 3520 04	epp2 	-497,ic		000037 = 404000000043
001021  aa  6 04252 2521 00	spri2	pr6|2218
001022  aa   777014 3520 04	epp2 	-500,ic		000036 = 526000000012
001023  aa  6 04254 2521 00	spri2	pr6|2220
001024  aa   776776 3520 04	epp2 	-514,ic		000022 = 524000000021
001025  aa  6 04256 2521 00	spri2	pr6|2222
001026  aa  6 04242 6211 00	eax1 	pr6|2210
001027  aa   014000 4310 07	fld  	6144,dl
001030  aa  6 00044 3701 20	epp4 	pr6|36,*
001031  la  4 00024 3521 20	epp2 	pr4|20,*		com_err_
001032  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 217
		return;

001033  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 218
	     end;

						STATEMENT 1 ON LINE 223
	call ring_zero_peek_ (itimep0, addr (itime), 2, code);

001034  aa  6 00144 3735 00	epp7 	pr6|100		itime
001035  aa  6 04260 6535 00	spri7	pr6|2224
001036  aa   000002 2360 07	ldq  	2,dl
001037  aa  6 04227 7561 00	stq  	pr6|2199
001040  aa  6 00044 3701 20	epp4 	pr6|36,*
001041  ia  4 00016 3521 00	epp2 	pr4|14		itimep0
001042  aa  6 04232 2521 00	spri2	pr6|2202
001043  aa  6 04260 3521 00	epp2 	pr6|2224
001044  aa  6 04234 2521 00	spri2	pr6|2204
001045  aa  6 04227 3521 00	epp2 	pr6|2199
001046  aa  6 04236 2521 00	spri2	pr6|2206
001047  aa  6 00111 3521 00	epp2 	pr6|73		code
001050  aa  6 04240 2521 00	spri2	pr6|2208
001051  aa  6 04230 6211 00	eax1 	pr6|2200
001052  aa   020000 4310 07	fld  	8192,dl
001053  la  4 00030 3521 20	epp2 	pr4|24,*		ring_zero_peek_
001054  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 224
	call ring_zero_peek_ (ptimep0, addr (charged_time), 2, code);

001055  aa  6 00172 3735 00	epp7 	pr6|122		charged_time
001056  aa  6 04260 6535 00	spri7	pr6|2224
001057  aa   000002 2360 07	ldq  	2,dl
001060  aa  6 04227 7561 00	stq  	pr6|2199
001061  aa  6 00044 3701 20	epp4 	pr6|36,*
001062  ia  4 00020 3521 00	epp2 	pr4|16		ptimep0
001063  aa  6 04232 2521 00	spri2	pr6|2202
001064  aa  6 04260 3521 00	epp2 	pr6|2224
001065  aa  6 04234 2521 00	spri2	pr6|2204
001066  aa  6 04227 3521 00	epp2 	pr6|2199
001067  aa  6 04236 2521 00	spri2	pr6|2206
001070  aa  6 00111 3521 00	epp2 	pr6|73		code
001071  aa  6 04240 2521 00	spri2	pr6|2208
001072  aa  6 04230 6211 00	eax1 	pr6|2200
001073  aa   020000 4310 07	fld  	8192,dl
001074  la  4 00030 3521 20	epp2 	pr4|24,*		ring_zero_peek_
001075  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 225
	call ring_zero_peek_ (ltimep0, addr (idle_time), 2, code);

001076  aa  6 00174 3735 00	epp7 	pr6|124		idle_time
001077  aa  6 04260 6535 00	spri7	pr6|2224
001100  aa   000002 2360 07	ldq  	2,dl
001101  aa  6 04227 7561 00	stq  	pr6|2199
001102  aa  6 00044 3701 20	epp4 	pr6|36,*
001103  ia  4 00022 3521 00	epp2 	pr4|18		ltimep0
001104  aa  6 04232 2521 00	spri2	pr6|2202
001105  aa  6 04260 3521 00	epp2 	pr6|2224
001106  aa  6 04234 2521 00	spri2	pr6|2204
001107  aa  6 04227 3521 00	epp2 	pr6|2199
001110  aa  6 04236 2521 00	spri2	pr6|2206
001111  aa  6 00111 3521 00	epp2 	pr6|73		code
001112  aa  6 04240 2521 00	spri2	pr6|2208
001113  aa  6 04230 6211 00	eax1 	pr6|2200
001114  aa   020000 4310 07	fld  	8192,dl
001115  la  4 00030 3521 20	epp2 	pr4|24,*		ring_zero_peek_
001116  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 227
	charged_time = charged_time - idle_time;

001117  aa  6 00172 2371 00	ldaq 	pr6|122		charged_time
001120  aa  6 00174 1771 00	sbaq 	pr6|124		idle_time
001121  aa  6 00172 7571 00	staq 	pr6|122		charged_time
						STATEMENT 1 ON LINE 228
	if gate_info (gi).old_time > 0
	then itime = gate_info (gi).old_time;

001122  aa  6 00101 2361 00	ldq  	pr6|65		gi
001123  aa   000014 4020 07	mpy  	12,dl
001124  aa  6 00044 3701 20	epp4 	pr6|36,*
001125  ia  4 00014 3735 20	epp7 	pr4|12,*		tempp
001126  aa  6 04227 7561 00	stq  	pr6|2199
001127  aa  7 77776 2371 06	ldaq 	pr7|-2,ql		gate_info_struct.old_time
001130  aa   000002 6044 04	tmoz 	2,ic		001132
001131  aa  6 00144 7571 00	staq 	pr6|100		itime
						STATEMENT 1 ON LINE 230
	ctime = charged_time - gate_info (gi).old_charged;

001132  aa  6 00172 2371 00	ldaq 	pr6|122		charged_time
001133  aa  6 04227 7271 00	lxl7 	pr6|2199
001134  aa  7 00000 1771 17	sbaq 	pr7|0,7		gate_info_struct.old_charged
001135  aa  6 00176 7571 00	staq 	pr6|126		ctime
						STATEMENT 1 ON LINE 232
	timnow = clock_ ();

001136  aa  6 00146 3521 00	epp2 	pr6|102		timnow
001137  aa  6 04232 2521 00	spri2	pr6|2202
001140  aa  6 04230 6211 00	eax1 	pr6|2200
001141  aa   004000 4310 07	fld  	2048,dl
001142  la  4 00036 3521 20	epp2 	pr4|30,*		clock_
001143  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 234
	if ^no_report
	then do;

001144  aa  6 00104 2351 00	lda  	pr6|68		no_report
001145  aa   000520 6010 04	tnz  	336,ic		001665
						STATEMENT 1 ON LINE 236
		i = 0;

001146  aa  6 00136 4501 00	stz  	pr6|94		i
						STATEMENT 1 ON LINE 237
		tottim = 0;

001147  aa   776673 2370 04	ldaq 	-581,ic		000042 = 000000000000 000000000000
001150  aa  6 00164 7571 00	staq 	pr6|116		tottim
						STATEMENT 1 ON LINE 238
		totcalls = 0;

001151  aa  6 00142 4501 00	stz  	pr6|98		totcalls
						STATEMENT 1 ON LINE 239
		total_ring_alarms = 0;

001152  aa  6 00166 4501 00	stz  	pr6|118		total_ring_alarms
						STATEMENT 1 ON LINE 244
		do i = 1 to nentries;

001153  aa  6 00140 2361 00	ldq  	pr6|96		nentries
001154  aa  6 04211 7561 00	stq  	pr6|2185
001155  aa   000001 2360 07	ldq  	1,dl
001156  aa  6 00136 7561 00	stq  	pr6|94		i
001157  aa   000000 0110 03	nop  	0,du
001160  aa  6 00136 2361 00	ldq  	pr6|94		i
001161  aa  6 04211 1161 00	cmpq 	pr6|2185
001162  aa   000166 6054 04	tpnz 	118,ic		001350
						STATEMENT 1 ON LINE 245
		     gate_datap = table (i).datap;

001163  aa   000002 7360 00	qls  	2
001164  aa  6 00200 7671 06	lprp7	pr6|128,ql	table.datap
001165  aa  6 04206 6535 00	spri7	pr6|2182		gate_datap
						STATEMENT 1 ON LINE 246
		     namep = table (i).entryp;

001166  aa  6 00176 7651 06	lprp5	pr6|126,ql	table.entryp
001167  aa  6 00106 6515 00	spri5	pr6|70		namep
						STATEMENT 1 ON LINE 247
		     namel = table (i).entryl;

001170  aa  6 04227 7561 00	stq  	pr6|2199
001171  aa  6 00177 2361 06	ldq  	pr6|127,ql	table.entryl
001172  aa  6 00110 7561 00	stq  	pr6|72		namel
						STATEMENT 1 ON LINE 249
		     calls = gate_entry_data.calls;

001173  aa  7 00005 2361 00	ldq  	pr7|5		gate_entry_data.calls
001174  aa  6 00141 7561 00	stq  	pr6|97		calls
						STATEMENT 1 ON LINE 250
		     if calls ^= 0
		     then /* Compute average and save. */
			avg = float (gate_entry_data.vcpu_time, 27) / (1.e3 * float (gate_entry_data.calls, 27));

001175  aa   000012 6000 04	tze  	10,ic		001207
001176  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
001177  aa   024764 4610 03	fmp  	10740,du
001200  aa  6 04336 4551 00	fst  	pr6|2270
001201  aa  7 00002 2371 00	ldaq 	pr7|2		gate_entry_data.vcpu_time
001202  aa   216000 4110 03	lde  	72704,du
001203  aa   400000 4750 03	fad  	131072,du
001204  aa  6 04336 5651 00	fdv  	pr6|2270
001205  aa  6 00102 4551 00	fst  	pr6|66		avg
001206  aa   000003 7100 04	tra  	3,ic		001211
						STATEMENT 1 ON LINE 253
		     else avg = 0.e0;

001207  aa   400000 4310 03	fld  	131072,du
001210  aa  6 00102 4551 00	fst  	pr6|66		avg
						STATEMENT 1 ON LINE 254
		     table (i).avg = avg;

001211  aa  6 04227 7271 00	lxl7 	pr6|2199
001212  aa  6 00201 4551 17	fst  	pr6|129,7		table.avg
						STATEMENT 1 ON LINE 256
		     if sort = 5
		     then do;

001213  aa  6 00135 2361 00	ldq  	pr6|93		sort
001214  aa   000005 1160 07	cmpq 	5,dl
001215  aa   000012 6010 04	tnz  	10,ic		001227
						STATEMENT 1 ON LINE 258
			     if entryname = entry
			     then do;

001216  aa  6 00110 7261 00	lxl6 	pr6|72		namel
001217  aa  040 100 106 540	cmpc 	(pr,rl),(pr),fill(040)
001220  aa  5 00000 00 0016	desc9a	pr5|0,x6		entryname
001221  aa  6 00125 00 0040	desc9a	pr6|85,32		entry
001222  aa   000124 6010 04	tnz  	84,ic		001346
						STATEMENT 1 ON LINE 260
				     j = i;

001223  aa  6 00136 2361 00	ldq  	pr6|94		i
001224  aa  6 00137 7561 00	stq  	pr6|95		j
						STATEMENT 1 ON LINE 261
				     call print;

001225  aa   000455 6700 04	tsp4 	301,ic		001702
						STATEMENT 1 ON LINE 262
				     go to finish;

001226  aa   000437 7100 04	tra  	287,ic		001665
						STATEMENT 1 ON LINE 263
				end;

						STATEMENT 1 ON LINE 265
			end;

						STATEMENT 1 ON LINE 267
		     totcalls = totcalls + calls;

001227  aa  6 00141 2361 00	ldq  	pr6|97		calls
001230  aa  6 00142 0561 00	asq  	pr6|98		totcalls
						STATEMENT 1 ON LINE 268
		     tottim = tottim + gate_entry_data.vcpu_time;

001231  aa  6 00164 2371 00	ldaq 	pr6|116		tottim
001232  aa  7 00002 0771 00	adaq 	pr7|2		gate_entry_data.vcpu_time
001233  aa  6 00164 7571 00	staq 	pr6|116		tottim
						STATEMENT 1 ON LINE 270
		     total_ring_alarms = total_ring_alarms + gate_entry_data.ring_alarms;

001234  aa  6 00166 2351 00	lda  	pr6|118		total_ring_alarms
001235  aa   000044 7330 00	lrs  	36
001236  aa  7 00006 0331 00	adl  	pr7|6		gate_entry_data.ring_alarms
001237  aa  6 00166 7561 00	stq  	pr6|118		total_ring_alarms
						STATEMENT 1 ON LINE 274
		     if sort ^= 0
		     then do j = i - 1 to 1 by -1;

001240  aa  6 00135 2361 00	ldq  	pr6|93		sort
001241  aa   000105 6000 04	tze  	69,ic		001346
001242  aa  6 00136 2361 00	ldq  	pr6|94		i
001243  aa   000001 1760 07	sbq  	1,dl
001244  aa  6 00137 7561 00	stq  	pr6|95		j
001245  aa   000000 0110 03	nop  	0,du
001246  aa  6 00137 2361 00	ldq  	pr6|95		j
001247  aa   000001 1160 07	cmpq 	1,dl
001250  aa   000076 6040 04	tmi  	62,ic		001346
						STATEMENT 1 ON LINE 277
			     if sort = 1
			     then /* If sorting on number of calls ... */
				if table (j).datap -> gate_entry_data.calls < gate_entry_data.calls
				then go to next;

001251  aa  6 00135 2361 00	ldq  	pr6|93		sort
001252  aa   000001 1160 07	cmpq 	1,dl
001253  aa   000011 6010 04	tnz  	9,ic		001264
001254  aa  6 00137 2361 00	ldq  	pr6|95		j
001255  aa   000002 7360 00	qls  	2
001256  aa  6 00200 7671 06	lprp7	pr6|128,ql	table.datap
001257  aa  7 00005 2361 00	ldq  	pr7|5		gate_entry_data.calls
001260  aa  6 04206 3715 20	epp5 	pr6|2182,*	gate_datap
001261  aa  5 00005 1161 00	cmpq 	pr5|5		gate_entry_data.calls
001262  aa   000064 6040 04	tmi  	52,ic		001346
						STATEMENT 1 ON LINE 281
				else ;

001263  aa   000034 7100 04	tra  	28,ic		001317
						STATEMENT 1 ON LINE 283
			     else if sort = 2
			     then /* If sorting on total time ... */
				if table (j).datap -> gate_entry_data.vcpu_time < gate_entry_data.vcpu_time
				then go to next;

001264  aa   000002 1160 07	cmpq 	2,dl
001265  aa   000011 6010 04	tnz  	9,ic		001276
001266  aa  6 00137 2361 00	ldq  	pr6|95		j
001267  aa   000002 7360 00	qls  	2
001270  aa  6 00200 7671 06	lprp7	pr6|128,ql	table.datap
001271  aa  7 00002 2371 00	ldaq 	pr7|2		gate_entry_data.vcpu_time
001272  aa  6 04206 3715 20	epp5 	pr6|2182,*	gate_datap
001273  aa  5 00002 1171 00	cmpaq	pr5|2		gate_entry_data.vcpu_time
001274  aa   000052 6040 04	tmi  	42,ic		001346
						STATEMENT 1 ON LINE 287
				else ;

001275  aa   000022 7100 04	tra  	18,ic		001317
						STATEMENT 1 ON LINE 289
			     else if sort = 3
			     then /* If sorting on average time ... */
				if table (j).avg < avg
				then go to next;

001276  aa   000003 1160 07	cmpq 	3,dl
001277  aa   000007 6010 04	tnz  	7,ic		001306
001300  aa  6 00137 2361 00	ldq  	pr6|95		j
001301  aa   000002 7360 00	qls  	2
001302  aa  6 00201 4311 06	fld  	pr6|129,ql	table.avg
001303  aa  6 00102 5151 00	fcmp 	pr6|66		avg
001304  aa   000042 6040 04	tmi  	34,ic		001346
						STATEMENT 1 ON LINE 293
				else ;

001305  aa   000012 7100 04	tra  	10,ic		001317
						STATEMENT 1 ON LINE 295
			     else if sort = 4
			     then /* If sorting on page waits ... */
				if table (j).datap -> gate_entry_data.page_waits < gate_entry_data.page_waits
				then go to next;

001306  aa   000004 1160 07	cmpq 	4,dl
001307  aa   000010 6010 04	tnz  	8,ic		001317
001310  aa  6 00137 2361 00	ldq  	pr6|95		j
001311  aa   000002 7360 00	qls  	2
001312  aa  6 00200 7671 06	lprp7	pr6|128,ql	table.datap
001313  aa  7 00004 2361 00	ldq  	pr7|4		gate_entry_data.page_waits
001314  aa  6 04206 3715 20	epp5 	pr6|2182,*	gate_datap
001315  aa  5 00004 1161 00	cmpq 	pr5|4		gate_entry_data.page_waits
001316  aa   000030 6040 04	tmi  	24,ic		001346
						STATEMENT 1 ON LINE 301
			     temp_table = table (j + 1);

001317  aa  6 00137 2361 00	ldq  	pr6|95		j
001320  aa   000002 7360 00	qls  	2
001321  aa   000000 6270 06	eax7 	0,ql
001322  aa  6 00202 2351 17	lda  	pr6|130,7		table
001323  aa  6 00203 2361 17	ldq  	pr6|131,7		table
001324  aa  6 04202 7571 00	staq 	pr6|2178		temp_table
001325  aa  6 00204 2351 17	lda  	pr6|132,7		table
001326  aa  6 00205 2361 17	ldq  	pr6|133,7		table
001327  aa  6 04204 7571 00	staq 	pr6|2180		temp_table
						STATEMENT 1 ON LINE 302
			     table (j + 1) = table (j);

001330  aa  6 00202 3735 17	epp7 	pr6|130,7		table
001331  aa  6 00176 3715 17	epp5 	pr6|126,7		table
001332  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001333  aa  5 00000 00 0020	desc9a	pr5|0,16		table
001334  aa  7 00000 00 0020	desc9a	pr7|0,16		table
						STATEMENT 1 ON LINE 303
			     table (j) = temp_table;

001335  aa  6 04202 2371 00	ldaq 	pr6|2178		temp_table
001336  aa  6 00176 7551 17	sta  	pr6|126,7		table
001337  aa  6 00177 7561 17	stq  	pr6|127,7		table
001340  aa  6 04204 2371 00	ldaq 	pr6|2180		temp_table
001341  aa  6 00200 7551 17	sta  	pr6|128,7		table
001342  aa  6 00201 7561 17	stq  	pr6|129,7		table
						STATEMENT 1 ON LINE 305
			end;

001343  aa   000001 3360 07	lcq  	1,dl
001344  aa  6 00137 0561 00	asq  	pr6|95		j
001345  aa   777701 7100 04	tra  	-63,ic		001246
						STATEMENT 1 ON LINE 307
next:
		end;

001346  aa  6 00136 0541 00	aos  	pr6|94		i
001347  aa   777611 7100 04	tra  	-119,ic		001160
						STATEMENT 1 ON LINE 313
		if sort = 5
		then do;

001350  aa  6 00135 2361 00	ldq  	pr6|93		sort
001351  aa   000005 1160 07	cmpq 	5,dl
001352  aa   000025 6010 04	tnz  	21,ic		001377
						STATEMENT 1 ON LINE 315
			call ioa_ ("Entry ^a not found or not metered in gate ^a.", entry, segname);

001353  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001354  aa   776573 00 0060	desc9a	-645,48		000146 = 105156164162
001355  aa  6 04242 00 0060	desc9a	pr6|2210,48
001356  aa  6 04242 3521 00	epp2 	pr6|2210
001357  aa  6 04264 2521 00	spri2	pr6|2228
001360  aa  6 00125 3521 00	epp2 	pr6|85		entry
001361  aa  6 04266 2521 00	spri2	pr6|2230
001362  aa  6 00115 3521 00	epp2 	pr6|77		segname
001363  aa  6 04270 2521 00	spri2	pr6|2232
001364  aa   776433 3520 04	epp2 	-741,ic		000017 = 524000000055
001365  aa  6 04272 2521 00	spri2	pr6|2234
001366  aa   776433 3520 04	epp2 	-741,ic		000021 = 526000000040
001367  aa  6 04274 2521 00	spri2	pr6|2236
001370  aa  6 04276 2521 00	spri2	pr6|2238
001371  aa  6 04262 6211 00	eax1 	pr6|2226
001372  aa   014000 4310 07	fld  	6144,dl
001373  aa  6 00044 3701 20	epp4 	pr6|36,*
001374  la  4 00034 3521 20	epp2 	pr4|28,*		ioa_
001375  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 316
			return;

001376  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 317
		     end;

						STATEMENT 1 ON LINE 319
		call date_time_ (itime, citime);

001377  aa  6 00144 3521 00	epp2 	pr6|100		itime
001400  aa  6 04232 2521 00	spri2	pr6|2202
001401  aa  6 00150 3521 00	epp2 	pr6|104		citime
001402  aa  6 04234 2521 00	spri2	pr6|2204
001403  aa   776436 3520 04	epp2 	-738,ic		000041 = 410000000107
001404  aa  6 04236 2521 00	spri2	pr6|2206
001405  aa   776411 3520 04	epp2 	-759,ic		000016 = 526000000030
001406  aa  6 04240 2521 00	spri2	pr6|2208
001407  aa  6 04230 6211 00	eax1 	pr6|2200
001410  aa   010000 4310 07	fld  	4096,dl
001411  aa  6 00044 3701 20	epp4 	pr6|36,*
001412  la  4 00040 3521 20	epp2 	pr4|32,*		date_time_
001413  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 320
		call date_time_ (timnow, ctimnow);

001414  aa  6 00146 3521 00	epp2 	pr6|102		timnow
001415  aa  6 04232 2521 00	spri2	pr6|2202
001416  aa  6 00156 3521 00	epp2 	pr6|110		ctimnow
001417  aa  6 04234 2521 00	spri2	pr6|2204
001420  aa   776421 3520 04	epp2 	-751,ic		000041 = 410000000107
001421  aa  6 04236 2521 00	spri2	pr6|2206
001422  aa   776374 3520 04	epp2 	-772,ic		000016 = 526000000030
001423  aa  6 04240 2521 00	spri2	pr6|2208
001424  aa  6 04230 6211 00	eax1 	pr6|2200
001425  aa   010000 4310 07	fld  	4096,dl
001426  aa  6 00044 3701 20	epp4 	pr6|36,*
001427  la  4 00040 3521 20	epp2 	pr4|32,*		date_time_
001430  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 323
		call comp_time (ctime);

001431  aa   000411 3520 04	epp2 	265,ic		002042 = 000002000000
001432  aa   000360 6700 04	tsp4 	240,ic		002012
						STATEMENT 1 ON LINE 325
		call ioa_ ("^/Metering since ^a.^/Total non-idle time at ^a = ^d hr. ^d min. ^d sec.", citime,
		     ctimnow, hr, mn, sc);

001433  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001434  aa   776627 00 0110	desc9a	-617,72		000262 = 136057115145
001435  aa  6 04262 00 0110	desc9a	pr6|2226,72
001436  aa  6 04262 3521 00	epp2 	pr6|2226
001437  aa  6 04306 2521 00	spri2	pr6|2246
001440  aa  6 00150 3521 00	epp2 	pr6|104		citime
001441  aa  6 04310 2521 00	spri2	pr6|2248
001442  aa  6 00156 3521 00	epp2 	pr6|110		ctimnow
001443  aa  6 04312 2521 00	spri2	pr6|2250
001444  aa  6 00167 3521 00	epp2 	pr6|119		hr
001445  aa  6 04314 2521 00	spri2	pr6|2252
001446  aa  6 00170 3521 00	epp2 	pr6|120		mn
001447  aa  6 04316 2521 00	spri2	pr6|2254
001450  aa  6 00171 3521 00	epp2 	pr6|121		sc
001451  aa  6 04320 2521 00	spri2	pr6|2256
001452  aa   776343 3520 04	epp2 	-797,ic		000015 = 524000000110
001453  aa  6 04322 2521 00	spri2	pr6|2258
001454  aa   776342 3520 04	epp2 	-798,ic		000016 = 526000000030
001455  aa  6 04324 2521 00	spri2	pr6|2260
001456  aa  6 04326 2521 00	spri2	pr6|2262
001457  aa   776361 3520 04	epp2 	-783,ic		000040 = 404000000021
001460  aa  6 04330 2521 00	spri2	pr6|2264
001461  aa  6 04332 2521 00	spri2	pr6|2266
001462  aa  6 04334 2521 00	spri2	pr6|2268
001463  aa  6 04304 6211 00	eax1 	pr6|2244
001464  aa   030000 4310 07	fld  	12288,dl
001465  aa  6 00044 3701 20	epp4 	pr6|36,*
001466  la  4 00034 3521 20	epp2 	pr4|28,*		ioa_
001467  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 328
		if totcalls > 0
		then do;

001470  aa  6 00142 2361 00	ldq  	pr6|98		totcalls
001471  aa   000145 6044 04	tmoz 	101,ic		001636
						STATEMENT 1 ON LINE 331
			call ioa_ ("^/Gate meters for ^a: total calls = ^d, total ring alarms polled = ^d.", segname, totcalls, total_ring_alarms);

001472  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001473  aa   776546 00 0110	desc9a	-666,72		000240 = 136057107141
001474  aa  6 04262 00 0110	desc9a	pr6|2226,72
001475  aa  6 04262 3521 00	epp2 	pr6|2226
001476  aa  6 04306 2521 00	spri2	pr6|2246
001477  aa  6 00115 3521 00	epp2 	pr6|77		segname
001500  aa  6 04310 2521 00	spri2	pr6|2248
001501  aa  6 00142 3521 00	epp2 	pr6|98		totcalls
001502  aa  6 04312 2521 00	spri2	pr6|2250
001503  aa  6 00166 3521 00	epp2 	pr6|118		total_ring_alarms
001504  aa  6 04314 2521 00	spri2	pr6|2252
001505  aa   776307 3520 04	epp2 	-825,ic		000014 = 524000000106
001506  aa  6 04316 2521 00	spri2	pr6|2254
001507  aa   776312 3520 04	epp2 	-822,ic		000021 = 526000000040
001510  aa  6 04320 2521 00	spri2	pr6|2256
001511  aa   776327 3520 04	epp2 	-809,ic		000040 = 404000000021
001512  aa  6 04322 2521 00	spri2	pr6|2258
001513  aa   776324 3520 04	epp2 	-812,ic		000037 = 404000000043
001514  aa  6 04324 2521 00	spri2	pr6|2260
001515  aa  6 04304 6211 00	eax1 	pr6|2244
001516  aa   020000 4310 07	fld  	8192,dl
001517  aa  6 00044 3701 20	epp4 	pr6|36,*
001520  la  4 00034 3521 20	epp2 	pr4|28,*		ioa_
001521  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 334
			if ctime > 0
			then ptime = (float (tottim, 63) / float (ctime, 63)) * 1.e2;

001522  aa  6 00176 2371 00	ldaq 	pr6|126		ctime
001523  aa   000013 6044 04	tmoz 	11,ic		001536
001524  aa   216000 4110 03	lde  	72704,du
001525  aa   400000 4750 03	fad  	131072,du
001526  aa  6 04260 4571 00	dfst 	pr6|2224
001527  aa  6 00164 2371 00	ldaq 	pr6|116		tottim
001530  aa   216000 4110 03	lde  	72704,du
001531  aa   400000 4750 03	fad  	131072,du
001532  aa  6 04260 5671 00	dfdv 	pr6|2224
001533  aa   016620 4610 03	fmp  	7568,du
001534  aa  6 00200 4551 00	fst  	pr6|128		ptime
001535  aa   000003 7100 04	tra  	3,ic		001540
						STATEMENT 1 ON LINE 337
			else ptime = 0e0;

001536  aa   400000 4310 03	fld  	131072,du
001537  aa  6 00200 4551 00	fst  	pr6|128		ptime
						STATEMENT 1 ON LINE 338
			call comp_time (tottim);

001540  aa   000276 3520 04	epp2 	190,ic		002036 = 000002000000
001541  aa   000251 6700 04	tsp4 	169,ic		002012
						STATEMENT 1 ON LINE 340
			call ioa_ ("^d hr. ^d min. ^d sec. or ^6.3f% spent in calls through gate.", hr, mn, sc,
			     ptime);

001542  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001543  aa   776436 00 0100	desc9a	-738,64		000200 = 136144040150
001544  aa  6 04262 00 0100	desc9a	pr6|2226,64
001545  aa  6 04262 3521 00	epp2 	pr6|2226
001546  aa  6 04306 2521 00	spri2	pr6|2246
001547  aa  6 00167 3521 00	epp2 	pr6|119		hr
001550  aa  6 04310 2521 00	spri2	pr6|2248
001551  aa  6 00170 3521 00	epp2 	pr6|120		mn
001552  aa  6 04312 2521 00	spri2	pr6|2250
001553  aa  6 00171 3521 00	epp2 	pr6|121		sc
001554  aa  6 04314 2521 00	spri2	pr6|2252
001555  aa  6 00200 3521 00	epp2 	pr6|128		ptime
001556  aa  6 04316 2521 00	spri2	pr6|2254
001557  aa   776234 3520 04	epp2 	-868,ic		000013 = 524000000075
001560  aa  6 04320 2521 00	spri2	pr6|2256
001561  aa   776257 3520 04	epp2 	-849,ic		000040 = 404000000021
001562  aa  6 04322 2521 00	spri2	pr6|2258
001563  aa  6 04324 2521 00	spri2	pr6|2260
001564  aa  6 04326 2521 00	spri2	pr6|2262
001565  aa   776225 3520 04	epp2 	-875,ic		000012 = 414000000033
001566  aa  6 04330 2521 00	spri2	pr6|2264
001567  aa  6 04304 6211 00	eax1 	pr6|2244
001570  aa   024000 4310 07	fld  	10240,dl
001571  aa  6 00044 3701 20	epp4 	pr6|36,*
001572  la  4 00034 3521 20	epp2 	pr4|28,*		ioa_
001573  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 343
			call ioa_ ("^/            ring                    page");

001574  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001575  aa   776337 00 0054	desc9a	-801,44		000133 = 136057040040
001576  aa  6 04242 00 0054	desc9a	pr6|2210,44
001577  aa  6 04242 3521 00	epp2 	pr6|2210
001600  aa  6 04232 2521 00	spri2	pr6|2202
001601  aa   776210 3520 04	epp2 	-888,ic		000011 = 524000000052
001602  aa  6 04234 2521 00	spri2	pr6|2204
001603  aa  6 04230 6211 00	eax1 	pr6|2200
001604  aa   004000 4310 07	fld  	2048,dl
001605  aa  6 00044 3701 20	epp4 	pr6|36,*
001606  la  4 00034 3521 20	epp2 	pr4|28,*		ioa_
001607  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 344
			call ioa_ ("  calls   alarms   pcnt     avg   faults  entry name^/");

001610  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001611  aa   776352 00 0070	desc9a	-790,56		000162 = 040040143141
001612  aa  6 04242 00 0070	desc9a	pr6|2210,56
001613  aa  6 04242 3521 00	epp2 	pr6|2210
001614  aa  6 04232 2521 00	spri2	pr6|2202
001615  aa   776173 3520 04	epp2 	-901,ic		000010 = 524000000066
001616  aa  6 04234 2521 00	spri2	pr6|2204
001617  aa  6 04230 6211 00	eax1 	pr6|2200
001620  aa   004000 4310 07	fld  	2048,dl
001621  aa  6 00044 3701 20	epp4 	pr6|36,*
001622  la  4 00034 3521 20	epp2 	pr4|28,*		ioa_
001623  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 346
			do j = nentries by -1 to 1;

001624  aa  6 00140 2361 00	ldq  	pr6|96		nentries
001625  aa  6 00137 7561 00	stq  	pr6|95		j
001626  aa  6 00137 2361 00	ldq  	pr6|95		j
001627  aa   000001 1160 07	cmpq 	1,dl
001630  aa   000022 6040 04	tmi  	18,ic		001652
						STATEMENT 1 ON LINE 347
			     call print;

001631  aa   000051 6700 04	tsp4 	41,ic		001702
						STATEMENT 1 ON LINE 348
			end;

001632  aa   000001 3360 07	lcq  	1,dl
001633  aa  6 00137 0561 00	asq  	pr6|95		j
001634  aa   777772 7100 04	tra  	-6,ic		001626
						STATEMENT 1 ON LINE 349
		     end;

001635  aa   000015 7100 04	tra  	13,ic		001652
						STATEMENT 1 ON LINE 350
		else call ioa_ ("No calls through this gate.");

001636  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001637  aa   776256 00 0034	desc9a	-850,28		000114 = 116157040143
001640  aa  6 04230 00 0034	desc9a	pr6|2200,28
001641  aa  6 04230 3521 00	epp2 	pr6|2200
001642  aa  6 04244 2521 00	spri2	pr6|2212
001643  aa   776144 3520 04	epp2 	-924,ic		000007 = 524000000033
001644  aa  6 04246 2521 00	spri2	pr6|2214
001645  aa  6 04242 6211 00	eax1 	pr6|2210
001646  aa   004000 4310 07	fld  	2048,dl
001647  aa  6 00044 3701 20	epp4 	pr6|36,*
001650  la  4 00034 3521 20	epp2 	pr4|28,*		ioa_
001651  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 352
		call ioa_ ("^/");

001652  aa   136057 2350 03	lda  	48175,du
001653  aa  6 04227 7551 00	sta  	pr6|2199
001654  aa  6 04227 3521 00	epp2 	pr6|2199
001655  aa  6 04232 2521 00	spri2	pr6|2202
001656  aa   776130 3520 04	epp2 	-936,ic		000006 = 524000000002
001657  aa  6 04234 2521 00	spri2	pr6|2204
001660  aa  6 04230 6211 00	eax1 	pr6|2200
001661  aa   004000 4310 07	fld  	2048,dl
001662  aa  6 00044 3701 20	epp4 	pr6|36,*
001663  la  4 00034 3521 20	epp2 	pr4|28,*		ioa_
001664  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 353
	     end;

						STATEMENT 1 ON LINE 355
finish:
	if reset_sw
	then do;

001665  aa  6 00103 2351 00	lda  	pr6|67		reset_sw
001666  aa   400000 3150 03	cana 	131072,du
001667  aa   000012 6000 04	tze  	10,ic		001701
						STATEMENT 1 ON LINE 358
		gate_info (gi).old_time = timnow;

001670  aa  6 00101 2361 00	ldq  	pr6|65		gi
001671  aa   000014 4020 07	mpy  	12,dl
001672  aa   000000 6270 06	eax7 	0,ql
001673  aa  6 00146 2371 00	ldaq 	pr6|102		timnow
001674  aa  6 00044 3701 20	epp4 	pr6|36,*
001675  ia  4 00014 3735 20	epp7 	pr4|12,*		tempp
001676  aa  7 77776 7571 17	staq 	pr7|-2,7		gate_info_struct.old_time
						STATEMENT 1 ON LINE 359
		gate_info (gi).old_charged = charged_time;

001677  aa  6 00172 2371 00	ldaq 	pr6|122		charged_time
001700  aa  7 00000 7571 17	staq 	pr7|0,7		gate_info_struct.old_charged
						STATEMENT 1 ON LINE 360
	     end;

						STATEMENT 1 ON LINE 363
	return;

001701  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 415
     end;

BEGIN PROCEDURE print
ENTRY TO print                                              STATEMENT 1 ON LINE 368
print:
     proc;

001702  aa  6 04212 6501 00	spri4	pr6|2186
						STATEMENT 1 ON LINE 371
	gate_datap = table (j).datap;

001703  aa  6 00137 2361 00	ldq  	pr6|95		j
001704  aa   000002 7360 00	qls  	2
001705  aa  6 00200 7671 06	lprp7	pr6|128,ql	table.datap
001706  aa  6 04206 6535 00	spri7	pr6|2182		gate_datap
						STATEMENT 1 ON LINE 372
	namep = table (j).entryp;

001707  aa  6 00176 7651 06	lprp5	pr6|126,ql	table.entryp
001710  aa  6 00106 6515 00	spri5	pr6|70		namep
						STATEMENT 1 ON LINE 373
	namel = table (j).entryl;

001711  aa   000000 6270 06	eax7 	0,ql
001712  aa  6 00177 2361 06	ldq  	pr6|127,ql	table.entryl
001713  aa  6 00110 7561 00	stq  	pr6|72		namel
						STATEMENT 1 ON LINE 374
	avg = table (j).avg;

001714  aa  6 00201 4311 17	fld  	pr6|129,7		table.avg
001715  aa  6 00102 4551 00	fst  	pr6|66		avg
						STATEMENT 1 ON LINE 375
	if gate_entry_data.calls > 0
	then do;

001716  aa  7 00005 2361 00	ldq  	pr7|5		gate_entry_data.calls
001717  aa   000072 6044 04	tmoz 	58,ic		002011
						STATEMENT 1 ON LINE 377
		if ctime <= 0
		then ptime = 0e0;

001720  aa  6 00176 2371 00	ldaq 	pr6|126		ctime
001721  aa   000004 6054 04	tpnz 	4,ic		001725
001722  aa   400000 4310 03	fld  	131072,du
001723  aa  6 00200 4551 00	fst  	pr6|128		ptime
001724  aa   000012 7100 04	tra  	10,ic		001736
						STATEMENT 1 ON LINE 379
		else ptime = (float (gate_entry_data.vcpu_time, 63) / float (ctime, 63)) * 1.e2;

001725  aa   216000 4110 03	lde  	72704,du
001726  aa   400000 4750 03	fad  	131072,du
001727  aa  6 04340 4571 00	dfst 	pr6|2272
001730  aa  7 00002 2371 00	ldaq 	pr7|2		gate_entry_data.vcpu_time
001731  aa   216000 4110 03	lde  	72704,du
001732  aa   400000 4750 03	fad  	131072,du
001733  aa  6 04340 5671 00	dfdv 	pr6|2272
001734  aa   016620 4610 03	fmp  	7568,du
001735  aa  6 00200 4551 00	fst  	pr6|128		ptime
						STATEMENT 1 ON LINE 381
		ppage = float (gate_entry_data.page_waits, 27) / float (gate_entry_data.calls, 27);

001736  aa  7 00005 2361 00	ldq  	pr7|5		gate_entry_data.calls
001737  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
001740  aa  6 04337 4551 00	fst  	pr6|2271
001741  aa  7 00004 2361 00	ldq  	pr7|4		gate_entry_data.page_waits
001742  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
001743  aa  6 04337 5651 00	fdv  	pr6|2271
001744  aa  6 00201 4551 00	fst  	pr6|129		ppage
						STATEMENT 1 ON LINE 383
		call ioa_ ("^7d  ^7d  ^5.2f ^8.2f  ^6.2f  ^a", gate_entry_data.calls, gate_entry_data.ring_alarms,
		     ptime, avg, ppage, entryname);

001745  aa  6 00110 2361 00	ldq  	pr6|72		namel
001746  aa   526000 2760 03	orq  	175104,du
001747  aa  6 04337 7561 00	stq  	pr6|2271
001750  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001751  aa   776153 00 0040	desc9a	-917,32		000123 = 136067144040
001752  aa  6 04342 00 0040	desc9a	pr6|2274,32
001753  aa  6 04342 3521 00	epp2 	pr6|2274
001754  aa  6 04354 2521 00	spri2	pr6|2284
001755  aa  7 00005 3521 00	epp2 	pr7|5		gate_entry_data.calls
001756  aa  6 04356 2521 00	spri2	pr6|2286
001757  aa  7 00006 3521 00	epp2 	pr7|6		gate_entry_data.ring_alarms
001760  aa  6 04360 2521 00	spri2	pr6|2288
001761  aa  6 00200 3521 00	epp2 	pr6|128		ptime
001762  aa  6 04362 2521 00	spri2	pr6|2290
001763  aa  6 00102 3521 00	epp2 	pr6|66		avg
001764  aa  6 04364 2521 00	spri2	pr6|2292
001765  aa  6 00201 3521 00	epp2 	pr6|129		ppage
001766  aa  6 04366 2521 00	spri2	pr6|2294
001767  aa  5 00000 3521 00	epp2 	pr5|0		entryname
001770  aa  6 04370 2521 00	spri2	pr6|2296
001771  aa   776014 3520 04	epp2 	-1012,ic		000005 = 524000000040
001772  aa  6 04372 2521 00	spri2	pr6|2298
001773  aa   776044 3520 04	epp2 	-988,ic		000037 = 404000000043
001774  aa  6 04374 2521 00	spri2	pr6|2300
001775  aa  6 04376 2521 00	spri2	pr6|2302
001776  aa   776014 3520 04	epp2 	-1012,ic		000012 = 414000000033
001777  aa  6 04400 2521 00	spri2	pr6|2304
002000  aa  6 04402 2521 00	spri2	pr6|2306
002001  aa  6 04404 2521 00	spri2	pr6|2308
002002  aa  6 04337 3521 00	epp2 	pr6|2271
002003  aa  6 04406 2521 00	spri2	pr6|2310
002004  aa  6 04352 6211 00	eax1 	pr6|2282
002005  aa   034000 4310 07	fld  	14336,dl
002006  aa  6 00044 3701 20	epp4 	pr6|36,*
002007  la  4 00034 3521 20	epp2 	pr4|28,*		ioa_
002010  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 385
	     end;

						STATEMENT 1 ON LINE 388
     end;

002011  aa  6 04212 6101 00	rtcd 	pr6|2186
  END PROCEDURE print
BEGIN PROCEDURE comp_time
ENTRY TO comp_time                                          STATEMENT 1 ON LINE 394
comp_time:
     proc (a);

002012  aa  6 04220 6501 00	spri4	pr6|2192
002013  aa  6 04222 2521 00	spri2	pr6|2194
						STATEMENT 1 ON LINE 401
	sc = divide (a, 1000000, 17, 0);

002014  aa  2 00002 2371 20	ldaq 	pr2|2,*		a
002015  aa   775766 3520 04	epp2 	-1034,ic		000003 = 000003641100
002016  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
002017  aa     000000000000
002020  aa  6 00171 7561 00	stq  	pr6|121		sc
						STATEMENT 1 ON LINE 402
	mn = divide (sc, 60, 17, 0);

002021  aa   000074 5060 07	div  	60,dl
002022  aa  6 00170 7561 00	stq  	pr6|120		mn
						STATEMENT 1 ON LINE 403
	hr = divide (mn, 60, 17, 0);

002023  aa   000074 5060 07	div  	60,dl
002024  aa  6 00167 7561 00	stq  	pr6|119		hr
						STATEMENT 1 ON LINE 404
	sc = mod (sc, 60);

002025  aa  6 00171 2361 00	ldq  	pr6|121		sc
002026  aa   000020 3520 04	epp2 	16,ic		002046 = 000000000074
002027  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
002030  aa  6 00171 7561 00	stq  	pr6|121		sc
						STATEMENT 1 ON LINE 405
	mn = mod (mn, 60);

002031  aa  6 00170 2361 00	ldq  	pr6|120		mn
002032  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
002033  aa  6 00170 7561 00	stq  	pr6|120		mn
						STATEMENT 1 ON LINE 407
	return;

002034  aa  6 04220 6101 00	rtcd 	pr6|2192
						STATEMENT 1 ON LINE 410
     end;

  END PROCEDURE comp_time
  END PROCEDURE mg


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
