	COMPILATION LISTING OF SEGMENT set_tpp
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/12/82  1239.2 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 set_tpp: stpp: proc;
       12 
       13 /* Procedure to print and set the time-page-product of a directory.
       14*   To be used by system administrators to repair clobbered directories,
       15*   avoiding loss of disk storage revenue, and keeping the diskreport job happy.
       16*
       17*   Usage: set_tpp directory -control_args-
       18*
       19*   directory	is the pathname of the directory to be operated upon.
       20*
       21*   control_args	may be chosen from the following and may appear in any order:
       22*
       23*   -print, -pr		causes the current tpp and equivalent dollar charge to be printed.
       24*   -long, -lg	causes the above, plus the quota, used time-tpp-updated, sons lvid, and quota switch to be printed.
       25*   -directory, -dr	sets command to operate on directory page figures.
       26*   -segment, -sm	sets the command to operate on segment page figures. This is the default.
       27*   -set value	causes the tpp to be modified as specified by value
       28*
       29*   value can be in dollars and cents (preceeded by a "$") or in page-seconds.
       30*   It can have a "+" or "-" sign preceeding it, indicating a change
       31*   to the current tpp, or be unsigned, indicating an absolute value to be set,
       32*   replacing the current tpp. Setting of an absolute value is only approximate, since
       33*   the tpp is growing while the command is being executed, and the
       34*   primitive that makes the change only accepts relative values, to modify
       35*   the current tpp.
       36*
       37*
       38*   Written by T. Casey, April 1976
       39*   Modified Feb 1980 by M. B. Armstrong to implement multiple rate structures.
       40*
       41**/
       42 
       43 /* Ext Entries */
       44 
       45 dcl  com_err_ entry options (variable);
       46 dcl  command_query_ entry options (variable);
       47 dcl  cv_dec_check_ entry (char (*) aligned, fixed bin (35)) returns (fixed bin (35));
       48 dcl  cv_float_ entry (char (*) aligned, fixed bin (35)) returns (float bin (27));
       49 dcl  cu_$arg_count entry (fixed bin);
       50 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
       51 dcl  date_time_$fstime entry (bit (36), char (*));
       52 dcl  expand_path_ entry (ptr, fixed bin, ptr, ptr, fixed bin (35));
       53 dcl  hcs_$quota_read entry (char (*), fixed bin (18), fixed bin (71), bit (36), bit (36), fixed bin (1), fixed bin (18),
       54      fixed bin (35));
       55 dcl  hcs_$dir_quota_read entry (char (*), fixed bin (18), fixed bin (71), bit (36), bit (36), fixed bin (1),
       56      fixed bin (18), fixed bin (35));
       57 dcl  hcs_$make_ptr entry (ptr, char (*), char (*), ptr, fixed bin (35));
       58 dcl  hphcs_$get_reset_quota entry (char (*), fixed bin (71), fixed bin (35));
       59 dcl  hphcs_$dir_get_reset_quota entry (char (*), fixed bin (71), fixed bin (35));
       60 dcl  ioa_ entry options (variable);
       61 dcl  system_info_$prices_rs entry (fixed bin, (0:7)float bin, (0:7)float bin, (0:7)float bin,
       62     (0:7) float bin, float bin, float bin);
       63 dcl  system_info_$max_rs_number entry (fixed bin);
       64 dcl  search_sat_$rs_number entry (char (*), fixed bin, fixed bin (35));
       65 dcl  search_sat_$clean_up entry;
       66 dcl  error_table_$noentry external fixed bin (35);
       67 
       68 /* Bit */
       69 
       70 dcl (dollar_sw, expecting_val, got_path, long_sw, print_sw, set_sw) bit (1) aligned init (""b);
       71 dcl (slvid, uptime) bit (36);
       72 
       73 /* Fixed bin */
       74 
       75 dcl (del_tpp, set_val, tpp) fixed bin (71);
       76 dcl  code fixed bin (35);
       77 dcl (quota, used) fixed bin (18);
       78 dcl  rs_number fixed bin;
       79 dcl  rs_count fixed bin;
       80 dcl (aix, argl, argno, i, nargs) fixed bin;
       81 dcl  operation fixed bin;
       82 dcl  ADD fixed bin int static init (1);
       83 dcl  SUBTRACT fixed bin int static init (2);
       84 dcl  SET fixed bin int static init (3);
       85 dcl  quota_sw fixed bin (1);
       86 
       87 /* Float Bin */
       88 
       89 dcl  dummy (0:7) float bin;
       90 dcl (cur_charge, del_charge, disk_price, dollar_val, dummy1) float bin;
       91 
       92 /* Char */
       93 
       94 dcl  path char (168) init ("");
       95 dcl  message char (168) init ("^a");
       96 dcl  aligned_arg char (32) aligned;
       97 dcl  date char (16);
       98 dcl  dir_seg char (9) init ("segment");
       99 dcl  me char (8) init ("set_tpp");
      100 dcl  inc_dec char (8);
      101 dcl  answer char (3) varying;
      102 
      103 /* Ptr */
      104 
      105 dcl (argp, dummy_ptr, segp) ptr init (null);
      106 
      107 /* Based */
      108 
      109 dcl  arg char (argl) based (argp);
      110 
      111 /* Builtin */
      112 
      113 dcl (addr, after, before, index, null, ptr, substr, verify) builtin;
      114 
      115 /* Condition */
      116 
      117 dcl  linkage_error condition;
      118 
      119 /* Ext */
      120 
      121 dcl (error_table_$bad_arg, error_table_$badopt, error_table_$noarg) ext fixed bin (35);
      122 
      123 /* Include */
      124 
  1     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  1     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  1     3 /*	version number changed to 4, 08/10/78 WOS */
  1     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  1     5 
  1     6 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  1     7     2 version fixed bin,				/* version of this structure - must be set, see below */
  1     8     2 switches aligned,                                     /* various bit switch values */
  1     9       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  1    10       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  1    11       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  1    12                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  1    13       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  1    14       3 padding bit (31) unaligned init (""b),		/* pads it out to t word */
  1    15     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  1    16     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  1    17 
  1    18 /*  Limit of data defined for version 2 */
  1    19 
  1    20     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  1    21     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  1    22     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  1    23 						/* minimum of 30 seconds required for repeat */
  1    24 						/* otherwise, no repeat will occur */
  1    25 /* Limit of data defined for version 4 */
  1    26 
  1    27     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  1    28     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  1    29 
  1    30 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  1    31 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  1    32 dcl  query_info_version_5 fixed bin int static options (constant) init (5); /* the current version number */
  1    33 
  1    34 /*	END INCLUDE FILE query_info.incl.pl1 */
      125 
      126 
      127 /* Procedure */
      128 
      129 	call cu_$arg_count (nargs);
      130 	if nargs = 0 then do;
      131 	     call com_err_ (0, me, "Usage: set_tpp path -print/-long -dr/-sm -set N/+N/-N/$N/$+N/$-N");
      132 	     return;
      133 	end;
      134 
      135 	do argno = 1 to nargs;
      136 	     call cu_$arg_ptr (argno, argp, argl, code);
      137 	     if code ^= 0 then do;
      138 		message = "";
      139 		goto call_com_err;
      140 	     end;
      141 
      142 	     if expecting_val then do;		/* previous argument was -set */
      143 		expecting_val = ""b;
      144 		aix = 1;				/* scan for + - or $ starting at char 1 */
      145 		operation = SET;			/* default, if + or - not given */
      146 val_loop:		if verify (substr (arg, aix), "0123456789.") = 0 /* if nothing but those chars in rest of arg */
      147 		then goto numeric;			/* then go convert it */
      148 		i = index ("+-", substr (arg, aix, 1)); /* see if next char is + or - */
      149 		if i ^= 0 then do;			/* it was one of them */
      150 		     operation = i;			/* 1 = ADD, 2 = SUBTRACT */
      151 		     aix = aix + 1;			/* skip to next char */
      152 		     goto val_loop;			/* and go see if it is special */
      153 		end;
      154 
      155 		if substr (arg, aix, 1) = "$" then do;
      156 		     dollar_sw = "1"b;
      157 		     aix = aix + 1;			/* go to next char */
      158 		     goto val_loop;			/* and go see if it is special */
      159 		end;
      160 bad_val:		message = "Error converting decimal argument: ""^a""";
      161 		code = 0;
      162 		goto arg_err;
      163 
      164 numeric:		aligned_arg = substr (arg, aix);	/* copy rest of arg to aligned string */
      165 		if dollar_sw then
      166 		     dollar_val = cv_float_ (aligned_arg, code); /* convert to float bin */
      167 		else set_val = cv_dec_check_ (aligned_arg, code); /* convert to fixed bin */
      168 		if code ^= 0 then goto bad_val;
      169 	     end;					/* end expecting */
      170 
      171 	     else if substr (arg, 1, 1) ^= "-" then do;	/* not ctl arg */
      172 		if ^got_path then do;
      173 		     call expand_path_ (argp, argl, addr (path), null (), code);
      174 		     if code ^= 0 then do;
      175 arg_err:			path = arg;
      176 call_com_err:		call com_err_ (code, me, message, path);
      177 			return;
      178 		     end;
      179 		     got_path = "1"b;		/* remember we already got the dir path */
      180 		end;
      181 
      182 		else do;				/* we already have the path. this arg is no good */
      183 		     code = error_table_$bad_arg;
      184 		     goto arg_err;
      185 		end;
      186 	     end;					/* end not ctl arg */
      187 
      188 /* must be control arg */
      189 
      190 	     else if arg = "-print" | arg = "-pr" then print_sw = "1"b;
      191 	     else if arg = "-s" | arg = "-sm" | arg = "-seg" | arg = "-segment" then dir_seg = "segment";
      192 	     else if arg = "-d" | arg = "-dr" | arg = "-dir" | arg = "-directory" then dir_seg = "directory";
      193 	     else if arg = "-lg" | arg = "-long" then print_sw, long_sw = "1"b;
      194 	     else if arg = "-set" then set_sw, expecting_val = "1"b;
      195 	     else do;
      196 		code = error_table_$badopt;
      197 		goto arg_err;
      198 	     end;
      199 
      200 	end;					/* and loop thru args */
      201 	if ^got_path then do;
      202 	     message = "directory path";
      203 noarg_err:     code = error_table_$noarg;
      204 	     goto call_com_err;
      205 	end;
      206 
      207 	if expecting_val then do;
      208 	     message = "after -set";
      209 	     goto noarg_err;
      210 	end;
      211 
      212 /* Now do the work */
      213 	call system_info_$max_rs_number (rs_count);	/* see if site has multiple rate structures */
      214 	if rs_count > 0 then			/* if it does, */
      215 	     call get_rs_number (path, rs_number);	/* we must get the correct rate_structure */
      216 	else rs_number = 0;				/* if not, use the default (the only one at the site) */
      217 	call system_info_$prices_rs (rs_number, dummy, dummy, dummy, dummy, disk_price, dummy1); /* get disk price */
      218 	call get_quota;				/* int proc to get dir or seg quota */
      219 	if code ^= 0 then goto call_com_err;
      220 
      221 	cur_charge = tpp * disk_price;		/* compute current charge for the dir */
      222 
      223 	if ^print_sw & ^set_sw then			/* if user said neither -print nor -set */
      224 	     print_sw = "1"b;			/* presumably he did want us to do something */
      225 	if print_sw then do;			/* if printing current values */
      226 	     if long_sw then do;
      227 		call date_time_$fstime (uptime, date);
      228 		call ioa_ ("q=^d,u=^d,tpp=^d ($^.2f),updt=^a,slvid=^w,qsw=^d",
      229 		     quota, used, tpp, cur_charge, date, slvid, quota_sw);
      230 	     end;
      231 	     else if quota_sw = 1 then		/* if dir has a quota and tpp */
      232 		call ioa_ ("tpp=^d ($^.2f)", tpp, cur_charge);
      233 	     else call ioa_ ("no quota or tpp on this directory");
      234 	end;					/* end printing current values */
      235 
      236 	if set_sw then do;				/* if setting new values */
      237 	     on linkage_error goto no_hphcs;		/* see if user has hphcs_ access, before querying him */
      238 	     call hcs_$make_ptr (null (), "hphcs_", "get_reset_quota", dummy_ptr, code);
      239 	     if code = 0 then goto yes_hphcs;
      240 no_hphcs:	     call com_err_ (code, me, "The set operation requires access to the hphcs_ gate");
      241 	     return;
      242 yes_hphcs:     revert linkage_error;
      243 
      244 	     if dollar_sw then			/* compute tpp from given dollar value */
      245 		set_val = dollar_val/disk_price;	/* floating point division, assigned to fixed bin */
      246 
      247 	     if operation = SET then			/* user wants to set absolute value */
      248 		del_tpp = tpp - set_val;		/* we can only approximate that */
      249 	     else if operation = ADD then
      250 		del_tpp = -set_val;			/* but we can make a +/- change exactly */
      251 	     else del_tpp = set_val;
      252 
      253 	     del_charge = - del_tpp * disk_price;
      254 
      255 /* The apparent sign reversal error here is not an error.
      256*   The confusion arises from the fact that the reset primitive subtracts del_tpp from the current tpp. */
      257 
      258 	     if del_charge < 0e0 then
      259 		inc_dec = "DECREASE";
      260 	     else inc_dec = "INCREASE";
      261 	     query_info.yes_or_no_sw = "1"b;
      262 	     call command_query_ (addr (query_info), answer, me,
      263 		"This operation will ^a the ^a page charge on ^a by $^.2f,to ^d ($^.2f). Do you want to do that?",
      264 		inc_dec, dir_seg, path, del_charge, tpp-del_tpp, cur_charge+del_charge);
      265 	     if answer = "no" then return;
      266 
      267 	     if dir_seg = "directory" then
      268 		call hphcs_$dir_get_reset_quota (path, del_tpp, code);
      269 	     else call hphcs_$get_reset_quota (path, del_tpp, code);
      270 	     if code ^= 0 then
      271 		call com_err_ (code, me, "trying to reset tpp of ^a", path);
      272 
      273 	     call get_quota;			/* look at result of what we did */
      274 	     if code ^= 0 then goto call_com_err;
      275 	     cur_charge = tpp * disk_price;
      276 	     call ioa_ ("tpp is now ^d ($^.2f)", tpp, cur_charge);
      277 	end;					/* end setting new values */
      278 	return;
      279 
      280 get_quota: proc;
      281 	     if dir_seg = "directory" then
      282 		call hcs_$dir_quota_read (path, quota, tpp, uptime, slvid, quota_sw, used, code);
      283 	     else call hcs_$quota_read (path, quota, tpp, uptime, slvid, quota_sw, used, code);
      284 	     return;
      285 	end get_quota;
      286 
      287 get_rs_number: proc (path, rs_number);
      288 
      289 dcl (path, work) char (168);
      290 dcl  rs_number fixed bin;
      291 
      292 dcl (code, sat_code) fixed bin (35);
      293 dcl (entry, project_entry) char (32);
      294 dcl  area area based (area_ptr);
      295 dcl (area_ptr, name_ptr init (null)) ptr;
      296 dcl  primary_name char (32) aligned based (name_ptr);
      297 
      298 dcl 1 status aligned,				/* status info structure */
      299    (2 type bit (2),
      300     2 nnames fixed bin (15),
      301     2 nrp bit (18),					/* rel ptr to names */
      302     2 dtm bit (36),
      303     2 dtu bit (36),
      304     2 mode bit (5),
      305     2 pad bit (13),
      306     2 records fixed bin (17)) unaligned;
      307 
      308 dcl  get_system_free_area_ entry returns (ptr);
      309 dcl  hcs_$status_ entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
      310 
      311 	     rs_number,
      312 		sat_code = 0;
      313 
      314 	     work = after (path, ">");		/* get rid of root */
      315 	     entry = before (work, ">");		/* and grab 1st level directory */
      316 	     if entry ^= "udd" then
      317 		if entry ^= "UDD" then
      318 		     if entry ^= "user_dir_dir" then return; /* doesn't belong to a project */
      319 	     work = after (work, ">");
      320 	     entry = before (work, ">");		/* finally - the project name (one of them) */
      321 	     project_entry = entry;
      322 	     if entry = "" then return;		/* sorry - not a project */
      323 
      324 	     area_ptr = get_system_free_area_ ();	/* get some working space */
      325 	     call hcs_$status_ (">udd", (entry), 0, addr (status), area_ptr, code); /* we want the primary name */
      326 	     if code = 0 & status.nrp ^= "0"b then do;
      327 		name_ptr = ptr (area_ptr, status.nrp);	/* find the names array */
      328 		project_entry = primary_name;		/* get the primary name */
      329 		free primary_name in (area);		/* clean up */
      330 		call search_sat_$rs_number ((project_entry), rs_number, sat_code); /* try for the rate */
      331 		call search_sat_$clean_up;		/* tidy up */
      332 		if sat_code = 0 then return;		/* home run */
      333 	     end;
      334 
      335 	     call search_sat_$rs_number ((entry), rs_number, sat_code); /* try the name given to us */
      336 	     call search_sat_$clean_up;		/* tidy up */
      337 	     if sat_code = 0 then return;		/* 1-0 for the good guys */
      338 	     if code ^= 0 then			/* We tried! Heaven knows, we tried!! */
      339 		call com_err_ (code, me, "Attempting to access project directory >udd>^a.", entry);
      340 	     if sat_code = error_table_$noentry then
      341 		call com_err_ (sat_code, me, "Trying to locate project ""^a"".  Default rates will be used.",
      342 		project_entry);
      343 	     else call com_err_ (sat_code, me, "Accessing the sat.  Default rates will be used");
      344 	     return;
      345 	end get_rs_number;
      346 
      347      end set_tpp;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/12/82  1110.5  set_tpp.pl1                       >spec>on>11/12/82>set_tpp.pl1
125          1    08/12/81  0911.2  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ADD                                    constant        fixed bin(17,0)          initial dcl 82 ref 249
SET                                    constant        fixed bin(17,0)          initial dcl 84 ref 145 247
addr                                                   builtin function         dcl 113 ref 173 173 262 262 325 325
after                                                  builtin function         dcl 113 ref 314 319
aix                             000123 automatic       fixed bin(17,0)          dcl 80 set ref 144* 146 148 151* 151 155 157* 157
                                                                                  164
aligned_arg                     000273 automatic       char(32)                 dcl 96 set ref 164* 165* 167*
answer                          000316 automatic       varying char(3)          dcl 101 set ref 262* 265
answer_iocbp              6     000334 automatic       pointer                  initial level 2 dcl 1-6 set ref 1-6*
area                                   based           area(1024)               dcl 294 ref 329
area_ptr                        000462 automatic       pointer                  dcl 295 set ref 324* 325* 327 329
arg                                    based           char                     unaligned dcl 109 ref 146 148 155 164 171 175 190
                                                                                  190 191 191 191 191 192 192 192 192 193 193 194
argl                            000124 automatic       fixed bin(17,0)          dcl 80 set ref 136* 146 148 155 164 171 173* 175 190
                                                                                  190 191 191 191 191 192 192 192 192 193 193 194
argno                           000125 automatic       fixed bin(17,0)          dcl 80 set ref 135* 136*
argp                            000320 automatic       pointer                  initial dcl 105 set ref 105* 136* 146 148 155 164
                                                                                  171 173* 175 190 190 191 191 191 191 192 192 192
                                                                                  192 193 193 194
before                                                 builtin function         dcl 113 ref 315 320
code                            000116 automatic       fixed bin(35,0)          dcl 76 in procedure "stpp" set ref 136* 137 161*
                                                                                  165* 167* 168 173* 174 176* 183* 196* 203* 219
                                                                                  238* 239 240* 267* 269* 270 270* 274 281* 283*
code                            000440 automatic       fixed bin(35,0)          dcl 292 in procedure "get_rs_number" set ref 325*
                                                                                  326 338 338*
com_err_                        000010 constant        entry                    external dcl 45 ref 131 176 240 270 338 340 343
command_query_                  000012 constant        entry                    external dcl 46 ref 262
cp_escape_control         1(02) 000334 automatic       bit(2)                   initial level 3 packed unaligned dcl 1-6 set ref
                                                                                  1-6*
cu_$arg_count                   000020 constant        entry                    external dcl 49 ref 129
cu_$arg_ptr                     000022 constant        entry                    external dcl 50 ref 136
cur_charge                      000142 automatic       float bin(27)            dcl 90 set ref 221* 228* 231* 262 275* 276*
cv_dec_check_                   000014 constant        entry                    external dcl 47 ref 167
cv_float_                       000016 constant        entry                    external dcl 48 ref 165
date                            000303 automatic       char(16)                 unaligned dcl 97 set ref 227* 228*
date_time_$fstime               000024 constant        entry                    external dcl 51 ref 227
del_charge                      000143 automatic       float bin(27)            dcl 90 set ref 253* 258 262* 262
del_tpp                         000110 automatic       fixed bin(71,0)          dcl 75 set ref 247* 249* 251* 253 262 267* 269*
dir_seg                         000307 automatic       char(9)                  initial unaligned dcl 98 set ref 98* 191* 192* 262*
                                                                                  267 281
disk_price                      000144 automatic       float bin(27)            dcl 90 set ref 217* 221 244 253 275
dollar_sw                       000100 automatic       bit(1)                   initial dcl 70 set ref 70* 156* 165 244
dollar_val                      000145 automatic       float bin(27)            dcl 90 set ref 165* 244
dummy                           000132 automatic       float bin(27)            array dcl 89 set ref 217* 217* 217* 217*
dummy1                          000146 automatic       float bin(27)            dcl 90 set ref 217*
dummy_ptr                       000322 automatic       pointer                  initial dcl 105 set ref 105* 238*
entry                           000442 automatic       char(32)                 unaligned dcl 293 set ref 315* 316 316 316 320* 321
                                                                                  322 325 335 338*
error_table_$bad_arg            000056 external static fixed bin(35,0)          dcl 121 ref 183
error_table_$badopt             000060 external static fixed bin(35,0)          dcl 121 ref 196
error_table_$noarg              000062 external static fixed bin(35,0)          dcl 121 ref 203
error_table_$noentry            000054 external static fixed bin(35,0)          dcl 66 ref 340
expand_path_                    000026 constant        entry                    external dcl 52 ref 173
expecting_val                   000101 automatic       bit(1)                   initial dcl 70 set ref 70* 142 143* 194* 207
explanation_len          14     000334 automatic       fixed bin(21,0)          initial level 2 dcl 1-6 set ref 1-6*
explanation_ptr          12     000334 automatic       pointer                  initial level 2 dcl 1-6 set ref 1-6*
get_system_free_area_           000064 constant        entry                    external dcl 308 ref 324
got_path                        000102 automatic       bit(1)                   initial dcl 70 set ref 70* 172 179* 201
hcs_$dir_quota_read             000032 constant        entry                    external dcl 55 ref 281
hcs_$make_ptr                   000034 constant        entry                    external dcl 57 ref 238
hcs_$quota_read                 000030 constant        entry                    external dcl 53 ref 283
hcs_$status_                    000066 constant        entry                    external dcl 309 ref 325
hphcs_$dir_get_reset_quota      000040 constant        entry                    external dcl 59 ref 267
hphcs_$get_reset_quota          000036 constant        entry                    external dcl 58 ref 269
i                               000126 automatic       fixed bin(17,0)          dcl 80 set ref 148* 149 150
inc_dec                         000314 automatic       char(8)                  unaligned dcl 100 set ref 258* 260* 262*
index                                                  builtin function         dcl 113 ref 148
ioa_                            000042 constant        entry                    external dcl 60 ref 228 231 233 276
linkage_error                   000326 stack reference condition                dcl 117 ref 237 242
long_sw                         000103 automatic       bit(1)                   initial dcl 70 set ref 70* 193* 226
me                              000312 automatic       char(8)                  initial unaligned dcl 99 set ref 99* 131* 176* 240*
                                                                                  262* 270* 338* 340* 343*
message                         000221 automatic       char(168)                initial unaligned dcl 95 set ref 95* 138* 160* 176*
                                                                                  202* 208*
name_ptr                        000464 automatic       pointer                  initial dcl 295 set ref 295* 327* 328 329
nargs                           000127 automatic       fixed bin(17,0)          dcl 80 set ref 129* 130 135
nrp                       0(18) 000466 automatic       bit(18)                  level 2 packed unaligned dcl 298 set ref 326 327
null                                                   builtin function         dcl 113 ref 105 105 105 173 173 238 238 1-6 1-6 1-6
                                                                                  295
operation                       000130 automatic       fixed bin(17,0)          dcl 81 set ref 145* 150* 247 249
padding                   1(05) 000334 automatic       bit(31)                  initial level 3 packed unaligned dcl 1-6 set ref
                                                                                  1-6*
path                            000147 automatic       char(168)                initial unaligned dcl 94 in procedure "stpp" set ref
                                                                                  94* 173 173 175* 176* 214* 262* 267* 269* 270*
                                                                                  281* 283*
path                                   parameter       char(168)                unaligned dcl 289 in procedure "get_rs_number" ref
                                                                                  287 314
primary_name                           based           char(32)                 dcl 296 ref 328 329
print_sw                        000104 automatic       bit(1)                   initial dcl 70 set ref 70* 190* 193* 223 223* 225
project_entry                   000452 automatic       char(32)                 unaligned dcl 293 set ref 321* 328* 330 340*
ptr                                                    builtin function         dcl 113 ref 327
query_code                3     000334 automatic       fixed bin(35,0)          initial level 2 dcl 1-6 set ref 1-6*
query_info                      000334 automatic       structure                level 1 dcl 1-6 set ref 262 262
question_iocbp            4     000334 automatic       pointer                  initial level 2 dcl 1-6 set ref 1-6*
quota                           000117 automatic       fixed bin(18,0)          dcl 77 set ref 228* 281* 283*
quota_sw                        000131 automatic       fixed bin(1,0)           dcl 85 set ref 228* 231 281* 283*
repeat_time              10     000334 automatic       fixed bin(71,0)          initial level 2 dcl 1-6 set ref 1-6*
rs_count                        000122 automatic       fixed bin(17,0)          dcl 79 set ref 213* 214
rs_number                       000121 automatic       fixed bin(17,0)          dcl 78 in procedure "stpp" set ref 214* 216* 217*
rs_number                              parameter       fixed bin(17,0)          dcl 290 in procedure "get_rs_number" set ref 287
                                                                                  311* 330* 335*
sat_code                        000441 automatic       fixed bin(35,0)          dcl 292 set ref 311* 330* 332 335* 337 340 340* 343*
search_sat_$clean_up            000052 constant        entry                    external dcl 65 ref 331 336
search_sat_$rs_number           000050 constant        entry                    external dcl 64 ref 330 335
segp                            000324 automatic       pointer                  initial dcl 105 set ref 105*
set_sw                          000105 automatic       bit(1)                   initial dcl 70 set ref 70* 194* 223 236
set_val                         000112 automatic       fixed bin(71,0)          dcl 75 set ref 167* 244* 247 249 251
slvid                           000106 automatic       bit(36)                  unaligned dcl 71 set ref 228* 281* 283*
status                          000466 automatic       structure                level 1 dcl 298 set ref 325 325
status_code               2     000334 automatic       fixed bin(35,0)          initial level 2 dcl 1-6 set ref 1-6*
substr                                                 builtin function         dcl 113 ref 146 148 155 164 171
suppress_name_sw          1(01) 000334 automatic       bit(1)                   initial level 3 packed unaligned dcl 1-6 set ref
                                                                                  1-6*
suppress_spacing          1(04) 000334 automatic       bit(1)                   initial level 3 packed unaligned dcl 1-6 set ref
                                                                                  1-6*
switches                  1     000334 automatic       structure                level 2 dcl 1-6
system_info_$max_rs_number      000046 constant        entry                    external dcl 63 ref 213
system_info_$prices_rs          000044 constant        entry                    external dcl 61 ref 217
tpp                             000114 automatic       fixed bin(71,0)          dcl 75 set ref 221 228* 231* 247 262 275 276* 281*
                                                                                  283*
uptime                          000107 automatic       bit(36)                  unaligned dcl 71 set ref 227* 281* 283*
used                            000120 automatic       fixed bin(18,0)          dcl 77 set ref 228* 281* 283*
verify                                                 builtin function         dcl 113 ref 146
work                            000366 automatic       char(168)                unaligned dcl 289 set ref 314* 315 319* 319 320
yes_or_no_sw              1     000334 automatic       bit(1)                   initial level 3 packed unaligned dcl 1-6 set ref
                                                                                  261* 1-6*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
SUBTRACT                               internal static fixed bin(17,0)          initial dcl 83
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 1-30
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 1-31
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 1-32

NAMES DECLARED BY EXPLICIT CONTEXT.
arg_err                         000722 constant        label                    dcl 175 ref 162 184 197
bad_val                         000603 constant        label                    dcl 160 ref 168
call_com_err                    000727 constant        label                    dcl 176 ref 139 204 219 274
get_quota                       001741 constant        entry                    internal dcl 280 ref 218 273
get_rs_number                   002056 constant        entry                    internal dcl 287 ref 214
no_hphcs                        001421 constant        label                    dcl 240 ref 237
noarg_err                       001107 constant        label                    dcl 203 ref 209
numeric                         000610 constant        label                    dcl 164 ref 146
set_tpp                         000427 constant        entry                    external dcl 11
stpp                            000417 constant        entry                    external dcl 11
val_loop                        000534 constant        label                    dcl 146 ref 152 158
yes_hphcs                       001446 constant        label                    dcl 242 ref 239

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3212        3302    2705        3222
Length      3532    2705        70         213     305           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
stpp                                542 external procedure  is an external procedure.  
on unit on line 237                  64 on unit               
get_quota                               internal procedure  shares stack frame of external procedure stpp.  
get_rs_number                           internal procedure  shares stack frame of external procedure stpp.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
stpp                     000100 dollar_sw                   stpp
                         000101 expecting_val               stpp
                         000102 got_path                    stpp
                         000103 long_sw                     stpp
                         000104 print_sw                    stpp
                         000105 set_sw                      stpp
                         000106 slvid                       stpp
                         000107 uptime                      stpp
                         000110 del_tpp                     stpp
                         000112 set_val                     stpp
                         000114 tpp                         stpp
                         000116 code                        stpp
                         000117 quota                       stpp
                         000120 used                        stpp
                         000121 rs_number                   stpp
                         000122 rs_count                    stpp
                         000123 aix                         stpp
                         000124 argl                        stpp
                         000125 argno                       stpp
                         000126 i                           stpp
                         000127 nargs                       stpp
                         000130 operation                   stpp
                         000131 quota_sw                    stpp
                         000132 dummy                       stpp
                         000142 cur_charge                  stpp
                         000143 del_charge                  stpp
                         000144 disk_price                  stpp
                         000145 dollar_val                  stpp
                         000146 dummy1                      stpp
                         000147 path                        stpp
                         000221 message                     stpp
                         000273 aligned_arg                 stpp
                         000303 date                        stpp
                         000307 dir_seg                     stpp
                         000312 me                          stpp
                         000314 inc_dec                     stpp
                         000316 answer                      stpp
                         000320 argp                        stpp
                         000322 dummy_ptr                   stpp
                         000324 segp                        stpp
                         000334 query_info                  stpp
                         000366 work                        get_rs_number
                         000440 code                        get_rs_number
                         000441 sat_code                    get_rs_number
                         000442 entry                       get_rs_number
                         000452 project_entry               get_rs_number
                         000462 area_ptr                    get_rs_number
                         000464 name_ptr                    get_rs_number
                         000466 status                      get_rs_number

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              fl2_to_fx2          tra_ext             enable
ext_entry           int_entry           free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      command_query_                cu_$arg_count                 cu_$arg_ptr
cv_dec_check_                 cv_float_                     date_time_$fstime             expand_path_
get_system_free_area_         hcs_$dir_quota_read           hcs_$make_ptr                 hcs_$quota_read
hcs_$status_                  hphcs_$dir_get_reset_quota    hphcs_$get_reset_quota        ioa_
search_sat_$clean_up          search_sat_$rs_number         system_info_$max_rs_number    system_info_$prices_rs

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$badopt           error_table_$noarg            error_table_$noentry




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     70 000344        94 000352        95 000355        98 000360        99 000363       105 000365    1    6 000371
     11 000416       129 000435       130 000444       131 000446       132 000473       135 000474       136 000502
    137 000517       138 000521       139 000524       142 000525       143 000527       144 000530       145 000532
    146 000534       148 000556       149 000567       150 000570       151 000571       152 000572       155 000573
    156 000577       157 000601       158 000602       160 000603       161 000606       162 000607       164 000610
    165 000614       167 000640       168 000663       169 000665       171 000666       172 000673       173 000675
    174 000720       175 000722       176 000727       177 000753       179 000754       180 000756       183 000757
    184 000762       186 000763       190 000764       191 001000       192 001024       193 001050       194 001064
    196 001074       197 001077       200 001100       201 001102       202 001104       203 001107       204 001112
    207 001113       208 001115       209 001120       213 001121       214 001130       216 001135       217 001136
    218 001156       219 001157       221 001161       223 001166       225 001174       226 001176       227 001200
    228 001215       230 001264       231 001265       233 001320       236 001334       237 001336       238 001355
    239 001417       240 001421       241 001445       242 001446       244 001447       247 001455       249 001464
    251 001471       253 001473       258 001500       260 001504       261 001506       262 001510       265 001576
    267 001603       269 001631       270 001652       273 001704       274 001705       275 001707       276 001714
    278 001740       280 001741       281 001742       283 002012       284 002055       287 002056       295 002060
    311 002062       314 002064       315 002103       316 002113       319 002130       320 002146       321 002156
    322 002161       324 002166       325 002175       326 002241       327 002250       328 002253       329 002256
    330 002260       331 002305       332 002312       335 002315       336 002342       337 002347       338 002352
    340 002404       343 002440       344 002463


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
