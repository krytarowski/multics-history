	COMPILATION LISTING OF SEGMENT mtdsim_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/20/88  1035.7 mst Wed
	    Options: optimize map

        1 /****^  ************************************************************
        2*        *                                                          *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1983  *
        4*        *                                                          *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1980. *
        6*        *                                                          *
        7*        * Copyright (c) 1972 by Massachusetts Institute of         *
        8*        * Technology and Honeywell Information Systems, Inc.       *
        9*        *                                                          *
       10*        ************************************************************ */
       11 
       12 
       13 
       14 
       15 
       16 /* mtdsim_ - (Multics T & D Slave Interface Module) Procedure to drive the gcos T & D Modules
       17*   known as slave mode polt and slave mode molt (and eventually slave mode colt)
       18*   originally coded by J. K. Rhodes 4Q/1977
       19*   extensive modification by J. A. Bush 9/78
       20*   code added to drive slave mode molts by J. A. Bush 2/79
       21*   initial release - MR7.0A
       22*   Modified by J. A. Bush 12/79 for static mme handler and to handle new deckfile catalog format
       23*   Modified by G. Haney & R. Fakoury  80/03/24 to handle mtar
       24*   Modified by J. A. Bush 5/80 for several performance enhancements
       25*   Modified by R. Fakoury 8/80 to handle the error return of "file not found" for a MME GCALL more cleanly.
       26*   Modified by R. Fakoury 8/80 to handle dcw tally of 4096 correctly and to handle an incorrect density from rcp_.
       27*   Modified by R. Fakoury 10/80 to set lostit_time = rcp_ max timeout.
       28*   Modified by R. Fakoury 12/80 for colts implementation.
       29*   Modified by R. Fakoury 10/81 to improve the quit handler.
       30*   Modified by R. Fakoury 11/81 to attach the mpc for disk and tape mdrs.
       31*   Modified by R. Fakoury 11/81 to dump the test exec when a machine fault is en countered.
       32*   Modified by R. Fakoury 01/82 to allow more room for test colts test pages and to be more user friendly on bad test requests.
       33*   Modified by R. Fakoury 03/17/82 to redesign mme allocr handler making it more effecient.
       34*   Modified by R. Fakoury 04/82 to change mme feptype interface, to add a timer for colts attachments,
       35*   add cleanner wrapup sequences for colts attach errors, and to add eurc pr54 support.
       36*   Modified by R. Fakoury 09/30/82 to change illegal zero dcws to a valid single xfer dcw and output a message.
       37*   Modified by R. Fakoury 11/01/82 to correct problem in Colts wrap-up & add 128 chan support.
       38*   Modified by R. Fakoury 01/07/83 to increase the value of iom table words read from the fnp.
       39*   Modified by R. Fakoury 01/21/83 to change the manner the tolts gets print train image to aggree with the way the system gets it.
       40*   Modified by Rick Fakoury 03/16/83 to add a call to tolts_util_$get_ttl_date.
       41*   Modified by R. Fakoury 09/83 to correct a 128chan bug.
       42*   Modified by R. Fakoury 11/84 for hyperchan i/o.
       43*   Modified by R.Fakoury 01/84 to accept multiple args & to implement a debugger for the slave execs.
       44*   Modified by R Fakoury 04/84 to add a new field in sctcmp for DAU support, and to put a temp bypass for an ioi timing problem.
       45*   Modified by R Fakoury 09/84 to correct a problem in get_px_tcx which caused io_sel to be invalid.
       46*   Modified by R Fakoury & Benson Margulies 10/84 to correct problems encountered with new AS,
       47*   to add more debugging functions, and to use convert_status_code instead of com_err.
       48**/
       49 
       50 
       51 
       52 
       53 
       54 /****^  HISTORY COMMENTS:
       55*  1) change(85-02-01,Fakoury), approve(86-08-20,MCR7514),
       56*     audit(86-12-09,Martinson), install(86-12-09,MR12.0-1235):
       57*      implement the test nio request (Dipper/MCA) with add debug aides,
       58*      implement extented status store,
       59*      further correct a problem in get_px_tcx,
       60*      prevent returning to the subexec after a fault dump,
       61*      support of a test rsp request (responder/DN8) with added debug aides,
       62*      to dump machine conditions and history regs,
       63*      to increase the bar value,
       64*      to increase the timeout time for printer mdrs,
       65*      to correct a problem encountered while attempting an attach for colts,
       66*      to correct poorly written error messages.
       67*  2) change(86-12-18,Fakoury), approve(86-12-18,MCR7514),
       68*     audit(86-12-18,Martinson), install(86-12-19,MR12.0-1252):
       69*     PBF to correct an error in MME POINTIT that returns the IO system type.
       70*  3) change(86-12-19,Fakoury), approve(86-12-19,MCR7514),
       71*     audit(87-01-05,Martinson), install(87-01-05,MR12.0-1254):
       72*     Modified to correct a problems in MME DATA. One problem was caused by a
       73*     change in the mca driver interface and the other problem was in the trace
       74*     function.
       75*  4) change(87-01-06,Fakoury), approve(87-01-06,MCR7514),
       76*     audit(87-01-07,Martinson), install(87-01-08,MR12.0-1263):
       77*     Corrected a Colt attachment problem by increasing the no responce count,
       78*     corrected a problem in releasing the channel when a failure occurs.
       79*                                                   END HISTORY COMMENTS */
       80 
       81 
       82 
       83 
       84 
       85 
       86 /* mtdsim_ - (Multics T & D Slave Interface Module) Procedure to drive the gcos T & D Modules
       87*   known as slave mode polt and slave mode molt (and eventually slave mode colt)
       88**/
       89 
       90 
       91 /* format: style4,ifthenstmt,ifthen,ind3,ll125,lineconind1 */
       92 
       93 mtdsim_: proc;
       94 
       95 
       96 /* External entries */
       97 
       98 dcl  bcd_to_ascii_ entry (bit (*) aligned, char (*));
       99 dcl  com_err_ entry () options (variable);
      100 dcl  continue_to_signal_ entry (fixed bin (35));
      101 dcl  convert_dial_message_$return_io_module entry (fixed bin (71), char (*), char (*), fixed bin, 1 aligned,
      102       2 bit (1) unal, 2 bit (1) unal, 2 bit (1) unal, 2 bit (33) unal, fixed bin (35));
      103 dcl  convert_status_code_ entry (fixed bin (35), char (*), char (*));
      104 dcl  cpu_time_and_paging_ entry (fixed bin, fixed bin (71), fixed bin);
      105 dcl  cu_$arg_count entry (fixed bin);
      106 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      107 dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
      108 dcl  dial_manager_$privileged_attach entry (ptr, fixed bin (35));
      109 dcl  dial_manager_$release_channel entry (ptr, fixed bin (35));
      110 dcl  dial_manager_$release_channel_no_listen entry (ptr, fixed bin (35));
      111 dcl  dial_manager_$tandd_attach entry (ptr, fixed bin (35));
      112 dcl  db_fnp_eval_ entry (ptr, fixed bin, char (*), ptr, char (*), fixed bin, fixed bin (35));
      113 dcl  db_fnp_memory_$fetch entry (ptr, fixed bin, fixed bin, fixed bin, ptr, fixed bin (35));
      114 dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
      115 dcl  gload_ entry (ptr, ptr, fixed bin (18), ptr, fixed bin (35));
      116 dcl  hcs_$wakeup entry (bit (36) aligned, fixed bin (71), ptr, fixed bin (35)); /* arg 3 is suppose to be fixed bin (71) */
      117 dcl  hcs_$get_ips_mask entry (bit (36) aligned);
      118 dcl  hcs_$set_ips_mask entry (bit (36) aligned, bit (36) aligned);
      119 dcl  (ioa_, ioa_$rsnnl) entry () options (variable);
      120 dcl  ioi_$connect entry (fixed bin (12), fixed bin (18), fixed bin (35));
      121 dcl  ioi_$release_devices entry (fixed bin (12), fixed bin (35));
      122 dcl  ioi_$set_channel_required entry (fixed bin (12), fixed bin (3), fixed bin (6), fixed bin (35));
      123 dcl  ioi_$set_status entry (fixed bin (12), fixed bin (18), fixed bin (8), fixed bin (35));
      124 dcl  ioi_$suspend_devices entry (fixed bin (12), fixed bin (35));
      125 dcl  ioi_$timeout entry (fixed bin (12), fixed bin (52), fixed bin (35));
      126 dcl  ioi_$workspace entry (fixed bin (12), ptr, fixed bin, fixed bin (35));
      127 dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
      128 dcl  iox_$close entry (ptr, fixed bin (35));
      129 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
      130 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      131 dcl  iox_$get_chars entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      132 dcl  iox_$modes entry (ptr, char (*), char (*), fixed bin (35));
      133 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      134 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
      135 dcl  ioi_$connect_pcw entry (fixed bin (12), fixed bin (18), bit (36), fixed bin (35));
      136 dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
      137 dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
      138 dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
      139 dcl  ipc_$read_ev_chn entry (fixed bin (71), fixed bin, ptr, fixed bin (35));
      140 dcl  mca_$attach_ipc entry (char (*), fixed bin, fixed bin, fixed bin (35));
      141 dcl  mca_$attach_mca entry (char (*), fixed bin (71), fixed bin, fixed bin (35));
      142 dcl  mca_$detach_ipc entry (char (*), fixed bin, bit (1), fixed bin (35));
      143 dcl  mca_$detach_mca entry (fixed bin, fixed bin (35));
      144 dcl  mca_$load_ipc entry (fixed bin, fixed bin, bit (36), fixed bin (35));
      145 dcl  mca_$tandd_read_data entry (fixed bin, ptr, fixed bin, bit (36), fixed bin (35));
      146 dcl  mca_$tandd_write_data entry (fixed bin, ptr, fixed bin, bit (36), fixed bin (35));
      147 dcl  mca_$tandd_write_text entry (fixed bin, ptr, fixed bin, bit (36), fixed bin (35));
      148 dcl  mca_$reset entry (fixed bin, bit (36), fixed bin (35));
      149 dcl  opr_query_ entry () options (variable);
      150 dcl  rcp_$attach entry (char (*) aligned, ptr, fixed bin (71), char (*), bit (36) aligned, fixed bin (35));
      151 dcl  rcp_$check_attach entry (bit (36) aligned, ptr, char (*), fixed bin (12),
      152       fixed bin (19) aligned, fixed bin (71) aligned, fixed bin, fixed bin (35));
      153 dcl  rcp_$detach entry (bit (36) aligned, bit (*), fixed bin, char (*), fixed bin (35));
      154 dcl  rcp_priv_$attach entry (char (*) aligned, ptr, fixed bin (71), char (*), bit (36) aligned, fixed bin (35));
      155 dcl  probe entry options (variable);
      156 dcl  terminate_process_ entry (char (*), ptr);
      157 dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
      158 dcl  timer_manager_$sleep entry (fixed bin (71), bit (2));
      159 dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
      160 dcl  tolts_alm_util_$ascii_to_bcd_ entry (char (*), bit (*));
      161 dcl  tolts_alm_util_$enter_ccc_req_ entry (ptr, bit (36));
      162 dcl  tolts_alm_util_$enter_slave_ entry (ptr);
      163 dcl  tolts_alm_util_$gen_ck_sum entry (ptr);
      164 dcl  tolts_alrm_util_$quit entry;
      165 dcl  tolts_device_info_ entry (ptr, fixed bin, fixed bin);
      166 dcl  tolts_file_util_$close entry;
      167 dcl  tolts_file_util_$open entry (fixed bin (35));
      168 dcl  tolts_file_util_$snap entry (ptr);
      169 dcl  tolts_file_util_$wdump entry (ptr);
      170 dcl  tolts_load_firmware_ entry (fixed bin, fixed bin (35));
      171 dcl  tolts_init_ entry (char (4), fixed bin (35));
      172 dcl  tolts_init_$clean_up entry;
      173 dcl  tolts_init_$cr_event_chan entry (fixed bin (71), bit (1), entry, ptr, fixed bin, fixed bin (35));
      174 dcl  tolts_io_int_ entry;
      175 dcl  tolts_qttyio_ entry (char (*), fixed bin);
      176 dcl  tolts_qttyio_$dcw_list entry (ptr, fixed bin);
      177 dcl  tolts_qttyio_$dcw_ptr entry (ptr, fixed bin, fixed bin);
      178 dcl  tolts_qttyio_$rcw entry (ptr);
      179 dcl  tolts_qttyio_$rs entry () options (variable);
      180 dcl  tolts_util_$cata_sel entry (ptr, char (32), ptr, fixed bin (35));
      181 dcl  tolts_util_$find_card entry (char (4), ptr);
      182 dcl  tolts_init_$gc_tod entry (bit (36));
      183 dcl  tolts_util_$get_ttl_date entry (entry, char (6));
      184 dcl  tolts_util_$search entry (ptr, char (32), ptr, fixed bin, fixed bin (35));
      185 
      186 /* AUTOMATIC */
      187 
      188 dcl  bufp ptr;
      189 dcl  (nargs, return_value, c_len, n_dialed, len, tio, dealc_err, ev_occurred,
      190      i, j, mesg_len, ndcws, tally, t_err) fixed bin init (0);
      191 dcl  (chan_name, io_module) char (32);
      192 dcl  (error, c_error, mem_needed) fixed bin (35) init (0);
      193 dcl  filename_idx fixed bin;
      194 dcl  lvl_idx fixed bin;
      195 dcl  imu_found bit (1) init ("0"b);
      196 dcl  iom_found bit (1) init ("0"b);
      197 dcl  iom fixed bin (3), chan fixed bin (6), tio_off fixed bin (18), timeout_time fixed bin (52) init (0);
      198 dcl  cpu_time fixed bin (71);
      199 dcl  wake_time fixed bin (71) init (500000);
      200 dcl  mem_now fixed bin (19);
      201 dcl  (pcwa, bcd_callname, gcos_tod) bit (36);
      202 dcl  b18 bit (18);
      203 dcl  bit_buf bit (72);
      204 dcl  pad_char bit (6);
      205 dcl  sb_data_idx fixed bin;
      206 dcl  ws_data_idx fixed bin;
      207 dcl  (argptr, train_ptr, tp, cltp, t_ptr, ioe_ptr, l_ptr, gcatp, info_ptr) ptr;
      208 dcl  coment char (256), shortinfo char (8), lginfo char (100), message char (512), ac_name char (6);
      209 dcl  workspace_move char (c_len * 4) based (bufp);
      210 
      211 
      212 /* INTERNAL STATIC */
      213 
      214 dcl  (gicm_count, io_sel, isc_cntdn, last_mme, mme_number, nr_cnt) fixed bin int static init (0);
      215 dcl  (term, gndc_flag, found, gelbar, glb_brk, in_ccc, isc_ccc_rqt, mpc_io, trace_save, debug, debugging,
      216      rd_blk, flt_flag, alt_flag, q_flag, rd_flag, tcd, trace_io, trace, itr_run) bit (1) aligned int static init ("0"b);
      217 dcl  tolts_active bit (1) aligned int static init ("0"b);	/* flag for epilogue handler */
      218 dcl  db_addr fixed dec int static;
      219 dcl  exec char (4) int static;
      220 dcl  ttl_date char (6) int static;
      221 dcl  (old_mask, new_mask) bit (36) aligned int static;
      222 dcl  clt_sw char (32) varying int static;
      223 dcl  io_block_len fixed bin;
      224 dcl  (gicmp, icmp, mvp, ricmp, ticmp, wicmp) ptr int static init (null);
      225 dcl  (l, k) fixed bin (6) int static;
      226 dcl  code fixed bin (35) init (0) int static;
      227 dcl  db_sv_wd bit (36) int static;
      228 dcl  (gerout_num, icm_tally, fnp_addr, fnp_num, remote_inquiry_ic) fixed bin int static;
      229 dcl  att_desc char (40) int static;
      230 dcl  (mmep, genp) ptr int static;
      231 dcl  (arglen, n_read) fixed bin (21) int static;
      232 dcl  blk_lbl label int static;
      233 dcl  emsg char (40) int static;
      234 dcl  term_lbl label int static;
      235 dcl  no_blk label int static;
      236 
      237 /* EXTERNAL STATIC */
      238 
      239 dcl  error_table_$bad_command_name fixed bin (35) ext static;
      240 dcl  error_table_$force_unassign external fixed bin (35);
      241 dcl  error_table_$resource_unavailable external fixed bin (35);
      242 dcl  printer_images_$n_images fixed bin external;
      243 dcl  printer_images_$image_base external;
      244 dcl  printer_images_$image_offsets (10) fixed bin (18) external;
      245 dcl  printer_images_$image_numbers (10) fixed bin external;
      246 dcl  sys_info$alrm_mask bit (36) aligned ext;
      247 
      248 /* BASED */
      249 
      250 dcl  arg char (arglen) based (argptr);
      251 dcl  data_move char (c_len * 4) based (mvp);
      252 dcl  prt_image (64) char (288) based unaligned;
      253 dcl  exec_wd (0:210000) bit (36) based (execp);
      254 dcl  ioe (11) bit (36) based (ioe_ptr);
      255 dcl  reg_move bit (36 * 8) based aligned;
      256 dcl  fix_wd (2) fixed bin (18) unsigned unaligned based (genp);
      257 dcl  sctwrk (12) bit (36) based (genp);
      258 dcl  mme_call_w (0:11) bit (36) based (mmep) aligned;	/* mme call template for full words */
      259 dcl  1 mme_call_hw (0:11) based (mmep) aligned,		/* mme template for half words */
      260        (2 upper bit (18),
      261        2 lower bit (18)) unaligned;
      262 
      263 dcl  1 mme_call_hf (0:11) based (mmep) aligned,		/* mme template for fixed half words */
      264        (2 upper fixed bin,
      265        2 lower fixed bin) unaligned;
      266 
      267 /* STRUCTURES */
      268 
      269 /* The following structure declaration defines the gcos slave prefix area as used by the slave
      270*   mode execs. Only areas used by the execs have been defined, the remaining area is set to
      271*   padx. For a full description of the gcos slave prefix area, refer to gcos manual DD19. */
      272 
      273 dcl  1 spa based (execp) aligned,			/* slave prefix area, 0 - 77 of slave pgm */
      274        (2 user_fault (0:10) bit (36),			/* 0 - 12 = user settable fault vectors */
      275        2 abort,					/* 13 = used for aborting slave pgm */
      276          3 add bit (18),				/*  U = abort address */
      277          3 code bit (18),				/*  L = abort reason code */
      278        2 pad1 (5) bit (36),
      279        2 glbtmr bit (36),				/* 21 = gelbar mode timer setting */
      280        2 glbici,					/* 22 = gelbar ic and i value */
      281          3 ic bit (18),				/*  U = instruction counter value */
      282          3 ind bit (18),				/*  L = indicator register */
      283        2 glbflt bit (36),				/* 23 = gelbar fault vector */
      284        2 pad2 (3) bit (36),
      285        2 wrapup_add bit (18),				/* 27 = exec wrap up address */
      286        2 pad3 bit (18),
      287        2 pad4 bit (36),
      288        2 acc_fault bit (36),				/* 31 = accumulated fault status word */
      289        2 enter,					/* 32 = entry into exec always at this point */
      290          3 lreg bit (36),				/* 32 = "lreg  spa.regs" instruction */
      291          3 lbar,					/* 33 = "lbar  bar,du" instruction */
      292 	 4 bar bit (18),				/*  U = bar value to load */
      293 	 4 inst bit (18),				/*  L = "230203"b3 (lbar  bar,du) */
      294          3 ret bit (36),				/* 34 = "ret  spa.enter.icivlu" instruction */
      295          3 icivlu,					/* 35 = return ic and i value */
      296 	 4 ic bit (18),				/*  U = instruction counter */
      297 	 4 ind bit (18),				/*  L = indicator register */
      298        2 ccc_icivlu bit (36),				/* 36 = ic and i storage while in courtesy call */
      299        2 pad5 bit (36),
      300        2 regs like mc.regs,				/* 40 = return register storage */
      301        2 ccc_regs like mc.regs,			/* 50 = courtesy call register storage */
      302        2 pad6 (16) bit (36)) unaligned;
      303 
      304 dcl  1 fatal_desc aligned,
      305        2 version fixed bin,
      306        2 fatal_code fixed bin (35);
      307 
      308 dcl  1 ci aligned like condition_info;
      309 
      310 dcl  1 event_out static aligned like event_wait_info;
      311 
      312 dcl  1 flags aligned,
      313        2 dialed_up bit (1) unal,
      314        2 hung_up bit (1) unal,
      315        2 control bit (1) unal,
      316        2 pad bit (33) unaligned;
      317 
      318 dcl  1 cata based (io_info.catp) aligned,		/* template for deckfile catalog */
      319        2 n fixed bin,				/* number of entries */
      320        2 key (1 refer (cata.n)) char (24);		/* array of key names */
      321 
      322 dcl  1 mca_gcata (100) based (gcatp) aligned,
      323          (2 equip_type bit (36),
      324        2 cat_index fixed bin,
      325        2 nblk fixed bin (13),
      326        2 dipper_flag bit (4),
      327        2 filename,
      328          3 filename bit (48),
      329          3 diskette_prod_tab bit (12),
      330          3 prog_tab bit (12)) unaligned;
      331 
      332 
      333 dcl  1 gcata (1000) based (gcatp) aligned,		/* template for a gcos catalog entry */
      334        (2 edit_rev bit (36),				/* bcd edit name and rev */
      335        2 cat_index fixed bin,				/* deckfile catalog index */
      336        2 pad1 bit (3),
      337        2 nblk fixed bin (14),				/* (same as cat_index) */
      338        2 ident bit (36),				/* word 0 of ident blk */
      339        2 purpose bit (36)) unaligned;			/* deck purpose (itr, mdr or fw) */
      340 
      341 /* The following structure declaration defines the gcos 11 word I/O  entry  as  used  by  the
      342*   slave  mode  execs.  Only areas used by the execs have been defined, the remaining area is
      343*   set to padx. For a full description of the gcos I/O entry, refer to gcos manual DD14. */
      344 
      345 dcl  1 io_entry based (ioe_ptr) aligned,		/* :: */
      346        (2 pad1 bit (36),				/* word 0 unused */
      347        2 ext_sts fixed bin,				/* extented status address */
      348        2 pad2 bit (18),
      349        2 pad3 bit (5),
      350        2 sct_add bit (13),				/* system config table entry (test page index) */
      351        2 pad4 bit (18),
      352        2 pad5 bit (36),
      353        2 prim,					/* primary device info */
      354          3 dev_cmd bit (6),				/* device command */
      355          3 dev bit (6),				/* punch indicator if not "00"b3 */
      356          3 pad6 bit (6),
      357          3 io_cmd bit (6),				/* iom command */
      358          3 pad7 bit (6),
      359          3 record_count bit (6),			/* idcw/pcw record count */
      360        2 first_dcw like dcw,				/* first dcw relative to iom lal */
      361        2 pad8 bit (36),
      362        2 second,					/* secondary device info (the same as prim unless dual cmd) */
      363          3 dev_cmd bit (6),				/* device command */
      364          3 prex bit (12),				/* preselect index */
      365          3 io_cmd bit (6),				/* iom command */
      366          3 pad9 bit (5),
      367          3 ignore_term bit (1),			/* ignore terminate int, report special int if on */
      368          3 record_count bit (6),			/* idcw/pcw record count */
      369        2 dcw_ptr fixed bin,				/* pointer to dcw list (offset to lal) */
      370        2 pad10 bit (18),
      371        2 stat_p bit (18),				/* ptr to place to store status */
      372        2 ccc_p bit (18),				/* courtesy call ptr */
      373        2 pad11 bit (36)) unaligned;
      374 
      375 dcl  1 colts_op_flags aligned ext static,
      376        2 colt_flag bit (1) unaligned init ("0"b),
      377        2 dm_attach bit (1) unaligned init ("0"b),
      378        2 dm_detach bit (1) unaligned init ("0"b),
      379        2 sicm bit (1) unaligned init ("0"b),
      380        2 gicm bit (1) unaligned init ("0"b);
      381 
      382 dcl  1 gicm based (gicmp) aligned,
      383        2 cltp ptr init (null),
      384        2 ricmp ptr init (null),
      385        2 cc_addr bit (36),
      386        2 st_addr fixed bin,
      387        2 tally fixed bin (21);
      388 
      389 
      390 dcl  1 ricm like icm based (ricmp);
      391 dcl  1 wicm like icm based (wicmp);
      392 dcl  1 ticm like icm based (ticmp);
      393 dcl  1 icm based (icmp) aligned,
      394        (2 word_total bit (18),
      395        2 rbuf_addr bit (18),
      396        2 cksum bit (18),
      397        2 test_id bit (18),
      398        2 host_opcode bit (18),
      399        2 fnp_opcode bit (18),
      400        2 icm_buf (icm_tally) bit (36)) unaligned;
      401 
      402 dcl  1 info_struct based (info_ptr) aligned,
      403        2 ev_chan fixed bin (71),
      404        2 out_pend bit;
      405 
      406 
      407 /* constants */
      408 
      409 dcl  (quit, lockup, illop, illegal_modifier, illegal_opcode, illegal_procedure,
      410      store, program_interrupt, cleanup, tolts_error_) condition;
      411 dcl  (addr, addrel, bin, bit, divide, fixed, index, length, null, rel, rtrim, string, substr, time, unspec) builtin;
      412 
      413 /* enviornment initialization */
      414 
      415       debug, debugging, q_flag, trace_io, trace = "0"b;
      416       exec = "";
      417       call cu_$arg_count (nargs);
      418       call cu_$arg_ptr (1, argptr, arglen, code);
      419       if arg ^= "polt" & arg ^= "molt" & arg ^= "colt" then do; /* invalid executive */
      420          call com_err_ (0, "mtdsim_", "Invalid executive code - ""^a""", exec); /* tell user */
      421          return;
      422       end;
      423       exec = arg;
      424       term = "0"b;
      425       if nargs > 1 then do;
      426          do i = 2 to nargs;
      427 	  call cu_$arg_ptr (i, argptr, arglen, code);
      428 	  if arg = "-debug" | arg = "-db" then debug = "1"b;
      429 
      430 	  else if arg = "-quit" | arg = "-q" then q_flag = "1"b; /* user wants to return to command level on quits  */
      431 
      432 	  else if arg = "-trace" | arg = "-tc" then trace = "1"b; /* user wants mme trace */
      433 	  else if arg = "-trace_cata_data" | arg = "-tcd" then tcd = "1"b;
      434 	  else if arg = "-tio" then trace_io = "1"b;
      435 	  else if arg = "-probe" | arg = "-pb" then call probe (mtdsim_);
      436          end;
      437          debugging = "1"b;
      438       end;
      439 
      440 
      441       last_mme, isc_cntdn, tio = 0;
      442       trace_save, in_ccc, isc_ccc_rqt, rd_blk, gelbar, glb_brk, itr_run = "0"b; /* reset flags */
      443       gicm_count = 0;
      444       gicmp, ricmp, ticmp, wicmp = null;		/* initialize colts pointers */
      445       call tolts_init_ (exec, error);			/* go init our enviornment and create slave seg */
      446       if error ^= 0 then return;			/* if error durring init */
      447       on cleanup call clean_up;			/* establish cleanup handler */
      448       gndc_flag = "0"b;				/* flag to prevent recursive courtsey calls */
      449       call tolts_util_$get_ttl_date (mtdsim_, ttl_date);
      450       tolts_active = "1"b;				/* set active flag for epilogue handler */
      451 
      452 /* search for <exec>cm in file system (exec can be polt, molt, or colt) */
      453 
      454       call tolts_util_$search (tolts_info.df_iocbp, substr (exec, 1, 1) || "lt." || exec || "cm", t_ptr, c_len, error);
      455       if error ^= 0 then do;				/* if couldn't find cplt */
      456          call com_err_ (error, exec, "searching for ^alt.^acm", substr (exec, 1, 1), exec);
      457          call tolts_init_$clean_up;			/* go delete our event channels and slave seg */
      458          return;
      459       end;
      460       call gload_ (t_ptr, execp, 0, addr (gload_data), error); /* load core image into our work segment */
      461       if error ^= 0 then do;				/* problem durring load */
      462          call com_err_ (error, exec, "^a^/attempting to load ^alt.^acm",
      463 	gload_data.diagnostic, substr (exec, 1, 1), exec);
      464          call tolts_init_$clean_up;			/* go delete our event channels and slave seg */
      465          return;
      466       end;
      467 
      468       if debugging then call ioa_ (" execp = ^p", execp);
      469 
      470       if debug then do;
      471          debug = "0"b;
      472          tolts_info.mult_ans = "";			/* clear out response */
      473 db_query:
      474          call tolts_qttyio_$rs (19, "tolts_debugger: enter break point address");
      475          call message_wait;				/* wait for user response */
      476          if mult_ans ^= "" then do;
      477 	  db_addr = cv_oct_check_ ((rtrim (mult_ans)), code);
      478 	  if code ^= 0 | db_addr > 65535 then do;
      479 	     call ioa_ ("Debugger: invalid address supplied");
      480 	     goto db_query;
      481 	  end;
      482 	  db_sv_wd = exec_wd (db_addr);
      483 	  exec_wd (db_addr) = "777650001000"b3;
      484          end;
      485       end;
      486 
      487 
      488       blk_lbl = block_disp;
      489       term_lbl = done;
      490       no_blk = no_blk_disp;
      491       spa.enter.lreg = rel (addr (spa.regs)) || "073200"b3; /* set lreg instruction  (lreg  spa.regs) */
      492       if exec = "molt" then string (spa.enter.lbar) = "000630230203"b3; /* set initial lbar instruction (lbar =o630,du) */
      493       else string (spa.enter.lbar) = "000201230203"b3;	/* set initial lbar instruction (lbar =o200,du) */
      494       spa.enter.ret = rel (addr (spa.enter.icivlu)) || "630200"b3; /* set return instruction (ret  spa.enter.icivlu) */
      495       spa.enter.icivlu.ic = gload_data.definition (1).offset; /* set initial entry point */
      496       spa.enter.icivlu.ind = "0"b;			/* initial entry indicators are zero */
      497       on lockup begin;
      498          call ioa_ ("^a encountered a lockup fault ^[a dump will be taken^]", exec, ^flt_flag);
      499          if ^flt_flag then call fault_dump;
      500          else call continue_to_signal_ (error);
      501       end;
      502       on illop begin;
      503          call ioa_ ("^a encountered a illop fault ^[a dump will be taken ^]", exec, ^flt_flag);
      504          if ^flt_flag then call fault_dump;
      505          else call continue_to_signal_ (error);
      506       end;
      507       on illegal_modifier begin;
      508          call ioa_ ("^a encountered an illegal_modifier fault ^[a dump will be taken ^]", exec, ^flt_flag);
      509          if ^flt_flag then call fault_dump;
      510          else call continue_to_signal_ (error);
      511       end;
      512       on illegal_opcode begin;
      513          call ioa_ ("^a encountered an illegal_opcode fault ^[a dump will be taken ^]", exec, ^flt_flag);
      514          if ^flt_flag then call fault_dump;
      515          else call continue_to_signal_ (error);
      516       end;
      517       on illegal_procedure begin;
      518          call ioa_ ("^a encountered an illegal_procedure fault ^[a dump will be taken ^]", exec, ^flt_flag);
      519          if ^flt_flag then call fault_dump;
      520          else call continue_to_signal_ (error);
      521       end;
      522       on store begin;
      523          call ioa_ ("^a encountered a store fault ^[a dump will be taken ^]", exec, ^flt_flag);
      524          if ^flt_flag then call fault_dump;
      525          else call continue_to_signal_ (error);
      526       end;
      527       on tolts_error_ begin;
      528          call probe (mtdsim_);
      529          call clean_up;
      530       end;
      531 
      532       on quit begin;				/* establish quit handler */
      533          if ^q_flag then				/* if normal operation */
      534 	  call tolts_alrm_util_$quit;
      535          else call continue_to_signal_ (error);
      536       end;
      537       on program_interrupt begin;			/* establish pi handler for debugging */
      538          call hcs_$wakeup (tolts_info.process, tolts_info.quith_event, null, error);
      539       end;
      540       call tolts_qttyio_ ("??? ", 9);			/* exec read for original data */
      541 
      542 /* this is the main program dispatcher */
      543 
      544       term = "0"b;					/* reset terminate condition */
      545       do while (^term);				/* loop until we are done */
      546 block_disp:					/* target of nonlocal gotos */
      547          call ipc_$block (addr (tolts_info.wait_list), addr (event_out), error);
      548          if error ^= 0 then do;			/* this is a fatal error, terminate our process */
      549 	  call com_err_ (error, exec, "*** fatal error, terminating process"); /* tell users first */
      550 	  fatal_desc.version = 0;
      551 	  fatal_desc.fatal_code = error;
      552 	  if ^debugging then
      553 	     call terminate_process_ ("fatal_error", addr (fatal_desc));
      554 	  else signal tolts_error_;
      555          end;					/* no need to return, as we won't be back */
      556          if tolts_info.wait_list.nchan > 1 then do;	/* if we are waiting for > 1 event */
      557 	  if event_out.channel_id ^= wait_list.wait_event_id (2)
      558 	   | event_out.channel_id ^= tolts_info.dm_event
      559 	  then do;				/* if the wake up is not for the second channel */
      560 	     ev_occurred = 0;			/* initialize in case code ^= 0 */
      561 	     call ipc_$read_ev_chn (wait_list.wait_event_id (2),
      562 	      ev_occurred, addr (event_out), code);	/* check and see if the second channel is ready */
      563 	     if code ^= 0 then do;
      564 	        call com_err_ (code, exec, "Error calling ipc_$read_ev_chn");
      565 	        if debugging then signal tolts_error_;
      566 	     end;
      567 	     if ev_occurred ^= 1 then do;
      568 	        if nr_cnt < 20 then do;
      569 		 if debugging then call ioa_ ("nr_cnt = ^d", nr_cnt);
      570 		 wake_time = 500000;
      571 		 call timer_manager_$sleep (wake_time, "10"b);
      572 		 nr_cnt = nr_cnt + 1;
      573 		 call wake_disp;			/* if the second channel hasn't awaken then wait */
      574 	        end;
      575 	        else do;
      576 		 if substr (clt_sw, 3, 4) = "c000" then do; /* if exec chan - wrapup */
      577 		    call tolts_qttyio_$rs (0, "^as: timeout error attempting attach of ^a",
      578 		     tolts_info.exec, clt_sw);	/* notify the user */
      579 		    call tolts_abort ("$c1");		/* then abort colts */
      580 		 end;
      581 		 else do;
      582 		    call rel_tst_chan (l);
      583 		    colts_pages (l).in_use = "0"b;	/* reset test page active */
      584 		    call tolts_qttyio_$rs (0, "^as:  timeout error attempting a tandd_attach of ^a",
      585 		     tolts_info.exec, substr (colts_pages (l).cdt_name, 1, 6));
      586 		    colts_op_flags.colt_flag = "0"b;	/* make use flag is reset so we don't go blocked */
      587 		    colts_op_flags.sicm = "0"b;
      588 		    colts_op_flags.dm_attach = "0"b;
      589 		    if mme_call_hf (2).lower ^= 0 then do; /* cc requested */
      590 		       exec_wd (mme_call_hf (2).upper) = "000000000004"b3; /* store error status */
      591 		       call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
      592 		        (mme_call_hw (2).lower || "000000"b3)); /* enter cc request */
      593 		    end;
      594 		    colts_pages (l).status_word = "000000000002"b3; /* test channel - store status */
      595 		 end;
      596 	        end;
      597 	     end;
      598 	  end;
      599 	  tolts_info.wait_list.nchan = tolts_info.wait_list.nchan - 1; /* else decrement the wait list */
      600 	  chan_name, io_module = "";
      601 	  n_dialed = 0;
      602 	  flags = ""b;
      603 	  call convert_dial_message_$return_io_module (event_out.message,
      604 	   chan_name, io_module, n_dialed, flags, code);	/* convert the message into flags */
      605 	  if code ^= 0 then do;
      606 	     call ioa_$rsnnl ("error attaching channel ^a", emsg, mesg_len, chan_name);
      607 	     call output_status_code (code, emsg);
      608 	  end;
      609 	  if trace_io then
      610 	     call ioa_ ("Channel ^a, IO Module ^a, N_dialed ^d, flags^[ dialed_up^]^[ hung_up^]^[ control^]",
      611 	      chan_name, io_module, n_dialed, flags.dialed_up, flags.hung_up, flags.control);
      612 
      613 	  if flags.control				/* if control flag then error */
      614 	   | (^flags.control			/* or an informative message */
      615 	   & ^flags.dialed_up & ^flags.control) then do;	/* with no information */
      616 
      617 	     if substr (clt_sw, 3, 4) = "c000" then do;	/* if exec chan - wrapup */
      618 	        call tolts_qttyio_$rs (0, "^as: control error attempting dial_manager_attach of ^a",
      619 	         tolts_info.exec, substr (clt_sw, 1, 6)); /* notify user */
      620 	        call tolts_abort ("$c0");		/* then abort colts */
      621 	     end;
      622 	     else do;
      623 	        call rel_tst_chan (l);
      624 	        colts_pages (l).in_use = "0"b;		/* reset test page active */
      625 	        call tolts_qttyio_$rs (0, "^as:  control error attempting a tandd_attach of ^a",
      626 	         tolts_info.exec, substr (colts_pages (l).cdt_name, 1, 6));
      627 	        colts_op_flags.colt_flag = "0"b;	/* make use flag is reset so we don't go blocked */
      628 	        colts_op_flags.sicm = "0"b;
      629 	        colts_op_flags.dm_attach = "0"b;
      630 	        if mme_call_hf (2).lower ^= 0 then do;	/* cc requested */
      631 		 exec_wd (mme_call_hf (2).upper) = "000000000002"b3; /* store error status */
      632 		 call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
      633 		  (mme_call_hw (2).lower || "000000"b3)); /* enter cc request */
      634 	        end;
      635 	        colts_pages (l).status_word = "000000000002"b3; /* else test channel - store status */
      636 	     end;
      637 	  end;
      638 
      639 	  if flags.dialed_up & colts_op_flags.dm_attach then do; /* if the channel is dialed attaching */
      640 	     call iox_$attach_name ((clt_sw), cltp, att_desc, null, code); /* create an io switch */
      641 	     if code ^= 0 then goto sw_err;		/* if error */
      642 	     call iox_$open (cltp, 3, "0"b, code);	/* open a switch */
      643 	     if code ^= 0 then goto sw_err;		/* if error */
      644 	     call iox_$modes (cltp, "rawi,rawo", "", code); /* now set the modes for the channel */
      645 	     if code ^= 0 then do;			/* if error */
      646 sw_err:	        if substr (clt_sw, 3, 4) = "c000" then do;/* if exec channel - wrapup */
      647 		 call convert_status_code_ (code, shortinfo, lginfo); /* convert the status code */
      648 		 call tolts_qttyio_$rs (0, "^as: ^a/ attempting a switch operation for ^a",
      649 		  tolts_info.exec, lginfo, clt_sw);	/* and notify the user */
      650 		 call tolts_abort ("$c1");		/* then abort colts */
      651 	        end;
      652 	        else do;
      653 		 colts_pages (l).status_word = "000000000002"b3; /* else test channel - store status */
      654 		 colts_pages (l).in_use = "0"b;
      655 	        end;
      656 	     end;
      657 	     if code = 0 then do;
      658 	        if substr (clt_sw, 3, 4) = "c000" then do;/* if exec channel */
      659 		 tolts_info.fnp (k).exec_active = "1"b; /* set exec active */
      660 		 fnp (k).fnp_execp = cltp;		/* save iocb ptr */
      661 		 exec_wd (remote_inquiry_ic) = "0000000500"b3 || "1"b
      662 		  || substr (bit (k), 2, 5);		/* answer remote inquiry request */
      663 	        end;
      664 	        else do;				/* else a test channel */
      665 		 colts_pages (l).chanp = cltp;	/* save iocb ptr */
      666 		 colts_pages (l).status_word = "000000000004"b3; /* store good status */
      667 		 exec_wd (remote_inquiry_ic) = "0000000500"b3 || "0"b
      668 		  || substr (bit (l), 2, 5);		/* answer remote inquiry request */
      669 	        end;
      670 	        colts_op_flags.colt_flag = "0"b;	/* reset colts flag */
      671 	        colts_op_flags.dm_attach = "0"b;	/* reset dial_manager attach flag */
      672 	        remote_inquiry_ic = 0;		/* reset remote inquiry ic */
      673 	     end;
      674 	  end;
      675          end;
      676 
      677          if colts_op_flags.sicm then do;		/* if an icm need to be sent to the fnp */
      678 	  call iox_$put_chars (fnp (k).fnp_execp, wicmp, (bin (wicm.word_total) + 1) * 4, code); /* send it */
      679 	  if code ^= 0 then do;			/* if error */
      680 	     call convert_status_code_ (code, shortinfo, lginfo);
      681 	     call tolts_qttyio_$rs (0, "^as: ^a/ error on data xfer to fnp colt exec ^a",
      682 	      tolts_info.exec, lginfo, fnp (k).fnp_execp);
      683 	     call tolts_abort ("$c1");		/* then abort colts */
      684 	  end;
      685 	  gicmp = addr (gicm);			/* else get ptr for return icm */
      686 	  gicm_count = gicm_count + 1;		/* inc position in the queue */
      687 
      688 	  if gicm_count = 17 then do;			/* if 17 - error */
      689 	     call tolts_qttyio_$rs (0, "^as: execessive outstanding io's", tolts_info.exec);
      690 	     call tolts_abort ("$c2");		/* abort colts */
      691 	  end;
      692 	  gicm.cltp = fnp (k).fnp_execp;		/* save iocb ptr */
      693 	  gicm.ricmp = ricmp;			/* rtrn icm ptr */
      694 	  gicm.tally = bin (wicm.word_total) + 1;	/* tally */
      695 	  if mme_call_hf (2).lower ^= 0 then do;	/* cc requested */
      696 	     gicm.cc_addr = mme_call_hw (2).lower || "000000"b3; /* save cc address */
      697 	     gicm.st_addr = mme_call_hf (2).upper;	/* save status address */
      698 	  end;
      699 	  colts_op_flags.sicm = "0"b;			/* reset send icm flag */
      700          end;
      701 
      702          if tolts_info.special_fault then do;		/* special int. fault from tolts_io_int_ */
      703 	  tolts_info.special_fault = "0"b;
      704 	  call tolts_abort ("$b6");
      705          end;
      706          else if tolts_info.exec_term_io_wait then term = "1"b; /* we are all done */
      707          else if tolts_info.first_request_done then do;	/* if we have something to do... */
      708 no_blk_disp:					/* target of non-local gotos */
      709 	  if gicm_count ^= 0 then do;			/* if outstanding icm */
      710 	     alloc info_struct;			/* alloc an info struct */
      711 	     info_ptr = addr (info_struct);		/* get its ptr */
      712 
      713 	     if gicm.cltp ^= null then do;		/* if slot is in use */
      714 	        call iox_$control (gicm.cltp, "read_status", info_ptr, code); /* read the status */
      715 	        if info_struct.out_pend then do;	/* output ready */
      716 		 call iox_$get_chars (gicm.cltp, gicm.ricmp, gicm.tally * 4, n_read, code); /* get the icm */
      717 		 if code ^= 0 then do;		/* if error */
      718 		    call convert_status_code_ (code, shortinfo, lginfo);
      719 		    call tolts_qttyio_$rs (0, "^as: ^a/ error on data xfer from fnp", tolts_info.exec, lginfo);
      720 		    call tolts_abort ("$c1");		/* then abort colts */
      721 		 end;
      722 		 if gicm.cc_addr ^= "0"b3 then do;	/*  if a courtesy call requested */
      723 		    if fnp (k).fnp_execp = gicm.cltp then
      724 		       exec_wd (gicm.st_addr) = fnp (k).status_word;
      725 		    else exec_wd (gicm.st_addr) = colts_pages (l).status_word;
      726 		    call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
      727 		     (gicm.cc_addr));		/* enter ccc request */
      728 		 end;
      729 		 gicm_count = gicm_count - 1;		/* dec the count */
      730 		 gicm.cltp = null;			/* open up the slot */
      731 		 gicm.ricmp = null;
      732 		 if gicm_count = 0
      733 		 then do;				/* delete unused gicms */
      734 		    free gicm;
      735 		    gicmp = null;
      736 		 end;
      737 	        end;
      738 	     end;
      739 
      740 	     free info_struct;			/* free the info structure */
      741 	  end;
      742 
      743 	  if isc_ccc_rqt then do;			/* if outstanding inter slave read ... */
      744 	     if tolts_info.exec_dta_cnt = 0 then isc_cntdn = isc_cntdn - 1; /* but no data to xfer yet ... */
      745 	     if isc_cntdn = 0 | tolts_info.exec_dta_cnt ^= 0 then do; /* if timeout or isc data avail */
      746 	        isc_ccc_rqt = "0"b;			/* reset isc courtesy call flag and enter courtesy call */
      747 	        call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue), (isc_queue.icivlu));
      748 	        exec_wd (isc_queue.status_add + 1) = "0"b;/* dcw residue = zero */
      749 	        if tolts_info.exec_dta_cnt = 0 then	/* if no data to xfer... */
      750 		 exec_wd (isc_queue.status_add) = "400006000000"b3; /* set status to timeout */
      751 	        else call pop_isc (isc_queue.status_add, isc_queue.data_add); /* data to xfer */
      752 	     end;
      753 	  end;
      754 	  if ^in_ccc & ^gndc_flag then		/* if not in ccc */
      755 	     if tolts_info.ccc_requests ^= 0 & ^gelbar then do; /* pay courtesy call first */
      756 	        unspec (spa.ccc_regs) = addr (spa.regs) -> reg_move; /* move current regs into safe store */
      757 	        spa.ccc_icivlu = string (spa.enter.icivlu);
      758 	        string (spa.enter.icivlu) = tolts_info.ccc_queue (1).icivlu;
      759 	        tolts_info.ccc_requests = tolts_info.ccc_requests - 1; /* decrement count */
      760 	        do i = 1 to tolts_info.ccc_requests;
      761 		 tolts_info.ccc_queue.icivlu (i) = tolts_info.ccc_queue.icivlu (i + 1); /* move queue down */
      762 	        end;
      763 	        in_ccc = "1"b;
      764 	     end;
      765 	     else if rd_blk then do;			/* road blocked? */
      766 	        if isc_ccc_rqt then call wake_disp;	/* wakeup dispatcher */
      767 	        rd_blk = "0"b;
      768 	     end;
      769 	  if trace | (trace_save & in_ccc) then		/* if tracing mmes and dispatches */
      770 	     call tolts_qttyio_$rs (10,
      771 	      "^a ^a ^12.3b^[, ^a^;^s^]^[, ^a ^6.3b^;^2s^]^[, ^a ^a ^12.3b, ^a ^12.3b^]",
      772 	      ctime (), "Dispatch to ici -", string (spa.enter.icivlu), in_ccc,
      773 	      "in courtesy call", gelbar, "in gelbar, BAR -", spa.enter.lbar.bar, glb_brk,
      774 	      "gelbar break,", "gb ici -", string (spa.glbici), "gbfv -", spa.glbflt);
      775 	  glb_brk = "0"b;				/* reset gelbar break indicator if set */
      776 	  gndc_flag = "0"b;
      777 	  if ^flt_flag then
      778 	     call tolts_alm_util_$enter_slave_ (addr (spa.enter)); /* enter slave program */
      779          end;
      780 done:						/* target of nonlocal goto */
      781       end;
      782       if ^tolts_active then return;
      783       tolts_info.exec_term_io_wait = "1"b;		/* make sure we quit */
      784       call clean_up;				/* go cleanup our enviornment */
      785       return;					/* and return  to tolts command level */
      786 
      787 
      788 /* mme_fault - static condition handler for GCOS type mme faults */
      789 
      790 mme_fault: entry (mcptr, cname, tptr1, tptr2, tcont);
      791 
      792 dcl  (mcptr, tptr1, tptr2) ptr;
      793 dcl  cname char (*);
      794 dcl  tcont bit (1);
      795 dcl  tags (1:8) char (1) static options (constant) init
      796       ("a", "b", "c", "d", "e", "f", "g", "h");
      797 dcl  fnp_state (0:4) char (7) static options (constant) init
      798       ("free   ", "unknown", "down   ", "booting", "up     ");
      799 
      800 
      801       mcp = mcptr;					/* get ptr to machine conditions */
      802       scup = addr (mc.scu);				/* get ptr to scu data */
      803       unspec (spa.regs) = addr (mc.regs) -> reg_move;	/* save the processor regs */
      804       spa.enter.icivlu.ind = string (scu.ir);
      805 
      806       if gelbar then				/* if in gelbar mode, pass fault on to gcos module */
      807          call set_gelbar;				/* we want return from this call */
      808       mmep = addrel (execp, scu.ilc);			/* set mme call ptr */
      809 
      810       if substr (mme_call_w (0), 19, 10) ^= "0000000010"b then /* if not mme1 instruction... */
      811          go to undefm;
      812 
      813       if in_ccc then
      814          if mme_call_hw (0).upper ^= "000016"b3 then do;
      815 	  call tolts_qttyio_$rs (0, "^as: Illegal mme in ccc  (^12.3b) @ ^p",
      816 	   exec, mme_call_w (0), mmep);
      817 	  call tolts_abort ("$a4");
      818          end;
      819       mme_number = mme_call_hf (0).upper;
      820       if (mme_number < -127 | mme_number > 31)		/* if out of legal range */
      821        | (mme_number < -66 & mme_number > -87)
      822        | (mme_number < -94 & mme_number > -127) then
      823          go to undefm;
      824       if trace | trace_save then do;			/* if tracing mmes and dispatches */
      825          if trace then do;				/* if currently tracing */
      826 	  if (mme_number = -1 & last_mme = -39)
      827 	   | (mme_number = -39 & last_mme = -1)
      828 	   | mme_number = last_mme then do;		/* do not display idle loop */
      829 	     trace_save = "1"b;			/* save state and turn trace off */
      830 	     trace = "0"b;				/* idle loop */
      831 	  end;
      832          end;
      833          else if mme_number ^= last_mme then do;		/* if idle loop has ended */
      834 	  trace = "1"b;				/* turn back on trace */
      835 	  trace_save = "0"b;
      836          end;
      837       end;
      838       last_mme = mme_number;				/* save mme number for nxt time */
      839       go to mme_typ (mme_number);			/* process gcos mme */
      840 
      841 /* ********* MME ABSTIM ********* (absolute time)
      842*
      843*   input registers: none
      844*
      845*   mme     abstim
      846*   ------  return
      847*
      848*   return registers: AR = time of day, 1/64 ms. since midnight */
      849 
      850 mme_typ (-1): if trace then call tolts_qttyio_$rs (10, "^a MME ABSTIM @ ^p", ctime (), mmep);
      851       call tolts_init_$gc_tod (spa.regs.a);		/* get current time of day */
      852       call return_plus (1);
      853 
      854 /* ********* MME ACCWRT ********* (accounting file write, unused in Multics)
      855*
      856*   input registers:   x1 -> message address
      857*
      858*   mme     accwrt
      859*   ------  return
      860*
      861*   return registers: none */
      862 
      863 mme_typ (-2): if trace then call tolts_qttyio_$rs (10, "^a MME ACCWRT @ ^p", ctime (), mmep);
      864       call return_plus (1);
      865 
      866 /* ********* MME ASGPAT ********* (assign peripheral allocation table, unused in Multics)
      867*
      868*   input registers:   X1 = sct (test page index mod 4),   X4 = pat address (lal offset)
      869*
      870*   mme     asgpat
      871*   ------  return
      872*
      873*   return registers: X2 = sct word 1 (returned = 0) */
      874 
      875 mme_typ (-5): if trace then call tolts_qttyio_$rs (10, "^a MME ASGPAT @ ^p", ctime (), mmep);
      876       spa.regs.x (2) = "0"b;				/* set # modules to zero */
      877       call return_plus (1);
      878 
      879 /* *********************************************************************************
      880*   *   alternate mtar device is defined as  "alt sct addr = (page index) *4 + 512   *
      881*   ********************************************************************************* */
      882 
      883 /* ********* MME ALLOCR ********* (allocate peripheral)
      884*
      885*   input registers:   x1 = sct (test page index mod 4)
      886*   x3 = chan number if new format
      887*
      888*   mme	allocr
      889*   zero	ficcdd,delaysct			ficcdd ptr, sct value if delayed allocation
      890*   zero	sctwrk,mtardata	                    ficcdd ptr to sct work area.
      891*   mtardata is storage for (even) mtar r/w flag (molts only)
      892*   zero	alcflg,0				ptr to alcflg
      893*   zero	alcccp,dldcwp			ptr to courtesy call routine, ptr to dcw for delayed allocation message
      894*   ----	return error 			(mme call + 5)
      895*   ----	return ask stranger permission	(mme call + 6)
      896*   ----	return not free			(mme call + 7)
      897*   ----	return allocated or usage count bumped	(mme call + 8)
      898*   ----	return shared device		(mme call + 9)
      899*   ----	return allocation in progress, wait	(mme call + 10)
      900*
      901*   return registers:	X2 = error code on error (see set_sctwrk subroutine for error codes)
      902*   *			output in sctwrk (12 words): see the set_sctwrk subroutine */
      903 
      904 mme_typ (-4): if trace then call tolts_qttyio_$rs (10, "^a MME ALLOCR @ ^p", ctime (), mmep);
      905       call get_px_sct ("ALLOCR", bin (spa.regs.x (1), 17), "0"b); /* get test page index */
      906       call set_sctwrk (io_sel);			/* go set up the sct work area */
      907       if spa.regs.x (2) ^= "0"b then do;		/* if some error from tolts_device_info_... */
      908          if fixed (spa.regs.x (2)) = m_iv_iom then	/* if invalid IOM number... */
      909 	  spa.regs.x (2) = "0"b;			/* correct error code */
      910          call return_plus (5);			/* take error return */
      911       end;
      912       io_info_ptr = addr (pages (io_sel));		/* get ptr to this test page */
      913 
      914 /* create an event call channel for tdio status events */
      915 
      916       if ^io_info.ev_ch_ass then do;			/* we we havn't done this already */
      917          call tolts_init_$cr_event_chan (io_info.status_event,
      918 	"1"b, tolts_io_int_, io_info_ptr, 2, error);
      919          if error ^= 0 then				/* if error creating event call chan */
      920 	  call tolts_abort ("$a9");
      921          io_info.ev_ch_ass = "1"b;			/* set event chan assigned flag */
      922       end;
      923 
      924       if mme_call_hf (1).lower = 0 then do;		/* if we havn't already attached perp... */
      925          alt_flag, rd_flag = "0"b;			/* make sure we start in a known state */
      926          if io_info.devsct.type_code = "22"b3		/* if ccu as a reader */
      927 	& ^io_info.ccu_pun then rd_flag = "1"b;		/* set read flag */
      928          if ^io_info.alloc_wait & ^io_info.p_att then do;
      929 
      930 	  if io_info.io_type = mca_io_type
      931 	   & io_info.mca_attach_state = MCA_NOT_CONFIGURED then do;
      932 	     call mca_$attach_mca ((io_info.device_name), io_info.status_event,
      933 	      io_info.mca_ioi_idx, error);
      934 	     io_info.mca_attach_state = MCA_FREE;
      935 	  end;
      936 	  else do;
      937 
      938 attach:	     if ^alt_flag then do;			/* if we want the primary or only channel */
      939 	        call ioa_$rsnnl ("T&D is attaching for a ^[write^]^[read^] ^a",
      940 	         att_desc, mesg_len, (^rd_flag), (rd_flag), io_info.device_name);
      941 	        call rcp_priv_$attach (io_info.rcp_name, addr (io_info.rcp_area (1)), io_info.status_event,
      942 	         att_desc, io_info.rcp_id, error);
      943 	     end;
      944 	     else do;
      945 	        call ioa_$rsnnl ("T&D is attaching for a ^[write^]^[read^] ^a",
      946 	         att_desc, mesg_len, (^rd_flag), (rd_flag), io_info.alt_device_name);
      947 	        call rcp_priv_$attach (io_info.rcp_name, addr (io_info.alt_rcp_area (1)), io_info.status_event,
      948 	         att_desc, io_info.alt_rcp_id, error);
      949 	     end;
      950 
      951 	     if error ^= 0 then do;
      952 	        call output_status_code (error, "rcp attach error");
      953 	        call dealcp_sub;			/* go release status event */
      954 	        spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
      955 	        call return_plus (5);			/* take error return */
      956 	     end;
      957 	     if ^alt_flag then
      958 	        call rcp_$check_attach (io_info.rcp_id, addr (io_info.rcp_area (1)), coment, io_info.device_index,
      959 	         tolts_info.max_wks_sz, tolts_info.max_to, io_info.rcp_state, io_info.attach_err);
      960 	     else call rcp_$check_attach (io_info.alt_rcp_id, addr (io_info.alt_rcp_area (1)), coment,
      961 		 io_info.alt_device_index, tolts_info.max_wks_sz,
      962 		 tolts_info.max_to, io_info.rcp_state, io_info.attach_err);
      963 
      964 	  end;
      965          end;
      966       end;
      967 
      968 /* only one call to rcp_$check_attach here. If delayed allocation (tape or disk),  RCP  will  signal
      969*   (via  the  status call channel) tolts_io_int_, when an event has ocurred. tolts_io_int_ will check the
      970*   rcp state flag and either return and let RCP work if attachment is incomplete or enter the  courtesy
      971*   call request and signal the dispatcher if the attachment is complete or if an error has occurred */
      972 
      973 /* *********************************************
      974*   *   check for mtar write permission denial	*
      975*   ********************************************* */
      976 
      977       if io_info.io_type = mtar_io_type
      978        & (^io_info.p_att | io_info.alt_dev_flag) then do;
      979          if io_info.attach_err = error_table_$force_unassign then do;
      980 	  if ^alt_flag then disk_info_ptr = addr (io_info.rcp_area (1));
      981 	  else disk_info_ptr = addr (io_info.alt_rcp_area (1));
      982 	  if ^rd_flag then do;			/* opr denied write request */
      983 	     disk_info.write_flag = "0"b;		/* read only */
      984 	     rd_flag = "1"b;
      985 	     goto attach;
      986 	  end;
      987 	  else do;
      988 	     call output_status_code (io_info.attach_err, "ioi_assign error--check attach");
      989 	     call dealcp_sub;			/* go release status event */
      990 	     spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
      991 	     call return_plus (5);			/* take error return */
      992 	  end;
      993          end;
      994       end;
      995 
      996       if ^io_info.p_att | ^io_info.p2_att then do;
      997 
      998          if io_info.attach_err ^= 0
      999 	| error ^= 0 then do;
     1000 	  if io_info.attach_err = error_table_$resource_unavailable then do; /* must have been busy */
     1001 	     spa.regs.x (2) = bit (dev_busy);		/* set appropriate error code */
     1002 	     if ^io_info.dev_busy then do;		/* only output device busy message once */
     1003 	        call tolts_qttyio_$rs (0, "^a device busy, allocation queued", io_info.test_hdr);
     1004 	        io_info.dev_busy = "1"b;		/* set flag so we only output message once */
     1005 	     end;
     1006 	     call return_plus (7);			/* return ic + 7 */
     1007 	  end;
     1008 	  if io_info.io_type ^= mca_io_type then
     1009 	     call output_status_code (io_info.attach_err, "ioi_assign error--check attach");
     1010 	  else call output_status_code (error, " mca assign error");
     1011 	  call dealcp_sub;				/* go release status event */
     1012 	  spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
     1013 	  call return_plus (5);			/* take error return */
     1014          end;
     1015          if io_info.rcp_state ^= 0			/* return - allocation wait */
     1016 	| (io_info.io_type = mca_io_type
     1017 	& io_info.mca_attach_state < MCA_ATTACHED) then do;
     1018 	  io_info.alloc_wait = "1"b;			/* set wait flag for tolts_io_int_ */
     1019 	  io_info.icivlu.ic = mme_call_hw (4).upper;	/* save ccc ptr for tolts_io_int_ */
     1020 	  io_info.icivlu.ind = "0"b;
     1021 	  call tolts_qttyio_$dcw_list (addrel (execp, mme_call_hf (4).lower), 0);
     1022 	  tolts_info.glob_int_cnt = tolts_info.glob_int_cnt + 1; /* increment global IO count */
     1023 	  call return_plus (10);			/* return ic + 10, allocation wait */
     1024          end;
     1025 
     1026          if io_info.io_type = mdr_io_type & ^io_info.p2_att then /* if running mdrs */
     1027 	  if substr (io_info.device_name, 1, 3) = "tap"	/* if tape */
     1028 	   | substr (io_info.device_name, 1, 3) = "dsk" then do; /* or disk */
     1029 	     io_info.p2_att = "1"b;			/* set perph attach flag */
     1030 	     io_info.alt_rcp_id = io_info.rcp_id;	/* mv rcp id to alt rcp id */
     1031 	     go to mme_typ (-4);			/* we have the mpc now go get the dev */
     1032 	  end;
     1033          if ^alt_flag then io_info.p_att = "1"b;		/* set perp attach flag */
     1034          else io_info.p2_att = "1"b;
     1035          io_info.dev_busy = "0"b;			/* reset device busy flag */
     1036       end;
     1037 
     1038 
     1039 /* ***************************************************
     1040*   *   attach alternate device for mtar if required   *
     1041*   *************************************************** */
     1042 
     1043 
     1044       if io_info.io_type = mtar_io_type & io_info.alt_dev_flag
     1045        & io_info.p_att & ^io_info.p2_att then do;
     1046 
     1047          if rd_flag then do;				/* sct requested permission equal to that of primary */
     1048 	  disk_info_ptr = addr (io_info.alt_rcp_area (1));
     1049 	  disk_info.write_flag = "0"b;
     1050 	  rd_flag, alt_flag = "1"b;
     1051 	  goto attach;
     1052          end;
     1053          else do;
     1054 	  disk_info_ptr = addr (io_info.alt_rcp_area (1));
     1055 	  disk_info.write_flag = "1"b;
     1056 	  rd_flag = "0"b;
     1057 	  alt_flag = "1"b;
     1058 	  goto attach;
     1059          end;
     1060       end;
     1061 
     1062 
     1063 
     1064 
     1065 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1066 /*   set permission code for mtar								*/
     1067 /*   The address for permission storage is in the lower half of (mme call + 2).				*/
     1068 /*   appropriate permission is stored in the lower half of the target word,      			*/
     1069 /*    0 = write permission, 8 = read permission                                                               */
     1070 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1071 
     1072 
     1073 
     1074       if ^rd_flag then
     1075          exec_wd (mme_call_hf (2).lower) = exec_wd (mme_call_hf (2).lower) & "777777000000"b3;
     1076       else exec_wd (mme_call_hf (2).lower) = (exec_wd (mme_call_hf (2).lower)) | ("000000000010"b3);
     1077       if io_info.rcp_name = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) then /* if tape device... */
     1078          call decode_den;				/* go decode density info */
     1079 
     1080       if io_info.io_type = mca_io_type then
     1081          call get_temp_segment_ ("mca_workspace", io_info.workspace_ptr, error);
     1082       else call ioi_$workspace (io_info.device_index, io_info.workspace_ptr, tolts_info.wks_sz, error);
     1083       if error ^= 0 then do;
     1084          call output_status_code (error, "workspace assign error");
     1085          call dealcp_sub;				/* go release status event */
     1086          spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
     1087          call return_plus (5);			/* take error return */
     1088       end;
     1089       io_info.cur_wks_sz = tolts_info.wks_sz;		/* set current value of workspace size */
     1090       if io_info.io_type ^= mca_io_type then do;
     1091          ioi_wksp = io_info.workspace_ptr;
     1092          call ioi_$set_status (io_info.device_index, fixed (rel (addr (tolts_workspace.status)), 18), 1, error);
     1093          if error ^= 0 then do;
     1094 	  call output_status_code (error, "set_status error");
     1095 	  call dealcp_sub;				/* go detach and release status event */
     1096 	  spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
     1097 	  call return_plus (5);			/* take error return */
     1098          end;
     1099          if io_info.nff then do;
     1100 	  iom = fixed (substr (io_info.devsct.icc, 1, 3), 3) + 1;
     1101 	  chan = fixed (substr (io_info.devsct.icc, 6, 6), 6);
     1102          end;
     1103          else do;
     1104 	  iom = fixed (substr (io_info.devsct.icc, 1, 3), 3) + 1;
     1105 	  chan = fixed (substr (io_info.devsct.icc, 4, 6), 6);
     1106          end;
     1107          call ioi_$set_channel_required (io_info.device_index, iom, chan, error);
     1108          if error ^= 0 then do;
     1109 	  call output_status_code (error, "set_channel error");
     1110 	  call dealcp_sub;				/* go detach and release status event */
     1111 	  spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
     1112 	  call return_plus (5);			/* take error return */
     1113          end;
     1114 
     1115          timeout_time = 30000000;			/* set timeout to a minimum value of 30 sec */
     1116          if io_info.io_type = mdr_io_type
     1117 	& io_info.devsct.type_code = "001110"b then	/* if mdr and 601/610 */
     1118 	  timeout_time = 390000000;			/* set timeout to 6.5 mins */
     1119          else if io_info.io_type = itr_io_type		/* if mdrs on an eurc */
     1120 	& io_info.devsct.cr501_pr54 then
     1121 	  timeout_time = 60000000;			/* time_out = 1min */
     1122          else if io_info.io_type = mtar_io_type then
     1123 	  timeout_time = 90000000;			/* time_out = 1.5min */
     1124          io_info.lostit_time =			/* set lostit time = time_out time + 1sec * 64 / 1000 */
     1125 	divide ((timeout_time + 1000000) * 64, 1000, 35);
     1126          call ioi_$timeout (io_info.device_index, timeout_time, error);
     1127          if error ^= 0 then do;
     1128 	  call output_status_code (error, "set timeout error");
     1129 	  call dealcp_sub;				/* go release status event */
     1130 	  spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
     1131 	  call return_plus (5);			/* take error return */
     1132          end;
     1133       end;
     1134       io_info.allocated = "1"b;
     1135       call return_plus (8);				/* return ic + 8 - good return */
     1136 
     1137 /* ********* MME CATA. ********* (Get itr or mdr deckfile catalog)
     1138*
     1139*   input registers:		qu = ICC
     1140*   *			x1 = ptr to call seq (defined by cata_call structure (below)
     1141*   *			x2 = max load address
     1142*   *			x3 = test page base
     1143*   mme     cata.
     1144*   ------  return if error
     1145*   ------  return if more or extenstion file follows
     1146*   ------  return if all read
     1147*
     1148*   return registers:	AL    = words read in this call
     1149*   *			Q-reg = error code
     1150*   *			status word 1 bit 18 set for extension call */
     1151 
     1152 dcl  1 cata_call based (genp) aligned,			/* structure for mme cata and mme data */
     1153        (2 fdcwp bit (18),				/* first dcw ptr */
     1154        2 statp bit (18),				/* ptr to status */
     1155        2 patp bit (18),				/* ptr to PAT entry */
     1156        2 nblk fixed bin) unaligned;			/* next catalog block */
     1157 
     1158 mme_typ (-50): if trace | tcd then call tolts_qttyio_$rs (10, "^a MME CATA. @ ^p", ctime (), mmep);
     1159       if substr (spa.regs.q, 7, 1) then			/* if new format */
     1160          call get_px_tcx ("CATA. ", substr (spa.regs.q, 8, 11)); /* get test page index */
     1161       else call get_px_tcx ("CATA. ", substr (spa.regs.q, 10, 9)); /* get test page index */
     1162       if io_info.io_type = mca_io_type then do;
     1163          if io_info.mcata_idx = 0 then do;
     1164 	  call tolts_util_$cata_sel (tolts_info.df_iocbp, "cata.nio.mca", addr (io_info.n_keys), error);
     1165 	  if error ^= 0 then do;			/* if we couldn't find catalog */
     1166 	     call output_status_code (error, "selecting catalog subset of cata." || io_info.cat_name);
     1167 	     call return_plus (1);			/* take error return */
     1168 	  end;
     1169 	  call tolts_util_$search (tolts_info.df_iocbp, (io_info.cata_keys (1)), io_info.catp, c_len, error);
     1170 	  if error ^= 0 then do;			/* if we couldn't find catalog */
     1171 	     call output_status_code (error, "searching for " || io_info.cata_keys (io_info.mcata_idx));
     1172 	     call return_plus (1);			/* take error return */
     1173 	  end;
     1174 	  do io_info.mcata_nkeys = 1 to cata.n;
     1175 	     io_info.mcata_keys (io_info.mcata_nkeys) = cata.key (io_info.mcata_nkeys);
     1176 	  end;
     1177 	  io_info.mcata_idx = 1;
     1178          end;
     1179          io_info.cat_name = substr (io_info.mcata_keys (io_info.mcata_idx), 6, 7);
     1180       end;
     1181       if io_info.catx = 0 then do;			/* only select catalog keys once */
     1182          call tolts_util_$cata_sel (tolts_info.df_iocbp, "cata." || io_info.cat_name, addr (io_info.n_keys), error);
     1183          if error ^= 0 then do;			/* if we couldn't find catalog */
     1184 	  call output_status_code (error, "selecting catalog subset of cata." || io_info.cat_name);
     1185 	  call return_plus (1);			/* take error return */
     1186          end;
     1187          io_info.catx = io_info.n_keys;
     1188          if io_info.io_type ^= mca_io_type
     1189 	& io_info.n_keys > 1 then do;			/* multiple catalogs */
     1190 	  call tolts_qttyio_$rs (0, "^a Multiple catalog files (^d) for ^a ^a catalog.",
     1191 	   io_info.test_hdr, io_info.n_keys, substr (io_info.cat_name, 5), substr (io_info.cat_name, 1, 3));
     1192 	  do io_info.catx = 1 to io_info.n_keys;
     1193 	     i = search (substr (io_info.cata_keys (io_info.catx), 10), ".");
     1194 
     1195 	     call tolts_qttyio_$rs (0, "^a ^a catalog, ^[firmware rev ^a^] - ",
     1196 	      substr (io_info.cata_keys (io_info.catx), 10, i - 1),
     1197 	      substr (io_info.cata_keys (io_info.catx), 6, 3),
     1198 	      (substr (io_info.cata_keys (io_info.catx), 6, 3) = "itr"),
     1199 	      substr (io_info.cata_keys (io_info.catx), 10 + i));
     1200 	  end;
     1201 	  call tolts_qttyio_$rs (0, "^a^/^a",
     1202 	   "Indicate which one is to be used by answering yes to",
     1203 	   "one of the following catalog entrys:");
     1204 	  tolts_info.mult_ans = "";			/* clear out response */
     1205 	  do io_info.catx = 1 to io_info.n_keys while (mult_ans = "" | mult_ans = "no" | mult_ans = "n");
     1206 	     i = search (substr (io_info.cata_keys (io_info.catx), 10), ".");
     1207 requery:
     1208 	     call tolts_qttyio_$rs (19, "^a ^a catalog, ^[firmware rev ^a^] - ",
     1209 	      substr (io_info.cata_keys (io_info.catx), 10, i - 1),
     1210 	      substr (io_info.cata_keys (io_info.catx), 6, 3),
     1211 	      (substr (io_info.cata_keys (io_info.catx), 6, 3) = "itr"),
     1212 	      substr (io_info.cata_keys (io_info.catx), 10 + i));
     1213 	     call message_wait;			/* wait for user response */
     1214 	     if tolts_info.mult_ans ^= ""
     1215 	      & (mult_ans ^= "yes" & mult_ans ^= "y")
     1216 	      & (mult_ans ^= "no" & mult_ans ^= "n") then do;
     1217 	        call tolts_qttyio_ ("Please answer yes, no, or eom", 0);
     1218 	        go to requery;			/* go ask again */
     1219 	     end;
     1220 	  end;
     1221 	  io_info.catx = io_info.catx - 1;		/* currect io_info.catx */
     1222 	  if io_info.catx > io_info.n_keys
     1223 	   | (mult_ans ^= "yes" & mult_ans ^= "y") then
     1224 	     call return_plus (1);			/* take error return */
     1225          end;
     1226       end;
     1227       else if io_info.io_type = mca_io_type then do;
     1228          if ^io_info.cata_cycle then io_info.cata_cycle = "1"b; /* first time thru */
     1229          else do;					/* must be second pass */
     1230 	  if io_info.catx > 1 then			/* if diskette catalog index > 1 */
     1231 	     io_info.catx = io_info.catx - 1;		/* subtract 1 */
     1232 	  else do;				/* else move to the mca cata index */
     1233 	     io_info.mcata_idx = io_info.mcata_idx + 1;
     1234 	     io_info.catx = 0;			/* reset the diskette catalog index */
     1235 	  end;
     1236 	  io_info.cata_cycle = "0"b;
     1237          end;
     1238          spa.regs.a = "0"b;				/* intialize words read to 0 */
     1239       end;
     1240       if io_info.catx ^= 0 then do;
     1241          call tolts_util_$search (tolts_info.df_iocbp, (io_info.cata_keys (io_info.catx)), io_info.catp, c_len, error);
     1242          if error ^= 0 then do;			/* if we couldn't find catalog */
     1243 	  call output_status_code (error, "searching for " || io_info.cata_keys (io_info.catx));
     1244 	  call return_plus (1);			/* take error return */
     1245          end;
     1246          genp = addrel (execp, spa.regs.x (1));		/* get ptr to slave call */
     1247          dcwp = addrel (execp, cata_call.fdcwp);		/*  get ptr to dcw */
     1248          gcatp = addrel (execp, dcw.address);		/* get ptr to buffer */
     1249          if trace | tcd then call tolts_qttyio_$rs (10, "MME CATA.; loading catalog ""cata.^a"" @ ^p",
     1250 	   io_info.cat_name, gcatp);
     1251          do i = 1 to cata.n;				/* give page all catalog entries */
     1252 	  if io_info.io_type = mca_io_type then do;
     1253 	     unspec (mca_gcata (i)) = "0"b;		/* reset this entry */
     1254 	     mca_gcata (i).cat_index, mca_gcata (i).nblk = i; /* set cata index & block number */
     1255 	     if index (cata.key (i), "HDR") ^= 0 then do;
     1256 	        mca_gcata (i).dipper_flag = "0100"b;	/* set header flag */
     1257 	        filename_idx = index (cata.key (i),
     1258 	         after (cata.key (i), "HDR."));		/* get index of filename */
     1259 	     end;
     1260 
     1261 	     else if index (cata.key (i), "DIR") ^= 0 then do;
     1262 	        mca_gcata (i).dipper_flag = "0101"b;	/* set dir flag */
     1263 	        filename_idx = index (cata.key (i), "DIR"); /* get index of filename */
     1264 	     end;
     1265 
     1266 	     else if index (cata.key (i), "cata") ^= 0 then do;
     1267 	        mca_gcata (i).dipper_flag = "0100"b;	/* set cata flag */
     1268 	        filename_idx = index (cata.key (i),
     1269 	         after (cata.key (i), "nio."));		/* get index of filename */
     1270 	     end;
     1271 
     1272 	     else filename_idx = index (cata.key (i),
     1273 		 after (cata.key (i), "nio."));	/* get index of filename */
     1274 	     call tolts_alm_util_$ascii_to_bcd_
     1275 	      (substr (cata.key (i), filename_idx, 12), bit_buf);
     1276 	     unspec (mca_gcata (i).filename) = bit_buf;
     1277 	  end;
     1278 
     1279 	  else do;
     1280 	     unspec (gcata (i)) = "0"b;		/* clear element first */
     1281 	     j = length (rtrim (cata.key (i)));		/* get true length of key */
     1282 	     ac_name = substr (cata.key (i), j - 6, 4) || substr (cata.key (i), j - 1, 2);
     1283 	     call tolts_alm_util_$ascii_to_bcd_ (ac_name, gcata (i).edit_rev); /* set edit name an rev */
     1284 	     gcata (i).cat_index, gcata (i).nblk = i;	/* set index */
     1285 	     if j < 13 then
     1286 	        call tolts_alm_util_$ascii_to_bcd_ (substr (cata.key (i), j, 6), gcata (i).ident); /* set ident */
     1287 	     else call tolts_alm_util_$ascii_to_bcd_ (substr (cata.key (i), j - 13, 6), gcata (i).ident); /* set ident */
     1288 	     if index (cata.key (i), ".") > 4 then	/* if firmware */
     1289 	        call tolts_alm_util_$ascii_to_bcd_ (substr (cata.key (i), 1, 6), gcata (i).purpose);
     1290 	     else do;
     1291 	        call tolts_alm_util_$ascii_to_bcd_ (substr (cata.key (i), 1, 3), b18);
     1292 	        substr (gcata (i).purpose, 19, 18) = b18;
     1293 	     end;
     1294 	  end;
     1295          end;
     1296          spa.regs.a = bit (bin (cata.n * 4, 36));		/* set words read */
     1297       end;
     1298       if io_info.mcata_idx <= io_info.mcata_nkeys
     1299        & io_info.io_type = mca_io_type then call return_plus (2); /* still more catalogs to read */
     1300       else call return_plus (3);			/* take good return */
     1301 
     1302 
     1303 
     1304 /* ********* MME CHANTM ********* (channel time)
     1305*
     1306*   input registers:   X1 = sct (test page index mod 4),   X4 = pat address (lal offset)
     1307*
     1308*   mme     chantm
     1309*   ------  return
     1310*
     1311*   return registers: AR = channel time */
     1312 
     1313 mme_typ (-6): if trace then call tolts_qttyio_$rs (10, "^a MME CHANTM @ ^p", ctime (), mmep);
     1314       call get_px_sct ("CHANTM", bin (spa.regs.x (1), 17), "1"b); /* get test page index */
     1315       spa.regs.a = bit (bin (pages (io_sel).chan_time, 36));
     1316       call return_plus (1);
     1317 
     1318 /* ********* MME CLEARQ ********* (clear ISC queue)
     1319*
     1320*   input/return registers: none
     1321*
     1322*   mme     clearq
     1323*   ------  return */
     1324 
     1325 mme_typ (-7): if trace then call tolts_qttyio_$rs (10, "^a MME CLEARQ @ ^p", ctime (), mmep);
     1326       isc_ccc_rqt = "0"b;
     1327       if isc_cntdn ^= 1 then isc_cntdn = 0;
     1328       call return_plus (1);
     1329 
     1330 /* ********* MME COINIT ********* (colts slave executive initialize)
     1331*
     1332*   input/output registers: none
     1333*
     1334*   mme	coinit
     1335*   zero	6,0       number of designators
     1336*   zero	wwflag,1
     1337*   zero	lstloc,2	core size available as loaded
     1338*   zero	tdflt,5	wrapup address
     1339*   zero	mmexec,7  interface module ttl
     1340*   zero   systyp,10  os type
     1341*   zero	crd30,11   .crd30	  bit 17 = 1 if fnp active and 18-29 = # of active fnps
     1342*   ----	return	return is mme call + the number of designators + 2
     1343*
     1344*   .crfig:
     1345*
     1346*   0 = series 60 0r 6000	6 = system sckd. save opt.		24-30 = reserved for gcos
     1347*   1 = class. module present	7 = reserved for gcos		31 = not in mem avail. space tab
     1348*   2 = shared memory system	8,9,10,11 = ioms 0-3 configured	32 = RLP300 present
     1349*   3 = >256k		12,13,14,15 = CPUs 0-3 configured	33 = DN30
     1350*   4 = IOM system		16-19 = reserved for gcos		34 = DN305
     1351*   5 = series 60 system	20,21,22,23 = CPU has EIS		35 = DN	355/6600
     1352**/
     1353 
     1354 
     1355 mme_typ (-62): if trace then call tolts_qttyio_$rs (10, "^a MME COINIT @ ^p", ctime (), mmep);
     1356       exec_wd (mme_call_hf (2).upper) = "0"b;		/*	zeros says not ww system */
     1357       spa.wrapup_add = mme_call_hw (4).upper;		/* set wrapup address */
     1358       call tolts_alm_util_$ascii_to_bcd_ (ttl_date, bcd_callname); /* convert ttl date to bcd */
     1359       exec_wd (mme_call_hf (5).upper) = bcd_callname;	/* and store in message */
     1360       substr (exec_wd (mme_call_hf (5).upper - 1), 19, 18) = "622017"b3; /* change version? ?? to version?s ? */
     1361       genp = addrel (execp, mme_call_hf (3).upper);	/* get ptr to lstloc */
     1362       if fix_wd (1) ^= 0 then				/* if lstloc specified... */
     1363          mem_now, fix_wd (1) = fix_wd (1) + 49152;	/* add 48k to lstloc */
     1364       else mem_now, fix_wd (1) = fixed (gload_data.text_len) + 49152; /* otherwise use loaded length */
     1365       call cpu_time_and_paging_ (i, cpu_time, j);		/* get current cpu time */
     1366       tolts_info.init_time = cpu_time;			/* save  */
     1367       exec_wd (mme_call_hf (6).upper) = "000000000002"b3;	/* set os to multics */
     1368       exec_wd (mme_call_hf (7).upper) = "000001001000"b3;	/* set fnp present bit and number of active fnp's to max */
     1369       fnp.status_word, colts_pages.status_word = "000000000004"b3;
     1370       call return_plus (8);
     1371 
     1372 /* ********* MME CONTML ********* (controlling terminal)
     1373*
     1374*   input registers:   x1 = old controlling terminal
     1375*
     1376*   mme     contml
     1377*   ------  return tolts aborted
     1378*   ------  return tolts swapped
     1379*   ------  return denied
     1380*   ------  return slaves copying
     1381*   ------  return good
     1382*
     1383*   return registers:   x1 = new logical controlling terminal in lower */
     1384 
     1385 mme_typ (-8): if trace then call tolts_qttyio_$rs (10, "^a MME CONTML @ ^p", ctime (), mmep);
     1386       spa.regs.x (1) = "000004"b3;			/* coded terminal 4 */
     1387       call return_plus (5);				/* return ic + 5 */
     1388 
     1389 
     1390 
     1391 /* ********* MME DATA. ********* (Get itr or mdr from deckfile)
     1392*
     1393*   input registers:		qu = ICC
     1394*   *			x1 = ptr to call seq (defined by cata_call structure (see MME CATA.)
     1395*   *			x2 = max load address
     1396*   *			x3 = test page base
     1397*   *			x4 = diskette sector number relative to sector 0
     1398*
     1399*   mme     data.
     1400*   ------  return if error
     1401*   ------  return if more or extenstion file follows
     1402*   ------  return if all read
     1403*
     1404*   return registers:	AL    = words read in this call
     1405*   *			Q-reg = error code
     1406*   *			status word 1 bit 18 set for extension call */
     1407 
     1408 mme_typ (-51): if trace | tcd then do;
     1409          call tolts_qttyio_$rs (10, "^a MME DATA. @ ^p to load ^a",
     1410 	ctime (), mmep, cata.key (cata_call.nblk));
     1411          genp = addrel (execp, spa.regs.x (1));		/* get ptr to slave call */
     1412       end;
     1413 
     1414       if substr (spa.regs.q, 7, 1) then			/* if new format */
     1415          call get_px_tcx ("DATA. ", substr (spa.regs.q, 8, 11)); /* get test page index */
     1416       else call get_px_tcx ("DATA. ", substr (spa.regs.q, 10, 9)); /* get test page index */
     1417       genp = addrel (execp, spa.regs.x (1));		/* get ptr to slave call */
     1418       dcwp = addrel (execp, cata_call.fdcwp);		/*  get ptr to dcw */
     1419       l_ptr = addrel (execp, dcw.address);		/* get ptr to buffer */
     1420       call tolts_util_$search (tolts_info.df_iocbp, (cata.key (cata_call.nblk)), t_ptr, c_len, error);
     1421       if error ^= 0 then do;				/* if we couldn't find module */
     1422          call output_status_code (error, "searching for " || cata.key (cata_call.nblk));
     1423          call return_plus (1);			/* take error return */
     1424       end;
     1425 
     1426       if io_info.io_type = mca_io_type then do;
     1427          if spa.regs.x (4) ^= "777777"b3 then do;		/* if data is wanted */
     1428 	  io_info.catx = 0;
     1429 	  io_info.mcata_idx = 1;
     1430 	  t_ptr = addrel (t_ptr, fixed (spa.regs.x (4)) * 64); /* adjust the ptr to the correct sector */
     1431 	  if bin (dcw.tally) = 0 then tally = 4096;	/* ck for a zero tally */
     1432 	  else tally = bin (dcw.tally);
     1433 	  if c_len < (fixed (spa.regs.x (4)) * 64) + tally then /* if the data wanted is > then end */
     1434 	     c_len = c_len - fixed (spa.regs.x (4)) * 64; /* adjust the amount to be sent */
     1435 	  else c_len = tally;
     1436 	  if c_len < 0 then call return_plus (1);	/* should not happen */
     1437 	  mvp = addrel (execp, dcw.address);		/* set mvp to where data is to go */
     1438 	  data_move = t_ptr -> data_move;		/* move it */
     1439 	  spa.regs.a = bit (bin (c_len, 36));		/* set words read */
     1440          end;
     1441          else spa.regs.a = "0"b;
     1442       end;
     1443       else do;
     1444          call gload_ (t_ptr, l_ptr, fixed (spa.regs.x (3), 18), addr (gload_data), error); /* load it */
     1445          if error ^= 0 then do;
     1446 	  call output_status_code (error,
     1447 	   gload_data.diagnostic || " loading module " || cata.key (cata_call.nblk));
     1448 	  call return_plus (1);			/* take error return */
     1449          end;
     1450          spa.regs.a = bit (bin (gload_data.text_len, 36));	/* set words read */
     1451       end;
     1452       if trace | tcd then call tolts_qttyio_$rs (10, "MME DATA.; loaded ""^a"" @ ^p to ^p for ^d",
     1453 	cata.key (cata_call.nblk), t_ptr, l_ptr, spa.regs.a);
     1454 
     1455       call return_plus (3);				/* take good return */
     1456 
     1457 
     1458 
     1459 /* ********* MME DEALCP ********* (deallocate peripheral)
     1460*
     1461*   input registers:   x1 = sct (test page index mod 4)
     1462*
     1463*   mme     dealcp
     1464*   ------  return
     1465*
     1466*   return registers: none */
     1467 
     1468 mme_typ (-9): if trace then call tolts_qttyio_$rs (10, "^a MME DEALCP @ ^p", ctime (), mmep);
     1469       call get_px_sct ("DEALCP", bin (spa.regs.x (1), 17), "0"b); /* get test page index */
     1470       call dealcp_sub;
     1471       if dealc_err ^= 0 then
     1472          call tolts_abort ("$b3");
     1473       else call return_plus (1);
     1474 
     1475 
     1476 
     1477 
     1478 /* ********* MME DOFPIO ********* (mme to do reponder io)
     1479*
     1480*   input registers:
     1481*   x1 = pointer to FPINFO table
     1482*   x3 = test page base
     1483*   a  = PCW like direct_channel_pcw
     1484*   q  = time out time
     1485*
     1486*   I/O COMMANDS
     1487*   71 - Interrupt fnp (uses level 3, 4, 5, 6 & 77)
     1488*   72 - Bootload fnp (not used)
     1489*   73 - Interrupt host (uses level 3 & 7)
     1490*   75 - Test data xfer (fnp - host)
     1491*   76 - Test data xfer (host - fnp)
     1492*
     1493*
     1494*   mme	DOFPIO
     1495*   zero	good return       (mme call + 1) */
     1496 
     1497 
     1498 mme_typ (-89): if trace | trace_io then call tolts_qttyio_$rs
     1499 	(10, "^a MME DOFPIO ^p, type - ^12.3b", ctime (), mmep, substr (spa.regs.a, 25));
     1500 
     1501       tolts_fpinfo_ptr = addrel (execp, spa.regs.x (1));
     1502 
     1503       do io_sel = 1 to hbound (tolts_info.pages, 1)	/* get the correct io_info for this page */
     1504        while (pages (io_sel).fnp_num ^= tolts_fpinfo.pcw_info.fnp_num);
     1505       end;
     1506 
     1507       if io_sel > hbound (tolts_info.pages, 1) then call tolts_abort ("$c3");
     1508       io_info_ptr = addr (pages (io_sel));
     1509       io_info.fpinfo_ptr = tolts_fpinfo_ptr;		/* save fpinfo_ptr for this page */
     1510       tolts_rspd_wksp = io_info.tolts_rspd_wksp;		/* get work space ptr */
     1511       tolts_fpinfo.fnpdcw.address =			/* set dcw address */
     1512        bin (bin (spa.regs.x (3), 18) + bin (substr (spa.regs.a, 1, 18), 18), 18);
     1513       direct_channel_pcw_ptr =			/* set pcw */
     1514        addr (tolts_rspd_workspace.mailbox.pcw);
     1515       substr (unspec (direct_channel_pcw), 19) = substr (spa.regs.a, 19);
     1516       substr (unspec (tolts_fpinfo.pcw_info), 19) =
     1517        substr (spa.regs.a, 19);			/* save pcw for test page */
     1518       io_info.dcw_list (1) = exec_wd (tolts_fpinfo.fnpdcw.address); /* set dcw */
     1519       direct_channel_tcw_ptr = addr (tolts_rspd_workspace.tcw); /* get tcw */
     1520       unspec (direct_channel_tcw) = unspec (io_info.dcw_list (1));
     1521       if direct_channel_pcw.operation = "75"b3		/* if data xfer pcw */
     1522        | direct_channel_pcw.operation = "76"b3 then do;	/* set up pcw */
     1523          substr (spa.regs.a, 1, 18) = unspec (tolts_fpinfo.fnpdcw.address);
     1524          direct_channel_pcw.tcw_address = wordno (addr (tolts_rspd_workspace.tcw));
     1525       end;
     1526 
     1527       else direct_channel_pcw.tcw_address = 0;		/* else set to 0 */
     1528       io_info.pcwa = spa.regs.a;
     1529       if direct_channel_pcw.operation = "76"b3 then do;	/* if sending data - move it */
     1530          c_len = direct_channel_tcw.host_word_count;
     1531          mvp = addrel (execp, bin (substr (spa.regs.a, 1, 18)) + 1);
     1532          bufp = addr (tolts_rspd_workspace.data_buf);
     1533          workspace_move = mvp -> workspace_move;
     1534       end;
     1535 
     1536       tolts_rspd_workspace.pcw = direct_channel_pcw;
     1537       unspec (tolts_rspd_workspace.tcw) = unspec (direct_channel_tcw);
     1538       tio_off = wordno (direct_channel_pcw_ptr);
     1539       io_info.lostit_time = bin (tolts_fpinfo.timeout_time);
     1540       call tolts_init_$gc_tod ((tolts_fpinfo.timeout_time));
     1541       tolts_fpinfo.timeout_time = bit (bin (tolts_fpinfo.timeout_time, 36) + io_info.lostit_time, 35);
     1542       tolts_fpinfo.io_rq_cnt = tolts_fpinfo.io_rq_cnt + 1;	/* bump io request count */
     1543 
     1544       io_info.io_in_progress = "1"b;
     1545       io_info.num_connects = io_info.num_connects + 1;
     1546       call ioi_$connect (io_info.device_index, tio_off, error);
     1547       if error ^= 0 then do;
     1548          call output_status_code (error, "io connect error");
     1549          call tolts_abort ("$c7");
     1550       end;
     1551 
     1552       wake_time = 500000;
     1553       call timer_manager_$sleep (wake_time, "10"b);
     1554       tolts_info.glob_int_cnt = tolts_info.glob_int_cnt + 1;
     1555       call return_plus (1);
     1556 
     1557 /* ********* MME EXPDEV ********* (return device sct)
     1558*
     1559*   input registers:   x1 = sct (test page index mod 4)
     1560*
     1561*   mme     expdev
     1562*   ------  return
     1563*
     1564*   return registers: A and Q regs contain 1st and 2nd words of device sct entry */
     1565 
     1566 mme_typ (-12): if trace then call tolts_qttyio_$rs (10, "^a MME EXPDEV @ ^p", ctime (), mmep);
     1567       call get_px_sct ("EXPDEV", bin (spa.regs.x (1), 17), "1"b); /* get test page index */
     1568       spa.regs.a = unspec (io_info.devsct.w1);		/* set sct in a  */
     1569       spa.regs.q = unspec (io_info.devsct.w2);		/* and q registers */
     1570       call return_plus (1);
     1571 
     1572 /* ********* MME FEPTYP ********* (return fnp type)
     1573*
     1574*   input registers:   x2 =  logical fep number * 4
     1575*
     1576*   mme     feptyp
     1577*   oct	 0         data returned here
     1578*   ------  return	     */
     1579 
     1580 
     1581 
     1582 mme_typ (-59): if trace then call tolts_qttyio_$rs (10, "^a MME FEPTYP @ ^p", ctime (), mmep);
     1583 
     1584 
     1585       cdtp = cdtptr;
     1586       j = bin (spa.regs.x (2));			/* get true fnp number */
     1587       tolts_info.fnp (j).type = (fnp_entry (j + 1).type);	/* find type */
     1588       if tolts_info.fnp (j).type = 1 then spa.regs.x (2) = "000002"b3; /* if type 1 (dn355) set code */
     1589       else if tolts_info.fnp (j).type = 3
     1590        then spa.regs.x (2) = "000001"b3;		/* if type 3 (DN6670) set code */
     1591       else if tolts_info.fnp (j).type = 0
     1592        then spa.regs.x (2) = "777777"b3;		/* if type = 0 then illegal type set error return */
     1593       if fnp_entry (j + 1).mpxe.current_service_type ^= 1
     1594        & fnp_entry (j + 1).state ^= 4 then do;		/* if fnp is not up */
     1595          spa.regs.x (2) = "777777"b3;			/* return a bad code */
     1596          call tolts_qttyio_$rs (0, "^as: fnp ^a is ^a", exec, tags (j + 1),
     1597 	fnp_state (fnp_entry (j + 1).mpxe.state));	/* notify the user */
     1598       end;
     1599       call return_plus (1);
     1600 
     1601 
     1602 /* ********* MME FPWRAP ********* (Responder wrapup)
     1603*
     1604*   input registers:   X1 = fpinfo pointer
     1605*
     1606*   mme     fpwrap
     1607*   ------  return    */
     1608 
     1609 
     1610 mme_typ (-93): if trace then call tolts_qttyio_$rs (10, "^a MME FPWRAP @ ^p", ctime (), mmep);
     1611 
     1612       tolts_fpinfo_ptr = addrel (execp, spa.regs.x (1));	/* get pointer to test page fpinfo table */
     1613 
     1614       do io_sel = 1 to hbound (pages, 1)		/* get the correct io_info for this page */
     1615 
     1616        while (pages (io_sel).fnp_num ^= tolts_fpinfo.pcw_info.fnp_num);
     1617       end;
     1618 
     1619       if io_sel > hbound (pages, 1) then call tolts_abort ("$c3"); /* page not found - */
     1620       io_info_ptr = addr (pages (io_sel));
     1621       tolts_rspd_wksp = io_info.tolts_rspd_wksp;		/* get the io workspace for this page */
     1622       tolts_fpinfo.partrs = 0;			/* reset tolts assigned flag */
     1623       if ^io_info.io_in_progress then tolts_fpinfo.io_rq_cnt = 0; /* reset io rquest count */
     1624       unspec (tolts_rspd_workspace.mailbox.num_int) = "0"b; /* reset int count */
     1625       tolts_rspd_workspace.mailbox.status_word = "0"b;
     1626       call dealcp_sub;				/* release the fep */
     1627       call return_plus (1);
     1628 
     1629 
     1630 
     1631 /* ********* MME FREEZE ********* (wire main memory (gcos only))
     1632*
     1633*   input registers:   none
     1634*
     1635*   mme     freeze
     1636*   ------  return
     1637*
     1638*   return registers: X5 = LAL (returned = 0) */
     1639 
     1640 
     1641 mme_typ (-53): if trace then call tolts_qttyio_$rs (10, "^a MME FREEZE @ ^p", ctime (), mmep);
     1642       spa.regs.x (5) = "0"b;				/* set x 5 to 0 */
     1643       call return_plus (1);
     1644 
     1645 
     1646 
     1647 /* ********* MME GECALL ********* (load object deck)
     1648*
     1649*   input registers: none
     1650*   output register: q       error code entry options(variable)
     1651*   mme     gecall
     1652*   bci     1,name
     1653*   zero    add,error return
     1654*   zero    transfer add,0 */
     1655 
     1656 
     1657 
     1658 mme_typ (18): call bcd_to_ascii_ (mme_call_w (1), ac_name); /* convert callname to ascii */
     1659       if trace then call tolts_qttyio_$rs (10, "^a MME GECALL (^a) @ ^p", ctime (), ac_name, mmep);
     1660       coment = "";
     1661       l_ptr = addrel (execp, mme_call_hf (2).upper);
     1662       call tolts_util_$search (tolts_info.df_iocbp,
     1663        substr (tolts_info.exec, 1, 1) || "lt." || ac_name, t_ptr, c_len, error);
     1664       if error ^= 0 then				/* if could'nt find polt or molt page, try util */
     1665          call tolts_util_$search (tolts_info.df_iocbp, "utl." || ac_name, t_ptr, c_len, error);
     1666       if error ^= 0 then				/* if found test page */
     1667          call ioa_$rsnnl ("searching for test page ^a", coment, mesg_len, ac_name);
     1668       if error = 0 then
     1669          call gload_ (t_ptr, l_ptr, fixed (spa.regs.x (3), 18), addr (gload_data), error); /* load it */
     1670       if error ^= 0 then do;
     1671          if coment = "" then
     1672 	  call ioa_$rsnnl ("^a loading test page ^a", coment, mesg_len, gload_data.diagnostic, ac_name);
     1673          call output_status_code (error, coment);
     1674          if mme_call_hw (2).lower = "0"b		/* error return = 0 */
     1675 	then spa.enter.icivlu = spa.wrapup_add;		/* set return to molts wrapup */
     1676          else do;
     1677 	  spa.enter.icivlu.ic = mme_call_hw (2).lower;	/* error return */
     1678 	  mme_call_hw (2).lower = "0"b;		/* zero error return to prevent loop */
     1679 	  spa.regs.q = "63"b3;			/* set q = file not found eror code */
     1680          end;
     1681       end;
     1682       else spa.enter.icivlu.ic = mme_call_hw (3).upper;	/* normal return */
     1683       call wake_disp;				/* go wake up dispatcher */
     1684 
     1685 /* ********* MME GEENDC ********* (end courtesy call)
     1686*
     1687*   input/return registers: none
     1688*
     1689*   mme     geendc
     1690*   no return from mme,   enters code whereever ccc interrupted */
     1691 
     1692 mme_typ (14): if trace | trace_io then call tolts_qttyio_$rs (10, "^a MME GEENDC @ ^p", ctime (), mmep);
     1693       if ^in_ccc then do;				/* if not in courtesy call complain */
     1694          call tolts_qttyio_$rs (0, "^as: MME GEENDC while not in courtesy call", exec);
     1695          call tolts_abort ("$a6");
     1696       end;
     1697       gndc_flag = "1"b;				/* set geendc complete flag */
     1698       in_ccc = "0"b;				/* reset courtesy call flag */
     1699       unspec (spa.regs) = addr (spa.ccc_regs) -> reg_move;
     1700       string (spa.enter.icivlu) = spa.ccc_icivlu;
     1701       call wake_disp;				/* go wake up dispatcher */
     1702 
     1703 /* ********* MME GEINOS ********* (console write or interslave read)
     1704*
     1705*   input/return registers: none
     1706*
     1707*   isc read:	mme     geinos		console write:	mme     geinos
     1708*   *		oct     010000000000			oct     130000000000
     1709*   *		zero    quefcd,quedcw			zero    flcode,ondcw
     1710*   *		zero    quests,quecc			zero    ofstat,offccc
     1711*   *		------  return				------  return   */
     1712 mme_typ (1): if trace then call tolts_qttyio_$rs (10, "^a MME GEINOS @ ^p, type - ^12.3b", ctime (), mmep, mme_call_w (1));
     1713       if mme_call_w (1) ^= "130000000000"b3 & mme_call_w (1) ^= "010000000000"b3 then do; /* illegal type */
     1714          call tolts_qttyio_$rs (0, "^as: MME GEINOS type ^12.3b not supported", exec, mme_call_w (1));
     1715          call tolts_abort ("$a7");
     1716       end;
     1717       dcwp = addrel (execp, mme_call_hf (2).lower);	/* get ptr to dcw */
     1718       exec_wd (mme_call_hf (3).upper), exec_wd (mme_call_hf (3).upper + 1) = "0"b; /* set status & dcw res to 0 */
     1719       if mme_call_hw (1).upper = "010000"b3 then do;	/* isc read */
     1720          if dcw.type ^= "0"b then do;			/* dcw not iotd */
     1721 	  call tolts_qttyio_$rs (0, "^as: MME GEINOS; Read isc dcw type not iotd. DCW = 12.3b",
     1722 	   exec, string (dcw));
     1723 	  call tolts_abort ("$a7");
     1724          end;
     1725          if dcw.tally ^= "0003"b3 then do;		/* isc read word cnt must be 3 */
     1726 	  call tolts_qttyio_$rs (0, "^as: MME GEINOS; Read isc word count ^= 3. DCW = 12.3b",
     1727 	   exec, string (dcw));
     1728 	  call tolts_abort ("$a7");
     1729          end;
     1730          if tolts_info.exec_dta_cnt ^= 0 then do;		/* if data to xfer... */
     1731 	  j = mme_call_hf (3).upper;			/* copy status address */
     1732 	  call pop_isc (j, bin (dcw.address, 17));	/* do it */
     1733 	  if mme_call_hf (3).lower ^= 0 then		/* if courtesy call requested */
     1734 	     call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
     1735 	      mme_call_hw (3).lower || "000000"b3);
     1736          end;
     1737          else do;					/* no data to xfer */
     1738 	  isc_cntdn = 10000;
     1739 	  if mme_call_hf (3).lower ^= 0 then do;	/* if courtesy call requested */
     1740 	     isc_ccc_rqt = "1"b;
     1741 	     isc_queue.icivlu = mme_call_hw (3).lower || "000000"b3;
     1742 	     isc_queue.status_add = mme_call_hf (3).upper;
     1743 	     isc_queue.data_add = fixed (dcw.address);
     1744 	  end;
     1745          end;
     1746       end;
     1747       else do;					/* console write */
     1748          if mme_call_hf (3).lower ^= 0 then		/* if courtesy call requested */
     1749 	  call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
     1750 	   mme_call_hw (3).lower || "000000"b3);
     1751          call tolts_qttyio_$dcw_list (dcwp, 0);		/* output the dcwp */
     1752       end;
     1753       call return_plus (4);				/* return ic + 4 */
     1754 
     1755 /* ********* MME GELBAR ********* (load base address register)
     1756*
     1757*   input registers:	AR = upper/ptr to LOC1 structure (defined by gelbar_temp below)
     1758*   *		QR = CPU time increment beffor interrupt
     1759*
     1760*   mme   gelbar
     1761*   no return, return to ic value located in gelbar_temp.ic
     1762*
     1763*   return registers: none */
     1764 
     1765 dcl  1 gelbar_temp based (genp) aligned,		/* template for gelbar loc1 and loc1+1 */
     1766        (2 bar bit (18),				/* desired bar value */
     1767        2 reg_ptr bit (18),				/* ptr to register storage */
     1768        2 ic bit (18),				/* instruction counter */
     1769        2 ind bit (18)) unaligned;			/* indicator register */
     1770 
     1771 mme_typ (31): if trace then call tolts_qttyio_$rs (10, "^a MME GELBAR @ ^p", ctime (), mmep);
     1772       spa.glbtmr = spa.regs.q;			/* store entry timer setting */
     1773       genp = addrel (execp, substr (spa.regs.a, 1, 18));	/* get ptr to LOC1 */
     1774       spa.enter.icivlu.ic = gelbar_temp.ic;		/* set desired ic value */
     1775       spa.enter.icivlu.ind = gelbar_temp.ind;		/* and indicators */
     1776       spa.enter.lbar.bar = gelbar_temp.bar;		/* store new bar value to return */
     1777       spa.acc_fault = gelbar_temp.bar || "000000"b3;	/* also save bar in accum fault status word */
     1778       call tolts_init_$gc_tod (gcos_tod);		/* get current time of day */
     1779       string (spa.glbici) = gcos_tod;			/* save current time of day in word 22 */
     1780       genp = addrel (execp, gelbar_temp.reg_ptr);
     1781       unspec (spa.regs) = genp -> reg_move;		/* move regs to be returned */
     1782       gelbar = "1"b;				/* and set gelbar mode indicator */
     1783       call wake_disp;				/* go wake up dispatcher */
     1784 
     1785 /* ********* MME GEMORE ********* (get more memory)
     1786*
     1787*   input/return registers: none
     1788*
     1789*   mme     gemore
     1790*   zero    0,no. 1024 word blocks
     1791*   ------  return denial
     1792*   ------  return succesful */
     1793 
     1794 mme_typ (9): if trace then call tolts_qttyio_$rs (10, "^a MME GEMORE @ ^p", ctime (), mmep);
     1795       call return_plus (3);				/* return ic + 3 */
     1796 
     1797 /* ********* MME GEMREL ********* (release memory)
     1798*
     1799*   input registers:	AR = return address in upper, lower not used
     1800*   *		QR = words lower mem to release in upper, words upper mem to release in lower
     1801*
     1802*   mme     gemrel
     1803*   ------  return
     1804*
     1805*   return registers: none */
     1806 
     1807 mme_typ (21): if trace then call tolts_qttyio_$rs (10, "^a MME GEMREL @ ^p", ctime (), mmep);
     1808       spa.enter.icivlu.ic = substr (spa.regs.a, 1, 18);	/* return to address in a upper */
     1809       call wake_disp;				/* go wake up dispatcher */
     1810 
     1811 /* ********* MME GEPROC ********* (dedicate CPU, unused in Multics. Return error)
     1812*
     1813*   input/return registers: none
     1814*
     1815*   mme     geproc
     1816*   zero    gprprc,0
     1817*   zero    work,0
     1818*   ------  return error
     1819*   ------  return good */
     1820 
     1821 mme_typ (-13): if trace then call tolts_qttyio_$rs (10, "^a MME GEPROC @ ^p", ctime (), mmep);
     1822       call return_plus (3);				/* return ic + 3, error return for Multics */
     1823 
     1824 /* ********* MME GERELC ********* (wait for I/O interrupt to occur)
     1825*
     1826*   input/return registers: none
     1827*
     1828*   mme     gerelc
     1829*   ------  return */
     1830 
     1831 mme_typ (15): if trace then call tolts_qttyio_$rs (10, "^a MME GERELC @ ^p", ctime (), mmep);
     1832       call return_plus (1);
     1833 
     1834 /* ********* MME GEROAD ********* (road block, wait)
     1835*
     1836*   input/return registers: none
     1837*
     1838*   mme     geroad
     1839*   ------  return */
     1840 mme_typ (2): if trace then call tolts_qttyio_$rs (10, "^a MME GEROAD @ ^p", ctime (), mmep);
     1841       rd_blk = "1"b;
     1842       call return_plus (1);
     1843 
     1844 
     1845 /* ********* MME GEROUT ********* (colts communications)
     1846*
     1847*   l   mme    gerout
     1848*   l+1	 vfd     18/record pointer,06/op,12/terminal id
     1849*   l+2	         status word pointer,courtesy call pointer
     1850*   l+3	         return
     1851*
     1852*
     1853*   There are six gerout types handled by tolts.
     1854*   04  write/read
     1855*   05  remote inquiry
     1856*   06  terminal type request
     1857*   07  fnp colts wake-up
     1858*   17  disconnect
     1859*   20  line status request	   */
     1860 
     1861 
     1862 mme_typ (24): if trace then call tolts_qttyio_$rs (10, "^a MME GEROUT ^p, type - ^12.3b", ctime (), mmep, mme_call_w (1));
     1863 
     1864       gerout_num = bin (substr (mme_call_hw (1).lower, 1, 6)); /* get the gerout number index 	*/
     1865       if gicm_count > 0 then call return_plus (0);
     1866       else go to gerout (gerout_num);			/* goto the gerout handler for this gerout	*/
     1867 
     1868 
     1869 
     1870 gerout (4): wicmp = addrel (execp, mme_call_hf (1).upper);	/* get write icm pointer */
     1871       ricmp = addrel (execp, bin (wicm.rbuf_addr) - 1);	/* get read icm pointer */
     1872       if gicmp = null then alloc gicm;			/* alloc an icm area */
     1873       gicmp = addr (gicm);				/* get a ptr to it */
     1874       icm_tally = bin (wicm.word_total) * 2;		/* get icm tally */
     1875       k = bin (substr (mme_call_hw (1).lower, 15, 4));	/* get index */
     1876       if substr (mme_call_hw (1).lower, 13, 1) = "1"b then do; /* an exec request */
     1877          if substr (wicm.host_opcode, 10, 9) = "042"b3 then do; /* if load memory request */
     1878 	  alloc ticm;				/* allocate a temp icm */
     1879 	  ticmp = addr (ticm);			/* get a ptr */
     1880 	  ticm = wicm;				/* move the icm */
     1881 	  fnp_num = bin (substr (mme_call_hw (1).lower, 16, 3)) + 1; /* get the fnp number */
     1882 	  do i = 1 to 2;
     1883 	     if substr (ticm.icm_buf (1), 1, 18) = "777777"b3 then do; /* if first get mem icm */
     1884 	        call db_fnp_eval_ (null (), fnp_num, ".criom", null (), exec, fnp_addr, code);
     1885 						/* get address of fnp iom table */
     1886 	        if code ^= 0 then go to db_err;		/* if error go to error routine */
     1887 	        icm_tally = 1;			/* else set icm tally to correct value */
     1888 	     end;
     1889 	     else do;
     1890 	        i = 2;				/* second get mem icm */
     1891 	        icm_tally = bin (wicm.word_total) * 2;	/* compute the icm tally */
     1892 	        fnp_addr = bin (substr (ticm.icm_buf (1), 1, 18)); /* fill in fnp address */
     1893 	     end;
     1894 	     call db_fnp_memory_$fetch (null (), fnp_num, fnp_addr, icm_tally, addr (ticm.icm_buf), code);
     1895 						/* get the iom table */
     1896 db_err:	     if code ^= 0 then do;			/* if error */
     1897 	        call convert_status_code_ (code, shortinfo, lginfo);
     1898 	        call tolts_qttyio_$rs (0, "^as: ^a error reading fnp memory", tolts_info.exec, lginfo);
     1899 						/* can't read fnp memory */
     1900 	        ticm.fnp_opcode = "000051"b3;		/* set bad status */
     1901 	     end;
     1902 	     else ticm.fnp_opcode = "000041"b3;		/* supply op complete code */
     1903 	  end;
     1904 	  ticm.rbuf_addr = "0"b;			/* zero read buffer pointer */
     1905 	  call tolts_alm_util_$gen_ck_sum (ticmp);	/* generate an icm check sum */
     1906 	  ricm = ticm;				/* move icm */
     1907 	  free ticm;
     1908 	  ticmp = null;
     1909 	  if mme_call_hf (2).lower ^= 0 then do;	/* a cc is requested */
     1910 	     exec_wd (mme_call_hf (2).upper) = "000000000004"b3;
     1911 	     call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
     1912 	      mme_call_hw (2).lower || "000000"b3);	/* enter a ccc request */
     1913 	  end;
     1914          end;
     1915          else if substr (wicm.host_opcode, 10, 9) = "001"b3 then do; /* if a start test request */
     1916 	  do i = 1 to 8 while (colts_pages (i).in_use);	/* find vacant test page slot */
     1917 	  end;
     1918 	  if i = 8 & colts_pages (8).in_use then do;	/* if 8 pages running - error */
     1919 	     call tolts_qttyio_$rs (0, "^a: mme gerout 04; no vacant test page slot found", exec);
     1920 	     call tolts_abort ("$c1");
     1921 	  end;
     1922 
     1923 	  colts_pages (i).in_use = "1"b;		/* else set page in use */
     1924 
     1925 	  do j = 1 to 8;
     1926 	     if substr (fnp (k).cdt_name (j), 1, 5) ^= "empty" then do;
     1927 	        colts_pages (i).cdt_name = tolts_info.fnp (k).cdt_name (j);
     1928 						/* save the cdt name in the test page */
     1929 	        tolts_info.fnp (k).cdt_name (j) = "empty";
     1930 	        j = 8;
     1931 	     end;
     1932 	  end;
     1933 	  tolts_info.exec_page_count = tolts_info.exec_page_count + 1; /* inc test page count */
     1934 	  dmap = addr (tolts_info.colts_pages (i).dm_arg);/* get dial_manager_arg ptr */
     1935 	  colts_pages (i).dm_arg.version = dial_manager_arg_version_2; /* fill in the required fields */
     1936 	  colts_pages (i).dm_arg.dial_qualifier = substr (colts_pages (i).cdt_name, 1, 22);
     1937 	  colts_pages (i).dm_arg.dial_channel = tolts_info.dm_event;
     1938 	  colts_pages (i).dm_arg.channel_name = colts_pages (i).cdt_name;
     1939 	  colts_pages (i).type_code = substr (wicm.icm_buf (1), 22, 6);
     1940 	  nr_cnt = 0;				/* reset the no responce count */
     1941 	  call dial_manager_$tandd_attach (dmap, code);	/* get the channel for testing */
     1942 	  if code ^= 0 then do;			/* if error */
     1943 	     if debugging then call com_err_ (code, "mtdsim_", "Error on tandd_attachment of ^a.",
     1944 	         colts_pages (i).cdt_name);
     1945 	     colts_pages (i).in_use = "0"b;		/* reset test page active */
     1946 	     call convert_status_code_ (code, shortinfo, lginfo);
     1947 	     call tolts_qttyio_$rs (0, "^as: ^a/ error attempting a tandd_attach of ^a",
     1948 	      tolts_info.exec, lginfo, substr (colts_pages (i).cdt_name, 1, 6));
     1949 	     colts_op_flags.colt_flag = "0"b;		/* make use flag is reset so we don't go blocked */
     1950 	     alloc ticm;				/* allocate a temp icm */
     1951 	     ticmp = addr (ticm);			/* get a ptr */
     1952 	     ticm = wicm;				/* move the icm */
     1953 	     ticm.fnp_opcode = "000051"b3;		/* set error status code */
     1954 	     ticm.rbuf_addr = "0"b;			/* zero read buffer pointer */
     1955 	     call tolts_alm_util_$gen_ck_sum (ticmp);	/* generate an icm check sum */
     1956 	     ricm = ticm;				/* move icm */
     1957 	     free ticm;
     1958 	     ticmp = null;
     1959 	     if mme_call_hf (2).lower ^= 0 then do;	/* a cc is requested */
     1960 	        exec_wd (mme_call_hf (2).upper) = "000000000004"b3;
     1961 
     1962 	        call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
     1963 	         mme_call_hw (2).lower || "000000"b3);	/* enter a ccc request */
     1964 	     end;
     1965 	     call return_plus (3);
     1966 	  end;
     1967 	  tolts_info.wait_list.nchan = tolts_info.wait_list.nchan + 1; /* inc the event wait list */
     1968 	  tolts_info.wait_event_id (tolts_info.wait_list.nchan) = tolts_info.dm_event; /* store the event id */
     1969 	  clt_sw = substr (colts_pages (i).cdt_name, 1, 6) || ".sw"; /* create a switch name */
     1970 	  att_desc = "tty_ " || substr (colts_pages (i).cdt_name, 1, 6); /* and an attach description */
     1971 	  colts_op_flags.dm_attach = "1"b;		/* set colts control flags */
     1972 	  colts_op_flags.colt_flag = "1"b;
     1973 	  colts_op_flags.sicm = "1"b;
     1974 	  l = i;					/* save i for later use */
     1975          end;
     1976          else do;					/* else a normal exec icm */
     1977 	  call iox_$put_chars (fnp (k).fnp_execp, wicmp, (bin (wicm.word_total) + 1) * 4, code); /* transmit the icm */
     1978 	  if code ^= 0 then do;			/* if error */
     1979 	     call convert_status_code_ (code, shortinfo, lginfo);
     1980 	     call tolts_qttyio_$rs (0, "^as: ^a/ error on data xfer to fnp", tolts_info.exec, lginfo);
     1981 	     call tolts_abort ("$c1");		/* then abort colts */
     1982 	  end;
     1983 	  gicm_count = gicm_count + 1;		/* inc outstanding icms count */
     1984 
     1985 	  if gicm_count = 17 then do;			/* if = 17 - error */
     1986 	     call tolts_qttyio_$rs (0, "^as: excessive outstanding io's", tolts_info.exec);
     1987 	     call tolts_abort ("$c1");		/* abort colts */
     1988 	  end;
     1989 
     1990 	  gicm.cltp = fnp (k).fnp_execp;		/* save iocb ptr */
     1991 	  gicm.ricmp = ricmp;			/* rd icm ptr */
     1992 	  gicm.tally = bin (wicm.word_total) + 1;	/* icm tally */
     1993 	  if mme_call_hf (2).lower ^= 0 then do;	/* if cc requested */
     1994 	     gicm.cc_addr = mme_call_hw (2).lower || "000000"b3; /* save ccc address */
     1995 	     gicm.st_addr = mme_call_hf (2).upper;	/* save status address */
     1996 	  end;
     1997          end;
     1998       end;
     1999       else do;					/* else icm for test chan */
     2000 
     2001          call iox_$put_chars (colts_pages (k).chanp, wicmp, (bin (wicm.word_total) + 1) * 4, code); /* send the icm */
     2002          if code ^= 0 then do;			/* if error */
     2003 	  call convert_status_code_ (code, shortinfo, lginfo);
     2004 	  call tolts_qttyio_$rs (0, "^as: ^a/ error on data xfer to chan ^a",
     2005 	   tolts_info.exec, lginfo, substr (colts_pages (k).cdt_name, 1, 6));
     2006 	  colts_pages (k).status_word = "000000000002"b3; /* store bad status */
     2007          end;
     2008 
     2009          gicm_count = gicm_count + 1;			/* inc outstanding icm count */
     2010 
     2011          if gicm_count = 17 then do;			/* if 17 - error */
     2012 	  call tolts_qttyio_$rs (0, "as: excessive outstanding io count", tolts_info.exec);
     2013 	  call tolts_abort ("$c1");			/* abort tolts */
     2014          end;
     2015          gicm.cltp = colts_pages (k).chanp;		/* save iocb ptr */
     2016          gicm.ricmp = ricmp;				/* read icm ptr */
     2017          gicm.tally = bin (wicm.word_total) + 1;		/* tally */
     2018          if mme_call_hf (2).lower ^= 0 then do;		/* if cc requested */
     2019 	  gicm.cc_addr = mme_call_hw (2).lower || "000000"b3; /* save ccc address */
     2020 	  gicm.st_addr = mme_call_hf (2).upper;		/* status address */
     2021          end;
     2022       end;
     2023       call return_plus (3);
     2024 
     2025 
     2026 
     2027 gerout (5): remote_inquiry_ic = bin (rel (addr (mme_call_w (1)))); /* remember remote inquiry location */
     2028       call return_plus (3);				/* return to colts */
     2029 
     2030 gerout (06):
     2031       k = bin (substr (mme_call_hw (1).lower, 15, 4));
     2032       if substr (mme_call_hw (1).lower, 13, 1) = "1"b then
     2033          mme_call_hw (1).upper = tolts_info.fnp (k).exec_type_code || "0000"b3; /* set type code	*/
     2034 
     2035       else substr (mme_call_hw (1).upper, 1, 6) = colts_pages (k).type_code;
     2036       call return_plus (3);
     2037 
     2038 
     2039 gerout (7): if remote_inquiry_ic ^= 0 then do;		/* if no outstanding remote inquiry - error */
     2040 
     2041          k = bin (substr (mme_call_hw (1).upper, 1, 3));	/* k = fnp number */
     2042 
     2043          if ^tolts_info.fnp (k).exec_active then do;	/* if the fnp exec is not active */
     2044 	  dmap = addr (tolts_info.fnp (k).dm_arg);	/* get addr of dial_manager arg */
     2045 	  fnp (k).dm_arg.version = dial_manager_arg_version_2;
     2046 	  fnp (k).dm_arg.dial_qualifier = substr (fnp (k).exec_chan, 1, 22);
     2047 	  tolts_info.fnp (k).dm_arg.dial_channel = tolts_info.dm_event; /* set dial_channel to event channel */
     2048 	  tolts_info.fnp (k).dm_arg.channel_name = fnp (k).exec_chan; /* get channel name	*/
     2049 
     2050 	  nr_cnt = 0;				/* reset the no responce count */
     2051 	  call dial_manager_$privileged_attach (dmap, code);
     2052 	  if code ^= 0 then do;
     2053 	     call convert_status_code_ (code, shortinfo, lginfo);
     2054 	     call tolts_qttyio_$rs (0, "^as: ^a/ error attempting a priviledged_attatch of ^a",
     2055 	      tolts_info.exec, lginfo, fnp (k).channel_name);
     2056 	     call tolts_abort ("$c1");		/* then abort colts */
     2057 	  end;
     2058 
     2059 	  tolts_info.wait_list.nchan = wait_list.nchan + 1;
     2060 	  tolts_info.wait_event_id (tolts_info.wait_list.nchan) = tolts_info.dm_event;
     2061 	  clt_sw = substr (fnp (k).exec_chan, 1, 6) || ".sw";
     2062 
     2063 	  att_desc = "tty_ " || substr (fnp (k).exec_chan, 1, 6);
     2064 	  colts_op_flags.colt_flag = "1"b;
     2065 	  colts_op_flags.dm_attach = "1"b; ;
     2066 	  fnp (k).exec_type_code = substr (mme_call_hw (1).lower, 13, 6); /* save exec type code	*/
     2067          end;
     2068          call return_plus (2);
     2069       end;
     2070       else do;
     2071          call tolts_qttyio_$rs (0, "^as:  MME GEROUT 07 - no outstanding GEROUT 05", exec);
     2072          call tolts_abort ("$c9");
     2073       end;
     2074 
     2075 
     2076 gerout (15): if mme_call_hw (1).lower = "170000"b3 then call return_plus (3);
     2077       k = bin (substr (mme_call_hw (1).lower, 15, 4));
     2078       if substr (mme_call_hw (1).lower, 13, 3) = "4"b3 then call rel_exec_chan (k);
     2079 
     2080       else call rel_tst_chan (k);
     2081 
     2082       if mme_call_hf (2).lower ^= 0 then do;
     2083          exec_wd (mme_call_hf (2).upper) = "000000000002"b3;
     2084          call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue), mme_call_hw (2).lower || "000000"b3);
     2085       end;
     2086 
     2087       call return_plus (3);
     2088 
     2089 
     2090 
     2091 gerout (16): k = bin (substr (mme_call_hw (1).lower, 15, 4));
     2092       if substr (mme_call_hw (1).lower, 13, 1) = "1"b then
     2093          exec_wd (mme_call_hf (2).upper) = "000000000004"b3;
     2094       else exec_wd (mme_call_hf (2).upper) = colts_pages (k).status_word;
     2095       call return_plus (3);
     2096 
     2097 
     2098 
     2099 
     2100 /* ********* MME GESNAP ********* (snap shot dump)
     2101*
     2102*   input/return registers: none
     2103*
     2104*   mme     gesnap
     2105*   iotd    add,wc
     2106*   ------  return */
     2107 
     2108 mme_typ (5): if trace then call tolts_qttyio_$rs (10, "^a MME GESNAP @ ^p", ctime (), mmep);
     2109       if tolts_info.file_attach then			/* if print file attached */
     2110          call tolts_file_util_$snap (addrel (mmep, 1));	/* go output snap dump */
     2111       call return_plus (2);				/* return ic + 2 */
     2112 						/* ********* MME GETIME ********* (return date/time)
     2113*
     2114*						   input registers: none
     2115*
     2116*						   mme     getime
     2117*						   ------  return
     2118*
     2119*						   return registers:   AR - date,  QR - time (right justified--1/64 ms. past midnight */
     2120 
     2121 mme_typ (17): if trace then call tolts_qttyio_$rs (10, "^a MME GETIME @ ^p", ctime (), mmep);
     2122       call tolts_init_$gc_tod (spa.regs.q);		/* get time of day */
     2123       spa.regs.a = tolts_info.gc_date;			/* and bcd date */
     2124       call return_plus (1);
     2125 
     2126 /* ********* MME HUNGTM ********* (check for outstanding I/O)
     2127*
     2128*   input registers:   AU = test page index (mod 4)
     2129*
     2130*   mme     hungtm
     2131*   ------  return not in transmission
     2132*   ------  return in transmission
     2133*
     2134*   return registers: QR = lostit time, X1 = 5 if timeout; = 3 if still time to go */
     2135 
     2136 mme_typ (-16): if trace then call tolts_qttyio_$rs (10, "^a MME HUNGTM @ ^p", ctime (), mmep);
     2137       call get_px_sct ("HUNGTM", bin (substr (spa.regs.a, 1, 18), 17), "1"b); /* get test page index */
     2138       if substr (spa.regs.a, 1, 18) = "0"b then do;
     2139          call tolts_qttyio_$rs (0, "^a MME HUNGTM  illegal test page index @ ^p", ctime (), mmep);
     2140          call tolts_abort ("$b6");
     2141       end;
     2142       call tolts_init_$gc_tod (gcos_tod);		/* get current time of day */
     2143       if bin (gcos_tod, 36) >= io_info.con_time + io_info.lostit_time then do; /* if time exceeded */
     2144          spa.regs.x (1) = "000005"b3;			/* set courtesy call wating */
     2145          exec_wd (io_info.status_add) = "510006000000"b3;	/* set time out status */
     2146          call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
     2147 	string (io_info.icivlu));			/* enter ccc request */
     2148          spa.regs.q = "0"b;				/* set 0 lostit time */
     2149       end;
     2150       else do;					/* not time out yet */
     2151          spa.regs.x (1) = "000003"b3;			/* set in xmission */
     2152          spa.regs.q = bit ((io_info.con_time + io_info.lostit_time) - bin (gcos_tod, 35, 0), 35);
     2153       end;
     2154       call return_plus (2);				/* return ic + 2 */
     2155 
     2156 /* ********* MME IOCONS ********* (return number of I/O connects)
     2157*
     2158*   input registers:   x1 = sct (test page index mod 4)
     2159*
     2160*   mme     iocons
     2161*   ------  return
     2162*
     2163*   return registers:   AR = number of connects for this test page */
     2164 
     2165 mme_typ (-17): if trace then call tolts_qttyio_$rs (10, "^a MME IOCONS @ ^p", ctime (), mmep);
     2166       call get_px_sct ("IOCONS", bin (spa.regs.x (1), 17), "1"b); /* get test page index */
     2167       spa.regs.a = bit (bin (pages (io_sel).num_connects, 36));
     2168       call return_plus (1);
     2169 
     2170 /* ********* MME IPCW. ********* ( send initialize PCW to mpc )
     2171*
     2172*   input registers:   x1 = ICC
     2173*
     2174*
     2175*   mme     ipcw.
     2176*   ------  return
     2177*
     2178*   return registers: none */
     2179 
     2180 mme_typ (-55): if trace then call tolts_qttyio_$rs (10, "^a MME IPCW. @ ^p", ctime (), mmep);
     2181       if substr (spa.regs.x (1), 7, 1) then		/* if new format */
     2182          call get_px_tcx ("IPCW. ", substr (spa.regs.x (1), 8, 11)); /* get test page index */
     2183       else call get_px_tcx ("IPCW. ", substr (spa.regs.x (1), 10, 9)); /* get test page index */
     2184       pcwa = "0"b;					/* initialize pcw first */
     2185       pcwp = addr (pcwa);
     2186       pcw.code = "111"b;				/* Set PCW code */
     2187       pcw.mask = "1"b;				/* Make it a reset PCW */
     2188       pcw.control = "11"b;
     2189       ioi_wksp = io_info.workspace_ptr;			/* get ptr to our workspace */
     2190       tio_off = fixed (rel (addr (tolts_workspace.p_idcw)));/* set default dcw list offset for ioi */
     2191       idcwp = addr (tolts_workspace.p_idcw);		/* set up idcw ptr */
     2192       string (idcw) = "0"b;				/* intiialize idcw */
     2193       idcw.code = "7"b3;				/* set in idcw type code */
     2194       io_info.to_no_cc = "1"b;			/* set flag for int processor */
     2195       call ioi_$connect_pcw (io_info.device_index, tio_off, pcwa, error);
     2196       if error ^= 0 then do;
     2197          call output_status_code (error, "io connect error");
     2198          call tolts_abort ("$m5");
     2199       end;
     2200       call return_plus (1);
     2201 
     2202 /* ********* MME LODIMG ********* (load print train image (GCOS only))
     2203*
     2204*   input registers:   x1 = sct (test page index mod 4)
     2205*
     2206*   mme     lodimg
     2207*   ------  return good
     2208*   ------  return bad
     2209*
     2210*   return registers: none */
     2211 
     2212 mme_typ (-18): if trace then call tolts_qttyio_$rs (10, "^a MME LODIMG @ ^p", ctime (), mmep);
     2213       call return_plus (1);				/* return ic + 1 */
     2214 
     2215 /* ********* MME LODVFC ********* (load printer vertical format control (VFC) (GCOS only))
     2216*
     2217*   input registers:   x1 = sct (test page index mod 4)
     2218*
     2219*   mme     lodvfc
     2220*   ------  return good
     2221*   ------  return error
     2222*
     2223*   return registers:   a-reg = error code on error */
     2224 
     2225 mme_typ (-19): if trace then call tolts_qttyio_$rs (10, "^a MME LODVFC @ ^p", ctime (), mmep);
     2226       call return_plus (1);				/* return ic + 1 */
     2227 
     2228 /* ********* MME LPW. ********* ( return LPW tally residue )
     2229*
     2230*   input registers:   x1 = ICC
     2231*
     2232*   mme     lpw.
     2233*   ------  return
     2234*
     2235*   return registers:   A-REG = LPW, .crmb1,1 */
     2236 
     2237 mme_typ (-52): if trace then call tolts_qttyio_$rs (10, "^a MME LPW. @ ^p", ctime (), mmep);
     2238       if substr (spa.regs.x (1), 7, 1) then		/* if new format */
     2239          call get_px_tcx ("LPW.  ", substr (spa.regs.x (1), 8, 11)); /* get test page index */
     2240       else call get_px_tcx ("LPW.  ", substr (spa.regs.x (1), 10, 9)); /* get test page index */
     2241       ioi_wksp = pages (io_sel).workspace_ptr;		/* get ptr to proper workspace */
     2242       spa.regs.a = tolts_workspace.lpw (1);		/* copy lpw tally residue */
     2243       call return_plus (1);
     2244 
     2245 
     2246 /* ********* MME MASTER MODE ENTRY ********* */
     2247 
     2248 mme_typ (30):					/* not valid on Multics */
     2249       call return_plus (1);
     2250 
     2251 
     2252 
     2253 
     2254 
     2255 /* ********* MME MBXCMP ********* (Responder compare mailbox data)
     2256*
     2257*   inputr registers:
     2258*
     2259*   X1 = pointer to was data
     2260*   X2 = pointer to s/b data
     2261*   X5 = fpinfo pointer
     2262*   mme     mbxcmp
     2263*   error return
     2264*   good return
     2265*
     2266*   return registers:
     2267*   A = bad data if not compare  */
     2268 
     2269 mme_typ (-90): if trace then call tolts_qttyio_$rs (10, "^a MME MBXCMP @ ^p", ctime (), mmep);
     2270 
     2271       tolts_fpinfo_ptr = addrel (execp, spa.regs.x (5));	/* get a ptr to the test page fpinfo table */
     2272       do io_sel = 1 to hbound (pages, 1)		/* get the io_info for this page */
     2273        while (pages (io_sel).fnp_num ^= tolts_fpinfo.pcw_info.fnp_num);
     2274       end;
     2275       if io_sel > hbound (pages, 1) then call tolts_abort ("$c3"); /* io_info for this page not found */
     2276       io_info_ptr = addr (pages (io_sel));
     2277       tolts_rspd_wksp = io_info.tolts_rspd_wksp;
     2278       lvl_idx = (bin (substr (spa.regs.x (1), 13, 3)));	/* get the level */
     2279       ws_data_idx = (bin (substr (spa.regs.x (1), 16, 3))); /* was data index */
     2280       sb_data_idx = (bin (substr (spa.regs.x (2), 16, 3))); /* s/b data index */
     2281       if tolts_rspd_workspace.ima_level (lvl_idx).word (sb_data_idx) /* compare the data */
     2282        ^= tolts_rspd_workspace.ima_level (lvl_idx).word (ws_data_idx) then do;
     2283          spa.regs.a = tolts_rspd_workspace.ima_level (lvl_idx).word (ws_data_idx);
     2284          call return_plus (1);			/* take error return */
     2285       end;
     2286       else call return_plus (2);			/* take good return */
     2287 
     2288 
     2289 /* ********* MME MBXDAT ********* (mme to manipulate mailbox data)
     2290*
     2291*   input registers:
     2292*   x1 = pointer to FPINFO table
     2293*   x2 = subcommand code
     2294*   1 = MBLC (get mbx location)       2 = INITMB (intialize mailbox data)
     2295*   3 = RDMBX (read mailbox)	       6 = RDINT (read interrupt word)
     2296*   7 = RDINT0 (rd intrpt wrd & 0)   11 = STMBX (store mailbox word)
     2297*
     2298*   mme	MBXDAT
     2299*   zero	error return       (mme call + 1)
     2300*   zero	timeout return       (mme call + 2)
     2301*   zero	retry return       (mme call + 3)
     2302*   zero	good return        (mme call + 4)
     2303*
     2304*   return registers:
     2305*   A & Q = data requested.
     2306*
     2307*   Data is also entered into FPINFO table.
     2308*
     2309*   dcl 1 tolts_fpinfo aligned based (tolts_fpinfo_ptr),
     2310*   *      2 pcw_info,
     2311*   *         3 fnp_num fixed bin unaligned,
     2312*   *         3 chan fixed bin (6) unaligned,
     2313*   *         3 cmnd fixed bin (6) unaligned,
     2314*   *     2 fnpdcw,
     2315*   *         3 address fixed bin unaligned,
     2316*   *         3 word_count fixed bin unaligned,
     2317*   *     2 io_rq_cnt fixed bin (35),
     2318*   *     2 mbxloc fixed bin (35),
     2319*   *     2 spec_cnt fixed bin,
     2320*   *     2 term_cnt fixed bin,
     2321*   *     2 partrs fixed bin (35),
     2322*   *     2 timeout_time fixed bin (35),
     2323*   *     2 temp01,
     2324*   *       3 word1,
     2325*   *         4 upper bit (18),
     2326*   *         4 lower bit (18),
     2327*   *       3 word2,
     2328*   *         4 upper bit (18),
     2329*   *         4 lower bit (18),
     2330*   *     2 temp02,
     2331*   *       3 word1,
     2332*   *         4 upper bit (18),
     2333*   *         4 lower bit (18),
     2334*   *       3 word2,
     2335*   *         4 upper bit (18),
     2336*   *         4 lower bit (18),
     2337*   *     2 temp03,
     2338*   *       3 word1,
     2339*   *         4 upper bit (18),
     2340*   *         4 lower bit (18),
     2341*   *       3 word2,
     2342*   *         4 upper bit (18),
     2343*   *         4 lower bit (18),
     2344*   *     2 lvl3_flag bit (36),
     2345*   *     2 lvl7_flag bit (36),
     2346*   *     2 lvl3_cnt fixed bin (35),
     2347*   *     2 lvl7_cnt fixed bin (35),
     2348*   *     2 pprt_avail bit (35); */
     2349 
     2350 
     2351 
     2352 mme_typ (-65): if trace then call tolts_qttyio_$rs (10, "^a MME MBXDAT ^p, type - ^6.3b", ctime (), mmep, spa.regs.x (2));
     2353 
     2354       tolts_fpinfo_ptr = addrel (execp, spa.regs.x (1));	/* get a ptr to the test page fpinfo table */
     2355       do io_sel = 1 to hbound (pages, 1)		/* get the io_info for this page */
     2356        while (pages (io_sel).fnp_num ^= tolts_fpinfo.pcw_info.fnp_num);
     2357       end;
     2358       if io_sel > hbound (pages, 1) then call tolts_abort ("$c3"); /* io_info for this page not found */
     2359       io_info_ptr = addr (pages (io_sel));
     2360       io_info.fpinfo_ptr = tolts_fpinfo_ptr;
     2361       goto sub_cmnd (bin (spa.regs.x (2)));
     2362 
     2363 
     2364 sub_cmnd (1):
     2365 
     2366 
     2367       call tolts_device_info_ (addr (io_info.test_req), io_sel, t_err);
     2368       if t_err ^= 0 then call tolts_abort ("$c4");
     2369 
     2370 /* create an event call channel for tdio status events */
     2371 
     2372       if ^io_info.ev_ch_ass then do;			/* we we havn't done this already */
     2373          call tolts_init_$cr_event_chan (io_info.status_event,
     2374 	"1"b, tolts_io_int_, io_info_ptr, 2, error);
     2375          if error ^= 0 then				/* if error creating event call chan */
     2376 	  call tolts_abort ("$a9");
     2377          io_info.ev_ch_ass = "1"b;			/* set event chan assigned flag */
     2378       end;
     2379       call ioa_$rsnnl ("T&D is attaching for a ^[write^]^[read^] ^a",
     2380        att_desc, mesg_len, (^rd_flag), (rd_flag), io_info.device_name);
     2381       call rcp_$attach (io_info.rcp_name, addr (io_info.rcp_area (1)), io_info.status_event,
     2382        att_desc, io_info.rcp_id, error);
     2383 
     2384       if error ^= 0 then do;
     2385          call output_status_code (error, "rcp attach error");
     2386          call dealcp_sub;				/* go release status event */
     2387          call tolts_abort ("$c5");
     2388       end;
     2389 
     2390       call rcp_$check_attach (io_info.rcp_id, addr (io_info.rcp_area (1)), coment, io_info.device_index,
     2391        tolts_info.max_wks_sz, tolts_info.max_to, io_info.rcp_state, io_info.attach_err);
     2392       if io_info.attach_err ^= 0
     2393        | io_info.rcp_state ^= 0 then do;
     2394          if io_info.attach_err ^= 0 then
     2395 	  call output_status_code (io_info.attach_err, "workspace assign error");
     2396          call dealcp_sub;
     2397          call tolts_abort ("$c6");
     2398       end;
     2399       io_info.p_att = "1"b;
     2400       io_info.tolts_rspd_wksp = addr (tolts_rspd_workspace);
     2401       call ioi_$workspace (io_info.device_index, io_info.tolts_rspd_wksp, tolts_info.wks_sz, error);
     2402       if error ^= 0 then do;
     2403          call output_status_code (error, "workspace assign error");
     2404          call dealcp_sub;				/* go release status event */
     2405          call tolts_abort ("$c6");
     2406       end;
     2407       io_info.cur_wks_sz = tolts_info.wks_sz;		/* set current value of workspace size */
     2408       call ioi_$set_status (io_info.device_index, fixed (rel (addr (tolts_rspd_workspace.mailbox.status_word)), 18), 1, error);
     2409 
     2410       tolts_fpinfo.mbxloc = 0;
     2411       spa.regs.q = "0"b;
     2412       tolts_fpinfo.partrs = -1;
     2413 
     2414       call return_plus (4);
     2415 
     2416 
     2417 sub_cmnd (2):
     2418 
     2419       tolts_rspd_wksp = io_info.tolts_rspd_wksp;
     2420       unspec (tolts_rspd_workspace.num_int) = "0"b;
     2421 
     2422       call return_plus (4);
     2423 
     2424 
     2425 sub_cmnd (3):
     2426 
     2427       tolts_rspd_wksp = io_info.tolts_rspd_wksp;
     2428       spa.regs.a = unspec (tolts_rspd_workspace.mailbox.pcw);
     2429 
     2430       call return_plus (4);
     2431 
     2432 sub_cmnd (6):
     2433 
     2434       tolts_rspd_wksp = io_info.tolts_rspd_wksp;
     2435       unspec (tolts_fpinfo.temp03.word1) = unspec (tolts_rspd_workspace.mailbox.num_int);
     2436 
     2437       call return_plus (4);
     2438 
     2439 sub_cmnd (7):
     2440 
     2441       tolts_rspd_wksp = io_info.tolts_rspd_wksp;
     2442       unspec (tolts_fpinfo.temp03.word2) = unspec (tolts_rspd_workspace.mailbox.num_int);
     2443       unspec (tolts_rspd_workspace.mailbox.num_int) = "0"b;
     2444 
     2445       call return_plus (4);
     2446 
     2447 sub_cmnd (11):
     2448 
     2449       tolts_rspd_wksp = io_info.tolts_rspd_wksp;
     2450       k = bin (substr (tolts_fpinfo.temp03.word1.upper, 13, 3));
     2451       unspec (tolts_rspd_workspace.ima_level (k)) = "0"b;
     2452       do i = 1 to bin (tolts_fpinfo.temp02.word1.upper);
     2453          ima_level (k).word (i) = spa.regs.a;
     2454       end;
     2455 
     2456       call return_plus (4);
     2457 
     2458 
     2459 
     2460 
     2461 /* ********* MME PACMAN ********* (allocate IPC's for mcad test )
     2462*
     2463*   input registers:			    Channel List format:
     2464*   x1 = sct (test page index mod 4)	    vfd 9/base chnl,9/# of chnls,16/flags
     2465*   x2 = address of channel list	    .
     2466*   x5 = address of mca config		    .
     2467*   A  =  0 then attach channels	    oct -1 end of list flag
     2468*   A ^= 0 then return channels
     2469*   Q  = ICC
     2470*   mme	pacman
     2471*   zero	error return	x2 = reason code		  (mme call + 1)
     2472*   zero	error return	no chnls requested configured	  (mme call + 2)
     2473*   zero	retry return	I/O in progress, retry	  (mme call + 3)
     2474*   zero	good return	requested chnls assigned	  (mme call + 4)
     2475*
     2476*   return registers:
     2477*   X2 = error code on error (see set_sctwrk subroutine for error codes)
     2478*   *			output in sctwrk (12 words): see the set_sctwrk subroutine */
     2479 
     2480 dcl  1 chan_list aligned based (clp),
     2481          (2 base_chan fixed bin (9) uns,
     2482        2 num_chans fixed bin (9) uns,
     2483        2 flags,
     2484          3 reboot bit (1),
     2485          3 pad bit (17)) unaligned;
     2486 dcl  clp ptr;
     2487 dcl  p99 pic "99" based;
     2488 
     2489 
     2490 mme_typ (-87): if trace then call tolts_qttyio_$rs (10, "^a MME PACMAN @ ^p", ctime (), mmep);
     2491 
     2492       if substr (spa.regs.q, 7, 1) then			/* if new format */
     2493          call get_px_tcx ("PACMAN", substr (spa.regs.q, 8, 11)); /* get test page index */
     2494       else call get_px_tcx ("PACMAN", substr (spa.regs.q, 10, 9)); /* get test page index */
     2495       clp = addrel (execp, fixed (spa.regs.x (2)));
     2496       if spa.regs.a = "0"b then do;
     2497          if io_info.ipc_attached then do;
     2498 	  call mca_$detach_ipc ((io_info.ipc_id), io_info.mca_ioi_idx, "0"b, code);
     2499 	  call tolts_qttyio_$rs (0, "^a ipc was still attached will detach leaving the device suspended", io_info.ipc_id);
     2500          end;
     2501          io_info.ipc_id = substr (io_info.device_name, 4, 1) || convert (p99, (chan_list.base_chan));
     2502          call mca_$attach_ipc ((io_info.ipc_id), io_info.mca_ioi_idx, io_info.ipc_number, code);
     2503          if code ^= 0 then do;
     2504 	  if code = error_table_$resource_unavailable then do; /* must have been busy */
     2505 	     spa.regs.x (2) = bit (dev_busy);		/* set appropriate error code */
     2506 	     call tolts_qttyio_$rs (0, "^a ipc ^a busy", io_info.test_hdr, io_info.ipc_id);
     2507 	     call return_plus (1);			/* return ic + 7 */
     2508 	  end;
     2509 	  else do;
     2510 	     call output_status_code (code, "ipc attach error");
     2511 	     spa.regs.x (2) = bit (os_deny);		/* set appropriate error code */
     2512 	     call return_plus (1);			/* take error return */
     2513 	  end;
     2514          end;
     2515          io_info.ipc_attached = "1"b;
     2516       end;
     2517       else if io_info.ipc_attached then do;
     2518          call mca_$detach_ipc ((io_info.ipc_id), io_info.mca_ioi_idx,
     2519 	chan_list.flags.reboot, code);
     2520          if code ^= 0 then call tolts_abort ("$p2");
     2521          else io_info.ipc_attached = "0"b;
     2522       end;
     2523       call return_plus (4);
     2524 
     2525 
     2526 
     2527 /* *************************************************************************************************************
     2528*   *   MTAR has to know what operating system it is running on. This code passes the Multics code to cmlt
     2529*   *   which passes it to mtar at initialize time.   *
     2530*   ************************************************************************************************************** */
     2531 
     2532 /*    ********* MME POINIT ********* (slave executive initialize)
     2533*
     2534*   input/output registers: none
     2535*
     2536*   mme	poinit
     2537*   zero	wwflag,o.s. code	from .crfig (upper) Multics o.s. code (lower)
     2538*   zero	lstloc,0	core size available as loaded
     2539*   zero	tewrk,0	from .crctb
     2540*   zero	.tdioc,0	from .crioc
     2541*   zero	wradd,0	wrapup address
     2542*   zero	cvttbl,0	conversion table ptr
     2543*   zero	mmexec,0	position of ttl date in message
     2544*   zero	mintr,0	min/max memory test ranges (2 words)
     2545*   zero	crafc0,0	.cracf bit 3 & mpc entry if single disk & disk acf for pri and alt files (3 words )
     2546*   ----	return	return is mme call + 10
     2547*
     2548*   .crfig:
     2549*
     2550*   0 = series 60 0r 6000	6 = system sckd. save opt.		24-30 = reserved for gcos
     2551*   1 = class. module present	7 = reserved for gcos		31 = not in mem avail. space tab
     2552*   2 = shared memory system	8,9,10,11 = ioms 0-3 configured	32 = RLP300 present
     2553*   3 = >256k		12,13,14,15 = CPUs 0-3 configured	33 = DN30
     2554*   4 = IOM system		16-19 = reserved for gcos		34 = DN305
     2555*   5 = series 60 system	20,21,22,23 = CPU has EIS		35 = DN	355/6600
     2556*
     2557*   .crctb ->    chars specify the first six tabs beyond position 0
     2558*   .crioc ->    -1 = IOMs */
     2559 
     2560 mme_typ (-20): if trace then call tolts_qttyio_$rs (10, "^a MME POINIT @ ^p", ctime (), mmep);
     2561       exec_wd (mme_call_hf (1).upper) = "0"b;		/*	zeros says not ww system */
     2562       if mme_call_hf (1).lower ^= 0 then
     2563          exec_wd (mme_call_hf (1).lower) = "000000000002"b3;/* store Multics code if pointer */
     2564       exec_wd (mme_call_hf (3).upper) = "122436506274"b3;	/*	tabs at 10,20,30,40,50,60  */
     2565       iom_cardp = null;
     2566       term = "0"b;					/* reset terminate condition */
     2567       do while (^term);				/* find all iom cards */
     2568          call tolts_util_$find_card ("iom ", iom_cardp);	/* find iom card */
     2569          if iom_cardp = null then term = "1"b;		/* completed search of the deck */
     2570          else do;
     2571 	  if iom_card.model = "imu " then imu_found = "1"b;
     2572 	  else if iom_card.model = "iom" then iom_found = "1"b;
     2573          end;
     2574       end;
     2575 
     2576       if imu_found then				/* imu system  */
     2577          exec_wd (mme_call_hf (4).upper) = "777777000000"b3;
     2578       else if iom_found then				/* iom system */
     2579          exec_wd (mme_call_hf (4).upper) = "777777777777"b3;
     2580       else exec_wd (mme_call_hf (4).upper) = "0"b3;	/* let the usbexec complain */
     2581 
     2582       spa.wrapup_add = mme_call_hw (5).upper;		/* set wrapup address */
     2583       call tolts_alm_util_$ascii_to_bcd_ (ttl_date, bcd_callname); /* convert ttl date to bcd */
     2584       exec_wd (mme_call_hf (7).upper) = bcd_callname;	/* and store in message */
     2585       substr (exec_wd (mme_call_hf (7).upper - 1), 19, 18) = "622017"b3; /* change version? ?? to version?s ? */
     2586       genp = addrel (execp, mme_call_hf (2).upper);	/* get ptr to lstloc */
     2587       if exec = "molt" then do;
     2588          if fix_wd (1) ^= 0 then			/* if lstloc specified... */
     2589 	  mem_now, fix_wd (1) = fix_wd (1) + 196608;	/* add 196k to lstloc */
     2590          else mem_now, fix_wd (1) = fixed (gload_data.text_len) + 196608; /* otherwise use loaded length */
     2591       end;
     2592       else do;
     2593          if fix_wd (1) ^= 0 then			/* if lstloc specified... */
     2594 	  mem_now, fix_wd (1) = fix_wd (1) + 32768;	/* add 32k to lstloc */
     2595          else mem_now, fix_wd (1) = fixed (gload_data.text_len) + 32768; /* otherwise use loaded length */
     2596       end;
     2597       call cpu_time_and_paging_ (i, cpu_time, j);		/* get current cpu time */
     2598       tolts_info.init_time = cpu_time;			/* save  */
     2599       call return_plus (10);				/* return ic + 10 */
     2600 
     2601 /* ********* MME PROCTM ********* (return CPU time used since exec init)
     2602*
     2603*   input registers: none
     2604*
     2605*   mme     proctm
     2606*   ------  return
     2607*
     2608*   return registers:   a-reg = processor time in 1/64 ms */
     2609 
     2610 mme_typ (-21): if trace then call tolts_qttyio_$rs (10, "^a MME PROCTM @ ^p", ctime (), mmep);
     2611       call cpu_time_and_paging_ (i, cpu_time, j);		/* get current cpu time */
     2612       cpu_time = cpu_time - tolts_info.init_time;		/* compute delta */
     2613       spa.regs.a = bit (bin (divide (cpu_time * 64, 1000, 71, 0), 36)); /* return time */
     2614       call return_plus (1);
     2615 
     2616 /* ********* MME PRTRAN ********* (load print train image for test)
     2617*
     2618*   input registers:   x1 = sct (test page index mod 4)
     2619*
     2620*   mme     prtran
     2621*   zero    loc,0 pointer to buffer for train image
     2622*   ------  return error
     2623*   ------  return good
     2624*
     2625*   return registers: AR contains error code if error */
     2626 
     2627 mme_typ (-22): if trace then call tolts_qttyio_$rs (10, "^a MME PRTRAN @ ^p", ctime (), mmep);
     2628       call get_px_sct ("PRTRAN", bin (spa.regs.x (1), 17), "1"b); /* get test page index */
     2629       do i = 1 to printer_images_$n_images while (io_info.devsct.ptrain ^= printer_images_$image_numbers (i));
     2630       end;
     2631       if i > printer_images_$n_images then do;
     2632          call tolts_qttyio_$rs (0, "^as: MME PRTRAN; No such train number - ^d",
     2633 	exec, io_info.devsct.ptrain);
     2634          call tolts_abort ("$b1");
     2635       end;
     2636       tp = addrel (addr (printer_images_$image_base), printer_images_$image_offsets (i));
     2637       train_ptr = addrel (execp, mme_call_hf (1).upper);
     2638       train_ptr -> prt_image = tp -> prt_image;
     2639       call return_plus (3);				/* return ic + 3 */
     2640 
     2641 /* ********* MME READIO ********* (read options)
     2642*
     2643*   input registers:	   x1 = 3/exec #,9/0,6/cid
     2644*   *		   x4 -> (see opt_temp structure declaration below)
     2645*
     2646*   mme     readio
     2647*   ------  return if tolts aborted
     2648*   ------  return if tolts swapped
     2649*   ------  return good
     2650*
     2651*   return registers: none */
     2652 
     2653 dcl  1 opt_temp based (genp) aligned,			/* template for MME READIO */
     2654        (2 bcd_o_dash bit (18),			/* = bcd " o-" */
     2655        2 tdpcn_add fixed bin,				/* address of .tdpcn */
     2656        2 bufnum fixed bin,				/* tadio buffer (array element) number */
     2657        2 nu1 bit (6),
     2658        2 exec_num bit (6),
     2659        2 nu2 bit (6),
     2660        2 opt_ptr fixed bin,				/* ptr to options storage area */
     2661        2 nu3 bit (6),
     2662        2 phy_term bit (12)) unaligned;			/* physical terminal id */
     2663 
     2664 dcl  bcd_options bit (6 * 84) based (genp);		/* to move options to test page */
     2665 
     2666 mme_typ (-24): if trace then call tolts_qttyio_$rs (10, "^a MME READIO @ ^p", ctime (), mmep);
     2667       genp = addrel (execp, spa.regs.x (4));		/* get ptr to options template */
     2668       i = opt_temp.bufnum;				/* get tadio buffer number */
     2669       tolts_info.tadio (i).inuse = "0"b;		/* reset  buffer in use flag */
     2670       genp = addrel (execp, opt_temp.opt_ptr);		/* get ptr to store options */
     2671       bcd_options = tolts_info.tadio (i).option;		/* move options to test page */
     2672       call return_plus (3);				/* return ic + 3 */
     2673 
     2674 /* ********* MME RELEAS ********* ( release device (reboot mpc firmware if running ITRs))
     2675*
     2676*   input registers:
     2677*
     2678*   *	POLT			MOLT
     2679*   X0	----			Master console file code
     2680*   X1	SCT (test page index * 4)	SCT (test page index * 4)
     2681*   X2	Patptr			----
     2682*   X4	----			Patptr
     2683*   X6	----			possible hang flag
     2684*   X7	0			Molt test type (In upper 6 bits: C = itrs, R = MDRs, T = MTAR, M = memory)
     2685*   AR	----			type code (tdcxxa)
     2686*   QR	----			ICC (XICCXXXX)
     2687*
     2688*   mme     releas
     2689*   ------  return if error
     2690*   ------  return
     2691*
     2692*   return registers: none */
     2693 
     2694 mme_typ (-56): if trace then call tolts_qttyio_$rs (10, "^a MME RELEAS @ ^p", ctime (), mmep);
     2695       if spa.regs.x (7) ^= "0"b then			/* if not polts */
     2696          if substr (spa.regs.x (7), 1, 6) = "23"b3 then do; /* molts, running itrs */
     2697 	  call get_px_sct ("RELEAS", bin (spa.regs.x (1), 17), "1"b); /* get test page index */
     2698 	  if io_info.chan_suspended then do;		/* only load firmware if channel suspended */
     2699 	     call tolts_load_firmware_ (io_sel, error);	/* go load mpc firmware */
     2700 	     if error ^= 0 then			/* if error loading firmware */
     2701 	        call ck_release;			/* try again, and then ask user */
     2702 	  end;
     2703          end;
     2704       call return_plus (2);
     2705 
     2706 /* ********* MME RLSMPC ********* (release mpc)
     2707*
     2708*   input registers:   x1 = mpc controller sct pointer
     2709*
     2710*   mme     rlsmpc
     2711*   ------  return
     2712*
     2713*   return registers: none */
     2714 
     2715 mme_typ (-26): if trace then call tolts_qttyio_$rs (10, "^a MME RLSMPC @ ^p", ctime (), mmep);
     2716       call return_plus (1);
     2717 
     2718 /* ********* MME RLSPAT ********* (release peripheral allocation table entry)
     2719*
     2720*   input registers:   x4 = pat address (offset relative to LAL)
     2721*
     2722*   mme     rlspat
     2723*   ------  return
     2724*
     2725*   return registers: none */
     2726 
     2727 mme_typ (-28): if trace then call tolts_qttyio_$rs (10, "^a MME RLSPAT @ ^p", ctime (), mmep);
     2728       call return_plus (1);
     2729 
     2730 
     2731 /* ********* MME RSPCHK ********* (check for fnp response)
     2732*
     2733*   input registers:   x1 = fpinfo table pointer
     2734*
     2735*   mme     rspchk
     2736*   ----	 error return
     2737*   ----	 timeout return
     2738*   ----	 retry return
     2739*   ----	 good return
     2740*
     2741*   return registers:  q = status word if fault occurs */
     2742 
     2743 mme_typ (-91): if trace then call tolts_qttyio_$rs (10, "^a MME RSPCHK @ ^p", ctime (), mmep);
     2744 
     2745       tolts_fpinfo_ptr = addrel (execp, spa.regs.x (1));	/* get a ptr to the test page fpinfo table */
     2746       do io_sel = 1 to hbound (pages, 1)		/* get the io_info for this page */
     2747        while (pages (io_sel).fnp_num ^= tolts_fpinfo.pcw_info.fnp_num);
     2748       end;
     2749       if io_sel > hbound (pages, 1) then call tolts_abort ("$c3"); /* io_info for this page not found */
     2750       io_info_ptr = addr (pages (io_sel));
     2751       tolts_rspd_wksp = io_info.tolts_rspd_wksp;
     2752       call tolts_init_$gc_tod (gcos_tod);
     2753       if tolts_rspd_workspace.mailbox.status_word ^= "0"b then do; /* error status stored */
     2754          if tolts_fpinfo.io_rq_cnt > 0 then		/* if io request cnt > 0 */
     2755 	  tolts_fpinfo.io_rq_cnt = tolts_fpinfo.io_rq_cnt - 1;
     2756          if substr (tolts_rspd_workspace.status_word, 4, 1) = "1"b /* if timeout */
     2757 	| bin (tolts_fpinfo.timeout_time) - bin (gcos_tod) < 1 then
     2758 	  call return_plus (2);			/* take timeout return */
     2759          else do;					/* else take normal error return */
     2760 	  spa.regs.q = tolts_rspd_workspace.status_word;	/* return the status */
     2761 	  call return_plus (1);			/* take error return */
     2762          end;
     2763       end;
     2764       else do;					/* no error */
     2765          tolts_fpinfo.spec_cnt =
     2766 	tolts_rspd_workspace.mailbox.num_int.lvl7;	/* move spec count */
     2767          tolts_fpinfo.term_cnt =
     2768 	tolts_rspd_workspace.mailbox.num_int.lvl3;	/* move term count */
     2769          tolts_fpinfo.lvl3_cnt =			/* decr levl 3 count with saved value */
     2770 	tolts_fpinfo.term_cnt - bin (unspec (tolts_fpinfo.temp01.word2));
     2771          tolts_fpinfo.lvl7_cnt =			/* decr levl 7 count with saved value */
     2772 	tolts_fpinfo.spec_cnt - bin (unspec (tolts_fpinfo.temp01.word1));
     2773          if (tolts_fpinfo.lvl3_cnt = 0 & tolts_fpinfo.lvl3_flag) /* if no term int & one expected */
     2774 	| (tolts_fpinfo.lvl7_cnt = 0 & tolts_fpinfo.lvl7_flag) /* or no spec int & one ecpected */
     2775 	& (bin (tolts_fpinfo.timeout_time) < 0) then	/* & no timeout */
     2776 	  call return_plus (3);			/* take retry return */
     2777          else do;
     2778 	  if tolts_fpinfo.io_rq_cnt > 0 then
     2779 	     tolts_fpinfo.io_rq_cnt = tolts_fpinfo.io_rq_cnt - 1;
     2780 	  if (tolts_fpinfo.lvl3_cnt = 1 | ^tolts_fpinfo.lvl3_flag)
     2781 	   & (tolts_fpinfo.lvl7_cnt = 1 | ^tolts_fpinfo.lvl7_flag) then
     2782 	     call return_plus (4);			/* take good return */
     2783          end;
     2784       end;
     2785 
     2786 
     2787 /* ********* MME SCTCMP********* (generate SCT entry)
     2788*
     2789*   input registers: X2 = 128 chan number for new format
     2790*
     2791*   mme     sctcmp
     2792*   zero    ficcdd,0
     2793*   zero    sctwrk,0
     2794*   ------  return good--shared file
     2795*   ------  return good--non-shared file
     2796*   ------  return error
     2797*
     2798*   return registers:	X2 = error code if error (see set_sctwrk subroutine for error codes)
     2799*   *			output in sctwrk area: see set_sctwrk subroutine */
     2800 
     2801 mme_typ (-29): if trace then call tolts_qttyio_$rs (10, "^a MME SCTCMP @ ^p", ctime (), mmep);
     2802       do i = 1 to 8 while (pages (i).in_use);		/* find vacant page */
     2803       end;
     2804       if i = 8 & pages (8).in_use then do;		/* no vacant page */
     2805          call tolts_qttyio_$rs (0, "^a: MME SCTCMP; No vacant test page slot found", exec);
     2806          call tolts_abort ("$a1");
     2807       end;
     2808       unspec (pages (i)) = "0"b;			/* clear test page data */
     2809       call set_sctwrk (i);				/* go set up the sct work area */
     2810       if spa.regs.x (2) ^= "0"b then do;		/* if error */
     2811          if fixed (spa.regs.x (2)) = m_iv_iom then	/* if invalid IOM number... */
     2812 	  spa.regs.x (2) = "0"b;			/* correct it */
     2813          call return_plus (5);			/* take error return */
     2814       end;
     2815       pages (i).in_use = "1"b;			/* set page in use flag */
     2816       tolts_info.exec_page_count = tolts_info.exec_page_count + 1; /* increment total test page count */
     2817       if pages (i).io_type = polt_io_type then		/* if user wants to run itrs... */
     2818          itr_run = "1"b;				/* set flag for wake_disp subroutine */
     2819       call return_plus (4);				/* take good return */
     2820 
     2821 /* ********* MME SETPRT & MME SETPR2 ********* (reserve printer (attach print file in Multics's case ))
     2822*
     2823*   input/return registers: none
     2824*
     2825*   mme     setprt
     2826*   ------  return tolts aborted
     2827*   ------  return tolts swapped
     2828*   ------  no prt available
     2829*   ------  return pr2 in use
     2830*   ------  return good */
     2831 
     2832 mme_typ (-30):
     2833 mme_typ (-31): if trace then call tolts_qttyio_$rs (10, "^a MME SET^[PRT^;PR2^] @ ^p", ctime (), (mme_number = -33), mmep);
     2834       if ^tolts_info.file_attach then do;		/* if print file not already attached... */
     2835          call tolts_file_util_$open (error);		/* attach and open it */
     2836          if error = 0 then				/* if no attach error */
     2837 	  call return_plus (5);			/* return good */
     2838       end;
     2839       call return_plus (3);				/* return ic + 3 */
     2840 
     2841 /* ********* MME SETPUN ********* (set reader/punch to punch mode)
     2842*
     2843*   input registers:   x1 = sct (test page index mod 4)
     2844*
     2845*   mme     setpun
     2846*   ------  return, no operator message
     2847*   ------	 return, Output Operator message to put reader/punch in punch mode
     2848*
     2849*   return registers: X1 = sct address
     2850*
     2851*   Issued for 214 reader/punch to set in punch mode before mme allocr to set punch indicator in sct */
     2852 
     2853 mme_typ (-32): if trace then call tolts_qttyio_$rs (10, "^a MME SETPUN @ ^p", ctime (), mmep);
     2854       call get_px_sct ("SETPUN", bin (spa.regs.x (1), 17), "0"b); /* get test page index */
     2855       io_info.ccu_pun = "1"b;				/* remember we want a punch */
     2856       call return_plus (1);
     2857 
     2858 /* ********* MME SETTYP & MME DISPRT ********* (reset prt or pr2 request)
     2859*
     2860*   input/return registers: none
     2861*
     2862*   mme     settyp
     2863*   ------  return tolts aborted
     2864*   ------  return tolts swapped
     2865*   ------  return good */
     2866 
     2867 mme_typ (-11):
     2868 mme_typ (-33): if trace then call tolts_qttyio_$rs (10, "^a MME ^[SETTYP^;DISPRT^] @ ^p", ctime (), (mme_number = -33), mmep);
     2869       if tolts_info.file_attach then			/* if print file attached... */
     2870          call tolts_file_util_$close;			/*  close it out */
     2871       call return_plus (3);				/* return ic + 3 */
     2872 
     2873 /* ********* MME TADIOD ********* (T&D terminal I/O)
     2874*
     2875*   input registers:	a-reg = 18/.tdpcn,6/pad,1/nu,1/dont record denial,1/mbz,3/exec,6/lid
     2876*
     2877*   mme     tadio
     2878*   zero    nodcws,0
     2879*   zero    iotpd,wc   from 1 to 5 of these exist
     2880*   ------  return if tolts aborted
     2881*   ------  return if tolts swapped
     2882*   ------  return if request denied
     2883*   ------  return accepted
     2884*
     2885*   return registers: none
     2886*
     2887*   tadio type:		bit 23 "p" 1     print line	bit 22 "c" 2    controlling terminal
     2888*   *			bit 21 "s" 4     slave term.	bit 20 "m" 8    master console output
     2889*   *			bit 19 "r" 16    output/input	bit 18 "e" 32   select console/printer by option
     2890*   all valid combinations:	ps  - 5	sp  - 5	cs  - 6	sc  - 6	mp  - 9	pm  - 9	cm  - 10
     2891*   *			mc  - 10	ms  - 12	sm  - 12	mps - 13	msp - 13	pms - 13	psm - 13
     2892*   *			smp - 13	spm - 13	cms - 14	csm - 14	mcs - 14	msc - 14
     2893*   *			scm - 14	smc - 14	ep  - 33	pe  - 33	em  - 40	me  - 40	   */
     2894 
     2895 mme_typ (-34): if trace then call tolts_qttyio_$rs (10, "^a MME TADIOD @ ^p", ctime (), mmep);
     2896       ndcws = mme_call_hf (1).upper;			/* extract number of dcws */
     2897       if ndcws < 1 | ndcws > 5 then do;
     2898          call tolts_qttyio_$rs (0, "^as: MME TADIOD; Number of dcws = ^d", exec, ndcws);
     2899          call tolts_abort ("$b2");
     2900       end;
     2901       do i = 1 to 8 while (tolts_info.tadio (i).inuse);	/* find vacant tadio queue entry */
     2902       end;
     2903       if i = 8 & tolts_info.tadio (8).inuse then do;	/* no queue entry */
     2904          call tolts_qttyio_$rs (0, "^as: MME TADIOD; No vacant queue entry", exec);
     2905          call tolts_abort ("$b2");
     2906       end;
     2907       tolts_info.tadio (i).inuse = "1"b;		/* fill in the queue entry */
     2908       tolts_info.tadio (i).return_word (3) = "000000006361"b3; /* phy term sb 24-35 */
     2909       tolts_info.tadio (i).return_word (2) = bit (bin (i, 18)) || "000000"b3;
     2910       if substr (mme_call_w (2), 20, 1) = "1"b then do;	/* if read involved */
     2911          tolts_info.tadio (i).optrd = "1"b;
     2912          tolts_info.tadio (i).return_word (1) = "204652"b3 || substr (spa.regs.a, 1, 18); /* " o-||.tdpcn */
     2913          pad_char = substr (spa.regs.a, 19, 6);		/* pick up pad character */
     2914          do j = 0 to 83;				/*  pad options buffer */
     2915 	  substr (tolts_info.tadio (i).option, (j * 6) + 1, 6) = pad_char;
     2916          end;
     2917       end;
     2918       else do;
     2919          tolts_info.tadio (i).optrd = "0"b;
     2920          tolts_info.tadio (i).return_word (1) = "206252"b3 || substr (spa.regs.a, 1, 18); /* " s-||.tdpcn */
     2921       end;
     2922       call tolts_qttyio_$dcw_ptr (addrel (mmep, 2), ndcws, i); /* go queue up message */
     2923       spa.enter.icivlu.ic = rel (addr (mme_call_w (5 + ndcws))); /* return ic +5 + number of dcws */
     2924       call wake_disp;				/* go wake up dispatcher */
     2925 
     2926 /* ********* MME TDIO ********* (issue I/O to device under test)
     2927*
     2928*   input registers: none
     2929*
     2930*   mme     tdio			eep commands:	3100007x4000 = diagnostic mode control
     2931*   zero    myioq,0					2200007x4000 = read controller main memory
     2932*   zero    tpbase,0					0600007x4000 = initiate read data transfer
     2933*   zero    datara,redfol-wrtpre+1  ( = 0 if molts)	where x = 0 if last and 2 if continue idcw
     2934*   zero    iotrac,0
     2935*   ------  return
     2936*
     2937*   return registers: AR = Time of day of connect, QR = lostit time, X4 = test page index */
     2938 
     2939 mme_typ (-36): ioe_ptr = addrel (execp, mme_call_hf (1).upper); /* get ptr to our io_entry */
     2940       if trace then do;
     2941          call tolts_qttyio_$rs (10, "^a MME TDIO @ ^p", ctime (), mmep);
     2942          call ioa_$rsnnl ("^/io_entry:^-^4(^12.3b ^)^/^-^4(^12.3b ^)^/^-^3(^12.3b ^)",
     2943 	message, mesg_len, ioe, ioe (5), ioe (9));
     2944          call tolts_qttyio_ (message, 10);
     2945       end;
     2946       if trace_io then do;				/* count number of mme tdio's if -tio option true */
     2947          call tolts_qttyio_$rs (10, "^a MME TDIO @ ^p", ctime (), mmep);
     2948          call ioa_$rsnnl ("^/io_entry:^-^4(^12.3b ^)^/^-^4(^12.3b ^)^/^-^3(^12.3b ^)",
     2949 	message, mesg_len, ioe, ioe (5), ioe (9));
     2950          call tolts_qttyio_ (message, 10);
     2951          tio = tio + 1;
     2952          call tolts_qttyio_$rs (10, " MME TDIO =  ^b @ ^a", tio, ctime ()); /* notify user of tally of tdio's */
     2953       end;
     2954       call get_px_sct ("TDIO  ", bin (io_entry.sct_add, 17), "1"b); /* get test page index */
     2955       if io_info.io_type = mca_io_type then call mca_io_setup; /* mca is special */
     2956       else call io_setup;				/* go set up our workspace */
     2957       if io_info.suspend_chan then do;			/* if channel to be suspended */
     2958          call ioi_$suspend_devices (io_info.device_index, error); /* let ioi_$ stop other io */
     2959          if error ^= 0 then do;			/* error, abort */
     2960 	  call output_status_code (error, "suspend devices error");
     2961 	  call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
     2962 	   string (io_info.icivlu));			/* enter ccc request */
     2963 	  io_info.suspend_chan = "0"b;
     2964 	  io_info.io_in_progress = "0"b;		/* reset io in progress flag */
     2965 	  if tolts_info.gewake_active then do;		/* if gewake alarm set */
     2966 	     call timer_manager_$reset_alarm_wakeup (tolts_info.gewake_event); /* reset it */
     2967 	     call ipc_$drain_chn (tolts_info.gewake_event, error); /* make sure no alarms queue up */
     2968 	     tolts_info.gewake_active = "0"b;		/* reset flag */
     2969 	  end;
     2970 
     2971 	  call tolts_abort ("$b5");
     2972          end;
     2973          io_info.chan_suspended = "1"b;			/* remember that channel suspended */
     2974       end;
     2975       if io_info.io_type = mca_io_type then do;
     2976          if io_entry.prim.dev_cmd = "40"b3 then		/* if reset dcw */
     2977 	  call mca_$reset (io_info.mca_ioi_idx, "0"b, error);
     2978          else if io_entry.prim.dev_cmd = "15"b3 then	/* send mca data */
     2979 	  call mca_$tandd_write_data (io_info.mca_ioi_idx,
     2980 	   io_info.workspace_ptr, io_block_len, "0"b, error);
     2981          else if io_entry.prim.dev_cmd = "13"b3 then	/* send mca command */
     2982 	  call mca_$tandd_write_text (io_info.mca_ioi_idx,
     2983 	   io_info.workspace_ptr, io_block_len, "0"b, error);
     2984          else if io_entry.prim.dev_cmd = "03"b3 then	/* every write must be followed by a read */
     2985 	  call mca_$tandd_read_data (io_info.mca_ioi_idx,
     2986 	   io_info.workspace_ptr, io_block_len, "0"b, error);
     2987          else error = error_table_$bad_command_name;
     2988       end;
     2989       else call ioi_$connect_pcw (io_info.device_index, tio_off, pcwa, error);
     2990       if error ^= 0 then do;
     2991          call output_status_code (error, "doing io for a tdio");
     2992          call tolts_alm_util_$enter_ccc_req_ (addr (tolts_info.ccc_queue),
     2993 	string (io_info.icivlu));			/* enter ccc request */
     2994          io_info.io_in_progress = "0"b;			/* reset io in progress flag */
     2995          if tolts_info.gewake_active then do;		/* if gewake alarm set */
     2996 	  call timer_manager_$reset_alarm_wakeup (tolts_info.gewake_event); /* reset it */
     2997 	  call ipc_$drain_chn (tolts_info.gewake_event, error); /* make sure no alarms queue up */
     2998 	  tolts_info.gewake_active = "0"b;		/* reset flag */
     2999          end;
     3000 
     3001          call tolts_abort ("$b5");
     3002       end;
     3003       call tolts_init_$gc_tod (spa.regs.a);		/* get current time of day */
     3004       io_info.con_time = bin (spa.regs.a, 35);		/* save connect time */
     3005       spa.regs.q = bit (bin (io_info.lostit_time, 36));	/* set lostit time */
     3006       spa.regs.x (4) = bit (bin (io_sel * 4, 18));	/* return test page index, mod 4 */
     3007       tolts_info.glob_int_cnt = tolts_info.glob_int_cnt + 1;/* increment global IO count */
     3008       call return_plus (5);				/* return ic + 5 */
     3009 
     3010 /* ********* MME TERMIN ********* (terminate slave executive)
     3011*
     3012*   input registers: none
     3013*
     3014*   mme     termin
     3015*   does not return */
     3016 
     3017 mme_typ (-35): if trace then call tolts_qttyio_$rs (10, "^a MME TERMIN @ ^p", ctime (), mmep);
     3018       term = "1"b;					/* set terminate condition */
     3019       go to term_lbl;				/* and perform nonlocal goto */
     3020 
     3021 /* ********* MME TNDBUG ********* (tolts debugger break point))
     3022*
     3023*   input/return registers: none
     3024*
     3025*   mme     tndbug
     3026*
     3027*   restores mme word with original value and returns to mme location */
     3028 
     3029 mme_typ (-88):
     3030       if ^debugging then call return_plus (1);
     3031       call probe (mtdsim_);
     3032       exec_wd (db_addr) = db_sv_wd;
     3033       tolts_info.mult_ans = "";			/* clear out response */
     3034       call tolts_qttyio_$rs (19, "tolts_debugger: enter break point address");
     3035       call message_wait;				/* wait for user response */
     3036       if mult_ans ^= "" then do;
     3037          db_addr = cv_oct_check_ ((rtrim (mult_ans)), code);
     3038          db_sv_wd = exec_wd (db_addr);
     3039          exec_wd (db_addr) = "777650001000"b3;
     3040       end;
     3041       call return_plus (0);				/* return ic + 0 */
     3042 
     3043 /* ********* MME TOLDIS ********* (disconnect logical terminal ID (LID))
     3044*
     3045*   input/return registers: none
     3046*
     3047*   mme     toldis
     3048*   ------  return tolts aborted
     3049*   ------  return tolts swapped
     3050*   ------  return */
     3051 
     3052 mme_typ (-37): if trace then call tolts_qttyio_$rs (10, "^a MME TOLDIS @ ^p", ctime (), mmep);
     3053       call return_plus (3);				/* return ic + 3 */
     3054 
     3055 
     3056 /* ********* MME TOLGON ********* (used in gecos to inform tolts is terminating)
     3057*   mme	   tolgon
     3058*   -----   return   */
     3059 
     3060 mme_typ (-38): if trace then call tolts_qttyio_$rs (10, "^a MME TOLGON @ ^p", ctime (), mmep);
     3061       call return_plus (1);
     3062 
     3063 
     3064 /* ********* MME TOLTIN ********* (slave executive idle dispatcher)
     3065*
     3066*   input registers:   q-reg = time in 1/64 ms for wakeup
     3067*
     3068*   mme     toltin
     3069*   ------  return not in core
     3070*   ------  return in core   (does mme gewake if in core)
     3071*
     3072*   return registers: none */
     3073 
     3074 mme_typ (-39): if trace then call tolts_qttyio_$rs (10, "^a MME TOLTIN @ ^p", ctime (), mmep);
     3075 
     3076       wake_time = divide (fixed (spa.regs.q) * 1000, 64, 71, 0); /* convert gcos time to useconds */
     3077       call timer_manager_$alarm_wakeup (wake_time, "10"b, tolts_info.gewake_event); /* set the alarm  */
     3078       tolts_info.gewake_active = "1"b;			/* set flag for int processor */
     3079       spa.enter.icivlu.ic = rel (addr (mme_call_w (2)));	/* increment ic by 2 */
     3080       go to blk_lbl;				/* return to blocked state */
     3081 
     3082 /* ********* MME TRACIO ********* (trace I/O events (GCOS only, Unused in Multics))
     3083*
     3084*   input/output registers: none
     3085*
     3086*   mme     tracio
     3087*   iotd    msg,wordcount
     3088*   ------  return */
     3089 
     3090 mme_typ (-40): if trace then call tolts_qttyio_$rs (10, "^a MME TRACIO @ ^p", ctime (), mmep);
     3091       call return_plus (2);				/* return ic + 2 */
     3092 
     3093 /* ********* MME UNFREZ ********* (unwire  main memory (gcos only))
     3094*
     3095*   input/return registers:   none
     3096*
     3097*   mme     unfrez
     3098*   ------  return */
     3099 
     3100 mme_typ (-54): if trace then call tolts_qttyio_$rs (10, "^a MME UNFREZ @ ^p", ctime (), mmep);
     3101       call return_plus (1);
     3102 
     3103 /* ********* MME WRDUMP ********* (wrapup dump)
     3104*
     3105*   input registers:	areg = iotd for dump prefix
     3106*   *		qreg = start,size (relative to LAL)
     3107*   *		x1 = address bias (-1024 or page base)
     3108*   *		x2 = master/slave (=3hm  ,=3hs  )
     3109*
     3110*   mme     wrdump
     3111*   ------  return
     3112*
     3113*   return registers: none */
     3114 
     3115 mme_typ (-42): if trace then call tolts_qttyio_$rs (10, "^a MME WRDUMP @ ^p", ctime (), mmep);
     3116       if tolts_info.file_attach then do;		/* if print file attached... */
     3117          call tolts_file_util_$wdump (addr (spa.regs));	/* go output entire dump */
     3118          call tolts_file_util_$close;
     3119       end;
     3120       else call tolts_qttyio_$rcw (addr (spa.regs.a));	/* otherwise just output dump prefix */
     3121       call return_plus (1);				/* return ic + 1 */
     3122 
     3123 mme_typ (-60): mme_typ (-58): mme_typ (-57):
     3124 mme_typ (-49): mme_typ (-48): mme_typ (-47): mme_typ (-46): mme_typ (-45):
     3125 mme_typ (-44): mme_typ (-43): mme_typ (-41): mme_typ (-27): mme_typ (-23): mme_typ (-10):
     3126 mme_typ (-25): mme_typ (-15): mme_typ (-14):
     3127 mme_typ (-3): mme_typ (0): mme_typ (3): mme_typ (4): mme_typ (6): mme_typ (7):
     3128 mme_typ (8): mme_typ (10): mme_typ (11): mme_typ (12): mme_typ (13): mme_typ (16):
     3129 mme_typ (19): mme_typ (20): mme_typ (22): mme_typ (23): mme_typ (25):
     3130 mme_typ (26): mme_typ (27): mme_typ (28): mme_typ (29):
     3131 undefm:
     3132 
     3133       in_ccc = "0"b;
     3134       call tolts_qttyio_$rs (0, "^as: Improper MME @ ^p; MME type - ^d; Instruction - ^12.3b",
     3135        exec, mmep, mme_call_hf (0).upper, mme_call_w (0));
     3136       call tolts_abort ("$b6");
     3137 
     3138 /* epilogue - entry called by execute_epilogue_ when process is terminated */
     3139 
     3140 epilogue: entry;
     3141 
     3142       if tolts_active then do;			/* continue only if we were active */
     3143          tolts_info.finish_cond = "1"b;			/* set finish flag */
     3144          call hcs_$get_ips_mask (old_mask);		/* get current ips mask */
     3145          new_mask = old_mask | sys_info$alrm_mask;	/* make sure "alrm"s are enabled */
     3146          call hcs_$set_ips_mask (new_mask, new_mask);	/* set the mask */
     3147          call clean_up;				/* go cleanup our enviornment */
     3148          call hcs_$set_ips_mask (old_mask, old_mask);	/* set original ips mask */
     3149       end;
     3150       return;
     3151 
     3152 
     3153 /* return_plus - int procedure to add specified value to ic, wakeup dispatcher and take non-local goto to block */
     3154 
     3155 return_plus: proc (ic_inc);
     3156 
     3157 dcl  ic_inc fixed bin;				/* value to increment ic by */
     3158 
     3159       spa.enter.icivlu.ic = rel (addr (mme_call_w (ic_inc))); /* increment ic */
     3160 
     3161 /* wake_disp - entry to do non-local goto to dispatcher. If there is any oustanding IO,
     3162*   the wait event channel is woken up and we do non-local goto to the dispatcher block label.
     3163*   If there is no outstanding IO (terminal or test IO), we do non-local goto  directly
     3164*   back to the no_blk label, thus saving needless wakeyps and blocks */
     3165 
     3166 wake_disp: entry;
     3167 
     3168       if (tolts_info.term_io_req_cnt = 0 & tolts_info.glob_int_cnt = 0 /* if there is nothing to wait for... */
     3169        & ^tolts_info.exec_term_io_wait & ^colts_op_flags.colt_flag) then /* go back to slave exec, don't go blocked */
     3170          go to no_blk;				/* do non-local goto */
     3171 
     3172       call hcs_$wakeup (tolts_info.process, tolts_info.wait_list.wait_event_id (1), null, error);
     3173       if error ^= 0 then do;				/* this is a fatal error, terminate our process */
     3174          call com_err_ (error, exec, "***fatal error, terminating process"); /* but tell user first */
     3175          fatal_desc.version = 0;
     3176          fatal_desc.fatal_code = error;
     3177          if ^debugging then
     3178 	  call terminate_process_ ("fatal_error", addr (fatal_desc));
     3179          else signal tolts_error_;
     3180       end;					/* no need to return, as we won't be back */
     3181       go to blk_lbl;				/* take non-local goto to dispatcher block */
     3182 
     3183    end return_plus;
     3184 
     3185 
     3186 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     3187 /*											*/
     3188 /* fault_dump - internal procedure to force open a file for tolts abort				*/
     3189 /*											*/
     3190 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     3191 
     3192 fault_dump: proc;
     3193       flt_flag = "1"b;
     3194       if ^tolts_info.file_attach then
     3195          call tolts_file_util_$open (error);
     3196       if error ^= 0 then do;
     3197          call com_err_ (error, exec, "encountered an error while attempting to open a point file for ^a", error);
     3198          call tolts_abort ("$t1");
     3199       end;
     3200       if debugging then call probe (mtdsim_);
     3201       if tolts_info.file_attach then do;
     3202          call display_mc;
     3203          call tolts_file_util_$wdump (execp);		/* go output entire dump */
     3204          call tolts_file_util_$close;
     3205 
     3206          in_ccc = "0"b;
     3207          call tolts_abort ("$t2");
     3208       end;
     3209    end fault_dump;
     3210 
     3211 
     3212 
     3213 /* tolts_abort - internal procedure to set up abort vectors for the slave exec */
     3214 
     3215 tolts_abort: proc (a_code);
     3216 
     3217 dcl  a_code char (3);
     3218 dcl  tfc bit (18);
     3219 
     3220       call tolts_alm_util_$ascii_to_bcd_ (a_code, tfc);	/* convert fault code to bcd */
     3221       spa.abort.code = tfc;				/* and store in spa */
     3222       spa.abort.add = scu.ilc;			/* equals address of last mme */
     3223       if spa.wrapup_add = "0"b			/* if we have not been thru mme pointit yet.. */
     3224        | flt_flag then do;				/* or we have detected a fault */
     3225          call clean_up;
     3226          term = "1"b;				/* set terminate condition */
     3227          go to term_lbl;				/* take non-local goto to get out of dispatcher */
     3228       end;
     3229       spa.enter.icivlu.ic = spa.wrapup_add;		/* set wrapup address */
     3230       call wake_disp;				/* and wake up dispatcher */
     3231 
     3232    end tolts_abort;
     3233 
     3234 /* display_mc - int proc to display machine conditions after a fault */
     3235 
     3236 display_mc: proc;
     3237 
     3238 dcl  cu_$stack_frame_ptr entry (ptr);
     3239 dcl  dump_machine_cond_ entry (ptr, ptr, char (32) aligned, fixed bin);
     3240 dcl  find_condition_frame_ entry (ptr) returns (ptr);
     3241 dcl  find_condition_info_ entry (ptr, ptr, fixed bin (35));
     3242 dcl  hran_$hranl entry (ptr, ptr, bit (1));
     3243 dcl  ioa_ entry () options (variable);
     3244 dcl  ioa_$ioa_switch entry () options (variable);
     3245 dcl  (faultsp, hreg_ptr, stackp) ptr;
     3246 dcl  code fixed bin (35);
     3247 
     3248 
     3249       call cu_$stack_frame_ptr (stackp);		/* get current sstack ptr */
     3250       faultsp = find_condition_frame_ (stackp);		/* is this the cond frame ? */
     3251       if faultsp = null () then do;
     3252          call ioa_ ("^a: Cannot find condition frame.", "exec_name");
     3253          return;
     3254       end;
     3255 
     3256       call find_condition_info_ (faultsp, addr (ci), code);
     3257       if ci.mc_ptr = null () then do;
     3258          call ioa_ ("^a: Cannot find condition frame.", "exec_name");
     3259          return;
     3260       end;
     3261 
     3262 
     3263       call ioa_$ioa_switch (tolts_info.pf_iocbp, "^/MACHINE CONDITIONS AT ^p:^/", ci.mc_ptr);
     3264       call dump_machine_cond_ (addr (ci), faultsp, "err_file", 2); /* print the MC */
     3265 
     3266 HREGS:
     3267       if mcptr ^= null then hreg_ptr = addrel (mcptr, 96);
     3268       if hreg_ptr = null then do;			/* no history regs to dump */
     3269          call ioa_$ioa_switch (tolts_info.pf_iocbp, "History Registers are not available");
     3270          return;
     3271       end;
     3272       else do;
     3273          call ioa_$ioa_switch (tolts_info.pf_iocbp, "CPU HISTORY REGISTERS AT TIME OF FAULT");
     3274          call hran_$hranl (hreg_ptr, tolts_info.pf_iocbp, "0"b);
     3275       end;
     3276 
     3277       return;
     3278    end display_mc;
     3279 
     3280 
     3281 
     3282 
     3283 /* set_sctwrk - internal procedure to set up the sct work area sctwrk */
     3284 
     3285 set_sctwrk: proc (px);
     3286 
     3287 dcl  px fixed bin;					/*  test page index */
     3288 
     3289 /*
     3290*   output in sctwrk (12 words):
     3291*
     3292*   18/devsct,6/0,12/xbicc
     3293*   18/altsct,6/g3typ,12/0
     3294*   18/cntsct,4/iotyp,4/cnttyp,1/pad,4/xiotyp,4/xcnttyp,1/pad
     3295*   18/cont. sct,18/mpc index (36/0 for non mpc)
     3296*   36/word +0 of .crcst entry for mpc
     3297*   36/word +1 of .crcst entry for mpc
     3298*   36/word +2 of .crcst entry for mpc
     3299*   36/word +3 of .crcst entry for mpc
     3300*   36/word +0 of sct entry
     3301*   36/word +1 of sct entry
     3302*   36/word +0 of alt sct
     3303*   36/word +1 of alt sct
     3304**/
     3305       genp = addrel (execp, mme_call_hf (2).upper);	/* get pointer to sctwrk */
     3306       spa.regs.x (2), sctwrk = "0"b;			/* initialize sctwrk first */
     3307       t_err = 0;
     3308       call tolts_device_info_ (addrel (execp, mme_call_hf (1).upper), px, t_err); /* get type code */
     3309       spa.regs.x (2) = bit (bin (t_err, 18));		/* set x2 to type_error if any */
     3310       substr (sctwrk (2), 19, 6) = pages (px).devsct.type_code; /* set type code */
     3311       if ^pages (px).devsct.com_prph then do;		/* if mpc subsystem */
     3312          pages (px).sct_info.cntsct = bit (bin (px * 4 + 1024, 18)); /* set cont. sct (device sct + 1024) */
     3313          sctwrk (3) = unspec (pages (px).sct_info);	/* fill word 3 of sct area */
     3314          substr (sctwrk (4), 1, 18) = bit (bin (px * 4 + 1024, 18)); /* set cont. sct */
     3315       end;
     3316       sctwrk (5) = unspec (pages (px).crcst);		/* set crcst entry wrd 0 */
     3317       sctwrk (6) = unspec (pages (px).crcst);		/* set crcst entry wrd 1 */
     3318       sctwrk (9) = unspec (pages (px).devsct.w1);		/* set dev sct word 1 */
     3319       sctwrk (10) = unspec (pages (px).devsct.w2);	/* and word 2 */
     3320       substr (sctwrk (1), 1, 18) = bit (bin (px * 4, 18));	/* set test page index (mod 4) */
     3321 
     3322 /*   The sct pointer and sct data for the alternate device must be passed back to cmlt, provided mtar is running   */
     3323 
     3324       if (pages (px).alt_dev_flag) then do;		/* alt. device exists return device info */
     3325          sctwrk (11) = unspec (pages (px).altsct.w1);
     3326          sctwrk (12) = unspec (pages (px).altsct.w2);
     3327          substr (sctwrk (2), 1, 18) = bit (bin (px * 4 + 512, 18));
     3328       end;
     3329 
     3330    end set_sctwrk;
     3331 
     3332 
     3333 /* mca_io_setup - internal procedure to set up the mca workspace for mca I/O */
     3334 
     3335 mca_io_setup: proc;
     3336 
     3337 
     3338       dcwp = addrel (execp, dcw_ptr);
     3339       mca_work_space_ptr = io_info.workspace_ptr;		/* get a ptr to our workspace */
     3340       unspec (mca_work_space) = "0"b;			/* clear it */
     3341       c_len = 4;					/* want to xfer 4 words */
     3342       mvp = addrel (execp, dcw_ptr - 1);		/* set move ptr to idcw */
     3343       bufp = addr (mca_work_space.list_of_dcw);		/* set buf ptr to work space dcw list */
     3344       workspace_move = mvp -> workspace_move;		/* move it */
     3345       bufp = addr (io_info.dcw_list);			/* move the buf ptrto save the dcw list in io_info */
     3346       workspace_move = mvp -> workspace_move;		/* move it */
     3347       if dcw.tally = "0"b3 then c_len = 4096;		/* check for 4096 tally */
     3348       else c_len = bin (dcw.tally);			/* else use as is */
     3349       io_block_len = c_len + 4096 + 2;			/* set io block length to reflect the tally */
     3350       mvp = addrel (execp, dcw.address);		/* set move ptr to data to be sent */
     3351       bufp = addr (mca_work_space.data_header_1);		/* set buf ptr to data header area */
     3352       workspace_move = mvp -> workspace_move;		/* move it */
     3353       data_size_1 = fixed (data_header_1.dest_len_msb || data_header_1.dest_len_lsb, 16);
     3354       io_info.icivlu.ic = io_entry.ccc_p;		/* set entry to call on io completion */
     3355       io_info.icivlu.ind = "0"b;			/* initialize indicators */
     3356       io_info.status_add = fixed (io_entry.stat_p);	/* save status storage ptr */
     3357       exec_wd (io_info.status_add) = "0"b;		/* initialize test page status */
     3358       exec_wd (io_info.status_add + 1) = "0"b;
     3359       io_info.pcwa = pcwa;				/* save pcw */
     3360       io_info.tio_off = 0;				/* save dcw list offset */
     3361       io_info.rew_wait = "0"b;			/* not expecting special interrupt */
     3362       io_info.io_in_progress = "1"b;			/* set flag for interrupt processing */
     3363       io_info.num_connects = io_info.num_connects + 1;
     3364       io_info.int_time = 0;				/* clear out interrupt time */
     3365 
     3366    end mca_io_setup;
     3367 
     3368 
     3369 
     3370 
     3371 
     3372 /* io_setup - internal procedure to set up the ioi workspace for test I/O */
     3373 
     3374 io_setup: proc;
     3375 
     3376 dcl  (continue, first, idcw_io) bit (1);
     3377 dcl  (cbuf_add, lstloc, nxtloc) fixed bin;
     3378 dcl  dcwb fixed bin (18) uns;
     3379 
     3380       ioi_wksp = io_info.workspace_ptr;			/* get a ptr to our workspace */
     3381       continue = "0"b;				/* reset continue flag */
     3382       unspec (wks_init) = "0"b;			/* initialize workspace to zero */
     3383       tolts_workspace.l_pad.e = "525252525252"b3;		/* set up our lower buffer pad */
     3384       tolts_workspace.l_pad.o = "525252525252"b3;
     3385       tio_off = fixed (rel (addr (tolts_workspace.p_idcw)));/* set default dcw list offset for ioi */
     3386       idcwp = addr (tolts_workspace.p_idcw);		/* set up idcw ptr */
     3387       idcw.code = "7"b3;				/* set in idcw type code */
     3388       if io_entry.prim.io_cmd = "40"b3			/* if idcw I/O */
     3389        | io_entry.prim.io_cmd = "24"b3
     3390        & io_info.io_type = mhp_io_type then do;		/* | idcw I/O & hyper */
     3391          idcw_io = "1"b;				/* set flag for idcw io */
     3392          idcw.command = io_entry.prim.dev_cmd;		/* set up first idcw from io entry word 4 */
     3393          if (idcw.command = "31"b3 & io_info.chan_suspended)/* if diagnostic mode control... */
     3394 	| io_entry.prim.dev ^= "00"b3 then		/* or punch indicator */
     3395 	  idcw.chan_cmd = "00"b3;			/* set data xfer chan command */
     3396          else if io_entry.prim.io_cmd = "24"b3		/* if cmd = 24 */
     3397 	& io_info.io_type = mhp_io_type then		/* & hyper io */
     3398 	  idcw.chan_cmd = "00"b3;			/* set data xfer chan command */
     3399          else if io_info.io_type = mtar_io_type then	/* if mtar  */
     3400 	  idcw.chan_cmd = "00"b3;			/* set data xfer chan command */
     3401          else idcw.chan_cmd = "40"b3;			/* otherwise set special cont. cmd */
     3402          idcw.count = io_entry.prim.record_count;		/* set record count */
     3403          if idcw.count ^= "00"b3 & idcw.count ^= "01"b3 then do; /* if not single idcw */
     3404 	  idcw.control = "10"b;			/* set idcw continue bit */
     3405 	  continue = "1"b;				/* set continue flag */
     3406          end;
     3407          if idcw.command = "00"b3 then			/* if suspend command */
     3408 	  io_info.suspend_chan = "1"b;		/* set flag for mme tdio */
     3409          if idcw.command = "20"b3 then			/* if release command */
     3410 	  io_info.release_chan = "1"b;		/* set flag for tolts_io_int_ */
     3411       end;					/* note that device code is = 0 */
     3412       else do;					/* not idcw I/O, single or dual I/O */
     3413          idcw_io = "0"b;
     3414          idcw.command = io_entry.second.dev_cmd;		/* get idcw from word 7 (same for single or dual I/O */
     3415          idcw.chan_cmd = io_entry.second.io_cmd;
     3416          idcw.count = io_entry.second.record_count;
     3417          if io_info.io_type = itr_io_type		/* insure that release_chan is reset */
     3418 	then io_info.suspend_chan = "0"b;		/* in the event no special was returned */
     3419          if io_entry.prim.dev_cmd ^= io_entry.second.dev_cmd then do; /* disk/dual I/O */
     3420 	  idcwp = addr (tolts_workspace.seek_idcw);	/* set up seek idcw */
     3421 	  idcw.command = io_entry.prim.dev_cmd;		/* set device command */
     3422 	  if bin (io_entry.sct_add, 13) >= 512
     3423 	   then idcw.device = io_info.altsct.device_no;
     3424 	  else idcw.device = io_info.devsct.device_no;
     3425 	  idcw.code = "7"b3;
     3426 	  idcw.control = "10"b;			/* set continue bit in idcw */
     3427 	  idcw.chan_cmd = io_entry.prim.io_cmd;
     3428 	  idcw.count = io_entry.prim.record_count;
     3429 	  dcwp = addr (tolts_workspace.seek_dcw);	/* set ptr to seek dcw */
     3430 	  string (dcw) = "0"b;			/* initialize */
     3431 	  dcw.address = rel (addr (tolts_workspace.seek_add)); /* set dcw address */
     3432 	  dcw.tally = "0001"b3;			/* set tally of one */
     3433 	  i = fixed (rel (addrel (execp, first_dcw.address))); /* compute index to seek add */
     3434 	  tolts_workspace.seek_add = exec_wd (i);	/* move seek address to workspace */
     3435 	  tio_off = fixed (rel (addr (tolts_workspace.seek_idcw))); /* set dcw list offset to seek idcw */
     3436          end;
     3437       end;
     3438 
     3439 /* process dcw list */
     3440 
     3441       idcwp = addr (tolts_workspace.p_idcw);		/* set primary idcw ptr */
     3442 
     3443       if ^mpc_io then				/* if not controller io */
     3444          if bin (io_entry.sct_add, 13) >= 512
     3445 	then idcw.device = io_info.altsct.device_no;
     3446          else idcw.device = io_info.devsct.device_no;
     3447       dcwp = addrel (execp, io_entry.dcw_ptr);		/* set dcw ptr to first dcw */
     3448       if string (dcw) = "0"b then do;			/* if non data command */
     3449          tolts_workspace.buf_size, c_len = 1;		/* set buffer size to 1 word */
     3450          dcwp = addr (tolts_workspace.dcw_list (1));	/* set up iotd that should not be used */
     3451          string (dcw) = "0"b;				/* initialize dcw */
     3452          dcw.address = rel (addr (tolts_workspace.data_buf));
     3453          dcw.tally = "0001"b3;			/* 1 word iotd */
     3454          if continue then				/* if idcw continue bit set */
     3455 	  idcw.control = "00"b;			/* reset it now */
     3456          go to non_data;				/* bypass dcw processing */
     3457       end;
     3458       io_info.page_base = bin (dcw.address);		/* set first dcw address as data buf base */
     3459       first, found = "0"b;				/* reset terminate condition */
     3460       unspec (io_info.dcw_list) = "0"b;			/* clear out saved dcw list */
     3461       lstloc, nxtloc, j = 1;				/* set initial dcw copy index */
     3462       bufp = addr (tolts_workspace.data_buf (1));		/* set intial buffer ptr */
     3463       do i = 1 to hbound (tolts_workspace.dcw_list, 1) while (^found); /* go through dcw list */
     3464          tolts_workspace.dcw_list (j) = string (dcw);	/* copy dcws (and idcws) to work space */
     3465          io_info.dcw_list (j) = string (dcw);		/* and for interrupt processor */
     3466          if dcw.char_pos = "7"b3 then do;		/* if idcw */
     3467 	  idcwp = addr (tolts_workspace.dcw_list (j));	/* set idcw ptr */
     3468 	  if idcw.control = "10"b then		/* if idcw continue bit set */
     3469 	     continue = "1"b;			/* set continue flag */
     3470 	  else continue = "0"b;			/* otherwise reset it */
     3471 
     3472 	  if ^mpc_io then				/* if not controller io */
     3473 	     if bin (io_entry.sct_add, 13) >= 512
     3474 	      then idcw.device = io_info.altsct.device_no;/* set device code */
     3475 	     else idcw.device = io_info.devsct.device_no;
     3476 	  j = j + 1;				/* increment copy dcw index */
     3477          end;
     3478          else if dcw.type = "10"b then			/* if tdcw */
     3479 	  dcwp = addrel (execp, bin (dcw.address) - 1);	/* set dcwp to list -1 */
     3480          else do;					/* data dcws */
     3481 	  if ^first then do;			/* if the first time through */
     3482 	     first = "1"b;				/* set flag, so we don't come back */
     3483 	     dcwb = bin (dcw.address);		/* set dcw base address */
     3484 	  end;
     3485 	  mvp = addrel (execp, dcw.address);		/* get ptr to data to move */
     3486 	  c_len = bin (dcw.tally);			/* get length of data */
     3487 	  if string (dcw) = "0"b then do;		/* if illegal zero dcw */
     3488 	     c_len = 1;				/* set length = 1 */
     3489 	     dcw.address = io_entry.stat_p;		/* set address to status word */
     3490 	     call tolts_qttyio_$rs			/* tell user */
     3491 	      (0, "Tolts: Last io_entry contains an illegal dcw. Please investigate");
     3492 	  end;
     3493 	  if c_len = 0 then c_len = 4096;		/* allow for a dcw tally of 4096 */
     3494 	  cbuf_add = bin (dcw.address) - dcwb;		/* compute relative address */
     3495 	  if cbuf_add = 0 then			/* if this dcw address is the same last */
     3496 	     cbuf_add = lstloc;			/* set the same index */
     3497 	  else cbuf_add = nxtloc;			/* otherwise use next avail address */
     3498 	  tolts_workspace.buf_size = cbuf_add;
     3499 	  bufp = addr (tolts_workspace.data_buf (cbuf_add)); /* set buffer ptr */
     3500 	  workspace_move = mvp -> workspace_move;	/* and move it */
     3501 	  mvp = addr (tolts_workspace.dcw_list (j));	/* set ptr to workspace dcw */
     3502 	  mvp -> dcw.address = rel (bufp);		/* set relative address */
     3503 	  lstloc = bin (mvp -> dcw.address) - bin (rel (addr (tolts_workspace.data_buf (1)))) + 1;
     3504 	  nxtloc = lstloc + c_len;			/* set next available location */
     3505 	  dcwb = bin (dcw.address);			/* set up to look at nxt dcw */
     3506 	  if idcw_io then do;			/* if running mdrs */
     3507 	     bufp = addrel (bufp, c_len);		/* set nxt buffer address for idcw io */
     3508 	     c_len = 0;				/* reset current length */
     3509 	  end;
     3510 	  j = j + 1;				/* increment copy dcw index */
     3511 	  if dcw.type = "00"b then			/* if iotd */
     3512 	     if ^continue then			/* and continue flag not set */
     3513 	        found = "1"b;			/* set terminate condition */
     3514          end;
     3515          dcwp = addrel (dcwp, 1);			/* increment dcw ptr to next one */
     3516       end;
     3517       tolts_workspace.buf_size = (bin (rel (bufp)) + c_len) - bin (rel (addr (tolts_workspace.data_buf (1))));
     3518 non_data:
     3519       tolts_workspace.h_pad.e = "252525252525"b3;		/* set upper buffer pad */
     3520       tolts_workspace.h_pad.o = "252525252525"b3;
     3521       if io_info.devsct.com_prph then do;		/* if common prph channel */
     3522          pcwa = tolts_workspace.p_idcw;			/* pick up first idcw */
     3523          tio_off = fixed (rel (addr (tolts_workspace.dcw_list (1)))); /* can't execute idcw on com prph */
     3524       end;
     3525       else pcwa = "000000700000"b3;			/* otherwise set phony pcw for ioi */
     3526       if substr (mme_call_w (4), 1, 1) = "1"b then do;	/* if user wants dcws traced */
     3527          io_info.io_trc_flag = "1"b;			/* set io trace flag */
     3528          call ioa_$rsnnl ("^/  ^/*** i/o trace ***^/", message, mesg_len);
     3529          if io_entry.prim.dev_cmd ^= io_entry.second.dev_cmd & ^idcw_io then /* if disk io */
     3530 	  call ioa_$rsnnl ("^a^/seek idcw: - ^12.3b, seek dcw: - ^12.3b, seek address: - ^12.3b",
     3531 	   message, mesg_len, message, tolts_workspace.seek_idcw,
     3532 	   tolts_workspace.seek_dcw, tolts_workspace.seek_add);
     3533          call ioa_$rsnnl ("^a^/^[pcw^;idcw^]: - ^12.3b^/dcw list:^/",
     3534 	message, mesg_len, message, io_info.devsct.com_prph, tolts_workspace.p_idcw);
     3535          do i = 1 by 4 while (tolts_workspace.dcw_list (i) ^= "0"b); /* put out only valid dcws */
     3536 	  call ioa_$rsnnl ("^12.3b ", lginfo, mesg_len, tolts_workspace.dcw_list (i));
     3537 	  do j = 1 to 3 while (tolts_workspace.dcw_list (i + j) ^= "0"b); /* 4 wds per line */
     3538 	     call ioa_$rsnnl ("^a ^12.3b ", lginfo, mesg_len, lginfo, tolts_workspace.dcw_list (i + j));
     3539 	  end;
     3540 	  call ioa_$rsnnl ("^a^/", lginfo, mesg_len, lginfo);
     3541 	  message = rtrim (message) || lginfo;		/* add line to message */
     3542          end;
     3543          call tolts_qttyio_ (message, 10);
     3544       end;
     3545       else io_info.io_trc_flag = "0"b;			/* reset trace flag */
     3546       io_info.ext_status_add = io_entry.ext_sts;		/* copy extended status store address */
     3547       io_info.ignore_term = io_entry.second.ignore_term;	/* copy ignore term flag */
     3548       io_info.icivlu.ic = io_entry.ccc_p;		/* set entry to call on io completion */
     3549       io_info.icivlu.ind = "0"b;			/* initialize indicators */
     3550       io_info.status_add = fixed (io_entry.stat_p);	/* save status storage ptr */
     3551       exec_wd (io_info.status_add) = "0"b;		/* initialize test page status */
     3552       exec_wd (io_info.status_add + 1) = "0"b;
     3553       io_info.pcwa = pcwa;				/* save pcw */
     3554       io_info.tio_off = tio_off;			/* save dcw list offset */
     3555       io_info.rew_wait = "0"b;			/* not expecting special interrupt */
     3556       io_info.io_in_progress = "1"b;			/* set flag for interrupt processing */
     3557       io_info.num_connects = io_info.num_connects + 1;
     3558       io_info.int_time = 0;				/* clear out interrupt time */
     3559 
     3560    end io_setup;
     3561 
     3562 /* get_px_sct - subroutine to get the correct test page index, given entry index */
     3563 /* the globol variables io_sel, mpc_io and io_info_ptr are set up by this subroutine */
     3564 
     3565 get_px_sct: proc (mname, px, ck_alloc);
     3566 
     3567 dcl  mname char (6);
     3568 dcl  px fixed bin;
     3569 dcl  ck_alloc bit (1);
     3570 
     3571       if px >= 1024 then do;				/* ck for controller sct */
     3572          mpc_io = "1"b;				/* set flag if controller sct */
     3573          io_sel = px - 1024;				/* get device sct */
     3574       end;
     3575       else if px >= 512 then do;			/* check for alt. device sct */
     3576          mpc_io = "0"b;
     3577          io_sel = px - 512;				/* get primary device sct */
     3578       end;
     3579       else do;					/* not controller sct, it is device sct */
     3580          mpc_io = "0"b;				/* reset controller io flag */
     3581          io_sel = px;				/* test page index is correct as is */
     3582       end;
     3583       io_sel = divide (io_sel, 4, 17, 0);		/* Multics scts are mod 4 */
     3584       if io_sel < 1 | io_sel > 8 | ^pages (io_sel).in_use |
     3585        (ck_alloc & ^pages (io_sel).allocated) then do;	/* if error in sct */
     3586          call tolts_qttyio_$rs (0, "^as: MME ^a; Invalid SCT - ^6.3b",
     3587 	exec, mname, bit (bin (px, 18)));
     3588          call tolts_abort ("$a2");
     3589       end;
     3590       io_info_ptr = addr (pages (io_sel));		/* get ptr to this test page */
     3591 
     3592    end get_px_sct;
     3593 
     3594 /* get_px_tcx - subroutine to get the correct page index, given the true channel index (ICC) */
     3595 /* the global variables io_sel and io_info_ptr are set up by this subroutine */
     3596 
     3597 get_px_tcx: proc (mname, tci);
     3598 
     3599 dcl  mname char (6);
     3600 dcl  tci bit (11);
     3601 
     3602       do io_sel = 1 to (hbound (pages, 1))
     3603        while (tci ^= pages (io_sel).devsct.icc);		/* find correct page */
     3604       end;
     3605       if io_sel > (hbound (pages, 1)) then do;		/* no matching page */
     3606          call tolts_qttyio_$rs (0, "^as: MME ^a; no matching page found for true chan. index - ^3.3b",
     3607 	exec, mname, tci);
     3608          call tolts_abort ("$m1");
     3609       end;
     3610       else io_info_ptr = addr (pages (io_sel));		/* get ptr to this test page */
     3611 
     3612    end get_px_tcx;
     3613 
     3614 
     3615 /* output_status_code - internal procedure to queue up a status message */
     3616 
     3617 output_status_code: proc (ecode, mess);
     3618 
     3619 dcl  ecode fixed bin (35);
     3620 dcl  mess char (*);
     3621 
     3622       call convert_status_code_ (ecode, shortinfo, lginfo);
     3623       call tolts_qttyio_$rs (0, "^as: ^a^/^a", tolts_info.exec, lginfo, mess);
     3624    end output_status_code;
     3625 
     3626 dealcp_sub: proc;
     3627 
     3628       dealc_err = 0;
     3629       if io_info.p_att | io_info.alloc_wait then do;	/* if perp. device attached to this page */
     3630          call ck_release;				/* go check mpc stae */
     3631          if io_info.io_type = mca_io_type then do;
     3632 	  if io_info.ipc_attached then do;
     3633 	     call tolts_qttyio_$rs (0, "^a IPC ^a not reloaded.^/^a^/", io_info.test_hdr, io_info.ipc_number,
     3634 	      "Do you wish to quit leaving IPC unloaded?");
     3635 ask_again:     call tolts_qttyio_$rs (19, "Please answer yes or no. - ");
     3636 	     call message_wait;			/* wait for users answer */
     3637 	     if tolts_info.mult_ans = "yes"
     3638 	      | tolts_info.mult_ans = "y" then do;
     3639 	        io_info.suspend_chan = "1"b;
     3640 	        opr_query_info.q_sw = "0"b;
     3641 	        call ioa_$rsnnl ("^/^a Unrecoverable error running ipc ^a firmware.^/^-^a",
     3642 	         message, i, io_info.test_hdr, io_info.ipc_number,
     3643 	         "IPC will not be reloaded");
     3644 	        call opr_query_ (addr (opr_query_info),
     3645 	         substr (message, 1, i));		/* tell opr bad news */
     3646 	     end;
     3647 	     else if mult_ans = "no"
     3648 	      | mult_ans = "n" then do;
     3649 	        io_info.io_in_progress = "1"b;		/* set flag for interrupt processing */
     3650 	        io_info.num_connects = io_info.num_connects + 1;
     3651 	        call mca_$load_ipc (io_info.mca_ioi_idx, io_info.ipc_number,
     3652 	         "0"b, code);
     3653 	     end;
     3654 	     else goto ask_again;
     3655 
     3656 	     call mca_$detach_ipc ((io_info.ipc_id), io_info.mca_ioi_idx,
     3657 	      ^io_info.suspend_chan, code);
     3658 	     io_info.ipc_attached = "0"b;
     3659 	  end;
     3660 	  if io_info.mca_attach_state ^= MCA_NOT_CONFIGURED then do;
     3661 	     io_info.io_in_progress = "1"b;		/* set flag for interrupt processing */
     3662 	     io_info.num_connects = io_info.num_connects + 1;
     3663 	     call mca_$reset (io_info.mca_ioi_idx, "0"b, code);
     3664 	     io_info.io_in_progress = "1"b;		/* set flag for interrupt processing */
     3665 	     io_info.num_connects = io_info.num_connects + 1;
     3666 	     call mca_$detach_mca (io_info.mca_ioi_idx, code);
     3667 	  end;
     3668          end;
     3669          else call rcp_$detach (io_info.rcp_id, "0"b, 0, "T&D is detaching " || io_info.device_name, error);
     3670          if error ^= 0 then do;			/* error detaching device */
     3671 	  dealc_err = 1;
     3672 	  call output_status_code (error, "unassign error");
     3673          end;
     3674       end;
     3675 
     3676 /* This code will detach the alternate device for mtar (or anyother program). The alternate device attached
     3677*   flag (io_info.p2_att) is checked to see if an alternate device is attached. If so it is detached.   */
     3678 
     3679       if io_info.p2_att then do;			/* detach alternate device if attached */
     3680          call rcp_$detach (io_info.alt_rcp_id, "0"b, 0, "t&d is detaching " || io_info.alt_device_name, error);
     3681          if error ^= 0 then do;			/* handle detach error */
     3682 	  dealc_err = 1;
     3683 	  call output_status_code (error, "unassign  error");
     3684          end;
     3685       end;
     3686       if io_info.ev_ch_ass then do;			/* if status event channel assigned to this page */
     3687          call ipc_$delete_ev_chn (io_info.status_event, error);
     3688          if error ^= 0 then do;			/* error deleting event channel */
     3689 	  dealc_err = 1;
     3690 	  call output_status_code (error, " deleting test io event channel ");
     3691          end;
     3692       end;
     3693       unspec (io_info) = "0"b;			/* clear the test page data */
     3694       tolts_info.exec_page_count = tolts_info.exec_page_count - 1; /* decrement total test page count */
     3695    end dealcp_sub;
     3696 
     3697 /*  rel_exec_chan - internal procedure to release the colts exec channel */
     3698 
     3699 rel_exec_chan: proc (k);
     3700 
     3701 dcl  k fixed bin (6);
     3702       dmap = addr (tolts_info.fnp (k).dm_arg);		/* get addr of dial_manager arg	*/
     3703       fnp (k).dm_arg.version = dial_manager_arg_version_2;
     3704       fnp (k).dm_arg.dial_qualifier = substr (fnp (k).exec_chan, 1, 22);
     3705       tolts_info.fnp (k).dm_arg.dial_channel = tolts_info.dm_event; /* set dial_channel to event channel */
     3706       tolts_info.fnp (k).dm_arg.channel_name = fnp (k).exec_chan; /* get channel name	*/
     3707 
     3708       call dial_manager_$release_channel (dmap, code);
     3709       if code ^= 0 then do;
     3710          if debugging then call com_err_ (code, "mtdsim_", "Error releasing ^a.", dmap -> dial_manager_arg.channel_name);
     3711          call convert_status_code_ (code, shortinfo, lginfo);
     3712          call tolts_qttyio_$rs (0, "^as: ^a/ error doing exec channel release", tolts_info.exec, lginfo);
     3713          call com_err_ (error, exec, "*** fatal error, terminating process"); /* tell users first */
     3714          fatal_desc.version = 0;
     3715          fatal_desc.fatal_code = error;
     3716          if ^debugging
     3717 	then call terminate_process_ ("fatal_error", addr (fatal_desc));
     3718          else signal tolts_error_;
     3719       end;					/* no need to return, as we won't be back */
     3720       cltp = fnp (k).fnp_execp;
     3721       call close_sw (cltp);
     3722       tolts_info.fnp (k).exec_active = "0"b;
     3723       return;
     3724    end rel_exec_chan;
     3725 
     3726 /* rel_tst_chan - internal procedure to release the colts test channel */
     3727 
     3728 rel_tst_chan: proc (k);
     3729 
     3730 dcl  k fixed bin (6);
     3731 
     3732       dmap = addr (tolts_info.colts_pages (k).dm_arg);
     3733       tolts_info.colts_pages (k).dm_arg.version = dial_manager_arg_version_2;
     3734       tolts_info.colts_pages (k).dm_arg.dial_qualifier = substr (colts_pages (k).cdt_name, 1, 22);
     3735       tolts_info.colts_pages (k).dm_arg.dial_channel = tolts_info.dm_event;
     3736       tolts_info.colts_pages (k).dm_arg.channel_name = colts_pages (k).cdt_name;
     3737       call tolts_qttyio_$rs (0, "Do you want to return the channel ^a to service?", tolts_info.colts_pages (k).cdt_name);
     3738 reask: call tolts_qttyio_$rs (19, "Please answer yes or no - ");
     3739       call message_wait;
     3740       if tolts_info.mult_ans = "yes" | mult_ans = "y" then
     3741          call dial_manager_$release_channel (dmap, code);
     3742       else if tolts_info.mult_ans = "no" | mult_ans = "n" then
     3743          call dial_manager_$release_channel_no_listen (dmap, code);
     3744       else goto reask;
     3745       if code ^= 0 then do;
     3746          if debugging then call com_err_ (code, "mdtsim_", "Error releasing channel ^a.", dmap -> dial_manager_arg.channel_name);
     3747          call convert_status_code_ (code, shortinfo, lginfo);
     3748          call tolts_qttyio_$rs (0, "^as: ^a/ error doing channel detach", tolts_info.exec, lginfo);
     3749          call com_err_ (error, exec, "*** fatal error, terminating process"); /* tell users first */
     3750          fatal_desc.version = 0;
     3751          fatal_desc.fatal_code = error;
     3752          if debugging
     3753 	then call terminate_process_ ("fatal_error", addr (fatal_desc));
     3754          else signal tolts_error_;
     3755       end;					/* no need to return, as we won't be back */
     3756       cltp = colts_pages (k).chanp;
     3757       call close_sw (cltp);
     3758       colts_pages (k).in_use = "0"b;
     3759       tolts_info.exec_page_count = tolts_info.exec_page_count - 1;
     3760       return;
     3761    end rel_tst_chan;
     3762 
     3763 /* close_sw - internal procedure to close and detatch colts io switches */
     3764 
     3765 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     3766 
     3767 
     3768 
     3769 close_sw: proc (cltp);
     3770 
     3771 dcl  cltp ptr;
     3772       call iox_$close (cltp, code);			/* close a switch */
     3773       if code ^= 0 then do;				/* if erroe */
     3774          call convert_status_code_ (code, shortinfo, lginfo); /* convert the status code */
     3775          call tolts_qttyio_$rs (0, "^as: ^a/ doing iox_$close", tolts_info.exec, lginfo); /* and notify the user */
     3776          call com_err_ (error, exec, "*** fatal error, terminating process"); /* tell users first */
     3777          fatal_desc.version = 0;
     3778          fatal_desc.fatal_code = error;
     3779          if ^debugging
     3780 	then call terminate_process_ ("fatal_error", addr (fatal_desc));
     3781          else signal tolts_error_;
     3782       end;
     3783       call iox_$detach_iocb (cltp, code);		/* detach the io switch */
     3784       if code ^= 0 then do;				/* if error */
     3785          call convert_status_code_ (code, shortinfo, lginfo); /* convert the error code */
     3786          call tolts_qttyio_$rs (0, "^as: ^a/ doing iox_$detach", tolts_info.exec, lginfo); /* notify the user */
     3787          call com_err_ (error, exec, "*** fatal error, terminating process"); /* tell users first */
     3788          fatal_desc.version = 0;
     3789          fatal_desc.fatal_code = error;
     3790          if ^debugging
     3791 	then call terminate_process_ ("fatal_error", addr (fatal_desc));
     3792          else signal tolts_error_;
     3793       end;
     3794       return;
     3795    end close_sw;
     3796 
     3797 /* ctime - internal function to return pl1 time string */
     3798 
     3799 ctime: proc returns (char (16));
     3800 
     3801 dcl  tim char (12);
     3802 dcl  ptime char (16);
     3803 dcl  plen fixed bin;
     3804 
     3805       tim = time;					/* get current time */
     3806       call ioa_$rsnnl ("^2a:^2a:^2a.^6a:", ptime, plen, substr (tim, 1, 2), substr (tim, 3, 2),
     3807        substr (tim, 5, 2), substr (tim, 7, 6));
     3808       return (ptime);				/* return time string */
     3809 
     3810    end ctime;
     3811 
     3812 
     3813 /* clean_up - entry to clean_up - our enviornment before returning to tolts command level */
     3814 
     3815 clean_up: entry;
     3816 
     3817       if exec = "colt" then do;
     3818          do k = 1 to hbound (pages, 1);
     3819 	  if colts_pages (k).in_use then call rel_tst_chan (k);
     3820          end;
     3821          do k = 0 to hbound (fnp, 1);
     3822 	  if fnp (k).exec_active then call rel_exec_chan (k);
     3823          end;
     3824       end;
     3825       do io_sel = 1 to hbound (pages, 1);		/* deallocate all perp. devices */
     3826          io_info_ptr = addr (pages (io_sel));
     3827          if io_info.in_use then
     3828 	  call dealcp_sub;
     3829       end;
     3830       if gicmp ^= null then free gicm;
     3831       if ticmp ^= null then free ticm;
     3832       term = "1"b;					/* set terminate condtion */
     3833       if tolts_info.file_attach then do;		/* if print file attached... */
     3834          call tolts_file_util_$wdump (addr (spa.regs));
     3835          call tolts_file_util_$close;			/* go close it out */
     3836       end;
     3837 
     3838       if tolts_info.term_io_req_cnt ^= 0 & ^tolts_info.finish_cond /* if we are still doing io */
     3839        & ^q_flag then
     3840          go to blk_lbl;
     3841       call tolts_init_$clean_up;			/* go delete our event channels and our slave segment */
     3842       tolts_active = "0"b;				/* reset active state for epilogue handler */
     3843 
     3844       return;
     3845 
     3846 
     3847 /* decode_den - int procedure to decode density info returned from rcp and put into sct entry */
     3848 
     3849 decode_den: proc;
     3850 
     3851       tape_info_ptr = addr (io_info.rcp_area);		/* set tape info ptr */
     3852       if substr (tape_info.density, 1, 6) = "00"b3 then do; /* rcp returned bad density information */
     3853 ask:
     3854          call tolts_qttyio_$rs (0, " ^a RCP returned incorrect device info ^/^a^/", io_info.test_hdr,
     3855 	"Please input density capabilities of device to be tested");
     3856          call tolts_qttyio_$rs (19, "Please input densities in the form: 200,556,800,1600,6250 ^-");
     3857          call message_wait;
     3858          if tolts_info.mult_ans = "200,556,800" then
     3859 	  io_info.devsct.w2.den_cap = "0001"b;
     3860          else if tolts_info.mult_ans = "200,556,800,1600" then
     3861 	  io_info.devsct.w2.den_cap = "0100"b;
     3862          else if tolts_info.mult_ans = "556,800,1600" then
     3863 	  io_info.devsct.w2.den_cap = "0101"b;
     3864          else if tolts_info.mult_ans = "556,800" then
     3865 	  io_info.devsct.w2.den_cap = "1001"b;
     3866          else if tolts_info.mult_ans = "800,1600" then
     3867 	  io_info.devsct.w2.den_cap = "1000"b;
     3868          else if tolts_info.mult_ans = "1600" then
     3869 	  io_info.devsct.w2.den_cap = "1100"b;
     3870          else if tolts_info.mult_ans = "1600,6250" then
     3871 	  io_info.devsct.w2.den_cap = "1011"b;
     3872          else if tolts_info.mult_ans = "6250" then
     3873 	  io_info.devsct.w2.den_cap = "1010"b;
     3874          else do;
     3875 	  call tolts_qttyio_$rs (0, "Incorrect reply. ^/ ^a ^/", /* If no match we fall thru */
     3876 	   "Do you want to run with default density");
     3877 	  call tolts_qttyio_$rs (19, "Please answer yes or no");
     3878 	  call message_wait;
     3879 	  if tolts_info.mult_ans = "no" | mult_ans = "n" then goto ask; /* ask for density again */
     3880 	  else if io_info.crcst.mtp610 then do;
     3881 	     io_info.devsct.w2.den_cap = "1100"b;	/* if mtp610 set density to 1600 only */
     3882 	     call tolts_qttyio_$rs (0, "Test will be run at 1600bpi ^/");
     3883 	  end;
     3884 	  else do;
     3885 	     io_info.devsct.w2.den_cap = "1000"b;	/* else run at 500/800bpi */
     3886 	     call tolts_qttyio_$rs (0, "Test will be run at 500/1600bpi ^/");
     3887 	  end;
     3888          end;
     3889       end;
     3890       else if substr (tape_info.density, 1, 6) = "70"b3 then/* 200,556 and 800 bpi */
     3891          io_info.devsct.w2.den_cap = "0001"b;
     3892       else if substr (tape_info.density, 1, 6) = "74"b3 then/* 200,556,800 and 1600 bpi */
     3893          io_info.devsct.w2.den_cap = "0100"b;
     3894       else if substr (tape_info.density, 1, 6) = "30"b3 then/* 556 and 800 bpi */
     3895          io_info.devsct.w2.den_cap = "1001"b;
     3896       else if substr (tape_info.density, 1, 6) = "14"b3 then/* 800 and 1600 bpi */
     3897          io_info.devsct.w2.den_cap = "1000"b;
     3898       else if substr (tape_info.density, 1, 6) = "04"b3 then/* 1600 bpi only */
     3899          io_info.devsct.w2.den_cap = "1100"b;
     3900       else if substr (tape_info.density, 1, 6) = "06"b3 then/* 1600 and 6250 bpi */
     3901          io_info.devsct.w2.den_cap = "1011"b;
     3902       else if substr (tape_info.density, 1, 6) = "02"b3 then/* 6250 bpi only */
     3903          io_info.devsct.w2.den_cap = "1010"b;
     3904       else if substr (tape_info.density, 1, 6) = "34"b3 then/* 556, 800, and 1600bpi */
     3905          io_info.devsct.w2.den_cap = "0101"b;
     3906    end decode_den;
     3907 
     3908 /* pop_isc - subroutine to pop the inter slave read queue and return data to slave exec */
     3909 
     3910 pop_isc: proc (s_add, d_add);
     3911 
     3912 dcl  (s_add, d_add) fixed bin;
     3913 
     3914       exec_wd (s_add) = "400000000000"b3;		/* set status to complete */
     3915       exec_wd (d_add) = tolts_info.exec_dta (1).word (1);	/* move isc data from queue */
     3916       exec_wd (d_add + 1) = tolts_info.exec_dta (1).word (2);
     3917       exec_wd (d_add + 2) = tolts_info.exec_dta (1).word (3);
     3918       tolts_info.exec_dta_cnt = tolts_info.exec_dta_cnt - 1;/* decrement count */
     3919       do i = 1 to tolts_info.exec_dta_cnt;
     3920          tolts_info.exec_dta (i) = tolts_info.exec_dta (i + 1); /* move queue down */
     3921       end;
     3922 
     3923    end pop_isc;
     3924 
     3925 /* ck_release - subroutine to check to see if mpc firmware has been destoryed and reload it */
     3926 
     3927 ck_release: proc;
     3928 
     3929       if io_info.io_in_progress then do;		/* if some io outstanding */
     3930          call timer_manager_$reset_alarm_wakeup (tolts_info.gewake_event); /* Be sure no alarm already set */
     3931          call ipc_$drain_chn (tolts_info.gewake_event, error); /* In case event occured */
     3932          call timer_manager_$alarm_wakeup (10, "11"b, tolts_info.gewake_event); /* Set 10 second timer */
     3933          tolts_info.gewake_active = "1"b;		/* set flag */
     3934          do while (tolts_info.gewake_active);		/* wait for timer to go off or interrupt */
     3935 	  call ipc_$block (addr (tolts_info.wait_list), addr (event_out), error); /* Wait for a second */
     3936          end;
     3937 
     3938          if io_info.chan_suspended then			/* if ioi_$suspend has been called */
     3939 	  if io_info.io_type = itr_io_type
     3940 	   | io_info.io_type = firm_ld_io_type then do;	/* and itrs have been run or attempted to load fw */
     3941 retry_ld:
     3942 	     call tolts_load_firmware_ (io_sel, error);	/* go reload firmware */
     3943 	     if error ^= 0 then do;			/* some problem, ask user what to do */
     3944 	        if tolts_info.finish_cond then		/* if we don't have a terminal... */
     3945 		 go to tell_opr;			/* just tell opr bad news */
     3946 	        call tolts_qttyio_$rs (0, "^a Error loading mpc firmware.^/^a^/", io_info.test_hdr,
     3947 	         "Do you wish to retry or quit leaving mpc suspended?");
     3948 retype:
     3949 	        call tolts_qttyio_$rs (19, "Please answer retry or quit. - ");
     3950 	        call message_wait;			/* wait for users answer */
     3951 	        if tolts_info.mult_ans = "retry" then go to retry_ld; /* go retry load again */
     3952 	        else if tolts_info.mult_ans = "quit" then do;
     3953 tell_opr:
     3954 		 opr_query_info.q_sw = "0"b;
     3955 		 call ioa_$rsnnl ("^/^a ^a^/^-^a", message, i, io_info.test_hdr,
     3956 		  "Unrecoverable error loading mpc firmware.", "I/O will remain suspended");
     3957 		 call opr_query_ (addr (opr_query_info), substr (message, 1, i)); /* tell opr bad news */
     3958 	        end;
     3959 	        else go to retype;			/* user gave wrong answer */
     3960 	     end;
     3961 	  end;
     3962 
     3963 	  else if io_info.io_type ^= mca_io_type then do; /* must be suspended from mdr io */
     3964 	     ioi_wksp = io_info.workspace_ptr;		/* get a ptr to our workspace */
     3965 	     unspec (wks_init) = "0"b;		/* initialize workspace to zero */
     3966 	     idcwp = addr (tolts_workspace.p_idcw);	/* set up idcw ptr */
     3967 	     idcw.code = "7"b3;			/* set in idcw type code */
     3968 	     idcw.command = "20"b3;			/* set release command */
     3969 	     idcw.chan_cmd = "40"b3;			/* special cont. command */
     3970 	     pcwa = "000000700000"b3;			/* set up phony pcw */
     3971 	     tio_off = fixed (rel (addr (tolts_workspace.p_idcw)));
     3972 	     io_info.release_chan = "1"b;		/* set flag for interrupt processor */
     3973 	     call timer_manager_$reset_alarm_wakeup (tolts_info.gewake_event); /* Be sure no alarm already set */
     3974 	     call ipc_$drain_chn (tolts_info.gewake_event, error); /* In case event occured */
     3975 	     call timer_manager_$alarm_wakeup (10, "11"b, tolts_info.gewake_event); /* Set 10 second timer */
     3976 	     tolts_info.gewake_active = "1"b;		/* set flag */
     3977 	     if pages (io_sel).p_att then do;
     3978 	        call ioi_$connect_pcw (io_info.device_index, tio_off, pcwa, error);
     3979 	        if error ^= 0 then
     3980 		 call output_status_code (error, "cleanup io connect error");
     3981 	        tolts_info.glob_int_cnt = tolts_info.glob_int_cnt + 1; /* increment global IO count */
     3982 	     end;
     3983 	     do while (tolts_info.gewake_active);	/* wait for timer to go off or interrupt */
     3984 	        call ipc_$block (addr (tolts_info.wait_list), addr (event_out), error); /* Wait for a second */
     3985 	     end;
     3986 	     if io_info.io_in_progress then do;		/* if we still got timeout... */
     3987 	        call ioa_$rsnnl ("^/^a ^a^/^-^a", message, i, io_info.test_hdr,
     3988 	         "Unable to release mpc,", "manually reset and branch to reinitialize mpc");
     3989 	        opr_query_info.q_sw = "0"b;
     3990 	        call opr_query_ (addr (opr_query_info), substr (message, 1, i));
     3991 	        call ioi_$release_devices (io_info.device_index, error); /* do it now */
     3992 	     end;
     3993 	  end;
     3994       end;
     3995    end ck_release;
     3996 
     3997 /* message_wait - subroutine to wait for terminal message to complete */
     3998 
     3999 message_wait: proc;
     4000 
     4001       do while (tolts_info.term_io_req_cnt > 0);		/* wait for all terminal io to complete */
     4002          call ipc_$block (addr (tolts_info.wait_list), addr (event_out), error);
     4003       end;
     4004 
     4005    end message_wait;
     4006 
     4007 
     4008 /* set_gelbar - int procedure to set up information to enter gelbar mode */
     4009 
     4010 set_gelbar: proc;
     4011 
     4012 dcl  fwd bit (36);
     4013 
     4014 dcl  1 acc_over based (addr (fwd)) aligned,		/* overlay of acc fault status */
     4015        (2 bar bit (18),				/* BAR value from last mme gelbar */
     4016        2 nu1 bit (1),
     4017        2 fault bit (1),				/* "1"b = fault occurred */
     4018        2 nu2 bit (1),
     4019        2 overflow bit (1),				/* "1"b = fixed point overflow */
     4020        2 ex_over bit (1),				/* "1"b = exponent overflow */
     4021        2 ex_under bit (1),				/* "1"b = exponent underflow */
     4022        2 ipr bit (1),				/* "1"b = eis data ipr fault */
     4023        2 nu3 bit (4),
     4024        2 dcf bit (1),				/* "1"b = divide check fault */
     4025        2 f_type fixed bin (5)) unaligned;		/* fault type, (refer to gcos manual DD19) */
     4026 
     4027       fwd = "0"b;					/* reset all bits */
     4028       acc_over.fault = "1"b;				/* valid gelbar fault,set the fault bit */
     4029       acc_over.bar = substr (spa.acc_fault, 1, 18);	/* pick up the current bar setting */
     4030       spa.acc_fault = fwd;				/* store accumlated ault status */
     4031       spa.enter.lbar.bar = "000630"b3;			/* reset bar to 0 lal */
     4032       spa.enter.icivlu.ic = rel (addr (spa.glbflt));	/* set ic to return to gelbar fault vector */
     4033       call tolts_init_$gc_tod (gcos_tod);		/* get current time of day */
     4034       spa.glbtmr = bit (fixed (gcos_tod, 35, 0) - fixed (string (spa.glbici), 35, 0), 36); /* delta time */
     4035       spa.glbici.ic = bit (bin (scu.ilc, 17) + 1, 18);	/* store current ic + 1 */
     4036       spa.glbici.ind = string (scu.ir);			/* and indicators */
     4037       gelbar, in_ccc = "0"b;				/* reset gelbar mode, and in ccc  */
     4038       glb_brk = "1"b;				/* and set gelbar break ind */
     4039       call wake_disp;				/* go wake up dispatcher */
     4040 
     4041    end set_gelbar;
     4042 
     4043 
     4044 
     4045 
  1     1 /* BEGIN INCLUDE FILE ... author_dcl.incl.pl1 */
  1     2 
  1     3 /* This include file declares the "author" substructure
  1     4*   in a form suitable for using the PL/I "like" attribute.
  1     5*
  1     6*   Written 750304 by PG
  1     7**/
  1     8 
  1     9 dcl 1 author_dcl aligned based,
  2     1 /* BEGIN INCLUDE FILE author.incl.pl1 */
  2     2 
  2     3 /* the "author" items must always be the first ones in the table. The
  2     4*   module which moves the converted table to the System Control process
  2     5*   fills in these data items and assumes them to be at the head of the segment
  2     6*   regardless of the specific table's actual declaration. The variables
  2     7*   "lock" and "last_install_time" used to be "process_id" and "ev_channel"
  2     8*    respectively. For tables installed in multiple processes, these
  2     9*    are to be used to lock out multiple installations. */
  2    10 
  2    11 /*  Lock should be used as a modification lock. Since, in general,
  2    12*    entries may not be moved in system tables, even by installations,
  2    13*    it is sufficient for only installers and programs that change threads
  2    14*    to set or respect the lock. Simply updating data in an entry
  2    15*    requires no such protection.
  2    16*
  2    17*    Last_install_time is used by readers of system tables to detect
  2    18*    installations or other serious modifications. By checking it before
  2    19*    and after copying a block of data, they can be protected against
  2    20*    modifications.
  2    21*
  2    22*    Modules that set the lock should save proc_group_id, and then
  2    23*    put their group id there for the time they hold the lock.
  2    24*    if they do not actually install the, they should restore the group id.
  2    25**/
  2    26 
  2    27     2 author aligned,				/* validation data about table's author */
  2    28       3 proc_group_id char (32),			/* process-group-id  (personid.projectid.tag) */
  2    29       3 lock bit (36),				/* installation lock */
  2    30       3 update_attributes bit (1) unal,			/* update/add/delete attributes */
  2    31       3 update_authorization bit (1) unal,		/* update only authorizations */
  2    32       3 deferral_notified bit (1) unal,			/* installer notified of deferral of installation */
  2    33       3 pad bit (33) unaligned,
  2    34       3 last_install_time fixed bin (71),
  2    35       3 table char (4),				/* name of table, e.g., SAT MGT TTT RTDT PDT etc. */
  2    36       3 w_dir char (64),				/* author's working directory */
  2    37 
  2    38 /* END INCLUDE FILE author.incl.pl1 */
  1    10 
  1    11     2 pad;
  1    12 
  1    13 /* END INCLUDE FILE ... author_dcl.incl.pl1 */
     4046 
     4047 
  3     1 /* BEGIN INCLUDE FILE ... cdt.incl.pl1 */
  3     2 
  3     3 /* format: style3,idind25,indcomtxt */
  3     4 
  3     5 /* Channel Definition Table.
  3     6*   This table lists all of the hardware channels (ports) connected
  3     7*   to the system, and maintains the attributes of each one.
  3     8*
  3     9*   PG 741230
  3    10*   Modified by Mike Grady 5/6/76 to add FNP info.
  3    11*   Modified by Tom Casey 7/29/76 to add more FNP info and a few other things.
  3    12*   Modified by Robert Coren 6/13/77 to make terminal types be character strings.
  3    13*   Modified July 1979 by T. Casey to add several variables for MR8.0 process preservation facility.
  3    14*   Modified December 1980 by E. N. Kittlitz to eliminate cdte.phone_no.
  3    15*   Modified March 1981 by Robert Coren to add "listening" flag for multiplexers and to add TANDD_SERVICE service_type.
  3    16*   Modified April 1981 by E. N. Kittlitz to add cdte.dial_ev_chn, cdte.recent_wakeup_time, cdte.recent_wakeup_count.
  3    17*   Modified July 1981 by T. Casey for MR9.0 to add dialup_flags.detach_after_hangup
  3    18*   Modified December 1981 by E. N. Kittlitz for cdte.leave_edited, cdte.hold_arg,
  3    19*   Modified September 1981 by Benson I. Margulies for cdt_mgr_'s tree of multiplexer's.
  3    20*   Modified August 1982 by E. N. Kittlitz for check_acs.
  3    21*   Modified January 1983 by Keith Loepere for generic_destination.
  3    22*   Modified August 1983 by Robert Coren to add mpxe.check and mpxe.retry_load.
  3    23*   Modified 831216 by E. N. Kittlitz for required_access_class.
  3    24*   Modified 84-04-01 by BIM to finish communications AIM:
  3    25*   access class ranges,
  3    26*   access_control flags.
  3    27**/
  3    28 
  3    29 
  3    30 /****^  HISTORY COMMENTS:
  3    31*  1) change(87-03-17,Beattie), approve(87-04-06,MCR7656),
  3    32*     audit(87-07-13,Parisek), install(87-08-04,MR12.1-1056):
  3    33*     Add support for answering service to use IOCBs when tty_ cannot be
  3    34*     used to service login channels.
  3    35*                                                   END HISTORY COMMENTS */
  3    36 
  3    37 
  3    38 dcl	CDT_version_5	     fixed bin internal static initial (5) options (constant);
  3    39 dcl	CDT_version	     fixed bin internal static initial (6) options (constant);
  3    40 
  3    41 dcl	(cdtp, cdtep, fnpep, mpxep)
  3    42 			     ptr;
  3    43 
  3    44 dcl	1 cdt		     based (cdtp) aligned,	/* all of the system channels */
  3    45 	  2 author	     like author_dcl.author,	/* standard header */
  3    46 	  2 max_size	     fixed bin,		/* maximum number of cdte's in 255K */
  3    47 	  2 current_size	     fixed bin,		/* number of last cdte. */
  3    48 	  2 version	     fixed bin,
  3    49 	  2 freep		     fixed bin,		/* chain of free cdte's */
  3    50 	  2 n_cdtes	     fixed bin,		/* number of used cdte's */
  3    51 	  2 meters_last_reset    fixed bin (71),	/* clock time dialup meters were reset */
  3    52 	  2 realtime_in_dialup   fixed bin (71),	/* Dialup meter */
  3    53 	  2 cpu_in_dialup	     fixed bin (71),	/* .. */
  3    54 	  2 pf_in_dialup	     fixed bin,		/* .. */
  3    55 	  2 pp_in_dialup	     fixed bin,		/* .. */
  3    56 	  2 entries_to_dialup    fixed bin,		/* .. */
  3    57 	  2 flags,
  3    58 	    3 go		     bit (1) unal,		/* ans. serv. said "go ahead and answer the phones" */
  3    59 	    3 cdt_is_live	     bit (1) unal,		/* cdt is active */
  3    60 	    3 mux_mgr_system_init
  3    61 			     bit (1) unal,		/* mux mgr has loaded top-levels */
  3    62 	    3 pad1	     bit (33) unal,
  3    63 	  2 acceptable_fnp_tbf   fixed bin,		/* acceptable minutes between FNP crashes */
  3    64 	  2 spare_channel_count  fixed bin,		/* number of extra channels to leave room for in ring0 */
  3    65 	  2 threads	     aligned like channel_threads,
  3    66 						/* root of non-fnp-top-level-multiplexers */
  3    67 	  2 pad2		     (31) bit (36) aligned,	/* pad header to 80 words */
  3    68 	  2 fnp_entry	     dim (8) like fnpe,	/* max of 8 FNPs for now */
  3    69 	  2 cdt_entry	     dim (2500) like cdte;	/* # of cdte's in 255K */
  3    70 
  3    71 
  3    72 dcl	1 cdte		     based (cdtep) aligned,	/* a channel */
  3    73 	  2 in_use	     fixed bin,		/* see dialup_values. 0=NOW_FREE */
  3    74 /**** * These variables are filled in when the CDTE is created by cv_cmf. They are not dynamic. */
  3    75 	  2 pad1		     bit (36) aligned,
  3    76 	  2 name		     char (32),		/* ASCII name of channel */
  3    77 	  2 access_class	     (2) bit (72) aligned,	/* access class range */
  3    78 	  2 comment	     char (48),		/* printable message about channel */
  3    79 	  2 charge_type	     fixed bin (17) unal,	/* billing group */
  3    80 	  2 service_type	     fixed bin (17) unal,	/* service group (AS, ftp, mc) */
  3    81 	  2 line_type	     fixed bin (17) unal,	/* tty line type (protocol) */
  3    82 	  2 baud_rate	     fixed bin (17) unal,	/* 110, 133, 150, etc. */
  3    83 	  2 modem_type	     fixed bin (17) unal,	/* type of modem on this channel */
  3    84 	  2 pad2		     bit (18) unaligned,
  3    85 	  2 answerback	     char (8),		/* answerback string expected */
  3    86 	  2 initial_terminal_type
  3    87 			     char (32) unal,	/* as specified in the CMF */
  3    88 	  2 mpx_data	     unal,		/* data used only for multiplexed channels */
  3    89 	    3 mpx_type	     fixed bin (17),	/* type of multiplexing used */
  3    90 	    3 mpx_service	     fixed bin (17),	/* service type, active or inactive */
  3    91 	  2 flags,
  3    92 	  ( 3 attributes,
  3    93 	      4 ck_answerback    bit (1),		/* ON means that ansbk must equal our records */
  3    94 	      4 audit_access_error
  3    95 			     bit (1),		/* ON means ck that person auth is inside access class range  */
  3    96 						/*    this implies that the access_class describes a range of
  3    97*						   legitimate user auths. */
  3    98 	      4 hardwired	     bit (1),		/* ON means it is */
  3    99 	      4 set_modes	     bit (1),		/* ON means to set initial modes at dialup */
  3   100 	      4 dont_read_answerback
  3   101 			     bit (1),		/* ON means don't try to read answerback */
  3   102 	      4 pada	     bit (4),
  3   103 	    3 access_control     unaligned,		/* As below */
  3   104 	      4 dial_out	     bit (1),		/* dialing user must be on ACS */
  3   105 	      4 priv_attach	     bit (1),		/* PA_ user must be on ACS */
  3   106 	      4 dial_server	     bit (1),		/* accept_dials process must be on acs */
  3   107 	      4 login	     bit (1),		/* logging in user must be on acs */
  3   108 	      4 slave_dial	     bit (1),		/* dialing user must give -user and be on acs */
  3   109 	      4 pado	     bit (3),
  3   110 	    3 options,
  3   111 	      4 execute_initial_command
  3   112 			     bit (1),		/* ON means to do it */
  3   113 	      4 attached_by_operator
  3   114 			     bit (1),		/* ON means temporary attachment. */
  3   115 	      4 private_line     bit (1),		/* ON means private_line sync modem in use */
  3   116 	      4 bsc_ebcdic	     bit (1),		/* ON means bsc would like to use ebcdic code set */
  3   117 	      4 bsc_transparent  bit (1),		/* ON means bsc is in transparent mode */
  3   118 	      4 vip_pollselect   bit (1),		/* ON means VIP line is multidrop */
  3   119 	      4 autobaud	     bit (1),		/* ON means auto baud detection this channel */
  3   120 	      4 generic_destination_present
  3   121 			     bit (1),		/* ON means that the initial_command field contains
  3   122*						   a generic destination to match on dial_out or priv attach */
  3   123 	      4 use_iocb	     bit (1),		/* ON means to use IOCB operations to support channel */
  3   124 	      4 pado	     bit (9)
  3   125 	      )		     unaligned,
  3   126 	  2 initial_command	     char (64),		/* pseudo first input line */
  3   127 /**** The following variables represent dynamic control info, and
  3   128*      are used mostly by dialup_ and asu_ */
  3   129 	  2 event		     fixed bin (71),	/* event call channel for channel events */
  3   130 	  2 current_service_type fixed bin (17) unal,	/* Current usage of line. */
  3   131 	  2 tra_vec	     fixed bin (17) unal,	/* which section of dialup_ to do next */
  3   132 	  2 count		     fixed bin (17) unal,	/* How many login tries he's had. */
  3   133 	  2 dialup_flags	     unal,		/* flag bits for dialup to maintain */
  3   134 	    3 ppm		     bit (1) unal,		/* print preaccess message for IBM terminals */
  3   135 	    3 cpo		     bit (1) unal,		/* conditional printer-off (depends on answerback */
  3   136 	    3 wakeup_handler     bit (1) unal,		/* says who is wakeup handler for this channel */
  3   137 						/* 0 = dialup_, 1 = mc_tty_ */
  3   138 	    3 save_arg	     bit (1) unal,		/* -save login arg given */
  3   139 	    3 nosave_arg	     bit (1) unal,		/* -nosave login arg given */
  3   140 	    3 detach_after_hangup
  3   141 			     bit (1) unal,		/* remember WAIT_DETACH when setting WAIT_BEFORE_HANGUP */
  3   142 	    3 leave_edited	     bit (1) unal,		/* user control of edited mode */
  3   143 	    3 hold_arg	     bit (1) unal,		/* -hold arg given */
  3   144 	    3 no_hold_arg	     bit (1) unal,		/* -no_hold arg given */
  3   145 	    3 immediate_arg	     bit (1) unal,		/* -immediate arg given */
  3   146 	    3 current_access_class_valid
  3   147 			     bit (1) unal,		/* dialup_ or lg_ctl_ has determined the current_access_class */
  3   148 	    3 pad		     bit (7) unal,
  3   149 	  2 twx		     fixed bin,		/* channel device index */
  3   150 	  2 state		     fixed bin,		/* channel state */
  3   151 	  2 tty_id_code	     char (4),		/* channel id (answerback) */
  3   152 	  2 current_terminal_type
  3   153 			     char (32) unal,	/* most recently-set terminal type */
  3   154 	  2 process	     ptr unal,		/* ptr to ATE owning this channel */
  3   155 	  2 dialed_to_procid     bit (36),		/* Dialed channels remember owner's proc id */
  3   156 	  2 next_channel	     fixed bin (17) unal,	/* cdte index of next channel for this process */
  3   157 	  2 cur_line_type	     fixed bin (17) unal,	/* line type of currently dialed terminal */
  3   158 	  2 current_access_class (2) bit (72) aligned,	/* This is a range, but at this time it must be a null range.
  3   159*						   We do not yet define multi-class connections, but we will someday. */
  3   160 	  2 disconnected_ate_index
  3   161 			     fixed bin (17) unal,	/* index of ate of disconnected process */
  3   162 	  2 dial_ctl_ring	     fixed bin (3) unsigned unaligned,
  3   163 						/* used by dial_ctl_ to record ring of priv_attach or dial_out attachments */
  3   164 	  2 dial_rq_privileged   bit (1) unaligned,	/* used by dial ctl to record comm priv from priv_attach or dial_out request */
  3   165 	  2 pad3		     bit (14) unaligned,
  3   166 /**** The following variables are kept for metering purposes. */
  3   167 	  2 n_dialups	     fixed bin,		/* number of times channel has been dialed up */
  3   168 	  2 n_logins	     fixed bin,		/* number of login sessions on this channel */
  3   169 	  2 dialed_up_time	     fixed bin (35),	/* total time channel was dialed up (seconds) */
  3   170 	  2 dialup_time	     fixed bin (71),	/* time of present dialup */
  3   171 	  2 disconnected_proc_command
  3   172 			     fixed bin (12) unsigned unal,
  3   173 						/* 1 to 5 for -list,-create,-connect,-new_proc,-destroy */
  3   174 	  2 disconnected_proc_number
  3   175 			     fixed bin (12) unsigned unal,
  3   176 						/* {N} in -connect {N}, -new_proc {N}, -destroy {N} */
  3   177 	  2 n_disconnected_procs fixed bin (12) unsigned unal,
  3   178 						/* number of disconnected processes that user has */
  3   179 	  2 recent_wakeup_count  fixed bin,		/* counter to detect channel wakeup loop */
  3   180 	  2 recent_wakeup_time   fixed bin (71),	/* time of first wakeup in suspected channel wakeup loop */
  3   181 	  2 dial_ev_chn	     fixed bin (71),	/* Dialed channels remember master's IPC channel */
  3   182 /**** cdt_mgr_ uses these to maintain the tree of channels. They ****/
  3   183 /**** really belong in the mpxe, but it is full up, and the cdte ****/
  3   184 /**** had the space. */
  3   185 	  2 threads	     aligned like channel_threads,
  3   186 /**** The use name is that of the user who gave the dial or slave ****/
  3   187 /**** preaccess request. ****/
  3   188 	  2 user_name	     unaligned,
  3   189 	    3 person	     char (20) unaligned,
  3   190 	    3 project	     char (9) unaligned,
  3   191 	    3 pad		     char (3) unaligned,	/* no tag */
  3   192 	  2 iocbp		     ptr unaligned;		/* 104 words */
  3   193 
  3   194 
  3   195 dcl	generic_destination	     based char (32);	/* used to match destinations on dial_out and priv_attach,
  3   196*						   overlays initial_command field for slave and autocall lines */
  3   197 
  3   198 
  3   199 
  3   200 dcl	1 fnpe		     based (fnpep) aligned,	/* an FNP */
  3   201 						/* These variables are filled in from the CMF */
  3   202 	  2 type		     fixed bin,		/* type of this FNP, DN355, DN6670, etc. */
  3   203 	  2 memory	     fixed bin,		/* amount of memory on this FNP */
  3   204 	  2 nlslas	     fixed bin,		/* number of lslas on this FNP */
  3   205 	  2 nhslas	     fixed bin,		/* number of hslas on this FNP */
  3   206 	  2 service_type	     fixed bin,		/* service type */
  3   207 	  2 mpx_type	     fixed bin,		/* type of multiplexer on this fnp */
  3   208 	  2 coreimage	     char (168),		/* pathname of image, maybe in >sl1 */
  3   209 /**** The following are used during system operation to remember the state of the FNP */
  3   210 	  2 boot_segp	     ptr,			/* ptr to seg used for bootload */
  3   211 	  2 boot_ev_chan	     fixed bin (71),	/* for ring0 to report crashes and bootload complete */
  3   212 	  2 mpxe		     like mpxe,		/* standard multiplexer data */
  3   213 	  2 threads	     aligned like channel_threads,
  3   214 						/* same mpx threads as channel */
  3   215 	  2 pad3		     (25) fixed bin;	/* pad to 96 words per entry */
  3   216 
  3   217 /* This structure describes the data necessary to control a multiplexer.
  3   218*   For FNP's., a copy appears in the fnpe. For communications lines, it
  3   219*   overlays the initial_command field in the cdte. */
  3   220 
  3   221 dcl	1 mpxe		     based (mpxep) aligned,
  3   222 	  2 state		     fixed bin,		/* current state, up, down, loading */
  3   223 	  2 current_service_type fixed bin,		/* usually = service type, unless cdt installation changes it */
  3   224 	  2 current_mpx_type     fixed bin,		/* type of multiplexer currently running */
  3   225 	  2 n_bootloads	     fixed bin,		/* count of load attempts */
  3   226 	  2 time_initial_load    fixed bin (71),	/* time this MPX first completed a load */
  3   227 	  2 time_last_load	     fixed bin (71),	/* time MPX last completed a bootload */
  3   228 	  2 time_last_crash	     fixed bin (71),	/* time MPX last crashed */
  3   229 	  2 time_load_start	     fixed bin (71),	/* time current load started */
  3   230 	  2 last_tbf	     fixed bin,		/* number of minutes this MPX was up last bootload */
  3   231 	  2 flags		     unal,
  3   232 	    3 go		     bit (1),		/* start MPX after it loads */
  3   233 	    3 listening	     bit (1),		/* listen has been done on subchannels */
  3   234 	    3 check	     bit (1),		/* loaded with check option */
  3   235 	    3 retry_load	     bit (1),		/* reload if load fails */
  3   236 	    3 pad1	     bit (32),
  3   237 	  2 pad2		     (2) fixed bin;		/* pad to 16 words */
  3   238 
  3   239 /* These threads define the tree of multiplexers in the cdt. */
  3   240 /* next_sister and prev_sister link nodes at the same level, ordered */
  3   241 /* by alpha sort order of the channel name. Daughter points to the */
  3   242 /* first child of this node, if any. Daughter count is the number */
  3   243 /* of children, as a consistency check. Mother is a back pointer to */
  3   244 /* the parent, present in all the children, not just the first. */
  3   245 /* threads are cdt indexes. If positive, they index the cdt_entry array */
  3   246 /* in cdt, if negative, they are the negative of an index into the fnp_entry */
  3   247 /* array. If zero, they refer to the top of the non-fnp mpx tree. */
  3   248 
  3   249 dcl	1 channel_threads	     aligned based,
  3   250 	  2 next_sister	     fixed bin unaligned,
  3   251 	  2 prev_sister	     fixed bin unaligned,
  3   252 	  2 daughter	     fixed bin unaligned,
  3   253 	  2 mother	     fixed bin unaligned,	/* negative is a fnpx, positive a cdtx */
  3   254 	  2 pad		     bit (18) unaligned,
  3   255 	  2 daughter_count	     fixed bin unaligned;
  3   256 
  3   257 /* Values for cdte.service_type field */
  3   258 
  3   259 dcl	(
  3   260 	ANS_SERVICE	     init (1),		/* login or dial */
  3   261 	FTP_SERVICE	     init (2),		/* file transfer service */
  3   262 	MC_SERVICE	     init (3),		/* message coordinator */
  3   263 	SLAVE_SERVICE	     init (4),		/* special channel */
  3   264 	DIAL_SERVICE	     init (5),		/* transient state */
  3   265 	DIAL_OUT_SERVICE	     init (6),		/* auto call line */
  3   266 	MPX_SERVICE	     init (8),		/* ring0 demultiplexed line */
  3   267 	TANDD_SERVICE	     init (9)		/* transient state, attached for T & D */
  3   268 	)		     fixed bin internal static options (constant);
  3   269 
  3   270 /* Values for service type in both cdte and fnpe */
  3   271 
  3   272 dcl	(
  3   273 	INACTIVE		     init (7),		/* not to be used, even though configured */
  3   274 	ACTIVE		     init (1)
  3   275 	) /* for FNP only, configured and to be used */
  3   276 			     fixed bin internal static options (constant);
  3   277 
  3   278 /* Value for both cdte.in_use and fnpe.state */
  3   279 
  3   280 dcl	NOT_CONFIGURED	     fixed bin int static init (-1) options (constant);
  3   281 						/* was not configured at Multics bootload time */
  3   282 
  3   283 /* NOTE: an INACTIVE channel can be made active by operator command or CDT installation,
  3   284*   but a NOT_CONFIGURED channel can not be used until its multiplexer is reloaded */
  3   285 
  3   286 /* Value for cdte.in_use */
  3   287 
  3   288 dcl	CHANNEL_DELETED	     fixed bin int static init (-2);
  3   289 						/* channel deleted by CDT installation */
  3   290 
  3   291 /* NOTE: a configured channel being deleted by a CDT installation is set to CHANNEL_DELETED.
  3   292*   multiplexer_mgr_ sets cdte.in_use to NOW_FREE at the next reload of its multiplexer.
  3   293*   A NOT_CONFIGURED channel is set to NOW_FREE immediately when deleted by a CDT installation. */
  3   294 
  3   295 
  3   296 /* Values for mpxe.state field */
  3   297 
  3   298 dcl	(
  3   299 	FNP_FREE		     init (0),		/* this fnpe is not used */
  3   300 	FNP_UNKNOWN	     init (1),		/* FNP is in some unknown state */
  3   301 	FNP_DOWN		     init (2),		/* FNP crashed, not yet reloaded */
  3   302 	FNP_BOOT		     init (3),		/* FNP has been booted, but no response yet */
  3   303 	FNP_UP		     init (4)		/* FNP is up and running fine */
  3   304 	)		     fixed bin internal static options (constant);
  3   305 
  3   306 dcl	(
  3   307 	MPX_FREE		     init (0),		/* this mpxe is not used */
  3   308 	MPX_UNKNOWN	     init (1),		/* MPX is in some unknown state */
  3   309 	MPX_DOWN		     init (2),		/* MPX crashed, not yet reloaded */
  3   310 	MPX_BOOT		     init (3),		/* MPX has been booted, but no response yet */
  3   311 	MPX_UP		     init (4)		/* MPX is up and running fine */
  3   312 	)		     fixed bin internal static options (constant);
  3   313 
  4     1 /* BEGIN INCLUDE FILE ... fnp_types.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  4     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  4     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  4     9*     implementation.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /* Values for fnpe.type field */
  4    14 /*
  4    15*   Created 79 May 14 by Art Beattie by splitting information out from cdt.incl.pl1
  4    16*   Added in March 1982 - DN7100.fd.
  4    17**/
  4    18 
  4    19 dcl (DN355 init (1),				/* a DataNet 355 FNP */
  4    20      DN6600 init (2),				/* a DataNet 6600 FNP */
  4    21      DN6670 init (3),				/* a Honeywell Bull Network Processor (18x) */
  4    22      DN7100 init (4)				/* The DSA Datanet architecture (DN7) */
  4    23      ) fixed bin internal static options (constant);
  4    24 
  4    25 dcl  fnp_types (4) char (8) int static options (constant)
  4    26      init ("DN355", "DN6600", "DN6670", "DN7100");
  4    27 
  4    28 dcl  fnp_models (4) fixed bin (17) int static options (constant)
  4    29      init (355, 6600, 6670, 7100);
  4    30 	
  4    31 dcl  supported_fnp (4) bit (1) int static options (constant)
  4    32      init ("0"b, "0"b, "1"b, "1"b);
  4    33 
  4    34 
  4    35 /* END INCLUDE FILE ... fnp_types.incl.pl1 */
  3   314 
  3   315 
  3   316 /* END INCLUDE FILE ... cdt.incl.pl1 */
     4048 
     4049 
  5     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  5     2 
  5     3 /* Structure for find_condition_info_.
  5     4*
  5     5*   Written 1-Mar-79 by M. N. Davidoff.
  5     6**/
  5     7 
  5     8 /* automatic */
  5     9 
  5    10      declare condition_info_ptr     pointer;
  5    11 
  5    12 /* based */
  5    13 
  5    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  5    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  5    16 	     2 version	      fixed binary,		/* Must be 1 */
  5    17 	     2 condition_name     char (32) varying,	/* name of condition */
  5    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  5    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  5    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  5    21 	     2 flags	      unaligned,
  5    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  5    23 	       3 pad1	      bit (35),
  5    24 	     2 pad2	      bit (36),
  5    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  5    26 	     2 pad3	      (4) bit (36);
  5    27 
  5    28 /* internal static */
  5    29 
  5    30      declare condition_info_version_1
  5    31 			      fixed binary internal static options (constant) initial (1);
  5    32 
  5    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
     4050 
     4051 
  6     1 /* BEGIN INCLUDE FILE ... config_iom_card.incl.pl1 ... 11/37/80 W. Olin Sibert */
  6     2 
  6     3 dcl  iom_cardp pointer;				/* pointer to IOM card */
  6     4 
  6     5 dcl 1 iom_card aligned based (iom_cardp),		/* IOM card declaration */
  6     6     2 word char (4),				/* "iom" */
  6     7     2 tag fixed bin (3),				/* One more than IOM tag set in maintenance panel switches */
  6     8     2 port fixed bin (3),				/* Controller port to which IOM is connected */
  6     9     2 model char (4),				/* IOM model number: "iomb", "nsa", "iioc" */
  6    10     2 state char (4),				/* State: "on" or "off" */
  6    11 
  6    12     2 pad (10) bit (36) aligned,			/* Pad to 15 fields */
  6    13 
  6    14     2 type_word aligned,
  6    15       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  6    16       3 pad1 bit (4) unaligned,
  6    17       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  6    18 
  6    19 dcl  IOM_CARD_WORD char (4) aligned internal static options (constant) init ("iom");
  6    20 
  6    21 /* END INCLUDE FILE ... config_iom_card.incl.pl1 */
     4052 
     4053 
  7     1 /* BEGIN INCLUDE FILE event_wait_info.incl.pl1 */
  7     2 
  7     3 /* T. Casey, May 1978 */
  7     4 
  7     5 dcl  event_wait_info_ptr ptr;
  7     6 
  7     7 dcl 1 event_wait_info aligned based (event_wait_info_ptr),	/* argument structure filled in on return from ipc_$block */
  7     8     2 channel_id fixed bin (71),			/* event channel on which wakeup occurred */
  7     9     2 message fixed bin (71),				/* 72 bits of information passed by sender of wakeup */
  7    10     2 sender bit (36),				/* process id of sender */
  7    11     2 origin,
  7    12       3 dev_signal bit (18) unaligned,			/* "1"b if device signal */
  7    13       3 ring fixed bin (17) unaligned,			/* ring from which sent */
  7    14     2 channel_index fixed bin;			/* index of this channel in the event wait list */
  7    15 
  7    16 /* END INCLUDE FILE event_wait_info.incl.pl1 */
     4054 
     4055 
  8     1 
  8     2 /* BEGIN INCLUDE FILE gload_data.incl.pl1 */
  8     3 /* created 9/29/78 by James A. Bush */
  8     4 
  8     5 dcl 1 gload_data aligned,				/* pertinent info  generated from gload_ */
  8     6    (2 deck_name char (4),				/* name from columns 73-76 of $ object card */
  8     7     2 deck_type bit (1),				/* "0"b = absolute, "1"b = relocatable */
  8     8     2 sym_cnt fixed bin (16),				/* count of valid symbols */
  8     9     2 text_len bit (18),				/* length in words including load offset */
  8    10     2 checksum bit (36),				/* checksum of loaded deck */
  8    11     2 diagnostic char (200),				/* loader diagnostic */
  8    12     2 definition (128),				/* array of definitions */
  8    13       3 symbol char (6),				/* symbol name */
  8    14       3 pad1 bit (18),
  8    15       3 offset bit (18),				/* symbol offset in text */
  8    16       3 pad2 bit (14),
  8    17       3 sym_type fixed bin (3)) unaligned;		/* type of symbol (0 - 7) */
  8    18 
  8    19 /* END INCLUDE FILE gload_data.incl.pl1 */
  8    20 
     4056 
     4057 
  9     1 /*  */
  9     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  9     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  9     4 /* Modified 07/07/76 by Morris for fault register data */
  9     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  9     6 /* Modified '82 to make values constant */
  9     7 
  9     8 /* words 0-15 pointer registers */
  9     9 
  9    10 dcl  mcp ptr;
  9    11 
  9    12 dcl 1 mc based (mcp) aligned,
  9    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  9    14    (2 regs,					/* registers */
  9    15       3 x (0:7) bit (18),				/* index registers */
  9    16       3 a bit (36),					/* accumulator */
  9    17       3 q bit (36),					/* q-register */
  9    18       3 e bit (8),					/* exponent */
  9    19       3 pad1 bit (28),
  9    20       3 t bit (27),					/* timer register */
  9    21       3 pad2 bit (6),
  9    22       3 ralr bit (3),				/* ring alarm register */
  9    23 
  9    24     2 scu (0:7) bit (36),
  9    25 
  9    26     2 mask bit (72),				/* mem controller mask at time of fault */
  9    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  9    28     2 errcode fixed bin (35),				/* fault handler's error code */
  9    29     2 fim_temp,
  9    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  9    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  9    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  9    33     2 fault_reg bit (36),				/* fault register */
  9    34     2 pad2 bit (1),
  9    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  9    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  9    37     2 fault_time bit (54),				/* time of fault */
  9    38 
  9    39     2 eis_info (0:7) bit (36)) unaligned;
  9    40 
  9    41 
  9    42 dcl (apx fixed bin init (0),
  9    43      abx fixed bin init (1),
  9    44      bpx fixed bin init (2),
  9    45      bbx fixed bin init (3),
  9    46      lpx fixed bin init (4),
  9    47      lbx fixed bin init (5),
  9    48      spx fixed bin init (6),
  9    49      sbx fixed bin init (7)) internal static options (constant);
  9    50 
  9    51 
  9    52 
  9    53 
  9    54 dcl  scup ptr;
  9    55 
  9    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  9    57 
  9    58 
  9    59 /*	WORD (0)		*/
  9    60 
  9    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  9    62       3 prr bit (3),				/* procedure ring register */
  9    63       3 psr bit (15),				/* procedure segment register */
  9    64       3 p bit (1),					/* procedure privileged bit */
  9    65 
  9    66     2 apu,					/* APPENDING UNIT STATUS */
  9    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  9    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  9    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  9    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  9    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  9    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  9    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  9    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  9    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  9    76       3 ptw bit (1),				/* Fetch of PTW */
  9    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  9    78       3 fap bit (1),				/* Fetch of final address paged */
  9    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  9    80       3 fabs bit (1),				/* Fetch of final address absolute */
  9    81 
  9    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  9    83 
  9    84 
  9    85 /*	WORD (1)		*/
  9    86 
  9    87     2 fd,						/* FAULT  DATA */
  9    88       3 iro bit (1),				/* illegal ring order */
  9    89       3 oeb bit (1),				/* out of execute bracket */
  9    90       3 e_off bit (1),				/* no execute */
  9    91       3 orb bit (1),				/* out of read bracket */
  9    92       3 r_off bit (1),				/* no read */
  9    93       3 owb bit (1),				/* out of write bracket */
  9    94       3 w_off bit (1),				/* no write */
  9    95       3 no_ga bit (1),				/* not a gate */
  9    96       3 ocb bit (1),				/* out of call bracket */
  9    97       3 ocall bit (1),				/* outward call */
  9    98       3 boc bit (1),				/* bad outward call */
  9    99       3 inret bit (1),				/* inward return */
  9   100       3 crt bit (1),				/* cross ring transfer */
  9   101       3 ralr bit (1),				/* ring alarm register */
  9   102       3 am_er bit (1),				/* associative memory fault */
  9   103       3 oosb bit (1),				/* out of segment bounds */
  9   104       3 paru bit (1),				/* processor parity upper */
  9   105       3 parl bit (1),				/* processor parity lower */
  9   106       3 onc_1 bit (1),				/* op not complete type 1 */
  9   107       3 onc_2 bit (1),				/* op not complete type 2 */
  9   108 
  9   109     2 port_stat,					/* PORT  STATUS */
  9   110       3 ial bit (4),				/* illegal action lines */
  9   111       3 iac bit (3),				/* illegal action channel */
  9   112       3 con_chan bit (3),				/* connect channel */
  9   113 
  9   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  9   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  9   116 
  9   117 
  9   118 /*	WORD (2)		*/
  9   119 
  9   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  9   121       3 trr bit (3),				/* temporary ring register */
  9   122       3 tsr bit (15),				/* temporary segment register */
  9   123 
  9   124     2 pad2 bit (9),
  9   125 
  9   126     2 cpu_no bit (3),				/* CPU number */
  9   127 
  9   128     2 delta bit (6),				/* tally modification DELTA */
  9   129 
  9   130 
  9   131 /*	WORD (3)		*/
  9   132 
  9   133     2 word3 bit (18),
  9   134 
  9   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  9   136       3 tsna,					/* Word 1 status */
  9   137         4 prn bit (3),				/* Word 1  PR  number */
  9   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  9   139       3 tsnb,					/* Word 2  status */
  9   140         4 prn bit (3),				/* Word 2  PR  number */
  9   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  9   142       3 tsnc,					/* Word 3  status */
  9   143         4 prn bit (3),				/* Word 3  PR  number */
  9   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  9   145 
  9   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  9   147 
  9   148 
  9   149 /* 	WORD (4)		*/
  9   150 
  9   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  9   152 
  9   153     2 ir,						/* INDICATOR  REGISTERS */
  9   154       3 zero bit (1),				/* zero indicator */
  9   155       3 neg bit (1),				/* negative indicator */
  9   156       3 carry bit (1),				/* carryry indicator */
  9   157       3 ovfl bit (1),				/* overflow indicator */
  9   158       3 eovf bit (1),				/* eponent overflow */
  9   159       3 eufl bit (1),				/* exponent underflow */
  9   160       3 oflm bit (1),				/* overflow mask */
  9   161       3 tro bit (1),				/* tally runout */
  9   162       3 par bit (1),				/* parity error */
  9   163       3 parm bit (1),				/* parity mask */
  9   164       3 bm bit (1),					/* ^bar mode */
  9   165       3 tru bit (1),				/* truncation mode */
  9   166       3 mif bit (1),				/* multi-word instruction mode */
  9   167       3 abs bit (1),				/* absolute mode */
  9   168       3 hex bit (1),				/* hexadecimal exponent mode */
  9   169       3 pad bit (3),
  9   170 
  9   171 
  9   172 /*	WORD (5)		*/
  9   173 
  9   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  9   175 
  9   176     2 cu,						/* CONTROL UNIT STATUS */
  9   177       3 rf bit (1),					/* on first cycle of repeat instr */
  9   178       3 rpt bit (1),				/* repeat instruction */
  9   179       3 rd bit (1),					/* repeat double instruction */
  9   180       3 rl bit (1),					/* repeat link instruciton */
  9   181       3 pot bit (1),				/* IT  modification */
  9   182       3 pon bit (1),				/* return type instruction */
  9   183       3 xde bit (1),				/* XDE from Even location */
  9   184       3 xdo bit (1),				/* XDE from Odd  location */
  9   185       3 poa bit (1),				/* operation preparation */
  9   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  9   187       3 its bit (1),				/* ITS modification */
  9   188       3 if bit (1),					/* fault occured during instruction fetch */
  9   189 
  9   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  9   191 
  9   192 
  9   193 /*	WORDS (6,7)	*/
  9   194 
  9   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  9   196 
  9   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  9   198 
  9   199 
  9   200 
  9   201 
  9   202 
  9   203 
  9   204 /*	ALTERNATE   SCU  DECLARATION		*/
  9   205 
  9   206 
  9   207 dcl 1 scux based (scup) aligned,
  9   208 
  9   209    (2 pad0 bit (36),
  9   210 
  9   211     2 fd,						/* GROUP II  FAULT DATA */
  9   212       3 isn bit (1),				/* illegal segment number */
  9   213       3 ioc bit (1),				/* illegal op  code  */
  9   214       3 ia_am bit (1),				/* illegal address - modifier */
  9   215       3 isp bit (1),				/* illegal slave  procedure */
  9   216       3 ipr bit (1),				/* illegal procedure */
  9   217       3 nea bit (1),				/* non existent address */
  9   218       3 oobb bit (1),				/* out of bounds */
  9   219       3 pad bit (29),
  9   220 
  9   221     2 pad2 bit (36),
  9   222 
  9   223     2 pad3a bit (18),
  9   224 
  9   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  9   226       3 prn bit (3),				/* PR  number */
  9   227       3 prv bit (1),				/* PR  valid bit */
  9   228 
  9   229     2 pad3b bit (6)) unaligned,
  9   230 
  9   231     2 pad45 (0:1) bit (36),
  9   232 
  9   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  9   234 
  9   235 
  9   236 
  9   237 /*  END INCLUDE FILE   mc.incl.pl1 */
     4058 
     4059 
 10     1 /*	Begin  include file ... mca_data.incl.pl1
 10     2*   *
 10     3*   *	Created on 09/14/84 by Paul Farley.
 10     4*   *      Modified by R. A. Fawcett 10/25/84
 10     5**/
 10     6 
 10     7 /****^  HISTORY COMMENTS:
 10     8*  1) change(85-09-11,Fawcett), approve(85-09-11,MCR6979),
 10     9*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
 10    10*     Created for MCA
 10    11*     support
 10    12*  2) change(86-08-19,Fawcett), approve(86-08-19,MCR7374),
 10    13*     audit(86-08-26,Lippard), install(86-09-16,MR12.0-1159):
 10    14*     Fix problems found in audit of the Online manager code.
 10    15*                                                   END HISTORY COMMENTS */
 10    16 
 10    17 dcl  MCA_data_version_1 char (8) int static options
 10    18 	(constant) init ("MCA00001");
 10    19 
 10    20 dcl  mca_data_seg_ptr ptr static init (null ());
 10    21 
 10    22 dcl  mcad_ptr ptr;
 10    23 
 10    24 dcl  ipcd_ptr ptr;
 10    25 
 10    26 dcl  1 mca_data_seg based (mca_data_seg_ptr),
 10    27        2 version char (8),
 10    28        2 array (1:4) like mcad;
 10    29 
 10    30 
 10    31 dcl  1 mcad based (mcad_ptr) aligned,
 10    32        2 lock bit (36),				/* The mca write lock. */
 10    33        2 state fixed bin,				/* Current mca state */
 10    34        2 attach_time fixed bin (71),			/* DT/time of attach */
 10    35        2 attach_pid bit (36),				/* PID of attaching process */
 10    36        2 name char (1),				/* name of this mca (a b c d) */
 10    37        2 imu_number fixed bin (17),			/* number of the IMU */
 10    38        2 ioi_idx fixed bin,				/* value to use with ioi_ */
 10    39        2 event_chn fixed bin (71),			/* ipc channel for IO processing ring_1 */
 10    40        2 ioi_wks_ptr ptr,				/* pointer to IOI Workspace */
 10    41        2 max_ws_size fixed bin (19),
 10    42        2 pad fixed bin,
 10    43        2 user_ptr ptr,				/* used for async_io */
 10    44        2 return_data_ptr ptr,				/* user for async_io */
 10    45        2 io_param_ptr ptr,				/* pointer to the io_parameter_block for mca returned data */
 10    46        2 entry_to_return_data entry (ptr, fixed bin (21), fixed bin (35)),
 10    47 						/* entry that will return the data to the user for async_io */
 10    48        2 status_offset fixed bin,			/* offset into work space for status */
 10    49        2 current_ws_size fixed bin (18),		/* current work_space */
 10    50        2 rcp_id bit (36),
 10    51        2 flags unaligned,
 10    52          3 async_io bit (1),				/* 1 = outer ring will catch IO events */
 10    53 						/* 0 = ring 1 will go blocked and wait for IO to complete */
 10    54          3 config_data_requested bit (1),		/* used during mca attachment */
 10    55          3 pad bit (34),
 10    56        2 max_time_out fixed bin (71),			/* maximum time for time out */
 10    57        2 last_status bit (71),			/* most recent MCA status return */
 10    58 
 10    59        2 ipcd_array (0:15) like ipcd aligned;
 10    60 
 10    61 dcl  1 ipcd based (ipcd_ptr) aligned,
 10    62        2 ipc_name char (8),				/* "ipcXX" */
 10    63        2 channel fixed bin (17) unaligned,		/* base channel */
 10    64        2 nchan fixed bin (17) unaligned,		/* number of channels */
 10    65        2 type_info,					/* type of IPC */
 10    66          3 no_level_2_info bit (1) unaligned,
 10    67          3 is_micro_cont bit (1) unaligned,
 10    68          3 fbus_disable_latch bit (1) unaligned,
 10    69          3 pad bit (6) unaligned,
 10    70          3 type_index fixed bin (8) unaligned,
 10    71        2 state fixed bin (17) unaligned,		/* current state */
 10    72        2 level_1_state fixed bin (17),			/* LVL-1_STATE  */
 10    73        2 prph_attachments fixed bin (17),		/* # of RCP attachments */
 10    74        2 attach_data (8),
 10    75          3 prph_name char (4),			/* Multics prph name */
 10    76          3 flags unaligned,
 10    77 	 4 attached_thru_rcp bit (1),			/* must detach when done */
 10    78 	 4 io_suspended bit (1),			/* must resume IO when done */
 10    79 	 4 pad (34) bit (1),
 10    80          3 attach_time fixed bin (71),			/* DT/time of attach */
 10    81          3 ipc_rcp_id bit (36),			/* rcp id */
 10    82          3 ipc_ioi_idx fixed bin;			/* index from rcp */
 10    83 
 10    84 dcl  SYSTEM_DIR char (17) init (">system_library_1") static options (constant);
 10    85 dcl  DATA_SEG char (12) init ("mca_data_seg") static options (constant);
 10    86 
 10    87 
 10    88 dcl  (MCA_NOT_CONFIGURED init (0),			/* possible mcad.state values */
 10    89      MCA_FREE init (1),
 10    90      MCA_ATTACHING init (2),
 10    91      MCA_ATTACHED init (3),
 10    92      MAINT_SESSION init (10)) fixed bin internal static options (constant);
 10    93 
 10    94 dcl  (IPC_NOT_CONFIGURED init (0),			/* possible ipcd.state values */
 10    95      IPC_FREE init (1),
 10    96      IPC_ATTACHED init (2)) fixed bin internal static options (constant);
 10    97 
 10    98 /*	End of include file ... mca_data.incl.pl1	*/
     4060 
     4061 
 11     1 /* Begin mca_data_area.incl.pl1 */
 11     2 
 11     3 /****^  HISTORY COMMENTS:
 11     4*  1) change(86-03-19,Fawcett), approve(86-03-19,MCR7374),
 11     5*     audit(86-04-28,Lippard), install(86-09-16,MR12.0-1159):
 11     6*     Created for control of the MCA. This is a template for the ioi workspace
 11     7*     needed for the MCA communications.
 11     8*                                                   END HISTORY COMMENTS */
 11     9 
 11    10 /* Created Sept 84 by R. A. Fawcett from information in
 11    11*   "EPS-1 DIPPER Maintainability" REV A (MAY 3, 1983) */
 11    12 
 11    13 
 11    14 
 11    15 dcl  data_header_ptr ptr;
 11    16 
 11    17 dcl  (data_size_1, data_size_2) fixed bin (21) init (0);
 11    18 
 11    19 dcl  io_param_blk_ptr ptr;
 11    20 
 11    21 dcl  mca_dcw_list_ptr ptr;
 11    22 
 11    23 dcl  mca_work_space_ptr ptr;
 11    24 
 11    25 dcl  1 mca_work_space based (mca_work_space_ptr),
 11    26        2 list_of_dcw like mca_dcw_list,
 11    27        2 status_area like istat,
 11    28 
 11    29        2 data_header_1 aligned like data_header,
 11    30        2 data_1 char (data_size_1),
 11    31        2 data_header_2 aligned like data_header,
 11    32        2 data_2 char (data_size_2);
 11    33 
 11    34 
 11    35 dcl  1 data_header based (data_header_ptr) aligned,
 11    36        2 type bit (9) unal,				/* must be equal to "000"b3 (MBZ) */
 11    37        2 definer fixed bin (9) unal unsigned,		/* defines type of info in header */
 11    38        2 ctl_sw bit (18) unal,			/* "currently undfined" mbz  = "000000"b3 */
 11    39 
 11    40        2 host_sts_ign1 bit (1) unal,
 11    41        2 host_sts_msb bit (8) unal,
 11    42        2 host_sts_ign2 bit (1) unal,
 11    43        2 host_sts_lsb bit (8) unal,
 11    44 
 11    45        2 rd_flpy fixed bin (9) unal unsigned,		/* 0 = data files from host */
 11    46 						/* 1 = data files from flopy */
 11    47        2 io_param_blk like io_parameter_block unal;
 11    48 
 11    49 
 11    50 dcl  1 io_parameter_block based (io_param_blk_ptr) unal,
 11    51        2 open fixed bin (9) unal unsigned,
 11    52        2 cmd bit (18),
 11    53        2 sts_ptr bit (18),				/* Unused */
 11    54        2 file_name char (8),				/* file name for this request */
 11    55        2 options bit (18),				/* Unused */
 11    56        2 source_ptr bit (18),				/* Unused */
 11    57        2 source_len,
 11    58 						/* data_size = source_len_msb||source_len_lsb MCA to HOST */
 11    59          3 source_len_ign1 bit (1),
 11    60          3 source_len_msb bit (8),
 11    61          3 source_len_ign2 bit (1),
 11    62          3 source_len_lsb bit (8),
 11    63        2 dest_ptr bit (18),				/* Unused */
 11    64        2 blk_ct,
 11    65 						/* if MCA to HOST blk_ct_msb||blk_ct_lsb = MAX number of 256 byte BLOCKS  */
 11    66 						/* else not used */
 11    67          3 blk_ct_ign1 bit (1),
 11    68          3 blk_ct_msb bit (8),
 11    69          3 blk_ct_ign2 bit (1),
 11    70          3 blk_ct_lsb bit (8),
 11    71        2 dest_len,
 11    72 						/* supplied by host as the number of bytes in data_field max value is 16128 */
 11    73 						/* dest_len_msb = substr(unspec(data_size),21,8) */
 11    74 						/* dest_len_lsb = substr(unspec(data_size),29,8) */
 11    75          3 dest_len_ign1 bit (1),
 11    76          3 dest_len_msb bit (8),
 11    77          3 dest_len_ign2 bit (1),
 11    78          3 dest_len_lsb bit (8);
 11    79 
 11    80 
 11    81 dcl  1 mca_dcw_list based (mca_dcw_list_ptr),
 11    82        2 idcw1 like idcw,
 11    83        2 dcw1 like dcw,
 11    84        2 idcw2 like idcw,
 11    85        2 dcw2 like dcw;
 11    86 
 11    87 
 12     1 
 12     2 /* Begin include file ...... iom_dcw.incl.pl1 */
 12     3 
 12     4 dcl  dcwp ptr,					/* pointer to DCW */
 12     5      tdcwp ptr;					/* pointer to TDCW */
 12     6 
 12     7 dcl 1 dcw based (dcwp) aligned,			/* Data Control Word */
 12     8      (2 address bit (18),				/* address for data transfer */
 12     9       2 char_pos bit (3),				/* character position */
 12    10       2 m64 bit (1),				/* non-zero for mod 64 address */
 12    11       2 type bit (2),				/* DCW type */
 12    12       2 tally bit (12)) unal;				/* tally for data transfer */
 12    13 
 12    14 dcl 1 tdcw based (tdcwp) aligned,			/* Transfer DCW */
 12    15      (2 address bit (18),				/* address to transfer to */
 12    16       2 mbz1 bit (4),
 12    17       2 type bit (2),				/* should be "10"b for TDCW */
 12    18       2 mbz2 bit (9),
 12    19       2 ec bit (1),					/* non-zero to set LPW AE bit */
 12    20       2 res bit (1),				/* non-zero to restrict further use of IDCW */
 12    21       2 rel bit (1)) unal;				/* non-zero to set relative mode after transfer */
 12    22 
 12    23 /* End of include file ...... iom_dcw.incl.pl1 */
 12    24 
 11    88 




 11    89 
 13     1 
 13     2 /* Begin include file ...... iom_pcw.incl.pl1 */
 13     3 
 13     4 dcl  pcwp ptr;					/* pointer to PCW */
 13     5 
 13     6 dcl 1 pcw based (pcwp) aligned,			/* Peripheral Control Word */
 13     7      (2 command bit (6),				/* device command */
 13     8       2 device bit (6),				/* device code */
 13     9       2 ext bit (6),				/* address extension */
 13    10       2 code bit (3),				/* should be "111"b for PCW */
 13    11       2 mask bit (1),				/* channel mask bit */
 13    12       2 control bit (2),				/* terminate/proceed and marker control bits */
 13    13       2 chan_cmd bit (6),				/* type of I/O operation */
 13    14       2 count bit (6),				/* record count or control character */
 13    15       2 mbz1 bit (3),
 13    16       2 channel bit (6),				/* channel number */
 13    17       2 mbz2 bit (27)) unal;
 13    18 
 13    19 dcl  idcwp ptr;					/* pointer to IDCW */
 13    20 
 13    21 dcl 1 idcw based (idcwp) aligned,			/* Instruction DCW */
 13    22      (2 command bit (6),				/* device command */
 13    23       2 device bit (6),				/* device code */
 13    24       2 ext bit (6),				/* address extension */
 13    25       2 code bit (3),				/* should be "111"b for PCW */
 13    26       2 ext_ctl bit (1),				/* "1"b if address extension to be used */
 13    27       2 control bit (2),				/* terminate/proceed and marker control bits */
 13    28       2 chan_cmd bit (6),				/* type of I/O operation */
 13    29       2 count bit (6)) unal;				/* record count or control character */
 13    30 
 13    31 /* End include file ...... iom_pcw.incl.pl1 */
 13    32 
 11    90 




 11    91 
 14     1 
 14     2 /* Begin include file ...... ioi_stat.incl.pl1 */
 14     3 /* Last modified 3/24/75 by Noel I. Morris */
 14     4 
 14     5 dcl  isp ptr;					/* pointer to status structure */
 14     6 
 14     7 dcl 1 istat based (isp) aligned,			/* I/O Interfacer status structure */
 14     8     2 completion,					/* completion flags */
 14     9      (3 st bit (1),					/* "1"b if status returned */
 14    10       3 er bit (1),					/* "1"b if status indicates error condition */
 14    11       3 run bit (1),				/* "1"b if channel still running */
 14    12       3 time_out bit (1)) unal,			/* "1"b if time-out occurred */
 14    13     2 level fixed bin (3),				/* IOM interrupt level */
 14    14     2 offset fixed bin (18),				/* DCW list offset */
 14    15     2 absaddr fixed bin (24),				/* absolute address of workspace */
 14    16     2 iom_stat bit (72),				/* IOM status */
 14    17     2 lpw bit (72);					/* LPW residue */
 14    18 
 14    19 dcl  imp ptr;					/* pointer to message structure */
 14    20 
 14    21 dcl 1 imess based (imp) aligned,			/* I/O Interfacer event message structure */
 14    22    (2 completion like istat.completion,			/* completion flags */
 14    23     2 pad bit (11),
 14    24     2 level bit (3),				/* interrupt level */
 14    25     2 offset bit (18),				/* DCW list offset */
 14    26     2 status bit (36)) unal;				/* first 36 bits of status */
 14    27 
 14    28 /* End of include file ...... ioi_stat.incl.pl1 */
 14    29 
 11    92 




 11    93 
 11    94 /* Constants used for data_header.definer */
 11    95 
 11    96 dcl  DATA_FROM_HOST
 11    97 	fixed bin (9) unsigned init (0) static options (constant);
 11    98 dcl  WRITE_CONSOLE
 11    99 	fixed bin (9) unsigned init (1) static options (constant);
 11   100 dcl  WRITE_READ_CONSOLE
 11   101 	fixed bin (9) unsigned init (2) static options (constant);
 11   102 dcl  DATA_FROM_MCA
 11   103 	fixed bin (9) unsigned init (3) static options (constant);
 11   104 dcl  REQ_DATA_FROM_HOST
 11   105 	fixed bin (9) unsigned init (4) static options (constant);
 11   106 dcl  STATUS_FROM_MCA
 11   107 	fixed bin (9) unsigned init (5) static options (constant);
 11   108 dcl  SEEK
 11   109 	fixed bin (9) unsigned init (6) static options (constant);
 11   110 dcl  CON_DATA_FROM_HOST
 11   111 	fixed bin (9) unsigned init (7) static options (constant);
 11   112 dcl  BIN_DATA_FROM_HOST
 11   113 	fixed bin (9) unsigned init (8) static options (constant);
 11   114 dcl  ABORT_SES_FROM_HOST
 11   115 	fixed bin (9) unsigned init (9) static options (constant);
 11   116 
 11   117 
 11   118 /* End mca_data_area.incl.pl1 */
 11   119 
     4062 
     4063 
 15     1 
 15     2 /* BEGIN INCLUDE FILE opr_query_info.incl.pl1 */
 15     3 
 15     4 /* created 10/20/78 by J. A. Bush. 
 15     5*   Modified by Rick Fakoury to increase size of the allowable answer.
 15     6**/
 15     7 
 15     8 dcl 1 opr_query_info aligned,				/* info structure for the opr_query_ subroutine */
 15     9     2 version fixed bin,				/* version of this structure, currently = to 1 */
 15    10     2 q_sw bit (1) aligned,				/* = "1"b if aswer is expected from operator */
 15    11     2 prim char (8),				/* primary expected operators response */
 15    12     2 alt char (8),					/* alternate expected operator response */
 15    13     2 answer char (80) varying,				/* operators answer */
 15    14     2 r_comment char (64),				/* comment to be output with respond message */
 15    15     2 err_code fixed bin (35);			/* standard system status code */
 15    16 
 15    17 /* END INCLUDE FILE opr_query_info.incl.pl1 */
 15    18 
     4064 
     4065 
 16     1 /*	Begin  include file rcp_disk_info.incl.pl1
 16     2**
 16     3**	Created on 03/31/74 by Bill Silver.
 16     4**	This include file defines the RCP device info structure for disks.
 16     5**/
 16     6 
 16     7 
 16     8 
 16     9 
 16    10 /****^  HISTORY COMMENTS:
 16    11*  1) change(86-06-03,Hartogs), approve(86-06-03,MCR7383),
 16    12*     audit(86-06-06,GWMay), install(86-07-18,MR12.0-1098):
 16    13*     Added DISK_INFO_VERSION_1 constant.
 16    14*                                                   END HISTORY COMMENTS */
 16    15 
 16    16 
 16    17 dcl	disk_info_ptr	ptr;		/* Pointer to disk device info structure. */
 16    18 
 16    19 dcl    1	disk_info based(disk_info_ptr) aligned,	/* RCP device info structure for disks. */
 16    20 	2  version_num	fixed bin,	/* Version number of this structure. */
 16    21 	2  usage_time	fixed bin,	/* Number of minutes drive will/may be used. */
 16    22 	2  wait_time	fixed bin,	/* Number of minutes user will/must wait. */
 16    23 	2  system_flag	bit(1),		/* ON => user wants to be a system process. */
 16    24 	2  device_name	char(8),		/* Disk drive name. */
 16    25 	2  model		fixed bin,	/* Disk drive model number. */
 16    26 	2  volume_name	char(32),		/* Disk pack name. */
 16    27 	2  write_flag	bit(1);		/* ON => writing on disk pack. */
 16    28 
 16    29 dcl       DISK_INFO_VERSION_1 fixed bin int static options (constant) init (1);
 16    30 
 16    31 /*	End of include file ... rcp_disk_info.incl.pl1	*/
     4066 
     4067 
 17     1 /*	Begin include file ... rcp_resource_types.incl.pl1
 17     2*   *
 17     3*   *	Created 3/79 by Michael R. Jordan for MR7.0R
 17     4*   *
 17     5*   *	This include file defines the official RCP resource types.
 17     6*   *	The array of names is indexed by the corresponding device type.
 17     7*   *      MOD by RAF for MCA
 17     8**/
 17     9 
 17    10 
 17    11 
 17    12 /****^  HISTORY COMMENTS:
 17    13*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
 17    14*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
 17    15*     Support of MCA.
 17    16*                                                   END HISTORY COMMENTS */
 17    17 
 17    18 dcl  DEVICE_TYPE (8) char (32)
 17    19 	internal static options (constant)
 17    20 	init ("tape_drive", "disk_drive", "console", "printer", "punch", "reader", "special", "mca");
 17    21 
 17    22 dcl  NUM_QUALIFIERS (8) fixed bin			/* Number of qualifiers for each device type. */
 17    23 	internal static init (3, 0, 0, 2, 0, 0, 0, 0);
 17    24 
 17    25 dcl  VOLUME_TYPE (8) char (32)
 17    26 	internal static options (constant)
 17    27 	init ("tape_vol", "disk_vol", "", "", "", "", "", "");
 17    28 
 17    29 dcl  TAPE_DRIVE_DTYPEX fixed bin static internal options (constant) init (1);
 17    30 dcl  DISK_DRIVE_DTYPEX fixed bin static internal options (constant) init (2);
 17    31 dcl  CONSOLE_DTYPEX fixed bin static internal options (constant) init (3);
 17    32 dcl  PRINTER_DTYPEX fixed bin static internal options (constant) init (4);
 17    33 dcl  PUNCH_DTYPEX fixed bin static internal options (constant) init (5);
 17    34 dcl  READER_DTYPEX fixed bin static internal options (constant) init (6);
 17    35 dcl  SPECIAL_DTYPEX fixed bin static internal options (constant) init (7);
 17    36 dcl  MCA_DTYPEX fixed bin static internal options (constant) init (8);
 17    37 dcl  TAPE_VOL_VTYPEX fixed bin static internal options (constant) init (1);
 17    38 dcl  DISK_VOL_VTYPEX fixed bin static internal options (constant) init (2);
 17    39 
 17    40 
 17    41 /*	End include file ... rcp_resource_types.incl.pl1 */
     4068 
     4069 
 18     1 /*	Begin  include file rcp_tape_info.incl.pl1
 18     2*   *
 18     3*   *	Created on 12/16/74 by Bill Silver.
 18     4*   *	Modified on 11/17/78 by Michael R. Jordan to add speed qualifier.
 18     5*   *	Modified on 09/30/82 by J. A. Bush for version 3 structure info
 18     6*   *	This include file defines the RCP device info structure for tapes.
 18     7**/
 18     8 /* format: style4 */
 18     9 
 18    10 dcl  tape_info_ptr ptr;				/* Pointer to tape device info structure. */
 18    11 
 18    12 dcl  tape_info_version_2 fixed bin internal static options (constant) init (2);
 18    13 dcl  tape_info_version_3 fixed bin internal static options (constant) init (3);
 18    14 
 18    15 dcl  1 tape_info based (tape_info_ptr) aligned,		/* RCP device info structure for tapes. */
 18    16        2 version_num fixed bin,			/* Version number of this structure. */
 18    17        2 usage_time fixed bin,			/* Number of minutes drive will/may be used. */
 18    18        2 wait_time fixed bin,				/* Number of minutes user will/must wait. */
 18    19        2 system_flag bit (1),				/* ON => user wants to be a system process. */
 18    20        2 device_name char (8),			/* Tape drive name. */
 18    21        2 model fixed bin,				/* Tape drive model number. */
 18    22        2 tracks fixed bin,				/* Track type, 7 or 9. */
 18    23        2 density bit (36),				/* Density capability: 200, 556, 800, 1600, 6250. */
 18    24        2 speed bit (36),				/* Speed: 75, 125, 200. */
 18    25        2 unused_qualifier bit (36),			/* Unused qualifier (must be "0"b). */
 18    26        2 volume_name char (32),			/* Tape reel name. */
 18    27        2 write_flag bit (1),				/* ON => writing on tape reel. */
 18    28        2 position_index fixed bin (35),			/* Counter used to determine tape reel position. */
 18    29 
 18    30 /* Limit of version 2 structure, info below returned if version 3 or greater */
 18    31 
 18    32        2 volume_type fixed bin,			/* Use rcp_volume_formats.incl.pl1 for decodes */
 18    33        2 volume_density fixed bin,			/* 1 - 5 = 200, 556, 800, 1600, or 6250 BPI */
 18    34        2 opr_auth bit (1);				/* "1"b => Operator Authentication was required */
 18    35 
 18    36 /*	End of include file ... rcp_tape_info.incl.pl1	*/
     4070 
     4071 
 19     1 
 19     2 /* BEGIN INCLUDE FILE tolts_err_codes.incl.pl1 */
 19     3 
 19     4 dcl (iv_iom init (0),				/* invalid IOM number */
 19     5      ch_not_ass init (1),				/* channel not assignable */
 19     6      iv_dev init (2),				/* invalid device number */
 19     7      mlt_act init (3),				/* Molts active on this mpc (gcos only) */
 19     8      ptrain init (4),				/* enter "ptrain" verb and retry (gcos only) */
 19     9      uns_rdr init (5),				/* can't unspec reader (gcos only) */
 19    10      os_deny init (6),				/* Operating system denies test request */
 19    11      rem_sp_pri init (7),				/* can't test removable spindle */
 19    12      rem_sp_sec init (8),				/* can't test removable spindle on alt dev */
 19    13      not_psia init (9),				/* not a PSIA channel */
 19    14      not_boot_psia init (10),				/* not a bootable psia channel */
 19    15      not_log_0 init (11),				/* not logical channel 0 of mpc */
 19    16      not_sec_mpc init (12),				/* not a secondary mpc */
 19    17      plt_act init (13),				/* polts active on mpc (gcos only) */
 19    18      gc_files init (14),				/* gcos files on mpc (gcos only) */
 19    19      no_sv_file init (15),				/* no file space for sv file (gcos only) */
 19    20      no_pat init (16),				/* no pat space for sv file (gcos only) */
 19    21      mem_test init (17),				/* memory already in test */
 19    22      mem_not_rel init (18),				/* memory not released */
 19    23      split_rlsec init (19),				/* can't split rlsec table (gcos only) */
 19    24      no_s2_test init (20),				/* can't test the S2 (gcos only) */
 19    25      dev_busy init (21),				/* device busy */
 19    26      alt_dev_busy init (22),				/* alternate device busy */
 19    27      inv_tt init (23),				/* invalid test type */
 19    28      m_iv_iom init (24)				/* Multics invalid IOM number */
 19    29      ) fixed bin (18) unsigned int static options (constant);
 19    30 
 19    31 /* END INCLUDE FILE tolts_err_codes.incl.pl1 */
 19    32 
     4072 
     4073 
 20     1 /*  BEGIN INCLUDE FILE:  tolts_fpinfo.incl.pl1
 20     2*
 20     3*/*  tolts_fpinfo.incl.pl1 describes a data base that resides in the responder
 20     4*    test page and is used for communication between tolts and the test page.*/
 20     5 
 20     6 
 20     7 /****^  HISTORY COMMENTS:
 20     8*  1) change(85-12-21,Fakoury), approve(86-08-21,MCR7514),
 20     9*     audit(86-12-03,Martinson), install(86-12-04,MR12.0-1235):
 20    10*     Created by Rick Fakoury for support of the Colts rspd request.
 20    11*                                                   END HISTORY COMMENTS */
 20    12 
 20    13 dcl  tolts_fpinfo_ptr ptr;
 20    14 						
 20    15 dcl  1 tolts_fpinfo aligned based (tolts_fpinfo_ptr),	/* front-end processor (DN8) info seg */
 20    16        2 pcw_info aligned,				/* pcw format */
 20    17          3 fnp_num fixed bin unaligned,
 20    18          3 pad bit (6) unaligned,
 20    19          3 chan bit (6) unaligned,
 20    20          3 cmnd bit (6) unaligned,
 20    21        2 fnpdcw aligned,				/* fnp dcw format */
 20    22          3 address fixed bin unaligned,
 20    23          3 word_count fixed bin unaligned,
 20    24        2 io_rq_cnt fixed bin (35) aligned,		/* count of io requests */
 20    25        2 mbxloc fixed bin (35) aligned,			/* mbx address - Multics = 0 */
 20    26        2 spec_cnt fixed bin (35) aligned,		/* special int count */
 20    27        2 term_cnt fixed bin (35) aligned,		/* terminate int count */
 20    28        2 partrs fixed bin (35) aligned,			/* fep atteched = -1 */
 20    29        2 timeout_time bit (36) aligned,			/* timeout time for DN8 */
 20    30        2 temp01 aligned,
 20    31          3 word1,
 20    32 	 4 upper bit (18) unaligned,
 20    33 	 4 lower bit (18) unaligned,
 20    34          3 word2,
 20    35 	 4 upper bit (18) unaligned,
 20    36 	 4 lower bit (18) unaligned,
 20    37        2 temp02,
 20    38          3 word1,
 20    39 	 4 upper bit (18) unaligned,
 20    40 	 4 lower bit (18) unaligned,
 20    41          3 word2,
 20    42 	 4 upper bit (18) unaligned,
 20    43 	 4 lower bit (18) unaligned,
 20    44        2 temp03,
 20    45          3 word1,
 20    46 	 4 upper bit (18) unaligned,
 20    47 	 4 lower bit (18) unaligned,
 20    48          3 word2,
 20    49 	 4 upper bit (18) unaligned,
 20    50 	 4 lower bit (18) unaligned,
 20    51        2 lvl3_flag bit (36) aligned,			/* terminate int expected */
 20    52        2 lvl7_flag bit (36) aligned,			/* special int expected */
 20    53        2 lvl3_cnt fixed bin (35) aligned,		/* terminate int received */
 20    54        2 lvl7_cnt fixed bin (35) aligned,		/* special int received */
 20    55        2 pprt_avail bit (35) aligned;			/* page print available - Multics = 0 */
 20    56 
 20    57 
 20    58 
 20    59 /* END INCLUDE FILE tolts_fpinfo.incl.pl1 */
     4074 
     4075 
 21     1 /*        BEGIN INCLUDE FILE tolts_info.incl.pl1     */
 21     2 
 21     3    
 21     4 
 21     5 
 21     6 
 21     7 
 21     8 
 21     9 /****^  HISTORY COMMENTS:
 21    10*  1) change(80-03-24,Fakoury), approve(), audit(86-11-25,Martinson),
 21    11*     install(86-12-04,MR12.0-1235):
 21    12*     to add second sct for 500/501 MTAR
 21    13*  2) change(80-09-01,Fakoury), approve(), audit(86-11-25,Martinson),
 21    14*     install(86-12-04,MR12.0-1235):
 21    15*     to init rcp_area and alt_rcp_area to 0.
 21    16*  3) change(81-09-01,Fakoury), approve(), audit(86-11-25,Martinson),
 21    17*     install(86-12-04,MR12.0-1235):
 21    18*     to add new statements for colts.
 21    19*  4) change(81-09-01,Fakoury), approve(), audit(86-11-25,Martinson),
 21    20*     install(86-12-04,MR12.0-1235):
 21    21*     to increase the dcw_list size.
 21    22*  5) change(82-04-01,Fakoury), approve(), audit(86-11-25,Martinson),
 21    23*     install(86-12-04,MR12.0-1235):
 21    24*     to add crcst and redefine devsct.
 21    25*  6) change(82-09-01,Fakoury), approve(), audit(86-11-25,Martinson),
 21    26*     install(86-12-04,MR12.0-1235):
 21    27*     to increase the console buffer size for mtar.
 21    28*  7) change(82-11-01,Fakoury), approve(), audit(86-11-25,Martinson),
 21    29*     install(86-12-04,MR12.0-1235):
 21    30*     for 128chan support.
 21    31*  8) change(83-07-01,Fakoury), approve(), audit(86-11-25,Martinson),
 21    32*     install(86-12-04,MR12.0-1235):
 21    33*     to increase the dcw_list size for mtar perm file track repair.
 21    34*  9) change(84-04-10,Fakoury), approve(86-08-21,MCR7514),
 21    35*     audit(86-11-25,Martinson), install(86-12-04,MR12.0-1235):
 21    36*     to add sct_info needed to support the DAU & DIPPER.
 21    37* 10) change(85-02-21,Fakoury), approve(86-08-21,MCR7514),
 21    38*     audit(86-11-25,Martinson), install(86-12-04,MR12.0-1235):
 21    39*      2/85 to support test nio request.
 21    40* 11) change(85-04-01,Fakoury), approve(86-08-21,MCR7514),
 21    41*     audit(86-11-25,Martinson), install(86-12-04,MR12.0-1235):
 21    42*     for extended status store.
 21    43* 12) change(85-12-21,Fakoury), approve(86-08-21,MCR7514),
 21    44*     audit(86-11-25,Martinson), install(86-12-04,MR12.0-1235):
 21    45*     for Colts Responder changes.
 21    46* 13) change(86-02-01,Fakoury), approve(86-08-20,MCR7514),
 21    47*     audit(86-11-25,Martinson), install(86-12-04,MR12.0-1235):
 21    48*      implement the test nio request.
 21    49*      support of a Colts responder test request.
 21    50*                                                   END HISTORY COMMENTS */
 21    51 
 21    52 
 21    53 
 21    54 
 21    55 
 21    56 
 21    57 /* format: style4,ifthenstmt,ifthen,ind3,ll125,lineconind1 */
 21    58 
 21    59 dcl  polt_io_type fixed bin int static options (constant) init (0);
 21    60 dcl  itr_io_type fixed bin int static options (constant) init (1);
 21    61 dcl  mdr_io_type fixed bin int static options (constant) init (2);
 21    62 dcl  mtar_io_type fixed bin int static options (constant) init (3);
 21    63 dcl  firm_ld_io_type fixed bin int static options (constant) init (4);
 21    64 dcl  mtc_io_type fixed bin int static options (constant) init (5);
 21    65 dcl  mtg_io_type fixed bin int static options (constant) init (6);
 21    66 dcl  mdc_io_type fixed bin int static options (constant) init (7);
 21    67 dcl  mhp_io_type fixed bin int static options (constant) init (8);
 21    68 dcl  mca_io_type fixed bin int static options (constant) init (9);
 21    69 dcl  rspd_io_type fixed bin int static options (constant) init (10);
 21    70 
 21    71 dcl  tolts_infop ptr external static;			/* ext static ptr to tolts_info structure */
 21    72 dcl  colts_info_ptr ptr;				/* ptr to individual test page data */
 21    73 dcl  io_info_ptr ptr;				/* ptr to individual test page data */
 21    74 dcl  dmap ptr;					/* pointer to dial_manager_arg */
 21    75 dcl  1 tolts_info based (tolts_infop) aligned,		/* data structure used for tolts routines */
 21    76        2 cdtptr ptr,
 21    77        2 df_iocbp ptr,				/* deckfile iocb ptr */
 21    78        2 dm_event fixed bin (71),			/* dial_manager event_channel */
 21    79        2 exec char (4),				/* executive name (polt, molt, colt etc) */
 21    80        2 exec_dta_cnt fixed bin,			/* inter slave request count */
 21    81        2 exec_page_count fixed bin,			/* number of test pages active */
 21    82        2 exec_term_io_wait bit (1),			/* waiting for io to complete for exec termination */
 21    83        2 execp ptr,					/* ptr to slave polt or molt segment */
 21    84        2 file_attach bit (1),				/* = "1"b if print file attached */
 21    85        2 file_open bit (1),				/* = "1"b if print file open */
 21    86        2 finish_cond bit (1),				/* = "1"b if finish condition has been signaled */
 21    87        2 first_request_done bit (1),			/* first terminal io request complete */
 21    88        2 gc_date bit (36),				/* gcos 6 char bcd date (set at init time, updated at rollover) */
 21    89        2 gewake_active bit (1),			/* = "1"b if gewake alarm timer is active */
 21    90        2 gewake_event fixed bin (71),			/* gewake alarm timer event channel id */
 21    91        2 glob_int_cnt fixed bin,			/*  total number of outstanding test IOs */
 21    92        2 hdir char (168),				/* users home directory pathname */
 21    93        2 init_time fixed bin (71),			/* gcos time of executive initialize (mme poinit) */
 21    94        2 max_to fixed bin (71),			/* max ioi timeout ( from rcp_$check_attach) */
 21    95        2 max_wks_sz fixed bin (19),			/* max ioi wkspace size (from rcp_$check_attach) */
 21    96        2 micro_time fixed bin (71),			/* time at midnight in usecs. (set at init time, updated at rollover */
 21    97        2 optflag fixed bin,				/* option request flag */
 21    98        2 padx (2) fixed bin,				/* reserved area */
 21    99        2 pf_iocbp ptr,				/* print file iocb ptr */
 21   100        2 pf_name char (32),				/* seg name of print file */
 21   101        2 process bit (36),				/* T & D users process id */
 21   102        2 quith_event fixed bin (71),			/* quit handler event call channel id */
 21   103        2 special_fault bit (1),			/* error on reconnect after special int */
 21   104        2 term_io_in_prog bit (1),			/* terminal io in progress */
 21   105        2 term_io_req_cnt fixed bin,			/* outstanding terminal io requests */
 21   106        2 tty_ccc_event fixed bin (71),			/* term io courtesy call event call channel id */
 21   107        2 tty_display_event fixed bin (71),		/* term io display event channel id */
 21   108        2 tty_issue_event fixed bin (71),		/* term io issue event call channel id */
 21   109        2 wks_sz fixed bin,				/* workspace size in words (4096 for polts, 6144 for molts) */
 21   110        2 exec_dta (16),				/* inter slave request queue */
 21   111          3 word (4) bit (36),				/* inter slave data */
 21   112        2 ccc_queue,					/* courtesy call queue */
 21   113          3 ccc_requests fixed bin,			/* courtesy call requests */
 21   114          3 icivlu (16) bit (36),			/* ic and ind of courtesy call routine */
 21   115        2 isc_queue,					/* interslave communication queue */
 21   116          3 icivlu bit (36),				/* ic and i of queue entry */
 21   117          3 status_add fixed bin,			/*  :: */
 21   118          3 data_add fixed bin,			/* :: */
 21   119 
 21   120        2 tadio (8),					/* T & D user io rqt queue */
 21   121          3 optrd bit (1),				/* = "1"b if options are to be read */
 21   122          3 inuse bit (1),				/* = "1"b if queue entry in use */
 21   123          3 return_word (3) bit (36),			/* data returned from mme tadiod */
 21   124          3 option bit (6 * 84),			/* bcd option string */
 21   125        2 wait_list,					/* wait list for dispatcher block */
 21   126          3 nchan fixed bin,				/* number of event wait channels  */
 21   127          3 wait_pad fixed bin,			/* will make wait_event_id on even boundary */
 21   128          3 wait_event_id (2) fixed bin (71),		/* dispatcher event wait chan id */
 21   129        2 clt_sw char (32),
 21   130        2 att_desc char (32),
 21   131        2 cdt_pointer ptr,				/* save pointer to cdt */
 21   132        2 fnp_exec_cnt fixed bin init (0),
 21   133        2 fnp (0:7),
 21   134          3 exec_active bit (1) init ("0"b),
 21   135          3 exec_chan char (32),
 21   136          3 status_word bit (36) init ("0"b),
 21   137          3 fnp_execp ptr,
 21   138          3 type fixed bin,
 21   139          3 exec_type_code bit (6) init ("0"b),
 21   140          3 cdt_name (8) char (32) init ("empty"),		/* cdt name built from test request */
 21   141          3 dm_arg like dial_manager_arg,
 21   142        2 mess_buf,					/* terminal io message buffers */
 21   143          3 first ptr,				/* ptr to start of message buffer */
 21   144          3 nxt ptr,					/* ptr to nxt queue entry */
 21   145          3 term_queue (8192) fixed bin,			/* message queu as fixed bin */
 21   146          3 q_end bit (0),				/* to find end of queue */
 21   147          3 q_pad (1024) fixed bin,			/* padding area */
 21   148          3 mult_ans char (28) varying,			/* answer to local Multics question */
 21   149          3 cv_buf char (4000) varying,			/* temporary conversion storage */
 21   150        2 colts_pages (8) like colts_info,
 21   151        2 pages (8) like io_info,			/* test pages (8 posible) */
 21   152        2 firm_buf (10240) fixed bin;			/* storage for loading firmware */
 21   153 
 21   154 
 21   155 dcl  1 io_info based (io_info_ptr) aligned,		/* this maps test pages in tolts_info */
 21   156        2 alloc_wait bit (1),				/* = "1"b if waiting  for delayed allocation */
 21   157        2 allocated bit (1),				/* = "1"b if device allocated to this page */
 21   158        2 alt_dev_flag bit (1),			/* = "1"b if 2nd logical device configured (MTAR 500/501 only */
 21   159        2 alt_device_index fixed bin (12),		/* ioi device index */
 21   160        2 alt_device_name char (8),			/* alternate allocated device name */
 21   161        2 alt_rcp_area (24) fixed bin init (0),		/* alternate device rcp */
 21   162        2 alt_rcp_id bit (36) aligned,			/* rcp id for alternate attach/check_attach */
 21   163        2 attach_err fixed bin (35),			/* error code returned durning attach */
 21   164        2 cata_cycle bit (1),				/* cycle check for cata */
 21   165        2 cat_name char (10),				/* itr or mdr catalog suffix */
 21   166        2 n_keys fixed bin aligned,			/* number of catalog keys below */
 21   167        2 cata_keys (10) char (24) aligned,		/* array of catalog keys */
 21   168        2 catp ptr,					/* ptr to itr or mdr catalog in deckfile */
 21   169        2 catx fixed bin,				/* current cata_info.index */
 21   170        2 ccu_pun bit (1),				/* = "1"b if ccu to be used as punch */
 21   171        2 chan_suspended bit (1),			/* = "1"b if channel has been suspended */
 21   172        2 chan_time fixed bin (35),			/* channel time (in 1/64th miliseconds) */
 21   173        2 con_time fixed bin (35),			/* abs time of connect (in 1/64 th miliseconds) */
 21   174        2 cur_wks_sz fixed bin,			/* current size of ioi workspace (normally tolts_info.wks_sz) */
 21   175        2 dcw_list (330) bit (36),			/* test page dcw list in unaltered form */
 21   176        2 dev_busy bit (1),				/* = "1"b  if device busy before */
 21   177        2 device_index fixed bin (12),			/* ioi device index */
 21   178        2 device_name char (8),			/* allocated device name (in ascii) */
 21   179        2 ev_ch_ass bit (1),				/* = "1"b if status event chan assigned to this page */
 21   180        2 ext_status_add fixed bin,			/* extended status store address */
 21   181        2 fnp_num fixed bin,
 21   182        2 fpinfo_ptr ptr,				/* ptr to rspd info table */
 21   183        2 ignore_term bit (1),				/* = "1"b if term int to be ignored, wait for special (ITR) */
 21   184        2 in_use bit (1),				/* = "1"b if this test page in use */
 21   185        2 int_time fixed bin (35),			/* abs time of interrupt (in 1/64 th miliseconds) */
 21   186        2 io_in_progress bit (1),			/* = "1"b if io in progress for this page */
 21   187        2 io_trc_flag bit (1),				/* = "1"b if io is being traced */
 21   188        2 io_type fixed bin,				/* 0 = polt, 1 = ITR, 2 = MDR, 3 = MTAR, 4 = firmware load */
 21   189        2 iocp ptr,
 21   190        2 ipc_attached bit (1),
 21   191        2 ipc_id char (3),
 21   192        2 ipc_number fixed bin,
 21   193        2 lostit_time fixed bin (35),			/* lost interrupt time in 1/64 th miliseconds */
 21   194        2 mca_attach_state fixed bin,
 21   195        2 mcata_idx fixed bin,				/* mca catalog indexer */
 21   196        2 mcata_nkeys fixed bin aligned,			/* no of keys in a mca catalog */
 21   197        2 mcata_keys (100) char (24) aligned,		/* mca catalog entries */
 21   198        2 mca_ioi_idx fixed bin,			/* ioi index of attached mca /
 21   199*       2 mca_iop ptr,				/* mca io ptr */
 21   200        2 mca_workspace_ptr ptr,
 21   201        2 mpc_dev_cnt fixed bin,			/* if urmpc to be booted, # of devices */
 21   202        2 nff bit (1),				/* = "1"b new format flag */
 21   203        2 num_connects fixed bin,			/* number of connects issued by this page */
 21   204        2 p2_att bit (1),				/* ="1"b if alternate device is attached (MTAR 500/501 only) */
 21   205        2 p_att bit (1),				/* = "1"b if perp. device attached to this page */
 21   206        2 page_base fixed bin (18) uns,			/* base of this test page in slave seg */
 21   207        2 pcwa bit (36),				/* pcw */
 21   208        2 rcp_area (24) fixed bin init (0),		/* storage for rcp device info */
 21   209        2 rcp_id bit (36) aligned,			/* rcp id for attach/check_attach */
 21   210        2 rcp_name char (32),				/* rcp name for this device */
 21   211        2 rcp_state fixed bin,				/* rcp attach state flag */
 21   212        2 release_chan bit (1),			/* = "1"b if ioi_$release devices to be called */
 21   213        2 rew_wait bit (1),				/* = "1"b if waiting for special on rewind complete */
 21   214        2 sp_flag bit (1),				/* = "1"b if special status available */
 21   215        2 sp_status bit (36),				/* special interrupt status storage */
 21   216        2 spare1 bit (1),
 21   217        2 status_add fixed bin,			/* address to store status in test page */
 21   218        2 status_event fixed bin (71),			/* io completion status event call channel id */
 21   219        2 suspend_chan bit (1),			/* = "1"b if ioi_$suspend devices to be called */
 21   220        2 tolts_rspd_wksp ptr,
 21   221        2 test_hdr char (16),				/* test header used for Multics local messages */
 21   222        2 tio_off fixed bin (18),			/* dcw list offset for ioi */
 21   223        2 to_no_cc bit (1),				/* = "1"b if timeout expected (set after mme ipcw) */
 21   224        2 workspace_ptr ptr,				/* ioi workspace ptr */
 21   225        2 altsct,					/* sct for MTAR alternate device */
 21   226 	 (3 w1,					/* device sct word 1 */
 21   227 	 4 type_code bit (6),			/* gcos 3 type code (see dd14 app. a) */
 21   228 	 4 device_no bit (6),			/* device number */
 21   229 	 4 com_prph bit (1),			/* = "1"b if common perph. device */
 21   230 	 4 hi_speed bit (1),			/* = "1"b if hi speed printer */
 21   231 	 4 ll160 bit (1),				/* = "1"b if 160 collum printer */
 21   232 	 4 pad1 bit (2),
 21   233 	 4 cr501_pr54 bit (1),			/* either a cr501 or pr54 device */
 21   234 	 4 icc bit (11),				/* iom and channel (true channel index) */
 21   235 	 4 pad2 bit (7),
 21   236          3 w2,					/* device sct word 2 */
 21   237 	 4 ptrain fixed bin (14),			/* print train number */
 21   238 	 4 nmods bit (3),				/* not used in Multics */
 21   239 	 4 pad4 bit (3),
 21   240 	 4 den_cap bit (4),				/* density capability for tapes */
 21   241 	 4 pad5 bit (11)) unaligned,
 21   242        2 crcst,					/* controller sct */
 21   243          (3 pad1 bit (1),
 21   244          3 volatile bit (1),				/* reloadable firmware */
 21   245          3 mpc bit (1),				/* = "1"b if mpc */
 21   246          3 pad2 bit (4),
 21   247          3 ms500 bit (1),				/* = "1"b if mss500 device */
 21   248          3 mtp610 bit (1),				/* = "1"b if mtp 610 device */
 21   249          3 pad3 bit (27)) unaligned,
 21   250        2 dev_firm (4),				/* storage for device firmware edit names */
 21   251          3 edit_name char (4),			/* for urmpc firmware */
 21   252          3 mask bit (36),				/* port mask for this firmware */
 21   253        2 devsct,					/* 2 word device sct entry */
 21   254 	 (3 w1,					/* device sct word 1 */
 21   255 	 4 type_code bit (6),			/* gcos 3 type code (see dd14 app. a) */
 21   256 	 4 device_no bit (6),			/* device number */
 21   257 	 4 com_prph bit (1),			/* = "1"b if common perph. device */
 21   258 	 4 hi_speed bit (1),			/* = "1"b if hi speed printer */
 21   259 	 4 ll160 bit (1),				/* = "1"b if 160 collum printer */
 21   260 	 4 pad1 bit (2),
 21   261 	 4 cr501_pr54 bit (1),			/* either a cr501 or pr54 device */
 21   262 	 4 icc bit (11),				/* iom and channel (true channel index) */
 21   263 	 4 pad2 bit (7),
 21   264          3 w2,					/* device sct word 2 */
 21   265 	 4 ptrain fixed bin (14),			/* print train number */
 21   266 	 4 nmods bit (3),				/* not used in Multics */
 21   267 	 4 pad4 bit (3),
 21   268 	 4 den_cap bit (4),				/* density capability for tapes */
 21   269 	 4 pad5 bit (11)) unaligned,
 21   270        2 icivlu,					/* ic and i for courtesy call on io completion */
 21   271          3 ic bit (18) unaligned,			/* instruction counter */
 21   272          3 ind bit (18) unaligned,			/* indicator register */
 21   273        2 sct_info,
 21   274          (3 cntsct bit (18),				/* unchanged from before */
 21   275          3 ioc_type bit (4),				/* 0 = IOM, 1 = IMU, 2 = IOX */
 21   276          3 cnt_type bit (4),				/* 0 = MPC, 1 = DAU, 2 = EURC, 3 = FIPS */
 21   277          3 pad1 bit (1),
 21   278          3 xioc_type bit (4),				/* not used in Multics */
 21   279          3 xcnt_type bit (4),				/* not used in Multics */
 21   280          3 pad2 bit (1)) unaligned,
 21   281        2 test_req aligned,
 21   282          (3 fnccss bit (18),
 21   283          3 tt bit (6),
 21   284          3 pad1 bit (6)) unaligned;
 21   285 
 21   286 
 21   287 dcl  1 colts_info aligned based (colts_info_ptr),
 21   288        2 cdt_name char (32),
 21   289        2 chanp pointer,				/* iox pointer to chan under test */
 21   290        2 dm_arg aligned like dial_manager_arg,
 21   291        2 fnp_num fixed bin (4),
 21   292        2 in_use bit (1) unaligned init ("0"b),
 21   293        2 status_word bit (36) aligned init ("0"b),
 21   294        2 type_code bit (6) unaligned init ("0"b);
 21   295 
 21   296 
 21   297 
 21   298 
 22     1 /* BEGIN INCLUDE FILE ... dial_manager_arg.incl.pl1 */
 22     2 
 22     3 /* Modified by E. N. Kittlitz 11/80 to add reservation string, move dial-out
 22     4*   destination from dial_qualifier, add dial_message.
 22     5*   Modified by Robert Coren 4/83 to add required access class stuff.
 22     6*   Modified 1984-08-27 BIM for V4, privileged_operation.
 22     7**/
 22     8 
 22     9 
 22    10 dcl  dial_manager_arg_version_2 fixed bin internal static initial (2) options (constant);
 22    11 dcl  dial_manager_arg_version_3 fixed bin internal static initial (3) options (constant);
 22    12 dcl  dial_manager_arg_version_4 fixed bin internal static initial (4) options (constant);
 22    13 
 22    14 dcl 1 dial_manager_arg based aligned,
 22    15     2 version fixed bin,				/* = 4 */
 22    16     2 dial_qualifier char (22),			/* identify different processes with same process group id */
 22    17     2 dial_channel fixed bin (71),			/* event wait channel */
 22    18     2 channel_name char (32),				/* channel name for privileged attach */
 22    19 						/* limit of version 1 structure */
 22    20     2 dial_out_destination char (32),			/* dial-out destination (e.g. phone_no) */
 22    21     2 reservation_string char (256),			/* reservation string */
 22    22     2 dial_message fixed bin (71),			/* OUTPUT: A.S. message received by dial_manager_ */
 22    23 						/* limit of version 2 structure */
 22    24     2 access_class bit (72),				/* access class to be associated with the attachment */
 22    25     2 flags aligned,
 22    26      3 access_class_required bit (1) unaligned,		/* indicates whether to enforce access_class */
 22    27      3 privileged_operation bit (1) unaligned,		/* for accept_dials, accepts dials from */
 22    28 						/* system_low:access_class */
 22    29 						/* no effect on other operations yet. */
 22    30      3 mbz bit (34) unaligned;			/* must be zero */
 22    31 
 22    32 /* END INCLUDE FILE ... dial_manager_arg.incl.pl1 */
 21   299 
 21   300 
 21   301 
 21   302 
 21   303 
 21   304 /* END INCLUDE FILE tolts_info.incl.pl1  */
     4076 
     4077 
 23     1 /*  BEGIN INCLUDE FILE: tolts_rspd_workspace.incl.pl1  */
 23     2 
 23     3  
 23     4 
 23     5 /****^  HISTORY COMMENTS:
 23     6*  1) change(85-12-11,Fakoury), approve(86-08-21,MCR7514),
 23     7*     audit(86-12-03,Martinson), install(86-12-04,MR12.0-1235):
 23     8*     Created by Rick Fakoury to support the Colts rspd request.
 23     9*                                                   END HISTORY COMMENTS */
 23    10 
 23    11 /* tolts_rspd_workspace defines the wired workspace used for tolts responder io to the DN8.            */
 23    12 
 23    13 
 23    14 dcl tolts_rspd_wksp ptr;
 23    15 
 23    16 dcl  1 tolts_rspd_workspace aligned based (tolts_rspd_wksp),
 23    17        2  mailbox aligned,
 23    18           3  pcw aligned like direct_channel_pcw,
 23    19           3  num_int,
 23    20              4  lvl7 fixed bin (18) unsigned unaligned,
 23    21              4  lvl3 fixed bin (18) unsigned unaligned,
 23    22           3  status_word bit (36) aligned,
 23    23           3  pad1 bit (144) aligned,
 23    24       2  ima_level(0:7) like intercom_mbx_area,
 23    25       2  tcw like direct_channel_tcw,
 23    26       2  data_buf area (320);
 23    27  
 23    28 
 23    29 dcl 1  intercom_mbx_area aligned,
 23    30        2 word (0:7) bit (36);
 23    31  
 24     1 /*----------BEGIN ioi_direct_channel_dcls.incl.pl1---------------------------*/
 24     2 
 24     3 
 24     4 /****^  HISTORY COMMENTS:
 24     5*  1) change(86-07-30,Wong), approve(86-07-30,MCR7397), audit(86-08-01,Ex),
 24     6*     install(86-08-18,MR12.0-1131):
 24     7*     New include file
 24     8*                                                   END HISTORY COMMENTS */
 24     9 
 24    10 /*****************************************************************************/
 24    11 /*							       */
 24    12 /*   This include file declares the PCW (peripheral control word) and TCW    */
 24    13 /*   (transfer control word) used by direct channels.  This PCW should not   */
 24    14 /*   be confused with the PCW used in a connect to IOI.  These formats come  */
 24    15 /*   from "L66 FEP Coupler - EPS 1", #60132445, pp. 49 - 51.	       */
 24    16 /*							       */
 24    17 /*****************************************************************************/
 24    18 
 24    19 /* format: style3,linecom,ifthenstmt,indthenelse,^indnoniterdo,indnoniterend,initcol3,dclind5,idind32 */
 24    20 
 24    21 dcl  direct_channel_pcw_ptr	       ptr;
 24    22 
 24    23 dcl  1 direct_channel_pcw	       aligned based (direct_channel_pcw_ptr),
 24    24        2 tcw_address	       fixed bin (18) unsigned unaligned,
 24    25        2 error_flag		       bit (1) unaligned,
 24    26        2 mbz1		       bit (1) unaligned,
 24    27        2 logical_channel_number      fixed bin (2) unsigned unaligned,
 24    28        2 parity		       bit (1) unaligned,
 24    29        2 mbz2		       bit (1) unaligned,
 24    30        2 tcw_address_extension       fixed bin (6) unsigned unaligned,
 24    31        2 operation		       bit (6) unaligned;
 24    32 
 24    33 /*****************************************************************************/
 24    34 /*							       */
 24    35 /*   The memory address in the TCW is in frontend words.  If the address is  */
 24    36 /*   a small type, then the address * 2 is the frontend (byte) address.  If  */
 24    37 /*   the address is a big type, then the address * 2**9 is the frontend      */
 24    38 /*   (byte) address.					       */
 24    39 /*							       */
 24    40 /*****************************************************************************/
 24    41 
 24    42 dcl  direct_channel_tcw_ptr	       ptr;
 24    43 
 24    44 dcl  1 direct_channel_tcw	       aligned based (direct_channel_tcw_ptr),
 24    45        2 must_be_001b	       bit (3) unaligned,
 24    46        2 fep_memory_address	       fixed bin (15) unsigned unaligned,
 24    47        2 fep_address_type	       bit (1) unaligned,
 24    48        2 mbz		       bit (5) unaligned,
 24    49        2 host_word_count	       fixed bin (12) unsigned unaligned;
 24    50 
 24    51 dcl  FEP_SMALL_ADDRESS_TYPE	       bit (1) internal static options (constant) init ("0"b);
 24    52 dcl  FEP_BIG_ADDRESS_TYPE	       bit (1) internal static options (constant) init ("1"b);
 24    53 
 24    54 /*----------END ioi_direct_channel_dcls.incl.pl1-----------------------------*/
 23    32 
 23    33 
 23    34 
 23    35 /* END INCLUDE FILE tolts_rspd_workspace.incl.pl1 */
 23    36 
     4078 
     4079 
 25     1 
 25     2 
 25     3 /* BEGIN INCLUDE FILE tolts_workspace.incl.pl1 */
 25     4 
 25     5 /* created 10/6/78 by J. A. Bush to define the ioi workspace as used by TOLTS 
 25     6*   Modified b R. Fakoury 8106 & 8201 to increase dcw_list size for mtar linked io.
 25     7*  Modified by R. Fakoury 8206 to force the data buffer to an even location for eurc itr test 1.
 25     8*  Modified by R. Fakoury 7/83 to increase the dcw_list size for mtar perm file track repair.
 25     9**/
 25    10 
 25    11 dcl  ioi_wksp ptr;					/* ptr to workspace */
 25    12 
 25    13 dcl 1 tolts_workspace based (ioi_wksp) aligned,
 25    14     2 status,					/* ioi status structure */
 25    15       3 completion,					/* completion flags */
 25    16        (4 st bit (1),				/* "1"b if status returned */
 25    17         4 er bit (1),				/* "1"b if status indicates error */
 25    18         4 run bit (1),				/* "1"b if channel still running */
 25    19         4 timeout bit (1)) unaligned,			/* "1"b if io timeout */
 25    20       3 level fixed bin (3),				/* IOM interrupt level */
 25    21       3 offset fixed bin (18),			/* dcw list offset for connect */
 25    22       3 absaddr fixed bin (24),			/* absolute address of workspace */
 25    23       3 iom_status bit (72),				/* IOM status storage */
 25    24       3 lpw (2) bit (36),				/* LPW residue */
 25    25     2 buf_size fixed bin,				/* current length of data buffer */
 25    26     2 seek_add bit (36),				/* seek address for disk I/O */
 25    27     2 seek_idcw bit (36),				/* seek idcw for disk I/O */
 25    28     2 seek_dcw bit (36),				/* seek dcw for disk I/O */
 25    29     2 p_idcw bit (36),				/* primary idcw, secondary for disk I/O */
 25    30     2 dcw_list (330) bit (36),			/* test page dcw list */
 25    31     2 pad bit (36),					/* force the buffer to begin on an even address */
 25    32     2 l_pad,					/* pad area of lower buffer */
 25    33       3 e bit (36),
 25    34       3 o bit (36),
 25    35     2 data_buf (buf_size) fixed bin (35),		/* data buffer */
 25    36     2 h_pad,					/* pad area of upper buffer */
 25    37       3 e bit (36),
 25    38       3 o bit (36);
 25    39 
 25    40 dcl  wks_init char (165 * 4) based (ioi_wksp);		/* used to initialize control word area of ioiworkspace */
 25    41 
 25    42 /* END INCLUDE FILE tolts_workspace.incl.pl1 */
 25    43 
     4080 
     4081 
     4082 
     4083 
     4084 
     4085 
     4086    end mtdsim_;
     4087 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/19/88  1536.9  mtdsim_.pl1                       >special_ldd>install>MR12.2-1061>mtdsim_.pl1
4046         1    09/09/75  2007.3  author_dcl.incl.pl1               >ldd>include>author_dcl.incl.pl1
1-10         2    04/21/82  1211.8  author.incl.pl1                   >ldd>include>author.incl.pl1
4048         3    08/06/87  0913.0  cdt.incl.pl1                      >ldd>include>cdt.incl.pl1
3-314        4    07/19/88  1524.1  fnp_types.incl.pl1                >special_ldd>install>MR12.2-1061>fnp_types.incl.pl1
4050         5    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
4052         6    05/08/81  1853.6  config_iom_card.incl.pl1          >ldd>include>config_iom_card.incl.pl1
4054         7    06/29/79  1727.8  event_wait_info.incl.pl1          >ldd>include>event_wait_info.incl.pl1
4056         8    05/23/79  1612.1  gload_data.incl.pl1               >ldd>include>gload_data.incl.pl1
4058         9    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
4060        10    09/18/86  1317.5  mca_data.incl.pl1                 >ldd>include>mca_data.incl.pl1
4062        11    09/18/86  1317.5  mca_data_area.incl.pl1            >ldd>include>mca_data_area.incl.pl1
11-88       12    11/12/74  1550.1  iom_dcw.incl.pl1                  >ldd>include>iom_dcw.incl.pl1
11-90       13    05/06/74  1742.1  iom_pcw.incl.pl1                  >ldd>include>iom_pcw.incl.pl1
11-92       14    08/17/79  2215.0  ioi_stat.incl.pl1                 >ldd>include>ioi_stat.incl.pl1
4064        15    06/09/83  1430.8  opr_query_info.incl.pl1           >ldd>include>opr_query_info.incl.pl1
4066        16    07/24/86  2051.8  rcp_disk_info.incl.pl1            >ldd>include>rcp_disk_info.incl.pl1
4068        17    03/27/86  1120.0  rcp_resource_types.incl.pl1       >ldd>include>rcp_resource_types.incl.pl1
4070        18    04/05/83  0853.0  rcp_tape_info.incl.pl1            >ldd>include>rcp_tape_info.incl.pl1
4072        19    05/23/79  1612.1  tolts_err_codes.incl.pl1          >ldd>include>tolts_err_codes.incl.pl1
4074        20    12/10/86  1422.0  tolts_fpinfo.incl.pl1             >ldd>include>tolts_fpinfo.incl.pl1
4076        21    12/10/86  1422.0  tolts_info.incl.pl1               >ldd>include>tolts_info.incl.pl1
21-299      22    09/13/84  0921.5  dial_manager_arg.incl.pl1         >ldd>include>dial_manager_arg.incl.pl1
4078        23    12/10/86  1422.0  tolts_rspd_workspace.incl.pl1     >ldd>include>tolts_rspd_workspace.incl.pl1
23-32       24    08/19/86  0932.1  ioi_direct_channel_dcls.incl.pl1  >ldd>include>ioi_direct_channel_dcls.incl.pl1
4080        25    10/11/83  1240.7  tolts_workspace.incl.pl1          >ldd>include>tolts_workspace.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DEVICE_TYPE                     000225 constant        char(32)                 initial array packed unaligned dcl 17-18 ref 1077
MCA_ATTACHED                           constant        fixed bin(17,0)          initial dcl 10-88 ref 1015
MCA_FREE                               constant        fixed bin(17,0)          initial dcl 10-88 ref 934
MCA_NOT_CONFIGURED                     constant        fixed bin(17,0)          initial dcl 10-88 ref 930 3660
TAPE_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 17-29 ref 1077
a                        44            based           bit(36)                  level 3 packed packed unaligned dcl 273 set ref 851*
                                                                                  1238* 1296* 1315* 1439* 1441* 1450* 1452* 1498
                                                                                  1498 1511 1515 1516 1523* 1528 1531 1568* 1773
                                                                                  1808 2123* 2137 2137 2138 2167* 2242* 2283* 2428*
                                                                                  2453 2496 2613* 2912 2913 2920 3003* 3004 3120
                                                                                  3120
a_code                                 parameter       char(3)                  packed unaligned dcl 3217 set ref 3215 3220*
abort                    13            based           structure                level 2 packed packed unaligned dcl 273
ac_name                         000552 automatic       char(6)                  packed unaligned dcl 208 set ref 1282* 1283* 1658*
                                                                                  1659* 1662 1664 1666* 1671*
acc_fault                31            based           bit(36)                  level 2 packed packed unaligned dcl 273 set ref
                                                                                  1777* 4029 4030*
acc_over                               based           structure                level 1 dcl 4014
add                      13            based           bit(18)                  level 3 packed packed unaligned dcl 273 set ref
                                                                                  3222*
addr                                                   builtin function         dcl 411 ref 460 460 491 494 546 546 546 546 552 552
                                                                                  561 561 591 591 632 632 685 711 726 726 747 747
                                                                                  756 777 777 802 803 912 941 941 947 947 957 957
                                                                                  960 960 980 981 1048 1054 1092 1092 1164 1164 1182
                                                                                  1182 1444 1444 1508 1513 1519 1524 1532 1620 1668
                                                                                  1668 1699 1733 1733 1748 1748 1873 1879 1894 1894
                                                                                  1911 1911 1934 1951 1962 1962 2027 2044 2084 2084
                                                                                  2146 2146 2185 2190 2191 2276 2359 2364 2364 2381
                                                                                  2381 2390 2390 2400 2408 2408 2636 2750 2923 2961
                                                                                  2961 2992 2992 3079 3117 3117 3120 3120 3159 3177
                                                                                  3177 3256 3256 3264 3264 3343 3345 3351 3385 3386
                                                                                  3420 3429 3431 3435 3441 3450 3452 3462 3467 3499
                                                                                  3501 3503 3517 3523 3590 3610 3644 3644 3702 3716
                                                                                  3716 3732 3752 3752 3779 3779 3790 3790 3826 3834
                                                                                  3834 3851 3935 3935 3935 3935 3957 3957 3966 3971
                                                                                  3984 3984 3984 3984 3990 3990 4002 4002 4002 4002
                                                                                  4028 4029 4032
addrel                                                 builtin function         dcl 411 ref 808 1021 1021 1246 1247 1248 1361 1411
                                                                                  1417 1418 1419 1430 1437 1501 1531 1612 1661 1717
                                                                                  1773 1780 1870 1871 2109 2109 2271 2354 2495 2586
                                                                                  2636 2637 2667 2670 2745 2922 2922 2939 3266 3305
                                                                                  3308 3308 3338 3342 3350 3433 3447 3478 3485 3507
                                                                                  3515
address                                based           bit(18)                  level 2 in structure "dcw" packed packed unaligned
                                                                                  dcl 12-7 in procedure "mtdsim_" set ref 1248 1419
                                                                                  1437 1732 1732 1743 3350 3431* 3452* 3458 3478
                                                                                  3483 3485 3489* 3494 3502* 3503 3505
address                   1            based           fixed bin(17,0)          level 3 in structure "tolts_fpinfo" packed packed
                                                                                  unaligned dcl 20-15 in procedure "mtdsim_" set ref
                                                                                  1511* 1518 1523
address                   5            based           bit(18)                  level 3 in structure "io_entry" packed packed
                                                                                  unaligned dcl 345 in procedure "mtdsim_" ref 3433
alloc_wait                             based           bit(1)                   level 2 dcl 21-155 set ref 928 1018* 3629
allocated             31103            based           bit(1)                   array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 3584
allocated                 1            based           bit(1)                   level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 1134*
alt_dev_flag              2            based           bit(1)                   level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 977 1044
alt_dev_flag          31104            based           bit(1)                   array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 3324
alt_device_index          3            based           fixed bin(12,0)          level 2 dcl 21-155 set ref 960*
alt_device_name           4            based           char(8)                  level 2 dcl 21-155 set ref 945* 3680
alt_flag                        000033 internal static bit(1)                   initial dcl 215 set ref 925* 938 957 980 1033 1050*
                                                                                  1057*
alt_rcp_area              6            based           fixed bin(17,0)          initial array level 2 dcl 21-155 set ref 947 947 960
                                                                                  960 981 1048 1054
alt_rcp_id               36            based           bit(36)                  level 2 dcl 21-155 set ref 947* 960* 1030* 3680*
altsct                 2146            based           structure                level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_"
altsct                33250            based           structure                array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_"
arg                                    based           char                     packed unaligned dcl 250 ref 419 419 419 423 428 428
                                                                                  430 430 432 432 433 433 434 435 435
arglen                          000130 internal static fixed bin(21,0)          dcl 231 set ref 418* 419 419 419 423 427* 428 428
                                                                                  430 430 432 432 433 433 434 435 435
argptr                          000174 automatic       pointer                  dcl 207 set ref 418* 419 419 419 423 427* 428 428
                                                                                  430 430 432 432 433 433 434 435 435
att_desc                        000111 internal static char(40)                 packed unaligned dcl 229 set ref 640* 939* 941* 945*
                                                                                  947* 1970* 2063* 2379* 2381*
attach_err               37            based           fixed bin(35,0)          level 2 dcl 21-155 set ref 957* 960* 979 988* 998
                                                                                  1000 1008* 2390* 2392 2394 2394*
author                                 based           structure                level 2 dcl 1-9
author_dcl                             based           structure                level 1 dcl 1-9
b18                             000164 automatic       bit(18)                  packed unaligned dcl 202 set ref 1291* 1292
bar                      33            based           bit(18)                  level 4 in structure "spa" packed packed unaligned
                                                                                  dcl 273 in procedure "mtdsim_" set ref 769* 1776*
                                                                                  4031*
bar                                    based           bit(18)                  level 2 in structure "gelbar_temp" packed packed
                                                                                  unaligned dcl 1765 in procedure "mtdsim_" ref 1776
                                                                                  1777
bar                                    based           bit(18)                  level 2 in structure "acc_over" packed packed
                                                                                  unaligned dcl 4014 in procedure "set_gelbar" set
                                                                                  ref 4029*
base_chan                              based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 2480
                                                                                  ref 2501
bcd_callname                    000162 automatic       bit(36)                  packed unaligned dcl 201 set ref 1358* 1359 2583*
                                                                                  2584
bcd_options                            based           bit(504)                 packed unaligned dcl 2664 set ref 2671*
bcd_to_ascii_                   000172 constant        entry                    external dcl 98 ref 1658
bin                                                    builtin function         dcl 411 ref 678 694 905 905 1296 1314 1314 1315 1431
                                                                                  1432 1439 1450 1469 1469 1511 1511 1511 1531 1539
                                                                                  1541 1567 1567 1586 1732 1732 1864 1871 1874 1875
                                                                                  1881 1891 1892 1977 1992 2001 2017 2027 2030 2041
                                                                                  2077 2091 2137 2137 2143 2152 2166 2166 2167 2278
                                                                                  2279 2280 2361 2450 2452 2613 2628 2628 2697 2697
                                                                                  2756 2756 2769 2771 2773 2854 2854 2909 2954 2954
                                                                                  3004 3005 3006 3309 3312 3314 3320 3327 3348 3422
                                                                                  3443 3458 3472 3478 3483 3486 3494 3503 3503 3505
                                                                                  3517 3517 3586 3586 4035
bit                                                    builtin function         dcl 411 ref 661 667 954 990 1001 1012 1086 1096 1111
                                                                                  1130 1296 1315 1439 1450 1541 2152 2167 2505 2511
                                                                                  2613 2909 3005 3006 3309 3312 3314 3320 3327 3586
                                                                                  3586 4034 4035
bit_buf                         000166 automatic       bit(72)                  packed unaligned dcl 203 set ref 1274* 1276
blk_lbl                         000132 internal static label variable           dcl 232 set ref 488* 3080 3181 3838
buf_size                 10            based           fixed bin(17,0)          level 2 dcl 25-13 set ref 3449* 3498* 3517* 3518
                                                                                  3520
bufnum                    1            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 2653 ref 2668
bufp                            000100 automatic       pointer                  dcl 188 set ref 1532* 1533 3343* 3344 3345* 3346
                                                                                  3351* 3352 3462* 3499* 3500 3502 3507* 3507 3517
c_error                         000141 automatic       fixed bin(35,0)          initial dcl 192 set ref 192*
c_len                           000104 automatic       fixed bin(17,0)          initial dcl 189 set ref 189* 454* 1169* 1241* 1420*
                                                                                  1433 1433* 1433 1435* 1436 1438 1438 1439 1530*
                                                                                  1533 1533 1662* 1664* 3341* 3344 3344 3346 3346
                                                                                  3347* 3348* 3349 3352 3352 3449* 3486* 3488* 3493
                                                                                  3493* 3500 3500 3504 3507 3508* 3517
cat_index                 1            based           fixed bin(17,0)          array level 2 in structure "mca_gcata" packed packed
                                                                                  unaligned dcl 322 in procedure "mtdsim_" set ref
                                                                                  1254*
cat_index                 1            based           fixed bin(17,0)          array level 2 in structure "gcata" packed packed
                                                                                  unaligned dcl 333 in procedure "mtdsim_" set ref
                                                                                  1284*
cat_name                 41            based           char(10)                 level 2 dcl 21-155 set ref 1166 1179* 1182 1184 1190
                                                                                  1190 1190 1190 1249*
cata                                   based           structure                level 1 dcl 318
cata_call                              based           structure                level 1 dcl 1152
cata_cycle               40            based           bit(1)                   level 2 dcl 21-155 set ref 1228 1228* 1236*
cata_keys                45            based           char(24)                 array level 2 dcl 21-155 set ref 1169 1171 1193 1195
                                                                                  1195 1195 1195 1195 1195 1195 1206 1207 1207 1207
                                                                                  1207 1207 1207 1207 1241 1243
catp                    142            based           pointer                  level 2 dcl 21-155 set ref 1169* 1174 1175 1241*
                                                                                  1251 1255 1257 1257 1261 1263 1266 1268 1268 1272
                                                                                  1272 1274 1274 1281 1282 1282 1285 1285 1287 1287
                                                                                  1288 1288 1288 1291 1291 1296 1409 1420 1422 1446
                                                                                  1452
catx                    144            based           fixed bin(17,0)          level 2 dcl 21-155 set ref 1181 1187* 1192* 1193
                                                                                  1195 1195 1195 1195 1195 1195 1195* 1205* 1206
                                                                                  1207 1207 1207 1207 1207 1207 1207* 1221* 1221
                                                                                  1222 1230 1230* 1230 1234* 1240 1241 1243 1428*
cbuf_add                        002003 automatic       fixed bin(17,0)          dcl 3377 set ref 3494* 3495 3495* 3497* 3498 3499
cc_addr                   4            based           bit(36)                  level 2 dcl 382 set ref 696* 722 726 1994* 2019*
ccc_icivlu               36            based           bit(36)                  level 2 packed packed unaligned dcl 273 set ref 757*
                                                                                  1700
ccc_p                    11(18)        based           bit(18)                  level 2 packed packed unaligned dcl 345 ref 3354
                                                                                  3548
ccc_queue               245            based           structure                level 2 dcl 21-75 set ref 591 591 632 632 726 726
                                                                                  747 747 1733 1733 1748 1748 1911 1911 1962 1962
                                                                                  2084 2084 2146 2146 2961 2961 2992 2992
ccc_regs                 50            based           structure                level 2 packed packed unaligned dcl 273 set ref 756*
                                                                                  1699
ccc_requests            245            based           fixed bin(17,0)          level 3 dcl 21-75 set ref 754 759* 759 760
ccu_pun                 145            based           bit(1)                   level 2 dcl 21-155 set ref 926 2855*
cdt                                    based           structure                level 1 dcl 3-44
cdt_name                572            based           char(32)                 initial array level 3 in structure "tolts_info"
                                                                                  dcl 21-75 in procedure "mtdsim_" set ref 1926 1927
                                                                                  1929*
cdt_name              27322            based           char(32)                 array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 584 584 625 625
                                                                                  1927* 1936 1938 1943* 1947 1947 1969 1970 2004
                                                                                  2004 3734 3736 3737*
cdte                                   based           structure                level 1 dcl 3-72
cdtp                            000712 automatic       pointer                  dcl 3-41 set ref 1585* 1587 1593 1593 1596
cdtptr                                 based           pointer                  level 2 dcl 21-75 ref 1585
chan                            000150 automatic       fixed bin(6,0)           dcl 197 set ref 1101* 1105* 1107*
chan_cmd                  0(24)        based           bit(6)                   level 2 packed packed unaligned dcl 13-21 set ref
                                                                                  3393* 3396* 3399* 3401* 3415* 3427* 3969*
chan_list                              based           structure                level 1 dcl 2480
chan_name                       000120 automatic       char(32)                 packed unaligned dcl 191 set ref 600* 603* 606* 609*
chan_suspended          146            based           bit(1)                   level 2 dcl 21-155 set ref 2698 2973* 3393 3938
chan_time             31251            based           fixed bin(35,0)          array level 3 dcl 21-75 set ref 1315
channel_id                      000160 internal static fixed bin(71,0)          level 2 dcl 310 set ref 557 557
channel_name            704            based           char(32)                 array level 4 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 2048* 2054* 3706*
channel_name             12            based           char(32)                 level 2 in structure "dial_manager_arg" dcl 22-14
                                                                                  in procedure "mtdsim_" set ref 3710* 3746*
channel_name          27346            based           char(32)                 array level 4 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 1938* 3736*
channel_threads                        based           structure                level 1 dcl 3-249
chanp                 27332            based           pointer                  array level 3 dcl 21-75 set ref 665* 2001* 2015 3756
char_pos                  0(18)        based           bit(3)                   level 2 packed packed unaligned dcl 12-7 set ref
                                                                                  3466
ci                              000560 automatic       structure                level 1 dcl 308 set ref 3256 3256 3264 3264
ck_alloc                               parameter       bit(1)                   packed unaligned dcl 3569 ref 3565 3584
cleanup                         000674 stack reference condition                dcl 409 ref 447
clp                             000710 automatic       pointer                  dcl 2486 set ref 2495* 2501 2518
clt_sw                          000054 internal static varying char(32)         dcl 222 set ref 576 577* 617 618 618 640 646 648*
                                                                                  658 1969* 2061*
cltp                            000202 automatic       pointer                  dcl 207 in procedure "mtdsim_" set ref 640* 642*
                                                                                  644* 660 665 3720* 3721* 3756* 3757*
cltp                                   based           pointer                  initial level 2 in structure "gicm" dcl 382
                                                                                  in procedure "mtdsim_" set ref 692* 713 714* 716*
                                                                                  723 730* 1872* 1990* 2015*
cltp                                   parameter       pointer                  dcl 3771 in procedure "close_sw" set ref 3769 3772*
                                                                                  3783*
cname                                  parameter       char                     packed unaligned dcl 793 ref 790
cntsct                33266            based           bit(18)                  array level 4 packed packed unaligned dcl 21-75 set
                                                                                  ref 3312*
code                            000102 internal static fixed bin(35,0)          initial dcl 226 in procedure "mtdsim_" set ref 418*
                                                                                  427* 477* 478 561* 563 564* 603* 605 607* 640* 641
                                                                                  642* 643 644* 645 647* 657 678* 679 680* 714* 716*
                                                                                  717 718* 1884* 1886 1894* 1896 1897* 1941* 1942
                                                                                  1943* 1946* 1977* 1978 1979* 2001* 2002 2003*
                                                                                  2051* 2052 2053* 2498* 2502* 2503 2504 2510* 2518*
                                                                                  2520 3037* 3651* 3656* 3663* 3666* 3708* 3709
                                                                                  3710* 3711* 3740* 3742* 3745 3746* 3747* 3772*
                                                                                  3773 3774* 3783* 3784 3785*
code                            000114 automatic       fixed bin(35,0)          dcl 3246 in procedure "display_mc" set ref 3256*
code                      0(18)        based           bit(3)                   level 2 in structure "idcw" packed packed unaligned
                                                                                  dcl 13-21 in procedure "mtdsim_" set ref 2193*
                                                                                  3387* 3425* 3967*
code                      0(18)        based           bit(3)                   level 2 in structure "pcw" packed packed unaligned
                                                                                  dcl 13-6 in procedure "mtdsim_" set ref 2186*
code                     13(18)        based           bit(18)                  level 3 in structure "spa" packed packed unaligned
                                                                                  dcl 273 in procedure "mtdsim_" set ref 3221*
colt_flag                       000466 external static bit(1)                   initial level 2 packed packed unaligned dcl 375 set
                                                                                  ref 586* 627* 670* 1949* 1972* 2064* 3168
colts_info                             based           structure                level 1 dcl 21-287
colts_op_flags                  000466 external static structure                level 1 dcl 375
colts_pages           27322            based           structure                array level 2 dcl 21-75
com_err_                        000174 constant        entry                    external dcl 99 ref 420 456 462 549 564 1943 3174
                                                                                  3197 3710 3713 3746 3749 3776 3787
com_prph               2161(12)        based           bit(1)                   level 4 in structure "io_info" packed packed
                                                                                  unaligned dcl 21-155 in procedure "mtdsim_" set
                                                                                  ref 3521 3533*
com_prph              33263(12)        based           bit(1)                   array level 5 in structure "tolts_info" packed
                                                                                  packed unaligned dcl 21-75 in procedure "mtdsim_"
                                                                                  set ref 3311
coment                          000216 automatic       char(256)                packed unaligned dcl 208 set ref 957* 960* 1660*
                                                                                  1666* 1671 1671* 1673* 2390*
command                                based           bit(6)                   level 2 packed packed unaligned dcl 13-21 set ref
                                                                                  3392* 3393 3407 3409 3414* 3421* 3968*
completion                4            based           structure                level 3 in structure "mca_work_space" packed packed
                                                                                  unaligned dcl 11-25 in procedure "mtdsim_"
completion                             based           structure                level 2 in structure "istat" dcl 14-7 in procedure
                                                                                  "mtdsim_"
con_time                150            based           fixed bin(35,0)          level 2 dcl 21-155 set ref 2143 2152 3004*
condition_info                         based           structure                level 1 dcl 5-14
continue                        002000 automatic       bit(1)                   packed unaligned dcl 3376 set ref 3381* 3405* 3454
                                                                                  3468* 3470* 3511
continue_to_signal_             000176 constant        entry                    external dcl 100 ref 500 505 510 515 520 525 535
control                   0(02) 000612 automatic       bit(1)                   level 2 in structure "flags" packed packed unaligned
                                                                                  dcl 312 in procedure "mtdsim_" set ref 609* 613
                                                                                  613 613
control                   0(22)        based           bit(2)                   level 2 in structure "pcw" packed packed unaligned
                                                                                  dcl 13-6 in procedure "mtdsim_" set ref 2188*
control                   0(22)        based           bit(2)                   level 2 in structure "idcw" packed packed unaligned
                                                                                  dcl 13-21 in procedure "mtdsim_" set ref 3404*
                                                                                  3426* 3454* 3468
convert_dial_message_$return_io_module
                                000200 constant        entry                    external dcl 101 ref 603
convert_status_code_            000202 constant        entry                    external dcl 103 ref 647 680 718 1897 1946 1979 2003
                                                                                  2053 3622 3711 3747 3774 3785
count                     0(30)        based           bit(6)                   level 2 packed packed unaligned dcl 13-21 set ref
                                                                                  3402* 3403 3403 3416* 3428*
cpu_time                        000154 automatic       fixed bin(71,0)          dcl 198 set ref 1365* 1366 2597* 2598 2611* 2612*
                                                                                  2612 2613
cpu_time_and_paging_            000204 constant        entry                    external dcl 104 ref 1365 2597 2611
cr501_pr54             2161(17)        based           bit(1)                   level 4 packed packed unaligned dcl 21-155 set ref
                                                                                  1119
crcst                  2150            based           structure                level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_"
crcst                 33252            based           structure                array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 3316 3317
cu_$arg_count                   000206 constant        entry                    external dcl 105 ref 417
cu_$arg_ptr                     000210 constant        entry                    external dcl 106 ref 418 427
cu_$stack_frame_ptr             000472 constant        entry                    external dcl 3238 ref 3249
cur_wks_sz              151            based           fixed bin(17,0)          level 2 dcl 21-155 set ref 1089* 2407*
current_service_type    205            based           fixed bin(17,0)          array level 4 dcl 3-44 ref 1593
cv_oct_check_                   000212 constant        entry                    external dcl 107 ref 477 3037
d_add                                  parameter       fixed bin(17,0)          dcl 3912 ref 3910 3915 3916 3917
data_add                270            based           fixed bin(17,0)          level 3 dcl 21-75 set ref 751* 1743*
data_buf                532            based           fixed bin(35,0)          array level 2 in structure "tolts_workspace"
                                                                                  dcl 25-13 in procedure "mtdsim_" set ref 3452 3462
                                                                                  3499 3503 3517
data_buf                110            based           area(320)                level 2 in structure "tolts_rspd_workspace"
                                                                                  dcl 23-16 in procedure "mtdsim_" set ref 1532
data_header                            based           structure                level 1 dcl 11-35
data_header_1            14            based           structure                level 2 dcl 11-25 set ref 3351
data_move                              based           char                     packed unaligned dcl 251 set ref 1438* 1438
data_size_1                     001610 automatic       fixed bin(21,0)          initial dcl 11-17 set ref 11-17* 3340 3353*
data_size_2                     001611 automatic       fixed bin(21,0)          initial dcl 11-17 set ref 11-17* 3340
db_addr                         000044 internal static fixed dec(7,0)           dcl 218 set ref 477* 478 482 483 3032 3037* 3038
                                                                                  3039
db_fnp_eval_                    000224 constant        entry                    external dcl 112 ref 1884
db_fnp_memory_$fetch            000226 constant        entry                    external dcl 113 ref 1894
db_sv_wd                        000103 internal static bit(36)                  packed unaligned dcl 227 set ref 482* 3032 3038*
dcw                                    based           structure                level 1 dcl 12-7 set ref 1721 1721 1726 1726 3430*
                                                                                  3448 3451* 3464 3465 3487
dcw_list                 15            based           bit(36)                  array level 2 in structure "tolts_workspace"
                                                                                  dcl 25-13 in procedure "mtdsim_" set ref 3450 3463
                                                                                  3464* 3467 3501 3523 3535 3536* 3537 3538*
dcw_list                152            based           bit(36)                  array level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 1518* 1520 3345
                                                                                  3460* 3465*
dcw_ptr                  10            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 345 ref 3338
                                                                                  3342 3447
dcwb                            002006 automatic       fixed bin(18,0)          unsigned dcl 3378 set ref 3483* 3494 3505*
dcwp                            001614 automatic       pointer                  dcl 12-4 set ref 1247* 1248 1418* 1419 1431 1432
                                                                                  1437 1717* 1720 1721 1721 1725 1726 1726 1732 1732
                                                                                  1743 1751* 3338* 3347 3348 3350 3429* 3430 3431
                                                                                  3432 3447* 3448 3450* 3451 3452 3453 3458 3464
                                                                                  3465 3466 3478 3478* 3478 3483 3485 3486 3487 3489
                                                                                  3494 3505 3511 3515* 3515
dealc_err                       000110 automatic       fixed bin(17,0)          initial dcl 189 set ref 189* 1471 3628* 3671* 3682*
                                                                                  3689*
debug                           000027 internal static bit(1)                   initial dcl 215 set ref 415* 428* 470 471*
debugging                       000030 internal static bit(1)                   initial dcl 215 set ref 415* 437* 468 552 565 569
                                                                                  1943 3029 3177 3200 3710 3716 3746 3752 3779 3790
definition               65     000716 automatic       structure                array level 2 packed packed unaligned dcl 8-5
den_cap                2162(21)        based           bit(4)                   level 4 packed packed unaligned dcl 21-155 set ref
                                                                                  3858* 3860* 3862* 3864* 3866* 3868* 3870* 3872*
                                                                                  3881* 3885* 3890* 3892* 3894* 3896* 3898* 3900*
                                                                                  3902* 3904*
density                  10            based           bit(36)                  level 2 dcl 18-15 ref 3852 3890 3892 3894 3896 3898
                                                                                  3900 3902 3904
dest_len                 23(18)        based           structure                level 4 packed packed unaligned dcl 11-25
dest_len_lsb             23(28)        based           bit(8)                   level 5 packed packed unaligned dcl 11-25 set ref
                                                                                  3353
dest_len_msb             23(19)        based           bit(8)                   level 5 packed packed unaligned dcl 11-25 set ref
                                                                                  3353
dev                       4(06)        based           bit(6)                   level 3 packed packed unaligned dcl 345 ref 3393
dev_busy                664            based           bit(1)                   level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 1002 1004* 1035*
dev_busy                               constant        fixed bin(18,0)          initial unsigned dcl 19-4 in procedure "mtdsim_" ref
                                                                                  1001 2505
dev_cmd                   4            based           bit(6)                   level 3 in structure "io_entry" packed packed
                                                                                  unaligned dcl 345 in procedure "mtdsim_" ref 2976
                                                                                  2978 2981 2984 3392 3419 3421 3529
dev_cmd                   7            based           bit(6)                   level 3 in structure "io_entry" packed packed
                                                                                  unaligned dcl 345 in procedure "mtdsim_" ref 3414
                                                                                  3419 3529
device                    0(06)        based           bit(6)                   level 2 packed packed unaligned dcl 13-21 set ref
                                                                                  3422* 3424* 3443* 3446* 3472* 3475*
device_index            665            based           fixed bin(12,0)          level 2 dcl 21-155 set ref 957* 1082* 1092* 1107*
                                                                                  1126* 1546* 2195* 2390* 2401* 2408* 2958* 2989*
                                                                                  3978* 3991*
device_name             666            based           char(8)                  level 2 dcl 21-155 set ref 932 939* 1026 1026 2379*
                                                                                  2501 3669
device_no              2146(06)        based           bit(6)                   level 4 in structure "io_info" packed packed
                                                                                  unaligned dcl 21-155 in procedure "mtdsim_" set
                                                                                  ref 3422 3443 3472
device_no              2161(06)        based           bit(6)                   level 4 in structure "io_info" packed packed
                                                                                  unaligned dcl 21-155 in procedure "mtdsim_" set
                                                                                  ref 3424 3446 3475
devsct                 2161            based           structure                level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_"
devsct                33263            based           structure                array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_"
df_iocbp                  2            based           pointer                  level 2 dcl 21-75 set ref 454* 1164* 1169* 1182*
                                                                                  1241* 1420* 1662* 1664*
diagnostic                3     000716 automatic       char(200)                level 2 packed packed unaligned dcl 8-5 set ref 462*
                                                                                  1446 1671*
dial_channel          27344            based           fixed bin(71,0)          array level 4 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 1937* 3735*
dial_channel            702            based           fixed bin(71,0)          array level 4 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 2047* 3705*
dial_manager_$privileged_attach 000214 constant        entry                    external dcl 108 ref 2051
dial_manager_$release_channel   000216 constant        entry                    external dcl 109 ref 3708 3740
dial_manager_$release_channel_no_listen
                                000220 constant        entry                    external dcl 110 ref 3742
dial_manager_$tandd_attach      000222 constant        entry                    external dcl 111 ref 1941
dial_manager_arg                       based           structure                level 1 dcl 22-14
dial_manager_arg_version_2             constant        fixed bin(17,0)          initial dcl 22-10 ref 1935 2045 3703 3733
dial_qualifier        27335            based           char(22)                 array level 4 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 1936* 3734*
dial_qualifier          673            based           char(22)                 array level 4 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 2046* 3704*
dialed_up                       000612 automatic       bit(1)                   level 2 packed packed unaligned dcl 312 set ref 609*
                                                                                  613 639
dipper_flag               1(32)        based           bit(4)                   array level 2 packed packed unaligned dcl 322 set
                                                                                  ref 1256* 1262* 1267*
direct_channel_pcw                     based           structure                level 1 dcl 24-23 set ref 1515 1536
direct_channel_pcw_ptr          001722 automatic       pointer                  dcl 24-21 set ref 1513* 1515 1521 1521 1524 1527
                                                                                  1529 1536 1538
direct_channel_tcw                     based           structure                level 1 dcl 24-44 set ref 1520* 1537
direct_channel_tcw_ptr          001724 automatic       pointer                  dcl 24-42 set ref 1519* 1520 1530 1537
disk_info                              based           structure                level 1 dcl 16-19
disk_info_ptr                   001676 automatic       pointer                  dcl 16-17 set ref 980* 981* 983 1048* 1049 1054*
                                                                                  1055
divide                                                 builtin function         dcl 411 ref 1124 2613 3076 3583
dm_arg                  672            based           structure                array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 2044 3702
dm_arg                27334            based           structure                array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 1934 3732
dm_attach                 0(01) 000466 external static bit(1)                   initial level 2 packed packed unaligned dcl 375 set
                                                                                  ref 588* 629* 639 671* 1971* 2065*
dm_event                  4            based           fixed bin(71,0)          level 2 dcl 21-75 ref 557 1937 1968 2047 2060 3705
                                                                                  3735
dmap                            001706 automatic       pointer                  dcl 21-74 set ref 1934* 1941* 2044* 2051* 3702*
                                                                                  3708* 3710 3732* 3740* 3742* 3746
dump_machine_cond_              000474 constant        entry                    external dcl 3239 ref 3264
e                       530            based           bit(36)                  level 3 in structure "tolts_workspace" dcl 25-13
                                                                                  in procedure "mtdsim_" set ref 3383*
e                                      based           bit(36)                  level 3 in structure "tolts_workspace" dcl 25-13
                                                                                  in procedure "mtdsim_" set ref 3518*
ecode                                  parameter       fixed bin(35,0)          dcl 3619 set ref 3617 3622*
edit_rev                               based           bit(36)                  array level 2 packed packed unaligned dcl 333 set
                                                                                  ref 1283*
emsg                            000136 internal static char(40)                 packed unaligned dcl 233 set ref 606* 607*
enter                    32            based           structure                level 2 packed packed unaligned dcl 273 set ref 777
                                                                                  777
error                           000140 automatic       fixed bin(35,0)          initial dcl 192 set ref 192* 445* 446 454* 455 456*
                                                                                  460* 461 462* 500* 505* 510* 515* 520* 525* 535*
                                                                                  538* 546* 548 549* 551 917* 919 932* 941* 947* 951
                                                                                  952* 998 1010* 1080* 1082* 1083 1084* 1092* 1093
                                                                                  1094* 1107* 1108 1109* 1126* 1127 1128* 1164* 1165
                                                                                  1166* 1169* 1170 1171* 1182* 1183 1184* 1241* 1242
                                                                                  1243* 1420* 1421 1422* 1444* 1445 1446* 1546* 1547
                                                                                  1548* 1662* 1664 1664* 1666 1668 1668* 1670 1673*
                                                                                  2195* 2196 2197* 2373* 2375 2381* 2384 2385* 2401*
                                                                                  2402 2403* 2408* 2699* 2700 2835* 2836 2958* 2959
                                                                                  2960* 2967* 2976* 2978* 2981* 2984* 2987* 2989*
                                                                                  2990 2991* 2997* 3172* 3173 3174* 3176 3194* 3196
                                                                                  3197* 3197* 3669* 3670 3672* 3680* 3681 3683*
                                                                                  3687* 3688 3690* 3713* 3715 3749* 3751 3776* 3778
                                                                                  3787* 3789 3931* 3935* 3941* 3943 3974* 3978* 3979
                                                                                  3979* 3984* 3991* 4002*
error_table_$bad_command_name   000446 external static fixed bin(35,0)          dcl 239 ref 2987
error_table_$force_unassign     000450 external static fixed bin(35,0)          dcl 240 ref 979
error_table_$resource_unavailable
                                000452 external static fixed bin(35,0)          dcl 241 ref 1000 2504
ev_ch_ass               670            based           bit(1)                   level 2 dcl 21-155 set ref 916 921* 2372 2377* 3686
ev_occurred                     000111 automatic       fixed bin(17,0)          initial dcl 189 set ref 189* 560* 561* 567
event_out                       000160 internal static structure                level 1 dcl 310 set ref 546 546 561 561 3935 3935
                                                                                  3984 3984 4002 4002
event_wait_info                        based           structure                level 1 dcl 7-7
exec                      6            based           char(4)                  level 2 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 577* 584* 618* 625*
                                                                                  648* 681* 689* 719* 1662 1898* 1947* 1980* 1986*
                                                                                  2004* 2012* 2054* 3623* 3712* 3748* 3775* 3786*
exec                            000046 internal static char(4)                  packed unaligned dcl 219 in procedure "mtdsim_" set
                                                                                  ref 416* 420* 423* 445* 454 454 456* 456 456 456*
                                                                                  462* 462 462 462* 492 498* 503* 508* 513* 518*
                                                                                  523* 549* 564* 815* 1596* 1694* 1714* 1721* 1726*
                                                                                  1884* 1919* 2071* 2587 2632* 2805* 2898* 2904*
                                                                                  3134* 3174* 3197* 3586* 3606* 3713* 3749* 3776*
                                                                                  3787* 3817
exec_active             554            based           bit(1)                   initial array level 3 dcl 21-75 set ref 659* 2043
                                                                                  3722* 3822
exec_chan               555            based           char(32)                 array level 3 dcl 21-75 ref 2046 2048 2061 2063 3704
                                                                                  3706
exec_dta                145            based           structure                array level 2 dcl 21-75 set ref 3920* 3920
exec_dta_cnt              7            based           fixed bin(17,0)          level 2 dcl 21-75 set ref 744 745 749 1730 3918*
                                                                                  3918 3919
exec_page_count          10            based           fixed bin(17,0)          level 2 dcl 21-75 set ref 1933* 1933 2816* 2816
                                                                                  3694* 3694 3759* 3759
exec_term_io_wait        11            based           bit(1)                   level 2 dcl 21-75 set ref 706 783* 3168
exec_type_code          571            based           bit(6)                   initial array level 3 dcl 21-75 set ref 2032 2066*
exec_wd                                based           bit(36)                  array packed unaligned dcl 253 set ref 482 483* 590*
                                                                                  631* 661* 667* 723* 725* 748* 749* 1074* 1074
                                                                                  1076* 1076 1356* 1359* 1360* 1367* 1368* 1518
                                                                                  1718* 1718* 1910* 1960* 2083* 2092* 2094* 2145*
                                                                                  2561* 2562* 2564* 2576* 2578* 2580* 2584* 2585*
                                                                                  3032* 3038 3039* 3357* 3358* 3434 3551* 3552*
                                                                                  3914* 3915* 3916* 3917*
execp                    12            based           pointer                  level 2 dcl 21-75 set ref 460* 468* 482 483 491 491
                                                                                  492 493 494 494 495 496 590 631 661 667 723 725
                                                                                  748 749 756 756 757 757 758 769 769 769 769 769
                                                                                  769 777 777 803 804 808 851 876 905 905 907 908
                                                                                  908 954 990 1001 1012 1021 1021 1074 1074 1076
                                                                                  1076 1086 1096 1111 1130 1159 1159 1159 1161 1161
                                                                                  1238 1246 1246 1247 1248 1296 1314 1314 1315 1356
                                                                                  1357 1359 1360 1361 1367 1368 1386 1411 1411 1414
                                                                                  1414 1414 1416 1416 1417 1417 1418 1419 1427 1430
                                                                                  1433 1433 1437 1439 1441 1444 1444 1450 1452 1469
                                                                                  1469 1498 1498 1501 1501 1511 1511 1515 1516 1518
                                                                                  1523 1528 1531 1531 1567 1567 1568 1569 1586 1588
                                                                                  1589 1591 1595 1612 1612 1642 1661 1668 1668 1674
                                                                                  1674 1677 1679 1682 1699 1699 1700 1700 1717 1718
                                                                                  1718 1772 1772 1773 1773 1774 1775 1776 1777 1779
                                                                                  1780 1781 1808 1808 1870 1871 1910 1960 2083 2092
                                                                                  2094 2122 2123 2137 2137 2138 2144 2145 2148 2151
                                                                                  2152 2166 2166 2167 2181 2181 2181 2183 2183 2238
                                                                                  2238 2238 2240 2240 2242 2271 2271 2278 2279 2280
                                                                                  2283 2352 2354 2354 2361 2411 2428 2453 2492 2492
                                                                                  2492 2494 2494 2495 2495 2496 2505 2511 2561 2562
                                                                                  2564 2576 2578 2580 2582 2584 2585 2586 2613 2628
                                                                                  2628 2637 2667 2667 2670 2695 2695 2697 2697 2745
                                                                                  2745 2760 2810 2811 2811 2854 2854 2912 2913 2920
                                                                                  2923 2939 3003 3004 3005 3006 3032 3038 3039 3076
                                                                                  3079 3117 3117 3120 3120 3159 3203* 3221 3222 3223
                                                                                  3229 3229 3305 3306 3308 3308 3309 3338 3342 3350
                                                                                  3357 3358 3433 3434 3447 3478 3485 3551 3552 3834
                                                                                  3834 3914 3915 3916 3917 4029 4030 4031 4032 4032
                                                                                  4034 4034 4035 4036
ext_status_add          671            based           fixed bin(17,0)          level 2 dcl 21-155 set ref 3546*
ext_sts                   1            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 345 ref 3546
fatal_code                1     000556 automatic       fixed bin(35,0)          level 2 dcl 304 set ref 551* 3176* 3715* 3751* 3778*
                                                                                  3789*
fatal_desc                      000556 automatic       structure                level 1 dcl 304 set ref 552 552 3177 3177 3716 3716
                                                                                  3752 3752 3779 3779 3790 3790
fault                     0(19)        based           bit(1)                   level 2 packed packed unaligned dcl 4014 set ref
                                                                                  4028*
faultsp                         000106 automatic       pointer                  dcl 3245 set ref 3250* 3251 3256* 3264*
fdcwp                                  based           bit(18)                  level 2 packed packed unaligned dcl 1152 ref 1247
                                                                                  1418
file_attach              14            based           bit(1)                   level 2 dcl 21-75 ref 2109 2834 2869 3116 3194 3201
                                                                                  3833
filename                  2            based           structure                array level 2 packed packed unaligned dcl 322 set
                                                                                  ref 1276*
filename_idx                    000143 automatic       fixed bin(17,0)          dcl 193 set ref 1257* 1263* 1268* 1272* 1274 1274
find_condition_frame_           000476 constant        entry                    external dcl 3240 ref 3250
find_condition_info_            000500 constant        entry                    external dcl 3241 ref 3256
finish_cond              16            based           bit(1)                   level 2 dcl 21-75 set ref 3143* 3838 3944
firm_ld_io_type                        constant        fixed bin(17,0)          initial dcl 21-63 ref 3938
first                           002001 automatic       bit(1)                   packed unaligned dcl 3376 set ref 3459* 3481 3482*
first_dcw                 5            based           structure                level 2 packed packed unaligned dcl 345
first_request_done       17            based           bit(1)                   level 2 dcl 21-75 ref 707
fix_wd                                 based           fixed bin(18,0)          array packed unsigned unaligned dcl 256 set ref 1362
                                                                                  1362 1362* 1364* 2588 2588 2588* 2590* 2593 2593
                                                                                  2593* 2595*
fixed                                                  builtin function         dcl 411 ref 908 1092 1092 1100 1101 1104 1105 1364
                                                                                  1430 1433 1433 1444 1444 1668 1668 1743 2190 2408
                                                                                  2408 2495 2590 2595 2811 3076 3353 3356 3385 3433
                                                                                  3435 3523 3550 3971 4034 4034
flags                           000612 automatic       structure                level 1 dcl 312 in procedure "mtdsim_" set ref 602*
                                                                                  603*
flags                     0(18)        based           structure                level 2 in structure "chan_list" packed packed
                                                                                  unaligned dcl 2480 in procedure "mtdsim_"
flt_flag                        000032 internal static bit(1)                   initial dcl 215 set ref 498 499 503 504 508 509 513
                                                                                  514 518 519 523 524 777 3193* 3223
fnp                     554            based           structure                array level 2 dcl 21-75 set ref 3821
fnp_addr                        000106 internal static fixed bin(17,0)          dcl 228 set ref 1884* 1892* 1894*
fnp_entry               120            based           structure                array level 2 dcl 3-44
fnp_execp               566            based           pointer                  array level 3 dcl 21-75 set ref 660* 678* 681* 692
                                                                                  723 1977* 1990 3720
fnp_num                         000107 internal static fixed bin(17,0)          dcl 228 in procedure "mtdsim_" set ref 1881* 1884*
                                                                                  1894*
fnp_num                                based           fixed bin(17,0)          level 3 in structure "tolts_fpinfo" packed packed
                                                                                  unaligned dcl 20-15 in procedure "mtdsim_" ref
                                                                                  1503 1614 2272 2355 2746
fnp_num               31774            based           fixed bin(17,0)          array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 1503 1614 2272 2355
                                                                                  2746
fnp_opcode                2(18)        based           bit(18)                  level 2 packed packed unaligned dcl 392 set ref
                                                                                  1900* 1902* 1953*
fnp_state                       000325 constant        char(7)                  initial array packed unaligned dcl 797 set ref 1596*
fnpdcw                    1            based           structure                level 2 dcl 20-15
fnpe                                   based           structure                level 1 dcl 3-200
found                           000020 internal static bit(1)                   initial dcl 215 set ref 3459* 3463 3511*
fpinfo_ptr              674            based           pointer                  level 2 dcl 21-155 set ref 1509* 2360*
fwd                             002162 automatic       bit(36)                  packed unaligned dcl 4012 set ref 4027* 4028 4029
                                                                                  4030
gc_date                  20            based           bit(36)                  level 2 dcl 21-75 ref 2123
gcata                                  based           structure                array level 1 dcl 333 set ref 1280*
gcatp                           000212 automatic       pointer                  dcl 207 set ref 1248* 1249* 1253 1254 1254 1256 1262
                                                                                  1267 1276 1280 1283 1284 1284 1285 1287 1288 1292
gcos_tod                        000163 automatic       bit(36)                  packed unaligned dcl 201 set ref 1778* 1779 2142*
                                                                                  2143 2152 2752* 2756 4033* 4034
gelbar                          000021 internal static bit(1)                   initial dcl 215 set ref 442* 754 769* 806 1782*
                                                                                  4037*
gelbar_temp                            based           structure                level 1 dcl 1765
genp                            000126 internal static pointer                  dcl 230 set ref 1246* 1247 1361* 1362 1362 1362 1364
                                                                                  1409 1411* 1417* 1418 1420 1422 1446 1452 1773*
                                                                                  1774 1775 1776 1777 1780* 1780 1781 2586* 2588
                                                                                  2588 2588 2590 2593 2593 2593 2595 2667* 2668
                                                                                  2670* 2670 2671 3305* 3306 3310 3313 3314 3316
                                                                                  3317 3318 3319 3320 3325 3326 3327
gerout_num                      000104 internal static fixed bin(17,0)          dcl 228 set ref 1864* 1865
get_temp_segment_               000230 constant        entry                    external dcl 114 ref 1080
gewake_active            21            based           bit(1)                   level 2 dcl 21-75 set ref 2965 2968* 2995 2998*
                                                                                  3078* 3933* 3934 3976* 3983
gewake_event             22            based           fixed bin(71,0)          level 2 dcl 21-75 set ref 2966* 2967* 2996* 2997*
                                                                                  3077* 3930* 3931* 3932* 3973* 3974* 3975*
gicm                                   based           structure                level 1 dcl 382 set ref 685 734 1872 1873 3830
gicm_count                      000010 internal static fixed bin(17,0)          initial dcl 214 set ref 443* 686* 686 688 708 729*
                                                                                  729 732 1865 1983* 1983 1985 2009* 2009 2011
gicmp                           000066 internal static pointer                  initial dcl 224 set ref 444* 685* 685 692 693 694
                                                                                  696 697 713 714 716 716 716 722 723 723 725 726
                                                                                  730 731 734 735* 1872 1872* 1873* 1873 1990 1991
                                                                                  1992 1994 1995 2015 2016 2017 2019 2020 3830 3830
glb_brk                         000022 internal static bit(1)                   initial dcl 215 set ref 442* 769* 775* 4038*
glbflt                   23            based           bit(36)                  level 2 packed packed unaligned dcl 273 set ref 769*
                                                                                  4032
glbici                   22            based           structure                level 2 packed packed unaligned dcl 273 set ref 769
                                                                                  769 1779* 4034
glbtmr                   21            based           bit(36)                  level 2 packed packed unaligned dcl 273 set ref
                                                                                  1772* 4034*
gload_                          000232 constant        entry                    external dcl 115 ref 460 1444 1668
gload_data                      000716 automatic       structure                level 1 dcl 8-5 set ref 460 460 1444 1444 1668 1668
glob_int_cnt             24            based           fixed bin(17,0)          level 2 dcl 21-75 set ref 1022* 1022 1554* 1554
                                                                                  3007* 3007 3168 3981* 3981
gndc_flag                       000017 internal static bit(1)                   initial dcl 215 set ref 448* 754 776* 1697*
h_pad                                  based           structure                level 2 dcl 25-13
hcs_$get_ips_mask               000236 constant        entry                    external dcl 117 ref 3144
hcs_$set_ips_mask               000240 constant        entry                    external dcl 118 ref 3146 3148
hcs_$wakeup                     000234 constant        entry                    external dcl 116 ref 538 3172
host_opcode               2            based           bit(18)                  level 2 packed packed unaligned dcl 391 ref 1877
                                                                                  1915
host_word_count           0(24)        based           fixed bin(12,0)          level 2 packed packed unsigned unaligned dcl 24-44
                                                                                  set ref 1530
hran_$hranl                     000502 constant        entry                    external dcl 3242 ref 3274
hreg_ptr                        000110 automatic       pointer                  dcl 3245 set ref 3266* 3268 3274*
hung_up                   0(01) 000612 automatic       bit(1)                   level 2 packed packed unaligned dcl 312 set ref 609*
i                               000112 automatic       fixed bin(17,0)          initial dcl 189 set ref 189* 426* 427* 760* 761 761*
                                                                                  1193* 1195 1195 1195 1195 1206* 1207 1207 1207
                                                                                  1207 1251* 1253 1254 1254 1254 1255 1256 1257 1257
                                                                                  1261 1262 1263 1266 1267 1268 1268 1272 1272 1274
                                                                                  1274 1276 1280 1281 1282 1282 1283 1284 1284 1284
                                                                                  1285 1285 1285 1287 1287 1287 1288 1288 1288 1288
                                                                                  1291 1291 1292* 1365* 1882* 1890* 1916* 1916* 1918
                                                                                  1923 1927 1934 1935 1936 1936 1937 1938 1938 1939
                                                                                  1943 1945 1947 1947 1969 1970 1974 2452* 2453*
                                                                                  2597* 2611* 2629* 2629* 2631 2636 2668* 2669 2671
                                                                                  2802* 2802* 2804 2808 2809* 2815 2817 2901* 2901*
                                                                                  2903 2907 2908 2909 2909 2911 2912 2915 2919 2920
                                                                                  2922* 3433* 3434 3463* 3535* 3535* 3536 3537 3538*
                                                                                  3641* 3644 3644 3919* 3920 3920* 3955* 3957 3957
                                                                                  3987* 3990 3990
ic                       35            based           bit(18)                  level 4 in structure "spa" packed packed unaligned
                                                                                  dcl 273 in procedure "mtdsim_" set ref 495* 1677*
                                                                                  1682* 1774* 1808* 2923* 3079* 3159* 3229* 4032*
ic                       22            based           bit(18)                  level 3 in structure "spa" packed packed unaligned
                                                                                  dcl 273 in procedure "mtdsim_" set ref 4035*
ic                        1            based           bit(18)                  level 2 in structure "gelbar_temp" packed packed
                                                                                  unaligned dcl 1765 in procedure "mtdsim_" ref 1774
ic                     2163            based           bit(18)                  level 3 in structure "io_info" packed packed
                                                                                  unaligned dcl 21-155 in procedure "mtdsim_" set
                                                                                  ref 1019* 3354* 3548*
ic_inc                                 parameter       fixed bin(17,0)          dcl 3157 ref 3155 3159
icc                   33263(18)        based           bit(11)                  array level 5 in structure "tolts_info" packed
                                                                                  packed unaligned dcl 21-75 in procedure "mtdsim_"
                                                                                  set ref 3602
icc                    2161(18)        based           bit(11)                  level 4 in structure "io_info" packed packed
                                                                                  unaligned dcl 21-155 in procedure "mtdsim_" set
                                                                                  ref 1100 1101 1104 1105
icivlu                  246            based           bit(36)                  array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 758 761* 761
icivlu                  266            based           bit(36)                  level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 747 1741*
icivlu                   35            based           structure                level 3 in structure "spa" packed packed unaligned
                                                                                  dcl 273 in procedure "mtdsim_" set ref 494 757
                                                                                  758* 769 769 1674* 1700*
icivlu                 2163            based           structure                level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 2146 2146 2961 2961
                                                                                  2992 2992
icm                                    based           structure                level 1 dcl 393
icm_buf                   3            based           bit(36)                  array level 2 in structure "ticm" packed packed
                                                                                  unaligned dcl 392 in procedure "mtdsim_" set ref
                                                                                  1883 1892 1894 1894
icm_buf                   3            based           bit(36)                  array level 2 in structure "wicm" packed packed
                                                                                  unaligned dcl 391 in procedure "mtdsim_" ref 1939
icm_tally                       000105 internal static fixed bin(17,0)          dcl 228 set ref 1874* 1878 1880 1880 1880 1887*
                                                                                  1891* 1894* 1906 1906 1906 1907 1950 1952 1952
                                                                                  1952 1956 1956 1956 1957 3831
idcw                                   based           structure                level 1 dcl 13-21 set ref 2192*
idcw_io                         002002 automatic       bit(1)                   packed unaligned dcl 3376 set ref 3391* 3413* 3506
                                                                                  3529
idcwp                           001620 automatic       pointer                  dcl 13-19 set ref 2191* 2192 2193 3386* 3387 3392
                                                                                  3393 3393 3396 3399 3401 3402 3403 3403 3404 3407
                                                                                  3409 3414 3415 3416 3420* 3421 3422 3424 3425 3426
                                                                                  3427 3428 3441* 3443 3446 3454 3467* 3468 3472
                                                                                  3475 3966* 3967 3968 3969
ident                     2            based           bit(36)                  array level 2 packed packed unaligned dcl 333 set
                                                                                  ref 1285* 1287*
ignore_term               7(29)        based           bit(1)                   level 3 in structure "io_entry" packed packed
                                                                                  unaligned dcl 345 in procedure "mtdsim_" ref 3547
ignore_term             676            based           bit(1)                   level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 3547*
ilc                       4            based           bit(18)                  level 2 packed packed unaligned dcl 9-56 ref 808
                                                                                  3222 4035
illegal_modifier                000636 stack reference condition                dcl 409 ref 507
illegal_opcode                  000644 stack reference condition                dcl 409 ref 512
illegal_procedure               000652 stack reference condition                dcl 409 ref 517
illop                           000630 stack reference condition                dcl 409 ref 502
ima_level                 7            based           structure                array level 2 dcl 23-16 set ref 2451*
imu_found                       000145 automatic       bit(1)                   initial packed unaligned dcl 195 set ref 195* 2571*
                                                                                  2576
in_ccc                          000023 internal static bit(1)                   initial dcl 215 set ref 442* 754 763* 769 769* 813
                                                                                  1693 1698* 3123* 3206* 4037*
in_use                27474            based           bit(1)                   initial array level 3 in structure "tolts_info"
                                                                                  packed packed unaligned dcl 21-75 in procedure
                                                                                  "mtdsim_" set ref 583* 624* 654* 1916 1918 1923*
                                                                                  1945* 3758* 3819
in_use                  677            based           bit(1)                   level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 3827
in_use                32001            based           bit(1)                   array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 2802 2804 2815*
                                                                                  3584
ind                    2163(18)        based           bit(18)                  level 3 in structure "io_info" packed packed
                                                                                  unaligned dcl 21-155 in procedure "mtdsim_" set
                                                                                  ref 1020* 3355* 3549*
ind                      35(18)        based           bit(18)                  level 4 in structure "spa" packed packed unaligned
                                                                                  dcl 273 in procedure "mtdsim_" set ref 496* 804*
                                                                                  1775*
ind                      22(18)        based           bit(18)                  level 3 in structure "spa" packed packed unaligned
                                                                                  dcl 273 in procedure "mtdsim_" set ref 4036*
ind                       1(18)        based           bit(18)                  level 2 in structure "gelbar_temp" packed packed
                                                                                  unaligned dcl 1765 in procedure "mtdsim_" ref 1775
index                                                  builtin function         dcl 411 ref 1255 1257 1261 1263 1266 1268 1272 1288
info_ptr                        000214 automatic       pointer                  dcl 207 set ref 710* 711* 711 714* 715 740
info_struct                            based           structure                level 1 dcl 402 set ref 710 711 740
init_time               100            based           fixed bin(71,0)          level 2 dcl 21-75 set ref 1366* 2598* 2612
int_time                700            based           fixed bin(35,0)          level 2 dcl 21-155 set ref 3364* 3558*
intercom_mbx_area               001712 automatic       structure                level 1 dcl 23-29
inuse                   272            based           bit(1)                   array level 3 dcl 21-75 set ref 2669* 2901 2903
                                                                                  2907*
io_block_len                    000554 automatic       fixed bin(17,0)          dcl 223 set ref 2978* 2981* 2984* 3349*
io_cmd                    7(18)        based           bit(6)                   level 3 in structure "io_entry" packed packed
                                                                                  unaligned dcl 345 in procedure "mtdsim_" ref 3415
io_cmd                    4(18)        based           bit(6)                   level 3 in structure "io_entry" packed packed
                                                                                  unaligned dcl 345 in procedure "mtdsim_" ref 3388
                                                                                  3388 3396 3427
io_entry                               based           structure                level 1 dcl 345
io_in_progress          701            based           bit(1)                   level 2 dcl 21-155 set ref 1544* 1623 2964* 2994*
                                                                                  3362* 3556* 3649* 3661* 3664* 3929 3986
io_info                                based           structure                level 1 dcl 21-155 set ref 3693*
io_info_ptr                     001704 automatic       pointer                  dcl 21-73 set ref 912* 916 917 917* 921 926 926 928
                                                                                  928 930 930 932 932 932 934 939 941 941 941 941
                                                                                  941 945 947 947 947 947 947 957 957 957 957 957
                                                                                  957 960 960 960 960 960 960 977 977 977 979 980
                                                                                  981 988 996 996 998 1000 1002 1003 1004 1008 1008
                                                                                  1015 1015 1015 1018 1019 1020 1026 1026 1026 1026
                                                                                  1029 1030 1030 1033 1034 1035 1044 1044 1044 1044
                                                                                  1048 1054 1077 1080 1080 1082 1082 1089 1090 1091
                                                                                  1092 1099 1100 1101 1104 1105 1107 1116 1116 1119
                                                                                  1119 1122 1124 1126 1134 1162 1163 1164 1164 1166
                                                                                  1169 1169 1171 1171 1174 1174 1175 1175 1175 1175
                                                                                  1177 1179 1179 1179 1181 1182 1182 1182 1184 1187
                                                                                  1187 1188 1188 1190 1190 1190 1190 1190 1190 1192
                                                                                  1192 1193 1193 1195 1195 1195 1195 1195 1195 1195
                                                                                  1195 1195 1195 1195 1195 1195 1195 1205 1205 1206
                                                                                  1206 1207 1207 1207 1207 1207 1207 1207 1207 1207
                                                                                  1207 1207 1207 1207 1207 1221 1221 1222 1222 1227
                                                                                  1228 1228 1230 1230 1230 1233 1233 1234 1236 1240
                                                                                  1241 1241 1241 1243 1243 1249 1251 1252 1255 1257
                                                                                  1257 1261 1263 1266 1268 1268 1272 1272 1274 1274
                                                                                  1281 1282 1282 1285 1285 1287 1287 1288 1288 1288
                                                                                  1291 1291 1296 1298 1298 1298 1409 1420 1422 1426
                                                                                  1428 1429 1446 1452 1508* 1509 1510 1518 1520 1528
                                                                                  1539 1541 1544 1545 1545 1546 1568 1569 1620* 1621
                                                                                  1623 2143 2143 2145 2146 2146 2152 2152 2189 2194
                                                                                  2195 2276* 2277 2359* 2360 2364 2364 2372 2373
                                                                                  2373* 2377 2379 2381 2381 2381 2381 2381 2390 2390
                                                                                  2390 2390 2390 2390 2392 2392 2394 2394 2399 2400
                                                                                  2401 2401 2407 2408 2417 2425 2432 2439 2447 2497
                                                                                  2498 2498 2499 2501 2501 2502 2502 2502 2506 2506
                                                                                  2515 2517 2518 2518 2521 2629 2632 2698 2750* 2751
                                                                                  2855 2955 2957 2958 2961 2961 2963 2964 2973 2975
                                                                                  2976 2978 2978 2981 2981 2984 2984 2989 2992 2992
                                                                                  2994 3004 3005 3339 3345 3354 3355 3356 3357 3358
                                                                                  3359 3360 3361 3362 3363 3363 3364 3380 3388 3393
                                                                                  3396 3399 3407 3409 3417 3417 3422 3424 3443 3446
                                                                                  3458 3460 3465 3472 3475 3521 3527 3533 3545 3546
                                                                                  3547 3548 3549 3550 3551 3552 3553 3554 3555 3556
                                                                                  3557 3557 3558 3590* 3610* 3629 3629 3631 3632
                                                                                  3633 3633 3639 3641 3641 3649 3650 3650 3651 3651
                                                                                  3656 3656 3656 3658 3660 3661 3662 3662 3663 3664
                                                                                  3665 3665 3666 3669 3669 3679 3680 3680 3686 3687
                                                                                  3693 3826* 3827 3851 3853 3858 3860 3862 3864 3866
                                                                                  3868 3870 3872 3880 3881 3885 3890 3892 3894 3896
                                                                                  3898 3900 3902 3904 3929 3938 3938 3938 3946 3955
                                                                                  3963 3964 3972 3978 3986 3987 3991
io_module                       000130 automatic       char(32)                 packed unaligned dcl 191 set ref 600* 603* 609*
io_param_blk             15(27)        based           structure                level 3 packed packed unaligned dcl 11-25
io_parameter_block                     based           structure                level 1 packed packed unaligned dcl 11-50
io_rq_cnt                 2            based           fixed bin(35,0)          level 2 dcl 20-15 set ref 1542* 1542 1623* 2754
                                                                                  2754* 2754 2778 2778* 2778
io_sel                          000011 internal static fixed bin(17,0)          initial dcl 214 set ref 906* 912 1315 1503* 1503*
                                                                                  1507 1508 1614* 1614* 1619 1620 2167 2241 2272*
                                                                                  2272* 2275 2276 2355* 2355* 2358 2359 2364* 2699*
                                                                                  2746* 2746* 2749 2750 3006 3573* 3577* 3581* 3583*
                                                                                  3583 3584 3584 3584 3584 3590 3602* 3602* 3605
                                                                                  3610 3825* 3826* 3941* 3977
io_trc_flag             702            based           bit(1)                   level 2 dcl 21-155 set ref 3527* 3545*
io_type               32005            based           fixed bin(17,0)          array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 2817
io_type                 703            based           fixed bin(17,0)          level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 930 977 1008 1015
                                                                                  1026 1044 1080 1090 1116 1119 1122 1162 1188 1227
                                                                                  1252 1298 1426 2955 2975 3388 3396 3399 3417 3631
                                                                                  3938 3938 3963
ioa_                            000242 constant        entry                    external dcl 119 in procedure "mtdsim_" ref 468 479
                                                                                  498 503 508 513 518 523 569 609
ioa_                            000504 constant        entry                    external dcl 3243 in procedure "display_mc" ref 3252
                                                                                  3258
ioa_$ioa_switch                 000506 constant        entry                    external dcl 3244 ref 3263 3269 3273
ioa_$rsnnl                      000244 constant        entry                    external dcl 119 ref 606 939 945 1666 1671 2379 2942
                                                                                  2948 3528 3529 3533 3536 3538 3540 3641 3806 3955
                                                                                  3987
ioe                                    based           bit(36)                  array packed unaligned dcl 254 set ref 2942* 2942*
                                                                                  2942* 2948* 2948* 2948*
ioe_ptr                         000206 automatic       pointer                  dcl 207 set ref 2939* 2942 2942 2942 2948 2948 2948
                                                                                  2954 2954 2976 2978 2981 2984 3338 3342 3354 3356
                                                                                  3388 3388 3392 3393 3396 3402 3414 3415 3416 3419
                                                                                  3419 3421 3422 3427 3428 3433 3443 3447 3472 3489
                                                                                  3529 3529 3546 3547 3548 3550
ioi_$connect                    000246 constant        entry                    external dcl 120 ref 1546
ioi_$connect_pcw                000304 constant        entry                    external dcl 135 ref 2195 2989 3978
ioi_$release_devices            000250 constant        entry                    external dcl 121 ref 3991
ioi_$set_channel_required       000252 constant        entry                    external dcl 122 ref 1107
ioi_$set_status                 000254 constant        entry                    external dcl 123 ref 1092 2408
ioi_$suspend_devices            000256 constant        entry                    external dcl 124 ref 2958
ioi_$timeout                    000260 constant        entry                    external dcl 125 ref 1126
ioi_$workspace                  000262 constant        entry                    external dcl 126 ref 1082 2401
ioi_wksp                        001726 automatic       pointer                  dcl 25-11 set ref 1091* 1092 1092 2189* 2190 2191
                                                                                  2241* 2242 3380* 3382 3383 3384 3385 3386 3420
                                                                                  3429 3431 3434 3435 3441 3449 3450 3452 3462 3463
                                                                                  3464 3467 3498 3499 3501 3503 3517 3517 3518 3518
                                                                                  3520 3520 3522 3523 3529 3529 3529 3533 3535 3536
                                                                                  3537 3538 3964* 3965 3966 3971
iom                             000147 automatic       fixed bin(3,0)           dcl 197 set ref 1100* 1104* 1107*
iom_card                               based           structure                level 1 dcl 6-5
iom_cardp                       000714 automatic       pointer                  dcl 6-3 set ref 2565* 2568* 2569 2571 2572
iom_found                       000146 automatic       bit(1)                   initial packed unaligned dcl 196 set ref 196* 2572*
                                                                                  2578
iox_$attach_name                000264 constant        entry                    external dcl 127 ref 640
iox_$close                      000266 constant        entry                    external dcl 128 ref 3772
iox_$control                    000270 constant        entry                    external dcl 129 ref 714
iox_$detach_iocb                000272 constant        entry                    external dcl 130 ref 3783
iox_$get_chars                  000274 constant        entry                    external dcl 131 ref 716
iox_$modes                      000276 constant        entry                    external dcl 132 ref 644
iox_$open                       000300 constant        entry                    external dcl 133 ref 642
iox_$put_chars                  000302 constant        entry                    external dcl 134 ref 678 1977 2001
ipc_$block                      000306 constant        entry                    external dcl 136 ref 546 3935 3984 4002
ipc_$delete_ev_chn              000310 constant        entry                    external dcl 137 ref 3687
ipc_$drain_chn                  000312 constant        entry                    external dcl 138 ref 2967 2997 3931 3974
ipc_$read_ev_chn                000314 constant        entry                    external dcl 139 ref 561
ipc_attached            706            based           bit(1)                   level 2 dcl 21-155 set ref 2497 2515* 2517 2521*
                                                                                  3632 3658*
ipc_id                  707            based           char(3)                  level 2 dcl 21-155 set ref 2498 2499* 2501* 2502
                                                                                  2506* 2518 3656
ipc_number              710            based           fixed bin(17,0)          level 2 dcl 21-155 set ref 2502* 3633* 3641* 3651*
ipcd                                   based           structure                level 1 dcl 10-61
ir                        4(18)        based           structure                level 2 packed packed unaligned dcl 9-56 ref 804
                                                                                  4036
isc_ccc_rqt                     000024 internal static bit(1)                   initial dcl 215 set ref 442* 743 746* 766 1326*
                                                                                  1740*
isc_cntdn                       000012 internal static fixed bin(17,0)          initial dcl 214 set ref 441* 744* 744 745 1327 1327*
                                                                                  1738*
isc_queue               266            based           structure                level 2 dcl 21-75
istat                                  based           structure                level 1 dcl 14-7
itr_io_type                            constant        fixed bin(17,0)          initial dcl 21-60 ref 1119 3417 3938
itr_run                         000041 internal static bit(1)                   initial dcl 215 set ref 442* 2817*
j                               000113 automatic       fixed bin(17,0)          initial dcl 189 set ref 189* 1281* 1282 1282 1285
                                                                                  1285 1285 1287 1287 1365* 1586* 1587 1587 1588
                                                                                  1589 1591 1593 1593 1596 1596 1731* 1732* 1925*
                                                                                  1926 1927 1929 1930* 2597* 2611* 2914* 2915* 3461*
                                                                                  3464 3465 3467 3476* 3476 3501 3510* 3510 3537*
                                                                                  3537* 3538*
k                                      parameter       fixed bin(6,0)           dcl 3701 in procedure "rel_exec_chan" ref 3699 3702
                                                                                  3703 3704 3704 3705 3706 3706 3720 3722
k                                      parameter       fixed bin(6,0)           dcl 3730 in procedure "rel_tst_chan" ref 3728 3732
                                                                                  3733 3734 3734 3735 3736 3736 3737 3756 3758
k                               000101 internal static fixed bin(6,0)           dcl 225 in procedure "mtdsim_" set ref 659 660 661
                                                                                  678 681 692 723 723 1875* 1926 1927 1929 1977 1990
                                                                                  2001 2004 2004 2006 2015 2030* 2032 2035 2041*
                                                                                  2043 2044 2045 2046 2046 2047 2048 2048 2054 2061
                                                                                  2063 2066 2077* 2078* 2080* 2091* 2094 2450* 2451
                                                                                  2453 3818* 3819 3819* 3821* 3822 3822*
key                       1            based           char(24)                 array level 2 dcl 318 set ref 1175 1255 1257 1257
                                                                                  1261 1263 1266 1268 1268 1272 1272 1274 1274 1281
                                                                                  1282 1282 1285 1285 1287 1287 1288 1288 1288 1291
                                                                                  1291 1409* 1420 1422 1446 1452*
l                               000100 internal static fixed bin(6,0)           dcl 225 set ref 582* 583 584 584 594 623* 624 625
                                                                                  625 635 653 654 665 666 667 725 1974*
l_pad                   530            based           structure                level 2 dcl 25-13
l_ptr                           000210 automatic       pointer                  dcl 207 set ref 1419* 1444* 1452* 1661* 1668*
last_mme                        000013 internal static fixed bin(17,0)          initial dcl 214 set ref 441* 826 826 826 833 838*
lbar                     33            based           structure                level 3 packed packed unaligned dcl 273 set ref 492*
                                                                                  493*
len                             000106 automatic       fixed bin(17,0)          initial dcl 189 set ref 189*
length                                                 builtin function         dcl 411 ref 1281
lginfo                          000320 automatic       char(100)                packed unaligned dcl 208 set ref 647* 648* 680* 681*
                                                                                  718* 719* 1897* 1898* 1946* 1947* 1979* 1980*
                                                                                  2003* 2004* 2053* 2054* 3536* 3538* 3538* 3540*
                                                                                  3540* 3541 3622* 3623* 3711* 3712* 3747* 3748*
                                                                                  3774* 3775* 3785* 3786*
list_of_dcw                            based           structure                level 2 packed packed unaligned dcl 11-25 set ref
                                                                                  3343
lockup                          000622 stack reference condition                dcl 409 ref 497
lostit_time             711            based           fixed bin(35,0)          level 2 dcl 21-155 set ref 1124* 1539* 1541 2143
                                                                                  2152 3005
lower                     0(18)        based           bit(18)                  array level 2 in structure "mme_call_hw" packed
                                                                                  packed unaligned dcl 259 in procedure "mtdsim_"
                                                                                  set ref 591 632 696 1674 1677 1678* 1733 1741 1748
                                                                                  1864 1875 1876 1881 1911 1962 1994 2019 2030 2032
                                                                                  2066 2076 2077 2078 2084 2091 2092
lower                     0(18)        based           fixed bin(17,0)          array level 2 in structure "mme_call_hf" packed
                                                                                  packed unaligned dcl 263 in procedure "mtdsim_"
                                                                                  ref 589 630 695 924 1021 1021 1074 1074 1076 1076
                                                                                  1717 1733 1739 1748 1909 1959 1993 2018 2082 2562
                                                                                  2562
lpw                       6            based           bit(36)                  array level 3 dcl 25-13 set ref 2242
lreg                     32            based           bit(36)                  level 3 packed packed unaligned dcl 273 set ref 491*
lstloc                          002004 automatic       fixed bin(17,0)          dcl 3377 set ref 3461* 3495 3503* 3504
lvl3                      1(18)        based           fixed bin(18,0)          level 4 packed packed unsigned unaligned dcl 23-16
                                                                                  set ref 2767
lvl3_cnt                 20            based           fixed bin(35,0)          level 2 dcl 20-15 set ref 2769* 2773 2780
lvl3_flag                16            based           bit(36)                  level 2 dcl 20-15 ref 2773 2780
lvl7                      1            based           fixed bin(18,0)          level 4 packed packed unsigned unaligned dcl 23-16
                                                                                  set ref 2765
lvl7_cnt                 21            based           fixed bin(35,0)          level 2 dcl 20-15 set ref 2771* 2773 2780
lvl7_flag                17            based           bit(36)                  level 2 dcl 20-15 ref 2773 2780
lvl_idx                         000144 automatic       fixed bin(17,0)          dcl 194 set ref 2278* 2281 2281 2283
m_iv_iom                               constant        fixed bin(18,0)          initial unsigned dcl 19-4 ref 908 2811
mailbox                                based           structure                level 2 dcl 23-16
mask                      0(21)        based           bit(1)                   level 2 packed packed unaligned dcl 13-6 set ref
                                                                                  2187*
max_to                  102            based           fixed bin(71,0)          level 2 dcl 21-75 set ref 957* 960* 2390*
max_wks_sz              104            based           fixed bin(19,0)          level 2 dcl 21-75 set ref 957* 960* 2390*
mbxloc                    3            based           fixed bin(35,0)          level 2 dcl 20-15 set ref 2410*
mc                                     based           structure                level 1 dcl 9-12
mc_ptr                          000560 automatic       pointer                  level 2 dcl 308 set ref 3257 3263*
mca_$attach_ipc                 000316 constant        entry                    external dcl 140 ref 2502
mca_$attach_mca                 000320 constant        entry                    external dcl 141 ref 932
mca_$detach_ipc                 000322 constant        entry                    external dcl 142 ref 2498 2518 3656
mca_$detach_mca                 000324 constant        entry                    external dcl 143 ref 3666
mca_$load_ipc                   000326 constant        entry                    external dcl 144 ref 3651
mca_$reset                      000336 constant        entry                    external dcl 148 ref 2976 3663
mca_$tandd_read_data            000330 constant        entry                    external dcl 145 ref 2984
mca_$tandd_write_data           000332 constant        entry                    external dcl 146 ref 2978
mca_$tandd_write_text           000334 constant        entry                    external dcl 147 ref 2981
mca_attach_state        712            based           fixed bin(17,0)          level 2 dcl 21-155 set ref 930 934* 1015 3660
mca_dcw_list                           based           structure                level 1 packed packed unaligned dcl 11-81
mca_gcata                              based           structure                array level 1 dcl 322 set ref 1253*
mca_io_type                            constant        fixed bin(17,0)          initial dcl 21-68 ref 930 1008 1015 1080 1090 1162
                                                                                  1188 1227 1252 1298 1426 2955 2975 3631 3963
mca_ioi_idx            2045            based           fixed bin(17,0)          level 2 dcl 21-155 set ref 932* 2498* 2502* 2518*
                                                                                  2976* 2978* 2981* 2984* 3651* 3656* 3663* 3666*
mca_work_space                         based           structure                level 1 unaligned dcl 11-25 set ref 3340*
mca_work_space_ptr              001612 automatic       pointer                  dcl 11-23 set ref 3339* 3340 3343 3351 3353 3353
mcad                                   based           structure                level 1 dcl 10-31
mcata_idx               713            based           fixed bin(17,0)          level 2 dcl 21-155 set ref 1163 1171 1177* 1179
                                                                                  1233* 1233 1298 1429*
mcata_keys              715            based           char(24)                 array level 2 dcl 21-155 set ref 1175* 1179
mcata_nkeys             714            based           fixed bin(17,0)          level 2 dcl 21-155 set ref 1174* 1175 1175* 1298
mcp                             001604 automatic       pointer                  dcl 9-10 set ref 801* 802 803
mcptr                                  parameter       pointer                  dcl 792 ref 790 801 3266 3266
mdr_io_type                            constant        fixed bin(17,0)          initial dcl 21-61 ref 1026 1116
mem_needed                      000142 automatic       fixed bin(35,0)          initial dcl 192 set ref 192*
mem_now                         000160 automatic       fixed bin(19,0)          dcl 200 set ref 1362* 1364* 2588* 2590* 2593* 2595*
mesg_len                        000114 automatic       fixed bin(17,0)          initial dcl 189 set ref 189* 606* 939* 945* 1666*
                                                                                  1671* 2379* 2942* 2948* 3528* 3529* 3533* 3536*
                                                                                  3538* 3540*
mess                                   parameter       char                     packed unaligned dcl 3620 set ref 3617 3623*
mess_buf               3334            based           structure                level 2 dcl 21-75
message                         000351 automatic       char(512)                packed unaligned dcl 208 in procedure "mtdsim_" set
                                                                                  ref 2942* 2944* 2948* 2950* 3528* 3529* 3529*
                                                                                  3533* 3533* 3541* 3541 3543* 3641* 3644 3644 3955*
                                                                                  3957 3957 3987* 3990 3990
message                   2     000160 internal static fixed bin(71,0)          level 2 in structure "event_out" dcl 310
                                                                                  in procedure "mtdsim_" set ref 603*
mhp_io_type                            constant        fixed bin(17,0)          initial dcl 21-67 ref 3388 3396
mme_call_hf                            based           structure                array level 1 dcl 263
mme_call_hw                            based           structure                array level 1 dcl 259
mme_call_w                             based           bit(36)                  array dcl 258 set ref 810 815* 1658* 1712* 1713 1713
                                                                                  1714* 1862* 2027 2910 2923 3079 3134* 3159 3526
mme_number                      000014 internal static fixed bin(17,0)          initial dcl 214 set ref 819* 820 820 820 820 820 820
                                                                                  826 826 826 833 838 839 2832 2867
mmep                            000124 internal static pointer                  dcl 230 set ref 589 590 591 630 631 632 695 696 697
                                                                                  808* 810 813 815 815* 819 850* 863* 875* 904* 924
                                                                                  1019 1021 1021 1074 1074 1076 1076 1158* 1313*
                                                                                  1325* 1355* 1356 1357 1359 1360 1361 1367 1368
                                                                                  1385* 1409* 1468* 1498* 1566* 1582* 1610* 1641*
                                                                                  1658 1659* 1661 1674 1677 1678 1682 1692* 1712*
                                                                                  1712 1713 1713 1714 1717 1718 1718 1719 1731 1733
                                                                                  1733 1739 1741 1742 1748 1748 1771* 1794* 1807*
                                                                                  1821* 1831* 1840* 1862* 1862 1864 1870 1875 1876
                                                                                  1881 1909 1910 1911 1959 1960 1962 1993 1994 1995
                                                                                  2018 2019 2020 2027 2030 2032 2032 2035 2041 2066
                                                                                  2076 2077 2078 2082 2083 2084 2091 2092 2092 2094
                                                                                  2108* 2109 2109 2121* 2136* 2139* 2165* 2180*
                                                                                  2212* 2225* 2237* 2269* 2352* 2490* 2560* 2561
                                                                                  2562 2562 2564 2576 2578 2580 2582 2584 2585 2586
                                                                                  2610* 2627* 2637 2666* 2694* 2715* 2727* 2743*
                                                                                  2801* 2832* 2853* 2867* 2895* 2896 2910 2922 2922
                                                                                  2923 2939 2941* 2947* 3017* 3052* 3060* 3074* 3079
                                                                                  3090* 3100* 3115* 3134* 3134 3134 3159 3305 3308
                                                                                  3308 3526
mname                                  parameter       char(6)                  packed unaligned dcl 3567 in procedure "get_px_sct"
                                                                                  set ref 3565 3586*
mname                                  parameter       char(6)                  packed unaligned dcl 3599 in procedure "get_px_tcx"
                                                                                  set ref 3597 3606*
model                     3            based           char(4)                  level 2 dcl 6-5 ref 2571 2572
mpc_io                          000025 internal static bit(1)                   initial dcl 215 set ref 3443 3472 3572* 3576* 3580*
mpxe                    204            based           structure                array level 3 in structure "cdt" dcl 3-44
                                                                                  in procedure "mtdsim_"
mpxe                                   based           structure                level 1 dcl 3-221 in procedure "mtdsim_"
mtar_io_type                           constant        fixed bin(17,0)          initial dcl 21-62 ref 977 1044 1122 3399
mtp610                 2150(08)        based           bit(1)                   level 3 packed packed unaligned dcl 21-155 set ref
                                                                                  3880
mult_ans              25340            based           varying char(28)         level 3 dcl 21-75 set ref 472* 476 477 1204* 1205
                                                                                  1205 1205 1214 1214 1214 1214 1214 1222 1222 3033*
                                                                                  3036 3037 3637 3637 3647 3647 3740 3740 3742 3742
                                                                                  3858 3860 3862 3864 3866 3868 3870 3872 3879 3879
                                                                                  3951 3952
mvp                             000070 internal static pointer                  initial dcl 224 set ref 1437* 1438 1531* 1533 3342*
                                                                                  3344 3346 3350* 3352 3485* 3500 3501* 3502 3503
n                                      based           fixed bin(17,0)          level 2 dcl 318 ref 1174 1251 1296
n_dialed                        000105 automatic       fixed bin(17,0)          initial dcl 189 set ref 189* 601* 603* 609*
n_keys                   44            based           fixed bin(17,0)          level 2 dcl 21-155 set ref 1164 1164 1182 1182 1187
                                                                                  1188 1190* 1192 1205 1222
n_read                          000131 internal static fixed bin(21,0)          dcl 231 set ref 716*
nargs                           000102 automatic       fixed bin(17,0)          initial dcl 189 set ref 189* 417* 425 426
nblk                      1(18)        based           fixed bin(17,0)          level 2 in structure "cata_call" packed packed
                                                                                  unaligned dcl 1152 in procedure "mtdsim_" ref 1409
                                                                                  1420 1422 1446 1452
nblk                      1(21)        based           fixed bin(14,0)          array level 2 in structure "gcata" packed packed
                                                                                  unaligned dcl 333 in procedure "mtdsim_" set ref
                                                                                  1284*
nblk                      1(18)        based           fixed bin(13,0)          array level 2 in structure "mca_gcata" packed packed
                                                                                  unaligned dcl 322 in procedure "mtdsim_" set ref
                                                                                  1254*
nchan                   522            based           fixed bin(17,0)          level 3 dcl 21-75 set ref 556 599* 599 1967* 1967
                                                                                  1968 2059* 2059 2060
ndcws                           000115 automatic       fixed bin(17,0)          initial dcl 189 set ref 189* 2896* 2897 2897 2898*
                                                                                  2922* 2923
new_mask                        000053 internal static bit(36)                  dcl 221 set ref 3145* 3146* 3146*
nff                    2051            based           bit(1)                   level 2 dcl 21-155 set ref 1099
no_blk                          000154 internal static label variable           dcl 235 set ref 490* 3168
nr_cnt                          000015 internal static fixed bin(17,0)          initial dcl 214 set ref 568 569* 572* 572 1940*
                                                                                  2050*
null                                                   builtin function         dcl 411 ref 444 538 538 640 640 713 730 731 735 1872
                                                                                  1872 1872 1884 1884 1884 1884 1894 1894 1908 1958
                                                                                  2565 2569 3172 3172 3251 3257 3266 3268 3830 3831
num_connects           2052            based           fixed bin(17,0)          level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 1545* 1545 3363*
                                                                                  3363 3557* 3557 3650* 3650 3662* 3662 3665* 3665
num_connects          33154            based           fixed bin(17,0)          array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 2167
num_int                   1            based           structure                level 3 dcl 23-16 set ref 1624* 2420* 2435 2442
                                                                                  2443*
nxtloc                          002005 automatic       fixed bin(17,0)          dcl 3377 set ref 3461* 3497 3504*
o                       531            based           bit(36)                  level 3 in structure "tolts_workspace" dcl 25-13
                                                                                  in procedure "mtdsim_" set ref 3384*
o                                      based           bit(36)                  level 3 in structure "tolts_workspace" dcl 25-13
                                                                                  in procedure "mtdsim_" set ref 3520*
offset                   67     000716 automatic       bit(18)                  array level 3 packed packed unaligned dcl 8-5 set
                                                                                  ref 495
old_mask                        000052 internal static bit(36)                  dcl 221 set ref 3144* 3145 3148* 3148*
operation                 0(30)        based           bit(6)                   level 2 packed packed unaligned dcl 24-23 ref 1521
                                                                                  1521 1529
opr_query_                      000340 constant        entry                    external dcl 149 ref 3644 3957 3990
opr_query_info                  001622 automatic       structure                level 1 dcl 15-8 set ref 3644 3644 3957 3957 3990
                                                                                  3990
opt_ptr                   2            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 2653 ref 2670
opt_temp                               based           structure                level 1 dcl 2653
option                  276            based           bit(504)                 array level 3 dcl 21-75 set ref 2671 2915*
optrd                   271            based           bit(1)                   array level 3 dcl 21-75 set ref 2911* 2919*
os_deny                                constant        fixed bin(18,0)          initial unsigned dcl 19-4 ref 954 990 1012 1086 1096
                                                                                  1111 1130 2511
out_pend                  2            based           bit(1)                   level 2 dcl 402 set ref 715
p2_att                 2053            based           bit(1)                   level 2 dcl 21-155 set ref 996 1026 1029* 1034* 1044
                                                                                  3679
p99                                    based           picture(2)               packed unaligned dcl 2487 ref 2501
p_att                 33156            based           bit(1)                   array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 3977
p_att                  2054            based           bit(1)                   level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 928 977 996 1033*
                                                                                  1044 2399* 3629
p_idcw                   14            based           bit(36)                  level 2 dcl 25-13 set ref 2190 2191 3385 3386 3441
                                                                                  3522 3533* 3966 3971
pad_char                        000170 automatic       bit(6)                   packed unaligned dcl 204 set ref 2913* 2915
page_base              2055            based           fixed bin(18,0)          level 2 unsigned dcl 21-155 set ref 3458*
pages                 31102            based           structure                array level 2 dcl 21-75 set ref 912 1503 1507 1508
                                                                                  1614 1619 1620 2272 2275 2276 2355 2358 2359 2746
                                                                                  2749 2750 2808* 3590 3602 3605 3610 3818 3825 3826
partrs                    6            based           fixed bin(35,0)          level 2 dcl 20-15 set ref 1622* 2412*
pcw                                    based           structure                level 1 dcl 13-6 in procedure "mtdsim_"
pcw                                    based           structure                level 3 in structure "tolts_rspd_workspace"
                                                                                  dcl 23-16 in procedure "mtdsim_" set ref 1513
                                                                                  1536* 2428
pcw_info                               based           structure                level 2 dcl 20-15 ref 1516
pcwa                   2056            based           bit(36)                  level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 1528* 3359* 3553*
pcwa                            000161 automatic       bit(36)                  packed unaligned dcl 201 in procedure "mtdsim_" set
                                                                                  ref 2184* 2185 2195* 2989* 3359 3522* 3525* 3553
                                                                                  3970* 3978*
pcwp                            001616 automatic       pointer                  dcl 13-4 set ref 2185* 2186 2187 2188
pf_iocbp                114            based           pointer                  level 2 dcl 21-75 set ref 3263* 3269* 3273* 3274*
plen                            002121 automatic       fixed bin(17,0)          dcl 3803 set ref 3806*
polt_io_type                           constant        fixed bin(17,0)          initial dcl 21-59 ref 2817
prim                      4            based           structure                level 2 packed packed unaligned dcl 345
printer_images_$image_base      000456 external static fixed bin(17,0)          dcl 243 set ref 2636
printer_images_$image_numbers   000462 external static fixed bin(17,0)          array dcl 245 ref 2629
printer_images_$image_offsets   000460 external static fixed bin(18,0)          array dcl 244 ref 2636
printer_images_$n_images        000454 external static fixed bin(17,0)          dcl 242 ref 2629 2631
probe                           000352 constant        entry                    external dcl 155 ref 435 528 3031 3200
process                 126            based           bit(36)                  level 2 dcl 21-75 set ref 538* 3172*
program_interrupt               000666 stack reference condition                dcl 409 ref 537
prt_image                              based           char(288)                array packed unaligned dcl 252 set ref 2638* 2638
ptime                           002115 automatic       char(16)                 packed unaligned dcl 3802 set ref 3806* 3808
ptrain                 2162            based           fixed bin(14,0)          level 4 packed packed unaligned dcl 21-155 set ref
                                                                                  2629 2632*
purpose                   3            based           bit(36)                  array level 2 packed packed unaligned dcl 333 set
                                                                                  ref 1288* 1292*
px                                     parameter       fixed bin(17,0)          dcl 3568 in procedure "get_px_sct" ref 3565 3571
                                                                                  3573 3575 3577 3581 3586 3586
px                                     parameter       fixed bin(17,0)          dcl 3287 in procedure "set_sctwrk" set ref 3285
                                                                                  3308* 3310 3311 3312 3312 3313 3314 3316 3317 3318
                                                                                  3319 3320 3324 3325 3326 3327
q                        45            based           bit(36)                  level 3 packed packed unaligned dcl 273 set ref 1159
                                                                                  1159 1159 1161 1161 1414 1414 1414 1416 1416 1569*
                                                                                  1679* 1772 2122* 2148* 2152* 2411* 2492 2492 2492
                                                                                  2494 2494 2760* 3005* 3076
q_flag                          000034 internal static bit(1)                   initial dcl 215 set ref 415* 430* 533 3838
q_sw                      1     001622 automatic       bit(1)                   level 2 dcl 15-8 set ref 3640* 3953* 3989*
quit                            000614 stack reference condition                dcl 409 ref 532
quith_event             130            based           fixed bin(71,0)          level 2 dcl 21-75 set ref 538*
rbuf_addr                 0(18)        based           bit(18)                  level 2 in structure "ticm" packed packed unaligned
                                                                                  dcl 392 in procedure "mtdsim_" set ref 1904* 1954*
rbuf_addr                 0(18)        based           bit(18)                  level 2 in structure "wicm" packed packed unaligned
                                                                                  dcl 391 in procedure "mtdsim_" ref 1871
rcp_$attach                     000342 constant        entry                    external dcl 150 ref 2381
rcp_$check_attach               000344 constant        entry                    external dcl 151 ref 957 960 2390
rcp_$detach                     000346 constant        entry                    external dcl 153 ref 3669 3680
rcp_area               2057            based           fixed bin(17,0)          initial array level 2 dcl 21-155 set ref 941 941 957
                                                                                  957 980 2381 2381 2390 2390 3851
rcp_id                 2107            based           bit(36)                  level 2 dcl 21-155 set ref 941* 957* 1030 2381*
                                                                                  2390* 3669*
rcp_name               2110            based           char(32)                 level 2 dcl 21-155 set ref 941* 947* 1077 2381*
rcp_priv_$attach                000350 constant        entry                    external dcl 154 ref 941 947
rcp_state              2120            based           fixed bin(17,0)          level 2 dcl 21-155 set ref 957* 960* 1015 2390* 2392
rd_blk                          000031 internal static bit(1)                   initial dcl 215 set ref 442* 765 767* 1841*
rd_flag                         000035 internal static bit(1)                   initial dcl 215 set ref 925* 926* 939 939 945 945
                                                                                  982 984* 1047 1050* 1056* 1074 2379 2379
reboot                    0(18)        based           bit(1)                   level 3 packed packed unaligned dcl 2480 set ref
                                                                                  2518*
record_count              4(30)        based           bit(6)                   level 3 in structure "io_entry" packed packed
                                                                                  unaligned dcl 345 in procedure "mtdsim_" ref 3402
                                                                                  3428
record_count              7(30)        based           bit(6)                   level 3 in structure "io_entry" packed packed
                                                                                  unaligned dcl 345 in procedure "mtdsim_" ref 3416
reg_move                               based           bit(288)                 dcl 255 ref 756 803 1699 1781
reg_ptr                   0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1765 ref 1780
regs                     20            based           structure                level 2 in structure "mc" packed packed unaligned
                                                                                  dcl 9-12 in procedure "mtdsim_" set ref 803
regs                     40            based           structure                level 2 in structure "spa" packed packed unaligned
                                                                                  dcl 273 in procedure "mtdsim_" set ref 491 756
                                                                                  803* 1699* 1781* 3117 3117 3834 3834
rel                                                    builtin function         dcl 411 ref 491 494 1092 1092 2027 2190 2408 2408
                                                                                  2923 3079 3159 3385 3431 3433 3435 3452 3502 3503
                                                                                  3517 3517 3523 3971 4032
release_chan           2121            based           bit(1)                   level 2 dcl 21-155 set ref 3409* 3972*
remote_inquiry_ic               000110 internal static fixed bin(17,0)          dcl 228 set ref 661 667 672* 2027* 2039
ret                      34            based           bit(36)                  level 3 packed packed unaligned dcl 273 set ref 494*
return_value                    000103 automatic       fixed bin(17,0)          initial dcl 189 set ref 189*
return_word             273            based           bit(36)                  array level 3 dcl 21-75 set ref 2908* 2909* 2912*
                                                                                  2920*
rew_wait               2122            based           bit(1)                   level 2 dcl 21-155 set ref 3361* 3555*
ricm                                   based           structure                level 1 packed packed unaligned dcl 390 set ref
                                                                                  1906* 1956*
ricmp                           000072 internal static pointer                  initial dcl 224 in procedure "mtdsim_" set ref 444*
                                                                                  693 1871* 1906 1956 1991 2016
ricmp                     2            based           pointer                  initial level 2 in structure "gicm" dcl 382
                                                                                  in procedure "mtdsim_" set ref 693* 716* 731*
                                                                                  1872* 1991* 2016*
rtrim                                                  builtin function         dcl 411 ref 477 1281 3037 3541
s_add                                  parameter       fixed bin(17,0)          dcl 3912 ref 3910 3914
sb_data_idx                     000171 automatic       fixed bin(17,0)          dcl 205 set ref 2280* 2281
sct_add                   2(05)        based           bit(13)                  level 2 packed packed unaligned dcl 345 ref 2954
                                                                                  2954 3422 3443 3472
sct_info              33266            based           structure                array level 3 dcl 21-75 set ref 3313
sctwrk                                 based           bit(36)                  array packed unaligned dcl 257 set ref 3306* 3310*
                                                                                  3313* 3314* 3316* 3317* 3318* 3319* 3320* 3325*
                                                                                  3326* 3327*
scu                                    based           structure                level 1 dcl 9-56 in procedure "mtdsim_"
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed packed
                                                                                  unaligned dcl 9-12 in procedure "mtdsim_" set ref
                                                                                  802
scup                            001606 automatic       pointer                  dcl 9-54 set ref 802* 804 808 3222 4035 4036
second                    7            based           structure                level 2 packed packed unaligned dcl 345
seek_add                 11            based           bit(36)                  level 2 dcl 25-13 set ref 3431 3434* 3529*
seek_dcw                 13            based           bit(36)                  level 2 dcl 25-13 set ref 3429 3529*
seek_idcw                12            based           bit(36)                  level 2 dcl 25-13 set ref 3420 3435 3529*
shortinfo                       000316 automatic       char(8)                  packed unaligned dcl 208 set ref 647* 680* 718*
                                                                                  1897* 1946* 1979* 2003* 2053* 3622* 3711* 3747*
                                                                                  3774* 3785*
sicm                      0(03) 000466 external static bit(1)                   initial level 2 packed packed unaligned dcl 375 set
                                                                                  ref 587* 628* 677 699* 1973*
spa                                    based           structure                level 1 dcl 273
spec_cnt                  4            based           fixed bin(35,0)          level 2 dcl 20-15 set ref 2765* 2771
special_fault           132            based           bit(1)                   level 2 dcl 21-75 set ref 702 703*
st_addr                   5            based           fixed bin(17,0)          level 2 dcl 382 set ref 697* 723 725 1995* 2020*
stackp                          000112 automatic       pointer                  dcl 3245 set ref 3249* 3250*
stat_p                   11            based           bit(18)                  level 2 packed packed unaligned dcl 345 ref 3356
                                                                                  3489 3550
state                   204            based           fixed bin(17,0)          array level 4 dcl 3-44 ref 1593 1596
status                                 based           structure                level 2 dcl 25-13 set ref 1092 1092
status_add             2126            based           fixed bin(17,0)          level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 2145 3356* 3357
                                                                                  3358 3550* 3551 3552
status_add              267            based           fixed bin(17,0)          level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 748 749 751* 1742*
status_event           2130            based           fixed bin(71,0)          level 2 dcl 21-155 set ref 917* 932* 941* 947* 2373*
                                                                                  2381* 3687*
status_word               2            based           bit(36)                  level 3 in structure "tolts_rspd_workspace"
                                                                                  dcl 23-16 in procedure "mtdsim_" set ref 1625*
                                                                                  2408 2408 2753 2756 2760
status_word             565            based           bit(36)                  initial array level 3 in structure "tolts_info"
                                                                                  dcl 21-75 in procedure "mtdsim_" set ref 723 1369*
status_word           27475            based           bit(36)                  initial array level 3 in structure "tolts_info"
                                                                                  dcl 21-75 in procedure "mtdsim_" set ref 594* 635*
                                                                                  653* 666* 725 1369* 2006* 2094
store                           000660 stack reference condition                dcl 409 ref 522
string                                                 builtin function         dcl 411 set ref 492* 493* 757 758* 769 769 769 769
                                                                                  804 1700* 1721 1721 1726 1726 1779* 2146 2146
                                                                                  2192* 2961 2961 2992 2992 3430* 3448 3451* 3464
                                                                                  3465 3487 4034 4036
substr                                                 builtin function         dcl 411 set ref 454 456 456 462 462 576 584 584 617
                                                                                  618 618 625 625 646 658 661 667 810 1026 1026 1100
                                                                                  1101 1104 1105 1159 1159 1159 1161 1161 1179 1190
                                                                                  1190 1190 1190 1193 1195 1195 1195 1195 1195 1195
                                                                                  1195 1206 1207 1207 1207 1207 1207 1207 1207 1274
                                                                                  1274 1282 1282 1285 1285 1287 1287 1288 1288 1291
                                                                                  1291 1292* 1360* 1414 1414 1414 1416 1416 1498
                                                                                  1498 1511 1515* 1515 1516* 1516 1523* 1531 1662
                                                                                  1773 1808 1864 1875 1876 1877 1881 1883 1892 1915
                                                                                  1926 1936 1939 1947 1947 1969 1970 2004 2004 2030
                                                                                  2032 2035* 2041 2046 2061 2063 2066 2077 2078 2091
                                                                                  2092 2137 2137 2138 2181 2181 2181 2183 2183 2238
                                                                                  2238 2238 2240 2240 2278 2279 2280 2450 2492 2492
                                                                                  2492 2494 2494 2501 2585* 2695 2756 2910 2912 2913
                                                                                  2915* 2920 3310* 3314* 3320* 3327* 3526 3644 3644
                                                                                  3704 3734 3806 3806 3806 3806 3806 3806 3806 3806
                                                                                  3852 3890 3892 3894 3896 3898 3900 3902 3904 3957
                                                                                  3957 3990 3990 4029
suspend_chan           2132            based           bit(1)                   level 2 dcl 21-155 set ref 2957 2963* 3407* 3417*
                                                                                  3639* 3656
sys_info$alrm_mask              000464 external static bit(36)                  dcl 246 ref 3145
t_err                           000117 automatic       fixed bin(17,0)          initial dcl 189 set ref 189* 2364* 2368 3307* 3308*
                                                                                  3309
t_ptr                           000204 automatic       pointer                  dcl 207 set ref 454* 460* 1420* 1430* 1430 1438
                                                                                  1444* 1452* 1662* 1664* 1668*
tadio                   271            based           structure                array level 2 dcl 21-75
tags                            000336 constant        char(1)                  initial array packed unaligned dcl 795 set ref 1596*
tally                           000116 automatic       fixed bin(17,0)          initial dcl 189 in procedure "mtdsim_" set ref 189*
                                                                                  1431* 1432* 1433 1435
tally                     6            based           fixed bin(21,0)          level 2 in structure "gicm" dcl 382 in procedure
                                                                                  "mtdsim_" set ref 694* 716 1992* 2017*
tally                     0(24)        based           bit(12)                  level 2 in structure "dcw" packed packed unaligned
                                                                                  dcl 12-7 in procedure "mtdsim_" set ref 1431 1432
                                                                                  1725 3347 3348 3432* 3453* 3486
tape_info                              based           structure                level 1 dcl 18-15
tape_info_ptr                   001700 automatic       pointer                  dcl 18-10 set ref 3851* 3852 3890 3892 3894 3896
                                                                                  3898 3900 3902 3904
tcd                             000036 internal static bit(1)                   initial dcl 215 set ref 433* 1158 1249 1408 1452
tci                                    parameter       bit(11)                  packed unaligned dcl 3600 set ref 3597 3602 3606*
tcont                                  parameter       bit(1)                   packed unaligned dcl 794 ref 790
tcw                     107            based           structure                level 2 dcl 23-16 set ref 1519 1524 1537*
tcw_address                            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 24-23
                                                                                  set ref 1524* 1527*
temp01                   10            based           structure                level 2 dcl 20-15
temp02                   12            based           structure                level 2 dcl 20-15
temp03                   14            based           structure                level 2 dcl 20-15
term                            000016 internal static bit(1)                   initial dcl 215 set ref 424* 544* 545 706* 2566*
                                                                                  2567 2569* 3018* 3226* 3832*
term_cnt                  5            based           fixed bin(35,0)          level 2 dcl 20-15 set ref 2767* 2769
term_io_req_cnt         134            based           fixed bin(17,0)          level 2 dcl 21-75 ref 3168 3838 4001
term_lbl                        000150 internal static label variable           dcl 234 set ref 489* 3019 3227
terminate_process_              000354 constant        entry                    external dcl 156 ref 552 3177 3716 3752 3779 3790
test_hdr               2136            based           char(16)                 level 2 dcl 21-155 set ref 1003* 1190* 2506* 3633*
                                                                                  3641* 3853* 3946* 3955* 3987*
test_req               2165            based           structure                level 2 dcl 21-155 set ref 2364 2364
text_len                  1(18) 000716 automatic       bit(18)                  level 2 packed packed unaligned dcl 8-5 set ref 1364
                                                                                  1450 2590 2595
tfc                             000100 automatic       bit(18)                  packed unaligned dcl 3218 set ref 3220* 3221
ticm                                   based           structure                level 1 packed packed unaligned dcl 392 set ref 1878
                                                                                  1879 1880* 1906 1907 1950 1951 1952* 1956 1957
                                                                                  3831
ticmp                           000074 internal static pointer                  initial dcl 224 set ref 444* 1878* 1879* 1879 1880
                                                                                  1883 1892 1894 1894 1900 1902 1904 1905* 1906 1907
                                                                                  1908* 1950* 1951* 1951 1952 1953 1954 1955* 1956
                                                                                  1957 1958* 3831 3831
tim                             002112 automatic       char(12)                 packed unaligned dcl 3801 set ref 3805* 3806 3806
                                                                                  3806 3806 3806 3806 3806 3806
time                                                   builtin function         dcl 411 ref 3805
timeout_time              7            based           bit(36)                  level 2 in structure "tolts_fpinfo" dcl 20-15
                                                                                  in procedure "mtdsim_" set ref 1539 1540 1541*
                                                                                  1541 2756 2773
timeout_time                    000152 automatic       fixed bin(52,0)          initial dcl 197 in procedure "mtdsim_" set ref 197*
                                                                                  1115* 1116* 1119* 1122* 1124 1126*
timer_manager_$alarm_wakeup     000356 constant        entry                    external dcl 157 ref 3077 3932 3975
timer_manager_$reset_alarm_wakeup
                                000362 constant        entry                    external dcl 159 ref 2966 2996 3930 3973
timer_manager_$sleep            000360 constant        entry                    external dcl 158 ref 571 1553
tio                             000107 automatic       fixed bin(17,0)          initial dcl 189 set ref 189* 441* 2951* 2951 2952*
tio_off                2142            based           fixed bin(18,0)          level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 3360* 3554*
tio_off                         000151 automatic       fixed bin(18,0)          dcl 197 in procedure "mtdsim_" set ref 1538* 1546*
                                                                                  2190* 2195* 2989* 3385* 3435* 3523* 3554 3971*
                                                                                  3978*
to_no_cc               2143            based           bit(1)                   level 2 dcl 21-155 set ref 2194*
tolts_active                    000042 internal static bit(1)                   initial dcl 217 set ref 450* 782 3142 3842*
tolts_alm_util_$ascii_to_bcd_   000364 constant        entry                    external dcl 160 ref 1274 1283 1285 1287 1288 1291
                                                                                  1358 2583 3220
tolts_alm_util_$enter_ccc_req_  000366 constant        entry                    external dcl 161 ref 591 632 726 747 1733 1748 1911
                                                                                  1962 2084 2146 2961 2992
tolts_alm_util_$enter_slave_    000370 constant        entry                    external dcl 162 ref 777
tolts_alm_util_$gen_ck_sum      000372 constant        entry                    external dcl 163 ref 1905 1955
tolts_alrm_util_$quit           000374 constant        entry                    external dcl 164 ref 533
tolts_device_info_              000376 constant        entry                    external dcl 165 ref 2364 3308
tolts_error_                    000702 stack reference condition                dcl 409 ref 527 554 565 3179 3718 3754 3781 3792
tolts_file_util_$close          000400 constant        entry                    external dcl 166 ref 2869 3118 3204 3835
tolts_file_util_$open           000402 constant        entry                    external dcl 167 ref 2835 3194
tolts_file_util_$snap           000404 constant        entry                    external dcl 168 ref 2109
tolts_file_util_$wdump          000406 constant        entry                    external dcl 169 ref 3117 3203 3834
tolts_fpinfo                           based           structure                level 1 dcl 20-15
tolts_fpinfo_ptr                001702 automatic       pointer                  dcl 20-13 set ref 1501* 1503 1509 1511 1516 1518
                                                                                  1523 1539 1540 1541 1541 1542 1542 1612* 1614 1622
                                                                                  1623 2271* 2272 2354* 2355 2360 2410 2412 2435
                                                                                  2442 2450 2452 2745* 2746 2754 2754 2754 2756 2765
                                                                                  2767 2769 2769 2769 2771 2771 2771 2773 2773 2773
                                                                                  2773 2773 2778 2778 2778 2780 2780 2780 2780
tolts_info                             based           structure                level 1 dcl 21-75
tolts_infop                     000470 external static pointer                  dcl 21-71 ref 454 460 468 472 476 477 482 483 491
                                                                                  491 492 493 494 494 495 496 538 538 546 546 556
                                                                                  557 557 561 577 583 584 584 584 590 591 591 594
                                                                                  599 599 618 624 625 625 625 631 632 632 635 648
                                                                                  653 654 659 660 661 665 666 667 678 681 681 689
                                                                                  692 702 703 706 707 719 723 723 723 725 725 726
                                                                                  726 744 745 747 747 747 748 748 749 749 749 751
                                                                                  751 754 756 756 757 757 758 758 759 759 760 761
                                                                                  761 769 769 769 769 769 769 777 777 783 803 804
                                                                                  808 851 876 905 905 907 908 908 912 954 957 957
                                                                                  960 960 990 1001 1012 1021 1021 1022 1022 1074
                                                                                  1074 1076 1076 1082 1086 1089 1096 1111 1130 1159
                                                                                  1159 1159 1161 1161 1164 1169 1182 1204 1205 1205
                                                                                  1205 1214 1214 1214 1214 1214 1222 1222 1238 1241
                                                                                  1246 1246 1247 1248 1296 1314 1314 1315 1315 1356
                                                                                  1357 1359 1360 1361 1366 1367 1368 1369 1369 1386
                                                                                  1411 1411 1414 1414 1414 1416 1416 1417 1417 1418
                                                                                  1419 1420 1427 1430 1433 1433 1437 1439 1441 1444
                                                                                  1444 1450 1452 1469 1469 1498 1498 1501 1501 1503
                                                                                  1503 1507 1508 1511 1511 1515 1516 1518 1523 1528
                                                                                  1531 1531 1554 1554 1567 1567 1568 1569 1585 1586
                                                                                  1587 1588 1588 1589 1589 1591 1591 1595 1612 1612
                                                                                  1614 1614 1619 1620 1642 1661 1662 1662 1664 1668
                                                                                  1668 1674 1674 1677 1679 1682 1699 1699 1700 1700
                                                                                  1717 1718 1718 1730 1733 1733 1741 1742 1743 1748
                                                                                  1748 1772 1772 1773 1773 1774 1775 1776 1777 1779
                                                                                  1780 1781 1808 1808 1870 1871 1898 1910 1911 1911
                                                                                  1916 1918 1923 1926 1927 1927 1929 1933 1933 1934
                                                                                  1935 1936 1936 1937 1937 1938 1938 1939 1943 1945
                                                                                  1947 1947 1947 1960 1962 1962 1967 1967 1968 1968
                                                                                  1968 1969 1970 1977 1980 1986 1990 2001 2004 2004
                                                                                  2004 2006 2012 2015 2032 2035 2043 2044 2045 2046
                                                                                  2046 2047 2047 2048 2048 2054 2054 2059 2059 2060
                                                                                  2060 2060 2061 2063 2066 2083 2084 2084 2092 2094
                                                                                  2094 2109 2122 2123 2123 2137 2137 2138 2144 2145
                                                                                  2146 2146 2148 2151 2152 2166 2166 2167 2167 2181
                                                                                  2181 2181 2183 2183 2238 2238 2238 2240 2240 2241
                                                                                  2242 2271 2271 2272 2272 2275 2276 2278 2279 2280
                                                                                  2283 2352 2354 2354 2355 2355 2358 2359 2361 2390
                                                                                  2390 2401 2407 2411 2428 2453 2492 2492 2492 2494
                                                                                  2494 2495 2495 2496 2505 2511 2561 2562 2564 2576
                                                                                  2578 2580 2582 2584 2585 2586 2598 2612 2613 2628
                                                                                  2628 2637 2667 2667 2669 2670 2671 2695 2695 2697
                                                                                  2697 2745 2745 2746 2746 2749 2750 2760 2802 2804
                                                                                  2808 2810 2811 2811 2815 2816 2816 2817 2834 2854
                                                                                  2854 2869 2901 2903 2907 2908 2909 2911 2912 2912
                                                                                  2913 2915 2919 2920 2920 2923 2939 2961 2961 2965
                                                                                  2966 2967 2968 2992 2992 2995 2996 2997 2998 3003
                                                                                  3004 3005 3006 3007 3007 3032 3033 3036 3037 3038
                                                                                  3039 3076 3077 3078 3079 3116 3117 3117 3120 3120
                                                                                  3143 3159 3168 3168 3168 3172 3172 3194 3201 3203
                                                                                  3221 3222 3223 3229 3229 3263 3269 3273 3274 3305
                                                                                  3306 3308 3308 3309 3310 3311 3312 3313 3316 3317
                                                                                  3318 3319 3324 3325 3326 3338 3342 3350 3357 3358
                                                                                  3433 3434 3447 3478 3485 3551 3552 3584 3584 3590
                                                                                  3602 3602 3605 3610 3623 3637 3637 3647 3647 3694
                                                                                  3694 3702 3703 3704 3704 3705 3705 3706 3706 3712
                                                                                  3720 3722 3732 3733 3734 3734 3735 3735 3736 3736
                                                                                  3737 3740 3740 3742 3742 3748 3756 3758 3759 3759
                                                                                  3775 3786 3818 3819 3821 3822 3825 3826 3833 3834
                                                                                  3834 3838 3838 3858 3860 3862 3864 3866 3868 3870
                                                                                  3872 3879 3879 3914 3915 3915 3916 3916 3917 3917
                                                                                  3918 3918 3919 3920 3920 3930 3931 3932 3933 3934
                                                                                  3935 3935 3944 3951 3952 3973 3974 3975 3976 3977
                                                                                  3981 3981 3983 3984 3984 4001 4002 4002 4029 4030
                                                                                  4031 4032 4032 4034 4034 4035 4036
tolts_init_                     000412 constant        entry                    external dcl 171 ref 445
tolts_init_$clean_up            000414 constant        entry                    external dcl 172 ref 457 464 3841
tolts_init_$cr_event_chan       000416 constant        entry                    external dcl 173 ref 917 2373
tolts_init_$gc_tod              000440 constant        entry                    external dcl 182 ref 851 1540 1778 2122 2142 2752
                                                                                  3003 4033
tolts_io_int_                   000420 constant        entry                    external dcl 174 ref 917 917 2373 2373
tolts_load_firmware_            000410 constant        entry                    external dcl 170 ref 2699 3941
tolts_qttyio_                   000422 constant        entry                    external dcl 175 ref 540 1217 2944 2950 3543
tolts_qttyio_$dcw_list          000424 constant        entry                    external dcl 176 ref 1021 1751
tolts_qttyio_$dcw_ptr           000426 constant        entry                    external dcl 177 ref 2922
tolts_qttyio_$rcw               000430 constant        entry                    external dcl 178 ref 3120
tolts_qttyio_$rs                000432 constant        entry                    external dcl 179 ref 473 577 584 618 625 648 681 689
                                                                                  719 769 815 850 863 875 904 1003 1158 1190 1195
                                                                                  1201 1207 1249 1313 1325 1355 1385 1409 1452 1468
                                                                                  1498 1566 1582 1596 1610 1641 1659 1692 1694 1712
                                                                                  1714 1721 1726 1771 1794 1807 1821 1831 1840 1862
                                                                                  1898 1919 1947 1980 1986 2004 2012 2054 2071 2108
                                                                                  2121 2136 2139 2165 2180 2212 2225 2237 2269 2352
                                                                                  2490 2499 2506 2560 2610 2627 2632 2666 2694 2715
                                                                                  2727 2743 2801 2805 2832 2853 2867 2895 2898 2904
                                                                                  2941 2947 2952 3017 3034 3052 3060 3074 3090 3100
                                                                                  3115 3134 3490 3586 3606 3623 3633 3635 3712 3737
                                                                                  3738 3748 3775 3786 3853 3856 3875 3877 3882 3886
                                                                                  3946 3948
tolts_rspd_wksp        2134            based           pointer                  level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 1510 1621 2277
                                                                                  2400* 2401* 2417 2425 2432 2439 2447 2751
tolts_rspd_wksp                 001710 automatic       pointer                  dcl 23-14 in procedure "mtdsim_" set ref 1510* 1513
                                                                                  1519 1524 1532 1536 1537 1621* 1624 1625 2277*
                                                                                  2281 2281 2283 2400 2408 2408 2417* 2420 2425*
                                                                                  2428 2432* 2435 2439* 2442 2443 2447* 2451 2453
                                                                                  2751* 2753 2756 2760 2765 2767
tolts_rspd_workspace                   based           structure                level 1 dcl 23-16 set ref 2400
tolts_util_$cata_sel            000434 constant        entry                    external dcl 180 ref 1164 1182
tolts_util_$find_card           000436 constant        entry                    external dcl 181 ref 2568
tolts_util_$get_ttl_date        000442 constant        entry                    external dcl 183 ref 449
tolts_util_$search              000444 constant        entry                    external dcl 184 ref 454 1169 1241 1420 1662 1664
tolts_workspace                        based           structure                level 1 dcl 25-13
tp                              000200 automatic       pointer                  dcl 207 set ref 2636* 2638
tptr1                                  parameter       pointer                  dcl 792 ref 790
tptr2                                  parameter       pointer                  dcl 792 ref 790
trace                           000040 internal static bit(1)                   initial dcl 215 set ref 415* 432* 769 824 825 830*
                                                                                  834* 850 863 875 904 1158 1249 1313 1325 1355 1385
                                                                                  1408 1452 1468 1498 1566 1582 1610 1641 1659 1692
                                                                                  1712 1771 1794 1807 1821 1831 1840 1862 2108 2121
                                                                                  2136 2165 2180 2212 2225 2237 2269 2352 2490 2560
                                                                                  2610 2627 2666 2694 2715 2727 2743 2801 2832 2853
                                                                                  2867 2895 2940 3017 3052 3060 3074 3090 3100 3115
trace_io                        000037 internal static bit(1)                   initial dcl 215 set ref 415* 434* 609 1498 1692 2946
trace_save                      000026 internal static bit(1)                   initial dcl 215 set ref 442* 769 824 829* 835*
train_ptr                       000176 automatic       pointer                  dcl 207 set ref 2637* 2638
ttl_date                        000050 internal static char(6)                  packed unaligned dcl 220 set ref 449* 1358* 2583*
type                    120            based           fixed bin(17,0)          array level 3 in structure "cdt" dcl 3-44
                                                                                  in procedure "mtdsim_" ref 1587
type                      0(22)        based           bit(2)                   level 2 in structure "dcw" packed packed unaligned
                                                                                  dcl 12-7 in procedure "mtdsim_" set ref 1720 3478
                                                                                  3511
type                    570            based           fixed bin(17,0)          array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 1587* 1588 1589
                                                                                  1591
type_code              2161            based           bit(6)                   level 4 in structure "io_info" packed packed
                                                                                  unaligned dcl 21-155 in procedure "mtdsim_" set
                                                                                  ref 926 1116
type_code             33263            based           bit(6)                   array level 5 in structure "tolts_info" packed
                                                                                  packed unaligned dcl 21-75 in procedure "mtdsim_"
                                                                                  set ref 3310
type_code             27476            based           bit(6)                   initial array level 3 in structure "tolts_info"
                                                                                  packed packed unaligned dcl 21-75 in procedure
                                                                                  "mtdsim_" set ref 1939* 2035
unspec                                                 builtin function         dcl 411 set ref 756* 803* 1253* 1276* 1280* 1515
                                                                                  1516 1520* 1520 1523 1537* 1537 1568 1569 1624*
                                                                                  1699* 1781* 2420* 2428 2435* 2435 2442* 2442 2443*
                                                                                  2451* 2769 2771 2808* 3313 3316 3317 3318 3319
                                                                                  3325 3326 3340* 3382* 3460* 3693* 3965*
upper                    14            based           bit(18)                  level 4 in structure "tolts_fpinfo" packed packed
                                                                                  unaligned dcl 20-15 in procedure "mtdsim_" set ref
                                                                                  2450
upper                                  based           fixed bin(17,0)          array level 2 in structure "mme_call_hf" packed
                                                                                  packed unaligned dcl 263 in procedure "mtdsim_"
                                                                                  set ref 590 631 697 819 1356 1359 1360 1361 1367
                                                                                  1368 1661 1718 1718 1731 1742 1870 1910 1960 1995
                                                                                  2020 2083 2092 2094 2561 2564 2576 2578 2580 2584
                                                                                  2585 2586 2637 2896 2939 3134* 3305 3308 3308
upper                                  based           bit(18)                  array level 2 in structure "mme_call_hw" packed
                                                                                  packed unaligned dcl 259 in procedure "mtdsim_"
                                                                                  set ref 813 1019 1357 1682 1719 2032* 2035* 2041
                                                                                  2582
upper                    12            based           bit(18)                  level 4 in structure "tolts_fpinfo" packed packed
                                                                                  unaligned dcl 20-15 in procedure "mtdsim_" ref
                                                                                  2452
version                         000556 automatic       fixed bin(17,0)          level 2 in structure "fatal_desc" dcl 304
                                                                                  in procedure "mtdsim_" set ref 550* 3175* 3714*
                                                                                  3750* 3777* 3788*
version               27334            based           fixed bin(17,0)          array level 4 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 1935* 3733*
version                 672            based           fixed bin(17,0)          array level 4 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 2045* 3703*
w1                     2161            based           structure                level 3 in structure "io_info" packed packed
                                                                                  unaligned dcl 21-155 in procedure "mtdsim_" set
                                                                                  ref 1568
w1                    33263            based           structure                array level 4 in structure "tolts_info" packed
                                                                                  packed unaligned dcl 21-75 in procedure "mtdsim_"
                                                                                  set ref 3318
w1                    33250            based           structure                array level 4 in structure "tolts_info" packed
                                                                                  packed unaligned dcl 21-75 in procedure "mtdsim_"
                                                                                  set ref 3325
w1                     2146            based           structure                level 3 in structure "io_info" packed packed
                                                                                  unaligned dcl 21-155 in procedure "mtdsim_"
w2                    33264            based           structure                array level 4 in structure "tolts_info" packed
                                                                                  packed unaligned dcl 21-75 in procedure "mtdsim_"
                                                                                  set ref 3319
w2                    33251            based           structure                array level 4 in structure "tolts_info" packed
                                                                                  packed unaligned dcl 21-75 in procedure "mtdsim_"
                                                                                  set ref 3326
w2                     2162            based           structure                level 3 in structure "io_info" packed packed
                                                                                  unaligned dcl 21-155 in procedure "mtdsim_" set
                                                                                  ref 1569
wait_event_id           524            based           fixed bin(71,0)          array level 3 dcl 21-75 set ref 557 561* 1968* 2060*
                                                                                  3172*
wait_list               522            based           structure                level 2 dcl 21-75 set ref 546 546 3935 3935 3984
                                                                                  3984 4002 4002
wake_time                       000156 automatic       fixed bin(71,0)          initial dcl 199 set ref 199* 570* 571* 1552* 1553*
                                                                                  3076* 3077*
wicm                                   based           structure                level 1 packed packed unaligned dcl 391 ref 1880
                                                                                  1952
wicmp                           000076 internal static pointer                  initial dcl 224 set ref 444* 678* 678 694 1870* 1871
                                                                                  1874 1877 1880 1891 1915 1939 1952 1977* 1977 1992
                                                                                  2001* 2001 2017
wks_init                               based           char(660)                packed unaligned dcl 25-40 set ref 3382* 3965*
wks_sz                  144            based           fixed bin(17,0)          level 2 dcl 21-75 set ref 1082* 1089 2401* 2407
word                    145            based           bit(36)                  array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 3915 3916 3917
word                      7            based           bit(36)                  array level 3 in structure "tolts_rspd_workspace"
                                                                                  dcl 23-16 in procedure "mtdsim_" set ref 2281 2281
                                                                                  2283 2453*
word1                    12            based           structure                level 3 in structure "tolts_fpinfo" dcl 20-15
                                                                                  in procedure "mtdsim_"
word1                    14            based           structure                level 3 in structure "tolts_fpinfo" dcl 20-15
                                                                                  in procedure "mtdsim_" set ref 2435*
word1                    10            based           structure                level 3 in structure "tolts_fpinfo" dcl 20-15
                                                                                  in procedure "mtdsim_" ref 2771
word2                    11            based           structure                level 3 in structure "tolts_fpinfo" dcl 20-15
                                                                                  in procedure "mtdsim_" ref 2769
word2                    15            based           structure                level 3 in structure "tolts_fpinfo" dcl 20-15
                                                                                  in procedure "mtdsim_" set ref 2442*
word_total                             based           bit(18)                  level 2 packed packed unaligned dcl 391 ref 678 694
                                                                                  1874 1891 1977 1992 2001 2017
workspace_move                         based           char                     packed unaligned dcl 209 set ref 1533* 1533 3344*
                                                                                  3344 3346* 3346 3352* 3352 3500* 3500
workspace_ptr          2144            based           pointer                  level 2 in structure "io_info" dcl 21-155
                                                                                  in procedure "mtdsim_" set ref 1080* 1082* 1091
                                                                                  2189 2978* 2981* 2984* 3339 3380 3964
workspace_ptr         33246            based           pointer                  array level 3 in structure "tolts_info" dcl 21-75
                                                                                  in procedure "mtdsim_" set ref 2241
wrapup_add               27            based           bit(18)                  level 2 packed packed unaligned dcl 273 set ref
                                                                                  1357* 1674 2582* 3223 3229
write_flag               17            based           bit(1)                   level 2 dcl 16-19 set ref 983* 1049* 1055*
ws_data_idx                     000172 automatic       fixed bin(17,0)          dcl 206 set ref 2279* 2281 2283
x                        40            based           bit(18)                  array level 3 packed packed unaligned dcl 273 set
                                                                                  ref 876* 905 905 907 908 908* 954* 990* 1001*
                                                                                  1012* 1086* 1096* 1111* 1130* 1246 1314 1314 1386*
                                                                                  1411 1417 1427 1430 1433 1433 1444 1444 1469 1469
                                                                                  1501 1511 1567 1567 1586 1588* 1589* 1591* 1595*
                                                                                  1612 1642* 1668 1668 2144* 2151* 2166 2166 2181
                                                                                  2181 2181 2183 2183 2238 2238 2238 2240 2240 2271
                                                                                  2278 2279 2280 2352* 2354 2361 2495 2505* 2511*
                                                                                  2628 2628 2667 2695 2695 2697 2697 2745 2810 2811
                                                                                  2811* 2854 2854 3006* 3306* 3309*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABORT_SES_FROM_HOST                    internal static fixed bin(9,0)           initial unsigned dcl 11-114
ACTIVE                                 internal static fixed bin(17,0)          initial dcl 3-272
ANS_SERVICE                            internal static fixed bin(17,0)          initial dcl 3-259
BIN_DATA_FROM_HOST                     internal static fixed bin(9,0)           initial unsigned dcl 11-112
CDT_version                            internal static fixed bin(17,0)          initial dcl 3-39
CDT_version_5                          internal static fixed bin(17,0)          initial dcl 3-38
CHANNEL_DELETED                        internal static fixed bin(17,0)          initial dcl 3-288
CONSOLE_DTYPEX                         internal static fixed bin(17,0)          initial dcl 17-31
CON_DATA_FROM_HOST                     internal static fixed bin(9,0)           initial unsigned dcl 11-110
DATA_FROM_HOST                         internal static fixed bin(9,0)           initial unsigned dcl 11-96
DATA_FROM_MCA                          internal static fixed bin(9,0)           initial unsigned dcl 11-102
DATA_SEG                               internal static char(12)                 initial packed unaligned dcl 10-85
DIAL_OUT_SERVICE                       internal static fixed bin(17,0)          initial dcl 3-259
DIAL_SERVICE                           internal static fixed bin(17,0)          initial dcl 3-259
DISK_DRIVE_DTYPEX                      internal static fixed bin(17,0)          initial dcl 17-30
DISK_INFO_VERSION_1                    internal static fixed bin(17,0)          initial dcl 16-29
DISK_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 17-38
DN355                                  internal static fixed bin(17,0)          initial dcl 4-19
DN6600                                 internal static fixed bin(17,0)          initial dcl 4-19
DN6670                                 internal static fixed bin(17,0)          initial dcl 4-19
DN7100                                 internal static fixed bin(17,0)          initial dcl 4-19
FEP_BIG_ADDRESS_TYPE                   internal static bit(1)                   initial packed unaligned dcl 24-52
FEP_SMALL_ADDRESS_TYPE                 internal static bit(1)                   initial packed unaligned dcl 24-51
FNP_BOOT                               internal static fixed bin(17,0)          initial dcl 3-298
FNP_DOWN                               internal static fixed bin(17,0)          initial dcl 3-298
FNP_FREE                               internal static fixed bin(17,0)          initial dcl 3-298
FNP_UNKNOWN                            internal static fixed bin(17,0)          initial dcl 3-298
FNP_UP                                 internal static fixed bin(17,0)          initial dcl 3-298
FTP_SERVICE                            internal static fixed bin(17,0)          initial dcl 3-259
INACTIVE                               internal static fixed bin(17,0)          initial dcl 3-272
IOM_CARD_WORD                          internal static char(4)                  initial dcl 6-19
IPC_ATTACHED                           internal static fixed bin(17,0)          initial dcl 10-94
IPC_FREE                               internal static fixed bin(17,0)          initial dcl 10-94
IPC_NOT_CONFIGURED                     internal static fixed bin(17,0)          initial dcl 10-94
MAINT_SESSION                          internal static fixed bin(17,0)          initial dcl 10-88
MCA_ATTACHING                          internal static fixed bin(17,0)          initial dcl 10-88
MCA_DTYPEX                             internal static fixed bin(17,0)          initial dcl 17-36
MCA_data_version_1                     internal static char(8)                  initial packed unaligned dcl 10-17
MC_SERVICE                             internal static fixed bin(17,0)          initial dcl 3-259
MPX_BOOT                               internal static fixed bin(17,0)          initial dcl 3-306
MPX_DOWN                               internal static fixed bin(17,0)          initial dcl 3-306
MPX_FREE                               internal static fixed bin(17,0)          initial dcl 3-306
MPX_SERVICE                            internal static fixed bin(17,0)          initial dcl 3-259
MPX_UNKNOWN                            internal static fixed bin(17,0)          initial dcl 3-306
MPX_UP                                 internal static fixed bin(17,0)          initial dcl 3-306
NOT_CONFIGURED                         internal static fixed bin(17,0)          initial dcl 3-280
NUM_QUALIFIERS                         internal static fixed bin(17,0)          initial array dcl 17-22
PRINTER_DTYPEX                         internal static fixed bin(17,0)          initial dcl 17-32
PUNCH_DTYPEX                           internal static fixed bin(17,0)          initial dcl 17-33
READER_DTYPEX                          internal static fixed bin(17,0)          initial dcl 17-34
REQ_DATA_FROM_HOST                     internal static fixed bin(9,0)           initial unsigned dcl 11-104
SEEK                                   internal static fixed bin(9,0)           initial unsigned dcl 11-108
SLAVE_SERVICE                          internal static fixed bin(17,0)          initial dcl 3-259
SPECIAL_DTYPEX                         internal static fixed bin(17,0)          initial dcl 17-35
STATUS_FROM_MCA                        internal static fixed bin(9,0)           initial unsigned dcl 11-106
SYSTEM_DIR                             internal static char(17)                 initial packed unaligned dcl 10-84
TANDD_SERVICE                          internal static fixed bin(17,0)          initial dcl 3-259
TAPE_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 17-37
VOLUME_TYPE                            internal static char(32)                 initial array packed unaligned dcl 17-25
WRITE_CONSOLE                          internal static fixed bin(9,0)           initial unsigned dcl 11-98
WRITE_READ_CONSOLE                     internal static fixed bin(9,0)           initial unsigned dcl 11-100
abx                                    internal static fixed bin(17,0)          initial dcl 9-42
alt_dev_busy                           internal static fixed bin(18,0)          initial unsigned dcl 19-4
apx                                    internal static fixed bin(17,0)          initial dcl 9-42
bbx                                    internal static fixed bin(17,0)          initial dcl 9-42
bpx                                    internal static fixed bin(17,0)          initial dcl 9-42
cdtep                                  automatic       pointer                  dcl 3-41
ch_not_ass                             internal static fixed bin(18,0)          initial unsigned dcl 19-4
colts_info_ptr                         automatic       pointer                  dcl 21-72
condition_info_ptr                     automatic       pointer                  dcl 5-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 5-30
data_header_ptr                        automatic       pointer                  dcl 11-15
dial_manager_arg_version_3             internal static fixed bin(17,0)          initial dcl 22-11
dial_manager_arg_version_4             internal static fixed bin(17,0)          initial dcl 22-12
event_wait_info_ptr                    automatic       pointer                  dcl 7-5
fnp_models                             internal static fixed bin(17,0)          initial array dcl 4-28
fnp_types                              internal static char(8)                  initial array packed unaligned dcl 4-25
fnpep                                  automatic       pointer                  dcl 3-41
gc_files                               internal static fixed bin(18,0)          initial unsigned dcl 19-4
generic_destination                    based           char(32)                 packed unaligned dcl 3-195
icmp                                   internal static pointer                  initial dcl 224
imess                                  based           structure                level 1 dcl 14-21
imp                                    automatic       pointer                  dcl 14-19
inv_tt                                 internal static fixed bin(18,0)          initial unsigned dcl 19-4
io_param_blk_ptr                       automatic       pointer                  dcl 11-19
ipcd_ptr                               automatic       pointer                  dcl 10-24
isp                                    automatic       pointer                  dcl 14-5
iv_dev                                 internal static fixed bin(18,0)          initial unsigned dcl 19-4
iv_iom                                 internal static fixed bin(18,0)          initial unsigned dcl 19-4
lbx                                    internal static fixed bin(17,0)          initial dcl 9-42
lpx                                    internal static fixed bin(17,0)          initial dcl 9-42
mca_data_seg                           based           structure                level 1 unaligned dcl 10-26
mca_data_seg_ptr                       internal static pointer                  initial dcl 10-20
mca_dcw_list_ptr                       automatic       pointer                  dcl 11-21
mcad_ptr                               automatic       pointer                  dcl 10-22
mdc_io_type                            internal static fixed bin(17,0)          initial dcl 21-66
mem_not_rel                            internal static fixed bin(18,0)          initial unsigned dcl 19-4
mem_test                               internal static fixed bin(18,0)          initial unsigned dcl 19-4
mlt_act                                internal static fixed bin(18,0)          initial unsigned dcl 19-4
mpxep                                  automatic       pointer                  dcl 3-41
mtc_io_type                            internal static fixed bin(17,0)          initial dcl 21-64
mtg_io_type                            internal static fixed bin(17,0)          initial dcl 21-65
no_pat                                 internal static fixed bin(18,0)          initial unsigned dcl 19-4
no_s2_test                             internal static fixed bin(18,0)          initial unsigned dcl 19-4
no_sv_file                             internal static fixed bin(18,0)          initial unsigned dcl 19-4
not_boot_psia                          internal static fixed bin(18,0)          initial unsigned dcl 19-4
not_log_0                              internal static fixed bin(18,0)          initial unsigned dcl 19-4
not_psia                               internal static fixed bin(18,0)          initial unsigned dcl 19-4
not_sec_mpc                            internal static fixed bin(18,0)          initial unsigned dcl 19-4
plt_act                                internal static fixed bin(18,0)          initial unsigned dcl 19-4
ptrain                                 internal static fixed bin(18,0)          initial unsigned dcl 19-4
rem_sp_pri                             internal static fixed bin(18,0)          initial unsigned dcl 19-4
rem_sp_sec                             internal static fixed bin(18,0)          initial unsigned dcl 19-4
rspd_io_type                           internal static fixed bin(17,0)          initial dcl 21-69
sbx                                    internal static fixed bin(17,0)          initial dcl 9-42
scux                                   based           structure                level 1 dcl 9-207
split_rlsec                            internal static fixed bin(18,0)          initial unsigned dcl 19-4
spx                                    internal static fixed bin(17,0)          initial dcl 9-42
supported_fnp                          internal static bit(1)                   initial array packed unaligned dcl 4-31
tape_info_version_2                    internal static fixed bin(17,0)          initial dcl 18-12
tape_info_version_3                    internal static fixed bin(17,0)          initial dcl 18-13
tdcw                                   based           structure                level 1 dcl 12-14
tdcwp                                  automatic       pointer                  dcl 12-4
uns_rdr                                internal static fixed bin(18,0)          initial unsigned dcl 19-4

NAMES DECLARED BY EXPLICIT CONTEXT.
HREGS                           035137 constant        label                    dcl 3266
ask                             041573 constant        label                    dcl 3853 set ref 3879
ask_again                       037570 constant        label                    dcl 3635 ref 3647
attach                          011426 constant        label                    dcl 938 ref 985 1051 1058
block_disp                      005751 constant        label                    dcl 546 ref 488
ck_release                      042334 constant        entry                    internal dcl 3927 ref 2700 3630
clean_up                        034137 constant        entry                    external dcl 3815 ref 447 529 784 3147 3225
close_sw                        041140 constant        entry                    internal dcl 3769 ref 3721 3757
ctime                           041462 constant        entry                    internal dcl 3799 ref 769 769 850 850 863 863 875
                                                                                  875 904 904 1158 1158 1313 1313 1325 1325 1355
                                                                                  1355 1385 1385 1409 1409 1468 1468 1498 1498 1566
                                                                                  1566 1582 1582 1610 1610 1641 1641 1659 1659 1692
                                                                                  1692 1712 1712 1771 1771 1794 1794 1807 1807 1821
                                                                                  1821 1831 1831 1840 1840 1862 1862 2108 2108 2121
                                                                                  2121 2136 2136 2139 2139 2165 2165 2180 2180 2212
                                                                                  2212 2225 2225 2237 2237 2269 2269 2352 2352 2490
                                                                                  2490 2560 2560 2610 2610 2627 2627 2666 2666 2694
                                                                                  2694 2715 2715 2727 2727 2743 2743 2801 2801 2832
                                                                                  2832 2853 2853 2867 2867 2895 2895 2941 2941 2947
                                                                                  2947 2952 2952 3017 3017 3052 3052 3060 3060 3074
                                                                                  3074 3090 3090 3100 3100 3115 3115
db_err                          022117 constant        label                    dcl 1896 ref 1886
db_query                        004707 constant        label                    dcl 473 ref 480
dealcp_sub                      037512 constant        entry                    internal dcl 3626 ref 953 989 1011 1085 1095 1110
                                                                                  1129 1470 1626 2386 2396 2404 3827
decode_den                      041563 constant        entry                    internal dcl 3849 ref 1077
display_mc                      034741 constant        entry                    internal dcl 3236 ref 3202
done                            010505 constant        label                    dcl 780 ref 489
epilogue                        034063 constant        entry                    external dcl 3140
fault_dump                      034510 constant        entry                    internal dcl 3192 ref 499 504 509 514 519 524
gerout                          000175 constant        label                    array(4:16) dcl 1870 ref 1865
get_px_sct                      037150 constant        entry                    internal dcl 3565 ref 905 1314 1469 1567 2137 2166
                                                                                  2628 2697 2854 2954
get_px_tcx                      037304 constant        entry                    internal dcl 3597 ref 1159 1161 1414 1416 2181 2183
                                                                                  2238 2240 2492 2494
io_setup                        035640 constant        entry                    internal dcl 3374 ref 2956
mca_io_setup                    035456 constant        entry                    internal dcl 3335 ref 2955
message_wait                    043173 constant        entry                    internal dcl 3999 ref 475 1213 3035 3636 3739 3857
                                                                                  3878 3950
mme_fault                       010526 constant        entry                    external dcl 790
mme_typ                         000000 constant        label                    array(-93:31) dcl 850 ref 839 1031
mtdsim_                         004054 constant        entry                    external dcl 93 ref 435 435 449 449 528 528 3031
                                                                                  3031 3200 3200
no_blk_disp                     007664 constant        label                    dcl 708 ref 490
non_data                        036475 constant        label                    dcl 3518 ref 3456
output_status_code              037413 constant        entry                    internal dcl 3617 ref 607 952 988 1008 1010 1084
                                                                                  1094 1109 1128 1166 1171 1184 1243 1422 1446 1548
                                                                                  1673 2197 2385 2394 2403 2510 2960 2991 3672 3683
                                                                                  3690 3979
pop_isc                         042256 constant        entry                    internal dcl 3910 ref 751 1732
reask                           040625 constant        label                    dcl 3738 ref 3742
rel_exec_chan                   040264 constant        entry                    internal dcl 3699 ref 2078 3822
rel_tst_chan                    040545 constant        entry                    internal dcl 3728 ref 582 623 2080 3819
requery                         014024 constant        label                    dcl 1207 set ref 1218
retry_ld                        042446 constant        label                    dcl 3941 ref 3951
return_plus                     034334 constant        entry                    internal dcl 3155 ref 852 864 877 910 955 991 1006
                                                                                  1013 1023 1087 1097 1112 1131 1135 1167 1172 1185
                                                                                  1222 1244 1298 1300 1316 1328 1370 1387 1423 1436
                                                                                  1448 1455 1473 1555 1570 1599 1627 1643 1753 1795
                                                                                  1822 1832 1842 1865 1965 2023 2028 2036 2068 2076
                                                                                  2087 2095 2111 2124 2154 2168 2200 2213 2226 2243
                                                                                  2248 2284 2286 2414 2422 2430 2437 2445 2456 2507
                                                                                  2512 2523 2599 2614 2639 2672 2704 2716 2728 2756
                                                                                  2761 2773 2780 2813 2819 2836 2839 2856 2871 3008
                                                                                  3029 3041 3053 3061 3091 3101 3121
retype                          042522 constant        label                    dcl 3948 ref 3952
set_gelbar                      043221 constant        entry                    internal dcl 4010 ref 806
set_sctwrk                      035242 constant        entry                    internal dcl 3285 ref 906 2809
sub_cmnd                        000212 constant        label                    array(11) dcl 2364 ref 2361
sw_err                          007166 constant        label                    dcl 646 ref 641 643
tell_opr                        042562 constant        label                    dcl 3953 set ref 3944
tolts_abort                     034655 constant        entry                    internal dcl 3215 ref 579 620 650 683 690 704 720
                                                                                  817 919 1471 1507 1549 1619 1695 1715 1723 1728
                                                                                  1920 1981 1987 2013 2056 2072 2140 2198 2275 2358
                                                                                  2368 2375 2387 2397 2405 2520 2634 2749 2806 2899
                                                                                  2905 2971 3001 3136 3198 3207 3588 3608
undefm                          034007 constant        label                    dcl 3123 set ref 810 820
wake_disp                       034353 constant        entry                    internal dcl 3166 ref 573 766 1683 1701 1783 1809
                                                                                  2924 3230 4039

NAMES DECLARED BY CONTEXT OR IMPLICATION.
after                                                  builtin function         ref 1257 1268 1272
convert                                                builtin function         ref 2501
hbound                                                 builtin function         ref 1503 1507 1614 1619 2272 2275 2355 2358 2746
                                                                                  2749 3463 3602 3605 3818 3821 3825
search                                                 builtin function         ref 1193 1206
wordno                                                 builtin function         ref 1524 1538

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     45670       46400   44147       45700
Length     50662   44147       510        2246    1521         160

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mtdsim_                            6571 external procedure  is an external procedure.  
on unit on line 447                  64 on unit               
on unit on line 497                  94 on unit               
on unit on line 502                  94 on unit               
on unit on line 507                  96 on unit               
on unit on line 512                  96 on unit               
on unit on line 517                  96 on unit               
on unit on line 522                  94 on unit               
on unit on line 527                  74 on unit               
on unit on line 532                  68 on unit               
on unit on line 537                  76 on unit               
return_plus                          96 internal procedure  is called by several nonquick procedures.  
fault_dump                          163 internal procedure  is called by several nonquick procedures.  
tolts_abort                          76 internal procedure  is called by several nonquick procedures.  
display_mc                              internal procedure  shares stack frame of internal procedure fault_dump.  
set_sctwrk                              internal procedure  shares stack frame of external procedure mtdsim_.  
mca_io_setup                            internal procedure  shares stack frame of external procedure mtdsim_.  
io_setup                                internal procedure  shares stack frame of external procedure mtdsim_.  
get_px_sct                              internal procedure  shares stack frame of external procedure mtdsim_.  
get_px_tcx                              internal procedure  shares stack frame of external procedure mtdsim_.  
output_status_code                      internal procedure  shares stack frame of external procedure mtdsim_.  
dealcp_sub                              internal procedure  shares stack frame of external procedure mtdsim_.  
rel_exec_chan                           internal procedure  shares stack frame of external procedure mtdsim_.  
rel_tst_chan                            internal procedure  shares stack frame of external procedure mtdsim_.  
close_sw                                internal procedure  shares stack frame of external procedure mtdsim_.  
ctime                                   internal procedure  shares stack frame of external procedure mtdsim_.  
decode_den                              internal procedure  shares stack frame of external procedure mtdsim_.  
pop_isc                                 internal procedure  shares stack frame of external procedure mtdsim_.  
ck_release                              internal procedure  shares stack frame of external procedure mtdsim_.  
message_wait                            internal procedure  shares stack frame of external procedure mtdsim_.  
set_gelbar                              internal procedure  shares stack frame of external procedure mtdsim_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 gicm_count                  mtdsim_
000011 io_sel                      mtdsim_
000012 isc_cntdn                   mtdsim_
000013 last_mme                    mtdsim_
000014 mme_number                  mtdsim_
000015 nr_cnt                      mtdsim_
000016 term                        mtdsim_
000017 gndc_flag                   mtdsim_
000020 found                       mtdsim_
000021 gelbar                      mtdsim_
000022 glb_brk                     mtdsim_
000023 in_ccc                      mtdsim_
000024 isc_ccc_rqt                 mtdsim_
000025 mpc_io                      mtdsim_
000026 trace_save                  mtdsim_
000027 debug                       mtdsim_
000030 debugging                   mtdsim_
000031 rd_blk                      mtdsim_
000032 flt_flag                    mtdsim_
000033 alt_flag                    mtdsim_
000034 q_flag                      mtdsim_
000035 rd_flag                     mtdsim_
000036 tcd                         mtdsim_
000037 trace_io                    mtdsim_
000040 trace                       mtdsim_
000041 itr_run                     mtdsim_
000042 tolts_active                mtdsim_
000044 db_addr                     mtdsim_
000046 exec                        mtdsim_
000050 ttl_date                    mtdsim_
000052 old_mask                    mtdsim_
000053 new_mask                    mtdsim_
000054 clt_sw                      mtdsim_
000066 gicmp                       mtdsim_
000070 mvp                         mtdsim_
000072 ricmp                       mtdsim_
000074 ticmp                       mtdsim_
000076 wicmp                       mtdsim_
000100 l                           mtdsim_
000101 k                           mtdsim_
000102 code                        mtdsim_
000103 db_sv_wd                    mtdsim_
000104 gerout_num                  mtdsim_
000105 icm_tally                   mtdsim_
000106 fnp_addr                    mtdsim_
000107 fnp_num                     mtdsim_
000110 remote_inquiry_ic           mtdsim_
000111 att_desc                    mtdsim_
000124 mmep                        mtdsim_
000126 genp                        mtdsim_
000130 arglen                      mtdsim_
000131 n_read                      mtdsim_
000132 blk_lbl                     mtdsim_
000136 emsg                        mtdsim_
000150 term_lbl                    mtdsim_
000154 no_blk                      mtdsim_
000160 event_out                   mtdsim_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
fault_dump               000106 faultsp                     display_mc
                         000110 hreg_ptr                    display_mc
                         000112 stackp                      display_mc
                         000114 code                        display_mc
mtdsim_                  000100 bufp                        mtdsim_
                         000102 nargs                       mtdsim_
                         000103 return_value                mtdsim_
                         000104 c_len                       mtdsim_
                         000105 n_dialed                    mtdsim_
                         000106 len                         mtdsim_
                         000107 tio                         mtdsim_
                         000110 dealc_err                   mtdsim_
                         000111 ev_occurred                 mtdsim_
                         000112 i                           mtdsim_
                         000113 j                           mtdsim_
                         000114 mesg_len                    mtdsim_
                         000115 ndcws                       mtdsim_
                         000116 tally                       mtdsim_
                         000117 t_err                       mtdsim_
                         000120 chan_name                   mtdsim_
                         000130 io_module                   mtdsim_
                         000140 error                       mtdsim_
                         000141 c_error                     mtdsim_
                         000142 mem_needed                  mtdsim_
                         000143 filename_idx                mtdsim_
                         000144 lvl_idx                     mtdsim_
                         000145 imu_found                   mtdsim_
                         000146 iom_found                   mtdsim_
                         000147 iom                         mtdsim_
                         000150 chan                        mtdsim_
                         000151 tio_off                     mtdsim_
                         000152 timeout_time                mtdsim_
                         000154 cpu_time                    mtdsim_
                         000156 wake_time                   mtdsim_
                         000160 mem_now                     mtdsim_
                         000161 pcwa                        mtdsim_
                         000162 bcd_callname                mtdsim_
                         000163 gcos_tod                    mtdsim_
                         000164 b18                         mtdsim_
                         000166 bit_buf                     mtdsim_
                         000170 pad_char                    mtdsim_
                         000171 sb_data_idx                 mtdsim_
                         000172 ws_data_idx                 mtdsim_
                         000174 argptr                      mtdsim_
                         000176 train_ptr                   mtdsim_
                         000200 tp                          mtdsim_
                         000202 cltp                        mtdsim_
                         000204 t_ptr                       mtdsim_
                         000206 ioe_ptr                     mtdsim_
                         000210 l_ptr                       mtdsim_
                         000212 gcatp                       mtdsim_
                         000214 info_ptr                    mtdsim_
                         000216 coment                      mtdsim_
                         000316 shortinfo                   mtdsim_
                         000320 lginfo                      mtdsim_
                         000351 message                     mtdsim_
                         000552 ac_name                     mtdsim_
                         000554 io_block_len                mtdsim_
                         000556 fatal_desc                  mtdsim_
                         000560 ci                          mtdsim_
                         000612 flags                       mtdsim_
                         000710 clp                         mtdsim_
                         000712 cdtp                        mtdsim_
                         000714 iom_cardp                   mtdsim_
                         000716 gload_data                  mtdsim_
                         001604 mcp                         mtdsim_
                         001606 scup                        mtdsim_
                         001610 data_size_1                 mtdsim_
                         001611 data_size_2                 mtdsim_
                         001612 mca_work_space_ptr          mtdsim_
                         001614 dcwp                        mtdsim_
                         001616 pcwp                        mtdsim_
                         001620 idcwp                       mtdsim_
                         001622 opr_query_info              mtdsim_
                         001676 disk_info_ptr               mtdsim_
                         001700 tape_info_ptr               mtdsim_
                         001702 tolts_fpinfo_ptr            mtdsim_
                         001704 io_info_ptr                 mtdsim_
                         001706 dmap                        mtdsim_
                         001710 tolts_rspd_wksp             mtdsim_
                         001712 intercom_mbx_area           mtdsim_
                         001722 direct_channel_pcw_ptr      mtdsim_
                         001724 direct_channel_tcw_ptr      mtdsim_
                         001726 ioi_wksp                    mtdsim_
                         002000 continue                    io_setup
                         002001 first                       io_setup
                         002002 idcw_io                     io_setup
                         002003 cbuf_add                    io_setup
                         002004 lstloc                      io_setup
                         002005 nxtloc                      io_setup
                         002006 dcwb                        io_setup
                         002112 tim                         ctime
                         002115 ptime                       ctime
                         002121 plen                        ctime
                         002162 fwd                         set_gelbar
tolts_abort              000100 tfc                         tolts_abort

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_e_as              alloc_char_temp     alloc_temp          call_ext_in         call_ext_out_desc
call_ext_out        call_int_this       call_int_other      return_mac          tra_ext_2           mpfx2
signal_op           enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry
set_chars_eis       index_chars_eis     divide_fx3          alloc_storage       op_freen_           index_after_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
bcd_to_ascii_                 com_err_                      continue_to_signal_
convert_dial_message_$return_io_module                      convert_status_code_          cpu_time_and_paging_
cu_$arg_count                 cu_$arg_ptr                   cu_$stack_frame_ptr           cv_oct_check_
db_fnp_eval_                  db_fnp_memory_$fetch          dial_manager_$privileged_attach
dial_manager_$release_channel dial_manager_$release_channel_no_listen                     dial_manager_$tandd_attach
dump_machine_cond_            find_condition_frame_         find_condition_info_          get_temp_segment_
gload_                        hcs_$get_ips_mask             hcs_$set_ips_mask             hcs_$wakeup
hran_$hranl                   ioa_                          ioa_                          ioa_$ioa_switch
ioa_$rsnnl                    ioi_$connect                  ioi_$connect_pcw              ioi_$release_devices
ioi_$set_channel_required     ioi_$set_status               ioi_$suspend_devices          ioi_$timeout
ioi_$workspace                iox_$attach_name              iox_$close                    iox_$control
iox_$detach_iocb              iox_$get_chars                iox_$modes                    iox_$open
iox_$put_chars                ipc_$block                    ipc_$delete_ev_chn            ipc_$drain_chn
ipc_$read_ev_chn              mca_$attach_ipc               mca_$attach_mca               mca_$detach_ipc
mca_$detach_mca               mca_$load_ipc                 mca_$reset                    mca_$tandd_read_data
mca_$tandd_write_data         mca_$tandd_write_text         opr_query_                    pl1_time_
probe                         rcp_$attach                   rcp_$check_attach             rcp_$detach
rcp_priv_$attach              terminate_process_            timer_manager_$alarm_wakeup
timer_manager_$reset_alarm_wakeup                           timer_manager_$sleep          tolts_alm_util_$ascii_to_bcd_
tolts_alm_util_$enter_ccc_req_                              tolts_alm_util_$enter_slave_  tolts_alm_util_$gen_ck_sum
tolts_alrm_util_$quit         tolts_device_info_            tolts_file_util_$close        tolts_file_util_$open
tolts_file_util_$snap         tolts_file_util_$wdump        tolts_init_                   tolts_init_$clean_up
tolts_init_$cr_event_chan     tolts_init_$gc_tod            tolts_io_int_                 tolts_load_firmware_
tolts_qttyio_                 tolts_qttyio_$dcw_list        tolts_qttyio_$dcw_ptr         tolts_qttyio_$rcw
tolts_qttyio_$rs              tolts_util_$cata_sel          tolts_util_$find_card         tolts_util_$get_ttl_date
tolts_util_$search

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
colts_op_flags                error_table_$bad_command_name error_table_$force_unassign
error_table_$resource_unavailable                           printer_images_$image_base    printer_images_$image_numbers
printer_images_$image_offsets printer_images_$n_images      sys_info$alrm_mask            tolts_infop




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    189 004020       192 004036       195 004041       196 004042       197 004043       199 004045   11   17 004047
     93 004053       415 004062       416 004070       417 004072       418 004100       419 004117       420 004136
    421 004170       423 004171       424 004174       425 004175       426 004200       427 004207       428 004224
    430 004242       432 004255       433 004270       434 004303       435 004312       436 004336       437 004340
    441 004343       442 004346       443 004355       444 004356       445 004363       446 004373       447 004375
    448 004416       449 004420       450 004434       454 004437       455 004502       456 004505       457 004546
    458 004553       460 004554       461 004600       462 004602       464 004644       465 004651       468 004652
    470 004700       471 004703       472 004704       473 004707       475 004731       476 004732       477 004742
    478 005006       479 005015       480 005030       482 005031       483 005043       488 005047       489 005052
    490 005055       491 005060       492 005071       493 005077       494 005101       495 005107       496 005111
    497 005113       498 005127       499 005155       500 005166       501 005175       502 005176       503 005212
    504 005240       505 005251       506 005260       507 005261       508 005275       509 005323       510 005334
    511 005343       512 005344       513 005360       514 005406       515 005417       516 005426       517 005427
    518 005443       519 005471       520 005502       521 005511       522 005512       523 005526       524 005554
    525 005565       526 005574       527 005575       528 005611       529 005625       530 005631       532 005632
    533 005646       535 005655       536 005664       537 005665       538 005701       539 005722       540 005723
    544 005744       545 005746       546 005751       548 005772       549 005774       550 006020       551 006021
    552 006023       554 006051       556 006054       557 006062       560 006067       561 006070       563 006106
    564 006111       565 006134       567 006142       568 006145       569 006151       570 006174       571 006176
    572 006211       573 006213       574 006217       576 006220       577 006225       579 006257       580 006267
    582 006270       583 006276       584 006305       586 006341       587 006344       588 006346       589 006350
    590 006355       591 006364       594 006406       599 006415       600 006422       601 006430       602 006431
    603 006441       605 006474       606 006477       607 006526       609 006543       613 006614       617 006632
    618 006640       620 006676       621 006706       623 006707       624 006715       625 006724       627 006760
    628 006763       629 006765       630 006767       631 006774       632 007003       635 007025       639 007034
    640 007043       641 007104       642 007110       643 007130       644 007133       645 007163       646 007166
    647 007173       648 007213       650 007252       651 007262       653 007263       654 007271       657 007273
    658 007276       659 007303       660 007311       661 007313       663 007334       665 007335       666 007343
    667 007347       670 007366       671 007370       672 007372       677 007373       678 007377       679 007434
    680 007437       681 007457       683 007520       685 007530       686 007533       688 007534       689 007537
    690 007565       692 007575       693 007604       694 007607       695 007617       696 007624       697 007632
    699 007635       702 007637       703 007643       704 007644       705 007654       706 007655       707 007662
    708 007664       710 007667       711 007673       713 007675       714 007702       715 007732       716 007735
    717 007760       718 007763       719 010003       720 010036       722 010046       723 010052       725 010073
    726 010103       729 010117       730 010122       731 010124       732 010126       734 010130       735 010132
    740 010135       743 010137       744 010142       745 010150       746 010154       747 010155       748 010171
    749 010202       751 010211       754 010221       756 010236       757 010242       758 010244       759 010246
    760 010250       761 010257       762 010264       763 010266       764 010271       765 010272       766 010274
    767 010302       769 010304       775 010465       776 010467       777 010470       780 010505       782 010506
    783 010510       784 010514       785 010520       790 010521       801 010542       802 010546       803 010550
    804 010560       806 010563       808 010567       810 010600       813 010605       815 010614       817 010650
    819 010660       820 010664       824 010700       825 010704       826 010706       829 010724       830 010726
    832 010727       833 010730       834 010732       835 010734       838 010735       839 010737       850 010740
    851 010776       852 011010       863 011020       864 011062       875 011072       876 011131       877 011137
    904 011147       905 011211       906 011226       907 011235       908 011244       910 011254       912 011264
    916 011273       917 011275       919 011325       921 011337       924 011342       925 011350       926 011352
    928 011362       930 011366       932 011373       934 011422       935 011425       938 011426       939 011431
    941 011475       943 011536       945 011537       947 011603       951 011644       952 011646       953 011657
    954 011660       955 011667       957 011677       960 011755       977 012027       979 012037       980 012043
    981 012050       982 012052       983 012054       984 012055       985 012057       988 012060       989 012077
    990 012100       991 012107       996 012117       998 012124      1000 012130      1001 012134      1002 012142
   1003 012144      1004 012170      1006 012173      1008 012203      1010 012227      1011 012235      1012 012236
   1013 012245      1015 012255      1018 012266      1019 012270      1020 012274      1021 012276      1022 012317
   1023 012323      1026 012333      1029 012350      1030 012352      1031 012354      1033 012355      1034 012363
   1035 012365      1044 012366      1047 012377      1048 012402      1049 012404      1050 012405      1051 012410
   1054 012411      1055 012413      1056 012415      1057 012416      1058 012417      1074 012420      1076 012443
   1077 012462      1080 012471      1082 012525      1083 012544      1084 012546      1085 012557      1086 012560
   1087 012567      1089 012577      1090 012605      1091 012610      1092 012612      1093 012635      1094 012637
   1095 012650      1096 012651      1097 012660      1099 012670      1100 012673      1101 012700      1102 012704
   1104 012705      1105 012712      1107 012716      1108 012733      1109 012735      1110 012746      1111 012747
   1112 012756      1115 012766      1116 012770      1119 013003      1122 013014      1124 013020      1126 013032
   1127 013045      1128 013047      1129 013055      1130 013056      1131 013065      1134 013075      1135 013100
   1158 013110      1159 013154      1161 013174      1162 013204      1163 013210      1164 013212      1165 013236
   1166 013240      1167 013252      1169 013262      1170 013307      1171 013311      1172 013326      1174 013336
   1175 013352      1176 013364      1177 013367      1179 013372      1181 013403      1182 013405      1183 013441
   1184 013444      1185 013456      1187 013466      1188 013471      1190 013477      1192 013547      1193 013562
   1195 013602      1200 013702      1201 013706      1204 013744      1205 013750      1206 014006      1207 014024
   1213 014134      1214 014136      1217 014172      1218 014212      1220 014213      1221 014216      1222 014221
   1226 014251      1227 014252      1228 014255      1230 014262      1233 014270      1234 014271      1236 014272
   1238 014273      1240 014300      1241 014303      1242 014331      1243 014333      1244 014350      1246 014360
   1247 014371      1248 014376      1249 014402      1251 014440      1252 014451      1253 014455      1254 014464
   1255 014500      1256 014515      1257 014521      1259 014554      1261 014555      1262 014565      1263 014571
   1264 014572      1266 014573      1267 014602      1268 014606      1270 014641      1272 014642      1274 014675
   1276 014723      1277 014732      1280 014733      1281 014742      1282 014762      1283 015007      1284 015025
   1285 015042      1287 015100      1288 015131      1291 015177      1292 015220      1295 015227      1296 015231
   1298 015246      1300 015265      1313 015275      1314 015334      1315 015351      1316 015365      1325 015375
   1326 015437      1327 015441      1328 015445      1355 015455      1356 015514      1357 015525      1358 015530
   1359 015544      1360 015555      1361 015564      1362 015570      1364 015607      1365 015620      1366 015632
   1367 015637      1368 015645      1369 015652      1370 015705      1385 015715      1386 015757      1387 015765
   1408 015775      1409 016002      1411 016053      1414 016063      1416 016102      1417 016112      1418 016123
   1419 016130      1420 016134      1421 016166      1422 016170      1423 016212      1426 016222      1427 016226
   1428 016237      1429 016240      1430 016242      1431 016252      1432 016262      1433 016263      1435 016276
   1436 016300      1437 016311      1438 016321      1439 016327      1440 016336      1441 016337      1442 016340
   1444 016341      1445 016370      1446 016372      1448 016425      1450 016436      1452 016451      1455 016531
   1468 016541      1469 016600      1470 016615      1471 016616      1473 016631      1498 016641      1501 016714
   1503 016724      1505 016742      1507 016744      1508 016757      1509 016766      1510 016770      1511 016772
   1513 017006      1515 017010      1516 017013      1518 017014      1519 017022      1520 017025      1521 017027
   1523 017036      1524 017040      1525 017047      1527 017050      1528 017053      1529 017056      1530 017062
   1531 017065      1532 017072      1533 017075      1536 017102      1537 017104      1538 017107      1539 017112
   1540 017116      1541 017126      1542 017140      1544 017144      1545 017146      1546 017147      1547 017162
   1548 017164      1549 017175      1552 017205      1553 017207      1554 017222      1555 017226      1566 017236
   1567 017300      1568 017315      1569 017324      1570 017326      1582 017336      1585 017375      1586 017402
   1587 017410      1588 017417      1589 017425      1591 017432      1593 017436      1595 017445      1596 017447
   1599 017513      1610 017523      1612 017562      1614 017572      1617 017610      1619 017612      1620 017625
   1621 017634      1622 017636      1623 017640      1624 017643      1625 017644      1626 017645      1627 017646
   1641 017656      1642 017720      1643 017726      1658 017736      1659 017754      1660 020022      1661 020025
   1662 020036      1664 020076      1666 020135      1668 020170      1670 020221      1671 020223      1673 020266
   1674 020271      1677 020310      1678 020314      1679 020316      1681 020320      1682 020321      1683 020330
   1692 020334      1693 020375      1694 020401      1695 020425      1697 020435      1698 020440      1699 020441
   1700 020447      1701 020451      1712 020455      1713 020521      1714 020530      1715 020560      1717 020570
   1718 020602      1719 020614      1720 020620      1721 020623      1723 020655      1725 020665      1726 020671
   1728 020724      1730 020734      1731 020741      1732 020745      1733 020752      1736 021002      1738 021003
   1739 021005      1740 021012      1741 021014      1742 021022      1743 021025      1746 021030      1748 021031
   1751 021055      1753 021067      1771 021077      1772 021141      1773 021147      1774 021154      1775 021156
   1776 021160      1777 021162      1778 021170      1779 021176      1780 021204      1781 021211      1782 021214
   1783 021216      1794 021222      1795 021261      1807 021271      1808 021333      1809 021341      1821 021345
   1822 021404      1831 021414      1832 021456      1840 021466      1841 021525      1842 021530      1862 021540
   1864 021604      1865 021612      1870 021625      1871 021636      1872 021653      1873 021667      1874 021671
   1875 021704      1876 021710      1877 021715      1878 021723      1879 021732      1880 021733      1881 021753
   1882 021763      1883 021771      1884 022001      1886 022044      1887 022047      1888 022051      1890 022052
   1891 022054      1892 022067      1894 022072      1896 022117      1897 022122      1898 022142      1900 022175
   1901 022202      1902 022203      1903 022207      1904 022211      1905 022216      1906 022224      1907 022246
   1908 022252      1909 022255      1910 022262      1911 022271      1914 022313      1915 022314      1916 022316
   1917 022332      1918 022334      1919 022345      1920 022371      1923 022401      1925 022410      1926 022415
   1927 022434      1929 022444      1930 022450      1932 022452      1933 022454      1934 022460      1935 022464
   1936 022467      1937 022476      1938 022500      1939 022505      1940 022512      1941 022513      1942 022523
   1943 022526      1945 022564      1946 022573      1947 022613      1949 022660      1950 022663      1951 022672
   1952 022673      1953 022713      1954 022717      1955 022722      1956 022731      1957 022753      1958 022757
   1959 022762      1960 022767      1962 022776      1965 023020      1967 023030      1968 023034      1969 023041
   1970 023061      1971 023075      1972 023100      1973 023102      1974 023104      1975 023106      1977 023107
   1978 023137      1979 023142      1980 023162      1981 023215      1983 023225      1985 023227      1986 023232
   1987 023260      1990 023270      1991 023277      1992 023302      1993 023312      1994 023317      1995 023325
   1998 023330      2001 023331      2002 023361      2003 023364      2004 023404      2006 023451      2009 023460
   2011 023461      2012 023464      2013 023512      2015 023522      2016 023531      2017 023534      2018 023544
   2019 023551      2020 023557      2023 023562      2027 023572      2028 023600      2030 023611      2032 023616
   2035 023633      2036 023641      2039 023651      2041 023654      2043 023660      2044 023665      2045 023667
   2046 023672      2047 023701      2048 023703      2050 023710      2051 023711      2052 023721      2053 023724
   2054 023744      2056 024005      2059 024015      2060 024021      2061 024026      2063 024046      2064 024062
   2065 024065      2066 024067      2068 024073      2069 024103      2071 024104      2072 024130      2076 024140
   2077 024156      2078 024163      2080 024177      2082 024205      2083 024213      2084 024222      2087 024244
   2091 024254      2092 024261      2094 024276      2095 024312      2108 024322      2109 024364      2111 024402
   2121 024412      2122 024451      2123 024463      2124 024471      2136 024501      2137 024543      2138 024560
   2139 024567      2140 024622      2142 024632      2143 024641      2144 024652      2145 024660      2146 024665
   2148 024701      2149 024706      2151 024707      2152 024715      2154 024730      2165 024740      2166 024777
   2167 025014      2168 025030      2180 025040      2181 025102      2183 025121      2184 025130      2185 025131
   2186 025133      2187 025135      2188 025137      2189 025141      2190 025144      2191 025150      2192 025152
   2193 025153      2194 025155      2195 025160      2196 025176      2197 025200      2198 025211      2200 025221
   2212 025231      2213 025270      2225 025300      2226 025342      2237 025352      2238 025413      2240 025432
   2241 025441      2242 025450      2243 025455      2248 025465      2269 025475      2271 025534      2272 025544
   2274 025562      2275 025564      2276 025577      2277 025606      2278 025610      2279 025617      2280 025622
   2281 025626      2283 025641      2284 025643      2285 025653      2286 025654      2352 025664      2354 025732
   2355 025742      2357 025760      2358 025762      2359 025775      2360 026004      2361 026006      2364 026014
   2368 026030      2372 026042      2373 026045      2375 026076      2377 026110      2379 026113      2381 026157
   2384 026220      2385 026222      2386 026233      2387 026234      2390 026244      2392 026317      2394 026324
   2396 026350      2397 026351      2399 026361      2400 026364      2401 026366      2402 026405      2403 026407
   2404 026420      2405 026421      2407 026431      2408 026437      2410 026463      2411 026465      2412 026472
   2414 026474      2417 026504      2420 026507      2422 026510      2425 026520      2428 026523      2430 026531
   2432 026541      2435 026544      2437 026547      2439 026557      2442 026562      2443 026565      2445 026566
   2447 026576      2450 026601      2451 026607      2452 026614      2453 026626      2454 026640      2456 026642
   2490 026652      2492 026714      2494 026734      2495 026744      2496 026755      2497 026757      2498 026762
   2499 027013      2501 027041      2502 027064      2503 027111      2504 027114      2505 027116      2506 027124
   2507 027160      2508 027170      2510 027171      2511 027213      2512 027222      2515 027232      2516 027235
   2517 027236      2518 027241      2520 027272      2521 027306      2523 027310      2560 027320      2561 027357
   2562 027370      2564 027402      2565 027407      2566 027411      2567 027412      2568 027415      2569 027427
   2571 027437      2572 027446      2574 027455      2576 027456      2578 027471      2580 027504      2582 027514
   2583 027521      2584 027535      2585 027546      2586 027555      2587 027561      2588 027564      2590 027603
   2591 027614      2593 027615      2595 027634      2597 027645      2598 027657      2599 027664      2610 027674
   2611 027736      2612 027751      2613 027757      2614 027772      2627 030002      2628 030041      2629 030056
   2630 030077      2631 030101      2632 030105      2634 030136      2636 030146      2637 030156      2638 030166
   2639 030176      2666 030207      2667 030251      2668 030262      2669 030265      2670 030267      2671 030274
   2672 030300      2694 030310      2695 030347      2697 030363      2698 030374      2699 030377      2700 030410
   2704 030413      2715 030423      2716 030465      2727 030475      2728 030534      2743 030544      2745 030606
   2746 030616      2748 030634      2749 030636      2750 030651      2751 030660      2752 030662      2753 030670
   2754 030673      2756 030704      2760 030735      2761 030743      2763 030753      2765 030754      2767 030760
   2769 030763      2771 030770      2773 030775      2778 031024      2780 031034      2801 031065      2802 031124
   2803 031137      2804 031141      2805 031152      2806 031176      2808 031206      2809 031220      2810 031222
   2811 031231      2813 031241      2815 031251      2816 031260      2817 031261      2819 031264      2832 031274
   2834 031343      2835 031350      2836 031356      2839 031370      2853 031400      2854 031442      2855 031457
   2856 031462      2867 031472      2869 031541      2871 031552      2895 031562      2896 031621      2897 031626
   2898 031632      2899 031662      2901 031672      2902 031705      2903 031707      2904 031717      2905 031743
   2907 031753      2908 031762      2909 031764      2910 031774      2911 032003      2912 032006      2913 032014
   2914 032020      2915 032025      2916 032041      2917 032043      2919 032044      2920 032046      2922 032054
   2923 032072      2924 032103      2939 032110      2940 032121      2941 032123      2942 032161      2944 032221
   2946 032240      2947 032243      2948 032301      2950 032341      2951 032360      2952 032361      2954 032420
   2955 032433      2956 032441      2957 032442      2958 032445      2959 032456      2960 032460      2961 032471
   2963 032511      2964 032513      2965 032514      2966 032521      2967 032527      2968 032542      2971 032546
   2973 032556      2975 032561      2976 032564      2978 032610      2981 032634      2984 032660      2987 032704
   2988 032707      2989 032710      2990 032725      2991 032727      2992 032735      2994 032755      2995 032757
   2996 032764      2997 032772      2998 033005      3001 033011      3003 033021      3004 033033      3005 033043
   3006 033051      3007 033061      3008 033062      3017 033072      3018 033134      3019 033137      3029 033141
   3031 033153      3032 033170      3033 033203      3034 033206      3035 033227      3036 033230      3037 033240
   3038 033304      3039 033317      3041 033323      3052 033332      3053 033371      3060 033401      3061 033443
   3074 033453      3076 033512      3077 033530      3078 033544      3079 033551      3080 033556      3090 033560
   3091 033621      3100 033631      3101 033670      3115 033700      3116 033742      3117 033747      3118 033760
   3119 033765      3120 033766      3121 033777      3123 034007      3134 034011      3136 034051      3140 034061
   3142 034071      3143 034074      3144 034100      3145 034106      3146 034112      3147 034121      3148 034125
   3150 034135      3815 034136      3817 034145      3818 034151      3819 034160      3820 034174      3821 034177
   3822 034204      3823 034217      3825 034222      3826 034230      3827 034235      3829 034240      3830 034243
   3831 034251      3832 034262      3833 034265      3834 034271      3835 034302      3838 034307      3841 034323
   3842 034330      3844 034332      3155 034333      3159 034341      3166 034351      3168 034360      3172 034376
   3173 034420      3174 034423      3175 034447      3176 034451      3177 034453      3179 034501      3181 034504
   3192 034507      3193 034515      3194 034517      3196 034532      3197 034535      3198 034564      3200 034575
   3201 034614      3202 034621      3203 034622      3204 034633      3206 034640      3207 034642      3209 034653
   3215 034654      3220 034662      3221 034677      3222 034706      3223 034712      3225 034720      3226 034724
   3227 034727      3229 034731      3230 034733      3232 034740      3236 034741      3249 034742      3250 034751
   3251 034762      3252 034766      3253 035013      3256 035014      3257 035032      3258 035037      3259 035064
   3263 035065      3264 035112      3266 035137      3268 035151      3269 035155      3270 035177      3273 035200
   3274 035222      3277 035241      3285 035242      3305 035244      3306 035255      3307 035275      3308 035276
   3309 035321      3310 035332      3311 035342      3312 035346      3313 035361      3314 035365      3316 035375
   3317 035402      3318 035405      3319 035411      3320 035415      3324 035431      3325 035433      3326 035437
   3327 035443      3330 035455      3335 035456      3338 035457      3339 035470      3340 035473      3341 035511
   3342 035513      3343 035522      3344 035524      3345 035531      3346 035534      3347 035537      3348 035546
   3349 035550      3350 035552      3351 035561      3352 035563      3353 035570      3354 035602      3355 035607
   3356 035611      3357 035614      3358 035622      3359 035627      3360 035631      3361 035632      3362 035633
   3363 035635      3364 035636      3366 035637      3374 035640      3380 035641      3381 035644      3382 035645
   3383 035651      3384 035653      3385 035654      3386 035660      3387 035662      3388 035664      3391 035707
   3392 035711      3393 035713      3396 035726      3399 035740      3401 035746      3402 035750      3403 035752
   3404 035756      3405 035762      3407 035764      3409 035772      3411 035777      3413 036000      3414 036001
   3415 036003      3416 036006      3417 036010      3419 036013      3420 036022      3421 036025      3422 036026
   3424 036036      3425 036040      3426 036042      3427 036046      3428 036051      3429 036053      3430 036056
   3431 036057      3432 036063      3433 036065      3434 036100      3435 036105      3436 036111      3441 036114
   3443 036117      3446 036134      3447 036137      3448 036147      3449 036151      3450 036155      3451 036157
   3452 036160      3453 036163      3454 036165      3456 036171      3458 036172      3459 036176      3460 036200
   3461 036203      3462 036207      3463 036212      3464 036222      3465 036226      3466 036230      3467 036235
   3468 036237      3470 036247      3472 036250      3475 036263      3476 036265      3477 036266      3478 036267
   3481 036307      3482 036311      3483 036313      3485 036316      3486 036325      3487 036330      3488 036332
   3489 036334      3490 036340      3493 036360      3494 036364      3495 036372      3497 036376      3498 036400
   3499 036402      3500 036404      3501 036413      3502 036416      3503 036420      3504 036431      3505 036433
   3506 036436      3507 036441      3508 036444      3510 036445      3511 036446      3515 036455      3516 036460
   3517 036462      3518 036475      3520 036502      3521 036503      3522 036507      3523 036511      3524 036515
   3525 036516      3526 036520      3527 036526      3528 036530      3529 036553      3533 036627      3535 036672
   3536 036700      3537 036727      3538 036741      3539 036776      3540 037000      3541 037026      3542 037054
   3543 037060      3544 037077      3545 037100      3546 037101      3547 037106      3548 037112      3549 037115
   3550 037117      3551 037122      3552 037131      3553 037136      3554 037140      3555 037142      3556 037143
   3557 037145      3558 037146      3560 037147      3565 037150      3571 037152      3572 037155      3573 037160
   3574 037162      3575 037163      3576 037165      3577 037167      3578 037171      3580 037172      3581 037174
   3583 037175      3584 037177      3586 037222      3588 037264      3590 037274      3592 037303      3597 037304
   3602 037306      3604 037332      3605 037334      3606 037337      3608 037374      3609 037404      3610 037405
   3612 037412      3617 037413      3622 037424      3623 037446      3624 037511      3626 037512      3628 037513
   3629 037514      3630 037521      3631 037522      3632 037526      3633 037530      3635 037570      3636 037612
   3637 037613      3639 037630      3640 037633      3641 037634      3644 037700      3646 037726      3647 037730
   3649 037742      3650 037745      3651 037746      3656 037764      3658 040020      3660 040022      3661 040024
   3662 040026      3663 040027      3664 040044      3665 040047      3666 040050      3668 040061      3669 040062
   3670 040124      3671 040126      3672 040130      3679 040141      3680 040144      3681 040206      3682 040210
   3683 040212      3686 040223      3687 040226      3688 040237      3689 040241      3690 040243      3693 040251
   3694 040256      3695 040263      3699 040264      3702 040266      3703 040275      3704 040302      3705 040311
   3706 040313      3708 040320      3709 040330      3710 040333      3711 040367      3712 040410      3713 040443
   3714 040467      3715 040470      3716 040472      3718 040520      3720 040523      3721 040533      3722 040535
   3723 040544      3728 040545      3732 040547      3733 040556      3734 040563      3735 040572      3736 040574
   3737 040601      3738 040625      3739 040647      3740 040650      3742 040676      3745 040720      3746 040723
   3747 040757      3748 041000      3749 041033      3750 041057      3751 041060      3752 041062      3754 041110
   3756 041113      3757 041123      3758 041125      3759 041135      3760 041137      3769 041140      3772 041142
   3773 041153      3774 041156      3775 041176      3776 041231      3777 041255      3778 041256      3779 041260
   3781 041306      3783 041311      3784 041323      3785 041326      3786 041346      3787 041401      3788 041425
   3789 041426      3790 041430      3792 041456      3794 041461      3799 041462      3805 041464      3806 041473
   3808 041555      3849 041563      3851 041564      3852 041567      3853 041573      3856 041630      3857 041652
   3858 041653      3860 041671      3862 041704      3864 041717      3866 041732      3868 041745      3870 041760
   3872 041773      3875 042006      3877 042035      3878 042062      3879 042063      3880 042100      3881 042104
   3882 042110      3883 042130      3885 042131      3886 042135      3889 042155      3890 042156      3892 042166
   3894 042176      3896 042206      3898 042216      3900 042226      3902 042236      3904 042246      3906 042255
   3910 042256      3914 042260      3915 042270      3916 042275      3917 042302      3918 042306      3919 042310
   3920 042317      3921 042331      3923 042333      3927 042334      3929 042335      3930 042340      3931 042351
   3932 042364      3933 042405      3934 042412      3935 042417      3936 042435      3938 042436      3941 042446
   3943 042457      3944 042461      3946 042466      3948 042522      3950 042544      3951 042545      3952 042555
   3953 042562      3955 042563      3957 042634      3958 042662      3961 042663      3963 042664      3964 042666
   3965 042670      3966 042674      3967 042676      3968 042700      3969 042702      3970 042704      3971 042706
   3972 042712      3973 042714      3974 042725      3975 042740      3976 042761      3977 042766      3978 042772
   3979 043007      3981 043022      3983 043026      3984 043033      3985 043051      3986 043052      3987 043055
   3989 043130      3990 043131      3991 043157      3995 043172      3999 043173      4001 043174      4002 043201
   4003 043217      4005 043220      4010 043221      4027 043222      4028 043223      4029 043225      4030 043233
   4031 043235      4032 043237      4033 043242      4034 043251      4035 043274      4036 043305      4037 043307
   4038 043311      4039 043313      4041 043317


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
