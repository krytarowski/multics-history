	COMPILATION LISTING OF SEGMENT upd_acl_task_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1722.1 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 upd_acl_task_:	procedure;
       12 
       13 
       14 /*
       15*
       16*	This procedure includes all acl task primitives for the Multics Online
       17*	Updater; the following are entries:
       18*
       19*		upd_acl_task_$list		list acl
       20*		upd_acl_task_$add		add acl entries
       21*		upd_acl_task_$delete	delete acl entries
       22*		upd_acl_task_$replace	replace acl
       23*		upd_acl_task_$list_inacl	list IACL of the target dir
       24*
       25*      *   Calling sequences are identical, being
       26*
       27*	     call upd_acl_task_$xxx (ctlw, areap, parentp, acode, asev, taskp, seqno,
       28*		dir, seg, msgseg, uid, ap, an, recover);
       29*
       30*	     (1)	ctlw	bit(36) aligned	updater task control word
       31*	     (2)	areap	ptr		caller-supplied area
       32*	     (3)	parentp	ptr		pointer to parent arglist
       33*	     (4)	acode	fixed bin(35)	status code
       34*	     (5)	asev	fixed bin		severity code
       35*	     (6)	taskp	ptr init(null)	task pointer
       36*	     (7)	seqno	fixed bin		task sequence no.
       37*	     (8)	dir	char(168)		dirname of affected segment
       38*	     (9)	seg	char(32)		entryname of segment
       39*	    (10)  msgseg	char(32)		entryname of segment for use in messages
       40*	    (11)	uid	bit(36) aligned	unique id of segment (may be ""b)
       41*	    (12)	ap	ptr		pointer to acl structure
       42*	    (13)	an	fixed bin		size of acl structure
       43*	    (14)  recover	bit(1)		on if upd_acl_task_$replace should give this user and
       44*					*.SysDaemon.*  rwa access to segment when running
       45*					in "reverse" mode.
       46*	*   (15)  rings	(3) fixed bin(5)	Extra arg for the "list_inacl" entry.  Determines
       47*					the ring of the IACL to be listed.
       48*	These entry points are restartable, e.g. after a system or process
       49*	failure, provided that all parameters are preserved as of the time
       50*	of the interruption.  Note, however, that severity 1 errors may occur
       51*	if upd_acl_task_$delete is restarted, due to limitations in hardcore
       52*	procedures.  "acode", "asev", and "taskp" are expected to be initialized
       53*	to "0", "0", and "null" respectively.  The "list" entry in addition
       54*	expects "ap" to be initially null.
       55*
       56*	P. Bos, May 1972
       57*
       58*	Modified Apr. 3, 1973 by Peter B. Kelley	to change acl structures and calls to
       59*						use the new hcs_ acl primitives.
       60*	Modified Jun. 1973 by P.B. Kelley		change to acl_form_sw because of drop
       61*						of bit 2 in options to print_acl_; also renamed
       62*						print_acl_ to upd_print_acl_.
       63*	Modified Mar. 1980 by P. B. Kelley
       64*	     The entry upd_acl_task_$list_inacl was added to list the IACL
       65*	     of the target directory.
       66*
       67*          Modified: 09/04/81 by GA Texada to call appropriate hcs_ entries on linkage error.
       68*
       69**/
       70 
       71 /**/
       72 
       73 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       74 
       75      dcl	ctlw			bit(36) aligned,	/* updater control word */
       76 	areap			ptr,		/* caller area pointer */
       77 	parentp			ptr,		/* pointer to parent arglist */
       78 	acode			fixed bin(35),	/* status code */
       79 	asev			fixed bin,	/* severity code */
       80 	taskp			ptr,		/* task pointer */
       81 	seqno			fixed bin,	/* task sequence no., for ordering */
       82 	dir			char(168),	/* dirname of affected segment */
       83 	seg			char(32),		/* entryname of segment */
       84 	msgseg			char(32),		/* entryname of segment used in messages.	*/
       85 						/* guaranteed not to be a unique name.		*/
       86 	uid			bit(36) aligned,	/* unique id of segment */
       87 	ap			ptr,		/* pointer to acl structure */
       88 	an			fixed bin,	/* acl count */
       89 	recover			bit(1);		/* on if OK to run "replace" in "reverse" */
       90 dcl
       91 	rings (3)			fixed bin(5),	/* for the "list_inacl" entry */
       92 	Parent_dir		char(168),	/* parent dir of the target seg */
       93 	Idir			char(168);	/* list the INACL of this dir */
       94 
       95      dcl	cu_$arg_list_ptr		entry (ptr),
       96 	cv_acl_			entry (ptr, fixed bin, char(*), fixed bin, bit(*)),
       97 	expand_pathname_		entry ( char(*), char(*), char(*), fixed bin(35)),
       98 	get_group_id_$tag_star	entry returns (char(32)),
       99 	add_acl_entries_entry	entry (char(*), char(*), ptr, fixed bin, fixed bin(35)) variable,
      100 	delete_acl_entries_entry	entry (char(*), char(*), ptr, fixed bin, fixed bin(35)) variable,
      101 	replace_acl_entry		entry (char(*), char(*), ptr, fixed bin, bit(1), fixed bin(35)) variable,
      102 	hcs_$add_acl_entries	entry (char(*), char(*), ptr, fixed bin, fixed bin(35)),
      103 	hcs_$delete_acl_entries	entry (char(*), char(*), ptr, fixed bin, fixed bin(35)),
      104 	hcs_$list_acl		entry (char(*), char(*), ptr, ptr, ptr, fixed bin, fixed bin(35)),
      105 	hcs_$list_inacl		entry ( char(*), char(*), ptr, ptr, ptr, fixed bin, fixed bin(5), fixed bin(35)),
      106 	hcs_$replace_acl		entry (char(*), char(*), ptr, fixed bin, bit(1), fixed bin(35)),
      107 	ioa_$ioa_stream		entry options (variable),
      108 	upd_print_acl_		entry (ptr, fixed bin, bit(*) aligned),
      109 	upd_add_task_		entry (char(*) aligned, ptr),
      110 	installation_tools_$add_acl_entries	entry (char(*), char(*), ptr, fixed bin, fixed bin(35)),
      111 	installation_tools_$delete_acl_entries	entry (char(*), char(*), ptr, fixed bin, fixed bin(35)),
      112 	installation_tools_$replace_acl	entry (char(*), char(*), ptr, fixed bin, bit(1) aligned, fixed bin(35)),
      113 	upd_status_$long		entry (char(*), char(*), fixed bin(1), ptr, ptr, fixed bin(35)),
      114 	upd_task_err_		entry options (variable);
      115 
      116      dcl (addr, bit, fixed, null)	builtin;
      117 
      118      dcl linkage_error		condition;
      119 
      120      dcl (error_table_$bad_ring_brackets,
      121 	error_table_$empty_acl,
      122 	error_table_$newnamerr,
      123 	error_table_$non_matching_uid,
      124 	error_table_$user_not_found)	ext fixed bin(35);
      125 
      126      dcl	acl_form_sw (5)		bit(3) aligned int static init (
      127 				     "100"b,		/* e = 1	*/
      128 				     "110"b,		/* e = 2	*/
      129 				     "010"b,		/* e = 3	*/
      130 				     "110"b,		/* e = 4	*/
      131 				     "100"b),		/* e = 5  */
      132 	entry (5)			char(32) aligned int static init (
      133 				     "upd_acl_task_$list",		/* e = 1	*/
      134 				     "upd_acl_task_$add",		/* e = 2	*/
      135 				     "upd_acl_task_$delete",		/* e = 3	*/
      136 			 	     "upd_acl_task_$replace",		/* e = 4	*/
      137 				     "upd_acl_task_$list_inacl");	/* e = 5  */
      138      dcl	string			char(52);		/* return string for cv_acl_ */
      139 
      140      dcl	msg (5)			char(12) aligned int static init (
      141 				"List ACL", "Set ACL", "Delete ACL", "Replace ACL", "List INACL");
      142 
      143      dcl	code			fixed bin(35),	/* status code */
      144 	e			fixed bin,	/* entry index */
      145          (i, n)			fixed bin,	/* random */
      146 	sev			fixed bin;	/* severity code */
      147 
      148      dcl	logsw			bit(1) aligned,	/* non-zero if printing */
      149 	rsw			bit(1) aligned,	/* non-zero if processing in reverse direction	*/
      150 	runsw			bit(1) aligned;	/* non-zero if processing */
      151 
      152      dcl	argp			ptr,		/* arglist pointer */
      153 	cp			ptr,		/* base pointer for expanded control word */
      154 	p			ptr;		/* random */
      155 
      156      dcl	1 c			aligned based (cp),	/* exploded control word */
      157 	 (2 rsw			bit(1),		/* non-zero if in reverse mode */
      158 	  2 tasksw		bit(1),		/* non-zero if to set up task */
      159 	  2 compsw		bit(1),		/* non-zero if compile-only task */
      160 	  2 runsw			bit(1),		/* non-zero if call to be processed immediately */
      161 	  2 trunsw		bit(1),		/* non-zero if subtask list to be processed */
      162 	  2 logsw			bit(1),		/* non-zero if in print mode */
      163 	  2 errsw			bit(1),		/* non-zero if to print error tasks only */
      164 	  2 briefsw		bit(1),		/* ignored */
      165 	  2 detailsw		bit(1),		/* non-zero if to list acl when logsw is non-zero */
      166 	  2 clear_code_sw		bit(1)) unal;	/* non-zero if error codes are to be cleared. */
      167 
      168      dcl	1 stat			aligned,		/* data structure for status_ */
      169 	 (2 type			bit(2),		/* entry type */
      170 	  2 nnames		bit(16),		/* number of names returned */
      171 	  2 nrp			bit(18),		/* rel pointer to name array */
      172 	  2 dtm			bit(36),		/* date/time modified */
      173 	  2 dtu			bit(36),		/* date/time used */
      174 	  2 mode			bit(5),		/* t, r, e, w, a */
      175 	  2 pad			bit(13),		/* unused */
      176 	  2 recs			bit(18),		/* pages used */
      177 	  2 dtd			bit(36),		/* date/time dumped */
      178 	  2 dtem			bit(36),		/* date/time entry modified */
      179 	  2 acct			bit(36),		/* accounting data */
      180 	  2 curlen		bit(12),		/* length of segment */
      181 	  2 bitcnt		bit(24),		/* bitcount of segment */
      182 	  2 did			bit(4),		/* device id */
      183 	  2 mdid			bit(4),		/* ? */
      184 	  2 copysw		bit(1),		/* segment copy switch */
      185 	  2 pad2			bit(9),		/* unused */
      186 	  2 rbs (0:2)		bit(6),		/* ring brackets */
      187 	  2 uid			bit(36)) unal;	/* unique id */
      188 
      189      dcl	1 acl (an)		aligned based (ap),	/* acl array */
      190 	  2 userid		char(32),		/* user name for this entry */
      191 	  2 mode			bit(36),		/* 1-3 "rew", rest 0 */
      192 	  2 pad			bit(36),		/* must be 0 */
      193 	  2 code			fixed bin(35);	/* status code */
      194 
      195      dcl	1 acle 			aligned,		/* a temporary ACL array, with only one element.	*/
      196 	  2 userid		char(32),		/* user name for this entry */
      197 	  2 mode			bit(36),		/* 1-3 "rew", rest 0 */
      198 	  2 pad			bit(36) init ("0"b),/* must be 0 */
      199 	  2 code			fixed bin(35);	/* status code */
      200 
      201      dcl	1 del_acl (an)		aligned,		/* acl array for delete_acl_entries */
      202 	  2  userid		char(32),		/* user name for entry */
      203 	  2  code			fixed bin(35);	/* status code */
      204 
      205 
      206 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      207 
      208 list:	entry (ctlw, areap, parentp, acode, asev, taskp, seqno, dir, seg, msgseg, uid, ap, an);
      209 
      210 	if ctlw & "10000000011"b then			/* this entry doesn't run in "reverse" or */
      211 	     return;				/* "clear" modes. return. */
      212 	e = 1;					/* set transfer vector index */
      213 	go to common;				/* join common code */
      214 
      215 
      216 add:	entry (ctlw, areap, parentp, acode, asev, taskp, seqno, dir, seg, msgseg, uid, ap, an);
      217 
      218 	if ctlw & "10000000001"b then			/* this entry doesn't run in "reverse" or */
      219 	     return;				/* "clear uid" modes */
      220 	e = 2;					/* transfer vector index */
      221 	go to common;				/* skip */
      222 
      223 
      224 delete:	entry (ctlw, areap, parentp, acode, asev, taskp, seqno, dir, seg, msgseg, uid, ap, an);
      225 
      226 	if ctlw & "10000000001"b then			/* this entry doesn't run in "reverse" or */
      227 	     return;				/* "clear uid" modes */
      228 	e = 3;					/* transfer vector index */
      229 	do i = 1 to an;				/* transfer regular acl structure into  */
      230 	     del_acl(an).userid = acl(an).userid;	/* "delete" acl structure  */
      231 	     del_acl(an).code = acl(an).code;		/* copy userid and codes  */
      232 	     end;
      233 	go to common;				/* join common code */
      234 
      235 
      236 replace:	entry (ctlw, areap, parentp, acode, asev, taskp, seqno, dir, seg, msgseg, uid, ap, an, recover);
      237 
      238 	if ctlw & "00000000001"b then			/* this entry doesn't run in "clear uid" mode */
      239 	     return;
      240 	if ctlw & "1"b then if ^recover then		/* this entry only runs in "reverse" mode if */
      241 	     return;				/* full recovery is possible. */
      242 	e = 4;					/* transfer vector index */
      243 	go to common;
      244 
      245 
      246 list_inacl:  entry (ctlw, areap, parentp, acode, asev, taskp, seqno, dir, seg, msgseg, uid, ap, an, rings);
      247 
      248 	if ctlw & "10000000011"b then			/* this entry doesn't run in "reverse" or */
      249 	     return;				/* "clear" modes. return. */
      250 	e = 5;					/* set transfer vector index */
      251 
      252 
      253 
      254 common:	call cu_$arg_list_ptr (argp);			/* locate arglist */
      255 	cp = addr (ctlw);				/* get pointer to control word */
      256 	rsw = c.rsw;				/* set reverse switch from control word.	*/
      257 	logsw = c.logsw;				/* non-zero if to print */
      258 	if c.errsw then if asev = 0 then		/* errors only to be printed */
      259 	     logsw = "0"b;				/* customer is always right */
      260 	runsw = c.runsw | c.trunsw;			/* non-zero if to process */
      261 
      262 	if c.clear_code_sw then			/* if in "clear code" mode, then clear acl codes */
      263 	     if ap ^= null then do i = 1 to an;
      264 		acl(i).code = 0;
      265 		end;
      266 
      267 	if c.tasksw then				/* is this a task call? */
      268 	     call upd_add_task_((entry(e)), argp);	/* yes, do it */
      269 
      270 	if logsw then do;				/* user is nosy */
      271 	     if e = 5
      272 		then call ioa_$ioa_stream ("installation_list_", "^5x^15a^a  (ring ^d)", msg(e), dir, rings(1));
      273 	     else do;
      274 		if seg = msgseg then
      275 		     call ioa_$ioa_stream ("installation_list_", "^5x^15a^a>^a", msg(e), dir, seg);
      276 		else
      277 		     call ioa_$ioa_stream ("installation_list_", "^5x^15a^a>^a  (^a)", msg(e), dir, seg, msgseg);
      278 	     end;
      279 	end;
      280 
      281 	if runsw then do;				/* are we to process call now? */
      282 	     if uid ^= ""b then do;			/* does caller want uid verified? */
      283 		call upd_status_$long (dir, seg, 1, addr(stat), null, code);
      284 		if code = 0 then if uid ^= stat.uid then	/* does it match? */
      285 		     code = error_table_$non_matching_uid;	/* no */
      286 		if code ^= 0 then			/* success? */
      287 		     go to aclerr;			/* no, go give error */
      288 		end;
      289 	     on linkage_error begin;
      290 		add_acl_entries_entry = hcs_$add_acl_entries;
      291 		delete_acl_entries_entry = hcs_$delete_acl_entries;
      292 		replace_acl_entry = hcs_$replace_acl;
      293 		goto revert_linkage_error;
      294 		end;
      295 
      296 	     replace_acl_entry = installation_tools_$replace_acl;
      297 	     delete_acl_entries_entry =  installation_tools_$delete_acl_entries;
      298 	     add_acl_entries_entry = installation_tools_$add_acl_entries;
      299 revert_linkage_error:
      300 	     revert linkage_error;
      301 	     if ^rsw then				/* if running forward, then		*/
      302 		go to forward(e);			/* skip to proper function.*/
      303 	     else					/* otherwise, we're running in reverse for	*/
      304 		go to reverse;			/* upd_acl_task_$replace.	*/
      305 	     end;
      306 	go to pracl;				/* skip to print acl */
      307 
      308 
      309 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      310 
      311 
      312 forward(1):
      313 	if ap ^= null then				/* list acl task, see if already done */
      314 	     go to pracl;				/* yes, skip processing again */
      315 	an = 0;					/* zero count */
      316 	call hcs_$list_acl (dir, seg, areap, p, null, n, code);/* ask, and ye shall receive */
      317 	if code ^= 0 then				/* was there an error? */
      318 	     go to aclerr;				/* yes, is fatal */
      319 	an = n;					/* set array count */
      320 	ap = p;					/* and pointer (set pointer last) */
      321 	go to pracl;				/* skip to print generated structure, if wanted */
      322 
      323 
      324 forward(2):
      325 
      326 
      327 	call add_acl_entries_entry (dir, seg, ap, an, code);	/* add acl task, call ring 1 entry */
      328 forward2a:
      329 	if code ^= 0 then if code ^= error_table_$newnamerr then if code ^= error_table_$bad_ring_brackets then
      330 	     go to aclerr;				/* any other error is fatal */
      331 	go to ckacl;				/* no fatal error, check for unprocessed entries */
      332 
      333 
      334 forward(3):
      335 
      336 
      337 	call delete_acl_entries_entry (dir,seg,addr(del_acl),an,code); /* delete acl task, call ring 1 */
      338 	do i = 1 to an;				/* put info back into "standard" acl structure */
      339 	     acl(an).code = del_acl(an).code;		/* "userid" will remain the same */
      340 	     end;					/* so just copy the codes   */
      341 	if code ^= 0 then if code ^= error_table_$user_not_found then if code ^= error_table_$newnamerr then
      342 	     go to aclerr;				/* fatal error */
      343 	go to ckacl;				/* no, go check acl codes */
      344 
      345 
      346 forward(4):
      347 	if (ap = null) | (an = 0) then		/* if there's no replacement ACL */
      348 	     go to pracl;				/* then we're done. */
      349 
      350 
      351 	call replace_acl_entry (dir, seg, ap, an, "1"b, code); /* replace acl task, ask ring 1 */
      352 	go to forward2a;				/* join code for add function */
      353 
      354 
      355 forward(5):
      356 	if ap ^= null then				/* list acl task, see if already done */
      357 	     go to pracl;				/* yes, skip processing again */
      358 	an = 0;					/* zero count */
      359 	call expand_pathname_ ( dir, Parent_dir, Idir, code);
      360 	if code ^= 0
      361 	     then go to aclerr;
      362 	call hcs_$list_inacl (Parent_dir, Idir, areap, p, null, n, rings(1), code);/* ask, and ye shall receive */
      363 	if code ^= 0 | n = 0			/* was there an error? */
      364 	     then go to aclerr;			/* yes, is fatal */
      365 	an = n;					/* set array count */
      366 	ap = p;					/* and pointer (set pointer last) */
      367 	go to pracl;				/* skip to print generated structure, if wanted */
      368 
      369 
      370 reverse:	acle.userid = get_group_id_$tag_star();		/* replace ACL with one giving this user rw access 	*/
      371 	acle.mode = "101"b;
      372 	acle.code = 0;
      373 	call replace_acl_entry (dir, seg, addr (acle), 1, "0"b, code);
      374 	if code ^= 0 then				/* any error is fatal.	*/
      375 	     go to aclerr;
      376 	go to pracl;
      377 
      378 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      379 
      380 
      381 
      382 /**/
      383 
      384 
      385 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      386 
      387 
      388 aclerr:	if e = 5 then do;
      389 	     code = error_table_$empty_acl;
      390 	     call upd_task_err_ (code, 3, argp, (entry(e)), "^/Referencing ^a  (ring ^d) .", dir, rings(1));
      391 	end;
      392 	else do;
      393 	     if seg = msgseg then
      394 		call upd_task_err_ (code, 3, argp, (entry(e)), "^/Referencing ^a>^a .", dir, seg);
      395 	     else
      396 		call upd_task_err_ (code, 3, argp, (entry(e)), "^/Referencing ^a>^a^/(^a>^a).", dir, seg, dir, msgseg);
      397 	end;
      398 	go to pracl;				/* go print acl if needed */
      399 
      400 
      401 ckacl:	do i = 1 to an;				/* here to check for error on acl entries */
      402 	     code = acl(i).code;			/* extract status code for this entry */
      403 	     if code = error_table_$user_not_found then	/* happens on delete function */
      404 		sev = 1;				/* and is severity 1 warning */
      405 	     else if code ^= 0 then			/* any other code means unprocessed entry */
      406 		sev = 2;				/* severity 2 */
      407 	     if code ^= 0 then do;			/* if we have an error */
      408 		call cv_acl_(ap, i, string, n, acl_form_sw(e) & "110"b);	/* format acl entry for error msg */
      409 		if seg = msgseg then
      410 		     call upd_task_err_(code, sev, argp, (entry(e)),
      411 			"^/Referencing ^a>^a .^/Offending entry is:^-^a .",
      412 			dir, seg, string);
      413 		else
      414 		     call upd_task_err_(code, sev, argp, (entry(e)),
      415 			"^/Referencing ^a>^a^/(^a>^a).^/Offending entry is:^-^a.",
      416 			dir, seg, dir, msgseg, string);
      417 		end;
      418 	     end;
      419 
      420 pracl:	if logsw then				/* reenter here to print acl for user */
      421 	     if (c.detailsw | c.errsw) then		/* .. with proper options */
      422 		call upd_print_acl_(ap, an, (acl_form_sw(e)));
      423 
      424 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      425 
      426 
      427 	end upd_acl_task_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1513.2  upd_acl_task_.pl1                 >dumps>old>recomp>upd_acl_task_.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Idir                            000152 automatic       char(168)                unaligned dcl 90 set ref 359* 362*
Parent_dir                      000100 automatic       char(168)                unaligned dcl 90 set ref 359* 362*
acl                                    based           structure                array level 1 dcl 189
acl_form_sw                     000055 constant        bit(3)                   initial array dcl 126 ref 408 420
acle                            000314 automatic       structure                level 1 dcl 195 set ref 373 373
acode                                  parameter       fixed bin(35,0)          dcl 75 ref 208 216 224 236 246
add_acl_entries_entry           000224 automatic       entry variable           dcl 95 set ref 290* 298* 324
addr                                                   builtin function         dcl 116 ref 255 283 283 334 334 373 373
an                                     parameter       fixed bin(17,0)          dcl 75 set ref 201 208 216 224 229 230 230 231 231
                                                                                  236 246 262 315* 319* 324* 334* 338 339 339 346
                                                                                  351* 358* 365* 401 420*
ap                                     parameter       pointer                  dcl 75 set ref 208 216 224 230 231 236 246 262 264
                                                                                  312 320* 324* 339 346 351* 355 366* 402 408* 420*
areap                                  parameter       pointer                  dcl 75 set ref 208 216 224 236 246 316* 362*
argp                            000274 automatic       pointer                  dcl 152 set ref 254* 267* 390* 393* 395* 409* 413*
asev                                   parameter       fixed bin(17,0)          dcl 75 ref 208 216 224 236 246 258
c                                      based           structure                level 1 dcl 156
clear_code_sw             0(09)        based           bit(1)                   level 2 packed unaligned dcl 156 ref 262
code                     10     000327 automatic       fixed bin(35,0)          array level 2 in structure "del_acl" dcl 201
                                                                                  in procedure "upd_acl_task_" set ref 231* 339
code                     12     000314 automatic       fixed bin(35,0)          level 2 in structure "acle" dcl 195 in procedure
                                                                                  "upd_acl_task_" set ref 372*
code                            000263 automatic       fixed bin(35,0)          dcl 143 in procedure "upd_acl_task_" set ref 283*
                                                                                  284 284* 286 316* 317 324* 328 328 328 334* 341
                                                                                  341 341 351* 359* 360 362* 363 373* 374 389* 390*
                                                                                  393* 395* 402* 403 405 407 409* 413*
code                     12            based           fixed bin(35,0)          array level 2 in structure "acl" dcl 189
                                                                                  in procedure "upd_acl_task_" set ref 231 264* 339*
                                                                                  402
cp                              000276 automatic       pointer                  dcl 152 set ref 255* 256 257 258 260 260 262 267 420
                                                                                  420
ctlw                                   parameter       bit(36)                  dcl 75 set ref 208 210 216 218 224 226 236 238 240
                                                                                  246 248 255
cu_$arg_list_ptr                000030 constant        entry                    external dcl 95 ref 254
cv_acl_                         000032 constant        entry                    external dcl 95 ref 408
del_acl                         000327 automatic       structure                array level 1 dcl 201 set ref 334 334
delete_acl_entries_entry        000230 automatic       entry variable           dcl 95 set ref 291* 297* 334
detailsw                  0(08)        based           bit(1)                   level 2 packed unaligned dcl 156 ref 420
dir                                    parameter       char(168)                unaligned dcl 75 set ref 208 216 224 236 246 271*
                                                                                  274* 276* 283* 316* 324* 334* 351* 359* 373* 390*
                                                                                  393* 395* 395* 409* 413* 413*
e                               000264 automatic       fixed bin(17,0)          dcl 143 set ref 212* 220* 228* 242* 250* 267 271 271
                                                                                  274 276 301 388 390 393 395 408 409 413 420
entry                           000005 constant        char(32)                 initial array dcl 126 ref 267 390 393 395 409 413
error_table_$bad_ring_brackets  000072 external static fixed bin(35,0)          dcl 120 ref 328
error_table_$empty_acl          000074 external static fixed bin(35,0)          dcl 120 ref 389
error_table_$newnamerr          000076 external static fixed bin(35,0)          dcl 120 ref 328 341
error_table_$non_matching_uid   000100 external static fixed bin(35,0)          dcl 120 ref 284
error_table_$user_not_found     000102 external static fixed bin(35,0)          dcl 120 ref 341 403
errsw                     0(06)        based           bit(1)                   level 2 packed unaligned dcl 156 ref 258 420
expand_pathname_                000034 constant        entry                    external dcl 95 ref 359
get_group_id_$tag_star          000036 constant        entry                    external dcl 95 ref 370
hcs_$add_acl_entries            000040 constant        entry                    external dcl 95 ref 290
hcs_$delete_acl_entries         000042 constant        entry                    external dcl 95 ref 291
hcs_$list_acl                   000044 constant        entry                    external dcl 95 ref 316
hcs_$list_inacl                 000046 constant        entry                    external dcl 95 ref 362
hcs_$replace_acl                000050 constant        entry                    external dcl 95 ref 292
i                               000265 automatic       fixed bin(17,0)          dcl 143 set ref 229* 262* 264* 338* 401* 402 408*
installation_tools_$add_acl_entries
                                000060 constant        entry                    external dcl 95 ref 298
installation_tools_$delete_acl_entries
                                000062 constant        entry                    external dcl 95 ref 297
installation_tools_$replace_acl 000064 constant        entry                    external dcl 95 ref 296
ioa_$ioa_stream                 000052 constant        entry                    external dcl 95 ref 271 274 276
linkage_error                   000240 stack reference condition                dcl 118 ref 289 299
logsw                     0(05)        based           bit(1)                   level 2 in structure "c" packed unaligned dcl 156
                                                                                  in procedure "upd_acl_task_" ref 257
logsw                           000270 automatic       bit(1)                   dcl 148 in procedure "upd_acl_task_" set ref 257*
                                                                                  258* 270 420
mode                     10     000314 automatic       bit(36)                  level 2 dcl 195 set ref 371*
msg                             000010 internal static char(12)                 initial array dcl 140 set ref 271* 274* 276*
msgseg                                 parameter       char(32)                 unaligned dcl 75 set ref 208 216 224 236 246 274
                                                                                  276* 393 395* 409 413*
n                               000266 automatic       fixed bin(17,0)          dcl 143 set ref 316* 319 362* 363 365 408*
null                                                   builtin function         dcl 116 ref 262 283 283 312 316 316 346 355 362 362
p                               000300 automatic       pointer                  dcl 152 set ref 316* 320 362* 366
pad                      11     000314 automatic       bit(36)                  initial level 2 dcl 195 set ref 195*
parentp                                parameter       pointer                  dcl 75 ref 208 216 224 236 246
recover                                parameter       bit(1)                   unaligned dcl 75 ref 236 240
replace_acl_entry               000234 automatic       entry variable           dcl 95 set ref 292* 296* 351 373
rings                                  parameter       fixed bin(5,0)           array dcl 90 set ref 246 271* 362* 390*
rsw                             000271 automatic       bit(1)                   dcl 148 in procedure "upd_acl_task_" set ref 256*
                                                                                  301
rsw                                    based           bit(1)                   level 2 in structure "c" packed unaligned dcl 156
                                                                                  in procedure "upd_acl_task_" ref 256
runsw                     0(03)        based           bit(1)                   level 2 in structure "c" packed unaligned dcl 156
                                                                                  in procedure "upd_acl_task_" ref 260
runsw                           000272 automatic       bit(1)                   dcl 148 in procedure "upd_acl_task_" set ref 260*
                                                                                  281
seg                                    parameter       char(32)                 unaligned dcl 75 set ref 208 216 224 236 246 274
                                                                                  274* 276* 283* 316* 324* 334* 351* 373* 393 393*
                                                                                  395* 409 409* 413*
seqno                                  parameter       fixed bin(17,0)          dcl 75 ref 208 216 224 236 246
sev                             000267 automatic       fixed bin(17,0)          dcl 143 set ref 403* 405* 409* 413*
stat                            000302 automatic       structure                level 1 dcl 168 set ref 283 283
string                          000246 automatic       char(52)                 unaligned dcl 138 set ref 408* 409* 413*
taskp                                  parameter       pointer                  dcl 75 ref 208 216 224 236 246
tasksw                    0(01)        based           bit(1)                   level 2 packed unaligned dcl 156 ref 267
trunsw                    0(04)        based           bit(1)                   level 2 packed unaligned dcl 156 ref 260
uid                                    parameter       bit(36)                  dcl 75 in procedure "upd_acl_task_" ref 208 216 224
                                                                                  236 246 282 284
uid                      11     000302 automatic       bit(36)                  level 2 in structure "stat" packed unaligned dcl 168
                                                                                  in procedure "upd_acl_task_" set ref 284
upd_add_task_                   000056 constant        entry                    external dcl 95 ref 267
upd_print_acl_                  000054 constant        entry                    external dcl 95 ref 420
upd_status_$long                000066 constant        entry                    external dcl 95 ref 283
upd_task_err_                   000070 constant        entry                    external dcl 95 ref 390 393 395 409 413
userid                                 based           char(32)                 array level 2 in structure "acl" dcl 189
                                                                                  in procedure "upd_acl_task_" ref 230
userid                          000327 automatic       char(32)                 array level 2 in structure "del_acl" dcl 201
                                                                                  in procedure "upd_acl_task_" set ref 230*
userid                          000314 automatic       char(32)                 level 2 in structure "acle" dcl 195 in procedure
                                                                                  "upd_acl_task_" set ref 370*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
bit                                                    builtin function         dcl 116
fixed                                                  builtin function         dcl 116

NAMES DECLARED BY EXPLICIT CONTEXT.
aclerr                          001561 constant        label                    dcl 388 ref 286 317 328 341 360 363 374
add                             000274 constant        entry                    external dcl 216
ckacl                           002016 constant        label                    dcl 401 ref 331 343
common                          000446 constant        label                    dcl 254 ref 213 221 233 243
delete                          000313 constant        entry                    external dcl 224
forward                         000000 constant        label                    array(5) dcl 312 ref 301
forward2a                       001217 constant        label                    dcl 328 ref 352
list                            000255 constant        entry                    external dcl 208
list_inacl                      000432 constant        entry                    external dcl 246
pracl                           002257 constant        label                    dcl 420 ref 306 312 321 346 355 367 376 398
replace                         000374 constant        entry                    external dcl 236
reverse                         001476 constant        label                    dcl 370 ref 303
revert_linkage_error            001100 constant        label                    dcl 299 ref 293
upd_acl_task_                   000235 constant        entry                    external dcl 11

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2632        2736    2314        2642
Length      3170    2314       104         216     316          20

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
upd_acl_task_                       444 external procedure  is an external procedure.  
on unit on line 289                  64 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 msg                         upd_acl_task_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
upd_acl_task_            000100 Parent_dir                  upd_acl_task_
                         000152 Idir                        upd_acl_task_
                         000224 add_acl_entries_entry       upd_acl_task_
                         000230 delete_acl_entries_entry    upd_acl_task_
                         000234 replace_acl_entry           upd_acl_task_
                         000246 string                      upd_acl_task_
                         000263 code                        upd_acl_task_
                         000264 e                           upd_acl_task_
                         000265 i                           upd_acl_task_
                         000266 n                           upd_acl_task_
                         000267 sev                         upd_acl_task_
                         000270 logsw                       upd_acl_task_
                         000271 rsw                         upd_acl_task_
                         000272 runsw                       upd_acl_task_
                         000274 argp                        upd_acl_task_
                         000276 cp                          upd_acl_task_
                         000300 p                           upd_acl_task_
                         000302 stat                        upd_acl_task_
                         000314 acle                        upd_acl_task_
                         000327 del_acl                     upd_acl_task_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_var_desc       call_ext_out_desc   call_ext_out        return              tra_ext             alloc_auto_adj
enable              ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_list_ptr              cv_acl_                       expand_pathname_              get_group_id_$tag_star
hcs_$add_acl_entries          hcs_$delete_acl_entries       hcs_$list_acl                 hcs_$list_inacl
hcs_$replace_acl              installation_tools_$add_acl_entries
installation_tools_$delete_acl_entries                      installation_tools_$replace_acl
ioa_$ioa_stream               upd_add_task_                 upd_print_acl_                upd_status_$long
upd_task_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_ring_brackets                              error_table_$empty_acl        error_table_$newnamerr
error_table_$non_matching_uid error_table_$user_not_found




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    195 000223       201 000224        11 000234       208 000243       210 000263       212 000267       213 000271
    216 000272       218 000302       220 000306       221 000310       224 000311       226 000321       228 000325
    229 000327       230 000336       231 000354       232 000357       233 000361       236 000362       238 000402
    240 000406       242 000415       243 000417       246 000420       248 000440       250 000444       254 000446
    255 000455       256 000460       257 000463       258 000467       260 000475       262 000506       264 000524
    265 000531       267 000533       270 000561       271 000563       274 000634       276 000706       281 000751
    282 000753       283 000756       284 001020       286 001031       289 001033       290 001047       291 001054
    292 001057       293 001062       296 001065       297 001072       298 001075       299 001100       301 001101
    303 001105       306 001106       312 001107       315 001114       316 001115       317 001156       319 001160
    320 001163       321 001165       324 001166       328 001217       331 001226       334 001227       338 001262
    339 001272       340 001305       341 001307       343 001316       346 001317       351 001326       352 001364
    355 001365       358 001372       359 001373       360 001416       362 001420       363 001465       365 001471
    366 001473       367 001475       370 001476       371 001510       372 001512       373 001513       374 001556
    376 001560       388 001561       389 001564       390 001567       391 001643       393 001644       395 001733
    398 002015       401 002016       402 002026       403 002034       405 002042       407 002046       408 002050
    409 002103       413 002171       418 002255       420 002257       427 002311


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
