	COMPILATION LISTING OF SEGMENT list_vols
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/20/88  1033.1 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,^inddcls */
       13 
       14 list_vols: proc;
       15 
       16 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       17 /*									*/
       18 /* Initial coding by T. H. VanVleck, 1975.					*/
       19 /* Modified August 1977 by T. Casey						*/
       20 /*          to add -records, -records_left, and active function processing.		*/
       21 /* Modified January 1978 by T. Casey						*/
       22 /*          to print short lines to accomodate narrow-carriage terminals.		*/
       23 /* Modified March 1979 by T. Casey						*/
       24 /*          to fix arg processing bug in -records and -records_left.			*/
       25 /* Modified February 1982 by JM Stansbury					*/
       26 /*          1. to output information within 80 columns,				*/
       27 /*          2. to add "I" flag to indicate PVs inhibited for segment creation,		*/
       28 /*          3. to add Records/VTOCEs Used reporting capability,			*/
       29 /*          4. to add percentage used/left figures for Records and VTOCEs,		*/
       30 /*          5. to add average segment size per PV,				*/
       31 /*          6. to remove printing of "P" flag indicating partitions.			*/
       32 /*          7. to allow processing of multiple LVs via the -lv control arg		*/
       33 /*          8. to add -grand_total, -gtt control arg for command processing.		*/
       34 /* Modified June 1983 by Art Beattie						*/
       35 /*	  1. to maintain column alignment in displays				*/
       36 /*	  2. fix bug which nulled -lv argument in command line			*/
       37 /*									*/
       38 /*									*/
       39 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       40 
       41 
       42 /****^  HISTORY COMMENTS:
       43*  1) change(88-03-30,GWMay), approve(88-04-12,MCR7867),
       44*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
       45*     Changed ioa_ call controls to properly align output.
       46*                                                   END HISTORY COMMENTS */
       47 
       48 
       49 
       50 	Ilv = 0;
       51 	Ptemp (1) = null;
       52 	Ptemp (2) = null;
       53 	af_sw = "0"b;
       54 	entry_name = "list_vols";
       55 	given_lvnm (*) = "";
       56 	given_pvnm = "";
       57 	left_sw = "0"b;
       58 	used_sw = "0"b;
       59 	gtt_sw = "0"b;
       60 	lvsw = "0"b;
       61 	max_pvname_ln = 7;				/* column heading width for PV Name */
       62 	nprt = 0;
       63 	prev_lvnm = "";
       64 	pvsw = "0"b;
       65 	record_sw = "0"b;
       66 	totfreevtoc = 0;
       67 	totleft = 0;
       68 	totrec = 0;
       69 	totsw = "0"b;
       70 	totvtoc = 0;
       71 
       72 	error_proc = active_fnc_err_;
       73 	af_sw = "1"b;				/* assume we were called as an active function */
       74 
       75 	call cu_$af_return_arg (nargs, retp, retl, code); /* but check to be sure */
       76 	if code ^= 0 then do;
       77 	     if code = error_table_$not_act_fnc then do;	/* if not */
       78 		af_sw = ""b;			/* we will print the value instead */
       79 		error_proc = com_err_;
       80 		goto get_arg_count;			/* go get arg count for command args */
       81 	     end;
       82 	     else do;				/* should never happen, but ... */
       83 		call error_proc (code, entry_name);
       84 		return;
       85 	     end;
       86 	end;
       87 	goto get_args;				/* go get arguments */
       88 
       89 get_arg_count:
       90 	call cu_$arg_count (nargs);
       91 
       92 get_args:
       93 	do an = 1 to nargs;
       94 	     call cu_$arg_ptr (an, argp, argl, code);
       95 	     if code = 0 then do;
       96 		if bchr = "-lv" then do;
       97 		     pvsw = "0"b;
       98 		     lvsw = "1"b;
       99 NEXT_LV:		     an = an + 1;
      100 		     call cu_$arg_ptr (an, argp, argl, code);
      101 		     if code = error_table_$noarg then do;
      102 			if given_lvnm (1) = "" then do;
      103 						/* -lv given with no names */
      104 			     call error_proc (code, entry_name, "^/-lv must be followed by at least one LV name.");
      105 			     return;
      106 			end;
      107 			else
      108 			     goto work;
      109 		     end;
      110 		     if code ^= 0 then
      111 			goto gape1;
      112 		     if char (bchr, 1) = "-" then
      113 			goto CHECK_NEXT_ARG;
      114 		     else do;
      115 			Ilv = Ilv + 1;
      116 			if Ilv > dim (given_lvnm, 1) then do;
      117 			     call ioa_ ("
      118 Number of LVs given is greater than currently supported by this procedure.");
      119 			     return;
      120 			end;
      121 			given_lvnm (Ilv) = bchr;
      122 			if an = nargs then
      123 			     goto work;		/* be sure we don't skip any */
      124 		     end;
      125 		     goto NEXT_LV;
      126 		end;
      127 CHECK_NEXT_ARG:
      128 		if bchr = "-pv" then do;
      129 		     an = an + 1;
      130 		     call cu_$arg_ptr (an, argp, argl, code);
      131 		     if code ^= 0 then go to gape1;
      132 		     given_pvnm = bchr;
      133 		     pvsw = "1"b;
      134 		     lvsw = "0"b;
      135 		end;
      136 		else if bchr = "-tt" | bchr = "-total" | bchr = "-totals" then
      137 		     totsw = "1"b;
      138 		else if bchr = "-records" | bchr = "-record" | bchr = "-rec" then
      139 		     record_sw = "1"b;
      140 		else if bchr = "-records_left" | bchr = "-rec_left" | bchr = "-left" then do;
      141 		     used_sw = "0"b;
      142 		     if af_sw then
      143 			gtt_sw, record_sw, left_sw = "1"b;
      144 		     else
      145 			left_sw = "1"b;
      146 		end;
      147 		else if bchr = "-records_used" | bchr = "-rec_used" | bchr = "-used" then do;
      148 		     left_sw = "0"b;
      149 		     if af_sw then
      150 			record_sw, used_sw = "1"b;
      151 		     else
      152 			used_sw = "1"b;
      153 		end;
      154 		else if bchr = "-grand_total" | bchr = "-gtt" then
      155 		     if af_sw then do;
      156 			call error_proc (error_table_$badopt, entry_name, "^a", bchr);
      157 			return;
      158 		     end;
      159 		     else
      160 			record_sw, gtt_sw = "1"b;
      161 		else if char (bchr, 1) ^= "-" then do;
      162 		     lvsw = "1"b;
      163 		     Ilv = 1;
      164 						/* check for >1 LV name */
      165 		     if given_lvnm (Ilv) ^= "" then do;
      166 			if given_lvnm (Ilv) ^= bchr then
      167 			     call error_proc (error_table_$bad_arg, entry_name, "^/Multiple LVs must be preceded by the -lv control argument.");
      168 			return;
      169 		     end;
      170 		     given_lvnm (Ilv) = bchr;		/* default to this lv */
      171 		end;
      172 		else do;				/* bad arg */
      173 		     code = error_table_$badopt;
      174 gape:		     call error_proc (code, entry_name, bchr);
      175 		     return;
      176 		end;
      177 	     end;
      178 	     else do;
      179 gape1:		call error_proc (code, entry_name);	/* code was ^= 0 */
      180 		return;
      181 	     end;
      182 	end;
      183 work:
      184 	if ^used_sw then
      185 	     left_sw = "1"b;			/* default */
      186 	if ^af_sw then
      187 	     if record_sw & ^gtt_sw then
      188 		left_sw = "0"b;
      189 	if record_sw & (^pvsw | ^lvsw) then do;
      190 	     totsw = "1"b;
      191 	     if af_sw & record_sw then
      192 		left_sw = "0"b;
      193 	end;
      194 	if gtt_sw & record_sw & ^used_sw then
      195 	     left_sw = "1"b;
      196 
      197 	if af_sw & ^record_sw then do;
      198 	     call error_proc (0, entry_name, "^/The -records, -records_left or -records_used argument is required when used as an active function.");
      199 	     goto common_exit;
      200 	end;
      201 	on cleanup call clean_out;
      202 
      203 	call get_temp_segments_ (entry_name, Ptemp, code);
      204 	if Ptemp (1) = null () then do;
      205 	     call error_proc (code, entry_name, "^/Cannot get ptr to temp seg.");
      206 	     return;
      207 	end;
      208 	pvtp = Ptemp (1);				/* ptr to the PVT */
      209 	dtp = Ptemp (2);				/* ptr to the disk table */
      210 	call ring_zero_peek_$get_max_length ("pvt", pvt_size, code);
      211 						/* get max number of words */
      212 	if code ^= 0 then do;
      213 CANNOT_GET_PVT:
      214 	     call error_proc (code, entry_name, "pvt");
      215 	     call clean_out;
      216 	     return;
      217 	end;
      218 	call ring_zero_peek_$by_name ("pvt", 0, pvtp, pvt_size, code);
      219 						/* obtain pvt contents in user ring */
      220 	if code ^= 0 then goto CANNOT_GET_PVT;
      221 
      222 	pvt_arrayp = addr (pvt.array);
      223 	call mdc_$read_disk_table (dtp, code);		/* obtain disk table contents in user ring */
      224 	if code ^= 0 then do;
      225 	     call error_proc (code, entry_name, "^/Error from read_disk_table.");
      226 	     return;
      227 	end;
      228 
      229 	n = dt.n_entries;
      230 
      231 	begin;
      232 dcl  sindex (n) fixed bin;
      233 dcl  sname (n) char (32) aligned;
      234 
      235 	     sname (*) = "";
      236 	     if lvsw then do;
      237 		do Ilv = 1 to dim (given_lvnm, 1) while (given_lvnm (Ilv) ^= "");
      238 		     do i = 1 to n;
      239 			if dt.array (i).used
      240 			then if (given_lvnm (Ilv) = dt.lv_array (dt.array (i).lvx).lvname)
      241 			     then go to end_lvsw_loop;
      242 			if i = n then do;
      243 
      244 			     call error_proc (error_table_$logical_volume_not_defined, entry_name, given_lvnm (Ilv));
      245 			     goto common_exit;
      246 			end;
      247 		     end;				/* do loop on i */
      248 
      249 end_lvsw_loop:
      250 		end;
      251 	     end;
      252 
      253 	     do i = 1 to n;
      254 		sindex (i) = i;
      255 		if dt.array (i).lvx > 0 then
      256 		     call ioa_$rsnnl ("^a^a", sname (i), argl,
      257 			dt.lv_array (dt.array (i).lvx).lvname,
      258 			dt.drive_name (i));
      259 	     end;
      260 	     if ^(lvsw | pvsw) | totsw then		/* dont sort if only one required */
      261 		call idsort_ (sname, sindex, n);
      262 
      263 	     Ilv = 1;
      264 	     if ^totsw & ^record_sw then		/* if printing both lv and pv names */
      265 		do i = 1 to n;			/* be nice to users with narrow-carriage terminals */
      266 						/* and compute how wide to make the pvname column */
      267 		dtep = addr (dt.array (sindex (i)));
      268 		if dte.used then
      269 		     if (^lvsw | dt.lv_array (dte.lvx).lvname = given_lvnm (Ilv))
      270 			& (^pvsw | dte.pvname = given_pvnm) then do;
      271 			if length (rtrim (dte.pvname)) > max_pvname_ln then
      272 			     max_pvname_ln = length (rtrim (dte.pvname));
      273 			if lvsw then Ilv = Ilv + 1;
      274 		     end;
      275 	     end;
      276 
      277 
      278 	     if ^record_sw then
      279 		if totsw then
      280 		     call ioa_ ("
      281 Records^3x^[Used^;Left^]  %^4xVTOCEs^3x^[Used^;Left^]  %^3xPB/PD  LV Name^/",
      282 			used_sw, used_sw);
      283 		else if ^(pvsw | lvsw) | (^totsw & lvsw) then
      284 		     call ioa_ ("
      285 ^44xAvg ^va
      286 Drive   Records^2x^[Used^;Left^]  %  VTOCEs  ^[Used^;Left^]  %  Size^1x^va^2xPB/PD LV Name^/",
      287 			max_pvname_ln, "PV", used_sw, used_sw,
      288 			max_pvname_ln, "Name");
      289 
      290 	     Ilv = 1;
      291 loop_thru_pvs: do i = 1 to n;				/* go through all physical volumes (pv) */
      292 		pvtep = addr (my_pvt_array (sindex (i)));
      293 		dtep = addr (dt.array (sindex (i)));
      294 
      295 		if dte.used then			/* if this entry is used */
      296 		     if (^lvsw | dt.lv_array (dte.lvx).lvname = given_lvnm (Ilv))
      297 						/* and it pertains to a lv that we want */
      298 			& (^pvsw | dte.pvname = given_pvnm) then do;
      299 						/* and it pertains to a pv that we want */
      300 			n_vtoce = pvte.n_vtoce;
      301 						/* obtain number of vtoces */
      302 			nprt = nprt + 1;		/* remember that we found at least one pv */
      303 
      304 			if totsw then do;		/* if -total (-tt) */
      305 
      306 			     if dt.lv_array (dte.lvx).lvname ^= prev_lvnm then do;
      307 						/* if current lv ^= previous lv */
      308 						/* following 2 lines needed for rounding */
      309 				half_totrec = divide (totrec, 2, 35, 0);
      310 				half_vtoce = divide (totvtoc, 2, 35, 0);
      311 				if prev_lvnm ^= "" then /* if there was a previous lv, we have totals for it */
      312 				     if record_sw then
      313 					goto display_records;
      314 						/* either display its records */
      315 				     else do;
      316 					if used_sw then
      317 					     call ioa_ ("^6d  ^6d ^3d  ^6d  ^6d ^3d  ^5a  ^a",
      318 						totrec, totrec - totleft,
      319 						divide ((totrec - totleft) * 100 + half_totrec, totrec, 35, 0),
      320 						totvtoc, totvtoc - totfreevtoc,
      321 						divide ((totvtoc - totfreevtoc) * 100 + half_vtoce, totvtoc, 35, 0),
      322 						lvflags (prev_lvx), prev_lvnm);
      323 
      324 					else if left_sw then
      325 					     call ioa_ ("^6d  ^6d ^3d  ^6d  ^6d ^3d  ^5a  ^a",
      326 						totrec, totleft,
      327 						divide ((totleft) * 100 + half_totrec, totrec, 35, 0),
      328 						totvtoc, totfreevtoc,
      329 						divide ((totfreevtoc) * 100 + half_vtoce, totvtoc, 35, 0),
      330 						lvflags (prev_lvx), prev_lvnm);
      331 				     end;
      332 				if ^record_sw then do; /* if we get here with record_sw on, we are totaling all vols */
      333 				     prev_lvx = dte.lvx; /* remember lvx of new lv */
      334 				     prev_lvnm = dt.lv_array (prev_lvx).lvname;
      335 						/* remember name of new lv */
      336 				     totrec, totleft, totvtoc, totfreevtoc = 0;
      337 						/* zero the lv totals */
      338 				end;
      339 			     end;
      340 
      341 			     totrec = totrec + pvte.totrec; /* add pv figures to lv totals */
      342 			     totleft = totleft + pvte.nleft;
      343 			     totvtoc = totvtoc + n_vtoce;
      344 			     totfreevtoc = totfreevtoc + pvte.n_free_vtoce;
      345 			end;
      346 			else do;			/* not -tt, so print for each pv */
      347 			     if record_sw then do;	/* or, if entered at records entry, just one pv */
      348 				totleft = pvte.nleft;
      349 				goto display_records;
      350 			     end;
      351 			     if pvte.device_inoperative then
      352 				flag = "X";
      353 			     else flag = " ";
      354 			     if pvte.vacating then
      355 				flag1 = "I";
      356 			     else flag1 = " ";
      357 			     half_totrec = divide (pvte.totrec, 2, 35, 0);
      358 			     half_vtoce = divide (n_vtoce, 2, 35, 0);
      359 						/* will need this for rounding */
      360 			     if used_sw then do;
      361 				call ioa_ ("^8a^1a^1a^5d ^5d ^3d ^6d ^5d ^3d ^4d ^va  ^5a ^a",
      362 
      363 				     dte.drive_name, flag, flag1,
      364 				     pvte.totrec, pvte.totrec - pvte.nleft,
      365 						/* following is for rounded record percentage */
      366 				     divide ((pvte.totrec - pvte.nleft) * 100 + half_totrec, pvte.totrec, 35, 0),
      367 				     n_vtoce, n_vtoce - pvte.n_free_vtoce,
      368 						/* following is for rounded vtoce percentage */
      369 				     divide ((n_vtoce - pvte.n_free_vtoce) * 100 + half_vtoce, n_vtoce, 35, 0),
      370 				     (pvte.totrec - pvte.nleft) / max (1, (n_vtoce - pvte.n_free_vtoce)), max_pvname_ln,
      371 				     dte.pvname, lvflags ((dte.lvx)), dt.lv_array (dte.lvx).lvname);
      372 			     end;			/* end rec_used */
      373 			     if left_sw then do;
      374 				call ioa_ ("^8a^1a^1a^5d ^5d ^3d ^6d ^5d ^3d ^4d ^va  ^5a ^a",
      375 				     dte.drive_name, flag, flag1,
      376 				     pvte.totrec, pvte.nleft,
      377 				     divide ((pvte.nleft) * 100 + half_totrec, pvte.totrec, 35, 0),
      378 				     n_vtoce, pvte.n_free_vtoce,
      379 				     divide ((pvte.n_free_vtoce) * 100 + half_vtoce, n_vtoce, 35, 0),
      380 				     (pvte.totrec - pvte.nleft) / max (1, (n_vtoce - pvte.n_free_vtoce)), max_pvname_ln,
      381 				     dte.pvname, lvflags ((dte.lvx)), dt.lv_array (dte.lvx).lvname);
      382 			     end;			/* end rec_left */
      383 			end;			/* end not -tt */
      384 		     end;				/* end pv is of interest */
      385 	     end;					/* end loop thru all pv's */
      386 						/* see if there are more lv's to do */
      387 	     if lvsw then do;
      388 		Ilv = Ilv + 1;
      389 		if given_lvnm (Ilv) ^= "" then	/* there are more... */
      390 		     goto loop_thru_pvs;
      391 	     end;
      392 	end;					/* end begin block */
      393 
      394 	if nprt = 0 then do;
      395 	     if lvsw then
      396 		call error_proc (error_table_$logical_volume_not_defined, entry_name, given_lvnm (Ilv - 1));
      397 	     else if pvsw then
      398 		call error_proc (error_table_$pvid_not_found, entry_name, given_pvnm);
      399 	end;
      400 	else
      401 	     if record_sw then
      402 	     goto display_records;
      403 	else
      404 	     if totsw then do;
      405 	     half_totrec = divide (totrec, 2, 35, 0);
      406 	     half_vtoce = divide (totvtoc, 2, 35, 0);
      407 	     if used_sw then
      408 		call ioa_ ("^6d  ^6d ^3d  ^6d  ^6d ^3d  ^5a  ^a^/",
      409 		     totrec, totrec - totleft,
      410 		     divide ((totrec - totleft) * 100 + half_totrec, totrec, 35, 0),
      411 		     totvtoc, totvtoc - totfreevtoc,
      412 		     divide ((totvtoc - totfreevtoc) * 100 + half_vtoce, totvtoc, 35, 0),
      413 		     lvflags (prev_lvx), prev_lvnm);
      414 	     else if left_sw then
      415 		call ioa_ ("^6d  ^6d ^3d  ^6d  ^6d ^3d  ^5a  ^a^/",
      416 		     totrec, totleft,
      417 		     divide ((totleft) * 100 + half_totrec, totrec, 35, 0),
      418 		     totvtoc, totfreevtoc,
      419 		     divide ((totfreevtoc) * 100 + half_vtoce, totvtoc, 35, 0),
      420 		     lvflags (prev_lvx), prev_lvnm);
      421 						/* print totals accumulated for last lv */
      422 	end;
      423 	else
      424 	     call ioa_ ("");
      425 
      426 common_exit:
      427 	call clean_out;
      428 	return;
      429 
      430 /* Come back here to print or return a single records left figure */
      431 
      432 display_records:
      433 	if left_sw then totrec = totleft;		/* display records left if that's what user wants */
      434 	if used_sw then totrec = totrec - totleft;	/* display records used if that's what uer wants */
      435 	if af_sw then do;
      436 	     call ioa_$rsnnl ("^d", char7, i, totrec);
      437 	     ret = substr (char7, 1, i);
      438 	end;
      439 	else call ioa_ ("^d", totrec);
      440 
      441 	goto common_exit;
      442 
      443 
      444 lvflags: proc (lvx) returns (char (5));
      445 
      446 dcl  lvx fixed bin;
      447 dcl  retstr char (5) init ("");
      448 
      449 	if dt.lv_array (lvx).public then substr (retstr, 1, 2) = "pb";
      450 	if dt.lv_array (lvx).pdirs_ok then substr (retstr, 4, 2) = "pd";
      451 	return (retstr);
      452 
      453      end lvflags;
      454 
      455 clean_out:
      456      proc;
      457 
      458 	if Ptemp (1) ^= null () then
      459 	     call release_temp_segments_ (entry_name, Ptemp, code);
      460 	Ptemp (1) = null ();
      461      end clean_out;
      462 
      463 /* A U T O M A T I C */
      464 dcl  Ilv fixed bin,
      465      Ptemp (2) ptr,					/* ptrs for temp segs */
      466      af_sw bit (1),
      467      an fixed bin,
      468      argl fixed bin,
      469      argp ptr,
      470      char7 char (7),
      471      code fixed bin (35),
      472      entry_name char (12),
      473      flag char (1),
      474      flag1 char (1),
      475      given_lvnm (10) char (32),			/* array of LV names, to allow >1 */
      476      given_pvnm char (32),
      477      gtt_sw bit (1),
      478      half_totrec fixed bin (35),
      479      half_vtoce fixed bin (35),
      480      i fixed bin,
      481      left_sw bit (1),
      482      lvsw bit (1),
      483      max_pvname_ln fixed bin,
      484      n fixed bin,
      485      n_vtoce fixed bin,
      486      nargs fixed bin,
      487      nprt fixed bin,
      488      prev_lvnm char (32),
      489      prev_lvx fixed bin,
      490      pvsw bit (1),
      491      pvt_size fixed bin (19),
      492      record_sw bit (1),
      493      retl fixed bin,
      494      retp ptr,
      495      totfreevtoc fixed bin (35),
      496      totleft fixed bin (35),
      497      totrec fixed bin (35),
      498      totsw bit (1),
      499      totvtoc fixed bin (35),
      500      used_sw bit (1);
      501 
      502 /* E N T R Y   V A R I A B L E */
      503 dcl  error_proc entry variable automatic options (variable);
      504 
      505 /* C O N D I T I O N */
      506 dcl  cleanup condition;
      507 
      508 /* B A S E D */
      509 
      510 dcl  bchr char (argl) based (argp),
      511      1 my_pvt_array (pvt.max_n_entries) aligned like pvte based (pvt_arrayp),
      512      ret char (retl) varying based (retp);		/* active function return arg */
      513 
      514 /* E X T E R N A L   E N T R I E S */
      515 dcl  active_fnc_err_ entry options (variable),
      516      com_err_ entry options (variable),
      517      cu_$af_return_arg entry (fixed bin, ptr, fixed bin, fixed bin (35)),
      518      cu_$arg_count entry (fixed bin),
      519      cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35)),
      520      get_temp_segments_ entry (char (*), (*) ptr, fixed bin (35)),
      521      idsort_ entry ((*) char (32) aligned, (*) fixed bin, fixed bin),
      522      ioa_ entry options (variable),
      523      ioa_$rsnnl entry options (variable),
      524      mdc_$read_disk_table
      525 	entry (ptr, fixed bin (35)),
      526      release_temp_segments_
      527 	entry (char (*), (*) ptr, fixed bin (35)),
      528      ring_zero_peek_$by_name
      529 	entry (char (*), fixed bin (18), ptr, fixed bin (19), fixed bin (35)),
      530      ring_zero_peek_$get_max_length
      531 	entry (char (*), fixed bin (19), fixed bin (35));
      532 
      533 
      534 /* E X T E R N A L   S T A T I C */
      535 dcl  (error_table_$bad_arg,
      536      error_table_$badopt,
      537      error_table_$logical_volume_not_defined,
      538      error_table_$noarg,
      539      error_table_$not_act_fnc,
      540      error_table_$pvid_not_found)
      541 	fixed bin (35) ext static;
      542 
      543 /* B U I L T I N */
      544 dcl  (addr, char, dim, divide, length, max, null, rtrim, substr) builtin;
      545 
  1     1 /*	BEGIN INCLUDE FILE ... disk_table.incl.pl1 ... Created Oct 75 for NSS */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  1     6*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  1     7*     Add support for subvolumes.
  1     8*                                                   END HISTORY COMMENTS */
  1     9 
  1    10 
  1    11 /*		Modified July 1977 by T. Casey to add pdirs_ok switch in lve */
  1    12 /*		Modified April 1981 by J. Bongiovanni to add shared_spindle_flip */
  1    13 /*		Modified 831122 by E. A. Ranzenbach to add vacate_pdirs bit to lve. */
  1    14 
  1    15 /* The disk table lives in ring 1. Its entries parallel the PVT */
  1    16 
  1    17 dcl  dtp ptr,
  1    18      dtep ptr,
  1    19      lvep ptr;
  1    20 
  1    21      
  1    22 
  1    23 dcl 1 dt based (dtp) aligned,
  1    24 
  1    25     2 n_entries fixed bin (17),			/* number of disk table entries */
  1    26     2 max_n_entries fixed bin (17),			/* max number of disk table entries */
  1    27     2 n_in_use fixed bin (17),			/* number of disk table entries in use */
  1    28     2 rpvx fixed bin,				/* index (pvtx, too) of the RPV */
  1    29     2 version fixed bin init (1),
  1    30     2 n_lv_entries fixed bin,				/* Number of LV entries */
  1    31     2 pad (2) bit (36),
  1    32     2 array (0 refer (dt.max_n_entries)) like dte,
  1    33     2 lv_array (0 refer (dt.max_n_entries)) like lve;
  1    34 
  1    35 dcl 1 dte based (dtep) aligned,
  1    36     2 drive_name char (8),				/* device name */
  1    37     (2 device_type fixed bin (8),			/* device type */
  1    38     2 used bit (1),					/* TRUE if this entry is used for paging */
  1    39     2 known bit (1),				/* TRUE if label has been read and checked */
  1    40     2 storage_system bit (1),				/* TRUE for storage system (vs io disk) */
  1    41     2 permanent bit (1),				/* TRUE if cannot be demounted */
  1    42     2 deleted bit (1),				/* TRUE if deleted by "deld" */
  1    43     2 rpv bit (1),					/* TRUE if the root physical volume */
  1    44     2 demounted bit (1),				/* TRUE if was here or was assumed here */
  1    45     2 need_salvage bit (1),				/* TRUE if this vol was volsalv'd automatic */
  1    46     2 hc_accepted bit (1),				/* TRUE if vol accepted by ring 0 init */
  1    47     2 shared_spindle_flip bit (1),			/* used by ring-4 for shared spindle allocation */
  1    48     2 is_sub_vol bit (1),
  1    49     2 pad bit (3),
  1    50     2 lvx fixed bin (11),				/* index in lv_array of lve */
  1    51     2 pre_accepted bit (1)) unaligned,			/* TRUE if was used in previous bootload */
  1    52     2 sv_num  fixed bin unal,				/* this sv number */
  1    53     2 num_of_sv fixed bin unal,			/* number of sv for this pv */
  1    54     2 sv_name   char (2) aligned,
  1    55     2 pvid bit (36),				/* physical volume ID */
  1    56     2 pvname char (32);				/* Physical volume name. */
  1    57 
  1    58 dcl 1 lve based (lvep) aligned,
  1    59     2 lvid bit (36),				/* logical volume ID */
  1    60     (2 used bit (1),				/* TRUE if entry used */
  1    61     2 hv_mounted bit (1),				/* TRUE if hvol is really OK */
  1    62     2 public bit (1),				/* TRUE for public vol */
  1    63     2 mounting bit (1),				/* TRUE if mhv is in progress */
  1    64     2 demounting bit (1),				/* TRUE if dhv is in progress */
  1    65     2 good_candidate bit (1) unal,			/* used for auto dhv */
  1    66     2 demounted_only bit (1) unal,			/* lve here only to warm demounted pve's */
  1    67     2 pdirs_ok bit (1) unal,				/* TRUE if process directory segments can be on this lv */
  1    68     2 prev_bootload bit (1) unal,			/* TRUE if can auto-accept pvs */
  1    69     2 vacate_pdirs bit (1) unal,			/* if TRUE we will demand move all perprocess segs */
  1    70     2 pad bit (26)) unal,
  1    71     2 lvname char (32),				/* Logical volume name */
  1    72     2 min_access_class bit (72),			/* Security stuff */
  1    73     2 max_access_class bit (72);			/* .. */
  1    74 
  1    75 /*	END INCLUDE FILE ...disk_table.incl.pl1 */
      546 
      547 
  2     1 /*	BEGIN INCLUDE FILE ... pvt.incl.pl1 ... last modified January 1982 */
  2     2 
  2     3 
  2     4 /* The physical volume table (PVT) is a wired-down table.
  2     5*   It has one entry for each spindle present, be it for
  2     6*   Storage System or "I/O" use.
  2     7**/
  2     8 
  2     9      dcl	   pvt$		      ext,
  2    10 	   pvtp		      ptr;
  2    11 
  2    12 
  2    13      dcl	   1 pvt		      based (pvtp) aligned,
  2    14 
  2    15 	     2 n_entries	      fixed bin (17),	/* number of PVT entries */
  2    16 	     2 max_n_entries      fixed bin (17),	/* max number of PVT entries */
  2    17 	     2 n_in_use	      fixed bin (17),	/* number of PVT entries in use */
  2    18 	     2 rwun_pvtx	      fixed bin,		/* rewind_unloading pvtx */
  2    19 	     2 shutdown_state     fixed bin,		/* state of previous shutdown */
  2    20 	     2 esd_state	      fixed bin,		/* state of ESD, >0 iff in ESD */
  2    21 	     2 prev_shutdown_state fixed bin,		/* shutdown state of previous bootload */
  2    22 	     2 prev_esd_state     fixed bin,		/* ESD state of previous bootload */
  2    23 
  2    24 	     2 time_of_bootload fixed bin (71),		/* Time of bootload */
  2    25 	     2 root_lvid	      bit (36) aligned,	/* Logical volume ID of Root Logical Volume (RLV) */
  2    26 	     2 root_pvid	      bit (36) aligned,	/* Physical volume ID of Root Physical Volume (RPV) */
  2    27 	     2 root_pvtx	      fixed bin,		/* Index to PVTE for Root Physical Volume (RPV) */
  2    28 	     2 root_vtocx	      fixed bin,		/* VTOCE index for root (>) */
  2    29 	     2 disk_table_vtocx   fixed bin,		/* VTOCE index for disk table on RPV */
  2    30 	     2 disk_table_uid     bit (36) aligned,	/* File System UID for disk_table */
  2    31 
  2    32 	     2 rpvs_requested     bit (1) aligned,	/* RPVS keyword given on BOOT */
  2    33 	     2 rpv_needs_salv     bit (1) aligned,	/* RPV required (not requested) salvage */
  2    34 	     2 rlv_needs_salv     bit (1) aligned,	/* RLV required (not requested) salvage */
  2    35 	     2 volmap_lock_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
  2    36 	     2 volmap_idle_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
  2    37 	     2 vtoc_map_lock_wait_constant bit (36) aligned, /* For constructing wait event: OR pvte_rel into lower */
  2    38 	     2 n_volmap_locks_held fixed bin (17),	/* Current number of volmap locks held */
  2    39 	     2 n_vtoc_map_locks_held fixed bin (17),	/* Current number of VTOC Map locks held */
  2    40 
  2    41 	     2 last_volmap_time   fixed bin (71),	/* Time a volmap was last locked/unlocked */
  2    42 	     2 last_vtoc_map_time fixed bin (71),	/* Time a VTOC Map was last locked/unlocked */
  2    43 	     2 total_volmap_lock_time fixed bin (71),	/* Total time volmap's were locked (integral) */
  2    44 	     2 total_vtoc_map_lock_time fixed bin (71),	/* Total time VTOC Maps were locked (integral) */
  2    45 
  2    46 	     2 n_volmap_locks     fixed bin (35),	/* Number times a volmap was locked */
  2    47 	     2 n_vtoc_map_locks   fixed bin (35),	/* Number times a vtoc_map was locked */
  2    48 	     2 volmap_lock_nowait_calls fixed bin (35),	/* Number calls to lock volmap, no wait */
  2    49 	     2 volmap_lock_nowait_fails fixed bin (35),	/* Number times lock failed */
  2    50 	     2 volmap_lock_wait_calls fixed bin (35),	/* Number calls to lock volmap, wait */
  2    51 	     2 volmap_lock_wait_fails fixed bin (35),	/* Number times lock failed */
  2    52 	     2 pad (2) bit (36) aligned,
  2    53 
  2    54 	     2 array	      fixed bin (71);	/* Array of PVTE's -- must be double-word aligned */
  2    55 
  2    56 
  2    57 
  2    58 /*	END INCLUDE FILE ...pvt.incl.pl1 */
      548 
      549 
  3     1 /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  3     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  3     8*     Add the support for subvolumes
  3     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  3    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  3    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  3    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  3    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  3    14*     Added inconsistent_dbm bit for determining the status of volume
  3    15*     dumper bit maps.
  3    16*                                                   END HISTORY COMMENTS */
  3    17 
  3    18      dcl	   pvt$array	      aligned external;
  3    19      dcl	   pvt$max_n_entries      fixed bin external;
  3    20 
  3    21      dcl	   pvt_arrayp	      ptr;
  3    22      dcl	   pvtep		      ptr;
  3    23 
  3    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  3    25 
  3    26      dcl	   1 pvte		      based (pvtep) aligned,
  3    27 
  3    28 	     2 pvid	      bit (36),		/* physical volume ID */
  3    29 
  3    30 	     2 lvid	      bit (36),		/* logical volume ID */
  3    31 
  3    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  3    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  3    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  3    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  3    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  3    37 	     2 pad3	      bit (2) unaligned,
  3    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  3    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  3    40 
  3    41 
  3    42 
  3    43 	     2 devname	      char (4),		/* device name */
  3    44 
  3    45 	     (2 device_type	      fixed bin (8),	/* device type */
  3    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  3    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  3    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  3    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  3    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  3    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  3    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  3    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  3    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  3    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  3    56 	     2 scav_check_address
  3    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  3    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  3    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  3    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  3    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  3    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  3    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  3    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  3    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  3    66 
  3    67 
  3    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  3    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  3    70 
  3    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  3    72 
  3    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  3    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  3    75 
  3    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  3    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  3    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  3    79 	     2 records_per_cyl    fixed bin,
  3    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  3    81 	     2 sv_name            char (2) aligned,
  3    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  3    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  3    84 
  3    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  3    86 	     2 pad2	      bit (18) unaligned,
  3    87 
  3    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  3    89 
  3    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  3    91 
  3    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  3    93 
  3    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  3    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  3    96 
  3    97 
  3    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  3    99 
  3   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  3   101 
  3   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  3   103 
  3   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  3   105 
  3   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  3   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  3   108 
  3   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  3   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  3   111 
  3   112 
  3   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  3   114 	   VOLMAP_ASYNC_READ      init (1),
  3   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  3   116 
  3   117 
  3   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      550 
      551      end list_vols;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/19/88  1523.2  list_vols.pl1                     >special_ldd>install>MR12.2-1061>list_vols.pl1
546          1    07/24/86  2051.9  disk_table.incl.pl1               >ldd>include>disk_table.incl.pl1
548          2    05/27/82  1525.8  pvt.incl.pl1                      >ldd>include>pvt.incl.pl1
550          3    07/19/88  1523.2  pvte.incl.pl1                     >special_ldd>install>MR12.2-1061>pvte.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Ilv                             000100 automatic       fixed bin(17,0)          dcl 464 set ref 50* 115* 115 116 121 163* 165 166
                                                                                  170 237* 237* 239 244* 263* 268 273* 273 290* 295
                                                                                  388* 388 389 395
Ptemp                           000102 automatic       pointer                  array dcl 464 set ref 51* 52* 203* 204 208 209 458
                                                                                  458* 460*
active_fnc_err_                 000010 constant        entry                    external dcl 515 ref 72
addr                                                   builtin function         dcl 544 ref 222 267 292 293
af_sw                           000106 automatic       bit(1)                   packed unaligned dcl 464 set ref 53* 73* 78* 142 149
                                                                                  154 186 191 197 435
an                              000107 automatic       fixed bin(17,0)          dcl 464 set ref 92* 94* 99* 99 100* 122 129* 129
                                                                                  130*
argl                            000110 automatic       fixed bin(17,0)          dcl 464 set ref 94* 96 100* 112 121 127 130* 132 136
                                                                                  136 136 138 138 138 140 140 140 147 147 147 154
                                                                                  154 156 156 161 166 170 174 174 255*
argp                            000112 automatic       pointer                  dcl 464 set ref 94* 96 100* 112 121 127 130* 132 136
                                                                                  136 136 138 138 138 140 140 140 147 147 147 154
                                                                                  154 156 161 166 170 174
array                    50            based           fixed bin(71,0)          level 2 in structure "pvt" dcl 2-13 in procedure
                                                                                  "list_vols" set ref 222
array                    10            based           structure                array level 2 in structure "dt" dcl 1-23
                                                                                  in procedure "list_vols" set ref 267 293
bchr                                   based           char                     packed unaligned dcl 510 set ref 96 112 121 127 132
                                                                                  136 136 136 138 138 138 140 140 140 147 147 147
                                                                                  154 154 156* 161 166 170 174*
char                                                   builtin function         dcl 544 ref 112 161
char7                           000114 automatic       char(7)                  packed unaligned dcl 464 set ref 436* 437
cleanup                         000320 stack reference condition                dcl 506 ref 201
code                            000116 automatic       fixed bin(35,0)          dcl 464 set ref 75* 76 77 83* 94* 95 100* 101 104*
                                                                                  110 130* 131 173* 174* 179* 203* 205* 210* 212
                                                                                  213* 218* 220 223* 224 225* 458*
com_err_                        000012 constant        entry                    external dcl 515 ref 79
cu_$af_return_arg               000014 constant        entry                    external dcl 515 ref 75
cu_$arg_count                   000016 constant        entry                    external dcl 515 ref 89
cu_$arg_ptr                     000020 constant        entry                    external dcl 515 ref 94 100 130
device_inoperative        4(25)        based           bit(1)                   level 2 packed packed unaligned dcl 3-26 ref 351
dim                                                    builtin function         dcl 544 ref 116 237
divide                                                 builtin function         dcl 544 ref 309 310 316 316 316 316 324 324 324 324
                                                                                  357 358 361 361 361 361 374 374 374 374 405 406
                                                                                  407 407 407 407 414 414 414 414
drive_name                             based           char(8)                  level 2 in structure "dte" dcl 1-35 in procedure
                                                                                  "list_vols" set ref 361* 374*
drive_name               10            based           char(8)                  array level 3 in structure "dt" dcl 1-23
                                                                                  in procedure "list_vols" set ref 255*
dt                                     based           structure                level 1 dcl 1-23
dte                                    based           structure                level 1 dcl 1-35
dtep                            000330 automatic       pointer                  dcl 1-17 set ref 267* 268 268 268 271 271 293* 295
                                                                                  295 295 306 333 361 361 361 361 361 374 374 374
                                                                                  374 374
dtp                             000326 automatic       pointer                  dcl 1-17 set ref 209* 223* 229 239 239 239 255 255
                                                                                  255 255 267 268 293 295 306 334 361 374 449 450
entry_name                      000117 automatic       char(12)                 packed unaligned dcl 464 set ref 54* 83* 104* 156*
                                                                                  166* 174* 179* 198* 203* 205* 213* 225* 244* 395*
                                                                                  397* 458*
error_proc                      000314 automatic       entry variable           dcl 503 set ref 72* 79* 83 104 156 166 174 179 198
                                                                                  205 213 225 244 395 397
error_table_$bad_arg            000042 external static fixed bin(35,0)          dcl 535 set ref 166*
error_table_$badopt             000044 external static fixed bin(35,0)          dcl 535 set ref 156* 173
error_table_$logical_volume_not_defined
                                000046 external static fixed bin(35,0)          dcl 535 set ref 244* 395*
error_table_$noarg              000050 external static fixed bin(35,0)          dcl 535 ref 101
error_table_$not_act_fnc        000052 external static fixed bin(35,0)          dcl 535 ref 77
error_table_$pvid_not_found     000054 external static fixed bin(35,0)          dcl 535 set ref 397*
flag                            000122 automatic       char(1)                  packed unaligned dcl 464 set ref 351* 353* 361* 374*
flag1                           000123 automatic       char(1)                  packed unaligned dcl 464 set ref 354* 356* 361* 374*
get_temp_segments_              000022 constant        entry                    external dcl 515 ref 203
given_lvnm                      000124 automatic       char(32)                 array packed unaligned dcl 464 set ref 55* 102 116
                                                                                  121* 165 166 170* 237 237 239 244* 268 295 389
                                                                                  395*
given_pvnm                      000244 automatic       char(32)                 packed unaligned dcl 464 set ref 56* 132* 268 295
                                                                                  397*
gtt_sw                          000254 automatic       bit(1)                   packed unaligned dcl 464 set ref 59* 142* 159* 186
                                                                                  194
half_totrec                     000255 automatic       fixed bin(35,0)          dcl 464 set ref 309* 316 316 324 324 357* 361 361
                                                                                  374 374 405* 407 407 414 414
half_vtoce                      000256 automatic       fixed bin(35,0)          dcl 464 set ref 310* 316 316 324 324 358* 361 361
                                                                                  374 374 406* 407 407 414 414
i                               000257 automatic       fixed bin(17,0)          dcl 464 set ref 238* 239 239 242* 253* 254 254 255
                                                                                  255 255 255* 264* 267* 291* 292 293* 436* 437
idsort_                         000024 constant        entry                    external dcl 515 ref 260
ioa_                            000026 constant        entry                    external dcl 515 ref 117 278 283 316 324 361 374 407
                                                                                  414 423 439
ioa_$rsnnl                      000030 constant        entry                    external dcl 515 ref 255 436
left_sw                         000260 automatic       bit(1)                   packed unaligned dcl 464 set ref 57* 142* 144* 148*
                                                                                  183* 186* 191* 194* 324 373 414 432
length                                                 builtin function         dcl 544 ref 271 271
lv_array                               based           structure                array level 2 dcl 1-23
lve                                    based           structure                level 1 dcl 1-58
lvname                                 based           char(32)                 array level 3 dcl 1-23 set ref 239 255* 268 295 306
                                                                                  334 361* 374*
lvsw                            000261 automatic       bit(1)                   packed unaligned dcl 464 set ref 60* 98* 134* 162*
                                                                                  189 236 260 268 273 283 283 295 387 395
lvx                       2(23)        based           fixed bin(11,0)          level 2 in structure "dte" packed packed unaligned
                                                                                  dcl 1-35 in procedure "list_vols" ref 268 295 306
                                                                                  333 361 361 361 374 374 374
lvx                                    parameter       fixed bin(17,0)          dcl 446 in procedure "lvflags" ref 444 449 450
lvx                      12(23)        based           fixed bin(11,0)          array level 3 in structure "dt" packed packed
                                                                                  unaligned dcl 1-23 in procedure "list_vols" set
                                                                                  ref 239 255 255
max                                                    builtin function         dcl 544 ref 361 374
max_n_entries             1            based           fixed bin(17,0)          level 2 dcl 1-23 ref 239 255 268 295 306 334 361 374
                                                                                  449 450
max_pvname_ln                   000262 automatic       fixed bin(17,0)          dcl 464 set ref 61* 271 271* 283* 283* 361* 374*
mdc_$read_disk_table            000032 constant        entry                    external dcl 515 ref 223
my_pvt_array                           based           structure                array level 1 dcl 510 set ref 292
n                               000263 automatic       fixed bin(17,0)          dcl 464 set ref 229* 232 233 238 242 253 260* 264
                                                                                  291
n_entries                              based           fixed bin(17,0)          level 2 dcl 1-23 ref 229
n_free_vtoce              5            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-26 set ref 344
                                                                                  361 361 361 361 374* 374 374 374
n_vtoce                         000264 automatic       fixed bin(17,0)          dcl 464 in procedure "list_vols" set ref 300* 343
                                                                                  358 361* 361 361 361 361 361 361 374* 374 374 374
n_vtoce                  17(18)        based           fixed bin(17,0)          level 2 in structure "pvte" packed packed unaligned
                                                                                  dcl 3-26 in procedure "list_vols" ref 300
nargs                           000265 automatic       fixed bin(17,0)          dcl 464 set ref 75* 89* 92 122
nleft                     7            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-26 set ref 342
                                                                                  348 361 361 361 361 374* 374 374 374
nprt                            000266 automatic       fixed bin(17,0)          dcl 464 set ref 62* 302* 302 394
null                                                   builtin function         dcl 544 ref 51 52 204 458 460
pdirs_ok                               based           bit(1)                   array level 3 packed packed unaligned dcl 1-23 ref
                                                                                  450
prev_lvnm                       000267 automatic       char(32)                 packed unaligned dcl 464 set ref 63* 306 311 316*
                                                                                  324* 334* 407* 414*
prev_lvx                        000277 automatic       fixed bin(17,0)          dcl 464 set ref 316* 316* 324* 324* 333* 334 407*
                                                                                  407* 414* 414*
public                                 based           bit(1)                   array level 3 packed packed unaligned dcl 1-23 ref
                                                                                  449
pvname                    6            based           char(32)                 level 2 dcl 1-35 set ref 268 271 271 295 361* 374*
pvsw                            000300 automatic       bit(1)                   packed unaligned dcl 464 set ref 64* 97* 133* 189
                                                                                  260 268 283 295 397
pvt                                    based           structure                level 1 dcl 2-13
pvt_arrayp                      000334 automatic       pointer                  dcl 3-21 set ref 222* 292
pvt_size                        000301 automatic       fixed bin(19,0)          dcl 464 set ref 210* 218*
pvte                                   based           structure                level 1 dcl 3-26
pvtep                           000336 automatic       pointer                  dcl 3-22 set ref 292* 300 341 342 344 348 351 354
                                                                                  357 361 361 361 361 361 361 361 361 361 361 361
                                                                                  361 361 361 361 374 374 374 374 374 374 374 374
                                                                                  374 374 374 374
pvtp                            000332 automatic       pointer                  dcl 2-9 set ref 208* 218* 222
record_sw                       000302 automatic       bit(1)                   packed unaligned dcl 464 set ref 65* 138* 142* 149*
                                                                                  159* 186 189 191 194 197 264 278 311 332 347 400
release_temp_segments_          000034 constant        entry                    external dcl 515 ref 458
ret                                    based           varying char             dcl 510 set ref 437*
retl                            000303 automatic       fixed bin(17,0)          dcl 464 set ref 75* 437
retp                            000304 automatic       pointer                  dcl 464 set ref 75* 437
retstr                          000100 automatic       char(5)                  initial packed unaligned dcl 447 set ref 447* 449*
                                                                                  450* 451
ring_zero_peek_$by_name         000036 constant        entry                    external dcl 515 ref 218
ring_zero_peek_$get_max_length  000040 constant        entry                    external dcl 515 ref 210
rtrim                                                  builtin function         dcl 544 ref 271 271
sindex                          000100 automatic       fixed bin(17,0)          array dcl 232 set ref 254* 260* 267 292 293
sname                           000100 automatic       char(32)                 array dcl 233 set ref 235* 255* 260*
substr                                                 builtin function         dcl 544 set ref 437 449* 450*
totfreevtoc                     000306 automatic       fixed bin(35,0)          dcl 464 set ref 66* 316 316 316 324* 324 324 336*
                                                                                  344* 344 407 407 407 414* 414 414
totleft                         000307 automatic       fixed bin(35,0)          dcl 464 set ref 67* 316 316 316 324* 324 324 336*
                                                                                  342* 342 348* 407 407 407 414* 414 414 432 434
totrec                          000310 automatic       fixed bin(35,0)          dcl 464 in procedure "list_vols" set ref 68* 309
                                                                                  316* 316 316 316 316 316 324* 324 324 336* 341*
                                                                                  341 405 407* 407 407 407 407 407 414* 414 414 432*
                                                                                  434* 434 436* 439*
totrec                    7(18)        based           fixed bin(17,0)          level 2 in structure "pvte" packed packed unaligned
                                                                                  dcl 3-26 in procedure "list_vols" set ref 341 357
                                                                                  361* 361 361 361 361 361 361 374* 374 374 374
totsw                           000311 automatic       bit(1)                   packed unaligned dcl 464 set ref 69* 136* 190* 260
                                                                                  264 278 283 304 403
totvtoc                         000312 automatic       fixed bin(35,0)          dcl 464 set ref 70* 310 316* 316 316 316 316 316
                                                                                  324* 324 324 336* 343* 343 406 407* 407 407 407
                                                                                  407 407 414* 414 414
used                      2(09)        based           bit(1)                   level 2 in structure "dte" packed packed unaligned
                                                                                  dcl 1-35 in procedure "list_vols" ref 268 295
used                     12(09)        based           bit(1)                   array level 3 in structure "dt" packed packed
                                                                                  unaligned dcl 1-23 in procedure "list_vols" set
                                                                                  ref 239
used_sw                         000313 automatic       bit(1)                   packed unaligned dcl 464 set ref 58* 141* 149* 151*
                                                                                  183 194 278* 278* 283* 283* 316 360 407 434
vacating                  4(31)        based           bit(1)                   level 2 packed packed unaligned dcl 3-26 ref 354

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 3-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 3-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 3-113
lvep                                   automatic       pointer                  dcl 1-17
pvt$                                   external static fixed bin(17,0)          dcl 2-9
pvt$array                              external static fixed bin(17,0)          dcl 3-18
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 3-19
pvt_array                              based           structure                array level 1 dcl 3-24

NAMES DECLARED BY EXPLICIT CONTEXT.
CANNOT_GET_PVT                  001477 constant        label                    dcl 213 ref 220
CHECK_NEXT_ARG                  000705 constant        label                    dcl 127 ref 112
NEXT_LV                         000567 constant        label                    dcl 99 ref 125
clean_out                       004257 constant        entry                    internal dcl 455 ref 201 215 426
common_exit                     004076 constant        label                    dcl 426 ref 199 245 441
display_records                 004103 constant        label                    dcl 432 ref 311 349 400
end_lvsw_loop                   002020 constant        label                    dcl 249 ref 239
gape                            001213 constant        label                    dcl 174
gape1                           001240 constant        label                    dcl 179 ref 110 131
get_arg_count                   000522 constant        label                    dcl 89 ref 80
get_args                        000530 constant        label                    dcl 92 ref 87
list_vols                       000371 constant        entry                    external dcl 14
loop_thru_pvs                   002372 constant        label                    dcl 291 ref 389
lvflags                         004204 constant        entry                    internal dcl 444 ref 316 316 324 324 361 361 374 374
                                                                                  407 407 414 414
work                            001257 constant        label                    dcl 183 ref 102 122

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4574        4652    4324        4604
Length      5136    4324        56         247     250           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
list_vols                           376 external procedure  is an external procedure.  
on unit on line 201                  64 on unit               
begin block on line 231             296 begin block         uses auto adjustable storage.  
lvflags                              68 internal procedure  is called by several nonquick procedures.  
clean_out                            78 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 231  000100 sname                       begin block on line 231
                         000100 sindex                      begin block on line 231
list_vols                000100 Ilv                         list_vols
                         000102 Ptemp                       list_vols
                         000106 af_sw                       list_vols
                         000107 an                          list_vols
                         000110 argl                        list_vols
                         000112 argp                        list_vols
                         000114 char7                       list_vols
                         000116 code                        list_vols
                         000117 entry_name                  list_vols
                         000122 flag                        list_vols
                         000123 flag1                       list_vols
                         000124 given_lvnm                  list_vols
                         000244 given_pvnm                  list_vols
                         000254 gtt_sw                      list_vols
                         000255 half_totrec                 list_vols
                         000256 half_vtoce                  list_vols
                         000257 i                           list_vols
                         000260 left_sw                     list_vols
                         000261 lvsw                        list_vols
                         000262 max_pvname_ln               list_vols
                         000263 n                           list_vols
                         000264 n_vtoce                     list_vols
                         000265 nargs                       list_vols
                         000266 nprt                        list_vols
                         000267 prev_lvnm                   list_vols
                         000277 prev_lvx                    list_vols
                         000300 pvsw                        list_vols
                         000301 pvt_size                    list_vols
                         000302 record_sw                   list_vols
                         000303 retl                        list_vols
                         000304 retp                        list_vols
                         000306 totfreevtoc                 list_vols
                         000307 totleft                     list_vols
                         000310 totrec                      list_vols
                         000311 totsw                       list_vols
                         000312 totvtoc                     list_vols
                         000313 used_sw                     list_vols
                         000314 error_proc                  list_vols
                         000326 dtp                         list_vols
                         000330 dtep                        list_vols
                         000332 pvtp                        list_vols
                         000334 pvt_arrayp                  list_vols
                         000336 pvtep                       list_vols
lvflags                  000100 retstr                      lvflags

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
enter_begin_block   leave_begin_block   call_ent_var_desc   call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          tra_ext_1           alloc_auto_adj      mpfx2               enable_op
ext_entry           int_entry           divide_fx1          divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               com_err_                      cu_$af_return_arg             cu_$arg_count
cu_$arg_ptr                   get_temp_segments_            idsort_                       ioa_
ioa_$rsnnl                    mdc_$read_disk_table          release_temp_segments_        ring_zero_peek_$by_name
ring_zero_peek_$get_max_length

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$badopt           error_table_$logical_volume_not_defined
error_table_$noarg            error_table_$not_act_fnc      error_table_$pvid_not_found




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 000370        50 000376        51 000377        52 000401        53 000402        54 000403        55 000406
     56 000422        57 000425        58 000426        59 000427        60 000430        61 000431        62 000433
     63 000434        64 000437        65 000440        66 000441        67 000442        68 000443        69 000444
     70 000445        72 000446        73 000453        75 000455        76 000471        77 000473        78 000476
     79 000477        80 000503        83 000504        84 000520        87 000521        89 000522        92 000530
     94 000537        95 000554        96 000556        97 000564        98 000565        99 000567       100 000570
    101 000605       102 000611       104 000615       105 000640       110 000641       112 000643       115 000654
    116 000655       117 000660       119 000673       121 000674       122 000701       125 000704       127 000705
    129 000711       130 000712       131 000727       132 000731       133 000736       134 000740       135 000741
    136 000742       138 000761       140 001000       141 001014       142 001016       144 001025       146 001027
    147 001030       148 001044       149 001045       151 001054       153 001056       154 001057       156 001071
    157 001123       159 001124       161 001130       162 001137       163 001141       165 001143       166 001152
    168 001202       170 001203       171 001207       173 001210       174 001213       175 001236       177 001237
    179 001240       180 001254       182 001255       183 001257       186 001266       189 001275       190 001303
    191 001305       194 001312       197 001322       198 001326       199 001352       201 001353       203 001375
    204 001416       205 001422       206 001445       208 001446       209 001450       210 001452       212 001475
    213 001477       215 001521       216 001525       218 001526       220 001562       222 001564       223 001567
    224 001600       225 001602       226 001625       229 001626       231 001630       232 001633       233 001640
    255 001646       260 001650       235 001670       236 001705       237 001710       238 001724       239 001734
    242 001765       244 001770       245 002013       247 002016       249 002020       253 002022       254 002034
    255 002036       259 002121       260 002124       263 002153       264 002156       267 002172       268 002200
    271 002237       273 002256       275 002261       278 002263       283 002312       290 002367       291 002372
    292 002404       293 002412       295 002420       300 002460       302 002465       304 002466       306 002470
    309 002502       310 002505       311 002510       316 002521       324 002660       332 002761       333 002764
    334 002771       336 003004       341 003010       342 003020       343 003026       344 003032       345 003040
    347 003041       348 003043       349 003046       351 003051       353 003057       354 003061       356 003067
    357 003071       358 003077       360 003102       361 003105       373 003315       374 003320       385 003525
    387 003530       388 003532       389 003533       392 003542       394 003543       395 003545       397 003573
    399 003616       400 003617       403 003621       405 003623       406 003626       407 003631       414 003765
    422 004064       423 004065       426 004076       428 004102       432 004103       434 004107       435 004120
    436 004122       437 004151       438 004162       439 004163       441 004202       444 004203       447 004211
    449 004213       450 004237       451 004251       455 004256       458 004264       460 004311       461 004314


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
