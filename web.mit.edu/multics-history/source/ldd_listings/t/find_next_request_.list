	COMPILATION LISTING OF SEGMENT find_next_request_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/28/88  1340.6 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 find_next_request_: proc (dev_class_index, descr_ptr) returns (bit (1) aligned);
       13 
       14 /* This is the io_coordinator procedure used for reading request messages
       15*   *  out of the IO daemon queues. It is normally the only procedure that
       16*   *  reads from message segments into request descriptors.
       17*   *
       18*   *  This procedure returns a bit(1) result indicating whether or not it actually
       19*   *  found a message in the queue(s).
       20*   */
       21 
       22 /* Coded August 1973 by Robert S. Coren */
       23 /* Modified for the Access Isolation Mechanism by J. Stern, 12/26/74 */
       24 /* Modified by J. Stern, 11/25/75 */
       25 /* Modified by J. C. Whitmore, 4/78, for max_queues per request type and new iod_tables format */
       26 /* Modified by J. C. Whitmore, 7/78, for priority requests in waiting list */
       27 /* Modified by J. C. Whitmore, 4/80, to mark the state of running requests */
       28 /* Modified by R. Kovalcik, 6/82, to handle defer_until_process_termination */
       29 /* Modified by R. Kovlacik, 1/83, to fix a problem in interaction between dupt and multiple printers */
       30 /* Modified by C. Marker, 02/23/85, to use message_segment_$read_message_index to support version 5 message segments */
       31 
       32 
       33 /****^  HISTORY COMMENTS:
       34*  1) change(88-06-03,Brunelle), approve(88-06-03,MCR7911),
       35*     audit(88-10-17,Wallman), install(88-10-28,MR12.2-1199):
       36*     Upgraded to handle version 5 I/O daemon tables.
       37*                                                   END HISTORY COMMENTS */
       38 
       39 
       40 	dcl     dev_class_index	 fixed bin;	/* index of device class entry (INPUT) */
       41 	dcl     descr_ptr		 ptr;		/* pointer to request descriptor to be filled in (INPUT) */
       42 
       43 	dcl     code		 fixed bin (35);
       44 	dcl     err_len		 fixed bin;
       45 	dcl     err_mess		 char (200);
       46 	dcl     found		 bit (1) aligned;
       47 	dcl     (queue, q)		 fixed bin;	/* queue number variables */
       48 
       49 	dcl     last_id		 bit (72) aligned;
       50 	dcl     dcp		 ptr;
       51 	dcl     retp		 ptr;
       52 	dcl     q_idx		 fixed bin;
       53 
       54 	dcl     wlp		 ptr int static;	/* ptr to the waiting list */
       55 	dcl     dcx		 fixed bin;	/* device class table entry index */
       56 	dcl     i			 fixed bin;	/* loop variable */
       57 	dcl     auth		 bit (72) aligned;	/* used to hold the sender authorization of a message */
       58 	dcl     auth_string		 char (170);	/* char string version of "auth" */
       59 	dcl     message_len		 fixed bin (18);	/* bit length of based_message */
       60 	dcl     based_message	 bit (message_len) aligned based; /* a message read from a queue */
       61 	dcl     (x, y, z)		 fixed bin;	/* waiting list entry subscripts */
       62 
       63 	dcl     convert_authorization_$to_string_short entry (bit (72) aligned, char (*), fixed bin (35));
       64 	dcl     aim_check_$greater_or_equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
       65 	dcl     free_oldest_request_$force entry;
       66 	dcl     ioa_$rsnnl		 entry options (variable);
       67 	dcl     iodc_message_	 entry (bit (3) aligned, fixed bin (35), char (*));
       68 	dcl     message_segment_$read_message_index entry (fixed bin, ptr, ptr, fixed bin (35));
       69 	dcl     message_segment_$update_message_index entry (fixed bin, fixed bin (18), bit (72) aligned, ptr, fixed bin (35));
       70 	dcl     set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35));
       71 	dcl     set_lock_$unlock	 entry (bit (36) aligned, fixed bin (35));
       72 
       73 	dcl     re_read		 bit (2) int static options (constant) init ("00"b); /* mseg code to read given msg id */
       74 	dcl     next_msg		 bit (2) int static options (constant) init ("01"b); /* mseg code to read next message forward */
       75 	dcl     priority		 fixed bin int static options (constant) init (2); /* state code for priority requests */
       76 	dcl     normal		 fixed bin int static options (constant) init (1); /* state code for normal priority */
       77 	dcl     unused		 fixed bin int static options (constant) init (0); /* state code for a free entry */
       78 
       79 	dcl     error_table_$bad_segment fixed bin (35) ext;
       80 	dcl     error_table_$invalid_lock_reset fixed bin (35) ext;
       81 	dcl     error_table_$no_message fixed bin (35) ext;
       82 	dcl     error_table_$notalloc	 fixed bin (35) ext;
       83 
       84 	dcl     (addr, unspec)	 builtin;
       85 
       86 
       87 	dcx = dev_class_index;
       88 	dctep = addr (iodc_static.dctp -> dev_class_tab.entries (dcx)); /* get ptr to device class */
       89 	qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (dcte.qgte_index)); /* get q group table entry ptr */
       90 	retp, mseg_message_info_ptr = descr_ptr;	/* this points to mseg return args and request desc */
       91 
       92 	do queue = 1 to qgte.max_queues;
       93 
       94 	     call read_one;				/* read a message from queue or list */
       95 	     if found then do;			/* got one */
       96 		     retp -> request_descriptor.q = q;	/* set source queue */
       97 		     retp -> request_descriptor.charge_q = queue; /* and charging queue */
       98 		     retp -> request_descriptor.dev_class_index = dcx;
       99 		     return ("1"b);
      100 		end;
      101 	end;
      102 
      103 /* no request found */
      104 
      105 	return ("0"b);
      106 
      107 
      108 read_one: proc;
      109 
      110 /* This subroutine first checks the waiting list of the target device class.
      111*   If the waiting list is non-empty, the first waiting request is reread.
      112*
      113*   Otherwise, the ID of the last read message from the current queue is
      114*   checked.  If zero, the first message is read from the queue.  
      115*   If non-zero, the next message is read.
      116*
      117*   If the authorization of the new message fits the target device
      118*   class access range and it should not be deferred for process termination,
      119*   the message is returned.  Otherwise it is appended to
      120*   the waiting list of some other device class and the entire above procedure
      121*   is repeated.
      122**/
      123 
      124 	dcl     direction		 bit (2) aligned;	/* = 01 if reading ahead, 00 if rereading */
      125 	dcl     (bad, space)	 fixed bin;
      126 	dcl     dupt		 bit (1) aligned;	/* flag to note process is still around */
      127 	dcl     scan_wait		 bit (1) aligned;	/* flag to scan wait list */
      128 
      129 	found = "0"b;
      130 	scan_wait = (dcte.first_waiting (queue) ^= 0);
      131 	z = dcte.last_waiting (queue);		/* save stop marker */
      132 
      133 next:	if scan_wait then do;			/* loop through requests in waiting list */
      134 		x = dcte.first_waiting (queue);	/* get waiting list head index for this queue */
      135 		last_id = wlp -> waiting_list.ms_id (x);/* get message id of the request */
      136 		if wlp -> waiting_list.state (x) = priority then
      137 		     retp -> request_descriptor.priority_request = "1"b;
      138 		else retp -> request_descriptor.priority_request = ""b;
      139 		q = wlp -> waiting_list.orig_q (x);	/* could have come from another queue */
      140 		if wlp -> waiting_list.next (x) = 0 then /* no more requests in waiting list */
      141 		     dcte.last_waiting (queue),
      142 			dcte.first_waiting (queue) = 0;
      143 		else dcte.first_waiting (queue) = wlp -> waiting_list.next (x); /* advance the list */
      144 		dcte.n_waiting = dcte.n_waiting - 1;
      145 		if (x = z) | (dcte.first_waiting (queue) = 0) then scan_wait = "0"b; /* if we are done with this, note it */
      146 		call free_wle;			/* free the waiting list entry */
      147 		direction = re_read;
      148 	     end;
      149 
      150 	else do;					/* look through the queue */
      151 		q = queue;			/* read a fresh request from the current queue */
      152 		last_id = qgte.last_read (q);		/* prepare to read request after the last */
      153 		retp -> request_descriptor.priority_request = "0"b; /* this can't be priority */
      154 		direction = next_msg;
      155 	     end;
      156 
      157 	q_idx = qgte.mseg_index (q);			/* get message segment index for read call */
      158 	if q_idx = 0 then return;			/* if it was dropped forget it */
      159 
      160 	bad, space = 0;
      161 
      162 	unspec (mseg_message_info) = ""b;
      163 	mseg_message_info.version = MSEG_MESSAGE_INFO_V1;
      164 	mseg_message_info.ms_id = last_id;
      165 
      166 retry:	if last_id = "0"b				/* no previous message, read one first */
      167 	then mseg_message_info.message_code = MSEG_READ_FIRST;
      168 	else if direction = re_read then mseg_message_info.message_code = MSEG_READ_SPECIFIED;
      169 	else if direction = next_msg then mseg_message_info.message_code = MSEG_READ_AFTER_SPECIFIED;
      170 
      171 	call message_segment_$read_message_index (q_idx, iodc_static.req_seg_ptr, mseg_message_info_ptr, code);
      172 	if code = 0 then do;			/* fine */
      173 
      174 		dupt = "0"b;			/* prepare to check for defer_until process termination */
      175 		if mseg_message_info.ms_ptr -> queue_msg_hdr.defer_until_process_termination then do; /* check to see if defer_until_process_termination is requested */
      176 			call set_lock_$lock (mseg_message_info.ms_ptr -> queue_msg_hdr.dupt_lock, 1, code); /* test to see if the process is still around */
      177 			if (code ^= 0) & (code ^= error_table_$invalid_lock_reset) then dupt = "1"b; /* it is, defer request until later */
      178 			else call set_lock_$unlock (mseg_message_info.ms_ptr -> queue_msg_hdr.dupt_lock, code); /* else, unlock the lock for good measure */
      179 		     end;				/* end of DUPT processing */
      180 
      181 		if direction = re_read then do;	/* request is from wait list */
      182 			if ^dupt then do;		/* when request was from wait list and dupt is ok, we are done */
      183 				call mark_request (STATE_RUNNING, code);
      184 				if code ^= 0 then go to next;
      185 				found = "1"b;
      186 			     end;
      187 			else do;
      188 				call add_wle (dupt, dctep); /* otherwise, add it back to wait list! */
      189 				goto flush;	/* and try again */
      190 			     end;
      191 		     end;
      192 
      193 		else do;				/* else request is from queue, check authorization */
      194 			qgte.last_read (q) = mseg_message_info.ms_id; /* update last_read */
      195 			auth = mseg_message_info.sender_authorization;
      196 			do i = qgte.first_dev_class to qgte.last_dev_class; /* find dev class with right access range */
      197 			     dcp = addr (iodc_static.dctp -> dev_class_tab.entries (i));
      198 			     if aim_check_$greater_or_equal (auth, dcp -> dcte.min_access) then
      199 				if aim_check_$greater_or_equal (dcp -> dcte.max_access, auth) then /* range is right */
      200 				     if (dcx = i) & ^dupt then do; /* bingo, this is our device class and we aren't waitng for process termination */
      201 					     call mark_request (STATE_RUNNING, code);
      202 					     if code ^= 0 then go to next;
      203 					     found = "1"b;
      204 					     return;
      205 					end;
      206 				     else do;	/* request belongs to another dev class or is waiting process termination, add it to waiting list */
      207 					     call add_wle (dupt, dcp);
      208 					     go to flush; /* free this one and try the next one */
      209 					end;
      210 			end;
      211 
      212 /* come here if we fell through,  i.e. no device class had right access range for request */
      213 
      214 			auth_string = "";
      215 			call convert_authorization_$to_string_short (auth, auth_string, code);
      216 			call ioa_$rsnnl ("Request skipped for request type ^a.^/Unexpected access class: ^a",
      217 			     err_mess, err_len, qgte.name, auth_string);
      218 			call iodc_message_ ("101"b, 0, err_mess); /* tell the operator */
      219 flush:			message_len = mseg_message_info.ms_len;
      220 			free mseg_message_info.ms_ptr -> based_message in (req_area); /* free request */
      221 			go to next;
      222 		     end;
      223 
      224 	     end;
      225 	else if code = error_table_$no_message then
      226 	     /* this is okay too, but there's no message */
      227 	     if direction = re_read then go to next;	/* waiting request must have been cancelled */
      228 	     else return;				/* the queue is exhausted */
      229 
      230 	else do;					/* not so good */
      231 		if code = error_table_$bad_segment then
      232 		     if bad = 0 then do;		/* message seg. was just salvaged, try again */
      233 
      234 			     bad = 1;		/* once */
      235 			     call ioa_$rsnnl ("Requests may be lost from queue ^d of request type ""^a"".",
      236 				err_mess, err_len, q, qgte.name);
      237 			     call iodc_message_ ("101"b, code, err_mess);
      238 			     go to retry;
      239 			end;
      240 
      241 		if code = error_table_$notalloc then
      242 		     if space = 0 then do;		/* if we couldn't allocate try freeing one */
      243 
      244 			     space = 1;
      245 			     call free_oldest_request_$force;
      246 			     go to retry;
      247 			end;
      248 
      249 /* come here if an unrecoverable error occurred */
      250 /* report error and drop the offending queue */
      251 
      252 		call ioa_$rsnnl ("Dropping queue ^d of queue group ^a",
      253 		     err_mess, err_len, q, qgte.name);
      254 		call iodc_message_ ("101"b, code, err_mess); /* tell the operator */
      255 		qgte.mseg_index (q) = 0;		/* turn off the queue */
      256 
      257 	     end;
      258 
      259 	return;
      260 
      261      end read_one;
      262 
      263 
      264 add_wle: proc (dupt_flag, dc_ptr);
      265 
      266 	dcl     dupt_flag		 bit (1) aligned;
      267 	dcl     dc_ptr		 pointer;
      268 
      269 	call allocate_wle;				/* get a waiting list entry */
      270 	if y = 0 then do;				/* ugh, out of space */
      271 		call ioa_$rsnnl ("Waiting list full.  Request skipped from queue ^a_^d.ms",
      272 		     err_mess, err_len, qgte.name, q);
      273 		call iodc_message_ ("101"b, 0, err_mess); /* tell the operator */
      274 	     end;
      275 	else do;					/* chain request into waiting list */
      276 		wlp -> waiting_list.ms_id (y) = mseg_message_info.ms_id;
      277 		wlp -> waiting_list.state (y) = normal; /* normal waiting request */
      278 		wlp -> waiting_list.orig_q (y) = q;	/* queue it is from */
      279 		if dc_ptr -> dcte.last_waiting (q) > 0 then /* waiting list is not empty */
      280 		     wlp -> waiting_list.next (dc_ptr -> dcte.last_waiting (q)) = y;
      281 		else dc_ptr -> dcte.first_waiting (q) = y;
      282 		dc_ptr -> dcte.last_waiting (q) = y;
      283 		dc_ptr -> dcte.n_waiting = dc_ptr -> dcte.n_waiting + 1;
      284 		if dupt_flag then call mark_request (STATE_DUPT, (0));
      285 		else call mark_request (STATE_DEFERRED, (0));
      286 	     end;
      287 
      288      end add_wle;
      289 
      290 
      291 allocate_wle: proc;					/* procedure to allocate a waiting list entry */
      292 
      293 	y = wlp -> waiting_list.first_free;
      294 	if y > 0 then do;				/* take block from free list */
      295 		wlp -> waiting_list.first_free = wlp -> waiting_list.next (y); /* move free list head */
      296 		wlp -> waiting_list.next (y) = 0;	/* don't leave junk around */
      297 	     end;
      298 	else if wlp -> waiting_list.last_used = max_wl_size then y = 0; /* no more room */
      299 	else y, wlp -> waiting_list.last_used = wlp -> waiting_list.last_used + 1; /* raise high-water mark */
      300 	if y > 0 then do;				/* clear the new entry */
      301 		wlp -> waiting_list.state (y) = unused;
      302 		wlp -> waiting_list.next (y) = 0;
      303 		wlp -> waiting_list.orig_q (y) = 0;
      304 		wlp -> waiting_list.ms_id (y) = ""b;
      305 	     end;
      306 
      307      end allocate_wle;
      308 
      309 
      310 free_wle: proc;					/* procedure to free a waiting list entry */
      311 
      312 	if x = wlp -> waiting_list.last_used then do;	/* lower high-water mark */
      313 		wlp -> waiting_list.last_used = wlp -> waiting_list.last_used - 1;
      314 		wlp -> waiting_list.next (x) = 0;
      315 	     end;
      316 	else do;					/* add to head of free list */
      317 		wlp -> waiting_list.next (x) = wlp -> waiting_list.first_free;
      318 		wlp -> waiting_list.first_free = x;
      319 	     end;
      320 	wlp -> waiting_list.state (x) = unused;		/* mark it as free */
      321 	wlp -> waiting_list.ms_id (x) = ""b;
      322 
      323      end free_wle;
      324 
      325 
      326 mark_request: proc (new_state, code);
      327 
      328 	dcl     new_state		 fixed bin;
      329 	dcl     code		 fixed bin (35);
      330 	dcl     msg_p		 ptr;
      331 	dcl     msg_id		 bit (72) aligned;
      332 	dcl     msg_len		 fixed bin (18);
      333 	dcl     retry		 fixed bin;
      334 
      335 	msg_p = mseg_message_info.ms_ptr;		/* get ptr to msg text */
      336 	msg_p -> queue_msg_hdr.state = new_state;	/* tell user */
      337 	msg_id = mseg_message_info.ms_id;		/* get ready to re-write the message */
      338 	msg_len = mseg_message_info.ms_len;
      339 	retry = 0;
      340 update:	call message_segment_$update_message_index (q_idx, msg_len, msg_id, msg_p, code);
      341 	if code ^= 0 then /* normal test should be cheap */
      342 	     if code = error_table_$bad_segment		/* message seg was salvaged */
      343 	     then if retry = 0 then do;		/* try once more */
      344 			retry = 1;
      345 			go to update;
      346 		     end;
      347 
      348      end mark_request;
      349 
      350 
      351 init: entry (a_ptr);
      352 
      353 	dcl     a_ptr		 ptr;
      354 
      355 	stat_p = a_ptr;				/* get ptr to iodc_static */
      356 
      357 	wlp = iodc_static.wait_list_ptr;
      358 	wlp -> waiting_list.first_free,
      359 	     wlp -> waiting_list.last_used = 0;
      360 
      361 	do dcx = 1 to iodc_static.dctp -> dev_class_tab.n_classes; /* init per device class info */
      362 	     dctep = addr (iodc_static.dctp -> dev_class_tab.entries (dcx));
      363 	     dcte.n_waiting = 0;
      364 	     do q = 1 to 4;				/* clear waiting list indices for all possible queues */
      365 		dcte.first_waiting (q),
      366 		     dcte.last_waiting (q) = 0;
      367 	     end;
      368 	end;
      369 
      370 	return;
      371  /* BEGIN INCLUDE FILE...device_class.incl.pl1 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  1     7*     Ancient History
  1     8*     Coded by R.S.Coren August 1973
  1     9*     Modified by J. Stern, 1/8/75
  1    10*     Modified by J. C. Whitmore, 5/78, to extent the size of the device list
  1    11*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  1    12*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  1    13*     Added comment field in dcte.
  1    14*                                                   END HISTORY COMMENTS */
  1    15 
  1    16 
  1    17 /* format: style4 */
  1    18 
  1    19 dcl  dctp ptr;					/* ptr to device class table */
  1    20 dcl  1 dev_class_tab aligned based (dctp),		/* the device class table */
  1    21        2 n_classes fixed bin,				/* number of device classes */
  1    22        2 pad fixed bin,
  1    23        2 entries (1 refer (dev_class_tab.n_classes)) like dcte;
  1    24 
  1    25 dcl  dctep ptr;					/* device class table entry ptr */
  1    26 
  1    27 dcl  1 dcte aligned based (dctep),			/* device class table entry */
  1    28 
  1    29 /* following items are initialized before daemon is run */
  1    30 
  1    31        2 id char (32),				/* device class name for this entry */
  1    32        2 comment unaligned like text_offset,		/* comment to apply to the device class */
  1    33        2 qgte_index fixed bin,			/* index of queue group table entry */
  1    34        2 pad1 fixed bin,
  1    35        2 max_access bit (72),				/* max request access class */
  1    36        2 min_access bit (72),				/* min request access class */
  1    37        2 min_banner bit (72),				/* min access class to be placed on output banner */
  1    38        2 device_list bit (360),			/* bit _i ON => minor device _i is valid for device class */
  1    39 
  1    40 /* remaining info is dynamic */
  1    41 
  1    42        2 pending_request fixed bin (18),		/* descriptor offset for allocated but unassigned request */
  1    43        2 restart_req fixed bin (18),			/* offset of next (or last) descriptor to be restarted */
  1    44        2 pad2 (3) fixed bin,
  1    45        2 n_waiting fixed bin,				/* number of waiting requests for device class */
  1    46        2 per_queue_info (4),				/* one copy of this for each queue */
  1    47          3 first_waiting fixed bin,			/* index of first waiting list entry */
  1    48          3 last_waiting fixed bin;			/* index of last waiting list entry */
  1    49 
  1    50 
  1    51 /* END INCLUDE FILE...device_class.incl.pl1 */
      371 
      372  /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  2     7*     Ancient History
  2     8*     Created by J. Stern, 1/20/75
  2     9*     Modified by J. C. Whitmore April 1978 for enhancements
  2    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
  2    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
  2    12*     q_group_tab
  2    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  2    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  2    15*     Change version number to reflect changes in q_group_tab and
  2    16*     iod_device_tab for laser printer support.  Added font tables.
  2    17*                                                   END HISTORY COMMENTS */
  2    18 
  2    19 
  2    20 /* format: style4 */
  2    21 
  2    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
  2    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
  2    24        2 version char (8),				/* version of this structure */
  2    25        2 date_time_compiled fixed bin (71),
  2    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
  2    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
  2    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
  2    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
  2    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
  2    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
  2    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
  2    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
  2    34        2 text_strings_offset fixed bin (18),
  2    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
  2    36 
  2    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
  2    38 dcl  text_strings_ptr ptr;
  2    39 dcl  1 text_strings aligned based (text_strings_ptr),
  2    40        2 length fixed bin,
  2    41        2 chars char (1 refer (text_strings.length)) unaligned;
  2    42 
  2    43 /* this defines text offsets used to locate i/o daemon tables strings in
  2    44*   the text_strings structure */
  2    45 dcl  1 text_offset based,
  2    46        2 first_char fixed bin (18) unsigned unaligned,
  2    47        2 total_chars fixed bin (18) unsigned unaligned;
  2    48 
  2    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
  2    50 
  2    51 
  2    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
      372 
      373  /* BEGIN INCLUDE FILE...iodc_static.incl.pl1 */
  3     2 
  3     3 dcl stat_p ptr int static init(null);
  3     4 
  3     5 dcl 1 iodc_static aligned based(stat_p),
  3     6 	2 dctp ptr,		/* pointer to device class table */
  3     7 	2 qgtp ptr,		/* pointer to queue group table */
  3     8 	2 wait_list_ptr ptr,	/* pointer to waiting list segment */
  3     9 	2 req_seg_ptr ptr,		/* pointer to base of request segment */
  3    10 	2 descr_seg_ptr ptr,	/* pointer to base of request descriptor segment */
  3    11 	2 save_first_req_p ptr,	/* pointer to req_desc_seg.first_saved */
  3    12 	2 first_req_done fixed bin(18),	/* offset of first descriptor on "saved" list */
  3    13 	2 last_req_done fixed bin(18),	/* offset of last  descriptor on "saved" list */
  3    14 	2 time_interval fixed bin(71),	/* time interval to elapse between completion */
  3    15 					/* and deletion of request */
  3    16 	2 max_q fixed bin,			/* maximum number of priority queues */
  3    17 	2 timer_chan fixed bin(71);		/* event channel for timer wakeups */
  3    18 
  3    19 dcl req_area area(131096) based(iodc_static.req_seg_ptr);
  3    20 
  3    21 dcl 1 req_desc_seg aligned based (iodc_static.descr_seg_ptr),
  3    22 	2 first_saved fixed bin(18),		/* offset of head of saved list */
  3    23 	2 pad fixed bin,
  3    24 	2 descr_area area (65560);		/* area where request descriptors are allocated */
  3    25 
  3    26 /* END INCLUDE FILE...iodc_static.incl.pl1 */
      373 
      374  /* .....  BEGIN INCLUDE FILE  ...  iodc_wait_list.incl.pl1  ..... */
  4     2 
  4     3 dcl 1 waiting_list aligned based,			/* list of waiting requests already read from queues */
  4     4     2 first_free fixed bin,				/* index of first entry of free list */
  4     5     2 last_used fixed bin,				/* high-water mark, i.e. largest index of all used entries */
  4     6     2 pad (2) fixed bin,				/* pad to 4-word boundary */
  4     7     2 entries (max_wl_size),
  4     8       3 ms_id bit (72),				/* message id of waiting request */
  4     9       3 next fixed bin,				/* next free entry or next waiting entry */
  4    10       3 state fixed bin,				/* 0 = free, 1 = normal, 2 = priority */
  4    11       3 orig_q fixed bin,				/* queue a priority request is in */
  4    12       3 pad fixed bin;				/* pad to even-word boundary */
  4    13 
  4    14 dcl  max_wl_size fixed bin int static init (10000);	/* at most 10000 waiting list entries */
  4    15 
  4    16 
  4    17 /* .....  END INCLUDE FILE  ...  iodc_wait_list.incl.pl1  ... */
      374 
      375  /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  5     2 /* format: style3,idind30 */
  5     3 
  5     4 /* structure returned when message is read from a message segment */
  5     5 
  5     6 
  5     7 dcl	mseg_message_info_ptr	pointer;
  5     8 
  5     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  5    10 	  2 version		char (8) aligned,
  5    11 	  2 message_code		fixed bin,
  5    12 	  2 control_flags		unaligned,
  5    13 	    3 own			bit (1),
  5    14 	    3 delete		bit (1),
  5    15 	    3 pad			bit (34),
  5    16 	  2 ms_ptr		ptr,		/* pointer to message */
  5    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  5    18 	  2 ms_id			bit (72),		/* unique ID of message */
  5    19 						/* input in some cases */
  5    20 	  2 ms_access_class		bit (72),		/* message access class */
  5    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  5    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  5    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  5    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  5    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  5    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  5    27 
  5    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  5    29 
  5    30 declare	(
  5    31 	MSEG_READ_FIRST		init (1),
  5    32 	MSEG_READ_LAST		init (2),
  5    33 	MSEG_READ_SPECIFIED		init (3),
  5    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  5    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  5    36 	fixed bin int static options (constant);
  5    37 
  5    38 declare  (MSEG_READ_OWN		init ("1"b),
  5    39 	MSEG_READ_DELETE		init ("01"b)
  5    40 	)			bit (36) aligned internal static options (constant);
  5    41 
  5    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
      375 
      376  /* BEGIN INCLUDE FILE...q_group_tab.incl.pl1 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  6     7*     Ancient History
  6     8*     Created by J. Stern, December 1974
  6     9*     Modified by J. Whitmore April 1978
  6    10*     Modified by R. McDonald May 1980 to include page charges (UNCA)
  6    11*     Modified by E. N. Kittlitz June 1981 for UNCA changes
  6    12*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  6    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  6    14*     Add forms_validation, default_form and font_dir variables for laser
  6    15*     printer support.
  6    16*                                                   END HISTORY COMMENTS */
  6    17 
  6    18 
  6    19 /* format: style4 */
  6    20 
  6    21 dcl  qgtp ptr;					/* ptr to queue group table */
  6    22 dcl  1 q_group_tab aligned based (qgtp),
  6    23        2 n_q_groups fixed bin,			/* number of queue groups */
  6    24        2 pad fixed bin,
  6    25        2 entries (1 refer (q_group_tab.n_q_groups)) like qgte; /* entries of queue group table */
  6    26 
  6    27 dcl  qgtep ptr;					/* queue group table entry pointer */
  6    28 dcl  1 qgte aligned based (qgtep),			/* queue group table entry */
  6    29 
  6    30 /* static info from the parms file */
  6    31 
  6    32        2 name char (24),				/* queue group name */
  6    33        2 comment unaligned like text_offset,		/* comment to apply to the request_type */
  6    34        2 driver_id char (32),				/* person.project name of drivers for this q group */
  6    35        2 accounting unaligned like text_offset,		/* offset to accounting routine pathname, "system" => charge_user_ */
  6    36        2 generic_type char (32),			/* generic type of requests in this queue */
  6    37        2 default_generic_queue fixed bin (1),		/* 1 if this is default queue for above generic type, else 0 */
  6    38        2 rqti_seg_name char (32),			/* name of rqti seg, if required, else blank */
  6    39        2 max_queues fixed bin,			/* number of queues for this request type */
  6    40        2 default_queue fixed bin,			/* number of the default queue */
  6    41        2 line_charge,				/* price names for line charges */
  6    42          3 queue (4) char (32),			/* one name for each queue */
  6    43        2 page_charge,				/* price names for page charges */
  6    44          3 queue (4) char (32),			/* one name for each queue */
  6    45        2 forms_table unaligned like text_offset,		/* offset to forms table to apply to this queue group */
  6    46        2 forms_validation unaligned like text_offset,	/* offset to name of routine for forms validation */
  6    47        2 default_form unaligned like text_offset,		/* offset to default -form string if none given */
  6    48        2 font_dir unaligned like text_offset,		/* offset to location of downloadable fonts */
  6    49        2 first_dev_class fixed bin,			/* index of first device class entry of queue group */
  6    50        2 last_dev_class fixed bin,			/* index of last device class entry of queue group */
  6    51 
  6    52 /* dynamic info reflecting current status of queues */
  6    53 
  6    54        2 open fixed bin,				/* 1 if queues have been opened, else 0 */
  6    55        2 per_queue_info (4),
  6    56          3 last_read bit (72),			/* ID of last message read */
  6    57          3 mseg_index fixed bin,			/* message segment index */
  6    58          3 pad fixed bin;				/* pad to even word boundary */
  6    59 
  6    60 /* END INCLUDE FILE...q_group_tab.incl.pl1 */
      376 
      377  /* BEGIN INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
  7     2 
  7     3 /* This is the message header used for standard system queue messages, namely:
  7     4*   IO daemon requests, absentee requests, retrieval requests.
  7     5**/
  7     6 
  7     7 /* Written by Jerry Whitmore, Spring 1978.
  7     8*   Modified by T. Casey, November 1978, to add values for state.
  7     9*   Modified by R. Kovalcik, June 1982, defer_until_process_terminataion
  7    10**/
  7    11 
  7    12 dcl 1 queue_msg_hdr based aligned,			/* standard header for all system queue messages */
  7    13     2 msg_time fixed bin (71),			/* date and time of request */
  7    14     2 hdr_version fixed bin,				/* version of this declaration */
  7    15     2 dirname char (168),				/* directory name */
  7    16     2 ename char (32),				/* entry name of file requested */
  7    17     2 message_type fixed bin,				/* message format descriptor   */
  7    18 						/* 0 = absentee request        */
  7    19 						/* 1 = print request           */
  7    20 						/* 2 = punch request           */
  7    21 						/* 3 = tape request            */
  7    22 						/* 4 = retrieval request       */
  7    23     2 bit_flags,
  7    24       3 delete_sw bit (1) unal,			/* delete file when done */
  7    25       3 notify bit (1) unal,				/* user wants to be notified */
  7    26       3 defer_until_process_termination bit (1) unal,	/* don't process request until process terminates */
  7    27       3 padding bit (33) unal,
  7    28     2 state fixed bin,				/* stage of processing after being queued:
  7    29*						   0 = initial unprocessed state, 1 = deferred,
  7    30*						   2 = in state transition, 3 = eligible, 4 = running,
  7    31*                                                               5 = bumped, 6 = deferred_until_process_termination */
  7    32     2 orig_queue fixed bin,				/* queue the request was submitted to */
  7    33     2 std_length fixed bin,				/* length of std msg for this type */
  7    34     2 dupt_lock bit (36) aligned,			/* lock word for defer until process termination */
  7    35     2 hdr_pad (3) fixed bin;
  7    36 
  7    37 dcl  queue_msg_hdr_version_1 fixed bin int static options (constant) init (1); /* current version of the header */
  7    38 
  7    39 /* Values for queue_msg_hdr.state */
  7    40 
  7    41 dcl  STATE_UNPROCESSED fixed bin int static options (constant) init (0);
  7    42 dcl  STATE_DEFERRED fixed bin int static options (constant) init (1);
  7    43 dcl  STATE_TRANSITION fixed bin int static options (constant) init (2);
  7    44 dcl  STATE_ELIGIBLE fixed bin int static options (constant) init (3);
  7    45 dcl  STATE_RUNNING fixed bin int static options (constant) init (4);
  7    46 dcl  STATE_BUMPED fixed bin int static options (constant) init (5);
  7    47 dcl  STATE_DUPT fixed bin int static options (constant) init (6);
  7    48 
  7    49 /* END INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
      377 
      378  /* BEGIN INCLUDE FILE...request_descriptor.incl.pl1 */
  8     2 
  8     3 /* Descriptor associated with an I/O daemon request */
  8     4 /* Coded August 1973 by Robert S. Coren */
  8     5 /* Modified by J. C. Whitmore, 5/78, to extend driver_data to 7 words */
  8     6 /* Modified by C. Marker, 2/23/85, changed to use mseg_message_info */
  8     7 
  8     8 dcl  1 request_descriptor based aligned,
  8     9 	2 mseg_message_info_copy like mseg_message_info,
  8    10 	2 seq_id fixed bin(35),	/* sequential number assigned by coordinator */
  8    11 	2 q fixed bin,		/* priority queue in which request was submitted */
  8    12 	2 contd_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of continued request */
  8    13 	2 prev_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of restarted request */
  8    14 	2 dev_class_index fixed bin,	/* index of device_class entry */
  8    15 	2 spare_fb fixed bin (17) unal, /* save half a word for later */
  8    16 	2 charge_q fixed bin (17) unal, /* priority to use for charging */
  8    17 	2 time_done fixed bin(71),	/* clock time when request was completed */
  8    18 	2 prev_done fixed bin(18),	/* descriptor threaded ahead of this one in saved list */
  8    19 	2 next_done fixed bin(18),	/*      "        "     behind    "        "       "      */
  8    20 	2 driver_data bit(252),	/* driver maintained data */
  8    21 	2 flags,
  8    22 	   (3 continued,		/* unfinished by one driver and given to another */
  8    23 	    3 finished,
  8    24 	    3 restarted,
  8    25 	    3 cancelled,
  8    26 	    3 dont_delete,
  8    27 	    3 saved,		/* not to be freed */
  8    28 	    3 keep_in_queue,	/* keep request in queue */
  8    29 	    3 series_restart,	/* this request is part of restarted series */
  8    30 	    3 priority_request) bit (1) unal, /* this request was given extra priority */
  8    31 	    3 pad bit(27) unal,
  8    32 	2 next_pending fixed bin(18);	/* thread to next pending descriptor */
  8    33 
  8    34 /* END INCLUDE FILE...request_descriptor.incl.pl1 */
      378 
      379 
      380      end find_next_request_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/28/88  1234.0  find_next_request_.pl1            >special_ldd>install>MR12.2-1199>find_next_request_.pl1
371          1    10/28/88  1227.7  device_class.incl.pl1             >special_ldd>install>MR12.2-1199>device_class.incl.pl1
372          2    10/28/88  1227.4  iod_tables_hdr.incl.pl1           >special_ldd>install>MR12.2-1199>iod_tables_hdr.incl.pl1
373          3    09/28/78  1359.8  iodc_static.incl.pl1              >ldd>include>iodc_static.incl.pl1
374          4    09/28/78  1359.8  iodc_wait_list.incl.pl1           >ldd>include>iodc_wait_list.incl.pl1
375          5    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
376          6    10/28/88  1227.2  q_group_tab.incl.pl1              >special_ldd>install>MR12.2-1199>q_group_tab.incl.pl1
377          7    08/31/82  1636.3  queue_msg_hdr.incl.pl1            >ldd>include>queue_msg_hdr.incl.pl1
378          8    03/15/85  0953.1  request_descriptor.incl.pl1       >ldd>include>request_descriptor.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
MSEG_MESSAGE_INFO_V1            000000 constant        char(8)                  initial dcl 5-28 ref 163
MSEG_READ_AFTER_SPECIFIED              constant        fixed bin(17,0)          initial dcl 5-30 ref 169
MSEG_READ_FIRST                        constant        fixed bin(17,0)          initial dcl 5-30 ref 166
MSEG_READ_SPECIFIED                    constant        fixed bin(17,0)          initial dcl 5-30 ref 168
STATE_DEFERRED                         constant        fixed bin(17,0)          initial dcl 7-42 set ref 285*
STATE_DUPT                             constant        fixed bin(17,0)          initial dcl 7-47 set ref 284*
STATE_RUNNING                          constant        fixed bin(17,0)          initial dcl 7-45 set ref 183* 201*
a_ptr                                  parameter       pointer                  dcl 353 ref 351 355
addr                                                   builtin function         dcl 84 ref 88 89 197 362
aim_check_$greater_or_equal     000016 constant        entry                    external dcl 64 ref 198 198
auth                            000202 automatic       bit(72)                  dcl 57 set ref 195* 198* 198* 215*
auth_string                     000204 automatic       char(170)                packed unaligned dcl 58 set ref 214* 215* 216*
bad                             000305 automatic       fixed bin(17,0)          dcl 125 set ref 160* 231 234*
based_message                          based           bit                      dcl 60 ref 220
bit_flags                66            based           structure                level 2 dcl 7-12
charge_q                 37(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 8-8 set ref 97*
code                            000100 automatic       fixed bin(35,0)          dcl 43 in procedure "find_next_request_" set ref
                                                                                  171* 172 176* 177 177 178* 183* 184 201* 202 215*
                                                                                  225 231 237* 241 254*
code                                   parameter       fixed bin(35,0)          dcl 329 in procedure "mark_request" set ref 326 340*
                                                                                  341 341
convert_authorization_$to_string_short
                                000014 constant        entry                    external dcl 63 ref 215
dc_ptr                                 parameter       pointer                  dcl 267 ref 264 279 279 281 282 283 283
dcp                             000172 automatic       pointer                  dcl 50 set ref 197* 198 198 207*
dcte                                   based           structure                level 1 dcl 1-27
dctep                           000264 automatic       pointer                  dcl 1-25 set ref 88* 89 130 131 134 140 140 143 144
                                                                                  144 145 188* 362* 363 365 365
dctp                                   based           pointer                  level 2 dcl 3-5 ref 88 197 361 362
dcx                             000177 automatic       fixed bin(17,0)          dcl 55 set ref 87* 88 98 198 361* 362*
defer_until_process_termination
                         66(02)        based           bit(1)                   level 3 packed packed unaligned dcl 7-12 ref 175
descr_ptr                              parameter       pointer                  dcl 41 ref 12 90
dev_class_index          36            based           fixed bin(17,0)          level 2 in structure "request_descriptor" dcl 8-8
                                                                                  in procedure "find_next_request_" set ref 98*
dev_class_index                        parameter       fixed bin(17,0)          dcl 40 in procedure "find_next_request_" ref 12 87
dev_class_tab                          based           structure                level 1 dcl 1-20
direction                       000304 automatic       bit(2)                   dcl 124 set ref 147* 154* 168 169 181 225
dupt                            000307 automatic       bit(1)                   dcl 126 set ref 174* 177* 182 188* 198 207*
dupt_flag                              parameter       bit(1)                   dcl 266 ref 264 284
dupt_lock                72            based           bit(36)                  level 2 dcl 7-12 set ref 176* 178*
entries                   2            based           structure                array level 2 in structure "q_group_tab" dcl 6-22
                                                                                  in procedure "find_next_request_" set ref 89
entries                   2            based           structure                array level 2 in structure "dev_class_tab" dcl 1-20
                                                                                  in procedure "find_next_request_" set ref 88 197
                                                                                  362
entries                   4            based           structure                array level 2 in structure "waiting_list" dcl 4-3
                                                                                  in procedure "find_next_request_"
err_len                         000101 automatic       fixed bin(17,0)          dcl 44 set ref 216* 235* 252* 271*
err_mess                        000102 automatic       char(200)                packed unaligned dcl 45 set ref 216* 218* 235* 237*
                                                                                  252* 254* 271* 273*
error_table_$bad_segment        000036 external static fixed bin(35,0)          dcl 79 ref 231 341
error_table_$invalid_lock_reset 000040 external static fixed bin(35,0)          dcl 80 ref 177
error_table_$no_message         000042 external static fixed bin(35,0)          dcl 81 ref 225
error_table_$notalloc           000044 external static fixed bin(35,0)          dcl 82 ref 241
first_dev_class         147            based           fixed bin(17,0)          level 2 dcl 6-28 ref 196
first_free                             based           fixed bin(17,0)          level 2 dcl 4-3 set ref 293 295* 317 318* 358*
first_waiting            41            based           fixed bin(17,0)          array level 3 dcl 1-27 set ref 130 134 140* 143* 145
                                                                                  281* 365*
flags                    53            based           structure                level 2 dcl 8-8
found                           000164 automatic       bit(1)                   dcl 46 set ref 95 129* 185* 203*
free_oldest_request_$force      000020 constant        entry                    external dcl 65 ref 245
i                               000200 automatic       fixed bin(17,0)          dcl 56 set ref 196* 197 198*
ioa_$rsnnl                      000022 constant        entry                    external dcl 66 ref 216 235 252 271
iodc_message_                   000024 constant        entry                    external dcl 67 ref 218 237 254 273
iodc_static                            based           structure                level 1 dcl 3-5
last_dev_class          150            based           fixed bin(17,0)          level 2 dcl 6-28 ref 196
last_id                         000170 automatic       bit(72)                  dcl 49 set ref 135* 152* 164 166
last_read               152            based           bit(72)                  array level 3 dcl 6-28 set ref 152 194*
last_used                 1            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 298 299 299* 312 313* 313
                                                                                  358*
last_waiting             42            based           fixed bin(17,0)          array level 3 dcl 1-27 set ref 131 140* 279 279 282*
                                                                                  365*
max_access               13            based           bit(72)                  level 2 dcl 1-27 set ref 198*
max_queues               41            based           fixed bin(17,0)          level 2 dcl 6-28 ref 92
max_wl_size                            constant        fixed bin(17,0)          initial dcl 4-14 ref 298
message_code              2            based           fixed bin(17,0)          level 2 dcl 5-9 set ref 166* 168* 169*
message_len                     000257 automatic       fixed bin(18,0)          dcl 59 set ref 219* 220 220
message_segment_$read_message_index
                                000026 constant        entry                    external dcl 68 ref 171
message_segment_$update_message_index
                                000030 constant        entry                    external dcl 69 ref 340
min_access               15            based           bit(72)                  level 2 dcl 1-27 set ref 198*
ms_id                     4            based           bit(72)                  array level 3 in structure "waiting_list" dcl 4-3
                                                                                  in procedure "find_next_request_" set ref 135 276*
                                                                                  304* 321*
ms_id                     7            based           bit(72)                  level 2 in structure "mseg_message_info" dcl 5-9
                                                                                  in procedure "find_next_request_" set ref 164* 194
                                                                                  276 337
ms_len                    6            based           fixed bin(24,0)          level 2 dcl 5-9 set ref 219 338
ms_ptr                    4            based           pointer                  level 2 dcl 5-9 set ref 175 176 178 220 335
mseg_index              154            based           fixed bin(17,0)          array level 3 dcl 6-28 set ref 157 255*
mseg_message_info                      based           structure                level 1 dcl 5-9 set ref 162*
mseg_message_info_ptr           000266 automatic       pointer                  dcl 5-7 set ref 90* 162 163 164 166 168 169 171* 175
                                                                                  176 178 194 195 219 220 276 335 337 338
msg_id                          000344 automatic       bit(72)                  dcl 331 set ref 337* 340*
msg_len                         000346 automatic       fixed bin(18,0)          dcl 332 set ref 338* 340*
msg_p                           000342 automatic       pointer                  dcl 330 set ref 335* 336 340*
n_classes                              based           fixed bin(17,0)          level 2 dcl 1-20 ref 361
n_waiting                40            based           fixed bin(17,0)          level 2 dcl 1-27 set ref 144* 144 283* 283 363*
name                                   based           char(24)                 level 2 dcl 6-28 set ref 216* 235* 252* 271*
new_state                              parameter       fixed bin(17,0)          dcl 328 ref 326 336
next                      6            based           fixed bin(17,0)          array level 3 dcl 4-3 set ref 140 143 279* 295 296*
                                                                                  302* 314* 317*
next_msg                               constant        bit(2)                   initial packed unaligned dcl 74 ref 154 169
normal                                 constant        fixed bin(17,0)          initial dcl 76 ref 277
orig_q                   10            based           fixed bin(17,0)          array level 3 dcl 4-3 set ref 139 278* 303*
per_queue_info           41            based           structure                array level 2 in structure "dcte" dcl 1-27
                                                                                  in procedure "find_next_request_"
per_queue_info          152            based           structure                array level 2 in structure "qgte" dcl 6-28
                                                                                  in procedure "find_next_request_"
priority                               constant        fixed bin(17,0)          initial dcl 75 ref 136
priority_request         53(08)        based           bit(1)                   level 3 packed packed unaligned dcl 8-8 set ref 136*
                                                                                  138* 153*
q                        33            based           fixed bin(17,0)          level 2 in structure "request_descriptor" dcl 8-8
                                                                                  in procedure "find_next_request_" set ref 96*
q                               000166 automatic       fixed bin(17,0)          dcl 47 in procedure "find_next_request_" set ref 96
                                                                                  139* 151* 152 157 194 235* 252* 255 271* 278 279
                                                                                  279 281 282 364* 365 365*
q_group_tab                            based           structure                level 1 dcl 6-22
q_idx                           000176 automatic       fixed bin(17,0)          dcl 52 set ref 157* 158 171* 340*
qgte                                   based           structure                level 1 dcl 6-28
qgte_index               11            based           fixed bin(17,0)          level 2 dcl 1-27 ref 89
qgtep                           000270 automatic       pointer                  dcl 6-27 set ref 89* 92 152 157 194 196 196 216 235
                                                                                  252 255 271
qgtp                      2            based           pointer                  level 2 dcl 3-5 ref 89
queue                           000165 automatic       fixed bin(17,0)          dcl 47 set ref 92* 97* 130 131 134 140 140 143 145
                                                                                  151
queue_msg_hdr                          based           structure                level 1 dcl 7-12
re_read                                constant        bit(2)                   initial packed unaligned dcl 73 ref 147 168 181 225
req_area                               based           area(131096)             dcl 3-19 ref 220
req_seg_ptr               6            based           pointer                  level 2 dcl 3-5 set ref 171* 220
request_descriptor                     based           structure                level 1 dcl 8-8
retp                            000174 automatic       pointer                  dcl 51 set ref 90* 96 97 98 136 138 153
retry                           000347 automatic       fixed bin(17,0)          dcl 333 set ref 339* 341 344*
scan_wait                       000310 automatic       bit(1)                   dcl 127 set ref 130* 133 145*
sender_authorization     25            based           bit(72)                  level 2 dcl 5-9 set ref 195
set_lock_$lock                  000032 constant        entry                    external dcl 70 ref 176
set_lock_$unlock                000034 constant        entry                    external dcl 71 ref 178
space                           000306 automatic       fixed bin(17,0)          dcl 125 set ref 160* 241 244*
stat_p                          000012 internal static pointer                  initial dcl 3-3 set ref 88 89 171 197 220 355* 357
                                                                                  361 362
state                     7            based           fixed bin(17,0)          array level 3 in structure "waiting_list" dcl 4-3
                                                                                  in procedure "find_next_request_" set ref 136 277*
                                                                                  301* 320*
state                    67            based           fixed bin(17,0)          level 2 in structure "queue_msg_hdr" dcl 7-12
                                                                                  in procedure "find_next_request_" set ref 336*
text_offset                            based           structure                level 1 packed packed unaligned dcl 2-45
unspec                                                 builtin function         dcl 84 set ref 162*
unused                                 constant        fixed bin(17,0)          initial dcl 77 ref 301 320
version                                based           char(8)                  level 2 dcl 5-9 set ref 163*
wait_list_ptr             4            based           pointer                  level 2 dcl 3-5 ref 357
waiting_list                           based           structure                level 1 dcl 4-3
wlp                             000010 internal static pointer                  dcl 54 set ref 135 136 139 140 143 276 277 278 279
                                                                                  293 295 295 296 298 299 299 301 302 303 304 312
                                                                                  313 313 314 317 317 318 320 321 357* 358 358
x                               000260 automatic       fixed bin(17,0)          dcl 61 set ref 134* 135 136 139 140 143 145 312 314
                                                                                  317 318 320 321
y                               000261 automatic       fixed bin(17,0)          dcl 61 set ref 270 276 277 278 279 281 282 293* 294
                                                                                  295 296 298* 299* 300 301 302 303 304
z                               000262 automatic       fixed bin(17,0)          dcl 61 set ref 131* 145

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
IODT_VERSION_5                         internal static char(8)                  initial packed unaligned dcl 2-49
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 5-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 5-38
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 5-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 5-38
STATE_BUMPED                           internal static fixed bin(17,0)          initial dcl 7-46
STATE_ELIGIBLE                         internal static fixed bin(17,0)          initial dcl 7-44
STATE_TRANSITION                       internal static fixed bin(17,0)          initial dcl 7-43
STATE_UNPROCESSED                      internal static fixed bin(17,0)          initial dcl 7-41
dctp                                   automatic       pointer                  dcl 1-19
iod_tables_hdr                         based           structure                level 1 dcl 2-23
ithp                                   automatic       pointer                  dcl 2-22
qgtp                                   automatic       pointer                  dcl 6-21
queue_msg_hdr_version_1                internal static fixed bin(17,0)          initial dcl 7-37
req_desc_seg                           based           structure                level 1 dcl 3-21
text_strings                           based           structure                level 1 dcl 2-39
text_strings_ptr                       automatic       pointer                  dcl 2-38

NAMES DECLARED BY EXPLICIT CONTEXT.
add_wle                         001204 constant        entry                    internal dcl 264 ref 188 207
allocate_wle                    001347 constant        entry                    internal dcl 291 ref 269
find_next_request_              000124 constant        entry                    external dcl 12
flush                           001003 constant        label                    dcl 219 set ref 189 208
free_wle                        001410 constant        entry                    internal dcl 310 ref 146
init                            000227 constant        entry                    external dcl 351
mark_request                    001443 constant        entry                    internal dcl 326 ref 183 201 284 285
next                            000322 constant        label                    dcl 133 ref 184 202 221 225
read_one                        000307 constant        entry                    internal dcl 108 ref 94
retry                           000441 constant        label                    dcl 166 ref 238 246
update                          001461 constant        label                    dcl 340 ref 345

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1772        2040    1555        2002
Length      2442    1555        46         366     215           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
find_next_request_                  352 external procedure  is an external procedure.  
read_one                                internal procedure  shares stack frame of external procedure find_next_request_.  
add_wle                                 internal procedure  shares stack frame of external procedure find_next_request_.  
allocate_wle                            internal procedure  shares stack frame of external procedure find_next_request_.  
free_wle                                internal procedure  shares stack frame of external procedure find_next_request_.  
mark_request                            internal procedure  shares stack frame of external procedure find_next_request_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 wlp                         find_next_request_
000012 stat_p                      find_next_request_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
find_next_request_       000100 code                        find_next_request_
                         000101 err_len                     find_next_request_
                         000102 err_mess                    find_next_request_
                         000164 found                       find_next_request_
                         000165 queue                       find_next_request_
                         000166 q                           find_next_request_
                         000170 last_id                     find_next_request_
                         000172 dcp                         find_next_request_
                         000174 retp                        find_next_request_
                         000176 q_idx                       find_next_request_
                         000177 dcx                         find_next_request_
                         000200 i                           find_next_request_
                         000202 auth                        find_next_request_
                         000204 auth_string                 find_next_request_
                         000257 message_len                 find_next_request_
                         000260 x                           find_next_request_
                         000261 y                           find_next_request_
                         000262 z                           find_next_request_
                         000264 dctep                       find_next_request_
                         000266 mseg_message_info_ptr       find_next_request_
                         000270 qgtep                       find_next_request_
                         000304 direction                   read_one
                         000305 bad                         read_one
                         000306 space                       read_one
                         000307 dupt                        read_one
                         000310 scan_wait                   read_one
                         000342 msg_p                       mark_request
                         000344 msg_id                      mark_request
                         000346 msg_len                     mark_request
                         000347 retry                       mark_request

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   call_ext_out        return_mac          signal_op           ext_entry
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
aim_check_$greater_or_equal   convert_authorization_$to_string_short                      free_oldest_request_$force
ioa_$rsnnl                    iodc_message_                 message_segment_$read_message_index
message_segment_$update_message_index                       set_lock_$lock                set_lock_$unlock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_segment      error_table_$invalid_lock_reset                             error_table_$no_message
error_table_$notalloc




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000120        87 000133        88 000136        89 000143        90 000151        92 000155        94 000165
     95 000166        96 000170        97 000173        98 000175        99 000177       101 000211       105 000213
    351 000224       355 000235       357 000242       358 000244       361 000246       362 000255       363 000263
    364 000264       365 000271       367 000275       368 000277       370 000301       108 000307       129 000310
    130 000311       131 000320       133 000322       134 000324       135 000332       136 000341       138 000351
    139 000354       140 000356       143 000364       144 000366       145 000370       146 000376       147 000377
    148 000400       151 000401       152 000403       153 000410       154 000413       157 000415       158 000422
    160 000424       162 000426       163 000432       164 000436       166 000441       168 000447       169 000455
    171 000462       172 000500       174 000502       175 000503       176 000510       177 000525       178 000535
    181 000550       182 000552       183 000555       184 000557       185 000561       186 000563       188 000564
    189 000566       191 000567       194 000570       195 000601       196 000604       197 000613       198 000621
    201 000663       202 000665       203 000667       204 000671       207 000672       208 000674       210 000675
    214 000677       215 000702       216 000723       218 000757       219 001003       220 001006       221 001012
    224 001013       225 001014       228 001021       231 001022       234 001026       235 001030       237 001062
    238 001105       241 001106       244 001113       245 001115       246 001121       252 001122       254 001154
    255 001177       259 001203       264 001204       269 001206       270 001207       271 001211       273 001244
    274 001270       276 001271       277 001302       278 001304       279 001306       281 001323       282 001326
    283 001333       284 001334       285 001343       288 001346       291 001347       293 001350       294 001353
    295 001354       296 001360       297 001361       298 001362       299 001370       300 001373       301 001375
    302 001402       303 001403       304 001404       307 001407       310 001410       312 001411       313 001416
    314 001420       315 001423       317 001424       318 001430       320 001432       321 001437       323 001442
    326 001443       335 001445       336 001450       337 001452       338 001456       339 001460       340 001461
    341 001501       344 001511       345 001513       348 001514


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
